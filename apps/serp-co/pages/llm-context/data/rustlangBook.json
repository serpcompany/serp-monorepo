[
  {
    "owner": "rust-lang",
    "repo": "book",
    "content": "TITLE: Defining the Option Enum in Rust\nDESCRIPTION: This code snippet shows the definition of the `Option` enum in Rust's standard library. It has two variants: `None`, which represents the absence of a value, and `Some(T)`, which represents the presence of a value of type `T`. This enum is used for handling cases where a value might be missing.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nenum Option<T> {\n    None,\n    Some(T),\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a Random Number with rand Crate in Rust\nDESCRIPTION: This Rust snippet demonstrates how to generate a random number between 1 and 100 (inclusive) using the `rand` crate.  It first imports the `Rng` trait, then obtains a thread-local random number generator, and finally calls `gen_range` to generate the random number within the specified range. The secret number is then printed to the console.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-03/src/main.rs:all}}\n```\n\n----------------------------------------\n\nTITLE: Declaring Constants in Rust\nDESCRIPTION: This code snippet demonstrates how to declare a constant in Rust using the `const` keyword. Constants must have their type annotated and can only be set to a constant expression. Rust's naming convention for constants is to use all uppercase with underscores between words.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-01-variables-and-mutability.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nconst THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;\n```\n\n----------------------------------------\n\nTITLE: Enum and Match Expression for Coin Values in Rust\nDESCRIPTION: This code defines an enum `Coin` with variants for different US coins and a function `value_in_cents` that uses a `match` expression to return the value of each coin in cents. The `match` expression compares the input `coin` value against each variant of the `Coin` enum.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter => 25,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Summary Trait on NewsArticle and SocialPost\nDESCRIPTION: This code implements the `Summary` trait for the `NewsArticle` and `SocialPost` structs.  The `summarize` method is implemented differently for each type, providing a custom summary string based on the struct's fields. This demonstrates how a trait can be implemented to provide different behaviors for different types.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-02-traits.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct NewsArticle {\n    pub headline: String,\n    pub location: String,\n    pub author: String,\n    pub content: String,\n}\n\nimpl Summary for NewsArticle {\n    fn summarize(&self) -> String {\n        format!(\"{}, by {} ({})\", self.headline, self.author, self.location)\n    }\n}\n\nstruct SocialPost {\n    pub username: String,\n    pub content: String,\n    pub reply: bool,\n    pub repost: bool,\n}\n\nimpl Summary for SocialPost {\n    fn summarize(&self) -> String {\n        format!(\"{} of course, as you probably already know, people\", self.username)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating a Value Based on the Old Value\nDESCRIPTION: This code counts the occurrences of each word in a text using a hash map. It utilizes the `entry` API and the `or_insert` method to either insert a new word with a count of 0 or increment the existing count for the word.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-03-hash-maps.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::HashMap;\n\nfn main() {\n    let text = \"hello world wonderful world\";\n\n    let mut map = HashMap::new();\n\n    for word in text.split_whitespace() {\n        let count = map.entry(word).or_insert(0);\n        *count += 1;\n    }\n\n    println!(\"{:?}\", map);\n}\n```\n\n----------------------------------------\n\nTITLE: Error Propagation with Method Chaining and ? in Rust\nDESCRIPTION: This code snippet demonstrates chaining method calls after the `?` operator for more concise error handling.  It combines file opening and reading into a single line using the `?` operator for error propagation, making the code more readable and efficient.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch09-02-recoverable-errors-with-result.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs::File;\nuse std::io;\nuse std::io::Read;\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    let mut username = String::new();\n    File::open(\"hello.txt\")?.read_to_string(&mut username)?;\n    Ok(username)\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Vector Elements via Indexing and get Method in Rust\nDESCRIPTION: This code snippet illustrates two ways to access elements in a vector: using indexing (`[]`) and using the `get` method. Indexing returns a reference, while `get` returns an `Option<&T>`, which must be handled to account for out-of-bounds access.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-01-vectors.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let v = vec![1, 2, 3, 4, 5];\n\n    let third: &i32 = &v[2];\n    println!(\"The third element is {}\", third);\n\n    let third: Option<&i32> = v.get(2);\n    match third {\n        Some(third) => println!(\"The third element is {}\", third),\n        None => println!(\"There is no third element.\"),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Character Ranges in Rust\nDESCRIPTION: This code snippet shows how to use ranges with `char` values in a `match` expression. It checks if a character falls within a specified range and executes the corresponding arm.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 'c';\n\nmatch x {\n    'a'..='j' => println!(\"early ASCII letter\"),\n    'k'..='z' => println!(\"late ASCII letter\"),\n    _ => println!(\"something else\"),\n}\n```\n\n----------------------------------------\n\nTITLE: Worker Thread Loop with Shutdown - Rust\nDESCRIPTION: This code snippet demonstrates how to modify the worker thread's loop to gracefully exit when the channel is closed. It uses a `match` statement on the result of `recv()` to differentiate between receiving a job and encountering an error (channel closed). On error, the thread prints a message and breaks out of the loop, allowing it to be joined by the `ThreadPool`'s `drop` implementation.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_29\n\nLANGUAGE: Rust\nCODE:\n```\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        let thread = thread::spawn(move || loop {\n            let message = receiver.lock().unwrap().recv();\n\n            match message {\n                Ok(job) => {\n                    println!(\"Worker {id} got a job; executing.\");\n\n                    job();\n                }\n                Err(_) => {\n                    println!(\"Worker {id} disconnected; shutting down.\");\n                    break;\n                }\n            }\n        });\n\n        Worker { id, thread }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Finding the First Word Using String Slices\nDESCRIPTION: This Rust code snippet shows how to find the first word in a string using string slices. The function takes a reference to a String and returns a string slice representing the first word. It iterates through the string, finds the first space, and returns a slice of the string up to that space. This eliminates the data race issues of previous versions by using slices.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-03-slices.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-18-first-word-slice/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Rectangle Struct and can_hold Method in Rust\nDESCRIPTION: This code defines a `Rectangle` struct with `width` and `height` fields, and a `can_hold` method that checks if one rectangle can contain another based on their dimensions. This struct and method are used for demonstrating testing with assertions.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-01-writing-tests.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-05/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Match Expression with Block and println! Macro in Rust\nDESCRIPTION: This example shows a `match` expression with a block of code for one of the arms. When the `coin` is `Coin::Penny`, it prints \"Lucky penny!\" and then returns 1.  The other arms return the cent value directly.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => {\n            println!(\"Lucky penny!\");\n            1\n        }\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter => 25,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Introducing a Bug in add_two Function in Rust\nDESCRIPTION: This code introduces a bug into the `add_two` function by adding 3 instead of 2. This demonstrates how the `assert_eq!` macro can detect errors and output valuable debugging information for fixing the bugs.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-01-writing-tests.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-04-bug-in-add-two/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Implementing Method `x` on `Point<T>` Struct in Rust\nDESCRIPTION: This code implements a method named `x` on the `Point<T>` struct. The method returns a reference to the `x` field, which is of type `T`. The `impl<T> Point<T>` syntax is crucial for specifying that the implementation applies to the generic `Point<T>` struct. This allows the method to be called on any instance of `Point` regardless of the concrete type substituted for `T`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-01-syntax.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Point<T> {\n    fn x(&self) -> &T {\n        &self.x\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enum with Associated Data in Rust\nDESCRIPTION: This code defines an enum called `IpAddr` with associated data for each variant.  `V4` and `V6` variants now directly hold a `String` representing the IP address. This eliminates the need for a separate struct.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-01-defining-an-enum.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nenum IpAddr {\n    V4(String),\n    V6(String),\n}\n```\n\n----------------------------------------\n\nTITLE: Using `move` Keyword to Transfer Ownership\nDESCRIPTION: This code snippet demonstrates how to use the `move` keyword to force a closure to take ownership of the values it uses, effectively transferring ownership of the vector `v` from the main thread to the spawned thread. This resolves the compile error from the previous example by ensuring that the spawned thread has ownership of the data it needs, guaranteeing its validity throughout the thread's execution.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch16-01-threads.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-05/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: If Expression: Type Mismatch Error in Rust\nDESCRIPTION: This code snippet illustrates a type mismatch error when using an `if` expression in a `let` statement.  The `if` arm evaluates to an integer (`5`), while the `else` arm evaluates to a string (`\"six\"`). Because variables in Rust must have a single, known type at compile time, this code will result in a compilation error.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-05-control-flow.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let condition = true;\n\n    let number = if condition {\n        5\n    } else {\n        \"six\"\n    };\n\n    println!(\"The value of number is: {}\", number);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Result Enum in Rust\nDESCRIPTION: This code snippet shows the definition of the `Result` enum, which is used to represent the outcome of an operation that can either succeed (`Ok`) or fail (`Err`). `T` represents the success type and `E` represents the error type.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch09-02-recoverable-errors-with-result.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\n----------------------------------------\n\nTITLE: Error Propagation with ? Operator in Rust\nDESCRIPTION: This code snippet uses the `?` operator to simplify error propagation. The `?` operator automatically returns the error from the function if the `Result` is an `Err`. If the `Result` is an `Ok`, it unwraps the value and continues execution. This eliminates the need for explicit `match` expressions.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch09-02-recoverable-errors-with-result.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs::File;\nuse std::io;\nuse std::io::Read;\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    let mut username_file = File::open(\"hello.txt\")?;\n    let mut username = String::new();\n    username_file.read_to_string(&mut username)?;\n    Ok(username)\n}\n```\n\n----------------------------------------\n\nTITLE: Using Items from the Standard Library with `use` in Rust\nDESCRIPTION: This example demonstrates how to bring the `HashMap` struct from the standard library into scope using the `use` keyword. The standard library doesn't need to be explicitly added as a dependency, but items within it must be brought into scope with `use`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::HashMap;\n```\n\n----------------------------------------\n\nTITLE: Creating a String Slice\nDESCRIPTION: This Rust code snippet demonstrates how to create a string slice.  It shows how to reference a portion of a String using the range syntax `[start..end]`. The slice doesn't take ownership, but it allows controlled access to parts of the original string.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-03-slices.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-17-slice/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Defining a Summary Trait with a Default Implementation\nDESCRIPTION: This code defines the `Summary` trait with a default implementation for the `summarize` method.  If a type implements the `Summary` trait without providing its own implementation of `summarize`, the default implementation will be used.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-02-traits.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub trait Summary {\n    fn summarize(&self) -> String {\n        String::from(\"Read more...\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Post State Transitions with Structs and Methods in Rust\nDESCRIPTION: This code snippet defines the `DraftPost`, `PendingReviewPost`, and `Post` structs, along with methods for transitioning between states. The `request_review` method on `DraftPost` consumes the instance and returns a `PendingReviewPost`. The `approve` method on `PendingReviewPost` consumes its instance and returns a `Post`. This enforces the workflow via the type system.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter18.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nimpl DraftPost {\n    // --snip--\n    pub fn request_review(self) -> PendingReviewPost {\n        PendingReviewPost {\n            content: self.content,\n        }\n    }\n}\n\npub struct PendingReviewPost {\n    content: String,\n}\n\nimpl PendingReviewPost {\n    pub fn approve(self) -> Post {\n        Post {\n            content: self.content,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Receiving and Executing Jobs in Worker Thread (Rust)\nDESCRIPTION: This snippet demonstrates how a `Worker` thread receives jobs from a channel, acquires a mutex lock, and executes the received job. It uses `lock` and `recv` to retrieve jobs and `unwrap` to handle potential errors, such as a poisoned mutex or a closed channel. The code ensures that only one worker thread can access the job queue at a time.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-02-multithreaded.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        let thread = thread::spawn(move || {\n            loop {\n                let job = receiver.lock().unwrap().recv().unwrap();\n\n                println!(\"Worker {} got a job; executing.\", id);\n\n                job();\n            }\n        });\n\n        Worker {\n            id,\n            thread,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Full Threadpool Implementation - Rust\nDESCRIPTION: This is the complete implementation of the threadpool including the thread pool struct, worker struct, and relevant methods for constructing the threadpool and safely managing threads during shutdown.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_31\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::{\n    sync::{mpsc, Arc, Mutex},\n    thread,\n};\n\npub struct ThreadPool {\n    workers: Vec<Worker>,\n    sender: Option<mpsc::Sender<Job>>,\n}\n\ntype Job = Box<dyn FnOnce() + Send + 'static>;\n\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let receiver = Arc::new(Mutex::new(receiver));\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&receiver)));\n        }\n\n        ThreadPool {\n            workers,\n            sender: Some(sender),\n        }\n    }\n\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static,\n    {\n        let job = Box::new(f);\n\n        self.sender.as_ref().unwrap().send(job).unwrap();\n    }\n}\n\nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        drop(self.sender.take());\n\n        for worker in &mut self.workers {\n            println!(\"Shutting down worker {}\", worker.id);\n\n            if let Some(thread) = worker.thread.take() {\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: Option<thread::JoinHandle<()>>,\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        let thread = thread::spawn(move || loop {\n            let message = receiver.lock().unwrap().recv();\n\n            match message {\n                Ok(job) => {\n                    println!(\"Worker {id} got a job; executing.\");\n\n                    job();\n                }\n                Err(_) => {\n                    println!(\"Worker {id} disconnected; shutting down.\");\n                    break;\n                }\n            }\n        });\n\n        Worker {\n            id,\n            thread: Some(thread),\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using `longest` Function with String Literals in Rust\nDESCRIPTION: This example demonstrates using the `longest` function with references to `String` values. The `string1` has a scope covering the entire main function, while `string2` has a scope limited to the inner block. The `result` variable references the longer of the two strings and its lifetime is determined by the smaller lifetime of `string1` and `string2`\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-03-lifetime-syntax.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let string1 = String::from(\"long string is long\");\n\n    {\n        let string2 = String::from(\"xyz\");\n        let result = longest(string1.as_str(), string2.as_str());\n        println!(\"The longest string is {}\", result);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Key and Value Only if Key is Absent\nDESCRIPTION: This code demonstrates the use of the `entry` API with the `or_insert` method to insert a key-value pair only if the key is not already present in the hash map.  It provides a concise way to add a default value if a key is missing.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-03-hash-maps.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::HashMap;\n\nfn main() {\n    let mut scores = HashMap::new();\n    scores.insert(String::from(\"Blue\"), 10);\n\n    scores.entry(String::from(\"Yellow\")).or_insert(50);\n    scores.entry(String::from(\"Blue\")).or_insert(50);\n\n    println!(\"{:?}\", scores);\n}\n```\n\n----------------------------------------\n\nTITLE: Introducing a Bug in can_hold Method in Rust\nDESCRIPTION: This code snippet introduces a bug in the `can_hold` method by changing the comparison operator. This showcases how tests can catch errors and prevent undesired behavior by testing the logic of functions.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-01-writing-tests.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-03-introducing-a-bug/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Creating a Vector with Initial Values using the `vec!` Macro\nDESCRIPTION: This code creates a new `Vec<i32>` and initializes it with the values `1`, `2`, and `3`. The `vec!` macro simplifies vector creation. Rust infers the type of the vector elements as `i32` from the initial values, so a type annotation is not needed. No dependencies are required.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet v = vec![1, 2, 3];\n```\n\n----------------------------------------\n\nTITLE: Using unwrap() for Panic on Error in Rust\nDESCRIPTION: This snippet demonstrates the usage of the `unwrap()` method on a `Result`. If the `Result` is `Ok`, it returns the value. If it's `Err`, it panics with a default error message. It's a shortcut but can be less informative in production code.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch09-02-recoverable-errors-with-result.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch09-error-handling/no-listing-04-unwrap/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Defining a Summary Trait in Rust\nDESCRIPTION: This code defines a public trait named `Summary` with a single method signature `summarize`. The `summarize` method takes a reference to `self` and returns a `String`. This trait defines a shared behavior that different types can implement.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-02-traits.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub trait Summary {\n    fn summarize(&self) -> String;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Values in a HashMap - Rust\nDESCRIPTION: This snippet shows how to access a value associated with a specific key in a HashMap using the `get()` method. It also demonstrates how to handle the `Option` returned by `get()` to provide a default value if the key is not found.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_28\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Yellow\"), 50);\n\nlet team_name = String::from(\"Blue\");\nlet score = scores.get(&team_name).copied().unwrap_or(0);\n```\n\n----------------------------------------\n\nTITLE: Option enum with generic type\nDESCRIPTION: Shows the definition of the `Option<T>` enum, which is generic over type `T`. It has two variants: `Some(T)`, which holds a value of type `T`, and `None`, which represents the absence of a value. This demonstrates a common use case of generics in enums.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-01-syntax.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nenum Option<T> {\n    Some(T),\n    None,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Rectangle Struct Rust\nDESCRIPTION: This code snippet defines a `Rectangle` struct with `width` and `height` fields, both of type `u32`. It calculates the area of a `Rectangle` instance using the struct's fields. The `main` function creates an instance of the `Rectangle` struct, and passes a reference to it to the `area` function.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-02-example-structs.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        area(&rect1)\n    );\n}\n\nfn area(rectangle: &Rectangle) -> u32 {\n    rectangle.width * rectangle.height\n}\n```\n\n----------------------------------------\n\nTITLE: Shutting Down Server After Two Requests - Rust\nDESCRIPTION: This code snippet demonstrates how to modify the `main` function to accept only two requests before gracefully shutting down the server. It uses the `take` method on the iterator to limit the number of requests processed. This allows verifying that the graceful shutdown and cleanup mechanisms are functioning correctly.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-03-graceful-shutdown-and-cleanup.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch21-web-server/listing-21-25/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Defining `Post`, `State` Trait, and `Draft` Struct\nDESCRIPTION: This snippet defines the `Post` struct with a `state` field holding a `Box<dyn State>` trait object. It also includes the `State` trait and the `Draft` struct, which represents the initial state of a blog post. The `Post::new` function initializes a new post with an empty content string and sets the state to `Draft`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-03-oo-design-patterns.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub struct Post {\n    state: Option<Box<dyn State>>,\n    content: String,\n}\n\nimpl Post {\n    pub fn new() -> Post {\n        Post {\n            state: Some(Box::new(Draft {})),\n            content: String::new(),\n        }\n    }\n}\n\ntrait State {}\n\nstruct Draft {}\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait with Default and Required Methods in Rust\nDESCRIPTION: This code defines the `Summary` trait with both a required method (`summarize_author`) and a default method (`summarize`). The default `summarize` method calls the `summarize_author` method, requiring implementors to define `summarize_author` but allowing them to optionally use the provided default implementation of `summarize`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\npub trait Summary {\n    fn summarize_author(&self) -> String;\n\n    fn summarize(&self) -> String {\n        format!(\"(Read more from {}...)\", self.summarize_author())\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Option Values with Different Types in Rust\nDESCRIPTION: This code demonstrates how to use the `Option` enum with different types, such as `i32` and `char`. It shows how to create `Option` values using `Some` and `None` variants, and how the compiler infers the type of the `Option` based on the value inside the `Some` variant. For `None`, the type needs to be explicitly specified.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-01-defining-an-enum.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n{{\n  #rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-06-option-examples/src/main.rs:here\n}}\n```\n\n----------------------------------------\n\nTITLE: String Scope Example in Rust\nDESCRIPTION: This code demonstrates how String variables are automatically deallocated when they go out of scope in Rust. The 'drop' function is automatically called when the variable 's' goes out of scope, returning the allocated memory to the memory allocator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n{\n    let s = String::from(\"hello\");   // s is valid from this point forward\n\n    // do stuff with s\n}\t\t\t\t\t\t  // this scope is now over, and s is no longer valid\n```\n\n----------------------------------------\n\nTITLE: Matching Nested Enums in Rust\nDESCRIPTION: This code demonstrates matching on nested enums within a `match` expression. It matches a `Message::ChangeColor` enum variant that contains either a `Color::Rgb` or a `Color::Hsv` variant, binding to the inner values. Dependencies: None. Inputs: A Message enum. Outputs: Prints color information.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(Color),\n}\n\nenum Color {\n    Rgb(i32, i32, i32),\n    Hsv(i32, i32, i32),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));\n\n    match msg {\n        Message::ChangeColor(Color::Rgb(r, g, b)) => {\n            println!(\"Change the color to red {}, green {}, and blue {}\", r, g, b)\n        }\n        Message::ChangeColor(Color::Hsv(h, s, v)) => {\n            println!(\"Change the color to hue {}, saturation {}, and value {}\", h, s, v)\n        }\n        _ => (),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting String Input to Number - Rust\nDESCRIPTION: This code snippet converts a string input (`guess`) to a 32-bit unsigned integer (`u32`) using the `trim` and `parse` methods. It shadows the original `guess` variable. It expects a string containing a number as input, removes leading/trailing whitespace and attempts to parse it into a `u32`.  If the parsing fails, it will panic with the provided error message.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nlet guess: u32 = guess.trim().parse().expect(\"Please type a number!\");\n```\n\n----------------------------------------\n\nTITLE: Changing `main` to return `Result<(), E>` in Rust\nDESCRIPTION: This code snippet shows how to modify the `main` function to return `Result<(), Box<dyn Error>>` to allow the use of the `?` operator. By changing the return type, `main` can now propagate errors using `?`. This code opens a file and uses the `?` to propagate errors, returning `Ok(())` on success.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch09-02-recoverable-errors-with-result.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch09-error-handling/listing-09-12/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Defining Area Method on Rectangle Struct in Rust\nDESCRIPTION: This snippet defines a `Rectangle` struct with `width` and `height` fields, and an `area` method associated with the struct using an `impl` block. The `area` method takes an immutable reference to `self` and returns the area of the rectangle as a `u32`. The main function creates a Rectangle instance and prints its area using the defined method.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        rect1.area()\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: If Expression: Multiple Conditions with Else If in Rust\nDESCRIPTION: This code snippet demonstrates the use of `else if` to handle multiple conditions. It checks a number for divisibility by 4, 3, and 2 in that order. The first condition that evaluates to `true` will have its corresponding code block executed, and the rest will be skipped. An `else` block handles the case where none of the conditions are true.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-05-control-flow.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let number = 6;\n\n    if number % 4 == 0 {\n        println!(\"number is divisible by 4\");\n    } else if number % 3 == 0 {\n        println!(\"number is divisible by 3\");\n    } else if number % 2 == 0 {\n        println!(\"number is divisible by 2\");\n    } else {\n        println!(\"number is not divisible by 4, 3, or 2\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Blog Post Usage Example in main.rs\nDESCRIPTION: This code demonstrates the desired behavior of the `blog` crate. It creates a new blog post, adds text, requests a review, approves the post, and then verifies that the content is only accessible after approval.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter18.md#_snippet_10\n\nLANGUAGE: Rust\nCODE:\n```\nuse blog::Post;\n\nfn main() {\n    let mut post = Post::new();\n\n    post.add_text(\"I ate a salad for lunch today\");\n    assert_eq!(\"\", post.content());\n\n    post.request_review();\n    assert_eq!(\"\", post.content());\n\n    post.approve();\n    assert_eq!(\"I ate a salad for lunch today\", post.content());\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating RefCell Panics with Multiple Mutable Borrows\nDESCRIPTION: This Rust code demonstrates the runtime borrow checking of `RefCell`. Attempting to create two mutable borrows to the same `RefCell` within the same scope will cause a panic at runtime, illustrating how `RefCell` enforces borrowing rules.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-05-interior-mutability.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nimpl Messenger for MockMessenger {\n    fn send(&self, message: &str) {\n        let mut one_borrow = self.sent_messages.borrow_mut();\n        let mut two_borrow = self.sent_messages.borrow_mut();\n\n        one_borrow.push(String::from(message));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Config::build with Iterator Methods\nDESCRIPTION: This is the refactored `Config::build` function using iterator methods like `next`.  It retrieves the query and file path from the iterator and returns a `Config` instance or an error if not enough arguments are provided.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-03-improving-our-io-project.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nimpl Config {\n    pub fn build<T>(mut args: T) -> Result<Config, &'static str>\n    where\n        T: Iterator<Item = String>,\n    {\n        args.next();\n\n        let query = match args.next() {\n            Some(arg) => arg,\n            None => return Err(\"Didn't get a query string\"),\n        };\n\n        let file_path = match args.next() {\n            Some(arg) => arg,\n            None => return Err(\"Didn't get a file path string\"),\n        };\n\n        Ok(Config { query, file_path })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implement ThreadPool::new (Rust)\nDESCRIPTION: Implements the `new` associated function for the `ThreadPool` struct, taking a `usize` size parameter and returning a `ThreadPool` instance. It serves as the constructor for the thread pool, initializing it with a given number of threads. It represents the initial state and lays the groundwork for thread management.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-02-multithreaded.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nimpl ThreadPool {\n    fn new(size: usize) -> ThreadPool {\n        ThreadPool\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the `Deref` Trait for `MyBox<T>` in Rust\nDESCRIPTION: Implements the `Deref` trait for the custom smart pointer `MyBox<T>`, enabling the use of the dereference operator (*). The `deref` method returns a reference to the inner data, allowing `MyBox<T>` to behave like a reference. `type Target = T;` defines the associated type for the Deref trait.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-02-deref.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops::Deref;\n\nstruct MyBox<T>(T);\n\nimpl<T> MyBox<T> {\n    fn new(x: T) -> MyBox<T> {\n        MyBox(x)\n    }\n}\n\nimpl<T> Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cons List Implementation with Rc<T> Rust\nDESCRIPTION: This code snippet demonstrates how to create a cons list using `Rc<T>` to allow multiple lists to share ownership of a third list. `Rc<T>` provides shared ownership by keeping track of the number of references to the data. Cloning an `Rc<T>` increments the reference count. The code defines the `List` enum with `Cons` and `Nil` variants and uses `Rc::clone` to share ownership of list `a` between lists `b` and `c`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nenum List {\n    Cons(i32, Rc<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil))))));\n    let b = Cons(3, Rc::clone(&a));\n    let c = Cons(4, Rc::clone(&a));\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting `parse_config` Function Rust\nDESCRIPTION: This code snippet demonstrates extracting the argument parsing logic from the `main` function into a separate function called `parse_config`. This prepares the code for moving the parsing logic to `src/lib.rs`. The `parse_config` function takes the command-line arguments as input and returns a tuple containing the query and file path.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-03-improving-error-handling-and-modularity.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-05/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Incrementing a Counter with Mutex and Arc - Rust\nDESCRIPTION: This code demonstrates the correct way to share a Mutex between multiple threads using Arc. Arc provides thread-safe reference counting, allowing the Mutex to be safely shared and mutated by multiple threads. This code shows the final corrected version that compiles and runs successfully.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter16.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Arc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Errors with `unwrap_or_else` in `main` - Rust\nDESCRIPTION: This snippet updates `main` to handle the `Result` being returned by `Config::build` and exit the process more cleanly in the error case. It uses `unwrap_or_else` to define custom error handling, printing the error message and calling `process::exit` with a nonzero exit code.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-03-improving-error-handling-and-modularity.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse std::env;\nuse std::fs;\nuse std::process;\n\nstruct Config {\n    query: String,\n    file_path: String,\n}\n\nimpl Config {\n    fn build(args: &[String]) -> Result<Config, &'static str> {\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config {\n            query,\n            file_path,\n        })\n    }\n}\n\nfn run(config: Config) {\n    let contents = fs::read_to_string(config.file_path)\n        .expect(\"Could not read file\");\n\n    println!(\"With contents:\\n{contents}\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::build(&args).unwrap_or_else(|err| {\n        println!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    run(config);\n}\n```\n\n----------------------------------------\n\nTITLE: Runtime Borrow Checking with RefCell\nDESCRIPTION: This code snippet demonstrates how RefCell<T> enforces borrowing rules at runtime. It shows that attempting to create two mutable borrows within the same scope will cause a panic at runtime, preventing data races.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nimpl Messenger for MockMessenger {\n    fn send(&self, message: &str) {\n        let mut one_borrow = self.sent_messages.borrow_mut();\n        let mut two_borrow = self.sent_messages.borrow_mut();\n\n        one_borrow.push(String::from(message));\n        two_borrow.push(String::from(message));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Sharing the receiver using Arc and Mutex\nDESCRIPTION: This snippet demonstrates how to share the receiver among the `Worker` instances using `Arc` and `Mutex`. This allows multiple threads to safely access and modify the receiver, preventing race conditions.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-02-multithreaded.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\nuse std::sync::mpsc;\nuse std::sync::Arc;\nuse std::sync::Mutex;\n\npub struct ThreadPool {\n    workers: Vec<Worker>,\n    sender: mpsc::Sender<Job>,\n}\n\ntype Job = Box<dyn FnOnce() + Send + 'static>;\n\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let receiver = Arc::new(Mutex::new(receiver));\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&receiver)));\n        }\n\n        ThreadPool {\n            workers,\n            sender,\n        }\n    }\n\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static\n    {\n\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: thread::JoinHandle<()>\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        let thread = thread::spawn(move || {\n            receiver;\n        });\n\n        Worker {\n            id,\n            thread,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using `FnMut` Closure with `sort_by_key` by Mutable Reference Capture in Rust\nDESCRIPTION: This example demonstrates a correct usage of `sort_by_key` with a closure that implements the `FnMut` trait.  The closure captures a mutable reference to `num_sort_operations` and increments it, allowing it to be called multiple times without moving any values out of its environment.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let mut list = [\n        Rectangle { width: 10, height: 1 },\n        Rectangle { width: 3, height: 5 },\n        Rectangle { width: 7, height: 12 },\n    ];\n\n    let mut num_sort_operations = 0;\n    list.sort_by_key(|r| {\n        num_sort_operations += 1;\n        r.width\n    });\n    println!(\"{list:#?}, sorted in {num_sort_operations} operations\");\n}\n```\n\n----------------------------------------\n\nTITLE: Opening a File with Result in Rust\nDESCRIPTION: This code demonstrates opening a file using `File::open`, which returns a `Result<std::fs::File, std::io::Error>`. The `Result` represents either a successful file handle (`Ok`) or an error (`Err`) if the file cannot be opened.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch09-02-recoverable-errors-with-result.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch09-error-handling/listing-09-03/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Explicitly calling panic! in Rust\nDESCRIPTION: This snippet shows how to explicitly call the `panic!` macro in Rust. The `panic!` macro causes the program to terminate with an error message. This can be used in situations where the program encounters an unrecoverable error and cannot continue execution.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch09-01-unrecoverable-errors-with-panic.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    panic!(\"crash and burn\");\n}\n```\n\n----------------------------------------\n\nTITLE: Refactoring run function to return Result in Rust\nDESCRIPTION: This snippet demonstrates changing the `run` function to return a `Result` type, enabling error propagation instead of panicking. It uses the `Box<dyn Error>` trait object for flexible error handling and the `?` operator for concise error propagation. The function returns `Ok(())` on success to indicate side effects only.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-03-improving-error-handling-and-modularity.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-12/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Reading HTTP Request from TCP Stream in Rust\nDESCRIPTION: This Rust code reads data from a TCP stream, specifically designed to capture and print HTTP requests sent by a web browser. It leverages `BufReader` for efficient reading and collects the request lines into a vector until an empty line (two newline characters in a row) signals the end of the request.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-01-single-threaded.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::io::prelude::*;\nuse std::io::BufReader;\nuse std::net::TcpStream;\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n    let http_request: Vec<_> = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    println!(\"Request: {:?}\", http_request);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing `timeout` with `race` and `sleep` in Rust\nDESCRIPTION: This code snippet implements the `timeout` function using `race` and `sleep`. It races the provided future against a timer created with `sleep` and returns the result accordingly. If the future completes first, it returns `Ok` with the output; otherwise, it returns `Err` with the timeout duration.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-03-more-futures.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n// The code was not provided in a parsable format. Therefore, a placeholder is provided.\n// This listing would demonstrate the implementation of a `timeout` function.\nasync fn timeout<F>(future_to_try: F, max_time: std::time::Duration) -> Result<F::Output, std::time::Duration>\nwhere\n    F: std::future::Future,\n{\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Reading a File in Rust\nDESCRIPTION: This code reads the contents of a file specified by `file_path` using `fs::read_to_string`.  It uses `expect` to handle potential errors during file reading. The code requires the `std::fs` module.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::env;\nuse std::fs;\n\nfn main() {\n    // --snip--\n    println!(\"In file {file_path}\");\n\n    let contents = fs::read_to_string(file_path)\n        .expect(\"Should have been able to read the file\");\n\n    println!(\"With text:\\n{contents}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using Rc<RefCell<i32>> to create a mutable List in Rust\nDESCRIPTION: This code demonstrates the use of `Rc<RefCell<i32>>` to create a `List` data structure where the underlying value can be mutated even when the list is shared by multiple owners. It initializes an `Rc<RefCell<i32>>` with the value 5, creates three lists (`a`, `b`, `c`) sharing the initial value, and then modifies the value to 15. The output shows that all lists reflect the change.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-05-interior-mutability.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nenum List {\n    Cons(Rc<RefCell<i32>>, Rc<List>),\n    Nil,\n}\n\nuse List::{Cons, Nil};\n\nfn main() {\n    let value = Rc::new(RefCell::new(5));\n\n    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));\n\n    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&a));\n    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&a));\n\n    *value.borrow_mut() += 10;\n\n    println!(\"a after = {:?}\", a);\n    println!(\"b after = {:?}\", b);\n    println!(\"c after = {:?}\", c);\n}\n```\n\n----------------------------------------\n\nTITLE: For Loop with Range and Reverse in Rust\nDESCRIPTION: This Rust snippet uses a `for` loop with a `Range` and the `rev` method to create a countdown. The `(1..4)` creates a range of numbers from 1 to 3 (exclusive of 4), and `.rev()` reverses the order, so the loop iterates from 3 down to 1.  This demonstrates a concise and idiomatic way to implement countdowns in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-05-control-flow.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    for number in (1..4).rev() {\n        println!(\"{}!\", number);\n    }\n    println!(\"LIFTOFF!!!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Breaking Out of Worker Loop - Rust\nDESCRIPTION: This code snippet modifies the worker thread's loop to gracefully exit when the `recv` function returns an error. This happens when the channel is closed (because the `sender` was dropped), signaling that no more jobs will be sent. This ensures that the threads will finish when the `ThreadPool`'s `Drop` implementation calls `join` on them.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-03-graceful-shutdown-and-cleanup.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch21-web-server/listing-21-24/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Implementing the `can_hold` method on `Rectangle` in Rust\nDESCRIPTION: This code snippet implements the `can_hold` method on the `Rectangle` struct. The `can_hold` method takes another `Rectangle` instance as a parameter (by immutable reference) and returns a boolean value indicating whether the first rectangle (`self`) can completely contain the second rectangle (passed as an argument).\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-03-method-syntax.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n\n    fn can_hold(&self, other: &Rectangle) -> bool {\n        self.width > other.width && self.height > other.height\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n    let rect2 = Rectangle {\n        width: 10,\n        height: 40,\n    };\n    let rect3 = Rectangle {\n        width: 60,\n        height: 45,\n    };\n\n    println!(\"Can rect1 hold rect2? {}\", rect1.can_hold(&rect2));\n    println!(\"Can rect1 hold rect3? {}\", rect1.can_hold(&rect3));\n}\n```\n\n----------------------------------------\n\nTITLE: Racing URLs with Async Futures in Rust\nDESCRIPTION: This code snippet demonstrates racing two asynchronous tasks, each fetching the title of a webpage from a given URL. It uses `trpl::race` to determine which future completes first and prints the result, including the URL and the page title if found. The `should_panic` attribute indicates that the test is expected to panic. The `noplayground` attribute indicates that the code should not be run in the Rust playground environment.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-01-futures-and-syntax.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n    use futures::future::join;\n    use std::time::Duration;\n\n    async fn get_title(url: String) -> String {\n        let client = reqwest::Client::new();\n        let response = client.get(&url).timeout(Duration::from_secs(3)).send().await;\n        match response {\n            Ok(res) => {\n                if res.status().is_success() {\n                    match res.text().await {\n                        Ok(body) => {\n                            if let Some(title) = extract_title(&body) {\n                                return format!(\"{}: {}\", url, title);\n                            } else {\n                                return format!(\"{}: No title found.\", url);\n                            }\n                        }\n                        Err(err) => return format!(\"{}: Error reading body: {}\", url, err),\n                    }\n                } else {\n                    return format!(\"{}: HTTP error {}\", url, res.status());\n                }\n            }\n            Err(err) => return format!(\"{}: Error: {}\", url, err),\n        }\n    }\n\n    fn extract_title(html: &str) -> Option<String> {\n        let start_tag = \"<title>\";\n        let end_tag = \"</title>\";\n\n        if let Some(start_index) = html.find(start_tag) {\n            if let Some(end_index) = html[start_index..].find(end_tag) {\n                let title_start = start_index + start_tag.len();\n                let title_end = start_index + end_index;\n                return Some(html[title_start..title_end].trim().to_string());\n            }\n        }\n        None\n    }\n\n    let url1 = std::env::args().nth(1).expect(\"Missing first URL\");\n    let url2 = std::env::args().nth(2).expect(\"Missing second URL\");\n\n    let (title1, title2) = join(get_title(url1.clone()), get_title(url2.clone())).await;\n\n    println!(\"{} \\n{}\", title1, title2);\n\n    Ok(())\n}\n\n```\n\n----------------------------------------\n\nTITLE: Closure Capturing Immutable Reference in Rust\nDESCRIPTION: This code defines a closure that captures an immutable reference to a vector named `list` because it only needs to print the value.  The closure is then called and the vector is accessed before, during, and after the closure's execution. The closure borrows the vector immutably.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-01-closures.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(\"Before defining closure: {:?}\", list);\n\n    let only_borrows = || println!(\"From closure: {:?}\", list);\n\n    println!(\"Before calling closure: {:?}\", list);\n    only_borrows();\n    println!(\"After calling closure: {:?}\", list);\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Panic Conditions with should_panic - Rust\nDESCRIPTION: This snippet shows how to use the `#[should_panic]` attribute to test that a function panics under specific conditions. It demonstrates testing the `Guess::new` function to ensure it panics when the input value is outside the valid range (1-100).\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-01-writing-tests.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-08/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Attempting String Indexing in Rust (Invalid)\nDESCRIPTION: This code snippet demonstrates an attempt to access a character in a String using indexing, which is an invalid operation in Rust. It illustrates why direct indexing of strings is not allowed due to the variable-length nature of UTF-8 encoding.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-02-strings.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(unused)]\nfn main() {\nlet s = String::from(\"hello\");\n\nlet _h = s[0];\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Input - Rust\nDESCRIPTION: This snippet demonstrates how to handle invalid input (non-numbers) in the guessing game without crashing the program. It utilizes a `match` expression to handle the `Result` returned by the `parse` method. If the input is a valid number, it proceeds; otherwise, it uses `continue` to skip to the next loop iteration, prompting the user for input again.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-05/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Accessing Vector Elements using Indexing and the `get` Method\nDESCRIPTION: This code illustrates two ways to access elements in a vector: using indexing syntax (`v[index]`) and the `get` method (`v.get(index)`). Indexing returns a reference to the element directly but panics if the index is out of bounds. The `get` method returns an `Option<&T>`, allowing for safe handling of out-of-bounds access without panicking.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet v = vec![1, 2, 3, 4, 5];\n\nlet third: &i32 = &v[2];\nprintln!(\"The third element is {third}\");\n\nlet third: Option<&i32> = v.get(2);\nmatch third {\n    Some(third) => println!(\"The third element is {third}\"),\n    None => println!(\"There is no third element.\"),\n}\n```\n\n----------------------------------------\n\nTITLE: Listening for TCP Connections in Rust\nDESCRIPTION: This code snippet demonstrates how to listen for incoming TCP connections on a specified address and port using the `std::net` module in Rust. It binds to the address `127.0.0.1:7878`, iterates through incoming connections, and prints a message for each established connection. The `unwrap()` calls handle potential errors during binding and stream processing, terminating the program if an error occurs.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::net::TcpListener;\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        println!(\"Connection established!\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending a Message to a Thread - Rust\nDESCRIPTION: This snippet demonstrates moving the transmitter end of a channel to a spawned thread and sending a string message. The `move` keyword ensures the spawned thread owns the transmitter. `unwrap` is used for error handling which could panic the program if there's an issue with sending the value through the channel.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch16-02-message-passing.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\nuse std::sync::mpsc;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        tx.send(String::from(\"hi\")).unwrap();\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Using a closure with the map method in Rust\nDESCRIPTION: This snippet showcases using a closure with the `map` method to convert a vector of numbers into a vector of strings.  It iterates over a vector of integers and applies a closure that converts each integer to its string representation.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-04-advanced-functions-and-closures.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let list_of_numbers = vec![1, 2, 3];\n    let list_of_strings: Vec<String> = list_of_numbers\n        .iter()\n        .map(|i| i.to_string())\n        .collect();\n    println!(\"{:?}\", list_of_strings);\n}\n```\n\n----------------------------------------\n\nTITLE: Running minigrep with Cargo\nDESCRIPTION: This snippet demonstrates the execution of the `minigrep` program using `cargo run`. It includes the compilation process, warnings, and the final output of the program, which searches for the string \"the\" in the file \"poem.txt\".\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch12-an-io-project/listing-12-12/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run -- the poem.txt\n Compiling minigrep v0.1.0 (file:///projects/minigrep)\nwarning: unused `Result` that must be used\n  --> src/main.rs:19:5\n   |\n19 |     run(config);\n   |     ^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\n   = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n19 |     let _ = run(config);\n   |     +++++++\n\nwarning: `minigrep` (bin \"minigrep\") generated 1 warning\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s\n     Running `target/debug/minigrep the poem.txt`\nSearching for the\nIn file poem.txt\nWith text:\nI'm nobody! Who are you?\nAre you nobody, too?\nThen there's a pair of us - don't tell!\nThey'd banish us, you know.\n\nHow dreary to be somebody!\nHow public, like a frog\nTo tell your name the livelong day\nTo an admiring bog!\n```\n\n----------------------------------------\n\nTITLE: Method with Lifetime and No Reference Return Value\nDESCRIPTION: This code shows a method `level` implemented on the `ImportantExcerpt` struct. It takes `&self` as a parameter and returns an `i32`.  Due to lifetime elision rules, no explicit lifetime annotation is needed for `&self`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-03-lifetime-syntax.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'a> ImportantExcerpt<'a> {\n    fn level(&self) -> i32 {\n        3\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Re-exporting Items with `pub use` in Rust\nDESCRIPTION: This code shows how to modify the `art` crate to re-export `PrimaryColor`, `SecondaryColor`, and `mix` to the top level using `pub use`.  This simplifies access for users of the crate by removing the need to specify the internal module structure.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-02-publishing-to-crates-io.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(unused)]\nfn main() {\n    pub mod kinds {\n        /// The primary colors according to the RYB color model.\n        pub enum PrimaryColor {\n            Red,\n            Yellow,\n            Blue,\n        }\n\n        /// The secondary colors according to the RYB color model.\n        pub enum SecondaryColor {\n            Orange,\n            Green,\n            Purple,\n        }\n    }\n\n    pub mod utils {\n        use crate::kinds::*;\n\n        /// Combines two primary colors in equal amounts to create\n        /// a secondary color.\n        pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {\n            // --snip--\n            SecondaryColor::Orange\n        }\n    }\n\n    pub use self::kinds::PrimaryColor;\n    pub use self::kinds::SecondaryColor;\n    pub use self::utils::mix;\n}\n```\n\n----------------------------------------\n\nTITLE: Shirt Company Giveaway Implementation in Rust\nDESCRIPTION: This code defines an enum `ShirtColor` with variants `Red` and `Blue`, and an `Inventory` struct containing a vector of shirt colors. The `giveaway` method uses a closure with `unwrap_or_else` to determine the shirt color to give away based on user preference and the most stocked color in the inventory. The `main` function creates an instance of `Inventory` and tests the `giveaway` method with different user preferences.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#[derive(Debug, PartialEq, Copy, Clone)]\nenum ShirtColor {\n    Red,\n    Blue,\n}\n\nstruct Inventory {\n    shirts: Vec<ShirtColor>,\n}\n\nimpl Inventory {\n    fn giveaway(&self, user_preference: Option<ShirtColor>) -> ShirtColor {\n        user_preference.unwrap_or_else(|| self.most_stocked())\n    }\n\n    fn most_stocked(&self) -> ShirtColor {\n        let mut num_red = 0;\n        let mut num_blue = 0;\n\n        for color in &self.shirts {\n            match color {\n                ShirtColor::Red => num_red += 1,\n                ShirtColor::Blue => num_blue += 1,\n            }\n        }\n        if num_red > num_blue {\n            ShirtColor::Red\n        } else {\n            ShirtColor::Blue\n        }\n    }\n}\n\nfn main() {\n    let store = Inventory {\n        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],\n    };\n\n    let user_pref1 = Some(ShirtColor::Red);\n    let giveaway1 = store.giveaway(user_pref1);\n    println!(\n        \"The user with preference {:?} gets {:?}\",\n        user_pref1, giveaway1\n    );\n\n    let user_pref2 = None;\n    let giveaway2 = store.giveaway(user_pref2);\n    println!(\n        \"The user with preference {:?} gets {:?}\",\n        user_pref2, giveaway2\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Drop Definition - Rust\nDESCRIPTION: This code snippet updates the `Drop` implementation for the `ThreadPool` struct using `Vec::drain`.  It removes all workers from the `Vec` and iterates through them, joining each thread. This resolves the compiler error from the previous attempt and ensures all threads finish their work before the pool is dropped.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-03-graceful-shutdown-and-cleanup.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch21-web-server/no-listing-04-update-drop-definition/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Defining a Struct in Rust\nDESCRIPTION: This code defines a `User` struct with fields for `active` (boolean), `username` (String), `email` (String), and `sign_in_count` (unsigned 64-bit integer). This example demonstrates how to structure related data into a custom type.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n```\n\n----------------------------------------\n\nTITLE: Blanket Implementations in Rust\nDESCRIPTION: Illustrates a blanket implementation where the `ToString` trait is implemented for any type that implements the `Display` trait. This enables calling the `to_string` method on any type that implements `Display`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-02-traits.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nimpl<T: Display> ToString for T {\n    // --snip--\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet s = 3.to_string();\n```\n\n----------------------------------------\n\nTITLE: Join Multiple Futures with join! Macro in Rust\nDESCRIPTION: This snippet showcases the use of the `join!` macro to concurrently execute multiple futures.  It takes an arbitrary number of futures as arguments and awaits their completion.  It simplifies the syntax compared to using individual `join` functions (e.g., `join3`).\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\ntrpl::join!(tx1_fut, tx_fut, rx_fut);\n```\n\n----------------------------------------\n\nTITLE: Iterating Over a Hash Map\nDESCRIPTION: This snippet iterates over the key-value pairs in a hash map using a `for` loop and prints each pair to the console. The order of iteration is arbitrary. This demonstrates how to access all elements within a HashMap.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-03-hash-maps.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::HashMap;\n\nfn main() {\n    let mut scores = HashMap::new();\n    scores.insert(String::from(\"Blue\"), 10);\n    scores.insert(String::from(\"Yellow\"), 50);\n\n    for (key, value) in &scores {\n        println!(\"{}: {}\", key, value);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using trpl::run with an Async Block\nDESCRIPTION: This snippet demonstrates the correct way to execute asynchronous code within the `main` function.  It utilizes the `trpl::run` function, which sets up an async runtime, and wraps the asynchronous code in an `async` block.  It retrieves the URL from command-line arguments, calls the `page_title` function, and prints the title or a 'no title' message based on the result.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n\n    trpl::run(async {\n        let url = &args[1];\n        match page_title(url).await {\n            Some(title) => println!(\"The title for {url} was {title}\"),\n            None => println!(\"{url} had no title\"),\n        }\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Shared Test Code in Submodule\nDESCRIPTION: This Rust code snippet defines a `setup` function within a submodule (common/mod.rs) for use in integration tests. This approach prevents the common module from being treated as a separate test file.  The function can be used to perform tasks like initializing variables or setting up the environment before running tests. No external dependencies are shown in the snippet.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-03-test-organization.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-12-shared-test-code-problem/tests/common.rs}}\n```\n\n----------------------------------------\n\nTITLE: Attempting to Use Value After Sending (Does Not Compile) - Rust\nDESCRIPTION: This snippet highlights ownership transfer in channels. The code attempts to use `val` after it has been sent through the channel, resulting in a compile-time error because the `send` function takes ownership of its parameter.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch16-02-message-passing.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\nuse std::sync::mpsc;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    let val = String::from(\"hi\");\n    thread::spawn(move || {\n        tx.send(val).unwrap();\n        // println!(\"val is {}\", val); // error!\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying ThreadPool to store channel sender\nDESCRIPTION: This snippet modifies the `ThreadPool` struct to store the sender of a channel that transmits `Job` instances. It introduces the `Job` type alias and creates a channel in `ThreadPool::new`, holding the sender.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-02-multithreaded.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\nuse std::sync::mpsc;\n\npub struct ThreadPool {\n    workers: Vec<Worker>,\n    sender: mpsc::Sender<Job>,\n}\n\ntype Job = Box<dyn FnOnce() + Send + 'static>;\n\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id));\n        }\n\n        ThreadPool {\n            workers,\n            sender,\n        }\n    }\n\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static\n    {\n\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: thread::JoinHandle<()>\n}\n\nimpl Worker {\n    fn new(id: usize) -> Worker {\n        let thread = thread::spawn(|| {});\n\n        Worker {\n            id,\n            thread,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Populating a HashMap - Rust\nDESCRIPTION: This code demonstrates how to create a new, empty HashMap and then insert key-value pairs into it. The HashMap stores team names (Strings) as keys and their corresponding scores (i32) as values.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_27\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Yellow\"), 50);\n```\n\n----------------------------------------\n\nTITLE: Defining a Recursive Enum with Box<T> in Rust\nDESCRIPTION: This code snippet demonstrates how to use `Box<T>` to create a recursive enum (`List`) with a known size. By wrapping the recursive `List` value within a `Box<T>`, the compiler can determine the size of the `Cons` variant, preventing the infinite size error. The `Box<T>` provides indirection by storing a pointer to the next `List` value on the heap.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nenum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating `search` Function in `run` - Rust\nDESCRIPTION: This code snippet shows how to call the `search` function from the `run` function, passing the query and file contents as arguments. It iterates through the lines returned by `search` and prints each matching line to the console. This demonstrates how to use the search functionality to filter and display relevant information from a file.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-04-testing-the-librarys-functionality.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-an-io-project/no-listing-02-using-search-in-run/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Racing Futures with trpl::race in Rust\nDESCRIPTION: This code snippet demonstrates how to use the `trpl::race` function to run two asynchronous tasks, `slow` and `fast`, concurrently. The `race` function waits for the first future to complete. The snippet also uses `trpl::sleep` to simulate asynchronous operations with different durations. The `Duration` from the `std::time` module is used to define the sleep duration.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\nlet slow = async {\n            println!(\"'slow' started.\");\n            trpl::sleep(Duration::from_millis(100)).await;\n            println!(\"'slow' finished.\");\n        };\n\n        let fast = async {\n            println!(\"'fast' started.\");\n            trpl::sleep(Duration::from_millis(50)).await;\n            println!(\"'fast' finished.\");\n        };\n\n        trpl::race(slow, fast).await;\n```\n\n----------------------------------------\n\nTITLE: Using fs::read_to_string for File Reading - Rust\nDESCRIPTION: This function `read_username_from_file` uses the `fs::read_to_string` function to simplify file reading. It opens the \"hello.txt\" file, reads its contents into a String, and returns the String. Any potential `io::Error` is propagated through the `Result` type. Dependencies: std::fs, std::io.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter09.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs;\nuse std::io;\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    fs::read_to_string(\"hello.txt\")\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Values in a Hash Map\nDESCRIPTION: This code demonstrates how to access a value in a HashMap using the `get` method. It retrieves the score associated with the \"Blue\" team. The example also handles the case where the key might not exist using `copied` and `unwrap_or` to provide a default value.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-03-hash-maps.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::HashMap;\n\nfn main() {\n    let mut scores = HashMap::new();\n\n    scores.insert(String::from(\"Blue\"), 10);\n    scores.insert(String::from(\"Yellow\"), 50);\n\n    let score = scores.get(\"Blue\").copied().unwrap_or(0);\n    println!(\"{}\", score);\n}\n```\n\n----------------------------------------\n\nTITLE: Returning `Result` from `Config::build` - Rust\nDESCRIPTION: This code demonstrates returning a `Result` value from `Config::build` instead of calling `panic!`. It changes the function name from `new` to `build` because many programmers expect `new` functions to never fail. The function returns a `Result` with a `Config` instance in the successful case and a string literal in the error case.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-03-improving-error-handling-and-modularity.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse std::env;\nuse std::fs;\n\nstruct Config {\n    query: String,\n    file_path: String,\n}\n\nimpl Config {\n    fn build(args: &[String]) -> Result<Config, &'static str> {\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config {\n            query,\n            file_path,\n        })\n    }\n}\n\nfn run(config: Config) {\n    let contents = fs::read_to_string(config.file_path)\n        .expect(\"Could not read file\");\n\n    println!(\"With contents:\\n{contents}\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::build(&args).unwrap();\n\n    run(config);\n}\n```\n\n----------------------------------------\n\nTITLE: Calling `map` and `collect` Methods in Rust\nDESCRIPTION: This code demonstrates chaining the `map` iterator adapter with the `collect` method.  The `map` adapter creates a new iterator that increments each item.  The `collect` method then consumes this new iterator and gathers the resulting values into a `Vec<i32>`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-02-iterators.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet v1 = vec![1, 2, 3];\n\nlet v2: Vec<i32> = v1.iter().map(|x| x + 1).collect();\n\nassert_eq!(v2, vec![2, 3, 4]);\n```\n\n----------------------------------------\n\nTITLE: Calculating Area with Tuples Rust\nDESCRIPTION: This code snippet calculates the area of a rectangle using a tuple to group the width and height. The `area` function now takes a single tuple as an argument, and accesses the width and height via tuple indexing. The `main` function creates a tuple representing the rectangle dimensions, then calls the `area` function.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-02-example-structs.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let rect1 = (30, 50);\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        area(rect1)\n    );\n}\n\nfn area(dimensions: (u32, u32)) -> u32 {\n    dimensions.0 * dimensions.1\n}\n```\n\n----------------------------------------\n\nTITLE: Spawning Thread per Request - Rust\nDESCRIPTION: This code snippet demonstrates how to spawn a new thread for each incoming connection. While this allows the server to handle multiple requests concurrently, it can lead to resource exhaustion if the server receives a large number of requests.  This approach is shown as a stepping stone to understanding thread pools.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-02-multithreaded.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\nuse std::net::TcpListener;\nuse std::net::TcpStream;\nuse std::io::prelude::*;\nuse std::fs;\nuse std::time::Duration;\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        thread::spawn(|| {\n            handle_connection(stream)\n        });\n    }\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let mut buffer = [0; 1024];\n    stream.read(&mut buffer).unwrap();\n\n    let get = b\"GET / HTTP/1.1\\r\\n\";\n    let sleep = b\"GET /sleep HTTP/1.1\\r\\n\";\n\n    if buffer.starts_with(get) {\n        let contents = fs::read_to_string(\"hello.html\").unwrap();\n\n        let response = format!(\n            \"HTTP/1.1 200 OK\\r\\nContent-Length: {}\\r\\n\\r\\n{}\",\n            contents.len(),\n            contents\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n        stream.flush().unwrap();    \n    } else if buffer.starts_with(sleep) {\n        thread::sleep(Duration::from_secs(5));\n\n        let contents = fs::read_to_string(\"hello.html\").unwrap();\n\n        let response = format!(\n            \"HTTP/1.1 200 OK\\r\\nContent-Length: {}\\r\\n\\r\\n{}\",\n            contents.len(),\n            contents\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n        stream.flush().unwrap();\n    } else {\n        let status_line = \"HTTP/1.1 404 NOT FOUND\\r\\n\\r\\n\";\n        let contents = fs::read_to_string(\"404.html\").unwrap();\n\n        let response = format!(\"{}{}\", status_line, contents);\n\n        stream.write_all(response.as_bytes()).unwrap();\n        stream.flush().unwrap();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Blanket Implementation of ToString for Types Implementing Display\nDESCRIPTION: This code demonstrates a blanket implementation where the `ToString` trait is implemented for all types `T` that implement the `Display` trait. This allows any type that implements `Display` to automatically use the `to_string` method.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_32\n\nLANGUAGE: Rust\nCODE:\n```\nimpl<T: Display> ToString for T {\n    // --snip--\n}\n```\n\n----------------------------------------\n\nTITLE: Closure Type Inference Example in Rust\nDESCRIPTION: This snippet showcases closure type inference in Rust. The `example_closure` takes a parameter `x` and returns it. The compiler infers the type based on the first usage, which is a `String`. Subsequent calls with a different type (integer) will result in a compilation error due to type mismatch.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet example_closure = |x| x;\n\nlet s = example_closure(String::from(\"hello\"));\nlet n = example_closure(5);\n```\n\n----------------------------------------\n\nTITLE: Bringing a Module into Scope with `use` in Rust\nDESCRIPTION: This code demonstrates how to bring a module into scope using the `use` keyword in Rust.  This allows the code to refer to items within the module using a shorter path. The function `add_to_waitlist` is then called via the shortened path `hosting::add_to_waitlist`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    use crate::front_of_house::hosting;\n    hosting::add_to_waitlist();\n}\n```\n\n----------------------------------------\n\nTITLE: Matching `Option` with `if let` in Rust\nDESCRIPTION: This snippet shows how to use `if let` to match an `Option<u8>` value. It provides a more concise way to handle only the `Some` variant and ignore the `None` variant, avoiding the need for a `_ => ()` arm in the `match` expression.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-03-if-let.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet config_max = Some(3u8);\nif let Some(max) = config_max {\n    println!(\"The maximum is configured to be {}\", max);\n}\n```\n\n----------------------------------------\n\nTITLE: For Loop Iterating Over Collection in Rust\nDESCRIPTION: This Rust code snippet demonstrates iterating over an array using a `for` loop.  The `for element in a` syntax allows direct access to each element in the array `a` without needing to manage an index.  This method is safer and more concise than using a `while` loop for array iteration.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-05-control-flow.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let a = [10, 20, 30, 40, 50];\n\n    for element in a {\n        println!(\"the value is: {}\", element);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Search Function with Iterator Adapters\nDESCRIPTION: This snippet presents the refactored `search` function using iterator adapters. It avoids a mutable intermediate vector by using `filter` and `collect` to achieve the same result in a more concise, functional style.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-03-improving-our-io-project.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\npub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    contents\n        .lines()\n        .filter(|line| line.contains(query))\n        .collect()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the `Add` trait for `Point` instances to overload the `+` operator in Rust\nDESCRIPTION: This code implements the `Add` trait for a `Point` struct, allowing the `+` operator to be used to add two `Point` instances. The `add` method adds the corresponding `x` and `y` values of the two points and returns a new `Point` instance with the summed coordinates.  The associated type `Output` defines the return type of the `add` method.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-02-advanced-traits.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops::Add;\n\n#[derive(Debug, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -> Point {\n        Point {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Abstracted Function to Find the Largest Number\nDESCRIPTION: This code demonstrates how to abstract the logic for finding the largest number in a list into a reusable function. The `largest` function takes a slice of `i32` values as input and returns the largest number.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-00-generics.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn largest(list: &[i32]) -> i32 {\n    let mut largest = list[0];\n\n    for &item in list {\n        if item > largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest(&number_list);\n    println!(\"The largest number is {}\", result);\n\n    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];\n\n    let result = largest(&number_list);\n    println!(\"The largest number is {}\", result);\n}\n```\n\n----------------------------------------\n\nTITLE: Add local dependencies in Cargo.toml\nDESCRIPTION: This code snippet shows how to add local dependencies to a Rust crate's `Cargo.toml` file. This is useful when the dependencies are not published on crates.io and are located in the same project or a nearby directory. The `path` attribute specifies the relative path to the dependency's directory.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-05-macros.md#_snippet_10\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nhello_macro = { path = \"../hello_macro\" }\nhello_macro_derive = { path = \"../hello_macro_derive\" }\n```\n\n----------------------------------------\n\nTITLE: Initializing an Empty Vector with Type Annotation in Rust\nDESCRIPTION: This snippet demonstrates how to create a new, empty vector in Rust and explicitly specify the data type it will hold (i32).  Because the vector is initially empty, the type annotation is required. The `Vec::new()` function is used for initialization.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-01-vectors.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let v: Vec<i32> = Vec::new();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a struct with private fields for encapsulation in Rust\nDESCRIPTION: This code defines a public struct `AveragedCollection` with a private `list` field (a vector of i32) and a private `average` field (a f64). The purpose is to encapsulate the data and ensure the `average` is always synchronized with the `list`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter18.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub struct AveragedCollection {\n    list: Vec<i32>,\n    average: f64,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementation of StreamExt for asynchronous stream processing in Rust\nDESCRIPTION: This snippet provides an example of how to use StreamExt for asynchronous stream processing. StreamExt provides the next method allowing us to easily await the next item in an asynchronous stream.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-05-traits-for-async.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch17-async-await/no-listing-stream-ext/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Receiving a Message in the Main Thread - Rust\nDESCRIPTION: This snippet demonstrates receiving a message in the main thread using the `recv` method of the receiver.  `recv` blocks the main thread until a message is received. `unwrap` is used for error handling which could panic the program if there's an issue with the receiving end of the channel.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch16-02-message-passing.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\nuse std::sync::mpsc;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        tx.send(String::from(\"hi\")).unwrap();\n    });\n\n    let received = rx.recv().unwrap();\n    println!(\"Got: {}\", received);\n}\n```\n\n----------------------------------------\n\nTITLE: Using RefCell for Mutable Access within Immutable Context\nDESCRIPTION: This Rust code demonstrates the use of `RefCell` to allow mutable access to the `sent_messages` vector within the `MockMessenger` struct, even though the `send` method takes an immutable reference. This enables the mock object to track messages sent during testing.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-05-interior-mutability.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cell::RefCell;\n\n    struct MockMessenger {\n        sent_messages: RefCell<Vec<String>>,\n    }\n\n    impl MockMessenger {\n        fn new() -> MockMessenger {\n            MockMessenger {\n                sent_messages: RefCell::new(vec![]),\n            }\n        }\n    }\n\n    impl Messenger for MockMessenger {\n        fn send(&self, message: &str) {\n            self.sent_messages.borrow_mut().push(String::from(message));\n        }\n    }\n\n    #[test]\n    fn it_sends_an_over_75_percent_warning_message() {\n        // --snip--\n        let mock_messenger = MockMessenger::new();\n        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);\n\n        limit_tracker.set_value(80);\n\n        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Define ThreadPool::execute method (Rust)\nDESCRIPTION: Defines the `execute` method on the `ThreadPool` struct, which accepts a closure with no parameters and returns the unit type. The closure also needs to satisfy trait bounds `FnOnce`, `Send` and have a static lifetime. This function is intended to submit tasks to the thread pool for execution.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-02-multithreaded.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nimpl ThreadPool {\n    fn new(size: usize) -> ThreadPool {\n        ThreadPool\n    }\n\n    fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static\n    {\n\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving the Debug Trait for a Struct in Rust\nDESCRIPTION: This snippet demonstrates how to derive the `Debug` trait for a `Rectangle` struct using the `#[derive(Debug)]` attribute. This allows the struct to be printed using debug formatting with `println!` and the `:?` or `:#?` specifier.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_14\n\nLANGUAGE: Rust\nCODE:\n```\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\"rect1 is {rect1:?}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Greeter Function with Bug - Rust\nDESCRIPTION: This snippet presents a buggy version of the `greeting` function where the name is excluded from the returned greeting. This is used to demonstrate how default test failures look without custom messages.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-01-writing-tests.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-06-greeter-with-bug/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Conditional Insertion into HashMap - Rust\nDESCRIPTION: This code snippet demonstrates how to use the `entry` API to insert a key-value pair into a HashMap only if the key does not already exist. It uses the `or_insert` method to either return a mutable reference to the existing value or insert a new value and return a mutable reference to it.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_32\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(String::from(\"Blue\"), 10);\n\nscores.entry(String::from(\"Yellow\")).or_insert(50);\nscores.entry(String::from(\"Blue\")).or_insert(50);\n\nprintln!(\"{scores:?}\");\n```\n\n----------------------------------------\n\nTITLE: Updating HashMap Value Based on Old Value - Rust\nDESCRIPTION: This code snippet shows how to update the value associated with a key in a HashMap based on its previous value. In this example, it counts the occurrences of words in a given text. The `or_insert` method is used to initialize the count to 0 if the word is not already in the map, and then the count is incremented.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_33\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::HashMap;\n\nlet text = \"hello world wonderful world\";\n\nlet mut map = HashMap::new();\n\nfor word in text.split_whitespace() {\n    let count = map.entry(word).or_insert(0);\n    *count += 1;\n}\n\nprintln!(\"{map:?}\");\n```\n\n----------------------------------------\n\nTITLE: Enum Variants with Different Data Types in Rust\nDESCRIPTION: This code defines an enum called `IpAddr` where each variant has different associated data types. `V4` stores four `u8` values, and `V6` stores a `String`. It showcases the flexibility of enums to handle different data structures.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-01-defining-an-enum.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nenum IpAddr {\n    V4(u8, u8, u8, u8),\n    V6(String),\n}\n```\n\n----------------------------------------\n\nTITLE: Sending a Message to a Thread in Rust\nDESCRIPTION: This snippet demonstrates sending a string message from a spawned thread to the main thread using a channel. It uses `thread::spawn` to create a new thread and `move` to transfer ownership of the transmitter (`tx`) to the spawned thread. The `send` method is used to send the string, and `unwrap` is called to handle potential errors.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter16.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        tx.send(val).unwrap();\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Refactoring HTTP Request Handling in Rust\nDESCRIPTION: This Rust code snippet refactors the HTTP request handling logic to reduce code duplication. It uses an `if` statement to determine the `status_line` and `filename` based on the request and then uses these variables to construct and send the response. Requires the `std::net` and `std::io` modules. Improves the previous code snippets.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-01-single-threaded.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse std::io::prelude::*;\nuse std::net::*;\n\nfn handle_connection(mut stream: TcpStream) {\n    let mut buffer = [0; 1024];\n    stream.read(&mut buffer).unwrap();\n\n    let get = b\"GET / HTTP/1.1\\r\\n\";\n\n    let (status_line, filename) = if buffer.starts_with(get) {\n        (\"HTTP/1.1 200 OK\\r\\n\", \"hello.html\")\n    } else {\n        (\"HTTP/1.1 404 NOT FOUND\\r\\n\", \"404.html\")\n    };\n\n    let contents = std::fs::read_to_string(filename).unwrap();\n\n    let response = format!(\n        \"{}\\r\\nContent-Length: {}\\r\\n\\r\\n{}\",\n        status_line,\n        contents.len(),\n        contents\n    );\n\n    stream.write(response.as_bytes()).unwrap();\n    stream.flush().unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Checking for Environment Variable in Rust\nDESCRIPTION: This code snippet demonstrates how to check for the presence of an environment variable named `IGNORE_CASE` using the `std::env::var` function. If the variable is set (to any value), the `ignore_case` field in the `Config` struct is set to `true`, enabling case-insensitive search.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_27\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::env;\n// --snip--\n\nimpl Config {\n    pub fn build(args: &[String]) -> Result<Config, &'static str> {\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        let ignore_case = env::var(\"IGNORE_CASE\").is_ok();\n\n        Ok(Config {\n            query,\n            file_path,\n            ignore_case,\n        })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Method with Lifetime Elision in Rust\nDESCRIPTION: This method `announce_and_return_part` takes a reference to `self` and a string slice, returning a string slice. It demonstrates how lifetime elision rules can infer lifetimes when one of the input parameters is `&self`, assigning the lifetime of `self` to the output lifetime.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_50\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'a> ImportantExcerpt<'a> {\n    fn announce_and_return_part(&self, announcement: &str) -> &str {\n        println!(\"Attention please: {announcement}\");\n        self.part\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving the Debug trait for a struct in Rust\nDESCRIPTION: This code snippet demonstrates how to use the `#[derive(Debug)]` attribute to automatically implement the `Debug` trait for a struct. This allows instances of the struct to be printed using debug formatting with `println!` and the `:?` or `:#?` specifiers.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-02-example-structs.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-12/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Original Search Function Implementation\nDESCRIPTION: This snippet presents the original implementation of the `search` function, which uses a loop and a mutable vector to find lines containing the query string. This version will be refactored to use iterator adapters.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-03-improving-our-io-project.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.contains(query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n```\n\n----------------------------------------\n\nTITLE: Using function pointers as arguments in Rust\nDESCRIPTION: This snippet demonstrates how to pass a function pointer as an argument to another function in Rust. The `do_twice` function takes a function pointer `f` (which takes an `i32` and returns an `i32`) and an `i32` value. It calls the function `f` twice with the given value and returns the sum of the results. The `add_one` function is used as the function pointer argument.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-04-advanced-functions-and-closures.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn add_one(x: i32) -> i32 {\n    x + 1\n}\n\nfn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {\n    f(arg) + f(arg)\n}\n\nfn main() {\n    let answer = do_twice(add_one, 5);\n\n    println!(\"The answer is: {}\", answer);\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified Vec Macro Definition\nDESCRIPTION: This snippet presents a simplified version of the `vec!` macro definition using `macro_rules!`. It showcases the pattern matching used within macros to handle a variable number of arguments and generate code for vector creation.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-05-macros.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-35/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Returning Errors from the run Function in Rust\nDESCRIPTION: This snippet modifies the `run` function to return a `Result` type, allowing it to propagate errors instead of panicking. It uses the `?` operator to handle errors from `fs::read_to_string` and returns a `Box<dyn Error>` as the error type.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_10\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::error::Error;\n\n// --snip--\n\nfn run(config: Config) -> Result<(), Box<dyn Error>> {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    println!(\"With text:\\n{contents}\");\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Concatenating String Values with the + Operator in Rust\nDESCRIPTION: Explains and demonstrates how to concatenate two `String` values using the `+` operator.  It highlights that the `+` operator takes ownership of the first `String` and coerces the second `String` into a `&str`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-02-strings.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet s1 = String::from(\"Hello, \");\nlet s2 = String::from(\"world!\");\nlet s3 = s1 + &s2; // Note s1 has been moved here and can no longer be used\n```\n\n----------------------------------------\n\nTITLE: Traits as Parameters with impl Trait in Rust\nDESCRIPTION: Defines a function `notify` that accepts any type that implements the `Summary` trait as a parameter using `impl Trait` syntax. This allows calling methods from the `Summary` trait on the `item` parameter within the `notify` function.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-02-traits.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-04-traits-as-parameters/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Struct with Lifetime Annotation in Rust\nDESCRIPTION: This code defines a struct `ImportantExcerpt` that holds a string slice reference. A lifetime annotation is required to ensure that the reference doesn't outlive the data it points to.  The lifetime parameter `'a` is declared after the struct name and used on the `part` field.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-03-lifetime-syntax.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nstruct ImportantExcerpt<'a> {\n    part: &'a str,\n}\n\nfn main() {\n    let novel = String::from(\"Call me Ishmael. Some years ago...\");\n    let first_sentence = novel.split('.').next().expect(\"Could not find a '.'\");\n    let i = ImportantExcerpt { part: first_sentence };\n}\n```\n\n----------------------------------------\n\nTITLE: Sorting Rectangles by Width using `sort_by_key`\nDESCRIPTION: This example uses the `sort_by_key` method to sort a vector of `Rectangle` structs based on their `width` attribute. The closure `|r| r.width` takes a reference to a `Rectangle` and returns its `width`, allowing the vector to be sorted by width in ascending order. This illustrates how `FnMut` closures are used with `sort_by_key`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-01-closures.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-07/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Modifying Main Function to Use New Post Workflow in Rust\nDESCRIPTION: This code snippet shows the updated `main` function to reflect the changes in the blog post workflow. It demonstrates how to create a new `Post`, add text, request a review, approve the post, and then assert that the content is as expected. The `let post =` shadowing assignments are essential due to the methods returning new instances.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter18.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nuse blog::Post;\n\nfn main() {\n    let mut post = Post::new();\n\n    post.add_text(\"I ate a salad for lunch today\");\n\n    let post = post.request_review();\n\n    let post = post.approve();\n\n    assert_eq!(\"I ate a salad for lunch today\", post.content());\n}\n```\n\n----------------------------------------\n\nTITLE: Reading File to String using fs::read_to_string in Rust\nDESCRIPTION: This code snippet demonstrates using the `fs::read_to_string` function to directly read the contents of a file into a string.  This function handles the file opening, reading, and string creation in a single call, simplifying the code significantly.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch09-02-recoverable-errors-with-result.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs;\nuse std::io;\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    fs::read_to_string(\"hello.txt\")\n}\n```\n\n----------------------------------------\n\nTITLE: Match Expression with Option\nDESCRIPTION: This snippet showcases a `match` expression that handles an `Option<i32>` value. It demonstrates pattern matching with `None` and `Some(i)` variants, adding 1 to the value if it's a `Some`. The patterns `None` and `Some(i)` are used to extract the inner value and perform operations based on the variant.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-01-all-the-places-for-patterns.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmatch x {\n    None => None,\n    Some(i) => Some(i + 1),\n}\n```\n\n----------------------------------------\n\nTITLE: Using Traits as Parameters in a Function in Rust\nDESCRIPTION: This code defines a function `notify` that takes a parameter `item` of any type that implements the `Summary` trait. This allows the function to work with multiple types (e.g., `NewsArticle`, `Tweet`) as long as they implement the `Summary` trait. This is achieved using `impl Trait` syntax.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\npub fn notify(item: &impl Summary) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n```\n\n----------------------------------------\n\nTITLE: Closure Definition Variations\nDESCRIPTION: This snippet illustrates various ways to define a closure that adds one to its parameter, showing how type annotations and brackets can be optionally included. It emphasizes the syntax similarities and differences between functions and closures in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-01-closures.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn  add_one_v1   (x: u32) -> u32 { x + 1 }\nlet add_one_v2 = |x: u32| -> u32 { x + 1 };\nlet add_one_v3 = |x|             { x + 1 };\nlet add_one_v4 = |x|               x + 1  ;\n```\n\n----------------------------------------\n\nTITLE: Using Rc<T> with Mutex<T> for Multi-Threaded Access - Rust (Incorrect)\nDESCRIPTION: This code attempts to use `Rc<T>` to allow multiple threads to own a `Mutex<T>`. While it resolves the ownership issue from the previous example, it introduces a new problem: `Rc<T>` is not thread-safe. The compiler flags this with an error indicating that `Rc<Mutex<i32>>` cannot be sent between threads safely because it does not implement the `Send` trait.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch16-03-shared-state.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::rc::Rc;\nuse std::thread;\nuse std::sync::Mutex;\n\nfn main() {\n    let counter = Rc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Rc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n```\n\n----------------------------------------\n\nTITLE: Waiting for Thread Completion Using `JoinHandle` in Rust\nDESCRIPTION: This snippet shows how to use `JoinHandle` to wait for a spawned thread to complete its execution before the main thread exits. The `join` method blocks the current thread until the target thread finishes, ensuring that all operations within the spawned thread are completed. This prevents premature termination of the spawned thread.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch16-01-threads.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n\n    handle.join().unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Dereferencing a Box<T> in Rust\nDESCRIPTION: This example shows how to use the dereference operator with a `Box<T>` smart pointer in Rust. A `Box<T>` is created to hold an integer value, and the `*` operator is used to access the underlying value.  This illustrates the basic usage of dereferencing a boxed value.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = 5;\n    let y = Box::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n```\n\n----------------------------------------\n\nTITLE: Explicitly Dropping Sender - Rust\nDESCRIPTION: This code snippet modifies the `ThreadPool`'s `Drop` implementation to explicitly drop the `sender` before joining the worker threads. Dropping the sender closes the channel, signaling to the workers that no more jobs will be sent. This is achieved by wrapping the `sender` in an `Option` to allow it to be moved out of the `ThreadPool` using `Option::take`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-03-graceful-shutdown-and-cleanup.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch21-web-server/listing-21-23/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Define Rectangle struct with can_hold method in Rust\nDESCRIPTION: This code defines a Rectangle struct with width and height fields, and implements a can_hold method that checks if one rectangle can contain another based on their dimensions. The derive macro allows for debug printing of the struct.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn can_hold(&self, other: &Rectangle) -> bool {\n        self.width > other.width && self.height > other.height\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Enum Definition for Multiple Types in a Vector - Rust\nDESCRIPTION: This code defines an enum `SpreadsheetCell` with variants to hold integer, floating-point, and text values.  This allows a vector to store a mix of these different data types. The example shows how to create a vector of this enum type and push different values into it.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-01-vectors.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nenum SpreadsheetCell {\n    Int(i32),\n    Float(f64),\n    Text(String),\n}\n\nfn main() {\n    let row = vec![\n        SpreadsheetCell::Int(10),\n        SpreadsheetCell::Float(3.14),\n        SpreadsheetCell::Text(String::from(\"hello\")),\n    ];\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Value from Loop Rust\nDESCRIPTION: This code demonstrates how to return a value from a `loop` in Rust using the `break` keyword. The loop increments a counter until it reaches 10, then breaks and returns `counter * 2`. The returned value is assigned to the `result` variable.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_33\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut counter = 0;\n\n    let result = loop {\n        counter += 1;\n\n        if counter == 10 {\n            break counter * 2;\n        }\n    };\n\n    println!(\"The result is {result}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Match Guards to Patterns in Rust\nDESCRIPTION: This code demonstrates how to add an `if` condition, called a match guard, to a `match` arm. This allows for more complex pattern matching by adding conditional logic based on the matched value.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_31\n\nLANGUAGE: rust\nCODE:\n```\nlet num = Some(4);\n\nmatch num {\n    Some(x) if x % 2 == 0 => println!(\"The number {x} is even\"),\n    Some(x) => println!(\"The number {x} is odd\"),\n    None => (),\n}\n```\n\n----------------------------------------\n\nTITLE: Destructuring a Tuple\nDESCRIPTION: This code snippet demonstrates how to destructure a tuple in Rust using pattern matching with the `let` keyword. The tuple is split into individual variables, allowing access to each element.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-02-data-types.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet tup = (500, 6.4, 1);\n\nlet (x, y, z) = tup;\n\nprintln!(\"The value of y is: {}\", y);\n\n```\n\n----------------------------------------\n\nTITLE: While Let Loop with Result\nDESCRIPTION: This example demonstrates a `while let` loop that processes messages received from a channel. The loop continues as long as the `recv` method returns `Ok(value)`. Once the sender disconnects and `recv` returns `Err`, the loop terminates. This is a common pattern for handling asynchronous message processing.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-01-all-the-places-for-patterns.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let vals = vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\")];\n\n        for val in vals {\n            tx.send(val).unwrap();\n        }\n    });\n\n    while let Ok(received) = rx.recv() {\n        println!(\"Got: {}\", received);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Destructuring Structs in Rust\nDESCRIPTION: This code demonstrates destructuring a struct into separate variables using a `let` statement.  It extracts the `x` and `y` fields of a `Point` struct into variables `a` and `b` respectively.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 0, y: 7 };\n\nlet Point { x: a, y: b } = p;\nassert_eq!(0, a);\nassert_eq!(7, b);\n```\n\n----------------------------------------\n\nTITLE: Testing a Private Function in Rust\nDESCRIPTION: This code demonstrates how to test a private function in Rust using the `use super::*` statement to bring the parent module's items into scope. This allows tests within the `tests` module to access and test private functions.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-03-test-organization.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-12/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Defining a Module in front_of_house.rs (Rust)\nDESCRIPTION: This code snippet represents the contents of the `src/front_of_house.rs` file, which contains the definition of the `front_of_house` module.  It's assumed that the actual code of the module would go inside this file. This code snippet is part of demonstrating how to split modules into separate files.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-05-separating-modules-into-different-files.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Definitions inside the `front_of_house` module in *src/front_of_house.rs*\n```\n\n----------------------------------------\n\nTITLE: Overwriting Values in a HashMap - Rust\nDESCRIPTION: This code demonstrates how inserting a key with a new value overwrites the existing value associated with that key in the HashMap.  The HashMap will only store the most recently inserted value for each unique key.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_31\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Blue\"), 25);\n\nprintln!(\"{scores:?}\");\n```\n\n----------------------------------------\n\nTITLE: Defining an `area` method on the `Rectangle` struct in Rust\nDESCRIPTION: This code snippet defines a struct `Rectangle` with `width` and `height` fields. It then implements an `area` method on the `Rectangle` struct within an `impl` block. The `area` method takes an immutable reference to `self` and returns the area of the rectangle as a `u32`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-03-method-syntax.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        rect1.area()\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Match Enum Variants for Coin Values in Rust\nDESCRIPTION: This code defines an enum `Coin` with variants representing different US coins. The `value_in_cents` function uses a `match` expression to determine the value of a given `Coin` variant in cents. It demonstrates basic pattern matching with enum variants.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-02-match.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter => 25,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Trait Bounds with where Clauses\nDESCRIPTION: This code defines a function `some_function` with generic types `T` and `U`. It uses a `where` clause to specify that `T` must implement `Display` and `Clone`, and `U` must implement `Clone` and `Debug`. This approach enhances readability when dealing with numerous trait bounds.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_27\n\nLANGUAGE: Rust\nCODE:\n```\nfn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {\n```\n\n----------------------------------------\n\nTITLE: Mapping and Collecting Iterator Elements (Rust)\nDESCRIPTION: This code snippet demonstrates how to use the `map` iterator adapter to increment each element of the vector and then consume the resulting iterator using the `collect` method.  `collect` gathers the modified values into a new `Vec<i32>`.  The type of the collected vector `v2` is inferred from the context.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nlet v1: Vec<i32> = vec![1, 2, 3];\n\nlet v2: Vec<_> = v1.iter().map(|x| x + 1).collect();\n\nassert_eq!(v2, vec![2, 3, 4]);\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Vector Values (Immutable) - Rust\nDESCRIPTION: This code snippet demonstrates how to iterate over the elements of a vector using a `for` loop to access immutable references. Each element is then printed to the console.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet v = vec![100, 32, 57];\nfor i in &v {\n    println!(\"{i}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using FnMut Closure with sort_by_key\nDESCRIPTION: This example demonstrates the correct way to use a closure with `sort_by_key`. The closure captures a mutable reference to a counter and increments it each time it's called. This allows the closure to be called multiple times without moving any values out of its environment, satisfying the `FnMut` trait bound required by `sort_by_key`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-01-closures.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-09/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Modifying ThreadPool to hold Worker instances\nDESCRIPTION: This snippet modifies the `ThreadPool` struct to hold `Worker` instances instead of `JoinHandle<()>` instances. It also defines the `Worker` struct and its `new` function, which spawns a new thread with an empty closure.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-02-multithreaded.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\n\npub struct ThreadPool {\n    workers: Vec<Worker>,\n}\n\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id));\n        }\n\n        ThreadPool {\n            workers\n        }\n    }\n\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static\n    {\n\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: thread::JoinHandle<()>\n}\n\nimpl Worker {\n    fn new(id: usize) -> Worker {\n        let thread = thread::spawn(|| {});\n\n        Worker {\n            id,\n            thread,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Draw Trait for Button Struct in Rust\nDESCRIPTION: This snippet defines a `Button` struct with fields for `width`, `height`, and `label`, and implements the `Draw` trait for it. The `draw` method is defined, but its implementation is left empty as a placeholder for actual GUI drawing code.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-02-trait-objects.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nstruct Button {\n    width: u32,\n    height: u32,\n    label: String,\n}\n\nimpl Draw for Button {\n    fn draw(&self) {\n        // Code to actually draw a button would go here\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the Deref Trait for MyBox<T> in Rust\nDESCRIPTION: This example implements the `Deref` trait for the `MyBox<T>` type.  The `deref` method returns a reference to the inner value of `MyBox<T>`, enabling dereferencing using the `*` operator.  It imports the `Deref` trait and defines the associated type `Target`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops::Deref;\n\nimpl<T> Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Draw Trait in Rust\nDESCRIPTION: This code defines a trait named `Draw` with a single method `draw` that takes a mutable reference to self as an argument. This trait will be used to define common behavior for GUI components.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-02-trait-objects.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub trait Draw {\n    fn draw(&mut self);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Case-Insensitive Search Function in Rust\nDESCRIPTION: This Rust code implements the `search_case_insensitive` function, which performs a case-insensitive search within a given text. It converts both the query and the lines to lowercase before comparing them, ensuring that the search is insensitive to casing.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-05-working-with-environment-variables.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-21/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Add Content Method to State Trait in Rust\nDESCRIPTION: This snippet demonstrates adding the `content` method to the `State` trait. A default implementation is provided, returning an empty string slice. The `Published` struct overrides this method to return the actual content of the post. Lifetime annotations are used to relate the lifetime of the returned reference to the lifetime of the `post` argument.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-03-oo-design-patterns.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\ntrait State {\n    fn request_review(self: Box<Self>) -> Box<dyn State>;\n    fn approve(self: Box<Self>) -> Box<dyn State>;\n    fn content<'a>(&self, post: &'a Post) -> &'a str {\n        \"\"\n    }\n}\n\nstruct Draft {}\n\nimpl State for Draft {\n    fn request_review(self: Box<Self>) -> Box<dyn State> {\n        Box::new(PendingReview {})\n    }\n\n    fn approve(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n}\n\nstruct PendingReview {}\n\nimpl State for PendingReview {\n    fn request_review(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n\n    fn approve(self: Box<Self>) -> Box<dyn State> {\n        Box::new(Published {})\n    }\n}\n\nstruct Published {}\n\nimpl State for Published {\n    fn request_review(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n\n    fn approve(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n\n    fn content<'a>(&self, post: &'a Post) -> &'a str {\n        &post.content\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Multiple Trait Bounds with + Syntax in Rust\nDESCRIPTION: Demonstrates specifying multiple trait bounds using the `+` syntax.  The `notify` function now requires the `item` parameter to implement both the `Summary` and `Display` traits, allowing usage of both `summarize` method and display formatting on `item`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-02-traits.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\npub fn notify(item: &(impl Summary + Display)) {\n```\n\nLANGUAGE: rust\nCODE:\n```\npub fn notify<T: Summary + Display>(item: &T) {\n```\n\n----------------------------------------\n\nTITLE: Mutable Data with Rc and RefCell\nDESCRIPTION: This code snippet showcases the combination of Rc<T> and RefCell<T> to enable multiple ownership of mutable data. It defines a List enum using Rc<RefCell<i32>> to create a shared, mutable list structure. The example demonstrates how to modify the shared data through borrow_mut.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nenum List {\n    Cons(Rc<RefCell<i32>>, Rc<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nfn main() {\n    let value = Rc::new(RefCell::new(5));\n\n    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));\n\n    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));\n    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));\n\n    *value.borrow_mut() += 10;\n\n    println!(\"a after = {a:?}\");\n    println!(\"b after = {b:?}\");\n    println!(\"c after = {c:?}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using Arc<T> and Mutex<T> for Thread-Safe Counter in Rust\nDESCRIPTION: This code demonstrates how to use `Arc<T>` to wrap a `Mutex<T>` in order to share ownership across multiple threads. Each thread acquires a lock on the mutex, increments the counter, and then releases the lock. `Arc::clone` is used to create multiple owners of the shared data.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch16-03-shared-state.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Arc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Failure Message with assert! and Bug in Rust\nDESCRIPTION: This snippet shows how a custom failure message helps debug a bug in the `greeting` function. When the function is changed to always return \"Hello!\", the test fails, and the custom message displays the actual value, helping identify the problem. Dependencies: None. Inputs: String `name`. Outputs: Always the string `Hello!`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\npub fn greeting(name: &str) -> String {\n    String::from(\"Hello!\")\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n    #[test]\n    fn greeting_contains_name() {\n        let result = greeting(\"Carol\");\n        assert!(\n            result.contains(\"Carol\"),\n            \"Greeting did not contain name, value was `{result}`\"\n        );\n    }\n```\n\n----------------------------------------\n\nTITLE: Integration Test in Rust\nDESCRIPTION: This is an example of an integration test in Rust, located in the `tests` directory. It imports the library being tested and uses its public API to verify that different parts of the library work together correctly.  It uses `use adder::add_two;` to bring the `add_two` function from the `adder` crate into scope.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-03-test-organization.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-13/tests/integration_test.rs}}\n```\n\n----------------------------------------\n\nTITLE: Improved First Word Function with &str Parameter\nDESCRIPTION: This improved `first_word` function takes a string slice (&str) as input, making it more flexible. It can now accept both &String and &str values, due to deref coercions.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_32\n\nLANGUAGE: Rust\nCODE:\n```\nfn first_word(s: &str) -> &str {\n```\n\n----------------------------------------\n\nTITLE: Using Nested Paths in `use` Statements in Rust\nDESCRIPTION: This code snippet demonstrates using nested paths within a `use` statement to bring multiple items with the same prefix into scope. It provides a more concise way to import related items.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{cmp::Ordering, io};\n```\n\n----------------------------------------\n\nTITLE: HashMap Ownership and Move Semantics - Rust\nDESCRIPTION: This example illustrates how ownership works when inserting values into a HashMap. When owned values like `String` are inserted, they are moved into the HashMap, and the original variables become invalid.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_30\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::collections::HashMap;\n\nlet field_name = String::from(\"Favorite color\");\nlet field_value = String::from(\"Blue\");\n\nlet mut map = HashMap::new();\nmap.insert(field_name, field_value);\n// field_name and field_value are invalid at this point, try using them and\n// see what compiler error you get!\n```\n\n----------------------------------------\n\nTITLE: Awaiting Multiple Futures with `join!` in Rust\nDESCRIPTION: This snippet demonstrates how to use the `join!` macro to concurrently await multiple futures. The `join!` macro can accept a variable number of futures, simplifying the code compared to using `join3`, `join4`, etc. It handles the awaiting of futures itself.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-03-more-futures.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[tokio::main]\nasync fn main() {\n    let (mut tx1, rx1) = tokio::sync::mpsc::channel::<i32>(100);\n    let (tx2, mut rx2) = tokio::sync::mpsc::channel::<i32>(100);\n\n    tokio::spawn(async move {\n        let mut i = 0;\n        loop {\n            // Maybe the receiver dropped\n            if tx1.send(i).await.is_err() {\n                break;\n            }\n            i += 1;\n        }\n    });\n\n    tokio::spawn(async move {\n        loop {\n            tokio::select! {\n                v1 = rx1.recv() => {\n                    println!(\"Got {:?} from tx1\", v1);\n                },\n                v2 = rx2.recv() => {\n                    println!(\"Got {:?} from tx2\", v2);\n                }\n                else => {\n                    println!(\"Both channels are closed\");\n                    return;\n                }\n            }\n        }\n    });\n\n    // Close the tx2 channel so the select! in the second task\n    // will exit.\n    drop(tx2);\n\n    tokio::time::sleep(std::time::Duration::from_secs(1)).await;\n}\n```\n\n----------------------------------------\n\nTITLE: Request Review State Transition in Rust\nDESCRIPTION: This code snippet demonstrates how to implement the `request_review` method on the `Post` struct and the `State` trait to change the state of a post from `Draft` to `PendingReview`. It includes defining the `State` trait with a `request_review` method and implementing it for the `Draft` and `PendingReview` structs. The `request_review` method consumes the current state and returns a new state.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-03-oo-design-patterns.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\ntrait State {\n    fn request_review(self: Box<Self>) -> Box<dyn State>;\n    fn approve(self: Box<Self>) -> Box<dyn State>;\n    fn content<'a>(&self, post: &'a Post) -> &'a str {\n        \"\"\n    }\n}\n\nstruct Draft {}\n\nimpl State for Draft {\n    fn request_review(self: Box<Self>) -> Box<dyn State> {\n        Box::new(PendingReview {})\n    }\n\n    fn approve(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n}\n\nstruct PendingReview {}\n\nimpl State for PendingReview {\n    fn request_review(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n\n    fn approve(self: Box<Self>) -> Box<dyn State> {\n        Box::new(Published {})\n    }\n}\n\nstruct Published {}\n\nimpl State for Published {\n    fn request_review(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n\n    fn approve(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n\n    fn content<'a>(&self, post: &'a Post) -> &'a str {\n        &post.content\n    }\n}\n\npub struct Post {\n    state: Option<Box<dyn State>>,\n    content: String,\n}\n\nimpl Post {\n    pub fn new() -> Post {\n        Post {\n            state: Some(Box::new(Draft {})),\n            content: String::new(),\n        }\n    }\n\n    pub fn add_text(&mut self, text: &str) {\n        self.content.push_str(text);\n    }\n\n    pub fn content(&self) -> &str {\n        self.state.as_ref().unwrap().content(self)\n    }\n\n    pub fn request_review(&mut self) {\n        if let Some(s) = self.state.take() {\n            self.state = Some(s.request_review())\n        }\n    }\n\n    pub fn approve(&mut self) {\n        if let Some(s) = self.state.take() {\n            self.state = Some(s.approve())\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implement ThreadPool::new - Rust\nDESCRIPTION: This code implements the `new` associated function for the `ThreadPool` struct.  It takes a `size` parameter of type `usize` representing the number of threads in the pool and returns a `ThreadPool` instance. This version does not handle any actual thread creation.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\npub struct ThreadPool;\n\nimpl ThreadPool {\n    pub fn new(size: usize) -> ThreadPool {\n        ThreadPool\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Hash Map Ownership: String Keys and Values\nDESCRIPTION: This code shows that HashMap takes ownership of String keys and values.  After the `insert` call, `field_name` and `field_value` cannot be used because their values have been moved into the HashMap.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-03-hash-maps.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::HashMap;\n\nfn main() {\n    let field_name = String::from(\"Favorite color\");\n    let field_value = String::from(\"Blue\");\n\n    let mut map = HashMap::new();\n    map.insert(field_name, field_value);\n    // field_name and field_value are invalid at this point, try using them and\n    // see what compiler error you get!\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Multiple Messages - Rust\nDESCRIPTION: This snippet demonstrates sending multiple messages from a spawned thread to the main thread using a channel. It iterates over a vector of strings, sending each message and pausing for one second between each send operation. It uses the std::time::Duration struct, and the std::thread::sleep function for pausing the execution.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch16-02-message-passing.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\nuse std::sync::mpsc;\nuse std::time::Duration;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!(\"Got: {}\", received);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enum with Varying Data Types in Rust\nDESCRIPTION: This snippet defines a `Message` enum with different variant types: `Quit` (no data), `Move` (named fields), `Write` (String), and `ChangeColor` (three i32 values). It showcases the flexibility of enums to represent diverse data structures.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n```\n\n----------------------------------------\n\nTITLE: Function with Parameter and Return Value in Rust\nDESCRIPTION: This code defines a function `plus_one` that takes an integer `x` as a parameter and returns `x + 1`. The return type is specified as `-> i32`. The main function calls `plus_one` with the argument `5` and assigns the returned value to the variable `x`, then prints the value of `x`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-03-how-functions-work.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nfn main() {\n    let x = plus_one(5);\n\n    println!(\"The value of x is: {}\", x);\n}\n```\n\n----------------------------------------\n\nTITLE: Requesting Review of a Post - Rust\nDESCRIPTION: This code snippet demonstrates how to add functionality to request a review of a post, changing its state from `Draft` to `PendingReview`. It defines the `Post` struct's `request_review` method and the `State` trait with a `request_review` method. The `Draft` and `PendingReview` structs implement the `State` trait, defining their respective behaviors when a review is requested.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter18.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nimpl Post {\n    // --snip--\n    pub fn request_review(&mut self) {\n        if let Some(s) = self.state.take() {\n            self.state = Some(s.request_review())\n        }\n    }\n}\n\ntrait State {\n    fn request_review(self: Box<Self>) -> Box<dyn State>;\n}\n\nstruct Draft {}\n\nimpl State for Draft {\n    fn request_review(self: Box<Self>) -> Box<dyn State> {\n        Box::new(PendingReview {})\n    }\n}\n\nstruct PendingReview {}\n\nimpl State for PendingReview {\n    fn request_review(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning a String in Rust\nDESCRIPTION: This code demonstrates how to create a deep copy of a `String` using the `clone` method. The `clone` method allocates new heap memory and copies the string data, allowing both the original and cloned strings to be independently modified.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\nlet s1 = String::from(\"hello\");\nlet s2 = s1.clone();\n\nprintln!(\"s1 = {s1}, s2 = {s2}\");\n```\n\n----------------------------------------\n\nTITLE: Trait Bounds with where Clauses in Rust\nDESCRIPTION: Demonstrates using a `where` clause to specify trait bounds.  This makes the function signature less cluttered, especially when dealing with multiple generic type parameters and associated trait bounds.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-02-traits.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {\n```\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-07-where-clause/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Matching Coin Enum with `if let` and `else` in Rust\nDESCRIPTION: This snippet demonstrates matching a `Coin` enum with a `UsState` value in the `Quarter` variant using `if let` and `else`.  It counts non-quarter coins and announces the state of the quarters, providing an alternative to the `match` expression.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-03-if-let.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nenum UsState {\n    Alabama,\n    Alaska,\n    // --snip--\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n}\n\nfn main() {\n    let mut count = 0;\n    let coin = Coin::Quarter(UsState::Alabama);\n    if let Coin::Quarter(state) = coin {\n        println!(\"State quarter from {:?}!\", state);\n    } else {\n        count += 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Trait and its Implementation in Rust\nDESCRIPTION: This code demonstrates how to use a trait (`Summary`) and its implementation. It creates an instance of the `Tweet` struct, calls the `summarize` method (inherited from the `Summary` trait implementation), and prints the result. The `use aggregator::{Summary, Tweet};` line brings the trait and the struct into scope.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nuse aggregator::{Summary, Tweet};\n\nfn main() {\n    let tweet = Tweet {\n        username: String::from(\"horse_ebooks\"),\n        content: String::from(\n            \"of course, as you probably already know, people\",\n        ),\n        reply: false,\n        retweet: false,\n    };\n\n    println!(\"1 new tweet: {}\", tweet.summarize());\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Types That Implement Traits in Rust\nDESCRIPTION: Demonstrates using `impl Trait` in the return position to return a value of some type that implements a trait. The calling code only knows that the returned value implements the specified trait (`Summary` in this case), without knowing the concrete type.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-02-traits.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-05-returning-impl-trait/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Filtering Shoes by Size Using a Closure in Rust\nDESCRIPTION: This code defines a `Shoe` struct and a `shoes_in_size` function that filters a vector of `Shoe` instances to return only the shoes that match a specified size. The `filter` method is used with a closure that captures the `shoe_size` from its environment.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-02-iterators.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nstruct Shoe {\n    size: u32,\n    style: String,\n}\n\nfn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {\n    shoes.into_iter().filter(|s| s.size == shoe_size).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn filters_by_size() {\n        let shoes = vec![\n            Shoe { size: 10, style: String::from(\"sneaker\") },\n            Shoe { size: 13, style: String::from(\"sandal\") },\n            Shoe { size: 10, style: String::from(\"boot\") },\n        ];\n\n        let in_my_size = shoes_in_size(shoes, 10);\n\n        assert_eq!(in_my_size.len(), 2);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Associated Function Example: Square Constructor in Rust\nDESCRIPTION: This code defines an associated function `square` for the `Rectangle` struct, which acts as a constructor for creating square rectangles. It takes a single dimension parameter and uses that for both width and height.  The `Self` keyword is used as an alias for the `Rectangle` type. This makes it easier to create a square Rectangle by only specifying one dimension.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-03-method-syntax.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn square(size: u32) -> Self {\n        Self {\n            width: size,\n            height: size,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example `add` function in _src/lib.rs_\nDESCRIPTION: This code snippet shows a basic Rust function `add` that takes two `i32` integers as input and returns their sum.  It's the starting point for writing tests to verify its correctness.  The snippet uses `rustdoc_include` to include the code from an external file.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-01-writing-tests.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-01/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Defining Module in Separate File - Rust\nDESCRIPTION: This code snippet shows the content of the *src/front_of_house.rs* file, which defines the `front_of_house` module's body. It contains a public module named `hosting` with a public function `add_to_waitlist`.  This file is automatically associated with the `front_of_house` module declaration in the crate root file.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\npub mod hosting {\n    pub fn add_to_waitlist() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Avoiding Heap Allocations with `Pin` and `pin!` in Rust\nDESCRIPTION: This code snippet shows how to avoid unnecessary heap allocations by using the `pin!` macro directly with each future, combined with `Pin` to pin mutable references. This provides the benefit of a single type in the `Vec` without needing to allocate futures on the heap. This optimization improves performance.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-03-more-futures.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch17-async-await/listing-17-19/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Updating a Vector Using the push Method in Rust\nDESCRIPTION: This snippet demonstrates how to add elements to an existing vector using the `push` method. The vector must be declared as mutable (`mut`) to allow modification. The `push` method appends the specified value to the end of the vector. Type inference is used here, and no explicit type annotation is needed.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-01-vectors.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut v = vec![1, 2, 3];\n\n    v.push(5);\n    v.push(6);\n}\n```\n\n----------------------------------------\n\nTITLE: Type Inference in Closures (Error)\nDESCRIPTION: This snippet demonstrates type inference in closures and the resulting type error when attempting to call a closure with different types after the initial type is inferred. The compiler infers the type based on the first usage and enforces it for subsequent calls.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-01-closures.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-03/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Creating Enum Instances in Rust\nDESCRIPTION: This code creates two instances of the `IpAddrKind` enum: `IpAddrKind::V4` and `IpAddrKind::V6`. It shows how to create instances of enum variants using the double colon `::` syntax.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-01-defining-an-enum.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet four = IpAddrKind::V4;\nlet six = IpAddrKind::V6;\n```\n\n----------------------------------------\n\nTITLE: Function Compiled Without Lifetime Annotations (Listing 4-9/10-25)\nDESCRIPTION: This code shows a function `first_word` that compiles without explicit lifetime annotations due to lifetime elision rules.  The function takes a string slice as input and returns a string slice.  The compiler infers the lifetimes based on the elision rules.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-03-lifetime-syntax.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nfn first_word(s: &str) -> &str {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &s[0..i];\n        }\n    }\n\n    &s[..]\n}\n```\n\n----------------------------------------\n\nTITLE: Summary Trait with Default Implementation Calling Other Methods\nDESCRIPTION: This code defines a `Summary` trait with a `summarize` method that has a default implementation, and calls another method, `summarize_author`, which doesn't have a default implementation. This forces any type implementing the trait to implement `summarize_author`, but allows the default `summarize` method to use it.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-02-traits.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub trait Summary {\n    fn summarize_author(&self) -> String;\n\n    fn summarize(&self) -> String {\n        format!(\"(Read more from {}...)\", self.summarize_author())\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Character to a String with push() in Rust\nDESCRIPTION: Shows how to add a single character to a `String` using the `push()` method.  The `push()` method takes a `char` as input and appends it to the end of the `String`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-02-strings.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet mut s = String::from(\"lo\");\ns.push('l');\n```\n\n----------------------------------------\n\nTITLE: Numeric Operations Rust\nDESCRIPTION: Illustrates basic mathematical operations in Rust, including addition, subtraction, multiplication, division, and remainder.  It shows how to perform these operations using the `let` statement and assign the results to variables.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // addition\n    let sum = 5 + 10;\n\n    // subtraction\n    let difference = 95.5 - 4.3;\n\n    // multiplication\n    let product = 4 * 30;\n\n    // division\n    let quotient = 56.7 / 32.2;\n    let truncated = -5 / 3; // Results in -1\n\n    // remainder\n    let remainder = 43 % 5;\n}\n```\n\n----------------------------------------\n\nTITLE: Audio Decoder: Linear Prediction Calculation in Rust\nDESCRIPTION: This Rust code snippet demonstrates a linear prediction calculation used in an audio decoder. It iterates through coefficients, pairs them with previous buffer values, performs multiplication and summation, and applies a bit shift. It showcases how Rust translates high-level iterator chains into efficient low-level code, often without runtime performance overhead.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-04-performance.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet buffer: &mut [i32];\nlet coefficients: [i64; 12];\nlet qlp_shift: i16;\n\nfor i in 12..buffer.len() {\n    let prediction = coefficients.iter()\n                                 .zip(&buffer[i - 12..i])\n                                 .map(|(&c, &s)| c * s as i64)\n                                 .sum::<i64>() >> qlp_shift;\n    let delta = buffer[i];\n    buffer[i] = prediction as i32 + delta;\n}\n```\n\n----------------------------------------\n\nTITLE: Returning a closure from a function using impl Trait in Rust\nDESCRIPTION: This snippet demonstrates how to return a closure from a function using the `impl Trait` syntax. The `returns_closure` function returns a closure that takes an `i32` and returns an `i32`.  The `impl Fn(i32) -> i32` syntax allows returning a closure without specifying its concrete type.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-04-advanced-functions-and-closures.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn returns_closure() -> impl Fn(i32) -> i32 {\n    |x| x + 1\n}\n```\n\n----------------------------------------\n\nTITLE: Re-exporting Items with `pub use` in Rust\nDESCRIPTION: This snippet demonstrates how to re-export items from the `kinds` and `utils` modules to the top level of the `art` crate using `pub use`. This allows users to access the items without needing to specify the internal module structure.  `self::` is used to specify that the module is in the current crate.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n//! # Art\n//!\n//! A library for modeling artistic concepts.\n\npub use self::kinds::PrimaryColor;\npub use self::kinds::SecondaryColor;\npub use self::utils::mix;\n\npub mod kinds {\n    // --snip--\n}\n\npub mod utils {\n    // --snip--\n}\n```\n\n----------------------------------------\n\nTITLE: Returning a Value from a Function in Rust\nDESCRIPTION: This code defines a function `five` that takes no parameters and returns the integer value `5`. The return type is specified as `-> i32`. The main function calls `five` and assigns the returned value to the variable `x`, then prints the value of `x`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-03-how-functions-work.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn five() -> i32 {\n    5\n}\n\nfn main() {\n    let x = five();\n\n    println!(\"The value of x is: {}\", x);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Async Channel\nDESCRIPTION: This snippet creates an asynchronous channel using `trpl::channel`, sends a string message, and receives it. It demonstrates the basic usage of the channel API with `tx.send` and `rx.recv().await`. The `recv` call is awaited to retrieve the message asynchronously.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nlet (tx, mut rx) = trpl::channel();\n\nlet val = String::from(\"hi\");\ntx.send(val).unwrap();\n\nlet received = rx.recv().await.unwrap();\nprintln!(\"Got: {received}\");\n```\n\n----------------------------------------\n\nTITLE: Storing i32 on the Heap with Box in Rust\nDESCRIPTION: This code demonstrates how to use a Box to store an i32 value on the heap. The variable `b` is defined as a `Box<i32>`, which points to the value `5` allocated on the heap. When `b` goes out of scope, both the box and the heap-allocated value are deallocated.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-01-box.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let b = Box::new(5);\n    println!(\"b = {}\", b);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Cons List with RefCell for Modification in Rust\nDESCRIPTION: This code defines a `List` enum with a `Cons` variant that holds a `RefCell<Rc<List>>`, allowing modification of the `List` value a `Cons` variant points to. It also includes a `tail` method for accessing the second item of a `Cons` variant.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-06-reference-cycles.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nenum List {\n    Cons(i32, RefCell<Rc<List>>),\n    Nil,\n}\n\nimpl List {\n    fn tail(&self) -> Option<&RefCell<Rc<List>>> {\n        match self {\n            Cons(_, item) => Some(item),\n            Nil => None,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Writing a Basic HTTP Response in Rust\nDESCRIPTION: This Rust code generates a simple HTTP 200 OK response and writes it to the TCP stream. The response is hardcoded and includes the HTTP version, status code, reason phrase, and two CRLF sequences to indicate the end of the headers and the absence of a body. It converts the string response into bytes before sending it over the stream.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-01-single-threaded.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::io::prelude::*;\nuse std::net::TcpStream;\n\nfn handle_connection(mut stream: TcpStream) {\n    let response = \"HTTP/1.1 200 OK\\r\\n\\r\\n\";\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Combining `use` Statements with `self` in Rust\nDESCRIPTION: This example demonstrates how to combine two `use` statements that share a subpath into a single `use` statement using the `self` keyword. This allows importing both the module and a specific item from that module in one line.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nuse std::io::{self, Write};\n```\n\n----------------------------------------\n\nTITLE: Attempting to Dereference `MyBox<T>` without `Deref` Trait\nDESCRIPTION: Illustrates the error that occurs when attempting to dereference the custom smart pointer `MyBox<T>` without implementing the `Deref` trait. This demonstrates that the dereference operator (*) is not automatically implemented for custom types.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-02-deref.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyBox<T>(T);\n\nimpl<T> MyBox<T> {\n    fn new(x: T) -> MyBox<T> {\n        MyBox(x)\n    }\n}\n\nfn main() {\n    let x = 5;\n    let y = MyBox::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y); // This line will cause a compile error\n}\n```\n\n----------------------------------------\n\nTITLE: Convert String to Bytes for Iteration\nDESCRIPTION: This Rust code snippet demonstrates how to convert a `String` to a byte array using the `as_bytes` method. This is a prerequisite step for iterating through the string byte by byte to identify characters or patterns.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-03-slices.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:as_bytes}}\n```\n\n----------------------------------------\n\nTITLE: Defining Messenger trait and LimitTracker struct in Rust\nDESCRIPTION: This Rust code defines a `Messenger` trait with a `send` method that takes an immutable reference to self and a message. It also defines a `LimitTracker` struct that tracks a value against a maximum value and sends messages via a `Messenger` when the value reaches certain thresholds.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-05-interior-mutability.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Messenger {\n    fn send(&self, msg: &str);\n}\n\nstruct LimitTracker<'a, T: Messenger> {\n    messenger: &'a T,\n    value: usize,\n    max: usize,\n}\n\nimpl<'a, T> LimitTracker<'a, T>\nwhere\n    T: Messenger,\n{\n    pub fn new(messenger: &'a T, max: usize) -> LimitTracker<'a, T> {\n        LimitTracker {\n            messenger,\n            value: 0,\n            max,\n        }\n    }\n\n    pub fn set_value(&mut self, value: usize) {\n        self.value = value;\n\n        let percentage_of_max = self.value as f64 / self.max as f64;\n\n        if percentage_of_max >= 1.0 {\n            self.messenger.send(\"Error: You are over your quota!\");\n        } else if percentage_of_max >= 0.9 {\n            self.messenger\n                .send(\"Urgent warning: You've used over 90% of your quota!\");\n        } else if percentage_of_max >= 0.75 {\n            self.messenger\n                .send(\"Warning: You've used over 75% of your quota!\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Type Alias for Result in std::io in Rust\nDESCRIPTION: This snippet defines a type alias `Result<T>` in the `std::io` module. This alias represents `Result<T, E>` where `E` is fixed as `std::io::Error`, reducing repetition and providing a consistent interface for I/O operations.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-03-advanced-types.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\npub type Result<T> = std::result::Result<T, Error>;\n```\n\n----------------------------------------\n\nTITLE: Defining a Stream trait in Rust\nDESCRIPTION: This snippet demonstrates how to define a Stream trait in Rust, which is similar to an asynchronous iterator. It includes an associated type Item and a poll_next method for retrieving items from the stream.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-05-traits-for-async.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\n\ntrait Stream {\n    type Item;\n\n    fn poll_next(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>\n    ) -> Poll<Option<Self::Item>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Failure with expect - Rust\nDESCRIPTION: This snippet demonstrates how to use the `expect` method to handle potential errors when reading a line from standard input. If an error occurs, the program will crash and display the specified message.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter02.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n        .expect(\"Failed to read line\");\n```\n\n----------------------------------------\n\nTITLE: Implementing the run Method on the Screen Struct in Rust\nDESCRIPTION: This code implements the `run` method on the `Screen` struct.  The method iterates through the `components` vector and calls the `draw` method on each component, leveraging the trait object to call the appropriate `draw` implementation at runtime.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter18.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nimpl Screen {\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Listening for TCP Streams\nDESCRIPTION: This Rust code snippet creates a TCP listener that binds to the address `127.0.0.1:7878`.  It then iterates over incoming TCP streams, printing \"Connection established!\" for each successful connection. The `unwrap()` method is used for error handling, which will terminate the program if an error occurs while binding or handling the stream.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-01-single-threaded.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::net::TcpListener;\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        println!(\"Connection established!\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using `move` to Transfer Ownership to a Thread in Rust\nDESCRIPTION: This code demonstrates using the `move` keyword with a closure passed to `thread::spawn`.  The `move` keyword forces the closure to take ownership of the captured variable `v`, ensuring that the spawned thread has a valid copy of the data, regardless of what happens in the main thread. This avoids borrowing issues.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter16.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n\n    let handle = thread::spawn(move || {\n        println!(\"Here's a vector: {v:?}\");\n    });\n\n    handle.join().unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Search Function to Compile Rust\nDESCRIPTION: This code defines a basic `search` function that takes a query string and text content as input. It's designed to satisfy the compiler's requirements for the failing test.  The function includes lifetime annotations to specify that the returned vector contains string slices referencing the `contents` argument. It always returns an empty vector, causing the test to fail.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-04-testing-the-librarys-functionality.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-16/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Match Enum and Extract Data in Rust\nDESCRIPTION: This example shows how to extract data from an enum variant using match.  The `Coin::Quarter` variant contains a `UsState`. The match arm `Coin::Quarter(state)` binds the `state` variable to the `UsState` value contained in the `Coin::Quarter` variant.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter(state) => {\n            println!(\"State quarter from {state:?}!\");\n            25\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Slicing Strings in Rust\nDESCRIPTION: This code demonstrates how to create a string slice using a range, extracting a portion of a UTF-8 encoded string. It highlights the importance of slicing at character boundaries to avoid runtime panics.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_24\n\nLANGUAGE: Rust\nCODE:\n```\nlet hello = \"\";\n\nlet s = &hello[0..4];\n```\n\n----------------------------------------\n\nTITLE: Declaring a Submodule in front_of_house.rs (Rust)\nDESCRIPTION: This code snippet shows how to declare the `hosting` submodule within the `front_of_house` module in the `src/front_of_house.rs` file.  It specifies that the `hosting` module's implementation will be located in a separate file, typically `src/front_of_house/hosting.rs`. This is a crucial step in organizing code into submodules.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-05-separating-modules-into-different-files.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nmod hosting;\n```\n\n----------------------------------------\n\nTITLE: Creating nodes with weak references in Rust\nDESCRIPTION: Creates a leaf and branch node, establishes a parent-child relationship by cloning the leaf's Rc pointer into the branch's children vector, and then downgrades the branch's Rc pointer to a Weak pointer in the leaf's parent field, printing the leaf's parent to demonstrate the weak reference.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_26\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n\n    let branch = Rc::new(Node {\n        value: 5,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![Rc::clone(&leaf)]),\n    });\n\n    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n}\n```\n\n----------------------------------------\n\nTITLE: Moving Config and run into src/lib.rs in Rust\nDESCRIPTION: This snippet shows moving the `Config` struct and `run` function from `src/main.rs` to `src/lib.rs` to create a library crate. The `pub` keyword is used to make the necessary components publicly accessible, enabling testing and modularity.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-03-improving-error-handling-and-modularity.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-13/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Empty String - Rust\nDESCRIPTION: This snippet shows how to create a new, empty `String` using the `String::new()` constructor. The string `s` is mutable and can be appended to later.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nlet mut s = String::new();\n```\n\n----------------------------------------\n\nTITLE: Joining Thread Early in Rust\nDESCRIPTION: This snippet demonstrates how placing the `join` call before the main thread's loop affects the order of execution. By calling `join` early, the main thread waits for the spawned thread to finish entirely before executing its own loop, resulting in non-interleaved output.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch16-01-threads.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    handle.join().unwrap();\n\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating String Length Using References in Rust\nDESCRIPTION: This Rust code demonstrates calculating the length of a string using references instead of taking ownership.  The `calculate_length` function takes a reference to a `String` and returns its length without taking ownership of the `String` data.  This allows the `String` to be used after the function call.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{s1}' is {len}.\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\n----------------------------------------\n\nTITLE: Implement Approve Method for State Transition in Rust\nDESCRIPTION: This snippet illustrates the implementation of the `approve` method on the `Post` struct and `State` trait to transition a post from `PendingReview` to `Published`. It defines the `approve` method within the `State` trait and provides implementations for the `Draft` and `PendingReview` structs.  The `approve` method consumes the current state and returns a new, appropriate state.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-03-oo-design-patterns.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\ntrait State {\n    fn request_review(self: Box<Self>) -> Box<dyn State>;\n    fn approve(self: Box<Self>) -> Box<dyn State>;\n    fn content<'a>(&self, post: &'a Post) -> &'a str {\n        \"\"\n    }\n}\n\nstruct Draft {}\n\nimpl State for Draft {\n    fn request_review(self: Box<Self>) -> Box<dyn State> {\n        Box::new(PendingReview {})\n    }\n\n    fn approve(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n}\n\nstruct PendingReview {}\n\nimpl State for PendingReview {\n    fn request_review(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n\n    fn approve(self: Box<Self>) -> Box<dyn State> {\n        Box::new(Published {})\n    }\n}\n\nstruct Published {}\n\nimpl State for Published {\n    fn request_review(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n\n    fn approve(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n\n    fn content<'a>(&self, post: &'a Post) -> &'a str {\n        &post.content\n    }\n}\n\npub struct Post {\n    state: Option<Box<dyn State>>,\n    content: String,\n}\n\nimpl Post {\n    pub fn new() -> Post {\n        Post {\n            state: Some(Box::new(Draft {})),\n            content: String::new(),\n        }\n    }\n\n    pub fn add_text(&mut self, text: &str) {\n        self.content.push_str(text);\n    }\n\n    pub fn content(&self) -> &str {\n        self.state.as_ref().unwrap().content(self)\n    }\n\n    pub fn request_review(&mut self) {\n        if let Some(s) = self.state.take() {\n            self.state = Some(s.request_review())\n        }\n    }\n\n    pub fn approve(&mut self) {\n        if let Some(s) = self.state.take() {\n            self.state = Some(s.approve())\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: String Slice Initialization with Range Syntax\nDESCRIPTION: This snippet illustrates how to use Rust's range syntax (..) to initialize string slices. It showcases the flexibility of omitting the starting index (defaults to 0) or the ending index (defaults to the end of the string).\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_26\n\nLANGUAGE: Rust\nCODE:\n```\nlet s = String::from(\"hello\");\n\nlet slice = &s[0..2];\nlet slice = &s[..2];\n```\n\n----------------------------------------\n\nTITLE: Using Library Crate in Main - Rust\nDESCRIPTION: This code imports the `Config` struct from the `minigrep` library crate into the `src/main.rs` file, allowing the main function to use the `Config` struct and the `run` function from the library. It also demonstrates calling the `run` function using the library's namespace.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nuse std::env;\nuse std::process;\n\nuse minigrep::Config;\n\nfn main() {\n    // --snip--\n    if let Err(e) = minigrep::run(config) {\n        // --snip--\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Struct Instance in Rust\nDESCRIPTION: This code creates an instance of the `User` struct, initializing its fields with specific values. It demonstrates how to instantiate a struct with concrete data.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let user1 = User {\n        active: true,\n        username: String::from(\"someusername123\"),\n        email: String::from(\"someone@example.com\"),\n        sign_in_count: 1,\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring and calling an `extern` function in Rust\nDESCRIPTION: This code shows how to declare and call an `extern` function (abs from the C standard library) in Rust.  `extern` blocks are unsafe because Rust cannot guarantee the safety of foreign code.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-01-unsafe-rust.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nextern \"C\" {\n    fn abs(input: i32) -> i32;\n}\n\nfn main() {\n    unsafe {\n        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom `Guess` Type with Validation - Rust\nDESCRIPTION: This code defines a custom struct `Guess` that encapsulates an `i32` value and provides a `new` associated function to create instances of the struct. The `new` function validates that the input value is within the range of 1 to 100, panicking if it's outside the range. It also implements a getter method `value` to access the validated value. Dependencies: None. Input: Integer value. Output: `Guess` instance if value is valid or panic if the value is invalid.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter09.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\npub struct Guess {\n    value: i32,\n}\n\nimpl Guess {\n    pub fn new(value: i32) -> Guess {\n        if value < 1 || value > 100 {\n            panic!(\"Guess value must be between 1 and 100, got {value}.\");\n        }\n\n        Guess { value }\n    }\n\n    pub fn value(&self) -> i32 {\n        self.value\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Patterns with Match Guard Rust\nDESCRIPTION: This example demonstrates combining multiple patterns with the `|` operator and a match guard. The match guard condition applies to all the patterns, meaning the arm only matches if the value of `x` is equal to `4`, `5`, or `6` _and_ if `y` is `true`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = 4;\n    let y = false;\n\n    match x {\n        4 | 5 | 6 if y => println!(\"yes\"),\n        _ => println!(\"no\"),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Appending a String Slice to a String with push_str() in Rust\nDESCRIPTION: Demonstrates how to append a string slice (`&str`) to an existing `String` using the `push_str()` method. This method modifies the `String` in place and takes a string slice to avoid taking ownership of the appended data.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-02-strings.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet mut s = String::from(\"foo\");\ns.push_str(\"bar\");\n```\n\n----------------------------------------\n\nTITLE: Worker Thread Job Receiving and Execution in Rust\nDESCRIPTION: This snippet implements the `Worker::new` function, which spawns a thread that continuously receives jobs from a channel, executes them, and handles potential errors. The worker thread acquires a mutex lock on the receiver, receives a `Job` from the channel, and executes the received closure. Errors during lock acquisition or receiving are handled by unwrapping the results.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        let thread = thread::spawn(move || loop {\n            let job = receiver.lock().unwrap().recv().unwrap();\n\n            println!(\"Worker {id} got a job; executing.\");\n\n            job();\n        });\n\n        Worker { id, thread }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Message Passing with Threads and Async Blocks\nDESCRIPTION: This example showcases how to combine threads and async blocks in Rust for message passing. A thread sends messages through an async channel, while an async block awaits and processes those messages. It demonstrates a common pattern where computationally intensive tasks are handled in a thread, and the results are communicated to an async event loop or UI.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-06-futures-tasks-threads.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\nuse std::time::Duration;\n\nuse futures::channel::mpsc;\nuse futures::stream::StreamExt;\n\n#[tokio::main]\nasync fn main() {\n    let (mut tx, mut rx) = mpsc::channel::<usize>(100);\n\n    thread::spawn(move || {\n        for i in 1..=10 {\n            tx.try_send(i).expect(\"Channel full\");\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    while let Some(message) = rx.next().await {\n        println!(\"Got: {}\", message);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Specific GET Request\nDESCRIPTION: This Rust code snippet handles a specific GET request to the root path (\"/\"). If the request matches, it sends the contents of \"hello.html\" as the response. Otherwise, it executes the `else` block.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n// --snip--\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&stream);\n    let request_line = buf_reader.lines().next().unwrap().unwrap();\n\n    if request_line == \"GET / HTTP/1.1\" {\n        let status_line = \"HTTP/1.1 200 OK\";\n        let contents = fs::read_to_string(\"hello.html\").unwrap();\n        let length = contents.len();\n\n        let response = format!(\n            \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n    } else {\n        // some other request\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a String from a String Literal using to_string() in Rust\nDESCRIPTION: Demonstrates creating a `String` from a string literal using the `to_string()` method, which is available on any type that implements the `Display` trait. This is a common way to initialize a `String` with initial content.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-02-strings.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet data = \"initial contents\";\nlet s = data.to_string();\n\n// the method also works on a literal directly:\nlet s = \"initial contents\".to_string();\n```\n\n----------------------------------------\n\nTITLE: Calling `sum` Method on an Iterator in Rust\nDESCRIPTION: This snippet illustrates the use of the `sum` method, a consuming adapter, to calculate the sum of all items in an iterator. The `sum` method takes ownership of the iterator and consumes it by repeatedly calling `next` until all items have been processed.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-02-iterators.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[test]\nfn iterator_sum() {\n    let v1 = vec![1, 2, 3];\n\n    let v1_iter = v1.iter();\n\n    let total: i32 = v1_iter.sum();\n\n    assert_eq!(total, 6);\n}\n```\n\n----------------------------------------\n\nTITLE: Catch-all Pattern in Match Expression Rust\nDESCRIPTION: This code demonstrates a catch-all pattern in a `match` expression. It handles specific dice roll values (3 and 7) and a default case for all other values using the `other` variable, which is then passed to `move_player`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_20\n\nLANGUAGE: Rust\nCODE:\n```\nlet dice_roll = 9;\n    match dice_roll {\n        3 => add_fancy_hat(),\n        7 => remove_fancy_hat(),\n        other => move_player(other),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n    fn move_player(num_spaces: u8) {}\n```\n\n----------------------------------------\n\nTITLE: Serving HTML Content in HTTP Response using Rust\nDESCRIPTION: This Rust code reads the contents of an HTML file (hello.html) and includes it as the body of an HTTP response. It constructs the HTTP response with a status line, a `Content-Length` header to indicate the size of the HTML content, and the HTML content itself. It utilizes the `fs` module to read the file contents into a string.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-01-single-threaded.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs;\nuse std::io::prelude::*;\nuse std::net::TcpStream;\n\nfn handle_connection(mut stream: TcpStream) {\n    let contents = fs::read_to_string(\"hello.html\").unwrap();\n\n    let response = format!(\n        \"HTTP/1.1 200 OK\\r\\nContent-Length: {}\\r\\n\\r\\n{}\",\n        contents.len(),\n        contents\n    );\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Method on `Point<f32>` with Concrete Type in Rust\nDESCRIPTION: This code demonstrates how to implement a method only for a specific concrete type of a generic struct. The `distance_from_origin` method is implemented only for `Point<f32>` instances.  This is achieved by specifying the concrete type `f32` directly in the `impl` block, i.e., `impl Point<f32>`. Instances of `Point<T>` where `T` is not `f32` will not have this method defined.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-01-syntax.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl Point<f32> {\n    fn distance_from_origin(&self) -> f32 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Re-exporting Names with `pub use` in Rust\nDESCRIPTION: This example demonstrates how to re-export a name using `pub use`. This makes the item available to other modules as if it were defined in the current scope, simplifying the external API.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub use crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a List with Rc<T> for shared ownership in Rust\nDESCRIPTION: This code defines a `List` data structure using `Rc<T>` instead of `Box<T>`. This allows multiple lists to share ownership of the same data.  The `Cons` variant holds a value and an `Rc<List>`, enabling shared access and preventing the original list from being dropped while others are referencing it.  `Rc::clone` is used to increment the reference count when creating new lists that point to existing ones.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-04-rc.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-18/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Concatenating Strings with the format! Macro in Rust\nDESCRIPTION: Illustrates how to use the `format!` macro for efficient and readable string concatenation. This macro does not take ownership of its parameters and is more versatile for complex string formatting.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-02-strings.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nlet s1 = String::from(\"tic\");\nlet s2 = String::from(\"-tac\");\nlet s3 = String::from(\"-toe\");\n\nlet s = format!(\"{}{}{}\", s1, s2, s3);\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Smart Pointer MyBox<T> in Rust\nDESCRIPTION: This example defines a custom smart pointer type `MyBox<T>` as a tuple struct. It also defines a `new` function to create instances of `MyBox<T>`. This code sets the foundation for implementing the `Deref` trait later to enable dereferencing.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyBox<T>(T);\n\nimpl<T> MyBox<T> {\n    fn new(x: T) -> MyBox<T> {\n        MyBox(x)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Async Delay to Stream Messages in Rust\nDESCRIPTION: This code snippet shows how to add a variable delay to messages sent through a channel, simulating real-world delays. It uses `tokio::time::sleep` to introduce delays before sending messages. It spawns a task to handle the async sleep calls, preventing blocking the main thread. Requires `tokio`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-04-streams.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse futures::stream::Stream;\nuse futures::task::{Context, Poll};\nuse std::pin::Pin;\nuse std::time::Duration;\nuse tokio::sync::mpsc;\nuse tokio::time;\n\nstruct ReceiverStream { rx: mpsc::Receiver<String> }\n\nimpl Stream for ReceiverStream {\n    type Item = String;\n\n    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<String>> {\n        self.rx.poll_recv(cx)\n    }\n}\n\nfn get_messages() -> impl Stream<Item = String> {\n    let (tx, rx) = mpsc::channel(128);\n    let messages = vec![\n        \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\",\n    ];\n\n    tokio::spawn(async move {\n        for (i, letter) in messages.iter().enumerate() {\n            if i % 2 == 0 {\n                time::sleep(Duration::from_millis(100)).await;\n            } else {\n                time::sleep(Duration::from_millis(300)).await;\n            }\n            tx.send(letter.to_string()).await.unwrap();\n        }\n    });\n\n    ReceiverStream { rx }\n}\n```\n\n----------------------------------------\n\nTITLE: Case-Insensitive Test in Rust\nDESCRIPTION: This test asserts that a case-insensitive search for the query \"rUsT\" in the provided contents returns the lines \"Rust:\" and \"Trust me.\". It verifies that the search_case_insensitive function correctly identifies the matching lines, ignoring the case of the characters in the query.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\n#[test]\n    fn case_insensitive() {\n        let query = \"rUsT\";\n        let contents = \"\\\nRust:\nsafe, fast, productive.\nPick three.\nTrust me.\";\n\n        assert_eq!(\n            vec![\"Rust:\", \"Trust me.\"],\n            search_case_insensitive(query, contents)\n        );\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait with a Default Implementation in Rust\nDESCRIPTION: This code defines a trait `Summary` with a default implementation for the `summarize` method. Types implementing this trait can choose to use the default implementation or override it with their own custom logic. This offers flexibility in trait design and implementation.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\npub trait Summary {\n    fn summarize(&self) -> String {\n        String::from(\"(Read more...)\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Compiler Error: Move and Drop Conflict\nDESCRIPTION: This snippet showcases a compiler error that occurs when attempting to both move a variable `v` into a closure and then drop it in the main thread.  This demonstrates that the `move` keyword enforces ownership rules and prevents attempts to use a variable after its ownership has been transferred. The error highlights Rust's ownership system in action, preventing invalid memory access.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch16-01-threads.md#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n{{#include ../listings/ch16-fearless-concurrency/output-only-01-move-drop/output.txt}}\n```\n\n----------------------------------------\n\nTITLE: Final Code - Main Function - Rust\nDESCRIPTION: The final version of the main function.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-03-graceful-shutdown-and-cleanup.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch21-web-server/no-listing-07-final-code/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Shadowing to Change Variable Types in Rust\nDESCRIPTION: This code demonstrates how shadowing can be used to change the type of a variable. Here, the `spaces` variable is first a string and then a number after shadowing. This is possible because shadowing effectively creates a new variable.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-01-variables-and-mutability.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let spaces = \"   \";\n    let spaces = spaces.len();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Game Loop for Multiple Guesses in Rust\nDESCRIPTION: This snippet introduces an infinite loop using the `loop` keyword to allow users to make multiple guesses until they win or interrupt the program. It includes the comparison logic using `match` and the `Ordering` enum to provide feedback to the user.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter02.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n    // --snip--\n\n    println!(\"The secret number is: {secret_number}\");\n\n    loop {\n        println!(\"Please input your guess.\");\n\n        // --snip--\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less => println!(\"Too small!\"),\n            Ordering::Greater => println!(\"Too big!\"),\n            Ordering::Equal => println!(\"You win!\"),\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Rust project with Cargo\nDESCRIPTION: This snippet demonstrates how to execute a Rust project using the `cargo run` command. It compiles the project and then runs the executable. The output includes compilation messages and the program's output, which is 'A baby dog is called a Spot' in this case.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch20-advanced-features/listing-20-20/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n Compiling traits-example v0.1.0 (file:///projects/traits-example)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s\n   Running `target/debug/traits-example`\nA baby dog is called a Spot\n```\n\n----------------------------------------\n\nTITLE: Catch-All Pattern with Underscore Placeholder in Match - Rust\nDESCRIPTION: This example shows a `match` expression using the `_` placeholder as a catch-all. If the dice roll is 3 or 7, specific actions are taken. Otherwise, if the roll is anything else, the code executes `reroll()`, effectively ignoring the value of the roll.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-02-match.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let dice_roll = 9;\n\n    match dice_roll {\n        3 => add_fancy_hat(),\n        7 => remove_fancy_hat(),\n        _ => reroll(),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n    fn reroll() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Future trait definition in Rust\nDESCRIPTION: This code defines the `Future` trait in Rust, which is fundamental to asynchronous programming. It requires an associated type `Output` and a `poll` method that takes a pinned mutable reference to `Self` and a `Context`, returning a `Poll` result indicating whether the future is ready or pending.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_50\n\nLANGUAGE: rust\nCODE:\n```\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\n\npub trait Future {\n    type Output;\n\n    // Required method\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Ranges of Values in Rust\nDESCRIPTION: This code demonstrates matching ranges of values using the `..=` syntax in a `match` expression. It matches any value within the specified range and executes the corresponding arm.  Ranges are only allowed with numeric or `char` types.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 5;\n\nmatch x {\n    1..=5 => println!(\"one through five\"),\n    _ => println!(\"something else\"),\n}\n```\n\n----------------------------------------\n\nTITLE: Greeter Function Test with Custom Failure Message - Rust\nDESCRIPTION: This snippet defines a function `greeting` that takes a name as input and returns a greeting string. The test asserts that the greeting contains the input name. It utilizes a custom failure message to provide more context when the assertion fails, including the actual output of the greeting function.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-01-writing-tests.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-05-greeter/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Concurrent Send and Receive with Async Blocks\nDESCRIPTION: This example demonstrates concurrency by separating the send and receive operations into two separate `async` blocks.  `trpl::join` is used to execute both futures concurrently. The `tx_fut` sends messages with delays, and `rx_fut` receives them until the channel is closed.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nlet tx_fut = async {\n    let vals = vec![\n        String::from(\"hi\"),\n        String::from(\"from\"),\n        String::from(\"the\"),\n        String::from(\"future\"),\n    ];\n\n    for val in vals {\n        tx.send(val).unwrap();\n        trpl::sleep(Duration::from_millis(500)).await;\n    }\n};\n\nlet rx_fut = async {\n    while let Some(value) = rx.recv().await {\n        println!(\"received '{value}'\");\n    }\n};\n\ntrpl::join(tx_fut, rx_fut).await;\n```\n\n----------------------------------------\n\nTITLE: Creating a String using String::from - Rust\nDESCRIPTION: This code snippet creates a `String` from a string literal using the `String::from()` function. This is another way to convert a string literal into a `String` object.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nlet s = String::from(\"initial contents\");\n```\n\n----------------------------------------\n\nTITLE: Explicitly dropping a value with std::mem::drop\nDESCRIPTION: This snippet demonstrates how to explicitly drop a value before it goes out of scope using the `std::mem::drop` function. This function allows you to force the `drop` method to be called at a specific point in the code. This is useful for releasing resources early, such as locks.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-03-drop.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct CustomSmartPointer {\n    data: String,\n}\n\nimpl Drop for CustomSmartPointer {\n    fn drop(&mut self) {\n        println!(\"Dropping CustomSmartPointer with data `{}`!\", self.data);\n    }\n}\n\nfn main() {\n    let c = CustomSmartPointer { data: String::from(\"some data\") };\n    println!(\"CustomSmartPointer created.\");\n    drop(c);\n    println!(\"CustomSmartPointer dropped before the end of main.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using Parent Modules with `use` for Conflicting Names in Rust\nDESCRIPTION: This code demonstrates how to bring two types with the same name (`Result`) into scope by using their parent modules.  This allows disambiguation of the two types when they are used.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nmod a {\n    pub struct Result;\n}\n\nmod b {\n    pub struct Result;\n}\n\nfn main() {\n    use a::Result;\n    use b::Result as BResult;\n\n    let _a_result: Result;\n    let _b_result: BResult;\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Multiple Messages from Multiple Producers in Rust\nDESCRIPTION: This code snippet demonstrates how to create multiple threads, each sending messages to a single receiver via a channel. The transmitter is cloned to allow multiple producers. The receiver then prints the received messages.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch16-02-message-passing.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\nuse std::sync::mpsc;\nuse std::time::Duration;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    let tx1 = tx.clone();\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx1.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"more\"),\n            String::from(\"messages\"),\n            String::from(\"for\"),\n            String::from(\"you\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!(\"Got: {}\", received);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending HTML Response\nDESCRIPTION: This Rust code snippet reads an HTML file and sends it as the body of an HTTP response. It constructs the response with a 200 OK status and a Content-Length header.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n};\n// --snip--\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&stream);\n    let http_request: Vec<_> = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    let status_line = \"HTTP/1.1 200 OK\";\n    let contents = fs::read_to_string(\"hello.html\").unwrap();\n    let length = contents.len();\n\n    let response =\n        format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ThreadPool::new with panic (Rust)\nDESCRIPTION: This code implements the `ThreadPool::new` function with an assertion that checks if the `size` parameter is greater than zero. If `size` is zero, the program will panic. This adds validation to ensure a valid number of threads.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-02-multithreaded.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        ThreadPool\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating ThreadPool with thread vector (Rust)\nDESCRIPTION: This code modifies the `ThreadPool` struct to hold a vector of `thread::JoinHandle<()>` instances. The vector is initialized with a capacity of `size`. It demonstrates the initial setup for managing worker threads within the thread pool, though the actual thread creation is not yet implemented.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-02-multithreaded.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\n\nstruct ThreadPool {\n    threads: Vec<thread::JoinHandle<()>>,\n}\n\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let threads = Vec::with_capacity(size);\n\n        ThreadPool { threads }\n    }\n\n    fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static\n    {\n\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a User Struct Instance in Rust\nDESCRIPTION: Creates an instance of the `User` struct named `user1` with specific values for each field. Demonstrates how to initialize a struct instance by specifying values for each field.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-01-defining-structs.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let user1 = User {\n        email: String::from(\"someone@example.com\"),\n        username: String::from(\"someusername123\"),\n        active: true,\n        sign_in_count: 1,\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Module in Crate Root - Rust\nDESCRIPTION: This code snippet demonstrates how to declare a module named `front_of_house` in the crate root file (*src/lib.rs*). The module's body will be defined in a separate file named *src/front_of_house.rs*.  The `pub use` statement makes the `hosting` module available to external code. The `eat_at_restaurant` function calls a function within the `hosting` module.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\nmod front_of_house;\n\npub use crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Result with Match Expression in Rust\nDESCRIPTION: This example shows how to handle the `Result` returned by `File::open` using a `match` expression. It handles both the `Ok` variant (successful file opening) and the `Err` variant (failure to open the file), panicking in the error case.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch09-02-recoverable-errors-with-result.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch09-error-handling/listing-09-04/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Multiple `impl` Blocks: Example in Rust\nDESCRIPTION: This code demonstrates using multiple `impl` blocks for a single struct in Rust. Each `impl` block defines a separate method for the `Rectangle` struct: `area` and `can_hold`. While not strictly necessary in this example, it showcases valid syntax and hints at use-cases with generics and traits.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-03-method-syntax.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n}\n\nimpl Rectangle {\n    fn can_hold(&self, other: &Rectangle) -> bool {\n        self.width > other.width && self.height > other.height\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Finding the First Word Using Byte Indices\nDESCRIPTION: This Rust code snippet demonstrates how to find the index of the first space in a string, effectively marking the end of the first word.  It converts the string to bytes, iterates through them, and returns the index of the first space encountered. It uses `as_bytes` to get byte array and `iter().enumerate()` to get the index and byte value while iterating.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-03-slices.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Vec Macro Example\nDESCRIPTION: This example demonstrates how to use the `vec!` macro to create a new vector with specific values. It shows the creation of a vector containing three 32-bit unsigned integers.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-05-macros.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet v: Vec<u32> = vec![1, 2, 3];\n```\n\n----------------------------------------\n\nTITLE: Creating Job Type Alias and Sending Job to Channel (Rust)\nDESCRIPTION: This code snippet defines a `Job` type alias as a `Box` containing a dynamically-sized trait object representing a closure. It then creates a new `Job` instance from the closure passed to the `execute` method and sends the job to a channel for worker threads to process. The `unwrap` call handles potential send failures, assuming the receiving end is always active.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-02-multithreaded.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\ntype Job = Box<dyn FnOnce() + Send + 'static>;\n\nimpl ThreadPool {\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static\n    {\n        let job = Box::new(f);\n\n        self.sender.as_ref().unwrap().send(job).unwrap();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Struct with Public and Private Fields in Rust\nDESCRIPTION: This snippet shows a struct with a public field (`toast`) and a private field (`seasonal_fruit`).  It also demonstrates providing a public associated function (`summer`) to construct an instance of the struct, as required when there are private fields.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nmod back_of_house {\n    pub struct Breakfast {\n        pub toast: String,\n        seasonal_fruit: String,\n    }\n\n    impl Breakfast {\n        pub fn summer(toast: &str) -> Breakfast {\n            Breakfast {\n                toast: String::from(toast),\n                seasonal_fruit: String::from(\"peaches\"),\n            }\n        }\n    }\n}\n\npub fn eat_at_restaurant() {\n    let mut meal = back_of_house::Breakfast::summer(\"Rye\");\n    // Changing our mind about what bread we'd like\n    meal.toast = String::from(\"Wheat\");\n    println!(\"I'd like {} toast please\", meal.toast);\n\n    // The next line won't compile if we uncomment it;\n    // we're not allowed to see or modify the seasonal fruit\n    // meal.seasonal_fruit = String::from(\"blueberries\");\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the `Add` trait on `Millimeters` to add `Millimeters` to `Meters` in Rust\nDESCRIPTION: This code demonstrates implementing the `Add` trait for a `Millimeters` struct, adding it to a `Meters` struct.  It customizes the `Rhs` type parameter of the `Add` trait to be `Meters`, allowing addition between the two different types. The `add` method converts the meters to millimeters, adds the values, and returns a new `Millimeters` instance.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-02-advanced-traits.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops::Add;\n\nstruct Millimeters(u32);\nstruct Meters(u32);\n\nimpl Add<Meters> for Millimeters {\n    type Output = Millimeters;\n\n    fn add(self, other: Meters) -> Millimeters {\n        Millimeters(self.0 + (other.0 * 1000))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Tree with Parent-Child Relationship\nDESCRIPTION: Creates a simple tree structure with a `leaf` node and a `branch` node, where the `branch` node holds a reference to the `leaf` node as its child. This demonstrates shared ownership of the `leaf` node by both the `leaf` and `branch` variables.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        children: RefCell::new(vec![]),\n    });\n\n    let branch = Rc::new(Node {\n        value: 5,\n        children: RefCell::new(vec![Rc::clone(&leaf)]),\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Shirt Company Giveaway Example\nDESCRIPTION: This snippet demonstrates a scenario where a shirt company gives away shirts based on user preferences using an `Inventory` struct and a closure. The `giveaway` method uses `unwrap_or_else` with a closure to determine the shirt color to give away based on user preference or the most stocked color.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-01-closures.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-01/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Creating Enum Instances in Rust\nDESCRIPTION: This snippet demonstrates how to create instances of the `IpAddrKind` enum variants. `four` will be the `V4` variant, and `six` will be the `V6` variant. Requires the `IpAddrKind` enum to be defined.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet four = IpAddrKind::V4;\nlet six = IpAddrKind::V6;\n```\n\n----------------------------------------\n\nTITLE: Joining a Thread Before Main Thread Execution (Rust)\nDESCRIPTION: This snippet demonstrates how to force a spawned thread to complete its execution before the main thread even begins its primary loop. The call `handle.join().unwrap()` blocks the main thread until the spawned thread is entirely finished. After this completes, the main thread proceeds to execute its own loop, resulting in non-interleaved output.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter16.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {i} from the spawned thread!\");\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    handle.join().unwrap();\n\n    for i in 1..5 {\n        println!(\"hi number {i} from the main thread!\");\n        thread::sleep(Duration::from_millis(1));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Errors from Config::build in Rust\nDESCRIPTION: This snippet shows how to handle the `Result` returned by `Config::build` in the `main` function. It uses `unwrap_or_else` to either retrieve the `Config` instance or print an error message and exit the program with a non-zero exit code.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::process;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::build(&args).unwrap_or_else(|err| {\n        println!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    // --snip--\n```\n\n----------------------------------------\n\nTITLE: Successful Crate Publishing Example\nDESCRIPTION: This console output shows an example of a successful `cargo publish` command, including updating the crates.io index, packaging, verifying, compiling, and uploading the crate.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-02-publishing-to-crates-io.md#_snippet_9\n\nLANGUAGE: console\nCODE:\n```\n$ cargo publish\n    Updating crates.io index\n   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)\n   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)\n   Compiling guessing_game v0.1.0\n(file:///projects/guessing_game/target/package/guessing_game-0.1.0)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.19s\n   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)\n```\n\n----------------------------------------\n\nTITLE: Using Library Crate in Binary Crate\nDESCRIPTION: Illustrates how to use the `add_one` function from the `add_one` library crate in the `adder` binary crate.  It calls `add_one::add_one(num)` and prints the result.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_20\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    let num = 10;\n    println!(\"Hello, world! {num} plus one is {}!\", add_one::add_one(num));\n}\n```\n\n----------------------------------------\n\nTITLE: Closure Moving Ownership in Rust for Thread\nDESCRIPTION: This example demonstrates using the `move` keyword to force a closure to take ownership of a vector when spawning a new thread. This is necessary because the new thread might outlive the main thread, and the compiler needs to ensure that the vector remains valid for the duration of the thread's execution. Dependencies: `std::thread`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\n\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(\"Before defining closure: {list:?}\");\n\n    thread::spawn(move || println!(\"From thread: {list:?}\"))\n        .join()\n        .unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing add_text Method in lib.rs\nDESCRIPTION: This snippet implements the `add_text` method for the `Post` struct. This method allows adding text to the post's content. It takes a mutable reference to `self` and a `&str` as input, appending the input text to the `content` field.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter18.md#_snippet_12\n\nLANGUAGE: Rust\nCODE:\n```\nimpl Post {\n    // --snip--\n    pub fn add_text(&mut self, text: &str) {\n        self.content.push_str(text);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing can_hold Method with assert! (Negative Case) in Rust\nDESCRIPTION: This test case uses the `assert!` macro along with negation to verify that a smaller `Rectangle` cannot hold a larger `Rectangle`. This demonstrates how to test for negative conditions using assertions in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-01-writing-tests.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-02-adding-another-rectangle-test/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Function with a Parameter and Return Value in Rust\nDESCRIPTION: This code defines a function `plus_one` that takes an integer `x` as input and returns `x + 1`. The example illustrates how to define function parameters with their types and specify the return type. It demonstrates a function call and use of the return value.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = plus_one(5);\n\n    println!(\"The value of x is: {x}\");\n}\n\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Display Trait for Point Struct\nDESCRIPTION: This code implements the `Display` trait for the `Point` struct, satisfying the requirement of the `OutlinePrint` trait. Requires `OutlinePrint` trait definition from previous example.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-02-advanced-traits.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt;\n\nstruct Point { x: i32, y: i32 }\n\nimpl fmt::Display for Point {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"({}, {})\", self.x, self.y)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Types That Implement Traits\nDESCRIPTION: This code defines a function `returns_summarizable` that returns a type which implements the `Summary` trait. The concrete type returned is `Tweet`, but the function signature only specifies that it returns something implementing `Summary`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_29\n\nLANGUAGE: Rust\nCODE:\n```\nfn returns_summarizable() -> impl Summary {\n    Tweet {\n        username: String::from(\"horse_ebooks\"),\n        content: String::from(\n            \"of course, as you probably already know, people\",\n        ),\n        reply: false,\n        retweet: false,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Future Trait in Rust\nDESCRIPTION: This code snippet shows the definition of the `Future` trait in Rust, including the associated `Output` type and the `poll` method. It showcases how futures are polled to check for completion and how they interact with the `Context` and `Poll` types.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-05-traits-for-async.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\n\npub trait Future {\n    type Output;\n\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n}\n```\n\n----------------------------------------\n\nTITLE: Testing with `Result<T, E>` in Rust\nDESCRIPTION: This code shows how to write tests that return a `Result<T, E>` instead of panicking. The `it_works` function now returns `Result<(), String>`. It returns `Ok(())` if the test passes and `Err(String::from(...))` if it fails. This allows the use of the question mark operator for error handling within the test.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n#[test]\nfn it_works() -> Result<(), String> {\n    let result = add(2, 2);\n\n    if result == 4 {\n        Ok(())\n    } else {\n        Err(String::from(\"two plus two does not equal four\"))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding an External Package Dependency in Cargo.toml\nDESCRIPTION: This shows how to add a dependency to a Rust project by specifying the package name and version in the `Cargo.toml` file. This allows Cargo to download the package and its dependencies.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nrand = \"0.8.5\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Recursive List with Box<T> in Rust\nDESCRIPTION: This code defines a recursive `List` enum using `Box<T>` to hold the next element. `Box<T>` is a smart pointer that allocates memory on the heap, allowing the compiler to determine the size of the `List` because the size of the pointer is known. The `Cons` variant holds an `i32` value and a `Box` containing another `List`, while the `Nil` variant represents the end of the list.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-01-box.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nenum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));\n\n    println!(\"{:?}\", list);\n}\n```\n\n----------------------------------------\n\nTITLE: Final Code - Library - Rust\nDESCRIPTION: The final version of the library code.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-03-graceful-shutdown-and-cleanup.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch21-web-server/no-listing-07-final-code/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Test larger_can_hold_smaller using assert! in Rust\nDESCRIPTION: This Rust code defines a test function, `larger_can_hold_smaller`, within a `tests` module. It creates two Rectangle instances, `larger` and `smaller`, and uses the `assert!` macro to verify that the `larger` rectangle can indeed hold the `smaller` rectangle based on the `can_hold` method.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn larger_can_hold_smaller() {\n        let larger = Rectangle {\n            width: 8,\n            height: 7,\n        };\n        let smaller = Rectangle {\n            width: 5,\n            height: 1,\n        };\n\n        assert!(larger.can_hold(&smaller));\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing an Empty String in Rust\nDESCRIPTION: Creates a new, empty `String` using the `String::new()` constructor. The resulting string can then be populated with data.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-02-strings.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet mut s = String::new();\n```\n\n----------------------------------------\n\nTITLE: Enum with Associated Data in Rust\nDESCRIPTION: This snippet defines the `IpAddr` enum with associated `String` data directly in each variant (`V4` and `V6`).  It then creates two instances of the enum, `home` and `loopback`. No dependencies required.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nenum IpAddr {\n    V4(String),\n    V6(String),\n}\n\nlet home = IpAddr::V4(String::from(\"127.0.0.1\"));\n\nlet loopback = IpAddr::V6(String::from(\"::1\"));\n```\n\n----------------------------------------\n\nTITLE: Matching Multiple Patterns with OR in Rust\nDESCRIPTION: This code snippet demonstrates matching multiple patterns using the `|` (OR) operator within a `match` expression. If `x` is either 1 or 2, the first arm is executed. Otherwise, it checks for 3 and then the default case.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 1;\n\nmatch x {\n    1 | 2 => println!(\"one or two\"),\n    3 => println!(\"three\"),\n    _ => println!(\"anything\"),\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HelloMacro with Parsed Rust Code\nDESCRIPTION: This code snippet shows the `impl_hello_macro` function, which takes a `DeriveInput` struct and generates the code that implements the `HelloMacro` trait on the annotated type. It uses `quote!` macro for code generation.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-05-macros.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-42/hello_macro/hello_macro_derive/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Returning Value from Loop in Rust\nDESCRIPTION: This Rust code snippet demonstrates how to return a value from a `loop` using the `break` keyword followed by the value. The `break` statement exits the loop, and the associated value is then assigned to a variable. This is a common pattern for retrying operations until they succeed.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-05-control-flow.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut counter = 0;\n\n    let result = loop {\n        counter += 1;\n\n        if counter == 10 {\n            break counter * 2;\n        }\n    };\n\n    println!(\"The result is {}\", result);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Guess Type for Validation in Rust\nDESCRIPTION: This code snippet shows how to create a custom `Guess` type in Rust to ensure values are between 1 and 100. It defines a `Guess` struct with a private `value` field and a `new` associated function that validates the input before creating a `Guess` instance. It includes a getter method named `value` to expose the value.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch09-03-to-panic-or-not-to-panic.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch09-error-handling/listing-09-13/src/guessing_game.rs}}\n```\n\n----------------------------------------\n\nTITLE: Implementing execute Method and Job Type Alias in Rust\nDESCRIPTION: This code defines a `Job` type alias as a boxed trait object representing a closure that can be sent and executed in a thread. The `execute` method creates a `Job` instance from a closure and sends it to the thread pool's channel for execution. The method expects a closure `f` that takes no arguments, returns nothing, and is thread-safe.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\ntype Job = Box<dyn FnOnce() + Send + 'static>;\n\nimpl ThreadPool {\n    // --snip--\n\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static,\n    {\n        let job = Box::new(f);\n\n        self.sender.send(job).unwrap();\n    }\n}\n\n// --snip--\n```\n\n----------------------------------------\n\nTITLE: Using Trait Objects to Store Different Types in Rust\nDESCRIPTION: This snippet demonstrates creating a `Screen` instance and adding a `SelectBox` and a `Button` to its `components` vector. Each component is wrapped in a `Box<T>` to become a trait object, allowing for dynamic dispatch when the `run` method calls `draw` on each component.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter18.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse gui::{Button, Screen};\n\nfn main() {\n    let screen = Screen {\n        components: vec![\n            Box::new(SelectBox {\n                width: 75,\n                height: 10,\n                options: vec![\n                    String::from(\"Yes\"),\n                    String::from(\"Maybe\"),\n                    String::from(\"No\"),\n                ],\n            }),\n            Box::new(Button {\n                width: 50,\n                height: 10,\n                label: String::from(\"OK\"),\n            }),\n        ],\n    };\n\n    screen.run();\n}\n```\n\n----------------------------------------\n\nTITLE: Compile Error Output\nDESCRIPTION: Shows the compile error output when trying to use a moved variable. The error clearly indicates that the value of `s1` has been moved and is no longer valid in the current scope.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_8\n\nLANGUAGE: console\nCODE:\n```\nerror[E0382]: borrow of moved value: `s1`\n  --> src/main.rs:5:28\n   |\n2  |     let s1 = String::from(\"hello\");\n   |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait\n3  |     let s2 = s1;\n   |              -- value moved here\n4  | \n5  |     println!(\"{} world!\", s1);\n   |                            ^^ value borrowed here after move\n\nFor more information about this error, try `rustc --explain E0382`.\n```\n\n----------------------------------------\n\nTITLE: Destructuring Structs and Tuples Rust\nDESCRIPTION: This code demonstrates complex destructuring of nested structs and tuples. It initializes a tuple containing another tuple and a struct `Point`. The destructuring pattern then extracts the individual values from these nested structures into separate variables. Note that the `Point` struct definition is not included in the snippet, but presumed to be defined elsewhere.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\n    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });\n```\n\n----------------------------------------\n\nTITLE: Creating Async Task with `spawn_task` in Rust\nDESCRIPTION: This code snippet demonstrates creating a new asynchronous task using `trpl::spawn_task` and `trpl::sleep` for concurrent counting. It sets up a `main` function to execute the async code and includes two loops, each with a `trpl::sleep` call, one within the spawned task and the other in the main async block. A `await` is added after the `sleep` calls.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-02-concurrency-with-async.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse trpl::futures::FutureExt;\n\nasync fn print_number(number: u32) {\n    println!(\"hi number {} from the second task!\", number);\n}\n\nasync fn count() {\n    for i in 1..10 {\n        print_number(i).await;\n        trpl::sleep(std::time::Duration::from_millis(500)).await;\n    }\n}\n\nfn main() {\n    trpl::run(async {\n        trpl::spawn_task(async {\n            for i in 1..6 {\n                println!(\"hi number {} from the first task!\", i);\n                trpl::sleep(std::time::Duration::from_millis(500)).await;\n            }\n        });\n        for i in 1..6 {\n            println!(\"hi number {} from the second task!\", i);\n            trpl::sleep(std::time::Duration::from_millis(500)).await;\n        }\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Output of mutable List example in Rust\nDESCRIPTION: This is the expected output of the `Rc<RefCell<i32>>` example, demonstrating that modifying the value through `RefCell` affects all lists that share ownership of it. The output shows that the printed values for 'a', 'b', and 'c' all reflect the modification.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-05-interior-mutability.md#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\na after = Cons(RefCell { value: 15 }, Nil)\nb after = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))\nc after = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))\n\n```\n\n----------------------------------------\n\nTITLE: Using a Long Type in Many Places in Rust\nDESCRIPTION: This snippet showcases using a long, complex type `Box<dyn Fn() + Send + 'static>` in multiple places. It highlights the issue of code repetition and potential for errors that can be addressed with type aliases.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-03-advanced-types.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn takes_long_type(f: Box<dyn Fn() + Send + 'static>) {\n    // --snip--\n}\n\nfn returns_long_type() -> Box<dyn Fn() + Send + 'static> {\n    // --snip--\n    Box::new(|| ())\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Future Trait in Rust\nDESCRIPTION: This code snippet defines the `Future` trait in Rust, showcasing the `Output` associated type and the `poll` method which takes a pinned mutable reference to self and a mutable reference to a `Context`, returning a `Poll` enum.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_45\n\nLANGUAGE: rust\nCODE:\n```\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\n\npub trait Future {\n    type Output;\n\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing a Channel in Rust\nDESCRIPTION: This snippet creates a channel using `mpsc::channel()`. The returned tuple contains the transmitter (`tx`) and receiver (`rx`) halves of the channel. This example does not yet specify the type of data that will be sent over the channel.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter16.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::mpsc;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n}\n```\n\n----------------------------------------\n\nTITLE: Async Function for Retrieving Page Title - Rust\nDESCRIPTION: This async function takes a URL as input, fetches the HTML content, parses it, and extracts the page title. It returns an `Option<String>` containing the title or `None` if not found.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-01-futures-and-syntax.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::future::Future;\nuse trpl::Html;\n\nfn page_title(url: &str) -> impl Future<Output = Option<String>> {\n    async move {\n        let text = trpl::get(url).await.text().await;\n        Html::parse(&text)\n            .select_first(\"title\")\n            .map(|title| title.inner_html())\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the add_one Function in lib.rs\nDESCRIPTION: This Rust code defines a simple function `add_one` in the `add_one` library crate. It takes an `i32` as input and returns the input plus one.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-03-cargo-workspaces.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\npub fn add_one(x: i32) -> i32 {\n    x + 1\n}\n```\n\n----------------------------------------\n\nTITLE: Searching Each Line for Query String Rust\nDESCRIPTION: This snippet extends the previous example by adding the `contains` method to check if the current line contains the specified query string. The `contains` method returns a boolean value indicating whether the query is found within the line. This example will not compile because it is still incomplete.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-04-testing-the-librarys-functionality.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-18/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Ignoring Parts of Value with Nested `_` in Rust\nDESCRIPTION: This code uses `_` within patterns to ignore parts of a value, specifically when matching `Some` variants without needing the value inside. The example manages a setting's value, allowing overwriting if the setting is unset but preventing it if already customized. Dependencies: None. Inputs: Two Option<i32> values. Outputs: Prints messages based on the values.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut setting_value: Option<i32> = Some(5);\n    let new_setting_value: Option<i32> = Some(10);\n\n    match (setting_value, new_setting_value) {\n        (Some(_), Some(_)) => {\n            println!(\"Can't overwrite an existing customized value\");\n        }\n        _ => {\n            setting_value = new_setting_value;\n        }\n    }\n\n    println!(\"setting is Some({:?})\", setting_value);\n}\n```\n\n----------------------------------------\n\nTITLE: If Expression: Assignment in Let Statement in Rust\nDESCRIPTION: This snippet shows how to use an `if` expression on the right side of a `let` statement to assign a value to a variable. The value assigned depends on the outcome of the `if` condition. Both arms of the `if` expression must evaluate to the same type.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-05-control-flow.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let condition = true;\n    let number = if condition {\n        5\n    } else {\n        6\n    };\n\n    println!(\"The value of number is: {}\", number);\n}\n```\n\n----------------------------------------\n\nTITLE: Destructuring Structs with Shorthand in Rust\nDESCRIPTION: This example uses struct field shorthand to destructure a `Point` struct. It creates variables with the same names as the struct fields (`x` and `y`) and assigns the corresponding values from the struct.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 0, y: 7 };\n\nlet Point { x, y } = p;\nassert_eq!(0, x);\nassert_eq!(7, y);\n```\n\n----------------------------------------\n\nTITLE: Chained Method Calls with ? Operator - Rust\nDESCRIPTION: This function `read_username_from_file` demonstrates chaining method calls after the `?` operator for a more concise error propagation. It opens the \"hello.txt\" file and reads its contents directly into a String.  Any error during the `File::open` or `read_to_string` operation will be propagated using the `?` operator. Dependencies: std::fs::File, std::io::{self, Read}.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter09.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    let mut username = String::new();\n\n    File::open(\"hello.txt\")?.read_to_string(&mut username)?;\n\n    Ok(username)\n}\n```\n\n----------------------------------------\n\nTITLE: Storing Matching Lines in Vector Rust\nDESCRIPTION: This snippet demonstrates how to store the lines that match the query in a vector. A mutable vector is created before the `for` loop, and the `push` method is used to add each matching line to the vector. Finally, the vector containing the matching lines is returned. This implementation makes the test pass.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-04-testing-the-librarys-functionality.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-19/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Returning Multiple Types with impl Trait in Rust (Incorrect)\nDESCRIPTION: Illustrates an attempt to return either a `NewsArticle` or a `SocialPost` with the return type specified as `impl Summary`, which is not allowed. `impl Trait` can only be used when returning a single concrete type that implements the specified trait.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-02-traits.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-06-impl-trait-returns-one-type/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Multiple Producers with Async Blocks in Rust\nDESCRIPTION: This code demonstrates sending messages from multiple asynchronous producers using cloned senders. It uses `async move` blocks to handle ownership of each sender.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-02-concurrency-with-async.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse trpl::sleep;\n\nasync fn here() {\n    let (tx, rx) = trpl::channel();\n    let tx1 = tx.clone();\n\n    let vals1 = [\"first\", \"second\"];\n    let vals2 = [\"third\", \"fourth\"];\n\n    trpl::join(\n        async move {\n            for val in vals1 {\n                println!(\"sending (1) {}\", val);\n                tx1.send(val).await;\n                sleep(0.5).await;\n            }\n        },\n        async move {\n            for val in vals2 {\n                println!(\"sending (2) {}\", val);\n                tx.send(val).await;\n                sleep(1.0).await;\n            }\n        },\n        async {\n            while let Some(msg) = rx.recv().await {\n                println!(\"received {}\", msg);\n            }\n        },\n    )\n    .await;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Renaming Types with `as` Keyword in Rust\nDESCRIPTION: This code shows how to rename a type when bringing it into scope using the `as` keyword.  This is useful for resolving naming conflicts when multiple types with the same name exist in different modules.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nmod a {\n    pub struct Result;\n}\n\nmod b {\n    pub struct Result;\n}\n\nfn main() {\n    use a::Result;\n    use b::Result as IoResult;\n\n    let _a_result: Result;\n    let _b_result: IoResult;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Enum Initializers with map in Rust\nDESCRIPTION: This snippet shows how to use enum initializers with the `map` method to create instances of an enum from a range of numbers. It demonstrates creating `Status::Value` instances from `u32` values using the initializer function of `Status::Value`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-04-advanced-functions-and-closures.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nenum Status {\n    Value(u32),\n    Stop,\n}\n\nfn main() {\n    let list_of_statuses: Vec<Status> = (0u32..20).map(Status::Value).collect();\n    println!(\"{:?}\", list_of_statuses);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the Drop Trait for Custom Cleanup in Rust\nDESCRIPTION: This Rust code defines a `CustomSmartPointer` struct and implements the `Drop` trait for it. The `drop` method prints a message indicating when the `CustomSmartPointer` instance goes out of scope. This demonstrates how to specify custom cleanup code that runs automatically when a value is no longer needed.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nstruct CustomSmartPointer {\n    data: String,\n}\n\nimpl Drop for CustomSmartPointer {\n    fn drop(&mut self) {\n        println!(\"Dropping CustomSmartPointer with data `{}`!\", self.data);\n    }\n}\n\nfn main() {\n    let c = CustomSmartPointer {\n        data: String::from(\"my stuff\"),\n    };\n    let d = CustomSmartPointer {\n        data: String::from(\"other stuff\"),\n    };\n    println!(\"CustomSmartPointers created.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Front of House Module\nDESCRIPTION: This Rust code snippet demonstrates defining a module named `front_of_house` which contains other modules named `hosting` and `serving`. These modules contain function signatures which illustrate the organization of the restaurant crate.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-02-defining-modules-to-control-scope-and-privacy.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nmod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {}\n\n        fn seat_at_table() {}\n    }\n\n    mod serving {\n        fn take_order() {}\n\n        fn serve_order() {}\n\n        fn take_payment() {}\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Ignoring a Test Function\nDESCRIPTION: This code snippet demonstrates how to ignore a test function using the `#[ignore]` attribute. The `expensive_test` function will be skipped during regular test runs unless specifically requested to be included.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-02-running-tests.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[test]\nfn it_works() {\n    assert_eq!(2 + 2, 4);\n}\n\n#[test]\n#[ignore]\nfn expensive_test() {\n    // code that takes an hour to run!\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Ignore Case Configuration Option in Rust\nDESCRIPTION: This code snippet adds a boolean field `ignore_case` to the `Config` struct. This new field allows the program to store whether to perform case-sensitive or case-insensitive searches, controlled by command-line arguments or environment variables.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_25\n\nLANGUAGE: Rust\nCODE:\n```\npub struct Config {\n    pub query: String,\n    pub file_path: String,\n    pub ignore_case: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Unsafe Trait - Rust\nDESCRIPTION: This snippet demonstrates how to define and implement an unsafe trait in Rust. A trait is unsafe when at least one of its methods has some invariant that the compiler cant verify. By using `unsafe impl`, the programmer promises to uphold the invariants that the compiler cant verify.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-01-unsafe-rust.md#_snippet_13\n\nLANGUAGE: Rust\nCODE:\n```\nunsafe trait Foo {\n    // methods go here\n}\n\nunsafe impl Foo for i32 {\n    // method implementations go here\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Input with Match in Rust\nDESCRIPTION: This snippet demonstrates how to handle non-numeric input gracefully by using a `match` expression on the `Result` returned by the `parse` method. If `parse` returns an `Err`, the `continue` keyword is used to skip to the next iteration of the loop, prompting the user for another guess.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter02.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n        // --snip--\n\n        io::stdin()\n            .read_line(&mut guess)\n            .expect(\"Failed to read line\");\n\n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        println!(\"You guessed: {guess}\");\n\n        // --snip--\n```\n\n----------------------------------------\n\nTITLE: Defining an Iterator Trait with Associated Type in Rust\nDESCRIPTION: This code defines the `Iterator` trait with an associated type `Item`. The `Item` type represents the type of values that the iterator will yield. The `next` method returns an `Option` containing a value of the `Item` type or `None` if the iterator is exhausted.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-02-advanced-traits.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Argument Parsing in Rust\nDESCRIPTION: This code extracts the argument parsing logic from `main` into a separate function `parse_config`.  It takes a slice of `String` as input and returns a tuple containing the query and file path.  This improves modularity and makes the code easier to test.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let (query, file_path) = parse_config(&args);\n\n    // --snip--\n}\n\nfn parse_config(args: &[String]) -> (&str, &str) {\n    let query = &args[1];\n    let file_path = &args[2];\n\n    (query, file_path)\n}\n```\n\n----------------------------------------\n\nTITLE: Field Init Shorthand in Rust\nDESCRIPTION: Demonstrates field init shorthand, a feature in Rust where if a struct field and a function parameter have the same name, you can initialize the field with just the name. Simplifies struct initialization when parameter names match field names.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-01-defining-structs.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn build_user(email: String, username: String) -> User {\n    User {\n        active: true,\n        username,\n        email,\n        sign_in_count: 1,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo Login Command\nDESCRIPTION: This command demonstrates how to log into crates.io using the `cargo login` command with an API token. The user is prompted to enter the token after executing the command. This is a necessary step before publishing crates to crates.io.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-02-publishing-to-crates-io.md#_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n$ cargo login\nabcdefghijklmnopqrstuvwxyz012345\n```\n\n----------------------------------------\n\nTITLE: Creating a Channel (Does Not Compile) - Rust\nDESCRIPTION: This snippet demonstrates creating a channel using `mpsc::channel`. It showcases the transmitter (`tx`) and receiver (`rx`) ends of the channel but does not compile because the type of data being sent is not specified.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch16-02-message-passing.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::mpsc;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n}\n```\n\n----------------------------------------\n\nTITLE: Conditionally Calling Search Functions based on `ignore_case`\nDESCRIPTION: This Rust code demonstrates how to modify the `run` function to conditionally call either the `search` function (case-sensitive) or the `search_case_insensitive` function, based on the value of the `ignore_case` field in the `Config` struct. This enables dynamic switching between search modes at runtime.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-05-working-with-environment-variables.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-22/src/lib.rs:there}}\n```\n\n----------------------------------------\n\nTITLE: Implementing the run Method on Screen\nDESCRIPTION: This code implements the `run` method on the `Screen` struct. This method iterates through the `components` vector and calls the `draw` method on each component. This demonstrates how to use trait objects to call methods on different types of objects through a common interface.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-02-trait-objects.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl Screen {\n    pub fn run(&mut self) {\n        for component in self.components.iter_mut() {\n            component.draw();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating over Key-Value Pairs in a HashMap - Rust\nDESCRIPTION: This code demonstrates how to iterate over all key-value pairs in a HashMap using a `for` loop.  Each key and its associated value are printed to the console.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_29\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Yellow\"), 50);\n\nfor (key, value) in &scores {\n    println!(\"{key}: {value}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Running Cargo Test Command\nDESCRIPTION: This snippet shows the command used to run the tests in a Rust project using cargo, the Rust package manager. The output displays the compilation process, test execution, and any failing tests.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch15-smart-pointers/listing-15-23/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test\n Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)\n  Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s\n  Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)\n\nrunning 1 test\ntest tests::it_sends_an_over_75_percent_warning_message ... FAILED\n\nfailures:\n\n---- tests::it_sends_an_over_75_percent_warning_message stdout ----\n\nthread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/lib.rs:60:53:\nalready borrowed: BorrowMutError\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::it_sends_an_over_75_percent_warning_message\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n```\n\n----------------------------------------\n\nTITLE: Defining `timeout` signature in Rust\nDESCRIPTION: This snippet declares the signature of the `timeout` function. It takes a future and a duration as parameters and returns a `Result` indicating whether the future completed successfully or the timeout elapsed.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-03-more-futures.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n// The code was not provided in a parsable format. Therefore, a placeholder is provided.\n// This listing would demonstrate the signature of a `timeout` function.\nasync fn timeout<F>(future: F, duration: std::time::Duration) -> Result<F::Output, std::time::Duration>\nwhere\n    F: std::future::Future,\n{\n    todo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Attempting to Use Moved String in Rust (Compile Error)\nDESCRIPTION: This code snippet shows an example that will result in a compile-time error in Rust.  Attempting to use `s1` after it has been moved to `s2` is not allowed, as Rust invalidates `s1` to prevent memory safety issues.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet s1 = String::from(\"hello\");\nlet s2 = s1;\n\nprintln!(\"{} world!\", s1);\n```\n\n----------------------------------------\n\nTITLE: Adding Asynchronous Delays to a Stream in Rust\nDESCRIPTION: This code demonstrates how to add variable delays to messages sent through a stream using `trpl::spawn_task`.  The `get_messages` function spawns an async task to send messages with alternating delays of 100ms and 300ms.  This simulates real-world scenarios where messages might arrive at different intervals. The main function remains the same as in the timeout example.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_39\n\nLANGUAGE: rust\nCODE:\n```\nfn get_messages() -> impl Stream<Item = String> {\n    let (tx, rx) = trpl::channel();\n\n    trpl::spawn_task(async move {\n        let messages = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"];\n        for (index, message) in messages.into_iter().enumerate() {\n            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };\n            trpl::sleep(Duration::from_millis(time_to_sleep)).await;\n\n            tx.send(format!(\"Message: '{message}'\")).unwrap();\n        }\n    });\n\n    ReceiverStream::new(rx)\n}\n```\n\n----------------------------------------\n\nTITLE: Generic largest function\nDESCRIPTION: This code shows the initial attempt to define a generic `largest` function that can work with any type `T`. However, it doesn't compile because it needs the `PartialOrd` trait to compare values of type `T`. The function takes a slice of type `T` and returns a reference to the largest value.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-01-syntax.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn largest<T>(list: &[T]) -> &T {\n```\n\n----------------------------------------\n\nTITLE: Server Shutdown After Two Requests - Rust\nDESCRIPTION: This code snippet shows how to limit the number of requests a web server handles before shutting down. It uses the `take(2)` method on the iterator returned by `listener.incoming()` to only process the first two incoming connections. After processing these connections, the server exits the loop and shuts down gracefully.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_30\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    let pool = ThreadPool::new(4);\n\n    for stream in listener.incoming().take(2) {\n        let stream = stream.unwrap();\n\n        pool.execute(|| {\n            handle_connection(stream);\n        });\n    }\n\n    println!(\"Shutting down.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing ThreadPool with a Channel Sender in Rust\nDESCRIPTION: This code snippet demonstrates the initialization of a `ThreadPool` struct with a channel sender. It creates a channel using `mpsc::channel()` and stores the sender in the `ThreadPool` struct. The `Job` struct is a placeholder for the type of data sent through the channel.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{sync::mpsc, thread};\n\npub struct ThreadPool {\n    workers: Vec<Worker>,\n    sender: mpsc::Sender<Job>,\n}\n\nstruct Job;\n\nimpl ThreadPool {\n    // --snip--\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id));\n        }\n\n        ThreadPool { workers, sender }\n    }\n    // --snip--\n}\n```\n\n----------------------------------------\n\nTITLE: Main Function with Async Block and Runtime - Rust\nDESCRIPTION: This snippet shows how to use an async block with `trpl::run` to execute asynchronous code within the main function. It retrieves a URL from command line arguments, fetches the page title using `page_title`, and prints the result using `match`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-01-futures-and-syntax.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch17-async-await/listing-17-04/src/main.rs:run}}\n```\n\n----------------------------------------\n\nTITLE: While Loop Iterating Over Collection in Rust\nDESCRIPTION: This Rust snippet iterates over the elements of an array using a `while` loop. The `index` variable is used to access each element of the array `a`.  The loop continues as long as `index` is less than 5. This approach is less safe than using a `for` loop due to the potential for out-of-bounds access.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-05-control-flow.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let a = [10, 20, 30, 40, 50];\n    let mut index = 0;\n\n    while index < 5 {\n        println!(\"the value is: {}\", a[index]);\n\n        index += 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Abstracting Largest Number Function - Rust\nDESCRIPTION: This Rust code snippet refactors the previous example by extracting the logic for finding the largest number into a separate function called `largest`. This function takes a slice of i32 integers as input and returns a reference to the largest integer in the slice. The main function then calls this function twice with different vectors to find the largest number in each, demonstrating code reuse.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn largest(list: &[i32]) -> &i32 {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item > largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest(&number_list);\n    println!(\"The largest number is {result}\");\n\n    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];\n\n    let result = largest(&number_list);\n    println!(\"The largest number is {result}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Receiving Messages Asynchronously in Rust\nDESCRIPTION: This code snippet demonstrates how to receive messages from an asynchronous channel using `rx.recv().await`. The `while let` loop continues as long as there are messages available on the channel. Each received message is then printed to the console.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nwhile let Some(value) = rx.recv().await {\n                println!(\"received '{value}'\");\n            }\n```\n\n----------------------------------------\n\nTITLE: Comments at End of Line in Rust\nDESCRIPTION: This snippet illustrates placing comments at the end of a line of code in Rust. While syntactically valid, comments are more commonly placed above the code they describe.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-04-comments.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-24-comments-end-of-line/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Match Enum with Data Binding in Rust\nDESCRIPTION: This code extends the `Coin` enum to include a `Quarter` variant that holds a `UsState` value. The `value_in_cents` function now extracts the `UsState` value using pattern matching and binds it to the `state` variable within the `Coin::Quarter` match arm. This demonstrates extracting data from enum variants.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-02-match.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nenum UsState {\n    Alabama,\n    Alaska,\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n}\n\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter(state) => {\n            println!(\"State quarter from {:?}!\", state);\n            25\n        },\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the Drop Trait in Rust\nDESCRIPTION: This code defines a `CustomSmartPointer` struct with a `String` field and implements the `Drop` trait for it. The `drop` function prints a message when an instance of `CustomSmartPointer` is about to go out of scope, showcasing custom cleanup behavior. The main function creates two instances of the struct and prints a message after their creation, demonstrating the order of execution.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/drop.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct CustomSmartPointer {\n    data: String,\n}\n\nimpl Drop for CustomSmartPointer {\n    fn drop(&mut self) {\n        println!(\"Dropping CustomSmartPointer with data `{}`!\", self.data);\n    }\n}\n\nfn main() {\n    let c = CustomSmartPointer { data: String::from(\"my stuff\") };\n    let d = CustomSmartPointer { data: String::from(\"other stuff\") };\n    println!(\"CustomSmartPointers created.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Running program with cargo run - Console\nDESCRIPTION: This is a console command to run the rust program with cargo run, passing program arguments after `--`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-01-accepting-command-line-arguments.md#_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n$ cargo run -- searchstring example-filename.txt\n```\n\n----------------------------------------\n\nTITLE: Refactoring `parse_config` to Return Config Struct Rust\nDESCRIPTION: This code snippet refactors the `parse_config` function to return an instance of a `Config` struct instead of a tuple.  The `Config` struct encapsulates the `query` and `file_path` values, improving code clarity and maintainability.  The `clone` method is used to avoid lifetime issues, creating owned `String` values within the `Config` struct.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-03-improving-error-handling-and-modularity.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-06/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Lifetime Annotation Examples in Rust\nDESCRIPTION: These examples demonstrate different ways to annotate references with lifetimes. They show a reference without a lifetime, a reference with an explicit lifetime named `'a`, and a mutable reference with the same lifetime `'a`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-03-lifetime-syntax.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n&i32        // a reference\n&'a i32     // a reference with an explicit lifetime\n&'a mut i32 // a mutable reference with an explicit lifetime\n```\n\n----------------------------------------\n\nTITLE: Compiler Output for Invalid i8 + Option<i8> Operation\nDESCRIPTION: This code shows the compiler output when you try to add an i8 to an Option<i8>. The compiler enforces explicit handling of the `Option` type, preventing potential null pointer exceptions. The output provides error details, guiding the developer to address the type mismatch and use the `Option` value safely.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-01-defining-an-enum.md#_snippet_13\n\nLANGUAGE: console\nCODE:\n```\n{{#include ../listings/ch06-enums-and-pattern-matching/no-listing-07-cant-use-option-directly/output.txt}}\n```\n\n----------------------------------------\n\nTITLE: Largest Function with Generic Type Parameter Rust\nDESCRIPTION: This function finds the largest element in a slice of any type `T`. It uses a generic type parameter `T` in the function signature. However, it won't compile without the `PartialOrd` trait bound because the `>` operator is used. It expects a slice of type T and returns a reference to the largest element of type T.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn largest<T>(list: &[T]) -> &T {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item > largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest(&number_list);\n    println!(\"The largest number is {result}\");\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest(&char_list);\n    println!(\"The largest char is {result}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Option Enum in Rust\nDESCRIPTION: This code snippet defines the `Option` enum with two variants: `None`, representing the absence of a value, and `Some(T)`, holding a value of type `T`. This enum is part of the standard library and is used to represent optional values, offering a safer alternative to null values.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-01-defining-an-enum.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nenum Option<T> {\n    None,\n    Some(T),\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Vec<T> of closures with Box<dyn Fn> in Rust\nDESCRIPTION: This example shows how to create a `Vec<T>` of closures defined by functions that return `Box<dyn Fn>`, allowing them to have the same type. This is necessary when you need to work with multiple functions that return closures with the same signature but different implementations.  Trait objects are used to achieve this.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-04-advanced-functions-and-closures.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn returns_closure() -> Box<dyn Fn(i32) -> i32> {\n    Box::new(|x| x + 1)\n}\n\nfn returns_initialized_closure(y: i32) -> Box<dyn Fn(i32) -> i32> {\n    Box::new(move |x| x + y)\n}\n\nfn main() {\n    let mut list: Vec<Box<dyn Fn(i32) -> i32>> = Vec::new();\n    list.push(returns_closure());\n    list.push(returns_initialized_closure(5));\n\n    for f in list {\n        println!(\"{}\", f(2));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implement methods on AveragedCollection struct in Rust\nDESCRIPTION: This code implements the `add`, `remove`, and `average` methods for the `AveragedCollection` struct. The `add` and `remove` methods update the `average` field by calling the private `update_average` method. This demonstrates encapsulation.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-01-what-is-oo.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimpl AveragedCollection {\n    pub fn add(&mut self, value: i32) {\n        self.list.push(value);\n        self.update_average();\n    }\n\n    pub fn remove(&mut self) -> Option<i32> {\n        let result = self.list.pop();\n        match result {\n            Some(value) => {\n                self.update_average();\n                Some(value)\n            }\n            None => None,\n        }\n    }\n\n    pub fn average(&self) -> f64 {\n        self.average\n    }\n\n    fn update_average(&mut self) {\n        let total: i32 = self.list.iter().sum();\n        self.average = total as f64 / self.list.len() as f64;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Cargo project\nDESCRIPTION: This command builds a Rust project using Cargo. It compiles the source code and creates an executable file in the `target/debug` directory. This command compiles the project in debug mode, generating an unoptimized executable with debug information.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-03-hello-cargo.md#_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n$ cargo build\n   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs\n```\n\n----------------------------------------\n\nTITLE: Approving a Post - Rust\nDESCRIPTION: This code snippet shows how to add an `approve` method to the `Post` struct and the `State` trait. The `approve` method changes the state of the post based on its current state. The `Draft`, `PendingReview`, and `Published` structs implement the `State` trait, defining their respective behaviors when a post is approved. The `PendingReview` state transitions to `Published` upon approval.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter18.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nimpl Post {\n    // --snip--\n    pub fn approve(&mut self) {\n        if let Some(s) = self.state.take() {\n            self.state = Some(s.approve())\n        }\n    }\n}\n\ntrait State {\n    fn request_review(self: Box<Self>) -> Box<dyn State>;\n    fn approve(self: Box<Self>) -> Box<dyn State>;\n}\n\nstruct Draft {}\n\nimpl State for Draft {\n    // --snip--\n    fn approve(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n}\n\nstruct PendingReview {}\n\nimpl State for PendingReview {\n    // --snip--\n    fn approve(self: Box<Self>) -> Box<dyn State> {\n        Box::new(Published {})\n    }\n}\n\nstruct Published {}\n\nimpl State for Published {\n    fn request_review(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n\n    fn approve(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: String Move Example in Rust\nDESCRIPTION: This code snippet demonstrates the move operation in Rust when assigning a `String` to another variable. After the assignment, the original variable (`s1`) is no longer valid to prevent double-free errors.  The ownership of the `String`'s heap data is transferred from `s1` to `s2`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\nlet s1 = String::from(\"hello\");\nlet s2 = s1;\n```\n\n----------------------------------------\n\nTITLE: Matching on Different Error Kinds in Rust\nDESCRIPTION: This code extends the previous example by matching on different error kinds. Specifically, it checks if the error is `ErrorKind::NotFound`. If so, it attempts to create the file; otherwise, it panics. This demonstrates handling specific error scenarios.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch09-02-recoverable-errors-with-result.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch09-error-handling/listing-09-05/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Let Statement with Tuple Destructuring\nDESCRIPTION: This example utilizes a `let` statement to destructure a tuple into three separate variables: `x`, `y`, and `z`. The values from the tuple `(1, 2, 3)` are assigned to the corresponding variables based on their position in the pattern. This demonstrates pattern matching for simultaneous variable initialization.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-01-all-the-places-for-patterns.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let (x, y, z) = (1, 2, 3);\n\n    println!(\"x = {}\", x);\n    println!(\"y = {}\", y);\n    println!(\"z = {}\", z);\n}\n```\n\n----------------------------------------\n\nTITLE: Closure Moving Ownership to a New Thread in Rust\nDESCRIPTION: This code demonstrates using the `move` keyword to force a closure to take ownership of the `list` vector when spawning a new thread. This ensures that the data is owned by the new thread and prevents potential issues if the main thread finishes before the new thread.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-01-closures.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\n\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(\"Before defining closure: {:?}\", list);\n\n    thread::spawn(move || println!(\"From thread: {:?}\", list))\n        .join()\n        .unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Testing with Result<T, E> - Rust\nDESCRIPTION: This snippet demonstrates how to write tests that return a `Result<T, E>` instead of panicking. It rewrites a basic test to return `Ok(())` on success and `Err(String)` on failure, allowing the use of the question mark operator for concise error handling within tests.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-01-writing-tests.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-10-result-in-tests/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Ignoring Values in a Tuple with `..` Rust\nDESCRIPTION: This code shows how to match only the first and last values in a tuple and ignore all other values in between using the `..` syntax. The `first` and `last` variables will be bound to the first and last elements of the tuple respectively.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let origin = (1, 2, 3, 4, 5);\n\n    match origin {\n        (first, .., last) => {\n            println!(\"First: {}\", first);\n            println!(\"Last: {}\", last);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Screen Struct with Trait Objects\nDESCRIPTION: This code defines a struct named `Screen` that holds a vector of trait objects `Box<dyn Draw>`. This allows the `Screen` to manage components of different types that all implement the `Draw` trait.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-02-trait-objects.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub struct Screen {\n    pub components: Vec<Box<dyn Draw>>,\n}\n```\n\n----------------------------------------\n\nTITLE: Running the minigrep Program in Shell\nDESCRIPTION: These shell commands demonstrate how to run the `minigrep` program with different queries and input files. It showcases how to search for a single line, multiple lines, and no lines in a given file using the program. The output shows the matching lines based on the provided query.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_21\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo run -- frog poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s\n     Running `target/debug/minigrep frog poem.txt`\nHow public, like a frog\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo run -- body poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep body poem.txt`\nI'm nobody! Who are you?\nAre you nobody, too?\nHow dreary to be somebody!\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo run -- monomorphization poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep monomorphization poem.txt`\n```\n\n----------------------------------------\n\nTITLE: Implementing the `add_text` Method\nDESCRIPTION: This snippet implements the `add_text` method on the `Post` struct, allowing text to be added to the `content` field of the post. It takes a mutable reference to `self` and appends the given text to the `content` string using `push_str`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-03-oo-design-patterns.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl Post {\n    pub fn add_text(&mut self, text: &str) {\n        self.content.push_str(text);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Post Struct and Draft State in lib.rs\nDESCRIPTION: This snippet defines the `Post` struct with a `state` field (Option<Box<dyn State>>) and a `content` field. It also includes the `new` function to create a new `Post` instance in the `Draft` state. It also includes the definition of `State` trait and `Draft` struct which implements the `State` trait.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter18.md#_snippet_11\n\nLANGUAGE: Rust\nCODE:\n```\npub struct Post {\n    state: Option<Box<dyn State>>,\n    content: String,\n}\n\nimpl Post {\n    pub fn new() -> Post {\n        Post {\n            state: Some(Box::new(Draft {})),\n            content: String::new(),\n        }\n    }\n}\n\ntrait State {}\n\nstruct Draft {}\n\nimpl State for Draft {}\n```\n\n----------------------------------------\n\nTITLE: Adding `ignore_case` Field to the `Config` struct\nDESCRIPTION: This Rust code snippet illustrates how to add an `ignore_case` field, a Boolean, to the `Config` struct. This field is used to configure case-sensitive or case-insensitive search mode.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-05-working-with-environment-variables.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-22/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Annotated Dangling Reference Code in Rust\nDESCRIPTION: This code is an annotated version of the previous example, highlighting the stages at which the `String` `s` is created and deallocated.  It emphasizes that returning a reference to `s` results in a dangling reference because `s` is deallocated when the `dangle` function finishes.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-02-references-and-borrowing.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let reference_to_nothing = dangle();\n}\n\nfn dangle() -> &String {\n    let s = String::from(\"hello\"); // s is created\n\n    &s // return a reference to the String s\n} // Here, s goes out of scope, and is dropped. Its memory goes away.\n  // Danger!\n\n```\n\n----------------------------------------\n\nTITLE: Typed Vec of Futures Using Trait Objects in Rust\nDESCRIPTION: This snippet shows how to store a collection of different anonymous futures in a `Vec` by using trait objects.  It declares the type of the `futures` variable as `Vec<Box<dyn Future<Output = ()>>>`, which allows storing futures with the same output type. This addresses the type mismatch errors encountered when attempting to store different async block types directly in a `Vec`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nlet futures: Vec<Box<dyn Future<Output = ()>>> =\n            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];\n```\n\n----------------------------------------\n\nTITLE: Function Returning a User Struct in Rust\nDESCRIPTION: Defines a function `build_user` that takes an email and username as input and returns a `User` struct instance. The `active` field is set to `true` and `sign_in_count` is set to `1`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-01-defining-structs.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn build_user(email: String, username: String) -> User {\n    User {\n        active: true,\n        username: username,\n        email: email,\n        sign_in_count: 1,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Improving Error Message - Rust\nDESCRIPTION: This snippet adds a check within the `Config::new` constructor to ensure that enough command-line arguments are provided. If fewer than three arguments are present, the program panics with a user-friendly error message, indicating that not enough arguments were provided.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n    // --snip--\n    fn new(args: &[String]) -> Config {\n        if args.len() < 3 {\n            panic!(\"not enough arguments\");\n        }\n        // --snip--\n\n```\n\n----------------------------------------\n\nTITLE: Variable Scope\nDESCRIPTION: This code snippet demonstrates variable scope in Rust. The variable `s` is valid from the point it's declared until the end of the current scope.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet s = \"hello\";\n```\n\n----------------------------------------\n\nTITLE: Full Web Server Implementation - Rust\nDESCRIPTION: This is the complete main.rs file that handles setting up the listener for the web server as well as the connection handling and request parsing.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_32\n\nLANGUAGE: Rust\nCODE:\n```\nuse hello::ThreadPool;\nuse std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n    thread,\n    time::Duration,\n};\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    let pool = ThreadPool::new(4);\n\n    for stream in listener.incoming().take(2) {\n        let stream = stream.unwrap();\n\n        pool.execute(|| {\n            handle_connection(stream);\n        });\n    }\n\n    println!(\"Shutting down.\");\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&stream);\n    let request_line = buf_reader.lines().next().unwrap().unwrap();\n\n    let (status_line, filename) = match &request_line[..] {\n        \"GET / HTTP/1.1\" => (\"HTTP/1.1 200 OK\", \"hello.html\"),\n        \"GET /sleep HTTP/1.1\" => {\n            thread::sleep(Duration::from_secs(5));\n            (\"HTTP/1.1 200 OK\", \"hello.html\")\n        }\n        _ => (\"HTTP/1.1 404 NOT FOUND\", \"404.html\"),\n    };\n\n    let contents = fs::read_to_string(filename).unwrap();\n    let length = contents.len();\n\n    let response =\n        format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Match Option<i32> with Value Increment in Rust\nDESCRIPTION: This code demonstrates using `match` with `Option<i32>`. The `plus_one` function takes an `Option<i32>` as input and returns `Some(i + 1)` if the input is `Some(i)`, or `None` if the input is `None`. This shows how to handle optional values using pattern matching.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-02-match.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn plus_one(x: Option<i32>) -> Option<i32> {\n    match x {\n        None => None,\n        Some(i) => Some(i + 1),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Async Channel with `move` Closure in Rust (Complete)\nDESCRIPTION: This example fixes the termination issue by using an `async move` block for the sender. This moves ownership of `tx` into the async block, ensuring it is dropped when the block completes, which then closes the channel and allows the receiver to terminate.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-02-concurrency-with-async.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse trpl::sleep;\n\nasync fn with_move() {\n    let (tx, rx) = trpl::channel();\n\n    let vals = [\"first\", \"second\", \"third\", \"fourth\"];\n\n    trpl::join(\n        async move {\n            for val in vals {\n                println!(\"sending {}\", val);\n                tx.send(val).await;\n                sleep(0.5).await;\n            }\n        },\n        async {\n            while let Some(msg) = rx.recv().await {\n                println!(\"received {}\", msg);\n            }\n        },\n    )\n    .await;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Running Rust Project with Cargo\nDESCRIPTION: The `cargo run` command compiles and executes the specified Rust project. It shows the compilation progress and the final output of the executed program, which in this case is \"Hello, world!\".\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s\n  Running `target/debug/guessing_game`\nHello, world!\n```\n\n----------------------------------------\n\nTITLE: Public Enum with Public Variants Rust\nDESCRIPTION: This snippet demonstrates how to define a public enum in Rust. When an enum is declared as public, all of its variants are automatically public. This example shows the `Appetizer` enum with `Soup` and `Salad` variants.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nmod back_of_house {\n    pub enum Appetizer {\n        Soup,\n        Salad,\n    }\n}\n\npub fn eat_at_restaurant() {\n    let order1 = back_of_house::Appetizer::Soup;\n    let order2 = back_of_house::Appetizer::Salad;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Node struct with a Weak parent reference in Rust\nDESCRIPTION: This code snippet defines a `Node` struct with a `parent` field of type `RefCell<Weak<Node>>`. This allows a child node to refer to its parent without creating a strong reference cycle. The `value` field holds an `i32`, the `parent` field holds a weak reference to the parent `Node`, and the `children` field holds a vector of `Rc<Node>` representing the child nodes.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-06-reference-cycles.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell<Weak<Node>>,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n\nfn main() {}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait\nDESCRIPTION: This snippet defines a public trait called `Summary` with a method signature `summarize(&self) -> String`.  Types implementing this trait must provide their own implementation for the `summarize` method, which returns a string summary.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\npub trait Summary {\n    fn summarize(&self) -> String;\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying a Mutable Struct Field in Rust\nDESCRIPTION: Demonstrates how to change the value of a field in a mutable `User` instance. It shows how to declare a struct instance as mutable and then use dot notation to modify the value of a specific field.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-01-defining-structs.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut user1 = User {\n        email: String::from(\"someone@example.com\"),\n        username: String::from(\"someusername123\"),\n        active: true,\n        sign_in_count: 1,\n    };\n\n    user1.email = String::from(\"anotheremail@example.com\");\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Stream Errors in Async Loops\nDESCRIPTION: This snippet shows how to handle errors that may occur during message sending in channel-based streams. It demonstrates printing the error and breaking from the loop to prevent further attempts to send messages after the channel has closed.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-04-streams.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nasync fn errors() {\n    let (tx, rx) = mpsc::channel(100);\n\n    tokio::spawn(async move {\n        for i in 0.. {\n            if tx.send(i).await.is_err() {\n                println!(\"Error sending\");\n                break;\n            }\n            tokio::time::sleep(Duration::from_millis(100)).await;\n        }\n    });\n\n    let mut stream = ReceiverStream(rx);\n\n    while let Some(message) = stream.next().await {\n        println!(\"Got: {}\", message);\n    }\n\n    println!(\"Stream finished\");\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Config::build Signature\nDESCRIPTION: This snippet shows the updated signature of the `Config::build` function to accept a generic iterator that yields `String` items. This change allows the function to take ownership of the iterator and avoid borrowing a slice.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-03-improving-our-io-project.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl Config {\n    pub fn build<T>(mut args: T) -> Result<Config, &'static str>\n    where\n        T: Iterator<Item = String>,\n    {\n        todo!()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Ownership to Prevent Dangling Reference - Rust\nDESCRIPTION: This code demonstrates the correct way to return a `String` without creating a dangling reference. Instead of returning a reference, the function `no_dangle` returns the `String` itself, transferring ownership to the caller. This prevents the `String` from being deallocated before the caller can use it.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_22\n\nLANGUAGE: Rust\nCODE:\n```\nfn no_dangle() -> String {\n    let s = String::from(\"hello\");\n\n    s\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream with a Counter in Rust\nDESCRIPTION: This snippet demonstrates how to create an asynchronous stream that emits a counter value every millisecond. It uses `tokio::spawn` to create a task, `tokio::time::sleep` for the delay, and `tokio::sync::mpsc` for sending the counter values through a channel. The return type is `impl Stream<Item = u32>`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-04-streams.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nasync fn get_intervals() -> impl Stream<Item = u32> {\n    let (tx, rx) = mpsc::channel(100);\n\n    tokio::spawn(async move {\n        let mut count = 0;\n        loop {\n            tokio::time::sleep(Duration::from_millis(1)).await;\n            count += 1;\n            if tx.send(count).await.is_err() {\n                break;\n            }\n        }\n    });\n\n    ReceiverStream(rx)\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating over Bytes in a String - Rust\nDESCRIPTION: This example iterates over the raw bytes of a string using the `bytes()` method.  Each byte is printed to the console. This is useful for lower-level operations or when dealing with specific encodings.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_26\n\nLANGUAGE: Rust\nCODE:\n```\nfor b in \"\".bytes() {\n    println!(\"{b}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Non-Zero Value in Rust 'if'\nDESCRIPTION: This code demonstrates how to explicitly check if a number is not equal to zero within an 'if' condition in Rust. It uses the '!=' operator to compare 'number' to 0 and execute the code block only if the condition is true.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_28\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let number = 3;\n\n    if number != 0 {\n        println!(\"number was something other than zero\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Getting user guess and printing\nDESCRIPTION: This code snippet gets input from the user using `std::io::stdin().read_line()` and prints it to the console. It imports the `io` library from the standard library and creates a mutable string variable to store the user's input.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_4\n\nLANGUAGE: rust,ignore\nCODE:\n```\n{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:all}}\n```\n\n----------------------------------------\n\nTITLE: Testing add_two Function with assert_eq! in Rust\nDESCRIPTION: This test case uses the `assert_eq!` macro to check if the `add_two` function returns the expected value when called with a specific input. It exemplifies the use of equality assertions for verifying function outputs in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-01-writing-tests.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-07/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Destructuring Tuple in for Loop using Pattern in Rust\nDESCRIPTION: This snippet demonstrates using a pattern within a `for` loop to destructure a tuple generated by the `enumerate` method. It iterates through a vector of characters and prints each character along with its index.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n    let v = vec!['a', 'b', 'c'];\n\n    for (index, value) in v.iter().enumerate() {\n        println!(\"{value} is at index {index}\");\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Draw Trait for SelectBox Struct in Rust\nDESCRIPTION: This snippet demonstrates a hypothetical implementation of the `Draw` trait for a `SelectBox` struct, showing how a user of the library might extend it with their own components. The `SelectBox` struct has fields for `width`, `height`, and `options`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-02-trait-objects.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nstruct SelectBox {\n    width: u32,\n    height: u32,\n    options: Vec<String>,\n}\n\nimpl Draw for SelectBox {\n    fn draw(&self) {\n        // Code to actually draw a select box would go here\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating a Potential Data Race with String Indices\nDESCRIPTION: This Rust code snippet demonstrates a potential data race where a stored index becomes invalid after the String is modified.  It showcases the danger of using indices directly without slices.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-03-slices.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-08/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Attempting to print a Rectangle instance (Fails)\nDESCRIPTION: This code snippet attempts to print a `Rectangle` struct using `println!` without implementing the `Debug` trait. It highlights the error that occurs when trying to use the default `Display` formatting on a custom struct.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-02-example-structs.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-11/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Monomorphization Example\nDESCRIPTION: This snippet illustrates monomorphization of generic types at compile time. The generic `Option<T>` enum is expanded into two specific definitions, `Option_i32` and `Option_f64`, based on the types used in the code.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nenum Option_i32 {\n    Some(i32),\n    None,\n}\n\nenum Option_f64 {\n    Some(f64),\n    None,\n}\n\nfn main() {\n    let integer = Option_i32::Some(5);\n    let float = Option_f64::Some(5.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Mutex in a Single-Threaded Context in Rust\nDESCRIPTION: This snippet demonstrates the basic usage of `Mutex<T>` in a single-threaded context. It initializes a mutex with a value, acquires a lock to access and modify the value, and then releases the lock when the `MutexGuard` goes out of scope.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter16.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::Mutex;\n\nfn main() {\n    let m = Mutex::new(5);\n\n    {\n        let mut num = m.lock().unwrap();\n        *num = 6;\n    }\n\n    println!(\"m = {m:?}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using `?` on an `Option<T>` value in Rust\nDESCRIPTION: This function `last_char_of_first_line` takes a string slice as input and attempts to return the last character of the first line. It uses the `?` operator to handle the cases where the input string is empty or the first line is empty, returning `None` in those scenarios. The return type is `Option<char>`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch09-02-recoverable-errors-with-result.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch09-error-handling/listing-09-11/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Attempting to use `?` in `main` returning `()` in Rust\nDESCRIPTION: This code snippet demonstrates an attempt to use the `?` operator within the `main` function, which has a return type of `()`. This results in a compilation error because the `?` operator is used on a `Result` value returned by `File::open`, which is incompatible with the `()` return type. The code opens a file and uses the `?` to propagate errors.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch09-02-recoverable-errors-with-result.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch09-error-handling/listing-09-10/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Defining a Hello Function with String Slice Parameter in Rust\nDESCRIPTION: This Rust function `hello` takes a string slice (`&str`) as input and prints a greeting message. It demonstrates the usage of string slices and serves as an example for illustrating Deref coercion later.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nfn hello(name: &str) {\n    println!(\"Hello, {name}!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Saving Argument Values - Rust\nDESCRIPTION: This snippet shows how to save command line arguments into variables for further use within the program. It accesses the arguments from the vector created earlier, assigning the first argument (search query) to `query` and the second argument (file path) to `file_path`. It assumes that at least two arguments are provided.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::env;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let query = &args[1];\n    let file_path = &args[2];\n\n    println!(\"Searching for {query}\");\n    println!(\"In file {file_path}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Ownership to Prevent Dangling Reference in Rust\nDESCRIPTION: This code demonstrates the solution to the dangling reference problem. Instead of returning a reference to the `String`, the `String` itself is returned, transferring ownership to the caller. This prevents the `String` from being deallocated before the caller can use it.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-02-references-and-borrowing.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let string = no_dangle();\n}\n\nfn no_dangle() -> String {\n    let s = String::from(\"hello\");\n\n    s\n}\n```\n\n----------------------------------------\n\nTITLE: Methods on Enums in Rust\nDESCRIPTION: This code defines a method called `call` on the `Message` enum.  It creates a `Message::Write` instance and then calls the `call` method on it, demonstrating how to add functionality to enums.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-01-defining-an-enum.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nimpl Message {\n    fn call(&self) {\n        // method body would be defined here\n    }\n}\n\nfn main() {\n    let m = Message::Write(String::from(\"hello\"));\n    m.call();\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a mutable String variable\nDESCRIPTION: This snippet creates a mutable variable named `guess` and initializes it with an empty `String`. The `mut` keyword allows the string's value to be changed, and `String::new()` creates a new, empty string.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_8\n\nLANGUAGE: rust,ignore\nCODE:\n```\n{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:string}}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Match in Rust\nDESCRIPTION: This Rust code snippet demonstrates pattern matching using the `match` keyword. It matches against a `Some` variant of an `Option` type. The snippet showcases matching a specific value (50), binding a value to a variable (y), and using a default case with a wildcard (_). The variable `x` is an optional integer, and `y` is initialized to 10. The `match` statement then compares `x` to several patterns.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/patterns.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet x = Some(5);\nlet y = 10;\n\nmatch x {\n    Some(50) => println!(\"Got 50\"),\n    Some(y) => println!(\"Matched, y = {:?}\", y),\n    _ => println!(\"Default case, x = {:?}\", x),\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Project Directory (Windows CMD)\nDESCRIPTION: Creates a 'projects' directory within the user's profile directory, navigates into it, and then creates a 'hello_world' directory within 'projects'. Finally, it changes the current directory to 'hello_world'.  The /d flag in the cd command is needed to change drives if the user profile is on a different drive.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_9\n\nLANGUAGE: Shell\nCODE:\n```\n> mkdir \"%USERPROFILE%\\projects\"\n> cd /d \"%USERPROFILE%\\projects\"\n> mkdir hello_world\n> cd hello_world\n```\n\n----------------------------------------\n\nTITLE: Initializing an Array with Default Value\nDESCRIPTION: This snippet shows how to initialize an array with a specified length, where each element has the same initial value. This is a concise way to create an array with repeated values.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-02-data-types.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nlet a = [3; 5];\n\n```\n\n----------------------------------------\n\nTITLE: Struct Definition with Lifetime Annotation in Rust\nDESCRIPTION: Defines a struct `ImportantExcerpt` that holds a reference to a string slice. The lifetime annotation ensures that the reference in the struct does not outlive the data it refers to. The example also demonstrates how to create an instance of the struct.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_45\n\nLANGUAGE: rust\nCODE:\n```\nstruct ImportantExcerpt<'a> {\n    part: &'a str,\n}\n\nfn main() {\n    let novel = String::from(\"Call me Ishmael. Some years ago...\");\n    let first_sentence = novel.split('.').next().unwrap();\n    let i = ImportantExcerpt {\n        part: first_sentence,\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: State Machine Enum Example - Rust\nDESCRIPTION: Example of an enum illustrating how Rust manages state transitions in async code. The compiler automates the creation and management of these state machine data structures.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-01-futures-and-syntax.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch17-async-await/no-listing-state-machine/src/lib.rs:enum}}\n```\n\n----------------------------------------\n\nTITLE: Implementing `area` and `can_hold` methods in Rust\nDESCRIPTION: This example demonstrates how to implement the `area` and `can_hold` methods within separate `impl` blocks for the `Rectangle` struct. The `area` method calculates the area of the rectangle, while the `can_hold` method checks if one rectangle can contain another based on their dimensions.  This highlights the flexibility of using multiple `impl` blocks to organize code.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nimpl Rectangle {\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n}\n\nimpl Rectangle {\n    fn can_hold(&self, other: &Rectangle) -> bool {\n        self.width > other.width && self.height > other.height\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Tracking strong and weak counts in Rust\nDESCRIPTION: Demonstrates how strong and weak reference counts of Rc pointers change when a branch node is created in an inner scope and then dropped. Includes printing the counts of both leaf and branch at different stages to illustrate how Weak pointers prevent memory leaks caused by reference cycles.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_27\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n\n    {\n        let branch = Rc::new(Node {\n            value: 5,\n            parent: RefCell::new(Weak::new()),\n            children: RefCell::new(vec![Rc::clone(&leaf)]),\n        });\n\n        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n\n        println!(\n            \"branch strong = {}, weak = {}\",\n            Rc::strong_count(&branch),\n            Rc::weak_count(&branch),\n        );\n\n        println!(\n            \"leaf strong = {}, weak = {}\",\n            Rc::strong_count(&leaf),\n            Rc::weak_count(&leaf),\n        );\n    }\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Failure Message with assert! in Rust\nDESCRIPTION: This snippet shows how to add a custom failure message to the `assert!` macro for better debugging. The `greeting` function returns a greeting string, and the test asserts that the result contains the name \"Carol\". If the assertion fails, a custom message is printed indicating the actual value of the greeting. Dependencies: None. Inputs: String `name`. Outputs: String formatted as `Hello {name}!`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\npub fn greeting(name: &str) -> String {\n    format!(\"Hello {name}!\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn greeting_contains_name() {\n        let result = greeting(\"Carol\");\n        assert!(result.contains(\"Carol\"));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Numbers with Ordering Enum and Match - Rust\nDESCRIPTION: This code snippet demonstrates comparing a user's guess to a secret number using the `Ordering` enum from `std::cmp` and a `match` expression to determine if the guess is less than, greater than, or equal to the secret number.  It requires importing `std::cmp::Ordering`. The code takes the `guess` and `secret_number` variables as input and prints a message based on the comparison result.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nuse std::cmp::Ordering;\n\n// ... other code ...\n\nmatch guess.cmp(&secret_number) {\n    Ordering::Less => println!(\"Too small!\"),\n    Ordering::Greater => println!(\"Too big!\"),\n    Ordering::Equal => println!(\"You win!\"),\n}\n```\n\n----------------------------------------\n\nTITLE: Calling std::mem::drop to Drop Value Rust\nDESCRIPTION: This code snippet shows how to use `std::mem::drop` to explicitly drop a `CustomSmartPointer` before it goes out of scope. This forces the `drop` method of the `CustomSmartPointer` to be called, allowing for early cleanup of resources.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let c = CustomSmartPointer {\n        data: String::from(\"some data\"),\n    };\n    println!(\"CustomSmartPointer created.\");\n    drop(c);\n    println!(\"CustomSmartPointer dropped before the end of main.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using External Package (rand) in Rust\nDESCRIPTION: This example shows how to bring the `Rng` trait into scope from the `rand` crate and then use the `rand::thread_rng` function to generate a random number.  This requires adding the `rand` crate as a dependency in the project's `Cargo.toml` file.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse rand::Rng;\n\nfn main() {\n    let secret_number = rand::thread_rng().gen_range(1..101);\n    println!(\"The secret number is: {}\", secret_number);\n}\n```\n\n----------------------------------------\n\nTITLE: Receiving a Message from a Thread in Rust\nDESCRIPTION: This snippet shows how to receive a message in the main thread using the receiver (`rx`) half of the channel. The `recv` method blocks the main thread until a message is received. Once a message is received, it is printed to the console. `unwrap` is used for basic error handling.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter16.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        tx.send(val).unwrap();\n    });\n\n    let received = rx.recv().unwrap();\n    println!(\"Got: {received}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Function that Takes an Enum in Rust\nDESCRIPTION: This code defines a function called `route` that takes an `IpAddrKind` enum as an argument. It demonstrates how to use enums as function parameters.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-01-defining-an-enum.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn route(ip_kind: IpAddrKind) {}\n```\n\n----------------------------------------\n\nTITLE: Method with Lifetime Elision in Return Value\nDESCRIPTION: This code demonstrates a method `announce_and_return_part` that takes a reference to `self` and another string slice reference, and returns a string slice. The lifetime of `&self` is implicitly assigned to the return value due to lifetime elision rules.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-03-lifetime-syntax.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'a> ImportantExcerpt<'a> {\n    fn announce_and_return_part(&self, announcement: &str) -> &str {\n        println!(\"Attention please: {}\", announcement);\n        self.part\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Stream Trait in Rust\nDESCRIPTION: This snippet defines a `Stream` trait in Rust, similar to an asynchronous iterator. It includes an associated type `Item` for the type of items produced by the stream and a `poll_next` method to asynchronously retrieve the next item, returning a `Poll<Option<Self::Item>>` to indicate readiness and the presence of more items.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_51\n\nLANGUAGE: rust\nCODE:\n```\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\n\ntrait Stream {\n    type Item;\n\n    fn poll_next(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>\n    ) -> Poll<Option<Self::Item>>;\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling in Main Function - Rust\nDESCRIPTION: This code snippet demonstrates error handling in the main function using `if let` to check if the `run` function returns an error. If an error is returned, it prints an error message to the console and exits the program with a failure status code.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // --snip--\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    if let Err(e) = run(config) {\n        println!(\"Application error: {e}\");\n        process::exit(1);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Unit Test Module with cfg Attribute in Rust\nDESCRIPTION: This snippet shows the basic structure of a unit test module in Rust, including the `#[cfg(test)]` annotation, which tells Rust to compile and run the test code only when you run `cargo test`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-03-test-organization.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-01/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Handling Result with Match\nDESCRIPTION: This code snippet shows how to handle a `Result` using a `match` expression. If the `File::open` call returns `Ok`, the file handle is assigned to `greeting_file`. If it returns `Err`, the program panics. Requires `std::fs::File` to be imported.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter09.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs::File;\n\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n\n    let greeting_file = match greeting_file_result {\n        Ok(file) => file,\n        Err(error) => panic!(\"Problem opening the file: {error:?}\"),\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Private Functions in Rust\nDESCRIPTION: This snippet demonstrates how to test private functions in Rust. Even though `internal_adder` is not marked as `pub`, it can still be tested within the `tests` module because the test module has access to its parent module's items via `use super::*;`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\npub fn add_two(a: usize) -> usize {\n    internal_adder(a, 2)\n}\n\nfn internal_adder(left: usize, right: usize) -> usize {\n    left + right\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn internal() {\n        let result = internal_adder(2, 2);\n        assert_eq!(result, 4);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Finding the Largest Number in a List\nDESCRIPTION: This code snippet demonstrates how to find the largest number within a list of integers in Rust. It initializes `largest` with the first element and iterates through the list, updating `largest` if a larger number is found.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-00-generics.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let mut largest = number_list[0];\n\n    for number in number_list {\n        if number > largest {\n            largest = number;\n        }\n    }\n\n    println!(\"The largest number is {}\", largest);\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing a Vector with Values Using the vec! Macro in Rust\nDESCRIPTION: This snippet shows how to create a vector and initialize it with values using the `vec!` macro. Rust infers the type of the vector elements (i32) based on the initial values provided, eliminating the need for explicit type annotation.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-01-vectors.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let v = vec![1, 2, 3];\n}\n```\n\n----------------------------------------\n\nTITLE: Writing HTTP Response to TCP Stream in Rust\nDESCRIPTION: This snippet shows how to write a basic HTTP '200 OK' response to a TCP stream. It defines a string containing the HTTP response and converts it to bytes before writing it to the stream using `stream.write_all()`. Dependencies include `std::net::TcpStream` and `std::io::Write`. The input is a `TcpStream`, and the output is the HTTP response sent to the client.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&stream);\n    let http_request: Vec<_> = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    let response = \"HTTP/1.1 200 OK\\r\\n\\r\\n\";\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the Drop Trait\nDESCRIPTION: This snippet demonstrates how to implement the `Drop` trait for a custom struct. The `drop` method is called automatically when an instance of the struct goes out of scope, allowing for resource cleanup or other actions. The example uses `println!` to visually demonstrate when the `drop` method is called.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-03-drop.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct CustomSmartPointer {\n    data: String,\n}\n\nimpl Drop for CustomSmartPointer {\n    fn drop(&mut self) {\n        println!(\"Dropping CustomSmartPointer with data `{}`!\", self.data);\n    }\n}\n\nfn main() {\n    let c = CustomSmartPointer { data: String::from(\"my stuff\") };\n    let d = CustomSmartPointer { data: String::from(\"other stuff\") };\n    println!(\"CustomSmartPointers created.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Submodule in hosting.rs (Rust)\nDESCRIPTION: This code snippet represents the contents of the `src/front_of_house/hosting.rs` file, which contains the definition of the `hosting` submodule of the `front_of_house` module. The actual code for the `hosting` module is expected to be placed within this file.  This demonstrates how submodule definitions are separated into their own files.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-05-separating-modules-into-different-files.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// Definitions made in the `hosting` module\n```\n\n----------------------------------------\n\nTITLE: Timeout Function Signature in Rust\nDESCRIPTION: This snippet defines the signature of the `timeout` function. It's an async function that takes a future and a duration as input, and returns a `Result`. The `Result` contains either the output of the future or a `Duration` indicating the timeout period.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_32\n\nLANGUAGE: rust\nCODE:\n```\nasync fn timeout<F: Future>(\n    future_to_try: F,\n    max_time: Duration,\n) -> Result<F::Output, Duration> {\n    // Here is where our implementation will go!\n}\n```\n\n----------------------------------------\n\nTITLE: Using String::to_string with the map method in Rust\nDESCRIPTION: This example demonstrates how to use the `String::to_string` method as an argument to the `map` method, achieving the same result as using a closure. The `to_string` function is used to convert each number in a vector to its string representation.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-04-advanced-functions-and-closures.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let list_of_numbers = vec![1, 2, 3];\n    let list_of_strings: Vec<String> = list_of_numbers\n        .iter()\n        .map(String::to_string)\n        .collect();\n    println!(\"{:?}\", list_of_strings);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Deref Trait for MyBox in Rust\nDESCRIPTION: This code snippet demonstrates the implementation of the `Deref` trait for a custom smart pointer `MyBox`. The `Deref` trait allows instances of `MyBox` to be dereferenced, providing access to the underlying value of type `T`. The `deref` method returns a reference to the inner data, allowing it to be treated as a regular reference.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/deref-coercions.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops::Deref;\n\n# struct MyBox<T>(T);\nimpl<T> Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        &self.0\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Method Using Different Generic Types Than Struct Definition\nDESCRIPTION: This snippet demonstrates a method (`mixup`) that uses generic types different from the struct's definition. The method creates a new `Point` instance with the `x` value from the `self` `Point` and the `y` value from the passed-in `Point`. The example in `main` shows the usage with different types.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point<X1, Y1> {\n    x: X1,\n    y: Y1,\n}\n\nimpl<X1, Y1> Point<X1, Y1> {\n    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {\n        Point {\n            x: self.x,\n            y: other.y,\n        }\n    }\n}\n\nfn main() {\n    let p1 = Point { x: 5, y: 10.4 };\n    let p2 = Point { x: \"Hello\", y: 'c' };\n\n    let p3 = p1.mixup(p2);\n\n    println!(\"p3.x = {}, p3.y = {}\", p3.x, p3.y);\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing IP Address with Expect in Rust\nDESCRIPTION: This snippet demonstrates creating an `IpAddr` instance from a hardcoded string using the `parse` method and handling the `Result` with `expect`. While the compiler requires handling the `Result`, the example asserts the string is a valid IP address, making `expect` appropriate. It prompts a change to better error-handling if the IP address source changes in the future.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch09-03-to-panic-or-not-to-panic.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::net::IpAddr;\n\nfn main() {\n    let home: IpAddr = \"127.0.0.1\"\n        .parse()\n        .expect(\"Hardcoded IP address should be valid\");\n    println!(\"{}\", home);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a new Cargo project\nDESCRIPTION: This command creates a new Rust project using Cargo. It initializes a new directory with the specified project name and sets up the basic project structure, including a Cargo.toml file and a src directory with a main.rs file. After creating the project, the command changes the current directory to the newly created project directory.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-03-hello-cargo.md#_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ cargo new hello_cargo\n$ cd hello_cargo\n```\n\n----------------------------------------\n\nTITLE: Simulating Slow Request - Rust\nDESCRIPTION: This code snippet shows how to simulate a slow request by adding a `/sleep` endpoint to the web server. When the server receives a request to `/sleep`, it sleeps for 5 seconds before responding with a successful HTML page. This demonstrates the blocking behavior of the single-threaded server.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-02-multithreaded.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let listener = std::net::TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        handle_connection(stream);\n    }\n}\n\nfn handle_connection(mut stream: std::net::TcpStream) {\n    use std::io::prelude::*;\n\n    let mut buffer = [0; 1024];\n\n    stream.read(&mut buffer).unwrap();\n\n    let request_line = String::from_utf8_lossy(&buffer);\n    let request_line = request_line.lines().next().unwrap();\n\n    let (status_line, filename) = match &request_line[..] {\n        \"GET / HTTP/1.1\" => (\"HTTP/1.1 200 OK\", \"hello.html\"),\n        \"GET /sleep HTTP/1.1\" => {\n            thread::sleep(Duration::from_secs(5));\n            (\"HTTP/1.1 200 OK\", \"hello.html\")\n        }\n        _ => (\"HTTP/1.1 404 NOT FOUND\", \"404.html\"),\n    };\n\n    let contents = std::fs::read_to_string(filename).unwrap();\n\n    let response = format!(\n        \"{}\\r\\nContent-Length: {}\\r\\n\\r\\n{}\",\n        status_line,\n        contents.len(),\n        contents\n    );\n\n    stream.write_all(response.as_bytes()).unwrap();\n    stream.flush().unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Copying Integers in Rust\nDESCRIPTION: This code demonstrates how integers are copied in Rust. Because integers have a known size at compile time and are stored on the stack, copying them is inexpensive and does not invalidate the original variable.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_9\n\nLANGUAGE: Rust\nCODE:\n```\nlet x = 5;\nlet y = x;\n\nprintln!(\"x = {x}, y = {y}\");\n```\n\n----------------------------------------\n\nTITLE: Setting Panic Behavior to Abort in Cargo.toml - TOML\nDESCRIPTION: This snippet shows how to configure a Cargo.toml file to abort the program immediately upon a panic, instead of unwinding the stack. This can reduce the size of the resulting binary.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter09.md#_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n[profile.release]\npanic = 'abort'\n```\n\n----------------------------------------\n\nTITLE: Reading File Contents - Rust\nDESCRIPTION: This code snippet reads the contents of a file specified by the second command line argument using `fs::read_to_string`. The file path is accessed from the `env::args` iterator. The content is then printed to the console using `println!`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-02-reading-a-file.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::env;\nuse std::fs;\nuse std::process;\n\nuse minigrep::Config;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::new(&args).unwrap_or_else(|err| {\n        eprintln!(\"Problem parsing arguments: {}\", err);\n        process::exit(1);\n    });\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    if let Err(e) = minigrep::run(config) {\n        eprintln!(\"Application error: {}\", e);\n\n        process::exit(1);\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Smart Pointer `MyBox<T>` in Rust\nDESCRIPTION: Defines a custom smart pointer type `MyBox<T>`, a tuple struct with a single element of type `T`. Also defines a `new` function to create instances of `MyBox<T>`. This example demonstrates creating a custom smart pointer similar to `Box<T>`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-02-deref.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyBox<T>(T);\n\nimpl<T> MyBox<T> {\n    fn new(x: T) -> MyBox<T> {\n        MyBox(x)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Equality with assert_eq! in Rust\nDESCRIPTION: This snippet demonstrates how to test equality between the result of a function and an expected value using the `assert_eq!` macro. The `add_two` function adds 2 to its parameter, and the test checks if the result of `add_two(2)` is equal to 4. Dependencies: None. Inputs: Integer `a`. Outputs: Integer `a+2`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\npub fn add_two(a: usize) -> usize {\n    a + 2\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_adds_two() {\n        let result = add_two(2);\n        assert_eq!(result, 4);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Errors to Standard Error with eprintln! in Rust\nDESCRIPTION: This code snippet demonstrates how to use the `eprintln!` macro in Rust to print error messages to the standard error stream. This ensures that error messages are displayed on the console even when the standard output is redirected to a file. It covers error handling for argument parsing and application runtime errors.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_28\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::build(&args).unwrap_or_else(|err| {\n        eprintln!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    if let Err(e) = minigrep::run(config) {\n        eprintln!(\"Application error: {e}\");\n        process::exit(1);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Error Propagation Operator Example\nDESCRIPTION: Demonstrates the error propagation operator (`?`) in Rust. It is used to propagate errors up the call stack. If the expression evaluates to `Ok(value)`, the value is returned. If it evaluates to `Err(err)`, the error is returned early from the function.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_55\n\nLANGUAGE: Rust\nCODE:\n```\nexpr?\n```\n\n----------------------------------------\n\nTITLE: Handling Futures with Distinct Output Types in Rust\nDESCRIPTION: This code snippet illustrates using `trpl::join!` to await multiple futures with different output types. `trpl::join!` can handle a fixed number of futures with varying types, while `trpl::join_all` requires all futures to have the same type. The example defines three futures, each with a different output type (`u32`, `&str`, and `bool`).\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-03-more-futures.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch17-async-await/listing-17-20/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Organizing and Exporting Items in `art` Crate in Rust\nDESCRIPTION: This snippet shows how to organize items into modules (`kinds` and `utils`) within a crate. It defines enums `PrimaryColor` and `SecondaryColor` in the `kinds` module and a function `mix` in the `utils` module. It demonstrates the initial structure of an `art` library before re-exporting items.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n//! # Art\n//!\n//! A library for modeling artistic concepts.\n\npub mod kinds {\n    /// The primary colors according to the RYB color model.\n    pub enum PrimaryColor {\n        Red,\n        Yellow,\n        Blue,\n    }\n\n    /// The secondary colors according to the RYB color model.\n    pub enum SecondaryColor {\n        Orange,\n        Green,\n        Purple,\n    }\n}\n\npub mod utils {\n    use crate::kinds::*;\n\n    /// Combines two primary colors in equal amounts to create\n    /// a secondary color.\n    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {\n        // --snip--\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying a Mutable Struct Field in Rust\nDESCRIPTION: This code creates a mutable instance of the `User` struct and modifies the value of its `email` field. It illustrates how to change the value of a field in a mutable struct instance using dot notation.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut user1 = User {\n        active: true,\n        username: String::from(\"someusername123\"),\n        email: String::from(\"someone@example.com\"),\n        sign_in_count: 1,\n    };\n\n    user1.email = String::from(\"anotheremail@example.com\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using expect() for Panic on Error in Rust\nDESCRIPTION: This snippet demonstrates the `expect()` method, which is similar to `unwrap()` but allows you to specify a custom panic message. This makes debugging easier by providing more context when an error occurs.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch09-02-recoverable-errors-with-result.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch09-error-handling/no-listing-05-expect/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Racing Two URLs for Page Titles\nDESCRIPTION: This code demonstrates racing two asynchronous tasks to retrieve page titles from two URLs passed as command line arguments. It imports `trpl::{Either, Html}`, uses `trpl::run` to manage the async runtime, calls `page_title` for both URLs, and then uses `trpl::race` to determine which title is retrieved first. The result is then printed to the console.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse trpl::{Either, Html};\n\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n\n    trpl::run(async {\n        let title_fut_1 = page_title(&args[1]);\n        let title_fut_2 = page_title(&args[2]);\n\n        let (url, maybe_title) =\n            match trpl::race(title_fut_1, title_fut_2).await {\n                Either::Left(left) => left,\n                Either::Right(right) => right,\n            };\n\n        println!(\"{url} returned first\");\n        match maybe_title {\n            Some(title) => println!(\"Its page title is: '{title}'\"),\n            None => println!(\"Its title could not be parsed.\"),\n        }\n    })\n}\n\nasync fn page_title(url: &str) -> (&str, Option<String>) {\n    let text = trpl::get(url).await.text().await;\n    let title = Html::parse(&text)\n        .select_first(\"title\")\n        .map(|title| title.inner_html());\n    (url, title)\n}\n```\n\n----------------------------------------\n\nTITLE: Match Guard with Outer Variable Rust\nDESCRIPTION: This code shows how to use a match guard to test for equality with an outer variable, avoiding the pattern-shadowing problem. The match guard `if n == y` ensures that the outer `y` is used for comparison.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = Some(5);\n    let y = 5;\n\n    match x {\n        Some(50) => println!(\"Got 50\"),\n        Some(n) if n == y => println!(\"Matched, n = {}\", n),\n        _ => println!(\"Default case, x = {:?}\", x),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Loop using while let in Rust\nDESCRIPTION: This Rust snippet illustrates the use of a `while let` loop to receive and print values sent through a channel. It loops as long as the receiver gets `Ok` results. This is frequently used in concurrent programs to process messages from other threads.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n    let (tx, rx) = std::sync::mpsc::channel();\n    std::thread::spawn(move || {\n        for val in [1, 2, 3] {\n            tx.send(val).unwrap();\n        }\n    });\n\n    while let Ok(value) = rx.recv() {\n        println!(\"{value}\");\n    }\n```\n\n----------------------------------------\n\nTITLE: Calling function using absolute and relative paths in Rust\nDESCRIPTION: This code demonstrates how to call a function (`add_to_waitlist`) using both absolute and relative paths within a Rust module structure. It defines the `eat_at_restaurant` function in the crate root and calls `add_to_waitlist` using `crate::front_of_house::hosting::add_to_waitlist` (absolute) and `front_of_house::hosting::add_to_waitlist` (relative).\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-03/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Generic Function with Maybe Sized Trait Bound in Rust\nDESCRIPTION: This code snippet shows how to relax the `Sized` restriction on a generic function using the `?Sized` trait bound. This allows the function to work with both types that have a known size at compile time and dynamically sized types. Because the type might not be `Sized`, a pointer type like `&T` should be used for the parameter.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-03-advanced-types.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-14-generic-maybe-sized/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Defining a Unit-Like Struct in Rust\nDESCRIPTION: This snippet demonstrates how to define a unit-like struct in Rust. Unit-like structs are structs without any fields and are useful when you need to implement a trait on some type but dont have any data to store.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-01-defining-structs.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nstruct AlwaysEqual;\n\nfn main() {\n    let subject = AlwaysEqual;\n}\n```\n\n----------------------------------------\n\nTITLE: String Length in Bytes (Russian)\nDESCRIPTION: This code snippet demonstrates how the length of a string containing non-ASCII characters is calculated in bytes. Each Unicode scalar value in the string \"\" takes 2 bytes of storage, so the length of this string in bytes is 24.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-02-strings.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(unused)]\nfn main() {\nlet s = String::from(\"\");\n\n    println!(\"{}\", s.len());\n}\n```\n\n----------------------------------------\n\nTITLE: Attempting to Use `FnOnce` Closure with `sort_by_key` in Rust\nDESCRIPTION: This code attempts to use a closure that implements only the `FnOnce` trait with `sort_by_key`. The closure moves the `value` out of its environment by pushing it into the `sort_operations` vector, causing a compilation error because `sort_by_key` requires an `FnMut` closure.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let mut list = [\n        Rectangle { width: 10, height: 1 },\n        Rectangle { width: 3, height: 5 },\n        Rectangle { width: 7, height: 12 },\n    ];\n\n    let mut sort_operations = vec![];\n    let value = String::from(\"closure called\");\n\n    list.sort_by_key(|r| {\n        sort_operations.push(value);\n        r.width\n    });\n    println!(\"{list:#?}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Enum in Rust\nDESCRIPTION: This code defines an enum called `IpAddrKind` with two variants: `V4` and `V6`. This enum represents the two possible kinds of IP addresses. It demonstrates a basic enum declaration in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-01-defining-an-enum.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum IpAddrKind {\n    V4,\n    V6,\n}\n```\n\n----------------------------------------\n\nTITLE: Disambiguating Trait Methods with UFCS in Rust\nDESCRIPTION: This code snippet demonstrates how to implement multiple traits with methods of the same name for a single struct and then use Universal Function Call Syntax (UFCS) to call the specific implementation of each trait's method. The code defines two traits, `Pilot` and `Wizard`, each with a `fly` method. It then defines a `Human` struct and implements both traits for it, as well as providing a direct implementation of `fly` for `Human`. Finally, the `main` function creates an instance of `Human` and calls each of the `fly` methods using UFCS to specify which trait's method to call, as well as the inherent `fly` method.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/ufcs.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Pilot {\n    fn fly(&self);\n}\n\ntrait Wizard {\n    fn fly(&self);\n}\n\nstruct Human;\n\nimpl Pilot for Human {\n#     fn fly(&self) {\n#         println!(\"This is your captain speaking.\");\n#     }\n}\n\nimpl Wizard for Human {\n#     fn fly(&self) {\n#         println!(\"Up!\");\n#     }\n}\n\nimpl Human {\n#     fn fly(&self) {\n#         println!(\"*waving arms furiously*\");\n#     }\n}\n\nfn main() {\n    let person = Human;\n    Pilot::fly(&person);\n    Wizard::fly(&person);\n    person.fly();\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining with await keyword - Rust\nDESCRIPTION: Illustrates chaining asynchronous operations using the `await` keyword for better code readability. Awaits the result of `trpl::get` and then `text` in a single chain. Returns an `Option<String>` containing the title.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-01-futures-and-syntax.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nasync fn page_title(url: String) -> Option<String> {\n    let response_text = trpl::get(url).await.text().await;\n    let html = Html::parse(&response_text);\n    html.select_first(\"title\")\n        .map(|title_element| title_element.inner_html())\n}\n```\n\n----------------------------------------\n\nTITLE: Mixing Threads and Async Channels in Rust\nDESCRIPTION: This code snippet demonstrates how to combine threads and async channels in Rust. It spawns a thread that sends messages through a channel and then uses an async block to receive and print those messages. It showcases how blocking code in a thread can interact with async code.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_55\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::{thread, time::Duration};\n\nfn main() {\n    let (tx, mut rx) = trpl::channel();\n\n    thread::spawn(move || {\n        for i in 1..11 {\n            tx.send(i).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    trpl::run(async {\n        while let Some(message) = rx.recv().await {\n            println!(\"{message}\");\n        }\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a String from a Literal in Rust\nDESCRIPTION: This code snippet shows how to create a `String` from a string literal using the `String::from` function. The `String` type manages data allocated on the heap, allowing it to store text with a size unknown at compile time.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nlet s = String::from(\"hello\");\n```\n\n----------------------------------------\n\nTITLE: Using StreamExt to Enable Stream::next\nDESCRIPTION: This code snippet demonstrates how to use the `StreamExt` trait to enable the `next` method on a stream. The snippet imports the `trpl::StreamExt` trait, allowing the `next` method to be called on the stream. The program initializes an array, maps its values, converts it to a stream, and then iterates through the stream to print the values.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_35\n\nLANGUAGE: rust\nCODE:\n```\nuse trpl::StreamExt;\n\nfn main() {\n    trpl::run(async {\n        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let iter = values.iter().map(|n| n * 2);\n        let mut stream = trpl::stream_from_iter(iter);\n\n        while let Some(value) = stream.next().await {\n            println!(\"The value was: {value}\");\n        }\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Guessing Game Code in Rust\nDESCRIPTION: This is the final, complete code for the guessing game. It includes importing necessary modules, generating a secret number, reading user input, validating the input, comparing it to the secret number, providing feedback, and exiting the game when the user guesses correctly. The secret number print statement is removed for the final version.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter02.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nuse std::cmp::Ordering;\nuse std::io;\n\nuse rand::Rng;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1..=100);\n\n    loop {\n        println!(\"Please input your guess.\");\n\n        let mut guess = String::new();\n\n        io::stdin()\n            .read_line(&mut guess)\n            .expect(\"Failed to read line\");\n\n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        println!(\"You guessed: {guess}\");\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less => println!(\"Too small!\"),\n            Ordering::Greater => println!(\"Too big!\"),\n            Ordering::Equal => {\n                println!(\"You win!\");\n                break;\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Submodule in Separate File - Rust\nDESCRIPTION: This code declares a submodule `hosting` inside the `front_of_house` module. This declaration resides in *src/front_of_house.rs*.  The implementation of the `hosting` module is expected to be in the *src/front_of_house/hosting.rs* file.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_26\n\nLANGUAGE: rust\nCODE:\n```\npub mod hosting;\n```\n\n----------------------------------------\n\nTITLE: Define async function to get HTML title - Rust\nDESCRIPTION: Defines an async function `page_title` that takes a URL, fetches the HTML content, parses it, and extracts the text of the `<title>` element. It uses the `trpl::get` function and the `Html::parse` method. Requires the `trpl` crate as a dependency. Returns an `Option<String>` containing the title.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-01-futures-and-syntax.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nasync fn page_title(url: String) -> Option<String> {\n    let response_text = trpl::get(url).await.text().await;\n    let html = Html::parse(&response_text);\n    html.select_first(\"title\")\n        .map(|title_element| title_element.inner_html())\n}\n```\n\n----------------------------------------\n\nTITLE: Method field interaction in Rust\nDESCRIPTION: This Rust code snippet demonstrates how a method can have the same name as a struct field. It defines a `width` method on the `Rectangle` struct that returns a `bool` indicating whether the `width` field is greater than 0. The code illustrates how Rust distinguishes between accessing the field and calling the method based on the presence of parentheses.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-03-method-syntax.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn width(&self) -> bool {\n        self.width > 0\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    if rect1.width() {\n        println!(\"The rectangle has a nonzero width; it is {}\", rect1.width);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Config Constructor - Rust\nDESCRIPTION: This snippet refactors the `parse_config` function into a constructor `Config::new` associated with the `Config` struct. It encapsulates the argument parsing logic within the struct's implementation, making the code more idiomatic and readable. The `main` function is updated to call `Config::new`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::new(&args);\n\n    // --snip--\n}\n\n// --snip--\n\nimpl Config {\n    fn new(args: &[String]) -> Config {\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Config { query, file_path }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Post in Draft State - main.rs\nDESCRIPTION: This snippet shows the creation of new posts in the draft state using `Post::new` and the ability to add text to the posts content. It demonstrates the starting point for encoding states and behavior as types.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-03-oo-design-patterns.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch18-oop/listing-18-11/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Incrementing Counter with Mutex<T> - Rust (Incorrect)\nDESCRIPTION: This code attempts to increment a counter guarded by a `Mutex<T>` using multiple threads. However, it results in a compiler error because the `counter` value is moved in each iteration of the loop, violating Rust's ownership rules. It highlights the problem of moving ownership of the mutex into multiple threads.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch16-03-shared-state.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\nuse std::sync::Mutex;\n\nfn main() {\n    let counter = Mutex::new(0);\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n```\n\n----------------------------------------\n\nTITLE: Fully Qualified Syntax for Trait Associated Function\nDESCRIPTION: This example demonstrates the correct way to call a trait's associated function when both the trait and the implementing struct have functions with the same name, using fully qualified syntax `<Type as Trait>::function()`. Requires `Animal` trait and `Dog` struct definition from previous examples.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-02-advanced-traits.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    println!(\"A baby dog is named {}\", <Dog as Animal>::baby_name());\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating and Searching for a Space in a Byte Array\nDESCRIPTION: This Rust code snippet shows the inner loop logic for iterating through a byte array and searching for a space character.  It uses byte literal syntax and returns the index when a space is found.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-03-slices.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:inside_for}}\n```\n\n----------------------------------------\n\nTITLE: Accessing Mutable Static Variable - Rust\nDESCRIPTION: This snippet shows how to declare, access, and modify a mutable static variable in Rust. Accessing and modifying mutable static variables requires an `unsafe` block because it can lead to data races if not handled carefully. Any code that reads or writes from `COUNTER` must be within an `unsafe` block.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-01-unsafe-rust.md#_snippet_12\n\nLANGUAGE: Rust\nCODE:\n```\nstatic mut COUNTER: u32 = 0;\n\nfn add_to_count(inc: u32) {\n    unsafe {\n        COUNTER += inc;\n    }\n}\n\nfn main() {\n    add_to_count(3);\n\n    unsafe {\n        println!(\"COUNTER: {}\", COUNTER);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Integration Test with Shared Code\nDESCRIPTION: This Rust code shows how to use a shared setup function from a common module within an integration test.  It declares the `common` module and then calls the `setup` function within a test function. The common module must be defined in `tests/common/mod.rs`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-03-test-organization.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-13-fix-shared-test-code-problem/tests/integration_test.rs}}\n```\n\n----------------------------------------\n\nTITLE: Matching `Option` with `match` in Rust\nDESCRIPTION: This snippet demonstrates matching an `Option<u8>` value using a `match` expression. It prints the value if it's `Some`, and does nothing if it's `None`. The `_ => ()` is used to satisfy the `match` expression.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-03-if-let.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet config_max = Some(3u8);\nmatch config_max {\n    Some(max) => println!(\"The maximum is configured to be {}\", max),\n    _ => (),\n}\n```\n\n----------------------------------------\n\nTITLE: Closure Capturing Mutable Reference in Rust\nDESCRIPTION: This code defines a closure that captures a mutable reference to a vector named `list` and adds an element to it. The closure borrows the vector mutably, modifying it. Note that there is no other borrow of `list` while the mutable borrow exists.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-01-closures.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut list = vec![1, 2, 3];\n\n    let mut borrows_mutably = || list.push(7);\n\n    borrows_mutably();\n}\n```\n\n----------------------------------------\n\nTITLE: Standard Library's `IpAddr` Definition in Rust\nDESCRIPTION: This code shows the standard library's implementation of `IpAddr` using `Ipv4Addr` and `Ipv6Addr` structs.  It demonstrates nesting structs within enum variants. No dependencies required.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nstruct Ipv4Addr {\n    // --snip--\n}\n\nstruct Ipv6Addr {\n    // --snip--\n}\n\nenum IpAddr {\n    V4(Ipv4Addr),\n    V6(Ipv6Addr),\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Panic Messages with expected Parameter - Rust\nDESCRIPTION: This snippet shows how to use the `expected` parameter in the `#[should_panic]` attribute to test for a specific panic message substring. It enhances the precision of `should_panic` tests by ensuring that the panic message contains the expected text.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-01-writing-tests.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-09/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Running a Rust Project with Cargo\nDESCRIPTION: This snippet shows the command used to compile and run a Rust project managed by Cargo.  It demonstrates the output after running `cargo run`, which includes the compilation stage and the execution of the resulting binary. The output confirms the compilation of the 'rectangles' project and subsequent execution, which prints information about a rectangle.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch05-using-structs-to-structure-related-data/listing-05-12/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s\n     Running `target/debug/rectangles`\nrect1 is Rectangle { width: 30, height: 50 }\n```\n\n----------------------------------------\n\nTITLE: Saving Command-Line Arguments to Variables - Rust\nDESCRIPTION: This code snippet demonstrates how to save the command-line arguments into variables for later use. It retrieves the first and second arguments from the `args` vector (skipping the program name at index 0) and stores them in `query` and `file_path` variables, respectively. It also includes a `should_panic` annotation.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-01-accepting-command-line-arguments.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::env;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let query = &args[1];\n    let file_path = &args[2];\n\n    println!(\"Searching for {}\", query);\n    println!(\"In file {}\", file_path);\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Values with `@` in Pattern Matching in Rust\nDESCRIPTION: This code illustrates the use of the `@` operator to bind a value to a variable while simultaneously testing it against a pattern. This allows you to both check the value and use it within the match arm.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_34\n\nLANGUAGE: rust\nCODE:\n```\nenum Message {\n    Hello { id: i32 },\n}\n\nlet msg = Message::Hello { id: 5 };\n\nmatch msg {\n    Message::Hello {\n        id: id_variable @ 3..=7,\n    } => println!(\"Found an id in range: {id_variable}\"),\n    Message::Hello { id: 10..=12 } => {\n        println!(\"Found an id in another range\")\n    }\n    Message::Hello { id } => println!(\"Found some other id: {id}\"),\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Paths Using `self` in a Nested `use` Statement in Rust\nDESCRIPTION: This snippet showcases combining two `use` statements (one being a subpath of the other) into a single, more concise `use` statement using the `self` keyword within a nested path. This imports both `std::io` and `std::io::Write`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nuse std::io::{self, Write};\n```\n\n----------------------------------------\n\nTITLE: Storing Matching Lines in Rust\nDESCRIPTION: This code snippet completes the `search` function by storing the matching lines in a mutable vector. It initializes an empty vector `results`, and for each line that contains the query, it pushes the line to the `results` vector. Finally, it returns the `results` vector, which contains all the matching lines.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\npub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.contains(query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n```\n\n----------------------------------------\n\nTITLE: Using an iterator as a stream with StreamExt\nDESCRIPTION: This code snippet demonstrates how to successfully use an iterator as the basis for a stream by importing the `trpl::StreamExt` trait.  This trait provides the `next` method, allowing the stream to be iterated over using a `while let` loop and the stream's values to be printed.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-04-streams.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse trpl::StreamExt;\n\n    let mut stream = trpl::stream_from_iter(array.into_iter().map(|x| x * 2));\n\n    while let Some(value) = stream.next().await {\n        println!(\"value: {}\", value);\n    }\n```\n\n----------------------------------------\n\nTITLE: Tuple Destructuring in Function Parameters in Rust\nDESCRIPTION: This snippet defines a function `print_coordinates` that takes a tuple as a parameter and destructures it into `x` and `y` coordinates. This example shows how patterns can be used within function parameters to directly access the elements of a tuple, making the code more concise and readable.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nfn print_coordinates(&(x, y): &(i32, i32)) {\n    println!(\"Current location: ({x}, {y})\");\n}\n\nfn main() {\n    let point = (3, 5);\n    print_coordinates(&point);\n}\n```\n\n----------------------------------------\n\nTITLE: Compiler Help Message for Using `move`\nDESCRIPTION: This snippet displays the compiler's helpful suggestion to use the `move` keyword to force the closure to take ownership of the referenced variable `v`. This message guides the user on how to resolve the lifetime issues and transfer ownership when sharing data between threads, preventing potential data races.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch16-01-threads.md#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nhelp: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword\n  |\n6 |     let handle = thread::spawn(move || {\n  |                                ++++\n```\n\n----------------------------------------\n\nTITLE: Updating Content Method in Post to Delegate to State in Rust\nDESCRIPTION: This code snippet shows how to update the `content` method in the `Post` struct to delegate to the `content` method defined in the current `State`. This ensures that the content returned depends on the current state of the post. It utilizes `as_ref` to get a reference to the state and `unwrap` as the state will always contain a `Some` value at that point.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-03-oo-design-patterns.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nimpl Post {\n    pub fn new() -> Post {\n        Post {\n            state: Some(Box::new(Draft {})),\n            content: String::new(),\n        }\n    }\n\n    pub fn add_text(&mut self, text: &str) {\n        self.content.push_str(text);\n    }\n\n    pub fn content(&self) -> &str {\n        self.state.as_ref().unwrap().content(self)\n    }\n\n    pub fn request_review(&mut self) {\n        if let Some(s) = self.state.take() {\n            self.state = Some(s.request_review())\n        }\n    }\n\n    pub fn approve(&mut self) {\n        if let Some(s) = self.state.take() {\n            self.state = Some(s.approve())\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo Run Output\nDESCRIPTION: This console output shows an example interaction with the guessing game, including compiling and running the game, user input, and program output. The example shows scenarios with too small, too big, and correct guesses as well as quitting.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_25\n\nLANGUAGE: console\nCODE:\n```\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s\n     Running `target/debug/guessing_game`\nGuess the number!\nThe secret number is: 59\nPlease input your guess.\n45\nYou guessed: 45\nToo small!\nPlease input your guess.\n60\nYou guessed: 60\nToo big!\nPlease input your guess.\n59\nYou guessed: 59\nYou win!\nPlease input your guess.\nquit\n\nthread 'main' panicked at src/main.rs:28:47:\nPlease type a number!: ParseIntError { kind: InvalidDigit }\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n```\n\n----------------------------------------\n\nTITLE: Overriding Rust Toolchain per Project via Rustup\nDESCRIPTION: These commands demonstrate how to override the default Rust toolchain for a specific project using Rustup. This allows developers to use nightly Rust on a project that requires cutting-edge features while using stable Rust for other projects.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-07-nightly-rust.md#_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ cd ~/projects/needs-nightly\n$ rustup override set nightly\n```\n\n----------------------------------------\n\nTITLE: Write trait in std::io with Result type alias\nDESCRIPTION: This example shows the `Write` trait function signatures using the `std::io::Result<T>` type alias.  The functions are simplified to `Result<usize>` and `Result<()>`, improving readability and consistency.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-03-advanced-types.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\ntrait Write {\n    fn write(&mut self, buf: &[u8]) -> Result<usize>;\n    fn flush(&mut self) -> Result<()>;\n\n    fn write_all(&mut self, buf: &[u8]) -> Result<()> { \n        // --snip--\n    }\n    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()> {\n        // --snip--\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Destructuring Structs and Tuples in Rust\nDESCRIPTION: This snippet shows a complex destructure where structs and tuples are nested inside a tuple, and all primitive values are extracted. It allows breaking complex types into their component parts for separate use. Dependencies: None. Inputs: A nested tuple containing a struct and a tuple. Outputs: Prints extracted values.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let ((_a, _b), Point { x: _x, y: _y }) = ((3, 5), Point { x: 10, y: 12 });\n    println!(\"a = {}, b = {}, x = {}, y = {}\", 3, 5, 10, 12); // to avoid warnings\n}\n```\n\n----------------------------------------\n\nTITLE: Array Type Declaration\nDESCRIPTION: This example showcases how to explicitly define an array's type, specifying the element type and number of elements. This helps ensure type safety during compilation.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-02-data-types.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nlet a: [i32; 5] = [1, 2, 3, 4, 5];\n\n```\n\n----------------------------------------\n\nTITLE: Match Guard Example Rust\nDESCRIPTION: This code demonstrates the use of a match guard, an additional `if` condition, specified after the pattern in a `match` arm. In this example, the match guard checks if a number is even before executing the corresponding arm.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let num = Some(4);\n\n    match num {\n        Some(x) if x % 2 == 0 => println!(\"The number {} is even\", x),\n        Some(x) => println!(\"The number {} is odd\", x),\n        None => (),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Racing Futures to Completion in Rust\nDESCRIPTION: This snippet demonstrates using `trpl::race` to run two futures against each other and obtain the result of the first one to complete.  It highlights the potential for unfairness in race implementations and emphasizes the importance of await points in relinquishing control to the runtime.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-03-more-futures.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch17-async-await/listing-17-21/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Validating User Input Range in Guessing Game - Rust\nDESCRIPTION: This code snippet demonstrates how to validate user input in a guessing game to ensure the guess is within the range of 1 to 100. It parses the input as an `i32`, checks if it's within the range, and continues to the next iteration of the loop if the guess is invalid. Dependencies: None. Input: User's guess as a string. Output: Prints an error message if the guess is out of range. Limitation: Inline check, not reusable.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter09.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nloop {\n        // --snip--\n\n        let guess: i32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        if guess < 1 || guess > 100 {\n            println!(\"The secret number will be between 1 and 100.\");\n            continue;\n        }\n\n        match guess.cmp(&secret_number) {\n            // --snip--\n    }\n```\n\n----------------------------------------\n\nTITLE: Returning Result from Config::build in Rust\nDESCRIPTION: This snippet shows how to modify the `Config::build` function to return a `Result` type, handling potential errors like insufficient arguments. The function returns a `Config` instance on success or a static string slice as an error.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\nimpl Config {\n    fn build(args: &[String]) -> Result<Config, &'static str> {\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config { query, file_path })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Vector Dropping Example - Rust\nDESCRIPTION: This example demonstrates how a vector and its elements are dropped when the vector goes out of scope. The program creates a vector and then demonstrates its lifecycle within a scope. When the scope ends, the vector and its contained integers are automatically dropped.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-01-vectors.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    {\n        let v = vec![1, 2, 3, 4];\n\n        // do stuff with v\n    } // <- v goes out of scope and is freed here\n}\n```\n\n----------------------------------------\n\nTITLE: Destructuring Enum Variants Rust\nDESCRIPTION: This code defines an enum `Message` with several variants, including those with no data, struct-like data, and tuple-like data. The `main` function then uses a `match` statement to destructure the enum and print corresponding messages based on the variant's data. It demonstrates how to access the inner values of each enum variant through pattern matching.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(0, 160, 255);\n\n    match msg {\n        Message::Quit => {\n            println!(\"The Quit variant has no data to destructure.\");\n        }\n        Message::Move { x, y } => {\n            println!(\"Move in the x direction {x} and in the y direction {y}\");\n        }\n        Message::Write(text) => {\n            println!(\"Text message: {text}\");\n        }\n        Message::ChangeColor(r, g, b) => {\n            println!(\"Change the color to red {r}, green {g}, and blue {b}\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Greeter Function Test with Improved Failure Message - Rust\nDESCRIPTION: This snippet demonstrates how to add a custom failure message to the `assert!` macro using the `format!` macro. The custom message displays the actual value returned by the `greeting` function, aiding in debugging when the test fails.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-01-writing-tests.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-07-custom-failure-message/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Throttling and Limiting Merged Streams in Rust\nDESCRIPTION: This snippet uses the `throttle` method to limit the rate of emission of the `intervals` stream and the `take` method to limit the total number of items taken from the merged stream. This prevents one stream from overwhelming the other and ensures the program terminates after processing a defined number of items.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_43\n\nLANGUAGE: Rust\nCODE:\n```\nlet messages = get_messages().timeout(Duration::from_millis(200));\n        let intervals = get_intervals()\n            .map(|count| format!(\"Interval: {count}\"))\n            .throttle(Duration::from_millis(100))\n            .timeout(Duration::from_secs(10));\n        let merged = messages.merge(intervals).take(20);\n        let mut stream = pin!(merged);\n```\n\n----------------------------------------\n\nTITLE: Passing Iterator to Config::build in Rust\nDESCRIPTION: This code snippet shows how to modify the `main` function to pass the iterator returned by `env::args` directly to the `Config::build` function, instead of collecting the arguments into a `Vec<String>` and then passing a slice. This is a preparatory step for removing the `clone` calls in `Config::build`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let config = Config::build(env::args()).unwrap_or_else(|err| {\n        eprintln!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    // --snip--\n}\n```\n\n----------------------------------------\n\nTITLE: For Loop with Tuple Destructuring\nDESCRIPTION: This snippet uses a `for` loop to iterate over a vector of characters and destructure the tuple created by `enumerate` method. The `enumerate` method generates tuples of (index, value). The loop uses the pattern `(index, value)` to unpack the tuple elements into separate variables for each iteration.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-01-all-the-places-for-patterns.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let v = vec!['a', 'b', 'c'];\n\n    for (index, value) in v.iter().enumerate() {\n        println!(\"{} is at index {}\", value, index);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling HTTP Requests in Rust\nDESCRIPTION: This Rust code snippet demonstrates how to handle incoming HTTP requests, specifically differentiating between a request for the root path ('/') and other requests.  It reads the first line of the request, and then responds with either the content of 'hello.html' or a 404 error.  Requires the `std::net` and `std::io` modules.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-01-single-threaded.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse std::io::prelude::*;\nuse std::net::*;\n\nfn handle_connection(mut stream: TcpStream) {\n    let mut buffer = [0; 1024];\n    stream.read(&mut buffer).unwrap();\n\n    let get = b\"GET / HTTP/1.1\\r\\n\";\n\n    if buffer.starts_with(get) {\n        let contents = std::fs::read_to_string(\"hello.html\").unwrap();\n\n        let response = format!(\n            \"HTTP/1.1 200 OK\\r\\nContent-Length: {}\\r\\n\\r\\n{}\",\n            contents.len(),\n            contents\n        );\n\n        stream.write(response.as_bytes()).unwrap();\n        stream.flush().unwrap();\n    } else {\n        // some other request\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Waiting for Task Completion with Await in Rust\nDESCRIPTION: This snippet shows how to wait for a spawned task to complete using `await` on the task handle. This ensures that the main function doesn't exit before the spawned task finishes its execution. The `.unwrap()` is used to handle potential errors from the task.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nlet handle = trpl::spawn_task(async {\n            for i in 1..10 {\n                println!(\"hi number {i} from the first task!\");\n                trpl::sleep(Duration::from_millis(500)).await;\n            }\n        });\n\n        for i in 1..5 {\n            println!(\"hi number {i} from the second task!\");\n            trpl::sleep(Duration::from_millis(500)).await;\n        }\n\n        handle.await.unwrap();\n```\n\n----------------------------------------\n\nTITLE: Creating a New Hash Map and Inserting Values\nDESCRIPTION: This code creates a new HashMap and inserts key-value pairs representing team scores. It demonstrates the basic usage of the HashMap data structure in Rust, requiring the use of `use std::collections::HashMap;` to bring the HashMap into scope.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-03-hash-maps.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::HashMap;\n\nfn main() {\n    let mut scores = HashMap::new();\n\n    scores.insert(String::from(\"Blue\"), 10);\n    scores.insert(String::from(\"Yellow\"), 50);\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Using Blanket Implementation of ToString for Integers\nDESCRIPTION: This code shows how to use the `to_string` method on an integer. Because integers implement the `Display` trait, they automatically gain the `to_string` method through the blanket implementation of the `ToString` trait.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_33\n\nLANGUAGE: Rust\nCODE:\n```\nlet s = 3.to_string();\n```\n\n----------------------------------------\n\nTITLE: Function with Multiple Trait Bounds using impl Trait\nDESCRIPTION: This code defines a function `notify` that takes two arguments `item1` and `item2` each of which must implement the `Summary` trait.  The function is designed to allow item1 and item2 to have different types as long as both types implement `Summary`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_23\n\nLANGUAGE: Rust\nCODE:\n```\npub fn notify(item1: &impl Summary, item2: &impl Summary) {\n```\n\n----------------------------------------\n\nTITLE: Importing the io library\nDESCRIPTION: This snippet imports the `io` module from the standard library to provide input/output functionality. It's essential for reading user input and printing output.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_5\n\nLANGUAGE: rust,ignore\nCODE:\n```\n{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:io}}\n```\n\n----------------------------------------\n\nTITLE: Testing Panic Messages with `expected` in Rust\nDESCRIPTION: This code demonstrates how to test for specific panic messages using the `expected` parameter of the `#[should_panic]` attribute. The `Guess::new` function now panics with different messages depending on whether the value is too small or too large. The test `greater_than_100` checks that the panic message contains the substring \"less than or equal to 100\".\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nimpl Guess {\n    pub fn new(value: i32) -> Guess {\n        if value < 1 {\n            panic!(\n                \"Guess value must be greater than or equal to 1, got {value}.\"\n            );\n        } else if value > 100 {\n            panic!(\n                \"Guess value must be less than or equal to 100, got {value}.\"\n            );\n        }\n\n        Guess { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic(expected = \"less than or equal to 100\")]\n    fn greater_than_100() {\n        Guess::new(200);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating shared ownership issues with Box<T> in Rust\nDESCRIPTION: This code snippet attempts to create two lists (b and c) that share ownership of a third list (a) using Box<T>. However, because Box<T> enforces exclusive ownership, this results in a compile-time error due to 'a' being moved into 'b' and then being used again in the creation of 'c'. This illustrates the need for Rc<T> when shared ownership is required.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-04-rc.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-17/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Attempting to Use a Vector in Another Thread (Compile Error)\nDESCRIPTION: This code attempts to create a vector in the main thread and then use it in a spawned thread. However, this code results in a compile error because Rust infers that the closure borrows `v`, and it cannot guarantee the reference will be valid for the lifetime of the spawned thread. The example highlights a common problem when sharing data between threads without proper ownership transfer.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch16-01-threads.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-03/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Catch-All Pattern with Variable in Match Expression - Rust\nDESCRIPTION: This code demonstrates a `match` expression using a catch-all pattern with a variable. If the dice roll is 3, the player gets a new hat. If it's 7, the player loses a hat. Otherwise, the player moves a number of spaces based on the dice roll, captured by the `other` variable.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-02-match.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let dice_roll = 9;\n\n    match dice_roll {\n        3 => add_fancy_hat(),\n        7 => remove_fancy_hat(),\n        other => move_player(other),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n    fn move_player(num_spaces: u8) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Searching Each Line for the Query in Rust\nDESCRIPTION: This code snippet extends the previous example by adding a check to see if each line contains the query string using the `contains` method. If a line contains the query, the code inside the `if` block is executed. Currently, the `if` block is empty, indicating that further logic needs to be added to handle matching lines.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\npub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    for line in contents.lines() {\n        if line.contains(query) {\n            // do something with line\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Lifetime Annotations in Rust\nDESCRIPTION: This snippet defines a function `longest` with lifetime annotations. The function takes two string slices as input and returns a string slice, all associated with the same lifetime `'a`. This enforces that the returned reference's lifetime is no longer than the shortest lifetime of the input references.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-03-lifetime-syntax.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Coin Enum with `match` in Rust\nDESCRIPTION: This snippet demonstrates matching a `Coin` enum with a `UsState` value in the `Quarter` variant using a `match` expression. It counts non-quarter coins and announces the state of the quarters.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-03-if-let.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nenum UsState {\n    Alabama,\n    Alaska,\n    // --snip--\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n}\n\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter(state) => {\n            println!(\"State quarter from {:?}!\", state);\n            25\n        }\n    }\n}\n\nfn main() {\n    let coin = Coin::Quarter(UsState::Alaska);\n    value_in_cents(coin);\n\n    let mut count = 0;\n    let coin = Coin::Quarter(UsState::Alabama);\n    match coin {\n        Coin::Quarter(state) => println!(\"State quarter from {:?}!\", state),\n        _ => count += 1,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Storing Enum and Data with a Struct in Rust\nDESCRIPTION: This code defines a struct called `IpAddr` that contains an `IpAddrKind` enum and a `String` to store the IP address. It shows how to combine enums and structs to represent data.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-01-defining-an-enum.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nenum IpAddrKind {\n    V4,\n    V6,\n}\n\nstruct IpAddr {\n    kind: IpAddrKind,\n    address: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Dereferencing Raw Pointers in Unsafe Block\nDESCRIPTION: Illustrates dereferencing raw pointers within an `unsafe` block. Dereferencing raw pointers is an unsafe operation that requires explicit opt-in via the `unsafe` keyword.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-01-unsafe-rust.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet mut num = 5;\n\nlet r1 = &raw const num as *const i32;\nlet r2 = &raw mut num as *mut i32;\n\nunsafe {\n    println!(\"r1 is: {}\", *r1);\n    println!(\"r2 is: {}\", *r2);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Non-Exhaustive Match Compilation Error in Rust\nDESCRIPTION: This code demonstrates a non-exhaustive match, where the `None` case is not handled. This results in a compilation error, as Rust requires that `match` expressions cover all possible cases. The compiler provides an error message indicating the missing case.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-02-match.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn plus_one(x: Option<i32>) -> Option<i32> {\n    match x {\n        Some(i) => Some(i + 1),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Overloading Add operator for Point struct in Rust\nDESCRIPTION: This code demonstrates how to overload the `Add` operator for a custom `Point` struct in Rust. It uses the `std::ops::Add` trait. The `add` function defines the behavior when the `+` operator is used with two `Point` instances. The `main` function includes an assertion to verify that the `Add` operator is implemented correctly.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/operators-and-overloading.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops::Add;\n\n#[derive(Debug,PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -> Point {\n        Point {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n\nfn main() {\n    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n               Point { x: 3, y: 3 });\n}\n```\n\n----------------------------------------\n\nTITLE: Conditionally Implementing Methods on a Generic Type in Rust\nDESCRIPTION: Demonstrates conditionally implementing methods on a generic type based on trait bounds. The `cmp_display` method is implemented only if the inner type `T` implements both `PartialOrd` and `Display` traits.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-02-traits.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-15/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Valid Reference Example in Rust\nDESCRIPTION: This code demonstrates a valid reference because the data being referenced (`x`) has a longer lifetime than the reference (`r`). This ensures that the reference will always be valid while `x` is valid, preventing dangling references.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-03-lifetime-syntax.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-18/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Enum for Multiple Types in a Vector - Rust\nDESCRIPTION: This code defines an enum `SpreadsheetCell` with variants for `Int`, `Float`, and `Text`.  It then creates a vector `row` that holds elements of this enum, effectively storing different data types in the same vector. This demonstrates how to store different data types into one vector.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nenum SpreadsheetCell {\n    Int(i32),\n    Float(f64),\n    Text(String),\n}\n\nlet row = vec![\n    SpreadsheetCell::Int(3),\n    SpreadsheetCell::Text(String::from(\"blue\")),\n    SpreadsheetCell::Float(10.12),\n];\n```\n\n----------------------------------------\n\nTITLE: Defining Width Method on Rectangle Struct in Rust\nDESCRIPTION: This snippet defines a `width` method on the `Rectangle` struct that checks if the width field is greater than 0.  It demonstrates how a method can have the same name as a struct field.  The main function creates a Rectangle and checks if the width is nonzero using the method, printing a message accordingly.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nimpl Rectangle {\n    fn width(&self) -> bool {\n        self.width > 0\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    if rect1.width() {\n        println!(\"The rectangle has a nonzero width; it is {}\", rect1.width);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Multiple Trait Bounds with + Syntax\nDESCRIPTION: This code defines a function `notify` that takes an argument `item` which must implement both the `Summary` and `Display` traits. This allows the function to use both the `summarize` method and display formatting on the `item`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_25\n\nLANGUAGE: Rust\nCODE:\n```\npub fn notify(item: &(impl Summary + Display)) {\n```\n\n----------------------------------------\n\nTITLE: Checking a Rust Project with Cargo Check\nDESCRIPTION: This command checks the Rust code for compilation errors without producing an executable. It's faster than `cargo build` and is useful for quickly verifying code correctness during development.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_27\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo check\n   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs\n```\n\n----------------------------------------\n\nTITLE: Creating an Iterator in Rust\nDESCRIPTION: This code demonstrates how to create an iterator from a vector using the `iter` method.  The iterator is then stored in a variable for later use. This example highlights the initial step in using iterators to process a sequence of items.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-02-iterators.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet v1 = vec![1, 2, 3];\n\nlet v1_iter = v1.iter();\n```\n\n----------------------------------------\n\nTITLE: Extracting Logic to a `run` Function - Rust\nDESCRIPTION: This snippet extracts the core program logic from the `main` function into a separate `run` function. The `run` function takes the `Config` instance as an argument and contains the logic for reading the file and printing its contents.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-03-improving-error-handling-and-modularity.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse std::env;\nuse std::fs;\nuse std::process;\n\nstruct Config {\n    query: String,\n    file_path: String,\n}\n\nimpl Config {\n    fn build(args: &[String]) -> Result<Config, &'static str> {\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config {\n            query,\n            file_path,\n        })\n    }\n}\n\nfn run(config: Config) {\n    let contents = fs::read_to_string(config.file_path)\n        .expect(\"Could not read file\");\n\n    println!(\"With contents:\\n{contents}\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::build(&args).unwrap_or_else(|err| {\n        println!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    run(config);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Post and DraftPost Structs - lib.rs\nDESCRIPTION: This snippet defines the `Post` struct with a `content` method and the `DraftPost` struct without a `content` method. It illustrates how the state is encoded into the types of the structs, preventing access to content in the draft state at compile time.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-03-oo-design-patterns.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch18-oop/listing-18-19/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Vector Values (Mutable) - Rust\nDESCRIPTION: This code snippet shows how to iterate over a mutable vector and modify each element.  It uses a `for` loop with mutable references and the dereference operator `*` to update the values in place. Adding 50 to each element.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet mut v = vec![100, 32, 57];\nfor i in &mut v {\n    *i += 50;\n}\n```\n\n----------------------------------------\n\nTITLE: Function Destructuring Tuple Parameters\nDESCRIPTION: This Rust code snippet defines a function that destructures a tuple passed as a parameter. The tuple `&(x, y)` is matched with the input tuple, assigning the first element to `x` and the second element to `y`. The function prints the values of `x` and `y`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-01-all-the-places-for-patterns.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nfn print_coordinates(&(x, y): &(i32, i32)) {\n    println!(\"Current location: ({}, {})\", x, y);\n}\n\nfn main() {\n    let point = (3, 5);\n    print_coordinates(&point);\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution with 'if' in Rust\nDESCRIPTION: This code demonstrates a simple 'if' expression in Rust. It checks if the variable 'number' is less than 5. If the condition is true, it prints \"condition was true\"; otherwise, it prints \"condition was false\".\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_26\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let number = 3;\n\n    if number < 5 {\n        println!(\"condition was true\");\n    } else {\n        println!(\"condition was false\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Input Range with if Expression Rust\nDESCRIPTION: This code snippet demonstrates how to validate user input to ensure it falls within a specified range (1-100). It parses the input as an `i32`, checks if it's within the valid range using an `if` expression, and continues the loop if the input is invalid. The check is performed directly within the main loop.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch09-03-to-panic-or-not-to-panic.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch09-error-handling/no-listing-09-guess-out-of-range/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Overwriting a Value in a Hash Map\nDESCRIPTION: This code demonstrates how inserting a value with an existing key overwrites the previous value. It shows that a key can only have one associated value at a time, and subsequent insertions replace the old value.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-03-hash-maps.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::HashMap;\n\nfn main() {\n    let mut scores = HashMap::new();\n\n    scores.insert(String::from(\"Blue\"), 10);\n    scores.insert(String::from(\"Blue\"), 25);\n\n    println!(\"{:?}\", scores);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Struct Instance with Some Values from Another Instance in Rust\nDESCRIPTION: This example demonstrates creating a new `User` instance (`user2`) by explicitly assigning values from `user1`, except for the `email` field, which is assigned a new value. This shows how to create a new struct instance using data from an existing instance.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // --snip--\n\n    let user2 = User {\n        active: user1.active,\n        username: user1.username,\n        email: String::from(\"another@example.com\"),\n        sign_in_count: user1.sign_in_count,\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Running All Tests in a Workspace\nDESCRIPTION: This snippet shows the command to run all tests within the Cargo workspace. This command executes the tests for all crates in the workspace, providing a comprehensive overview of the project's test status.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-03-cargo-workspaces.md#_snippet_14\n\nLANGUAGE: console\nCODE:\n```\n$ cargo test\n   Compiling add_one v0.1.0 (file:///projects/add/add_one)\n   Compiling adder v0.1.0 (file:///projects/add/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.20s\n     Running unittests src/lib.rs (target/debug/deps/add_one-93c49ee75dc46543)\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running unittests src/main.rs (target/debug/deps/adder-3a47283c568d2b6a)\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests add_one\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Matching with Option<i32> in Rust\nDESCRIPTION: This function, `plus_one`, takes an `Option<i32>` as input and uses a `match` expression to add 1 to the value if it's `Some`, or returns `None` if it's `None`. This demonstrates pattern matching on `Option` types.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\n    fn plus_one(x: Option<i32>) -> Option<i32> {\n        match x {\n            None => None,\n            Some(i) => Some(i + 1),\n        }\n    }\n\n    let five = Some(5);\n    let six = plus_one(five);\n    let none = plus_one(None);\n```\n\n----------------------------------------\n\nTITLE: Assignment/Equivalence Operator Rust\nDESCRIPTION: This operator is used for assignment or equivalence depending on the context. For example, assignment (`var = expr`) or assigning a type to an identifier (`ident = type`). This operator cannot be overloaded.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_41\n\nLANGUAGE: Rust\nCODE:\n```\n`var = expr`\n```\n\nLANGUAGE: Rust\nCODE:\n```\n`ident = type`\n```\n\n----------------------------------------\n\nTITLE: Shadowing Variables in Match Expressions Rust\nDESCRIPTION: This code snippet demonstrates variable shadowing within a `match` expression. A new variable `y` is introduced in a match arm, shadowing the outer `y`. The code illustrates how scopes work within `match` expressions.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet x = Some(5);\nlet y = 10;\n\nmatch x {\n    Some(50) => println!(\"Got 50\"),\n    Some(y) => println!(\"Matched, y = {y}\"),\n    _ => println!(\"Default case, x = {:?}\", x),\n}\n\nprintln!(\"at the end: x = {:?}, y = {y}\");\n```\n\n----------------------------------------\n\nTITLE: Using Iterator Methods in Config::build in Rust\nDESCRIPTION: This code snippet demonstrates how to modify the body of the `Config::build` function to use iterator methods, specifically `next`, to extract the arguments from the iterator. This eliminates the need for indexing and cloning, improving the efficiency and clarity of the code. The code handles the case where not enough arguments are provided by returning an `Err`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nimpl Config {\n    pub fn build(\n        mut args: impl Iterator<Item = String>,\n    ) -> Result<Config, &'static str> {\n        args.next();\n\n        let query = match args.next() {\n            Some(arg) => arg,\n            None => return Err(\"Didn't get a query string\"),\n        };\n\n        let file_path = match args.next() {\n            Some(arg) => arg,\n            None => return Err(\"Didn't get a file path\"),\n        };\n\n        let ignore_case = env::var(\"IGNORE_CASE\").is_ok();\n\n        Ok(Config {\n            query,\n            file_path,\n            ignore_case,\n        })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Function Return with Statement in Rust (Compile Error)\nDESCRIPTION: This code demonstrates an error that occurs when a semicolon is added to the expression `x + 1` in the `plus_one` function, turning it into a statement. Statements do not return a value, causing a type mismatch because the function is declared to return an `i32` but effectively returns nothing (unit type `()`).\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-03-how-functions-work.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nfn plus_one(x: i32) -> i32 {\n    x + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Reading HTTP Request from TCP Stream in Rust\nDESCRIPTION: This code snippet demonstrates how to read an HTTP request from a TCP stream using `BufReader` for buffering and the `lines()` method to iterate over lines. It collects the lines into a `Vec<String>` until an empty line is encountered, indicating the end of the request headers. Dependencies include `std::io::{prelude::*, BufReader}` and `std::net::{TcpListener, TcpStream}`. The input is a `TcpStream`, and the output is the printed HTTP request.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n};\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        handle_connection(stream);\n    }\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&stream);\n    let http_request: Vec<_> = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    println!(\"Request: {http_request:#?}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Point struct with generic type\nDESCRIPTION: Defines a `Point` struct that is generic over type `T`. The `x` and `y` fields of the struct are both of type `T`, meaning they must be the same type. This example demonstrates how to use generics in struct definitions to create flexible data structures.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-01-syntax.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n```\n\n----------------------------------------\n\nTITLE: Changing `main` to Return `Result<(), E>` - Rust\nDESCRIPTION: This code snippet shows how to change the return type of the `main` function to `Result<(), Box<dyn Error>>` to allow the use of the `?` operator on `Result` values. By returning a `Result`, the `main` function can handle potential errors from operations like file opening using the `?` operator, returning an appropriate error value if something goes wrong. The `Ok(())` represents a successful execution.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter09.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nuse std::error::Error;\nuse std::fs::File;\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let greeting_file = File::open(\"hello.txt\")?;\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Format Rust Code using cargo-fmt\nDESCRIPTION: This command utilizes the cargo-fmt tool to automatically reformat all Rust code within the current Cargo project, ensuring adherence to the community's code style guidelines.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-04-useful-development-tools.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ cargo fmt\n```\n\n----------------------------------------\n\nTITLE: Executing Cargo Test\nDESCRIPTION: This snippet demonstrates running tests in a Rust project using the `cargo test` command. It shows the compilation process, the execution of unit tests, and doc tests. The output indicates the number of tests passed, failed, ignored, and the overall result.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/listing-11-07/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test\n Compiling adder v0.1.0 (file:///projects/adder)\n  Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s\n   Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::it_adds_two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Attempting to call drop manually (incorrect)\nDESCRIPTION: This snippet shows an attempt to call the `drop` method of the `Drop` trait manually. This is not allowed in Rust because the compiler automatically inserts the `drop` call when a value goes out of scope. Calling `drop` manually would lead to a double-free error. This example is marked as `does_not_compile`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-03-drop.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct CustomSmartPointer {\n    data: String,\n}\n\nimpl Drop for CustomSmartPointer {\n    fn drop(&mut self) {\n        println!(\"Dropping CustomSmartPointer with data `{}`!\", self.data);\n    }\n}\n\nfn main() {\n    let c = CustomSmartPointer { data: String::from(\"some data\") };\n    println!(\"CustomSmartPointer created.\");\n    c.drop();\n    println!(\"CustomSmartPointer dropped before the end of main.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Run Clippy on a Cargo Project\nDESCRIPTION: This command invokes the Clippy linter on a Cargo project, analyzing the code for common mistakes and potential improvements.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-04-useful-development-tools.md#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n$ cargo clippy\n```\n\n----------------------------------------\n\nTITLE: Initializing a Post in Draft State and Adding Text - Rust\nDESCRIPTION: This code snippet demonstrates the creation of a new post in the draft state using `Post::new()` and adding text to its content using the `add_text()` method. It then asserts that accessing the content of the draft post results in an empty string, as expected.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter18.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut post = Post::new();\n\n    post.add_text(\"I ate a salad for lunch today\");\n    assert_eq!(\"\", post.content());\n}\n```\n\n----------------------------------------\n\nTITLE: String Length in Bytes (Spanish)\nDESCRIPTION: This code snippet shows how to get the length of a string in bytes when each character takes one byte, as is the case for simple ASCII strings. The `len` function returns the number of bytes used to store the string.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-02-strings.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(unused)]\nfn main() {\nlet s = String::from(\"Hola\");\n\n    println!(\"{}\", s.len());\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing `unwrap_or_else` with `FnOnce` in Rust\nDESCRIPTION: This code shows the implementation of the `unwrap_or_else` method on `Option<T>`. It accepts a closure `f` of type `FnOnce() -> T`, which means the closure can be called once, takes no arguments, and returns a value of type `T`. The function calls the closure only if the `Option` is `None`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nimpl<T> Option<T> {\n    pub fn unwrap_or_else<F>(self, f: F) -> T\n    where\n        F: FnOnce() -> T\n    {\n        match self {\n            Some(x) => x,\n            None => f(),\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: String Slicing in Rust\nDESCRIPTION: This code snippet demonstrates how to create a string slice using a range. It extracts the first four bytes from the string \"\". Requires careful handling to avoid splitting a Unicode character across byte boundaries, which would cause a panic.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-02-strings.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(unused)]\nfn main() {\nlet hello = \"\";\n\nlet s = &hello[0..4];\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Cargo.toml Example for Publishing\nDESCRIPTION: This example shows a complete Cargo.toml file with the required metadata for publishing, including name, version, edition, description, and license.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-02-publishing-to-crates-io.md#_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"guessing_game\"\nversion = \"0.1.0\"\nedition = \"2024\"\ndescription = \"A fun game where you guess what number the computer has chosen.\"\nlicense = \"MIT OR Apache-2.0\"\n\n[dependencies]\n```\n\n----------------------------------------\n\nTITLE: Searching a String with Iterator Adapters in Rust\nDESCRIPTION: This function searches for lines in a string containing a specific query using iterator adapters. It utilizes `lines()` to create an iterator over lines, `filter()` to select lines containing the query, and `collect()` to gather the results into a `Vec` of string slices. This approach avoids mutable intermediate variables.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_23\n\nLANGUAGE: Rust\nCODE:\n```\npub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    contents\n        .lines()\n        .filter(|line| line.contains(query))\n        .collect()\n}\n```\n\n----------------------------------------\n\nTITLE: Calling next Method on Iterator (Rust)\nDESCRIPTION: This code snippet demonstrates how to call the `next` method directly on an iterator. The `next` method returns an `Option` containing a reference to the next element in the iterator, or `None` if the iterator is exhausted. The iterator `v1_iter` must be declared as mutable because calling `next` modifies its internal state.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n#[test]\nfn iterator_demonstration() {\n    let v1 = vec![1, 2, 3];\n\n    let mut v1_iter = v1.iter();\n\n    assert_eq!(v1_iter.next(), Some(&1));\n    assert_eq!(v1_iter.next(), Some(&2));\n    assert_eq!(v1_iter.next(), Some(&3));\n    assert_eq!(v1_iter.next(), None);\n}\n```\n\n----------------------------------------\n\nTITLE: Storing i32 on the Heap using Box<T> in Rust\nDESCRIPTION: This snippet demonstrates how to allocate an i32 value on the heap using a Box<T>. The Box<T> smart pointer allows data to be stored on the heap instead of the stack.  The value pointed to by the box is deallocated when the box goes out of scope.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let b = Box::new(5);\n    println!(\"b = {b}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Loops with While Rust\nDESCRIPTION: This code demonstrates the use of a `while` loop in Rust. The loop continues as long as the `number` variable is not equal to 0. In each iteration, it prints the value of `number` and decrements it. Once `number` reaches 0, the loop terminates and prints \"LIFTOFF!!!\".\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_35\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut number = 3;\n\n    while number != 0 {\n        println!(\"{number}!\");\n\n        number -= 1;\n    }\n\n    println!(\"LIFTOFF!!!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Closure Capturing Mutable Reference in Rust\nDESCRIPTION: This example demonstrates a closure that captures a mutable reference to a vector. The closure adds an element to the vector using `push`. Because the closure holds a mutable reference, no other borrows (mutable or immutable) are allowed while it's active, which affects when the `println!` can occur. Dependencies: none.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut list = vec![1, 2, 3];\n    println!(\"Before defining closure: {list:?}\");\n\n    let mut borrows_mutably = || list.push(7);\n\n    borrows_mutably();\n    println!(\"After calling closure: {list:?}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Integer Assignment in Rust\nDESCRIPTION: Illustrates the assignment of an integer value to a variable in Rust. Because integers are simple values with a known, fixed size, the value is copied directly onto the stack. Both variables independently hold the same value.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 5;\nlet y = x;\n```\n\n----------------------------------------\n\nTITLE: Using Improved First Word Function\nDESCRIPTION: This example showcases how the improved `first_word` function, which accepts &str, can be used with String slices, String references, and string literals directly. It demonstrates the increased flexibility of the API.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_33\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    let my_string = String::from(\"hello world\");\n\n    // `first_word` works on slices of `String`s, whether partial or whole.\n    let word = first_word(&my_string[0..6]);\n    let word = first_word(&my_string[..]);\n    // `first_word` also works on references to `String`s, which are equivalent\n    // to whole slices of `String`s.\n    let word = first_word(&my_string);\n\n    let my_string_literal = \"hello world\";\n\n    // `first_word` works on slices of string literals, whether partial or\n    // whole.\n    let word = first_word(&my_string_literal[0..6]);\n    let word = first_word(&my_string_literal[..]);\n\n    // Because string literals *are* string slices already,\n    // this works too, without the slice syntax!\n    let word = first_word(my_string_literal);\n}\n```\n\n----------------------------------------\n\nTITLE: If Let Else with Coin Enum Rust\nDESCRIPTION: This example demonstrates the use of `if let` with an `else` block to handle different variants of a `Coin` enum. It prints the state of a quarter if it's a `Coin::Quarter` and increments a counter for all other coin types. This provides a cleaner alternative to a `match` expression when only one or two cases need special handling.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_25\n\nLANGUAGE: Rust\nCODE:\n```\nlet mut count = 0;\n    if let Coin::Quarter(state) = coin {\n        println!(\"State quarter from {state:?}!\");\n    } else {\n        count += 1;\n    }\n```\n\n----------------------------------------\n\nTITLE: Throttling and Taking from Merged Streams\nDESCRIPTION: This code demonstrates the use of `throttle` to limit the rate at which the `intervals` stream is polled and `take` to limit the number of items pulled from the merged stream. This helps to manage the output rate and prevent one stream from overwhelming the other.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-04-streams.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nasync fn throttle() {\n    let messages = get_messages();\n    let intervals = get_intervals()\n        .map(|i| format!(\"Interval: {}\", i))\n        .throttle(Duration::from_millis(100))\n        .timeout(Duration::from_secs(10));\n\n    let merged = messages.merge(intervals).take(20);\n\n    pin_mut!(merged);\n\n    while let Some(msg) = merged.next().await {\n        println!(\"{}\", msg);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Rust code with cargo fix\nDESCRIPTION: This command runs the `rustfix` tool via `cargo fix` to automatically apply suggestions from compiler warnings. In this case, it removes the unnecessary `mut` keyword from the variable declaration.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix.md#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo fix\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Cargo\nDESCRIPTION: This command initiates the test suite for a Rust project. It compiles the project and runs both unit tests and doc tests, reporting the results. The output shows the compilation status, test execution details, and a summary of the test results.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/listing-11-01/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test\n Compiling adder v0.1.0 (file:///projects/adder)\n  Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s\n  Running unittests src/lib.rs (target/debug/deps/adder-01ad14159ff659ab)\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n  Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Using where Clause for Trait Bounds\nDESCRIPTION: This code defines a function `some_function` with generic types `T` and `U`. It utilizes a `where` clause to specify that `T` must implement `Display` and `Clone`, and `U` must implement `Clone` and `Debug`. This syntax improves code readability by separating trait bounds from the function's parameter list.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_28\n\nLANGUAGE: Rust\nCODE:\n```\nfn some_function<T, U>(t: &T, u: &U) -> i32\nwhere\n    T: Display + Clone,\n    U: Clone + Debug,\n{\n```\n\n----------------------------------------\n\nTITLE: Garden Module Definition\nDESCRIPTION: This Rust code snippet defines the 'garden' module in `src/garden.rs`, declaring a submodule named 'vegetables' as public. It shows how modules can be nested to create a hierarchy of code organization.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-02-defining-modules-to-control-scope-and-privacy.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub mod vegetables;\n```\n\n----------------------------------------\n\nTITLE: Using Macro Invocation\nDESCRIPTION: This code snippet demonstrates different forms of macro invocation in Rust, using parentheses, curly braces, or square brackets.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_95\n\nLANGUAGE: Rust\nCODE:\n```\nident!(...)\n```\n\nLANGUAGE: Rust\nCODE:\n```\nident!{...}\n```\n\nLANGUAGE: Rust\nCODE:\n```\nident![...]\n```\n\n----------------------------------------\n\nTITLE: Adding a Timeout to a Stream in Rust\nDESCRIPTION: This code demonstrates adding a timeout to a stream using the `StreamExt::timeout` method.  It sets a time limit for each item in the stream.  The `while let` loop handles the `Result` returned by the stream, printing the message if it arrives in time or an error message if the timeout elapses. The stream needs to be pinned after applying the timeout.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_38\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{pin::pin, time::Duration};\nuse trpl::{ReceiverStream, Stream, StreamExt};\n\nfn main() {\n    trpl::run(async {\n        let mut messages =\n            pin!(get_messages().timeout(Duration::from_millis(200)));\n\n        while let Some(result) = messages.next().await {\n            match result {\n                Ok(message) => println!(\"{message}\"),\n                Err(reason) => eprintln!(\"Problem: {reason:?}\"),\n            }\n        }\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Calling a Function in Rust\nDESCRIPTION: This snippet demonstrates a simple function definition and its subsequent call within the `main` function. It illustrates the basic syntax for function declaration using the `fn` keyword and the calling convention using parentheses. The function `another_function` prints a message to the console when called.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-03-how-functions-work.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    println!(\"Hello, world!\");\n\n    another_function();\n}\n\nfn another_function() {\n    println!(\"Another function.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Calling `next` Method on an Iterator in Rust\nDESCRIPTION: This code demonstrates calling the `next` method directly on an iterator to retrieve its elements. The iterator must be mutable because calling `next` changes its internal state. Repeated calls to `next` consume the iterator until it returns `None`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-02-iterators.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[test]\nfn iterator_demonstration() {\n    let v1 = vec![1, 2, 3];\n\n    let mut v1_iter = v1.iter();\n\n    assert_eq!(v1_iter.next(), Some(&1));\n    assert_eq!(v1_iter.next(), Some(&2));\n    assert_eq!(v1_iter.next(), Some(&3));\n    assert_eq!(v1_iter.next(), None);\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Command Line Arguments - Rust\nDESCRIPTION: This code snippet demonstrates how to read command line arguments passed to a Rust program using `std::env::args`. It collects the arguments into a vector of strings and prints them using the debug macro. This requires importing the `std::env` module.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::env;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    dbg!(args);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Raw Identifiers to Resolve Keyword Conflicts in Rust\nDESCRIPTION: This example showcases how to use raw identifiers (prefixing `match` with `r#`) to successfully define and call a function named `match`, which would otherwise be a keyword conflict. The code demonstrates the usage of `r#match` in both the function definition and the function call within the `main` function.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-01-keywords.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn r#match(needle: &str, haystack: &str) -> bool {\n    haystack.contains(needle)\n}\n\nfn main() {\n    assert!(r#match(\"foo\", \"foobar\"));\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Conditions with 'else if' in Rust\nDESCRIPTION: This code demonstrates using 'else if' to handle multiple conditions in Rust. It checks if 'number' is divisible by 4, 3, or 2, and prints a corresponding message. If none of the conditions are met, it executes the 'else' block.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_29\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let number = 6;\n\n    if number % 4 == 0 {\n        println!(\"number is divisible by 4\");\n    } else if number % 3 == 0 {\n        println!(\"number is divisible by 3\");\n    } else if number % 2 == 0 {\n        println!(\"number is divisible by 2\");\n    } else {\n        println!(\"number is not divisible by 4, 3, or 2\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust Code\nDESCRIPTION: This command compiles a Rust source file (`main.rs`) using the Rust compiler `rustc`. It creates an executable file in the same directory, named `main` (or `main.exe` on Windows).  The compiler checks the code for errors before generating the executable.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-02-hello-world.md#_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n$ rustc main.rs\n```\n\n----------------------------------------\n\nTITLE: Creating a Reference Cycle with Rc and RefCell in Rust\nDESCRIPTION: This code creates a reference cycle between two `List` values (`a` and `b`) using `Rc<List>` and `RefCell<Rc<List>>`. It demonstrates how modifying the tail of list `a` to point to list `b` creates a cycle where both lists refer to each other, preventing their memory from being freed.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-06-reference-cycles.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));\n\n    println!(\"a initial rc count = {}\", Rc::strong_count(&a));\n    println!(\"a next item = {:?}\", a.tail());\n\n    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));\n\n    println!(\"a rc count after b creation = {}\", Rc::strong_count(&a));\n    println!(\"b initial rc count = {}\", Rc::strong_count(&b));\n    println!(\"b next item = {:?}\", b.tail());\n\n    if let Some(link) = a.tail() {\n        *link.borrow_mut() = Rc::clone(&b);\n    }\n\n    println!(\"b rc count after changing a = {}\", Rc::strong_count(&b));\n    println!(\"a rc count after changing a = {}\", Rc::strong_count(&a));\n\n    // Uncomment the next line to see that we have a cycle; it will\n    // overflow the stack.\n    // println!(\"a next item = {:?}\", a.tail());\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving Debug Trait in Rust\nDESCRIPTION: The `Debug` trait enables debug formatting, allowing printing instances of a type for debugging purposes using the `:?` format specifier within `{}` placeholders in format strings. It's often required by macros like `assert_eq!` to display values when equality assertions fail.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix.md#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Struct Update Syntax in Rust\nDESCRIPTION: Demonstrates struct update syntax for creating a new struct instance based on an existing one.  The `..user1` syntax copies the remaining fields from `user1` into `user2`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-01-defining-structs.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let user1 = User {\n        email: String::from(\"someone@example.com\"),\n        username: String::from(\"someusername123\"),\n        active: true,\n        sign_in_count: 1,\n    };\n\n    let user2 = User {\n        email: String::from(\"another@example.com\"),\n        ..user1\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo.toml dependency declaration - TOML\nDESCRIPTION: This snippet shows how to declare a dependency on the `rand` crate in the `Cargo.toml` file.  The version specifier `0.8.5` is used.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter02.md#_snippet_5\n\nLANGUAGE: TOML\nCODE:\n```\n[dependencies]\nrand = \"0.8.5\"\n```\n\n----------------------------------------\n\nTITLE: Running Clippy Linter on a Cargo Project\nDESCRIPTION: This command runs the Clippy linter on the current Cargo project, identifying potential issues and suggesting improvements to the code.  Clippy provides a collection of lints to catch common mistakes and improve Rust code. Requires Clippy to be installed.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix_d.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo clippy\n```\n\n----------------------------------------\n\nTITLE: Implementing Methods on Generic Structs\nDESCRIPTION: This snippet demonstrates implementing a method `x` on a generic struct `Point<T>`. The method returns a reference to the `x` field of the struct. The `main` function creates an instance of `Point<i32>` and calls the `x` method.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Point<T> {\n    fn x(&self) -> &T {\n        &self.x\n    }\n}\n\nfn main() {\n    let p = Point { x: 5, y: 10 };\n\n    println!(\"p.x = {}\", p.x());\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Immutable References in a Vector in Rust\nDESCRIPTION: This snippet shows how to iterate over the elements of a vector using a `for` loop, obtaining immutable references to each element. The `&` before `i` in the loop creates an immutable reference, preventing modification of the vector's elements during iteration.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-01-vectors.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let v = vec![100, 32, 57];\n    for i in &v {\n        println!(\"{}\", i);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Joining Anonymous Futures with trpl::join in Rust\nDESCRIPTION: This example demonstrates how to use `trpl::join` to run two anonymous futures concurrently and wait for both to complete. It highlights the fair scheduling provided by `trpl::join`, ensuring that both futures progress relatively evenly. The output is ignored as it is a tuple of unit values.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nlet fut1 = async {\n            for i in 1..10 {\n                println!(\"hi number {i} from the first task!\");\n                trpl::sleep(Duration::from_millis(500)).await;\n            }\n        };\n\n        let fut2 = async {\n            for i in 1..5 {\n                println!(\"hi number {i} from the second task!\");\n                trpl::sleep(Duration::from_millis(500)).await;\n            }\n        };\n\n        trpl::join(fut1, fut2).await;\n```\n\n----------------------------------------\n\nTITLE: Using a Thread Pool Interface in Rust\nDESCRIPTION: This code snippet demonstrates the intended usage of a `ThreadPool` struct for handling incoming connections. The `ThreadPool::new` function creates a pool with a specified number of threads (4 in this case). The `pool.execute` method is then used to submit a closure containing the `handle_connection` function to the thread pool, allowing one of the available threads to process the connection.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    let pool = ThreadPool::new(4);\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        pool.execute(|| {\n            handle_connection(stream);\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Macro Repetition\nDESCRIPTION: This code snippet shows how to use macro repetition in Rust.  It allows repeating a sequence of tokens zero or more times.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_94\n\nLANGUAGE: Rust\nCODE:\n```\n$(...)\n```\n\n----------------------------------------\n\nTITLE: Running a Rust Cargo Project\nDESCRIPTION: This command compiles and runs a Rust project named 'cons-list' using the Cargo build system. It compiles the source code, handles dependencies, and executes the resulting binary. The output displays the compilation status, the time taken for the process, and the final result of the program execution.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch15-smart-pointers/listing-15-24/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling cons-list v0.1.0 (file:///projects/cons-list)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.63s\n   Running `target/debug/cons-list`\na after = Cons(RefCell { value: 15 }, Nil)\nb after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))\nc after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))\n```\n\n----------------------------------------\n\nTITLE: Introducing a Type Alias `Thunk` to reduce repetition in Rust\nDESCRIPTION: This snippet demonstrates using a type alias `Thunk` to simplify the use of a long and complex type `Box<dyn Fn() + Send + 'static>`.  By using `Thunk`, the code becomes more readable and easier to maintain.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-03-advanced-types.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ntype Thunk = Box<dyn Fn() + Send + 'static>;\n\nfn takes_long_type(f: Thunk) {\n    // --snip--\n}\n\nfn returns_long_type() -> Thunk {\n    // --snip--\n    Box::new(|| ())\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Lifetime Restrictions with `longest` Function in Rust\nDESCRIPTION: This code demonstrates a scenario where lifetime annotations cause a compile-time error. The `result` variable is declared outside the inner scope but assigned within it, using the `longest` function with `string2` which has a smaller scope. Attempting to use `result` outside the inner scope leads to a borrow checker error because the lifetime of the reference in result is tied to the lifetime of `string2`\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-03-lifetime-syntax.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        result = longest(string1.as_str(), string2.as_str());\n    }\n    println!(\"The longest string is {}\", result);\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Command-Line Arguments - Rust\nDESCRIPTION: This code snippet demonstrates how to collect command-line arguments into a vector of strings using `std::env::args` and the `collect` method. The vector is then printed using the debug macro.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-01-accepting-command-line-arguments.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::env;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    println!(\"{:?}\", args);\n}\n```\n\n----------------------------------------\n\nTITLE: Function with Multiple Parameters in Rust\nDESCRIPTION: This snippet shows a function that accepts two parameters: an integer (`i32`) and a character (`char`). It demonstrates how to define multiple parameters in a function signature, separating them with commas. The `println!` macro is used to display the values of both parameters.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-03-how-functions-work.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    print_labeled_measurement(5, 'h');\n}\n\nfn print_labeled_measurement(value: i32, unit_label: char) {\n    println!(\"The measurement is: {}{}\", value, unit_label);\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Literals in Rust\nDESCRIPTION: This snippet demonstrates matching against literal values using the `match` expression in Rust. It checks the value of `x` against several literal values (1, 2, 3) and prints a corresponding message. The `_` pattern is used as a catch-all case.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 1;\n\nmatch x {\n    1 => println!(\"one\"),\n    2 => println!(\"two\"),\n    3 => println!(\"three\"),\n    _ => println!(\"anything\"),\n}\n```\n\n----------------------------------------\n\nTITLE: Installing a Binary Crate with cargo install\nDESCRIPTION: This snippet demonstrates how to install a binary crate using `cargo install`.  It shows the installation of the `ripgrep` crate. The output displays the downloading, compiling, and installing steps, culminating in the executable `rg` being installed in the user's cargo bin directory.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_29\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo install ripgrep\n    Updating crates.io index\n  Downloaded ripgrep v13.0.0\n  Downloaded 1 crate (243.3 KB) in 0.88s\n  Installing ripgrep v13.0.0\n--snip--\n   Compiling ripgrep v13.0.0\n    Finished `release` profile [optimized + debuginfo] target(s) in 10.64s\n  Installing ~/.cargo/bin/rg\n   Installed package `ripgrep v13.0.0` (executable `rg`)\n```\n\n----------------------------------------\n\nTITLE: Creating Failing Test for Search Function Rust\nDESCRIPTION: This test case defines the expected behavior of the `search` function. It asserts that when searching for the string \"duct\" within a given text, the function should return a vector containing only the line that includes \"duct\". This example does not compile as the search function is not yet implemented.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-04-testing-the-librarys-functionality.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-15/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Explicit Type Declaration for Futures (Incorrect)\nDESCRIPTION: This snippet adds an explicit type declaration for the `futures` variable using trait objects (`dyn Future<Output = ()>`) and `Box` to allow different async blocks to be stored in the same vector. However, this still doesn't fully resolve the compilation errors, as it introduces the `Unpin` trait errors that must be handled separately.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-03-more-futures.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse tokio::sync::mpsc;\nuse futures::future;\n\n#[tokio::main]\nasync fn main() {\n    let (tx1, mut rx1) = mpsc::channel::<i32>(100);\n    let (tx2, rx2) = mpsc::channel::<i32>(100);\n    let mut tx_fut = async move {\n        let mut i = 0;\n        loop {\n            // Maybe the receiver dropped\n            if tx1.send(i).await.is_err() {\n                break;\n            }\n            i += 1;\n        }\n    };\n\n    let mut rx_fut = async {\n        loop {\n            if rx1.recv().await.is_none() {\n                break;\n            }\n        }\n    };\n    let mut tx1_fut = async move {\n        let mut i = 0;\n        loop {\n            // Maybe the receiver dropped\n            if tx2.send(i).await.is_err() {\n                break;\n            }\n            i += 1;\n        }\n    };\n\n    let futures: Vec<Box<dyn Future<Output = ()> + Unpin>> = vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];\n    future::join_all(futures).await;\n}\n```\n\n----------------------------------------\n\nTITLE: Loop: Infinite Loop in Rust\nDESCRIPTION: This code snippet demonstrates an infinite loop using the `loop` keyword in Rust. The code inside the loop will execute repeatedly until explicitly stopped using a `break` statement or by interrupting the program externally. The program will continuously print \"again!\" to the console.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-05-control-flow.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    loop {\n        println!(\"again!\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Option Enum Definition Rust\nDESCRIPTION: This is the standard library definition of the `Option<T>` enum.  It can either be `Some(T)` representing a value or `None` representing no value.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nenum Option<T> {\n    Some(T),\n    None,\n}\n```\n\n----------------------------------------\n\nTITLE: Ignoring Fields in a Struct with `..` Rust\nDESCRIPTION: This code demonstrates how to ignore all fields of a `Point` struct except for the `x` coordinate using the `..` syntax in a `match` expression. This avoids the need to explicitly list underscores for the ignored `y` and `z` fields.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point {\n    x: i32,\n    y: i32,\n    z: i32,\n}\n\nfn main() {\n    let point = Point { x: 0, y: 7, z: 9 };\n\n    match point {\n        Point { x, .. } => println!(\"x is {}\", x),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Methods on Enums in Rust\nDESCRIPTION: This snippet shows how to implement methods on an enum using `impl`. The `call` method is defined on the `Message` enum and can be called on instances of the enum.  It then calls this method on a Write variant of the enum.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nimpl Message {\n    fn call(&self) {\n        // method body would be defined here\n    }\n}\n\nlet m = Message::Write(String::from(\"hello\"));\nm.call();\n```\n\n----------------------------------------\n\nTITLE: Conditional Logic with if let, else if in Rust\nDESCRIPTION: This Rust code demonstrates the use of `if let`, `else if`, and `else if let` expressions to determine a background color based on different conditions. It includes parsing a string to an integer and using nested `if` statements.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let favorite_color: Option<&str> = None;\n    let is_tuesday = false;\n    let age: Result<u8, _> = \"34\".parse();\n\n    if let Some(color) = favorite_color {\n        println!(\"Using your favorite color, {color}, as the background\");\n    } else if is_tuesday {\n        println!(\"Tuesday is green day!\");\n    } else if let Ok(age) = age {\n        if age > 30 {\n            println!(\"Using purple as the background color\");\n        } else {\n            println!(\"Using orange as the background color\");\n        }\n    } else {\n        println!(\"Using blue as the background color\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Largest i32 and char functions\nDESCRIPTION: Two functions, `largest_i32` and `largest_char`, are defined to find the largest value in a slice of `i32` and `char` respectively. This illustrates the need for generics to avoid code duplication when the logic is the same but the data types differ.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-01-syntax.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn largest_i32(list: &[i32]) -> &i32 {\n    let mut largest = &list[0];\n\n    for &item in list {\n        if item > *largest {\n            largest = &item;\n        }\n    }\n\n    largest\n}\n\nfn largest_char(list: &[char]) -> &char {\n    let mut largest = &list[0];\n\n    for &item in list {\n        if item > *largest {\n            largest = &item;\n        }\n    }\n\n    largest\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Numbers Using Ordering Enum and Match - Rust\nDESCRIPTION: This code snippet demonstrates how to compare the user's guess with the secret number using the `std::cmp::Ordering` enum and a `match` expression to determine if the guess is too small, too big, or equal to the secret number.\nIt requires the `guess` and `secret_number` variables to be in scope. The code prints a message to the console indicating the result of the comparison.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter02.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nuse std::cmp::Ordering;\nuse std::io;\n\nuse rand::Rng;\n\nfn main() {\n    // --snip--\n\n    println!(\"You guessed: {guess}\");\n\n    match guess.cmp(&secret_number) {\n        Ordering::Less => println!(\"Too small!\"),\n        Ordering::Greater => println!(\"Too big!\"),\n        Ordering::Equal => println!(\"You win!\"),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Looping with Range and Rev Rust\nDESCRIPTION: This code uses a `for` loop, a `Range`, and the `rev` method to create a countdown.  The `(1..4)` creates a range of numbers from 1 up to (but not including) 4. The `rev()` method reverses this range, and the `for` loop iterates through the reversed range, printing each number.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_38\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    for number in (1..4).rev() {\n        println!(\"{number}!\");\n    }\n    println!(\"LIFTOFF!!!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Reference Count with Rc<T> in Rust\nDESCRIPTION: This code demonstrates how to track the reference count of an `Rc<List>` using the `Rc::strong_count` function. It creates a list 'a', then clones it to create lists 'b' and 'c'.  The reference count is printed at various points, including before and after cloning, and after 'c' goes out of scope, showcasing how the count changes.  This illustrates how `Rc<T>` manages shared ownership and automatically decrements the reference count when a variable goes out of scope.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-04-rc.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-19/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Multiple Trait Bounds on Generic Types\nDESCRIPTION: This function `notify` uses a generic type `T` which is constrained to implement both the `Summary` and `Display` traits.  The function takes a reference to `T` as its argument.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_26\n\nLANGUAGE: Rust\nCODE:\n```\npub fn notify<T: Summary + Display>(item: &T) {\n```\n\n----------------------------------------\n\nTITLE: Point struct with multiple generic types\nDESCRIPTION: Defines a `Point` struct that is generic over two types, `T` and `U`. The `x` field is of type `T`, and the `y` field is of type `U`, allowing them to be different types. This shows how to use multiple generic type parameters to create even more flexible data structures.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-01-syntax.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point<T, U> {\n    x: T,\n    y: U,\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating over Characters in a String\nDESCRIPTION: This code snippet shows how to iterate over individual Unicode scalar values in a string using the `chars()` method. This method returns an iterator of `char` values.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-02-strings.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(unused)]\nfn main() {\nfor c in \"\".chars() {\n    println!(\"{c}\");\n}\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Slicing in Rust\nDESCRIPTION: This represents collection slicing in Rust, using `Range`, `RangeFrom`, `RangeTo`, or `RangeFull` as the index. It allows extracting a portion of a collection.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_115\n\nLANGUAGE: Rust\nCODE:\n```\nexpr[..]\n```\n\nLANGUAGE: Rust\nCODE:\n```\nexpr[a..]\n```\n\nLANGUAGE: Rust\nCODE:\n```\nexpr[..b]\n```\n\nLANGUAGE: Rust\nCODE:\n```\nexpr[a..b]\n```\n\n----------------------------------------\n\nTITLE: For Loop iterating over array in Rust\nDESCRIPTION: This code demonstrates a `for` loop in Rust that iterates over the elements of an array. It prints the value of each element in the array using the `.iter()` method to create an iterator.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/loops.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet a = [10, 20, 30, 40, 50];\nfor element in a.iter() {\n    println!(\"the value is: {element}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Running a Rust Project with Cargo Run\nDESCRIPTION: This command combines the build and execution steps into one. Cargo checks if the source code has changed and recompiles if necessary, then runs the resulting executable from `target/debug`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_25\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/hello_cargo`\nHello, world!\n```\n\n----------------------------------------\n\nTITLE: Updating Config::build Signature to Use Iterator in Rust\nDESCRIPTION: This code snippet updates the signature of the `Config::build` function to accept an iterator as input, rather than a slice. It uses the `impl Iterator<Item = String>` trait bound to specify that the argument must be an iterator that yields `String` values. The `mut` keyword is added because the iterator will be mutated.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nimpl Config {\n    pub fn build(\n        mut args: impl Iterator<Item = String>,\n    ) -> Result<Config, &'static str> {\n        // --snip--\n\n```\n\n----------------------------------------\n\nTITLE: Fixing Future Type Mismatches with Pin and Box in Rust\nDESCRIPTION: This snippet demonstrates how to fix type mismatches when combining different futures into a vector for use with `join_all`. It uses `Pin` and `Box::pin` to ensure all futures are of the same type, allowing them to be stored in a `Vec<Pin<Box<dyn Future<Output = ()>>>>`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nlet futures: Vec<Pin<Box<dyn Future<Output = ()>>>> =\n    vec![Box::pin(tx1_fut), Box::pin(rx_fut), Box::pin(tx_fut)];\n```\n\n----------------------------------------\n\nTITLE: Defining modules for a restaurant front of house\nDESCRIPTION: This code snippet defines nested modules for a restaurant's front of house.  It includes modules for `hosting` and `serving`, with functions defined inside them. This demonstrates how modules can be used to organize code logically.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nmod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {}\n\n        fn seat_at_table() {}\n    }\n\n    mod serving {\n        fn take_order() {}\n\n        fn serve_order() {}\n\n        fn take_payment() {}\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Loop Labels in Rust\nDESCRIPTION: This Rust code snippet shows how to use loop labels to control which loop is exited by a `break` statement in nested loops.  The outer loop is labeled `'counting_up`, allowing the `break 'counting_up;` statement to exit the outer loop directly.  This is essential for managing complex control flow in nested loop scenarios.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-05-control-flow.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut count = 0;\n    'counting_up: loop {\n        println!(\"count = {}\", count);\n        let mut remaining = 10;\n\n        loop {\n            println!(\"remaining = {}\", remaining);\n            if remaining == 9 {\n                break;\n            }\n            if count == 2 {\n                break 'counting_up;\n            }\n            remaining -= 1;\n        }\n\n        count += 1;\n    }\n    println!(\"End count = {}\", count);\n}\n```\n\n----------------------------------------\n\nTITLE: Using `Asparagus` from `vegetables` module\nDESCRIPTION: This code snippet demonstrates how to use the `Asparagus` struct from the `vegetables` module within the `main` function. It relies on the `garden` module and its submodule `vegetables` containing the `Asparagus` struct. The `use` keyword is used to create a shortcut to `crate::garden::vegetables::Asparagus`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse crate::garden::vegetables::Asparagus;\n\npub mod garden;\n\nfn main() {\n    let plant = Asparagus {};\n    println!(\"I'm growing {plant:?}!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Function Signature for Finding the First Word in a String (Initial)\nDESCRIPTION: This code shows the initial function signature for finding the first word in a string without using slices. The function takes a reference to a String and is expected to return something representing the first word, but the return type is not yet defined. This example sets the stage for introducing string slices as a solution.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-03-slices.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn first_word(s: &String) -> ?\n```\n\n----------------------------------------\n\nTITLE: Function Signature with String Slice in Rust\nDESCRIPTION: This snippet presents a function signature that takes a string slice (`&str`) as a parameter, allowing the function to be used with both `&String` and `&str` values. This approach leverages deref coercions for greater flexibility.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-03-slices.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nfn first_word(s: &String) -> &str {\n```\n\n----------------------------------------\n\nTITLE: Guessing Game with Looping - Rust\nDESCRIPTION: This snippet demonstrates the use of a `loop` to allow multiple guesses in the guessing game.  The code prompts the user for a guess repeatedly. It requires the standard input/output library and the `rand` crate. The loop continues indefinitely until the program is manually terminated.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-04-looping/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Matching Enum Values with `match` in Rust\nDESCRIPTION: This code snippet demonstrates using the `match` control flow operator to determine the value of different coin types. The `Coin` enum defines the possible coin types, and the `value_in_cents` function uses `match` to return the corresponding value in cents for each coin variant.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/match.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -> u32 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter => 25,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Failed Rust Test Assertion\nDESCRIPTION: This snippet shows the output of a failed test case, `tests::greeting_contains_name`. The test failed because the assertion `result.contains(\"Carol\")` returned false, indicating the generated greeting did not contain the name \"Carol\".\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/no-listing-06-greeter-with-bug/output.txt#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntest tests::greeting_contains_name ... FAILED\n\nfailures:\n\n---- tests::greeting_contains_name stdout ----\n\nthread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:\nassertion failed: result.contains(\"Carol\")\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n```\n\n----------------------------------------\n\nTITLE: `main` function calling `longest` in Rust\nDESCRIPTION: This is a `main` function that calls the `longest` function (not yet implemented in the provided context) to find the longer of two string slices. It sets the stage for demonstrating the need for lifetime annotations in the `longest` function.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-03-lifetime-syntax.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-19/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Using Types with the Same Name from Different Modules Rust\nDESCRIPTION: This snippet shows how to use types with the same name from different modules using the `use` keyword. You must bring in the types using their full paths to avoid naming conflicts and ambiguity.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt;\nuse std::io;\n\nfn function1() -> fmt::Result {\n    // --snip--\n}\n\nfn function2() -> io::Result<()> {\n    // --snip--\n}\n```\n\n----------------------------------------\n\nTITLE: Ignoring Function Parameter with `_` in Rust\nDESCRIPTION: This code ignores the first function parameter using the `_` pattern in the function signature. This is useful when implementing a trait with a specific signature but not needing all parameters in the implementation. Dependencies: None. Inputs: Two i32 values. Outputs: Prints a message using only the second parameter.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nfn foo(_: i32, y: i32) {\n    println!(\"This code only uses the y parameter: {}\", y);\n}\n\nfn main() {\n    foo(3, 4);\n}\n```\n\n----------------------------------------\n\nTITLE: Error Propagation with Match in Rust\nDESCRIPTION: This code snippet demonstrates error propagation using `match` expressions to handle `Result` values returned by `File::open` and `read_to_string`. If an error occurs during file opening or reading, the function returns early with the error. Otherwise, it returns the username read from the file.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch09-02-recoverable-errors-with-result.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs::File;\nuse std::io;\nuse std::io::Read;\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    let username_file_result = File::open(\"hello.txt\");\n\n    let mut username_file = match username_file_result {\n        Ok(file) => file,\n        Err(e) => return Err(e),\n    };\n\n    let mut username = String::new();\n\n    match username_file.read_to_string(&mut username) {\n        Ok(_) => Ok(username),\n        Err(e) => Err(e),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running the Hello World program\nDESCRIPTION: This shows the output of running the default \"Hello, world!\" program generated by `cargo new`.  It demonstrates the basic usage of `cargo run`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n{{#include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/output.txt}}\n```\n\n----------------------------------------\n\nTITLE: Art Library with Modules in Rust\nDESCRIPTION: This code defines a library `art` with two modules, `kinds` (containing enums `PrimaryColor` and `SecondaryColor`) and `utils` (containing function `mix`). It shows the initial structure before re-exporting items using `pub use`. The code demonstrates a hierarchical module structure.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-02-publishing-to-crates-io.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(unused)]\nfn main() {\n    pub mod kinds {\n        /// The primary colors according to the RYB color model.\n        pub enum PrimaryColor {\n            Red,\n            Yellow,\n            Blue,\n        }\n\n        /// The secondary colors according to the RYB color model.\n        pub enum SecondaryColor {\n            Orange,\n            Green,\n            Purple,\n        }\n    }\n\n    pub mod utils {\n        use crate::kinds::*;\n\n        /// Combines two primary colors in equal amounts to create\n        /// a secondary color.\n        pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {\n            // --snip--\n            SecondaryColor::Orange\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Calling function with MyBox<String> using deref coercion in Rust\nDESCRIPTION: This snippet demonstrates calling the `hello` function with a reference to a `MyBox<String>` value. Deref coercion allows Rust to automatically convert `&MyBox<String>` to `&String` and then to `&str`, which matches the function's parameter type.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-02-deref.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse crate::MyBox;\n\nfn main() {\n    let m = MyBox::new(String::from(\"Rust\"));\n    hello(&m);\n}\n```\n\n----------------------------------------\n\nTITLE: Async Main Function for Single Page Title Retrieval\nDESCRIPTION: This code snippet demonstrates an initial attempt to create an async main function that retrieves the title of a webpage given a URL from command line arguments. It uses `std::env::args()` to collect arguments, `page_title` function (assumed to be defined elsewhere) to fetch the title asynchronously, and a `match` expression to handle the result.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nasync fn main() {\n    let args: Vec<String> = std::env::args().collect();\n    let url = &args[1];\n    match page_title(url).await {\n        Some(title) => println!(\"The title for {url} was {title}\"),\n        None => println!(\"{url} had no title\"),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Associated Functions and Fully Qualified Syntax\nDESCRIPTION: This code showcases the use of fully qualified syntax to call associated functions (non-methods) defined in traits and implemented on structs. It illustrates a scenario where both a trait and a struct implementing the trait define an associated function with the same name, requiring explicit disambiguation using `<Type as Trait>::function()` syntax. This example defines an `Animal` trait and `Dog` struct.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-02-advanced-traits.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\ntrait Animal {\n    fn baby_name() -> String;\n}\n\nstruct Dog;\n\nimpl Dog {\n    fn baby_name() -> String {\n        String::from(\"Spot\")\n    }\n}\n\nimpl Animal for Dog {\n    fn baby_name() -> String {\n        String::from(\"A baby dog is called a puppy\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering a stream with StreamExt::filter\nDESCRIPTION: This code snippet demonstrates filtering a stream using the `StreamExt::filter` method. It filters the stream to only include multiples of three and five. It showcases the utility methods provided by the `StreamExt` trait.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-04-streams.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse trpl::StreamExt;\n\n    let mut stream = trpl::stream_from_iter(array.into_iter().map(|x| x * 2));\n\n    let mut stream = stream.filter(|x| future::ready(x % 3 == 0 || x % 5 == 0));\n\n    while let Some(value) = stream.next().await {\n        println!(\"value: {}\", value);\n    }\n```\n\n----------------------------------------\n\nTITLE: Block Expression in Rust\nDESCRIPTION: This represents a block expression in Rust, which is a sequence of statements enclosed in curly braces. Block expressions can evaluate to a value, which is the value of the last expression in the block. If the block ends with a semicolon, it evaluates to ().\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_109\n\nLANGUAGE: Rust\nCODE:\n```\n{...}\n```\n\n----------------------------------------\n\nTITLE: Rust Code Using Exact PI Constant\nDESCRIPTION: This corrected code snippet utilizes the `PI` constant from the `std::f64::consts` module, resolving the Clippy error and improving the program's accuracy.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-04-useful-development-tools.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = std::f64::consts::PI;\n    let r = 8.0;\n    println!(\"the area of the circle is {}\", x * r * r);\n}\n```\n\n----------------------------------------\n\nTITLE: Avoiding Heap Allocations with pin! Macro in Rust Futures\nDESCRIPTION: This snippet shows how to avoid heap allocations when working with futures by using the `pin!` macro. It defines the futures with `pin!` and stores them in a `Vec` of pinned mutable references to the dynamic future type (`Vec<Pin<&mut dyn Future<Output = ()>>>`).\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\nlet tx1_fut = pin!(async move {\n    // --snip--\n});\n\nlet rx_fut = pin!(async {\n    // --snip--\n});\n\nlet tx_fut = pin!(async move {\n    // --snip--\n});\n\nlet futures: Vec<Pin<&mut dyn Future<Output = ()>>> =\n    vec![tx1_fut, rx_fut, tx_fut];\n```\n\n----------------------------------------\n\nTITLE: Generic Type Parameters, Trait Bounds, and Lifetimes in Rust\nDESCRIPTION: This snippet shows an example of a function in Rust that uses generic type parameters, trait bounds, and lifetimes. The `longest` function takes two string slices and a generic type `T` that implements the `Display` trait. The lifetime parameter `'a` and the generic type parameter `T` are declared within the angle brackets after the function name.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-03-lifetime-syntax.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-11-generics-traits-and-lifetimes/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Remainder and Assignment Operator Rust\nDESCRIPTION: This operator calculates the remainder of an arithmetic division and assigns the result to the variable.  It's a shorthand for `var = var % expr`. The `RemAssign` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\n`var %= expr`\n```\n\n----------------------------------------\n\nTITLE: Conditional Pattern Matching with `if let` in Rust\nDESCRIPTION: This code demonstrates the use of `if let` to concisely match a specific pattern in a `Some` variant of an `Option`. If `some_u8_value` is `Some(3)`, the code prints \"three\". Otherwise, it does nothing. The snippet requires no external dependencies, assuming standard library usage.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/if-let.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet some_u8_value = Some(3u8);\nif let Some(3) = some_u8_value {\n    println!(\"three\");\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Output of Successful Tests\nDESCRIPTION: This command demonstrates how to show the output of successful tests using the `--show-output` flag.  By default, only output from failing tests is displayed.  This flag is passed to the test binary after the `--` separator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-02-running-tests.md#_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ cargo test -- --show-output\n```\n\n----------------------------------------\n\nTITLE: Executing Rust Tests with Cargo\nDESCRIPTION: This snippet shows the output of running the `cargo test` command in a Rust project. It demonstrates the compilation process, the execution of unit tests and doc tests, and the summary of test results indicating success.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/listing-11-11/output.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 3 tests\ntest tests::add_three_and_two ... ok\ntest tests::add_two_and_two ... ok\ntest tests::one_hundred ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error: Missing Debug Implementation\nDESCRIPTION: This snippet demonstrates a compilation error in Rust when the `Debug` trait is not implemented for a struct being printed using the `{:?}` format specifier. The error message suggests adding `#[derive(Debug)]` to the struct definition to automatically implement the trait. This ensures the struct can be formatted for debugging purposes.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch05-using-structs-to-structure-related-data/output-only-01-debug/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nerror[E0277]: `Rectangle` doesn't implement `Debug`\n  --> src/main.rs:12:31\n   |\n12 |     println!(\"rect1 is {:?}\", rect1);\n   |                               ^^^^^ `Rectangle` cannot be formatted using `{:?}`\n   |\n   = help: the trait `Debug` is not implemented for `Rectangle`\n   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`\n   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `Rectangle` with `#[derive(Debug)]`\n   |\n1  + #[derive(Debug)]\n2  | struct Rectangle {\n   |\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `rectangles` (bin \"rectangles\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Attempting to Call Drop Method Manually Rust\nDESCRIPTION: This code snippet demonstrates an attempt to call the `drop` method of a `CustomSmartPointer` struct manually. The attempt results in a compiler error because explicit calls to the drop method are not allowed in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let c = CustomSmartPointer {\n        data: String::from(\"some data\"),\n    };\n    println!(\"CustomSmartPointer created.\");\n    c.drop();\n    println!(\"CustomSmartPointer dropped before the end of main.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a new Rust package using Cargo\nDESCRIPTION: This command creates a new Rust binary package named `my-project` using Cargo. It initializes a directory structure including a `Cargo.toml` file and a `src` directory containing `main.rs`. The `Cargo.toml` file defines the package metadata, and `src/main.rs` serves as the crate root for the binary crate.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-01-packages-and-crates.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo new my-project\n     Created binary (application) `my-project` package\n$ ls my-project\nCargo.toml\nsrc\n$ ls my-project/src\nmain.rs\n```\n\n----------------------------------------\n\nTITLE: Moving Sender Ownership for Channel Closure\nDESCRIPTION: This code modifies the previous example to move ownership of the sender (`tx`) into the `tx_fut` async block. This ensures that the sender is dropped when the block completes, closing the channel and allowing the receiver to terminate gracefully.  The `async move` keyword is crucial for this.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nlet (tx, mut rx) = trpl::channel();\n\nlet tx_fut = async move {\n    let vals = vec![\n        String::from(\"hi\"),\n        String::from(\"from\"),\n        String::from(\"the\"),\n        String::from(\"future\"),\n    ];\n\n    for val in vals {\n        tx.send(val).unwrap();\n        trpl::sleep(Duration::from_millis(500)).await;\n    }\n};\n\nlet rx_fut = async {\n\n```\n\n----------------------------------------\n\nTITLE: Pinning Futures with `Pin` and `Box::pin` in Rust\nDESCRIPTION: This code snippet demonstrates how to use `Pin` and `Box::pin` to fix the `Unpin` trait issue with dynamic futures. It wraps each boxed future in a `Pin` to ensure that the type checker is satisfied. This allows the code to compile and run successfully using `join_all`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-03-more-futures.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch17-async-await/listing-17-18/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Async Task in Rust\nDESCRIPTION: This snippet demonstrates how to create a new async task using `trpl::spawn_task`.  It spawns a task that prints a message multiple times with a delay, while the main task also prints a message. The `trpl::sleep` function is used to simulate work.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse std::time::Duration;\n\nfn main() {\n    trpl::run(async {\n        trpl::spawn_task(async {\n            for i in 1..10 {\n                println!(\"hi number {i} from the first task!\");\n                trpl::sleep(Duration::from_millis(500)).await;\n            }\n        });\n\n        for i in 1..5 {\n            println!(\"hi number {i} from the second task!\");\n            trpl::sleep(Duration::from_millis(500)).await;\n        }\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Checking for Environment Variable in Rust\nDESCRIPTION: This Rust code demonstrates how to use the `std::env` module to check if the `IGNORE_CASE` environment variable is set.  The `is_ok` method on the `Result` returned by `env::var` is used to determine if the variable exists, enabling case-insensitive search if it's set.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-05-working-with-environment-variables.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-23/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Fetching and Printing Data Asynchronously in Rust\nDESCRIPTION: This code snippet demonstrates how to fetch data asynchronously from a URL and print it using Rust's `async` and `await` keywords. The `await` keyword allows the program to pause execution until the `fetch_data_from` function returns a value, without blocking the main thread. This example requires an async runtime to execute.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet data = fetch_data_from(url).await;\nprintln!(\"{data}\");\n```\n\n----------------------------------------\n\nTITLE: Calling a Function in Parent Module using `super` in Rust\nDESCRIPTION: This snippet demonstrates how to use the `super` keyword to call a function in the parent module. The `fix_incorrect_order` function in the `back_of_house` module calls the `deliver_order` function defined in the parent module (in this case, the crate root) using the `super::deliver_order()` syntax.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_9\n\nLANGUAGE: Rust\nCODE:\n```\nfn deliver_order() {}\n\nmod back_of_house {\n    fn fix_incorrect_order() {\n        cook_order();\n        super::deliver_order();\n    }\n\n    fn cook_order() {}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a `Config::new` Constructor in Rust\nDESCRIPTION: This code snippet demonstrates how to change a plain `parse_config` function into a function named `new` that is associated with the `Config` struct.  This allows for creating instances of `Config` by calling `Config::new`. The code updates the `main` function and moves the `parse_config` function within an `impl` block.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-03-improving-error-handling-and-modularity.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::env;\nuse std::fs;\nuse std::process;\n\nstruct Config {\n    query: String,\n    file_path: String,\n}\n\nimpl Config {\n    fn new(args: &[String]) -> Config {\n        if args.len() < 3 {\n            panic!(\"not enough arguments\");\n        }\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Config {\n            query,\n            file_path,\n        }\n    }\n}\n\nfn run(config: Config) {\n    let contents = fs::read_to_string(config.file_path)\n        .expect(\"Could not read file\");\n\n    println!(\"With contents:\\n{contents}\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::new(&args);\n\n    run(config);\n}\n```\n\n----------------------------------------\n\nTITLE: Responding with 404 Error in Rust\nDESCRIPTION: This Rust code snippet extends the previous example to handle requests that are not for the root path ('/'). It responds with a 404 status code and the content of the '404.html' file. Requires the `std::net` and `std::io` modules and a file named 404.html. Builds on the previous snippet.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-01-single-threaded.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse std::io::prelude::*;\nuse std::net::*;\n\nfn handle_connection(mut stream: TcpStream) {\n    let mut buffer = [0; 1024];\n    stream.read(&mut buffer).unwrap();\n\n    let get = b\"GET / HTTP/1.1\\r\\n\";\n\n    if buffer.starts_with(get) {\n        let contents = std::fs::read_to_string(\"hello.html\").unwrap();\n\n        let response = format!(\n            \"HTTP/1.1 200 OK\\r\\nContent-Length: {}\\r\\n\\r\\n{}\",\n            contents.len(),\n            contents\n        );\n\n        stream.write(response.as_bytes()).unwrap();\n        stream.flush().unwrap();\n    } else {\n        let status_line = \"HTTP/1.1 404 NOT FOUND\\r\\n\";\n        let contents = std::fs::read_to_string(\"404.html\").unwrap();\n\n        let response = format!(\n            \"{}\\r\\nContent-Length: {}\\r\\n\\r\\n{}\",\n            status_line,\n            contents.len(),\n            contents\n        );\n\n        stream.write(response.as_bytes()).unwrap();\n        stream.flush().unwrap();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dangling Reference Example\nDESCRIPTION: This code attempts to create a dangling reference by assigning a reference to a variable that goes out of scope before the reference is used. It demonstrates a common error that Rust's borrow checker prevents.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_34\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let r;\n\n    {\n        let x = 5;\n        r = &x;\n    }\n\n    println!(\"r: {r}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Concatenating Strings with format! Macro\nDESCRIPTION: This snippet demonstrates how to combine multiple strings using the `format!` macro. The `format!` macro is similar to `println!` but returns a `String` instead of printing to the console.  It's generally easier to read than using the `+` operator for multiple strings and it takes references to the parameters so it doesn't take ownership.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nlet s1 = String::from(\"tic\");\nlet s2 = String::from(\"tac\");\nlet s3 = String::from(\"toe\");\n\nlet s = format!(\"{s1}-{s2}-{s3}\");\n```\n\n----------------------------------------\n\nTITLE: Using `timeout` with a slow future in Rust\nDESCRIPTION: This code snippet demonstrates how the imagined `timeout` function would be used to run a slow operation with a specified time limit. It showcases the basic usage of the function before its actual implementation.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-03-more-futures.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n// The code was not provided in a parsable format. Therefore, a placeholder is provided.\n// This listing would demonstrate the usage of a `timeout` function with a slow future.\nfn main() {\n    println!(\"Code demonstrating usage of a `timeout` function.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Ignoring Unused Variable with Underscore Prefix Rust\nDESCRIPTION: This code shows how to avoid unused variable warnings by prefixing a variable name with an underscore. The variable `_x` is declared but not used, and Rust will not issue a warning about it. However, the variable `y` is also declared but not used, and Rust will issue a warning for `y`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_26\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let _x = 5;\n    let y = 10;\n}\n```\n\n----------------------------------------\n\nTITLE: Supertraits: Defining a Trait with Trait Bounds\nDESCRIPTION: This code defines a trait `OutlinePrint` that requires implementing types to also implement the `Display` trait. This is achieved by specifying `OutlinePrint: Display` in the trait definition. This allows `OutlinePrint` to use methods provided by `Display`, such as `to_string()`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-02-advanced-traits.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt::Display;\n\ntrait OutlinePrint: Display {\n    fn outline_print(&self) {\n        let output = self.to_string();\n        let len = output.len();\n        println!(\"{}\", \"*\".repeat(len + 4));\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"* {} *\", output);\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"{}\", \"*\".repeat(len + 4));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Closure\nDESCRIPTION: This code snippet demonstrates defining a closure in Rust. Closures are anonymous functions that can capture their environment.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_64\n\nLANGUAGE: Rust\nCODE:\n```\n&vert;...&vert; expr\n```\n\n----------------------------------------\n\nTITLE: Message Enum with Different Data Types in Rust\nDESCRIPTION: This code defines an enum called `Message` with different variants storing different types of data. `Quit` has no data, `Move` has named fields, `Write` has a `String`, and `ChangeColor` has three `i32` values. This illustrates complex enum usage.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-01-defining-an-enum.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n```\n\n----------------------------------------\n\nTITLE: Appending to a String with push_str\nDESCRIPTION: This snippet demonstrates how to append a string slice to a `String` using the `push_str` method. The `push_str` method takes a string slice as input and appends it to the end of the `String` without taking ownership of the slice.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nlet mut s = String::from(\"foo\");\ns.push_str(\"bar\");\n```\n\n----------------------------------------\n\nTITLE: Accessing Tuple Elements by Index\nDESCRIPTION: This snippet shows how to access tuple elements directly using their index, starting from 0. A period (`.`) is used followed by the index number.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-02-data-types.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet x: (i32, f64, u8) = (500, 6.4, 1);\n\nlet five_hundred = x.0;\n\nlet six_point_four = x.1;\n\nlet one = x.2;\n\n```\n\n----------------------------------------\n\nTITLE: Using an Iterator in a `for` Loop in Rust\nDESCRIPTION: This snippet shows how to use an iterator within a `for` loop.  The iterator is automatically consumed by the loop, and each element of the iterator is used in one iteration of the loop, effectively printing each value in the vector.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-02-iterators.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet v1 = vec![1, 2, 3];\n\nlet v1_iter = v1.iter();\n\nfor val in v1_iter {\n    println!(\"Got: {}\", val);\n}\n```\n\n----------------------------------------\n\nTITLE: Array Type in Rust\nDESCRIPTION: This represents an array type containing `len` instances of `type` in Rust.  It declares the type of an array with a fixed size.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_113\n\nLANGUAGE: Rust\nCODE:\n```\n[type; len]\n```\n\n----------------------------------------\n\nTITLE: Building with Cargo: dev and release profiles\nDESCRIPTION: This command shows how to build a Rust project using the `dev` and `release` profiles. The `cargo build` command uses the `dev` profile, which is optimized for development. The `cargo build --release` command uses the `release` profile, which is optimized for release builds.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-01-release-profiles.md#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ cargo build\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s\n$ cargo build --release\n    Finished `release` profile [optimized] target(s) in 0.32s\n```\n\n----------------------------------------\n\nTITLE: Running the program with output redirection after using `eprintIn!`\nDESCRIPTION: This command runs the compiled Rust program, redirecting standard output to `output.txt`.  Since the program now uses `eprintln!` for error messages, errors will be displayed on the console even when standard output is redirected.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-06-writing-to-stderr-instead-of-stdout.md#_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ cargo run > output.txt\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Mutable References to Modify Elements in a Vector in Rust\nDESCRIPTION: This snippet demonstrates how to iterate over mutable references to the elements of a vector, allowing modification of each element. The `&mut` before `i` in the loop creates a mutable reference. The `*` dereference operator is required to modify the underlying value.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-01-vectors.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut v = vec![100, 32, 57];\n    for i in &mut v {\n        *i += 50;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Rust Program with Cargo\nDESCRIPTION: This snippet demonstrates how to compile and run a Rust program using the `cargo run` command. It shows the output of the compilation process and the subsequent execution of the compiled binary. The program checks for divisibility by 3.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch03-common-programming-concepts/no-listing-30-else-if/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n   Compiling branches v0.1.0 (file:///projects/branches)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s\n     Running `target/debug/branches`\nnumber is divisible by 3\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Variable Shadowing in Rust\nDESCRIPTION: This code shows variable shadowing in Rust, where a new variable is declared with the same name as a previous variable. The second variable overshadows the first, taking any uses of the variable name to itself. The first variable is shadowed by the second until either it itself is shadowed or the scope ends.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-01-variables-and-mutability.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = 5;\n\n    let x = x + 1;\n\n    {\n        let x = x * 2;\n        println!(\"The value of x in the inner scope is: {x}\");\n    }\n\n    println!(\"The value of x is: {x}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Type Alias for Kilometers in Rust\nDESCRIPTION: This snippet demonstrates how to create a type alias named `Kilometers` for the `i32` type using the `type` keyword. This allows `Kilometers` to be used interchangeably with `i32` for better readability and maintainability. However, it doesn't provide type-checking benefits like newtypes.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-03-advanced-types.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntype Kilometers = i32;\n```\n\n----------------------------------------\n\nTITLE: Dangling Reference Attempt in Rust\nDESCRIPTION: This code attempts to create a dangling reference by assigning a reference to a variable that goes out of scope before the reference is used. It demonstrates a common error that Rust's borrow checker prevents.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-03-lifetime-syntax.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-16/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Screen Struct with Generics and Trait Bounds in Rust\nDESCRIPTION: This code shows an alternative implementation of the `Screen` struct using generics and trait bounds. This restricts the `Screen` instance to hold components of only one concrete type that implements the `Draw` trait, enabling compile-time monomorphization.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter18.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\npub struct Screen<T: Draw> {\n    pub components: Vec<T>,\n}\n\nimpl<T> Screen<T>\nwhere\n    T: Draw,\n{\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error Example\nDESCRIPTION: This code snippet demonstrates a Rust compilation error when using `impl Trait` as a return type. The error E0308 occurs because distinct uses of `impl Trait` result in different opaque types, preventing the creation of a homogenous vector of closures with different definitions. The `returns_closure` and `returns_initialized_closure` functions both return types that implement the `Fn(i32) -> i32` trait, but they are considered different types due to the use of `impl Trait`.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch20-advanced-features/listing-20-33/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo build\n   Compiling functions-example v0.1.0 (file:///projects/functions-example)\nerror[E0308]: mismatched types\n  --> src/main.rs:2:44\n   |\n2  |     let handlers = vec![returns_closure(), returns_initialized_closure(123)];\n   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected opaque type, found a different opaque type\n...\n9  | fn returns_closure() -> impl Fn(i32) -> i32 {\n   |                         ------------------- the expected opaque type\n...\n13 | fn returns_initialized_closure(init: i32) -> impl Fn(i32) -> i32 {\n   |                                              ------------------- the found opaque type\n   |\n   = note: expected opaque type `impl Fn(i32) -> i32` (opaque type at <src/main.rs:9:25>)\n              found opaque type `impl Fn(i32) -> i32` (opaque type at <src/main.rs:13:46>)\n   = note: distinct uses of `impl Trait` result in different opaque types\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `functions-example` (bin \"functions-example\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Creating a Cargo Workspace\nDESCRIPTION: This TOML code defines the `Cargo.toml` file for a Cargo workspace. It includes the `[workspace]` section, which lists the member packages in the workspace. The `resolver` key specifies the version of Cargo's resolver algorithm to use.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-03-cargo-workspaces.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[workspace]\nmembers = [\n    \"adder\",\n    \"add_one\",\n]\nresolver = \"3\"\n```\n\n----------------------------------------\n\nTITLE: Function with Multiple Input Lifetimes in Rust\nDESCRIPTION: Shows the `longest` function with explicit lifetime parameters, illustrating a scenario where the compiler cannot infer the output lifetime due to multiple input lifetimes. This requires the programmer to explicitly specify the relationship between the lifetimes.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_48\n\nLANGUAGE: rust\nCODE:\n```\nfn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {\n```\n\n----------------------------------------\n\nTITLE: Search Function Definition - Rust\nDESCRIPTION: This code defines the `search` function, which takes a query string and content to search within.  It is defined with the minimum implementation needed to compile, returning an empty vector. The function signature includes explicit lifetime annotations to ensure the returned string slices reference the `contents` argument.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\npub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    vec![]\n}\n```\n\n----------------------------------------\n\nTITLE: Specific Integration Test Execution - Bash\nDESCRIPTION: This bash command executes only the tests within the specified integration test file (integration_test.rs). It utilizes the `--test` flag, allowing for targeted testing of specific integration tests.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo test --test integration_test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.64s\n     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)\n\nrunning 1 test\ntest it_adds_two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Corrected Drop Implementation for ThreadPool in Rust\nDESCRIPTION: This code snippet presents the corrected implementation of the `Drop` trait for a `ThreadPool` in Rust, resolving the ownership issue encountered in the initial attempt. By using `self.workers.drain(..)`, the code moves each `Worker` out of the `Vec`, allowing the `join` method to consume the thread without borrowing issues.  This approach ensures proper thread cleanup during `ThreadPool` destruction.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_27\n\nLANGUAGE: rust\nCODE:\n```\nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        for worker in self.workers.drain(..) {\n            println!(\"Shutting down worker {}\", worker.id);\n\n            worker.thread.join().unwrap();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Ownership and Functions in Rust\nDESCRIPTION: This code illustrates how ownership is transferred when passing a `String` to a function. When `takes_ownership` is called with `s`, the ownership of the `String` is moved to the function, and `s` is no longer valid in the `main` function.  Integers, which implement the `Copy` trait, are copied, so `x` remains valid after being passed to `makes_copy`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_10\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    let s = String::from(\"hello\");  // s comes into scope\n\n    takes_ownership(s);             // s's value moves into the function...\n                                    // ... and so is no longer valid here\n\n    let x = 5;                      // x comes into scope\n\n    makes_copy(x);                  // because i32 implements the Copy trait,\n                                    // x does NOT move into the function,\n    println!(\"{}\", x);              // so it's okay to use x afterward\n\n} // Here, x goes out of scope, then s. But because s's value was moved, nothing\n  // special happens.\n\nfn takes_ownership(some_string: String) { // some_string comes into scope\n    println!(\"{some_string}\");\n} // Here, some_string goes out of scope and `drop` is called. The backing\n  // memory is freed.\n\nfn makes_copy(some_integer: i32) { // some_integer comes into scope\n    println!(\"{some_integer}\");\n} // Here, some_integer goes out of scope. Nothing special happens.\n```\n\n----------------------------------------\n\nTITLE: Array Literal in Rust\nDESCRIPTION: This represents an array literal in Rust, which is used to create an array with specific values. The values are enclosed in square brackets.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_111\n\nLANGUAGE: Rust\nCODE:\n```\n[...]\n```\n\n----------------------------------------\n\nTITLE: Building Cargo Workspace\nDESCRIPTION: This snippet shows the command to build the entire Cargo workspace. This command compiles all crates within the workspace, including the `add_one` and `adder` crates. It also downloads and compiles any dependencies, such as the `rand` crate.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-03-cargo-workspaces.md#_snippet_11\n\nLANGUAGE: console\nCODE:\n```\n$ cargo build\n    Updating crates.io index\n  Downloaded rand v0.8.5\n   --snip--\n   Compiling rand v0.8.5\n   Compiling add_one v0.1.0 (file:///projects/add/add_one)\nwarnings: unused import: `rand`\n --> add_one/src/lib.rs:1:5\n  |\n1 | use rand;\n  |     ^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarnings: `add_one` (lib) generated 1 warning (run `cargo fix --lib -p add_one` to apply 1 suggestion)\n   Compiling adder v0.1.0 (file:///projects/add/adder)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.95s\n```\n\n----------------------------------------\n\nTITLE: Initializing an Array\nDESCRIPTION: This code snippet demonstrates how to create an array in Rust with a fixed size and elements of the same type. The array is declared using square brackets with comma-separated values.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-02-data-types.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nlet a = [1, 2, 3, 4, 5];\n\n```\n\n----------------------------------------\n\nTITLE: Running a Cargo Project\nDESCRIPTION: This snippet shows the output of the `cargo run` command, which compiles and executes a Rust project. The output indicates the compilation status, including the package name, version, file path, and compilation profile. It also shows the program's output to standard output.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch13-functional-features/listing-13-05/output.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n$ cargo run\n Compiling closure-example v0.1.0 (file:///projects/closure-example)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s\n   Running `target/debug/closure-example`\nBefore defining closure: [1, 2, 3]\nAfter calling closure: [1, 2, 3, 7]\n```\n\n----------------------------------------\n\nTITLE: Collection Indexing in Rust\nDESCRIPTION: This represents collection indexing in Rust. The `Index` and `IndexMut` traits can be overloaded to customize indexing behavior for custom types.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_114\n\nLANGUAGE: Rust\nCODE:\n```\nexpr[expr]\n```\n\n----------------------------------------\n\nTITLE: Function with Parameters in Rust\nDESCRIPTION: This snippet demonstrates a function that accepts a single parameter of type `i32`. It showcases how to define parameters in a function signature, including specifying the parameter name and its type. The `println!` macro is used to display the value of the parameter within the function body.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-03-how-functions-work.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    another_function(5);\n}\n\nfn another_function(x: i32) {\n    println!(\"The value of x is: {}\", x);\n}\n```\n\n----------------------------------------\n\nTITLE: Example Test Functions with println!\nDESCRIPTION: This code defines a function `prints_and_returns_10` that prints its input and returns 10. It also includes two test functions: one that asserts the function returns 10 with input 4 (which passes) and another that asserts it returns 5 with input 8 (which fails).\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-02-running-tests.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn this_test_passes() {\n        let value = prints_and_returns_10(4);\n        assert_eq!(10, value);\n    }\n\n    #[test]\n    fn this_test_fails() {\n        let value = prints_and_returns_10(8);\n        assert_eq!(5, value);\n    }\n\n    fn prints_and_returns_10(a: i32) -> i32 {\n        println!(\"I got the value {}\", a);\n        10\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Finding the Largest Number in a List - Rust\nDESCRIPTION: This Rust code snippet demonstrates finding the largest number within a vector of i32 integers. It iterates through the vector, comparing each element to the current largest value and updating the largest value if a larger element is found. It showcases a simple approach to finding the maximum value in a list.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let mut largest = &number_list[0];\n\n    for number in &number_list {\n        if number > largest {\n            largest = number;\n        }\n    }\n\n    println!(\"The largest number is {largest}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Binary Crate in a Workspace\nDESCRIPTION: This console command runs the `adder` binary crate within the Cargo workspace. The `-p` argument specifies the package to run.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-03-cargo-workspaces.md#_snippet_9\n\nLANGUAGE: console\nCODE:\n```\n$ cargo run -p adder\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s\n     Running `target/debug/adder`\nHello, world! 10 plus one is 11!\n```\n\n----------------------------------------\n\nTITLE: Defining a function with a string slice parameter in Rust\nDESCRIPTION: This code defines a function named `hello` that accepts a string slice (`&str`) as its parameter `name`. This function is used to demonstrate deref coercion, where a `MyBox<String>` can be passed as an argument due to automatic conversion.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-02-deref.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn hello(name: &str) {\n    println!(\"Hello, {name}!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Attempting to use a refutable pattern with `let` in Rust\nDESCRIPTION: This code attempts to use a refutable pattern `Some(x)` with a `let` statement, which requires an irrefutable pattern. This results in a compile-time error because the `let` statement cannot handle the case where `some_option_value` is `None`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-02-refutability.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet some_option_value: Option<i32> = None;\nlet Some(x) = some_option_value;\n```\n\n----------------------------------------\n\nTITLE: Mutability Error When Changing Type in Rust\nDESCRIPTION: This code snippet illustrates the error that occurs when attempting to change the type of a mutable variable.  The variable `spaces` is declared as mutable and initialized as a string. The attempt to reassign it to an integer of the string's length causes a compile-time error because `mut` variables cannot change type.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet mut spaces = \"   \";\nspaces = spaces.len();\n```\n\n----------------------------------------\n\nTITLE: Defining Trait Bound\nDESCRIPTION: This code defines a function `notify` that takes a generic type `T` which must implement the `Summary` trait. It then calls the `summarize` method on the input `item`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_22\n\nLANGUAGE: Rust\nCODE:\n```\npub fn notify<T: Summary>(item: &T) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Tree Node Structure in Rust\nDESCRIPTION: This code defines a `Node` struct for a tree data structure. Each `Node` holds an `i32` value and a vector of `Rc<Node>` wrapped in a `RefCell<T>` to allow modification of the children. This enables shared ownership and mutability of child nodes.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-06-reference-cycles.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Reference Cycle with Lists\nDESCRIPTION: Creates a reference cycle between two `List` instances, 'a' and 'b', using `Rc` and `RefCell`. The code demonstrates how modifying the tail of list 'a' to point to list 'b', and vice-versa, results in a memory leak because the reference counts never reach zero.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));\n\n    println!(\"a initial rc count = {}\", Rc::strong_count(&a));\n    println!(\"a next item = {:?}\", a.tail());\n\n    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));\n\n    println!(\"a rc count after b creation = {}\", Rc::strong_count(&a));\n    println!(\"b initial rc count = {}\", Rc::strong_count(&b));\n    println!(\"b next item = {:?}\", b.tail());\n\n    if let Some(link) = a.tail() {\n        *link.borrow_mut() = Rc::clone(&b);\n    }\n\n    println!(\"b rc count after changing a = {}\", Rc::strong_count(&b));\n    println!(\"a rc count after changing a = {}\", Rc::strong_count(&a));\n\n    // Uncomment the next line to see that we have a cycle;\n    // it will overflow the stack.\n    // println!(\"a next item = {:?}\", a.tail());\n}\n```\n\n----------------------------------------\n\nTITLE: Calling functions using absolute and relative paths in Rust\nDESCRIPTION: This code demonstrates how to call the `add_to_waitlist` function using both absolute and relative paths from the `eat_at_restaurant` function. It showcases the use of `crate` for absolute paths and module names for relative paths. The `pub` keyword is used to make the `eat_at_restaurant` function part of the library crate's public API.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nmod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Absolute path\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // Relative path\n    front_of_house::hosting::add_to_waitlist();\n}\n```\n\n----------------------------------------\n\nTITLE: Attempting to Create a `str` Variable in Rust\nDESCRIPTION: This code snippet demonstrates an attempt to create variables of type `str`, which is a dynamically sized type. It highlights why directly creating `str` variables is not allowed in Rust because the compiler needs to know the size of variables at compile time, and `str`'s size is only known at runtime. The code will fail to compile.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-03-advanced-types.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-11-cant-create-str/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Function with Multiple Trait Bounds using Generic Type\nDESCRIPTION: This code defines a function `notify` that takes two arguments `item1` and `item2` which are references to the same type `T`. `T` is constrained by the `Summary` trait, meaning `item1` and `item2` must be of the same type and implement the `Summary` trait.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_24\n\nLANGUAGE: Rust\nCODE:\n```\npub fn notify<T: Summary>(item1: &T, item2: &T) {\n```\n\n----------------------------------------\n\nTITLE: Running Cargo Project\nDESCRIPTION: This snippet shows the command used to run a Rust project using Cargo. The 'cargo run' command compiles the project and then executes the resulting binary.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch03-common-programming-concepts/no-listing-18-functions-with-multiple-parameters/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling functions v0.1.0 (file:///projects/functions)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s\n   Running `target/debug/functions`\nThe measurement is: 5h\n```\n\n----------------------------------------\n\nTITLE: Attempting a MockMessenger Implementation (Fails)\nDESCRIPTION: This code attempts to implement a `MockMessenger` struct to track sent messages during testing.  The attempt fails because the `send` method requires a mutable reference to modify the `sent_messages` vector, but the `Messenger` trait requires an immutable reference.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-05-interior-mutability.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    struct MockMessenger {\n        sent_messages: Vec<String>,\n    }\n\n    impl MockMessenger {\n        fn new() -> MockMessenger {\n            MockMessenger {\n                sent_messages: vec![],\n            }\n        }\n    }\n\n    impl Messenger for MockMessenger {\n        fn send(&self, message: &str) {\n            self.sent_messages.push(String::from(message));\n        }\n    }\n\n    #[test]\n    fn it_sends_an_over_75_percent_warning_message() {\n        let mock_messenger = MockMessenger::new();\n        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);\n\n        limit_tracker.set_value(80);\n\n        assert_eq!(mock_messenger.sent_messages.len(), 1);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Closure with Type Annotations in Rust\nDESCRIPTION: This code snippet defines a closure named `expensive_closure` that takes a `u32` as input and returns a `u32`. It includes a print statement and a sleep duration to simulate a time-consuming calculation. The type annotations `u32` are optional but provide explicitness.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet expensive_closure = |num: u32| -> u32 {\n    println!(\"calculating slowly...\");\n    thread::sleep(Duration::from_secs(2));\n    num\n};\n```\n\n----------------------------------------\n\nTITLE: Disambiguating Method Calls by Type\nDESCRIPTION: This code snippet shows how to disambiguate a method call by naming the type for which it's defined in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_74\n\nLANGUAGE: Rust\nCODE:\n```\ntype::method(...)\n```\n\n----------------------------------------\n\nTITLE: Matching Multiple Patterns with OR in Rust\nDESCRIPTION: This example shows how to match multiple patterns using the `|` (OR) operator in a `match` expression. If `x` matches either 1 or 2, the first arm is executed. This allows handling multiple values with the same code.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 1;\n\nmatch x {\n    1 | 2 => println!(\"one or two\"),\n    3 => println!(\"three\"),\n    _ => println!(\"anything\"),\n}\n```\n\n----------------------------------------\n\nTITLE: Using Nested Paths in `use` Statements in Rust\nDESCRIPTION: This code snippet shows how to use nested paths to import multiple items from the same crate or module in a single `use` statement, reducing the number of lines required.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{cmp::Ordering, io};\n```\n\n----------------------------------------\n\nTITLE: Updating a Vector using the `push` Method\nDESCRIPTION: This code snippet demonstrates how to add elements to an existing vector using the `push` method.  The vector `v` is declared as mutable using `mut` to allow modifications. The `push` method appends the specified values to the end of the vector. Rust infers the vector element type from the pushed values, so explicit type annotation isn't needed.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet mut v = Vec::new();\n\nv.push(5);\nv.push(6);\nv.push(7);\nv.push(8);\n```\n\n----------------------------------------\n\nTITLE: Disambiguating Method Calls by Trait\nDESCRIPTION: This code snippet demonstrates how to disambiguate a method call by naming the trait that defines it in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_73\n\nLANGUAGE: Rust\nCODE:\n```\ntrait::method(...)\n```\n\n----------------------------------------\n\nTITLE: Dangling Reference Example: Unrelated Lifetime in Rust\nDESCRIPTION: This snippet demonstrates an attempt to return a reference to a value created within the `longest` function.  Because the returned reference `result` does not refer to one of the input parameters, the compiler flags this code as invalid, as it would result in a dangling reference. The lifetime of `result` is not related to the parameters.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-03-lifetime-syntax.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nfn longest<'a>(x: &str, y: &str) -> &'a str {\n    let result = String::from(\"really long string\");\n    result.as_str()\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo Run Command in Rust\nDESCRIPTION: This snippet illustrates the use of the `cargo run` command in Rust to compile and execute a project. It displays the compilation process, including the project name and target, and then shows the output of the running executable.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch03-common-programming-concepts/no-listing-02-adding-mut/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling variables v0.1.0 (file:///projects/variables)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s\n   Running `target/debug/variables`\nThe value of x is: 5\nThe value of x is: 6\n```\n\n----------------------------------------\n\nTITLE: Finding Largest Number in Two Lists\nDESCRIPTION: This snippet illustrates duplicated code for finding the largest number in two separate lists. While functional, it highlights the need for abstraction through functions to avoid redundancy.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-00-generics.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let mut largest = number_list[0];\n\n    for number in number_list {\n        if number > largest {\n            largest = number\n        }\n    }\n\n    println!(\"The largest number is {}\", largest);\n\n    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];\n\n    let mut largest = number_list[0];\n\n    for number in number_list {\n        if number > largest {\n            largest = number\n        }\n    }\n\n    println!(\"The largest number is {}\", largest);\n}\n```\n\n----------------------------------------\n\nTITLE: Reassigning String and Memory Management in Rust\nDESCRIPTION: This code demonstrates how reassigning a `String` variable in Rust leads to the original value being dropped and its memory freed immediately. It showcases Rust's memory management mechanism by automatically deallocating the old string when a new value is assigned.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\nlet mut s = String::from(\"hello\");\ns = String::from(\"ahoy\");\n\nprintln!(\"{s}, world!\");\n```\n\n----------------------------------------\n\nTITLE: Rust Short-Circuiting Logical OR Operator Example\nDESCRIPTION: Demonstrates the short-circuiting logical OR operator (`||`) in Rust. It evaluates the left-hand side and only evaluates the right-hand side if the left-hand side is false.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_54\n\nLANGUAGE: Rust\nCODE:\n```\nexpr || expr\n```\n\n----------------------------------------\n\nTITLE: Setting Optimization Level in Cargo.toml for release profile\nDESCRIPTION: This code snippet shows how to set the optimization level (`opt-level`) for the `release` profile in the `Cargo.toml` file.  The `opt-level` setting controls the number of optimizations the Rust compiler applies. Here, it sets the optimization level to 3 for the `release` profile.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-01-release-profiles.md#_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[profile.release]\nopt-level = 3\n```\n\n----------------------------------------\n\nTITLE: Numeric Operations in Rust\nDESCRIPTION: This code snippet illustrates basic mathematical operations in Rust. It covers addition, subtraction, multiplication, division, and remainder operations using the `let` statement to bind the results to variables.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-02-data-types.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// addition\nlet sum = 5 + 10;\n\n// subtraction\nlet difference = 95.5 - 4.3;\n\n// multiplication\nlet product = 4 * 30;\n\n// division\nlet quotient = 56.7 / 32.2;\nlet truncated = -5 / 3; // Results in -1\n\n// remainder\nlet remainder = 43 % 5;\n```\n\n----------------------------------------\n\nTITLE: Using Art Crate with Internal Structure in Rust\nDESCRIPTION: This code demonstrates how to use the `art` crate items (`PrimaryColor` and `mix`) by specifying the full module path. It highlights the inconvenience of navigating the internal module structure for the crate user.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-02-publishing-to-crates-io.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(unused)]\nfn main() {\n    use art::kinds::PrimaryColor;\n    use art::utils::mix;\n\n    fn main() {\n        let red = PrimaryColor::Red;\n        let yellow = PrimaryColor::Yellow;\n        mix(red, yellow);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Attempting to Modify a Borrowed String in Rust\nDESCRIPTION: This Rust code attempts to modify a borrowed string using the `push_str` method. However, it results in a compile-time error because references are immutable by default. The `change` function tries to append \", world\" to the borrowed string, which is not allowed.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let s = String::from(\"hello\");\n\n    change(&s);\n}\n\nfn change(some_string: &String) {\n    some_string.push_str(\", world\");\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Binary Crate in Workspace\nDESCRIPTION: Creates a new binary crate named 'adder' within the workspace. The `cargo new adder` command automatically adds this package to the workspace's `members` list in the Cargo.toml file.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_14\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo new adder\n    Creating binary (application) `adder` package\n      Adding `adder` as member of workspace at `file:///projects/add`\n```\n\n----------------------------------------\n\nTITLE: Addition and Assignment Operator Rust\nDESCRIPTION: This operator performs arithmetic addition and assigns the result to the variable. It's a shorthand for `var = var + expr`. The `AddAssign` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_16\n\nLANGUAGE: Rust\nCODE:\n```\n`var += expr`\n```\n\n----------------------------------------\n\nTITLE: Creating Raw Pointer to Arbitrary Memory\nDESCRIPTION: Shows how to create a raw pointer to an arbitrary memory address using `as`. Accessing arbitrary memory is generally undefined and can lead to various issues including segmentation faults.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-01-unsafe-rust.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet address = 0x012345usize;\nlet r = address as *mut i32;\n\n```\n\n----------------------------------------\n\nTITLE: Attempting to Print a Struct Without Debug Trait in Rust\nDESCRIPTION: This snippet attempts to print a `Rectangle` struct using the default `println!` macro formatting. Because the `Rectangle` struct doesn't implement the `Display` trait, this code will result in a compilation error.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_13\n\nLANGUAGE: Rust\nCODE:\n```\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\"rect1 is {}\", rect1);\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Async Await Example in Rust\nDESCRIPTION: This snippet shows the basic syntax for using async and await in Rust. It demonstrates how to asynchronously fetch data from a URL and then print the data to the console. The ignore and does_not_compile directives indicate that this code is for illustrative purposes and may require additional context or dependencies to compile and run.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-00-async-await.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet data = fetch_data_from(url).await;\nprintln!(\"{data}\");\n```\n\n----------------------------------------\n\nTITLE: Using Macro Capture\nDESCRIPTION: This code snippet demonstrates the use of macro capture in Rust. It captures an identifier of a specified kind.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_93\n\nLANGUAGE: Rust\nCODE:\n```\n$ident:kind\n```\n\n----------------------------------------\n\nTITLE: Store and Join Futures with join_all in Rust\nDESCRIPTION: This snippet attempts to store async futures in a `Vec` and join them using `trpl::join_all`. It illustrates the type challenges encountered when working with collections of anonymous futures in Rust due to different async block types. The corrected version uses trait objects and boxing.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nlet futures = vec![tx1_fut, rx_fut, tx_fut];\n\n        trpl::join_all(futures).await;\n```\n\n----------------------------------------\n\nTITLE: Defining the Either Enum in Rust\nDESCRIPTION: This code snippet defines a generic `Either` enum with two variants: `Left` and `Right`. It's used to represent a value that can be one of two types, without implying success or failure like `Result`. The `Left` and `Right` variants hold values of types `A` and `B` respectively.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-01-futures-and-syntax.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nenum Either<A, B> {\n    Left(A),\n    Right(B),\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Poll Enum in Rust\nDESCRIPTION: This code snippet defines the `Poll` enum in Rust, showcasing the `Ready` variant that holds a value of type `T`, and the `Pending` variant that signifies the future is not yet complete.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_46\n\nLANGUAGE: rust\nCODE:\n```\nenum Poll<T> {\n    Ready(T),\n    Pending,\n}\n```\n\n----------------------------------------\n\nTITLE: Modified `longest` function with single lifetime parameter\nDESCRIPTION: This version of the `longest` function demonstrates that it's not always necessary to annotate all input lifetimes. Since the function always returns the first argument (`x`), only `x`'s lifetime needs to be annotated and connected to the return value's lifetime. The lifetime of `y` is irrelevant because it's not related to the returned reference.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_43\n\nLANGUAGE: rust\nCODE:\n```\nfn longest<'a>(x: &'a str, y: &str) -> &'a str {\n    x\n}\n```\n\n----------------------------------------\n\nTITLE: Array Element Access Rust\nDESCRIPTION: Shows how to access elements of an array using indexing. The example demonstrates accessing the first and second elements of the array.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let a = [1, 2, 3, 4, 5];\n\n    let first = a[0];\n    let second = a[1];\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Parameters to Generic Type, Function, or Method\nDESCRIPTION: This code snippet illustrates how to specify parameters to a generic type, function, or method in an expression, often referred to as turbofish (e.g., `\"42\".parse::<i32>()`).\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_77\n\nLANGUAGE: Rust\nCODE:\n```\npath::<...>\n```\n\nLANGUAGE: Rust\nCODE:\n```\nmethod::<...>\n```\n\n----------------------------------------\n\nTITLE: Function Returning a Value in Rust\nDESCRIPTION: This example defines a function `five` that returns the integer value `5`. The return type `i32` is declared after the arrow `->`. This demonstrates how the last expression in a function's body is implicitly returned.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nfn five() -> i32 {\n    5\n}\n\nfn main() {\n    let x = five();\n\n    println!(\"The value of x is: {x}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating String Length with Reference Annotations in Rust\nDESCRIPTION: This Rust code snippet illustrates calculating the length of a string using references with explicit annotations. The `calculate_length` function takes a reference (`&String`) to a string, avoiding ownership transfer, and returns its length. The annotations clarify that the function borrows the string and doesn't drop it after use.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nfn calculate_length(s: &String) -> usize { // s is a reference to a String\n    s.len()\n} // Here, s goes out of scope. But because s does not have ownership of what\n  // it refers to, the value is not dropped.\n```\n\n----------------------------------------\n\nTITLE: Calling Methods with Same Name on a Struct\nDESCRIPTION: This code demonstrates the default behavior when calling a method with a name that exists in both a trait implementation and directly on the struct. Rust defaults to the implementation on the struct itself. This snippet requires the `Pilot`, `Wizard`, and `Human` definitions from the previous example.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-02-advanced-traits.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let person = Human;\n    person.fly();\n}\n```\n\n----------------------------------------\n\nTITLE: Tuple Element Access Rust\nDESCRIPTION: Shows how to access individual elements of a tuple using their index. The example demonstrates accessing elements at indices 0, 1, and 2.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x: (i32, f64, u8) = (500, 6.4, 1);\n\n    let five_hundred = x.0;\n\n    let six_point_four = x.1;\n\n    let one = x.2;\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Recursive List Enum in Rust (Fails)\nDESCRIPTION: This code attempts to use the `List` enum to store a list of `1, 2, 3`. It creates nested `Cons` values, each holding a value and another `List`, ending with `Nil`. This example showcases the intended usage of the recursive type, but it won't compile due to the infinite size problem.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-01-box.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nenum List {\n    Cons(i32, List),\n    Nil,\n}\n\nuse List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1, Cons(2, Cons(3, Nil)));\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream with a Counter in Rust\nDESCRIPTION: This snippet defines a function `get_intervals` that creates an asynchronous stream emitting a counter every millisecond. It uses a channel to send the counter value from an async task to a `ReceiverStream`. The `count` variable is incremented in an infinite loop, with `trpl::sleep` introducing a delay.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_40\n\nLANGUAGE: Rust\nCODE:\n```\nfn get_intervals() -> impl Stream<Item = u32> {\n    let (tx, rx) = trpl::channel();\n\n    trpl::spawn_task(async move {\n        let mut count = 0;\n        loop {\n            trpl::sleep(Duration::from_millis(1)).await;\n            count += 1;\n            tx.send(count).unwrap();\n        }\n    });\n\n    ReceiverStream::new(rx)\n}\n```\n\n----------------------------------------\n\nTITLE: If Let with Option<u8> Rust\nDESCRIPTION: This code shows how to use `if let` to handle the `Some` variant of an `Option<u8>`. It provides a more concise way to execute code only when a specific pattern matches, avoiding the boilerplate needed in a full `match` expression.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_24\n\nLANGUAGE: Rust\nCODE:\n```\nlet config_max = Some(3u8);\n    if let Some(max) = config_max {\n        println!(\"The maximum is configured to be {max}\");\n    }\n```\n\n----------------------------------------\n\nTITLE: Main Function with env::args Iterator\nDESCRIPTION: This code snippet demonstrates how to modify the main function to pass the iterator returned by `env::args` directly to `Config::build`, rather than collecting into a vector first. This is the first step in leveraging iterators for improved efficiency.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-03-improving-our-io-project.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::env;\nuse std::process;\n\nuse minigrep::Config;\n\nfn main() {\n    let config = Config::build(env::args()).unwrap_or_else(|err| {\n        eprintln!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    if let Err(e) = minigrep::run(config) {\n        eprintln!(\"Application error: {e}\");\n        process::exit(1);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Can Hold Method to Check Rectangle Containment in Rust\nDESCRIPTION: This snippet demonstrates how to use the `can_hold` method defined on the `Rectangle` struct. It creates three Rectangle instances and calls the `can_hold` method on the first rectangle (`rect1`) to check if it can hold the second (`rect2`) and third (`rect3`) rectangles. The results are printed to the console.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n    let rect2 = Rectangle {\n        width: 10,\n        height: 40,\n    };\n    let rect3 = Rectangle {\n        width: 60,\n        height: 45,\n    };\n\n    println!(\"Can rect1 hold rect2? {}\", rect1.can_hold(&rect2));\n    println!(\"Can rect1 hold rect3? {}\", rect1.can_hold(&rect3));\n}\n```\n\n----------------------------------------\n\nTITLE: Using Outer Line Doc Comment\nDESCRIPTION: This code snippet demonstrates the use of an outer line doc comment in Rust. Outer line doc comments start with `///`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_98\n\nLANGUAGE: Rust\nCODE:\n```\n///\n```\n\n----------------------------------------\n\nTITLE: Block as an Expression in Rust\nDESCRIPTION: This snippet demonstrates the use of a block as an expression in Rust. The block, enclosed in curly brackets, evaluates to a value. The value of the last expression in the block (without a semicolon) is the value of the entire block. This value is then assigned to the variable `y`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-03-how-functions-work.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let y = {\n        let x = 3;\n        x + 1\n    };\n\n    println!(\"The value of y is: {}\", y);\n}\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Subtraction Operator Rust\nDESCRIPTION: This operator performs arithmetic subtraction. It subtracts the right operand from the left operand and returns the difference. The `Sub` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_19\n\nLANGUAGE: Rust\nCODE:\n```\n`expr - expr`\n```\n\n----------------------------------------\n\nTITLE: Finding the Largest Number in Two Lists - Rust\nDESCRIPTION: This Rust code snippet extends the previous example by finding the largest number in two separate vectors of i32 integers. It duplicates the logic for finding the largest number, demonstrating the problem of code duplication that generics and functions aim to solve. This example highlights the need for abstraction to avoid redundancy and potential errors.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let mut largest = &number_list[0];\n\n    for number in &number_list {\n        if number > largest {\n            largest = number;\n        }\n    }\n\n    println!(\"The largest number is {largest}\");\n\n    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];\n\n    let mut largest = &number_list[0];\n\n    for number in &number_list {\n        if number > largest {\n            largest = number;\n        }\n    }\n\n    println!(\"The largest number is {largest}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Derive Macro Code Skeleton - Rust\nDESCRIPTION: Defines the skeleton for the procedural macro `hello_macro_derive`. It includes the `hello_macro_derive` function, which parses the `TokenStream` and calls `impl_hello_macro` to transform the syntax tree. The `proc_macro_derive` attribute indicates that this is a derive macro.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-05-macros.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-40/hello_macro/hello_macro_derive/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Type Mutation Error with `mut`\nDESCRIPTION: This code snippet demonstrates that you cannot change the type of a variable using `mut`. Using `mut` with variables only allow changing the value of the variable, but the type must remain constant. Shadowing is the way to declare a new variable with the same name and a different type.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-01-variables-and-mutability.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut spaces = \"   \";\n    spaces = spaces.len();\n}\n```\n\n----------------------------------------\n\nTITLE: Underscore Placeholder in Match Expression Rust\nDESCRIPTION: This snippet uses the underscore (`_`) placeholder as a catch-all pattern in a `match` expression.  It ignores all values other than 3 and 7, calling the `reroll` function in the default case. This avoids unused variable warnings when the value isn't needed.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_21\n\nLANGUAGE: Rust\nCODE:\n```\nlet dice_roll = 9;\n    match dice_roll {\n        3 => add_fancy_hat(),\n        7 => remove_fancy_hat(),\n        _ => reroll(),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n    fn reroll() {}\n```\n\n----------------------------------------\n\nTITLE: Defining a User Struct in Rust\nDESCRIPTION: Defines a struct named `User` with fields `active` (bool), `username` (String), `email` (String), and `sign_in_count` (u64). This struct is used to store information about a user account.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-01-defining-structs.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n```\n\n----------------------------------------\n\nTITLE: Running the automatically generated test\nDESCRIPTION: This command runs all tests in the current Rust project using `cargo test`.  It compiles the code, executes the test functions, and reports the test results.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-01-writing-tests.md#_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n{{#include ../listings/ch11-writing-automated-tests/listing-11-01/output.txt}}\n```\n\n----------------------------------------\n\nTITLE: Reading user input\nDESCRIPTION: This snippet reads a line of input from the standard input (stdin) and appends it to the `guess` string variable.  `read_line` requires a mutable reference (`&mut`) to the string where the input will be stored.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_9\n\nLANGUAGE: rust,ignore\nCODE:\n```\n{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:read}}\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution with If-Else Statement in Rust\nDESCRIPTION: This code snippet illustrates the use of an 'if-else' statement in Rust. It initializes a variable 'number' and checks if it's less than 5. If the condition is true, it prints \"condition was true\"; otherwise, it prints \"condition was false\". This demonstrates basic conditional branching in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/if.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let number = 3;\n\n    if number < 5 {\n        println!(\"condition was true\");\n    } else {\n        println!(\"condition was false\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dereferencing a Box smart pointer in Rust\nDESCRIPTION: Demonstrates using the dereference operator (*) on a `Box<i32>`. The variable 'x' holds an i32 value 5. 'y' is a `Box` pointing to a copy of 'x'. We use '*y' to dereference 'y' and compare it with 5. The `Box` smart pointer automatically dereferences to its underlying value.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-02-deref.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 5;\nlet y = Box::new(x);\n\nassert_eq!(5, x);\nassert_eq!(5, *y);\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error: Borrow of Moved Value\nDESCRIPTION: This error occurs when attempting to use a variable after it has been moved. In this case, the `String` named `val` is moved into the channel through the `tx.send()` function. Subsequently, the code attempts to print `val`, which is now owned by the channel. This results in a compilation error because Rust's borrow checker prevents accessing moved values.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch16-fearless-concurrency/listing-16-09/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nerror[E0382]: borrow of moved value: `val`\n  --> src/main.rs:10:26\n   |\n8  |         let val = String::from(\"hi\");\n   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait\n9  |         tx.send(val).unwrap();\n   |                 --- value moved here\n10 |         println!(\"val is {val}\");\n   |                          ^^^^^ value borrowed here after move\n   |\n   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n```\n\n----------------------------------------\n\nTITLE: Building the Cargo Workspace\nDESCRIPTION: This console command builds the entire Cargo workspace from the top-level directory. It compiles all member packages and places the output artifacts in the shared `target` directory.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-03-cargo-workspaces.md#_snippet_8\n\nLANGUAGE: console\nCODE:\n```\n$ cargo build\n   Compiling add_one v0.1.0 (file:///projects/add/add_one)\n   Compiling adder v0.1.0 (file:///projects/add/adder)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.22s\n```\n\n----------------------------------------\n\nTITLE: Function Signature with Separate Variables Rust\nDESCRIPTION: This code snippet shows the function signature of the `area` function, which takes two `u32` type parameters, representing width and height, and returns a `u32` representing the area.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-02-example-structs.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn area(width: u32, height: u32) -> u32\n```\n\n----------------------------------------\n\nTITLE: Defining Immutable Static Variable - Rust\nDESCRIPTION: This snippet demonstrates how to declare and use an immutable static variable in Rust. Static variables are similar to constants but have a fixed address in memory and can only store references with the `'static` lifetime. Accessing an immutable static variable is safe.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-01-unsafe-rust.md#_snippet_11\n\nLANGUAGE: Rust\nCODE:\n```\nstatic HELLO_WORLD: &str = \"Hello, world!\";\n\nfn main() {\n    println!(\"name is: {}\", HELLO_WORLD);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Raw Pointers\nDESCRIPTION: Demonstrates how to create immutable and mutable raw pointers using the raw borrow operators. Raw pointers bypass the borrow checker's guarantees and can point to invalid memory.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-01-unsafe-rust.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet mut num = 5;\n\nlet r1 = &raw const num as *const i32;\nlet r2 = &raw mut num as *mut i32;\n\n```\n\n----------------------------------------\n\nTITLE: Rust Error: Suggested Fix\nDESCRIPTION: This code snippet demonstrates the compiler's suggested fix for the error, which involves changing the return type of the main function to `Result<(), Box<dyn std::error::Error>>`. This allows the `?` operator to function correctly by propagating errors. Additionally, `Ok(())` needs to be returned.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch09-error-handling/listing-09-10/output.txt#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let greeting_file = File::open(\"hello.txt\")?;\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Right-Inclusive Range Literal Operator Rust\nDESCRIPTION: This operator creates a right-inclusive range. The range includes both the starting and ending values. The `PartialOrd` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_26\n\nLANGUAGE: Rust\nCODE:\n```\n`..=expr`\n```\n\nLANGUAGE: Rust\nCODE:\n```\n`expr..=expr`\n```\n\n----------------------------------------\n\nTITLE: Implementing State Age Check in Rust\nDESCRIPTION: This snippet defines a method `can_vote` on the `UsState` enum to check if the state existed in 1900. It's a simple example showcasing how to add methods to enums.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-03-if-let.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nenum UsState {\n    Alabama,\n    Alaska,\n    // --snip--\n}\n\nimpl UsState {\n    fn can_vote(&self) -> bool {\n        match self {\n            UsState::Alabama => true,\n            UsState::Alaska => false,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Closure Capturing Immutable Reference in Rust\nDESCRIPTION: This example demonstrates a closure that captures an immutable reference to a vector.  The closure simply prints the vector's contents. Because the closure only requires an immutable reference, the original vector `list` remains accessible both before and after the closure is defined and called. Dependencies: none.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(\"Before defining closure: {list:?}\");\n\n    let only_borrows = || println!(\"From closure: {list:?}\");\n\n    println!(\"Before calling closure: {list:?}\");\n    only_borrows();\n    println!(\"After calling closure: {list:?}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Guess Struct with Bug in new Function - Rust\nDESCRIPTION: This snippet introduces a bug into the `Guess::new` function by removing the panic condition when the value is greater than 100. This allows demonstrating a failing `should_panic` test.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-01-writing-tests.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-08-guess-with-bug/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Handling Type Errors with Trait Objects in Rust\nDESCRIPTION: This snippet shows an example of attempting to add a `String` to a `Screen`'s components vector, which expects types that implement the `Draw` trait. The compiler will produce an error because `String` does not implement `Draw`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter18.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse gui::Screen;\n\nfn main() {\n    let screen = Screen {\n        components: vec![Box::new(String::from(\"Hi\"))],\n    };\n\n    screen.run();\n}\n```\n\n----------------------------------------\n\nTITLE: Re-exporting Names with `pub use` in Rust\nDESCRIPTION: This code demonstrates how to re-export a name from a module using `pub use`, making it available to other modules as if it were defined in the current scope.  It allows external code to access items using a shorter path.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub use crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n```\n\n----------------------------------------\n\nTITLE: Largest Number and Char Functions (Non-Generic) Rust\nDESCRIPTION: These functions find the largest i32 and char in a slice respectively. The code demonstrates duplicated logic that can be improved by using generics. The `largest_i32` function finds the largest i32, while `largest_char` finds the largest char.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn largest_i32(list: &[i32]) -> &i32 {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item > largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn largest_char(list: &[char]) -> &char {\n    let mut largest = &list[0];\n\n    for item in list {\n        if item > largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest_i32(&number_list);\n    println!(\"The largest number is {result}\");\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest_char(&char_list);\n    println!(\"The largest char is {result}\");\n}\n```\n\n----------------------------------------\n\nTITLE: If Expression: Checking for Non-Zero Value in Rust\nDESCRIPTION: This code snippet uses an `if` expression to check if a number is not equal to zero. It explicitly uses a boolean condition (`number != 0`) to determine whether the code block inside the `if` statement should be executed. This demonstrates the correct way to check for a non-zero value in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-05-control-flow.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let number = 3;\n\n    if number != 0 {\n        println!(\"number was something other than zero\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Glob Operator in a `use` Statement in Rust\nDESCRIPTION: This code snippet demonstrates the use of the glob operator (`*`) in a `use` statement to bring all public items defined in a specific path into the current scope. It highlights the potential benefits and drawbacks of using the glob operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::*;\n```\n\n----------------------------------------\n\nTITLE: Using Struct Update Syntax in Rust\nDESCRIPTION: This code shows the use of struct update syntax (`..user1`) to create a new `User` instance (`user2`) that inherits most values from `user1`, except for the `email` field, which is explicitly set to a new value. This demonstrates a concise way to create a new struct based on an existing one.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // --snip--\n\n    let user2 = User {\n        email: String::from(\"another@example.com\"),\n        ..user1\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating Over a Vector in Rust\nDESCRIPTION: This Rust code snippet demonstrates how to create an iterator from a vector using `v1.iter()` and then iterate over the elements using a `for` loop. The `println!` macro is used to print each element's value to the console. The code assumes the existence of a vector `v1` containing integer values.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/iterators.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet v1 = vec![1, 2, 3];\n\nlet v1_iter = v1.iter();\n\nfor val in v1_iter {\n    println!(\"Got: {val}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Multi-line Comment in Rust\nDESCRIPTION: This snippet shows how to create multi-line comments in Rust.  Each line of a multi-line comment must start with `//`.  These are helpful for longer explanations.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-04-comments.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n// So we're doing something complicated here, long enough that we need\n// multiple lines of comments to do it! Whew! Hopefully, this comment will\n// explain what's going on.\n```\n\n----------------------------------------\n\nTITLE: Workspace Cargo.toml with adder Package\nDESCRIPTION: This TOML code shows the `Cargo.toml` file for the workspace after adding the `adder` package. The `members` array now includes \"adder\".\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-03-cargo-workspaces.md#_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[workspace]\nmembers = [\n    \"adder\",\n]\nresolver = \"3\"\n```\n\n----------------------------------------\n\nTITLE: Creating a Library Crate in a Workspace\nDESCRIPTION: This console command creates a new library crate named `add_one` within the Cargo workspace. The `--lib` flag specifies that a library crate should be created. This command also automatically updates the workspace `Cargo.toml`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-03-cargo-workspaces.md#_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ cargo new add_one --lib\n    Creating library `add_one` package\n      Adding `add_one` as member of workspace at `file:///projects/add`\n```\n\n----------------------------------------\n\nTITLE: Illustrating Statement Limitations in Rust\nDESCRIPTION: This code demonstrates an error caused by attempting to assign a `let` statement to a variable. Because `let` statements do not return values, this operation is invalid in Rust. This snippet showcases the difference between Rust and other languages like C or Ruby.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = (let y = 6);\n}\n```\n\n----------------------------------------\n\nTITLE: Attempting String Indexing\nDESCRIPTION: This snippet demonstrates the invalid attempt to access a character in a `String` using indexing syntax. Rust strings do not support direct indexing due to UTF-8 encoding and variable character sizes.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nlet s1 = String::from(\"hello\");\nlet h = s1[0];\n```\n\n----------------------------------------\n\nTITLE: Creating a new cargo project - Console\nDESCRIPTION: This is a console command to create a new Rust project named `minigrep`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-01-accepting-command-line-arguments.md#_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ cargo new minigrep\n     Created binary (application) `minigrep` project\n$ cd minigrep\n```\n\n----------------------------------------\n\nTITLE: Running Tests for the Search Function in Shell\nDESCRIPTION: This shell command executes the tests for the `minigrep` project. It compiles the code and runs the unit tests defined in the `src/lib.rs` and `src/main.rs` files. The output shows the results of the tests, including the number of tests passed, failed, and ignored.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_19\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo test\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.22s\n     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 1 test\ntest tests::one_result ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests minigrep\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n```\n\n----------------------------------------\n\nTITLE: Alternative Worker Implementation with While Let in Rust\nDESCRIPTION: This snippet demonstrates an alternative implementation of the `Worker::new` function using a `while let` loop to receive and execute jobs. This approach can lead to longer lock holding times, as the mutex guard is not dropped until the end of the `while let` block.  The worker thread acquires a mutex lock on the receiver, receives a `Job` from the channel, and executes the received closure. Errors during lock acquisition or receiving are handled by unwrapping the results.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        let thread = thread::spawn(move || {\n            while let Ok(job) = receiver.lock().unwrap().recv() {\n                println!(\"Worker {id} got a job; executing.\");\n\n                job();\n            }\n        });\n\n        Worker { id, thread }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Path Dependency\nDESCRIPTION: Defines a path dependency from the `adder` binary crate to the `add_one` library crate. This is done in the `adder/Cargo.toml` file and specifies the relative path to the `add_one` crate.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_19\n\nLANGUAGE: TOML\nCODE:\n```\n[dependencies]\nadd_one = { path = \"../add_one\" }\n```\n\n----------------------------------------\n\nTITLE: Iterating Through Lines with Lines Method Rust\nDESCRIPTION: This snippet demonstrates iterating through each line of a given text content using the `lines` method. The `lines` method returns an iterator that yields each line in the string. The code snippet won't compile, as it's part of building up the `search` function step-by-step.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-04-testing-the-librarys-functionality.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-17/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Short-circuiting Logical AND Operator Rust\nDESCRIPTION: This operator performs a short-circuiting logical AND operation. It returns `true` only if both operands are `true`, but it evaluates the right operand only if the left operand is `true`. This operator cannot be overloaded.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_9\n\nLANGUAGE: Rust\nCODE:\n```\n`expr && expr`\n```\n\n----------------------------------------\n\nTITLE: Initializing ThreadPool with JoinHandles - Rust\nDESCRIPTION: This code snippet demonstrates initializing a `ThreadPool` with a vector of `thread::JoinHandle<()>` instances. It creates a vector with a specified capacity and initializes a `ThreadPool` struct with it. The threads are not actually spawned yet, but the structure is prepared to hold them.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\n\npub struct ThreadPool {\n    threads: Vec<thread::JoinHandle<()>>,\n}\n\nimpl ThreadPool {\n    // --snip--\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let mut threads = Vec::with_capacity(size);\n\n        for _ in 0..size {\n            // create some threads and store them in the vector\n        }\n\n        ThreadPool { threads }\n    }\n    // --snip--\n}\n```\n\n----------------------------------------\n\nTITLE: Using eprintIn! for Standard Error\nDESCRIPTION: This code snippet (Listing 12-24) from `src/main.rs` replaces `println!` with `eprintln!` to direct error messages to the standard error stream (stderr) instead of the standard output stream (stdout). This allows users to redirect successful program output to a file while still seeing error messages on the console.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-06-writing-to-stderr-instead-of-stdout.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-24/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Summing Iterator Elements (Rust)\nDESCRIPTION: This code snippet demonstrates the `sum` consuming adapter, which calculates the sum of all elements in an iterator. The `sum` method takes ownership of the iterator, so the iterator cannot be used after the call to `sum`. The return type of `sum` must be specified, in this case, `i32`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n#[test]\nfn iterator_sum() {\n    let v1 = vec![1, 2, 3];\n\n    let v1_iter = v1.iter();\n\n    let total: i32 = v1_iter.sum();\n\n    assert_eq!(total, 6);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Thread with `spawn` in Rust\nDESCRIPTION: This snippet demonstrates how to create a new thread using `thread::spawn` and execute a closure within it. The main thread and the spawned thread both print numbers, illustrating concurrent execution. The `thread::sleep` function introduces a short pause to allow thread switching.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch16-01-threads.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Can Hold Method on Rectangle Struct in Rust\nDESCRIPTION: This snippet defines a `can_hold` method on the `Rectangle` struct that takes another `Rectangle` instance as a parameter. It checks if the first rectangle (self) can completely contain the second rectangle. The method returns true if both the width and height of self are greater than the width and height of the other rectangle, respectively; otherwise, it returns false.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nimpl Rectangle {\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n\n    fn can_hold(&self, other: &Rectangle) -> bool {\n        self.width > other.width && self.height > other.height\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Sample 404 HTML content\nDESCRIPTION: This is a sample HTML content for the 404 error page. It provides a basic structure for displaying an error message to the user when a requested resource is not found.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-01-single-threaded.md#_snippet_7\n\nLANGUAGE: html\nCODE:\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <title>404</title>\n</head>\n<body>\n    <h1>Oops!</h1>\n    <p>Sorry, I don't know what you're asking for.</p>\n</body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Integer Assignment in Rust\nDESCRIPTION: This snippet illustrates simple value copying with integers.  `x`'s value is copied to `y`. Both `x` and `y` own distinct copies of the data on the stack.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nlet x = 5;\nlet y = x;\n```\n\n----------------------------------------\n\nTITLE: Rust Bitwise OR Operator Example\nDESCRIPTION: Demonstrates the bitwise OR operator (`|`) in Rust. It performs a bitwise OR operation between two expressions.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_52\n\nLANGUAGE: Rust\nCODE:\n```\nexpr | expr\n```\n\n----------------------------------------\n\nTITLE: Enum with Data and Match Expression Binding to Values in Rust\nDESCRIPTION: This snippet defines an enum `UsState` and modifies the `Coin` enum to include a `UsState` value within the `Quarter` variant. The `value_in_cents` function then uses a `match` expression to bind the `state` value of the `Quarter` variant and prints a message including the state name.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)] // so we can inspect the state in a minute\nenum UsState {\n    Alabama,\n    Alaska,\n    // --snip--\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n}\n```\n\n----------------------------------------\n\nTITLE: Using the search Function in the run Function in Rust\nDESCRIPTION: This code snippet demonstrates how to integrate the `search` function into the `run` function. It calls the `search` function with the query and contents, then iterates through the returned lines and prints each line to the console. This allows the `run` function to utilize the search functionality to find and display matching lines from a file.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\npub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    for line in search(&config.query, &contents) {\n        println!(\"{line}\");\n    }\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Main Function Calling Longest\nDESCRIPTION: This main function calls the `longest` function with two string slices and prints the result. It demonstrates the intended usage of the `longest` function to find the longer of two strings.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_37\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let string1 = String::from(\"abcd\");\n    let string2 = \"xyz\";\n\n    let result = longest(string1.as_str(), string2);\n    println!(\"The longest string is {result}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Result enum with generic types\nDESCRIPTION: Shows the definition of the `Result<T, E>` enum, which is generic over two types, `T` and `E`. It has two variants: `Ok(T)`, which holds a value of type `T` representing success, and `Err(E)`, which holds a value of type `E` representing an error. This demonstrates how enums can use multiple generic types.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-01-syntax.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\n----------------------------------------\n\nTITLE: String Literal as a Slice in Rust\nDESCRIPTION: This snippet shows how string literals are stored inside the binary and how they are treated as slices (`&str`) pointing to a specific point in memory. String literals are immutable due to being an immutable reference.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-03-slices.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nlet s = \"Hello, world!\";\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Division Operator Rust\nDESCRIPTION: This operator performs arithmetic division. It divides the left operand by the right operand and returns the quotient. The `Div` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_30\n\nLANGUAGE: Rust\nCODE:\n```\n`expr / expr`\n```\n\n----------------------------------------\n\nTITLE: Using Re-exported Items from Art Crate in Rust\nDESCRIPTION: This code demonstrates using the re-exported items from the `art` crate. The `use` statements are simplified because `PrimaryColor` and `mix` are now available directly under the `art` crate, without specifying nested modules.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-02-publishing-to-crates-io.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(unused)]\nfn main() {\n    use art::PrimaryColor;\n    use art::mix;\n\n    fn main() {\n        let red = PrimaryColor::Red;\n        let yellow = PrimaryColor::Yellow;\n        mix(red, yellow);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Division and Assignment Operator Rust\nDESCRIPTION: This operator performs arithmetic division and assigns the result to the variable. It's a shorthand for `var = var / expr`. The `DivAssign` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_31\n\nLANGUAGE: Rust\nCODE:\n```\n`var /= expr`\n```\n\n----------------------------------------\n\nTITLE: Exploring Mutex<T> API in Single-Threaded Context - Rust\nDESCRIPTION: This code demonstrates the basic usage of `Mutex<T>` in a single-threaded context. It creates a `Mutex<i32>`, locks it to access the inner value, modifies the value, and then the lock is automatically released when the `MutexGuard` goes out of scope.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch16-03-shared-state.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::Mutex;\n\nfn main() {\n    let m = Mutex::new(5);\n\n    {\n        let mut num = m.lock().unwrap();\n        *num = 6;\n    }\n\n    println!(\"m = {:?}\", m);\n}\n```\n\n----------------------------------------\n\nTITLE: Build Rust Project Showing Unused Mutability Warning\nDESCRIPTION: This console output shows the result of building the Rust project, which produces a warning about an unused mutable variable. The warning includes a suggestion to remove the `mut` keyword, which `cargo fix` can apply automatically.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-04-useful-development-tools.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n$ cargo build\n   Compiling myprogram v0.1.0 (file:///projects/myprogram)\nwarning: variable does not need to be mutable\n --> src/main.rs:2:9\n  |\n2 |     let mut x = 0;\n  |         ----^\n  |         |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n```\n\n----------------------------------------\n\nTITLE: Attempting to Access an Out-of-Bounds Vector Element\nDESCRIPTION: This example demonstrates the behavior when attempting to access an element beyond the bounds of a vector. Using indexing (`v[100]`) will cause the program to panic. Using the `get` method (`v.get(100)`) will return `None`, allowing for safe handling of the out-of-bounds access.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet v = vec![1, 2, 3, 4, 5];\n\nlet does_not_exist = &v[100];\nlet does_not_exist = v.get(100);\n```\n\n----------------------------------------\n\nTITLE: Variable Scope Example in Rust\nDESCRIPTION: This code snippet demonstrates the scope of a variable in Rust. The variable `s` is valid only within the curly braces where it's declared. When the scope ends, `s` is no longer valid.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n{\n    let s = \"hello\";   \n\n    // do stuff with s\n}                      \n```\n\n----------------------------------------\n\nTITLE: Monomorphization Example with `Option<T>` in Rust\nDESCRIPTION: This code demonstrates Rust's monomorphization process with the standard library's `Option<T>` enum. The compiler analyzes the usage of `Option<T>` and generates specialized versions for the concrete types used (in this case, `i32` and `f64`). This avoids runtime overhead by replacing the generic definition with specific ones at compile time. The code illustrates the concept by showing a conceptual representation of the compiler's output.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-01-syntax.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nenum Option_i32 {\n    Some(i32),\n    None,\n}\n\nenum Option_f64 {\n    Some(f64),\n    None,\n}\n\nfn main() {\n    let integer = Option_i32::Some(5);\n    let float = Option_f64::Some(5.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Boxing Futures to Align Types (Incorrect)\nDESCRIPTION: This snippet tries to use `Box::new` to align the types of the futures in a `Vec`. Although boxing provides a level of indirection, it doesn't fully resolve the type mismatch because the futures are still distinct types. Additionally, it introduces errors related to the `Unpin` trait.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-03-more-futures.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse tokio::sync::mpsc;\nuse futures::future;\n\n#[tokio::main]\nasync fn main() {\n    let (tx1, mut rx1) = mpsc::channel::<i32>(100);\n    let (tx2, rx2) = mpsc::channel::<i32>(100);\n    let mut tx_fut = async move {\n        let mut i = 0;\n        loop {\n            // Maybe the receiver dropped\n            if tx1.send(i).await.is_err() {\n                break;\n            }\n            i += 1;\n        }\n    };\n\n    let mut rx_fut = async {\n        loop {\n            if rx1.recv().await.is_none() {\n                break;\n            }\n        }\n    };\n    let mut tx1_fut = async move {\n        let mut i = 0;\n        loop {\n            // Maybe the receiver dropped\n            if tx2.send(i).await.is_err() {\n                break;\n            }\n            i += 1;\n        }\n    };\n\n    let futures = vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];\n    future::join_all(futures).await;\n}\n```\n\n----------------------------------------\n\nTITLE: Running Rust Cargo Test\nDESCRIPTION: This snippet shows the output of the `cargo test` command, which compiles and runs unit tests for the `guessing_game` project. It indicates a failed test case.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/no-listing-08-guess-with-bug/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test\n Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n  Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s\n   Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)\n\nrunning 1 test\ntest tests::greater_than_100 - should panic ... FAILED\n\nfailures:\n\n---- tests::greater_than_100 stdout ----\nnote: test did not panic as expected\n\nfailures:\n    tests::greater_than_100\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n```\n\n----------------------------------------\n\nTITLE: Project Directory Structure\nDESCRIPTION: This represents the directory structure of a Rust project, highlighting the location of source files, integration tests, and a common module for shared test code. It demonstrates the structure needed to import modules for testing and avoid naming conflicts.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-03-test-organization.md#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n Cargo.lock\n Cargo.toml\n src\n  lib.rs\n tests\n     common\n      mod.rs\n     integration_test.rs\n```\n\n----------------------------------------\n\nTITLE: Right-Shift and Assignment Operator Rust\nDESCRIPTION: This operator performs a right-shift operation and assigns the result to the variable. It's a shorthand for `var = var >> expr`. The `ShrAssign` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_47\n\nLANGUAGE: Rust\nCODE:\n```\n`var >>= expr`\n```\n\n----------------------------------------\n\nTITLE: Using a Default Trait Implementation in Rust\nDESCRIPTION: This code demonstrates how to use a default trait implementation by creating an empty `impl` block for the `NewsArticle` struct, which indicates that it implements the `Summary` trait using the default `summarize` method. This enables calling the `summarize` method without writing any specific implementation for `NewsArticle`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nimpl Summary for NewsArticle {}\n```\n\n----------------------------------------\n\nTITLE: If Expression: Handling False Condition in Rust\nDESCRIPTION: This snippet shows an `if` expression where the condition is false. It demonstrates that the code within the `else` block will be executed when the `if` condition evaluates to false. The purpose is to illustrate the behavior of `if-else` when the initial condition isn't met.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-05-control-flow.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let number = 7;\n\n    if number < 5 {\n        println!(\"condition was true\");\n    } else {\n        println!(\"condition was false\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Thread Spawn Error with Closure\nDESCRIPTION: This snippet demonstrates a common Rust compilation error (E0373) that occurs when a closure spawned in a new thread attempts to borrow a variable `v` from the main function. The closure's lifetime may exceed that of `v`, leading to a potential dangling reference. The suggested fix is to use the `move` keyword, forcing the closure to take ownership of `v`.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch16-fearless-concurrency/listing-16-03/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n Compiling threads v0.1.0 (file:///projects/threads)\nerror[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function\n --> src/main.rs:6:32\n  |\n6 |     let handle = thread::spawn(|| {\n  |                                ^^ may outlive borrowed value `v`\n7 |         println!(\"Here's a vector: {v:?}\");\n  |                                     - `v` is borrowed here\n  |\nnote: function requires argument type to outlive `'static`\n --> src/main.rs:6:18\n  |\n6 |       let handle = thread::spawn(|| {\n  |  __________________^\n7 | |         println!(\"Here's a vector: {v:?}\");\n8 | |     });\n  | |______^\nhelp: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword\n  |\n6 |     let handle = thread::spawn(move || {\n  |                                ++++\n\nFor more information about this error, try `rustc --explain E0373`.\nerror: could not compile `threads` (bin \"threads\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Displaying PATH in PowerShell\nDESCRIPTION: Prints the value of the PATH environment variable in PowerShell. This is useful for verifying if the Rust installation directory is included in the PATH.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_4\n\nLANGUAGE: PowerShell\nCODE:\n```\n> echo $env:Path\n```\n\n----------------------------------------\n\nTITLE: Modifications to Main for New Workflow - main.rs\nDESCRIPTION: This snippet shows the changes required in `main` to accommodate the new implementation of the blog post workflow. This includes reassigning `post` due to the methods returning new instances rather than modifying the existing ones.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-03-oo-design-patterns.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch18-oop/listing-18-21/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Using Function Call Expression\nDESCRIPTION: This code snippet illustrates the use of a function call expression in Rust. It's also used to initialize tuple structs and tuple enum variants.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_108\n\nLANGUAGE: Rust\nCODE:\n```\nexpr(expr, ...)\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Struct in Rust\nDESCRIPTION: This code defines a generic struct `Point` with two type parameters, `T` and `U`, representing the types of the `x` and `y` fields respectively. The `main` function then demonstrates how to instantiate this struct with different concrete types for `x` and `y`, including integers, floats, and a combination of both.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/generics.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point<T, U> {\n    x: T,\n    y: U,\n}\n\nfn main() {\n    let both_integer = Point { x: 5, y: 10 };\n    let both_float = Point { x: 1.0, y: 4.0 };\n    let integer_and_float = Point { x: 5, y: 4.0 };\n}\n```\n\n----------------------------------------\n\nTITLE: Public Enum Declaration in Rust\nDESCRIPTION: This example demonstrates declaring an enum as public, which automatically makes all its variants public. This allows access to the enum variants from outside the module where the enum is defined.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nmod back_of_house {\n    pub enum Appetizer {\n        Soup,\n        Salad,\n    }\n}\n\npub fn eat_at_restaurant() {\n    let order1 = back_of_house::Appetizer::Soup;\n    let order2 = back_of_house::Appetizer::Salad;\n}\n```\n\n----------------------------------------\n\nTITLE: Function Parameter Pattern Example (i32)\nDESCRIPTION: This Rust code snippet defines a function `foo` that takes one parameter `x` of type `i32`. The parameter `x` itself acts as a pattern.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-01-all-the-places-for-patterns.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn foo(x: i32) {\n    println!(\"The value of x is: {}\", x);\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Main Function with a Statement in Rust\nDESCRIPTION: This snippet shows a basic `main` function declaration in Rust containing a single statement that declares and initializes a variable `y` with the value 6. Statements in Rust do not return a value.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let y = 6;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mutable Variables in Rust\nDESCRIPTION: This code shows how to declare a mutable variable using the `mut` keyword, allowing its value to be changed. By adding `mut` to a variable, we are indicating that other parts of the code will be changing this variable's value.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-01-variables-and-mutability.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut x = 5;\n    println!(\"The value of x is: {x}\");\n    x = 6;\n    println!(\"The value of x is: {x}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Error: `?` Operator in `main` Function\nDESCRIPTION: This code snippet demonstrates the error E0277 in Rust, which occurs when the `?` operator is used in a function (in this case, `main`) that does not return a `Result` or `Option` type. To fix this, the function's return type should be changed to `Result<(), Box<dyn std::error::Error>>` or similar. This allows the `?` operator to propagate errors up the call stack.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch09-error-handling/listing-09-10/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let greeting_file = File::open(\"hello.txt\")?;\n}\n```\n\n----------------------------------------\n\nTITLE: Macro Expansion Operator Rust\nDESCRIPTION: This operator is used for macro expansion in Rust.  It takes an identifier and expands it using the defined macro rules. The operator is not overloadable.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n`ident!(...)`\n```\n\nLANGUAGE: Rust\nCODE:\n```\n`ident!{...}`\n```\n\nLANGUAGE: Rust\nCODE:\n```\n`ident![...]`\n```\n\n----------------------------------------\n\nTITLE: Running Cargo and Compilation Error\nDESCRIPTION: This snippet shows the output of the `cargo run` command, which resulted in a compilation error in a Rust project named `gui`. The error indicates that the `String` type does not implement the `Draw` trait, which is required when trying to add it to a vector expecting `Box<dyn Draw>`.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch18-oop/listing-18-10/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n Compiling gui v0.1.0 (file:///projects/gui)\nerror[E0277]: the trait bound `String: Draw` is not satisfied\n --> src/main.rs:5:26\n  |\n5 |         components: vec![Box::new(String::from(\"Hi\"))],\n  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not implemented for `String`\n  |\n  = help: the trait `Draw` is implemented for `Button`\n  = note: required for the cast from `Box<String>` to `Box<dyn Draw>`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `gui` (bin \"gui\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Running Tests and Showing Output - Cargo\nDESCRIPTION: This command instructs Cargo to run tests and display the standard output for both passing and failing tests using the `--show-output` flag.  This is useful for debugging and understanding the behavior of tests.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo test -- --show-output\n```\n\n----------------------------------------\n\nTITLE: Define HelloMacro Trait - Rust\nDESCRIPTION: Defines the `HelloMacro` trait with an associated function `hello_macro`. This trait is intended to be implemented by a procedural macro.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-05-macros.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-38/hello_macro/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Defining an ASCII Byte Literal\nDESCRIPTION: This code snippet illustrates the definition of an ASCII byte literal in Rust.  It represents a single ASCII byte.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_63\n\nLANGUAGE: Rust\nCODE:\n```\nb'...' \n```\n\n----------------------------------------\n\nTITLE: Running Tests with Specific Number of Threads\nDESCRIPTION: This command shows how to specify the number of threads to use when running tests.  Setting `--test-threads=1` disables parallelism, which can be useful when tests share state.  This command is passed to the test binary after the `--` separator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-02-running-tests.md#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ cargo test -- --test-threads=1\n```\n\n----------------------------------------\n\nTITLE: Subtraction and Assignment Operator Rust\nDESCRIPTION: This operator performs arithmetic subtraction and assigns the result to the variable. It's a shorthand for `var = var - expr`. The `SubAssign` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_20\n\nLANGUAGE: Rust\nCODE:\n```\n`var -= expr`\n```\n\n----------------------------------------\n\nTITLE: Ignoring Struct Fields with `..` in Rust\nDESCRIPTION: This code demonstrates how to ignore specific fields of a struct during pattern matching using the `..` syntax. The `..` pattern ignores any fields that are not explicitly matched, simplifying the pattern when only a few fields are relevant.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_28\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point {\n    x: i32,\n    y: i32,\n    z: i32,\n}\n\nlet origin = Point { x: 0, y: 0, z: 0 };\n\nmatch origin {\n    Point { x, .. } => println!(\"x is {x}\"),\n}\n```\n\n----------------------------------------\n\nTITLE: Calling `map` Method to Create a New Iterator in Rust\nDESCRIPTION: This code shows how to use the `map` iterator adapter to create a new iterator by applying a closure to each item in the original iterator. The `map` method is lazy and produces a new iterator that yields the modified items. It needs to be consumed to produce a result.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-02-iterators.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet v1 = vec![1, 2, 3];\n\nv1.iter().map(|x| x + 1);\n```\n\n----------------------------------------\n\nTITLE: Generating a Random Number in Rust\nDESCRIPTION: This Rust code snippet generates a random number between 1 and 100 (inclusive) using the `rand` crate. It imports the necessary modules (`std::io` and `rand::Rng`), initializes a random number generator, and calls the `gen_range` method to produce the random number. The `secret_number` is then printed to the console (for debugging purposes).\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter02.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse std::io;\n\nuse rand::Rng;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1..=100);\n\n    println!(\"The secret number is: {secret_number}\");\n\n    println!(\"Please input your guess.\");\n\n    let mut guess = String::new();\n\n    io::stdin()\n        .read_line(&mut guess)\n        .expect(\"Failed to read line\");\n\n    println!(\"You guessed: {guess}\");\n}\n```\n\n----------------------------------------\n\nTITLE: ThreadPool::build Result Type - Rust\nDESCRIPTION: This code defines the signature for an alternative `build` function that returns a `Result` type, allowing for error handling instead of panicking when the thread pool size is invalid. It suggests an alternative implementation for the `ThreadPool` constructor.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\npub fn build(size: usize) -> Result<ThreadPool, PoolCreationError> {\n```\n\n----------------------------------------\n\nTITLE: Iterating over Characters in a String - Rust\nDESCRIPTION: This snippet shows how to iterate over individual Unicode scalar values (characters) in a string using the `chars()` method. Each character is then printed to the console.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_25\n\nLANGUAGE: Rust\nCODE:\n```\nfor c in \"\".chars() {\n    println!(\"{c}\");\n}\n```\n\n----------------------------------------\n\nTITLE: UsState Implementation Rust\nDESCRIPTION: This code defines an `impl` block for the `UsState` enum and includes a function `existed_in` that determines whether the state existed in a given year using pattern matching.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_26\n\nLANGUAGE: Rust\nCODE:\n```\nimpl UsState {\n    fn existed_in(&self, year: u16) -> bool {\n        match self {\n            UsState::Alabama => year >= 1819,\n            UsState::Alaska => year >= 1959,\n            // -- snip --\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Hello, world! program in Rust\nDESCRIPTION: This is a basic \"Hello, world!\" program in Rust. It defines a `main` function, which is the entry point of the program, and uses the `println!` macro to print the string \"Hello, world!\" to the console.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-02-hello-world.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Cargo Test\nDESCRIPTION: This command executes the test suite defined for the Rust project. It compiles the project and runs the tests.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/no-listing-07-custom-failure-message/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test\n```\n\n----------------------------------------\n\nTITLE: Calling an Unsafe Function within an Unsafe Block\nDESCRIPTION: Demonstrates calling the `dangerous` function within an `unsafe` block.  Calling unsafe functions necessitates the `unsafe` block to acknowledge the caller's responsibility for maintaining the function's contracts.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-01-unsafe-rust.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nunsafe fn dangerous() {}\n\nfn main() {\n    unsafe {\n        dangerous();\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Attempting to Create a Dangling Reference in Rust\nDESCRIPTION: This code snippet demonstrates an attempt to create a dangling reference by returning a reference to a `String` that goes out of scope. This will result in a compile-time error, as Rust's borrow checker prevents dangling pointers.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-02-references-and-borrowing.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let reference_to_nothing = dangle();\n}\n\nfn dangle() -> &String {\n    let s = String::from(\"hello\");\n\n    &s\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Constants and Statics in Rust\nDESCRIPTION: This code snippet demonstrates how to define a constant (`const`) and a static variable (`static`) in Rust. Constants are immutable and evaluated at compile time, while static variables represent global mutable data.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/const-and-static.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nconst MAX_POINTS: u32 = 100_000;\nstatic HELLO_WORLD: &str = \"Hello, world!\";\n```\n\n----------------------------------------\n\nTITLE: Using trpl::join! with Distinct Future Types in Rust\nDESCRIPTION: This snippet demonstrates using `trpl::join!` to await futures with different output types.  Each future returns a different type (u32, &str, bool), and `trpl::join!` returns a tuple containing the results of each future. This is useful when futures have distinct output types and a fixed number of futures are being awaited.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\nlet a = async { 1u32 };\nlet b = async { \"Hello!\" };\nlet c = async { true };\n\nlet (a_result, b_result, c_result) = trpl::join!(a, b, c);\nprintln!(\"{a_result}, {b_result}, {c_result}\");\n```\n\n----------------------------------------\n\nTITLE: Destructuring Enums in Rust\nDESCRIPTION: This code demonstrates destructuring different variants of an enum within a `match` expression. It shows how to extract values from struct-like and tuple-like enum variants. The number of variables in the pattern must match the number of elements in the variant were matching.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nlet msg = Message::ChangeColor(0, 160, 255);\n\nmatch msg {\n    Message::Quit => println!(\"The Quit variant has no data to destructure.\"),\n    Message::Move { x, y } => {\n        println!(\"Move in the x direction {x} and in the y direction {y}\");\n    },\n    Message::Write(text) => println!(\"Text message: {text}\"),\n    Message::ChangeColor(red, green, blue) => {\n        println!(\"Change color to red {red}, green {green}, and blue {blue}\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Calling a Function with Enum Variants in Rust\nDESCRIPTION: This code shows how to call the `route` function with different variants of the `IpAddrKind` enum. Requires the `IpAddrKind` enum and the `route` function to be defined.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nroute(IpAddrKind::V4);\nroute(IpAddrKind::V6);\n```\n\n----------------------------------------\n\nTITLE: Matching Ranges of Values in Rust\nDESCRIPTION: This example shows how to match against a range of values using the `..=` syntax in a `match` expression. If `x` is within the range of 1 to 5 (inclusive), the first arm is executed. Otherwise, the default arm is executed.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 5;\n\nmatch x {\n    1..=5 => println!(\"one through five\"),\n    _ => println!(\"something else\"),\n}\n```\n\n----------------------------------------\n\nTITLE: Running Program with Arguments (Variables) - Console\nDESCRIPTION: This console output shows the result of running the `minigrep` program with the arguments `test` and `sample.txt`. The program successfully saves these arguments into the `query` and `file_path` variables and prints their values to the console.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-01-accepting-command-line-arguments.md#_snippet_4\n\nLANGUAGE: console\nCODE:\n```\nSearching for test\nIn file sample.txt\n```\n\n----------------------------------------\n\nTITLE: Function-like macro definition\nDESCRIPTION: This code snippet shows the function signature for defining a function-like macro in Rust. It takes a single `TokenStream` parameter, `input`, which represents the tokens inside the macro's parentheses. It returns a `TokenStream` representing the generated code.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-05-macros.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n#[proc_macro]\npub fn sql(input: TokenStream) -> TokenStream {\n```\n\n----------------------------------------\n\nTITLE: Thread Attempting to Capture a Borrowed Reference\nDESCRIPTION: This code attempts to capture a reference to `v` in a thread, but the main thread drops `v` using `drop(v)`. This illustrates a scenario where a spawned thread might access an invalid reference, which Rust's borrow checker prevents by default.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter16.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n\n    let handle = thread::spawn(|| {\n        println!(\"Here's a vector: {v:?}\");\n    });\n\n    drop(v); // oh no!\n\n    handle.join().unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Method Call Operator Rust\nDESCRIPTION: This operator is used to call a method on a value. It executes the method associated with the value's type. This operator cannot be overloaded.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_23\n\nLANGUAGE: Rust\nCODE:\n```\n`expr.ident(expr, ...)`\n```\n\n----------------------------------------\n\nTITLE: Character Type in Rust\nDESCRIPTION: This code snippet demonstrates the use of the `char` type in Rust. It shows how to declare character variables using single quotes and represents Unicode Scalar Values.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-02-data-types.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet c = 'z';\nlet z: char = ''; // with explicit type annotation\nlet heart_eyed_cat = '';\n```\n\n----------------------------------------\n\nTITLE: Testing can_hold Method with assert! in Rust\nDESCRIPTION: This test case uses the `assert!` macro to verify that a larger `Rectangle` can indeed hold a smaller `Rectangle`, demonstrating a basic usage of assertions for boolean conditions in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-01-writing-tests.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-06/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Attempting to Use a Non-Drawable Type with Trait Objects in Rust\nDESCRIPTION: This snippet demonstrates the compiler error that occurs when trying to add a type that doesn't implement the `Draw` trait to a `Screen`'s components vector. This highlights the type safety provided by Rust's trait objects.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-02-trait-objects.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nstruct Screen {\n    pub components: Vec<Box<dyn Draw>>,\n}\n\nfn main() {\n    let screen = Screen {\n        components: vec![Box::new(\"Hi\".to_string())],\n    };\n\n    screen.run();\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo.toml configuration file content\nDESCRIPTION: This is the content of the Cargo.toml file generated by `cargo new`. It defines the package's metadata, including the name, version, and Rust edition. The `[dependencies]` section is used to list project dependencies.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-03-hello-cargo.md#_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"hello_cargo\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\n```\n\n----------------------------------------\n\nTITLE: Running cargo command in Rust\nDESCRIPTION: This snippet shows the execution of the command `cargo run` within the Rust project named `cons-list`. It demonstrates the compilation process and the subsequent execution of the compiled binary.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch15-smart-pointers/listing-15-26/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling cons-list v0.1.0 (file:///projects/cons-list)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.53s\n   Running `target/debug/cons-list`\na initial rc count = 1\na next item = Some(RefCell { value: Nil })\na rc count after b creation = 2\nb initial rc count = 1\nb next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })\nb rc count after changing a = 2\na rc count after changing a = 2\n```\n\n----------------------------------------\n\nTITLE: Thread Capturing a Reference to `v` (Compile Error)\nDESCRIPTION: This code demonstrates a scenario where a spawned thread attempts to capture a reference to a vector `v` from the main thread. The main thread then drops `v` immediately. This leads to a potential use-after-free situation, causing a compile error. This example further emphasizes the need for careful handling of ownership and lifetimes when working with threads in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch16-01-threads.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-04/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Idiomatic `use` of `HashMap` in Rust\nDESCRIPTION: This example demonstrates the idiomatic way to bring the `HashMap` struct into scope.  Structs and enums are generally brought into scope using their full path, while functions are brought in by bringing in their parent modules.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::HashMap;\n\nfn main() {\n    let mut map = HashMap::new();\n    map.insert(1, 2);\n}\n```\n\n----------------------------------------\n\nTITLE: Unyanking a Crate Version\nDESCRIPTION: This snippet shows how to undo a yank and allow projects to start depending on a version again using `cargo yank --undo`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo yank --vers 1.0.1 --undo\n    Updating crates.io index\n      Unyank guessing_game@1.0.1\n```\n\n----------------------------------------\n\nTITLE: Attempting to use an irrefutable pattern with `if let` in Rust\nDESCRIPTION: This code attempts to use an irrefutable pattern `x` with an `if let` statement.  The compiler will issue a warning that using an irrefutable pattern with `if let` does not make sense because the `if let` is designed to handle potential failures, which an irrefutable pattern cannot have.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-02-refutability.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 5;\nif let x = 5 {\n    println!(\"{}\", x);\n};\n```\n\n----------------------------------------\n\nTITLE: Raw Pointer Types Rust\nDESCRIPTION: These are raw pointer types, which are similar to pointers in C/C++.  They can be either mutable or immutable, and are not guaranteed to be valid. They require `unsafe` code to dereference.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_13\n\nLANGUAGE: Rust\nCODE:\n```\n`*const type`\n```\n\nLANGUAGE: Rust\nCODE:\n```\n`*mut type`\n```\n\n----------------------------------------\n\nTITLE: Adding Timeout to a Stream in Rust\nDESCRIPTION: This code snippet demonstrates adding a timeout to a stream using the `StreamExt::timeout` method from the `futures` crate. It sets a time limit on the items in the stream, and the `while let` loop handles both the successful arrival of messages and timeout errors. Requires `futures` and `tokio`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-04-streams.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse futures::stream::Stream;\nuse futures::stream::StreamExt;\nuse futures::task::{Context, Poll};\nuse std::pin::Pin;\nuse std::time::Duration;\nuse tokio::sync::mpsc;\n\nstruct ReceiverStream { rx: mpsc::Receiver<String> }\n\nimpl Stream for ReceiverStream {\n    type Item = String;\n\n    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<String>> {\n        self.rx.poll_recv(cx)\n    }\n}\n\nfn get_messages() -> impl Stream<Item = String> {\n    let (tx, rx) = mpsc::channel(128);\n\n    tokio::spawn(async move {\n        let alphabet = vec![\n            \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\",\n        ];\n\n        for letter in alphabet {\n            tx.send(letter.to_string()).await.unwrap();\n        }\n    });\n\n    ReceiverStream { rx }\n}\n\n#[tokio::main]\nasync fn main() {\n    let mut stream = get_messages().timeout(Duration::from_millis(200));\n    \n    while let Some(result) = stream.next().await {\n        match result {\n            Ok(message) => println!(\"Message: '{message}'\"),\n            Err(_elapsed) => println!(\"Problem: Elapsed(())\"),\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Desired Blog Crate Behavior (Illustrative)\nDESCRIPTION: This snippet shows how the `blog` crate is intended to be used, including creating a new draft post, adding text, requesting a review, and publishing the post. It also demonstrates that content should only be available after the post is published.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-03-oo-design-patterns.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet mut post = Post::new();\n\npost.add_text(\"I ate a salad for lunch today\");\nassert_eq!(\"\", post.content());\n\npost.request_review();\nassert_eq!(\"\", post.content());\n\npost.approve();\nassert_eq!(\"I ate a salad for lunch today\", post.content());\n```\n\n----------------------------------------\n\nTITLE: Library Crate Structure - Rust\nDESCRIPTION: This snippet shows the structure of the library crate, including the `Config` struct and the `run` function. It uses `pub` to make the struct, its fields, its build method, and the run function public, allowing them to be used in the binary crate.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nuse std::error::Error;\nuse std::fs;\n\npub struct Config {\n    pub query: String,\n    pub file_path: String,\n}\n\nimpl Config {\n    pub fn build(args: &[String]) -> Result<Config, &'static str> {\n        // --snip--\n    }\n}\n\npub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n    // --snip--\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Installed Rust Toolchains via Rustup\nDESCRIPTION: This command lists all installed Rust toolchains (releases of Rust and associated components) managed by Rustup. It helps developers identify which versions of Rust are available on their system.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-07-nightly-rust.md#_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n> rustup toolchain list\nstable-x86_64-pc-windows-msvc (default)\nbeta-x86_64-pc-windows-msvc\nnightly-x86_64-pc-windows-msvc\n```\n\n----------------------------------------\n\nTITLE: Static Lifetime Annotation in Rust\nDESCRIPTION: This code snippet shows how to explicitly annotate a string literal with the `'static` lifetime. String literals are stored in the program's binary and are available for the entire duration of the program's execution.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_51\n\nLANGUAGE: rust\nCODE:\n```\nlet s: &'static str = \"I have a static lifetime.\";\n```\n\n----------------------------------------\n\nTITLE: Borrowed Pointer Type Rust\nDESCRIPTION: This syntax is used to define borrowed pointer types, either immutable or mutable, with or without a lifetime annotation. It specifies that a reference is being used.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\n`&type`\n```\n\nLANGUAGE: Rust\nCODE:\n```\n`&mut type`\n```\n\nLANGUAGE: Rust\nCODE:\n```\n`&'a type`\n```\n\nLANGUAGE: Rust\nCODE:\n```\n`&'a mut type`\n```\n\n----------------------------------------\n\nTITLE: Cargo Run Error\nDESCRIPTION: This snippet shows the error output when running `cargo run` on a Rust project without a specified binary target. This typically occurs when the project is a library rather than an executable application.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch17-async-await/no-listing-stream-ext/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\nerror: a bin target must be available for `cargo run`\n```\n\n----------------------------------------\n\nTITLE: Cargo Run Command and Compilation Error\nDESCRIPTION: This snippet shows the output of a `cargo run` command that attempts to compile and execute a Rust program. The compilation fails due to an invalid syntax: using a `let` statement inside an expression. The compiler outputs an error message indicating the location and type of the error, along with a suggestion to remove the parentheses.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch03-common-programming-concepts/no-listing-19-statements-vs-expressions/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n Compiling functions v0.1.0 (file:///projects/functions)\nerror: expected expression, found `let` statement\n --> src/main.rs:2:14\n  |\n2 |     let x = (let y = 6);\n  |              ^^^\n  |\n  = note: only supported directly in conditions of `if` and `while` expressions\n\nwarning: unnecessary parentheses around assigned value\n --> src/main.rs:2:13\n  |\n2 |     let x = (let y = 6);\n  |             ^         ^\n  |\n  = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n  |\n2 -     let x = (let y = 6);\n2 +     let x = let y = 6;\n  |\n\nwarning: `functions` (bin \"functions\") generated 1 warning\nerror: could not compile `functions` (bin \"functions\") due to 1 previous error; 1 warning emitted\n```\n\n----------------------------------------\n\nTITLE: Displaying the PATH environment variable in PowerShell\nDESCRIPTION: Displays the value of the PATH environment variable in PowerShell. The PATH variable is essential for the system to locate executable files.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-01-installation.md#_snippet_4\n\nLANGUAGE: PowerShell\nCODE:\n```\n> echo $env:Path\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error: Use of Moved Value\nDESCRIPTION: This snippet demonstrates a Rust compilation error (E0382) that occurs when attempting to use a value after it has been moved. The error arises because the `List` type, represented by the `Cons` struct, does not implement the `Copy` trait. When `a` is used in the creation of `b`, ownership is transferred, preventing its subsequent use in the creation of `c`. This showcases Rust's ownership system and move semantics.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch15-smart-pointers/listing-15-17/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n Compiling cons-list v0.1.0 (file:///projects/cons-list)\nerror[E0382]: use of moved value: `a`\n  --> src/main.rs:11:30\n   |\n9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));\n   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait\n10 |     let b = Cons(3, Box::new(a));\n   |                              - value moved here\n11 |     let c = Cons(4, Box::new(a));\n   |                              ^ value used here after move\n\nFor more information about this error, try `rustc --explain E0382`.\nerror: could not compile `cons-list` (bin \"cons-list\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Running Cargo Test\nDESCRIPTION: This snippet shows the output of the `cargo test` command, which compiles the project and runs all tests defined in the project. The output includes results for unit tests in `src/lib.rs`, integration tests in `tests/integration_test.rs`, and doc tests.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/no-listing-12-shared-test-code-problem/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.89s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::internal ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)\n\nrunning 1 test\ntest it_adds_two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Polling a Future with Match in Rust\nDESCRIPTION: This example demonstrates how Rust might compile `await` under the hood by polling a future and matching on the `Poll` result.  It illustrates a simplified, not-fully-functional example, showing handling for `Ready` but a placeholder for the `Pending` state. It showcases the basic logic of checking the status of a future.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-05-traits-for-async.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nmatch page_title(url).poll() {\n    Ready(page_title) => match page_title {\n        Some(title) => println!(\"The title for {url} was {title}\"),\n        None => println!(\"{url} had no title\"),\n    }\n    Pending => {\n        // But what goes here?\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using AsRef for String Comparison in Rust\nDESCRIPTION: This code demonstrates how to use the `AsRef` trait in Rust to convert a value to a string reference for comparison. The `is_hello` function takes a generic type `T` that implements `AsRef<str>`, allowing it to accept various string-like types and compare them to the string \"hello\".\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/borrow-and-asref.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn is_hello<T: AsRef<str>>(s: T) {\n   assert_eq!(\"hello\", s.as_ref());\n}\n```\n\n----------------------------------------\n\nTITLE: Using `let...else` for Control Flow in Rust\nDESCRIPTION: This snippet demonstrates using `let...else` syntax in Rust. If the pattern matches, it binds the value from the pattern in the outer scope. If the pattern does _not_ match, the program will flow into the `else` arm, which must return from the function.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-03-if-let.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nenum UsState {\n    Alabama,\n    Alaska,\n    // --snip--\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n}\n\nimpl UsState {\n    fn can_vote(&self) -> bool {\n        match self {\n            UsState::Alabama => true,\n            UsState::Alaska => false,\n        }\n    }\n}\n\nfn describe_coin(coin: Coin) -> String {\n    let Coin::Quarter(state) = coin else {\n        return \"Not a quarter\".to_string();\n    };\n\n    if state.can_vote() {\n        format!(\"{} can vote!\", coin_name(coin))\n    } else {\n        format!(\"{} cannot vote!\", coin_name(coin))\n    }\n}\n\nfn coin_name(coin: Coin) -> &'static str {\n    match coin {\n        Coin::Penny => \"Penny\",\n        Coin::Nickel => \"Nickel\",\n        Coin::Dime => \"Dime\",\n        Coin::Quarter(_) => \"Quarter\",\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: UTF-8 Byte Representation\nDESCRIPTION: This snippet demonstrates the UTF-8 encoding of the string \"\". Each Unicode scalar value in that string takes 2 bytes of storage. Therefore, an index into the strings bytes will not always correlate to a valid Unicode scalar value.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nlet hello = String::from(\"\");\n```\n\n----------------------------------------\n\nTITLE: Method Definition with Lifetime Annotation in Rust\nDESCRIPTION: Defines a method `level` on the `ImportantExcerpt` struct that takes a reference to self and returns an i32. It illustrates that lifetime annotations are not always required for the reference to `self` due to lifetime elision rules.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_49\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'a> ImportantExcerpt<'a> {\n    fn level(&self) -> i32 {\n        3\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Match Guards to Compare with Outer Variables in Rust\nDESCRIPTION: This code shows how to use a match guard to test for equality with a variable defined outside the `match` expression, avoiding shadowing issues.  It uses a match guard to check if a value `n` matches the value of an outer variable `y`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_32\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) => println!(\"Got 50\"),\n        Some(n) if n == y => println!(\"Matched, n = {n}\"),\n        _ => println!(\"Default case, x = {x:?}\"),\n    }\n\n    println!(\"at the end: x = {x:?}, y = {y}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Immutable Variables in Rust\nDESCRIPTION: This code snippet demonstrates the immutability of variables in Rust. Attempting to reassign a value to an immutable variable results in a compile-time error. This example shows how Rust enforces immutability by default to prevent bugs.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-01-variables-and-mutability.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = 5;\n    println!(\"The value of x is: {x}\");\n    x = 6;\n    println!(\"The value of x is: {x}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Refactoring Request Handling Logic\nDESCRIPTION: This Rust code snippet refactors the request handling logic by extracting the status line and filename into variables based on the request.  It reduces code duplication and improves readability.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n// --snip--\n\nfn handle_connection(mut stream: TcpStream) {\n    // --snip--\n\n    let (status_line, filename) = if request_line == \"GET / HTTP/1.1\" {\n        (\"HTTP/1.1 200 OK\", \"hello.html\")\n    } else {\n        (\"HTTP/1.1 404 NOT FOUND\", \"404.html\")\n    };\n\n    let contents = fs::read_to_string(filename).unwrap();\n    let length = contents.len();\n\n    let response =\n        format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using Nested Conditionals inside `if let` in Rust\nDESCRIPTION: This snippet uses nested conditionals inside an `if let` statement to check if a state existed in 1900. It demonstrates a more complex use case of `if let` but suggests it can become difficult to follow for complex logic.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-03-if-let.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nenum UsState {\n    Alabama,\n    Alaska,\n    // --snip--\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n}\n\nimpl UsState {\n    fn can_vote(&self) -> bool {\n        match self {\n            UsState::Alabama => true,\n            UsState::Alaska => false,\n        }\n    }\n}\n\nfn describe_coin(coin: Coin) {\n    if let Coin::Quarter(state) = coin {\n        if state.can_vote() {\n            println!(\"{} can vote!\", coin_name(coin));\n        } else {\n            println!(\"{} cannot vote!\", coin_name(coin));\n        }\n    }\n}\n\nfn coin_name(coin: Coin) -> &'static str {\n    match coin {\n        Coin::Penny => \"Penny\",\n        Coin::Nickel => \"Nickel\",\n        Coin::Dime => \"Dime\",\n        Coin::Quarter(_) => \"Quarter\",\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Destructuring and Matching Literals in Structs - Rust\nDESCRIPTION: This code shows how to destructure a struct and match literal values within a `match` expression. It matches `Point` values based on whether they lie on the x or y axis or neither. The pattern still creates an `x` or `y` variable that we can use in the code for this arm.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 0, y: 7 };\n\nmatch p {\n    Point { x: 0, y: y } => println!(\"On the y axis at {y}\"),\n    Point { x: x, y: 0 } => println!(\"On the x axis at {x}\"),\n    Point { x, y } => println!(\"On neither axis: ({x}, {y})\"),\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Screen Struct with Trait Objects in Rust\nDESCRIPTION: This code defines a `Screen` struct that holds a vector of trait objects (`Box<dyn Draw>`). This allows the `Screen` to hold different types that implement the `Draw` trait. The `Box` is used to store the types on the heap.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter18.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub struct Screen {\n    pub components: Vec<Box<dyn Draw>>,\n}\n```\n\n----------------------------------------\n\nTITLE: If Expression: Basic Conditional Execution in Rust\nDESCRIPTION: This code snippet demonstrates a basic `if` expression in Rust. It checks if the variable `number` is less than 5 and prints a corresponding message.  An `else` block provides an alternative message if the condition is false. The condition must evaluate to a boolean value.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-05-control-flow.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let number = 3;\n\n    if number < 5 {\n        println!(\"condition was true\");\n    } else {\n        println!(\"condition was false\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Submodule in Separate File - Rust\nDESCRIPTION: This code defines the `hosting` submodule, which is a submodule of `front_of_house`. The code resides in *src/front_of_house/hosting.rs*. It contains a single public function `add_to_waitlist`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_27\n\nLANGUAGE: rust\nCODE:\n```\npub fn add_to_waitlist() {}\n```\n\n----------------------------------------\n\nTITLE: Type Annotation Example in Rust\nDESCRIPTION: This code demonstrates the use of type annotations in Rust. When the compiler cannot infer the type of a variable, a type annotation is required to explicitly specify the type. In this case, the `parse` method needs a type annotation to specify which numeric type to parse the string into.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet guess: u32 = \"42\".parse().expect(\"Not a number!\");\n```\n\n----------------------------------------\n\nTITLE: Demonstrating the Problem with Index-Based String Manipulation - Rust\nDESCRIPTION: This code demonstrates the issue with using an index to represent a word within a `String`. After obtaining the index using `first_word`, the original `String` is cleared. The stored index is now invalid because the string it references no longer contains the original data. This highlights the potential for errors when managing indices independently from the string they refer to.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_24\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    let mut s = String::from(\"hello world\");\n\n    let word = first_word(&s); // word will get the value 5\n\n    s.clear(); // this empties the String, making it equal to \"\"\n\n    // `word` still has the value `5` here, but `s` no longer has any content\n    // that we could meaningfully use with the value `5`, so `word` is now\n    // totally invalid!\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Empty Vector with Type Annotation\nDESCRIPTION: This code snippet demonstrates how to create a new, empty vector that will hold values of type `i32`.  The type annotation `Vec<i32>` is necessary because no values are initially inserted, preventing Rust from inferring the intended type. Without the type annotation, the compiler will raise an error. No dependencies are required.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet v: Vec<i32> = Vec::new();\n```\n\n----------------------------------------\n\nTITLE: String Literal as a String Slice\nDESCRIPTION: This code shows that a string literal is actually a string slice (&str). It's a slice pointing to a specific point in the binary, which is why string literals are immutable.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_31\n\nLANGUAGE: Rust\nCODE:\n```\nlet s = \"Hello, world!\";\n```\n\n----------------------------------------\n\nTITLE: Unit Tests Module with #[cfg(test)] in Rust\nDESCRIPTION: This snippet shows the standard structure for unit tests in Rust. The `tests` module is annotated with `#[cfg(test)]`, which means that the code inside the module will only be compiled when running tests, saving compile time and space. The `use super::*` line brings all items from the parent module into scope.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\npub fn add(left: u64, right: u64) -> u64 {\n    left + right\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_works() {\n        let result = add(2, 2);\n        assert_eq!(result, 4);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrectly Using References in Structs without Lifetimes\nDESCRIPTION: This snippet demonstrates an example of attempting to store references in a struct without specifying lifetimes, which results in a compile-time error.  It showcases how the Rust compiler requires lifetime specifiers when structs contain references to prevent dangling pointers.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nstruct User {\n    active: bool,\n    username: &str,\n    email: &str,\n    sign_in_count: u64,\n}\n\nfn main() {\n    let user1 = User {\n        active: true,\n        username: \"someusername123\",\n        email: \"someone@example.com\",\n        sign_in_count: 1,\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Compiler Error When Directly Adding i8 and Option<i8> in Rust\nDESCRIPTION: This code snippet showcases a compiler error that occurs when trying to directly add an `i8` and an `Option<i8>`. This illustrates how Rust's type system prevents the implicit use of optional values as regular values, requiring explicit handling of the `Option` type. This example highlights Rust's approach to preventing null-related errors.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-01-defining-an-enum.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n{{\n  #rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-07-cant-use-option-directly/src/main.rs:here\n}}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Keyword Conflict in Rust\nDESCRIPTION: This example demonstrates a compilation error that occurs when attempting to use a Rust keyword (`match`) as a function identifier. The code will not compile due to this conflict, highlighting the need for raw identifiers.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-01-keywords.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn match(needle: &str, haystack: &str) -> bool {\n    haystack.contains(needle)\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Reference Scopes in Rust\nDESCRIPTION: This Rust code demonstrates how the scope of references affects borrowing rules. Because the immutable references `r1` and `r2` are only used before the mutable reference `r3` is created, the code compiles without errors. The key is that the scopes of the immutable and mutable references do not overlap.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nlet mut s = String::from(\"hello\");\n\nlet r1 = &s; // no problem\nlet r2 = &s; // no problem\nprintln!(\"{r1} and {r2}\");\n// Variables r1 and r2 will not be used after this point.\n\nlet r3 = &mut s; // no problem\nprintln!(\"{r3}\");\n```\n\n----------------------------------------\n\nTITLE: Rust Build with Compilation Errors\nDESCRIPTION: This snippet shows the output of a `cargo build` command that results in compilation errors because of attempts to call a private function. The errors highlight the privacy violation and provide the location of both the call and the function's definition.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch07-managing-growing-projects/listing-07-05/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo build\n   Compiling restaurant v0.1.0 (file:///projects/restaurant)\nerror[E0603]: function `add_to_waitlist` is private\n  --> src/lib.rs:10:37\n   |\n10 |     crate::front_of_house::hosting::add_to_waitlist();\n   |                                     ^^^^^^^^^^^^^^^ private function\n   |\nnote: the function `add_to_waitlist` is defined here\n  --> src/lib.rs:3:9\n   |\n3  |         fn add_to_waitlist() {}\n   |         ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0603]: function `add_to_waitlist` is private\n  --> src/lib.rs:13:30\n   |\n13 |     front_of_house::hosting::add_to_waitlist();\n   |                              ^^^^^^^^^^^^^^^ private function\n   |\nnote: the function `add_to_waitlist` is defined here\n  --> src/lib.rs:3:9\n   |\n3  |         fn add_to_waitlist() {}\n   |         ^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0603`.\nerror: could not compile `restaurant` (lib) due to 2 previous errors\n```\n\n----------------------------------------\n\nTITLE: Floating-Point Numbers in Rust\nDESCRIPTION: This code snippet demonstrates the use of floating-point numbers in Rust. It shows how to declare variables with `f32` and `f64` types and perform basic arithmetic operations with them.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-02-data-types.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 2.0; // f64\n\t\t\nlet y: f32 = 3.0; // f32\n```\n\n----------------------------------------\n\nTITLE: Defining a Byte String Literal\nDESCRIPTION: This code snippet shows how to define a byte string literal in Rust. Byte string literals construct an array of bytes instead of a UTF-8 string.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_60\n\nLANGUAGE: Rust\nCODE:\n```\nb\"...\"\n```\n\n----------------------------------------\n\nTITLE: Using Line Comment\nDESCRIPTION: This code snippet shows how to use a line comment in Rust. Line comments start with `//` and extend to the end of the line.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_96\n\nLANGUAGE: Rust\nCODE:\n```\n//\n```\n\n----------------------------------------\n\nTITLE: Creating a Tree with Parent and Child Nodes in Rust\nDESCRIPTION: This code creates a `leaf` node with no children and a `branch` node with the `leaf` node as one of its children. It demonstrates how to use `Rc<Node>` to share ownership of the `leaf` node between `leaf` and `branch`, allowing access to the `leaf` node from the `branch` node.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-06-reference-cycles.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse crate::Node;\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        children: RefCell::new(vec![]),\n    });\n\n    let branch = Rc::new(Node {\n        value: 5,\n        children: RefCell::new(vec![Rc::clone(&leaf)]),\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Inline Comment Example in Rust\nDESCRIPTION: This code snippet shows an inline comment in Rust, where the comment is placed at the end of a line containing code. The comment starts with `//`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let lucky_number = 7; // I'm feeling lucky today\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise AND and Assignment Operator Rust\nDESCRIPTION: This operator performs a bitwise AND operation and assigns the result to the variable. It's a shorthand for `var = var & expr`. The `BitAndAssign` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\n`var &= expr`\n```\n\n----------------------------------------\n\nTITLE: Defining the Poll Enum in Rust\nDESCRIPTION: This snippet defines the `Poll` enum, which represents the state of a future after being polled. It can either be `Ready` with a value or `Pending`, indicating that the future is not yet complete and should be polled again later.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-05-traits-for-async.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nenum Poll<T> {\n    Ready(T),\n    Pending,\n}\n```\n\n----------------------------------------\n\nTITLE: Method with Different Generic Types Than Struct Definition in Rust\nDESCRIPTION: This code showcases a method (`mixup`) using different generic types (`X2`, `Y2`) from its struct's definition (`X1`, `Y1`). It creates a new `Point` instance using the `x` value from the `self` `Point` (of type `X1`) and the `y` value from the passed-in `Point` (of type `Y2`). This illustrates the flexibility of using generics in method signatures independent of the struct's generic type parameters. The `main` function shows how the `mixup` method affects the types of the resulting `Point`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-01-syntax.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point<X1, Y1> {\n    x: X1,\n    y: Y1,\n}\n\nimpl<X1, Y1> Point<X1, Y1> {\n    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {\n        Point {\n            x: self.x,\n            y: other.y,\n        }\n    }\n}\n\nfn main() {\n    let p1 = Point { x: 5, y: 10.4 };\n    let p2 = Point { x: \"Hello\", y: 'c' };\n\n    let p3 = p1.mixup(p2);\n\n    println!(\"p3.x = {}, p3.y = {}\", p3.x, p3.y);\n}\n```\n\n----------------------------------------\n\nTITLE: Compound Type Constraint Operator Rust\nDESCRIPTION: This operator is used to specify a compound type constraint, typically in trait bounds or where clauses. It indicates that a type must implement multiple traits. This operator cannot be overloaded.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_14\n\nLANGUAGE: Rust\nCODE:\n```\n`trait + trait`\n```\n\nLANGUAGE: Rust\nCODE:\n```\n`'a + trait`\n```\n\n----------------------------------------\n\nTITLE: Defining the Main Function in Rust\nDESCRIPTION: This code snippet defines the `main` function, the entry point for every executable Rust program. The function takes no parameters and returns nothing. The curly brackets denote the function body.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n\n}\n```\n\n----------------------------------------\n\nTITLE: Example Rust Code with Mutable Variable\nDESCRIPTION: This Rust code defines a mutable variable `x` but doesn't modify it. This triggers a compiler warning, demonstrating a scenario where `rustfix` can be used to automatically fix the issue.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-04-useful-development-tools.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut x = 42;\n    println!(\"{x}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Cargo Tests\nDESCRIPTION: This snippet shows the execution of `cargo test` command in a Rust project. It compiles the project, runs unit tests, integration tests, and documentation tests, then presents the results.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/listing-11-13/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test\n Compiling adder v0.1.0 (file:///projects/adder)\n  Finished `test` profile [unoptimized + debuginfo] target(s) in 1.31s\n   Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)\n\nrunning 1 test\ntest tests::internal ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n  Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)\n\nrunning 1 test\ntest it_adds_two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n  Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Running Only Ignored Tests\nDESCRIPTION: This command shows how to run only the ignored tests using the `--ignored` flag. This is useful for running time-consuming tests separately from the main test suite. This command is passed to the test binary after the `--` separator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-02-running-tests.md#_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ cargo test -- --ignored\n```\n\n----------------------------------------\n\nTITLE: Constraining Generic Parameter with Trait\nDESCRIPTION: This code snippet shows how to constrain a generic parameter `T` to types that implement trait `U` in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_84\n\nLANGUAGE: Rust\nCODE:\n```\nT: U\n```\n\n----------------------------------------\n\nTITLE: Creating a Dangling Reference (Compile-Time Error) - Rust\nDESCRIPTION: This code attempts to create a dangling reference by returning a reference to a `String` that goes out of scope. Rust's compiler prevents this with an error, ensuring memory safety. The function `dangle` tries to return a reference to a local variable `s`, which is deallocated when the function exits. This is not allowed in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_21\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    let reference_to_nothing = dangle();\n}\n\nfn dangle() -> &String {\n    let s = String::from(\"hello\");\n\n    &s\n}\n```\n\n----------------------------------------\n\nTITLE: Comment Above Code in Rust\nDESCRIPTION: This example shows a comment placed on a separate line above the code it's annotating. This is a common practice to provide context or explanation for the code that follows.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // I'm feeling lucky today\n    let lucky_number = 7;\n}\n```\n\n----------------------------------------\n\nTITLE: Define ThreadPool Struct (Rust)\nDESCRIPTION: Defines the basic structure of the `ThreadPool` with no members. This is the simplest possible definition, intended to satisfy the compiler's initial type requirements. It introduces the `ThreadPool` type, which is essential for the program's execution, and serves as a starting point for adding functionality.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-02-multithreaded.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nstruct ThreadPool;\n```\n\n----------------------------------------\n\nTITLE: Using `if let` to Produce a Value or Return Early in Rust\nDESCRIPTION: This snippet demonstrates using `if let` to either produce a value or return early from a function.  It shows an alternative approach but highlights its potential complexity.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-03-if-let.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nenum UsState {\n    Alabama,\n    Alaska,\n    // --snip--\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n}\n\nimpl UsState {\n    fn can_vote(&self) -> bool {\n        match self {\n            UsState::Alabama => true,\n            UsState::Alaska => false,\n        }\n    }\n}\n\nfn describe_coin(coin: Coin) -> Option<String> {\n    if let Coin::Quarter(state) = coin {\n        if state.can_vote() {\n            Some(format!(\"{} can vote!\", coin_name(coin)))\n        } else {\n            return None;\n        }\n    } else {\n        None\n    }\n}\n\nfn coin_name(coin: Coin) -> &'static str {\n    match coin {\n        Coin::Penny => \"Penny\",\n        Coin::Nickel => \"Nickel\",\n        Coin::Dime => \"Dime\",\n        Coin::Quarter(_) => \"Quarter\",\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying the PATH environment variable in Windows CMD\nDESCRIPTION: Displays the value of the PATH environment variable in the Windows Command Prompt (CMD). The PATH variable contains a list of directories where the system searches for executable files.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-01-installation.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n> echo %PATH%\n```\n\n----------------------------------------\n\nTITLE: Lifetime Annotations for Dangling Reference in Rust\nDESCRIPTION: This code demonstrates how Rust uses lifetimes to prevent dangling references. It annotates the lifetimes of variables `r` and `x` with `'a` and `'b`, respectively, showing that `x`'s lifetime is shorter than `r`'s, causing a compile-time error.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-03-lifetime-syntax.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-17/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Defining and Instantiating Unit-Like Structs in Rust\nDESCRIPTION: This snippet illustrates how to define and instantiate unit-like structs in Rust. Unit-like structs don't have any fields and behave similarly to the unit type `()`. They are useful when implementing traits without needing to store data.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nstruct AlwaysEqual;\n\nfn main() {\n    let subject = AlwaysEqual;\n}\n```\n\n----------------------------------------\n\nTITLE: println! with variables and expressions - Rust\nDESCRIPTION: This snippet demonstrates how to use placeholders in the `println!` macro to print the value of a variable and the result of an expression.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter02.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nlet x = 5;\nlet y = 10;\n\nprintln!(\"x = {x} and y + 2 = {}\", y + 2);\n```\n\n----------------------------------------\n\nTITLE: Using Trait Objects to Store Different Drawable Types in Rust\nDESCRIPTION: This snippet shows how to use trait objects (`Box<dyn Draw>`) to store different types that implement the `Draw` trait in a vector. This allows the `Screen` struct to hold and draw any component that implements `Draw` without needing to know its concrete type at compile time.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-02-trait-objects.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nstruct Screen {\n    pub components: Vec<Box<dyn Draw>>,\n}\n\nimpl Screen {\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Function without Explicit Lifetime Annotations in Rust\nDESCRIPTION: This function `first_word` takes a string slice as input and returns a string slice representing the first word. It showcases how lifetime elision rules allow the compiler to infer lifetimes without explicit annotations in certain cases. The function iterates through the bytes of the string to find the first space and returns a slice up to that point.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_46\n\nLANGUAGE: rust\nCODE:\n```\nfn first_word(s: &str) -> &str {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &s[0..i];\n        }\n    }\n\n    &s[..]\n}\n```\n\n----------------------------------------\n\nTITLE: Output of Rectangles\nDESCRIPTION: This is the standard output of the program. It shows an array of `Rectangle` structs, each containing `width` and `height` fields. This output indicates that the `rectangles` program creates and prints an array of rectangle objects with specified dimensions.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch13-functional-features/listing-13-07/output.txt#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n[\n    Rectangle {\n        width: 3,\n        height: 5,\n    },\n    Rectangle {\n        width: 7,\n        height: 12,\n    },\n    Rectangle {\n        width: 10,\n        height: 1,\n    },\n]\n```\n\n----------------------------------------\n\nTITLE: Guess Struct with Swapped Panic Conditions - Rust\nDESCRIPTION: This snippet introduces a bug by swapping the bodies of the `if value < 1` and `else if value > 100` blocks within the `Guess::new` function. This allows for demonstrating how an `expected` parameter in `should_panic` catches incorrect panic messages.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-01-writing-tests.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-09-guess-with-panic-msg-bug/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Using `std::thread` APIs for `get_intervals`\nDESCRIPTION: This code snippet demonstrates how to use the `std::thread` APIs, such as `thread::spawn` and `thread::sleep`, as an alternative to the async `trpl` APIs for creating concurrent operations. It aims to show how thread-based concurrency can be used in place of async tasks, while producing the same output from the calling code. It replaces `trpl::spawn_task` and `trpl::sleep` with standard library equivalents.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-06-futures-tasks-threads.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\nuse std::time::Duration;\n\nuse futures::channel::mpsc;\nuse futures::SinkExt;\n\nfn get_intervals(tx: mpsc::Sender<usize>) {\n    thread::spawn(move || {\n        for i in 1..=10 {\n            tx.clone()\n                .send(i)\n                .await\n                .expect(\"Failed to send message\");\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Mutable String\nDESCRIPTION: This code demonstrates how to create a mutable `String` and append to it. This showcases the difference between string literals and the `String` type, which can be modified.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-01-can-mutate-string/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Tuple Declaration Rust\nDESCRIPTION: Demonstrates how to declare a tuple with different data types in Rust.  The example includes an optional type annotation specifying the types within the tuple.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let tup: (i32, f64, u8) = (500, 6.4, 1);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Iterator in Rust\nDESCRIPTION: This code snippet demonstrates how to create an iterator from a vector using the `iter()` method. The iterator `v1_iter` is created to iterate over immutable references to the elements of the vector `v1`. The iterator is lazy and requires a consuming method to produce results.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nlet v1 = vec![1, 2, 3];\n\nlet v1_iter = v1.iter();\n```\n\n----------------------------------------\n\nTITLE: Declaring a Module in lib.rs (Rust)\nDESCRIPTION: This code snippet shows how to declare the `front_of_house` module in the `src/lib.rs` file, indicating that the module's definition is located in `src/front_of_house.rs`. The `mod` keyword is used to declare the module. This code will not compile until the corresponding file is created.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-05-separating-modules-into-different-files.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmod front_of_house;\n```\n\n----------------------------------------\n\nTITLE: Lifetimes Annotation Example\nDESCRIPTION: This snippet demonstrates lifetimes of variables r and x, named 'a and 'b, respectively. It shows how the inner 'b block is smaller than the outer 'a lifetime block, illustrating the error caught by the borrow checker when r references memory with a shorter lifetime 'b.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_35\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let r;                // ---------+-- 'a\n                          //          |\n    {\n        let x = 5;        // -+-- 'b  |\n        r = &x;           //  |       |\n    }                     // -+       |\n                          //          |\n    println!(\"r: {r}\");   //          |\n}                         // ---------+\n```\n\n----------------------------------------\n\nTITLE: Compile-Time Error with String Slices\nDESCRIPTION: This Rust code snippet demonstrates a compile-time error that occurs when trying to use a string slice after the original string has been cleared. It shows that Rust prevents borrowing issues by ensuring that a mutable borrow (clear) cannot occur while there's an immutable borrow (slice) in use.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-03-slices.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-19-slice-error/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Trait Bound Syntax in Rust\nDESCRIPTION: Illustrates the trait bound syntax, which is equivalent to the `impl Trait` syntax but more verbose.  It declares a generic type parameter `T` constrained by the `Summary` trait, ensuring the `item` parameter implements `Summary`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-02-traits.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\npub fn notify<T: Summary>(item: &T) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Cargo Test Command\nDESCRIPTION: This snippet shows the execution of the `cargo test` command in a Rust project. It compiles the project and then runs both unit tests and documentation tests, providing a summary of the results.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/listing-11-08/output.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n$ cargo test\n Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n  Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s\n   Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)\n\nrunning 1 test\ntest tests::greater_than_100 - should panic ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests guessing_game\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Unresolved Import Error\nDESCRIPTION: This snippet shows the error that occurs when trying to use the `rand` crate in the `adder` crate without declaring it as a dependency in the `adder/Cargo.toml` file. This highlights the need to explicitly declare dependencies for each crate in the workspace that uses them.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-03-cargo-workspaces.md#_snippet_12\n\nLANGUAGE: console\nCODE:\n```\n$ cargo build\n  --snip--\n   Compiling adder v0.1.0 (file:///projects/add/adder)\nerror[E0432]: unresolved import `rand`\n --> adder/src/main.rs:2:5\n  |\n2 | use rand;\n  |     ^^^^ no external crate `rand`\n```\n\n----------------------------------------\n\nTITLE: Timeout Implementation with Race in Rust\nDESCRIPTION: This snippet implements the `timeout` function using `trpl::race` to race the provided future against a sleep timer. If the future completes first, it returns `Ok` with the future's output. If the timer elapses first, it returns `Err` with the timeout duration. The example also shows how to use the timeout function inside a `main` function.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_33\n\nLANGUAGE: rust\nCODE:\n```\nuse trpl::Either;\n\n// --snip--\n\nfn main() {\n    trpl::run(async {\n        let slow = async {\n            trpl::sleep(Duration::from_secs(5)).await;\n            \"Finally finished\"\n        };\n\n        match timeout(slow, Duration::from_secs(2)).await {\n            Ok(message) => println!(\"Succeeded with '{message}'\"),\n            Err(duration) => {\n                println!(\"Failed after {} seconds\", duration.as_secs())\n            }\n        }\n    });\n}\n\nasync fn timeout<F: Future>(\n    future_to_try: F,\n    max_time: Duration,\n) -> Result<F::Output, Duration> {\n    match trpl::race(future_to_try, trpl::sleep(max_time)).await {\n        Either::Left(output) => Ok(output),\n        Either::Right(_) => Err(max_time),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the add_one Crate in adder's main.rs\nDESCRIPTION: This Rust code demonstrates how to use the `add_one` function from the `add_one` crate in the `adder` binary crate. It calls the `add_one` function with a value of 10 and prints the result.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-03-cargo-workspaces.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse add_one;\n\nfn main() {\n    let num = 10;\n    println!(\"Hello, world! {} plus one is {}!\", num, add_one::add_one(num));\n}\n```\n\n----------------------------------------\n\nTITLE: Fixed Rust code after running cargo fix\nDESCRIPTION: This is the corrected Rust code after running `cargo fix`. The `mut` keyword has been removed from the variable `x`, resolving the compiler warning.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix.md#_snippet_9\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    let x = 42;\n    println!(\"{x}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Rust Library Project\nDESCRIPTION: This command creates a new Rust library project named `adder` using Cargo. The `--lib` flag specifies that it should be a library rather than an executable.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo new adder --lib\n     Created library `adder` project\n$ cd adder\n```\n\n----------------------------------------\n\nTITLE: Right-Shift Operator Rust\nDESCRIPTION: This operator performs a right-shift operation. It shifts the bits of the left operand to the right by the number of positions specified by the right operand. The `Shr` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_46\n\nLANGUAGE: Rust\nCODE:\n```\n`expr >> expr`\n```\n\n----------------------------------------\n\nTITLE: Binding Values with `@` Operator Rust\nDESCRIPTION: This code demonstrates using the `@` operator to create a variable that holds a value while also testing that value for a pattern match. The `id_variable` will hold the value of the `id` field if it's within the range `3..=7`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\nenum Message {\n    Hello { id: i32 },\n}\n\nfn main() {\n    let msg = Message::Hello { id: 5 };\n\n    match msg {\n        Message::Hello { id: id_variable @ 3..=7 } => {\n            println!(\"Found an id in range: {}\", id_variable)\n        },\n        Message::Hello { id: 10..=12 } => {\n            println!(\"Found an id in another range\")\n        },\n        Message::Hello { id } => {\n            println!(\"Found some other id: {}\", id)\n        },\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Marking an `extern` function as `safe` in Rust\nDESCRIPTION: This example shows how to mark a specific function within an `extern` block as `safe`.  This signifies that the Rust programmer asserts the foreign function is safe to call without additional `unsafe` blocks. This shifts responsibility to the programmer to ensure safety.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-01-unsafe-rust.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nextern \"C\" {\n    #[safe]\n    fn abs(input: i32) -> i32;\n}\n\nfn main() {\n    println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n}\n```\n\n----------------------------------------\n\nTITLE: Infinite Loop with 'loop' in Rust\nDESCRIPTION: This code demonstrates a basic infinite loop using the 'loop' keyword in Rust. It continuously prints \"again!\" to the console until the program is manually interrupted (e.g., with Ctrl+C).\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_32\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    loop {\n        println!(\"again!\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Awaiting Join Handle for Task Completion in Rust\nDESCRIPTION: This example shows how to use `await` with a join handle to ensure a spawned task runs to completion. It spawns a task using `trpl::spawn_task` and then awaits the returned handle. The task includes a loop that prints numbers with a delay.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-02-concurrency-with-async.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse trpl::futures::FutureExt;\n\nasync fn print_number(number: u32) {\n    println!(\"hi number {} from the second task!\", number);\n}\n\nasync fn count() {\n    for i in 1..10 {\n        print_number(i).await;\n        trpl::sleep(std::time::Duration::from_millis(500)).await;\n    }\n}\n\nfn main() {\n    trpl::run(async {\n        let handle = trpl::spawn_task(async {\n            for i in 1..10 {\n                println!(\"hi number {} from the first task!\", i);\n                trpl::sleep(std::time::Duration::from_millis(500)).await;\n            }\n        });\n        handle.await.unwrap();\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Installing mdBook Plugin\nDESCRIPTION: This command installs the `mdbook-trpl` plugin, which is used by the Rust book. It uses cargo to install the plugin from the specified path.\nSOURCE: https://github.com/rust-lang/book/blob/main/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install --locked --path packages/mdbook-trpl\n```\n\n----------------------------------------\n\nTITLE: Array Slices in Rust\nDESCRIPTION: This snippet introduces the concept of slices for arrays. It shows how to create a slice from an array, similar to string slices, by specifying a range of indices.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_34\n\nLANGUAGE: Rust\nCODE:\n```\nlet a = [1, 2, 3, 4, 5];\n\nlet slice = &a[1..3];\n\nassert_eq!(slice, &[2, 3]);\n```\n\n----------------------------------------\n\nTITLE: Sample HTML File\nDESCRIPTION: Simple HTML5 document with a heading and some text.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-01-single-threaded.md#_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Hello!</title>\n  </head>\n  <body>\n    <h1>Hello, world!</h1>\n    <p>Hi from Rust!</p>\n  </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Attempted `split_at_mut` implementation using safe Rust\nDESCRIPTION: This is an attempt to implement `split_at_mut` using only safe Rust. This code will not compile because the borrow checker cannot understand that the two slices are borrowing different parts of the original slice.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-01-unsafe-rust.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {\n    let len = slice.len();\n\n    assert!(mid <= len);\n\n    (&mut slice[..mid], &mut slice[mid..])\n}\n```\n\n----------------------------------------\n\nTITLE: Constraining Generic Type with Static Lifetime\nDESCRIPTION: This code snippet shows how to constrain a generic type `T` to contain no borrowed references other than `'static` ones in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_86\n\nLANGUAGE: Rust\nCODE:\n```\nT: 'static\n```\n\n----------------------------------------\n\nTITLE: Cargo Run Compilation Error\nDESCRIPTION: This snippet shows the output of the `cargo run` command, which results in a compilation error due to a type mismatch. Specifically, the error `E0308` indicates that a floating-point number was provided where an integer was expected. This demonstrates Rust's strict type checking at compile time.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch10-generic-types-traits-and-lifetimes/listing-10-07/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0308]: mismatched types\n --> src/main.rs:7:38\n  |\n7 |     let wont_work = Point { x: 5, y: 4.0 };\n  |                                      ^^^ expected integer, found floating-point number\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `chapter10` (bin \"chapter10\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Generic Function Definition with Explicit Sized Bound in Rust\nDESCRIPTION: This code snippet demonstrates the equivalent of the previous example but with the `Sized` trait bound explicitly declared. It shows that Rust implicitly treats generic functions as though they have a `T: Sized` bound.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-03-advanced-types.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-13-generic-implicit-sized-bound/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Using Single-Element Tuple Expression\nDESCRIPTION: This code snippet shows how to create a single-element tuple expression in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_104\n\nLANGUAGE: Rust\nCODE:\n```\n(expr,)\n```\n\n----------------------------------------\n\nTITLE: Reference Examples With/Without Lifetimes\nDESCRIPTION: This section shows how to declare references to i32 with and without lifetime parameters. It also illustrates how to declare a mutable reference with an explicit lifetime.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_39\n\nLANGUAGE: rust\nCODE:\n```\n&i32        // a reference\n&'a i32     // a reference with an explicit lifetime\n&'a mut i32 // a mutable reference with an explicit lifetime\n```\n\n----------------------------------------\n\nTITLE: Invalid Function Definition with Keyword in Rust\nDESCRIPTION: This code demonstrates an attempt to define a function named `match` which is a reserved keyword in Rust, resulting in a compilation error. It highlights the importance of using raw identifiers when naming functions with keywords.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn match(needle: &str, haystack: &str) -> bool {\n    haystack.contains(needle)\n}\n```\n\n----------------------------------------\n\nTITLE: Ownership and Unused Variable `_s` in Rust (Compile Error)\nDESCRIPTION: This code shows a compile error when using a variable prefixed with an underscore (`_s`) because the value is still moved into `_s`, preventing further use. This illustrates that `_s` still binds the value. Dependencies: None. Inputs: None. Outputs: Compile-time error.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let s = String::from(\"hello\");\n\n    let _s = s;\n\n    println!(\"{}\", s);\n}\n```\n\n----------------------------------------\n\nTITLE: Empty Main Function in Rust\nDESCRIPTION: This snippet shows an empty `main` function in Rust.  The `main` function is the entry point for all Rust executable programs. This example shows the basic structure of the function definition, including the curly braces that define the function's body.  Currently, the function does nothing.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-02-hello-world.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n\n}\n```\n\n----------------------------------------\n\nTITLE: Sharing Channel Receiver with Arc and Mutex in Rust\nDESCRIPTION: This code demonstrates how to correctly share the channel receiver among multiple `Worker` instances using `Arc` and `Mutex`. `Arc` allows multiple ownership of the receiver, while `Mutex` ensures exclusive access to the receiver when taking a job off the channel queue, preventing race conditions. This approach enables safe and concurrent access to the receiver.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{\n    sync::{mpsc, Arc, Mutex},\n    thread,\n};\n// --snip--\n\nimpl ThreadPool {\n    // --snip--\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let receiver = Arc::new(Mutex::new(receiver));\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&receiver)));\n        }\n\n        ThreadPool { workers, sender }\n    }\n\n    // --snip--\n}\n\n// --snip--\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        // --snip--\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating a lifetime error with `longest`\nDESCRIPTION: This `main` function demonstrates a common lifetime error. The `result` variable is declared outside the inner scope where `string2` is defined. When the `println!` macro is called outside the inner scope, it attempts to use `result`, which may contain a reference to `string2`, which has already been dropped. The borrow checker correctly identifies that `string2` does not live long enough, preventing a potential dangling reference.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_42\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        result = longest(string1.as_str(), string2.as_str());\n    }\n    println!(\"The longest string is {result}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Async Futures with `trpl::yield_now` for Interleaving in Rust\nDESCRIPTION: This code defines two async futures, `a` and `b`, using `trpl::yield_now` to allow operations to switch off making progress.  The `slow` function simulates work, and `trpl::yield_now().await` hands control back to the async runtime. This approach is more efficient than `trpl::sleep` for cooperative multitasking, as it avoids the overhead of timer-based delays.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_29\n\nLANGUAGE: rust\nCODE:\n```\nlet a = async {\n    println!(\"'a' started.\");\n    slow(\"a\", 30);\n    trpl::yield_now().await;\n    slow(\"a\", 10);\n    trpl::yield_now().await;\n    slow(\"a\", 20);\n    trpl::yield_now().await;\n    println!(\"'a' finished.\");\n};\n\nlet b = async {\n    println!(\"'b' started.\");\n    slow(\"b\", 75);\n    trpl::yield_now().await;\n    slow(\"b\", 10);\n    trpl::yield_now().await;\n    slow(\"b\", 15);\n    trpl::yield_now().await;\n    slow(\"b\", 35);\n    trpl::yield_now().await;\n    println!(\"'b' finished.\");\n};\n```\n\n----------------------------------------\n\nTITLE: Right-Exclusive Range Literal Operator Rust\nDESCRIPTION: This operator creates a right-exclusive range. The range includes the starting value and excludes the ending value. The `PartialOrd` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_25\n\nLANGUAGE: Rust\nCODE:\n```\n`..`\n```\n\nLANGUAGE: Rust\nCODE:\n```\n`expr..`\n```\n\nLANGUAGE: Rust\nCODE:\n```\n`..expr`\n```\n\nLANGUAGE: Rust\nCODE:\n```\n`expr..expr`\n```\n\n----------------------------------------\n\nTITLE: Function Accepting an Enum in Rust\nDESCRIPTION: This code defines a function `route` that accepts an `IpAddrKind` enum as a parameter.  It is a simple function demonstrating how to use the enum as a type in a function signature. Requires the `IpAddrKind` enum to be defined.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn route(ip_kind: IpAddrKind) {}\n```\n\n----------------------------------------\n\nTITLE: Inclusive Range Pattern Operator (Deprecated) Rust\nDESCRIPTION: This operator was used to define inclusive range patterns in match statements.  It has been deprecated in favor of the `..=` operator. This operator cannot be overloaded.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_29\n\nLANGUAGE: Rust\nCODE:\n```\n`expr...expr`\n```\n\n----------------------------------------\n\nTITLE: Defining an Async Function\nDESCRIPTION: Defines an async function `page_title` that fetches the HTML content from a given URL and extracts the title element using the `trpl` crate for HTTP requests and HTML parsing. It uses `await` to handle asynchronous operations. Dependencies include the `trpl` crate and requires an HTML page URL as input. The function returns an `Option<String>` representing the title, or `None` if no title is found.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse trpl::Html;\n\nasync fn page_title(url: &str) -> Option<String> {\n    let response = trpl::get(url).await;\n    let response_text = response.text().await;\n    Html::parse(&response_text)\n        .select_first(\"title\")\n        .map(|title_element| title_element.inner_html())\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo Run Compilation\nDESCRIPTION: This snippet shows the output of the `cargo run` command, which results in a compilation error (E0515) because the code attempts to return a reference to a local variable. The error message explains that the `result` variable, owned by the current function, is being borrowed and returned as a reference, but `result` will be dropped when the function exits, leading to a dangling reference.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch10-generic-types-traits-and-lifetimes/no-listing-09-unrelated-lifetime/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0515]: cannot return value referencing local variable `result`\n  --> src/main.rs:11:5\n   |\n11 |     result.as_str()\n   |     ------^^^^^^^^^\n   |     |\n   |     returns a value referencing data owned by the current function\n   |     `result` is borrowed here\n\nFor more information about this error, try `rustc --explain E0515`.\nerror: could not compile `chapter10` (bin \"chapter10\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Floating-Point Declaration Rust\nDESCRIPTION: Demonstrates the declaration of floating-point variables in Rust using `f64` (default) and `f32` types. It initializes variables `x` and `y` with floating-point values.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = 2.0; // f64\n\n    let y: f32 = 3.0; // f32\n}\n```\n\n----------------------------------------\n\nTITLE: Simulating a Slow Request in Rust\nDESCRIPTION: This code snippet demonstrates how to simulate a slow request in a Rust web server by pausing the thread for 5 seconds using `thread::sleep`. This is done within the `handle_connection` function when a request to `/sleep` is received. This allows observation of how a slow request affects other requests.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n    thread,\n    time::Duration,\n};\n// --snip--\n\nfn handle_connection(mut stream: TcpStream) {\n    // --snip--\n\n    let (status_line, filename) = match &request_line[..] {\n        \"GET / HTTP/1.1\" => (\"HTTP/1.1 200 OK\", \"hello.html\"),\n        \"GET /sleep HTTP/1.1\" => {\n            thread::sleep(Duration::from_secs(5));\n            (\"HTTP/1.1 200 OK\", \"hello.html\")\n        }\n        _ => (\"HTTP/1.1 404 NOT FOUND\", \"404.html\"),\n    };\n\n    // --snip--\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Producers via Cloning in Rust\nDESCRIPTION: This code snippet showcases how to create multiple producer threads that send values to a single receiver using channels. It clones the transmitter to create multiple transmitters and spawns two threads, each sending its own set of messages to the same receiver.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter16.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n    // --snip--\n\n    let (tx, rx) = mpsc::channel();\n\n    let tx1 = tx.clone();\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx1.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"more\"),\n            String::from(\"messages\"),\n            String::from(\"for\"),\n            String::from(\"you\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!(\"Got: {received}\");\n    }\n\n    // --snip--\n```\n\n----------------------------------------\n\nTITLE: Handling Result with Expect in Rust\nDESCRIPTION: This code snippet demonstrates how to handle a `Result` value returned by the `read_line` method using the `expect` method. If the `Result` is an `Err`, the program will crash and display the given message. If it's `Ok`, it returns the value the `Ok` variant holds.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nio::stdin().read_line(&mut guess).expect(\"Failed to read line\");\n```\n\n----------------------------------------\n\nTITLE: Match Arm with Multiple Lines in Rust\nDESCRIPTION: This code snippet demonstrates using curly brackets to execute multiple lines of code within a `match` arm. It prints \"Lucky penny!\" when the `Coin::Penny` variant is matched, and then returns the value `1`. It shows how to execute more complex logic within a `match` arm.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-02-match.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => {\n            println!(\"Lucky penny!\");\n            1\n        },\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter => 25,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Yanking a Crate Version\nDESCRIPTION: This snippet shows how to yank a specific version of a crate using `cargo yank`. Yanking prevents new projects from depending on the version, but allows existing projects to continue using it.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo yank --vers 1.0.1\n    Updating crates.io index\n        Yank guessing_game@1.0.1\n```\n\n----------------------------------------\n\nTITLE: Ownership and Channels in Rust\nDESCRIPTION: This snippet demonstrates how Rust's ownership system prevents data races when using channels. Attempting to use the `val` variable after sending it through the channel results in a compile-time error because the `send` function takes ownership of its parameter.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter16.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        tx.send(val).unwrap();\n        println!(\"val is {val}\");\n    });\n\n    let received = rx.recv().unwrap();\n    println!(\"Got: {received}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Recursive Enum (Cons List) in Rust\nDESCRIPTION: This code snippet attempts to use the previously defined `List` enum to store a list of `i32` values (1, 2, 3). It imports the `Cons` and `Nil` variants and creates a `List` using nested `Cons` calls. This snippet, when compiled with the initial `List` definition, will result in a compilation error due to the infinite size of the recursive type.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1, Cons(2, Cons(3, Nil)));\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating over Bytes in a String\nDESCRIPTION: This code snippet demonstrates how to iterate over raw bytes in a string using the `bytes()` method. This method returns an iterator of `u8` values, representing each byte of the string's UTF-8 encoding.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-02-strings.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(unused)]\nfn main() {\nfor b in \"\".bytes() {\n    println!(\"{b}\");\n}\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Public Function in a Public Module in Rust\nDESCRIPTION: This snippet demonstrates how to declare both a public module named `hosting` and a public function `add_to_waitlist` within that module using the `pub` keyword. This allows external code to access and call the `add_to_waitlist` function. The module `front_of_house` is implicitly private.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Less Than or Equal To Comparison Operator Rust\nDESCRIPTION: This operator performs a less than or equal to comparison. It returns `true` if the left operand is less than or equal to the right operand, and `false` otherwise. The `PartialOrd` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_40\n\nLANGUAGE: Rust\nCODE:\n```\n`expr <= expr`\n```\n\n----------------------------------------\n\nTITLE: Define ThreadPool Struct - Rust\nDESCRIPTION: This code defines a basic `ThreadPool` struct. It serves as a starting point for creating a thread pool implementation in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\npub struct ThreadPool;\n```\n\n----------------------------------------\n\nTITLE: Printing Values with Placeholders in Rust\nDESCRIPTION: This snippet shows how to print values using placeholders in Rust's `println!` macro. It demonstrates printing both variables and the result of evaluating expressions.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 5;\nlet y = 10;\n\nprintln!(\"x = {x} and y + 2 = {}\", y + 2);\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error: Unspecified Implementation Type\nDESCRIPTION: This snippet showcases a Rust compilation error (E0790) that occurs when attempting to call an associated function on a trait without specifying the implementing type. It highlights the error message from the compiler and suggests a solution by using the fully-qualified path to the implementation.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch20-advanced-features/listing-20-21/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n Compiling traits-example v0.1.0 (file:///projects/traits-example)\nerror[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type\n  --> src/main.rs:20:43\n   |\n2  |     fn baby_name() -> String;\n   |     ------------------------- `Animal::baby_name` defined here\n...\n20 |     println!(\"A baby dog is called a {}\", Animal::baby_name());\n   |                                           ^^^^^^^^^^^^^^^^^^^ cannot call associated function of trait\n   |\nhelp: use the fully-qualified path to the only available implementation\n   |\n20 |     println!(\"A baby dog is called a {}\", <Dog as Animal>::baby_name());\n   |                                           +++++++       +\n\nFor more information about this error, try `rustc --explain E0790`.\nerror: could not compile `traits-example` (bin \"traits-example\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Using Parent Module Path\nDESCRIPTION: This code snippet demonstrates the usage of a path relative to the parent of the current module in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_70\n\nLANGUAGE: Rust\nCODE:\n```\nsuper::path\n```\n\n----------------------------------------\n\nTITLE: Constraining Generic Type with Lifetime\nDESCRIPTION: This code snippet demonstrates how to constrain a generic type `T` to outlive lifetime `'a` in Rust. This ensures that the type does not contain references with shorter lifetimes than `'a`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_85\n\nLANGUAGE: Rust\nCODE:\n```\nT: 'a\n```\n\n----------------------------------------\n\nTITLE: Fixed-Size Array Syntax Operator Rust\nDESCRIPTION: This operator is part of the syntax for defining fixed-size arrays. It is used to create an array with a specific number of elements initialized with a default value. This operator cannot be overloaded.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_36\n\nLANGUAGE: Rust\nCODE:\n```\n`[...; len]`\n```\n\n----------------------------------------\n\nTITLE: Closure Type Annotations\nDESCRIPTION: This example shows how to add optional type annotations to closure parameters and return values.  It defines a closure with explicit types, similar to function definitions, for increased clarity.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-01-closures.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-02/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Function with Printing and Tests - Rust\nDESCRIPTION: This code defines a function `prints_and_returns_10` that prints its input and returns 10. It also includes two tests: one that passes and one that fails, demonstrating how Rust captures standard output during testing.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nfn prints_and_returns_10(a: i32) -> i32 {\n    println!(\"I got the value {a}\");\n    10\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn this_test_will_pass() {\n        let value = prints_and_returns_10(4);\n        assert_eq!(value, 10);\n    }\n\n    #[test]\n    fn this_test_will_fail() {\n        let value = prints_and_returns_10(8);\n        assert_eq!(value, 5);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Ambiguous `..` Usage Rust\nDESCRIPTION: This code illustrates an example of using `..` ambiguously in a tuple match, which will result in a compile error. Rust cannot determine how many values to ignore before matching a value with `second` and then how many further values to ignore thereafter.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (.., second, ..) => {\n            println!(\"Some numbers: {:?}\", second);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Tuple Type Mismatch Error\nDESCRIPTION: This code snippet demonstrates a Rust compilation error due to assigning a tuple with three elements to a variable expecting a tuple with two elements. The `cargo run` command attempts to compile and execute the `patterns` project, but the type mismatch in the `src/main.rs` file causes a compilation error.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch19-patterns-and-matching/listing-19-05/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet (x, y) = (1, 2, 3);\n```\n\n----------------------------------------\n\nTITLE: Using Inner Block Doc Comment\nDESCRIPTION: This code snippet illustrates the use of an inner block doc comment in Rust. Inner block doc comments are enclosed in `/*!` and `*/`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_100\n\nLANGUAGE: Rust\nCODE:\n```\n/*!...*/\n```\n\n----------------------------------------\n\nTITLE: Adding a Dependency in Cargo.toml\nDESCRIPTION: This is an example `Cargo.toml` snippet that demonstrates how to add an external package (rand) as a dependency to a Rust project.  Adding the dependency enables the project to use the `rand` crate and its functionality.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nrand = \"0.8.5\"\n```\n\n----------------------------------------\n\nTITLE: Multiple Producers Asynchronous Channel Rust\nDESCRIPTION: This snippet demonstrates creating an asynchronous channel and sending messages from multiple producer futures. It clones the transmitter `tx` to create `tx1`, allowing concurrent message sending from different async blocks.  Each producer sends a series of messages with delays, and a receiver future consumes these messages.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nlet (tx, mut rx) = trpl::channel();\n\n        let tx1 = tx.clone();\n        let tx1_fut = async move {\n            let vals = vec![\n                String::from(\"hi\"),\n                String::from(\"from\"),\n                String::from(\"the\"),\n                String::from(\"future\"),\n            ];\n\n            for val in vals {\n                tx1.send(val).unwrap();\n                trpl::sleep(Duration::from_millis(500)).await;\n            }\n        };\n\n        let rx_fut = async {\n            while let Some(value) = rx.recv().await {\n                println!(\"received '{value}'\");\n            }\n        };\n\n        let tx_fut = async move {\n            let vals = vec![\n                String::from(\"more\"),\n                String::from(\"messages\"),\n                String::from(\"for\"),\n                String::from(\"you\"),\n            ];\n\n            for val in vals {\n                tx.send(val).unwrap();\n                trpl::sleep(Duration::from_millis(1500)).await;\n            }\n        };\n\n        trpl::join3(tx1_fut, tx_fut, rx_fut).await;\n```\n\n----------------------------------------\n\nTITLE: Reference Count Demonstration with Rc<T> Rust\nDESCRIPTION: This code snippet demonstrates how the reference count of an `Rc<T>` changes as references are created and go out of scope. It uses `Rc::strong_count` to print the reference count at various points in the program. It shows that cloning an `Rc<T>` increments the reference count and that the reference count is automatically decremented when an `Rc<T>` value goes out of scope. This example shows a nested scope for variable `c` to demonstrate the drop behavior.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil))))));\n    println!(\"count after creating a = {}\", Rc::strong_count(&a));\n    let b = Cons(3, Rc::clone(&a));\n    println!(\"count after creating b = {}\", Rc::strong_count(&a));\n    {\n        let c = Cons(4, Rc::clone(&a));\n        println!(\"count after creating c = {}\", Rc::strong_count(&a));\n    }\n    println!(\"count after c goes out of scope = {}\", Rc::strong_count(&a));\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Library Crate to Workspace Definition\nDESCRIPTION: Updates the workspace's `Cargo.toml` to include the `add_one` library crate as a member. This involves adding \"add_one\" to the `members` list. This makes `add_one` part of the workspace.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_16\n\nLANGUAGE: TOML\nCODE:\n```\n[workspace]\nresolver = \"2\"\nmembers = [\"adder\", \"add_one\"]\n```\n\n----------------------------------------\n\nTITLE: Separating Send and Receive into Async Blocks in Rust (Incomplete)\nDESCRIPTION: This code separates the sending and receiving of messages into separate async blocks using `trpl::join` to achieve concurrency. However, the program still doesn't terminate because the receiver waits indefinitely.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-02-concurrency-with-async.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse trpl::sleep;\n\nasync fn futures() {\n    let (tx, rx) = trpl::channel();\n\n    let vals = [\"first\", \"second\", \"third\", \"fourth\"];\n\n    trpl::join(\n        async {\n            for val in vals {\n                println!(\"sending {}\", val);\n                tx.send(val).await;\n                sleep(0.5).await;\n            }\n        },\n        async {\n            while let Some(msg) = rx.recv().await {\n                println!(\"received {}\", msg);\n            }\n        },\n    )\n    .await;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Unsafe `split_at_mut` implementation in Rust\nDESCRIPTION: This example shows how to implement the `split_at_mut` function using unsafe Rust code. It uses raw pointers and the `slice::from_raw_parts_mut` function to create the two slices.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-01-unsafe-rust.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse std::slice;\n\nfn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {\n    let len = slice.len();\n    let ptr = slice.as_mut_ptr();\n\n    assert!(mid <= len);\n\n    unsafe {\n        (slice::from_raw_parts_mut(ptr, mid),\n         slice::from_raw_parts_mut(ptr.add(mid), len - mid))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Constraining Generic Lifetime\nDESCRIPTION: This code snippet illustrates how to specify that a generic lifetime `'b` must outlive lifetime `'a` in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_87\n\nLANGUAGE: Rust\nCODE:\n```\n'b: 'a\n```\n\n----------------------------------------\n\nTITLE: Declaring the `garden` module\nDESCRIPTION: This code snippet declares the `garden` module. It indicates that the compiler should look for the module's code in either `src/garden.rs` or `src/garden/mod.rs`. Making it public with `pub mod` exposes the module to external code.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub mod garden;\n```\n\n----------------------------------------\n\nTITLE: Running cargo check\nDESCRIPTION: This snippet shows the command `cargo check` used to check a Rust project. It ensures that the code compiles without producing an executable. The output displays the project being checked and the compilation status.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch21-web-server/no-listing-03-define-execute/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo check\n  Checking hello v0.1.0 (file:///projects/hello)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.24s\n```\n\n----------------------------------------\n\nTITLE: String Scope Example in Rust\nDESCRIPTION: This example demonstrates how Rust automatically manages the memory allocated for a `String` when the variable goes out of scope. The `drop` function is automatically called, freeing the allocated memory.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n{\n    let s = String::from(\"hello\"); // s is valid from this point forward\n\n    // do stuff with s\n}                                  // this scope is now over, and s is no\n                                   // longer valid\n```\n\n----------------------------------------\n\nTITLE: Cargo Test Execution - Bash\nDESCRIPTION: This bash command executes all tests in the project, including unit tests, integration tests, and doctests. The output shows the results for each category, indicating the number of tests run, passed, failed, ignored, etc.  It demonstrates the typical output when all tests pass.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.31s\n     Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)\n\nrunning 1 test\ntest tests::internal ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)\n\nrunning 1 test\ntest it_adds_two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error: Mismatched Types\nDESCRIPTION: This snippet shows a compilation error in a Rust program related to mismatched types. Specifically, it indicates that the `cmp` method expected a reference to a `String` but received a reference to an integer. This error occurs because the user input (`guess`) is likely a String, while the secret number is an integer, and direct comparison requires compatible types.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch02-guessing-game-tutorial/listing-02-04/output.txt#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nerror[E0308]: mismatched types\n  --> src/main.rs:23:21\n   |\n23 |     match guess.cmp(&secret_number) {\n   |                 --- ^^^^^^^^^^^^^^ expected `&String`, found `&{integer}`\n   |                 |\n   |                 arguments to this method are incorrect\n   |\n   = note: expected reference `&String`\n              found reference `&{integer}`\nnote: method defined here\n  --> /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/core/src/cmp.rs:964:8\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `guessing_game` (bin \"guessing_game\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Workspace Cargo.toml with Two Crates\nDESCRIPTION: This TOML code shows the `Cargo.toml` file after adding both the `adder` and `add_one` packages. The `members` array now includes both package names.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-03-cargo-workspaces.md#_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[workspace]\nmembers = [\n    \"adder\",\n    \"add_one\",\n]\nresolver = \"3\"\n```\n\n----------------------------------------\n\nTITLE: Creating Workspace Directory\nDESCRIPTION: Creates a new directory for the Rust workspace and navigates into it. This is the first step in setting up a Cargo workspace.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_12\n\nLANGUAGE: Shell\nCODE:\n```\n$ mkdir add\n$ cd add\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation for macOS in Rust\nDESCRIPTION: This snippet demonstrates how to conditionally include a function in a Rust program only when compiling for macOS. The `#[cfg(target_os = \"macos\")]` attribute ensures that the `macos_only` function is only included in the build when the target operating system is macOS.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/conditional-compilation.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// The function is only included in the build when compiling for macOS\n#[cfg(target_os = \"macos\")]\nfn macos_only() {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo Run Command in Console\nDESCRIPTION: This console snippet shows the output of running `cargo run`. It demonstrates compiling and running a rust program, including the output of the secret number and the user input.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_18\n\nLANGUAGE: console\nCODE:\n```\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s\n     Running `target/debug/guessing_game`\nGuess the number!\nThe secret number is: 7\nPlease input your guess.\n4\nYou guessed: 4\n\n$ cargo run\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s\n     Running `target/debug/guessing_game`\nGuess the number!\nThe secret number is: 83\nPlease input your guess.\n5\nYou guessed: 5\n```\n\n----------------------------------------\n\nTITLE: Tuple Indexing Operator Rust\nDESCRIPTION: This operator is used to access elements of a tuple by their index. The index must be a non-negative integer literal. This operator cannot be overloaded.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_24\n\nLANGUAGE: Rust\nCODE:\n```\n`expr.0`\n```\n\nLANGUAGE: Rust\nCODE:\n```\n`expr.1`\n```\n\n----------------------------------------\n\nTITLE: Implementing methods for encapsulated data management in Rust\nDESCRIPTION: This code implements methods for the `AveragedCollection` struct. `add` adds a value, `remove` removes a value, `average` returns the average, and `update_average` recalculates the average. Only `add`, `remove`, and `average` are public, ensuring external code cannot directly modify the `list` or `average` and keeping the `average` consistent with `list`'s content.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter18.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimpl AveragedCollection {\n    pub fn add(&mut self, value: i32) {\n        self.list.push(value);\n        self.update_average();\n    }\n\n    pub fn remove(&mut self) -> Option<i32> {\n        let result = self.list.pop();\n        match result {\n            Some(value) => {\n                self.update_average();\n                Some(value)\n            }\n            None => None,\n        }\n    }\n\n    pub fn average(&self) -> f64 {\n        self.average\n    }\n\n    fn update_average(&mut self) {\n        let total: i32 = self.list.iter().sum();\n        self.average = total as f64 / self.list.len() as f64;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Shoes by Size with Closures in Rust\nDESCRIPTION: This code snippet defines a `Shoe` struct and a `shoes_in_size` function that uses the `filter` iterator adapter with a closure to return only shoes of a specified size. The closure captures the `shoe_size` variable from its environment.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(PartialEq, Debug)]\nstruct Shoe {\n    size: u32,\n    style: String,\n}\n\nfn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {\n    shoes.into_iter().filter(|s| s.size == shoe_size).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn filters_by_size() {\n        let shoes = vec![\n            Shoe {\n                size: 10,\n                style: String::from(\"sneaker\"),\n            },\n            Shoe {\n                size: 13,\n                style: String::from(\"sandal\"),\n            },\n            Shoe {\n                size: 10,\n                style: String::from(\"boot\"),\n            },\n        ];\n\n        let in_my_size = shoes_in_size(shoes, 10);\n\n        assert_eq!(\n            in_my_size,\n            vec![\n                Shoe {\n                    size: 10,\n                    style: String::from(\"sneaker\")\n                },\n                Shoe {\n                    size: 10,\n                    style: String::from(\"boot\")\n                },\n            ]\n        );\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Thread with spawn in Rust\nDESCRIPTION: This code snippet demonstrates how to create a new thread using `thread::spawn` in Rust. It spawns a new thread that prints numbers from 1 to 9 and sleeps for a short duration between each print. The main thread also prints numbers from 1 to 4 and sleeps. The purpose is to illustrate basic thread creation and execution in Rust and show how threads can run concurrently. The `std::thread` and `std::time::Duration` are required dependencies.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter16.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {i} from the spawned thread!\");\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!(\"hi number {i} from the main thread!\");\n        thread::sleep(Duration::from_millis(1));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing rustup on Linux/macOS\nDESCRIPTION: Downloads and executes the rustup installation script, which installs the latest stable version of Rust. Requires an internet connection. The command pipes the output of curl to sh for execution.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\n```\n\n----------------------------------------\n\nTITLE: Matching Literals in Rust\nDESCRIPTION: This code demonstrates matching literal values in a `match` expression. It compares the value of `x` to literal values and executes the corresponding arm. This allows specific actions based on concrete values.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 1;\n\nmatch x {\n    1 => println!(\"one\"),\n    2 => println!(\"two\"),\n    3 => println!(\"three\"),\n    _ => println!(\"anything\"),\n}\n```\n\n----------------------------------------\n\nTITLE: Array Slices in Rust\nDESCRIPTION: This snippet demonstrates how to create a slice from an array in Rust. An array slice provides a way to refer to a portion of an array, similar to how string slices work with strings. It creates a slice of `i32` values, storing a reference to the first element and a length.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-03-slices.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nlet a = [1, 2, 3, 4, 5];\n\nlet slice = &a[1..3];\n\nassert_eq!(slice, &[2, 3]);\n```\n\n----------------------------------------\n\nTITLE: Adding Break Statement for Correct Guess in Rust\nDESCRIPTION: This code snippet shows how to exit the game loop when the user guesses the correct number by using the `break` statement inside the `Ordering::Equal` arm of the `match` expression. This allows the program to terminate gracefully after a successful guess.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter02.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n        // --snip--\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less => println!(\"Too small!\"),\n            Ordering::Greater => println!(\"Too big!\"),\n            Ordering::Equal => {\n                println!(\"You win!\");\n                break;\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Tuple Destructuring\nDESCRIPTION: This code illustrates an attempt to destructure a tuple with three elements into a pattern with only two variables. This mismatch in the number of elements results in a compiler error because the types do not match.  This example highlights the importance of matching the number of elements in the pattern to the structure being destructured.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-01-all-the-places-for-patterns.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let (x, y) = (1, 2, 3);\n\n    println!(\"x = {}\", x);\n    println!(\"y = {}\", y);\n}\n```\n\n----------------------------------------\n\nTITLE: println! placeholder example - Rust\nDESCRIPTION: This snippet demonstrates how to use placeholders in the `println!` macro to print the value of a variable.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter02.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n    println!(\"You guessed: {guess}\");\n```\n\n----------------------------------------\n\nTITLE: Destructuring Nested Enums Rust\nDESCRIPTION: This code demonstrates destructuring of nested enums. It defines an enum `Color` with `Rgb` and `Hsv` variants, and a `Message` enum that includes a `ChangeColor` variant that holds a `Color` enum. The `match` statement in `main` destructures both the `Message` and the nested `Color` enum to print color values based on the inner enum's type. It uses nested patterns to match specific enum variants.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nenum Color {\n    Rgb(i32, i32, i32),\n    Hsv(i32, i32, i32),\n}\n\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(Color),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));\n\n    match msg {\n        Message::ChangeColor(Color::Rgb(r, g, b)) => {\n            println!(\"Change color to red {r}, green {g}, and blue {b}\");\n        }\n        Message::ChangeColor(Color::Hsv(h, s, v)) => {\n            println!(\"Change color to hue {h}, saturation {s}, value {v}\");\n        }\n        _ => (),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Function with Trait Bounds and Lifetimes in Rust\nDESCRIPTION: This code defines a generic function `longest_with_an_announcement` that takes two string slices with a lifetime `'a` and a generic type `T` that implements the `Display` trait. It returns the longer of the two string slices. The function also prints an announcement using the provided generic parameter `ann`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_52\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt::Display;\n\nfn longest_with_an_announcement<'a, T>(\n    x: &'a str,\n    y: &'a str,\n    ann: T,\n) -> &'a str\nwhere\n    T: Display,\n{\n    println!(\"Announcement! {ann}\");\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Recursive Enum (Cons List) in Rust (Fails)\nDESCRIPTION: This code attempts to define a recursive enum, `List`, representing a cons list of i32 values. It includes two variants: `Cons`, which holds an i32 value and another `List`, and `Nil`, which represents the end of the list.  This code does not compile because Rust cannot determine the size of the recursive `List` type at compile time.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-01-box.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nenum List {\n    Cons(i32, List),\n    Nil,\n}\n```\n\n----------------------------------------\n\nTITLE: Using the dbg! macro for debugging in Rust\nDESCRIPTION: This code snippet shows how to use the `dbg!` macro to print the value of an expression to the standard error stream (`stderr`). The `dbg!` macro takes ownership of the expression, prints its value along with the file and line number, and returns ownership of the value.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-02-example-structs.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-05-dbg-macro/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Audio Decoding with Iterator Chain in Rust\nDESCRIPTION: This code snippet demonstrates an iterator chain used in an audio decoder to perform linear prediction. It iterates through coefficients, pairs them with previous buffer values using `zip`, multiplies corresponding values, sums the results, and shifts the bits. The result is then used to update buffer values.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_24\n\nLANGUAGE: Rust\nCODE:\n```\nlet buffer: &mut [i32];\nlet coefficients: [i64; 12];\nlet qlp_shift: i16;\n\nfor i in 12..buffer.len() {\n    let prediction = coefficients.iter()\n                                 .zip(&buffer[i - 12..i])\n                                 .map(|(&c, &s)| c * s as i64)\n                                 .sum::<i64>() >> qlp_shift;\n    let delta = buffer[i];\n    buffer[i] = prediction as i32 + delta;\n}\n```\n\n----------------------------------------\n\nTITLE: Cons List Definition with RefCell\nDESCRIPTION: Defines a cons list using `Rc` and `RefCell` to allow modification of the list a `Cons` variant points to. The `tail` method provides convenient access to the second item of a `Cons` variant.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nenum List {\n    Cons(i32, RefCell<Rc<List>>>),\n    Nil,\n}\n\nimpl List {\n    fn tail(&self) -> Option<&RefCell<Rc<List>>> {\n        match self {\n            Cons(_, item) => Some(item),\n            Nil => None,\n        }\n    }\n}\n\nfn main() {}\n```\n\n----------------------------------------\n\nTITLE: Using Relative Path\nDESCRIPTION: This code snippet shows the usage of a relative path in Rust.  It's a path relative to the current module.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_69\n\nLANGUAGE: Rust\nCODE:\n```\nself::path\n```\n\n----------------------------------------\n\nTITLE: Basic Rust Test Function with Assertion\nDESCRIPTION: This code snippet shows a simple Rust test function inside a `tests` module. The `#[test]` attribute marks the function as a test. The `assert_eq!` macro checks if the result of `add(2, 2)` is equal to 4. It uses `super::*` to bring the `add` function into scope within the `tests` module.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\npub fn add(left: u64, right: u64) -> u64 {\n    left + right\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_works() {\n        let result = add(2, 2);\n        assert_eq!(result, 4);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Point Struct with Multiple Generic Types Rust\nDESCRIPTION: This struct defines a `Point` with `x` and `y` coordinates of potentially different generic types `T` and `U`. This allows for the `x` and `y` fields to have different types. It shows examples of creating instances with both integer, float, and mixed types.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point<T, U> {\n    x: T,\n    y: U,\n}\n\nfn main() {\n    let both_integer = Point { x: 5, y: 10 };\n    let both_float = Point { x: 1.0, y: 4.0 };\n    let integer_and_float = Point { x: 5, y: 4.0 };\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Borrow Error - Moved Mutex\nDESCRIPTION: This snippet shows a common Rust error where a Mutex is moved into a closure within a loop.  The `counter` Mutex is moved into the `thread::spawn` closure during each iteration, causing a borrow-after-move error when trying to access `counter` outside the loop. The error `E0382` indicates that the `counter` variable, which is a `Mutex<i32>`, has been moved, and cannot be borrowed afterwards.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch16-fearless-concurrency/listing-16-13/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nerror[E0382]: borrow of moved value: `counter`\n  --> src/main.rs:21:29\n   |\n5  |     let counter = Mutex::new(0);\n   |         ------- move occurs because `counter` has type `Mutex<i32>`, which does not implement the `Copy` trait\n...\n8  |     for _ in 0..10 {\n   |     -------------- inside of this loop\n9  |         let handle = thread::spawn(move || {\n   |                                    ------- value moved into closure here, in previous iteration of loop\n...\n21 |     println!(\"Result: {}\", *counter.lock().unwrap());\n   |                             ^^^^^^^ value borrowed here after move\n   |\nhelp: consider moving the expression out of the loop so it is only moved once\n   |\n8  ~     let mut value = counter.lock();\n9  ~     for _ in 0..10 {\n10 |         let handle = thread::spawn(move || {\n11 ~             let mut num = value.unwrap();\n   |\n```\n\n----------------------------------------\n\nTITLE: Function-like macro example\nDESCRIPTION: This code snippet demonstrates the usage of a function-like macro in Rust. The `sql!` macro is used to embed an SQL query directly into the Rust code. The macro will parse the SQL statement and perform necessary checks.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-05-macros.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nlet sql = sql!(SELECT * FROM posts WHERE id=1);\n```\n\n----------------------------------------\n\nTITLE: Type Annotation in Rust\nDESCRIPTION: This code snippet demonstrates type annotation in Rust. It shows how to explicitly specify the data type of a variable when the compiler cannot infer it automatically, specifically when parsing a string to a numeric type.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-02-data-types.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet guess: u32 = \"42\".parse().expect(\"Not a number!\");\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Remainder Operator Rust\nDESCRIPTION: This operator calculates the remainder of an arithmetic division. It returns the remaining value after dividing the left operand by the right operand. The `Rem` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n`expr % expr`\n```\n\n----------------------------------------\n\nTITLE: Incomplete Match Expression Demonstrating Exhaustiveness Requirement in Rust\nDESCRIPTION: This code demonstrates the exhaustiveness requirement of `match` expressions in Rust. The `plus_one` function attempts to match on an `Option<i32>` but only handles the `Some` case, causing a compile-time error because the `None` case is not covered.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\n    fn plus_one(x: Option<i32>) -> Option<i32> {\n        match x {\n            Some(i) => Some(i + 1),\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Aligning Stream Types Before Merging in Rust\nDESCRIPTION: This snippet demonstrates how to align the types of two streams before merging. It uses the `map` helper method to convert the `intervals` stream to a stream of strings and applies a timeout to match the `messages` stream's type. Finally, the merged stream is pinned for safe iteration.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_42\n\nLANGUAGE: Rust\nCODE:\n```\nlet messages = get_messages().timeout(Duration::from_millis(200));\n        let intervals = get_intervals()\n            .map(|count| format!(\"Interval: {count}\"))\n            .timeout(Duration::from_secs(10));\n        let merged = messages.merge(intervals);\n        let mut stream = pin!(merged);\n```\n\n----------------------------------------\n\nTITLE: Redirecting standard output to a file\nDESCRIPTION: This command demonstrates how to redirect the standard output of a Rust program to a file named `output.txt`. If the program encounters an error, the error message will be written to this file instead of being displayed on the console, revealing the current behavior of directing errors to stdout.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-06-writing-to-stderr-instead-of-stdout.md#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ cargo run > output.txt\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream from a Receiver in Rust\nDESCRIPTION: This code snippet demonstrates how to create a stream from a `Receiver` using `ReceiverStream`. It creates an async channel, sends messages through the channel, and then converts the receiver end into a stream that can be consumed using a `while let` loop. Requires the `futures` crate for stream functionality and `tokio` for async runtime.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-04-streams.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse futures::stream::Stream;\nuse futures::task::{Context, Poll};\nuse std::pin::Pin;\nuse tokio::sync::mpsc;\n\nstruct ReceiverStream { rx: mpsc::Receiver<String> }\n\nimpl Stream for ReceiverStream {\n    type Item = String;\n\n    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<String>> {\n        self.rx.poll_recv(cx)\n    }\n}\n\nfn get_messages() -> impl Stream<Item = String> {\n    let (tx, rx) = mpsc::channel(128);\n\n    tokio::spawn(async move {\n        let alphabet = vec![\n            \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\",\n        ];\n\n        for letter in alphabet {\n            tx.send(letter.to_string()).await.unwrap();\n        }\n    });\n\n    ReceiverStream { rx }\n}\n\n#[tokio::main]\nasync fn main() {\n    let mut stream = get_messages();\n\n    while let Some(message) = stream.next().await {\n        println!(\"Message: '{message}'\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Run megadiff script\nDESCRIPTION: Runs a script called megadiff.sh.\nSOURCE: https://github.com/rust-lang/book/blob/main/ADMIN_TASKS.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n./tools/megadiff.sh\n```\n\n----------------------------------------\n\nTITLE: Dropping Sender in ThreadPool Drop - Rust\nDESCRIPTION: This code snippet shows the implementation of the `Drop` trait for the `ThreadPool` struct. It explicitly drops the `sender` field (wrapped in an `Option`) to close the channel, signaling the worker threads to shut down. It then iterates through the worker threads and joins them, waiting for their completion.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_28\n\nLANGUAGE: Rust\nCODE:\n```\npub struct ThreadPool {\n    workers: Vec<Worker>,\n    sender: Option<mpsc::Sender<Job>>,\n}\n// --snip--\nimpl ThreadPool {\n    pub fn new(size: usize) -> ThreadPool {\n        // --snip--\n\n        ThreadPool {\n            workers,\n            sender: Some(sender),\n        }\n    }\n\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static,\n    {\n        let job = Box::new(f);\n\n        self.sender.as_ref().unwrap().send(job).unwrap();\n    }\n}\n\nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        drop(self.sender.take());\n\n        for worker in self.workers.drain(..) {\n            println!(\"Shutting down worker {}\", worker.id);\n\n            worker.thread.join().unwrap();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Catch-All Pattern with Unit Value in Match - Rust\nDESCRIPTION: This code shows a `match` expression using the `_` placeholder with the unit value `()`.  If the dice roll is 3 or 7, the appropriate actions are performed. However, if the roll is any other value, no action is taken due to the `()`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-02-match.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let dice_roll = 9;\n\n    match dice_roll {\n        3 => add_fancy_hat(),\n        7 => remove_fancy_hat(),\n        _ => (),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling Rust Project with Errors\nDESCRIPTION: This snippet shows the output of a `cargo run` command that results in compilation errors due to lifetime and ownership issues. The errors include a missing lifetime specifier in a function signature and returning a reference to a local variable.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch04-understanding-ownership/no-listing-14-dangling-reference/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0106]: missing lifetime specifier\n --> src/main.rs:5:16\n  |\n5 | fn dangle() -> &String {\n  |                ^ expected named lifetime parameter\n  |\n  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\nhelp: consider using the `'static` lifetime, but this is uncommon unless you're returning a borrowed value from a `const` or a `static`\n  |\n5 | fn dangle() -> &'static String {\n  |                 +++++++\nhelp: instead, you are more likely to want to return an owned value\n  |\n5 - fn dangle() -> &String {\n5 + fn dangle() -> String {\n  |\n\nerror[E0515]: cannot return reference to local variable `s`\n --> src/main.rs:8:5\n  |\n8 |     &s\n  |     ^^ returns a reference to data owned by the current function\n\nSome errors have detailed explanations: E0106, E0515.\nFor more information about an error, try `rustc --explain E0106`.\nerror: could not compile `ownership` (bin \"ownership\") due to 2 previous errors\n```\n\n----------------------------------------\n\nTITLE: Running Cargo and Encountering Refutable Pattern Error\nDESCRIPTION: This snippet demonstrates running `cargo run` and receiving an error because of a refutable pattern in a local binding. The error occurs when attempting to bind a value to `Some(x)` from an `Option<i32>` using `let`, without handling the possibility of `None`.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch19-patterns-and-matching/listing-19-08/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling patterns v0.1.0 (file:///projects/patterns)\nerror[E0005]: refutable pattern in local binding\n --> src/main.rs:3:9\n  |\n3 |     let Some(x) = some_option_value;\n  |         ^^^^^^^ pattern `None` not covered\n  |\n  = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n  = note: for more information, visit https://doc.rust-lang.org/book/ch19-02-refutability.html\n  = note: the matched value is of type `Option<i32>`\nhelp: you might want to use `let else` to handle the variant that isn't matched\n  |\n3 |     let Some(x) = some_option_value else { todo!() };\n  |                                     ++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0005`.\nerror: could not compile `patterns` (bin \"patterns\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Opening Book in Firefox (Windows - Cmd)\nDESCRIPTION: This command opens the built book in Firefox on Windows systems using the command prompt.\nSOURCE: https://github.com/rust-lang/book/blob/main/README.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ start firefox.exe .\\book\\index.html\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Error with Statement Return Value\nDESCRIPTION: This snippet shows how adding a semicolon to the end of `x + 1` in the `plus_one` function changes it from an expression to a statement, causing the function to no longer return a value and resulting in a type mismatch error. The function is expected to return `i32`, but the statement doesn't evaluate to any value, which is represented by `()`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = plus_one(5);\n\n    println!(\"The value of x is: {x}\");\n}\n\nfn plus_one(x: i32) -> i32 {\n    x + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Enumeration\nDESCRIPTION: This code snippet demonstrates how to define a generic enumeration in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_80\n\nLANGUAGE: Rust\nCODE:\n```\nenum ident<...> ...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Keyword Conflict with `match` in Rust\nDESCRIPTION: This code snippet demonstrates the error that occurs when attempting to use the keyword `match` as a function name in Rust. It highlights the need for raw identifiers in such cases.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix_a.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn match(needle: &str, haystack: &str) -> bool {\n    haystack.contains(needle)\n}\n```\n\n----------------------------------------\n\nTITLE: Using Block Comment\nDESCRIPTION: This code snippet shows how to use a block comment in Rust. Block comments are enclosed in `/*` and `*/`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_99\n\nLANGUAGE: Rust\nCODE:\n```\n/*...*/\n```\n\n----------------------------------------\n\nTITLE: Implementing content Method (Placeholder) in lib.rs\nDESCRIPTION: This snippet implements the `content` method for the `Post` struct. Initially, it's a placeholder that always returns an empty string slice. This ensures that draft posts do not expose their content.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter18.md#_snippet_13\n\nLANGUAGE: Rust\nCODE:\n```\nimpl Post {\n    // --snip--\n    pub fn content(&self) -> &str {\n        \"\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Attempt to Call Trait Associated Function (Compilation Error)\nDESCRIPTION: This code demonstrates an attempt to call the trait's associated function using the trait name, which results in a compilation error because Rust cannot determine which implementation to use. Requires the `Animal` trait and `Dog` struct definition from previous examples.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-02-advanced-traits.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    println!(\"A baby dog is named {}\", Animal::baby_name());\n}\n```\n\n----------------------------------------\n\nTITLE: Console Output of Tests\nDESCRIPTION: This is an example output after running the tests. `common` appears with `running 0 tests`, but this is not the desired output.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-03-test-organization.md#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n{{#include ../listings/ch11-writing-automated-tests/no-listing-12-shared-test-code-problem/output.txt}}\n```\n\n----------------------------------------\n\nTITLE: Listing Files in a Directory (CMD on Windows)\nDESCRIPTION: This command lists files in a directory on Windows using the `dir` command with the `/B` option to show only file names. It demonstrates how to check for the compiled executable on Windows.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_17\n\nLANGUAGE: shell\nCODE:\n```\n> dir /B %= the /B option says to only show the file names =%\nmain.exe\nmain.pdb\nmain.rs\n```\n\n----------------------------------------\n\nTITLE: Running Tests in a Cargo Workspace\nDESCRIPTION: This snippet shows the output of running `cargo test` in a Cargo workspace. It demonstrates that `cargo test` runs tests for all crates in the workspace. The output displays the compilation and execution of tests for both the `add_one` and `adder` crates.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_27\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo test\n   Compiling add_one v0.1.0 (file:///projects/add/add_one)\n   Compiling adder v0.1.0 (file:///projects/add/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.20s\n     Running unittests src/lib.rs (target/debug/deps/add_one-f0253159197f7841)\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running unittests src/main.rs (target/debug/deps/adder-49979ff40686fa8e)\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests add_one\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Comparing `trpl::sleep` and `trpl::yield_now` Performance in Rust\nDESCRIPTION: This code snippet benchmarks the performance difference between `trpl::sleep` and `trpl::yield_now` in a loop. It measures the execution time for 1000 iterations of each function, demonstrating that `trpl::yield_now` is significantly faster due to avoiding the overhead of timer granularity associated with `trpl::sleep`. The `Instant` struct is used to measure the elapsed time.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_30\n\nLANGUAGE: rust\nCODE:\n```\nlet one_ns = Duration::from_nanos(1);\nlet start = Instant::now();\nasync {\n    for _ in 1..1000 {\n        trpl::sleep(one_ns).await;\n    }\n}\n.await;\nlet time = Instant::now() - start;\nprintln!(\n    \"'sleep' version finished after {} seconds.\",\n    time.as_secs_f32()\n);\n\nlet start = Instant::now();\nasync {\n    for _ in 1..1000 {\n        trpl::yield_now().await;\n    }\n}\n.await;\nlet time = Instant::now() - start;\nprintln!(\n    \"'yield' version finished after {} seconds.\",\n    time.as_secs_f32()\n);\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error: Mutable Borrow with Shared Reference\nDESCRIPTION: This snippet demonstrates a Rust compilation error (E0596) that arises when attempting to modify a String via a shared reference. The `push_str` method attempts to mutate the string, but it is disallowed because the string is borrowed immutably. To fix this, the function signature should use a mutable reference `&mut String`.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch04-understanding-ownership/listing-04-06/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` reference\n --> src/main.rs:8:5\n  |\n8 |     some_string.push_str(\", world\");\n  |     ^^^^^^^^^^^ `some_string` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n  |\nhelp: consider changing this to be a mutable reference\n  |\n7 | fn change(some_string: &mut String) {\n  |                         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `ownership` (bin \"ownership\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Uninstalling Rust with rustup\nDESCRIPTION: Uninstalls Rust and the `rustup` tool from the system. This removes the Rust toolchain and associated components.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-01-installation.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\n$ rustup self uninstall\n```\n\n----------------------------------------\n\nTITLE: Passing Channel Receiver to Workers (Incorrectly) in Rust\nDESCRIPTION: This snippet shows an attempt to pass the channel receiver to each `Worker` instance. It highlights a common error where the receiver is moved in the loop, leading to a compilation error because the `Receiver` type does not implement the `Copy` trait. This illustrates the multiple producer, single consumer nature of Rust's channels.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nimpl ThreadPool {\n    // --snip--\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, receiver));\n        }\n\n        ThreadPool { workers, sender }\n    }\n    // --snip--\n}\n\n// --snip--\n\nimpl Worker {\n    fn new(id: usize, receiver: mpsc::Receiver<Job>) -> Worker {\n        let thread = thread::spawn(|| {\n            receiver;\n        });\n\n        Worker { id, thread }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo build after trivial change - Shell\nDESCRIPTION: Demonstrates cargo build command after a trivial change in the code.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter02.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo build\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s\n```\n\n----------------------------------------\n\nTITLE: Extracting Program Logic into run Function in Rust\nDESCRIPTION: This snippet extracts the core program logic from the `main` function into a separate `run` function. The `run` function takes a `Config` instance as input and performs the file reading and processing steps.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_9\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    // --snip--\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    run(config);\n}\n\nfn run(config: Config) {\n    let contents = fs::read_to_string(config.file_path)\n        .expect(\"Should have been able to read the file\");\n\n    println!(\"With text:\\n{contents}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Tuple Destructuring Rust\nDESCRIPTION: Illustrates how to destructure a tuple in Rust using pattern matching with the `let` keyword. It breaks a single tuple into multiple variables, allowing access to individual elements.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let tup = (500, 6.4, 1);\n\n    let (x, y, z) = tup;\n\n    println!(\"The value of y is: {y}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Failing Test for Case-Insensitive Search in Rust\nDESCRIPTION: This Rust code demonstrates a failing test case for a case-insensitive search function. It tests if the `search_case_insensitive` function correctly identifies lines containing a specific query, regardless of the casing of the query or the lines in the content.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-05-working-with-environment-variables.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-20/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Loop Labels for Disambiguation Rust\nDESCRIPTION: This example illustrates the use of loop labels in nested loops to control which loop `break` exits. The outer loop is labeled `'counting_up`. The inner loop breaks unconditionally. The `break 'counting_up;` statement exits the outer loop when `count` equals 2.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_34\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut count = 0;\n    'counting_up: loop {\n        println!(\"count = {count}\");\n        let mut remaining = 10;\n\n        loop {\n            println!(\"remaining = {remaining}\");\n            if remaining == 9 {\n                break;\n            }\n            if count == 2 {\n                break 'counting_up;\n            }\n            remaining -= 1;\n        }\n\n        count += 1;\n    }\n    println!(\"End count = {count}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Running Minigrep with Cargo\nDESCRIPTION: This command executes the minigrep program.  It first compiles the Rust project using `cargo run` and then runs the executable with the arguments `body poem.txt`. The expected output will be lines from `poem.txt` that contain the word 'body'.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch12-an-io-project/output-only-03-multiple-matches/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run -- body poem.txt\n Compiling minigrep v0.1.0 (file:///projects/minigrep)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n  Running `target/debug/minigrep body poem.txt`\nI'm nobody! Who are you?\nAre you nobody, too?\nHow dreary to be somebody!\n```\n\n----------------------------------------\n\nTITLE: Create a new library project with Cargo\nDESCRIPTION: This command creates a new Rust library project named `adder` using Cargo. It initializes the project structure with a `src/lib.rs` file.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-01-writing-tests.md#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ cargo new adder --lib\n     Created library `adder` project\n$ cd adder\n```\n\n----------------------------------------\n\nTITLE: Defining Function in Library Crate\nDESCRIPTION: Defines a simple function `add_one` in the `add_one` library crate. This function takes an i32 integer as input and returns the input plus one.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_18\n\nLANGUAGE: Rust\nCODE:\n```\npub fn add_one(x: i32) -> i32 {\n    x + 1\n}\n```\n\n----------------------------------------\n\nTITLE: Dereference Operator Rust\nDESCRIPTION: This operator dereferences a pointer, allowing access to the value it points to. It's used to retrieve the value stored at the memory location referenced by the pointer. The `Deref` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_12\n\nLANGUAGE: Rust\nCODE:\n```\n`*expr`\n```\n\n----------------------------------------\n\nTITLE: Function Definition with Parameter Pattern in Rust\nDESCRIPTION: This snippet defines a function `foo` in Rust that takes a parameter `x` of type `i32`. The parameter `x` itself acts as a pattern.  This demonstrates how function parameters can be seen as simple patterns that bind the input argument to a variable name.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nfn foo(x: i32) {\n    // code goes here\n}\n```\n\n----------------------------------------\n\nTITLE: Bringing HashMap into Scope (Idiomatic) Rust\nDESCRIPTION: This snippet demonstrates the idiomatic way to bring a struct, like `HashMap`, into scope using the `use` keyword. It specifies the full path to the struct, making it clear where the struct is defined.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::HashMap;\n\nfn main() {\n    let mut map = HashMap::new();\n    map.insert(1, 2);\n}\n```\n\n----------------------------------------\n\nTITLE: Using `?` Operator on `Option<T>` Value - Rust\nDESCRIPTION: This code snippet demonstrates using the `?` operator on an `Option<T>` value. The `last_char_of_first_line` function returns an `Option<char>` representing the last character of the first line in a given text. The `?` operator is used to handle the cases where the input string is empty or the first line is empty, returning `None` in those scenarios. It showcases a concise way to express error handling with `Option`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter09.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nfn last_char_of_first_line(text: &str) -> Option<char> {\n    text.lines().next()?.chars().last()\n}\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Addition Operator Rust\nDESCRIPTION: This operator performs arithmetic addition. It adds two expressions and returns the sum. The `Add` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_15\n\nLANGUAGE: Rust\nCODE:\n```\n`expr + expr`\n```\n\n----------------------------------------\n\nTITLE: String Move Example in Rust\nDESCRIPTION: Demonstrates the concept of a \"move\" in Rust when assigning one String variable to another. Instead of creating a deep copy of the heap data, the pointer, length, and capacity are copied, and the original variable is invalidated to prevent a double free. This ensures memory safety.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet s1 = String::from(\"hello\");\nlet s2 = s1;\n```\n\n----------------------------------------\n\nTITLE: String Slice with Trailing Number Dropped\nDESCRIPTION: This example demonstrates dropping the trailing number in the range when slicing a string. It shows how to create a slice from a specified index to the end of the String by omitting the ending index.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_27\n\nLANGUAGE: Rust\nCODE:\n```\nlet s = String::from(\"hello\");\n\nlet len = s.len();\n\nlet slice = &s[3..len];\nlet slice = &s[3..];\n```\n\n----------------------------------------\n\nTITLE: Cargo run command - Shell\nDESCRIPTION: This snippet shows the command to run the cargo project.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter02.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo run\n```\n\n----------------------------------------\n\nTITLE: Accessing Array Elements by Index\nDESCRIPTION: This code shows how to access elements within an array using indexing. The index starts from 0, and specifying an invalid index will cause a runtime panic.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-02-data-types.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nlet a = [1, 2, 3, 4, 5];\n\nlet first = a[0];\n\nlet second = a[1];\n\n```\n\n----------------------------------------\n\nTITLE: Opening Book in Chrome (Linux)\nDESCRIPTION: This command opens the built book in Google Chrome on Linux systems.\nSOURCE: https://github.com/rust-lang/book/blob/main/README.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ google-chrome book/index.html\n```\n\n----------------------------------------\n\nTITLE: Adding Argument Length Check in `Config::new` - Rust\nDESCRIPTION: This snippet shows how to add a check in the `new` function to verify that the slice is long enough before accessing index 1 and index 2. If the slice isnt long enough, the program panics and displays a better error message. The code uses `panic!` when the length of `args` is less than 3.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-03-improving-error-handling-and-modularity.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::env;\nuse std::fs;\nuse std::process;\n\nstruct Config {\n    query: String,\n    file_path: String,\n}\n\nimpl Config {\n    fn new(args: &[String]) -> Config {\n        if args.len() < 3 {\n            panic!(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Config {\n            query,\n            file_path,\n        }\n    }\n}\n\nfn run(config: Config) {\n    let contents = fs::read_to_string(config.file_path)\n        .expect(\"Could not read file\");\n\n    println!(\"With contents:\\n{contents}\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::new(&args);\n\n    run(config);\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error: Borrowed Value\nDESCRIPTION: This snippet shows the error message produced by the Rust compiler when a borrowed value does not live long enough. The error E0597 is triggered when a variable `x` is dropped while a reference `r` to it is still in scope and later used. This indicates a lifetime issue where the borrow outlives the data it refers to.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch10-generic-types-traits-and-lifetimes/listing-10-16/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nerror[E0597]: `x` does not live long enough\n --> src/main.rs:6:13\n  |\n5 |         let x = 5;\n  |             - binding `x` declared here\n6 |         r = &x;\n  |             ^^ borrowed value does not live long enough\n7 |     }\n  |     - `x` dropped here while still borrowed\n8 |\n9 |     println!(\"r: {r}\");\n  |                  --- borrow later used here\n\nFor more information about this error, try `rustc --explain E0597`.\nerror: could not compile `chapter10` (bin \"chapter10\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Public Struct with Public and Private Fields Rust\nDESCRIPTION: This snippet demonstrates how to define a public struct in Rust with both public and private fields. The `Breakfast` struct has a public `toast` field and a private `seasonal_fruit` field.  It shows how to create an instance using a public associated function since a private field exists.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nmod back_of_house {\n    pub struct Breakfast {\n        pub toast: String,\n        seasonal_fruit: String,\n    }\n\n    impl Breakfast {\n        pub fn summer(toast: &str) -> Breakfast {\n            Breakfast {\n                toast: String::from(toast),\n                seasonal_fruit: String::from(\"peaches\"),\n            }\n        }\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Order a breakfast in the summer with Rye toast.\n    let mut meal = back_of_house::Breakfast::summer(\"Rye\");\n    // Change our mind about what bread we'd like.\n    meal.toast = String::from(\"Wheat\");\n    println!(\"I'd like {} toast please\", meal.toast);\n\n    // The next line won't compile if we uncomment it; we're not allowed\n    // to see or modify the seasonal fruit that comes with the meal.\n    // meal.seasonal_fruit = String::from(\"blueberries\");\n}\n```\n\n----------------------------------------\n\nTITLE: Example of unused mutable variable in Rust\nDESCRIPTION: This Rust code snippet demonstrates a scenario where a variable is declared as mutable but is never actually mutated. This will trigger a compiler warning that can be automatically fixed using `cargo fix`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix.md#_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    let mut x = 42;\n    println!(\"{x}\");\n}\n```\n\n----------------------------------------\n\nTITLE: HTML Content for 404 Page\nDESCRIPTION: This HTML file defines the structure and content for a simple 404 error page. It includes a heading and a paragraph explaining that the requested resource was not found.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_7\n\nLANGUAGE: html\nCODE:\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Hello!</title>\n  </head>\n  <body>\n    <h1>Oops!</h1>\n    <p>Sorry, I don't know what you're asking for.</p>\n  </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Equivalent Structs for Enum Variants in Rust\nDESCRIPTION: This code demonstrates structs that are equivalent to the enum variants defined in the Message enum.  `QuitMessage` is a unit struct, `MoveMessage` has named fields, and `WriteMessage` and `ChangeColorMessage` are tuple structs.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nstruct QuitMessage; // unit struct\nstruct MoveMessage {\n    x: i32,\n    y: i32,\n}\nstruct WriteMessage(String); // tuple struct\nstruct ChangeColorMessage(i32, i32, i32); // tuple struct\n```\n\n----------------------------------------\n\nTITLE: Multi-Line Comment in Rust\nDESCRIPTION: This snippet demonstrates a multi-line comment in Rust. Each line of the comment starts with two forward slashes `//`. This is the idiomatic way to write comments that span multiple lines.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\n// So we're doing something complicated here, long enough that we need\n// multiple lines of comments to do it! Whew! Hopefully, this comment will\n// explain what's going on.\n```\n\n----------------------------------------\n\nTITLE: Using an External Package in Rust\nDESCRIPTION: This demonstrates how to bring items from an external package into scope using the `use` keyword.  The external package must first be added as a dependency in `Cargo.toml`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nuse rand::Rng;\n\nfn main() {\n    let secret_number = rand::thread_rng().gen_range(1..=100);\n}\n```\n\n----------------------------------------\n\nTITLE: Running Cargo build after a trivial change\nDESCRIPTION: This is example output from running `cargo build` after making a trivial change to the source file. It highlights that only the project crate is recompiled, not the dependencies.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_14\n\nLANGUAGE: console\nCODE:\n```\n$ cargo build\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s\n```\n\n----------------------------------------\n\nTITLE: Installing Rust with rustup on Linux/macOS\nDESCRIPTION: Downloads and executes the rustup installation script to install the latest stable version of Rust. This script manages Rust versions and associated tools. It requires an internet connection to download the necessary files.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-01-installation.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\n```\n\n----------------------------------------\n\nTITLE: Checking Rust Installation\nDESCRIPTION: Checks whether Rust is installed correctly by printing the version, commit hash, and commit date. The command `rustc --version` invokes the Rust compiler and outputs version information if Rust is correctly installed and accessible in the system's PATH.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-01-installation.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n$ rustc --version\n```\n\n----------------------------------------\n\nTITLE: Creating Async Channel in Rust\nDESCRIPTION: This snippet creates an asynchronous channel using `trpl::channel`, assigning the sender to `tx` and the receiver to `rx`. This allows sending messages between asynchronous tasks.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-02-concurrency-with-async.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet (tx, rx) = trpl::channel();\n\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error: Type Mismatch\nDESCRIPTION: This code snippet demonstrates a Rust compilation error (E0308) caused by a type mismatch. The `spaces` variable is initially declared as a mutable string slice (`&str`). The subsequent assignment attempts to assign the length of the string (a `usize` value) to `spaces`, resulting in a type mismatch error because `&str` and `usize` are incompatible types. The compiler output provides information about the expected and found types, aiding in debugging.  This emphasizes Rust's strong type system.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet mut spaces = \"   \";\nspaces = spaces.len();\n```\n\n----------------------------------------\n\nTITLE: Reading Username from File with ? Operator - Rust\nDESCRIPTION: This function `read_username_from_file` attempts to read the username from a file named \"hello.txt\". It opens the file, creates a new String, and reads the file's content into the String. The `?` operator is used to propagate any errors that occur during file opening or reading. If an error occurs, the function returns early with the Err value.  Dependencies: std::fs::File, std::io::{self, Read}.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter09.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    let mut username_file = File::open(\"hello.txt\")?;\n    let mut username = String::new();\n    username_file.read_to_string(&mut username)?;\n    Ok(username)\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error: Missing Display Trait Implementation\nDESCRIPTION: This code snippet shows the error message produced by the Rust compiler when attempting to compile code that uses a trait (`OutlinePrint`) which requires the `std::fmt::Display` trait to be implemented for a struct (`Point`), but it is not. The error highlights the missing trait implementation and suggests using `{:?}` for debugging purposes.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch20-advanced-features/no-listing-02-impl-outlineprint-for-point/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nerror[E0277]: `Point` doesn't implement `std::fmt::Display`\n  --> src/main.rs:20:23\n   |\n20 | impl OutlinePrint for Point {}\n   |                       ^^^^^ `Point` cannot be formatted with the default formatter\n   |\n   = help: the trait `std::fmt::Display` is not implemented for `Point`\n   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\nnote: required by a bound in `OutlinePrint`\n  --> src/main.rs:3:21\n   |\n3  | trait OutlinePrint: fmt::Display {\n   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`\n\nerror[E0277]: `Point` doesn't implement `std::fmt::Display`\n  --> src/main.rs:24:7\n   |\n24 |     p.outline_print();\n   |       ^^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter\n   |\n   = help: the trait `std::fmt::Display` is not implemented for `Point`\n   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\nnote: required by a bound in `OutlinePrint::outline_print`\n  --> src/main.rs:3:21\n   |\n3  | trait OutlinePrint: fmt::Display {\n   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint::outline_print`\n4  |     fn outline_print(&self) {\n   |        ------------- required by a bound in this associated function\n```\n\n----------------------------------------\n\nTITLE: Ignoring Value with `_` (No Ownership Transfer) in Rust\nDESCRIPTION: This code demonstrates that using only the underscore `_` does not bind the value, so there is no ownership transfer. This allows using the original value after the match arm. Dependencies: None. Inputs: None. Outputs: Prints the string value.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let s = String::from(\"hello\");\n\n    match s {\n        _ => {\n            println!(\"The value of s is moved here, but we don't bind it.\");\n        }\n    }\n\n    println!(\"{}\", s);\n}\n```\n\n----------------------------------------\n\nTITLE: Storing UTF-8 Greetings in Rust Strings\nDESCRIPTION: Illustrates storing greetings in different languages within `String` variables, demonstrating that Rust strings are UTF-8 encoded and can hold characters from various alphabets.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-02-strings.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet hello = String::from(\" \");\nlet hello = String::from(\"Dobr den\");\nlet hello = String::from(\"Hello\");\nlet hello = String::from(\"\");\nlet hello = String::from(\"Ol\");\nlet hello = String::from(\"\");\nlet hello = String::from(\"Hola\");\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream from an Iterator\nDESCRIPTION: This code snippet demonstrates how to create a stream from an iterator in Rust. It starts with an array of numbers, converts it to an iterator, doubles the values using `map`, and then converts the iterator into a stream using the `trpl::stream_from_iter` function. The code then attempts to loop over the items in the stream and print their values.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_34\n\nLANGUAGE: rust\nCODE:\n```\nlet values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nlet iter = values.iter().map(|n| n * 2);\nlet mut stream = trpl::stream_from_iter(iter);\n\nwhile let Some(value) = stream.next().await {\n    println!(\"The value was: {value}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Incrementing a Counter with Mutex - Rust\nDESCRIPTION: This code attempts to increment a shared counter using a Mutex. However, it results in a compiler error because the Mutex is moved into the first thread and then borrowed by subsequent threads. Demonstrates the issue of moving a value into multiple threads without proper shared ownership.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter16.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::Mutex;\nuse std::thread;\n\nfn main() {\n    let counter = Mutex::new(0);\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n```\n\n----------------------------------------\n\nTITLE: Calculate String Length with Reference in Rust\nDESCRIPTION: This code defines a function `calculate_length` that takes a reference to a String (`&String`) as input and returns its length as a `usize`. The key aspect is that the function borrows the String without taking ownership, meaning the String is not dropped when the function's scope ends. This is fundamental to Rust's ownership and borrowing system, allowing efficient memory management.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/references-and-borrowing.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn calculate_length(s: &String) -> usize { // s is a reference to a String\n    s.len()\n} // Here, s goes out of scope. But because it does not have ownership of what\n  // it refers to, nothing happens.\n```\n\n----------------------------------------\n\nTITLE: String Creation and Slicing in Rust\nDESCRIPTION: This code snippet demonstrates how to create a `String` from a string literal using `String::from()` and how to create string slices that reference parts of the `String`. The `hello` and `world` variables are string slices that point to different parts of the `s` String.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/strings.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet s = String::from(\"hello world\");\n\nlet hello = &s[0..5];\nlet world = &s[6..11];\n```\n\n----------------------------------------\n\nTITLE: Concatenating Multiple Strings with + Operator in Rust\nDESCRIPTION: Demonstrates the verbose way of concatenating multiple strings using the `+` operator. This example showcases the unwieldy nature of using `+` for complex string concatenation.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-02-strings.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nlet s1 = String::from(\"tic\");\nlet s2 = String::from(\"-tac\");\nlet s3 = String::from(\"-toe\");\n\nlet s = s1 + &s2 + &s3;\n```\n\n----------------------------------------\n\nTITLE: Adding rand Dependency to Cargo.toml\nDESCRIPTION: This snippet demonstrates how to add the `rand` crate as a dependency to the `add_one` crate within a Cargo workspace. This allows the `add_one` crate to use the `rand` crate's functionality. The file to modify is add_one/Cargo.toml. The version number should match across the project.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-03-cargo-workspaces.md#_snippet_10\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nrand = \"0.8.5\"\n```\n\n----------------------------------------\n\nTITLE: Using `if let` with refutable patterns in Rust\nDESCRIPTION: This code fixes the previous error by using `if let` instead of `let`. `if let` can handle refutable patterns because it provides a way to skip the code block if the pattern doesn't match, allowing the program to continue validly even if `some_option_value` is `None`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-02-refutability.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet some_option_value: Option<i32> = None;\nif let Some(x) = some_option_value {\n    println!(\"{}\", x);\n}\n```\n\n----------------------------------------\n\nTITLE: Array Declaration Rust\nDESCRIPTION: Demonstrates how to declare an array in Rust with a fixed size and a list of initial values. All elements in an array must have the same type.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let a = [1, 2, 3, 4, 5];\n}\n```\n\n----------------------------------------\n\nTITLE: Update Editions Script Execution\nDESCRIPTION: Executes the `./tools/update-editions.sh` script to update the edition metadata in all the listings' Cargo.toml files.\nSOURCE: https://github.com/rust-lang/book/blob/main/ADMIN_TASKS.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./tools/update-editions.sh\n```\n\n----------------------------------------\n\nTITLE: Vegetables Submodule Definition\nDESCRIPTION: This Rust code snippet defines the 'vegetables' submodule within the 'garden' module in `src/garden/vegetables.rs`. It defines a public struct named `Asparagus`, illustrating how to define items within modules.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-02-defining-modules-to-control-scope-and-privacy.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\npub struct Asparagus {}\n```\n\n----------------------------------------\n\nTITLE: String to Number Conversion with Shadowing - Rust\nDESCRIPTION: This snippet shows how to convert a string input to an unsigned 32-bit integer (`u32`) using `trim()` and `parse()`.  It also demonstrates variable shadowing, where a new variable `guess` is declared with the same name, replacing the previous `String` value. The `expect` method is used to handle potential errors during parsing, crashing the program if the input is not a valid number.\nThe code relies on the `io::stdin()` to be executed before to read user input into the original `guess` variable as a String.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter02.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nlet mut guess = String::new();\n\n    io::stdin()\n        .read_line(&mut guess)\n        .expect(\"Failed to read line\");\n\n    let guess: u32 = guess.trim().parse().expect(\"Please type a number!\");\n\n    println!(\"You guessed: {guess}\");\n\n    match guess.cmp(&secret_number) {\n        Ordering::Less => println!(\"Too small!\"),\n        Ordering::Greater => println!(\"Too big!\"),\n        Ordering::Equal => println!(\"You win!\"),\n    \n```\n\n----------------------------------------\n\nTITLE: String Slice of the Entire String\nDESCRIPTION: This code shows how to create a string slice that refers to the entire String. It demonstrates that omitting both the starting and ending indices in the range results in a slice encompassing the whole string.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_28\n\nLANGUAGE: Rust\nCODE:\n```\nlet s = String::from(\"hello\");\n\nlet len = s.len();\n\nlet slice = &s[0..len];\nlet slice = &s[..];\n```\n\n----------------------------------------\n\nTITLE: Install ghp-import tool using pip\nDESCRIPTION: Installs the `ghp-import` tool using pip, which is used to publish a preview to GitHub Pages. This command requires pip to be installed.\nSOURCE: https://github.com/rust-lang/book/blob/main/ADMIN_TASKS.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npip install ghp-import\n```\n\n----------------------------------------\n\nTITLE: Console Output for Area Calculation Rust\nDESCRIPTION: This code snippet shows the expected console output when running the previous Rust code that calculates the area of a rectangle using separate variables.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-02-example-structs.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nThe area of the rectangle is 1500 square pixels.\n```\n\n----------------------------------------\n\nTITLE: Installing rustfmt with rustup\nDESCRIPTION: This command installs the `rustfmt` component using rustup. `rustfmt` is a tool for automatically formatting Rust code according to the community style guidelines. After installation, `cargo fmt` can be used to format the current project.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n$ rustup component add rustfmt\n```\n\n----------------------------------------\n\nTITLE: Annotating Static Lifetime in Rust\nDESCRIPTION: This snippet demonstrates how to annotate a string literal with the `'static` lifetime in Rust. String literals have a `'static` lifetime because their text is stored directly in the program's binary and is always available. The `s` variable is declared as a string slice with a static lifetime.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-03-lifetime-syntax.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nlet s: &'static str = \"I have a static lifetime.\";\n```\n\n----------------------------------------\n\nTITLE: Creating Library Crate in Workspace\nDESCRIPTION: Creates a new library crate named 'add_one' inside the workspace. The `--lib` flag specifies that a library crate should be created.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_17\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo new add_one --lib\n    Creating library `add_one` package\n      Adding `add_one` as member of workspace at `file:///projects/add`\n```\n\n----------------------------------------\n\nTITLE: Checking a Cargo project\nDESCRIPTION: This command checks a Rust project for compilation errors without producing an executable. It quickly verifies the code's syntax and type correctness, making it faster than a full build.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-03-hello-cargo.md#_snippet_7\n\nLANGUAGE: console\nCODE:\n```\n$ cargo check\n   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs\n```\n\n----------------------------------------\n\nTITLE: Executing Cargo Test in Rust\nDESCRIPTION: This snippet demonstrates the execution of the `cargo test` command in a Rust project.  It showcases the compilation process, the execution of unit tests, and the reporting of test results, including successful and failed tests, along with their standard output.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/listing-11-10/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo test\n Compiling silly-function v0.1.0 (file:///projects/silly-function)\n  Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s\n  Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)\n\nrunning 2 tests\ntest tests::this_test_will_fail ... FAILED\ntest tests::this_test_will_pass ... ok\n\nfailures:\n\n---- tests::this_test_will_fail stdout ----\nI got the value 8\n\nthread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:\nassertion `left == right` failed\n left: 10\nright: 5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n   tests::this_test_will_fail\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n```\n\n----------------------------------------\n\nTITLE: Cargo Run Output with Error Handling\nDESCRIPTION: This console output demonstrates running the guessing game with the non-number input handling, showcasing how the program continues after receiving 'foo' as input. It shows successful compilation, running, user interaction (guesses, including a non-numeric input \"foo\"), and winning the game.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_26\n\nLANGUAGE: console\nCODE:\n```\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s\n     Running `target/debug/guessing_game`\nGuess the number!\nThe secret number is: 61\nPlease input your guess.\n10\nYou guessed: 10\nToo small!\nPlease input your guess.\n99\nYou guessed: 99\nToo big!\nPlease input your guess.\nfoo\nPlease input your guess.\n61\nYou guessed: 61\nYou win!\n```\n\n----------------------------------------\n\nTITLE: Definition of the `Add` trait with a default generic type parameter in Rust\nDESCRIPTION: This code defines the `Add` trait with a default generic type parameter `Rhs` that defaults to `Self`. This allows implementing the `Add` trait for a type without specifying the `Rhs` type, in which case it will default to the type being implemented. The associated type `Output` determines the return type of the `add` method.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-02-advanced-traits.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\ntrait Add<Rhs=Self> {\n    type Output;\n\n    fn add(self, rhs: Rhs) -> Self::Output;\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo Run Compilation Error in Rust\nDESCRIPTION: This code snippet shows the error output when running `cargo run`. The error E0277 indicates a failure to compare an integer with a reference to an integer using the `assert_eq!` macro. The compiler cannot find a suitable implementation for `PartialEq<&{integer}>` for the integer type.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch15-smart-pointers/output-only-01-comparing-to-reference/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling deref-example v0.1.0 (file:///projects/deref-example)\nerror[E0277]: can't compare `{integer}` with `&{integer}`\n --> src/main.rs:6:5\n  |\n6 |     assert_eq!(5, y);\n  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`\n  |\n  = help: the trait `PartialEq<&{integer}>` is not implemented for `{integer}`\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `deref-example` (bin \"deref-example\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation with Type Annotation Error\nDESCRIPTION: This snippet shows a Rust compilation error that occurs when the compiler cannot infer the type of the `guess` variable during the `parse()` operation. This happens because the return type of `parse()` is generic and needs an explicit type annotation. The error message suggests adding a type annotation to the variable `guess` to resolve the error.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch03-common-programming-concepts/output-only-01-no-type-annotations/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo build\n Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)\nerror[E0284]: type annotations needed\n --> src/main.rs:2:9\n  |\n2 |     let guess = \"42\".parse().expect(\"Not a number!\");\n  |         ^^^^^        ----- type must be known at this point\n  |\n  = note: cannot satisfy `<_ as FromStr>::Err == _`\nhelp: consider giving `guess` an explicit type\n  |\n2 |     let guess: /* Type */ = \"42\".parse().expect(\"Not a number!\");\n  |              ++++++++++++\n\nFor more information about this error, try `rustc --explain E0284`.\nerror: could not compile `no_type_annotations` (bin \"no_type_annotations\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Analyzing Rust Test Output\nDESCRIPTION: This snippet showcases the output of a Rust `cargo test` command. It displays successful and failed tests, stdout output, and panic messages, providing insights into test execution and debugging.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/output-only-01-show-output/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test -- --show-output\n Compiling silly-function v0.1.0 (file:///projects/silly-function)\n  Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s\n  Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)\n\nrunning 2 tests\ntest tests::this_test_will_fail ... FAILED\ntest tests::this_test_will_pass ... ok\n\nsuccesses:\n\n---- tests::this_test_will_pass stdout ----\nI got the value 4\n\n\nsuccesses:\n   tests::this_test_will_pass\n\nfailures:\n\n---- tests::this_test_will_fail stdout ----\nI got the value 8\n\nthread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:\nassertion `left == right` failed\n left: 10\nright: 5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n   tests::this_test_will_fail\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n```\n\n----------------------------------------\n\nTITLE: Returning Ownership in Rust\nDESCRIPTION: This code demonstrates how ownership is transferred when returning a `String` from a function.  `gives_ownership` returns a `String`, transferring ownership to `s1` in `main`. `takes_and_gives_back` takes ownership of a `String` and returns it, transferring ownership to `s3` in `main`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_11\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    let s1 = gives_ownership();        // gives_ownership moves its return\n                                       // value into s1\n\n    let s2 = String::from(\"hello\");    // s2 comes into scope\n\n    let s3 = takes_and_gives_back(s2); // s2 is moved into\n                                       // takes_and_gives_back, which also\n                                       // moves its return value into s3\n} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing\n  // happens. s1 goes out of scope and is dropped.\n\nfn gives_ownership() -> String {       // gives_ownership will move its\n                                       // return value into the function\n                                       // that calls it\n\n    let some_string = String::from(\"yours\"); // some_string comes into scope\n\n    some_string                        // some_string is returned and\n                                       // moves out to the calling\n                                       // function\n}\n\n// This function takes a String and returns a String.\nfn takes_and_gives_back(a_string: String) -> String {\n    // a_string comes into\n    // scope\n\n    a_string  // a_string is returned and moves out to the calling function\n}\n```\n\n----------------------------------------\n\nTITLE: Running Cargo build after adding rand\nDESCRIPTION: This is example output from running `cargo build` after adding the `rand` crate as a dependency in Cargo.toml.  It shows the process of Cargo updating the index, locking packages, adding the `rand` crate and its dependencies, compiling the dependencies, and finally compiling the project.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_13\n\nLANGUAGE: console\nCODE:\n```\n$ cargo build\n  Updating crates.io index\n   Locking 15 packages to latest Rust 1.85.0 compatible versions\n    Adding rand v0.8.5 (available: v0.9.0)\n Compiling proc-macro2 v1.0.93\n Compiling unicode-ident v1.0.17\n Compiling libc v0.2.170\n Compiling cfg-if v1.0.0\n Compiling byteorder v1.5.0\n Compiling getrandom v0.2.15\n Compiling rand_core v0.6.4\n Compiling quote v1.0.38\n Compiling syn v2.0.98\n Compiling zerocopy-derive v0.7.35\n Compiling zerocopy v0.7.35\n Compiling ppv-lite86 v0.2.20\n Compiling rand_chacha v0.3.1\n Compiling rand v0.8.5\n Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.48s\n```\n\n----------------------------------------\n\nTITLE: Clippy Error: Approximate PI Constant\nDESCRIPTION: This console output shows the error generated by Clippy when an approximate value of PI is used. It recommends using the `f{32, 64}::consts::PI` constant directly.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-04-useful-development-tools.md#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nerror: approximate value of `f{32, 64}::consts::PI` found\n --> src/main.rs:2:13\n  |\n2 |     let x = 3.1415;\n  |             ^^^^^^\n  |\n  = note: `#[deny(clippy::approx_constant)]` on by default\n  = help: consider using the constant directly\n  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant\n```\n\n----------------------------------------\n\nTITLE: Opening Book in Firefox (OS X)\nDESCRIPTION: This command opens the built book in Firefox on macOS systems.\nSOURCE: https://github.com/rust-lang/book/blob/main/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ open -a \"Firefox\" book/index.html\n```\n\n----------------------------------------\n\nTITLE: HTML Output of the Preprocessor\nDESCRIPTION: This snippet shows the resulting HTML after the preprocessor has transformed the Markdown blockquote. It uses the `<section>` element with the `note` class to semantically represent the note.\nSOURCE: https://github.com/rust-lang/book/blob/main/packages/mdbook-trpl/src/bin/README - mdbook-trpl-note.md#_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<section class=\"note\" aria-role=\"note\">\n\nThis is some material we want to provide more emphasis for, because it is\nimportant in some way!\n\n</section>\n\nSome text.\n\n<section class=\"note\" aria-role=\"note\">\n\n## Some subject\n\nHere is all the important things to know about that particular subject.\n\n</section>\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple Traits with Same Method Name\nDESCRIPTION: This code defines two traits, `Pilot` and `Wizard`, both with a `fly` method. It then implements both traits on a `Human` struct, which also has its own `fly` method. This demonstrates how Rust handles name collisions when multiple traits with the same method name are implemented on the same type, and how to call the desired method explicitly.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-02-advanced-traits.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\ntrait Pilot {\n    fn fly(&self);\n}\n\ntrait Wizard {\n    fn fly(&self);\n}\n\nstruct Human;\n\nimpl Human {\n    fn fly(&self) {\n        println!(\"*waving arms furiously*\");\n    }\n}\n\nimpl Pilot for Human {\n    fn fly(&self) {\n        println!(\"This is your captain speaking.\");\n    }\n}\n\nimpl Wizard for Human {\n    fn fly(&self) {\n        println!(\"Up!\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Test Results with a Failing Test\nDESCRIPTION: This output shows the result of running tests where one test (`exploration`) passes and another (`another`) fails. The output includes the reason for the failure (the `panic!` macro) and the location where the panic occurred.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 2 tests\ntest tests::another ... FAILED\ntest tests::exploration ... ok\n\nfailures:\n\n---- tests::another stdout ----\nthread 'tests::another' panicked at src/lib.rs:17:9:\nMake this test fail\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::another\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n```\n\n----------------------------------------\n\nTITLE: Grouping Configuration Values - Rust\nDESCRIPTION: This snippet demonstrates grouping command-line arguments into a `Config` struct for better organization and clarity. It defines a struct with fields for `query` and `file_path` and modifies the `parse_config` function to return an instance of this struct. Cloning is used to handle ownership of the `String` values.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = parse_config(&args);\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    let contents = fs::read_to_string(config.file_path)\n        .expect(\"Should have been able to read the file\");\n\n    // --snip--\n}\n\nstruct Config {\n    query: String,\n    file_path: String,\n}\n\nfn parse_config(args: &[String]) -> Config {\n    let query = args[1].clone();\n    let file_path = args[2].clone();\n\n    Config { query, file_path }\n}\n```\n\n----------------------------------------\n\nTITLE: Using `longest` function with `String` references\nDESCRIPTION: This `main` function demonstrates a valid usage of the `longest` function with references to `String` values that have different concrete lifetimes. The lifetime of `result` is constrained by the smaller lifetime of `string2`, but since `println!` is within the same scope as `string2`, the code compiles successfully.  The function `longest` is called with the `as_str()` method to convert `String` to string slices.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_41\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let string1 = String::from(\"long string is long\");\n\n    {\n        let string2 = String::from(\"xyz\");\n        let result = longest(string1.as_str(), string2.as_str());\n        println!(\"The longest string is {result}\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Post Content Based on State - Rust\nDESCRIPTION: This code snippet demonstrates how to update the `content` method on the `Post` struct to delegate to a `content` method defined on its current `state`. It also shows how to add a `content` method to the `State` trait with a default implementation and override it in the `Published` struct to return the actual content of the post.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter18.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nimpl Post {\n    // --snip--\n    pub fn content(&self) -> &str {\n        self.state.as_ref().unwrap().content(self)\n    }\n    // --snip--\n}\n\ntrait State {\n    // --snip--\n    fn content<'a>(&self, post: &'a Post) -> &'a str {\n        \"\"\n    }\n}\n\n// --snip--\nstruct Published {}\n\nimpl State for Published {\n    // --snip--\n    fn content<'a>(&self, post: &'a Post) -> &'a str {\n        &post.content\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Trait for NewsArticle and Tweet structs in Rust\nDESCRIPTION: This code implements the `Summary` trait for the `NewsArticle` and `Tweet` structs. The `summarize` method generates a summary string specific to each type, leveraging the struct's fields. This demonstrates how to implement trait methods with custom behavior for different types.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\npub struct NewsArticle {\n    pub headline: String,\n    pub location: String,\n    pub author: String,\n    pub content: String,\n}\n\nimpl Summary for NewsArticle {\n    fn summarize(&self) -> String {\n        format!(\"{}, by {} ({})\", self.headline, self.author, self.location)\n    }\n}\n\npub struct Tweet {\n    pub username: String,\n    pub content: String,\n    pub reply: bool,\n    pub retweet: bool,\n}\n\nimpl Summary for Tweet {\n    fn summarize(&self) -> String {\n        format!(\"{}: {}\", self.username, self.content)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Rust Tests with Cargo\nDESCRIPTION: This snippet shows the execution of Rust tests using the `cargo test` command. It includes compilation details, test results, and failure output, demonstrating the process of identifying and debugging failing tests in a Rust project.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/no-listing-03-introducing-a-bug/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test\n Compiling rectangle v0.1.0 (file:///projects/rectangle)\n  Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n  Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)\n\nrunning 2 tests\ntest tests::larger_can_hold_smaller ... FAILED\ntest tests::smaller_cannot_hold_larger ... ok\n\nfailures:\n\n---- tests::larger_can_hold_smaller stdout ----\n\nthread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:\nassertion failed: larger.can_hold(&smaller)\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::larger_can_hold_smaller\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n```\n\n----------------------------------------\n\nTITLE: Running Cargo Project\nDESCRIPTION: This snippet shows the output of the command `cargo run` which compiles and executes a rust project.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch19-patterns-and-matching/listing-19-03/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling patterns v0.1.0 (file:///projects/patterns)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.52s\n   Running `target/debug/patterns`\na is at index 0\nb is at index 1\nc is at index 2\n```\n\n----------------------------------------\n\nTITLE: Calling Associated Function Directly on Struct\nDESCRIPTION: This code demonstrates calling an associated function defined directly on a struct. Requires the `Animal` trait and `Dog` struct definition from the previous example.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-02-advanced-traits.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    println!(\"A baby dog is named {}\", Dog::baby_name());\n}\n```\n\n----------------------------------------\n\nTITLE: Using `use` statements without nested paths in Rust\nDESCRIPTION: This code snippet demonstrates using multiple `use` statements to bring items from the `std` module into scope, without using nested paths. It shows the less concise way of importing multiple items.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse std::io;\nuse std::cmp::Ordering;\n```\n\n----------------------------------------\n\nTITLE: Cargo Check Compilation Error\nDESCRIPTION: This snippet shows the error output from `cargo check`, indicating that the `ThreadPool` type is undeclared. To fix this, ensure the `ThreadPool` type is imported from a crate or defined within the current module.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch21-web-server/listing-21-12/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo check\n    Checking hello v0.1.0 (file:///projects/hello)\nerror[E0433]: failed to resolve: use of undeclared type `ThreadPool`\n  --> src/main.rs:11:16\n   |\n11 |     let pool = ThreadPool::new(4);\n   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `hello` (bin \"hello\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Mutable Variable Declaration in Rust\nDESCRIPTION: This code snippet demonstrates how to declare a mutable variable in Rust using the `mut` keyword. The `mut` keyword allows the variable `x` to be reassigned with a new value. Mutable variables are useful when the value of a variable needs to change during the execution of the program.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut x = 5;\n    println!(\"The value of x is: {x}\");\n    x = 6;\n    println!(\"The value of x is: {x}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Crate Name in Cargo.toml\nDESCRIPTION: This snippet shows how to set the crate name in the Cargo.toml file. The `name` field under the `[package]` section specifies the unique identifier for the crate on crates.io.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-02-publishing-to-crates-io.md#_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"guessing_game\"\n```\n\n----------------------------------------\n\nTITLE: Shadowing Changes Variable Type in Rust\nDESCRIPTION: This code snippet shows how shadowing can be used to change the type of a variable. The variable `spaces` is first declared as a string and then shadowed with an integer representing the length of the string. This demonstrates the flexibility of shadowing compared to `mut`, which requires the type to remain the same.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet spaces = \"   \";\nlet spaces = spaces.len();\n```\n\n----------------------------------------\n\nTITLE: Using a string slice after appending\nDESCRIPTION: This snippet demonstrates that `push_str` takes a string slice, and therefore the original string slice `s2` can be used after being appended to `s1`. If `push_str` took ownership of `s2`, `s2` could not be printed.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nlet mut s1 = String::from(\"foo\");\nlet s2 = \"bar\";\ns1.push_str(s2);\nprintln!(\"s2 is {s2}\");\n```\n\n----------------------------------------\n\nTITLE: Adding License to Cargo.toml\nDESCRIPTION: This snippet illustrates how to specify the license for a crate in the Cargo.toml file using the `license` field. It uses the SPDX identifier `MIT` for the MIT License.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-02-publishing-to-crates-io.md#_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"guessing_game\"\nlicense = \"MIT\"\n```\n\n----------------------------------------\n\nTITLE: Simulating Await with Poll in Rust\nDESCRIPTION: This code snippet simulates how Rust might compile an `await` call using the `poll` method.  It shows a match statement on the result of `poll()`, handling both `Ready` and `Pending` states, but lacks the logic for properly handling the `Pending` state in a non-blocking manner.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_47\n\nLANGUAGE: rust\nCODE:\n```\nmatch page_title(url).poll() {\n    Ready(page_title) => match page_title {\n        Some(title) => println!(\"The title for {url} was {title}\"),\n        None => println!(\"{url} had no title\"),\n    }\n    Pending => {\n        // But what goes here?\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Unidiomatic `use` of Function in Rust\nDESCRIPTION: This code shows an unidiomatic way to bring a function into scope with `use` by specifying the full path to the function. While it compiles and functions correctly, it is considered less readable and maintainable than bringing in the parent module and then calling the function using the module name.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    use crate::front_of_house::hosting::add_to_waitlist;\n    add_to_waitlist();\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests for a Specific Crate\nDESCRIPTION: This snippet demonstrates how to run tests for a specific crate within a Cargo workspace using the `-p` flag. It shows the output of running `cargo test -p add_one`, which executes tests only for the `add_one` crate.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_28\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo test -p add_one\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.00s\n     Running unittests src/lib.rs (target/debug/deps/add_one-b3235fea9a156f74)\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests add_one\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Allowing Dynamically Sized Types\nDESCRIPTION: This code snippet shows how to allow a generic type parameter to be a dynamically sized type using `?Sized` in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_88\n\nLANGUAGE: Rust\nCODE:\n```\nT: ?Sized\n```\n\n----------------------------------------\n\nTITLE: Formatting Rust Code with cargo fmt\nDESCRIPTION: This command formats all the Rust code in the current Cargo crate, ensuring consistent code style across the project. It should only change the code style and not the code semantics. The rustfmt tool needs to be installed.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix_d.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo fmt\n```\n\n----------------------------------------\n\nTITLE: Storing Enum and Data with Structs in Rust\nDESCRIPTION: This snippet defines an `IpAddr` struct containing an `IpAddrKind` enum and a `String` to represent an IP address. It then creates two instances, `home` and `loopback`, demonstrating the usage. Requires the `IpAddrKind` enum to be defined.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nenum IpAddrKind {\n    V4,\n    V6,\n}\n\nstruct IpAddr {\n    kind: IpAddrKind,\n    address: String,\n}\n\nlet home = IpAddr {\n    kind: IpAddrKind::V4,\n    address: String::from(\"127.0.0.1\"),\n};\n\nlet loopback = IpAddr {\n    kind: IpAddrKind::V6,\n    address: String::from(\"::1\"),\n};\n```\n\n----------------------------------------\n\nTITLE: Running a Rust program with backtrace enabled\nDESCRIPTION: This snippet shows how to run a Rust program with the `RUST_BACKTRACE` environment variable set to 1 to display a backtrace when a panic occurs. The backtrace provides information about the call stack, which can be used to identify the source of the panic.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch09-01-unrecoverable-errors-with-panic.md#_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ RUST_BACKTRACE=1 cargo run\nthread 'main' panicked at src/main.rs:4:6:\nindex out of bounds: the len is 3 but the index is 99\nstack backtrace:\n   0: rust_begin_unwind\n             at /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/panicking.rs:692:5\n   1: core::panicking::panic_fmt\n             at /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/panicking.rs:75:14\n   2: core::panicking::panic_bounds_check\n             at /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/panicking.rs:273:5\n   3: <usize as core::slice::index::SliceIndex<[T]>>::index\n             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/slice/index.rs:274:10\n   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index\n             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/slice/index.rs:16:9\n   5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index\n             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3361:9\n   6: panic::main\n             at ./src/main.rs:4:6\n   7: core::ops::function::FnOnce::call_once\n             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/ops/function.rs:250:5\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error\nDESCRIPTION: This snippet shows a Rust compilation error (E0277) that arises when attempting to directly add an `Option<i8>` to an `i8`. The error message indicates that the `Add` trait is not implemented for this combination. This requires handling the `Option` using `match`, `if let`, or `.unwrap_or()` before the addition.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch06-enums-and-pattern-matching/no-listing-07-cant-use-option-directly/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nCompiling enums v0.1.0 (file:///projects/enums)\nerror[E0277]: cannot add `Option<i8>` to `i8`\n --> src/main.rs:5:17\n  |\n5 |     let sum = x + y;\n  |                 ^ no implementation for `i8 + Option<i8>`\n  |\n  = help: the trait `Add<Option<i8>>` is not implemented for `i8`\n  = help: the following other types implement trait `Add<Rhs>`:\n            `&i8` implements `Add<i8>`\n            `&i8` implements `Add`\n            `i8` implements `Add<&i8>`\n            `i8` implements `Add`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `enums` (bin \"enums\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Attempting to use FnOnce Closure with sort_by_key\nDESCRIPTION: This code demonstrates an attempt to use a closure that implements only the `FnOnce` trait with the `sort_by_key` method, which requires an `FnMut` closure. The closure attempts to move a `String` value from its environment into a vector, resulting in ownership transfer. The compiler prevents this because `sort_by_key` calls the closure multiple times, and moving the value out of the environment makes subsequent calls impossible.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-01-closures.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch13-functional-features/listing-13-08/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Attribute-like macro example\nDESCRIPTION: This code snippet illustrates the usage of an attribute-like macro in Rust. The `#[route(GET, \"/\")]` attribute annotates the `index` function. The attribute macro will process the function and the arguments passed to the attribute.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-05-macros.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n#[route(GET, \"/\")]\nfn index() {\n```\n\n----------------------------------------\n\nTITLE: Sorting Rectangles by Width using `sort_by_key` and `FnMut` in Rust\nDESCRIPTION: This example demonstrates how to use `sort_by_key` to sort a slice of `Rectangle` structs by their `width` attribute. It showcases a closure that doesn't capture, mutate, or move anything from its environment, thus meeting the `FnMut` trait bound required by `sort_by_key`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let mut list = [\n        Rectangle { width: 10, height: 1 },\n        Rectangle { width: 3, height: 5 },\n        Rectangle { width: 7, height: 12 },\n    ];\n\n    list.sort_by_key(|r| r.width);\n    println!(\"{list:#?}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Borrowing Error: Mutable Borrow After Immutable\nDESCRIPTION: This code snippet demonstrates the Rust borrowing rules. It attempts to create immutable references (r1, r2) and then a mutable reference (r3) to the same variable `s`. This violates Rust's borrowing rules, which state that you cannot have both mutable and immutable borrows of the same data at the same time. The snippet results in a compile-time error E0502, which the compiler explains.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch04-understanding-ownership/no-listing-12-immutable-and-mutable-not-allowed/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet r1 = &s; // no problem\nlet r2 = &s; // no problem\nlet r3 = &mut s; // BIG PROBLEM\n\nprintln!(\"{}, {}, and {}\", r1, r2, r3);\n```\n\n----------------------------------------\n\nTITLE: Mapping Iterator Elements (Rust)\nDESCRIPTION: This code snippet attempts to use the `map` iterator adapter to increment each element of the vector. However, the result of the `map` call is not consumed, which leads to a compiler warning because iterators are lazy and do nothing unless consumed. This highlights that iterator adapters need to be chained with consuming adapters like `collect` to produce a result.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nlet v1: Vec<i32> = vec![1, 2, 3];\n\nv1.iter().map(|x| x + 1);\n```\n\n----------------------------------------\n\nTITLE: Defining a function with lifetime annotations\nDESCRIPTION: This function, `longest`, takes two string slices as input and returns the longest one.  It uses lifetime annotations to specify that the returned reference will be valid as long as both input references are valid. The `'a` lifetime parameter is used to connect the lifetimes of the input parameters and the return value, ensuring that the returned reference doesn't outlive the input references.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_40\n\nLANGUAGE: rust\nCODE:\n```\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Underscore vs Underscore Prefix Rust\nDESCRIPTION: This code highlights the difference between using `_` and `_s` in patterns.  `_s` binds the value of `s` causing a move and prevents later use of `s`. `_` does not bind the value so ownership isn't transferred and `s` can be used again. The first example fails to compile because `_s` takes ownership of `s`, while the second compiles successfully because `_` does not bind the value.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_27\n\nLANGUAGE: rust\nCODE:\n```\n    let s = Some(String::from(\"Hello!\"));\n\n    if let Some(_s) = s {\n        println!(\"found a string\");\n    }\n\n    println!(\"{s:?}\");\n```\n\nLANGUAGE: rust\nCODE:\n```\n    let s = Some(String::from(\"Hello!\"));\n\n    if let Some(_) = s {\n        println!(\"found a string\");\n    }\n\n    println!(\"{s:?}\");\n```\n\n----------------------------------------\n\nTITLE: Rust Compiler Error: Recursive Type\nDESCRIPTION: This snippet shows a Rust compiler error (E0072) indicating that the `List` type has infinite size because it is defined recursively without indirection (e.g., a `Box`). The error message suggests inserting a `Box` to break the cycle. It occurs when attempting to compile a `cons-list` project.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch15-smart-pointers/listing-15-03/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nerror[E0072]: recursive type `List` has infinite size\n --> src/main.rs:1:1\n  |\n1 | enum List {\n  | ^^^^^^^^^\n2 |     Cons(i32, List),\n  |               ---- recursive without indirection\n  |\nhelp: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n  |\n2 |     Cons(i32, Box<List>),\n  |               ++++    +\n```\n\n----------------------------------------\n\nTITLE: Adding rand crate dependency in Cargo.toml\nDESCRIPTION: This snippet shows how to add the `rand` crate as a dependency in the Cargo.toml file. It specifies the crate name and version using semantic versioning.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_12\n\nLANGUAGE: toml\nCODE:\n```\nrand = \"0.8.5\"\n```\n\n----------------------------------------\n\nTITLE: Conditional Background Color with if let\nDESCRIPTION: This code determines a background color based on user preferences and conditions using a combination of `if let`, `else if`, and `else`. It demonstrates how to check for a favorite color, the day of the week, and the user's age (parsed from a string). Multiple `if let` and `else if` blocks are used for different checks.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-01-all-the-places-for-patterns.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let favorite_color: Option<&str> = None;\n    let is_tuesday = false;\n    let age: Result<i32, _> = \"34\".parse();\n\n    if let Some(color) = favorite_color {\n        println!(\"Using your favorite color, {color}, as the background\");\n    } else if is_tuesday {\n        println!(\"Using green as the background color because it's Tuesday!\");\n    } else if let Ok(age) = age {\n        if age > 30 {\n            println!(\"Using purple as the background color\");\n        } else {\n            println!(\"Using orange as the background color\");\n        }\n    } else {\n        println!(\"Using blue as the background color\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Unresolved Import Error\nDESCRIPTION: Demonstrates the error that occurs when trying to use an external crate (`rand`) without declaring it as a dependency in the crate's Cargo.toml file.  The compiler reports an unresolved import error.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_25\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo build\n  --snip--\n   Compiling adder v0.1.0 (file:///projects/add/adder)\nerror[E0432]: unresolved import `rand`\n --> adder/src/main.rs:2:5\n  |\n2 | use rand;\n  |     ^^^^ no external crate `rand`\n```\n\n----------------------------------------\n\nTITLE: Rust Closure Type Mismatch Error\nDESCRIPTION: This snippet demonstrates a compilation error that arises when a Rust closure is called with different argument types. The closure `example_closure` is first called with a `String` argument and then with an integer `5`, leading to a type mismatch error because Rust infers the closure's argument type based on the first call.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch13-functional-features/listing-13-03/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n Compiling closure-example v0.1.0 (file:///projects/closure-example)\nerror[E0308]: mismatched types\n --> src/main.rs:5:29\n  |\n5 |     let n = example_closure(5);\n  |             --------------- ^- help: try using a conversion method: `.to_string()`\n  |             |               |\n  |             |               expected `String`, found integer\n  |             arguments to this function are incorrect\n  |\nnote: expected because the closure was earlier called with an argument of type `String`\n --> src/main.rs:4:29\n  |\n4 |     let s = example_closure(String::from(\"hello\"));\n  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`\n  |             |\n  |             in this closure call\nnote: closure parameter defined here\n --> src/main.rs:2:28\n  |\n2 |     let example_closure = |x| x;\n  |                            ^\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `closure-example` (bin \"closure-example\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream with Threads in Rust\nDESCRIPTION: This code snippet demonstrates how to create a stream using threads instead of async tasks. It uses `std::thread::spawn` to create a new thread that sends incrementing numbers over a channel. The `get_intervals` function returns a `Stream` that receives these numbers.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_54\n\nLANGUAGE: Rust\nCODE:\n```\nfn get_intervals() -> impl Stream<Item = u32> {\n    let (tx, rx) = trpl::channel();\n\n    // This is *not* `trpl::spawn` but `std::thread::spawn`!\n    thread::spawn(move || {\n        let mut count = 0;\n        loop {\n            // Likewise, this is *not* `trpl::sleep` but `std::thread::sleep`!\n            thread::sleep(Duration::from_millis(1));\n            count += 1;\n\n            if let Err(send_error) = tx.send(count) {\n                eprintln!(\"Could not send interval {count}: {send_error}\");\n                break;\n            };\n        }\n    });\n\n    ReceiverStream::new(rx)\n}\n```\n\n----------------------------------------\n\nTITLE: Finding the First Word in a String (Index-Based) - Rust\nDESCRIPTION: This code defines a function `first_word` that takes a `&String` and returns the index of the end of the first word (before the first space). It iterates through the bytes of the string, searching for a space character. If a space is found, the function returns the index of that space; otherwise, it returns the length of the string. This approach is prone to errors if the original string is modified after the index is obtained.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_23\n\nLANGUAGE: Rust\nCODE:\n```\nfn first_word(s: &String) -> usize {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return i;\n        }\n    }\n\n    s.len()\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo Build and Dependency Compilation\nDESCRIPTION: This snippet shows the output of the `cargo build` command, which is used to compile a Rust project. It includes the successful compilation of several dependencies such as `libc`, `getrandom`, `cfg-if`, `ppv-lite86`, `rand_core`, `rand_chacha`, and `rand` before attempting to compile the main project `guessing_game`.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch02-guessing-game-tutorial/listing-02-04/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo build\n   Compiling libc v0.2.86\n   Compiling getrandom v0.2.2\n   Compiling cfg-if v1.0.0\n   Compiling ppv-lite86 v0.2.10\n   Compiling rand_core v0.6.2\n   Compiling rand_chacha v0.3.0\n   Compiling rand v0.8.5\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n```\n\n----------------------------------------\n\nTITLE: Rust Mutable Borrow Error\nDESCRIPTION: This code snippet demonstrates a Rust compilation error (E0499) caused by attempting to borrow a mutable variable more than once simultaneously. The code attempts to create two mutable references (`r1` and `r2`) to the same variable `s`, which violates Rust's borrowing rules. The error message highlights the conflicting borrows and their locations.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch04-understanding-ownership/no-listing-10-multiple-mut-not-allowed/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nerror[E0499]: cannot borrow `s` as mutable more than once at a time\n --> src/main.rs:5:14\n  |\n4 |     let r1 = &mut s;\n  |              ------ first mutable borrow occurs here\n5 |     let r2 = &mut s;\n  |              ^^^^^^ second mutable borrow occurs here\n6 |\n7 |     println!(\"{}, {}\", r1, r2);\n  |                        -- first borrow later used here\n```\n\n----------------------------------------\n\nTITLE: Invalid Array Access (Panicking)\nDESCRIPTION: This code snippet demonstrates how accessing an array element with an out-of-bounds index causes a runtime panic in Rust. Rust's memory safety checks prevent invalid memory access, resulting in an immediate program termination with an error message.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-02-data-types.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nuse std::io;\n\nfn main() {\n    let a = [1, 2, 3, 4, 5];\n\n    println!(\"Please enter an array index.\");\n\n    let mut index = String::new();\n\n    io::stdin()\n        .read_line(&mut index)\n        .expect(\"Failed to read line\");\n\n    let index: usize = index\n        .trim()\n        .parse()\n        .expect(\"Index entered was not a number\");\n\n    let element = a[index];\n\n    println!(\"The value of the element at index {} is: {}\", index, element);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Executing Cargo Test\nDESCRIPTION: This snippet shows the execution of the `cargo test` command within a Rust project. It compiles the project and then runs both unit tests and doc tests. The output indicates whether the tests passed or failed, along with summary statistics.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/no-listing-02-adding-another-rectangle-test/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test\n   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)\n\nrunning 2 tests\ntest tests::larger_can_hold_smaller ... ok\ntest tests::smaller_cannot_hold_larger ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests rectangle\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Using an Iterator in a for Loop (Rust)\nDESCRIPTION: This code snippet demonstrates how to use an iterator in a `for` loop to process each element of the vector. The `for` loop implicitly calls the `next` method on the iterator until it returns `None`. Each element in the iterator is printed to the console using `println!`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nlet v1 = vec![1, 2, 3];\n\nlet v1_iter = v1.iter();\n\nfor val in v1_iter {\n    println!(\"Got: {val}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using Outer Block Doc Comment\nDESCRIPTION: This code snippet demonstrates the use of an outer block doc comment in Rust. Outer block doc comments are enclosed in `/**` and `*/`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_101\n\nLANGUAGE: Rust\nCODE:\n```\n/**...*/\n```\n\n----------------------------------------\n\nTITLE: Longest Function Without Lifetimes\nDESCRIPTION: This implementation of the `longest` function takes two string slices as input and returns a string slice. However, it lacks lifetime annotations, causing a compilation error because Rust cannot determine the relationship between the lifetimes of the input and output references.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_38\n\nLANGUAGE: rust\nCODE:\n```\nfn longest(x: &str, y: &str) -> &str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified read_line with expect - Rust\nDESCRIPTION: This snippet shows a more compact way to read a line from standard input and handle potential errors using the `expect` method.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter02.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nio::stdin().read_line(&mut guess).expect(\"Failed to read line\");\n```\n\n----------------------------------------\n\nTITLE: Cargo Test and Compilation Error in Rust\nDESCRIPTION: This snippet shows the output of `cargo test`, which results in a compilation error. The error E0596 indicates that `self.sent_messages` cannot be borrowed as mutable because `self` is an immutable reference (`&`). To fix this, the `send` method in both the `trait` definition and `impl` block needs to take a mutable reference (`&mut`) to `self`.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch15-smart-pointers/listing-15-21/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo test\n Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)\nerror[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&` reference\n  --> src/lib.rs:58:13\n   |\n58 |             self.sent_messages.push(String::from(message));\n   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n   |\nhelp: consider changing this to be a mutable reference in the `impl` method and the `trait` definition\n   |\n2  ~     fn send(&mut self, msg: &str);\n3  | }\n...\n56 |     impl Messenger for MockMessenger {\n57 ~         fn send(&mut self, message: &str) {\n   |\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `limit-tracker` (lib test) due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Test results with a failing test\nDESCRIPTION: This console output shows the results of running tests when one test passes and another test fails.  It indicates the `FAILED` status for the `another` test and provides details about the panic.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-01-writing-tests.md#_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n{{#include ../listings/ch11-writing-automated-tests/listing-11-03/output.txt}}\n```\n\n----------------------------------------\n\nTITLE: ThreadPool build function with Result (Rust)\nDESCRIPTION: This code defines an alternative `build` function for creating a `ThreadPool`. Instead of panicking on invalid input, it returns a `Result` type. This approach is useful for handling errors in a recoverable way. `PoolCreationError` is an unmentioned custom error type.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-02-multithreaded.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\npub fn build(size: usize) -> Result<ThreadPool, PoolCreationError> {\n```\n\n----------------------------------------\n\nTITLE: Left-Shift and Assignment Operator Rust\nDESCRIPTION: This operator performs a left-shift operation and assigns the result to the variable. It's a shorthand for `var = var << expr`. The `ShlAssign` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_38\n\nLANGUAGE: Rust\nCODE:\n```\n`var <<= expr`\n```\n\n----------------------------------------\n\nTITLE: Specifying Parameters to Generic Type\nDESCRIPTION: This code snippet shows how to specify parameters to a generic type in a type declaration (e.g., `Vec<u8>`).\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_76\n\nLANGUAGE: Rust\nCODE:\n```\npath<...>\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Message Stream in Rust\nDESCRIPTION: This code creates a basic stream of string messages using an async channel.  The `get_messages` function creates a channel, sends a series of messages into it, and then converts the receiver into a `ReceiverStream`.  The main function then iterates through the stream and prints each received message.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_37\n\nLANGUAGE: rust\nCODE:\n```\nuse trpl::{ReceiverStream, Stream, StreamExt};\n\nfn main() {\n    trpl::run(async {\n        let mut messages = get_messages();\n\n        while let Some(message) = messages.next().await {\n            println!(\"{message}\");\n        }\n    });\n}\n\nfn get_messages() -> impl Stream<Item = String> {\n    let (tx, rx) = trpl::channel();\n\n    let messages = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"];\n    for message in messages {\n        tx.send(format!(\"Message: '{message}'\")).unwrap();\n    }\n\n    ReceiverStream::new(rx)\n}\n```\n\n----------------------------------------\n\nTITLE: Using the safe `split_at_mut` function in Rust\nDESCRIPTION: This example demonstrates how to use the safe `split_at_mut` function, which splits a mutable slice into two mutable slices at a given index.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-01-unsafe-rust.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut v = vec![1, 2, 3, 4, 5, 6];\n\n    let r = &mut v[..];\n\n    let (a, b) = r.split_at_mut(3);\n\n    assert_eq!(a, &mut [1, 2, 3]);\n    assert_eq!(b, &mut [4, 5, 6]);\n    println!(\"success\");\n}\n```\n\n----------------------------------------\n\nTITLE: Running Integration Tests\nDESCRIPTION: The `cargo test --test integration_test` command compiles and runs integration tests located in the `tests` directory.  The output shows compilation progress, the executed test file, and the results of each test case including passes, failures, and execution time. The test filename is specified after the `--test` flag.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/output-only-05-single-integration/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test --test integration_test\n Compiling adder v0.1.0 (file:///projects/adder)\n  Finished `test` profile [unoptimized + debuginfo] target(s) in 0.64s\n  Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)\n\nrunning 1 test\ntest it_adds_two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: \"And the rest\" Pattern Binding Operator Rust\nDESCRIPTION: This operator is used in pattern matching to ignore the remaining fields of a struct or enum variant. It allows matching only specific fields while ignoring the rest. This operator cannot be overloaded.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_28\n\nLANGUAGE: Rust\nCODE:\n```\n`variant(x, ..)`\n```\n\nLANGUAGE: Rust\nCODE:\n```\n`struct_type { x, .. }`\n```\n\n----------------------------------------\n\nTITLE: Attribute-like macro definition\nDESCRIPTION: This code snippet shows the function signature for defining an attribute-like macro in Rust. It takes two `TokenStream` parameters: `attr` for the attribute's contents and `item` for the annotated item. It returns a `TokenStream` that replaces the original item.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-05-macros.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n#[proc_macro_attribute]\npub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {\n```\n\n----------------------------------------\n\nTITLE: Equivalent non-async function - Rust\nDESCRIPTION: Shows the equivalent non-async function definition for an `async fn`. Demonstrates that an async function returns a future of the return type. The compiler handles the conversion under the hood.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-01-futures-and-syntax.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nasync fn page_title(url: String) -> Option<String>\n```\n\n----------------------------------------\n\nTITLE: Defining Case-Insensitive Search Function in Rust\nDESCRIPTION: This function `search_case_insensitive` performs a case-insensitive search within a given text `contents` for occurrences of a specified `query`. It converts both the query and each line of the contents to lowercase before performing the search using the `contains` method. The function returns a vector of string slices, each representing a line that contains the query.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_24\n\nLANGUAGE: Rust\nCODE:\n```\npub fn search_case_insensitive<'a>(\n    query: &str,\n    contents: &'a str,\n) -> Vec<&'a str> {\n    let query = query.to_lowercase();\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.to_lowercase().contains(&query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error: Borrow of Moved Value\nDESCRIPTION: This snippet illustrates a Rust compilation error (E0382) that occurs when attempting to borrow a String value after it has been moved to another variable. The error highlights the ownership concept in Rust and the behavior of non-`Copy` types.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch04-understanding-ownership/no-listing-04-cant-use-after-move/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nerror[E0382]: borrow of moved value: `s1`\n --> src/main.rs:5:15\n  |\n2 |     let s1 = String::from(\"hello\");\n  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait\n3 |     let s2 = s1;\n  |              -- value moved here\n4 |\n5 |     println!(\"{s1}, world!\");\n  |               ^^^^ value borrowed here after move\n  |\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider cloning the value if the performance cost is acceptable\n  |\n3 |     let s2 = s1.clone();\n  |                ++++++++\n```\n\n----------------------------------------\n\nTITLE: Executing Cargo Test\nDESCRIPTION: This snippet shows the output of running the `cargo test` command in a Rust project named guessing_game. It compiles the project and executes the unit tests.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/no-listing-09-guess-with-panic-msg-bug/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test\n Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n  Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n   Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)\n\nrunning 1 test\ntest tests::greater_than_100 - should panic ... FAILED\n\nfailures:\n\n---- tests::greater_than_100 stdout ----\n\nthread 'tests::greater_than_100' panicked at src/lib.rs:12:13:\nGuess value must be greater than or equal to 1, got 200.\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nnote: panic did not contain expected string\n      panic message: `\"Guess value must be greater than or equal to 1, got 200.\"`,\n expected substring: `\"less than or equal to 100\"`\n\nfailures:\n    tests::greater_than_100\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n```\n\n----------------------------------------\n\nTITLE: Running Rust Application with Cargo\nDESCRIPTION: This command compiles and runs a Rust application using Cargo, the Rust package manager and build tool. It shows the compilation process and the execution of the program. An example of runtime panic with index out of bounds error is provided. The environment variable RUST_BACKTRACE=1 is recommended for more detailed backtraces.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch12-an-io-project/listing-12-07/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling minigrep v0.1.0 (file:///projects/minigrep)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n  Running `target/debug/minigrep`\n\nthread 'main' panicked at src/main.rs:27:21:\nindex out of bounds: the len is 1 but the index is 1\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n```\n\n----------------------------------------\n\nTITLE: Illustrating Type Safety with Option\nDESCRIPTION: This code shows an example of how Rust's type system prevents direct operations between a concrete type (i8) and an `Option<i8>`. The compiler will throw an error if you attempt to add them without properly handling the potential absence of a value in the `Option`.  This highlights the safety benefits of using `Option` to avoid null-related errors.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nlet x: i8 = 5;\nlet y: Option<i8> = Some(5);\n\nlet sum = x + y;\n```\n\n----------------------------------------\n\nTITLE: Testing Panic Conditions with `should_panic` in Rust\nDESCRIPTION: This code demonstrates how to use the `#[should_panic]` attribute in Rust to test that a specific function panics under certain conditions. The `Guess::new` function is defined to panic if the input value is outside the range of 1 to 100. The test `greater_than_100` is annotated with `#[should_panic]` to verify this behavior.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\npub struct Guess {\n    value: i32,\n}\n\nimpl Guess {\n    pub fn new(value: i32) -> Guess {\n        if value < 1 || value > 100 {\n            panic!(\"Guess value must be between 1 and 100, got {value}.\");\n        }\n\n        Guess { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn greater_than_100() {\n        Guess::new(200);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Joining a Thread After Main Thread Execution (Rust)\nDESCRIPTION: This snippet demonstrates how to use `JoinHandle` to wait for a spawned thread to finish before the main thread exits.  The `handle.join().unwrap()` call blocks the main thread's execution until the spawned thread completes, ensuring all output from the spawned thread is printed. The thread alternates prints with the main thread until the spawned thread completes.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter16.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {i} from the spawned thread!\");\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!(\"hi number {i} from the main thread!\");\n        thread::sleep(Duration::from_millis(1));\n    }\n\n    handle.join().unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Ignoring Parts of a Value with Nested Underscore Rust\nDESCRIPTION: This code demonstrates how to use underscores within patterns to ignore parts of a value. In the first `match` arm, the code checks if both `setting_value` and `new_setting_value` are `Some`, regardless of the actual values inside `Some`. The second `match` statement shows how to ignore the second and fourth elements of a tuple.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\n    let mut setting_value = Some(5);\n    let new_setting_value = Some(10);\n\n    match (setting_value, new_setting_value) {\n        (Some(_), Some(_)) => {\n            println!(\"Can't overwrite an existing customized value\");\n        }\n        _ => {\n            setting_value = new_setting_value;\n        }\n    }\n\n    println!(\"setting is {setting_value:?}\");\n```\n\nLANGUAGE: rust\nCODE:\n```\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, _, third, _, fifth) => {\n            println!(\"Some numbers: {first}, {third}, {fifth}\")\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: ThreadPool Interface - Rust\nDESCRIPTION: This code defines the desired interface for a `ThreadPool` struct. It includes a `new` method to create the pool with a specified number of threads and an `execute` method that takes a closure to be run by one of the threads in the pool. This snippet does not compile as it shows only the interface and not the implementation.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-02-multithreaded.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    use std::net::TcpListener;\n\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    let pool = ThreadPool::new(4);\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n        pool.execute(|| {\n            handle_connection(stream)\n        });\n    }\n}\n\nfn handle_connection(stream: std::net::TcpStream) {} // Dummy implementation\n```\n\n----------------------------------------\n\nTITLE: Sending Multiple Values via Channel in Rust\nDESCRIPTION: This snippet demonstrates how to send multiple values from a spawned thread to the main thread using a channel. It creates a channel, spawns a thread that sends a vector of strings with a delay between each message, and the main thread receives and prints each message.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter16.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!(\"Got: {received}\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building the Book with mdBook\nDESCRIPTION: This command builds the Rust book using the mdBook tool. It generates the output in the `book` subdirectory.\nSOURCE: https://github.com/rust-lang/book/blob/main/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ mdbook build\n```\n\n----------------------------------------\n\nTITLE: Running All Tests - Cargo\nDESCRIPTION: This command runs all tests defined in the project. By default, tests are executed in parallel.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo test\n```\n\n----------------------------------------\n\nTITLE: Equality Comparison Operator Rust\nDESCRIPTION: This operator performs an equality comparison. It returns `true` if the left operand is equal to the right operand, and `false` otherwise. The `PartialEq` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_42\n\nLANGUAGE: Rust\nCODE:\n```\n`expr == expr`\n```\n\n----------------------------------------\n\nTITLE: Matching on Different Errors\nDESCRIPTION: This code snippet handles different kinds of errors using nested `match` expressions. If `File::open` fails because the file doesn't exist (`ErrorKind::NotFound`), it attempts to create the file. Otherwise, it panics. Requires `std::fs::File` and `std::io::ErrorKind` to be imported.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter09.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n\n    let greeting_file = match greeting_file_result {\n        Ok(file) => file,\n        Err(error) => match error.kind() {\n            ErrorKind::NotFound => match File::create(\"hello.txt\") {\n                Ok(fc) => fc,\n                Err(e) => panic!(\"Problem creating the file: {e:?}\"),\n            },\n            other_error => {\n                panic!(\"Problem opening the file: {other_error:?}\");\n            }\n        },\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Bringing a Module into Scope with Use Rust\nDESCRIPTION: This snippet illustrates how to bring a module into scope using the `use` keyword in Rust.  The `hosting` module is brought into scope, allowing `add_to_waitlist` to be called without specifying the full path each time. Note that the `use` statement only applies to the current scope.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\nuse crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo Test Execution\nDESCRIPTION: This snippet shows the execution of the `cargo test` command with the argument `one_hundred`. It demonstrates how cargo compiles the project, runs the specified test, and provides a summary of the results, including the number of tests passed, failed, ignored, and filtered out.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/output-only-02-single-test/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test one_hundred\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.69s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::one_hundred ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: `use` Statement Scope Limitation in Rust\nDESCRIPTION: This code illustrates that a `use` statement only applies to the scope in which it is defined.  The `eat_at_restaurant` function is moved into a new `customer` module, which is a different scope than the `use` statement in the parent module. Therefore, the shortcut created by `use` is no longer available within the `customer` module, resulting in a compile error.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\nmod customer {\n    fn eat_at_restaurant() {\n        hosting::add_to_waitlist();\n    }\n}\n\npub fn eat_at_restaurant() {\n    use crate::front_of_house::hosting;\n}\n```\n\n----------------------------------------\n\nTITLE: Conditionally Implementing Methods Based on Trait Bounds\nDESCRIPTION: This code defines a struct `Pair<T>` and conditionally implements the `cmp_display` method only for types `T` that implement both `Display` and `PartialOrd` traits. The `new` method is implemented for all `Pair<T>` types.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_31\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::fmt::Display;\n\nstruct Pair<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Pair<T> {\n    fn new(x: T, y: T) -> Self {\n        Self { x, y }\n    }\n}\n\nimpl<T: Display + PartialOrd> Pair<T> {\n    fn cmp_display(&self) {\n        if self.x >= self.y {\n            println!(\"The largest member is x = {}\", self.x);\n        } else {\n            println!(\"The largest member is y = {}\", self.y);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing mdBook with Cargo\nDESCRIPTION: This command installs the mdBook tool using cargo, the Rust package manager. The `--locked` flag ensures that the exact version specified is used, and the `--version` flag specifies the required version number.\nSOURCE: https://github.com/rust-lang/book/blob/main/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install mdbook --locked --version <version_num>\n```\n\n----------------------------------------\n\nTITLE: Running a Rust project with Cargo\nDESCRIPTION: This snippet shows the execution of a Rust project using the `cargo run` command. It includes the compilation step and the subsequent execution of the compiled binary, showing the standard output from the program.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch03-common-programming-concepts/no-listing-32-5-loop-labels/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n   Compiling loops v0.1.0 (file:///projects/loops)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.58s\n     Running `target/debug/loops`\ncount = 0\nremaining = 10\nremaining = 9\ncount = 1\nremaining = 10\nremaining = 9\ncount = 2\nremaining = 10\nEnd count = 2\n```\n\n----------------------------------------\n\nTITLE: Adding a Path Dependency in adder's Cargo.toml\nDESCRIPTION: This TOML code adds a path dependency on the `add_one` crate to the `adder` binary crate's `Cargo.toml` file. This allows the `adder` crate to use the `add_one` library crate.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-03-cargo-workspaces.md#_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nadd_one = { path = \"../add_one\" }\n```\n\n----------------------------------------\n\nTITLE: Boolean Condition Requirement in Rust 'if'\nDESCRIPTION: This example shows that Rust 'if' conditions must evaluate to a boolean value. Using an integer directly as a condition results in a compile-time error, as Rust does not automatically convert integers to booleans like some other languages.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_27\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let number = 3;\n\n    if number {\n        println!(\"number was three\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Aligning Stream Types (Does Not Compile)\nDESCRIPTION: This code demonstrates aligning the types of two streams to allow for merging. It uses `map` to transform the `intervals` stream into a string and creates a timeout of 10 seconds using `Duration::from_secs(10)` to match the `Timeout` type of the `messages` stream.  The stream is pinned and made mutable for iteration.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-04-streams.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nasync fn main() {\n    let messages = get_messages();\n    let intervals = get_intervals().map(|i| format!(\"Interval: {}\", i)).timeout(Duration::from_secs(10));\n\n    let merged = messages.merge(intervals);\n\n    pin_mut!(merged);\n\n    while let Some(msg) = merged.next().await {\n        println!(\"Got: {}\", msg);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Constant Declaration in Rust\nDESCRIPTION: This code snippet shows how to declare a constant in Rust using the `const` keyword. Constants are always immutable and must have their type annotated. They can be declared in any scope and are typically used for values that are known at compile time and are needed throughout the program.  The example calculates the number of seconds in three hours.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nconst THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;\n```\n\n----------------------------------------\n\nTITLE: Adding a character to a String with push\nDESCRIPTION: This snippet demonstrates how to add a single character to a `String` using the `push` method. The `push` method takes a `char` as input and appends it to the end of the `String`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nlet mut s = String::from(\"lo\");\ns.push('l');\n```\n\n----------------------------------------\n\nTITLE: Config::build Function Reproduction\nDESCRIPTION: This is a reproduction of the `Config::build` function from Listing 12-23, showcasing the original implementation before iterator-based improvements. It takes a slice of `String` values and clones them to create a `Config` instance.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-03-improving-our-io-project.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nimpl Config {\n    pub fn build(args: &[String]) -> Result<Config, &'static str> {\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config { query, file_path })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Calling a Function with Enum Variants in Rust\nDESCRIPTION: This code calls the `route` function with both `IpAddrKind::V4` and `IpAddrKind::V6` as arguments. It demonstrates how to pass enum variants to a function that accepts the enum as a parameter.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-01-defining-an-enum.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nroute(IpAddrKind::V4);\nroute(IpAddrKind::V6);\n```\n\n----------------------------------------\n\nTITLE: Making `hosting` Module and `add_to_waitlist` Function Public in Rust\nDESCRIPTION: This snippet illustrates how to make both the `hosting` module and the `add_to_waitlist` function public, allowing the `eat_at_restaurant` function to call it. The `pub` keyword is essential for exposing functions within public modules.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Absolute path\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // Relative path\n    front_of_house::hosting::add_to_waitlist();\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Alternatives Operator Rust\nDESCRIPTION: This operator is used to specify multiple alternative patterns in a match arm. It allows matching one of several different patterns. This operator cannot be overloaded.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_51\n\nLANGUAGE: Rust\nCODE:\n```\n<code>pat &vert; pat</code>\n```\n\n----------------------------------------\n\nTITLE: Hypothetical Iterator Trait Definition Using Generics in Rust\nDESCRIPTION: This code snippet demonstrates a hypothetical definition of the `Iterator` trait using generics.  While it achieves similar functionality to associated types, it allows for multiple implementations of `Iterator` for the same type with different item types, requiring explicit type annotation when calling `next`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-02-advanced-traits.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait Iterator<T> {\n    fn next(&mut self) -> Option<T>;\n}\n```\n\n----------------------------------------\n\nTITLE: Case-Sensitive Test in Rust\nDESCRIPTION: This test asserts that a case-sensitive search for the query \"duct\" in the provided contents returns the line \"safe, fast, productive.\". It verifies that the search function correctly identifies the matching line while respecting the case of the characters.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\n#[test]\n    fn case_sensitive() {\n        let query = \"duct\";\n        let contents = \"\\\nRust:\nsafe, fast, productive.\nPick three.\nDuct tape.\";\n\n        assert_eq!(vec![\"safe, fast, productive.\"], search(query, contents));\n    }\n```\n\n----------------------------------------\n\nTITLE: Executing Rust Tests with Cargo\nDESCRIPTION: This snippet shows the command to run Rust tests using the Cargo build system. It compiles the project and executes unit tests defined in the `src/lib.rs` file. The output includes the test results, such as the number of tests passed and failed, as well as error messages for failed tests.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/listing-11-03/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test\n Compiling adder v0.1.0 (file:///projects/adder)\n  Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s\n   Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 2 tests\ntest tests::another ... FAILED\ntest tests::exploration ... ok\n\nfailures:\n\n---- tests::another stdout ----\n\nthread 'tests::another' panicked at src/lib.rs:17:9:\nMake this test fail\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::another\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n```\n\n----------------------------------------\n\nTITLE: Async Futures with Thread Sleep for CPU-Bound Work in Rust\nDESCRIPTION: This code defines two async futures, `a` and `b`, which simulate CPU-bound work using the `slow` function. Each future performs a series of slow operations with delays, followed by a `trpl::sleep` call. The `trpl::race` function is then used to execute the futures concurrently, with the first completing future determining the overall result. The code utilizes `std::thread::sleep` (via `slow`) to block the thread for a specified duration, simulating CPU-bound work and allowing control to switch between futures. The futures are named 'a' and 'b'.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_27\n\nLANGUAGE: rust\nCODE:\n```\nlet a = async {\n    println!(\"'a' started.\");\n    slow(\"a\", 30);\n    slow(\"a\", 10);\n    slow(\"a\", 20);\n    trpl::sleep(Duration::from_millis(50)).await;\n    println!(\"'a' finished.\");\n};\n\nlet b = async {\n    println!(\"'b' started.\");\n    slow(\"b\", 75);\n    slow(\"b\", 10);\n    slow(\"b\", 15);\n    slow(\"b\", 350);\n    trpl::sleep(Duration::from_millis(50)).await;\n    println!(\"'b' finished.\");\n};\n\ntrpl::race(a, b).await;\n```\n\n----------------------------------------\n\nTITLE: Filtering a Stream with StreamExt::filter\nDESCRIPTION: This code snippet demonstrates how to filter a stream using the `StreamExt::filter` method in Rust. The code creates a stream from a range of numbers, doubles the values, and then filters the stream to only include multiples of 3 or 5. The filtered stream is then iterated over, and the values are printed.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_36\n\nLANGUAGE: rust\nCODE:\n```\nuse trpl::StreamExt;\n\nfn main() {\n    trpl::run(async {\n        let values = 1..101;\n        let iter = values.map(|n| n * 2);\n        let stream = trpl::stream_from_iter(iter);\n\n        let mut filtered =\n            stream.filter(|value| value % 3 == 0 || value % 5 == 0);\n\n        while let Some(value) = filtered.next().await {\n            println!(\"The value was: {value}\");\n        }\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Option::unwrap_or_else Implementation\nDESCRIPTION: This code snippet shows the implementation of the `unwrap_or_else` method on `Option<T>`. It takes a closure `f` of type `F` which must implement the `FnOnce() -> T` trait, meaning it can be called at most once. If the `Option` is `Some`, the contained value is returned; otherwise, the closure `f` is called and its result is returned.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch13-01-closures.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nimpl<T> Option<T> {\n    pub fn unwrap_or_else<F>(self, f: F) -> T\n    where\n        F: FnOnce() -> T\n    {\n        match self {\n            Some(x) => x,\n            None => f(),\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining StreamExt Trait (Old Rust Version)\nDESCRIPTION: This snippet presents an alternative `StreamExt` trait definition for older Rust versions that did not support `async` functions in traits.  It defines the `next` method, returning a `Next<'_, Self>` type, which is a `struct` implementing `Future`. This allows using `await` with the method, accommodating the lifetime of the reference to `self`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_53\n\nLANGUAGE: rust\nCODE:\n```\nfn next(&mut self) -> Next<'_, Self> where Self: Unpin;\n```\n\n----------------------------------------\n\nTITLE: Updating Crate Versions in Cargo\nDESCRIPTION: This shell command demonstrates how to update crate versions using the `cargo update` command. It ignores the `Cargo.lock` file and fetches the latest compatible versions based on the `Cargo.toml` specifications.  The output shows the updating of the `rand` crate from version 0.8.5 to 0.8.6.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter02.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo update\n    Updating crates.io index\n     Locking 1 package to latest Rust 1.85.0 compatible version\n    Updating rand v0.8.5 -> v0.8.6 (available: v0.9.0)\n```\n\n----------------------------------------\n\nTITLE: Calling C `abs` function with FFI in Rust\nDESCRIPTION: This snippet demonstrates how to call the C standard library's `abs` function from Rust using the `extern` keyword.  It defines the external function signature within an `extern \"C\"` block and then calls it within an `unsafe` block in the `main` function.  The `unsafe` block is required because Rust cannot guarantee the safety of code written in other languages.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/ffi.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nextern \"C\" {\n    fn abs(input: i32) -> i32;\n}\n\nfn main() {\n    unsafe {\n        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using `?` in `main` Function with Incompatible Return Type - Rust\nDESCRIPTION: This code snippet demonstrates an attempt to use the `?` operator in the `main` function, which has a return type of `()`.  The `File::open` function returns a `Result`, and using `?` on it requires the `main` function to return a `Result` or `Option` to handle the potential error. This example showcases the compiler error that occurs when the return types are incompatible.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter09.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\")?;\n}\n```\n\n----------------------------------------\n\nTITLE: Function and Closures Comparison in Rust\nDESCRIPTION: This code compares a function definition with different variations of closure definitions. The function `add_one_v1` and the closures `add_one_v2`, `add_one_v3`, and `add_one_v4` all achieve the same result: adding 1 to the input. The example demonstrates the optional nature of type annotations and brackets in closures.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn  add_one_v1   (x: u32) -> u32 { x + 1 }\nlet add_one_v2 = |x: u32| -> u32 { x + 1 };\nlet add_one_v3 = |x|             { x + 1 };\nlet add_one_v4 = |x|               x + 1  ;\n```\n\n----------------------------------------\n\nTITLE: Spawning a Thread for Each Request in Rust\nDESCRIPTION: This code snippet shows how to spawn a new thread for each incoming connection in a Rust web server using `thread::spawn`. The `handle_connection` function is executed in a new thread for each `TcpStream`. This approach allows the server to handle multiple requests concurrently but can lead to resource exhaustion if the number of requests is high.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        thread::spawn(|| {\n            handle_connection(stream);\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Type Mismatch Error in Rust 'if' Assignment\nDESCRIPTION: This example demonstrates the error that occurs when the 'if' and 'else' branches of an 'if' expression return incompatible types.  In this case, the 'if' branch returns an integer (5), while the 'else' branch returns a string (\"six\"), leading to a compile-time error because the compiler cannot infer a single type for the 'number' variable.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_31\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let condition = true;\n\n    let number = if condition { 5 } else { \"six\" };\n\n    println!(\"The value of number is: {number}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Async Timeout Usage Example in Rust\nDESCRIPTION: This snippet demonstrates how to use the `timeout` function with a slow future. It defines a slow future that sleeps for 100 milliseconds and then uses `timeout` to limit the execution time to 10 milliseconds. The result is then matched to print either a success message or a timeout error.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_31\n\nLANGUAGE: rust\nCODE:\n```\nlet slow = async {\n            trpl::sleep(Duration::from_millis(100)).await;\n            \"I finished!\"\n        };\n\n        match timeout(slow, Duration::from_millis(10)).await {\n            Ok(message) => println!(\"Succeeded with '{message}'\"),\n            Err(duration) => {\n                println!(\"Failed after {} seconds\", duration.as_secs())\n            }\n        }\n```\n\n----------------------------------------\n\nTITLE: Ignoring Tests with #[ignore] in Rust\nDESCRIPTION: This snippet demonstrates how to use the `#[ignore]` attribute to exclude specific tests from running during normal test execution. The `expensive_test` function is marked with `#[ignore]`, so it will be skipped unless specifically requested.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_works() {\n        let result = add(2, 2);\n        assert_eq!(result, 4);\n    }\n\n    #[test]\n    #[ignore]\n    fn expensive_test() {\n        // code that takes an hour to run\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error: Multiple `..` in Tuple Pattern\nDESCRIPTION: This snippet demonstrates a Rust compilation error that occurs when the `..` pattern is used more than once within a tuple pattern. The error message indicates that the `..` pattern can only be used once per tuple pattern. The code attempts to match a tuple pattern with multiple `..` placeholders, leading to the compilation error.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch19-patterns-and-matching/listing-19-25/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n Compiling patterns v0.1.0 (file:///projects/patterns)\nerror: `..` can only be used once per tuple pattern\n --> src/main.rs:5:22\n  |\n5 |         (.., second, ..) => {\n  |          --          ^^ can only be used once per tuple pattern\n  |          |\n  |          previously used here\n\nerror: could not compile `patterns` (bin \"patterns\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Rust Borrowing Error Example\nDESCRIPTION: This code snippet demonstrates a common Rust borrowing error. The `first_word` function borrows `s` immutably. Subsequently, `s.clear()` attempts to borrow `s` mutably, which is disallowed because an immutable borrow already exists. The immutable borrow persists until it is used in the `println!` macro.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch04-understanding-ownership/no-listing-19-slice-error/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nerror[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable\n  --> src/main.rs:18:5\n   |\n16 |     let word = first_word(&s);\n   |                           -- immutable borrow occurs here\n17 |\n18 |     s.clear(); // error!\n   |     ^^^^^^^^^ mutable borrow occurs here\n19 |\n20 |     println!(\"the first word is: {word}\");\n   |                                  ------ immutable borrow later used here\n```\n\n----------------------------------------\n\nTITLE: Basic Polling Loop in Rust\nDESCRIPTION: This code snippet demonstrates a basic loop attempting to poll a future until it's ready. It showcases handling the `Ready` and `Pending` states, printing a title if available or continuing the loop otherwise. This naive implementation would block the thread, defeating the purpose of asynchronous operations.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_48\n\nLANGUAGE: rust\nCODE:\n```\nlet mut page_title_fut = page_title(url);\nloop {\n    match page_title_fut.poll() {\n        Ready(value) => match page_title {\n            Some(title) => println!(\"The title for {url} was {title}\"),\n            None => println!(\"{url} had no title\"),\n        }\n        Pending => {\n            // continue\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Searching a String with a Loop in Rust\nDESCRIPTION: This function searches for lines in a given string that contain a specified query using a traditional `for` loop. It iterates through each line, checks if the query exists, and adds the line to a vector of results. The function returns a `Vec` of string slices.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_22\n\nLANGUAGE: Rust\nCODE:\n```\npub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.contains(query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n```\n\n----------------------------------------\n\nTITLE: Validate Thread Count in ThreadPool::new - Rust\nDESCRIPTION: This code implements the `new` function for the `ThreadPool` struct, including validation to ensure the size is greater than zero. It uses the `assert!` macro to panic if the size is zero. It also includes documentation comments for the `ThreadPool` with doc comments.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        ThreadPool\n    }\n\n    // --snip--\n}\n```\n\n----------------------------------------\n\nTITLE: Running Cargo Tests with Ignored Flag\nDESCRIPTION: This snippet demonstrates running tests, including those marked as ignored, within a Rust project using the cargo test command. The `-- --ignored` flag is used to include ignored tests in the test execution.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/output-only-04-running-ignored/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test -- --ignored\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest expensive_test ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Testing Equality with assert_eq! and Bug in Rust\nDESCRIPTION: This code shows how `assert_eq!` catches a bug when the `add_two` function incorrectly adds 3 instead of 2. The test fails and provides a message indicating that the left value (5) is not equal to the right value (4). Dependencies: None. Inputs: Integer `a`. Outputs: Integer `a+3`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\npub fn add_two(a: usize) -> usize {\n    a + 3\n}\n```\n\n----------------------------------------\n\nTITLE: Modified can_hold method with a bug in Rust\nDESCRIPTION: This code snippet demonstrates a buggy implementation of the `can_hold` method in the `Rectangle` struct. The greater-than sign (>) used for comparing widths is intentionally replaced with a less-than sign (<), which will cause the `larger_can_hold_smaller` test to fail, showcasing how tests can catch bugs.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n// --snip--\nimpl Rectangle {\n    fn can_hold(&self, other: &Rectangle) -> bool {\n        self.width < other.width && self.height > other.height\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Example Rust Code After cargo fix\nDESCRIPTION: This is the corrected Rust code after running `cargo fix`. The `mut` keyword has been removed from the variable `x`, resolving the compiler warning.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-04-useful-development-tools.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = 42;\n    println!(\"{x}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Boolean Declaration Rust\nDESCRIPTION: Demonstrates how to declare boolean variables in Rust using the `bool` type. It shows both implicit and explicit type annotations when assigning `true` and `false` values.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let t = true;\n\n    let f: bool = false; // with explicit type annotation\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Mutable References in Rust\nDESCRIPTION: This Rust code attempts to create two mutable references to the same string `s` at the same time. This is not allowed in Rust and results in a compile-time error, preventing data races.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nlet mut s = String::from(\"hello\");\n\nlet r1 = &mut s;\nlet r2 = &mut s;\n\nprintln!(\"{}, {}\", r1, r2);\n```\n\n----------------------------------------\n\nTITLE: Storing Anonymous Futures in a Vector (Incorrect)\nDESCRIPTION: This code attempts to store anonymous futures with the same output type in a vector and then use `join_all`. However, it results in a type mismatch error because each async block creates a unique enum. This illustrates the problem of storing different anonymous future types in a single collection.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-03-more-futures.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse tokio::sync::mpsc;\nuse futures::future;\n\n#[tokio::main]\nasync fn main() {\n    let (tx1, mut rx1) = mpsc::channel::<i32>(100);\n    let (tx2, rx2) = mpsc::channel::<i32>(100);\n    let mut tx_fut = async move {\n        let mut i = 0;\n        loop {\n            // Maybe the receiver dropped\n            if tx1.send(i).await.is_err() {\n                break;\n            }\n            i += 1;\n        }\n    };\n\n    let mut rx_fut = async {\n        loop {\n            if rx1.recv().await.is_none() {\n                break;\n            }\n        }\n    };\n    let mut tx1_fut = async move {\n        let mut i = 0;\n        loop {\n            // Maybe the receiver dropped\n            if tx2.send(i).await.is_err() {\n                break;\n            }\n            i += 1;\n        }\n    };\n\n    let futures = vec![tx1_fut, rx_fut, tx_fut];\n    future::join_all(futures).await;\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Statement Assignment in Rust (Compile Error)\nDESCRIPTION: This snippet demonstrates an invalid attempt to assign a `let` statement to another variable. It results in a compile-time error because statements in Rust do not return values. This is different from languages like C and Ruby where assignment expressions return a value.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-03-how-functions-work.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = (let y = 6);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a String from String Literal using String::from() in Rust\nDESCRIPTION: Shows how to create a `String` from a string literal using the `String::from()` function.  This method achieves the same outcome as using `to_string()` but offers a different style.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-02-strings.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet s = String::from(\"initial contents\");\n```\n\n----------------------------------------\n\nTITLE: Generated Code from Vec Macro Expansion\nDESCRIPTION: This shows the code that is generated after the `vec!` macro is expanded with the arguments `1`, `2`, and `3`. It illustrates how the macro transforms the input into Rust code that creates and populates a vector.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-05-macros.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n{\n    let mut temp_vec = Vec::new();\n    temp_vec.push(1);\n    temp_vec.push(2);\n    temp_vec.push(3);\n    temp_vec\n}\n```\n\n----------------------------------------\n\nTITLE: If Expression: Boolean Condition Requirement in Rust\nDESCRIPTION: This code snippet demonstrates that the condition in an `if` expression must be a boolean value.  Attempting to use a non-boolean type (like an integer) will result in a compilation error. Rust does not automatically convert non-boolean types to booleans, enforcing explicit boolean conditions.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-05-control-flow.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let number = 3;\n\n    if number {\n        println!(\"number was three\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the Draw Trait for SelectBox in Rust\nDESCRIPTION: This snippet defines a `SelectBox` struct with `width`, `height`, and `options` fields and implements the `Draw` trait for it. The `draw` method is left empty, representing the GUI drawing logic.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter18.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse gui::Draw;\n\nstruct SelectBox {\n    width: u32,\n    height: u32,\n    options: Vec<String>,\n}\n\nimpl Draw for SelectBox {\n    fn draw(&self) {\n        // code to actually draw a select box\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Quitting Game on Correct Guess - Rust\nDESCRIPTION: This snippet shows how to add a `break` statement to exit the loop when the user guesses the correct number.  It depends on the previous looping structure.  The `break` statement terminates the loop and thus the program.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-05-quitting/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Struct in Rust\nDESCRIPTION: This snippet defines a `Rectangle` struct with `width` and `height` fields.  It then creates an instance of the struct and calculates its area using a function that takes a reference to the struct as input.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_12\n\nLANGUAGE: Rust\nCODE:\n```\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        area(&rect1)\n    );\n}\n\nfn area(rectangle: &Rectangle) -> u32 {\n    rectangle.width * rectangle.height\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Hardcoded IP Address with Expect in Rust\nDESCRIPTION: This code snippet demonstrates parsing a hardcoded IP address string using the `parse` method and handling the `Result` with `expect`.  The `expect` method is used because the hardcoded string is known to be a valid IP address.  The `expect` method is called with a message that explains why the code expects the parse to succeed. This provides documentation that the code relies on the assumption of a hardcoded valid IP address.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter09.md#_snippet_13\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::net::IpAddr;\n\nlet home: IpAddr = \"127.0.0.1\"\n    .parse()\n    .expect(\"Hardcoded IP address should be valid\");\n```\n\n----------------------------------------\n\nTITLE: Fix Rust Code Using cargo fix\nDESCRIPTION: This command executes the `cargo fix` tool, which automatically applies suggestions from compiler warnings. In this case, it removes the unnecessary `mut` keyword from the variable `x`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-04-useful-development-tools.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n$ cargo fix\n    Checking myprogram v0.1.0 (file:///projects/myprogram)\n      Fixing src/main.rs (1 fix)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.59s\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Multiplication Operator Rust\nDESCRIPTION: This operator performs arithmetic multiplication. It multiplies two expressions and returns the product. The `Mul` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_10\n\nLANGUAGE: Rust\nCODE:\n```\n`expr * expr`\n```\n\n----------------------------------------\n\nTITLE: Building Workspace with External Dependency\nDESCRIPTION: Command to build the workspace after adding the external `rand` dependency. It shows the output with a warning for the unused import.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_24\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo build\n    Updating crates.io index\n  Downloaded rand v0.8.5\n   --snip--\n   Compiling rand v0.8.5\n   Compiling add_one v0.1.0 (file:///projects/add/add_one)\nwarning: unused import: `rand`\n --> add_one/src/lib.rs:1:5\n  |\n1 | use rand;\n  |     ^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: `add_one` (lib) generated 1 warning (run `cargo fix --lib -p add_one` to apply 1 suggestion)\n   Compiling adder v0.1.0 (file:///projects/add/adder)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.95s\n```\n\n----------------------------------------\n\nTITLE: Running the program with input and output redirection\nDESCRIPTION: This command executes the Rust program, passing `to poem.txt` as arguments. The standard output is redirected to the file `output.txt`. Because the arguments don't cause an error, the program's successful output is written to `output.txt`, while no output is written to standard error (the console).\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-06-writing-to-stderr-instead-of-stdout.md#_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ cargo run -- to poem.txt > output.txt\n```\n\n----------------------------------------\n\nTITLE: Running Minigrep with Cargo Run\nDESCRIPTION: This snippet shows how to execute the `minigrep` program using `cargo run`.  It passes `test` as the search string and `sample.txt` as the file to search within as command-line arguments to the program.  The expected output indicates the program is searching for 'test' in 'sample.txt'.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch12-an-io-project/listing-12-02/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run -- test sample.txt\n Compiling minigrep v0.1.0 (file:///projects/minigrep)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n  Running `target/debug/minigrep test sample.txt`\nSearching for test\nIn file sample.txt\n```\n\n----------------------------------------\n\nTITLE: Cargo Check Command and Error Message\nDESCRIPTION: This snippet displays the error message generated by `cargo check` when it cannot find the `new` function or associated item in `ThreadPool`. It shows the command used and the location of the error in the `src/main.rs` file.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch21-web-server/no-listing-01-define-threadpool-struct/output.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n$ cargo check\n  Checking hello v0.1.0 (file:///projects/hello)\nerror[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope\n  --> src/main.rs:12:28\n   |\n12 |     let pool = ThreadPool::new(4);\n   |                            ^^^ function or associated item not found in `ThreadPool`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `hello` (bin \"hello\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Attempting to return a reference to a local variable\nDESCRIPTION: This `longest` function attempts to return a reference to a `String` created within the function. This code will not compile because the `String` named `result` is deallocated when the function returns, creating a dangling reference.  Rust's borrow checker prevents this by issuing a compile-time error.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_44\n\nLANGUAGE: rust\nCODE:\n```\nfn longest<'a>(x: &str, y: &str) -> &'a str {\n    let result = String::from(\"really long string\");\n    result.as_str()\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Project-Specific Toolchain\nDESCRIPTION: These commands demonstrate how to override the global default Rust toolchain for a specific project using `rustup override`. This allows developers to use nightly Rust for projects requiring cutting-edge features while maintaining stable Rust for other projects. First, navigate to the project directory, then set the nightly toolchain.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix.md#_snippet_16\n\nLANGUAGE: Shell\nCODE:\n```\n$ cd ~/projects/needs-nightly\n$ rustup override set nightly\n```\n\n----------------------------------------\n\nTITLE: Immutable Variable Assignment Error in Rust\nDESCRIPTION: This code snippet demonstrates the immutability of variables in Rust by default. Assigning a new value to an immutable variable `x` results in a compile-time error. The compiler enforces immutability to prevent unexpected behavior and improve code safety. To fix this, the `mut` keyword can be used to declare the variable as mutable.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = 5;\n    println!(\"The value of x is: {x}\");\n    x = 6;\n    println!(\"The value of x is: {x}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Square Constructor Function in Rust\nDESCRIPTION: This code defines an associated function `square` within the `impl` block for the `Rectangle` struct. This function acts as a constructor, creating a square `Rectangle` instance given a single size parameter. It uses the `Self` keyword as an alias for the `Rectangle` type, ensuring type safety and conciseness.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nimpl Rectangle {\n    fn square(size: u32) -> Self {\n        Self {\n            width: size,\n            height: size,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Cargo Test\nDESCRIPTION: This snippet displays the output of running the `cargo test` command in a Rust project named 'adder'. It shows the compilation process, execution of unit tests in `src/lib.rs`, and execution of doc tests.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/no-listing-01-changing-test-name/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::exploration ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Let Else for Value Production Rust\nDESCRIPTION: This code shows how to use `let`-`else` for cleaner control flow. If `coin` is a `Coin::Quarter`, the `state` variable is bound; otherwise, the `else` block returns `None`. This keeps the \"happy path\" more readable.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_28\n\nLANGUAGE: Rust\nCODE:\n```\nfn describe_state_quarter(coin: Coin) -> Option<String> {\n    let Coin::Quarter(state) = coin else {\n        return None;\n    };\n\n    if state.existed_in(1900) {\n        Some(format!(\"{state:?} is pretty old, for America!\"))\n    } else {\n        Some(format!(\"{state:?} is relatively new.\"))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implement ThreadPool::execute - Rust\nDESCRIPTION: This code implements the `execute` method for the `ThreadPool` struct. It takes a closure `f` as a parameter, with trait bounds `FnOnce() + Send + 'static`. This allows the thread pool to accept closures that can be executed on a thread. This version of the `execute` method does nothing.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nimpl ThreadPool {\n    // --snip--\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static,\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Variable Shadowing Example in Rust\nDESCRIPTION: This code demonstrates variable shadowing in Rust.  A variable `x` is declared and initialized, then shadowed within the same scope and a nested scope, illustrating how the value of `x` changes with each shadowing. The `println!` macro is used to display the value of `x` in different scopes.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = 5;\n\n    let x = x + 1;\n\n    {\n        let x = x * 2;\n        println!(\"The value of x in the inner scope is: {x}\");\n    }\n\n    println!(\"The value of x is: {x}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Cargo\nDESCRIPTION: This command runs all tests in the current Rust project using Cargo's built-in testing framework. It compiles the code in test mode and executes the test functions marked with the `#[test]` attribute. The output displays the test results, including the number of tests run, passed, and failed.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s\n     Running unittests src/lib.rs (file:///projects/adder/target/debug/deps/adder-7acb243c25ffd9dc)\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Defining a Raw String Literal\nDESCRIPTION: This code snippet illustrates the definition of raw string literals in Rust.  Escape characters are not processed in raw string literals, making them useful for strings with backslashes or other special characters.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_59\n\nLANGUAGE: Rust\nCODE:\n```\nr\"...\"\n```\n\nLANGUAGE: Rust\nCODE:\n```\nr#\"...\"#\n```\n\nLANGUAGE: Rust\nCODE:\n```\nr##\"...\"##\n```\n\n----------------------------------------\n\nTITLE: Implementing Methods on Structs with Concrete Types\nDESCRIPTION: This snippet shows how to implement a method on a struct with a specific concrete type (`f32`) for the generic type parameter `T`.  The `distance_from_origin` method calculates the distance of a `Point<f32>` from the origin (0.0, 0.0). This method is only available for `Point<f32>` instances.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nimpl Point<f32> {\n    fn distance_from_origin(&self) -> f32 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Cargo Project\nDESCRIPTION: This snippet shows the output of running a Rust project named 'patterns' using `cargo run`. It includes compiler warnings regarding an irrefutable `let...else` pattern and the successful execution of the compiled binary.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch19-patterns-and-matching/listing-19-10/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling patterns v0.1.0 (file:///projects/patterns)\nwarning: irrefutable `let...else` pattern\n --> src/main.rs:2:5\n  |\n2 |     let x = 5 else {\n  |     ^^^^^^^^^\n  |\n  = note: this pattern will always match, so the `else` clause is useless\n  = help: consider removing the `else` clause\n  = note: `#[warn(irrefutable_let_patterns)]` on by default\n\nwarning: `patterns` (bin \"patterns\") generated 1 warning\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.39s\n     Running `target/debug/patterns`\n```\n\n----------------------------------------\n\nTITLE: Assigning 'if' Expression Result to a Variable in Rust\nDESCRIPTION: This code shows how to use an 'if' expression on the right-hand side of a 'let' statement to assign a value to a variable. The 'number' variable will be assigned either 5 or 6, depending on the value of the 'condition' variable.  The types of values returned by both the 'if' and 'else' branches must be compatible.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_30\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let condition = true;\n    let number = if condition { 5 } else { 6 };\n\n    println!(\"The value of number is: {number}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing a Crate with Cargo\nDESCRIPTION: This snippet shows the command to publish a crate to crates.io using `cargo publish`. It assumes the crate has the necessary metadata defined in its `Cargo.toml` file.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo publish\n    Updating crates.io index\n   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)\n   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)\n   Compiling guessing_game v0.1.0\n(file:///projects/guessing_game/target/package/guessing_game-0.1.0)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.19s\n   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)\n```\n\n----------------------------------------\n\nTITLE: Destructuring Structs in Rust\nDESCRIPTION: This example demonstrates how to destructure a struct's fields into separate variables using a `let` statement. It defines a `Point` struct with `x` and `y` fields, and then destructures an instance of `Point` into variables `a` and `b` (and later `x` and `y`).\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    let Point { x: a, y: b } = p;\n    assert_eq!(0, a);\n    assert_eq!(7, b);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Closure in Rust\nDESCRIPTION: This code defines a closure named `expensive_closure` in Rust. The closure takes a numerical input `num`, prints a message to the console, pauses execution for 2 seconds using `thread::sleep`, and then returns the input number. The `use` statements import necessary modules for threading and time duration.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/closures.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# use std::thread;\n# use std::time::Duration;\n\nlet expensive_closure = |num| {\n    println!(\"calculating slowly...\");\n    thread::sleep(Duration::from_secs(2));\n    num\n};\n# expensive_closure(5);\n```\n\n----------------------------------------\n\nTITLE: Transformed Async Function\nDESCRIPTION: Demonstrates how Rust internally transforms an `async fn` into a non-async function that returns a `Future`. It uses `impl Trait` syntax and wraps the original code in an `async move` block. Dependencies include `std::future::Future` and the `trpl` crate.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse std::future::Future;\nuse trpl::Html;\n\nfn page_title(url: &str) -> impl Future<Output = Option<String>> + '_ {\n    async move {\n        let text = trpl::get(url).await.text().await;\n        Html::parse(&text)\n            .select_first(\"title\")\n            .map(|title| title.inner_html())\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Thread with a Closure in Rust\nDESCRIPTION: This code demonstrates creating a new thread using `thread::spawn` and passing it a closure. The closure captures a vector `v` from the main thread's environment and prints its value. This example shows a basic way to use threads in Rust, capturing a variable from the main thread.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter16.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n\n    let handle = thread::spawn(|| {\n        println!(\"Here's a vector: {v:?}\");\n    });\n\n    handle.join().unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Tuple Structs in Rust\nDESCRIPTION: This snippet demonstrates how to define and use tuple structs in Rust. Tuple structs are similar to tuples but have a name associated with them, making them distinct types.  The example defines `Color` and `Point` tuple structs and creates instances of each.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Example Rust Code with Approximate Constant\nDESCRIPTION: This code snippet uses an approximation of the mathematical constant pi.  Clippy will flag this as an issue, suggesting the use of the `std::f64::consts::PI` constant for greater precision. This example shows Clippy's ability to detect potentially problematic code.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix_d.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    let x = 3.1415;\n    let r = 8.0;\n    println!(\"the area of the circle is {}\", x * r * r);\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Tests for add_two Function\nDESCRIPTION: This code snippet shows three test functions for the `add_two` function, each with a different name: `it_adds_two`, `add_two_and_two`, and `one_hundred`. These tests are used to demonstrate running subsets of tests by name.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-02-running-tests.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_adds_two() {\n        assert_eq!(4, add_two(2));\n    }\n\n    #[test]\n    fn add_two_and_two() {\n        assert_eq!(4, add_two(2));\n    }\n\n    #[test]\n    fn one_hundred() {\n        assert_eq!(102, add_two(100));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Tuple Destructuring with `let` in Rust\nDESCRIPTION: This snippet demonstrates how to destructure a tuple using a pattern in a `let` statement in Rust. The tuple `(1, 2, 3)` is matched against the pattern `(x, y, z)`, binding the corresponding values to the variables `x`, `y`, and `z`. This showcases a more advanced use of patterns for extracting values from tuples.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet (x, y, z) = (1, 2, 3);\n```\n\n----------------------------------------\n\nTITLE: Cargo Run Compilation Error in Rust\nDESCRIPTION: This snippet shows the error output from `cargo run` when there's a lifetime issue with string borrows. The error E0597 indicates that `string2` does not live long enough, as it's dropped before the borrow `result` is used in the `println!` macro. The error suggests that `string2`'s scope ends before the `result` is printed.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch10-generic-types-traits-and-lifetimes/listing-10-23/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0597]: `string2` does not live long enough\n --> src/main.rs:6:44\n  |\n5 |         let string2 = String::from(\"xyz\");\n  |             ------- binding `string2` declared here\n6 |         result = longest(string1.as_str(), string2.as_str());\n  |                                            ^^^^^^^ borrowed value does not live long enough\n7 |     }\n  |     - `string2` dropped here while still borrowed\n8 |     println!(\"The longest string is {result}\");\n  |                                     -------- borrow later used here\n\nFor more information about this error, try `rustc --explain E0597`.\nerror: could not compile `chapter10` (bin \"chapter10\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Returning Different Types That Implement the Same Trait - Invalid Example\nDESCRIPTION: This code attempts to return either a `NewsArticle` or a `Tweet`, both implementing the `Summary` trait, based on the `switch` boolean. This approach is invalid in Rust when using `impl Summary` as the return type because the function must return a single concrete type known at compile time.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_30\n\nLANGUAGE: Rust\nCODE:\n```\nfn returns_summarizable(switch: bool) -> impl Summary {\n    if switch {\n        NewsArticle {\n            headline: String::from(\n                \"Penguins win the Stanley Cup Championship!\",\n            ),\n            location: String::from(\"Pittsburgh, PA, USA\"),\n            author: String::from(\"Iceburgh\"),\n            content: String::from(\n                \"The Pittsburgh Penguins once again are the best \\\n                 hockey team in the NHL.\",\n            ),\n        }\n    } else {\n        Tweet {\n            username: String::from(\"horse_ebooks\"),\n            content: String::from(\n                \"of course, as you probably already know, people\",\n            ),\n            reply: false,\n            retweet: false,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the StreamExt Trait in Rust\nDESCRIPTION: This code snippet defines the `StreamExt` trait, which extends the `Stream` trait by providing convenient methods for working with streams, such as the `next` method. The `next` method is an asynchronous function that returns the next item from the stream as an `Option<Self::Item>`. The `Unpin` bound ensures that the stream can be safely moved.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_52\n\nLANGUAGE: rust\nCODE:\n```\ntrait StreamExt: Stream {\n    async fn next(&mut self) -> Option<Self::Item>\n    where\n        Self: Unpin;\n\n    // other methods...\n}\n```\n\n----------------------------------------\n\nTITLE: Running tests with Cargo\nDESCRIPTION: This command executes the tests defined in the Rust project using the Cargo build system. It compiles the code, runs the tests, and displays the results, including the number of passed, failed, ignored, and filtered-out tests.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/output-only-03-multiple-tests/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test add\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 2 tests\ntest tests::add_three_and_two ... ok\ntest tests::add_two_and_two ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Executing Cargo Test\nDESCRIPTION: This command executes the tests defined in the Rust project using the cargo tool. It compiles the project, runs unit tests in `src/lib.rs` and `src/main.rs`, and performs doc-tests. The output shows the test results, indicating the number of tests passed, failed, ignored, measured, and filtered out.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch12-an-io-project/listing-12-21/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test\n Compiling minigrep v0.1.0 (file:///projects/minigrep)\n  Finished `test` profile [unoptimized + debuginfo] target(s) in 1.33s\n   Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 2 tests\ntest tests::case_insensitive ... ok\ntest tests::case_sensitive ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests minigrep\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Async Futures with `trpl::sleep` for Interleaving in Rust\nDESCRIPTION: This code defines two async futures, `a` and `b`, which simulate work using the `slow` function, interleaved with calls to `trpl::sleep`. By adding `trpl::sleep` calls with await points between calls to `slow`, the code allows the two futures' work to be interleaved, handing control back to the runtime. This demonstrates cooperative multitasking by allowing the futures to yield execution.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_28\n\nLANGUAGE: rust\nCODE:\n```\nlet one_ms = Duration::from_millis(1);\n\nlet a = async {\n    println!(\"'a' started.\");\n    slow(\"a\", 30);\n    trpl::sleep(one_ms).await;\n    slow(\"a\", 10);\n    trpl::sleep(one_ms).await;\n    slow(\"a\", 20);\n    trpl::sleep(one_ms).await;\n    println!(\"'a' finished.\");\n};\n\nlet b = async {\n    println!(\"'b' started.\");\n    slow(\"b\", 75);\n    trpl::sleep(one_ms).await;\n    slow(\"b\", 10);\n    trpl::sleep(one_ms).await;\n    slow(\"b\", 15);\n    trpl::sleep(one_ms).await;\n    slow(\"b\", 35);\n    trpl::sleep(one_ms).await;\n    println!(\"'b' finished.\");\n};\n```\n\n----------------------------------------\n\nTITLE: Complete Guessing Game Code - Rust\nDESCRIPTION: This snippet represents the final code for the guessing game, including looping, input handling, and quitting on a correct guess. It builds on the previous snippets to provide a complete, functional game.  It requires the `rand` crate and the standard input/output library.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-06/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Executing Cargo Check\nDESCRIPTION: This command executes the `cargo check` tool to verify the Rust project 'hello' located in the /projects/hello directory. It checks for errors without compiling the project into an executable, which is faster than `cargo build`. The output shows the project name and the time taken for the check.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch21-web-server/no-listing-04-update-drop-definition/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo check\n  Checking hello v0.1.0 (file:///projects/hello)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.07s\n```\n\n----------------------------------------\n\nTITLE: Function with Tests for add_two - Rust\nDESCRIPTION: This code defines a function `add_two` that adds 2 to a given number. It also includes three tests to verify its functionality with different inputs.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\npub fn add_two(a: usize) -> usize {\n    a + 2\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn add_two_and_two() {\n        let result = add_two(2);\n        assert_eq!(result, 4);\n    }\n\n    #[test]\n    fn add_three_and_two() {\n        let result = add_two(3);\n        assert_eq!(result, 5);\n    }\n\n    #[test]\n    fn one_hundred() {\n        let result = add_two(100);\n        assert_eq!(result, 102);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Kilometers Type Alias in Rust\nDESCRIPTION: This snippet shows how the `Kilometers` type alias can be used just like the original `i32` type. You can create variables of type `Kilometers` and perform operations with `i32` values without compiler errors because they are considered the same type.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-03-advanced-types.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntype Kilometers = i32;\n\nfn main() {\n    let x: i32 = 5;\n    let y: Kilometers = 5;\n\n    println!(\"x + y = {}\", x + y);\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error: Incompatible Types\nDESCRIPTION: This Rust code snippet demonstrates a compilation error (E0308) caused by assigning different types (integer and string) in the `if` and `else` branches of a conditional expression. The compiler expects a single type for the variable `number`, but it infers an integer from the `if` branch and then encounters a string in the `else` branch.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch03-common-programming-concepts/no-listing-31-arms-must-return-same-type/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet number = if condition { 5 } else { \"six\" };\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running (Windows PowerShell)\nDESCRIPTION: These commands compile the `main.rs` file using the Rust compiler (`rustc`), creating an executable. The executable is then run using `.\\main`. The expected output is \"Hello, world!\" printed to the console.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-02-hello-world.md#_snippet_4\n\nLANGUAGE: powershell\nCODE:\n```\n> rustc main.rs\n> .\\main\nHello, world!\n```\n\n----------------------------------------\n\nTITLE: Running Rust Project with Cargo\nDESCRIPTION: This command compiles and runs a Rust project using Cargo. It shows the compilation process and the resulting output of the program, in this case, printing a string to the console.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch20-advanced-features/listing-20-22/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling traits-example v0.1.0 (file:///projects/traits-example)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s\n   Running `target/debug/traits-example`\n```\n\n----------------------------------------\n\nTITLE: Accessing an element out of bounds in a Vector in Rust\nDESCRIPTION: This snippet demonstrates how accessing an element beyond the bounds of a vector will cause a `panic!` in Rust. This is a common error that can lead to security vulnerabilities in other languages, but Rust protects against this by causing the program to panic.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch09-01-unrecoverable-errors-with-panic.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let v = vec![1, 2, 3];\n    v[99];\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining Async Calls with Await\nDESCRIPTION: Shows how to chain multiple async calls using the `await` keyword in Rust.  It concisely chains the `trpl::get` and `text` methods to retrieve the text content of an HTTP response.  Requires a URL string, and the code assumes the existence of the `trpl` crate for making HTTP requests.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet response_text = trpl::get(url).await.text().await;\n```\n\n----------------------------------------\n\nTITLE: Deriving PartialEq and Eq Traits in Rust\nDESCRIPTION: The `PartialEq` trait allows comparing instances for equality using `==` and `!=` operators, and derives the `eq` method. For structs, it checks equality of all fields. The `Eq` trait signifies that a type's value is always equal to itself and is required for types used as keys in `HashMap<K, V>`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix.md#_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Generic Function with ?Sized Trait Bound in Rust\nDESCRIPTION: This code snippet demonstrates a generic function in Rust that accepts a type parameter `T` with a `?Sized` trait bound. The `?Sized` trait bound indicates that `T` may or may not be `Sized`, meaning the size of `T` might not be known at compile time. This is useful for working with dynamically sized types.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/unsized-types.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn generic<T: ?Sized>(t: &T) {\n    // ...snip...\n}\n```\n\n----------------------------------------\n\nTITLE: Merging Streams with Different Types in Rust\nDESCRIPTION: This snippet attempts to merge two streams, `messages` (String) and `intervals` (u32), but encounters a type mismatch error. It highlights the need to transform the streams to have compatible types before merging using the `merge` method from the `Stream` trait.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_41\n\nLANGUAGE: Rust\nCODE:\n```\nlet messages = get_messages().timeout(Duration::from_millis(200));\n        let intervals = get_intervals();\n        let merged = messages.merge(intervals);\n```\n\n----------------------------------------\n\nTITLE: Returning a 404 Error\nDESCRIPTION: This Rust code snippet implements the `else` block for handling requests that don't match the specific GET request. It returns a 404 Not Found response with the contents of the \"404.html\" file.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n    // --snip--\n    } else {\n        let status_line = \"HTTP/1.1 404 NOT FOUND\";\n        let contents = fs::read_to_string(\"404.html\").unwrap();\n        let length = contents.len();\n\n        let response = format!(\n            \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n        );\n\n        stream.write_all(response.as_bytes()).unwrap();\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Calling Hello Function with MyBox<String> Using Deref Coercion in Rust\nDESCRIPTION: This Rust code snippet demonstrates calling the `hello` function with a `MyBox<String>` value. Deref coercion automatically converts the `&MyBox<String>` to `&String` and then to `&str`, allowing the `hello` function to be called successfully. It relies on the implementation of the `Deref` trait for `MyBox<T>` and `String`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let m = MyBox::new(String::from(\"Rust\"));\n    hello(&m);\n}\n```\n\n----------------------------------------\n\nTITLE: Example Rust Code with Unused Variable Warning\nDESCRIPTION: This code snippet demonstrates a common scenario where the Rust compiler issues a warning about an unused variable. The `i` variable in the `for` loop is not used, resulting in a compiler warning. This example is used to illustrate the use of `cargo fix`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix_d.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nfn do_something() {}\n\nfn main() {\n    for i in 0..100 {\n        do_something();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Struct Method in Rust\nDESCRIPTION: This code defines a `Rectangle` struct and implements a method called `area` that calculates the area of the rectangle. The `area` method takes `&self` as its first parameter, which is a reference to the instance of the `Rectangle` struct on which the method is being called.  The method returns a `u32` representing the calculated area.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/method-syntax.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# struct Rectangle {\n#     width: u32,\n#     height: u32,\n# }\n\nimpl Rectangle {\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Crate Version in Cargo.toml\nDESCRIPTION: This TOML snippet demonstrates how to specify a crate version in the Cargo.toml file.  The rand crate is specified with version 0.9.0. This change instructs Cargo to update the dependency to this version on the next build.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_15\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nrand = \"0.9.0\"\n```\n\n----------------------------------------\n\nTITLE: Rust Test Function with Panic\nDESCRIPTION: This code snippet demonstrates a failing test function that uses the `panic!` macro. When this test is run, it will cause the test runner to mark the test as failed because it panics.  This snippet is contained within the #[cfg(test)] module.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\npub fn add(left: u64, right: u64) -> u64 {\n    left + right\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn exploration() {\n        let result = add(2, 2);\n        assert_eq!(result, 4);\n    }\n\n    #[test]\n    fn another() {\n        panic!(\"Make this test fail\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Attempting to Dereference MyBox<T> Without Deref Trait Implementation\nDESCRIPTION: This example attempts to dereference the `MyBox<T>` type defined earlier without implementing the `Deref` trait. This will result in a compilation error because Rust doesn't know how to dereference the custom type. This illustrates the need for the `Deref` trait to enable dereferencing.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = 5;\n    let y = MyBox::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n```\n\n----------------------------------------\n\nTITLE: Helper Function Module - Rust\nDESCRIPTION: This Rust code defines a helper function named `setup` within the `tests/common/mod.rs` file.  This allows for code reuse across multiple integration tests. The `pub` keyword ensures the function is accessible from other modules. Helper modules in the `tests` directory should use the `mod.rs` naming convention.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_29\n\nLANGUAGE: rust\nCODE:\n```\npub fn setup() {\n    // setup code specific to your library's tests would go here\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Crate Warning Example\nDESCRIPTION: This console output demonstrates the warning and error messages received when attempting to publish a crate without the required metadata fields (description and license).\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-02-publishing-to-crates-io.md#_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n$ cargo publish\n    Updating crates.io index\nwarning: manifest has no description, license, license-file, documentation, homepage or repository.\nSee https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.\n--snip--\nerror: failed to publish to registry at https://crates.io\n\nCaused by:\n  the remote server responded with an error (status 400 Bad Request): missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for more information on configuring these fields\n```\n\n----------------------------------------\n\nTITLE: Avoiding Unused Variable Warnings with `_x` in Rust\nDESCRIPTION: This code demonstrates how to avoid unused variable warnings by starting a variable name with an underscore (`_x`). It highlights the difference between using `_` and `_x`, where `_x` still binds the value to the variable. Dependencies: None. Inputs: None. Outputs: No output, demonstrates compile-time behavior.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let _x = 5;\n    let y = 10;\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Rust Program with Cargo\nDESCRIPTION: This snippet shows the output of executing a Rust program using `cargo run`. It includes the compilation steps, build profile, execution path, and sample output that demonstrates the behavior of the `closure-example` program.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch13-functional-features/listing-13-04/output.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n$ cargo run\n Compiling closure-example v0.1.0 (file:///projects/closure-example)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s\n   Running `target/debug/closure-example`\nBefore defining closure: [1, 2, 3]\nBefore calling closure: [1, 2, 3]\nFrom closure: [1, 2, 3]\nAfter calling closure: [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Executing a Rust project with Cargo\nDESCRIPTION: This snippet shows how to run a Rust project using the `cargo run` command. The output displays the compilation process, including the package name, version, file path, and the compilation profile. It also shows the execution of the compiled binary and the output produced by the program.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch03-common-programming-concepts/no-listing-27-if-false/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling branches v0.1.0 (file:///projects/branches)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s\n   Running `target/debug/branches`\ncondition was false\n```\n\n----------------------------------------\n\nTITLE: Destructuring Structs with Field Shorthand in Rust\nDESCRIPTION: This snippet shows a shorthand way to destructure struct fields where the variable names match the field names. It's equivalent to the previous example, but uses `let Point { x, y } = p;` instead of `let Point { x: a, y: b } = p;`\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    let Point { x, y } = p;\n    assert_eq!(0, x);\n    assert_eq!(7, y);\n}\n```\n\n----------------------------------------\n\nTITLE: Compilation Error: Undeclared Module\nDESCRIPTION: This error indicates that the module `hosting` could not be found. It occurs within the `src/lib.rs` file on line 11. The error suggests importing the module using its public re-export as a possible solution.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch07-managing-growing-projects/listing-07-12/output.txt#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nerror[E0433]: failed to resolve: use of undeclared crate or module `hosting`\n  --> src/lib.rs:11:9\n   |\n11 |         hosting::add_to_waitlist();\n   |         ^^^^^^^ use of undeclared crate or module `hosting`\n   |\nhelp: consider importing this module through its public re-export\n   |\n10 +     use crate::hosting;\n   |\n```\n\n----------------------------------------\n\nTITLE: Declaring the `vegetables` module\nDESCRIPTION: This code snippet declares the `vegetables` submodule within the `garden` module. It indicates that the compiler should look for the module's code in either `src/garden/vegetables.rs` or `src/garden/vegetables/mod.rs`. Making it public with `pub mod` exposes the module to external code.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub mod vegetables;\n```\n\n----------------------------------------\n\nTITLE: Node struct definition with Weak parent reference in Rust\nDESCRIPTION: Defines a Node struct with a value, a RefCell containing a Weak pointer to its parent, and a RefCell containing a vector of Rc pointers to its children. This setup allows child nodes to reference their parent without creating a strong reference cycle, thus avoiding memory leaks.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\nuse std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell<Weak<Node>>,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Files (Windows CMD)\nDESCRIPTION: This command lists the files in the current directory using Windows CMD. The `/B` option ensures that only the file names are displayed. The command shows the compiled executable `main.exe`, the program database `main.pdb`, and the source code file `main.rs`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-02-hello-world.md#_snippet_8\n\nLANGUAGE: cmd\nCODE:\n```\n> dir /B %= the /B option says to only show the file names =%\nmain.exe\nmain.pdb\nmain.rs\n```\n\n----------------------------------------\n\nTITLE: Running a Rust Project with Cargo\nDESCRIPTION: This snippet illustrates the execution of a Rust project using the `cargo run` command. It compiles the 'rectangles' project and then runs the resulting executable. The output shows the compilation process and the output of the running program, printing details about a `Rectangle` struct.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch05-using-structs-to-structure-related-data/output-only-02-pretty-debug/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s\n     Running `target/debug/rectangles`\nrect1 is Rectangle {\n    width: 30,\n    height: 50,\n}\n```\n\n----------------------------------------\n\nTITLE: First Word Function Returning a String Slice\nDESCRIPTION: This function `first_word` takes a String reference and returns a string slice (&str) representing the first word in the string. It iterates through the bytes of the string, looking for a space character to determine the end of the first word. Returns the full slice if no space is found.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_29\n\nLANGUAGE: Rust\nCODE:\n```\nfn first_word(s: &String) -> &str {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &s[0..i];\n        }\n    }\n\n    &s[..]\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Rust Project with Cargo\nDESCRIPTION: This command compiles and runs a Rust project using Cargo. It compiles the `functions` project and executes the resulting binary, producing the \"Hello, world!\" and \"Another function.\" output.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch03-common-programming-concepts/no-listing-16-functions/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n   Compiling functions v0.1.0 (file:///projects/functions)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.28s\n     Running `target/debug/functions`\nHello, world!\nAnother function.\n```\n\n----------------------------------------\n\nTITLE: Creating String Slices in Rust\nDESCRIPTION: This code demonstrates how to create a string slice from a String using range indexing. It shows how to create slices referring to specific portions of a String, specifying starting and ending indices.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_25\n\nLANGUAGE: Rust\nCODE:\n```\nlet s = String::from(\"hello world\");\n\nlet hello = &s[0..5];\nlet world = &s[6..11];\n```\n\n----------------------------------------\n\nTITLE: Rust Borrowing Example with Error E0502\nDESCRIPTION: This code snippet demonstrates a borrowing error in Rust. The error E0502 occurs because the code attempts to create a mutable borrow of the vector `v` via `v.push(6)` while an immutable borrow `&v[0]` is still active and used later in the `println!` macro. This violates Rust's borrowing rules, which prevent mutable borrows while immutable borrows exist.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch08-common-collections/listing-08-06/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling collections v0.1.0 (file:///projects/collections)\nerror[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable\n --> src/main.rs:6:5\n  |\n4 |     let first = &v[0];\n  |                  - immutable borrow occurs here\n5 |\n6 |     v.push(6);\n  |     ^^^^^^^^^ mutable borrow occurs here\n7 |\n8 |     println!(\"The first element is: {first}\");\n  |                                     ------- immutable borrow later used here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `collections` (bin \"collections\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Using a String Slice after Appending to a String in Rust\nDESCRIPTION: Illustrates the use of a string slice (`&str`) after appending it to a `String` using `push_str()`. This highlights that `push_str()` does not take ownership of the string slice, allowing it to be used afterwards.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-02-strings.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet mut s1 = String::from(\"foo\");\nlet s2 = String::from(\"bar\");\ns1.push_str(&s2);\nprintln!(\"s2 is {}\", s2);\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error: Moved Value\nDESCRIPTION: This snippet shows a Rust compilation error (E0382) resulting from an attempt to use a vector (`v`) after it has been moved into a thread closure. The vector `v` is moved into the closure owned by the spawned thread, making it unavailable for subsequent use in the main thread (specifically, `drop(v)`).\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch16-fearless-concurrency/output-only-01-move-drop/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling threads v0.1.0 (file:///projects/threads)\nerror[E0382]: use of moved value: `v`\n  --> src/main.rs:10:10\n   |\n4  |     let v = vec![1, 2, 3];\n   |         - move occurs because `v` has type `Vec<i32>`, which does not implement the `Copy` trait\n5  |\n6  |     let handle = thread::spawn(move || {\n   |                                ------- value moved into closure here\n7  |         println!(\"Here's a vector: {v:?}\");\n   |                                     - variable moved due to use in closure\n...\n10 |     drop(v); // oh no!\n   |          ^ value used here after move\n\nFor more information about this error, try `rustc --explain E0382`.\nerror: could not compile `threads` (bin \"threads\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Destructuring Structs with Literal Matching in Rust\nDESCRIPTION: This example combines destructuring with literal matching in a `match` expression. It checks if a `Point` lies on the x-axis (`y = 0`), the y-axis (`x = 0`), or neither, and prints a message accordingly.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    match p {\n        Point { x, y: 0 } => println!(\"On the x axis at {x}\"),\n        Point { x: 0, y } => println!(\"On the y axis at {y}\"),\n        Point { x, y } => {\n            println!(\"On neither axis: ({x}, {y})\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Returning a Struct Instance from a Function in Rust\nDESCRIPTION: This code defines a function `build_user` that takes email and username as input and returns a `User` struct instance with specified values for email, username and default values for active and sign_in_count.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn build_user(email: String, username: String) -> User {\n    User {\n        active: true,\n        username: username,\n        email: email,\n        sign_in_count: 1,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Output of Concurrent Futures\nDESCRIPTION: This is the expected output when running the code that uses futures concurrently. The messages from the different sending futures are received at different intervals due to the varying delays after sending.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-02-concurrency-with-async.md#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\nreceived 'hi'\nreceived 'more'\nreceived 'from'\nreceived 'the'\nreceived 'messages'\nreceived 'future'\nreceived 'for'\nreceived 'you'\n```\n\n----------------------------------------\n\nTITLE: Running Minigrep with Arguments\nDESCRIPTION: This command executes the 'minigrep' program compiled using cargo. It passes 'to' and 'poem.txt' as command-line arguments. The 'cargo run' command compiles and runs the program, forwarding the specified arguments.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch12-an-io-project/listing-12-23/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run -- to poem.txt\n Compiling minigrep v0.1.0 (file:///projects/minigrep)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n  Running `target/debug/minigrep to poem.txt`\nAre you nobody, too?\nHow dreary to be somebody!\n```\n\n----------------------------------------\n\nTITLE: Boolean Type in Rust\nDESCRIPTION: This code snippet shows how to declare and use Boolean values in Rust. It demonstrates the declaration of Boolean variables with the `bool` type and assigning them the values `true` and `false`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-02-data-types.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet t = true;\n\nlet f: bool = false; // with explicit type annotation\n```\n\n----------------------------------------\n\nTITLE: Matching Named Variables with Shadowing in Rust\nDESCRIPTION: This example showcases how named variables are matched within a `match` expression and how they can shadow outer variables with the same name. The code initializes `x` as `Some(5)` and `y` as `10`. The match expression introduces a new `y` variable within its scope, which shadows the outer `y`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nlet x = Some(5);\nlet y = 10;\n\nmatch x {\n    Some(50) => println!(\"Got 50\"),\n    Some(y) => println!(\"Matched, y = {y}\"),\n    _ => println!(\"Default case, x = {x:?}\"),\n}\n\nprintln!(\"at the end: x = {x:?}, y = {y}\");\n```\n\n----------------------------------------\n\nTITLE: Cargo.toml file for the guessing game\nDESCRIPTION: This is the `Cargo.toml` file generated for the 'guessing_game' project. It specifies the project's metadata and dependencies. This particular example contains the standard `Cargo.toml` file.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n{{#include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/Cargo.toml}}\n```\n\n----------------------------------------\n\nTITLE: Failing Test for Search - Rust\nDESCRIPTION: This test case defines a failing test for the `search` function. It sets up a query string and content to search within, asserting that the `search` function returns a vector containing the expected line.  Currently, it fails because the `search` function doesn't exist.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn one_result() {\n        let query = \"duct\";\n        let contents = \"\\\nRust:\\nsafe, fast, productive.\\nPick three.\";\n\n        assert_eq!(vec![\"safe, fast, productive.\"], search(query, contents));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Rust Project with Cargo\nDESCRIPTION: This command compiles and runs a Rust project using Cargo. It first compiles the 'functions' project, then executes the compiled binary. The output 'The value of x is: 5' indicates the successful execution of the program.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch03-common-programming-concepts/no-listing-17-functions-with-parameters/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling functions v0.1.0 (file:///projects/functions)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.21s\n  Running `target/debug/functions`\nThe value of x is: 5\n```\n\n----------------------------------------\n\nTITLE: Running a Rust Executable Built with Cargo\nDESCRIPTION: This command executes the compiled Rust program located in the `target/debug` directory. This assumes the project has been previously built with `cargo build`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_24\n\nLANGUAGE: Rust\nCODE:\n```\n$ ./target/debug/hello_cargo # or .\\target\\debug\\hello_cargo.exe on Windows\nHello, world!\n```\n\n----------------------------------------\n\nTITLE: Calculating Area with Separate Variables Rust\nDESCRIPTION: This code snippet calculates the area of a rectangle using separate width and height variables. It defines a function `area` that takes width and height as arguments and returns the calculated area. The `main` function sets the width and height, then calls the `area` function and prints the result.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-02-example-structs.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let width1 = 30;\n    let height1 = 50;\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        area(width1, height1)\n    );\n}\n\nfn area(width: u32, height: u32) -> u32 {\n    width * height\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning and building a project\nDESCRIPTION: This command shows the series of commands to checkout, change directory and build the code. First `git clone` will download the code, then `cd` will change the current directory, and `cargo build` will build the project.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-03-hello-cargo.md#_snippet_9\n\nLANGUAGE: console\nCODE:\n```\n$ git clone example.org/someproject\n$ cd someproject\n$ cargo build\n```\n\n----------------------------------------\n\nTITLE: Rust Code Using the PI Constant\nDESCRIPTION: This code snippet uses the `std::f64::consts::PI` constant, which is the recommended way to represent pi in Rust.  This avoids the warning generated by Clippy in the previous example. This demonstrates the correct way to use mathematical constants in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix_d.md#_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    let x = std::f64::consts::PI;\n    let r = 8.0;\n    println!(\"the area of the circle is {}\", x * r * r);\n}\n```\n\n----------------------------------------\n\nTITLE: Expression Block Example in Rust\nDESCRIPTION: This snippet presents an example of a block of code enclosed in curly braces `{}` being used as an expression. The block calculates `x + 1` and its result is assigned to `y`. The absence of a semicolon at the end of `x + 1` ensures it's treated as an expression and its value is returned.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let y = {\n        let x = 3;\n        x + 1\n    };\n\n    println!(\"The value of y is: {y}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Limiting Mutable Reference Scope in Rust\nDESCRIPTION: This Rust code demonstrates how to limit the scope of a mutable reference using curly brackets, allowing for the creation of another mutable reference after the first one goes out of scope. This avoids the error of having multiple mutable references to the same data simultaneously.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nlet mut s = String::from(\"hello\");\n\n{\n    let r1 = &mut s;\n} // r1 goes out of scope here, so we can make a new reference with no problems.\n\nlet r2 = &mut s;\n```\n\n----------------------------------------\n\nTITLE: Rust Code with Approximate PI Constant\nDESCRIPTION: This code snippet demonstrates a program that uses an approximation of the mathematical constant pi. Running Clippy on this code will result in an error, suggesting the use of the precise `PI` constant from the standard library.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-04-useful-development-tools.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = 3.1415;\n    let r = 8.0;\n    println!(\"the area of the circle is {}\", x * r * r);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Trait with a Required Method in Rust\nDESCRIPTION: This code implements the `Summary` trait for the `Tweet` struct, specifically defining the required `summarize_author` method. Because `summarize` has a default implementation that uses `summarize_author`, implementing this single method provides the full `Summary` trait functionality.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nimpl Summary for Tweet {\n    fn summarize_author(&self) -> String {\n        format!(\"@{}\", self.username)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Multiple Values with Ownership\nDESCRIPTION: This code shows how to return multiple values from a function in Rust using a tuple. The `calculate_length` function takes ownership of a `String`, calculates its length, and then returns both the `String` and its length as a tuple.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_12\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let (s2, len) = calculate_length(s1);\n\n    println!(\"The length of '{s2}' is {len}.\");\n}\n\nfn calculate_length(s: String) -> (String, usize) {\n    let length = s.len(); // len() returns the length of a String\n\n    (s, length)\n}\n```\n\n----------------------------------------\n\nTITLE: Argument/Element Separator Rust\nDESCRIPTION: This operator is used to separate arguments in function calls, elements in tuples, and items in lists or arrays. It's a fundamental part of Rust syntax for defining sequences of values. This operator cannot be overloaded.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_17\n\nLANGUAGE: Rust\nCODE:\n```\n`expr, expr`\n```\n\n----------------------------------------\n\nTITLE: Running a Cargo project using cargo run\nDESCRIPTION: This command compiles and runs a Rust project using Cargo. It first checks if the code has been modified, compiles if necessary, and then executes the resulting binary. This is a more convenient way to run a project than manually building and then running the executable.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-03-hello-cargo.md#_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/hello_cargo`\nHello, world!\n```\n\n----------------------------------------\n\nTITLE: Displaying PATH in Windows CMD\nDESCRIPTION: Prints the value of the PATH environment variable in the Windows command prompt (CMD). This is useful for verifying if the Rust installation directory is included in the PATH.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n> echo %PATH%\n```\n\n----------------------------------------\n\nTITLE: Using the dbg! Macro for Debugging in Rust\nDESCRIPTION: This snippet illustrates the use of the `dbg!` macro for debugging expressions and struct values.  The `dbg!` macro prints the file and line number along with the value of the expression to the standard error stream.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_15\n\nLANGUAGE: Rust\nCODE:\n```\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let scale = 2;\n    let rect1 = Rectangle {\n        width: dbg!(30 * scale),\n        height: 50,\n    };\n\n    dbg!(&rect1);\n}\n```\n\n----------------------------------------\n\nTITLE: Bring ThreadPool into scope (Rust)\nDESCRIPTION: This code imports the `ThreadPool` struct from the library crate into the main file's scope. This allows the `main.rs` file to use the `ThreadPool` type defined in `lib.rs`. It's a necessary step to integrate the thread pool implementation into the main application logic.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-02-multithreaded.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse hello::ThreadPool;\n```\n\n----------------------------------------\n\nTITLE: Running a Cargo Project with cargo run\nDESCRIPTION: This command compiles and executes a Rust project. The output displays the compilation process, including the project name and version, followed by the execution output, in this case, \"The value of x is: 5\". It requires Cargo to be installed and configured.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch03-common-programming-concepts/no-listing-21-function-return-values/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n   Compiling functions v0.1.0 (file:///projects/functions)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s\n     Running `target/debug/functions`\nThe value of x is: 5\n```\n\n----------------------------------------\n\nTITLE: Unused Map Iterator\nDESCRIPTION: This code snippet shows an example of an unused `Map` iterator. The Rust compiler issues a warning because iterators are lazy and do nothing unless consumed. The warning suggests using `let _ = ...` to ignore the resulting value if the iterator's side effects are intended.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch13-functional-features/listing-13-14/output.txt#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nv1.iter().map(|x| x + 1);\n```\n\n----------------------------------------\n\nTITLE: Modifying a Borrowed String with Mutable References in Rust\nDESCRIPTION: This Rust code demonstrates modifying a borrowed string using a mutable reference. The `change` function now accepts a mutable reference (`&mut String`) and appends \", world\" to it.  The `String` `s` must also be declared as mutable (`mut s`).\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    change(&mut s);\n}\n\nfn change(some_string: &mut String) {\n    some_string.push_str(\", world\");\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Cargo project for release\nDESCRIPTION: This command builds a Rust project using Cargo in release mode.  It compiles the source code with optimizations, creating an executable file in the `target/release` directory that is suitable for distribution. It prioritizes performance over build speed.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-03-hello-cargo.md#_snippet_8\n\nLANGUAGE: console\nCODE:\n```\n$ cargo build --release\n```\n\n----------------------------------------\n\nTITLE: Combining Mutable and Immutable References in Rust\nDESCRIPTION: This Rust code attempts to create a mutable reference while immutable references to the same value are still in scope. This results in a compile-time error because Rust does not allow having both mutable and immutable references to the same data at the same time.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nlet mut s = String::from(\"hello\");\n\nlet r1 = &s; // no problem\nlet r2 = &s; // no problem\nlet r3 = &mut s; // BIG PROBLEM\n\nprintln!(\"{}, {}, and {}\", r1, r2, r3);\n```\n\n----------------------------------------\n\nTITLE: Creating a Rust Testing Module\nDESCRIPTION: This code snippet demonstrates how to create a testing module in Rust using the #[cfg(test)] attribute. This ensures the module and its contents are only compiled during testing.  The #[test] attribute marks a function as a test case, which can then be executed by the Rust test runner.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/testing.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Test to a Crate\nDESCRIPTION: This snippet demonstrates how to add a test function to a Rust crate using the `#[cfg(test)]` attribute and the `#[test]` attribute. It includes a test module and a simple assertion to verify the functionality of the `add_one` function.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_26\n\nLANGUAGE: rust\nCODE:\n```\npub fn add_one(x: i32) -> i32 {\n    x + 1\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_works() {\n        assert_eq!(3, add_one(2));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Unused Variable Warning with cargo fix\nDESCRIPTION: This command automatically applies the suggested fix for the unused variable warning in the previous code snippet.  The `rustfix` tool, invoked by `cargo fix`, changes the variable name to `_i`, indicating that the variable is intentionally unused.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix_d.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo fix\n```\n\n----------------------------------------\n\nTITLE: PendingReviewPost and State Transitions - lib.rs\nDESCRIPTION: This snippet shows the `PendingReviewPost` struct, the `request_review` method on `DraftPost` which returns a `PendingReviewPost`, and the `approve` method on `PendingReviewPost` which returns a `Post`. It demonstrates how state transitions are implemented as transformations between different types, ensuring type safety.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-03-oo-design-patterns.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch18-oop/listing-18-20/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Integration Test Example - Rust\nDESCRIPTION: This Rust code demonstrates a basic integration test located in `tests/integration_test.rs`. It imports the `add_two` function from the `adder` crate and asserts that adding 2 to 2 results in 4. This test file is compiled as a separate crate, necessitating the `use` statement.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_26\n\nLANGUAGE: rust\nCODE:\n```\nuse adder::add_two;\n\n#[test]\nfn it_adds_two() {\n    let result = add_two(2);\n    assert_eq!(result, 4);\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Mutable Variable in Rust\nDESCRIPTION: This code snippet showcases the declaration and modification of a mutable variable `x` in Rust. The `mut` keyword is used to make the variable mutable, allowing its value to be changed after initialization. The `println!` macro is used to print the value of `x` before and after the modification.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/mutability.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet mut x = 5;\nprintln!(\"The value of x is: {x}\");\nx = 6;\nprintln!(\"The value of x is: {x}\");\n```\n\n----------------------------------------\n\nTITLE: Running a Rust project with Cargo\nDESCRIPTION: This command compiles and executes the Rust project located in the current directory. It uses Cargo, Rust's package manager, to build the project and then run the resulting executable. The output displays the compilation progress and the program's output to standard output.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch15-smart-pointers/listing-15-19/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling cons-list v0.1.0 (file:///projects/cons-list)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s\n   Running `target/debug/cons-list`\ncount after creating a = 1\ncount after creating b = 2\ncount after creating c = 3\ncount after c goes out of scope = 2\n```\n\n----------------------------------------\n\nTITLE: Refutable Pattern with `let` in Rust\nDESCRIPTION: This snippet demonstrates attempting to use a refutable pattern `Some(x)` with a `let` statement, which is not allowed in Rust. This example leads to a compiler error because `let` statements require irrefutable patterns. The pattern `Some(x)` is refutable because if the value is `None`, the pattern won't match.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nlet Some(x) = some_option_value;\n```\n\n----------------------------------------\n\nTITLE: Running and Compiling Rust Project with Cargo\nDESCRIPTION: This snippet shows the output of running a Rust project using `cargo run`. It includes the compilation process and the execution of the binary, which results in a panic due to an out-of-bounds access.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch09-error-handling/listing-09-01/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling panic v0.1.0 (file:///projects/panic)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s\n  Running `target/debug/panic`\n\nthread 'main' panicked at src/main.rs:4:6:\nindex out of bounds: the len is 3 but the index is 99\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n```\n\n----------------------------------------\n\nTITLE: Use Statement Scope Limitation Rust\nDESCRIPTION: This snippet demonstrates that a `use` statement only applies to the scope in which it is defined. The `eat_at_restaurant` function is moved into a new module `customer`, outside the scope of the `use` statement, resulting in a compilation error.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\nuse crate::front_of_house::hosting;\n\nmod customer {\n    pub fn eat_at_restaurant() {\n        hosting::add_to_waitlist();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Field Init Shorthand in Rust\nDESCRIPTION: This code defines a function `build_user` that utilizes field init shorthand to simplify struct initialization when the parameter names match the field names. It takes email and username as input and returns a `User` struct.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn build_user(email: String, username: String) -> User {\n    User {\n        active: true,\n        username,\n        email,\n        sign_in_count: 1,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: While Loop in Rust\nDESCRIPTION: This Rust snippet uses a `while` loop to execute code as long as a condition is true. The counter variable `number` is decremented in each iteration, and the loop continues until `number` is no longer greater than 0. After the loop, a message is printed.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-05-control-flow.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut number = 3;\n\n    while number != 0 {\n        println!(\"{}!\", number);\n\n        number -= 1;\n    }\n\n    println!(\"LIFTOFF!!!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Main Function Module Declaration\nDESCRIPTION: This Rust code snippet demonstrates the declaration of modules within the main function of a binary crate, as specified in `src/main.rs`. It showcases the `pub mod` declaration, making the 'garden' module public.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-02-defining-modules-to-control-scope-and-privacy.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub mod garden;\n\nfn main() {\n    let plant = garden::vegetables::Asparagus {};\n    println!(\"I'm growing {:?}!\", plant);\n}\n```\n\n----------------------------------------\n\nTITLE: Borrowing Issues with Mutable and Immutable References in Rust\nDESCRIPTION: This snippet demonstrates a common borrowing error in Rust: attempting to hold an immutable reference to an element in a vector while simultaneously trying to add a new element to the same vector. This is disallowed due to potential memory reallocation that could invalidate the existing reference.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-01-vectors.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let mut v = vec![1, 2, 3, 4, 5];\n\n    let first = &v[0];\n\n    v.push(6);\n\n    println!(\"The first element is: {}\", first);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Iterator Trait with Associated Type in Rust\nDESCRIPTION: This code snippet demonstrates the definition of the `Iterator` trait with an associated type `Item`. The `next` method uses this associated type in its signature, returning an `Option` containing the associated `Item` type.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/associated-types.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub trait Iterator {\n    type Item;\n    fn next(&mut self) -> Option<Self::Item>;\n}\n```\n\n----------------------------------------\n\nTITLE: If Let for Value Production Rust\nDESCRIPTION: This snippet demonstrates using `if let` to produce a value or return early. If the coin is a quarter, it proceeds; otherwise, it returns `None`. It's somewhat verbose because it combines producing a value and returning early within the same if-else structure.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_27\n\nLANGUAGE: Rust\nCODE:\n```\nfn describe_state_quarter(coin: Coin) -> Option<String> {\n    let state = if let Coin::Quarter(state) = coin {\n        state\n    } else {\n        return None;\n    };\n\n    if state.existed_in(1900) {\n        Some(format!(\"{state:?} is pretty old, for America!\"))\n    } else {\n        Some(format!(\"{state:?} is relatively new.\"))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending and Receiving Multiple Messages over Async Channel in Rust (Incomplete)\nDESCRIPTION: This code attempts to send multiple messages over an asynchronous channel with a delay between each message. However, due to the single async block, the messages are sent all at once and the program never exits.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-02-concurrency-with-async.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse trpl::sleep;\n\nasync fn many_messages() {\n    let (tx, rx) = trpl::channel();\n\n    let vals = [\"first\", \"second\", \"third\", \"fourth\"];\n\n    for val in vals {\n        println!(\"sending {}\", val);\n        tx.send(val).await;\n        sleep(0.5).await;\n    }\n\n    while let Some(msg) = rx.recv().await {\n        println!(\"received {}\", msg);\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Explicit dereferencing without coercion in Rust\nDESCRIPTION: This code shows how to call the `hello` function with a `MyBox<String>` without deref coercion. It requires explicit dereferencing and slicing to convert the `MyBox<String>` into a `&str`, which is more verbose and less readable than using deref coercion.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-02-deref.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse crate::MyBox;\n\nfn main() {\n    let m = MyBox::new(String::from(\"Rust\"));\n    hello(&(*m)[..]);\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo Run Execution Output\nDESCRIPTION: This output shows the result of executing the `cargo run` command for a Rust project. The output includes compilation messages, the time taken for compilation, and the program's output, which demonstrates the logic for assigning shirt colors.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch13-functional-features/listing-13-01/output.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n Compiling shirt-company v0.1.0 (file:///projects/shirt-company)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s\n     Running `target/debug/shirt-company`\nThe user with preference Some(Red) gets Red\nThe user with preference None gets Blue\n```\n\n----------------------------------------\n\nTITLE: Looping Through Collection with For Rust\nDESCRIPTION: This example showcases iterating through an array using a `for` loop in Rust. The `for` loop provides a safer and more concise way to access each element in the array without needing to manage an index manually.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_37\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let a = [10, 20, 30, 40, 50];\n\n    for element in a {\n        println!(\"the value is: {element}\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Cargo.toml for Publishing\nDESCRIPTION: This snippet shows a complete `Cargo.toml` file with a unique name, version, description, and license, ready for publishing to crates.io. It includes the edition and license fields.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"guessing_game\"\nversion = \"0.1.0\"\nedition = \"2021\"\ndescription = \"A fun game where you guess what number the computer has chosen.\"\nlicense = \"MIT OR Apache-2.0\"\n\n[dependencies]\n```\n\n----------------------------------------\n\nTITLE: Enum with Different Data Types in Rust\nDESCRIPTION: This snippet defines the `IpAddr` enum where `V4` has four `u8` values and `V6` has a `String`. It showcases the ability to have different data types per enum variant. No dependencies required.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nenum IpAddr {\n    V4(u8, u8, u8, u8),\n    V6(String),\n}\n\nlet home = IpAddr::V4(127, 0, 0, 1);\n\nlet loopback = IpAddr::V6(String::from(\"::1\"));\n```\n\n----------------------------------------\n\nTITLE: Adding trpl crate dependency with cargo\nDESCRIPTION: This snippet demonstrates how to add the `trpl` crate as a dependency to a new Rust project named `hello-async` using Cargo. It involves creating a new project, navigating to the project directory, and then using `cargo add` to add the `trpl` crate.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo new hello-async\n$ cd hello-async\n$ cargo add trpl\n```\n\n----------------------------------------\n\nTITLE: Implementing the Draw Trait for Button in Rust\nDESCRIPTION: This snippet defines a `Button` struct with `width`, `height`, and `label` fields and implements the `Draw` trait for it. The `draw` method is left empty, representing the GUI drawing logic.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter18.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\npub struct Button {\n    pub width: u32,\n    pub height: u32,\n    pub label: String,\n}\n\nimpl Draw for Button {\n    fn draw(&self) {\n        // code to actually draw a button\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Warning: Unused Import\nDESCRIPTION: This warning indicates that the import statement `use crate::front_of_house::hosting;` is not being used in the code. The compiler detected this unused import and issued a warning. This may indicate redundant or unnecessary code.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch07-managing-growing-projects/listing-07-12/output.txt#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nwarning: unused import: `crate::front_of_house::hosting`\n --> src/lib.rs:7:5\n  |\n7 | use crate::front_of_house::hosting;\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n```\n\n----------------------------------------\n\nTITLE: Opening a File with Result\nDESCRIPTION: This code snippet demonstrates how to open a file using `File::open` which returns a `Result`. The code does not handle the `Result`, but it shows the basic structure for opening a file that may or may not exist. The `std::fs::File` is required.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter09.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fs::File;\n\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n}\n```\n\n----------------------------------------\n\nTITLE: Point Struct with Single Generic Type Rust\nDESCRIPTION: This struct defines a `Point` with `x` and `y` coordinates of the same generic type `T`. Both x and y must be the same type. An example of how to instantiate it with integers and floats is provided.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nfn main() {\n    let integer = Point { x: 5, y: 10 };\n    let float = Point { x: 1.0, y: 4.0 };\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo new hello_macro --lib\nDESCRIPTION: Creates a new library crate named `hello_macro` using cargo.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-05-macros.md#_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n$ cargo new hello_macro --lib\n```\n\n----------------------------------------\n\nTITLE: Declaring Floating Point Variables with Type Inference/Annotation Rust\nDESCRIPTION: This code snippet demonstrates declaring floating-point variables in Rust. It shows both type inference, where the compiler deduces the type (f64 by default for floating-point literals), and explicit type annotation using `f32`.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/primitive-types.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 2.0; // f64\n\nlet y: f32 = 3.0; // f32\n```\n\n----------------------------------------\n\nTITLE: Using Option Values in Rust\nDESCRIPTION: This snippet demonstrates how to create and use `Option` values with different types. It shows how to create `Some` variants with specific values (e.g., `Some(5)`, `Some('e')`) and how to declare a `None` variant with a specific type (`Option<i32>`).\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nlet some_number = Some(5);\nlet some_char = Some('e');\n\nlet absent_number: Option<i32> = None;\n```\n\n----------------------------------------\n\nTITLE: Rust: Immutable Variable Reassignment Error\nDESCRIPTION: This code snippet demonstrates a compile-time error in Rust that occurs when attempting to assign a new value to a variable declared as immutable using `let`. The error message suggests declaring the variable as mutable using `let mut` to allow reassignment.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch03-common-programming-concepts/no-listing-01-variables-are-immutable/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 5;\nprintln!(\"The value of x is: {x}\");\nx = 6;\n```\n\n----------------------------------------\n\nTITLE: Node Struct Definition with Child Nodes\nDESCRIPTION: Defines a `Node` struct for a tree data structure, with a value and a vector of child nodes. The `children` field uses `RefCell` and `Rc` to allow interior mutability and shared ownership of child nodes.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n```\n\n----------------------------------------\n\nTITLE: Dereferencing a Regular Reference in Rust\nDESCRIPTION: This example demonstrates how to dereference a regular reference in Rust using the `*` operator to access the underlying value. It initializes an integer, creates a reference to it, and then asserts the equality of the original value and the dereferenced reference.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = 5;\n    let y = &x;\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise AND Operator Rust\nDESCRIPTION: This operator performs a bitwise AND operation on two expressions. It compares the bits of both operands and returns a new value where each bit is 1 only if the corresponding bits in both operands are 1. The `BitAnd` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\n`expr & expr`\n```\n\n----------------------------------------\n\nTITLE: Using Numeric Literal of Specific Type\nDESCRIPTION: This code snippet shows how to define numeric literals of specific types in Rust. These suffixes enforce the data type of the literal, influencing how the compiler handles the value.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_57\n\nLANGUAGE: Rust\nCODE:\n```\n...u8\n```\n\nLANGUAGE: Rust\nCODE:\n```\n...i32\n```\n\nLANGUAGE: Rust\nCODE:\n```\n...f64\n```\n\nLANGUAGE: Rust\nCODE:\n```\n...usize\n```\n\n----------------------------------------\n\nTITLE: Analyzing Rust E0507 Compile Error\nDESCRIPTION: This code snippet shows a Rust compile error E0507 that arises when attempting to move a `JoinHandle` out of a mutable reference. The `join()` method consumes `self`, causing a move. This example highlights the error in a context where a `JoinHandle` (likely associated with a spawned thread) is being accessed through a mutable reference, and the `join()` method is called.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch21-web-server/listing-21-22/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo check\n    Checking hello v0.1.0 (file:///projects/hello)\nerror[E0507]: cannot move out of `worker.thread` which is behind a mutable reference\n  --> src/lib.rs:52:13\n   |\n52 |             worker.thread.join().unwrap();\n   |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this method call\n   |             |\n   |             move occurs because `worker.thread` has type `JoinHandle<()>`, which does not implement the `Copy` trait\n   |\nnote: `JoinHandle::<T>::join` takes ownership of the receiver `self`, which moves `worker.thread`\n  --> /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/std/src/thread/mod.rs:1876:17\n\nFor more information about this error, try `rustc --explain E0507`.\nerror: could not compile `hello` (lib) due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Using the Glob Operator in `use` Statements in Rust\nDESCRIPTION: This demonstrates how to use the glob operator (`*`) to bring all public items defined in a path into the current scope. While convenient, it's generally discouraged due to potential naming conflicts and reduced code clarity.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::*;\n```\n\n----------------------------------------\n\nTITLE: Compiler Error: Async Main Function Not Allowed\nDESCRIPTION: This snippet presents the compiler error that arises when attempting to define the `main` function as `async`. This error highlights the requirement for an async runtime to manage asynchronous code execution, as `main` cannot be inherently asynchronous.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nerror[E0752]: `main` function is not allowed to be `async`\n --> src/main.rs:6:1\n  |\n6 | async fn main() {\n  | ^^^^^^^^^^^^^^^ `main` function is not allowed to be `async`\n```\n\n----------------------------------------\n\nTITLE: Yanking a Crate Version\nDESCRIPTION: This console command demonstrates how to yank a specific version of a crate using `cargo yank`. The `--vers` flag specifies the version to yank.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-02-publishing-to-crates-io.md#_snippet_10\n\nLANGUAGE: console\nCODE:\n```\n$ cargo yank --vers 1.0.1\n    Updating crates.io index\n        Yank guessing_game@1.0.1\n```\n\n----------------------------------------\n\nTITLE: String Creation with String::from\nDESCRIPTION: This code snippet shows how to create a `String` type from a string literal using the `from` function. The `String` type manages data allocated on the heap, allowing it to store text of unknown size at compile time.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet s = String::from(\"hello\");\n```\n\n----------------------------------------\n\nTITLE: Accessing Associated Items\nDESCRIPTION: This code snippet illustrates how to access associated constants, functions, and types using a type or a trait in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_71\n\nLANGUAGE: Rust\nCODE:\n```\ntype::ident\n```\n\nLANGUAGE: Rust\nCODE:\n```\n<type as trait>::ident\n```\n\n----------------------------------------\n\nTITLE: Incrementing a Counter with Mutex and Rc - Rust\nDESCRIPTION: This code attempts to fix the previous error by wrapping the Mutex in an Rc to allow multiple ownership. However, Rc is not thread-safe, leading to a different compiler error: Rc<Mutex<i32>> cannot be sent between threads safely. Demonstrates that Rc is unsuitable for sharing data between threads.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter16.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nuse std::rc::Rc;\nuse std::sync::Mutex;\nuse std::thread;\n\nfn main() {\n    let counter = Rc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Rc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating Through Lines with the lines Method in Rust\nDESCRIPTION: This code snippet demonstrates how to iterate through lines in a string using the `lines` method in Rust. It takes a query string and a content string as input and iterates through each line of the content. The function currently doesn't perform any action on each line, but serves as a starting point for further implementation.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\npub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    for line in contents.lines() {\n        // do something with line\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Procedural Macro Definition Example\nDESCRIPTION: This code demonstrates the basic structure of a procedural macro definition in Rust.  It shows the function signature that accepts and returns a `TokenStream`, and the attribute used to indicate the type of procedural macro.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-05-macros.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse proc_macro;\n\n#[some_attribute]\npub fn some_name(input: TokenStream) -> TokenStream {\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the `content` Method (Placeholder)\nDESCRIPTION: This snippet provides a placeholder implementation of the `content` method on the `Post` struct. It currently always returns an empty string slice, ensuring that draft posts do not expose any content. This will be updated later to return the actual content when the post is in the published state.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-03-oo-design-patterns.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nimpl Post {\n    pub fn content(&self) -> &str {\n        \"\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Multiple Messages Over Async Channel\nDESCRIPTION: This code sends a series of messages through the channel with a delay between each send using `trpl::sleep`. It then receives the messages using a `while let` loop. The loop continues until the sender closes the channel, which is signaled by `rx.recv().await` returning `None`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nlet (tx, mut rx) = trpl::channel();\n\nlet vals = vec![\n    String::from(\"hi\"),\n    String::from(\"from\"),\n    String::from(\"the\"),\n    String::from(\"future\"),\n];\n\nfor val in vals {\n    tx.send(val).unwrap();\n    trpl::sleep(Duration::from_millis(500)).await;\n}\n\nwhile let Some(value) = rx.recv().await {\n    println!(\"received '{value}'\");\n}\n```\n\n----------------------------------------\n\nTITLE: Documenting a Crate with `//!` in Rust\nDESCRIPTION: This snippet demonstrates how to use `//!` style doc comments to document a crate as a whole. The comments are placed at the beginning of the `src/lib.rs` file and describe the purpose of the crate.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n//! # My Crate\n//!\n//! `my_crate` is a collection of utilities to make performing certain\n//! calculations more convenient.\n\n/// Adds one to the number given.\n// --snip--\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Macro in Rust\nDESCRIPTION: This code snippet demonstrates how to define a macro named `five_times` using `macro_rules!`. The macro takes an expression as input and expands to the expression multiplied by 5. The `main` function then shows how to call the macro and assert the result.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/macros.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmacro_rules! five_times {\n    ($x:expr) => (5 * $x);\n}\n\nfn main() {\n    assert_eq!(25, five_times!(2 + 3));\n}\n```\n\n----------------------------------------\n\nTITLE: Screen Struct with Generics and Trait Bounds\nDESCRIPTION: This code shows an alternative implementation of the `Screen` struct using generics and trait bounds. This approach restricts the `Screen` to holding components of a single type that implements the `Draw` trait, contrasting with the trait object approach that allows for heterogeneous collections.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-02-trait-objects.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub struct Screen<T: Draw> {\n    pub components: Vec<T>,\n}\n\nimpl<T>\n    Screen<T>\nwhere\n    T: Draw,\n{\n    pub fn run(&mut self) {\n        for component in self.components.iter_mut() {\n            component.draw();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Program Without Arguments - Console\nDESCRIPTION: This console output shows the result of running the `minigrep` program without any command-line arguments. The output displays a vector containing only the path to the executable.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-01-accepting-command-line-arguments.md#_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n[\"target/debug/minigrep\"]\n```\n\n----------------------------------------\n\nTITLE: Running Cargo Project\nDESCRIPTION: This snippet demonstrates how to run a Rust project using the `cargo run` command. It compiles the project 'backyard' and then executes the compiled binary. The output displays compilation status and the program's output.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch07-managing-growing-projects/quick-reference-example/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n   Compiling backyard v0.1.0 (file:///projects/backyard)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.36s\n     Running `target/debug/backyard`\nI'm growing Asparagus!\n```\n\n----------------------------------------\n\nTITLE: Vector Dropping Example - Rust\nDESCRIPTION: This code snippet illustrates how a vector is automatically dropped when it goes out of scope. When the variable `v` goes out of scope, the memory it occupies is deallocated, including all of its elements.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n{\n    let v = vec![1, 2, 3, 4];\n\n    // do stuff with v\n} // <- v goes out of scope and is freed here\n```\n\n----------------------------------------\n\nTITLE: Incorrect Tuple Destructuring in Rust\nDESCRIPTION: This snippet shows an example of incorrect tuple destructuring, where the number of elements in the pattern does not match the number of elements in the tuple.  This results in a compiler error, highlighting the importance of matching the structure of the pattern with the structure of the value being matched.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet (x, y) = (1, 2, 3);\n```\n\n----------------------------------------\n\nTITLE: Adding License to Cargo.toml\nDESCRIPTION: This snippet demonstrates how to add a license identifier to the `Cargo.toml` file, indicating the terms under which the crate can be used. It uses the SPDX identifier for the MIT license.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"guessing_game\"\nlicense = \"MIT\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Module in Rust\nDESCRIPTION: This code snippet demonstrates how to define a module named `network` in Rust. The module contains a private function `connect`.  By default, items within a module are private, meaning they are not accessible from outside the module.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/crates-and-modules.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmod network {\n    fn connect() {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Two `use` statements, one a subpath of the other in Rust\nDESCRIPTION: This example displays two separate `use` statements, where one is a subpath of the other, specifically `std::io` and `std::io::Write`. It sets the stage for combining them using nested paths.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nuse std::io;\nuse std::io::Write;\n```\n\n----------------------------------------\n\nTITLE: Generated main.rs file by Cargo\nDESCRIPTION: This code snippet shows the content of `src/main.rs` which is generated by `cargo new`. It contains a simple \"Hello, world!\" program, which demonstrates the basic structure of a Rust application.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-03-hello-cargo.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n----------------------------------------\n\nTITLE: UTF-8 Byte Representation (Hindi)\nDESCRIPTION: This snippet demonstrates the UTF-8 byte representation of the Hindi word . The string is stored as a vector of `u8` values. The length of this string when measured in bytes is 18 bytes.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\n[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,\n224, 165, 135]\n```\n\n----------------------------------------\n\nTITLE: Async Block Cannot Be Unpinned Error in Rust\nDESCRIPTION: This code snippet shows a common error encountered when working with asynchronous blocks and the `join_all` function. The error message indicates that the `Unpin` trait is not implemented for the async block, requiring the use of `pin!` macro or `Box::pin` to pin the value.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-05-traits-for-async.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nerror[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned\n  --> src/main.rs:48:33\n   |\n48 |         trpl::join_all(futures).await;\n   |                                 ^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`\n   |\n   = note: consider using the `pin!` macro\n           consider using `Box::pin` if you need to access the pinned value outside of the current scope\n   = note: required for `Box<{async block@src/main.rs:10:23: 10:33}>` to implement `Future`\nnote: required by a bound in `futures_util::future::join_all::JoinAll`\n  --> file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:29:8\n   |\n27 | pub struct JoinAll<F>\n   |            ------- required by a bound in this struct\n28 | where\n29 |     F: Future,\n   |        ^^^^^^ required by this bound in `JoinAll`\n```\n\n----------------------------------------\n\nTITLE: Installing dprint using cargo\nDESCRIPTION: This command installs `dprint` using cargo, the Rust package manager. `dprint` is used for formatting Markdown source files and non-Rust code within the project, ensuring consistent styling across all file types.\nSOURCE: https://github.com/rust-lang/book/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncargo install dprint\n```\n\n----------------------------------------\n\nTITLE: Installing Nightly Rust Toolchain via Rustup\nDESCRIPTION: This command installs the nightly toolchain of Rust using Rustup. The nightly toolchain allows developers to access and test unstable features that are not yet available in the stable release.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-07-nightly-rust.md#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ rustup toolchain install nightly\n```\n\n----------------------------------------\n\nTITLE: While Loop in Rust\nDESCRIPTION: This code demonstrates a `while` loop in Rust. It initializes a mutable variable `number` to 3 and decrements it in each iteration until it becomes 0. In each iteration, it prints the current value of `number`.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/loops.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet mut number = 3;\nwhile number != 0 {\n    println!(\"{number}!\");\n    number = number - 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Match Expression with Option<i32> Pattern in Rust\nDESCRIPTION: This snippet shows a `match` expression that matches on an `Option<i32>` value. It demonstrates how to handle both `None` and `Some(i)` variants, incrementing the value inside the `Some` variant.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nmatch x {\n    None => None,\n    Some(i) => Some(i + 1),\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running (Linux/macOS)\nDESCRIPTION: These commands compile the `main.rs` file using the Rust compiler (`rustc`), creating an executable named `main`.  Then, the executable is run using `./main`. The expected output is \"Hello, world!\" printed to the console.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-02-hello-world.md#_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ rustc main.rs\n$ ./main\nHello, world!\n```\n\n----------------------------------------\n\nTITLE: Box Smart Pointer Initialization in Rust\nDESCRIPTION: This code snippet demonstrates how to initialize a `Box` smart pointer in Rust. The `Box::new(5)` allocates memory on the heap to store the integer 5 and returns a `Box` pointer to that memory location. The value is then printed to the console.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/choosing-your-guarantees.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet b = Box::new(5);\nprintln!(\"b = {b}\");\n```\n\n----------------------------------------\n\nTITLE: Using Re-exported Items from `art` Crate in Rust\nDESCRIPTION: This snippet shows how a crate can use the re-exported items from the `art` crate.  The `use` statements are simplified as the items are now available at the top level of the `art` crate.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nuse art::mix;\nuse art::PrimaryColor;\n\nfn main() {\n    // --snip--\n}\n```\n\n----------------------------------------\n\nTITLE: Creating type alias in Rust\nDESCRIPTION: This code snippet demonstrates how to create a type alias named `Kilometers` for the `i32` type in Rust. This allows you to use `Kilometers` as a synonym for `i32` in your code, improving readability when dealing with distance-related values.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/type-aliases.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntype Kilometers = i32;\n```\n\n----------------------------------------\n\nTITLE: Cargo Update Command in Console\nDESCRIPTION: This console snippet shows the output of running `cargo update`. It demonstrates how cargo updates crate dependencies, showing the current version, the target version, and available versions.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_17\n\nLANGUAGE: console\nCODE:\n```\n$ cargo update\n    Updating crates.io index\n     Locking 1 package to latest Rust 1.85.0 compatible version\n    Updating rand v0.8.5 -> v0.8.6 (available: v0.9.0)\n```\n\n----------------------------------------\n\nTITLE: Structs Similar to Message Enum in Rust\nDESCRIPTION: This code shows struct definitions that are similar to the `Message` enum variants. It highlights the difference between using separate structs and using a single enum with multiple variants.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch06-01-defining-an-enum.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nstruct QuitMessage;\nstruct MoveMessage {\n    x: i32,\n    y: i32,\n}\nstruct WriteMessage {\n    string: String,\n}\nstruct ChangeColorMessage {\n    red: i32,\n    green: i32,\n    blue: i32,\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Cargo Test\nDESCRIPTION: This snippet shows the command used to run tests in a Rust project using cargo, Rust's package manager. It compiles the project and executes the tests defined within the project. The command outputs the compilation status, test results, and execution time.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch12-an-io-project/listing-12-19/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test\n```\n\n----------------------------------------\n\nTITLE: HTML Content for Hello Page\nDESCRIPTION: This HTML file defines the structure and content for a simple \"Hello!\" webpage. It includes basic HTML5 structure with a heading and a paragraph.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Hello!</title>\n  </head>\n  <body>\n    <h1>Hello!</h1>\n    <p>Hi from Rust</p>\n  </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Define AveragedCollection struct in Rust\nDESCRIPTION: This code defines a struct `AveragedCollection` that holds a list of integers (`list`) and their average (`average`). The fields are private to ensure that the average is always in sync with the list.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch18-01-what-is-oo.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub struct AveragedCollection {\n    list: Vec<i32>,\n    average: f64,\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Area with Separate Variables in Rust\nDESCRIPTION: This snippet shows a basic program in Rust that calculates the area of a rectangle using separate width and height variables. The `area` function takes width and height as separate parameters.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let width1 = 30;\n    let height1 = 50;\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        area(width1, height1)\n    );\n}\n\nfn area(width: u32, height: u32) -> u32 {\n    width * height\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error: Explicit drop() call\nDESCRIPTION: This snippet demonstrates a Rust compilation error that occurs when explicitly calling the `drop()` method on an object. The error message suggests using the `drop` function from the standard library instead.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch15-smart-pointers/listing-15-15/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n Compiling drop-example v0.1.0 (file:///projects/drop-example)\nerror[E0040]: explicit use of destructor method\n  --> src/main.rs:16:7\n   |\n16 |     c.drop();\n   |       ^^^^ explicit destructor calls not allowed\n   |\nhelp: consider using `drop` function\n   |\n16 |     drop(c);\n   |     +++++ ~\n\nFor more information about this error, try `rustc --explain E0040`.\nerror: could not compile `drop-example` (bin \"drop-example\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Running a Rust Program with Cargo\nDESCRIPTION: These shell commands demonstrate how to run a Rust program using `cargo run`. The output shows the compilation process and the execution of the `guessing_game` application.  The program prompts the user to guess a number, reveals a secret number, then displays the user's guess.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter02.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s\n     Running `target/debug/guessing_game`\nGuess the number!\nThe secret number is: 7\nPlease input your guess.\n4\nYou guessed: 4\n\n$ cargo run\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s\n     Running `target/debug/guessing_game`\nGuess the number!\nThe secret number is: 83\nPlease input your guess.\n5\nYou guessed: 5\n```\n\n----------------------------------------\n\nTITLE: Rust Compiler Error: Drop Cycle Detection\nDESCRIPTION: This snippet shows a Rust compiler error (E0391) indicating a cycle detected when computing when `List` needs drop.  This is caused by the recursive nature of the `List` type.  The error message provides links to the Rust documentation about queries.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch15-smart-pointers/listing-15-03/output.txt#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nerror[E0391]: cycle detected when computing when `List` needs drop\n --> src/main.rs:1:1\n  |\n1 | enum List {\n  | ^^^^^^^^^\n  |\n  = note: ...which immediately requires computing when `List` needs drop again\n  = note: cycle used when computing whether `List` needs drop\n  = note: see https://rustc-dev-guide.rust-lang.org/overview.html#queries and https://rustc-dev-guide.rust-lang.org/query.html for more information\n```\n\n----------------------------------------\n\nTITLE: Cargo Test Summary\nDESCRIPTION: This snippet shows the summary of the test run, indicating that one test failed and none passed. It also shows the time taken for the test run and the command to rerun the tests.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/no-listing-06-greeter-with-bug/output.txt#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfailures:\n    tests::greeting_contains_name\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n```\n\n----------------------------------------\n\nTITLE: Adding a failing test\nDESCRIPTION: This code snippet demonstrates how to create a test that intentionally fails using the `panic!` macro.  This is useful for verifying that the test framework correctly identifies and reports failing tests.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-01-writing-tests.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-03/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Running Cargo with Arguments\nDESCRIPTION: This command compiles and runs the `minigrep` project, passing 'needle' and 'haystack' as command-line arguments. Cargo manages the compilation process and executes the resulting binary.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch12-an-io-project/output-only-01-with-args/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run -- needle haystack\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.57s\n     Running `target/debug/minigrep needle haystack`\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait in Rust\nDESCRIPTION: This code snippet defines a trait named `Summarizable` in Rust. The trait has a single method, `summary`, which takes a reference to `self` and returns a `String`. This trait allows types to abstract over common behavior related to summarization.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/traits.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub trait Summarizable {\n    fn summary(&self) -> String;\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding default optimization level for dev profile in Cargo.toml\nDESCRIPTION: This code snippet demonstrates how to override the default optimization level (`opt-level`) for the `dev` profile in the `Cargo.toml` file. It changes the default optimization level from 0 to 1, resulting in more optimizations during development builds.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-01-release-profiles.md#_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[profile.dev]\nopt-level = 1\n```\n\n----------------------------------------\n\nTITLE: Creating a New Project with Cargo\nDESCRIPTION: This command creates a new Cargo project named `hello_cargo`. It initializes a new directory and project structure with necessary files like `Cargo.toml` and `src/main.rs`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_20\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo new hello_cargo\n$ cd hello_cargo\n```\n\n----------------------------------------\n\nTITLE: Generic Function Definition with Implicit Sized Bound in Rust\nDESCRIPTION: This code snippet shows a generic function definition. Rust implicitly adds a `Sized` trait bound to every generic function, meaning the function will only work on types whose size is known at compile time.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-03-advanced-types.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-12-generic-fn-definition/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Lifetime Elision: One Input Reference with Lifetime in Rust\nDESCRIPTION: This code presents a modified `longest` function where only the first parameter `x` and the return type are annotated with a lifetime `'a`. Because the lifetime of `y` is not related to the lifetime of `x` or the return value, it is not necessary to specify a lifetime for `y`. This demonstrates lifetime elision rules when there is only one input lifetime.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-03-lifetime-syntax.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nfn longest<'a>(x: &'a str, y: &str) -> &'a str {\n    x\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Test Function\nDESCRIPTION: This snippet shows how to add a test function within the `add_one` crate to verify its functionality. The test checks if the `add_one` function returns the correct result. Located in the add_one/src/lib.rs file.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-03-cargo-workspaces.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_works() {\n        assert_eq!(add_one(2), 3);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a String from a String Literal - Rust\nDESCRIPTION: This example demonstrates how to create a `String` from a string literal using the `to_string()` method.  The `to_string()` method is available on any type that implements the `Display` trait.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nlet data = \"initial contents\";\n\nlet s = data.to_string();\n\n// The method also works on a literal directly:\nlet s = \"initial contents\".to_string();\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running Rust Code (Windows)\nDESCRIPTION: Compiles the main.rs file using the rustc compiler and then executes the compiled binary. The .\\main command runs the executable in the current directory.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_12\n\nLANGUAGE: Shell\nCODE:\n```\n> rustc main.rs\n> .\\main\n```\n\n----------------------------------------\n\nTITLE: Installing a C compiler on macOS\nDESCRIPTION: Installs the command line developer tools, which includes a C compiler. This is necessary because some Rust packages depend on C code and require a C compiler to build.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n$ xcode-select --install\n```\n\n----------------------------------------\n\nTITLE: Refutable Pattern with `if let` in Rust\nDESCRIPTION: This snippet shows the corrected version of the previous example, using `if let` with the refutable pattern `Some(x)`. This allows the code to handle the case where `some_option_value` is `None`, making the code valid.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nif let Some(x) = some_option_value {\n    println!(\"{x}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Installing C compiler on macOS\nDESCRIPTION: Installs a C compiler on macOS using xcode-select. This is necessary because some common Rust packages depend on C code and require a C compiler for compilation. The command opens a prompt that will install the command line developer tools.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-01-installation.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n$ xcode-select --install\n```\n\n----------------------------------------\n\nTITLE: Downloading Rust dependencies offline with Cargo\nDESCRIPTION: Creates a new Cargo project, navigates into it, and adds specified dependencies.  This process caches the dependencies allowing for offline usage later. Requires Cargo to be installed.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-01-installation.md#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo new get-dependencies\n$ cd get-dependencies\n$ cargo add rand@0.8.5 trpl@0.2.0\n```\n\n----------------------------------------\n\nTITLE: Running Program With Arguments - Console\nDESCRIPTION: This console output shows the result of running the `minigrep` program with two command-line arguments: `arg1` and `arg2`. The output displays a vector containing the path to the executable followed by the two provided arguments.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-01-accepting-command-line-arguments.md#_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n[\"target/debug/minigrep\", \"arg1\", \"arg2\"]\n```\n\n----------------------------------------\n\nTITLE: Import ThreadPool - Rust\nDESCRIPTION: This code imports the `ThreadPool` struct into the `main.rs` file, allowing it to be used in the main application logic. It assumes that the `ThreadPool` struct is defined in a separate library crate named `hello`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nuse hello::ThreadPool;\n```\n\n----------------------------------------\n\nTITLE: Bitwise Exclusive OR and Assignment Operator Rust\nDESCRIPTION: This operator performs a bitwise exclusive OR (XOR) operation and assigns the result to the variable. It's a shorthand for `var = var ^ expr`. The `BitXorAssign` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_50\n\nLANGUAGE: Rust\nCODE:\n```\n`var ^= expr`\n```\n\n----------------------------------------\n\nTITLE: Updating Rust via rustup\nDESCRIPTION: Updates the Rust toolchain to the latest stable version using the rustup tool. This ensures that you have the most recent features and bug fixes.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\n$ rustup update\n```\n\n----------------------------------------\n\nTITLE: Changing the test name output\nDESCRIPTION: This console output shows the result of running tests after renaming the `it_works` function to `exploration`. The output now displays `exploration` instead of `it_works` indicating the name change was successful.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-01-writing-tests.md#_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n{{#include ../listings/ch11-writing-automated-tests/no-listing-01-changing-test-name/output.txt}}\n```\n\n----------------------------------------\n\nTITLE: Cargo.toml Dependencies for derive\nDESCRIPTION: Adds `syn` and `quote` as dependencies to the `hello_macro_derive` crate's Cargo.toml file. These dependencies are necessary for parsing and generating Rust code within the macro.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-05-macros.md#_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n{{#include ../listings/ch20-advanced-features/listing-20-40/hello_macro/hello_macro_derive/Cargo.toml:6:12}}\n```\n\n----------------------------------------\n\nTITLE: Defining and Calling Functions in Rust\nDESCRIPTION: This code snippet defines two functions in Rust: `main` and `another_function`. The `main` function is the entry point of the program and calls `another_function`. Both functions use `println!` to print messages to the console.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/functions.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    println!(\"Hello, world!\");\n\n    another_function();\n}\n\nfn another_function() {\n    println!(\"Another function.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Enum in Rust\nDESCRIPTION: This code snippet defines a simple enum called `IpAddrKind` with two possible values: `V4` and `V6`. Enums are used to represent a type that can be one of several possible variants.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/enums.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum IpAddrKind {\n    V4,\n    V6,\n}\n```\n\n----------------------------------------\n\nTITLE: Printing to the Console Using println! Macro in Rust\nDESCRIPTION: This code snippet uses the `println!` macro to print \"Hello, world!\" to the console. The `println!` macro is used for outputting text to the screen.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nprintln!(\"Hello, world!\");\n```\n\n----------------------------------------\n\nTITLE: Rust code using the PI constant\nDESCRIPTION: This Rust code snippet uses the `std::f64::consts::PI` constant. This is the recommended way to use pi in Rust and will not trigger an error from Clippy.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix.md#_snippet_13\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    let x = std::f64::consts::PI;\n    let r = 8.0;\n    println!(\"the area of the circle is {}\", x * r * r);\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Cargo Version using command line\nDESCRIPTION: This command checks the installed version of Cargo, Rust's build system and package manager. It's used to verify that Cargo is installed correctly and to determine its version.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-03-hello-cargo.md#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ cargo --version\n```\n\n----------------------------------------\n\nTITLE: Installing Clippy with rustup\nDESCRIPTION: This command installs the Clippy linter using rustup. Clippy is a collection of lints that can help catch common mistakes and improve Rust code quality.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix.md#_snippet_10\n\nLANGUAGE: Shell\nCODE:\n```\n$ rustup component add clippy\n```\n\n----------------------------------------\n\nTITLE: Less Than Comparison Operator Rust\nDESCRIPTION: This operator performs a less than comparison. It returns `true` if the left operand is less than the right operand, and `false` otherwise. The `PartialOrd` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_39\n\nLANGUAGE: Rust\nCODE:\n```\n`expr < expr`\n```\n\n----------------------------------------\n\nTITLE: Running Cargo Run after Source Code Modification\nDESCRIPTION: Demonstrates the behavior of `cargo run` when source code has been modified. It recompiles the project before running the executable.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_26\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs\n     Running `target/debug/hello_cargo`\nHello, world!\n```\n\n----------------------------------------\n\nTITLE: Creating Project Directory (Windows CMD)\nDESCRIPTION: These commands create a project directory called `projects` inside the user's profile directory, then create a subdirectory called `hello_world` inside it, and finally navigate into the new directory. It uses Windows CMD commands.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-02-hello-world.md#_snippet_1\n\nLANGUAGE: cmd\nCODE:\n```\n> mkdir \"%USERPROFILE%\\projects\"\n> cd /d \"%USERPROFILE%\\projects\"\n> mkdir hello_world\n> cd hello_world\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error: Missing `None` Pattern\nDESCRIPTION: This code demonstrates a Rust compilation error (E0004) that arises when a `match` expression doesn't handle all possible cases of an enum. Here, the `None` variant of the `Option<i32>` enum is not matched. The compiler suggests adding a `None => todo!()` arm to handle the missing case.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch06-enums-and-pattern-matching/no-listing-10-non-exhaustive-match/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nerror[E0004]: non-exhaustive patterns: `None` not covered\n --> src/main.rs:3:15\n  |\n3 |         match x {\n  |               ^ pattern `None` not covered\n  |\nnote: `Option<i32>` defined here\n --> /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/core/src/option.rs:572:1\n ::: /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/core/src/option.rs:576:5\n  |\n  = note: not covered\n  = note: the matched value is of type `Option<i32>`\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n  |\n4 ~             Some(i) => Some(i + 1),\n5 ~             None => todo!(),\n  |\n```\n\n----------------------------------------\n\nTITLE: Invalid UTF-8 Indexing\nDESCRIPTION: This snippet demonstrates why Rust prevents indexing into strings. The first byte of the Cyrillic letter  is 208, but 208 is not a valid character on its own. Returning 208 is not what a user would expect if they asked for the first letter of the string.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nlet hello = \"\";\nlet answer = &hello[0];\n```\n\n----------------------------------------\n\nTITLE: Executing Cargo Tests\nDESCRIPTION: This snippet shows the command used to run tests in a Rust project using Cargo. It compiles the project and executes the defined unit and doc tests, providing feedback on their success or failure.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/no-listing-11-ignore-a-test/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test\n Compiling adder v0.1.0 (file:///projects/adder)\n  Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s\n   Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 2 tests\ntest tests::expensive_test ... ignored\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Creating a new project\nDESCRIPTION: This snippet shows how to create a new Rust project named 'guessing_game' using Cargo. The `cargo new` command initializes a new project directory with the necessary files and structure.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ cargo new guessing_game\n$ cd guessing_game\n```\n\n----------------------------------------\n\nTITLE: Defining a String Literal\nDESCRIPTION: This code snippet demonstrates a string literal in Rust. String literals are immutable sequences of UTF-8 characters.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_58\n\nLANGUAGE: Rust\nCODE:\n```\n\"...\"\n```\n\n----------------------------------------\n\nTITLE: Running a Cargo Project\nDESCRIPTION: This snippet shows the command used to run a Rust project using Cargo, along with the output showing compilation and execution. The output includes debug prints showing the values of variables during runtime.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch05-using-structs-to-structure-related-data/no-listing-05-dbg-macro/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s\n     Running `target/debug/rectangles`\n[src/main.rs:10:16] 30 * scale = 60\n[src/main.rs:14:5] &rect1 = Rectangle {\n    width: 60,\n    height: 50,\n}\n```\n\n----------------------------------------\n\nTITLE: Write trait in std::io with Result\nDESCRIPTION: This example shows the `Write` trait with functions returning `Result<T, E>` where `E` is `std::io::Error`. This is the initial state before introducing the type alias.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-03-advanced-types.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\ntrait Write {\n    fn write(&mut self, buf: &[u8]) -> Result<usize, Error>;\n    fn flush(&mut self) -> Result<(), Error>;\n\n    fn write_all(&mut self, buf: &[u8]) -> Result<(), Error> {\n        // --snip--\n    }\n    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<(), Error> {\n        // --snip--\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Never Type Example in Rust\nDESCRIPTION: This code illustrates a function `bar` that returns the never type `!`. Functions that return never are called diverging functions and can never return a value.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-03-advanced-types.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn bar() -> ! {\n    // --snip--\n    panic!();\n}\n```\n\n----------------------------------------\n\nTITLE: Longest Function Implementation (Uncompiled) in Rust\nDESCRIPTION: This code shows a basic implementation of the `longest` function, which attempts to return the longer of two string slices. However, it doesn't compile because the return type needs a generic lifetime parameter to tell Rust which reference (`x` or `y`) is being returned.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-03-lifetime-syntax.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-20/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Setting panic behavior to abort in Cargo.toml\nDESCRIPTION: This snippet demonstrates how to configure the panic behavior in the Cargo.toml file to abort instead of unwind. Setting `panic = 'abort'` will cause the program to terminate immediately without cleaning up when a panic occurs, potentially reducing the size of the resulting binary.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch09-01-unrecoverable-errors-with-panic.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[profile.release]\npanic = 'abort'\n```\n\n----------------------------------------\n\nTITLE: Creating an Iterator over a Byte Array\nDESCRIPTION: This Rust code snippet shows how to create an iterator over a byte array using the `iter` method. This iterator allows you to access each byte in the array sequentially, which is useful for searching or processing characters.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-03-slices.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-07/src/main.rs:iter}}\n```\n\n----------------------------------------\n\nTITLE: Nonequality Comparison Operator Rust\nDESCRIPTION: This operator checks if two expressions are not equal. It returns `true` if the expressions are different, and `false` otherwise. The `PartialEq` trait can be used to overload this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n`expr != expr`\n```\n\n----------------------------------------\n\nTITLE: Initializing a Tuple\nDESCRIPTION: This code snippet demonstrates how to create a tuple with different data types in Rust. The tuple is declared with parentheses and comma-separated values. Optional type annotations are also included.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-02-data-types.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet tup: (i32, f64, u8) = (500, 6.4, 1);\n\n```\n\n----------------------------------------\n\nTITLE: Install ghp-import tool using pipx\nDESCRIPTION: Installs the `ghp-import` tool using pipx, which is used to publish a preview to GitHub Pages. This command requires pipx to be installed.\nSOURCE: https://github.com/rust-lang/book/blob/main/ADMIN_TASKS.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npipx install ghp-import\n```\n\n----------------------------------------\n\nTITLE: Listing Files (Linux/macOS/PowerShell)\nDESCRIPTION: This command lists the files in the current directory.  It is used to verify that the `rustc` command has successfully created an executable file named `main` in addition to the source file `main.rs`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-02-hello-world.md#_snippet_7\n\nLANGUAGE: console\nCODE:\n```\n$ ls\nmain  main.rs\n```\n\n----------------------------------------\n\nTITLE: Compiling a Rust Program Using rustc\nDESCRIPTION: This command compiles a Rust source file (main.rs) using the Rust compiler `rustc`. It takes the source file as an argument and generates an executable binary.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\n$ rustc main.rs\n```\n\n----------------------------------------\n\nTITLE: Generated main.rs by Cargo\nDESCRIPTION: This code snippet is the \"Hello, world!\" program generated by Cargo in the `src/main.rs` file. It demonstrates the basic structure of a Rust program within a Cargo project.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Multiplication and Assignment Operator Rust\nDESCRIPTION: This operator performs arithmetic multiplication and assigns the result to the variable. It's a shorthand for `var = var * expr`. The `MulAssign` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_11\n\nLANGUAGE: Rust\nCODE:\n```\n`var *= expr`\n```\n\n----------------------------------------\n\nTITLE: Defining the Future Trait in Rust\nDESCRIPTION: This Rust code snippet presents the definition of the `Future` trait, including the `poll` method. The `poll` method takes a pinned mutable reference to `Self` (`Pin<&mut Self>`) and a `Context`, which is crucial for allowing a runtime to check any given future.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-05-traits-for-async.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\n\npub trait Future {\n    type Output;\n\n    // Required method\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Raw Pointers in Rust\nDESCRIPTION: This code snippet demonstrates how to create raw pointers from references in Rust. It creates both a const raw pointer (`*const i32`) and a mutable raw pointer (`*mut i32`) from a mutable variable.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/raw-pointers.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet mut num = 5;\n\nlet r1 = &num as *const i32;\nlet r2 = &mut num as *mut i32;\n```\n\n----------------------------------------\n\nTITLE: Defining a Draw Trait in Rust\nDESCRIPTION: This code snippet defines a trait named `Draw` with a single method `draw`. Any type implementing this trait must provide an implementation for the `draw` method.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter18.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub trait Draw {\n    fn draw(&self);\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Tests by Name - Cargo\nDESCRIPTION: This command runs all tests whose names contain the given string (e.g., `add`).  This is useful for running a subset of tests related to a specific feature or module.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo test add\n```\n\n----------------------------------------\n\nTITLE: Displaying PATH in Linux/macOS\nDESCRIPTION: Prints the value of the PATH environment variable in Linux and macOS. This is useful for verifying if the Rust installation directory is included in the PATH.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\n$ echo $PATH\n```\n\n----------------------------------------\n\nTITLE: Cargo Build Command\nDESCRIPTION: This snippet shows the command used to build the project. It uses the cargo tool, which is Rust's package manager and build system. The `build` command compiles the Rust source code in the project directory.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch07-managing-growing-projects/listing-07-12/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo build\n```\n\n----------------------------------------\n\nTITLE: Update Rustc Script Execution\nDESCRIPTION: Executes the `./tools/update-rustc.sh` script to update the Rust compiler version used by the book. This script handles the necessary changes to compiler output normalization.\nSOURCE: https://github.com/rust-lang/book/blob/main/ADMIN_TASKS.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./tools/update-rustc.sh\n```\n\n----------------------------------------\n\nTITLE: Uninstalling Rust via rustup\nDESCRIPTION: Uninstalls Rust and rustup from the system using the rustup self uninstall command. This removes all Rust-related files and configurations.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\n$ rustup self uninstall\n```\n\n----------------------------------------\n\nTITLE: Cargo Login Command in Rust\nDESCRIPTION: This snippet shows the command line interface command for logging into crates.io using a provided API token.  The token is pasted at the prompt.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo login\nabcdefghijklmnopqrstuvwxyz012345\n```\n\n----------------------------------------\n\nTITLE: Result Enum Definition Rust\nDESCRIPTION: This is the standard library definition of the `Result<T, E>` enum. It has two variants: `Ok(T)` representing a successful result and `Err(E)` representing an error.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Specified Threads - Cargo\nDESCRIPTION: This command instructs Cargo to run tests sequentially by setting the number of test threads to 1. This prevents tests from interfering with each other if they share state.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo test -- --test-threads=1\n```\n\n----------------------------------------\n\nTITLE: Bitwise/Logical Complement Operator Rust\nDESCRIPTION: This operator performs a bitwise or logical complement operation on an expression. It inverts the bits or negates the logical value. The `Not` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n`!expr`\n```\n\n----------------------------------------\n\nTITLE: Main function Hello World\nDESCRIPTION: This is the `src/main.rs` file generated by `cargo new`. It contains a basic \"Hello, world!\" program. The program prints \"Hello, world!\" to the console.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Struct Literal Update Syntax Operator Rust\nDESCRIPTION: This operator is used in struct literal update syntax to create a new struct instance by copying the fields from an existing instance.  It sets unspecified fields to the values from another struct.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_27\n\nLANGUAGE: Rust\nCODE:\n```\n`..expr`\n```\n\n----------------------------------------\n\nTITLE: Checking Rust Version\nDESCRIPTION: Checks if Rust is installed correctly by printing the version number, commit hash, and commit date. It invokes the rustc compiler with the --version flag.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n$ rustc --version\n```\n\n----------------------------------------\n\nTITLE: Match Expression Pattern Matching in Rust\nDESCRIPTION: Demonstrates the basic structure of a `match` expression in Rust, including the `match` keyword, a value to match on, and match arms consisting of a pattern and an expression to execute if the value matches the pattern.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmatch VALUE {\n    PATTERN => EXPRESSION,\n    PATTERN => EXPRESSION,\n    PATTERN => EXPRESSION,\n}\n```\n\n----------------------------------------\n\nTITLE: Simple panic! Call - Rust\nDESCRIPTION: This snippet demonstrates a basic call to the `panic!` macro, which will cause the program to terminate with an error message. It shows how to explicitly trigger a panic.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter09.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    panic!(\"crash and burn\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using Ignored Pattern Binding\nDESCRIPTION: This code snippet shows how to use the underscore (_) as an ignored pattern binding in Rust. It's also used to improve the readability of integer literals.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_66\n\nLANGUAGE: Rust\nCODE:\n```\n_\n```\n\n----------------------------------------\n\nTITLE: Attempt to Implement Supertrait Without Required Trait (Compilation Error)\nDESCRIPTION: This snippet attempts to implement the `OutlinePrint` trait for the `Point` struct without implementing the required `Display` trait, resulting in a compilation error. Requires `OutlinePrint` trait definition from the previous example.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-02-advanced-traits.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point { x: i32, y: i32 }\n\nimpl OutlinePrint for Point {}\n\n```\n\n----------------------------------------\n\nTITLE: Executing Rust program with Cargo and arguments\nDESCRIPTION: This command compiles and runs the Rust program `minigrep` with `poem.txt` as a command-line argument. It compiles the code using cargo, and then executes the compiled binary, passing `the poem.txt` as arguments.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch12-an-io-project/listing-12-04/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run -- the poem.txt\n Compiling minigrep v0.1.0 (file:///projects/minigrep)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n  Running `target/debug/minigrep the poem.txt`\nSearching for the\nIn file poem.txt\nWith text:\nI'm nobody! Who are you?\nAre you nobody, too?\nThen there's a pair of us - don't tell!\nThey'd banish us, you know.\n\nHow dreary to be somebody!\nHow public, like a frog\nTo tell your name the livelong day\nTo an admiring bog!\n```\n\n----------------------------------------\n\nTITLE: Installing rustfmt with rustup\nDESCRIPTION: This command uses `rustup` to add the `rustfmt` component to your Rust toolchain. `rustfmt` is used to automatically format Rust code to adhere to project coding style guidelines.\nSOURCE: https://github.com/rust-lang/book/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nrustup component add rustfmt\n```\n\n----------------------------------------\n\nTITLE: Rust Compile Error Message\nDESCRIPTION: This snippet shows the Rust compiler error message when attempting to use `Rc<Mutex<i32>>` in a multi-threaded context. The error indicates that `Rc<Mutex<i32>>` does not implement the `Send` trait, preventing it from being safely sent between threads.  The message points to the location in the code where the error occurs and provides hints on potential solutions, such as using `Arc` instead of `Rc` for thread-safe shared ownership.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch16-fearless-concurrency/listing-16-14/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nerror[E0277]: `Rc<Mutex<i32>>` cannot be sent between threads safely\n  --> src/main.rs:11:36\n   |\n11 |           let handle = thread::spawn(move || {\n   |                        ------------- ^------\n   |                        |             |\n   |  ______________________|_____________within this `{closure@src/main.rs:11:36: 11:43}`\n   | |                      |\n   | |                      required by a bound introduced by this call\n12 | |             let mut num = counter.lock().unwrap();\n13 | |\n14 | |             *num += 1;\n15 | |         });\n   | |_________^ `Rc<Mutex<i32>>` cannot be sent between threads safely\n   |\n   = help: within `{closure@src/main.rs:11:36: 11:43}`, the trait `Send` is not implemented for `Rc<Mutex<i32>>`\nnote: required because it's used within this closure\n  --> src/main.rs:11:36\n   |\n11 |         let handle = thread::spawn(move || {\n   |                                    ^^^^^^^\nnote: required by a bound in `spawn`\n  --> /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/std/src/thread/mod.rs:728:1\n```\n\n----------------------------------------\n\nTITLE: Irrefutable Pattern with `if let` in Rust\nDESCRIPTION: This snippet demonstrates attempting to use an irrefutable pattern `x` with `if let`, which triggers a compiler warning. This is because `if let` is designed to handle potential failure, and using an irrefutable pattern makes the `if let` construct redundant.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nif let x = 5 {\n    println!(\"{x}\");\n};\n```\n\n----------------------------------------\n\nTITLE: Running Cargo Project\nDESCRIPTION: This snippet demonstrates the execution of a Rust project named `traits-example` using the `cargo run` command. The output shows the compilation process and the program's output to the console.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch20-advanced-features/listing-20-19/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s\n     Running `target/debug/traits-example`\nThis is your captain speaking.\nUp!\n*waving arms furiously*\n```\n\n----------------------------------------\n\nTITLE: Defining the `Asparagus` struct\nDESCRIPTION: This code snippet defines the `Asparagus` struct and derives the `Debug` trait for it.  It resides within the `vegetables` module. The `pub` keyword makes the struct public, allowing it to be used outside the module.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\npub struct Asparagus {}\n```\n\n----------------------------------------\n\nTITLE: Running Tests for Specific Crate\nDESCRIPTION: This snippet demonstrates how to run tests for a specific crate (`add_one`) within the Cargo workspace using the `-p` flag. This allows focusing on the tests for a single crate, which can be useful for debugging or development.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-03-cargo-workspaces.md#_snippet_15\n\nLANGUAGE: console\nCODE:\n```\n$ cargo test -p add_one\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.00s\n     Running unittests src/lib.rs (target/debug/deps/add_one-93c49ee75dc46543)\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests add_one\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Executing Cargo Tests\nDESCRIPTION: This command executes the tests defined in the Rust project using the Cargo build system. It compiles the code, runs the tests, and reports the results, including any failures.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/no-listing-04-bug-in-add-two/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo test\n```\n\n----------------------------------------\n\nTITLE: Defining Result Enum\nDESCRIPTION: This code snippet defines the `Result` enum with two variants: `Ok` and `Err`. `Ok` represents a successful result with type `T`, while `Err` represents an error with type `E`. This enum is already available in the prelude.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter09.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\n----------------------------------------\n\nTITLE: Let Statement with Simple Assignment\nDESCRIPTION: This demonstrates a basic `let` statement with a simple variable assignment.  The variable `x` is bound to the value `5`. This highlights that even simple assignments utilize pattern matching where the variable name serves as the pattern.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-01-all-the-places-for-patterns.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 5;\n```\n\n----------------------------------------\n\nTITLE: Main function definition\nDESCRIPTION: This defines the `main` function, which is the entry point of the Rust program. All Rust programs must have a `main` function.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_6\n\nLANGUAGE: rust,ignore\nCODE:\n```\n{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:main}}\n```\n\n----------------------------------------\n\nTITLE: Contents of the output.txt file after a successful run\nDESCRIPTION: This snippet shows the contents of the `output.txt` file after a successful program run with standard output redirected to it. It demonstrates that successful program output is correctly being written to standard output, while errors now go to standard error.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-06-writing-to-stderr-instead-of-stdout.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nAre you nobody, too?\nHow dreary to be somebody!\n```\n\n----------------------------------------\n\nTITLE: Integrating Case-Insensitive Search into Run Function in Rust\nDESCRIPTION: The `run` function now checks the `ignore_case` field of the `Config` struct to determine whether to call the `search` or `search_case_insensitive` function. This allows the program to dynamically choose the appropriate search method based on the configuration.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter12.md#_snippet_26\n\nLANGUAGE: Rust\nCODE:\n```\npub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    let results = if config.ignore_case {\n        search_case_insensitive(&config.query, &contents)\n    } else {\n        search(&config.query, &contents)\n    };\n\n    for line in results {\n        println!(\"{line}\");\n    }\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Cargo Version\nDESCRIPTION: This command checks the installed version of Cargo, Rust's build system and package manager.  It verifies that Cargo is installed and accessible.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_19\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo --version\n```\n\n----------------------------------------\n\nTITLE: Character Declaration Rust\nDESCRIPTION: Shows examples of declaring character variables in Rust using the `char` type. It includes examples with ASCII characters, Unicode characters, and emoji.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let c = 'z';\n    let z: char = ''; // with explicit type annotation\n    let heart_eyed_cat = '';\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Enum in Rust\nDESCRIPTION: This snippet defines an `IpAddrKind` enum with two variants, `V4` and `V6`. This enum represents the possible types of IP addresses.  No dependencies required.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum IpAddrKind {\n    V4,\n    V6,\n}\n```\n\n----------------------------------------\n\nTITLE: Using Absolute Path\nDESCRIPTION: This code snippet illustrates the usage of an absolute path in Rust.  It's a path relative to the extern prelude, where all crates are rooted.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_68\n\nLANGUAGE: Rust\nCODE:\n```\n::path\n```\n\n----------------------------------------\n\nTITLE: Handling Errors in Asynchronous Channel Sends in Rust\nDESCRIPTION: This snippet demonstrates how to handle potential errors when sending messages through asynchronous channels. It modifies the `get_messages` and `get_intervals` functions to check for send errors and break out of the loops if an error occurs, preventing further attempts to send messages on a closed channel.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_44\n\nLANGUAGE: Rust\nCODE:\n```\nfn get_messages() -> impl Stream<Item = String> {\n    let (tx, rx) = trpl::channel();\n\n    trpl::spawn_task(async move {\n        let messages = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"];\n\n        for (index, message) in messages.into_iter().enumerate() {\n            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };\n            trpl::sleep(Duration::from_millis(time_to_sleep)).await;\n\n            if let Err(send_error) = tx.send(format!(\"Message: '{message}'\")) {\n                eprintln!(\"Cannot send message '{message}': {send_error}\");\n                break;\n            }\n        }\n    });\n\n    ReceiverStream::new(rx)\n}\n\nfn get_intervals() -> impl Stream<Item = u32> {\n    let (tx, rx) = trpl::channel();\n\n    trpl::spawn_task(async move {\n        let mut count = 0;\n        loop {\n            trpl::sleep(Duration::from_millis(1)).await;\n            count += 1;\n\n            if let Err(send_error) = tx.send(count) {\n                eprintln!(\"Could not send interval {count}: {send_error}\");\n                break;\n            };\n        }\n    });\n\n    ReceiverStream::new(rx)\n}\n```\n\n----------------------------------------\n\nTITLE: Variable Scope Example\nDESCRIPTION: This code block illustrates how a variable is valid within its scope in Rust. It shows when a variable comes into scope and when it goes out of scope.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-01/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Running Executable (Linux/macOS)\nDESCRIPTION: This command runs the compiled Rust executable named `main` on Linux or macOS. The `./` prefix is necessary to specify that the executable is in the current directory.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-02-hello-world.md#_snippet_9\n\nLANGUAGE: console\nCODE:\n```\n$ ./main # or .\\main on Windows\n```\n\n----------------------------------------\n\nTITLE: Loop Label Operator Rust\nDESCRIPTION: This operator is used to define a label for a loop, allowing `break` and `continue` statements to target a specific loop. This operator cannot be overloaded.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_34\n\nLANGUAGE: Rust\nCODE:\n```\n`'a: loop {...}`\n```\n\n----------------------------------------\n\nTITLE: Array Literal with Copies in Rust\nDESCRIPTION: This represents an array literal containing `len` copies of `expr` in Rust.  It's a shorthand for creating arrays with repeated values.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_112\n\nLANGUAGE: Rust\nCODE:\n```\n[expr; len]\n```\n\n----------------------------------------\n\nTITLE: Testing Book with mdBook\nDESCRIPTION: This command runs the tests for the book using the mdBook tool. It specifies the library path for the tests.\nSOURCE: https://github.com/rust-lang/book/blob/main/README.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ cd packages/trpl\n$ mdbook test --library-path packages/trpl/target/debug/deps\n```\n\n----------------------------------------\n\nTITLE: Console output\nDESCRIPTION: This snippet shows the console output when running the code with `poem.txt` as the file argument.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-02-reading-a-file.md#_snippet_2\n\nLANGUAGE: console\nCODE:\n```\nSearching for the\nIn file poem.txt\nIm Nobody! Who are you?\nAre you  Nobody  too?\nThen theres a pair of us!\nDont tell! theyd advertise  you know!\n\nHow dreary  to be  Somebody!\nHow public  like a Frog \nTo tell your name  the livelong June \nTo an admiring Bog!\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Drop Trait - Initial Attempt - Rust\nDESCRIPTION: This code snippet shows an initial, non-compiling attempt to implement the `Drop` trait for the `ThreadPool` struct. The goal is to join all threads in the pool when the pool goes out of scope. The code iterates through the workers and attempts to call `join` on each thread, but it fails because `join` requires ownership of the thread.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-03-graceful-shutdown-and-cleanup.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch21-web-server/listing-21-22/src/lib.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Running minigrep with Cargo\nDESCRIPTION: This command compiles and runs the `minigrep` application. It takes `frog` as the search string and `poem.txt` as the file to search within. The output shows the line in `poem.txt` that contains the word `frog`.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch12-an-io-project/no-listing-02-using-search-in-run/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run -- frog poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s\n     Running `target/debug/minigrep frog poem.txt`\nHow public, like a frog\n```\n\n----------------------------------------\n\nTITLE: Using Raw Identifiers to Define a Function Named `match` in Rust\nDESCRIPTION: This code snippet shows how to use a raw identifier (`r#`) to define a function named `match` in Rust, which is normally a reserved keyword. It also demonstrates how to call the function using the same raw identifier syntax.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix_a.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn r#match(needle: &str, haystack: &str) -> bool {\n    haystack.contains(needle)\n}\n\nfn main() {\n    assert!(r#match(\"foo\", \"foobar\"));\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Compile Error: Display trait not implemented\nDESCRIPTION: This code snippet shows a Rust compilation error indicating that the `Rectangle` struct does not implement the `std::fmt::Display` trait, preventing it from being directly printed using the `{}` format specifier in `println!`.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch05-using-structs-to-structure-related-data/listing-05-11/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n Compiling rectangles v0.1.0 (file:///projects/rectangles)\nerror[E0277]: `Rectangle` doesn't implement `std::fmt::Display`\n  --> src/main.rs:12:29\n   |\n12 |     println!(\"rect1 is {}\", rect1);\n   |                             ^^^^^ `Rectangle` cannot be formatted with the default formatter\n   |\n   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`\n   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `rectangles` (bin \"rectangles\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Adding External Dependency to Library Crate\nDESCRIPTION: Adds the `rand` crate as a dependency to the `add_one` library crate.  The version is specified as \"0.8.5\". This allows the add_one crate to use the rand crate.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_23\n\nLANGUAGE: TOML\nCODE:\n```\n[dependencies]\nrand = \"0.8.5\"\n```\n\n----------------------------------------\n\nTITLE: Executing Cargo Run\nDESCRIPTION: This snippet demonstrates the execution of a Rust project named `minigrep` using the `cargo run` command. The command compiles the project and then executes the resulting binary, passing `monomorphization` and `poem.txt` as command-line arguments to the executable.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch12-an-io-project/output-only-04-no-matches/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run -- monomorphization poem.txt\n Compiling minigrep v0.1.0 (file:///projects/minigrep)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n  Running `target/debug/minigrep monomorphization poem.txt`\n```\n\n----------------------------------------\n\nTITLE: Using Generic Type with Associated Type Assignments\nDESCRIPTION: This code snippet shows how to define a generic type where one or more associated types have specific assignments (e.g., `Iterator<Item=T>`).\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_83\n\nLANGUAGE: Rust\nCODE:\n```\ntype<ident=type>\n```\n\n----------------------------------------\n\nTITLE: Creating a Tuple Struct in Rust\nDESCRIPTION: Defines two tuple structs named `Color` and `Point`. Tuple structs are similar to tuples but have a name. This example shows how to define and instantiate tuple structs.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-01-defining-structs.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Rust Program with Cargo\nDESCRIPTION: This snippet shows the command `cargo run` being used to compile and execute a Rust program. It compiles the `variables` project and then runs the executable, printing the output to the console. The output shows the values of the variable 'x' in different scopes.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch03-common-programming-concepts/no-listing-03-shadowing/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n   Compiling variables v0.1.0 (file:///projects/variables)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s\n     Running `target/debug/variables`\nThe value of x in the inner scope is: 12\nThe value of x is: 6\n```\n\n----------------------------------------\n\nTITLE: Initializing an array of strings\nDESCRIPTION: This code shows how to initialize an array of string literals in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-02-data-types.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nlet months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n              \"August\", \"September\", \"October\", \"November\", \"December\"];\n\n```\n\n----------------------------------------\n\nTITLE: Running a Rust project with Cargo\nDESCRIPTION: This command compiles and runs the specified Rust project. It assumes a valid `Cargo.toml` file exists in the current directory or a specified project path. The output shows the compilation process, the finished build profile, and the execution of the compiled binary. It also demonstrates a basic error message when required command-line arguments are missing.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch12-an-io-project/listing-12-10/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling minigrep v0.1.0 (file:///projects/minigrep)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s\n   Running `target/debug/minigrep`\nProblem parsing arguments: not enough arguments\n```\n\n----------------------------------------\n\nTITLE: Bringing a Function into Scope with Use (Unidiomatic) Rust\nDESCRIPTION: This snippet shows an unidiomatic way of using the `use` keyword in Rust to bring a function directly into scope. While functional, it's generally preferred to bring the parent module into scope and then call the function through the module.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\nuse crate::front_of_house::hosting::add_to_waitlist;\n\npub fn eat_at_restaurant() {\n    add_to_waitlist();\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Trait Method Implementation Explicitly\nDESCRIPTION: This example demonstrates how to explicitly call a trait method implementation when multiple traits with the same method name are implemented on a struct. It uses the fully qualified syntax `Trait::method(&instance)` to specify which trait's implementation of the method to use. It requires the `Pilot`, `Wizard`, and `Human` definitions from the first snippet.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-02-advanced-traits.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let person = Human;\n    Pilot::fly(&person);\n    Wizard::fly(&person);\n    person.fly();\n}\n```\n\n----------------------------------------\n\nTITLE: Poem Text\nDESCRIPTION: This snippet is a poem by Emily Dickinson to be used as a test file. It will be read by the rust code.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-02-reading-a-file.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nIm Nobody! Who are you?\nAre you  Nobody  too?\nThen theres a pair of us!\nDont tell! theyd advertise  you know!\n\nHow dreary  to be  Somebody!\nHow public  like a Frog \nTo tell your name  the livelong June \nTo an admiring Bog!\n```\n\n----------------------------------------\n\nTITLE: Defining a Non-Recursive Enum (Message) in Rust\nDESCRIPTION: This code defines a non-recursive enum `Message` with several variants: `Quit`, `Move`, `Write`, and `ChangeColor`. Each variant can hold different types of data. Rust determines the size of the `Message` enum by finding the variant that requires the most space.  This example shows how Rust handles size calculation for non-recursive enums, contrasting it with the issue encountered with recursive enums.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-01-box.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n```\n\n----------------------------------------\n\nTITLE: Borrow Operator Rust\nDESCRIPTION: This operator creates a borrow, which is a reference to a value. It allows accessing a value without taking ownership. This operator cannot be overloaded.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\n`&expr`\n```\n\nLANGUAGE: Rust\nCODE:\n```\n`&mut expr`\n```\n\n----------------------------------------\n\nTITLE: Printing to the console\nDESCRIPTION: This uses the `println!` macro to print a string to the console, which is useful for displaying prompts or information to the user.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch02-00-guessing-game-tutorial.md#_snippet_7\n\nLANGUAGE: rust,ignore\nCODE:\n```\n{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:print}}\n```\n\n----------------------------------------\n\nTITLE: Defining a Character Literal\nDESCRIPTION: This code snippet shows how to define a character literal in Rust. Character literals represent single Unicode scalar values.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_62\n\nLANGUAGE: Rust\nCODE:\n```\n'...'\n```\n\n----------------------------------------\n\nTITLE: Docx to Markdown Conversion Script Execution\nDESCRIPTION: Executes the `./tools/doc-to-md.sh` script to convert a docx file into markdown.\nSOURCE: https://github.com/rust-lang/book/blob/main/ADMIN_TASKS.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n./tools/doc-to-md.sh\n```\n\n----------------------------------------\n\nTITLE: Using Outer Attribute\nDESCRIPTION: This code snippet demonstrates the use of an outer attribute in Rust. Outer attributes apply to the item they precede.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_90\n\nLANGUAGE: Rust\nCODE:\n```\n#[meta]\n```\n\n----------------------------------------\n\nTITLE: Adding Member to Workspace Definition\nDESCRIPTION: Shows how the `adder` package is automatically added as a member in the workspace's `Cargo.toml` file after running `cargo new adder`. This entry ensures that the package is recognized as part of the workspace.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_15\n\nLANGUAGE: TOML\nCODE:\n```\n[workspace]\nresolver = \"2\"\nmembers = [\"adder\"]\n```\n\n----------------------------------------\n\nTITLE: Building the Workspace\nDESCRIPTION: Command to compile all the packages (crates) in the workspace. It compiles both the add_one library and the adder binary.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_21\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo build\n   Compiling add_one v0.1.0 (file:///projects/add/add_one)\n   Compiling adder v0.1.0 (file:///projects/add/adder)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.22s\n```\n\n----------------------------------------\n\nTITLE: Accessing Associated Items for Unnamed Types\nDESCRIPTION: This code snippet shows how to access an associated item for a type that cannot be directly named (e.g., `<&T>::...`, `<[T]>::...`).\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_72\n\nLANGUAGE: Rust\nCODE:\n```\n<type>::...\n```\n\n----------------------------------------\n\nTITLE: Rust String Indexing Error Example\nDESCRIPTION: This code snippet demonstrates the error that occurs when trying to access a character in a string using integer indexing in Rust. It shows the compiler error and suggests alternative methods for accessing string characters.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch08-common-collections/listing-08-19/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet s1 = String::from(\"hello\");\nlet h = s1[0];\n```\n\n----------------------------------------\n\nTITLE: Using `art` Crate with Internal Structure in Rust\nDESCRIPTION: This example illustrates how a crate can use items from the `art` crate while specifying the internal module structure (`art::kinds::PrimaryColor`, `art::utils::mix`). This shows the original way of using the `art` crate before any re-exporting.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nuse art::kinds::PrimaryColor;\nuse art::utils::mix;\n\nfn main() {\n    let red = PrimaryColor::Red;\n    let yellow = PrimaryColor::Yellow;\n    mix(red, yellow);\n}\n```\n\n----------------------------------------\n\nTITLE: Statement Example in Rust\nDESCRIPTION: This snippet provides an example of a statement in Rust, specifically the declaration and assignment of a variable using the `let` keyword. Statements do not return a value.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-03-how-functions-work.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let y = 6;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Empty Tuple (Unit)\nDESCRIPTION: This code snippet shows how to use an empty tuple (also known as unit) in Rust, both as a literal and as a type.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_102\n\nLANGUAGE: Rust\nCODE:\n```\n()\n```\n\n----------------------------------------\n\nTITLE: Trait Objects Example in Rust\nDESCRIPTION: This code defines GUI components (InputBox and Button) that implement the Draw trait. It then uses a Screen struct with a generic type parameter bounded by the Draw trait. The main function attempts to create a Screen with a vector of trait objects (Box<dyn Draw>), but this won't compile due to the Screen struct using a generic type parameter instead of trait objects.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/trait-objects.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub struct InputBox {\n    pub label: String,\n}\n\nimpl Draw for InputBox {\n    fn draw(&self) {\n        // Code to actually draw an input box\n    }\n}\n\npub struct Button {\n    pub label: String,\n}\n\nimpl Draw for Button {\n    fn draw(&self) {\n        // Code to actually draw a button\n    }\n}\n\npub struct Screen<T: Draw> {\n    pub components: Vec<T>,\n}\n\nimpl<T> Screen<T>\n    where T: Draw {\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n\nfn main() {\n    let screen = Screen {\n        components: vec![\n            Box::new(InputBox {\n                label: String::from(\"OK\"),\n            }),\n            Box::new(Button {\n                label: String::from(\"OK\"),\n            }),\n        ],\n    };\n\n    screen.run();\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Rust Program with Cargo\nDESCRIPTION: This snippet shows the output of running a Rust program named 'loops' using the `cargo run` command. It demonstrates the compilation process and the subsequent execution of the compiled binary, with output printed to the console.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch03-common-programming-concepts/listing-03-04/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n   Compiling loops v0.1.0 (file:///projects/loops)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32s\n     Running `target/debug/loops`\nthe value is: 10\nthe value is: 20\nthe value is: 30\nthe value is: 40\nthe value is: 50\n```\n\n----------------------------------------\n\nTITLE: Vector Initialization: Empty and Pre-populated (Rust)\nDESCRIPTION: This snippet demonstrates two ways to initialize vectors in Rust. The first line initializes an empty vector of type `i32` using `Vec::new()`. The second line uses the `vec![]` macro to initialize a vector with pre-defined integer values (1, 2, and 3).\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/vectors.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nlet v: Vec<i32> = Vec::new();\nlet numbers = vec![1, 2, 3];\n```\n\n----------------------------------------\n\nTITLE: Running a Cargo project\nDESCRIPTION: This command runs a Rust project using Cargo. It compiles the source code if necessary and then executes the resulting binary. This is a convenient way to both build and run a project in a single step.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-03-hello-cargo.md#_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ ./target/debug/hello_cargo # or .\\target\\debug\\hello_cargo.exe on Windows\nHello, world!\n```\n\n----------------------------------------\n\nTITLE: Declaring a `hosting` Module as Public in Rust\nDESCRIPTION: This snippet demonstrates declaring the `hosting` module as `pub` to allow access from the `eat_at_restaurant` function. This makes the module itself accessible, but not its contents.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nmod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Absolute path\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // Relative path\n    front_of_house::hosting::add_to_waitlist();\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error: Move Out of Captured Variable in Closure\nDESCRIPTION: This snippet shows a Rust compilation error (E0507) that arises when trying to move a captured variable (`value` of type `String`) inside an `FnMut` closure during list sorting (`list.sort_by_key`). The error occurs because `String` doesn't implement the `Copy` trait, and moving the value would violate borrowing rules. The suggested solution is to clone the value using `value.clone()` to avoid the move.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch13-functional-features/listing-13-08/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nerror[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure\n  --> src/main.rs:18:30\n   |\n15 |     let value = String::from(\"closure called\");\n   |         ----- captured outer variable\n16 |\n17 |     list.sort_by_key(|r| {\n   |                      --- captured by this `FnMut` closure\n18 |         sort_operations.push(value);\n   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait\n   |\nhelp: consider cloning the value if the performance cost is acceptable\n   |\n18 |         sort_operations.push(value.clone());\n   |                                   ++++++++\n```\n\n----------------------------------------\n\nTITLE: Examining strong and weak reference counts in Rust\nDESCRIPTION: This code snippet illustrates the use of inner scopes to track `strong_count` and `weak_count` of `Rc<Node>` instances. It shows how creating and dropping a `branch` node affects the reference counts of both the `branch` and `leaf` nodes. It demonstrates how a `Weak<Node>` reference (from `leaf.parent` pointing to `branch`) affects the weak count but doesn't prevent the `Node` from being dropped when the strong count reaches zero.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-06-reference-cycles.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell<Weak<Node>>,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n\nfn main() {\n    let leaf = Rc::new(\n        Node {\n            value: 3,\n            parent: RefCell::new(Weak::new()),\n            children: RefCell::new(vec![]),\n        }\n    );\n\n    println!(\"leaf strong = {}\\nleaf weak = {}\",\n             Rc::strong_count(&leaf),\n             Rc::weak_count(&leaf),\n    );\n\n    {\n        let branch = Rc::new(\n            Node {\n                value: 5,\n                parent: RefCell::new(Weak::new()),\n                children: RefCell::new(vec![Rc::clone(&leaf)]),\n            }\n        );\n\n        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n\n        println!(\"branch strong = {}\\nbranch weak = {}\",\n                 Rc::strong_count(&branch),\n                 Rc::weak_count(&branch),\n        );\n\n        println!(\"leaf strong = {}\\nleaf weak = {}\",\n                 Rc::strong_count(&leaf),\n                 Rc::weak_count(&leaf),\n        );\n    }\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n    println!(\"leaf strong = {}\\nleaf weak = {}\",\n             Rc::strong_count(&leaf),\n             Rc::weak_count(&leaf),\n    );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Opening Book in Firefox (Windows - PowerShell)\nDESCRIPTION: This command opens the built book in Firefox on Windows systems using PowerShell.\nSOURCE: https://github.com/rust-lang/book/blob/main/README.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ Start-Process \"firefox.exe\" .\\book\\index.html\n```\n\n----------------------------------------\n\nTITLE: Casting Integer to Float with `as` Operator in Rust\nDESCRIPTION: This code snippet demonstrates how to cast an integer to a float in Rust using the `as` keyword.  It defines a function `average` that takes a slice of `f64` values as input, calculates their sum and size (as `i32`), and then casts the size to `f64` before performing the division to calculate the average. This avoids integer division and ensures a floating-point result. The functions `sum` and `len` are assumed to be defined elsewhere.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/casting-between-types.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# fn sum(values: &[f64]) -> f64 { 0.0 }\n# fn len(values: &[f64]) -> i32 { 0 }\n\nfn average(values: &[f64]) -> f64 {\n    let sum: f64 = sum(values);\n    let size: f64 = len(values) as f64;\n    sum / size\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Single Test by Name - Cargo\nDESCRIPTION: This command executes only the test function with the specified name (e.g., `one_hundred`).\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo test one_hundred\n```\n\n----------------------------------------\n\nTITLE: Generate a built book before the change\nDESCRIPTION: Generates a built book before applying changes to test them.\nSOURCE: https://github.com/rust-lang/book/blob/main/ADMIN_TASKS.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nmdbook build -d tmp/book-before\n```\n\n----------------------------------------\n\nTITLE: Using Named Lifetime or Loop Label\nDESCRIPTION: This code snippet illustrates the use of a named lifetime or loop label in Rust. It is used to specify a particular lifetime or loop that a reference or loop control statement should refer to.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_56\n\nLANGUAGE: Rust\nCODE:\n```\n'ident\n```\n\n----------------------------------------\n\nTITLE: Executing Cargo Test\nDESCRIPTION: This snippet shows the command used to run the tests and the beginning of the output indicating that tests are being compiled and run. It includes the path of the compiled artifact and the indication that one test is running.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/no-listing-06-greeter-with-bug/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo test\n Compiling greeter v0.1.0 (file:///projects/greeter)\n  Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s\n   Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)\n\nrunning 1 test\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Patterns with a Match Guard in Rust\nDESCRIPTION: This snippet demonstrates how to combine multiple patterns using the `|` operator with a match guard. The match guard condition applies to all patterns specified with `|`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_33\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 4;\nlet y = false;\n\nmatch x {\n    4 | 5 | 6 if y => println!(\"yes\"),\n    _ => println!(\"no\"),\n}\n```\n\n----------------------------------------\n\nTITLE: Box Futures for Polymorphism in Rust\nDESCRIPTION: This snippet wraps each future in `Box::new` to attempt to align the types of the futures stored in the `Vec`. It's a step toward addressing the type mismatch issue but requires further type annotation and handling of `Unpin` requirements to fully resolve the compilation errors.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nlet futures =\n            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];\n\n        trpl::join_all(futures).await;\n```\n\n----------------------------------------\n\nTITLE: Single-line Comment in Rust\nDESCRIPTION: This snippet demonstrates a basic single-line comment in Rust. Comments are used to explain code and are ignored by the compiler.  They start with `//` and continue to the end of the line.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-04-comments.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n// hello, world\n```\n\n----------------------------------------\n\nTITLE: Panicking on Out-of-Bounds Access with Indexing in Rust\nDESCRIPTION: This snippet demonstrates that accessing a vector element using indexing with an out-of-bounds index will cause the program to panic. It shows the expected behavior when trying to access an element beyond the vector's size, specifically index 100 of a vector containing only five elements.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch08-01-vectors.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let v = vec![1, 2, 3, 4, 5];\n\n    let does_not_exist = &v[100];\n}\n```\n\n----------------------------------------\n\nTITLE: Struct Literal in Rust\nDESCRIPTION: This represents a struct literal in Rust, which is used to create an instance of a struct. It consists of the struct's type name followed by curly braces containing field-value pairs.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_110\n\nLANGUAGE: Rust\nCODE:\n```\nType {...}\n```\n\n----------------------------------------\n\nTITLE: Rust Compile Error: Use of Moved Value\nDESCRIPTION: This code snippet demonstrates a Rust compiler error (E0382) where a value `receiver` is moved inside a loop and then used again in a subsequent iteration. The error indicates that `receiver` has a type that does not implement the `Copy` trait and is therefore moved instead of copied. The compiler suggests either borrowing the value or moving the expression outside the loop.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch21-web-server/listing-21-17/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nerror[E0382]: use of moved value: `receiver`\n  --> src/lib.rs:26:42\n   |\n21 |         let (sender, receiver) = mpsc::channel();\n   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver<Job>`, which does not implement the `Copy` trait\n...\n25 |         for id in 0..size {\n   |         ----------------- inside of this loop\n26 |             workers.push(Worker::new(id, receiver));\n   |                                          ^^^^^^^^ value moved here, in previous iteration of loop\n   |\nnote: consider changing this parameter type in method `new` to borrow instead if owning the value isn't necessary\n  --> src/lib.rs:47:33\n   |\n47 |     fn new(id: usize, receiver: mpsc::Receiver<Job>) -> Worker {\n   |        --- in this method       ^^^^^^^^^^^^^^^^^^^ this parameter takes ownership of the value\nhelp: consider moving the expression out of the loop so it is only moved once\n   |\n25 ~         let mut value = Worker::new(id, receiver);\n26 ~         for id in 0..size {\n27 ~             workers.push(value);\n   |\n```\n\n----------------------------------------\n\nTITLE: Cargo Run Command and Output\nDESCRIPTION: This snippet demonstrates the execution of a Rust program using the `cargo run` command. It shows the compilation process and the subsequent output of the program, which prints the value of the 'number' variable. The command assumes that the current directory contains a Cargo project named 'branches'.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch03-common-programming-concepts/listing-03-02/output.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo run\n Compiling branches v0.1.0 (file:///projects/branches)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s\n  Running `target/debug/branches`\nThe value of number is: 5\n```\n\n----------------------------------------\n\nTITLE: Running a Binary Crate in a Workspace\nDESCRIPTION: Shows how to run a specific binary crate within the workspace using the `-p` argument followed by the package name. This executes the 'adder' binary.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_22\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo run -p adder\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s\n     Running `target/debug/adder`\nHello, world! 10 plus one is 11!\n```\n\n----------------------------------------\n\nTITLE: Creating a new Cargo project\nDESCRIPTION: This snippet demonstrates the command used to create a new binary application package using Cargo. It initializes a project directory with a Cargo.toml file and a src directory containing main.rs, setting up the basic structure for a Rust application.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo new my-project\n     Created binary (application) `my-project` package\n$ ls my-project\nCargo.toml\nsrc\n$ ls my-project/src\nmain.rs\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error: Missing Method\nDESCRIPTION: This error message indicates that the `execute` method is not found for the `ThreadPool` struct. This means the method is either not defined, not in scope, or has a different name. To resolve this, ensure that the `execute` method is properly defined for the `ThreadPool` struct and that it is accessible in the current scope.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch21-web-server/no-listing-02-impl-threadpool-new/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nerror[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope\n  --> src/main.rs:17:14\n   |\n17 |         pool.execute(|| {\n   |         -----^^^^^^^ method not found in `ThreadPool`\n```\n\n----------------------------------------\n\nTITLE: Using Macro Substitution\nDESCRIPTION: This code snippet illustrates the use of macro substitution in Rust. It replaces `$ident` with the corresponding value during macro expansion.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_92\n\nLANGUAGE: Rust\nCODE:\n```\n$ident\n```\n\n----------------------------------------\n\nTITLE: Defining an Unsafe Function\nDESCRIPTION: Defines an unsafe function named `dangerous`. Unsafe functions require the caller to uphold specific requirements, and they must be called within an `unsafe` block.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-01-unsafe-rust.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nunsafe fn dangerous() {}\n\n```\n\n----------------------------------------\n\nTITLE: Displaying the PATH environment variable in Linux/macOS\nDESCRIPTION: Displays the value of the PATH environment variable in Linux and macOS. The PATH variable is used by the shell to find executables.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-01-installation.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\n$ echo $PATH\n```\n\n----------------------------------------\n\nTITLE: Using Higher-Ranked Lifetime Bounds\nDESCRIPTION: This code snippet illustrates the usage of higher-ranked lifetime bounds in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_82\n\nLANGUAGE: Rust\nCODE:\n```\nfor<...> type\n```\n\n----------------------------------------\n\nTITLE: Defining Post and DraftPost structs with Methods - Rust\nDESCRIPTION: This code defines the `Post` and `DraftPost` structs, both containing a private `content` field. It also includes implementations for the `Post` struct with a `new` method that returns a `DraftPost` and a `content` method that returns a string slice. The `DraftPost` struct has an `add_text` method for adding text to its content.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter18.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\npub struct Post {\n    content: String,\n}\n\npub struct DraftPost {\n    content: String,\n}\n\nimpl Post {\n    pub fn new() -> DraftPost {\n        DraftPost {\n            content: String::new(),\n        }\n    }\n\n    pub fn content(&self) -> &str {\n        &self.content\n    }\n}\n\nimpl DraftPost {\n    pub fn add_text(&mut self, text: &str) {\n        self.content.push_str(text);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Function\nDESCRIPTION: This code snippet demonstrates how to define a generic function in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_78\n\nLANGUAGE: Rust\nCODE:\n```\nfn ident<...> ...\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Structure\nDESCRIPTION: This code snippet shows how to define a generic structure in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_79\n\nLANGUAGE: Rust\nCODE:\n```\nstruct ident<...> ...\n```\n\n----------------------------------------\n\nTITLE: Using Parenthesized Expression\nDESCRIPTION: This code snippet demonstrates the use of a parenthesized expression in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_103\n\nLANGUAGE: Rust\nCODE:\n```\n(expr)\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Implementation\nDESCRIPTION: This code snippet shows how to define a generic implementation in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_81\n\nLANGUAGE: Rust\nCODE:\n```\nimpl<...> ...\n```\n\n----------------------------------------\n\nTITLE: UTF-8 String Examples - Rust\nDESCRIPTION: This snippet showcases the ability of Rust's `String` to handle UTF-8 encoded text, providing examples in various languages. Each line creates a `String` initialized with a greeting in a different language.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nlet hello = String::from(\" \");\nlet hello = String::from(\"Dobr den\");\nlet hello = String::from(\"Hello\");\nlet hello = String::from(\"\");\nlet hello = String::from(\"\");\nlet hello = String::from(\"\");\nlet hello = String::from(\"\");\nlet hello = String::from(\"\");\nlet hello = String::from(\"Ol\");\nlet hello = String::from(\"\");\nlet hello = String::from(\"Hola\");\n```\n\n----------------------------------------\n\nTITLE: Running a Rust program with Cargo\nDESCRIPTION: This command compiles and executes a Rust program using Cargo, the Rust package manager. It shows the compilation output and the subsequent runtime output, including a panic message if an error occurs during execution.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch08-common-collections/output-only-01-not-char-boundary/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n   Compiling collections v0.1.0 (file:///projects/collections)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s\n     Running `target/debug/collections`\n\nthread 'main' panicked at src/main.rs:4:19:\nbyte index 1 is not a char boundary; it is inside '' (bytes 0..2) of ``\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error: Binary Operation `>`\nDESCRIPTION: This error occurs when the `>` operator is used on a generic type `T` without ensuring that `T` implements the `PartialOrd` trait.  The compiler cannot guarantee that the `>` operator is defined for all possible types that could be substituted for `T`. The suggested solution is to add a trait bound `T: std::cmp::PartialOrd` to the generic type definition.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0369]: binary operation `>` cannot be applied to type `&T`\n --> src/main.rs:5:17\n  |\n5 |         if item > largest {\n  |            ---- ^ ------- &T\n  |            |\n  |            &T\n  |\nhelp: consider restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> &T {\n  |             ++++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `chapter10` (bin \"chapter10\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Running a Cargo Project\nDESCRIPTION: This snippet demonstrates the use of the `cargo run` command to execute a Rust project.  It highlights a common error that occurs when the project doesn't have a defined binary target (e.g., no `main.rs` file in the `src` directory, or no `[[bin]]` section in the `Cargo.toml` file). The command attempts to compile and execute the default binary.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch17-async-await/no-listing-state-machine/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\nerror: a bin target must be available for `cargo run`\n```\n\n----------------------------------------\n\nTITLE: Calling a Function Using `super` in Rust\nDESCRIPTION: This example demonstrates using the `super` keyword to call a function defined in the parent module.  The `fix_incorrect_order` function in the `back_of_house` module calls the `deliver_order` function defined in the crate root.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn deliver_order() {}\n\nmod back_of_house {\n    fn fix_incorrect_order() {\n        super::deliver_order();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Constraint Operator Rust\nDESCRIPTION: This operator is used to specify a type constraint in pattern matching or variable declarations. It indicates that a value must have a specific type. This operator cannot be overloaded.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_32\n\nLANGUAGE: Rust\nCODE:\n```\n`pat: type`\n```\n\nLANGUAGE: Rust\nCODE:\n```\n`ident: type`\n```\n\n----------------------------------------\n\nTITLE: Installing Nightly Rust Toolchain\nDESCRIPTION: This command uses `rustup` to install the nightly toolchain, allowing users to access the latest, potentially unstable, features of the Rust language. This is a prerequisite for experimenting with features behind feature flags.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix.md#_snippet_14\n\nLANGUAGE: Shell\nCODE:\n```\n$ rustup toolchain install nightly\n```\n\n----------------------------------------\n\nTITLE: Cargo Run and Output\nDESCRIPTION: This snippet shows the output of the `cargo run` command, including the compilation process and program execution output.  It demonstrates the lifecycle of `CustomSmartPointer` instances and their associated `drop` implementations.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch15-smart-pointers/listing-15-14/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n   Compiling drop-example v0.1.0 (file:///projects/drop-example)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.60s\n     Running `target/debug/drop-example`\nCustomSmartPointers created.\nDropping CustomSmartPointer with data `other stuff`!\nDropping CustomSmartPointer with data `my stuff`!\n```\n\n----------------------------------------\n\nTITLE: Ignoring Tuple Elements with `..` in Rust\nDESCRIPTION: This snippet shows how to use the `..` syntax to ignore elements in a tuple while matching specific elements.  The `..` will match and ignore everything in the middle, but it must be unambiguous.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_29\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, .., last) => {\n            println!(\"Some numbers: {first}, {last}\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Rust program with Cargo\nDESCRIPTION: This command compiles and executes the Rust program located in the current directory. It assumes a 'Cargo.toml' file is present, defining the project. The output shows the compilation process, the execution of the program, and the resulting panic message.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch09-error-handling/no-listing-01-panic/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n Compiling panic v0.1.0 (file:///projects/panic)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.25s\n   Running `target/debug/panic`\n\nthread 'main' panicked at src/main.rs:2:5:\ncrash and burn\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n```\n\n----------------------------------------\n\nTITLE: Rust Missing Lifetime Specifier Error\nDESCRIPTION: This error message indicates a missing lifetime specifier in the `search` function signature.  The function takes string slices (`&str`) as input and returns a `Vec` of string slices. The compiler cannot determine the lifetime relationship between the input and output slices, requiring an explicit lifetime annotation.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch12-an-io-project/output-only-02-missing-lifetimes/output.txt#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nerror[E0106]: missing lifetime specifier\n  --> src/lib.rs:28:51\n   |\n28 | pub fn search(query: &str, contents: &str) -> Vec<&str> {\n   |                      ----            ----         ^ expected named lifetime parameter\n   |\n   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`\nhelp: consider introducing a named lifetime parameter\n   |\n28 | pub fn search<'a>(query: &'a str, contents: &'a str) -> Vec<&'a str> {\n   |              ++++         ++                 ++              ++\n\nFor more information about this error, try `rustc --explain E0106`.\nerror: could not compile `minigrep` (lib) due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Rust Mutable Borrow Error Compilation\nDESCRIPTION: This code snippet demonstrates a Rust compilation error (E0499) that arises from attempting to mutably borrow the same slice (`values`) twice within the `split_at_mut` function. The error message points out that the second mutable borrow overlaps with the first, violating Rust's borrowing rules. The suggestion to use `.split_at_mut(position)` is provided as a solution to obtain two non-overlapping sub-slices.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch20-advanced-features/listing-20-05/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nerror[E0499]: cannot borrow `*values` as mutable more than once at a time\n --> src/main.rs:6:31\n  |\n1 | fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {\n  |                         - let's call the lifetime of this reference `'1`\n...\n6 |     (&mut values[..mid], &mut values[mid..])\n  |     --------------------------^^^^^^--------\n  |     |     |                   |\n  |     |     |                   second mutable borrow occurs here\n  |     |     first mutable borrow occurs here\n  |     returning this value requires that `*values` is borrowed for `'1`\n  |\n  = help: use `.split_at_mut(position)` to obtain two mutable non-overlapping sub-slices\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `unsafe-example` (bin \"unsafe-example\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Disambiguating Method Calls by Trait and Type\nDESCRIPTION: This code snippet demonstrates how to disambiguate a method call by naming both the trait and the type in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_75\n\nLANGUAGE: Rust\nCODE:\n```\n<type as trait>::method(...)\n```\n\n----------------------------------------\n\nTITLE: Specifying Crate Versions in Cargo.toml\nDESCRIPTION: This snippet shows how to specify a particular crate version in the `Cargo.toml` file.  In this case, the `rand` crate is specified with version \"0.9.0\". This directs Cargo to update to this specific version or a compatible version within the 0.9.x series when `cargo build` or `cargo update` is run.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter02.md#_snippet_9\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nrand = \"0.9.0\"\n```\n\n----------------------------------------\n\nTITLE: Aliasing a Type with `as` in Rust\nDESCRIPTION: This code demonstrates how to use the `as` keyword to create an alias for a type when bringing it into scope with `use`. This is useful when multiple types with the same name are used in the same scope.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt::Result;\nuse std::io::Result as IoResult;\n\nfn function1() -> Result {\n    // --snip--\n}\n\nfn function2() -> IoResult<()> {\n    // --snip--\n}\n```\n\n----------------------------------------\n\nTITLE: Running Cargo Project\nDESCRIPTION: This command compiles and executes the Rust project. It assumes that you are in the project directory (where the `Cargo.toml` file is located). The output shows the compilation process and the execution of the resulting binary, in this case printing the area of a rectangle.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch05-using-structs-to-structure-related-data/listing-05-08/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling rectangles v0.1.0 (file:///projects/rectangles)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.42s\n   Running `target/debug/rectangles`\nThe area of the rectangle is 1500 square pixels.\n```\n\n----------------------------------------\n\nTITLE: Mutable Borrow Error in Rust\nDESCRIPTION: This code snippet demonstrates a compile-time error in Rust when attempting to create a mutable reference to an immutable variable. The compiler prevents this to enforce Rust's borrowing rules.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_18\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    let x = 5;\n    let y = &mut x;\n}\n```\n\n----------------------------------------\n\nTITLE: Statement/Item Terminator Operator Rust\nDESCRIPTION: This operator is used to terminate statements and items in Rust code. It signifies the end of a unit of code, such as an expression or declaration. This operator cannot be overloaded.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_35\n\nLANGUAGE: Rust\nCODE:\n```\n`expr;`\n```\n\n----------------------------------------\n\nTITLE: Looping Through Collection with While Rust\nDESCRIPTION: This snippet shows how to iterate through an array using a `while` loop in Rust. An index variable is used to access each element of the array until the index is no longer less than the array's length.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_36\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let a = [10, 20, 30, 40, 50];\n    let mut index = 0;\n\n    while index < 5 {\n        println!(\"the value is: {}\", a[index]);\n\n        index += 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error\nDESCRIPTION: This snippet shows a Rust compilation error indicating that a type `MyBox<{integer}>` cannot be dereferenced. The error occurs on line 14 of `src/main.rs`.  The `cargo run` command triggers the compilation process, resulting in this error.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch15-smart-pointers/listing-15-09/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n Compiling deref-example v0.1.0 (file:///projects/deref-example)\nerror[E0614]: type `MyBox<{integer}>` cannot be dereferenced\n  --> src/main.rs:14:19\n   |\n14 |     assert_eq!(5, *y);\n   |                   ^^\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `deref-example` (bin \"deref-example\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Cargo new hello_macro_derive --lib\nDESCRIPTION: Creates a new library crate named `hello_macro_derive` using cargo. This crate will contain the procedural macro.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-05-macros.md#_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n$ cargo new hello_macro_derive --lib\n```\n\n----------------------------------------\n\nTITLE: Cargo Build Command\nDESCRIPTION: This command initiates the compilation process for the Rust project using the Cargo build tool. It compiles the source code and reports any errors or warnings encountered during the compilation process.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch07-managing-growing-projects/listing-07-03/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo build\n```\n\n----------------------------------------\n\nTITLE: Declaring a Public Module in Rust\nDESCRIPTION: This snippet demonstrates how to declare a public module named `hosting` within the `front_of_house` module using the `pub` keyword. This allows parent modules to access the `hosting` module itself, but not necessarily its contents. The `add_to_waitlist` function is private within the `hosting` module.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter07.md#_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\nmod front_of_house {\n    pub mod hosting {\n        fn add_to_waitlist() {}\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Passing the receiver to each Worker\nDESCRIPTION: This code attempts to pass the receiver of the channel to each `Worker`. This will not compile, as the channel implementation in Rust is multiple producer, single consumer.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-02-multithreaded.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\nuse std::sync::mpsc;\n\npub struct ThreadPool {\n    workers: Vec<Worker>,\n    sender: mpsc::Sender<Job>,\n}\n\ntype Job = Box<dyn FnOnce() + Send + 'static>;\n\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, receiver));\n        }\n\n        ThreadPool {\n            workers,\n            sender,\n        }\n    }\n\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static\n    {\n\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: thread::JoinHandle<()>\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: mpsc::Receiver<Job>) -> Worker {\n        let thread = thread::spawn(|| {\n            receiver;\n        });\n\n        Worker {\n            id,\n            thread,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Greater Than Comparison Operator Rust\nDESCRIPTION: This operator performs a greater than comparison. It returns `true` if the left operand is greater than the right operand, and `false` otherwise. The `PartialOrd` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_44\n\nLANGUAGE: Rust\nCODE:\n```\n`expr > expr`\n```\n\n----------------------------------------\n\nTITLE: Looping and Polling a Future in Rust\nDESCRIPTION: This example extends the previous one by adding a loop to repeatedly poll the future until it becomes ready. However, it is a simplified example and doesn't account for how the async runtime handles the `Pending` state.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-05-traits-for-async.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet mut page_title_fut = page_title(url);\nloop {\n    match page_title_fut.poll() {\n        Ready(value) => match page_title {\n            Some(title) => println!(\"The title for {url} was {title}\"),\n            None => println!(\"{url} had no title\"),\n        }\n        Pending => {\n            // continue\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing ThreadPool with Worker Instances - Rust\nDESCRIPTION: This code snippet demonstrates initializing a `ThreadPool` with a vector of `Worker` instances. It creates a `Worker` struct, spawns a thread for each worker, and stores the worker in a vector. The `Worker` struct holds an id and a `JoinHandle<()>`. It is a private implementation detail of the `ThreadPool`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nuse std::thread;\n\npub struct ThreadPool {\n    workers: Vec<Worker>,\n}\n\nimpl ThreadPool {\n    // --snip--\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id));\n        }\n\n        ThreadPool { workers }\n    }\n    // --snip--\n}\n\nstruct Worker {\n    id: usize,\n    thread: thread::JoinHandle<()>,\n}\n\nimpl Worker {\n    fn new(id: usize) -> Worker {\n        let thread = thread::spawn(|| {});\n\n        Worker { id, thread }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Modified Rust Code After Applying cargo fix\nDESCRIPTION: This code snippet shows the result of running `cargo fix` on the previous example. The variable `i` has been renamed to `_i`, resolving the unused variable warning. This demonstrates how `rustfix` can automatically apply suggested fixes.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix_d.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nfn do_something() {}\n\nfn main() {\n    for _i in 0..100 {\n        do_something();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building Rust Minigrep Project\nDESCRIPTION: This command attempts to build a Rust project named 'minigrep' using the cargo build command. This command compiles the source code.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch12-an-io-project/output-only-02-missing-lifetimes/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo build\n```\n\n----------------------------------------\n\nTITLE: Pattern Binding Operator Rust\nDESCRIPTION: This operator is used in pattern matching to bind a value to a name while also matching the pattern. This operator cannot be overloaded.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_48\n\nLANGUAGE: Rust\nCODE:\n```\n`ident @ pat`\n```\n\n----------------------------------------\n\nTITLE: Running a Cargo Project\nDESCRIPTION: This command compiles and executes a Rust project using Cargo. It shows the compilation output, including any warnings or errors, and then runs the compiled executable.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch13-functional-features/listing-13-14/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n```\n\n----------------------------------------\n\nTITLE: Bitwise Exclusive OR Operator Rust\nDESCRIPTION: This operator performs a bitwise exclusive OR (XOR) operation. It returns a new value where each bit is 1 only if the corresponding bits in the operands are different. The `BitXor` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_49\n\nLANGUAGE: Rust\nCODE:\n```\n`expr ^ expr`\n```\n\n----------------------------------------\n\nTITLE: Running a Rust project with Cargo\nDESCRIPTION: This snippet shows the command used to run a Rust project using Cargo. It also displays the output of the compilation and execution process, including a panic message indicating that not enough arguments were provided to the program.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch12-an-io-project/listing-12-08/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep`\n\nthread 'main' panicked at src/main.rs:26:13:\nnot enough arguments\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n```\n\n----------------------------------------\n\nTITLE: Rust Bitwise OR and Assignment Operator Example\nDESCRIPTION: Demonstrates the bitwise OR and assignment operator (`|=`) in Rust. It performs a bitwise OR operation between a variable and an expression and assigns the result to the variable.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_53\n\nLANGUAGE: Rust\nCODE:\n```\nvar |= expr\n```\n\n----------------------------------------\n\nTITLE: Listing Installed Rust Toolchains\nDESCRIPTION: This command lists all installed Rust toolchains using `rustup`. It displays the available stable, beta, and nightly versions, indicating the default toolchain. The output helps users verify which versions of Rust are installed and active on their system.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix.md#_snippet_15\n\nLANGUAGE: Shell\nCODE:\n```\n> rustup toolchain list\nstable-x86_64-pc-windows-msvc (default)\nbeta-x86_64-pc-windows-msvc\nnightly-x86_64-pc-windows-msvc\n```\n\n----------------------------------------\n\nTITLE: Left-Shift Operator Rust\nDESCRIPTION: This operator performs a left-shift operation. It shifts the bits of the left operand to the left by the number of positions specified by the right operand. The `Shl` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_37\n\nLANGUAGE: Rust\nCODE:\n```\n`expr << expr`\n```\n\n----------------------------------------\n\nTITLE: Out-of-Bounds Vector Access - Rust\nDESCRIPTION: This snippet attempts to access an element outside the bounds of a vector, which will cause a panic. It illustrates a common scenario where Rust's safety mechanisms prevent undefined behavior.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter09.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    let v = vec![1, 2, 3];\n\n    v[99];\n}\n```\n\n----------------------------------------\n\nTITLE: Greater Than or Equal To Comparison Operator Rust\nDESCRIPTION: This operator performs a greater than or equal to comparison. It returns `true` if the left operand is greater than or equal to the right operand, and `false` otherwise. The `PartialOrd` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_45\n\nLANGUAGE: Rust\nCODE:\n```\n`expr >= expr`\n```\n\n----------------------------------------\n\nTITLE: Valid Reference Example\nDESCRIPTION: This code shows a valid reference because the data (x) has a longer lifetime ('b) than the reference (r) which has lifetime ('a). This ensures that the reference in r will always be valid while x is valid.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_36\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let x = 5;            // ----------+-- 'b\n                          //           |\n    let r = &x;           // --+-- 'a  |\n                          //   |       |\n    println!(\"r: {r}\");   //   |       |\n                          // --+       |\n}                         // ----------+\n```\n\n----------------------------------------\n\nTITLE: Mutating a String in Rust\nDESCRIPTION: This snippet demonstrates how to mutate a `String` using the `push_str` method. `String` can be mutated, unlike string literals, because it owns the allocated memory on the heap.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nlet mut s = String::from(\"hello\");\n\ns.push_str(\", world!\"); // push_str() appends a literal to a String\n\nprintln!(\"{s}\");\n```\n\n----------------------------------------\n\nTITLE: Merging Streams (Attempt - Does Not Compile)\nDESCRIPTION: This snippet shows an attempt to merge two streams, `messages` (of type `Timeout<impl Stream<Item = String>>`) and `intervals` (of type `impl Stream<Item = u32>`), using the `merge` method. However, it doesn't compile because the streams have different types. The code demonstrates the initial setup for stream merging before type conversion is applied.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-04-streams.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nasync fn main() {\n    let messages = get_messages();\n    let intervals = get_intervals();\n\n    let merged = messages.merge(intervals);\n\n    pin_mut!(merged);\n\n    while let Some(msg) = merged.next().await {\n        println!(\"Got: {}\", msg);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Rust Project with Cargo\nDESCRIPTION: This command compiles and executes the main binary of a Rust project. It first compiles the 'branches' project, showing compilation progress and any dependencies. After successful compilation, it runs the generated executable located in the target/debug directory. The output 'condition was true' indicates the execution of the compiled code.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch03-common-programming-concepts/no-listing-26-if-true/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling branches v0.1.0 (file:///projects/branches)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s\n   Running `target/debug/branches`\ncondition was true\n```\n\n----------------------------------------\n\nTITLE: Initial Drop Implementation for ThreadPool in Rust\nDESCRIPTION: This code snippet demonstrates an initial attempt to implement the `Drop` trait for a `ThreadPool` in Rust. It iterates through the `workers` vector and attempts to `join` each thread.  It uses `&mut self.workers` to be able to mutate each worker. The `join` call consumes the `worker.thread` which leads to a compiler error because it's behind a mutable reference.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter21.md#_snippet_26\n\nLANGUAGE: rust\nCODE:\n```\nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        for worker in &mut self.workers {\n            println!(\"Shutting down worker {}\", worker.id);\n\n            worker.thread.join().unwrap();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Single-Line Comment in Rust\nDESCRIPTION: This example shows a basic single-line comment in Rust. The comment starts with two forward slashes `//` and continues until the end of the line. The compiler ignores comments.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter03.md#_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\n// hello, world\n```\n\n----------------------------------------\n\nTITLE: Ignoring Function Parameter with Underscore Rust\nDESCRIPTION: This code snippet shows how to ignore a function parameter using `_`. The `foo` function takes two `i32` arguments but only uses the second one (`y`).  Using `_` for the first parameter suppresses the compiler warning about an unused parameter.  The function prints a message that includes the value of `y`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\nfn foo(_: i32, y: i32) {\n    println!(\"This code only uses the y parameter: {y}\");\n}\n\nfn main() {\n    foo(3, 4);\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning, Navigating, and Building an Existing Rust Project\nDESCRIPTION: This sequence of commands demonstrates how to clone a Rust project from a Git repository, navigate to the project directory, and build it using Cargo.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_28\n\nLANGUAGE: Rust\nCODE:\n```\n$ git clone example.org/someproject\n$ cd someproject\n$ cargo build\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mutable Borrow of Immutable Value - Rust\nDESCRIPTION: This code snippet illustrates an attempt to borrow an immutable value mutably, which is disallowed by Rust's borrowing rules, resulting in a compile-time error. This example sets the stage for introducing `RefCell<T>` as a solution for interior mutability.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-05-interior-mutability.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch15-smart-pointers/no-listing-01-cant-borrow-immutable-as-mutable/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Field Access Operator Rust\nDESCRIPTION: This operator is used to access a field of a struct, enum, or union. It retrieves the value of the specified field. This operator cannot be overloaded.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_22\n\nLANGUAGE: Rust\nCODE:\n```\n`expr.ident`\n```\n\n----------------------------------------\n\nTITLE: Using the Never Type\nDESCRIPTION: This code snippet demonstrates the 'never' type (!) in Rust. It represents the type of expressions that never return, such as diverging functions.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_65\n\nLANGUAGE: Rust\nCODE:\n```\n!\n```\n\n----------------------------------------\n\nTITLE: Cons List Implementation with Box<T> (Failing Example) Rust\nDESCRIPTION: This code snippet demonstrates an attempt to create a cons list where multiple lists share ownership of a third list using `Box<T>`. This approach fails because `Box<T>` enforces exclusive ownership, leading to a move error when trying to use the original list after it has been moved into another. The code defines the `List` enum with `Cons` and `Nil` variants, and the `main` function tries to create three lists, `a`, `b`, and `c`, where `b` and `c` are intended to share `a`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nenum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));\n    let b = Cons(3, Box::new(a));\n    let c = Cons(4, Box::new(a));\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Files in a Directory (Linux/macOS/PowerShell)\nDESCRIPTION: This command lists the files in the current directory using the `ls` command. This is used to verify the existence of the compiled executable.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\n$ ls\nmain  main.rs\n```\n\n----------------------------------------\n\nTITLE: Executing Cargo Tests\nDESCRIPTION: This snippet shows the execution of cargo tests within a Rust project named 'rectangle'. It compiles the crate, runs the unit tests, and then runs the doc tests, showing the results of each test suite. The output indicates that all tests passed successfully.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch11-writing-automated-tests/listing-11-06/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test\n   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)\n\nrunning 1 test\ntest tests::larger_can_hold_smaller ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests rectangle\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n```\n\n----------------------------------------\n\nTITLE: Using Inner Attribute\nDESCRIPTION: This code snippet shows how to use an inner attribute in Rust. Inner attributes apply to the item they are contained within (e.g., a module or function).\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_91\n\nLANGUAGE: Rust\nCODE:\n```\n#![meta]\n```\n\n----------------------------------------\n\nTITLE: Function/Closure Return Type Operator Rust\nDESCRIPTION: This operator is used to specify the return type of a function or closure. It indicates the type of value that the function or closure will return after execution. This operator cannot be overloaded.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_21\n\nLANGUAGE: Rust\nCODE:\n```\n`fn(...) -> type`\n```\n\nLANGUAGE: Rust\nCODE:\n```\n<code>&vert;...&vert; -> type</code>\n```\n\n----------------------------------------\n\nTITLE: Incorrect Worker Implementation Using `while let` (Rust)\nDESCRIPTION: This snippet shows an alternative, but incorrect, implementation of `Worker::new` using `while let`. While it compiles and runs, it doesn't achieve the desired threading behavior because the mutex lock is held for the entire duration of the `job()` execution.  This prevents other worker instances from receiving jobs until the current job is finished, essentially serializing the job processing.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch21-02-multithreaded.md#_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        let thread = thread::spawn(move || {\n            while let Ok(job) = receiver.lock().unwrap().recv() {\n                println!(\"Worker {} got a job; executing.\", id);\n\n                job();\n            }\n        });\n\n        Worker {\n            id,\n            thread,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a slice from an arbitrary memory location in Rust\nDESCRIPTION: This code snippet demonstrates creating a slice from an arbitrary memory location using `slice::from_raw_parts_mut`.  It's highly unsafe and likely to cause a crash because the memory location might not be valid or contain valid `i32` values.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch20-01-unsafe-rust.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse std::slice;\n\nfn main() {\n    let address = 0x012345usize;\n    let r = address as *mut i32;\n\n    let values: &[i32] = unsafe {\n        slice::from_raw_parts_mut(r, 10000)\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Cargo Test Command\nDESCRIPTION: This snippet shows the command used to run tests in a Rust project.  It demonstrates the command 'cargo test' being executed and the subsequent output related to compilation and test execution.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch12-an-io-project/listing-12-16/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo test\n```\n\n----------------------------------------\n\nTITLE: Defining a Raw Byte String Literal\nDESCRIPTION: This code snippet illustrates the definition of a raw byte string literal in Rust. It's a combination of raw and byte string literals where escape characters are not processed, and the string represents a byte array.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_61\n\nLANGUAGE: Rust\nCODE:\n```\nbr\"...\"\n```\n\nLANGUAGE: Rust\nCODE:\n```\nbr#\"...\"#\n```\n\nLANGUAGE: Rust\nCODE:\n```\nbr##\"...\"##\n```\n\n----------------------------------------\n\nTITLE: Defining Cargo Workspace\nDESCRIPTION: Defines the workspace configuration in the top-level Cargo.toml file.  It sets the resolver version and doesn't contain a [package] section. This configuration enables adding members to the workspace.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_13\n\nLANGUAGE: TOML\nCODE:\n```\n[workspace]\nresolver = \"2\"\n```\n\n----------------------------------------\n\nTITLE: Match Arm Syntax Operator Rust\nDESCRIPTION: This operator is part of the syntax for match arms. It separates the pattern to match from the expression to execute if the pattern matches. This operator cannot be overloaded.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_43\n\nLANGUAGE: Rust\nCODE:\n```\n`pat => expr`\n```\n\n----------------------------------------\n\nTITLE: Building a Rust Project with Cargo\nDESCRIPTION: This command builds a Rust project using Cargo. It compiles the source code and creates an executable file in the `target/debug` directory. The compilation includes debug information and is unoptimized by default.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_23\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo build\n   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs\n```\n\n----------------------------------------\n\nTITLE: Running Clippy on a Cargo project\nDESCRIPTION: This command runs Clippy's lints on the current Cargo project. Clippy analyzes the code for common mistakes and suggests improvements.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix.md#_snippet_11\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo clippy\n```\n\n----------------------------------------\n\nTITLE: Installing ripgrep with cargo install\nDESCRIPTION: This command installs the `ripgrep` binary crate using `cargo install`. It fetches the crate from crates.io, compiles it, and installs the executable to the Cargo's bin directory.  The output shows the download and installation process.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-04-installing-binaries.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo install ripgrep\n    Updating crates.io index\n  Downloaded ripgrep v14.1.1\n  Downloaded 1 crate (213.6 KB) in 0.40s\n  Installing ripgrep v14.1.1\n--snip--\n   Compiling grep v0.3.2\n    Finished `release` profile [optimized + debuginfo] target(s) in 6.73s\n  Installing ~/.cargo/bin/rg\n   Installed package `ripgrep v14.1.1` (executable `rg`)\n```\n\n----------------------------------------\n\nTITLE: Concatenating Multiple Strings with + Operator\nDESCRIPTION: This snippet demonstrates concatenating multiple strings using the `+` operator. This approach can become unwieldy due to the number of `+` and `&` characters.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nlet s1 = String::from(\"tic\");\nlet s2 = String::from(\"tac\");\nlet s3 = String::from(\"toe\");\n\nlet s = s1 + \"-\" + &s2 + \"-\" + &s3;\n```\n\n----------------------------------------\n\nTITLE: Creating a leaf node with a weak reference to its parent in Rust\nDESCRIPTION: This code snippet demonstrates creating a `leaf` node with a `Weak` reference to its parent, and creating a `branch` node, which will be the leaf's parent. It shows how to use `Rc::downgrade` to create a `Weak` reference from an `Rc`, and how to use `upgrade` to attempt to get a strong reference from a `Weak` reference. The output demonstrates the parent of `leaf` being initially `None`, and then becoming `Some(branch)` after the parent reference is set.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-06-reference-cycles.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell<Weak<Node>>,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n\nfn main() {\n    let leaf = Rc::new(\n        Node {\n            value: 3,\n            parent: RefCell::new(Weak::new()),\n            children: RefCell::new(vec![]),\n        }\n    );\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n\n    let branch = Rc::new(\n        Node {\n            value: 5,\n            parent: RefCell::new(Weak::new()),\n            children: RefCell::new(vec![Rc::clone(&leaf)]),\n        }\n    );\n\n    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n    println!(\"leaf = {:?}\", leaf);\n}\n\n```\n\n----------------------------------------\n\nTITLE: String Use After Move Error in Rust\nDESCRIPTION: This example demonstrates the error that occurs when trying to use a `String` after it has been moved to another variable. Rust's borrow checker detects that `s1` is no longer valid and prevents its use, ensuring memory safety.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\nlet s1 = String::from(\"hello\");\nlet s2 = s1;\n\nprintln!(\"{s1}, world!\");\n```\n\n----------------------------------------\n\nTITLE: Cargo Run Command and Output\nDESCRIPTION: Shows the execution of a Rust project using `cargo run`. The output displays the compilation status, the time taken for compilation, and the program's output, which showcases the creation and dropping of a `CustomSmartPointer`.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch15-smart-pointers/listing-15-16/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n   Compiling drop-example v0.1.0 (file:///projects/drop-example)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s\n     Running `target/debug/drop-example`\nCustomSmartPointer created.\nDropping CustomSmartPointer with data `some data`!\nCustomSmartPointer dropped before the end of main.\n```\n\n----------------------------------------\n\nTITLE: Struct Field Initializer Operator Rust\nDESCRIPTION: This operator is used to initialize fields in struct literals.  It associates a field name with its initial value. This operator cannot be overloaded.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_33\n\nLANGUAGE: Rust\nCODE:\n```\n`ident: expr`\n```\n\n----------------------------------------\n\nTITLE: Variable Assignment with `let` in Rust\nDESCRIPTION: This snippet demonstrates a simple variable assignment using the `let` statement in Rust. The variable `x` is bound to the integer value `5`. This showcases the basic use of patterns for binding values to variables.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 5;\n```\n\n----------------------------------------\n\nTITLE: Config::build Function (Initial Implementation) in Rust\nDESCRIPTION: This is the initial implementation of the `Config::build` function that takes a slice of `String` values and creates a `Config` struct by cloning the values from the slice. This version is inefficient due to the unnecessary `clone` calls.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter13.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nimpl Config {\n    pub fn build(args: &[String]) -> Result<Config, &'static str> {\n        if args.len() < 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        let ignore_case = env::var(\"IGNORE_CASE\").is_ok();\n\n        Ok(Config {\n            query,\n            file_path,\n            ignore_case,\n        })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Debugging Arguments in Rust\nDESCRIPTION: This snippet shows how the arguments are captured within the Rust program.  It displays the arguments passed to the compiled binary, which includes the executable path and the provided command-line arguments.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch12-an-io-project/output-only-01-with-args/output.txt#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n[src/main.rs:5:5] args = [\n    \"target/debug/minigrep\",\n    \"needle\",\n    \"haystack\",\n]\n```\n\n----------------------------------------\n\nTITLE: Graphviz Dot Conversion to SVG\nDESCRIPTION: Converts a Graphviz `.dot` file into an `.svg` image. Requires Graphviz to be installed.\nSOURCE: https://github.com/rust-lang/book/blob/main/ADMIN_TASKS.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndot dot/trpl04-01.dot -Tsvg > src/img/trpl04-01.svg\n```\n\n----------------------------------------\n\nTITLE: Rust code with approximate constant\nDESCRIPTION: This Rust code snippet uses an approximation of pi. Running Clippy on this code will result in an error because it suggests using the built-in `std::f64::consts::PI` constant instead.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix.md#_snippet_12\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    let x = 3.1415;\n    let r = 8.0;\n    println!(\"the area of the circle is {}\", x * r * r);\n}\n```\n\n----------------------------------------\n\nTITLE: Unyanking a Crate Version\nDESCRIPTION: This console command demonstrates how to undo a yank and allow projects to start depending on a version again using `cargo yank --undo`. The `--vers` flag specifies the version to unyank.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-02-publishing-to-crates-io.md#_snippet_11\n\nLANGUAGE: console\nCODE:\n```\n$ cargo yank --vers 1.0.1 --undo\n    Updating crates.io index\n      Unyank guessing_game@1.0.1\n```\n\n----------------------------------------\n\nTITLE: Calling Hello Function Without Deref Coercion in Rust\nDESCRIPTION: This Rust code demonstrates how to call the `hello` function with a `MyBox<String>` value without relying on deref coercion. It requires explicitly dereferencing the `MyBox<String>` to a `String` and then taking a string slice to match the `&str` parameter of the `hello` function. This illustrates the complexity that Deref coercion simplifies.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let m = MyBox::new(String::from(\"Rust\"));\n    hello(&(*m)[..]);\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error: Mismatched Types\nDESCRIPTION: This snippet demonstrates a Rust compilation error (E0308) that occurs when a function's return type does not match the value returned by the function body. The example function `plus_one` is defined to return an `i32`, but the expression `x + 1;` includes a semicolon, which suppresses the return value, causing the function to implicitly return `()`. Removing the semicolon fixes the error.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch03-common-programming-concepts/no-listing-23-statements-dont-return-values/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn plus_one(x: i32) -> i32 {\n    x + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Changing the test name\nDESCRIPTION: This code snippet shows how to rename a test function from `it_works` to `exploration`. It demonstrates the flexibility in naming test functions while adhering to the `#[test]` attribute requirement.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch11-01-writing-tests.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-01-changing-test-name/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Marking a Function as a Unit Test in Rust\nDESCRIPTION: This code snippet shows how to use the `#[test]` attribute in Rust to mark a function as a unit test. The Rust test runner will automatically discover and execute functions marked with this attribute. This attribute signals to the compiler that this function should be compiled and executed when running tests.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/attributes.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// A function marked as a unit test\n#[test]\nfn test_foo() {\n    /* ... */\n}\n```\n\n----------------------------------------\n\nTITLE: Generate Preview Script Execution\nDESCRIPTION: Executes the `tools/generate-preview.sh` script to generate a preview of the book for publication on GitHub Pages.\nSOURCE: https://github.com/rust-lang/book/blob/main/ADMIN_TASKS.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ntools/generate-preview.sh\n```\n\n----------------------------------------\n\nTITLE: Rust Multi-line Comment\nDESCRIPTION: This Rust code snippet demonstrates how to write a multi-line comment. Each line of the comment must start with '//'.  This allows for more detailed explanations within the code.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/comments.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// So were doing something complicated here, long enough that we need\n// multiple lines of comments to do it! Whew! Hopefully, this comment will\n// explain whats going on.\n```\n\n----------------------------------------\n\nTITLE: Variable Binding in Rust\nDESCRIPTION: This snippet demonstrates how to bind a value to a variable name using the `let` keyword in Rust. The `foo` variable is bound to the value 5.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/variable-bindings.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet foo = 5;\n```\n\n----------------------------------------\n\nTITLE: Ignoring Multiple Tuple Parts with `_` in Rust\nDESCRIPTION: This snippet ignores the second and fourth values in a tuple using the `_` pattern. It demonstrates how to selectively extract and use specific values from a tuple while ignoring others. Dependencies: None. Inputs: A tuple of five i32 values. Outputs: Prints some of the numbers from the tuple.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch19-03-pattern-syntax.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, _, third, _, fifth) => {\n            println!(\"Some numbers: {}, {}, {}\", first, third, fifth)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Raw Identifier Function Definition in Rust\nDESCRIPTION: This code defines a function named `match` using the raw identifier syntax `r#match` to avoid conflict with the `match` keyword. It also includes a `main` function demonstrating how to call the raw identifier function.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn r#match(needle: &str, haystack: &str) -> bool {\n    haystack.contains(needle)\n}\n\nfn main() {\n    assert!(r#match(\"foo\", \"foobar\"));\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a stream from an iterator\nDESCRIPTION: This code snippet attempts to create a stream from an iterator and print its values using the `next` method. However, it results in a compilation error because the `StreamExt` trait is not in scope, which provides the `next` method for streams. This example is provided to illustrate a common error and the need to import the `StreamExt` trait.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-04-streams.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet mut stream = trpl::stream_from_iter(array.into_iter().map(|x| x * 2));\n\n    while let Some(value) = stream.next().await {\n        println!(\"value: {}\", value);\n    }\n```\n\n----------------------------------------\n\nTITLE: Using Inner Line Doc Comment\nDESCRIPTION: This code snippet illustrates the use of an inner line doc comment in Rust. Inner line doc comments start with `//!`.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_97\n\nLANGUAGE: Rust\nCODE:\n```\n//! \n```\n\n----------------------------------------\n\nTITLE: Running a Cargo Project\nDESCRIPTION: This command compiles and executes the Rust project 'rectangles'. It uses the `cargo run` command, which first compiles the project and then runs the resulting executable. The output shows compilation messages followed by the program's output.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch13-functional-features/listing-13-07/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s\n     Running `target/debug/rectangles`\n```\n\n----------------------------------------\n\nTITLE: Opening Book in Firefox (Linux)\nDESCRIPTION: This command opens the built book in Firefox on Linux systems.\nSOURCE: https://github.com/rust-lang/book/blob/main/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ firefox book/index.html\n```\n\n----------------------------------------\n\nTITLE: Run Rust Program with Miri\nDESCRIPTION: This snippet shows how to run a Rust program using the Miri interpreter. It compiles and executes the `unsafe-example` crate using the nightly Rust toolchain and Miri.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch20-advanced-features/listing-20-11/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo +nightly miri run\n Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s\n  Running `file:///home/.rustup/toolchains/nightly/bin/cargo-miri runner target/miri/debug/unsafe-example`\nCOUNTER: 3\n```\n\n----------------------------------------\n\nTITLE: Ambiguous `..` Usage in Tuple Matching (Error) in Rust\nDESCRIPTION: This code illustrates an example of ambiguous usage of the `..` syntax in tuple matching, which results in a compilation error. The Rust compiler cannot determine which values should be ignored when `..` is used multiple times within a tuple pattern.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_30\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (.., second, ..) => {\n            println!(\"Some numbers: {second}\")\n        },\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Hello World Program\nDESCRIPTION: A basic Rust program that prints the message \"Hello, world!\" to the console. It defines a main function that uses the println! macro to output the string.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_10\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Running Cargo Project\nDESCRIPTION: Executes the Rust project using `cargo run`. This command compiles the project in debug mode and then executes the resulting binary. The compilation output and debugging information are shown.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch12-an-io-project/listing-12-01/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n Compiling minigrep v0.1.0 (file:///projects/minigrep)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s\n   Running `target/debug/minigrep`\n[src/main.rs:5:5] args = [\n    \"target/debug/minigrep\",\n]\n```\n\n----------------------------------------\n\nTITLE: Formatting a Cargo project with rustfmt\nDESCRIPTION: This command reformats all Rust code in the current Cargo project using `rustfmt`. This tool helps ensure code style consistency across a project and prevents style-related debates.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo fmt\n```\n\n----------------------------------------\n\nTITLE: Infinite Loop using Loop in Rust\nDESCRIPTION: This code demonstrates an infinite loop using the `loop` keyword in Rust. It repeatedly prints \"again!\" to the console until explicitly stopped.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/loops.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nloop {\n    println!(\"again!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Test smaller_cannot_hold_larger using assert! in Rust\nDESCRIPTION: This test case checks that a smaller rectangle cannot hold a larger one. It creates `larger` and `smaller` `Rectangle` instances and asserts that the `can_hold` method returns `false` when called on the `smaller` rectangle with the `larger` rectangle as an argument. The `!` negates the result before passing it to `assert!`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn larger_can_hold_smaller() {\n        // --snip--\n    }\n\n    #[test]\n    fn smaller_cannot_hold_larger() {\n        let larger = Rectangle {\n            width: 8,\n            height: 7,\n        };\n        let smaller = Rectangle {\n            width: 5,\n            height: 1,\n        };\n\n        assert!(!smaller.can_hold(&larger));\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using a Helper Function in Integration Test - Rust\nDESCRIPTION: This Rust code demonstrates how to use a helper function defined in a separate module within an integration test. The `mod common;` declaration imports the `common` module, allowing the `setup` function to be called within the `it_adds_two` test function.  This ensures that code can be reused across integration tests without creating a separate test target.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter11.md#_snippet_30\n\nLANGUAGE: rust\nCODE:\n```\nuse adder::add_two;\n\nmod common;\n\n#[test]\nfn it_adds_two() {\n    common::setup();\n\n    let result = add_two(2);\n    assert_eq!(result, 4);\n}\n```\n\n----------------------------------------\n\nTITLE: Simulating Slow Operations with Thread Sleep in Rust\nDESCRIPTION: This function `slow` simulates a long-running, blocking operation by pausing the current thread for a specified number of milliseconds using `std::thread::sleep`. It takes the name of the operation and the duration in milliseconds as input and prints a message when the operation is complete. This function blocks the current thread.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_26\n\nLANGUAGE: rust\nCODE:\n```\nfn slow(name: &str, ms: u64) {\n    thread::sleep(Duration::from_millis(ms));\n    println!(\"'{}' ran for {}ms\", name, ms);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Project Directory (Linux/macOS/PowerShell)\nDESCRIPTION: Creates a 'projects' directory in the home directory, navigates into it, and then creates a 'hello_world' directory within 'projects'.  Finally, it changes the current directory to 'hello_world'.  This is the standard setup for Rust projects in the book.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\n$ mkdir ~/projects\n$ cd ~/projects\n$ mkdir hello_world\n$ cd hello_world\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error Output\nDESCRIPTION: This snippet shows the output of a `cargo run` command that results in a compilation error in Rust. The error indicates that lifetime specifiers are missing for string slices used within a struct definition. The compiler suggests how to fix this by adding lifetime parameters.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n Compiling structs v0.1.0 (file:///projects/structs)\nerror[E0106]: missing lifetime specifier\n --> src/main.rs:3:15\n  |\n3 |     username: &str,\n  |               ^ expected named lifetime parameter\n  |\nhelp: consider introducing a named lifetime parameter\n  |\n1 ~ struct User<'a> {\n2 |     active: bool,\n3 ~     username: &'a str,\n  |\n\nerror[E0106]: missing lifetime specifier\n --> src/main.rs:4:12\n  |\n4 |     email: &str,\n  |            ^ expected named lifetime parameter\n  |\nhelp: consider introducing a named lifetime parameter\n  |\n1 ~ struct User<'a> {\n2 |     active: bool,\n3 |     username: &str,\n4 ~     email: &'a str,\n  |\n\nFor more information about this error, try `rustc --explain E0106`.\nerror: could not compile `structs` (bin \"structs\") due to 2 previous errors\n```\n\n----------------------------------------\n\nTITLE: Mutable Borrowing Conflict While Holding Immutable Reference\nDESCRIPTION: This code shows an example of a borrowing conflict.  It attempts to add an element to the vector using `push` (mutable borrow) while holding an immutable reference to the first element.  Because adding an element might require reallocating the vector, the immutable reference could become invalid, so the compiler prevents this scenario.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet mut v = vec![1, 2, 3, 4, 5];\n\nlet first = &v[0];\n\nv.push(6);\n\nprintln!(\"The first element is: {first}\");\n```\n\n----------------------------------------\n\nTITLE: Using Compound Type Constraint\nDESCRIPTION: This code snippet demonstrates the use of a compound type constraint (e.g., `'a + trait`, `trait + trait`) in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_89\n\nLANGUAGE: Rust\nCODE:\n```\n'a + trait\n```\n\nLANGUAGE: Rust\nCODE:\n```\ntrait + trait\n```\n\n----------------------------------------\n\nTITLE: Dereferencing a raw pointer in Rust\nDESCRIPTION: Demonstrates using the dereference operator (*) to access the value pointed to by a raw pointer (reference). The variable 'x' holds an i32 value 5. 'y' is a reference to 'x'. We use '*y' to dereference 'y' and compare it with 5.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch15-02-deref.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 5;\nlet y = &x;\n\nassert_eq!(5, x);\nassert_eq!(5, *y);\n```\n\n----------------------------------------\n\nTITLE: Setting Crate Name in Cargo.toml\nDESCRIPTION: This snippet shows how to set the name of a crate in the `Cargo.toml` file. The name must be unique on crates.io before publishing.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter14.md#_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"guessing_game\"\n```\n\n----------------------------------------\n\nTITLE: Concatenating Strings with the + Operator\nDESCRIPTION: This snippet shows how to combine two `String` values into a new `String` using the `+` operator. Note that the first `String` (`s1`) is moved and can no longer be used after the addition. A reference to the second string (`&s2`) is used because the `add` method only takes a `&str`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter08.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nlet s1 = String::from(\"Hello, \");\nlet s2 = String::from(\"world!\");\nlet s3 = s1 + &s2; // note s1 has been moved here and can no longer be used\n```\n\n----------------------------------------\n\nTITLE: Rust Lifetime Example\nDESCRIPTION: This code snippet demonstrates a basic example of lifetimes in Rust. The lifetime 'a represents the scope in which the reference 'r' is valid, while 'b' is the lifetime of the variable 'x'. The code prints the value referenced by 'r'.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/lifetimes.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{\n    let x = 5;            // -----+-- 'b\n                          //      |\n    let r = &x;           // --+--+-- 'a\n                          //   |  |\n    println!(\"r: {r}\");   //   |  |\n                          // --+  |\n}                         // -----+\n\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running Rust Code (Linux/macOS)\nDESCRIPTION: Compiles the main.rs file using the rustc compiler and then executes the compiled binary. The ./main command runs the executable in the current directory.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_11\n\nLANGUAGE: Shell\nCODE:\n```\n$ rustc main.rs\n$ ./main\n```\n\n----------------------------------------\n\nTITLE: Updating Rust with rustup\nDESCRIPTION: Updates the installed Rust toolchain to the latest stable version using the `rustup` command-line tool. This ensures the user has the most recent features, bug fixes, and security patches.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-01-installation.md#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\n$ rustup update\n```\n\n----------------------------------------\n\nTITLE: Calculating Area with Tuples in Rust\nDESCRIPTION: This snippet demonstrates calculating the area of a rectangle in Rust using a tuple to group the width and height. The `area` function now accepts a single tuple containing the dimensions.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter05.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let rect1 = (30, 50);\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        area(rect1)\n    );\n}\n\nfn area(dimensions: (u32, u32)) -> u32 {\n    dimensions.0 * dimensions.1\n}\n```\n\n----------------------------------------\n\nTITLE: Match on Option<u8> Rust\nDESCRIPTION: Demonstrates matching on an `Option<u8>` using the `match` keyword. It prints the maximum value if it's a `Some` variant and does nothing if it's `None`. The `_ => ()` is boilerplate.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_23\n\nLANGUAGE: Rust\nCODE:\n```\nlet config_max = Some(3u8);\n    match config_max {\n        Some(max) => println!(\"The maximum is configured to be {max}\"),\n        _ => (),\n    }\n```\n\n----------------------------------------\n\nTITLE: Explicit Lifetime Annotations in Rust\nDESCRIPTION: Demonstrates how the `first_word` function would be written with explicit lifetime annotations, showcasing the syntax used before lifetime elision rules were implemented. This example helps to understand the evolution of Rust's lifetime handling.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_47\n\nLANGUAGE: rust\nCODE:\n```\nfn first_word<'a>(s: &'a str) -> &'a str {\n```\n\n----------------------------------------\n\nTITLE: Using the minigrep Library Crate in src/main.rs in Rust\nDESCRIPTION: This snippet demonstrates how to use the `minigrep` library crate in `src/main.rs` after refactoring. It imports the `Config` type from the library using `use minigrep::Config` and calls the `run` function using the crate name as a prefix (`minigrep::run`).\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-03-improving-error-handling-and-modularity.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-14/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Defining a Recursive Enum (Cons List) in Rust\nDESCRIPTION: This code snippet defines an enum `List` representing a cons list. It showcases the initial attempt to define a recursive enum, which results in a compilation error due to the infinite size of the `List` type. The `Cons` variant holds an `i32` value and another `List` value, leading to infinite recursion.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter15.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nenum List {\n    Cons(i32, List),\n    Nil,\n}\n```\n\n----------------------------------------\n\nTITLE: No Starch Markdown Generation Script Execution\nDESCRIPTION: Executes the `./tools/nostarch.sh` script to produce new markdown files specifically for No Starch Press.\nSOURCE: https://github.com/rust-lang/book/blob/main/ADMIN_TASKS.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n./tools/nostarch.sh\n```\n\n----------------------------------------\n\nTITLE: Generate a built book after the change\nDESCRIPTION: Generates a built book after applying changes to test them.\nSOURCE: https://github.com/rust-lang/book/blob/main/ADMIN_TASKS.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nmdbook build -d tmp/book-after\n```\n\n----------------------------------------\n\nTITLE: Point Struct with Single Generic Type (Error) Rust\nDESCRIPTION: This example demonstrates an error when trying to create a `Point` struct with `x` and `y` values of different types when using a single generic type parameter.  This code will not compile because `x` and `y` are defined to be of the same type `T`.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter10.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nfn main() {\n    let wont_work = Point { x: 5, y: 4.0 };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a User Struct in Rust\nDESCRIPTION: This code snippet defines a `User` struct in Rust. The struct has four fields: `username` (String), `email` (String), `sign_in_count` (u64), and `active` (bool). This struct is used to group related information about a user.\nSOURCE: https://github.com/rust-lang/book/blob/main/redirects/structs.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct User {\n    username: String,\n    email: String,\n    sign_in_count: u64,\n    active: bool,\n}\n```\n\n----------------------------------------\n\nTITLE: Running an Executable on Linux/macOS/PowerShell\nDESCRIPTION: This command executes the compiled binary on Linux, macOS, or PowerShell on Windows.  It runs the `main` executable.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_18\n\nLANGUAGE: shell\nCODE:\n```\n$ ./main # or .\\main on Windows\n```\n\n----------------------------------------\n\nTITLE: Illustrating Borrowing Rules with String Slices\nDESCRIPTION: This snippet demonstrates Rust's borrowing rules and how string slices can prevent errors. Attempting to clear the String (mutable borrow) after creating a slice (immutable borrow) results in a compile-time error because the immutable borrow must still be active when `println!` is called.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter04.md#_snippet_30\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    let mut s = String::from(\"hello world\");\n\n    let word = first_word(&s);\n\n    s.clear(); // error!\n\n    println!(\"the first word is: {word}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Unit Value in Match Expression Rust\nDESCRIPTION: This example uses the unit value `()` as the code associated with the underscore catch-all pattern. It indicates that no action should be taken for values other than 3 and 7, explicitly ignoring them.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter06.md#_snippet_22\n\nLANGUAGE: Rust\nCODE:\n```\nlet dice_roll = 9;\n    match dice_roll {\n        3 => add_fancy_hat(),\n        7 => remove_fancy_hat(),\n        _ => (),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n```\n\n----------------------------------------\n\nTITLE: Handling Errors Returned from run in main in Rust\nDESCRIPTION: This snippet showcases how to handle errors returned from the `run` function in the `main` function using `if let`.  It checks for an `Err` variant and exits the program with an error code if an error occurred. It avoids using `unwrap_or_else` because `run` returns `()` on success.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch12-03-improving-error-handling-and-modularity.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-an-io-project/no-listing-01-handling-errors-in-main/src/main.rs:here}}\n```\n\n----------------------------------------\n\nTITLE: Point with different types (invalid)\nDESCRIPTION: This code attempts to create a `Point` struct with `x` as an integer and `y` as a float, but it fails to compile because the `Point` struct is defined to have both fields of the same generic type `T`. This illustrates a limitation of using a single generic type parameter for multiple fields.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch10-01-syntax.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nfn main() {\n    let p = Point { x: 5, y: 4.0 };\n}\n```\n\n----------------------------------------\n\nTITLE: Comments Above Line in Rust\nDESCRIPTION: This snippet demonstrates the preferred style of placing comments above the lines of code they are annotating in Rust. This improves readability and code organization.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch03-04-comments.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-25-comments-above-line/src/main.rs}}\n```\n\n----------------------------------------\n\nTITLE: Opening Book in Chrome (OS X)\nDESCRIPTION: This command opens the built book in Google Chrome on macOS systems.\nSOURCE: https://github.com/rust-lang/book/blob/main/README.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ open -a \"Google Chrome\" book/index.html\n```\n\n----------------------------------------\n\nTITLE: Using `trpl::join` for Awaiting Futures in Rust\nDESCRIPTION: This snippet utilizes `trpl::join` to concurrently run two anonymous futures. It defines two async blocks, each containing a loop with a delay, and then uses `trpl::join` to wait for both to complete. The output of `trpl::join` (a tuple containing the outputs of the two futures) is ignored.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch17-02-concurrency-with-async.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse trpl::futures::FutureExt;\n\nasync fn print_number(number: u32) {\n    println!(\"hi number {} from the second task!\", number);\n}\n\nasync fn count() {\n    for i in 1..10 {\n        print_number(i).await;\n        trpl::sleep(std::time::Duration::from_millis(500)).await;\n    }\n}\n\nfn main() {\n    trpl::run(async {\n        let fut1 = async {\n            for i in 1..6 {\n                println!(\"hi number {} from the first task!\", i);\n                trpl::sleep(std::time::Duration::from_millis(500)).await;\n            }\n        };\n        let fut2 = async {\n            for i in 1..6 {\n                println!(\"hi number {} from the second task!\", i);\n                trpl::sleep(std::time::Duration::from_millis(500)).await;\n            }\n        };\n        trpl::join(fut1, fut2).await;\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Using Namespace Path\nDESCRIPTION: This code snippet demonstrates the usage of a namespace path in Rust. It specifies the path through the module hierarchy to a specific item.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_67\n\nLANGUAGE: Rust\nCODE:\n```\nident::ident\n```\n\n----------------------------------------\n\nTITLE: Opening Book in Chrome (Windows - Cmd)\nDESCRIPTION: This command opens the built book in Google Chrome on Windows systems using the command prompt.\nSOURCE: https://github.com/rust-lang/book/blob/main/README.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ start chrome.exe .\\book\\index.html\n```\n\n----------------------------------------\n\nTITLE: Cargo.toml Configuration File\nDESCRIPTION: This TOML file contains the configuration for the Cargo project, including the package name, version, and Rust edition. It also includes a `dependencies` section to list project dependencies.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter01.md#_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\n[package]\nname = \"hello_cargo\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\n```\n\n----------------------------------------\n\nTITLE: Release Listings Binary Execution\nDESCRIPTION: Runs the `release_listings` binary using cargo to generate a compressed archive of all listings for release. This command requires Cargo to be installed and configured.\nSOURCE: https://github.com/rust-lang/book/blob/main/ADMIN_TASKS.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo run --bin release_listings\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error: Missing Lifetime Specifier\nDESCRIPTION: This snippet presents the output from a `cargo run` command, revealing a compilation error in a Rust program. The error, E0106, indicates that the `longest` function is missing a lifetime specifier. This occurs because the function returns a borrowed string slice (`&str`), but the compiler cannot determine whether it is borrowed from the `x` or `y` input string slices.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch10-generic-types-traits-and-lifetimes/listing-10-20/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n$ cargo run\n Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0106]: missing lifetime specifier\n --> src/main.rs:9:33\n  |\n9 | fn longest(x: &str, y: &str) -> &str {\n  |               ----     ----     ^ expected named lifetime parameter\n  |\n  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`\nhelp: consider introducing a named lifetime parameter\n  |\n9 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n  |           ++++     ++          ++          ++\n\nFor more information about this error, try `rustc --explain E0106`.\nerror: could not compile `chapter10` (bin \"chapter10\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Using Tuple Expression\nDESCRIPTION: This code snippet demonstrates the use of a tuple expression in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_106\n\nLANGUAGE: Rust\nCODE:\n```\n(expr, ...)\n```\n\n----------------------------------------\n\nTITLE: Creating a Binary Crate in a Workspace\nDESCRIPTION: This console command creates a new binary crate named `adder` within the Cargo workspace. The `cargo new` command automatically adds the newly created package to the `members` key in the workspace `Cargo.toml` file.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-03-cargo-workspaces.md#_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ cargo new adder\n    Creating binary (application) `adder` package\n      Adding `adder` as member of workspace at `file:///projects/add`\n```\n\n----------------------------------------\n\nTITLE: Creating Project Directory (Linux/macOS/PowerShell)\nDESCRIPTION: These commands create a project directory called `projects` in the user's home directory, then create a subdirectory called `hello_world` inside it, and finally navigate into the new directory. They use standard shell commands.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch01-02-hello-world.md#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ mkdir ~/projects\n$ cd ~/projects\n$ mkdir hello_world\n$ cd hello_world\n```\n\n----------------------------------------\n\nTITLE: Matching Character Ranges in Rust\nDESCRIPTION: This snippet illustrates matching character ranges with the `..=` syntax in a `match` expression. It checks if the character `x` falls within the ranges 'a' to 'j' or 'k' to 'z'.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter19.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 'c';\n\nmatch x {\n    'a'..='j' => println!(\"early ASCII letter\"),\n    'k'..='z' => println!(\"late ASCII letter\"),\n    _ => println!(\"something else\"),\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo build command with rand crate - Shell\nDESCRIPTION: This snippet demonstrates the output from running `cargo build` after adding the `rand` crate as a dependency to the `Cargo.toml` file.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter02.md#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo build\n  Updating crates.io index\n   Locking 15 packages to latest Rust 1.85.0 compatible versions\n    Adding rand v0.8.5 (available: v0.9.0)\n Compiling proc-macro2 v1.0.93\n Compiling unicode-ident v1.0.17\n Compiling libc v0.2.170\n Compiling cfg-if v1.0.0\n Compiling byteorder v1.5.0\n Compiling getrandom v0.2.15\n Compiling rand_core v0.6.4\n Compiling quote v1.0.38\n Compiling syn v2.0.98\n Compiling zerocopy-derive v0.7.35\n Compiling zerocopy v0.7.35\n Compiling ppv-lite86 v0.2.20\n Compiling rand_chacha v0.3.1\n Compiling rand v0.8.5\n Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.48s\n```\n\n----------------------------------------\n\nTITLE: Using Tuple Type\nDESCRIPTION: This code snippet shows how to use a tuple type in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_107\n\nLANGUAGE: Rust\nCODE:\n```\n(type, ...)\n```\n\n----------------------------------------\n\nTITLE: Struct with References without Lifetimes (Compile Error)\nDESCRIPTION: This snippet shows an example of a struct that attempts to store references without specifying lifetimes, resulting in a compile-time error. Lifetimes are necessary to ensure the referenced data is valid for as long as the struct is valid. This example demonstrates why using owned types like String is often preferred over references like &str when defining structs.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch05-01-defining-structs.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nstruct User {\n    active: bool,\n    username: &str,\n    email: &str,\n    sign_in_count: u64,\n}\n\nfn main() {\n    let user1 = User {\n        active: true,\n        username: \"someusername123\",\n        email: \"someone@example.com\",\n        sign_in_count: 1,\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Optimization Level in Cargo.toml for dev profile\nDESCRIPTION: This code snippet shows how to set the optimization level (`opt-level`) for the `dev` profile in the `Cargo.toml` file.  The `opt-level` setting controls the number of optimizations the Rust compiler applies. Here, it sets the optimization level to 0 for the `dev` profile.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/ch14-01-release-profiles.md#_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[profile.dev]\nopt-level = 0\n```\n\n----------------------------------------\n\nTITLE: Rust Mutable Borrowing Error\nDESCRIPTION: This code snippet attempts to create a mutable reference `y` to an immutable variable `x`. This results in a compilation error because `x` was not declared as mutable using `let mut`. The error message suggests changing the declaration of `x` to `let mut x = 5;` to allow mutable borrowing.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch15-smart-pointers/no-listing-01-cant-borrow-immutable-as-mutable/output.txt#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet x = 5;\nlet y = &mut x;\n```\n\n----------------------------------------\n\nTITLE: Cargo Run Compilation Error\nDESCRIPTION: This snippet shows the output of a `cargo run` command that resulted in a compilation error. The error E0308 highlights a type mismatch where an integer was used instead of a boolean in an `if` statement's condition. It specifies the file and line number where the error occurred.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch03-common-programming-concepts/no-listing-28-if-condition-must-be-bool/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling branches v0.1.0 (file:///projects/branches)\nerror[E0308]: mismatched types\n --> src/main.rs:4:8\n  |\n4 |     if number {\n  |        ^^^^^^ expected `bool`, found integer\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `branches` (bin \"branches\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Rust Compilation Error: Unsafe Function Call\nDESCRIPTION: This code snippet demonstrates a Rust compilation error (E0133) that occurs when calling an `unsafe` function without wrapping it in an `unsafe` block. The error message indicates that the `dangerous` function is unsafe and requires an `unsafe` block.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch20-advanced-features/output-only-01-missing-unsafe/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)\nerror[E0133]: call to unsafe function `dangerous` is unsafe and requires unsafe block\n --> src/main.rs:4:5\n  |\n4 |     dangerous();\n  |     ^^^^^^^^^^^ call to unsafe function\n  |\n  = note: consult the function's documentation for information on how to avoid undefined behavior\n\nFor more information about this error, try `rustc --explain E0133`.\nerror: could not compile `unsafe-example` (bin \"unsafe-example\") due to 1 previous error\n```\n\n----------------------------------------\n\nTITLE: Error indicating Unpin trait is not implemented\nDESCRIPTION: This error message indicates that a type does not implement the `Unpin` trait, which is required when using `Box<T>` with `Future` if `T` might be moved in memory. It suggests using the `pin!` macro or `Box::pin` to ensure the value is pinned and doesn't move.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/chapter17.md#_snippet_49\n\nLANGUAGE: rust\nCODE:\n```\nerror[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned\n  --> src/main.rs:48:33\n   |\n48 |         trpl::join_all(futures).await;\n   |                                 ^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required by `Box<{async block@src/main.rs:10:23: 10:33}>: Future`\n   |\n   = note: consider using the `pin!` macro\n           consider using `Box::pin` if you need to access the pinned value outside of the current scope\n   = note: required for `Box<{async block@src/main.rs:10:23: 10:33}>` to implement `Future`\nnote: required by a bound in `futures_util::future::join_all::JoinAll`\n  --> file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:29:8\n   |\n27 | pub struct JoinAll<F>\n   |            ------- required by a bound in this struct\n28 | where\n29 |     F: Future,\n   |        ^^^^^^ required by this bound in `JoinAll`\n```\n\n----------------------------------------\n\nTITLE: Running a Cargo Project in Rust\nDESCRIPTION: This snippet shows the command used to run a Rust project using Cargo. The output illustrates the compilation process and a runtime error due to a missing file.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch09-error-handling/listing-09-04/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo run\n Compiling error-handling v0.1.0 (file:///projects/error-handling)\n  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s\n  Running `target/debug/error-handling`\n\nthread 'main' panicked at src/main.rs:8:23:\nProblem opening the file: Os { code: 2, kind: NotFound, message: \"No such file or directory\" }\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Negation Operator Rust\nDESCRIPTION: This operator performs arithmetic negation. It negates the value of an expression. The `Neg` trait allows for overloading this operator.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_18\n\nLANGUAGE: Rust\nCODE:\n```\n`- expr`\n```\n\n----------------------------------------\n\nTITLE: Using Single-Element Tuple Type\nDESCRIPTION: This code snippet illustrates the use of a single-element tuple type in Rust.\nSOURCE: https://github.com/rust-lang/book/blob/main/src/appendix-02-operators.md#_snippet_105\n\nLANGUAGE: Rust\nCODE:\n```\n(type,)\n```\n\n----------------------------------------\n\nTITLE: Markdown Note Blockquote Example\nDESCRIPTION: This snippet illustrates the Markdown syntax that the preprocessor is designed to transform. It uses a blockquote with a 'Note:' prefix to indicate important material.\nSOURCE: https://github.com/rust-lang/book/blob/main/packages/mdbook-trpl/src/bin/README - mdbook-trpl-note.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n> Note: This is some material we want to provide more emphasis for, because it\n> is important in some way!\n\nSome text.\n\n> ## Some subject\n>\n> Here is all the important things to know about that particular subject.\n```\n\n----------------------------------------\n\nTITLE: Opening Book in Chrome (Windows - PowerShell)\nDESCRIPTION: This command opens the built book in Google Chrome on Windows systems using PowerShell.\nSOURCE: https://github.com/rust-lang/book/blob/main/README.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ Start-Process \"chrome.exe\" .\\book\\index.html\n```\n\n----------------------------------------\n\nTITLE: Building Rust Project with Cargo\nDESCRIPTION: This snippet shows the output of the `cargo build` command for a Rust project. It includes compiler warnings related to an unused `Result` returned by `io::stdin().read_line()`.  The warning suggests either handling the `Result` or ignoring it using `let _ = ...`.\nSOURCE: https://github.com/rust-lang/book/blob/main/listings/ch02-guessing-game-tutorial/no-listing-02-without-expect/output.txt#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n$ cargo build\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\nwarning: unused `Result` that must be used\n  --> src/main.rs:10:5\n   |\n10 |     io::stdin().read_line(&mut guess);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\n   = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n10 |     let _ = io::stdin().read_line(&mut guess);\n   |     +++++++\n\nwarning: `guessing_game` (bin \"guessing_game\") generated 1 warning\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s\n```\n\n----------------------------------------\n\nTITLE: Building a Rust project to trigger warnings\nDESCRIPTION: This command compiles the Rust project and triggers a warning because the variable `x` is declared as mutable but never mutated.\nSOURCE: https://github.com/rust-lang/book/blob/main/nostarch/appendix.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo build\n```"
  }
]