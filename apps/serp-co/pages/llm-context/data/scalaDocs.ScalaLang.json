[
  {
    "owner": "scala",
    "repo": "docs.scala-lang",
    "content": "TITLE: Scala Promises: Creating and Completing Futures\nDESCRIPTION: This snippet explains the concept of Promises in Scala, illustrating how they serve as writable containers to complete associated Futures either successfully or with exceptions. It provides examples of producing, consuming, and handling failures using Promises.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_35\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.concurrent.{ Future, Promise }\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nval p = Promise[T]()\nval f = p.future\n\nval producer = Future {\n  val r = produceSomething()\n  p.success(r)\n  continueDoingSomethingUnrelated()\n}\n\nval consumer = Future {\n  startDoingSomething()\n  f.foreach { r =>\n    doSomethingWithResult()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Simple Package and Class in Scala\nDESCRIPTION: This snippet shows how to declare a new package named \"users\" and define a class \"User\" within it. No external dependencies are required, and no parameters are needed; the package declaration organizes code into namespaces. Outputs the class definition, and the package can be referenced elsewhere in the codebase. There are no constraints aside from standard Scala naming conventions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/packages-and-imports.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\npackage users\n\nclass User\n```\n\n----------------------------------------\n\nTITLE: Creating a Singleton Logger with an 'info' Method in Scala 2 and 3\nDESCRIPTION: Defines a singleton object 'Logger' with an 'info' method to print informational messages to the console. Illustrates the syntax differences between Scala 2 and Scala 3. The 'info' method can be imported and used across the project for logging purposes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/singleton-objects.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\npackage logging\n\nobject Logger {\n  def info(message: String): Unit = println(s\"INFO: $message\")\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\npackage logging\n\nobject Logger:\n  def info(message: String): Unit = println(s\"INFO: $message\")\n```\n\n----------------------------------------\n\nTITLE: Specifying Scala Version in sbt Build File - Scala\nDESCRIPTION: This sbt build file (build.sbt) snippet declares the Scala version used for the project with the scalaVersion setting. It ensures all source files will compile with the specified Scala compiler version, which is a placeholder value '{{ site.scala-3-version }}' representing the current Scala 3 release version.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nscalaVersion := \"{{ site.scala-3-version }}\"\n```\n\n----------------------------------------\n\nTITLE: Using Standard Library List Methods in Scala\nDESCRIPTION: This snippet illustrates various common methods available on Scala collections like `List`. It shows operations for creating lists (`range`, `fill`, `tabulate`), manipulating them (`distinct`, `drop`, `filter`, `map`, `slice`, `tail`, `take`, `flatMap`), finding elements (`find`, `head`, `last`, `headOption`, `lastOption`), and sorting (`sorted`, `sortWith`). These methods generally work across different Scala collection types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/why-scala-3.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nList.range(1, 3)                          // List(1, 2)\nList.range(start = 1, end = 6, step = 2)  // List(1, 3, 5)\nList.fill(3)(\"foo\")                       // List(foo, foo, foo)\nList.tabulate(3)(n => n * n)              // List(0, 1, 4)\nList.tabulate(4)(n => n * n)              // List(0, 1, 4, 9)\n\nval a = List(10, 20, 30, 40, 10)          // List(10, 20, 30, 40, 10)\na.distinct                                // List(10, 20, 30, 40)\na.drop(2)                                 // List(30, 40, 10)\na.dropRight(2)                            // List(10, 20, 30)\na.dropWhile(_ < 25)                       // List(30, 40, 10)\na.filter(_ < 25)                          // List(10, 20, 10)\na.filter(_ > 100)                         // List()\na.find(_ > 20)                            // Some(30)\na.head                                    // 10\na.headOption                              // Some(10)\na.init                                    // List(10, 20, 30, 40)\na.intersect(List(19,20,21))               // List(20)\na.last                                    // 10\na.lastOption                              // Some(10)\na.map(_ * 2)                              // List(20, 40, 60, 80, 20)\na.slice(2, 4)                             // List(30, 40)\na.tail                                    // List(20, 30, 40, 10)\na.take(3)                                 // List(10, 20, 30)\na.takeRight(2)                            // List(40, 10)\na.takeWhile(_ < 30)                       // List(10, 20)\na.filter(_ < 30).map(_ * 10)              // List(100, 200, 100)\n\nval fruits = List(\"apple\", \"pear\")\nfruits.map(_.toUpperCase)                 // List(APPLE, PEAR)\nfruits.flatMap(_.toUpperCase)             // List(A, P, P, L, E, P, E, A, R)\n\nval nums = List(10, 5, 8, 1, 7)\nnums.sorted                               // List(1, 5, 7, 8, 10)\nnums.sortWith(_ < _)                      // List(1, 5, 7, 8, 10)\nnums.sortWith(_ > _)                      // List(10, 8, 7, 5, 1)\n```\n\n----------------------------------------\n\nTITLE: Defining Arithmetic Expression ADT using Enum (Scala 3)\nDESCRIPTION: Defines the structure for arithmetic expressions using a Scala 3 enum. `Sum` represents addition, `Var` represents a variable, and `Const` represents an integer constant. Enum cases in Scala 3 provide automatic getters, `equals`/`hashCode`, `toString`, and support pattern matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\nenum Tree:\n  case Sum(left: Tree, right: Tree)\n  case Var(n: String)\n  case Const(v: Int)\n```\n\n----------------------------------------\n\nTITLE: Correct Indentation in Scala Class Definition - Scala\nDESCRIPTION: Provides an example of a Scala class and method using the preferred two-space indentation for scopes and logical blocks, as guided by the Scala style guide. No external libraries are necessary. Key parameters are a class, method, and local variable. Inputs follow standard Scala syntax. The snippet exemplifies proper coding style to improve code readability and maintainability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/indentation.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n// right!\nclass Foo {\n  def twospaces = {\n    val x = 2\n    ..\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a multi-method type class 'HasLegs' in Scala 3\nDESCRIPTION: Defines a trait with extension methods 'walk' and 'run' for type 'A', enabling multiple behaviors within a single type class in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-type-classes.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ntrait HasLegs[A]:\n  extension (a: A)\n    def walk(): Unit\n    def run(): Unit\n```\n\n----------------------------------------\n\nTITLE: Enumerated Examples of New Proposed given Syntax Variants in Scala\nDESCRIPTION: Provides detailed examples of various given definition styles using the new syntax, including simple typeclasses, parameterized instances with context bounds and parameters, named context parameters, simple aliases, parameterized aliases, abstract (deferred) givens, and by-name given aliases. These showcase the enhanced expressive power and readability of the proposed given syntax across common use cases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\n  // Simple typeclass\n  given Ord[Int]:\n    def compare(x: Int, y: Int) = ...\n\n  // Parameterized typeclass with context bound\n  given [A: Ord] => Ord[List[A]]:\n    def compare(x: List[A], y: List[A]) = ...\n\n  // Parameterized typeclass with context parameter\n  given [A] => Ord[A] => Ord[List[A]]:\n    def compare(x: List[A], y: List[A]) = ...\n\n  // Parameterized typeclass with named context parameter\n  given [A] => (ord: Ord[A]) => Ord[List[A]]:\n    def compare(x: List[A], y: List[A]) = ...\n\n  // Simple alias\n  given Ord[Int] = IntOrd()\n\n  // Parameterized alias with context bound\n  given [A: Ord] => Ord[List[A]] =\n    ListOrd[A]\n\n  // Parameterized alias with context parameter\n  given [A] => Ord[A] => Ord[List[A]] =\n    ListOrd[A]\n\n  // Abstract or deferred given\n  given Context = deferred\n\n  // By-name given\n  given () => Context = curCtx\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Stack Class in Scala\nDESCRIPTION: This Scala snippet defines a generic Stack class parameterized by a type A. It maintains an internal list of elements of type A and provides methods to push elements onto the stack, peek at the top element, and pop elements from the stack. The implementation ensures type safety by allowing only elements of type A to be stored. The snippet requires knowledge of Scala's type parameters and List data structure, with expected input being elements of type A and output being the manipulated stack state or elements retrieved. Elements are stored immutably by reassigning the list property.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/generic-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Stack[A] {\n  private var elements: List[A] = Nil\n  def push(x: A): Unit =\n    elements = x :: elements\n  def peek: A = elements.head\n  def pop(): A = {\n    val currentTop = peek\n    elements = elements.tail\n    currentTop\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing implicit Monoid instances for String and Integer types in Scala\nDESCRIPTION: This snippet declares two implicit values, stringMonoid and intMonoid, implementing the Monoid trait for String and Int types. These implicit objects enable Scala to automatically resolve monoid instances when summing lists of these types without explicitly passing the monoid parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/implicit-parameters.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit val stringMonoid: Monoid[String] = new Monoid[String] {\n  def add(x: String, y: String): String = x concat y\n  def unit: String = \"\"\n}\n\nimplicit val intMonoid: Monoid[Int] = new Monoid[Int] {\n  def add(x: Int, y: Int): Int = x + y\n  def unit: Int = 0\n}\n```\n\n----------------------------------------\n\nTITLE: Evaluating Arithmetic Expression Trees Using Pattern Matching in Scala\nDESCRIPTION: Defines the `eval` function which recursively computes the integer value of a given `Tree` expression within an `Environment`. It uses pattern matching to determine the structure of the tree: sums are evaluated by recursively evaluating left and right subtrees and adding their results; variables are looked up in the environment; constants evaluate to their integer value. If the input tree does not match any case, a pattern matching exception is raised. This implementation demonstrates how to decode tree structures and evaluate expressions via pattern matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_it/tutorials/scala-for-java-programmers.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ndef eval(t: Tree, env: Environment): Int = t match {\n  case Sum(l, r) => eval(l, env) + eval(r, env)\n  case Var(n)    => env(n)\n  case Const(v)  => v\n}\n```\n\n----------------------------------------\n\nTITLE: Ternary conditional assignment in Python and Scala\nDESCRIPTION: Demonstrates concise expression of conditional assignments selecting the minimum of two variables a and b. Inputs: integers a and b; outputs: assignment of min_val or minValue. No dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_25\n\nLANGUAGE: Python\nCODE:\n```\nmin_val = a if a < b else b\n```\n\n----------------------------------------\n\nTITLE: Accessing command-line arguments with App trait in Scala\nDESCRIPTION: A Scala application that extends the App trait and demonstrates how to access command-line arguments via the automatically provided 'args' array.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/hello-world-2.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject HelloYou extends App {\n    if (args.size == 0)\n        println(\"Hello, you\")\n    else\n        println(\"Hello, \" + args(0))\n}\n```\n\n----------------------------------------\n\nTITLE: Using Opaque Types for Logarithms in Scala 3\nDESCRIPTION: Example usage of the opaque type implementation showing type safety and operations. This demonstrates how opaque types prevent accidental type conversions while still allowing the defined operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-opaque-types.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport Logarithms.*\nval log2 = Logarithm(2.0)\nval log3 = Logarithm(3.0)\nprintln((log2 * log3).toDouble) // prints 6.0\nprintln((log2 + log3).toDouble) // prints 4.999...\n\nval d: Double = log2 // ERROR: Found Logarithm required Double\n```\n\n----------------------------------------\n\nTITLE: Using Traits as Subtypes and Polymorphism in Scala\nDESCRIPTION: Illustrates how traits can be used as subtypes where classes 'Dog' and 'Cat' extend the trait 'Pet', and their instances are stored in a collection. It emphasizes trait polymorphism by calling 'pet.name' on a collection of 'Pet' objects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/traits.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.mutable.ArrayBuffer\n\ntrait Pet {\n  val name: String\n}\n\nclass Cat(val name: String) extends Pet\nclass Dog(val name: String) extends Pet\n\nval dog = new Dog(\"Harry\")\nval cat = new Cat(\"Sally\")\n\nval animals = ArrayBuffer.empty[Pet]\nanimals.append(dog)\nanimals.append(cat)\nanimals.foreach(pet => println(pet.name))  // Prints Harry Sally\n```\n\n----------------------------------------\n\nTITLE: Filtering and Mapping Lists in Scala\nDESCRIPTION: This set of snippets illustrates the filter method to select elements matching a predicate and filter-map chaining for transformation. Inputs are lists of Ints or Strings, predicates are lambdas. No dependencies necessary. Outputs are filtered lists or mapped lists. Shows idiomatic sequential operations on collections for querying and transformation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-methods.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nscala> val lessThanFive = oneToTen.filter(_ < 5)\nlessThanFive: List[Int] = List(1, 2, 3, 4)\n\nscala> val evens = oneToTen.filter(_ % 2 == 0)\nevans: List[Int] = List(2, 4, 6, 8, 10)\n\nscala> val shortNames = names.filter(_.length <= 4)\nshortNames: List[String] = List(adam)\n```\n\nLANGUAGE: scala\nCODE:\n```\noneToTen.filter(_ < 4).map(_ * 10)\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> oneToTen.filter(_ < 4).map(_ * 10)\nval res1: List[Int] = List(10, 20, 30)\n```\n\n----------------------------------------\n\nTITLE: 定义和使用Traits作为接口的示例(Scala 3)\nDESCRIPTION: 展示如何在Scala 3中定义traits作为接口，包括抽象和具体方法的实现。此示例创建了Speaker、TailWagger和Runner三个trait，定义了动物行为的接口。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-modeling.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Speaker:\n  def speak(): String  // has no body, so it's abstract\n\ntrait TailWagger:\n  def startTail(): Unit = println(\"tail is wagging\")\n  def stopTail(): Unit = println(\"tail is stopped\")\n\ntrait Runner:\n  def startRunning(): Unit = println(\"I'm running\")\n  def stopRunning(): Unit = println(\"Stopped running\")\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Trait Scala\nDESCRIPTION: Defines a simple Scala trait named `TailWagger` that specifies two abstract methods, `startTail` and `stopTail`. These methods have no parameters and return Unit, serving as an interface contract that classes extending this trait must implement.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/traits-interfaces.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait TailWagger {\n    def startTail(): Unit\n    def stopTail(): Unit\n}\n```\n\n----------------------------------------\n\nTITLE: Sequencing Option Operations with For Comprehension, Scala\nDESCRIPTION: Illustrates using a `for` comprehension to sequence multiple operations that return `Option`. If all steps within the comprehension succeed (return `Some`), the final result is wrapped in a `Some`. If any step fails (returns `None`), the entire comprehension short-circuits and the result is `None`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-functional-error-handling.md#_snippet_4\n\nLANGUAGE: Scala 2\nCODE:\n```\nval y = for {\n  a <- makeInt(stringA)\n  b <- makeInt(stringB)\n  c <- makeInt(stringC)\n} yield {\n  a + b + c\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nval y = for\n  a <- makeInt(stringA)\n  b <- makeInt(stringB)\n  c <- makeInt(stringC)\nyield\n  a + b + c\n```\n\n----------------------------------------\n\nTITLE: Using Concise Lambda Syntax for Collections in Scala\nDESCRIPTION: This snippet illustrates the use of concise lambda syntax with higher-order functions on collections. It shows both the long-form lambda (`i => i * 2`) and the shorter placeholder syntax (`_ * 2`) for operations like `map` and `filter`, highlighting Scala's expressiveness for functional programming patterns.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-features.md#_snippet_3\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\nnums.map(i => i * 2)   // long form\nnums.map(_ * 2)        // short form\n\nnums.filter(i => i > 1)\nnums.filter(_ > 1)\n```\n\n----------------------------------------\n\nTITLE: Defining Algebraic Data Types with Case Classes in Scala\nDESCRIPTION: Introduces case classes for defining an algebraic data type representing an arithmetic expression tree. Defines an abstract base class `Tree` and three case classes (`Sum`, `Var`, `Const`) extending it. Mentions benefits like automatic companion objects, accessors, `equals`/`hashCode`, `toString`, and pattern matching support.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tutorials/scala-for-java-programmers.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Tree\ncase class Sum(l: Tree, r: Tree) extends Tree\ncase class Var(n: String) extends Tree\ncase class Const(v: Int) extends Tree\n```\n\n----------------------------------------\n\nTITLE: Chaining Filter and Foreach in Scala\nDESCRIPTION: Demonstrates chaining methods, specifically combining `filter` and `foreach` to first select elements based on a condition and then perform a side effect on the filtered subset.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/collections-methods.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nnums.filter(_ < 4).foreach(println)\n```\n\n----------------------------------------\n\nTITLE: Using Inline to Improve Compile-Time Performance and Avoid Closures in Scala 3\nDESCRIPTION: This snippet demonstrates how inline parameters can prevent closure allocations and duplicate work, enabling more efficient compile-time optimizations. It compares the behavior of by-name parameters (which create closures) versus inline parameters (which duplicate code), showing improved performance and code clarity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ninline def assert1(cond: Boolean, msg: => String) =\n  if !cond then\n    throw new Exception(msg)\n\n// Usage:\nassert1(x, \"error1\")\n```\n\nLANGUAGE: Scala\nCODE:\n```\ninline def assert2(cond: Boolean, inline msg: String) =\n  if !cond then\n    throw new Exception(msg)\n\n// Usage:\nassert2(x, \"error2\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Scala Tuple with Heterogeneous Elements in Scala\nDESCRIPTION: Demonstrates how to directly create a tuple containing multiple heterogeneous elements — an integer, a string, and an instance of the Person class — by enclosing values in parentheses. This approach avoids needing explicit classes for simple grouped data. The tuple size is three items. Input is the literal values, output is a tuple instance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/tuples.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval t = (3, \"Three\", new Person(\"Al\"))\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Case Objects for Messages\nDESCRIPTION: Defines a sealed trait `Message` representing a message hierarchy. It includes case classes for messages with data (`PlaySong`, `IncreaseVolume`, `DecreaseVolume`) and a case object `StopPlaying` for a simple, parameterless message. Case objects are singletons that also get an `unapply` method, making them usable directly in pattern matching. The syntax is the same for Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_50\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\nsealed trait Message\ncase class PlaySong(name: String) extends Message\ncase class IncreaseVolume(amount: Int) extends Message\ncase class DecreaseVolume(amount: Int) extends Message\ncase object StopPlaying extends Message\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Scala Value Class Syntax\nDESCRIPTION: Illustrates the fundamental syntax for declaring a value class in Scala. Value classes must extend `AnyVal` and have exactly one `val` parameter, which serves as the underlying value. This structure is the basis for achieving zero-overhead abstraction.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/value-classes.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n    class C (val u: U) extends AnyVal {\n      def m1(ps1) = ...\n      ...\n      def mN(psN) = ...\n    }\n```\n\n----------------------------------------\n\nTITLE: Scala variable mutability with 'val' and 'var'\nDESCRIPTION: Demonstrates mutable variables in Scala using the 'var' keyword, allowing reassignment after initial declaration. Emphasizes that the default practice preferred in Scala is to use 'val' for immutability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nvar x = 1\nx += 1\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Pure Function in Scala\nDESCRIPTION: This snippet demonstrates a basic pure function `double` in Scala. It takes an integer `i` as input and returns its value multiplied by 2. It adheres to the definition of a pure function as its output depends solely on its input, and it produces no side effects. This example is valid for both Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-pure-functions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef double(i: Int): Int = i * 2\n```\n\n----------------------------------------\n\nTITLE: Implementing Covariant Singly Linked List That Fails Compilation in Scala\nDESCRIPTION: Defines a covariant trait Node and its implementations ListNode and Nil representing a singly linked list with a covariant type parameter B. The prepend method accepts an element of type B. This approach fails to compile because methods with covariant type parameters cannot accept parameters of the covariant type due to Scala's variance rules. This snippet highlights the variance conflict when using covariant type parameters in method parameter positions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/lower-type-bounds.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Node[+B] {\n  def prepend(elem: B): Node[B]\n}\n\ncase class ListNode[+B](h: B, t: Node[B]) extends Node[B] {\n  def prepend(elem: B): ListNode[B] = ListNode(elem, this)\n  def head: B = h\n  def tail: Node[B] = t\n}\n\ncase class Nil[+B]() extends Node[B] {\n  def prepend(elem: B): ListNode[B] = ListNode(elem, this)\n}\n```\n\n----------------------------------------\n\nTITLE: Chained Usage of Functional Pizza Methods in Scala\nDESCRIPTION: Illustrates usage of the Pizza case class with embedded functional methods. Starting from a base pizza, methods like addTopping and updateCrustType are chained to create a modified Pizza instance, at the end accessing the price. This fluent style showcases composition of immutable transformations and method calls on the Pizza instance in both Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-fp.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nPizza(Small, Thin, Seq(Cheese))\n  .addTopping(Pepperoni)\n  .updateCrustType(Thick)\n  .price\n```\n\n----------------------------------------\n\nTITLE: Populating and Using Scala List Collections\nDESCRIPTION: Illustrates various idiomatic ways to create and populate Scala List collections using range and character sequences, including specifying increments. These simple expressions showcase how to generate lists of integers and characters with built-in Scala methods. Dependencies are limited to Scala's core collections library. Inputs are numeric or character ranges, and outputs are immutable lists of corresponding elements. This snippet serves as a foundational technique for preparing data in Scala collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/prelude-taste-of-scala.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval nums = List.range(0, 10)\nval nums = (1 to 10 by 2).toList\nval letters = ('a' to 'f').toList\nval letters = ('a' to 'f' by 2).toList\n```\n\n----------------------------------------\n\nTITLE: Assigning Anonymous Function to Variable to Create Function Variable in Scala\nDESCRIPTION: Creates a function variable `double` by assigning an anonymous function that doubles an integer input to a val. This enables reuse and passing the function as a value. The input is an Int, the output is Int, with type Int => Int inferred by the compiler.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-function-variables.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval double = (i: Int) => i * 2\n```\n\n----------------------------------------\n\nTITLE: Using match Expressions as a Method Body in Scala\nDESCRIPTION: Shows how to implement a method using a match expression instead of if/else. This alternative implementation of isTruthy uses pattern matching with case statements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\ndef isTruthy(a: Any) = a match {\n  case 0 | \"\" | false => false\n  case _ => true\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef isTruthy(a: Matchable) = a match\n  case 0 | \"\" | false => false\n  case _ => true\n```\n\n----------------------------------------\n\nTITLE: Using sum function with implicit parameters in Scala\nDESCRIPTION: These examples demonstrate calling the `sum` function with lists of integers and strings. The appropriate implicit `Monoid` instances (`IntMonoid` and `StringMonoid`) are automatically resolved based on the list element type, allowing concise and type-safe aggregation of list elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/implicit-parameters.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nprintln(sum(List(1, 2, 3)))          // uses IntMonoid implicitly\nprintln(sum(List(\"a\", \"b\", \"c\")))    // uses StringMonoid implicitly\n```\n\n----------------------------------------\n\nTITLE: Printing Hello, World! in Scala 3 Using @main Annotation\nDESCRIPTION: Defines a standalone method `hello` annotated with `@main` which serves as the application entry point in Scala 3. It prints \"Hello, World!\" directly using `println`. This modern syntax eliminates the need for a singleton object and the explicit `main` method signature. The snippet depends only on Scala 3 standard library features and demonstrates the concise program definition possible in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-hello-world.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n@main def hello() = println(\"Hello, World!\")\n```\n\n----------------------------------------\n\nTITLE: Defining Functions in Scala\nDESCRIPTION: Various ways to define functions in Scala, including proper return type definitions, parameter specifications, and common pitfalls to avoid.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/cheatsheets/index.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: Int) = { x*x }\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: Any) = println(x)\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype R = Double\ndef f(x: R)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: => R)\n```\n\n----------------------------------------\n\nTITLE: Creating Scala 3 'Hello, World!' Entry Point using @main\nDESCRIPTION: Defines a Scala 3 top-level function `hello` annotated with `@main`. This annotation marks the function as a program entry point, replacing the need for an object extending `App`. When executed, it prints 'Hello, World!' to the console. This is the preferred method for defining main methods in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/getting-started/intellij-track/getting-started-with-scala-in-intellij.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n@main def hello(): Unit =\n  println(\"Hello, World!\")\n```\n\n----------------------------------------\n\nTITLE: Publishing on Tag Push with GitHub Actions - YAML\nDESCRIPTION: This YAML snippet defines a GitHub Actions workflow to publish a Scala library when a Git tag prefixed with ‘v’ is pushed. It configures a CI job that checks out all tags, sets up Java (Temurin 8), caches sbt, and runs sbt ci-release. Secrets for Sonatype and PGP (SONATYPE_USERNAME, SONATYPE_PASSWORD, PGP_PASSPHRASE, PGP_SECRET) are passed as environment variables. Place this configuration in .github/workflows/publish.yml. Required inputs are repository secrets and properly configured sbt-ci-release and keys; outputs are published artifacts.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\nname: Continuous publication\non:\n  push:\n    tags: [v*]\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0 # fetch all tags, required to compute the release version\n      - uses: actions/setup-java@v3\n        with:\n          distribution: temurin\n          java-version: 8\n          cache: sbt\n      - run: sbt ci-release\n        env:\n          PGP_PASSPHRASE: ${{ secrets.PGP_PASSPHRASE }}\n          PGP_SECRET: ${{ secrets.PGP_SECRET }}\n          SONATYPE_PASSWORD: ${{ secrets.SONATYPE_PASSWORD }}\n          SONATYPE_USERNAME: ${{ secrets.SONATYPE_USERNAME }}\n```\n\n----------------------------------------\n\nTITLE: General Exception Handling and Resource Cleanup with Scala try/catch/finally\nDESCRIPTION: This snippet illustrates Scala's try/catch/finally syntax for general exception handling and resource cleanup. Multiple exception types are matched using case statements with typed exceptions, including a catch-all case for Throwable. The finally block runs code regardless of exceptions, commonly used to close resources like files or database connections. Dependencies include the definitions of the exception types FooException and BarException and appropriate handler methods. The snippet emphasizes Scala's pattern matching style consistency across control structures.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/try-catch-finally.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntry {\n    // your scala code here\n} \ncatch {\n    case foo: FooException => handleFooException(foo)\n    case bar: BarException => handleBarException(bar)\n    case _: Throwable => println(\"Got some other kind of Throwable exception\")\n} finally {\n    // your scala code here, such as closing a database connection\n    // or file handle\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a basic enum in Scala 3\nDESCRIPTION: This snippet demonstrates how to define a simple enumeration 'Color' with three cases: Red, Green, and Blue. It shows the equivalent expansion using 'extends' for clarity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-adts-gadts.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nenum Color:\n  case Red, Green, Blue\n```\n\nLANGUAGE: Scala\nCODE:\n```\nenum Color:\n  case Red   extends Color\n  case Green extends Color\n  case Blue  extends Color\n```\n\n----------------------------------------\n\nTITLE: Implementing a trait with a concrete class in Scala\nDESCRIPTION: Shows how to extend a trait with a class that implements all required abstract methods. The example implements an Integer iterator that counts up to a specified limit.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/traits.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait Iterator[A] {\n  def hasNext: Boolean\n  def next(): A\n}\n\nclass IntIterator(to: Int) extends Iterator[Int] {\n  private var current = 0\n  override def hasNext: Boolean = current < to\n  override def next(): Int = {\n    if (hasNext) {\n      val t = current\n      current += 1\n      t\n    } else 0\n  }\n}\n\nval iterator = new IntIterator(10)\niterator.next()  // вернет 0\niterator.next()  // вернет 1\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait Iterator[A]:\n  def hasNext: Boolean\n  def next(): A\n\nclass IntIterator(to: Int) extends Iterator[Int]:\n  private var current = 0\n  override def hasNext: Boolean = current < to\n  override def next(): Int =\n    if hasNext then\n      val t = current\n      current += 1\n      t\n    else\n      0\nend IntIterator\n\nval iterator = new IntIterator(10)\niterator.next()  // вернет 0\niterator.next()  // вернет 1\n```\n\n----------------------------------------\n\nTITLE: Using Common Scala Collection Methods in Scala\nDESCRIPTION: This snippet initializes a Scala List and demonstrates the use of basic collection methods such as distinct, drop, head, init, intersect, last, slice, tail, take, and takeRight. No additional dependencies are required. The snippet shows how to operate on List objects, highlighting methods that return new collections or values based on the original sequence, and does not mutate the original collection. Inputs are Scala lists (e.g., List of Int), outputs are transformed lists or single values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-methods.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval a = List(10, 20, 30, 40, 10)      // List(10, 20, 30, 40, 10)\n\na.distinct                            // List(10, 20, 30, 40)\na.drop(2)                             // List(30, 40, 10)\na.dropRight(2)                        // List(10, 20, 30)\na.head                                // 10\na.headOption                          // Some(10)\na.init                                // List(10, 20, 30, 40)\na.intersect(List(19,20,21))           // List(20)\na.last                                // 10\na.lastOption                          // Some(10)\na.slice(2,4)                          // List(30, 40)\na.tail                                // List(20, 30, 40, 10)\na.take(3)                             // List(10, 20, 30)\na.takeRight(2)                        // List(40, 10)\n```\n\n----------------------------------------\n\nTITLE: Using foldLeft and reduceLeft to Aggregate List Values in Scala 2 and 3\nDESCRIPTION: Illustrates summing integers in a List[Int] using reduceLeft for aggregation without seed and foldLeft with an initial seed value. Highlights the difference where foldLeft allows specifying a starting accumulator, enabling flexible accumulation logic. Both methods are functional and operate from the left of the collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-collections.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval firstTen = (1 to 10).toList            // List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\nfirstTen.reduceLeft(_ + _)                 // 55\nfirstTen.foldLeft(100)(_ + _)              // 155 (100 is a “seed” value)\n```\n\n----------------------------------------\n\nTITLE: Using a match Expression as a Method Body in Scala\nDESCRIPTION: Defines an `isTruthy` method that takes a `Matchable` input (the root type for pattern matching) and returns a `Boolean`. The entire method body consists of a `match` expression that checks for specific \"falsy\" values (0, empty string, false) and returns `false`, otherwise returning `true`. Shows syntax for Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_29\n\nLANGUAGE: Scala 2\nCODE:\n```\ndef isTruthy(a: Matchable) = a match {\n  case 0 | \"\" | false => false\n  case _              => true\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ndef isTruthy(a: Matchable) = a match\n  case 0 | \"\" | false => false\n  case _              => true\n```\n\n----------------------------------------\n\nTITLE: Method Return Type Inference in Scala\nDESCRIPTION: This snippet discusses Scala's type inference for method return types, highlighting that methods without explicit return types will have their return types automatically inferred based on implementation. It emphasizes best practices for public members.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_11\n\n\n\n----------------------------------------\n\nTITLE: Demonstrating Covariant List Usage with Lower Type Bounds in Scala\nDESCRIPTION: Defines trait Bird and two subclasses AfricanSwallow and EuropeanSwallow to demonstrate covariant type assignment and method interaction with lower type bounds. Creates an AfricanSwallow list that is assigned to a list variable of type Node[Bird], then prepends a EuropeanSwallow element, showcasing the flexibility gained by the lower type bound in the prepend method parameter allowing insertion of supertypes or sibling subtypes safely.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/lower-type-bounds.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait Bird\ncase class AfricanSwallow() extends Bird\ncase class EuropeanSwallow() extends Bird\n\n\nval africanSwallowList= ListNode[AfricanSwallow](AfricanSwallow(), Nil())\nval birdList: Node[Bird] = africanSwallowList\nbirdList.prepend(EuropeanSwallow())\n```\n\n----------------------------------------\n\nTITLE: Defining a Covariant Singly-Linked List Trait in Scala\nDESCRIPTION: This snippet shows an initial attempt to implement a covariant singly-linked list with a prepend method. The List trait is covariant in A with +A. The prepend method takes an element of type A and returns a NonEmptyList of A. NonEmptyList is a case class containing a head and a tail, extending List[A]. 'Nil' represents an empty list with type List[Nothing]. This snippet demonstrates the problem of variance with the method parameter 'elem' being of covariant type A, which causes compilation errors due to function parameter contra-variance rules.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/lower-type-bounds.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait List[+A] {\n  def prepend(elem: A): NonEmptyList[A] = NonEmptyList(elem, this)\n}\n\ncase class NonEmptyList[+A](head: A, tail: List[A]) extends List[A]\n\nobject Nil extends List[Nothing]\n```\n\n----------------------------------------\n\nTITLE: Importing Essential Libraries for Futures and Try Handling in Scala\nDESCRIPTION: This snippet shows the recommended import statements for working with Scala Futures and handling Success/Failure using the Try API. It imports Future and ExecutionContext.Implicits.global for execution of asynchronous tasks and utilities for result handling. This setup is necessary for any application utilizing Futures and their callback methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/futures.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.util.{Failure, Success}\n```\n\n----------------------------------------\n\nTITLE: Defining a Multi-Parameter Method with Explicit Return Type in Scala\nDESCRIPTION: Defines the `add` method with two integer parameters, `a` and `b`, explicitly specifying the return type as `Int`. This shows the syntax for declaring multiple parameters along with an explicit return type for a method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/methods-first-look.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef add(a: Int, b: Int): Int = a + b\n```\n\n----------------------------------------\n\nTITLE: Passing Function Variable to Map Call in Scala\nDESCRIPTION: Illustrates passing a previously defined function variable `double` as an argument to the `map` method on a list, demonstrating function variables as first-class citizens that can be passed around and invoked by higher-order functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-function-variables.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nList(1, 2, 3).map(double)   // List(2, 4, 6)\n```\n\n----------------------------------------\n\nTITLE: Setting scalaVersion in sbt build file - Scala\nDESCRIPTION: Shows how to specify the Scala version in an sbt 'build.sbt' file either as a project-local or build-wide setting. The first example demonstrates a 'bare' setting that applies only to the root project, while the second example shows using 'ThisBuild' prefix to apply the setting across all subprojects in a multi-project build. Proper usage avoids common configuration issues.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/FAQ/index.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nscalaVersion := \"2.13.16\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\nThisBuild / scalaVersion := \"2.13.16\"\n```\n\n----------------------------------------\n\nTITLE: Tuple Deconstruction via Pattern Matching (Scala mdoc)\nDESCRIPTION: Illustrates how to use pattern matching to destructure a tuple into separate variables in Scala. No additional dependencies are needed. The tuple 'ingredient' is split into variables 'name' and 'quantity', which are then printed. The inferred types of 'name' and 'quantity' match the tuple's element types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/tuples.md#_snippet_3\n\nLANGUAGE: Scala mdoc\nCODE:\n```\nval (name, quantity) = ingredient\nprintln(name)     // Sugar\nprintln(quantity) // 25\n```\n\n----------------------------------------\n\nTITLE: Using ArrayOps for Sequence Methods on Arrays\nDESCRIPTION: Accesses sequence methods directly on arrays through implicit conversion to ArrayOps, such as reverse, which returns an Array. Demonstrates how implicit conversions add sequence methods without turning the array into a sequence object itself.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/arrays.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\na1.reverse\n```\n\n----------------------------------------\n\nTITLE: Implementing 'Showable' instance for 'Person' in Scala 2\nDESCRIPTION: Creates an implicit 'Showable' instance for 'Person' class, providing an implementation of 'show' that concatenates first and last names. Used for Scala 2 codebases to enable custom string representations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-type-classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimplicit val showablePerson: Showable[Person] = new Showable[Person] {\n  def show(p: Person): String =\n    s\"${p.firstName} ${p.lastName}\"\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Immutable Fields of Scala Case Classes\nDESCRIPTION: Shows direct access to publicly available immutable constructor parameters of a case class instance. Retrieves the 'title' field from an Email instance and prints it, illustrating how case classes expose constructor parameters as public vals for easy retrieval.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/case-classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval title = emailFromJohn.title\nprintln(title) // prints \"Greetings From John!\"\n```\n\n----------------------------------------\n\nTITLE: Handling Command-Line Arguments in Scala CLI scala\nDESCRIPTION: Scala source code that defines a `@main` method accepting a single `String` parameter `name`. It prints a personalized greeting by interpolating the `name` argument within the output string. This snippet requires that the program be executed with a command-line argument after `--` to supply the `name`, or else execution will fail. It demonstrates basic argument passing and string interpolation using Scala CLI.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/getting-started/install-scala.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n//> using scala {{site.scala-3-version}}\n\n@main\ndef hello(name: String): Unit =\n  println(s\"Hello, $name!\")\n```\n\n----------------------------------------\n\nTITLE: Defining and using variables in Scala\nDESCRIPTION: Shows different ways to declare and use variables in Scala, including mutable variables (var), immutable constants (val), and explicit type declarations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nvar x = 5\nx = 6\n```\n\nLANGUAGE: scala\nCODE:\n```\nval x = 5\nx = 6\n```\n\nLANGUAGE: scala\nCODE:\n```\nvar x: Double = 5\n```\n\n----------------------------------------\n\nTITLE: Defining a Ring-Buffer Capped Collection - Scala 3\nDESCRIPTION: Creates a capped immutable ring-buffer-like collection using modern Scala 3 syntax, leveraging enums, inlines, and extended trait composition for efficient and idiomatic interoperability with the Scala collections library. As in Scala 2, it supports efficient append, indexed access, strict iterable operations, and a reusable CappedFactory for instantiation. Inputs are the capacity and elements; output is a strongly-typed, capped collection. Depends on scala.collection and associated traits. Input arrays are replaced/wrapped on append when full. Factory and builder patterns use Scala 3 idioms and type inference.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_7\n\nLANGUAGE: Scala 3\nCODE:\n```\nimport scala.collection.*\n\nfinal class Capped[A] private (val capacity: Int, val length: Int, offset: Int, elems: Array[Any])\n  extends immutable.Iterable[A],\n    IterableOps[A, Capped, Capped[A]],\n    IterableFactoryDefaults[A, Capped],\n    StrictOptimizedIterableOps[A, Capped, Capped[A]]:\n  self =>\n\n  def this(capacity: Int) =\n    this(capacity, length = 0, offset = 0, elems = Array.ofDim(capacity))\n\n  def appended[B >: A](elem: B): Capped[B] =\n    val newElems = Array.ofDim[Any](capacity)\n    Array.copy(elems, 0, newElems, 0, capacity)\n    val (newOffset, newLength) =\n      if length == capacity then\n        newElems(offset) = elem\n        ((offset + 1) % capacity, length)\n      else\n        newElems(length) = elem\n        (offset, length + 1)\n    Capped[B](capacity, newLength, newOffset, newElems)\n  end appended\n\n  inline def :+ [B >: A](elem: B): Capped[B] = appended(elem)\n\n  def apply(i: Int): A = elems((i + offset) % capacity).asInstanceOf[A]\n\n  def iterator: Iterator[A] = view.iterator\n\n  override def view: IndexedSeqView[A] = new IndexedSeqView[A]:\n    def length: Int = self.length\n    def apply(i: Int): A = self(i)\n\n  override def knownSize: Int = length\n\n  override def className = \"Capped\"\n\n  override val iterableFactory: IterableFactory[Capped] = new CappedFactory(capacity)\n\nend Capped\n\nclass CappedFactory(capacity: Int) extends IterableFactory[Capped]:\n\n  def from[A](source: IterableOnce[A]): Capped[A] =\n    source match\n      case capped: Capped[?] if capped.capacity == capacity => capped.asInstanceOf[Capped[A]]\n      case _ => (newBuilder[A] ++= source).result()\n\n  def empty[A]: Capped[A] = Capped[A](capacity)\n\n  def newBuilder[A]: mutable.Builder[A, Capped[A]] =\n    new mutable.ImmutableBuilder[A, Capped[A]](empty):\n      def addOne(elem: A): this.type = { elems = elems :+ elem; this }\n\nend CappedFactory\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple @main Method in Scala 3\nDESCRIPTION: Shows how to create a minimal executable Scala 3 program by annotating a parameterless method with @main. This method prints a greeting message to the standard output. No dependencies other than Scala 3 compiler are required. The method can be executed using the scala command-line tool by saving it in a source file. The main method name corresponds to the annotated method's name for invocation. Output is the printed string.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/methods-main-methods.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n@main def hello() = println(\"Hello, World\")\n```\n\n----------------------------------------\n\nTITLE: Constructing and Using Option Types in Scala for Null-Safe Programming\nDESCRIPTION: Examples demonstrating construction of Option values with Some and None, null-safe creation with Option factory that converts null to None, explicit type declarations for Options, and idiomatic handling of optional parameters from methods such as request.getParameter. The snippets illustrate functional transformations on Option using map, filter, for-comprehensions, and retrieving default values with getOrElse. They show how to safely manipulate potentially missing or null values in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/cheatsheets/index.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nSome(42)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nNone\n```\n\nLANGUAGE: Scala\nCODE:\n```\nOption(null) == None\nOption(24) == Some(24)\n\nobj.unsafeMethod // number or null\nOption(obj.unsafeMethod) // Some or None\n\nSome(null) != None\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval optStr: Option[String] = None\nval optStr = Option.empty[String]\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval name: Option[String] =\n  request.getParameter(\"name\")\nval upper = name.map {\n  _.trim\n} filter {\n  _.length != 0\n} map {\n  _.toUpperCase\n}\nprintln(upper.getOrElse(\"\"))\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval upper = for {\n  name <- request.getParameter(\"name\")\n  trimmed <- Some(name.trim)\n    if trimmed.length != 0\n  upper <- Some(trimmed.toUpperCase)\n} yield upper\nprintln(upper.getOrElse(\"\"))\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption.map(f(_))\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption match {\n  case Some(x) => Some(f(x))\n  case None    => None\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption.flatMap(f(_))\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption match {\n  case Some(x) => f(x)\n  case None    => None\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\noptionOfOption.flatten\n```\n\nLANGUAGE: Scala\nCODE:\n```\noptionOfOption match {\n  case Some(Some(x)) => Some(x)\n  case _             => None\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption.foreach(f(_))\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption match {\n  case Some(x) => f(x)\n  case None    => ()\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption.fold(y)(f(_))\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption match {\n  case Some(x) => f(x)\n  case None    => y\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Scala Using Coursier Installer bash\nDESCRIPTION: Instructions for installing Scala on macOS, Linux, and Windows using the Coursier (`cs`) installer command-line tool. Dependencies include having a compatible JVM installed. The installation command varies by operating system and system architecture. Outputs include installation of the Scala compiler (`scalac`), Scala CLI (`scala`), build tools (`sbt`), REPL (`amm`), and formatter (`scalafmt`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/getting-started/install-scala.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nRun the following command in your terminal, following the on-screen instructions:\n\nmacOS (using Homebrew):\n> brew install coursier/formulas/coursier\n\nAlternatively on Apple Silicon (M1, M2):\n> curl -fLo cs https://git.io/coursier-cli-linux && chmod +x cs\n\nOn x86-64 macOS:\n> curl -Lo cs https://git.io/coursier-cli-linux-x86_64 && chmod +x cs\n\nLinux x86-64:\n> curl -Lo cs https://git.io/coursier-cli-linux-x86_64 && chmod +x cs\n\nLinux ARM64:\n> curl -Lo cs https://git.io/coursier-cli-linux-arm64 && chmod +x cs\n\nWindows:\nDownload and run the installer from https://get-coursier.io/windows\n\nAfter installation, use:\n> cs setup\n\nThis installs the JVM and Scala tools automatically.\n```\n\n----------------------------------------\n\nTITLE: Creating Immutable and Mutable Variables in Scala\nDESCRIPTION: Demonstrates how to create immutable (val) and mutable (var) variables in Scala, showing the basic syntax for variable declaration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-vars-data-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// immutable\nval a = 0\n\n// mutable\nvar b = 1\n```\n\n----------------------------------------\n\nTITLE: Adding an external library dependency in build.sbt with sbt\nDESCRIPTION: This snippet demonstrates how to include an external library, specifically 'scala-parser-combinators', into a Scala project's build configuration using sbt. Dependencies are added via the 'libraryDependencies' setting with the '+=' operator, enabling the incorporation of additional functionalities into the project. It is essential for managing external libraries and ensuring they are downloaded during build.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/getting-started/sbt-track/getting-started-with-scala-and-sbt-on-the-command-line.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nlibraryDependencies += \"org.scala-lang.modules\" %% \"scala-parser-combinators\" % \"1.1.2\"\n```\n\n----------------------------------------\n\nTITLE: Handling and Reporting Exceptions in Scala Futures - Scala 2\nDESCRIPTION: Demonstrates how to handle exceptions in asynchronous computations using Scala 2 Futures and ExecutionContext. The example defines various functions that throw different exceptions, wraps them in Futures, and uses Await and pattern matching to inspect results. It shows how to set up custom error reporters, use different ExecutionContext configurations (global, custom executor, custom UncaughtExceptionHandler), and handle failed or incomplete Future computations. Requires scala.concurrent, scala.util, and Java concurrency libraries. Key parameters include the ExecutionContext, thrown exceptions, and completion handling via check(). Outputs are printed to standard output or error; exceptions can be reported via custom reporter functions. This snippet can be limited by thread pool configuration and exception propagation behaviors.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_32\n\nLANGUAGE: Scala\nCODE:\n```\nimport java.util.concurrent.{ForkJoinPool, TimeoutException}\nimport scala.concurrent.{Await, ExecutionContext, Future}\nimport scala.concurrent.duration.DurationInt\nimport scala.util.{Failure, Success}\n\nobject Test extends App {\n  def crashing(): Int  = throw new NoSuchMethodError(\"test\")\n  def failing(): Int   = throw new NumberFormatException(\"test\")\n  def interrupt(): Int = throw new InterruptedException(\"test\")\n  def erroring(): Int  = throw new AssertionError(\"test\")\n\n  // computations can fail in the middle of a chain of combinators, after the initial Future job has completed\n  def testCrashes()(implicit ec: ExecutionContext): Future[Int] =\n    Future.unit.map(_ => crashing())\n  def testFails()(implicit ec: ExecutionContext): Future[Int] =\n    Future.unit.map(_ => failing())\n  def testInterrupted()(implicit ec: ExecutionContext): Future[Int] =\n    Future.unit.map(_ => interrupt())\n  def testError()(implicit ec: ExecutionContext): Future[Int] =\n    Future.unit.map(_ => erroring())\n\n  // Wait for 1 second for the the completion of the passed `future` value and print it\n  def check(future: Future[Int]): Unit =\n    try {\n      Await.ready(future, 1.second)\n      for (completion <- future.value) {\n        println(s\"completed $completion\")\n        // In case of failure, also print the cause of the exception, when defined\n        completion match {\n          case Failure(exception) if exception.getCause != null =>\n            println(s\"  caused by ${exception.getCause}\")\n          _ => ()\n        }\n      }\n    } catch {\n      // If the future value did not complete within 1 second, the call\n      // to `Await.ready` throws a TimeoutException\n      case _: TimeoutException => println(s\"did not complete\")\n    }\n\n  def reporter(t: Throwable) = println(s\"reported $t\")\n\n  locally {\n    // using the `global` implicit context\n    import ExecutionContext.Implicits._\n    // a successful Future\n    check(Future(42))        // completed Success(42)\n    // a Future that completes with an application exception\n    check(Future(failing())) // completed Failure(java.lang.NumberFormatException: test)\n    // same, but the exception is thrown somewhere in the chain of combinators\n    check(testFails())       // completed Failure(java.lang.NumberFormatException: test)\n    // a Future that does not complete because of a linkage error;\n    // the trace is printed to stderr by default\n    check(testCrashes())     // did not complete\n    // a Future that completes with an operational exception that is wrapped\n    check(testInterrupted()) // completed Failure(java.util.concurrent.ExecutionException: Boxed Exception)\n                             //   caused by java.lang.InterruptedException: test\n    // a Future that completes due to a failed assert, which is bad for the app,\n    // but is handled the same as interruption\n    check(testError())       // completed Failure(java.util.concurrent.ExecutionException: Boxed Exception)\n                             //   caused by java.lang.AssertionError: test\n  }\n  locally {\n    // same as `global`, but adds a custom reporter that will handle uncaught\n    // exceptions and errors reported to the context\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutor(null, reporter)\n    check(testCrashes())     // reported java.lang.NoSuchMethodError: test\n                             // did not complete\n  }\n  locally {\n    // does not handle uncaught exceptions; the executor would have to be\n    // configured separately\n    val executor = ForkJoinPool.commonPool()\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutor(executor, reporter)\n    // the reporter is not invoked and the Future does not complete\n    check(testCrashes())     // did not complete\n  }\n  locally {\n    // sample minimal configuration for a context and underlying pool that\n    // use the reporter\n    val handler: Thread.UncaughtExceptionHandler =\n      (_: Thread, t: Throwable) => reporter(t)\n    val executor = new ForkJoinPool(\n      Runtime.getRuntime.availableProcessors,\n      ForkJoinPool.defaultForkJoinWorkerThreadFactory, // threads use the pool's handler\n      handler,\n      /*asyncMode=*/ false\n    )\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutor(executor, reporter)\n    check(testCrashes())     // reported java.lang.NoSuchMethodError: test\n                             // did not complete\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Uploading a single file with sttp in Scala 3\nDESCRIPTION: This snippet shows how to upload a single file over HTTP using sttp client in Scala 3. It uses the quickRequest API with Scala 3 import syntax, converts an OS-Lib path to Java Path, sets it as the request body for a POST request, executes the request, and prints the response code. Requirements include sttp client4 and OS-Lib. The snippet expects a local file path input and outputs the HTTP status code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/http-client-upload-file.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport sttp.client4.quick.*\n\nval file: java.nio.file.Path = (os.pwd / \"image.png\").toNIO\nval response = quickRequest.post(uri\"https://example.com/\").body(file).send()\n\nprintln(response.code)\n// prints: 200\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Main Method Scala 3\nDESCRIPTION: Shows the minimal Scala 3 program entry point using the `@main` annotation. Placing `@main` on a method turns it into the executable entry point. The program executes the code within the annotated method. This requires a Scala 3 compiler.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-main-methods.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n@main def hello() = println(\"Hello, World\")\n```\n\n----------------------------------------\n\nTITLE: Using Inferred Types for Object Creation in Scala\nDESCRIPTION: Demonstrates creating a new instance of a class with type inference. Use these snippets when the type is obvious from the context, to keep code clean. The explicit form is also shown for comparison, highlighting verbosity versus brevity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/type-is-optional.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval p = new Person(\"Candy\")\n\nval p: Person = new Person(\"Candy\")\n```\n\n----------------------------------------\n\nTITLE: Calculating Pizza Price with Pattern Matching in Scala\nDESCRIPTION: Defines a function `pizzaPrice` that takes a `Pizza` object and computes its total price. It uses pattern matching on the case class to extract components and calls helper functions (`crustPrice`, `toppingPrice`) to sum up base, crust, and topping costs. Requires the `Pizza` case class and helper price functions to be defined.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-fp.md#_snippet_4\n\nLANGUAGE: Scala 2\nCODE:\n```\ndef pizzaPrice(p: Pizza): Double = p match {\n  case Pizza(crustSize, crustType, toppings) => {\n    val base  = 6.00\n    val crust = crustPrice(crustSize, crustType)\n    val tops  = toppings.map(toppingPrice).sum\n    base + crust + tops\n  }\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ndef pizzaPrice(p: Pizza): Double = p match\n  case Pizza(crustSize, crustType, toppings) =>\n    val base  = 6.00\n    val crust = crustPrice(crustSize, crustType)\n    val tops  = toppings.map(toppingPrice).sum\n    base + crust + tops\n```\n\n----------------------------------------\n\nTITLE: Evaluating Option Results from makeInt, Scala\nDESCRIPTION: Shows example calls to the `makeInt` function that returns an `Option[Int]`. A valid integer string results in a `Some` containing the integer, while a non-integer string results in `None`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-functional-error-handling.md#_snippet_2\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\nval a = makeInt(\"1\")     // Some(1)\nval b = makeInt(\"one\")   // None\n```\n\n----------------------------------------\n\nTITLE: Using Scala Pattern Matching with Case Classes\nDESCRIPTION: Demonstrates pattern matching on instances of 'Person' using a 'match' expression. The 'case' statements leverage the automatically generated 'unapply' methods of the 'Student' and 'Teacher' case classes to extract constructor parameters (constructor pattern).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/case-classes.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef getPrintableString(p: Person): String = p match {\n    case Student(name, year) =>\n        s\"$name is a student in Year $year.\"\n    case Teacher(name, whatTheyTeach) =>\n        s\"$name teaches $whatTheyTeach.\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Method in Scala with def\nDESCRIPTION: Shows the standard way to declare a named method, including parameters, return type, and body. Methods differ from function values in their syntax, declaration, and invocation. Used for defining reusable operations within classes or objects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\ndef add(x: Int, y: Int): Int = x + y\nprintln(add(1, 2)) // 3\n```\n\n----------------------------------------\n\nTITLE: Defining an Anonymous Function in Scala\nDESCRIPTION: Provides a lambda expression which adds one to an integer input. Demonstrates function literals, parameter declaration, and return value; a foundational construct for higher-order functions and collection operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\n(x: Int) => x + 1\n```\n\n----------------------------------------\n\nTITLE: Illustrating Expression-Oriented Programming (EOP) with 'if' in Scala\nDESCRIPTION: Provides an example of Expression-Oriented Programming (EOP) where an `if/else` construct evaluates to a value assigned to `minValue`. This highlights how Scala encourages expressions over statements. Compares Scala 2 and Scala 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_7\n\nLANGUAGE: Scala 2\nCODE:\n```\nval minValue = if (a < b) a else b\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nval minValue = if a < b then a else b\n```\n\n----------------------------------------\n\nTITLE: Accessing Private Members Between Class and Companion Object in Scala\nDESCRIPTION: This snippet demonstrates mutual access to private members between a Scala class and its companion object. The class defines a method that prints a private value from the companion object. The object holds a private val, showing how encapsulated data can be securely shared. No external libraries are required; the main parameter is HiddenFilename, which must be defined privately within the companion object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/companion-objects.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass SomeClass {\n    def printFilename() = {\n        println(SomeClass.HiddenFilename)\n    }\n}\n\nobject SomeClass {\n    private val HiddenFilename = \"/tmp/foo.bar\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a function type that takes two Int parameters and returns an Int in Scala\nDESCRIPTION: Displays the function parameter type signature `(Int, Int) => Int`, denoting a function that takes two integer inputs and produces an integer output. This signature is typical for arithmetic or binary operations and forms the basis for the example method definitions that follow.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-hofs.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nf: (Int, Int) => Int\n```\n\n----------------------------------------\n\nTITLE: Creating an Ad-hoc Class to Store Multiple Different Types in Scala\nDESCRIPTION: Shows a Scala class that groups multiple heterogeneous values via parameters to class constructor. This example explains the alternative to tuples when grouping data requires explicitly defining a structure. No external dependencies are necessary.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/tuples.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass SomeThings(i: Int, s: String, p: Person)\n```\n\n----------------------------------------\n\nTITLE: Creating and accessing fields of a Scala case class with multiple parameters\nDESCRIPTION: This snippet demonstrates the creation of a 'Message' case class with three string parameters, instantiation of an object, and access to its 'sender' property. It highlights the immutability of constructor parameters declared as 'val'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/case-classes.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Message(sender: String, recipient: String, body: String)\nval message1 = Message(\"guillaume@quebec.ca\", \"jorge@catalonia.es\", \"Ça va ?\")\n\nprintln(message1.sender)  // prints guillaume@quebec.ca\nmessage1.sender = \"travis@washington.us\"  // this line does not compile\n```\n\n----------------------------------------\n\nTITLE: Specifying Numeric Types and Formats in Scala\nDESCRIPTION: This multi-part snippet demonstrates suffix usage (L, D, F) to specify Long, Double, and Float, plus different literal formats including hexadecimal and scientific notation. It also highlights formatting options for floating-point numbers. Input is limited to literal assignment; output is the correctly-typed variable. Useful when specific numeric precision or representation is required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/first-look-at-types.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval x = 1_000L   // val x: Long = 1000\nval y = 2.2D     // val y: Double = 2.2\nval z = -3.3F    // val z: Float = -3.3\n```\n\nLANGUAGE: scala\nCODE:\n```\nval a = 0xACE    // val a: Int = 2766\nval b = 0xfd_3aL // val b: Long = 64826\n```\n\nLANGUAGE: scala\nCODE:\n```\nval q = .25      // val q: Double = 0.25\nval r = 2.5e-1   // val r: Double = 0.25\nval s = .0025e2F // val s: Float = 0.25\n```\n\n----------------------------------------\n\nTITLE: Working with Ranges in Scala\nDESCRIPTION: Demonstrates different ways to create and use Ranges in Scala, including filling collections, iterating in loops, and generating test data with various step sizes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-classes.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\n// Creating Ranges\n1 to 5         // Range(1, 2, 3, 4, 5)\n1 until 5      // Range(1, 2, 3, 4)\n1 to 10 by 2   // Range(1, 3, 5, 7, 9)\n'a' to 'c'     // NumericRange(a, b, c)\n\n// Converting Ranges to collections\nval x = (1 to 5).toList     // List(1, 2, 3, 4, 5)\nval x = (1 to 5).toBuffer   // ArrayBuffer(1, 2, 3, 4, 5)\n\n// Using Ranges in for loops (Scala 2)\nfor (i <- 1 to 3) println(i)\n\n// Using Ranges in for loops (Scala 3)\nfor i <- 1 to 3 do println(i)\n\n// Range methods on collections\nVector.range(1, 5)       // Vector(1, 2, 3, 4)\nList.range(1, 10, 2)     // List(1, 3, 5, 7, 9)\nSet.range(1, 10)         // HashSet(5, 1, 6, 9, 2, 7, 3, 8, 4)\n\n// Using Ranges for test data\nval evens = (0 to 10 by 2).toList     // List(0, 2, 4, 6, 8, 10)\nval odds = (1 to 10 by 2).toList      // List(1, 3, 5, 7, 9)\nval doubles = (1 to 5).map(_ * 2.0)   // Vector(2.0, 4.0, 6.0, 8.0, 10.0)\n\n// create a Map\nval map = (1 to 3).map(e => (e,s\"$e\")).toMap\n    // map: Map[Int, String] = Map(1 -> \"1\", 2 -> \"2\", 3 -> \"3\")\n```\n\n----------------------------------------\n\nTITLE: Defining the Main Entry Point in a Scala 3 Application - Scala\nDESCRIPTION: Demonstrates the idiomatic way to define the main entry point in Scala 3 using the @main annotation. The snippet declares a top-level main method 'hello' that prints 'Hello, World!' to the console. This approach utilizes Scala 3's main method syntax for executable applications. Only the Scala 3 compiler and standard library are required. The string passed to println appears as output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/add-guides.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n@main def hello() = println(\"Hello, World!\")\n```\n\n----------------------------------------\n\nTITLE: Defining a Scala 3 main method using Scala\nDESCRIPTION: This snippet defines a simple Scala 3 main method using the '@main' annotation which runs the 'hello' function printing a greeting message to the console. It demonstrates the modern entry point syntax introduced in Scala 3. No external dependencies are required beyond the Scala 3 compiler, and the output is 'Hello, world' printed to standard output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/scala3/guides/tasty-overview.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n@main def hello = println(\"Hello, world\")\n```\n\n----------------------------------------\n\nTITLE: Using Companion Objects to Access Private Members in Scala 2 and Scala 3\nDESCRIPTION: This example illustrates the use of a companion object Circle alongside a class Circle, where the companion object defines a private method calculateArea. The class imports its companion's members and calls this private method within its public area method. This pattern enables encapsulating implementation details in the companion object while exposing functionality via the class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-objects.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.math._\n\nclass Circle(radius: Double) {\n  import Circle._\n  def area: Double = calculateArea(radius)\n}\n\nobject Circle {\n  private def calculateArea(radius: Double): Double =\n    Pi * pow(radius, 2.0)\n}\n\nval circle1 = new Circle(5.0)\ncircle1.area   // Double = 78.53981633974483\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.math.*\n\nclass Circle(radius: Double):\n  import Circle.*\n  def area: Double = calculateArea(radius)\n\nobject Circle:\n  private def calculateArea(radius: Double): Double =\n    Pi * pow(radius, 2.0)\n\nval circle1 = Circle(5.0)\ncircle1.area   // Double = 78.53981633974483\n```\n\n----------------------------------------\n\nTITLE: Filtering a Collection in Scala\nDESCRIPTION: Shows the Scala equivalent of filtering a collection (`numbers`). It uses the `filter` method directly on the collection with a concise anonymous function (`_ > 1`) to achieve the same result as the Python example.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_68\n\nLANGUAGE: Scala\nCODE:\n```\nval x = numbers.filter(_ > 1)\n```\n\n----------------------------------------\n\nTITLE: Filtering collections with list comprehensions and filter method in Python and Scala\nDESCRIPTION: Shows how to select elements based on a predicate condition. Python uses list comprehension with if condition to keep only evens. Scala demonstrates two ways: using filter method with anonymous function and for-comprehension with conditional guard. Both examples produce collections containing only even numbers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_64\n\nLANGUAGE: python\nCODE:\n```\nevens = [i for i in numbers if i % 2 == 0]\n```\n\nLANGUAGE: scala\nCODE:\n```\nval evens = numbers.filter(_ % 2 == 0)\n// or\nval evens = for i <- numbers if i % 2 == 0 yield i\n```\n\n----------------------------------------\n\nTITLE: Shorthand Anonymous Function Syntax in Scala\nDESCRIPTION: Shows the core shorthand syntax (`_ * 2`) for an anonymous function that takes one argument (represented by `_`) and multiplies it by 2. This is commonly used within higher-order methods like `map`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-anonymous-functions.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n_ * 2\n```\n\n----------------------------------------\n\nTITLE: Using Scala 2 Match Expression as Value\nDESCRIPTION: This snippet demonstrates the Scala 2 syntax for a `match` expression used to return a value. The expression matches an input `i` against various cases (`1 | 3 | ...`, `2 | 4 | ...`, `_`) and assigns the resulting string to the `val` `numAsString`. This highlights that `match` is an expression, not just a statement.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/why-scala-3.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval numAsString = i match {\n  case 1 | 3 | 5 | 7 | 9 => \"odd\"\n  case 2 | 4 | 6 | 8 | 10 => \"even\"\n  case _ => \"too big\"\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit Anonymous Function Definition in Scala\nDESCRIPTION: Isolates the explicit syntax of a Scala anonymous function: `(parameter: Type) => expression`. This defines a function that takes an `Int` named `i` and returns `i * 2`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-anonymous-functions.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n(i: Int) => i * 2\n```\n\n----------------------------------------\n\nTITLE: Adding and Removing Elements from a Mutable Map in Scala\nDESCRIPTION: These examples show how to add entries using '+=', '++=' and remove entries with '-=' and '--=' operators on a mutable Map. Inputs include individual key-value pairs or entire Maps/lists. Results in in-place modification of the original Map. Relies on Scala's collection.mutable.Map and standard operator methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/collections-maps.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nstates += (\"AZ\" -> \"Arizona\")\nstates ++= Map(\"CO\" -> \"Colorado\", \"KY\" -> \"Kentucky\")\n```\n\nLANGUAGE: Scala\nCODE:\n```\nstates -= \"KY\"\nstates --= List(\"AZ\", \"CO\")\n```\n\n----------------------------------------\n\nTITLE: Using Option Type and Its Combinators in Scala\nDESCRIPTION: Provides examples of constructing and manipulating optional values using Some and None, emphasizing null safety with Option factory and usage patterns. Shows pipeline style transformations via map, filter, and flatMap; describes for-comprehension equivalent for Option; demonstrates method equivalences by pattern matching on Some and None including foreach, fold, collect, isDefined, isEmpty, and nonEmpty methods. Dependencies: Scala standard library Option type. Input: possibly null or defined values. Output: safely transformed optional values or default fallbacks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nSome(42)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nNone\n```\n\nLANGUAGE: Scala\nCODE:\n```\nOption(null) == None\nOption(obj.unsafeMethod)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nSome(null) != None\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval optStr: Option[String] = None\nval optStr = Option.empty[String]\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval name: Option[String] =\n  request.getParameter(\"name\")\nval upper = name.map {\n  _.trim\n} filter {\n  _.length != 0\n} map {\n  _.toUpperCase\n}\nprintln(upper.getOrElse(\"\"))\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval upper = for {\n  name <- request.getParameter(\"name\")\n  trimmed <- Some(name.trim)\n    if trimmed.length != 0\n  upper <- Some(trimmed.toUpperCase)\n} yield upper\nprintln(upper.getOrElse(\"\"))\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption.map(f(_))\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption match {\n  case Some(x) => Some(f(x))\n  case None    => None\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption.flatMap(f(_))\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption match {\n  case Some(x) => f(x)\n  case None    => None\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\noptionOfOption.flatten\n```\n\nLANGUAGE: Scala\nCODE:\n```\noptionOfOption match {\n  case Some(Some(x)) => Some(x)\n  case _             => None\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption.foreach(f(_))\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption match {\n  case Some(x) => f(x)\n  case None    => ()\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption.fold(y)(f(_))\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption match {\n  case Some(x) => f(x)\n  case None    => y\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption.collect {\n  case x => ...\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption match {\n  case Some(x) if f.isDefinedAt(x) => ...\n  case Some(_)                     => None\n  case None                        => None\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption.isDefined\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption match {\n  case Some(_) => true\n  case None    => false\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption.isEmpty\n```\n\nLANGUAGE: Scala\nCODE:\n```\noption match {\n  case Some(_) => false\n  case None    => true\n}\n```\n\n----------------------------------------\n\nTITLE: Using 's' Interpolator for Variable Embedding in Strings\nDESCRIPTION: Demonstrates how to embed variables and expressions inside strings using the 's' interpolator. The 's' interpolator allows direct insertion of variables and arbitrary expressions within string literals via the '$' prefix and '${}' syntax, respectively.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/string-interpolation.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval name = \"James\"\nprintln(s\"Hello, $name\")  // Hello, James\n\nprintln(s\"1 + 1 = ${1 + 1}\")\n```\n\n----------------------------------------\n\nTITLE: Connecting to WebSockets with sttp in Scala 3\nDESCRIPTION: This code sample shows how to use sttp and DefaultFutureBackend for WebSocket communication in Scala 3, defining a function to send and receive text asynchronously via Futures. The sample uses Scala 3's significant indentation and universal imports. It sends a message, awaits a reply, and prints the received data. Dependencies: sttp.client4, sttp.ws, Scala's Futures and ExecutionContext, and valid WebSocket server endpoint. Inputs: WebSocket endpoint and message. Output: prints the echoed message; blocking on Await.result should be avoided for highly concurrent scenarios.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/http-client-what-else.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.concurrent.duration.Duration\nimport scala.concurrent.{Await, Future}\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nimport sttp.client4.*\nimport sttp.ws.WebSocket\n\nval asyncBackend = DefaultFutureBackend()\n\ndef useWebSocket(ws: WebSocket[Future]): Future[Unit] =\n  for\n    _ <- ws.sendText(\"Hello\")\n    text <- ws.receiveText()\n  yield\n    println(text)\n\nval response = quickRequest\n  .get(uri\"wss://ws.postman-echo.com/raw\")\n  .response(asWebSocketAlways(useWebSocket))\n  .send(asyncBackend)\n\nAwait.result(response, Duration.Inf)\n// prints: Hello\n```\n\n----------------------------------------\n\nTITLE: Using the `s` Interpolator for Basic Variable Embedding in Scala\nDESCRIPTION: Demonstrates basic string interpolation in Scala using the `s` interpolator. Variables `name` and `age` are declared and then embedded within a string literal by prefixing the literal with `s` and the variables with `$`. The resulting string is printed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval name = \"James\"\nval age = 30\nprintln(s\"$name is $age years old\")   // \"James is 30 years old\"\n```\n\n----------------------------------------\n\nTITLE: Interactive Hello World Program in Scala 3 Using @main and User Input\nDESCRIPTION: Defines a method `helloInteractive` annotated with `@main` for Scala 3 that prompts the user for their name, reads it via `readLine()`, and prints a personalized greeting to the console. This snippet uses Scala 3's concise main method syntax while demonstrating standard input handling and string concatenation. Requires importing `scala.io.StdIn.readLine`. Input is user typed text from the command line; output is a customized greeting message.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-hello-world.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.io.StdIn.readLine\n\n@main def helloInteractive() =\n  println(\"Please enter your name:\")\n  val name = readLine()\n\n  println(\"Hello, \" + name + \"!\")\n```\n\n----------------------------------------\n\nTITLE: Scala: Creating a Test Suite with ScalaTest FunSuite\nDESCRIPTION: This snippet shows a test class 'CubeCalculatorTest' extending ScalaTest's 'AnyFunSuite'. It imports the necessary testing library, defines a test case that asserts the cube of 3 equals 27, and demonstrates test execution commands. It serves as a template for writing unit tests in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/getting-started/intellij-track/testing-scala-in-intellij-with-scalatest.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport org.scalatest.funsuite.AnyFunSuite\n\nclass CubeCalculatorTest extends AnyFunSuite:\n  test(\"CubeCalculator.cube\") {\n    assert(CubeCalculator.cube(3) === 27)\n  }\n```\n\n----------------------------------------\n\nTITLE: Returning a Tuple from a Scala Method\nDESCRIPTION: Shows how to return multiple values from a method by returning a tuple. The method getStockInfo returns a Tuple3 containing a stock symbol and two prices as a triple (String, Double, Double). This approach avoids creating a dedicated class for returning compound data. Dependencies: none external, relies on standard Scala tuples.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/tuples.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef getStockInfo = {\n    // other code here ...\n    (\"NFLX\", 100.00, 101.00)  // this is a Tuple3\n}\n```\n\n----------------------------------------\n\nTITLE: Scala 'Case Class' 'Person' for Immutable Data\nDESCRIPTION: Defines an immutable 'Person' case class with two fields, 'name' and 'relation'. It provides automatic implementations of common methods like 'equals', 'hashCode', and 'toString', suitable for data modeling.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Person(name: String, relation: String)\n```\n\n----------------------------------------\n\nTITLE: Mitigation using class/trait parameters to prevent null-values\nDESCRIPTION: This example demonstrates how passing values as constructor parameters to classes can prevent the null-value issue during initialization, ensuring all fields are properly initialized before use. It also notes Scala 3's support for trait parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/FAQ/initialization-order.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class A(val x1: String, val x2: String = \"mom\") {\n  println(\"A: \" + x1 + \", \" + x2)\n}\nclass B(x1: String = \"hello\", x2: String = \"mom\") extends A(x1, x2) {\n  println(\"B: \" + x1 + \", \" + x2)\n}\nclass C(x2: String = \"dad\") extends B(x2 = x2) {\n  println(\"C: \" + x1 + \", \" + x2)\n}\n```\n\n----------------------------------------\n\nTITLE: Using Lazy View Take with Find Palindrome - Scala\nDESCRIPTION: Demonstrates finding a palindrome within the first million words using `.view.take`. This is more efficient as it creates only a lightweight view and processes elements one by one, stopping as soon as the palindrome is found, without creating an intermediate collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/views.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nfindPalindrome(words.view take 1000000)\n```\n\n----------------------------------------\n\nTITLE: Creating Multiline Strings with Triple Quotes\nDESCRIPTION: Illustrates how to define multiline string literals in Scala, preserving formatting and indentation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-vars-data-types.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nval quote = \"\"\"The essence of Scala:\n               Fusion of functional and object-oriented\n               programming in a typed setting.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Top-Level Constructs in Scala 3\nDESCRIPTION: This snippet illustrates Scala 3's ability to define various elements directly at the file's top level without requiring a package, class, or object wrapper. It shows examples of importing, defining an enum, importing enum cases, defining a class, creating an instance, defining an extension method, defining a type alias, and defining a main entry point using `@main`, demonstrating a more flexible code organization compared to Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-toplevel-definitions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable.ArrayBuffer\n\nenum Topping:\n  case Cheese, Pepperoni, Mushrooms\n\nimport Topping.*\nclass Pizza:\n  val toppings = ArrayBuffer[Topping]()\n\nval p = Pizza()\n\nextension (s: String)\n  def capitalizeAllWords = s.split(\" \").map(_.capitalize).mkString(\" \")\n\nval hwUpper = \"hello, world\".capitalizeAllWords\n\ntype Money = BigDecimal\n\n// more definitions here as desired ...\n\n@main def myApp =\n  p.toppings += Cheese\n  println(\"show me the code\".capitalizeAllWords)\n```\n\n----------------------------------------\n\nTITLE: Defining a Class in Scala 3\nDESCRIPTION: Presents a class definition using Scala 3's indentation-based syntax, reducing keyword and brace noise. Defines a constructor and a method that prints a greeting. No external dependencies required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\nclass Greeter(prefix: String, suffix: String):\n  def greet(name: String): Unit =\n    println(prefix + name + suffix)\n```\n\n----------------------------------------\n\nTITLE: Comparing Case Class Instances by Value in Scala 2\nDESCRIPTION: Demonstrates use of == operator to check structural equality for case class instances. Outputs different messages based on value equality, showing this differs from reference equality found in standard classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\nif (point == anotherPoint) {\n  println(s\"$point and $anotherPoint are the same.\")\n} else {\n  println(s\"$point and $anotherPoint are different.\")\n} // Point(1,2) and Point(1,2) are the same.\n\nif (point == yetAnotherPoint) {\n  println(s\"$point and $yetAnotherPoint are the same.\")\n} else {\n  println(s\"$point and $yetAnotherPoint are different.\")\n} // Point(1,2) and Point(2,2) are different.\n```\n\n----------------------------------------\n\nTITLE: Immutable Field Declaration in Scala 3\nDESCRIPTION: Declares an immutable integer field i using val keyword, initialized to 1. The val keyword provides constant binding, preventing reassignment, adhering to Scala's preference for immutability by default.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nval i = 1\n```\n\n----------------------------------------\n\nTITLE: ケースクラスの定義 - Scala\nDESCRIPTION: 不変で値比較可能な特別なクラス「ケースクラスPoint」の定義例です。case classキーワードを用い、x,y座標を持つ単純な構造を宣言しています。暗黙的にequals,hashCode,toStringなどが付与されます。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\ncase class Point(x: Int, y: Int)\n```\n\n----------------------------------------\n\nTITLE: Scala Enumeration for Sum Types in Scala 2\nDESCRIPTION: Defines enumerations using sealed abstract classes and case objects for sum types like crust size, type, and toppings in Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-modeling.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nsealed abstract class CrustSize\nobject CrustSize {\n  case object Small extends CrustSize\n  case object Medium extends CrustSize\n  case object Large extends CrustSize\n}\n\nsealed abstract class CrustType\nobject CrustType {\n  case object Thin extends CrustType\n  case object Thick extends CrustType\n  case object Regular extends CrustType\n}\n\nsealed abstract class Topping\nobject Topping {\n  case object Cheese extends Topping\n  case object Pepperoni extends Topping\n  case object BlackOlives extends Topping\n  case object GreenOlives extends Topping\n  case object Onions extends Topping\n}\n```\n\n----------------------------------------\n\nTITLE: Using Short Lambdas with Higher-Order Methods in Scala\nDESCRIPTION: This snippet applies higher-order functions (dropWhile, filter, filterNot, find, takeWhile) with short-form lambda syntax to a Scala List. The input is a List[Int], and outputs are new lists or Option types depending on the method. No special dependencies are required. The focus is on concise lambda usage, illustrating how predicates drive filtering and search operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-methods.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\na.dropWhile(_ < 25)   // List(30, 40, 10)\na.filter(_ > 100)     // List()\na.filterNot(_ < 25)   // List(30, 40)\na.find(_ > 20)        // Some(30)\na.takeWhile(_ < 30)   // List(10, 20)\n```\n\n----------------------------------------\n\nTITLE: Reassigning a var in Scala\nDESCRIPTION: Demonstrates that variables declared with var can be reassigned without compile errors, enabling mutable state.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-vars-data-types.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nvar msg = \"Hello, world\"\nmsg = \"Aloha\"   // this compiles because a var can be reassigned\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Enumerations (Enums) in Scala 3\nDESCRIPTION: Shows how to declare enumerations using the `enum` keyword in Scala 3 to define finite sets of named constant values. Examples include different pizza attributes such as crust size, crust type, and toppings. These enums provide a typesafe alternative to integer constants and can be pattern matched or compared with `==`. No external dependencies required beyond Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\nenum CrustSize:\n  case Small, Medium, Large\n\nenum CrustType:\n  case Thin, Thick, Regular\n\nenum Topping:\n  case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions\n```\n\n----------------------------------------\n\nTITLE: Comparing Scala case class instances for structural equality\nDESCRIPTION: This snippet illustrates comparing two 'Message' instances for equality using '==', which checks for structural equivalence rather than reference equality. It shows that two different objects with identical content are considered equal.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/case-classes.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Message(sender: String, recipient: String, body: String)\n\nval message2 = Message(\"jorge@catalonia.es\", \"guillaume@quebec.ca\", \"Com va?\")\nval message3 = Message(\"jorge@catalonia.es\", \"guillaume@quebec.ca\", \"Com va?\")\nval messagesAreTheSame = message2 == message3  // true\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic map Method in TraversableLike Using Implicit Builder Factories in Scala\nDESCRIPTION: Shows the implementation of the map transformation in TraversableLike, leveraging implicit builder factories via the CanBuildFrom type class. This design enables map to dynamically adjust its result type based on the transformation function's result, supporting flexible but type-safe collection operations. Requires an implicit CanBuildFrom in scope and uses foreach to populate a dynamically chosen builder. Inputs are a transformation function and an implicit builder factory; output is a new collection whose element type and representation depend on the arguments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-collections.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef map[B, That](f: Elem => B)\n    (implicit bf: CanBuildFrom[Repr, B, That]): That = {\n  val b = bf(this)\n  this.foreach(x => b += f(x))\n  b.result\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Immutable Ranges in Scala\nDESCRIPTION: Shows two ways to create immutable `Range` objects in Scala. The `to` method creates an inclusive range (e.g., 1, 2, 3). Using `by` specifies a step value for the range (e.g., 5, 8, 11, 14). Ranges are efficient as they only store start, end, and step values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-immutable-collection-classes.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nscala> 1 to 3\nres2: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3)\nscala> 5 to 14 by 3\nres3: scala.collection.immutable.Range = Range(5, 8, 11, 14)\n```\n\n----------------------------------------\n\nTITLE: Defining Scala SortedSet Map Signature\nDESCRIPTION: Presents the specific `map` method signature for `SortedSet[A]`. This signature includes an implicit (Scala 2) or using (Scala 3) parameter for `Ordering[B]`, which is required to maintain the sorted property of the collection after transformation. This requirement differentiates it from the `map` in `IterableOps`, necessitating a specialized template trait.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_11\n\nLANGUAGE: Scala 2\nCODE:\n```\ndef map[B](f: A => B)(implicit ord: Ordering[B]): SortedSet[B]\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ndef map[B](f: A => B)(using ord: Ordering[B]): SortedSet[B]\n```\n\n----------------------------------------\n\nTITLE: Handling Exceptions with try/catch/finally in Scala 3\nDESCRIPTION: Shows the Scala 3 concise syntax for exception handling with `try/catch/finally`. The code tries calling `openAndReadAFile` (assumed defined), storing the result in `text`. It catches specific exceptions (`FileNotFoundException`, `IOException`) via pattern matching in the `catch` block, and executes cleanup code (like closing resources) in the `finally` block.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_34\n\nLANGUAGE: scala\nCODE:\n```\nvar text = \"\"\ntry\n  text = openAndReadAFile(filename)\ncatch\n  case fnf: FileNotFoundException => fnf.printStackTrace()\n  case ioe: IOException => ioe.printStackTrace()\nfinally\n  // close your resources here\n  println(\"Came to the 'finally' clause.\")\n```\n\n----------------------------------------\n\nTITLE: Basic For Comprehension with User Data in Scala\nDESCRIPTION: Demonstrates a basic for comprehension that filters a list of users to find those in their twenties. The example shows how to use guards for filtering and the yield statement to create a new list of names.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/for-comprehensions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class User(name: String, age: Int)\n\nval userBase = List(\n  User(\"Travis\", 28),\n  User(\"Kelly\", 33),\n  User(\"Jennifer\", 44),\n  User(\"Dennis\", 23))\n\nval twentySomethings =\n  for (user <- userBase if user.age >=20 && user.age < 30)\n  yield user.name  // i.e. add this to a list\n\ntwentySomethings.foreach(println)  // prints Travis Dennis\n```\n\nLANGUAGE: scala\nCODE:\n```\ncase class User(name: String, age: Int)\n\nval userBase = List(\n  User(\"Travis\", 28),\n  User(\"Kelly\", 33),\n  User(\"Jennifer\", 44),\n  User(\"Dennis\", 23))\n\nval twentySomethings =\n  for user <- userBase if user.age >=20 && user.age < 30\n  yield user.name  // i.e. add this to a list\n\ntwentySomethings.foreach(println)  // prints Travis Dennis\n```\n\n----------------------------------------\n\nTITLE: Combining Higher-Order Functions in Scala\nDESCRIPTION: Example of chaining multiple higher-order functions to process a collection, combining filter, takeWhile, and map methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/collections-methods.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// выдает `List(100, 200)`\na.filter(_ < 40)\n .takeWhile(_ < 30)\n .map(_ * 10)\n```\n\n----------------------------------------\n\nTITLE: Defining Classes, Constructors, and Inheritance in Scala Object Orientation\nDESCRIPTION: Shows various ways to define class constructors with parameters and modifiers (val, var) affecting member visibility and mutability. Demonstrates assertion in constructor, declaration of public, private, and readonly members, alternative constructors, anonymous classes, abstract classes, inheritance syntax, singleton objects, traits (Scala's mixins/interfaces), multiple trait mixin, method overriding requirement, and correct instantiation of classes. Dependencies are on standard Scala language core concepts and runtime. Inputs vary based on class design, outputs depend on instantiation and member access or override behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nclass C(x: R)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass C(val x: R)\nvar c = new C(4)\nc.x\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass C(var x: R) {\n  assert(x > 0, \"positive please\")\n  var y = x\n  val readonly = 5\n  private var secret = 1\n  def this() = this(42)\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nnew {\n  ...\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class D { ... }\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass C extends D { ... }\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass D(var x: R)\nclass C(x: R) extends D(x)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nobject O extends D { ... }\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntrait T { ... }\nclass C extends T { ... }\nclass C extends D with T { ... }\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntrait T1; trait T2\nclass C extends T1 with T2\nclass C extends D with T1 with T2\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass C extends D { override def f = ...}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nnew java.io.File(\"f\")\n```\n\nLANGUAGE: Scala\nCODE:\n```\nnew List[Int]\n```\n\nLANGUAGE: Scala\nCODE:\n```\nList(1, 2, 3)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclassOf[String]\n```\n\nLANGUAGE: Scala\nCODE:\n```\nx.isInstanceOf[String]\n```\n\nLANGUAGE: Scala\nCODE:\n```\nx.asInstanceOf[String]\n```\n\nLANGUAGE: Scala\nCODE:\n```\nx: String\n```\n\n----------------------------------------\n\nTITLE: Evaluating an Expression in Scala\nDESCRIPTION: Demonstrates a simple arithmetic expression that computes the sum of two integers. No external dependencies are required. Useful for illustrating basic computation syntax; inputs are integer literals, output is an integer result.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n1 + 1\n```\n\n----------------------------------------\n\nTITLE: Defining a Multiline String in Scala\nDESCRIPTION: This code demonstrates how to create a multiline string using triple double-quote syntax in Scala. The resulting string preserves line breaks and indentation from the source, and is stored in the variable quote. No dependencies are required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/first-look-at-types.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval quote = \"\"\"The essence of Scala:\n               Fusion of functional and object-oriented\n               programming in a typed setting.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Method Parameters with Default Values in Scala 2 and 3\nDESCRIPTION: Defines a method with a parameter that has a default value (timeout = 5000). This allows calls to the method without explicitly providing all arguments, with defaults applied as needed. Useful for simplifying method invocations with optional parameters. Input parameters are url (String) and optional timeout (Int), output is Unit with a printed message.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-methods.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef makeConnection(url: String, timeout: Int = 5000): Unit =\n  println(s\"url=$url, timeout=$timeout\")\n```\n\n----------------------------------------\n\nTITLE: Implementing getStackTraceAsString in Scala 2\nDESCRIPTION: Provides a practical example of a multiline method in Scala 2 that takes a `Throwable`, uses `java.io.StringWriter` and `java.io.PrintWriter` to capture the stack trace content, and returns it as a String. Requires importing Java IO classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport java.io.{PrintWriter, StringWriter}\n\ndef getStackTraceAsString(t: Throwable): String = {\n  val sw = new StringWriter()\n  t.printStackTrace(new PrintWriter(sw))\n  sw.toString\n}\n```\n\n----------------------------------------\n\nTITLE: Finding First Occurrence in File and Handling Future Completion - Scala\nDESCRIPTION: Finds the index of the first occurrence of a specific keyword in a file asynchronously, using a Future. Handles both success and failure cases with onComplete, printing the result or any file processing error. Requires scala.concurrent.Future and scala.util.{Success, Failure}. Input: a file name and keyword string. Output: printed result or error message.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nval firstOccurrence: Future[Int] = Future {\n  val source = scala.io.Source.fromFile(\"myText.txt\")\n  source.toSeq.indexOfSlice(\"myKeyword\")\n}\n\nfirstOccurrence.onComplete {\n  case Success(idx) => println(\"The keyword first appears at position: \" + idx)\n  case Failure(t) => println(\"Could not process file: \" + t.getMessage)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Singleton Object in Scala\nDESCRIPTION: Demonstrates the definition of a singleton object in Scala using the 'object' keyword, which contains a method 'sum' to compute the sum of an integer list. This object encapsulates functionality that is globally accessible without instantiating a class. Dependencies include the standard Scala collections library for the List type. The method 'sum' accepts a List[Int] as input and returns an Int representing the sum. This pattern replaces static methods from languages like Java and provides a thread-safe, single-instance access point.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/singleton-objects.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\npackage test\n\nobject Blah {\n  def sum(l: List[Int]): Int = l.sum\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Futures with For Expression in Scala\nDESCRIPTION: Uses a Scala `for` expression to combine the results of multiple independent `Future` instances (`aaplFuture`, `amznFuture`, `googFuture`). The `yield` keyword collects the successful results into a tuple wrapped in a new `Future`, which completes only after all source futures complete.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/futures.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nval result: Future[(Double, Double, Double)] = for {\n    aapl <- aaplFuture\n    amzn <- amznFuture\n    goog <- googFuture\n} yield (aapl, amzn, goog)\n```\n\n----------------------------------------\n\nTITLE: Creating and Running a Simple Scala Program with Scala CLI scala\nDESCRIPTION: A Scala source file example demonstrating the definition of a `@main` method named `hello` that prints \"Hello, World!\" to standard output. The snippet shows how to define the program entry point using an annotation, with the method returning `Unit`. This example requires Scala CLI for compilation and execution. Running `scala run hello.scala` will compile and execute the program, outputting the greeting.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/getting-started/install-scala.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n//> using scala {{site.scala-3-version}}\n\n@main\ndef hello(): Unit =\n  println(\"Hello, World!\")\n```\n\n----------------------------------------\n\nTITLE: Applying map Method to Lists in Scala\nDESCRIPTION: Demonstrates the `map` method, which applies a function to each element of a sequence and returns a new sequence containing the results. Examples show transforming numbers, capitalizing strings, and mapping numbers to boolean values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/collections-methods.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval doubles = nums.map(_ * 2)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval doubles = nums.map(i => i * 2)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval capNames = names.map(_.capitalize)\nval doubles = nums.map(_ * 2)\nval lessThanFive = nums.map(_ < 5)\n```\n\n----------------------------------------\n\nTITLE: Defining a minimal Scala case class\nDESCRIPTION: This snippet shows how to define a simple case class named 'Book' with a single parameter and instantiate an object without using the 'new' keyword, leveraging the automatic 'apply' method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/case-classes.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Book(isbn: String)\n\nval frankenstein = Book(\"978-0486282114\")\n```\n\n----------------------------------------\n\nTITLE: Processing Multiple Options with For-Comprehension (Scala)\nDESCRIPTION: Shows how to use a `for`/`yield` comprehension to elegantly process multiple `Option` results from `toInt`. The comprehension yields `Some(sum)` only if all conversions succeed (the \"Happy Path\"); otherwise, it yields `None` (the \"Unhappy Path\"), simplifying code that depends on multiple optional values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/no-null-values.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval y = for {\n    a <- toInt(stringA)\n    b <- toInt(stringB)\n    c <- toInt(stringC)\n} yield a + b + c\n```\n\n----------------------------------------\n\nTITLE: Declaring Immutable Fields with val in Scala\nDESCRIPTION: In Scala, the `val` keyword is used to declare an immutable variable (field). Once initialized, its value cannot be reassigned.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nval i = 1\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running a Scala Application\nDESCRIPTION: Shell commands showing how to compile a Scala source file using scalac and then run the compiled application using scala. This demonstrates the workflow for Scala development.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/command-line-io.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n$ scalac HelloInteractive.scala\n```\n\nLANGUAGE: sh\nCODE:\n```\n$ scala HelloInteractive\n```\n\n----------------------------------------\n\nTITLE: Non-Exhaustive Sealed Match - Scala 3\nDESCRIPTION: Demonstrates how pattern matching on a `sealed` type helps the compiler check for exhaustivity using Scala 3 syntax. When a `case` for a subtype (`VoiceRecording`) is missing, the compiler issues a warning indicating the potential failure case. Requires `sealed trait Notification` and its subtypes (`Email`, `SMS`, `VoiceRecording`) to be defined in the same file.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/pattern-matching.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ndef showNotification(notification: Notification): String =\n  notification match\n    case Email(sender, title, _) =>\n      s\"You got an email from $sender with title: $title\"\n    case SMS(number, message) =>\n      s\"You got an SMS from $number! Message: $message\"\n```\n\n----------------------------------------\n\nTITLE: Pattern matching on Notification case classes in Scala\nDESCRIPTION: Implements 'showNotification' function that matches 'Notification' objects against specific case classes, extracting relevant data like sender, title, message, and link. It demonstrates data deconstruction and conditional processing based on notification type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/pattern-matching.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef showNotification(notification: Notification): String = {\n  notification match {\n    case Email(sender, title, _) =>\n      s\"You got an email from $sender with title: $title\"\n    case SMS(number, message) =>\n      s\"You got an SMS from $number! Message: $message\"\n    case VoiceRecording(name, link) =>\n      s\"you received a Voice Recording from $name! Click the link to hear it: $link\"\n  }\n}\nval someSms = SMS(\"12345\", \"Are you there?\")\nval someVoiceRecording = VoiceRecording(\"Tom\", \"voicerecording.org/id/123\")\n\nprintln(showNotification(someSms))  // prints You got an SMS from 12345! Message: Are you there?\n\nprintln(showNotification(someVoiceRecording))  // you received a Voice Recording from Tom! Click the link to hear it: voicerecording.org/id/123\n```\n\n----------------------------------------\n\nTITLE: Deserializing JSON to a Case Class in Scala 2 using uPickle\nDESCRIPTION: Provides a full example of deserializing a JSON string into a custom `PetOwner` case class in Scala 2. It includes defining the case class, providing the implicit `ReadWriter` via `macroRW`, calling `upickle.default.read`, and accessing the resulting object's properties. Requires the uPickle library.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-deserialize.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport upickle.default._\n\ncase class PetOwner(name: String, pets: List[String])\nimplicit val ownerRw: ReadWriter[PetOwner] = macroRW\n\nval json = \"\"\"{\"name\": \"Peter\", \"pets\": [\"Toolkitty\", \"Scaniel\"]}\"\"\"\nval petOwner: PetOwner = read[PetOwner](json)\n\nval firstPet = petOwner.pets.head\nprintln(s\"${petOwner.name} has a pet called $firstPet\")\n// prints: Peter has a pet called Toolkitty\n```\n\n----------------------------------------\n\nTITLE: Implementing Symbolic Derivation Function with Pattern Matching in Scala 3\nDESCRIPTION: Defines the same symbolic derivative function derive as in Scala 2, using Scala 3's updated syntax (dot notation for import, optional curly braces and parentheses). The function expects a Tree t and a variable name v, pattern matches on t to apply derivation rules for sums and variables, and defaults to Const(0) otherwise. Requires the presence of Tree data structure and properly imported Tree.*, returning a new Tree representing the derivative.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\nimport Tree.*\n\ndef derive(t: Tree, v: String): Tree = t match\n  case Sum(left, right)        => Sum(derive(left, v), derive(right, v))\n  case Var(n) if v == n => Const(1)\n  case _                => Const(0)\n```\n\n----------------------------------------\n\nTITLE: Using 'match' expression as the body of a Scala method\nDESCRIPTION: Defines a Scala method 'convertBooleanToStringMessage' demonstrating the use of a 'match' expression directly as method body, matching Boolean values to specific String messages, with examples of how to call and print the result.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/match-expressions.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef convertBooleanToStringMessage(bool: Boolean): String = bool match {\n    case true => \"you said true\"\n    case false => \"you said false\"\n}\n\nval result = convertBooleanToStringMessage(true)\nprintln(result)\n```\n\n----------------------------------------\n\nTITLE: Parameterized Scala 3 Enum 'Color' with RGB Values\nDESCRIPTION: This code shows a Scala 3 enum 'Color' with a constructor parameter 'rgb', representing the color's RGB code. Each enum case supplies a specific RGB value, enabling color manipulation and comparison.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\nenum Color(val rgb: Int):\n  case Red   extends Color(0xFF0000)\n  case Green extends Color(0x00FF00)\n  case Blue  extends Color(0x0000FF)\n```\n\n----------------------------------------\n\nTITLE: Scala Classes for Data Encapsulation in Scala 3\nDESCRIPTION: Scala 3 version of Person class with constructor fields and method, demonstrating object creation and field manipulation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-modeling.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nclass Person(var firstName: String, var lastName: String):\n  def printFullName() = println(s\"$firstName $lastName\")\n\nval p = Person(\"John\", \"Stephens\")\nprintln(p.firstName)   // \"John\"\np.lastName = \"Legend\"\np.printFullName()      // \"John Legend\"\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Function with Caching in Scala\nDESCRIPTION: This code snippet demonstrates how to create a caching mechanism for an expensive function using a mutable Map. It shows how getOrElseUpdate can be used to efficiently cache function results and avoid redundant calculations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/maps.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval cache = collection.mutable.Map[String, String]()\ndef f(x: String) = {\n       println(\"taking my time.\"); sleep(100)\n       x.reverse }\ndef cachedF(s: String) = cache.getOrElseUpdate(s, f(s))\n```\n\n----------------------------------------\n\nTITLE: Composing String and Rich Iterators (Scala)\nDESCRIPTION: Demonstrates the power of mixins by defining `RichStringIter` that extends the concrete `StringIterator` and mixes in the `RichIterator` trait. This class automatically gains both the string iteration logic and the `foreach` method, showcasing effective code reuse and composition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/mixin-class-composition.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass RichStringIter extends StringIterator(\"Scala\") with RichIterator\nval richStringIter = new RichStringIter\nrichStringIter.foreach(println)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass RichStringIter extends StringIterator(\"Scala\"), RichIterator\nval richStringIter = RichStringIter()\nrichStringIter.foreach(println)\n```\n\n----------------------------------------\n\nTITLE: Launching the Scala REPL Session - Scala\nDESCRIPTION: Demonstrates how to start the Scala REPL from the command line using the 'scala' command, and shows the initial welcome message and prompt. No dependencies are required aside from having Scala installed on your operating system. This snippet illustrates the initial interaction between the user and the REPL environment.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/scala-repl.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n$ scala\nWelcome to Scala 2.13.0 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_131).\nType in expressions for evaluation. Or try :help.\n\nscala> _\n```\n\n----------------------------------------\n\nTITLE: Scala Object Main with @main Annotation\nDESCRIPTION: This snippet defines a Scala object with a `@main` annotated method `run()`, which serves as the program entry point. Inside the method, it creates a sequence of ages and prints the maximum age. This modern approach simplifies defining executable Scala programs compared to traditional main method definitions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/getting-started/intellij-track/building-a-scala-project-with-intellij-and-sbt.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n@main def run() =\n  val ages = Seq(42, 75, 29, 64)\n  println(s\"The oldest person is ${ages.max}\")\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Methods for Pizza with Extension Syntax in Scala 3\nDESCRIPTION: Uses Scala 3's extension syntax to provide additional methods—price, addTopping, removeAllToppings, updateCrustSize, updateCrustType—directly on Pizza instances. This approach eliminates the need for implicit classes and encourages clearer modular extension. Prerequisites include prior definitions for pizzaPrice and all involved domain types. These methods allow external, modular additions to a data model, making them accessible wherever the extension is imported.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-fp.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Pizza(\n  crustSize: CrustSize,\n  crustType: CrustType,\n  toppings: Seq[Topping]\n)\n\nextension (p: Pizza)\n  def price: Double =\n    pizzaPrice(p) // implementation from above\n\n  def addTopping(t: Topping): Pizza =\n    p.copy(toppings = p.toppings :+ t)\n\n  def removeAllToppings: Pizza =\n    p.copy(toppings = Seq.empty)\n\n  def updateCrustSize(cs: CrustSize): Pizza =\n    p.copy(crustSize = cs)\n\n  def updateCrustType(ct: CrustType): Pizza =\n    p.copy(crustType = ct)\n```\n\n----------------------------------------\n\nTITLE: Defining Anonymous given Instances Using Proposed Scala 3 Syntax in Scala\nDESCRIPTION: Illustrates the new proposed syntax for anonymous given definitions in Scala 3, which removes the 'with' keyword and uses colons more naturally to start the implementation body. Conditional givens use implication arrows '=>', representing type constraints or contexts. This approach aligns given definitions with type implementations and context functions, improving code clarity and consistency.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\n  // Simple typeclass\n  given Ord[String]:\n    def compare(x: String, y: String) = ...\n\n  // Parameterized typeclass with context bound\n  given [A: Ord] => Ord[List[A]]:\n    def compare(x: List[A], y: List[A]) = ...\n```\n\n----------------------------------------\n\nTITLE: Using for-comprehension with flatMap and withFilter for Futures in Scala 2\nDESCRIPTION: Illustrates using 'for' comprehensions to combine multiple Futures by flatMapping over two currency quotes (USD and CHF) and filtering based on profitability condition. The result Future completes only after both quotes and the profitability condition are satisfied, triggering a purchase operation. Demonstrates more readable composition of asynchronous computations and filtering within Futures.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\nval usdQuote = Future { connection.getCurrentValue(USD) }\nval chfQuote = Future { connection.getCurrentValue(CHF) }\n\nval purchase = for {\n  usd <- usdQuote\n  chf <- chfQuote\n  if isProfitable(usd, chf)\n} yield connection.buy(amount, chf)\n\npurchase foreach { amount =>\n  println(\"Purchased \" + amount + \" CHF\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Enumerations in Scala 3\nDESCRIPTION: Examples of creating different types of enumerations in Scala 3, including simple enums, parameterized enums, and enums with user-defined members.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_37\n\nLANGUAGE: scala\nCODE:\n```\nenum Color:\n  case Red, Green, Blue\n```\n\nLANGUAGE: scala\nCODE:\n```\nenum Color(val rgb: Int):\n  case Red   extends Color(0xFF0000)\n  case Green extends Color(0x00FF00)\n  case Blue  extends Color(0x0000FF)\n```\n\nLANGUAGE: scala\nCODE:\n```\nenum Planet(mass: Double, radius: Double):\n  case Mercury extends Planet(3.303e+23, 2.4397e6)\n  case Venus   extends Planet(4.869e+24,6.0518e6)\n  case Earth   extends Planet(5.976e+24,6.37814e6)\n  // more planets here ...\n\n  private final val G = 6.67300E-11\n  def surfaceGravity = G * mass / (radius * radius)\n  def surfaceWeight(otherMass: Double) = otherMass * surfaceGravity\n```\n\n----------------------------------------\n\nTITLE: Using If Guards in Scala 3 Case Clauses\nDESCRIPTION: Demonstrates using `if` conditions (guards) within `case` clauses of a Scala 3 match expression (using indentation syntax) to match against multiple integer values or conditions, providing specific output for matched cases and a default fallback.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\ni match\n  case 1 => println(\"one, a lonely number\")\n  case x if x == 2 || x == 3 => println(\"two’s company, three’s a crowd\")\n  case x if x > 3 => println(\"4+, that’s a party\")\n  case _ => println(\"i’m guessing your number is zero or less\")\n```\n\n----------------------------------------\n\nTITLE: Tworzenie i dostęp do parametrów niemutowalnej case class w Scali\nDESCRIPTION: Pokazuje definicję klasy przypadku z trzema parametrami, które są publiczne i niemutowalne (val). Przykład tworzy instancję oraz demonstruje, że próba zmiany wartości parametru nie skompiluje się, podkreślając niemutowalność typową dla klas przypadków. Zaleca się unikanie parametru var pomimo możliwości jego użycia.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/case-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class Message(sender: String, recipient: String, body: String)\nval message1 = Message(\"guillaume@quebec.ca\", \"jorge@catalonia.es\", \"Ça va ?\")\n\nprintln(message1.sender)  // wypisze guillaume@quebec.ca\nmessage1.sender = \"travis@washington.us\"  // ten wiersz nie skompiluje się\n```\n\n----------------------------------------\n\nTITLE: Using Named Parameters in Scala Function Calls\nDESCRIPTION: This example demonstrates how to call a function using positional parameters or named parameters. When using named parameters, the order of arguments doesn't matter as long as all required parameters are specified.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/named-arguments.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef imprimeNome(nome:String, sobrenome:String) = {\n  println(nome + \" \" + sobrenome)\n}\n\nimprimeNome(\"John\",\"Smith\") // Imprime \"John Smith\"\nimprimeNome(nome = \"John\",sobrenome = \"Smith\") // Imprime \"John Smith\"\nimprimeNome(sobrenome = \"Smith\",nome = \"John\") // Imprime \"John Smith\"\n```\n\n----------------------------------------\n\nTITLE: Accessing Class Fields in Scala\nDESCRIPTION: Examples of how to access fields of a class instance in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-tools.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\np.name       // \"Robert Allen Zimmerman\"\np.vocation   // \"Harmonica Player\"\n```\n\n----------------------------------------\n\nTITLE: Evaluating Conditionals with If/Else in Scala 3\nDESCRIPTION: Checks the sign of a value x and prints 'negative', 'zero', or 'positive' using Scala 3 indentation-based syntax. No dependencies required; x must be numeric and defined. The structure triggers output via side effects for each condition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nif x < 0 then\n  println(\"negative\")\nelse if x == 0 then\n  println(\"zero\")\nelse\n  println(\"positive\")\n\n```\n\n----------------------------------------\n\nTITLE: Pattern matching on Notification case classes with Scala match - Scala\nDESCRIPTION: Defines a function showNotification that accepts a Notification object and uses pattern matching to destructure it into its case class components. It returns a formatted String describing the notification content. This uses case patterns to bind variables to fields, ignores some fields with underscores, and covers all subtypes without a default case, relying on exhaustiveness. The snippet also demonstrates instantiation of case classes and printing results.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/pattern-matching.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef showNotification(notification: Notification): String = {\n  notification match {\n    case Email(sender, title, _) =>\n      s\"You got an email from $sender with title: $title\"\n    case SMS(number, message) =>\n      s\"You got an SMS from $number! Message: $message\"\n    case VoiceRecording(name, link) =>\n      s\"you received a Voice Recording from $name! Click the link to hear it: $link\"\n  }\n}\nval someSms = SMS(\"12345\", \"Are you there?\")\nval someVoiceRecording = VoiceRecording(\"Tom\", \"voicerecording.org/id/123\")\n\nprintln(showNotification(someSms))  // You got an SMS from 12345! Message: Are you there? が出力されます。\n\nprintln(showNotification(someVoiceRecording))  // you received a Voice Recording from Tom! Click the link to hear it: voicerecording.org/id/123 が出力されます。\n```\n\n----------------------------------------\n\nTITLE: Combining Higher-Order Functions for List Transformation in Scala\nDESCRIPTION: This snippet demonstrates chained use of filter, takeWhile, and map methods on a Scala List to perform a multi-step data transformation. Inputs are List[Int], outputs are transformed lists. There are no dependencies. This pattern is key for functional composition and fluent data pipelines in Scala, and shows how method chaining can solve complex problems with concise code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-methods.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// yields `List(100, 200)`\na.filter(_ < 40)\n .takeWhile(_ < 30)\n .map(_ * 10)\n```\n\n----------------------------------------\n\nTITLE: Using 'fallbackTo' for Future Result Fallback in Scala\nDESCRIPTION: This snippet demonstrates using 'fallbackTo' to provide a fallback future in case the primary future fails, such as attempting to get USD value and falling back to CHF value if the USD fetch fails, exemplifying fault-tolerant asynchronous design.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\nval finalQuote = usdQuote fallbackTo chfQuote\n```\n\n----------------------------------------\n\nTITLE: Defining Anonymous and Named Functions\nDESCRIPTION: Demonstrates creating anonymous functions with '=>', assigning functions to variables, and invoking them, showing Scala's support for first-class functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/basics.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\n(x: Int) => x + 1\nval addOne = (x: Int) => x + 1\nprintln(addOne(1)) // 2\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval add = (x: Int, y: Int) => x + y\nprintln(add(1, 2)) // 3\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval getTheAnswer = () => 42\nprintln(getTheAnswer()) // 42\n```\n\n----------------------------------------\n\nTITLE: Accessing Companion Object Members and Private Scope in Scala\nDESCRIPTION: Shows how a Scala class `X` can import and utilize members from its companion object `X`. This pattern serves as an alternative to Java's `static` members. The example defines a private method `foo` in the companion object `X` and accesses it from within the class `X`. It highlights that a class and its companion object share access to each other's private members.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/singleton-objects.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass X {\n  import X._\n\n  def blah = foo\n}\n\nobject X {\n  private def foo = 42\n}\n```\n\n----------------------------------------\n\nTITLE: Looping Over a Scala List with For-Comprehension - Scala\nDESCRIPTION: The snippet demonstrates iteration over a Scala List using a for-comprehension to print each element. No external imports or dependencies are required. Input is a List of strings and output consists of printed elements to the standard output, making this a general-purpose example for sequence traversal in Scala collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/list-class.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval names = List(\"Joel\", \"Chris\", \"Ed\")\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor (name <- names) println(name)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nscala> for (name <- names) println(name)\nJoel\nChris\nEd\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Mutable HashMap in Scala\nDESCRIPTION: Demonstrates initializing an empty mutable `HashMap[Int, String]`, adding key-value pairs using `+=`, retrieving a value by key using `map(key)`, and checking for key existence using `contains`. HashMaps provide efficient average time complexity for these operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-mutable-collection-classes.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nscala> val map = scala.collection.mutable.HashMap.empty[Int,String]\nmap: scala.collection.mutable.HashMap[Int,String] = Map()\nscala> map += (1 -> \"make a web site\")\nres42: map.type = Map(1 -> make a web site)\nscala> map += (3 -> \"profit!\")\nres43: map.type = Map(1 -> make a web site, 3 -> profit!)\nscala> map(1)\nres44: String = make a web site\nscala> map contains 2\nres46: Boolean = false\n```\n\n----------------------------------------\n\nTITLE: Using named arguments in Scala 2 and 3\nDESCRIPTION: Illustrates calling a method with named parameters for clarity and flexibility, especially useful with multiple parameters of the same type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-methods.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nmakeConnection(\n  url = \"https://localhost\",\n  timeout = 2500\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterless Methods with and without Parentheses in Scala\nDESCRIPTION: Explains the convention of using parentheses in parameterless method declarations to indicate side effects. Methods without parentheses indicate pure accessors returning consistent values without side effects. Includes notes on Scala 2 vs Scala 3 restrictions and standard library practices.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/naming-conventions.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ndef foo1() = ...\n\ndef foo2 = ...\n```\n\n----------------------------------------\n\nTITLE: Defining a Single-Parameter Method with Explicit Return Type in Scala\nDESCRIPTION: Defines the `double` method again, this time explicitly declaring the method's return type as `Int` using the `: Int` syntax after the parameter list. Explicit return types are optional for single-expression methods but improve code clarity and can help prevent errors.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/methods-first-look.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef double(a: Int): Int = a * 2\n```\n\n----------------------------------------\n\nTITLE: Defining an Implicit Conversion using 'implicit def' in Scala 2\nDESCRIPTION: Illustrates the Scala 2 approach to defining an implicit conversion from `Int` to `Long` using an `implicit def`. This method converts an `Int` to a `Long` using `toLong`. The import `scala.language.implicitConversions` is required to suppress compiler warnings related to defining implicit conversions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-implicit-conversions.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.language.implicitConversions\n\nimplicit def int2long(x: Int): Long = x.toLong\n```\n\n----------------------------------------\n\nTITLE: Compiler Desugaring of Custom Interpolator Call in Scala 3\nDESCRIPTION: Explains how the Scala 3 compiler transforms a custom interpolator call like `p\"1, $someVar\"`. It creates a `StringContext` instance with the static string parts (`\"1, \"`, `\"\"`) and directly calls the extension method `p` on it, passing the evaluated expression (`someVar`) as an argument.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nStringContext(\"1, \",\"\").p(someVar)\n```\n\n----------------------------------------\n\nTITLE: 値の定義と利用 - Scala\nDESCRIPTION: valキーワードを用いて式の結果に名前をつけ不変の値を定義し、その値を参照・出力する例です。再代入不可であるため、初期化後の変更はコンパイルエラーになります。型推論機能を使用していますが、明示的な型指定も可能です。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval x = 1 + 1\nprintln(x) // 2\n```\n\n----------------------------------------\n\nTITLE: Defining Top-Level Constructs Using Scala 3 Features - Scala\nDESCRIPTION: This snippet demonstrates declaring various top-level definitions in a Scala 3 source file, including imports, enums, classes, extension methods, type aliases, and a main method. Dependencies include the Scala standard library and scala.collection.mutable for ArrayBuffer. It illustrates how to define an enum for pizza toppings, a Pizza class holding toppings, an extension method to capitalize all words in a string, and a main entry point that uses these constructs. Inputs include usage of the capitalizeAllWords method and Pizza instances, with console output as expected output. There are no enclosing package or class definitions, showcasing Scala 3's syntax for top-level definitions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-toplevel-definitions.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.mutable.ArrayBuffer\n\nenum Topping:\n  case Cheese, Pepperoni, Mushrooms\n\nimport Topping.*\nclass Pizza:\n  val toppings = ArrayBuffer[Topping]()\n\nval p = Pizza()\n\nextension (s: String)\n  def capitalizeAllWords = s.split(\" \").map(_.capitalize).mkString(\" \")\n\nval hwUpper = \"hello, world\".capitalizeAllWords\n\ntype Money = BigDecimal\n\n// more definitions here as desired ...\n\n@main def myApp =\n  p.toppings += Cheese\n  println(\"show me the code\".capitalizeAllWords)\n```\n\n----------------------------------------\n\nTITLE: Using Pattern Matching on Scala Case Classes to Handle Notifications\nDESCRIPTION: Defines a function 'showNotification' which takes a Notification instance and uses pattern matching to destructure the case classes Email, SMS, and VoiceRecording to produce customized notification messages. Demonstrates pattern matching on case classes with variable binding to extract fields for message construction. Includes example calls with print outputs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/case-classes.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef showNotification(notification: Notification): String = {\n  notification match {\n    case Email(email, title, _) =>\n      \"You got an email from \" + email + \" with title: \" + title\n    case SMS(number, message) =>\n      \"You got an SMS from \" + number + \"! Message: \" + message\n    case VoiceRecording(name, link) =>\n      \"you received a Voice Recording from \" + name + \"! Click the link to hear it: \" + link\n  }\n}\n\nval someSms = SMS(\"12345\", \"Are you there?\")\nval someVoiceRecording = VoiceRecording(\"Tom\", \"voicerecording.org/id/123\")\n\nprintln(showNotification(someSms))\nprintln(showNotification(someVoiceRecording))\n```\n\n----------------------------------------\n\nTITLE: Defining a Graph with Inner Nodes Using Path-Dependent Types in Scala 2\nDESCRIPTION: Implements a Graph class containing an inner Node class where each Node maintains connections to other nodes within the same graph via a list. The use of a path-dependent type (Node nested inside Graph) enforces that nodes belong to the specific Graph instance, preventing the mixing of nodes across different graph instances at compile time. Key methods include creating new nodes and connecting nodes. Dependencies include the Scala standard library; no external libraries are needed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/inner-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Graph {\n  class Node {\n    var connectedNodes: List[Node] = Nil\n    def connectTo(node: Node): Unit = {\n      if (!connectedNodes.exists(node.equals)) {\n        connectedNodes = node :: connectedNodes\n      }\n    }\n  }\n  var nodes: List[Node] = Nil\n  def newNode: Node = {\n    val res = new Node\n    nodes = res :: nodes\n    res\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Map and Filter Combined with Filter-Map Chain and For-Yield in Scala\nDESCRIPTION: First filters even numbers, then maps the result multiplying each by 10, or alternatively uses a single 'for-yield' comprehension combining filtering and mapping with 'if' guard.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_30\n\nLANGUAGE: Scala\nCODE:\n```\nval x = numbers.filter(_ % 2 == 0).map(_ * 10)\n// or\nval x = for i <- numbers if i % 2 == 0 yield i * 10\n```\n\n----------------------------------------\n\nTITLE: Filtering and transforming a list in Scala using 'filter' and 'map' (Scala 2 & 3)\nDESCRIPTION: This snippet demonstrates how to process an immutable list of strings by filtering names that start with 'j' and converting them to capitalized form, highlighting functional programming principles of non-mutability and composition. Requires Scala 2 or 3 and the standard library collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fp-immutable-values.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval a = List(\"jane\", \"jon\", \"mary\", \"joe\")\nval b = a.filter(_.startsWith(\"j\"))\n         .map(_.capitalize)\n```\n\n----------------------------------------\n\nTITLE: Creating Instance of Scala Case Class Person (Scala 2 and 3)\nDESCRIPTION: Demonstrates creating an instance of the Person case class using positional arguments. The fields are immutable, thus cannot be reassigned after creation. Shows usage of the case class constructor and enforced immutability of fields.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-tools.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nval christina = Person(\"Christina\", \"niece\")\n```\n\n----------------------------------------\n\nTITLE: Sample build.sbt for a Simple sbt Project - Scala\nDESCRIPTION: This build.sbt snippet contains typical key settings to identify the project name, version, and Scala version used. It is sufficient for a simple Scala sbt project using conventional directory structures. The 'name' provides a project identifier, 'version' specifies the build version, and 'scalaVersion' sets the compiler version.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nname := \"HelloWorld\"\nversion := \"0.1\"\nscalaVersion := \"{{ site.scala-3-version }}\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Multiline Method in Scala 3\nDESCRIPTION: Illustrates defining a method (`addThenDouble`) with a body spanning multiple lines in Scala 3 using indentation rather than curly braces. The method calculates a sum and returns the doubled sum. The last expression is the return value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef addThenDouble(a: Int, b: Int): Int =\n  // imagine that this body requires multiple lines\n  val sum = a + b\n  sum * 2\n```\n\n----------------------------------------\n\nTITLE: Single-Line Method Definition in Scala 3\nDESCRIPTION: Defines a concise Scala method add using expression syntax that sums two Int parameters and returns the result. Demonstrates Scala's ability to declare simple methods in a single line without braces or return keywords.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\ndef add(a: Int, b: Int): Int = a + b\n```\n\n----------------------------------------\n\nTITLE: Defining Methods with Default Parameters in Scala 3\nDESCRIPTION: Shows how to define a method (`makeConnection`) in Scala 3 with default values specified for its parameters (`timeout = 5_000`, `protocol = \"http\"`). Uses indentation-based syntax for the method body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ndef makeConnection(timeout: Int = 5_000, protocol: String = \"http\") =\n  println(f\"timeout = ${timeout}%d, protocol = ${protocol}%s\")\n  // more code here ...\n```\n\n----------------------------------------\n\nTITLE: Using if as expression to assign a value\nDESCRIPTION: Demonstrates that Scala's if/then/else is an expression that returns a value, which can be assigned to a variable. Highlights the absence of a ternary operator, emphasizing expression-oriented programming.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/if-then-else-construct.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval minValue = if (a < b) a else b\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Partial Application with foldLeft in Scala\nDESCRIPTION: Shows how calling a method with multiple parameter lists using only the first list results in a function that takes the remaining parameter lists. This enables partial application, allowing the creation of specialized functions (e.g., `numberFunc`) that can be reused with different arguments for the later parameter lists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/multiple-parameter-lists.md#_snippet_7\n\nLANGUAGE: Scala 2\nCODE:\n```\nval numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nval numberFunc = numbers.foldLeft(List[Int]()) _\n\nval squares = numberFunc((xs, x) => xs :+ x*x)\nprintln(squares) // List(1, 4, 9, 16, 25, 36, 49, 64, 81, 100)\n\nval cubes = numberFunc((xs, x) => xs :+ x*x*x)\nprintln(cubes)  // List(1, 8, 27, 64, 125, 216, 343, 512, 729, 1000)\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nval numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nval numberFunc = numbers.foldLeft(List[Int]())\n\nval squares = numberFunc((xs, x) => xs :+ x*x)\nprintln(squares) // List(1, 4, 9, 16, 25, 36, 49, 64, 81, 100)\n\nval cubes = numberFunc((xs, x) => xs :+ x*x*x)\nprintln(cubes)  // List(1, 8, 27, 64, 125, 216, 343, 512, 729, 1000)\n```\n\n----------------------------------------\n\nTITLE: Using 'Showable' in Scala 3 to print a person's info\nDESCRIPTION: Creates a 'Person' instance and prints its string representation using extension method 'show', illustrating Scala 3's syntax for type class usage.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-type-classes.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval person = Person(\"John\", \"Doe\")\nprintln(person.show)\n```\n\n----------------------------------------\n\nTITLE: Using Future with fallbackTo for currency quotes in Scala\nDESCRIPTION: Fetches current currency values asynchronously for USD and CHF, then uses fallbackTo to provide a default quote if the primary fetch fails. Outputs formatted currency value strings. Depends on the `connection` object and the `Future` API.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\nval usdQuote = Future {\n  connection.getCurrentValue(USD)\n}.map {\n  usd => \"Value: \" + usd + \"$\"\n}\nval chfQuote = Future {\n  connection.getCurrentValue(CHF)\n}.map {\n  chf => \"Value: \" + chf + \"CHF\"\n}\n\nval anyQuote = usdQuote.fallbackTo(chfQuote)\n\nanyQuote.foreach { println(_) }\n```\n\n----------------------------------------\n\nTITLE: Calling Methods with and without Default Parameters in Scala 2 and 3\nDESCRIPTION: Demonstrates calling a method that has default parameter values by passing one or both arguments. Shows that when the optional parameter is omitted, the default value is used. Inputs correspond to either only the mandatory parameter or both. Outputs are printed side effects from the method body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-methods.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nmakeConnection(\"https://localhost\")         // url=http://localhost, timeout=5000\nmakeConnection(\"https://localhost\", 2500)   // url=http://localhost, timeout=2500\n```\n\n----------------------------------------\n\nTITLE: Basic For-Comprehension with User Filtering in Scala\nDESCRIPTION: Example demonstrating how to use a for-comprehension to filter a list of users based on age criteria and yield their names. The example shows both the generator (user <- userBase) and filter (if user.age condition) components.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/for-comprehensions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class User(name: String, age: Int)\n\nval userBase = List(\n  User(\"Travis\", 28),\n  User(\"Kelly\", 33),\n  User(\"Jennifer\", 44),\n  User(\"Dennis\", 23))\n\nval twentySomethings =\n  for (user <- userBase if user.age >=20 && user.age < 30)\n  yield user.name  // т. е. добавить результат к списку\n\ntwentySomethings.foreach(println)  // выводит \"Travis Dennis\"\n```\n\n----------------------------------------\n\nTITLE: Using foreach for Side-Effects on Elements in Scala\nDESCRIPTION: This snippet demonstrates the foreach method on a List[String], printing each element to standard output. The method accepts a function (e.g., println) and applies it to each element for side effects. No dependencies are required. Input is a list of strings; output is not a new collection but the act of printing itself.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-methods.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nscala> names.foreach(println)\nadam\nbrandy\nchris\ndavid\n```\n\n----------------------------------------\n\nTITLE: Defining an Algebraic Data Type (ADT) with `enum` in Scala\nDESCRIPTION: Illustrates how to define an ADT, specifically a generic `Option` type, using the `enum` keyword in Scala 3. It includes a parameterized case (`Some`) and a simple case (`None`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-adts-gadts.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nenum Option[+T]:\n  case Some(x: T)\n  case None\n```\n\n----------------------------------------\n\nTITLE: Using Immutable ListMaps in Scala\nDESCRIPTION: Shows how to create an immutable `ListMap` with initial key-value pairs and access a value by its key using the `apply` method (e.g., `map(2)`). `ListMap` preserves insertion order but typically has linear time complexity for operations, making it less commonly used than other immutable maps.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-immutable-collection-classes.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nscala> val map = scala.collection.immutable.ListMap(1->\"one\", 2->\"two\")\nmap: scala.collection.immutable.ListMap[Int,java.lang.String] =\n    Map(1 -> one, 2 -> two)\nscala> map(2)\nres30: String = \"two\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Trait with Abstract Methods in Scala\nDESCRIPTION: Defines a generic trait 'Iterator[A]' with two abstract members: 'hasNext' of type Boolean and 'next()' returning a value of generic type A. This trait serves as an interface expecting implementations to provide these methods, useful for iterating collections of type A.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/traits.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntrait Iterator[A] {\n  def hasNext: Boolean\n  def next(): A\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Mutable Stack Class in Scala\nDESCRIPTION: This snippet defines a Scala class named Stack parametrized by a generic type T. It models a mutable stack with fundamental operations: push to add elements, top to retrieve the top element, and pop to remove the top element. The internal state is maintained as a List of type T. The use of generic types ensures type safety by allowing only elements of type T to be handled within the stack.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/generic-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Stack[T] {\n  var elems: List[T] = Nil\n  def push(x: T): Unit =\n    elems = x :: elems\n  def top: T = elems.head\n  def pop(): Unit = { elems = elems.tail }\n}\n```\n\n----------------------------------------\n\nTITLE: Matching multiple strings with 'match' in Scala\nDESCRIPTION: Shows pattern matching multiple string commands together, such as starting/stopping commands, with multiple options leading to the same action, leveraging pattern alternatives within 'case' clauses.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/match-expressions.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ncmd match {\n    case \"start\" | \"go\" => println(\"starting\")\n    case \"stop\" | \"quit\" | \"exit\" => println(\"stopping\")\n    case _ => println(\"doing nothing\")\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Generic Reference Container in Scala\nDESCRIPTION: Creates a generic Reference class that can hold values of any type. It demonstrates Scala's generics feature with type parameter T, allowing the creation of type-safe containers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tutorials/scala-for-java-programmers.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nclass Reference[T] {\n  private var contenu: T = _\n  def set(valeur: T) { contenu = valeur }\n  def get: T = contenu\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Comments in Java\nDESCRIPTION: Demonstrates the syntax for single-line (`//`), multi-line (`/* ... */`), and Javadoc (`/** ... */`) comments in Java.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\n//\n/* ... */\n/** ... */\n```\n\n----------------------------------------\n\nTITLE: Demonstrating `reify` Limitations for Function Abstraction in Scala\nDESCRIPTION: Shows a limitation of `reify` where attempting to abstract over a function name like `println` itself fails. `reify` requires valid, typeable Scala code and interprets `reify(println)` as reifying a call `println()` rather than capturing the function reference, leading to a type error when trying to splice arguments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\nscala> val fn = reify(println)\nfn: scala.reflect.runtime.universe.Expr[Unit] = Expr[Unit](scala.this.Predef.println())\n\nscala> reify(fn.splice(2))\n<console>:12: error: Unit does not take parameters\n            reify(fn.splice(2))\n                            ^\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Leaky Module Abstraction in Scala\nDESCRIPTION: Example showing how the module abstraction can leak implementation details. This code demonstrates how the type equality becomes visible to users when directly importing from the implementation module.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-opaque-types.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport LogarithmsImpl.*\nval l: Logarithm = make(1.0)\nval d: Double = l // type checks AND leaks the equality!\n```\n\n----------------------------------------\n\nTITLE: Appending Collection to Buffer in Scala\nDESCRIPTION: Appends all elements from a collection 'xs' to the end of the buffer 'buf'. This is an efficient way to merge another collection into the buffer.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/seqs.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nbuf ++= xs\n```\n\n----------------------------------------\n\nTITLE: Sending POST Request with String Body in Scala 3\nDESCRIPTION: This snippet demonstrates how to use sttp's quickRequest to send a POST request with a string body in Scala 3. The example uses the wildcard import syntax of Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/http-client-request-body.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport sttp.client4.quick.*\n\nval response = quickRequest\n  .post(uri\"https://example.com/\")\n  .body(\"Lorem ipsum\")\n  .send()\n\nprintln(response.code)\n// prints: 200\n```\n\n----------------------------------------\n\nTITLE: Implementing a Trait with Class Extension in Scala\nDESCRIPTION: Shows a complete example of a class `IntIterator` that extends the generic trait `Iterator[Int]`. It contains an upper bound parameter `to` and implements the abstract methods `hasNext` and `next`. The class uses a private mutable state variable `current` to iterate from zero up to `to`, safely returning next integer values as long as `hasNext` is true. Demonstrates overriding abstract members with `override` keyword and using the trait as an interface.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/tour/traits.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait Iterator[A] {\n  def hasNext: Boolean\n  def next(): A\n}\n\nclass IntIterator(to: Int) extends Iterator[Int] {\n  private var current = 0\n  override def hasNext: Boolean = current < to\n  override def next(): Int =  {\n    if (hasNext) {\n      val t = current\n      current += 1\n      t\n    } else 0\n  }\n}\n\n\nval iterator = new IntIterator(10)\niterator.next()  // returns 0\niterator.next()  // returns 1\n```\n\n----------------------------------------\n\nTITLE: Importing CollectionConverters in Scala 3\nDESCRIPTION: Shows how to import the CollectionConverters package in Scala 3, allowing implicit conversions between collections with updated syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/conversions-between-java-and-scala-collections.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.jdk.CollectionConverters.*\n```\n\n----------------------------------------\n\nTITLE: Class Definition Using Option for Optional Field (Scala)\nDESCRIPTION: Redefines the `Address` class using `Option[String]` for the `street2` field. This clearly marks the field as optional and forces consumers to handle the potential absence of a value safely using `Option` patterns.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/no-null-values.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nclass Address (\n    var street1: String,\n    var street2: Option[String],\n    var city: String, \n    var state: String, \n    var zip: String\n)\n```\n\n----------------------------------------\n\nTITLE: Partitioning Collections using partition in Scala\nDESCRIPTION: This Scala snippet demonstrates how to use the `partition` method available on collections. It takes a collection (`people`) and a predicate function (`_.age < 18`), splitting the collection into two new collections based on whether elements satisfy the predicate, returning them as a tuple. This method is a concise and efficient way to categorize collection elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/introduction.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval (minors, adults) = people partition (_.age < 18)\n```\n\n----------------------------------------\n\nTITLE: Using for-Expression with Iterator forelements in Scala\nDESCRIPTION: This code snippet demonstrates the use of Scala’s for-expression syntax to iterate over an iterator and perform an action (printing) for each item. It leverages the syntactic sugar provided for foreach and supports alternative iteration constructs. No special dependencies are needed. Input: a Scala Iterator. Output: prints each element. Limitation: The iterator is left at its end after traversal, further iteration will fail.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/iterators.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nfor (elem <- it) println(elem)\n```\n\n----------------------------------------\n\nTITLE: Executing a Two-Parameter Function and Printing Result in Scala\nDESCRIPTION: Defines a Scala method `executeAndPrint` that accepts a function `f` of type `(Int, Int) => Int` and two integer parameters `i` and `j`, then applies `f` to these integers and prints the result. This method facilitates passing different two-parameter functions like `sum` or `multiply` and prints their computed values. Suitable for Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-hofs.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\ndef executeAndPrint(f: (Int, Int) => Int, i: Int, j: Int): Unit =\n  println(f(i, j))\n```\n\n----------------------------------------\n\nTITLE: Using Union Types in Scala 3\nDESCRIPTION: Examples demonstrating Scala 3's union types feature, which allows accepting or returning values of different types that don't need to share a common hierarchy, expressed concisely using the | operator.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-introduction.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef isTruthy(a: Boolean | Int | String): Boolean = ???\ndef dogCatOrWhatever(): Dog | Plant | Car | Sun = ???\n```\n\n----------------------------------------\n\nTITLE: Semantic Preservation with Inline Parameters in Scala 3\nDESCRIPTION: This snippet explains how inline parameters are duplicated at call sites to enable constant folding and optimization. It illustrates usage with calculations and emphasizes the importance of single-use for inline parameters to avoid multiple evaluations of side-effects or costly expressions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ninline def perimeter(inline radius: Double): Double =\n  2.0 * pi * radius\n```\n\nLANGUAGE: Scala\nCODE:\n```\nperimeter(5.0)\n// becomes\n2.0 * pi * 5.0\n// inlined to\n2.0 * 3.141592653589793 * 5.0\n// finally constant folded to\n31.4159265359\n```\n\nLANGUAGE: Scala\nCODE:\n```\ninline def printPerimeter(inline radius: Double): Double =\n  println(s\"Perimeter (r = $radius) = ${perimeter(radius)}\")\n\nprintPerimeter(5.0)\n// inlined as\n// println(s\"Perimeter (r = ${5.0}) = ${31.4159265359}\")\n```\n\n----------------------------------------\n\nTITLE: Defining a higher-order method accepting a no-argument function in Scala\nDESCRIPTION: This snippet defines a method `sayHello` which takes a parameter `f` representing a function with no input parameters and returning Unit. The method executes the function `f` when called. It demonstrates how to declare function type signatures as method parameters and invoke them within the method body. This pattern is foundational for creating higher-order functions that accept behavior as inputs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-hofs.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef sayHello(f: () => Unit): Unit = f()\n```\n\n----------------------------------------\n\nTITLE: Defining an Opaque Type Logarithm in Scala\nDESCRIPTION: Defines the opaque type Logarithm as an alias for Double using the new 'opaque' keyword inside a package object. This hides the underlying representation externally while allowing it internally within the companion object. Requires Scala 3 or a compatible compiler supporting opaque types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/opaque-types.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\npackage object opaquetypes {\n  opaque type Logarithm = Double\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Scala Par Collection with Custom ForkJoinPool TaskSupport\nDESCRIPTION: Demonstrates setting a parallel collection's task support using a user-provided java.util.concurrent.ForkJoinPool instance via ForkJoinTaskSupport. It shows creating a mutable.ParArray, a ForkJoinPool with specific parallelism, assigning ForkJoinTaskSupport, and executing a parallel map operation. Proper shutdown of the custom pool is noted.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/configuration.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nscala> import scala.collection.parallel._\nimport scala.collection.parallel._\n\nscala> val pc = mutable.ParArray(1, 2, 3)\npc: scala.collection.parallel.mutable.ParArray[Int] = ParArray(1, 2, 3)\n\nscala> val forkJoinPool = new java.util.concurrent.ForkJoinPool(2)\nforkJoinPool: java.util.concurrent.ForkJoinPool = java.util.concurrent.ForkJoinPool@6436e181[Running, parallelism = 2, size = 0, active = 0, running = 0, steals = 0, tasks = 0, submissions = 0]\n\nscala> pc.tasksupport = new ForkJoinTaskSupport(forkJoinPool)\npc.tasksupport: scala.collection.parallel.TaskSupport = scala.collection.parallel.ForkJoinTaskSupport@4a5d484a\n\nscala> pc map { _ + 1 }\nres0: scala.collection.parallel.mutable.ParArray[Int] = ParArray(2, 3, 4)\n```\n\n----------------------------------------\n\nTITLE: Extending and Implementing Traits in Scala Classes\nDESCRIPTION: Provides an example of a class 'IntIterator' extending the 'Iterator[Int]' trait, implementing the abstract methods with specific behavior, and showcasing object instantiation and method calls demonstrating iteration over a range.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/traits.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass IntIterator(to: Int) extends Iterator[Int] {\n  private var current = 0\n  override def hasNext: Boolean = current < to\n  override def next(): Int =  {\n    if (hasNext) {\n      val t = current\n      current += 1\n      t\n    } else 0\n  }\n}\n\nval iterator = new IntIterator(10)\niterator.next()  // prints 0\niterator.next()  // prints 1\n```\n\n----------------------------------------\n\nTITLE: Defining Class Hierarchy and PetContainer with Upper Type Bound in Scala\nDESCRIPTION: Defines an Animal/Pet class hierarchy including Cat, Dog, and Lion. It then defines the generic class PetContainer[P <: Pet] which uses an upper type bound to accept only types that are subtypes of Pet. Valid instantiations of PetContainer for Dog and Cat are shown.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/upper-type-bounds.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Animal {\n def name: String\n}\n\nabstract class Pet extends Animal {}\n\nclass Cat extends Pet {\n  override def name: String = \"Cat\"\n}\n\nclass Dog extends Pet {\n  override def name: String = \"Dog\"\n}\n\nclass Lion extends Animal {\n  override def name: String = \"Lion\"\n}\n\nclass PetContainer[P <: Pet](p: P) {\n  def pet: P = p\n}\n\nval dogContainer = new PetContainer[Dog](new Dog)\nval catContainer = new PetContainer[Cat](new Cat)\n```\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Animal:\n  def name: String\n\nabstract class Pet extends Animal\n\nclass Cat extends Pet:\n  override def name: String = \"Cat\"\n\nclass Dog extends Pet:\n  override def name: String = \"Dog\"\n\nclass Lion extends Animal:\n  override def name: String = \"Lion\"\n\nclass PetContainer[P <: Pet](p: P):\n  def pet: P = p\n\nval dogContainer = PetContainer[Dog](Dog())\nval catContainer = PetContainer[Cat](Cat())\n```\n\n----------------------------------------\n\nTITLE: Returning Values from If/Else Expressions in Scala 3\nDESCRIPTION: Uses Scala 3's terser syntax to return either a or b from an if/else expression, assigning the result to x. No dependencies; variables a and b must be present. Returns the selected value directly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval x = if a < b then a else b\n\n```\n\n----------------------------------------\n\nTITLE: Creating Immutable Vectors in Scala\nDESCRIPTION: Demonstrates various ways to initialize an immutable `Vector` in Scala (valid for Scala 2 and 3): with integers, strings, and custom case class objects. `Vector` is an indexed sequence providing efficient random access.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\nval nums = Vector(1, 2, 3, 4, 5)\n\nval strings = Vector(\"one\", \"two\")\n\ncase class Person(name: String)\nval people = Vector(\n  Person(\"Bert\"),\n  Person(\"Ernie\"),\n  Person(\"Grover\")\n)\n```\n\n----------------------------------------\n\nTITLE: String Pattern Matching with Interpolators\nDESCRIPTION: Using string interpolation in pattern matching to extract parts of a string based on a pattern, demonstrating structured text parsing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/pattern-matching.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval input: String = \"Alice is 25 years old\"\n\ninput match {\n  case s\"$name is $age years old\" => s\"$name's age is $age\"\n  case _ => \"No match\"\n}\n// Result: \"Alice's age is 25\"\n```\n\n----------------------------------------\n\nTITLE: Performing Multi-Step Transformations with for-yield in Scala\nDESCRIPTION: Defines a list of strings with leading underscores (`names`) and shows how to use a `for` expression with `yield` for multi-step transformations. Examples include using a multi-line code block after `yield` for clarity and more concise versions using method chaining (`drop(1).capitalize`) to remove the underscore and capitalize each string, creating the `capNames` list. Both verbose and concise styles achieve the same result, confirmed by the REPL output `List(Adam, David, Frank)`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/for-expressions.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval names = List(\"_adam\", \"_david\", \"_frank\")\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval capNames = for (name <- names) yield {\n    val nameWithoutUnderscore = name.drop(1)\n    val capName = nameWithoutUnderscore.capitalize\n    capName\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\ncapNames: List[String] = List(Adam, David, Frank)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval capNames = for (name <- names) yield name.drop(1).capitalize\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval capNames = for (name <- names) yield { name.drop(1).capitalize }\n```\n\n----------------------------------------\n\nTITLE: Using Traits and Trait Composition in Scala\nDESCRIPTION: Provides examples of Scala traits which are used as interfaces with implementation that classes can extend or mix in. It includes single trait extension, mixing traits with an inherited class, and mixing multiple traits using the 'with' keyword. Traits do not have constructor parameters and enable modular mix-in compositions. Understanding traits and mixin composition is required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/cheatsheets/index.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ntrait T { ... }\nclass C extends T { ... }\nclass C extends D with T { ... }\n```\n\n----------------------------------------\n\nTITLE: Concise anonymous function with `map` in Scala\nDESCRIPTION: Shows how to use an anonymous function directly within `map` to double salaries, enabling more compact code without explicitly declaring a named function.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/higher-order-functions.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval salaries = Seq(20_000, 70_000, 40_000)\nval newSalaries = salaries.map(x => x * 2) // List(40000, 140000, 80000)\n```\n\n----------------------------------------\n\nTITLE: Defining a Minimal Class and Instantiation in Scala\nDESCRIPTION: Demonstrates the minimal syntax for defining a class named `User` in Scala. It shows how to create an instance of this class using `new User` in Scala 2 and `User()` in Scala 3. The class has a default constructor taking no arguments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass User\n\nval user1 = new User\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass User\n\nval user1 = User()\n```\n\n----------------------------------------\n\nTITLE: Defining a foldLeft Method with Multiple Parameters in Scala\nDESCRIPTION: This snippet defines the 'foldLeft' method in Scala, which applies a binary function to an initial value and collection elements from left to right. It demonstrates the standard usage, accepting an initial value and a lambda function as parameters. Dependencies include Scala's collection API. Inputs are a starting value and a function, and the output is the accumulated result after applying the function across the collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/multiple-parameter-lists.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef foldLeft[B](z: B)(op: (B, A) => B): B\n```\n\n----------------------------------------\n\nTITLE: Defining an Enum with Parameters and Methods - Scala\nDESCRIPTION: This snippet shows a Scala 3 enum Planet with parameters mass and radius, and enum cases Mercury, Venus, and Earth, each instantiating the base enum. The enum declares a constant for gravity (G), as well as methods for surfaceGravity and surfaceWeight. Inputs are per-case planetary data and otherMass for calculation. Requires Scala 3 and possibly a Person class definition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_61\n\nLANGUAGE: Scala\nCODE:\n```\nenum Planet(\n  mass: Double, \n  radius: Double\n):\n  case Mercury extends   Planet(3.303e+23, 2.4397e6)\n  case Venus extends     Planet(4.869e+24, 6.0518e6)\n  case Earth extends     Planet(5.976e+24, 6.37814e6)\n    // more planets ...\n\n  private final val G = 6.67300E-11\n\n  def surfaceGravity =   G * mass / (radius * radius)\n\n  def surfaceWeight(otherMass: Double)\n    = otherMass * surfaceGravity\n```\n\n----------------------------------------\n\nTITLE: Manually Implementing and Using a Type Class Instance in Scala\nDESCRIPTION: Provides an explicit implicit implementation of the `Showable` type class for `Int` using an `implicit object`. It demonstrates a successful call to the `show` method for an `Int` and comments on a scenario that would result in a compilation error due to the lack of an implicit `Showable[String]` instance in scope.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/implicits.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimplicit object IntShowable extends Showable[Int] {\n  def show(x: Int) = x.toString\n}\nshow(42) // \"42\"\nshow(\"42\") // compilation error\n```\n\n----------------------------------------\n\nTITLE: Defining a Lazy Fibonacci Stream Function in Scala\nDESCRIPTION: Defines a recursive function `fibFrom` that generates an infinite Fibonacci sequence as a Stream. Laziness via the `#::` operator prevents infinite recursion during definition, as the right-hand side (`fibFrom(b, a + b)`) is not evaluated until its elements are requested.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/concrete-immutable-collection-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef fibFrom(a: Int, b: Int): Stream[Int] = a #:: fibFrom(b, a + b)\n```\n\nLANGUAGE: output\nCODE:\n```\nfibFrom: (a: Int,b: Int)Stream[Int]\n```\n\n----------------------------------------\n\nTITLE: Creating a Class with Default Parameters in Scala\nDESCRIPTION: Defines a Scala class 'Point' with default values for 'x' and 'y'. Demonstrates creating an instance of 'Point' specifying only 'y', which overrides its default value. This pattern simplifies object instantiation when only some parameters differ from defaults.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/default-parameter-values.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass Point(val x: Double = 0, val y: Double = 0)\n\nval point1 = new Point(y = 1)\n```\n\n----------------------------------------\n\nTITLE: Doubling Elements in List with Anonymous Function Using map in Scala\nDESCRIPTION: Uses an anonymous function as a parameter to the map method of a List. Doubles each element in the original list. Requires a List[Int] as input (example shown with ints from 1 to 3). Output: a new List[Int] with elements multiplied by two. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/anonymous-functions.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval doubledInts = ints.map(_ * 2)\n```\n\n----------------------------------------\n\nTITLE: Handling Immutable Messages Using Scala Case Classes and Case Objects with Pattern Matching (Scala 2 and 3)\nDESCRIPTION: Defines a sealed trait Message and multiple case classes and a case object extending it to represent various immutable commands/messages for a music player system. The handleMessages function demonstrates pattern matching on these messages to trigger corresponding actions by calling other methods (playSong, changeVolume, stopPlayingSong). This approach enables clean, type-safe, and extensible message handling within a functional programming style, leveraging sealed hierarchies and immutability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-tools.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait Message\ncase class PlaySong(name: String) extends Message\ncase class IncreaseVolume(amount: Int) extends Message\ncase class DecreaseVolume(amount: Int) extends Message\ncase object StopPlaying extends Message\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef handleMessages(message: Message): Unit = message match {\n  case PlaySong(name)         => playSong(name)\n  case IncreaseVolume(amount) => changeVolume(amount)\n  case DecreaseVolume(amount) => changeVolume(-amount)\n  case StopPlaying            => stopPlayingSong()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Inline Recursive Power Function in Scala\nDESCRIPTION: Defines a recursive function `power` to calculate `x` raised to the power of `n`. The function itself and the parameter `n` are marked `inline`, enabling the compiler to potentially unroll the recursion and perform partial evaluation at compile time if `n` is a known constant.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ninline def power(x: Double, inline n: Int): Double =\n  if (n == 0) 1.0\n  else if (n % 2 == 1) x * power(x, n - 1)\n  else power(x * x, n / 2)\n```\n\n----------------------------------------\n\nTITLE: Evaluating Arithmetic Expression with Pattern Matching (Scala 3)\nDESCRIPTION: Defines the `eval` function that takes a `Tree` and an `Environment` (a function mapping strings to integers) and returns an `Int`. It uses Scala 3's simplified pattern matching syntax on the `Tree` to recursively evaluate `Sum` nodes, look up variable values in the environment for `Var` nodes, and return the constant value for `Const` nodes. Requires `import Tree.*`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\nimport Tree.*\n\ndef eval(t: Tree, ev: Environment): Int = t match\n  case Sum(left, right) => eval(left, ev) + eval(right, ev)\n  case Var(n)    => ev(n)\n  case Const(v)  => v\n```\n\n----------------------------------------\n\nTITLE: Implementing Chained Conditionals with 'if/else if/else' in Scala\nDESCRIPTION: Demonstrates how to chain multiple conditions using the `if/else if/else` structure in Scala 2 and Scala 3. Prints whether a number `x` is negative, zero, or positive.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_3\n\nLANGUAGE: Scala 2\nCODE:\n```\nif (x < 0)\n  println(\"negative\")\nelse if (x == 0)\n  println(\"zero\")\nelse\n  println(\"positive\")\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nif x < 0 then\n  println(\"negative\")\nelse if x == 0 then\n  println(\"zero\")\nelse\n  println(\"positive\")\n```\n\n----------------------------------------\n\nTITLE: Creating and initializing lists in Python and Scala\nDESCRIPTION: Demonstrates how to create and initialize lists in Python and how to create sequences in Scala using different classes: List, Vector, and ArrayBuffer (mutable). Shows the closest equivalent to Python's mutable list is Scala's ArrayBuffer. Useful for understanding collection type selection based on mutability in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_51\n\nLANGUAGE: python\nCODE:\n```\na = [1,2,3]\n```\n\nLANGUAGE: scala\nCODE:\n```\n// use different sequence classes\n// as needed\nval a = List(1,2,3)\nval a = Vector(1,2,3)\nval a = ArrayBuffer(1,2,3)\n```\n\n----------------------------------------\n\nTITLE: Handling Errors by Returning Option (Scala)\nDESCRIPTION: This Scala snippet shows the idiomatic approach to handle potential errors without using checked exceptions. Instead of throwing an exception on failure, the method returns an `Option[Int]`, which will be `Some(Int)` if the conversion succeeds or `None` if it fails (e.g., due to a `NumberFormatException`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_72\n\nLANGUAGE: Scala\nCODE:\n```\ndef makeInt(s: String): Option[Int] =\n  try\n    Some(s.toInt)\n  catch\n    case e: NumberFormatException => None\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Option Values Using Scala for-Comprehension (Scala 2 and Scala 3 Syntax)\nDESCRIPTION: These snippets use for-comprehensions to combine multiple Option[Int] values returned by makeInt for different strings. In both Scala 2 and Scala 3, if all makeInt calls return Some values, their contents are summed and wrapped in a Some; if any produce None, the entire result is None. This idiomatic pattern enables concise handling of dependent optional values. Key parameters include stringA, stringB, and stringC as inputs to makeInt, which returns Option[Int].\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-functional-error-handling.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nval y = for {\n  a <- makeInt(stringA)\n  b <- makeInt(stringB)\n  c <- makeInt(stringC)\n} yield {\n  a + b + c\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval y = for\n  a <- makeInt(stringA)\n  b <- makeInt(stringB)\n  c <- makeInt(stringC)\nyield\n  a + b + c\n```\n\n----------------------------------------\n\nTITLE: Using Scala Iterable Methods for Collection Operations\nDESCRIPTION: Defines a wide range of standard collection operations available on Scala Iterable types. Provides method names and descriptions covering iteration (e.g., iterator, foreach), transformations (map, flatMap), concatenations (concat, ++), conversions (toArray, toList, toSet, toMap), selections (head, tail, filter), partitions (splitAt, span, partition), aggregations (foldLeft, sum, min), and string operations (mkString). These methods operate on collections of type Iterable[A] and support functional programming paradigms in Scala. Dependencies include Scala Standard Library collections and their traits.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/trait-iterable.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nxs.iterator\nxs foreach f\nxs grouped size\nxs sliding size\nxs concat ys\nxs ++ ys\nxs map f\nxs flatMap f\nxs collect f\nxs.toArray\nxs.toList\nxs.toIterable\nxs.toSeq\nxs.toIndexedSeq\nxs.toSet\nxs.toMap\nxs.to(SortedSet)\nxs copyToArray(arr, s, n)\nxs.isEmpty\nxs.nonEmpty\nxs.size\nxs.knownSize\nxs.sizeCompare(ys)\nxs.sizeCompare(n)\nxs.sizeIs < 42\nxs.sizeIs != 42\nxs.head\nxs.headOption\nxs.last\nxs.lastOption\nxs find p\nxs.tail\nxs.init\nxs.slice(from, to)\nxs take n\nxs drop n\nxs takeWhile p\nxs dropWhile p\nxs takeRight n\nxs dropRight n\nxs filter p\nxs withFilter p\nxs filterNot p\nxs splitAt n\nxs span p\nxs partition p\nxs groupBy f\nxs.groupMap(f)(g)\nxs.groupMapReduce(f)(g)(h)\nxs forall p\nxs exists p\nxs count p\nxs.foldLeft(z)(op)\nxs.foldRight(z)(op)\nxs reduceLeft op\nxs reduceRight op\nxs.sum\nxs.product\nxs.min\nxs.max\nxs.minOption\nxs.maxOption\nxs.addString(b, start, sep, end)\nxs.mkString(start, sep, end)\nxs.stringPrefix\nxs zip ys\nxs.zipAll(ys, x, y)\nxs.zipWithIndex\nxs.view\n```\n\n----------------------------------------\n\nTITLE: Accessing Class Fields in Scala\nDESCRIPTION: This snippet demonstrates how to access the fields (constructor parameters defined as `var` or `val`) of a class instance using dot notation. This syntax is consistent between Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\np.name       // \"Robert Allen Zimmerman\"\np.vocation   // \"Harmonica Player\"\n```\n\n----------------------------------------\n\nTITLE: Réduction de la redondance via une fonction d'ordre supérieur en Scala\nDESCRIPTION: Refactorise les méthodes promotionnelles de SalaryRaiser en extrayant une fonction d'ordre supérieur promotion qui prend une List[Double] et une fonction Double => Double comme paramètre. Les méthodes promotionnelles délèguent leur logique à cette fonction, évitant la duplication et rendant le code plus générique et réutilisable. Nécessite la bibliothèque standard Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tour/higher-order-functions.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nobject SalaryRaiser {\n\n  private def promotion(salaries: List[Double], promotionFunction: Double => Double): List[Double] =\n    salaries.map(promotionFunction)\n\n  def smallPromotion(salaries: List[Double]): List[Double] =\n    promotion(salaries, salary => salary * 1.1)\n\n  def greatPromotion(salaries: List[Double]): List[Double] =\n    promotion(salaries, salary => salary * math.log(salary))\n\n  def hugePromotion(salaries: List[Double]): List[Double] =\n    promotion(salaries, salary => salary * salary)\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining Filters and Mapping on Immutable List in Scala 2 and 3\nDESCRIPTION: Shows how to chain multiple higher-order functions such as 'filter' and 'map' on an immutable List. It filters elements greater than 3, then filters those less than 7, and finally multiplies each remaining element by 10. The original list remains unchanged, and a new List with the transformed values is produced. Demonstrates fluent-style chaining common with immutable collections in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-functions.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n// a sample list\nval nums = (1 to 10).toList   // List(1,2,3,4,5,6,7,8,9,10)\n\n// methods can be chained together as needed\nval x = nums.filter(_ > 3)\n            .filter(_ < 7)\n            .map(_ * 10)\n\n// result: x == List(40, 50, 60)\n```\n\n----------------------------------------\n\nTITLE: Creating Enumerations with Case Objects for Pizza Toppings and Crusts\nDESCRIPTION: Uses sealed traits and case objects to define enumerations for pizza toppings, crust sizes, and crust types, enabling pattern matching and type safety. These enumerations are used in the `Pizza` case class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/case-objects.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nsealed trait Topping\ncase object Cheese extends Topping\ncase object Pepperoni extends Topping\ncase object Sausage extends Topping\ncase object Mushrooms extends Topping\ncase object Onions extends Topping\n\nsealed trait CrustSize\ncase object SmallCrustSize extends CrustSize\ncase object MediumCrustSize extends CrustSize\ncase object LargeCrustSize extends CrustSize\n\nsealed trait CrustType\ncase object RegularCrustType extends CrustType\ncase object ThinCrustType extends CrustType\ncase object ThickCrustType extends CrustType\n```\n\n----------------------------------------\n\nTITLE: Deriving a uPickle ReadWriter in Scala 3\nDESCRIPTION: Shows the Scala 3 approach to automatically generating a `ReadWriter` instance for the `PetOwner` case class using the `derives ReadWriter` clause. This instance enables uPickle to deserialize JSON into the `PetOwner` type without explicit boilerplate. Requires the uPickle library.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-deserialize.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport upickle.default.*\n\ncase class PetOwner(name: String, pets: List[String])\n  derives ReadWriter\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Expression Evaluation and Derivation in Scala 2 Main Program\nDESCRIPTION: Implements an object Calc with a main method to demonstrate composition of arithmetic expressions, environment mapping for variables, evaluation of expressions, and symbolic derivation with respect to different variables. Expects Tree and Environment definitions, with eval and derive functions available (the provided derive may be used). Takes no command-line parameters, prints the built expression, its evaluation in a supplied environment, and its symbolic derivatives with respect to x and y. Requires prior definition of eval and derive, and assumes Sum, Var, and Const types are defined.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\nimport Tree._\n\nobject Calc {\n  type Environment = String => Int\n  def eval(t: Tree, ev: Environment): Int = ...\n  def derive(t: Tree, v: String): Tree = ...\n\n  def main(args: Array[String]): Unit = {\n    val exp: Tree = Sum(Sum(Var(\"x\"),Var(\"x\")),Sum(Const(7),Var(\"y\")))\n    val env: Environment = { case \"x\" => 5 case \"y\" => 7 }\n    println(\"Expression: \" + exp)\n    println(\"Evaluation with x=5, y=7: \" + eval(exp, env))\n    println(\"Derivative relative to x:\\n \" + derive(exp, \"x\"))\n    println(\"Derivative relative to y:\\n \" + derive(exp, \"y\"))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping over a List with a Separate Method in Scala\nDESCRIPTION: This snippet defines a double function and demonstrates three ways to use it with the map method on a Scala List. No extra dependencies are needed. Inputs are a List[Int] and the output is a List[Int] where each element is doubled. Shows function reference and lambda alternatives as arguments to higher-order methods, illustrating idiomatic and concise mapping strategies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-methods.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef double(i: Int) = i * 2\n\n// these all return `List(20, 40, 60, 80, 20)`\na.map(i => double(i))\na.map(double(_))\na.map(double)\n```\n\n----------------------------------------\n\nTITLE: Defining String to Int Conversion Using Option in Scala\nDESCRIPTION: This snippet defines a function to safely convert a string to an integer using the Option class, returning Some[Int] on success or None on failure. The implementation uses a try-catch block to capture any exceptions from Integer.parseInt, enforcing a functional approach by preventing null values. No external dependencies are required; the method expects a string as input and yields an Option[Int] as output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/functional-error-handling.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef toInt(s: String): Option[Int] = {\n    try {\n        Some(Integer.parseInt(s.trim))\n    } catch {\n        case e: Exception => None\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Sequence Element by Index Using apply in Scala Seq\nDESCRIPTION: Retrieves an element at a specified index within a sequence using the apply method (e.g., Seq(1, 2, 3)(1)). Dependencies: only standard Scala collections. Input is a sequence and an integer index; output is the sequence element at that index. Indices must be integers starting from 0; accessing out-of-bounds indices throws an exception.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/trait-iterable.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nSeq(1, 2, 3)(1)\n```\n\n----------------------------------------\n\nTITLE: Capitalizing Strings in a List using for-yield in Scala\nDESCRIPTION: Defines a list of lowercase strings (`names`) and demonstrates using a `for` expression with `yield` to create a new list (`ucNames`) containing the capitalized versions of the original strings. The `capitalize` method is applied to each element during iteration. The REPL output shows the resulting `List(Adam, David, Frank)`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/for-expressions.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval names = List(\"adam\", \"david\", \"frank\")\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval ucNames = for (name <- names) yield name.capitalize\n```\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val ucNames = for (name <- names) yield name.capitalize\nucNames: List[String] = List(Adam, David, Frank)\n```\n\n----------------------------------------\n\nTITLE: Running multiple futures in parallel and combining results with for expression\nDESCRIPTION: Starts multiple Futures that run concurrently with different sleep durations, then combines their results in a for-comprehension. Demonstrates parallel execution and how to aggregate results once all futures complete, measuring total elapsed time.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/concurrency.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval f1 = Future { sleep(800); 1 }\nval f2 = Future { sleep(200); 2 }\nval f3 = Future { sleep(400); 3 }\n\nval result =\n  for\n    r1 <- f1\n    r2 <- f2\n    r3 <- f3\n  yield\n    (r1 + r2 + r3)\n\nresult.onComplete {\n  case Success(x) => println(s\"Result = $x\")\n  case Failure(e) => e.printStackTrace\n}\n```\n\n----------------------------------------\n\nTITLE: Prepending and Appending Elements to Scala List - Scala\nDESCRIPTION: These snippets show how to prepend single or multiple elements to an existing immutable List by creating a new List using the \"+:\" and \"++:\" operators. They highlight the idiomatic way to extend Lists, though appending is discouraged for performance reasons. The examples focus on integer Lists, demonstrate assignment to a new variable, and REPL output shows the resulting List structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/list-class.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval a = List(1,2,3)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval b = 0 +: a\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval b = List(-1, 0) ++: a\n```\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val b = 0 +: a\nb: List[Int] = List(0, 1, 2, 3)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val b = List(-1, 0) ++: a\nb: List[Int] = List(-1, 0, 1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Any Type with List in Scala\nDESCRIPTION: This example shows how various data types (string, integer, character, boolean, and function) can all be stored in a List[Any], demonstrating Scala's unified type system where everything is an object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/unified-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval list: List[Any] = List(\n  \"a string\",\n  732,  // целое число\n  'c',  // символ\n  true, // логическое значение\n  () => \"анонимная функция возвращающая строку\"\n)\n\nlist.foreach(element => println(element))\n```\n\n----------------------------------------\n\nTITLE: Creating Modules by Implementing Traits in Scala\nDESCRIPTION: Demonstrates how to combine multiple traits into a concrete singleton object to create a module. The example shows two service traits (AddService and MultiplyService) being implemented by a single MathService object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-objects.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntrait AddService:\n  def add(a: Int, b: Int) = a + b\n\ntrait MultiplyService:\n  def multiply(a: Int, b: Int) = a * b\n\n// implement those traits as a concrete object\nobject MathService extends AddService, MultiplyService\n\n// use the object\nimport MathService.*\nprintln(add(1,1))        // 2\nprintln(multiply(2,2))   // 4\n```\n\n----------------------------------------\n\nTITLE: Scala 'match' expression returning a value\nDESCRIPTION: Shows how to assign the result of a 'match' expression to a variable, mapping month numbers to their names, including a default fallback, illustrating common pattern for value-returning 'match' expressions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/match-expressions.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval monthName = i match {\n    case 1  => \"January\"\n    case 2  => \"February\"\n    case 3  => \"March\"\n    case 4  => \"April\"\n    case 5  => \"May\"\n    case 6  => \"June\"\n    case 7  => \"July\"\n    case 8  => \"August\"\n    case 9  => \"September\"\n    case 10 => \"October\"\n    case 11 => \"November\"\n    case 12 => \"December\"\n    case _  => \"Invalid month\"\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Scala HashMap Class with Default Parameters and Named Arguments\nDESCRIPTION: This Scala snippet demonstrates defining a generic HashMap class where constructor parameters initialCapacity and loadFactor have default values (16 and 0.75f respectively). It shows usage examples including invoking the constructor with default parameters, overriding one or both parameters, and using named arguments to override specific parameters only. This approach improves readability, reduces boilerplate, and solves the problem of duplicated default values found in Java constructors. Inputs are constructor parameters with optional overriding values; output is a HashMap instance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/default-parameter-values.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass HashMap[K,V](initialCapacity:Int = 16, loadFactor:Float = 0.75f) {\n}\n\n// Utiliza os valores padrões (16, 0.75f)\nval m1 = new HashMap[String,Int]\n\n// Inicial com capacidade 20, e fator de carga padrão\nval m2= new HashMap[String,Int](20)\n\n// Sobreescreve ambos os valores\nval m3 = new HashMap[String,Int](20,0.8f)\n\n// Sobreescreve somente o fator de carga\n// parâmetro nomeado\nval m4 = new HashMap[String,Int](loadFactor = 0.8f)\n```\n\n----------------------------------------\n\nTITLE: Comprehension with yield in Scala\nDESCRIPTION: Defines a val list by yielding values from a for-comprehension that multiplies integers 1 to 3 by 10. This creates a new collection (Vector) with the results. Scala's for-yield syntax enables functional transformations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_47\n\nLANGUAGE: scala\nCODE:\n```\nval list = \n  for\n    i <- 1 to 3\n  yield\n    i * 10\n// list: Vector(10, 20, 30)\n```\n\n----------------------------------------\n\nTITLE: Initializing Abstract Scala Collections via Apply Method\nDESCRIPTION: Shows examples of using the `apply` factory method on abstract collection types like `Iterable` and `mutable.Iterable`. Calling `apply` on an abstract type typically returns an instance of a default concrete implementation (e.g., `List` for `Iterable`, `ArrayBuffer` for `mutable.Iterable`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/creating-collections-from-scratch.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> List(1, 2, 3)\nval res17: List[Int] = List(1, 2, 3)\n\nscala> Iterable(1, 2, 3)\nval res18: Iterable[Int] = List(1, 2, 3)\n\nscala> mutable.Iterable(1, 2, 3)\nval res19: scala.collection.mutable.Iterable[Int] = ArrayBuffer(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Passing Anonymous Functions to Map and Filter in Scala\nDESCRIPTION: Demonstrates creating a list of integers and using anonymous functions with map and filter methods to produce transformed or filtered lists. This snippet uses anonymous function syntax with underscores as placeholders for function parameters. It requires Scala's standard collection library and implicitly shows the functional programming style in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/passing-functions-around.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval nums = (1 to 10).toList\n\nval doubles = nums.map(_ * 2)\nval lessThanFive = nums.filter(_ < 5)\n```\n\n----------------------------------------\n\nTITLE: Пример использования метода map в коллекциях Scala - Scala\nDESCRIPTION: Демонстрация универсального принципа единообразного типа возвращаемого значения в Scala коллекциях. Метод map вызывается на коллекциях List и Set, возвращая коллекции того же типа с преобразованными элементами. Показывает, что операции преобразования коллекций сохраняют тип коллекции, что является ключевой особенностью API коллекций Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/overview.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nscala> List(1, 2, 3) map (_ + 1)\nres0: List[Int] = List(2, 3, 4)\nscala> Set(1, 2, 3) map (_ * 2)\nres0: Set[Int] = Set(2, 4, 6)\n```\n\n----------------------------------------\n\nTITLE: 定義された木構造データ型（ケースクラス）\nDESCRIPTION: 式の表現に用いる木構造を示すケースクラスの定義例。Sum、Var、Constの各クラスがTree型を拡張し、算術式の構造を表現する。これにより、式の構造をパターンマッチによって操作可能になる。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tutorials/scala-for-java-programmers.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Tree\ncase class Sum(l: Tree, r: Tree) extends Tree\ncase class Var(n: String) extends Tree\ncase class Const(v: Int) extends Tree\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching in Scala\nDESCRIPTION: Shows correct and incorrect pattern matching examples in Scala, including matching in anonymous functions, handling variable binding in patterns, and using backticks for referencing existing values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/cheatsheets/index.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n(xs zip ys) map {\n  case (x, y) => x * y\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\n(xs zip ys) map {\n  (x, y) => x * y\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval v42 = 42\n3 match {\n  case v42 => println(\"42\")\n  case _   => println(\"Not 42\")\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval v42 = 42\n3 match {\n  case `v42` => println(\"42\")\n  case _     => println(\"Not 42\")\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval UppercaseVal = 42\n3 match {\n  case UppercaseVal => println(\"42\")\n  case _            => println(\"Not 42\")\n}\n```\n\n----------------------------------------\n\nTITLE: Omitting parameter name for context parameters in Scala 3\nDESCRIPTION: Highlights how to omit explicit parameter names for 'using' context parameters, simplifying function signatures in Scala 3. The syntax relies solely on type inference to provide the appropriate context object during function calls.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/ca-context-parameters.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef renderWebsite(path: String)(using Config): String =\n    \"<html>\" + renderWidget(List(\"cart\")) + \"</html>\"\n```\n\n----------------------------------------\n\nTITLE: Creating Collections with For Comprehensions - Scala\nDESCRIPTION: Introduces Scala's 'for' comprehension, which uses the 'yield' keyword to transform iterated elements and collect them into a new collection. This is a common functional pattern in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_30\n\nLANGUAGE: Scala\nCODE:\n```\nval list =\n  for\n    i <- 1 to 3\n  yield\n    i * 10\n// result: Vector(10, 20, 30)\n```\n\n----------------------------------------\n\nTITLE: Transforming List Elements with a for/yield Block in Scala\nDESCRIPTION: Shows how to use a `for` expression with `yield` and a code block to perform multi-step processing on each element in a `List` of strings (`names`). It removes a leading underscore and capitalizes each name, producing a new `List`. Includes syntax for Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_19\n\nLANGUAGE: Scala 2\nCODE:\n```\nval names = List(\"_olivia\", \"_walter\", \"_peter\")\n\nval capNames = for (name <- names) yield { \n  val nameWithoutUnderscore = name.drop(1)\n  val capName = nameWithoutUnderscore.capitalize\n  capName\n}\n\n// capNames: List[String] = List(Olivia, Walter, Peter)\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nval names = List(\"_olivia\", \"_walter\", \"_peter\")\n\nval capNames = for name <- names yield\n  val nameWithoutUnderscore = name.drop(1)\n  val capName = nameWithoutUnderscore.capitalize\n  capName\n\n// capNames: List[String] = List(Olivia, Walter, Peter)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Scala 3 Enumerations and Extension Methods\nDESCRIPTION: This snippet provides examples of two ergonomic features introduced in Scala 3: `enum` for defining enumerations and `extension` methods for adding functionality to existing types without modification. The example shows a `Color` enumeration and extension methods (`circumference`, `diameter`, `area`) added to a `Circle` type (assuming `Circle` and `radius` are defined elsewhere).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/why-scala-3.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\n// enumeration\nenum Color:\n  case Red, Green, Blue\n\n// extension methods\nextension (c: Circle)\n  def circumference: Double = c.radius * math.Pi * 2\n  def diameter: Double = c.radius * 2\n  def area: Double = math.Pi * c.radius * c.radius\n```\n\n----------------------------------------\n\nTITLE: Pattern matching with multiple cases in Java vs Scala\nDESCRIPTION: Shows how Scala's pattern matching can handle multiple values in a single case with the pipe operator, compared to Java's more verbose approach with multiple case statements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_46\n\nLANGUAGE: Java\nCODE:\n```\nString numAsString = \"\";\nswitch (i) {\n  case 1: case 3:\n  case 5: case 7: case 9: \n    numAsString = \"odd\";\n    break;\n  case 2: case 4:\n  case 6: case 8: case 10: \n    numAsString = \"even\";\n    break;\n  default:\n    numAsString = \"too big\";\n    break;\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval numAsString = i match\n  case 1 | 3 | 5 | 7 | 9 => \"odd\"\n  case 2 | 4 | 6 | 8 | 10 => \"even\"\n  case _ => \"too big\"\n```\n\n----------------------------------------\n\nTITLE: Parentheses Omission for Arity-0 Methods in Scala\nDESCRIPTION: Shows how Scala allows omitting parentheses for methods with no arguments (arity-0). This syntax should only be used for methods without side effects (purely-functional). Calling `reply()` is equivalent to `reply` in such cases, but omitting parentheses is discouraged for methods with side-effects like `println()`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/method-invocation.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nreply()\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// is the same as\n\nreply\n```\n\n----------------------------------------\n\nTITLE: Example JSON for versions dictionary for scaladoc - JSON\nDESCRIPTION: An example JSON structure representing a versions dictionary mapping version labels to URLs where the documentation index.html files can be found. This JSON is used with the `-versions-dictionary-url` option to enable scaladoc to link different documentation versions. It contains a single property `versions` which maps strings (version names) to their corresponding documentation URLs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/settings.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"versions\": {\n    \"3.0.x\": \"https://dotty.epfl.ch/3.0.x/docs/index.html\",\n    \"Nightly\": \"https://dotty.epfl.ch/docs/index.html\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling multiple patterns in one case in Scala 2\nDESCRIPTION: Shows how to handle multiple possible pattern matches in a single case statement using the alternation operator (|). This technique helps reduce repetitive code in match expressions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nval evenOrOdd = i match {\n  case 1 | 3 | 5 | 7 | 9 => println(\"odd\")\n  case 2 | 4 | 6 | 8 | 10 => println(\"even\")\n  case _ => println(\"some other number\")\n}\n```\n\n----------------------------------------\n\nTITLE: Scala Classes for Data Encapsulation in Scala 2\nDESCRIPTION: Defines a Person class with mutable fields, illustrating constructor creation and field access/modification in Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-modeling.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nclass Person(var firstName: String, var lastName: String) {\n  def printFullName() = println(s\"$firstName $lastName\")\n}\n\nval p = new Person(\"John\", \"Stephens\")\nprintln(p.firstName)   // \"John\"\np.lastName = \"Legend\"\np.printFullName()      // \"John Legend\"\n```\n\n----------------------------------------\n\nTITLE: Failing Nested Generic Call Due to Missing ClassTag Propagation (REPL)\nDESCRIPTION: Illustrates an error scenario where a generic function 'wrap[U]' calls another generic function 'evenElems[T: ClassTag]'. The call fails because 'wrap' does not itself require a ClassTag for U, so it cannot implicitly provide one to 'evenElems'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/arrays.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nscala> def wrap[U](xs: Vector[U]) = evenElems(xs)\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Collections in Scala\nDESCRIPTION: Shows Scala 'for' loop syntax to iterate over elements in 'ints', printing each element. The preferred syntax uses 'for i <- ints do println(i)', with an alternative comma-less option. Assumes presence of a collection or sequence 'ints'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\n// preferred\nfor i <- ints do println(i)\n\n// also available\nfor (i <- ints) println(i)\n```\n\n----------------------------------------\n\nTITLE: Defining a Class Constructor with Default Parameter Values in Scala\nDESCRIPTION: Shows how to define a `Point` class constructor with default values (`0`) for parameters `x` and `y`. This allows instantiation without arguments (`Point()` or `new Point`), with one argument (`Point(1)` or `new Point(1)` which sets `x`), or with both. Demonstrates instantiation using default values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass Point(var x: Int = 0, var y: Int = 0)\n\nval origin = new Point    // x and y are both set to 0\nval point1 = new Point(1) // x is set to 1 and y is set to 0\nprintln(point1)           // prints (1, 0)\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Point(var x: Int = 0, var y: Int = 0)\n\nval origin = Point()  // x and y are both set to 0\nval point1 = Point(1) // x is set to 1 and y is set to 0\nprintln(point1)       // prints (1, 0)\n```\n\n----------------------------------------\n\nTITLE: Defining Traits with Self-Types in Scala\nDESCRIPTION: This snippet demonstrates how to use a self-type (`this: User =>`) in the `Tweeter` trait. This declaration ensures that any concrete class extending `Tweeter` must also mix in the `User` trait, making the `username` method available directly within the `Tweeter` trait's methods, such as `tweet`. The `VerifiedTweeter` class shows how to satisfy this requirement by mixing in both `Tweeter` and `User`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/self-types.md#_snippet_0\n\nLANGUAGE: Scala 2\nCODE:\n```\ntrait User {\n  def username: String\n}\n\ntrait Tweeter {\n  this: User =>  // reassign this\n  def tweet(tweetText: String) = println(s\"$username: $tweetText\")\n}\n\nclass VerifiedTweeter(val username_ : String) extends Tweeter with User {  // We mixin User because Tweeter required it\n  def username = s\"real $username_\"\n}\n\nval realBeyoncé = new VerifiedTweeter(\"Beyoncé\")\nrealBeyoncé.tweet(\"Just spilled my glass of lemonade\")  // prints \"real Beyoncé: real Beyoncé: Just spilled my glass of lemonade\"\n\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ntrait User:\n  def username: String\n\ntrait Tweeter:\n  this: User =>  // reassign this\n  def tweet(tweetText: String) = println(s\"$username: $tweetText\")\n\nclass VerifiedTweeter(val username_ : String) extends Tweeter, User:  // We mixin User because Tweeter required it\n  def username = s\"real $username_\"\n\nval realBeyoncé = VerifiedTweeter(\"Beyoncé\")\nrealBeyoncé.tweet(\"Just spilled my glass of lemonade\")  // prints \"real Beyoncé: real Beyoncé: Just spilled my glass of lemonade\"\n\n```\n\n----------------------------------------\n\nTITLE: Using Named Parameters in Method Calls in Scala (2 & 3)\nDESCRIPTION: Illustrates calling the `makeConnection` method using named parameters (`timeout = ...`, `protocol = ...`). This allows specifying arguments out of order and selectively overriding defaults, improving code readability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nmakeConnection(timeout=10_000)\nmakeConnection(protocol=\"https\")\nmakeConnection(timeout=10_000, protocol=\"https\")\nmakeConnection(protocol=\"https\", timeout=10_000)\n```\n\n----------------------------------------\n\nTITLE: Define Parameterized `greet` Method (Scala)\nDESCRIPTION: Defines an improved version of the `greet` method that accepts a `String` parameter `theGreeting`. This parameter is used within the returned anonymous function to customize the greeting message, making the method more flexible. The returned function still has the type `String => Unit`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-write-method-returns-function.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef greet(theGreeting: String): String => Unit = \n  (name: String) => println(s\"$theGreeting, $name\")\n```\n\n----------------------------------------\n\nTITLE: Functional Composition of Futures using 'map' in Scala 2\nDESCRIPTION: This snippet refactors callback-based code to use the 'map' combinator for more straightforward future composition, eliminating nested callbacks and improving code readability. It demonstrates reasoning about futures and exception propagation with 'map'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nval rateQuote = Future {\n  connection.getCurrentValue(USD)\n}\n\nval purchase = rateQuote.map { quote =>\n  if (isProfitable(quote)) connection.buy(amount, quote)\n  else throw new Exception(\"not profitable\")\n}\n\npurchase.foreach { amount =>\n  println(\"Purchased \" + amount + \" USD\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using Mutable Stacks in Scala 2\nDESCRIPTION: Shows how to create a mutable `Stack[Int]` in Scala 2 using `new`, push elements onto the stack using `push`, inspect the top element without removing it using `top`, and remove/return the top element using `pop`. Implements LIFO (Last-In-First-Out) behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-mutable-collection-classes.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nscala> val stack = new scala.collection.mutable.Stack[Int]\nstack: scala.collection.mutable.Stack[Int] = Stack()\nscala> stack.push(1)\nres0: stack.type = Stack(1)\nscala> stack\nres1: scala.collection.mutable.Stack[Int] = Stack(1)\nscala> stack.push(2)\nres0: stack.type = Stack(1, 2)\nscala> stack\nres3: scala.collection.mutable.Stack[Int] = Stack(2, 1)\nscala> stack.top\nres8: Int = 2\nscala> stack\nres9: scala.collection.mutable.Stack[Int] = Stack(2, 1)\nscala> stack.pop\nres10: Int = 2\nscala> stack\nres11: scala.collection.mutable.Stack[Int] = Stack(1)\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Test Cases with ScalaTest - Scala\nDESCRIPTION: Extends the CubeCalculatorTest class to include multiple tests using AnyFunSuite. This snippet adds a new test case for the cube of 0, ensuring both 3 and 0 are tested. Dependencies: ScalaTest configured in build.sbt and a CubeCalculator object with a 'cube' method. Both tests use assert to check output correctness. Inputs are hardcoded (3 and 0), and expected outputs are 27 and 0 respectively. Useful for demonstrating how to expand test coverage.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/getting-started/sbt-track/testing-scala-with-sbt-on-the-command-line.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n  import org.scalatest.funsuite.AnyFunSuite\n  \n  class CubeCalculatorTest extends AnyFunSuite {\n      test(\"CubeCalculator.cube 3 should be 27\") {\n          assert(CubeCalculator.cube(3) === 27)\n      }\n\n      test(\"CubeCalculator.cube 0 should be 0\") {\n          assert(CubeCalculator.cube(0) === 0)\n      }\n  }\n```\n\n----------------------------------------\n\nTITLE: Example of Implicit Int to Long Conversion in Scala\nDESCRIPTION: This example demonstrates how Scala automatically converts an Int to a Long when required, using the implicit conversion Int.int2long(x).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/implicit-conversions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nInt.int2long(x)\n```\n\n----------------------------------------\n\nTITLE: Define `createGreetingFunction` Factory Method (Scala)\nDESCRIPTION: Defines a Scala method `createGreetingFunction` that acts as a factory for generating greeting functions. It takes a `desiredLanguage` string as input and returns a function of type `String => Unit`. Inside the method, two specific greeting functions (English and French) are defined and assigned to variables. A `match` expression is used to return the appropriate function based on the `desiredLanguage` parameter. Both Scala 2 and Scala 3 syntax versions are provided.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-write-method-returns-function.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef createGreetingFunction(desiredLanguage: String): String => Unit = ???\n// Method signature stub\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(name: String) => println(s\"Hello, $name\")\n(name: String) => println(s\"Bonjour, $name\")\n// Anonymous functions for English and French\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval englishGreeting = (name: String) => println(s\"Hello, $name\")\nval frenchGreeting = (name: String) => println(s\"Bonjour, $name\")\n// Assigning anonymous functions to variables\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef createGreetingFunction(desiredLanguage: String): String => Unit = {\n  val englishGreeting = (name: String) => println(s\"Hello, $name\")\n  val frenchGreeting = (name: String) => println(s\"Bonjour, $name\")\n  desiredLanguage match {\n    case \"english\" => englishGreeting\n    case \"french\" => frenchGreeting\n  }\n}\n// Scala 2 Implementation\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef createGreetingFunction(desiredLanguage: String): String => Unit =\n  val englishGreeting = (name: String) => println(s\"Hello, $name\")\n  val frenchGreeting = (name: String) => println(s\"Bonjour, $name\")\n  desiredLanguage match\n    case \"english\" => englishGreeting\n    case \"french\" => frenchGreeting\n// Scala 3 Implementation\n```\n\n----------------------------------------\n\nTITLE: Adding Elements to a Mutable ArrayBuffer in Scala\nDESCRIPTION: Shows how to append a single element (`+=`) or multiple elements from another collection (like a `List`) using `++=` to a mutable `ArrayBuffer`. The buffer is modified in place.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_26\n\nLANGUAGE: Scala\nCODE:\n```\nval nums = ArrayBuffer(1, 2, 3)   // ArrayBuffer(1, 2, 3)\nnums += 4                         // ArrayBuffer(1, 2, 3, 4)\nnums ++= List(5, 6)               // ArrayBuffer(1, 2, 3, 4, 5, 6)\n```\n\n----------------------------------------\n\nTITLE: Using `foreach` with Underscore Placeholder Syntax in Scala\nDESCRIPTION: Illustrates using the underscore placeholder `_` within an anonymous function passed to `foreach`. `println(_)` is shorthand for `i => println(i)` when the parameter is used only once.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-anonymous-functions.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nints.foreach(println(_))\n```\n\n----------------------------------------\n\nTITLE: Defining Enumerations for Alternatives\nDESCRIPTION: This snippet demonstrates how to model data types consisting of distinct alternatives (sum types) in Scala, such as crust sizes, crust types, and toppings. It shows the differences in syntax between Scala 2 (using sealed abstract classes and case objects) and the more concise `enum` construct introduced in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-fp.md#_snippet_0\n\nLANGUAGE: Scala 2\nCODE:\n```\nsealed abstract class CrustSize\nobject CrustSize {\n  case object Small extends CrustSize\n  case object Medium extends CrustSize\n  case object Large extends CrustSize\n}\n\nsealed abstract class CrustType\nobject CrustType {\n  case object Thin extends CrustType\n  case object Thick extends CrustType\n  case object Regular extends CrustType\n}\n\nsealed abstract class Topping\nobject Topping {\n  case object Cheese extends Topping\n  case object Pepperoni extends Topping\n  case object BlackOlives extends Topping\n  case object GreenOlives extends Topping\n  case object Onions extends Topping\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nenum CrustSize:\n  case Small, Medium, Large\n\nenum CrustType:\n  case Thin, Thick, Regular\n\nenum Topping:\n  case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions\n```\n\n----------------------------------------\n\nTITLE: Illustration of covariance with Animal hierarchy and List\nDESCRIPTION: This snippet demonstrates covariant type parameters in Scala collections using an Animal hierarchy (Animal, Cat, Dog) and the standard List class. It shows how List[Cat] and List[Dog] can be used where List[Animal] is expected due to covariance, enabling flexible and intuitive type assignments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/variances.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Animal {\n  def name: String\n}\ncase class Cat(name: String) extends Animal\ncase class Dog(name: String) extends Animal\n```\n\nLANGUAGE: Scala\nCODE:\n```\nobject CovarianceTest extends App {\n  def printAnimalNames(animals: List[Animal]): Unit = {\n    animals.foreach { animal =>\n      println(animal.name)\n    }\n  }\n\n  val cats: List[Cat] = List(Cat(\"Whiskers\"), Cat(\"Tom\"))\n  val dogs: List[Dog] = List(Dog(\"Fido\"), Dog(\"Rex\"))\n\n  printAnimalNames(cats)\n  // Whiskers\n  // Tom\n\n  printAnimalNames(dogs)\n  // Fido\n  // Rex\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and using a function with caching in Scala\nDESCRIPTION: Demonstrates how to implement a caching mechanism using mutable Maps in Scala. The example defines a function f that simulates an expensive operation, then creates a cached version using getOrElseUpdate to avoid redundant computations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/maps.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: String) = {\n  println(\"taking my time.\"); sleep(100)\n  x.reverse\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Generic Stack Instance (Scala 2)\nDESCRIPTION: Demonstrates how to create and use an instance of the generic `Stack` class in Scala 2. It specifically instantiates a `Stack[Int]`, pushes two integers onto it, and then pops and prints them.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-generics.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval stack = new Stack[Int]\nstack.push(1)\nstack.push(2)\nprintln(stack.pop())  // prints 2\nprintln(stack.pop())  // prints 1\n```\n\n----------------------------------------\n\nTITLE: Prepending Elements with Symbolic Method\nDESCRIPTION: Demonstrates using the +: method to prepend an element to a List.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n0 +: a\n```\n\n----------------------------------------\n\nTITLE: Filtering List with Anonymous Function Equivalent to Named Predicate in Scala\nDESCRIPTION: Demonstrates that filtering with an anonymous function (_ < 5) is equivalent to using a named predicate method. Inputs: List[Int]. Outputs: elements less than five.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/anonymous-functions.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nval y = ints.filter(_ < 5)\n```\n\n----------------------------------------\n\nTITLE: Calculating Option Size with Pattern Matching - Scala\nDESCRIPTION: This snippet shows how to implement Option.size using explicit pattern matching, returning 1 for Some and 0 for None. No dependencies are required. The input is an Option, and the output is an integer (0 or 1). Useful for understanding method equivalence in Scala Option. Limited to single-element Options.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\noption match {\n  case Some(_) => 1\n  case None    => 0\n}\n```\n\n----------------------------------------\n\nTITLE: Control Structures in Scala\nDESCRIPTION: Control flow constructs in Scala including if/else, loops, break statements, and for-comprehensions with their functional equivalents.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/cheatsheets/index.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nif (check) happy else sad\n```\n\nLANGUAGE: Scala\nCODE:\n```\nif (check) happy\n```\n\nLANGUAGE: Scala\nCODE:\n```\nif (check) happy else ()\n```\n\nLANGUAGE: Scala\nCODE:\n```\nwhile (x < 5) { println(x); x += 1}\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndo { println(x); x += 1} while (x < 5)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.util.control.Breaks._\nbreakable {\n  for (x <- xs) {\n    if (Math.random < 0.1)\n      break\n  }\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor (x <- xs if x%2 == 0) yield x*10\n```\n\nLANGUAGE: Scala\nCODE:\n```\nxs.filter(_%2 == 0).map(_*10)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor ((x,y) <- xs zip ys) yield x*y\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(xs zip ys) map { case (x,y) => x*y }\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor (x <- xs; y <- ys) yield x*y\n```\n\nLANGUAGE: Scala\nCODE:\n```\nxs flatMap {x => ys map {y => x*y}}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor (x <- xs; y <- ys) {\n  println(\"%d/%d = %.1f\".format(x, y, x/y.toFloat))\n}\n```\n\n----------------------------------------\n\nTITLE: Object-Oriented Programming in Scala\nDESCRIPTION: Demonstrates class definitions, constructor parameters, inheritance, traits, singleton objects, and type operations in Scala's object-oriented programming model.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/cheatsheets/index.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass C(x: R)\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass C(val x: R)\n```\n\nLANGUAGE: scala\nCODE:\n```\nvar c = new C(4)\n```\n\nLANGUAGE: scala\nCODE:\n```\nc.x\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass C(var x: R) {\n  assert(x > 0, \"positive please\")\n  var y = x\n  val readonly = 5\n  private var secret = 1\n  def this = this(42)\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nnew {\n  ...\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nabstract class D { ... }\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass C extends D { ... }\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass D(var x: R)\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass C(x: R) extends D(x)\n```\n\nLANGUAGE: scala\nCODE:\n```\nobject O extends D { ... }\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait T { ... }\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass C extends T { ... }\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass C extends D with T { ... }\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait T1; trait T2\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass C extends T1 with T2\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass C extends D with T1 with T2\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass C extends D { override def f = ...}\n```\n\nLANGUAGE: scala\nCODE:\n```\nnew java.io.File(\"f\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nnew List[Int]\n```\n\nLANGUAGE: scala\nCODE:\n```\nList(1, 2, 3)\n```\n\nLANGUAGE: scala\nCODE:\n```\nclassOf[String]\n```\n\nLANGUAGE: scala\nCODE:\n```\nx.isInstanceOf[String]\n```\n\nLANGUAGE: scala\nCODE:\n```\nx.asInstanceOf[String]\n```\n\nLANGUAGE: scala\nCODE:\n```\nx: String\n```\n\n----------------------------------------\n\nTITLE: Using a Generic Stack with Integer Type in Scala\nDESCRIPTION: An example demonstrating how to instantiate and use the generic Stack class with Integer type. This code shows creating a Stack[Int], pushing elements, and retrieving values with the top method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/generic-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject GenericsTest extends App {\n  val stack = new Stack[Int]\n  stack.push(1)\n  stack.push('a')\n  println(stack.top)\n  stack.pop()\n  println(stack.top)\n}\n```\n\n----------------------------------------\n\nTITLE: Using Methods as Function Parameters in Scala\nDESCRIPTION: Demonstrating how to pass methods as parameters to higher-order functions, with different syntax options from verbose to concise.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/collections-methods.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef double(i: Int) = i * 2\n\n// these all return `List(20, 40, 60, 80, 20)`\na.map(i => double(i))\na.map(double(_))\na.map(double)\n```\n\n----------------------------------------\n\nTITLE: For-comprehensions in Scala\nDESCRIPTION: Shows different ways to use for-comprehensions in Scala for filtering, mapping, destructuring, creating cross products, and imperative-style programming.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nfor (x <- xs if x % 2 == 0)\n  yield x * 10\n```\n\nLANGUAGE: scala\nCODE:\n```\nxs.filter(_ % 2 == 0).map(_ * 10)\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor ((x, y) <- xs zip ys)\n  yield x * y\n```\n\nLANGUAGE: scala\nCODE:\n```\n(xs zip ys) map {\n  case (x, y) => x * y\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor (x <- xs; y <- ys)\n  yield x * y\n```\n\nLANGUAGE: scala\nCODE:\n```\nxs flatMap { x =>\n  ys map { y =>\n    x * y\n  }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor (x <- xs; y <- ys) {\n  val div = x / y.toFloat\n  println(\"%d/%d = %.1f\".format(x, y, div))\n}\n```\n\n----------------------------------------\n\nTITLE: Running Scala Hello World Program from Command Line\nDESCRIPTION: This shell snippet shows how to run a Scala program directly using the `scala run` command. Saving the Scala source to a file named HelloWorld.scala, the example demonstrates the automatic compilation and execution flow, with verbose output indicating compilation and execution steps. It assumes the use of the Scala command-line tool and illustrates how to invoke a program without manual compilation steps.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n> scala run HelloWorld.scala\n```\n\n----------------------------------------\n\nTITLE: Enhanced ScalaTest suite with additional test case for 'cube' function\nDESCRIPTION: This snippet shows an expanded test suite class that includes an additional test case for checking the output of 'cube' when input is 0. It demonstrates how to write multiple test cases within the same class, following naming conventions, and verifying multiple input-output scenarios with assertions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_it/getting-started/sbt-track/testing-scala-with-sbt-on-the-command-line.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport org.scalatest.funsuite.AnyFunSuite\n\nclass CubeCalculatorTest extends AnyFunSuite {\n    test(\"CubeCalculator.cube 3 should be 27\") {\n        assert(CubeCalculator.cube(3) === 27)\n    }\n\n    test(\"CubeCalculator.cube 0 should be 0\") {\n        assert(CubeCalculator.cube(0) === 0)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Constants with 'val'\nDESCRIPTION: Shows how to assign expression results to immutable constants using 'val', including type inference and explicit type declaration. Also indicates that 'val' variables cannot be reassigned.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/basics.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval x = 1 + 1\nprintln(x)\n// x = 3  // This line does not compile\nval x: Int = 1 + 1\n```\n\n----------------------------------------\n\nTITLE: Defining arithmetic functions matching (Int, Int) => Int signature in Scala\nDESCRIPTION: Defines three methods: `add`, `subtract`, and `multiply`, each taking two `Int` parameters and returning an `Int` result. These methods exemplify functions matching the `(Int, Int) => Int` type signature and can be used as function arguments to higher-order methods expecting that signature.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-hofs.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef add(a: Int, b: Int): Int = a + b\ndef subtract(a: Int, b: Int): Int = a - b\ndef multiply(a: Int, b: Int): Int = a * b\n```\n\n----------------------------------------\n\nTITLE: Defining Macro Bundles Using Scala Reflect Blackbox Context in Scala\nDESCRIPTION: This snippet demonstrates a minimal implementation of a macro bundle in Scala, using the blackbox macro context. It defines a class 'Impl' that takes a 'Context' parameter, enabling macro implementations without explicitly specifying the macro context in method signatures. Methods 'mono' and 'poly' showcase how to generate literal Scala expressions statically and parametrically, with 'poly' leveraging Scala's type tags to handle polymorphic macros. The object 'Macros' exposes these macro methods for clients to invoke. Dependencies include scala.reflect.macros.blackbox.Context, and the snippet requires Scala 2.11.x or 2.12.x for support. This encapsulation improves modularity over previous Scala 2.10.x macro implementations based on plain functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/bundles.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.macros.blackbox.Context\n\nclass Impl(val c: Context) {\n  def mono = c.literalUnit\n  def poly[T: c.WeakTypeTag] = c.literal(c.weakTypeOf[T].toString)\n}\n\nobject Macros {\n  def mono = macro Impl.mono\n  def poly[T] = macro Impl.poly[T]\n}\n```\n\n----------------------------------------\n\nTITLE: Using Traits and Mixin Composition in Scala\nDESCRIPTION: This set of snippets introduces traits as interfaces with implementation but without constructor parameters, illustrating multiple trait inheritance and mixin composition. Classes can extend one superclass and mix in multiple traits using 'with'. This facilitates modular design and reuse of behavioral components in Scala. The examples also show trait declarations and class extensions that combine a superclass and traits.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/cheatsheets/index.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\ntrait T { ... }\nclass C extends T { ... }\nclass C extends D with T { ... }\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntrait T1; trait T2\nclass C extends T1 with T2\nclass C extends D with T1 with T2\n```\n\n----------------------------------------\n\nTITLE: 패키지 선언 및 모듈화 구성 스칼라\nDESCRIPTION: 스칼라 파일 상단에 패키지 이름을 선언하여 해당 파일을 특정 네임스페이스(패키지)에 배치하는 기본적인 방법을 보여줍니다. 이 방식은 코드의 모듈화를 가능하게 하고, 프로젝트 디렉토리와 연계하여 유지보수 및 조직 관리를 돕습니다. class User가 users 패키지 내에 정의됩니다. 이 예시의 의존성은 스칼라 컴파일러이며, 입력은 users라는 패키지명, 출력은 해당 패키지에 포함된 User 클래스입니다.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/packages-and-imports.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\npackage users\n\nclass User\n```\n\n----------------------------------------\n\nTITLE: Comprehensions for creating new collections in Python and Scala\nDESCRIPTION: Demonstrates creating a new collection by transforming elements of a range using list comprehension in Python and yielding a Vector in Scala. Inputs: range 1 to 3; outputs: collection of products (10, 20, 30). No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_43\n\nLANGUAGE: Python\nCODE:\n```\nxs = [i * 10 for i in range(1, 4)]\n# xs: [10,20,30]\n```\n\n----------------------------------------\n\nTITLE: シングルトンオブジェクト定義とメンバアクセス - Scala\nDESCRIPTION: objectキーワードによるシングルトンオブジェクトIdFactoryを定義し、privateな可変カウンタを保持しつつcreateメソッドで1つずつ増加した整数IDを生成する例です。カウンタの変化を追跡可能です。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nobject IdFactory {\n  private var counter = 0\n  def create(): Int = {\n    counter += 1\n    counter\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining String to Int Conversion Using Try in Scala\nDESCRIPTION: This snippet provides two concise ways to define a toInt function using Try, returning Success[Int] if parsing succeeds or Failure containing the exception on error. It showcases both block-form and single-expression-form, eliminating explicit try-catch. The function expects a string input and returns Try[Int], encapsulating the computation's result or failure. No prerequisites except importing scala.util.Try.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/functional-error-handling.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef toInt(s: String): Try[Int] = Try {\n    Integer.parseInt(s.trim)\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef toInt(s: String): Try[Int] = Try(Integer.parseInt(s.trim))\n```\n\n----------------------------------------\n\nTITLE: Scala在伴生对象中组织价格函数（Pizza和Topping伴生对象）\nDESCRIPTION: 将`pizzaPrice`和`toppingPrice`函数封装在对应的伴生对象中，将行为与数据模型组织在一起，便于维护和调用。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-fp.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ncase class Pizza(\n  crustSize: CrustSize,\n  crustType: CrustType,\n  toppings: Seq[Topping]\n)\n\n// Pizza的伴生对象\nobject Pizza {\n  def price(p: Pizza): Double = ...\n}\n\nenum Topping:\n  case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions\n\n// Topping的伴生对象\nobject Topping {\n  def price(t: Topping): Double = t match\n    case Cheese | Onions => 0.5\n    case Pepperoni | BlackOlives | GreenOlives => 0.75\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Named Method as Function Reference to map in Scala\nDESCRIPTION: Defines a named method and passes it as a function reference to the map method of a List. Requires: List[Int] named ints and a method double(i: Int): Int. Output: List[Int] where each value is doubled. Illustrates that map can accept both anonymous functions and named methods. Only Scala standard library is needed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/anonymous-functions.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval ints = List(1,2,3)\ndef double(i: Int): Int = i * 2   //a method that doubles an Int\nval doubledInts = ints.map(double)\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait with Concrete and Abstract Methods in Scala\nDESCRIPTION: Creates a Pet trait that has a concrete 'speak' method implementation and an abstract 'comeToMaster' method that must be implemented by extending classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/traits-abstract-mixins.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Pet {\n    def speak = println(\"Yo\")     // concrete implementation of a speak method\n    def comeToMaster(): Unit      // abstract\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Integer Values Using Scala Pattern Matching\nDESCRIPTION: This snippet defines an object that extends App to run a pattern matching function on integer input, mapping specific integers to strings and using a wildcard for all other cases. It demonstrates basic pattern matching syntax and the use of the match keyword in Scala to associate values with specific patterns.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/pattern-matching.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject MatchTest1 extends App {\n  def matchTest(x: Int): String = x match {\n    case 1 => \"one\"\n    case 2 => \"two\"\n    case _ => \"many\"\n  }\n  println(matchTest(3))\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating Data and Calling Companion Object Methods in Scala\nDESCRIPTION: Provides an example showing how to create an instance of the `Pizza` case class using predefined enumeration values (`Small`, `Thin`, `Cheese`, `Onions`). It then demonstrates how to call the `price` function, which is defined in the `Pizza` companion object, passing the created pizza instance to calculate its price. Requires the `Pizza` case class, `Pizza` companion object with the `price` function, and the necessary enumeration values (`CrustSize`, `CrustType`, `Topping`) to be in scope.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-fp.md#_snippet_8\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\nval pizza1 = Pizza(Small, Thin, Seq(Cheese, Onions))\nPizza.price(pizza1)\n```\n\n----------------------------------------\n\nTITLE: Explicitly passing context using 'using' during function invocation in Scala 3\nDESCRIPTION: Shows how to explicitly provide a context value when calling a function that uses 'using' clauses. This approach is useful when multiple context values are available, and specific ones must be chosen explicitly, ensuring correct dependencies are used at runtime.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/ca-context-parameters.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nrenderWebsite(\"/home\")(using config)\n```\n\n----------------------------------------\n\nTITLE: Initializing Singleton Object with Main Function in Scala\nDESCRIPTION: Defines a simple singleton object named HelloWorld with a main function accepting command-line arguments as an array of strings. The main function prints \"Hello, world!\" to standard output. This snippet demonstrates the Scala pattern of using an object as a static container, the absence of static members in Scala, and the basic program entry point. It requires a Scala environment with access to the println standard library function. The input is an optional array of command-line strings, and the output is a console print. The main function returns Unit, indicating no meaningful return value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tutorials/scala-for-java-programmers.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject HelloWorld {\n  def main(args: Array[String]): Unit = {\n    println(\"Hello, world!\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Calling Methods in Scala REPL\nDESCRIPTION: Example showing how to define a method and then call it in the Scala REPL. The REPL displays the method signature after definition and the result after invocation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-repl.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nscala> def sum(a: Int, b: Int): Int = a + b\ndef sum(a: Int, b: Int): Int\n\nscala> sum(2, 2)\nval res2: Int = 4\n```\n\n----------------------------------------\n\nTITLE: Using map Method with Collections in Scala\nDESCRIPTION: Examples of the map method applied to collections, showing how to transform each element into new values with different types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/collections-methods.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nscala> val doubles = oneToTen.map(_ * 2)\ndoubles: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)\n```\n\n----------------------------------------\n\nTITLE: Mapping with Named Function in Scala 2 and 3\nDESCRIPTION: Illustrates using a named method 'double' to transform list elements by multiplying by 2, passed as a function to the 'map' method. Depicts two equivalent usages: explicitly calling the function within the lambda and passing the method name directly. Inputs a List of integers and outputs a new List containing the doubled values. Utilizes Scala standard library List and higher-order functions without mutation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-functions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef double(i: Int): Int = i * 2\n\nval a = List(1, 2, 3).map(i => double(i))   // List(2,4,6)\nval b = List(1, 2, 3).map(double)           // List(2,4,6)\n```\n\n----------------------------------------\n\nTITLE: Вывод типов по умолчанию для числовых данных в Scala\nDESCRIPTION: Иллюстрирует, что целочисленные литералы по умолчанию имеют тип `Int`, а литералы с плавающей запятой - тип `Double`, когда тип выводится автоматически.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-vars-data-types.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval i = 123   // по умолчанию Int\nval j = 1.0   // по умолчанию Double\n```\n\n----------------------------------------\n\nTITLE: Importing the readLine Method in Scala\nDESCRIPTION: Demonstrates how to import the readLine method from the scala.io.StdIn package to read input from the command line.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/command-line-io.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.io.StdIn.readLine\n```\n\n----------------------------------------\n\nTITLE: Handling Option Results with a Match Expression (Scala)\nDESCRIPTION: Illustrates how to consume the `Option[Int]` returned by `toInt` using a `match` expression. This pattern allows for explicit handling of both the `Some(i)` case (success, extracting the value `i`) and the `None` case (failure).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/no-null-values.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntoInt(x) match {\n    case Some(i) => println(i)\n    case None => println(\"That didn't work.\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using Pattern Matching and Copy Method on Case Classes in Scala 2 and 3\nDESCRIPTION: Demonstrates common usages of case classes including pattern matching with `unapply`, structural equality with `equals`, auto-generated `toString` method, and the convenient `copy` method to create modified copies of instances. The example shows matching on a `Person` instance, equality check between instances, printing, and copying a `BaseballTeam` with updated data. These features facilitate immutable data handling and functional programming idioms.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_41\n\nLANGUAGE: scala\nCODE:\n```\n// Case classes can be used as patterns\nchristina match {\n  case Person(n, r) => println(\"name is \" + n)\n}\n\n// `equals` and `hashCode` methods generated for you\nval hannah = Person(\"Hannah\", \"niece\")\nchristina == hannah       // false\n\n// `toString` method\nprintln(christina)        // Person(Christina,niece)\n\n// built-in `copy` method\ncase class BaseballTeam(name: String, lastWorldSeriesWin: Int)\nval cubs1908 = BaseballTeam(\"Chicago Cubs\", 1908)\nval cubs2016 = cubs1908.copy(lastWorldSeriesWin = 2016)\n// result:\n// cubs2016: BaseballTeam = BaseballTeam(Chicago Cubs,2016)\n```\n\nLANGUAGE: scala\nCODE:\n```\n// Case classes can be used as patterns\nchristina match\n  case Person(n, r) => println(\"name is \" + n)\n\n// `equals` and `hashCode` methods generated for you\nval hannah = Person(\"Hannah\", \"niece\")\nchristina == hannah       // false\n\n// `toString` method\nprintln(christina)        // Person(Christina,niece)\n\n// built-in `copy` method\ncase class BaseballTeam(name: String, lastWorldSeriesWin: Int)\nval cubs1908 = BaseballTeam(\"Chicago Cubs\", 1908)\nval cubs2016 = cubs1908.copy(lastWorldSeriesWin = 2016)\n// result:\n// cubs2016: BaseballTeam = BaseballTeam(Chicago Cubs,2016)\n```\n\n----------------------------------------\n\nTITLE: Constructing a Scala List Using '::' and Nil - Scala\nDESCRIPTION: This example builds a new immutable Scala List by chaining elements with the '::' operator and terminating with 'Nil', mirroring the classic Lisp list construction approach. It requires only the core Scala library. The input is a sequence of values, output is a fully constructed List. The accompanying REPL output verifies creation and shows the type and contents of the resulting List.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/list-class.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval ints = List(1, 2, 3)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval list = 1 :: 2 :: 3 :: Nil\n```\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val list = 1 :: 2 :: 3 :: Nil\nlist: List[Int] = List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Scala 3 'Ord' trait and 'max' function with using clause\nDESCRIPTION: Defines the 'Ord' type class trait with a 'greaterThan' method, and a 'max' function that utilizes the 'using' keyword for context parameters in Scala 3. The 'max' function compares two values based on the 'greaterThan' method. This modern syntax streamlines implicit parameter passing via context bounds.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-context-bounds.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n/** Defines how to compare values of type `A` */\ntrait Ord[A]:\n  def greaterThan(a1: A, a2: A): Boolean\n\n/** Returns the maximum of two values */\ndef max[A](a1: A, a2: A)(using ord: Ord[A]): A =\n  if ord.greaterThan(a1, a2) then a1 else a2\n```\n\n----------------------------------------\n\nTITLE: Adding a Dependency in build.sbt\nDESCRIPTION: Shows how to add the `scala-parser-combinators` library dependency to an sbt project. The `libraryDependencies` setting in `build.sbt` is modified using `+=` to append the new dependency, specifying the organization, artifact name (using `%%` for Scala version cross-publishing), and version.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/getting-started/intellij-track/building-a-scala-project-with-intellij-and-sbt.md#_snippet_2\n\nLANGUAGE: sbt\nCODE:\n```\nlibraryDependencies += \"org.scala-lang.modules\" %% \"scala-parser-combinators\" % \"1.1.2\"\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Methods in Scala 3\nDESCRIPTION: Introduces Scala 3 extension methods by adding a new method `makeInt` to the String class. The extension method takes a radix parameter and parses the string to an integer using that base. This allows calling the method directly on string instances. Note: error handling for invalid inputs is not implemented. Requires Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-methods.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nextension (s: String)\n  def makeInt(radix: Int): Int = Integer.parseInt(s, radix)\n\n\"1\".makeInt(2)      // Int = 1\n\"10\".makeInt(2)     // Int = 2\n\"100\".makeInt(2)    // Int = 4\n```\n\n----------------------------------------\n\nTITLE: Defining a Single Extension Method in Scala 3\nDESCRIPTION: Shows the Scala 3 syntax using the `extension` keyword to define a single extension method (`circumference`) for the `Circle` type. The `(c: Circle)` part specifies the type being extended and provides a reference `c` to the instance within the method body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-extension-methods.md#_snippet_3\n\nLANGUAGE: Scala 3\nCODE:\n```\nextension (c: Circle)\n  def circumference: Double = c.radius * math.Pi * 2\n```\n\n----------------------------------------\n\nTITLE: Dequeuing an Element from an Immutable Queue in Scala\nDESCRIPTION: Demonstrates the `dequeue` operation on an immutable Queue. It returns a `Tuple2` (a pair) containing the first element (`element`, which is 1) and a new Queue (`has23`) with the remaining elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/concrete-immutable-collection-classes.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval (element, has23) = has123.dequeue\n```\n\nLANGUAGE: output\nCODE:\n```\nelement: Int = 1\nhas23: scala.collection.immutable.Queue[Int] = Queue(2, 3)\n```\n\n----------------------------------------\n\nTITLE: Defining a Hello World Application in Scala 3 Using @main Annotation\nDESCRIPTION: This Scala 3 snippet defines a `hello` method annotated with `@main`, signaling the compiler to treat it as the program's main entry point. The method prints \"Hello, World!\" directly to standard output using `println`. This approach simplifies the traditional Scala 2 main method pattern by removing the explicit singleton object and main method signature. Requires Scala 3 compiler and runtime for compilation and execution. No input parameters are used, and the method returns Unit implicitly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-hello-world.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n@main def hello() = println(\"Hello, World!\")\n```\n\n----------------------------------------\n\nTITLE: Defining a Class with Private Mutable State in Scala\nDESCRIPTION: Defines a `Counter` class encapsulating a private mutable variable `currentCount`. It provides public methods `tick` to modify the state and `count` to access it. Shows Scala 2 and 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-oop.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nclass Counter {\n  // can only be observed by the method `count`\n  private var currentCount = 0\n\n  def tick(): Unit = currentCount += 1\n  def count: Int = currentCount\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Counter:\n  // can only be observed by the method `count`\n  private var currentCount = 0\n\n  def tick(): Unit = currentCount += 1\n  def count: Int = currentCount\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Case Classes with Guards in Scala\nDESCRIPTION: Demonstrates pattern matching on a `Person` case class within a `speak` method. It extracts the `name` field from the `Person` object and uses `if` guards (`if name == \"Fred\"`) to apply conditions based on the extracted field's value for specific outputs. Shows syntax for Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_28\n\nLANGUAGE: Scala 2\nCODE:\n```\ncase class Person(name: String)\n\ndef speak(p: Person) = p match {\n  case Person(name) if name == \"Fred\" => println(s\"$name says, Yubba dubba doo\")\n  case Person(name) if name == \"Bam Bam\" => println(s\"$name says, Bam bam!\")\n  case _ => println(\"Watch the Flintstones!\")\n}\n\nspeak(Person(\"Fred\"))      // \"Fred says, Yubba dubba doo\"\nspeak(Person(\"Bam Bam\"))   // \"Bam Bam says, Bam bam!\"\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ncase class Person(name: String)\n\ndef speak(p: Person) = p match\n  case Person(name) if name == \"Fred\" => println(s\"$name says, Yubba dubba doo\")\n  case Person(name) if name == \"Bam Bam\" => println(s\"$name says, Bam bam!\")\n  case _ => println(\"Watch the Flintstones!\")\n\nspeak(Person(\"Fred\"))      // \"Fred says, Yubba dubba doo\"\nspeak(Person(\"Bam Bam\"))   // \"Bam Bam says, Bam bam!\"\n```\n\n----------------------------------------\n\nTITLE: Reassigning Values to Mutable Variables in Scala\nDESCRIPTION: Demonstrates that mutable (var) variables can be reassigned with new values after initialization.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-vars-data-types.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nvar msg = \"Hello, world\"\nmsg = \"Aloha\" // 因为可以重新分配 var，所以可以编译\n```\n\n----------------------------------------\n\nTITLE: Formatting For-Comprehensions with Multiple Generators in Scala\nDESCRIPTION: This snippet explains the recommended syntax for for-comprehensions that have multiple generators. It discourages chaining multiple generators inside parentheses separated by semicolons and instead encourages using curly braces for each generator for better readability and scalability. For-comprehensions without yield (used as loops) should combine generators in parentheses rather than using complex nested curly-brace blocks. Examples show correct and incorrect usages emphasizing readability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/control-structures.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n// wrong!\nfor (x <- board.rows; y <- board.files)\n  yield (x, y)\n\n// right!\nfor {\n  x <- board.rows\n  y <- board.files\n} yield (x, y)\n\n// wrong!\nfor {\n  x <- board.rows\n  y <- board.files\n} {\n  printf(\"(%d, %d)\", x, y)\n}\n\n// right!\nfor (x <- board.rows; y <- board.files) {\n  printf(\"(%d, %d)\", x, y)\n}\n```\n\n----------------------------------------\n\nTITLE: Collapsing Leading Zeros with Iterator dropWhile and ++ in Scala\nDESCRIPTION: This Scala function `collapse` demonstrates one way to collapse leading zeros in an `Iterator[Int]` by keeping only the first zero if present and dropping the rest. It uses `it.dropWhile(_ == 0)` to skip subsequent zeros after the first and concatenates the single potentially-kept head element with the rest of the iterator using `Iterator.single(head) ++ rest`. Note that the original iterator should be discarded after calling this function.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/iterators.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\ndef collapse(it: Iterator[Int]) = if (!it.hasNext) Iterator.empty else {\n     | var head = it.next\n     | val rest = if (head == 0) it.dropWhile(_ == 0) else it\n     | Iterator.single(head) ++ rest\n     | }\n```\n\n----------------------------------------\n\nTITLE: Creating a Heterogeneous List and Iterating in Scala\nDESCRIPTION: This code creates a List of type Any, containing various data types such as String, Int, Char, Boolean, and a function literal. It demonstrates that all values in Scala inherit from Any, allowing polymorphic collections. It uses foreach to print each element, including a function which will display as <function> when printed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/first-look-at-types.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval list: List[Any] = List(\n  \"a string\",\n  732,  // an integer\n  'c',  // a character\n  '\\'', // a character with a backslash escape\n  true, // a boolean value\n  () => \"an anonymous function returning a string\"\n)\n\nlist.foreach(element => println(element))\n```\n\n----------------------------------------\n\nTITLE: Setting a Default Tree Structure Printer Using Given in Scala\nDESCRIPTION: Illustrates how to define an implicit or given Printer[Tree] set to Printer.TreeStructure to make printing trees more convenient by default. After the given is declared, calling show on a Tree will automatically use the TreeStructure printer without needing explicit parameters. This snippet imports necessary reflection elements and uses Scala 3's given syntax for implicits.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/reflection.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport quotes.reflect.*\ngiven Printer[Tree] = Printer.TreeStructure\n...\nprintln(tree.show)\n```\n\n----------------------------------------\n\nTITLE: Providing an Implicit uPickle ReadWriter in Scala 2\nDESCRIPTION: Explains how to generate and provide an implicit `ReadWriter` instance for the `PetOwner` case class in Scala 2 using `upickle.default.macroRW`. This implicit instance is necessary for uPickle to automatically deserialize JSON into the `PetOwner` type. Requires the uPickle library and the `PetOwner` case class definition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-deserialize.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport upickle.default._\n\nimplicit val ownerRw: ReadWriter[PetOwner] = macroRW[PetOwner]\n```\n\n----------------------------------------\n\nTITLE: Covariant Generic List Usage with Animal Subtypes in Scala - scala\nDESCRIPTION: Defines an object with a method printAnimalNames that accepts a List of Animal and prints each animal's name. Demonstrates passing lists of Cats and Dogs (subtypes of Animal) to the method, which compiles due to List's covariance on its type parameter. This snippet showcases practical use of covariance facilitating intuitive subtype polymorphism in collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/variances.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nobject CovarianceTest extends App {\n  def printAnimalNames(animals: List[Animal]): Unit = {\n    animals.foreach { animal =>\n      println(animal.name)\n    }\n  }\n\n  val cats: List[Cat] = List(Cat(\"Whiskers\"), Cat(\"Tom\"))\n  val dogs: List[Dog] = List(Dog(\"Fido\"), Dog(\"Rex\"))\n\n  printAnimalNames(cats)\n  // Whiskers\n  // Tom\n\n  printAnimalNames(dogs)\n  // Fido\n  // Rex\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Covariant, Contravariant, and Invariant Classes in Scala\nDESCRIPTION: This snippet demonstrates how to declare a generic class as covariant, contravariant, or invariant using the + and - variance annotations in Scala. No dependencies are required; each class is generic over a single type parameter, and the annotations determine how subtyping works for parameterized versions. Covariant classes allow their type parameter to vary in the same direction as subtyping; contravariant classes in the opposite direction; invariant means no subtyping relationship is assumed. These patterns establish the foundation for advanced type relationships in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/variances.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass Foo[+A] // A covariant class\nclass Bar[-A] // A contravariant class\nclass Baz[A]  // An invariant class\n```\n\n----------------------------------------\n\nTITLE: Extension Methods and Types in the NamedTuple Object for Scala 3\nDESCRIPTION: NamedTuple companion object defines extension methods for named tuples that correspond to standard tuple operations like apply, head, tail, take, drop, ++, map, and zip. It also defines types such as Elem, Head, and Concat to describe results of these methods. This provides full tuple functionality to named tuples, enabling seamless use in tuple programming idioms with named fields.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-tuples.md#_snippet_4\n\n\n\n----------------------------------------\n\nTITLE: Defining a Scala Hello World Application with main Method\nDESCRIPTION: Defines a Scala singleton object named Hello with a main method that accepts an array of strings as arguments and prints \"Hello, world\" to the console. The object keyword creates a single instance similar to a static class in Java, allowing the main method to serve as the program entry point. This snippet requires a Scala build environment to compile and run.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/hello-world-1.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject Hello {\n    def main(args: Array[String]) = {\n        println(\"Hello, world\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Concrete String Iterator Implementation in Scala 2\nDESCRIPTION: Implements the AbsIterator abstract class to iterate over characters in a string. It defines T as Char and implements the required methods for iteration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/mixin-class-composition.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass StringIterator(s: String) extends AbsIterator {\n  type T = Char\n  private var i = 0\n  def hasNext = i < s.length\n  def next() = {\n    val ch = s charAt i\n    i += 1\n    ch\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Futures in Scala\nDESCRIPTION: Demonstrates the creation of multiple `Future` instances by calling a function (`getStockPrice`) that returns a `Future`. Each call immediately initiates the asynchronous computation defined within the `getStockPrice` function, running concurrently.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/futures.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval aaplFuture = getStockPrice(\"AAPL\")\nval amznFuture = getStockPrice(\"AMZN\")\nval googFuture = getStockPrice(\"GOOG\")\n```\n\n----------------------------------------\n\nTITLE: Using Pattern Binding with Guards in Scala 2\nDESCRIPTION: Shows how to use pattern binding (`@`) in Scala 2 match expressions to bind the matched pattern (`Cat(...)`, `Dog(...)`) to a variable (`c`, `d`), allowing access to type-specific methods (`meow`, `bark`) and fields within the `if` guard and case body. Includes trait, case class definitions, and example calls.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_28\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Animal {\n  val name: String\n}\ncase class Cat(name: String) extends Animal {\n  def meow: String = \"Meow\"\n}\ncase class Dog(name: String) extends Animal {\n  def bark: String = \"Bark\"\n}\n\ndef speak(animal: Animal) = animal match {\n  case c @ Cat(name) if name == \"Felix\" => println(s\"$name says, ${c.meow}!\")\n  case d @ Dog(name) if name == \"Rex\" => println(s\"$name says, ${d.bark}!\")\n  case _ => println(\"I don't know you!\")\n}\n\nspeak(Cat(\"Felix\")) // \"Felix says, Meow!\"\nspeak(Dog(\"Rex\"))   // \"Rex says, Bark!\"\n```\n\n----------------------------------------\n\nTITLE: Alternative Scala If Syntax (Curly Braces)\nDESCRIPTION: Shows the traditional curly brace syntax for if/else if/else statements in Scala 3, which is still supported as an alternative to the indent-based syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\nif (i == 0) {\n  println(0)\n} else if (i == 1) {\n  println(1)\n} else {\n  println(\"other\")\n}\n```\n\n----------------------------------------\n\nTITLE: Wildcard import in Scala 2 and 3\nDESCRIPTION: Imports all members from the 'scala.concurrent' package, reducing verbosity when multiple members are needed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/packaging-imports.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.concurrent._  // Scala 2\nimport scala.concurrent.*  // Scala 3\n```\n\n----------------------------------------\n\nTITLE: For Comprehensions and Desugaring to Collection Operations - Scala\nDESCRIPTION: Shows equivalence between for-comprehensions and filter/map, destructuring via zip, and flatMap for cross products. Inputs: collections. Outputs: mapped/filtered/combined results. No dedicated dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nfor (x <- xs if x%2 == 0) yield x*10\n```\n\nLANGUAGE: Scala\nCODE:\n```\nxs.filter(_%2 == 0).map(_*10)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor ((x,y) <- xs zip ys) yield x*y\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(xs zip ys) map { case (x,y) => x*y }\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor (x <- xs; y <- ys) yield x*y\n```\n\nLANGUAGE: Scala\nCODE:\n```\nxs flatMap {x => ys map {y => x*y}}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor (x <- xs; y <- ys) {\n    println(\"%d/%d = %.1f\".format(x, y, x/y.toFloat))\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor (i <- 1 to 5) {\n    println(i)\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor (i <- 1 until 5) {\n    println(i)\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Anonymous Functions in Scala\nDESCRIPTION: Syntax for anonymous functions (lambdas) in Scala, including shorthand notations with underscores and block-style implementations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/cheatsheets/index.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n(x:R) => x*x\n```\n\nLANGUAGE: scala\nCODE:\n```\n(1 to 5).map(_*2)\n```\n\nLANGUAGE: scala\nCODE:\n```\n(1 to 5).reduceLeft( _+_ )\n```\n\nLANGUAGE: scala\nCODE:\n```\n(1 to 5).map( x => x*x )\n```\n\nLANGUAGE: scala\nCODE:\n```\n(1 to 5).map(2*)\n```\n\nLANGUAGE: scala\nCODE:\n```\n(1 to 5).map { x => val y=x*2; println(y); y }\n```\n\nLANGUAGE: scala\nCODE:\n```\n(1 to 5) filter {_%2 == 0} map {_*2}\n```\n\n----------------------------------------\n\nTITLE: Class with Private Mutable State in Scala 3\nDESCRIPTION: This is the Scala 3 equivalent of the Counter class, which manages private mutable state with tick and count methods. Encapsulation is enforced via the private keyword. No external dependencies are necessary; this demonstrates stateful instance management in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nclass Counter:\n  // can only be observed by the method `count`\n  private var currentCount = 0\n\n  def tick(): Unit = currentCount += 1\n  def count: Int = currentCount\n```\n\n----------------------------------------\n\nTITLE: Creating Code Blocks and Accessing Final Expression\nDESCRIPTION: Shows how to group multiple expressions into a block using '{}', with the block's value being the result of the last expression.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/basics.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nprintln({\n  val x = 1 + 1\n  x + 1\n}) // 3\n```\n\n----------------------------------------\n\nTITLE: Creating a Singleton Logger Object with an Info Method - scala\nDESCRIPTION: Defines a singleton object 'Logger' in the 'logging' package containing a method 'info' that accepts a string message and prints it with an INFO prefix. This method can be imported and used globally, showing common usage for logging functionalities. It depends only on Scala's standard I/O. The method allows for centralized logging via a stable path.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/singleton-objects.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\npackage logging\n\nobject Logger {\n  def info(message: String): Unit = println(s\"INFO: $message\")\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching and Variable Binding - Scala\nDESCRIPTION: Demonstrates proper case matching syntax, usage of backticks and capitalization for distinguishing between variable patterns and value equality. Inputs: options, integers. Outputs: results based on successful pattern matches. Highlights common pitfalls and best practices.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\n(xs zip ys) map { case (x,y) => x*y }\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(xs zip ys) map( (x,y) => x*y )\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval v42 = 42\nSome(3) match {\n  case Some(v42) => println(\"42\")\n    case _ => println(\"Not 42\")\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval v42 = 42\nSome(3) match {\n    case Some(`v42`) => println(\"42\")\ncase _ => println(\"Not 42\")\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval UppercaseVal = 42\nSome(3) match {\n  case Some(UppercaseVal) => println(\"42\")\n    case _ => println(\"Not 42\")\n}\n```\n\n----------------------------------------\n\nTITLE: map Operation Using iterableFactory in IterableOps - Scala 3\nDESCRIPTION: In Scala 3 syntax, this trait shows the use of iterableFactory with the map operation, enabling the creation of new mapped collections by invoking the from method of the factory with a view. This approach preserves abstraction over different concrete collection types. It relies on the IterableFactory trait and View.Map for construction.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\ntrait IterableOps[+A, +CC[_], +C]:\n\n  def iterableFactory: IterableFactory[CC]\n  \n  def map[B](f: A => B): CC[B] = \n    iterableFactory.from(View.Map(this, f))  \n```\n\n----------------------------------------\n\nTITLE: Initializing a Future with ExecutionContext in Scala 2 and Scala 3\nDESCRIPTION: Demonstrates how to create a Future representing the asynchronous computation of the inverse of a matrix, supplying an ExecutionContext explicitly in Scala 2 and Scala 3. The Future evaluates the computation non-blocking and returns a placeholder for the eventual result. The examples show both the explicit and implicit passing of ExecutionContext, which manages the thread pool on which the operation runs. Key dependencies include scala.concurrent.Future and scala.concurrent.ExecutionContext.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval inverseFuture: Future[Matrix] = Future {\n  fatMatrix.inverse() // non-blocking long lasting computation\n}(executionContext)\n```\n\nLANGUAGE: scala\nCODE:\n```\nimplicit val ec: ExecutionContext = ...\nval inverseFuture : Future[Matrix] = Future {\n  fatMatrix.inverse()\n} // ec is implicitly passed\n```\n\nLANGUAGE: scala\nCODE:\n```\ngiven ExecutionContext = ...\nval inverseFuture : Future[Matrix] = Future {\n  fatMatrix.inverse()\n} // execution context is implicitly passed\n```\n\n----------------------------------------\n\nTITLE: Using higher-order functions to reduce code duplication in salary promotions\nDESCRIPTION: Shows how to abstract repetitive salary increase calculations into a generic `promotion` method accepting a function, enhancing code reusability and configuration via function parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/higher-order-functions.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nobject SalaryRaiser {\n\n  private def promotion(salaries: List[Double], promotionFunction: Double => Double): List[Double] =\n    salaries.map(promotionFunction)\n\n  def smallPromotion(salaries: List[Double]): List[Double] =\n    promotion(salaries, salary => salary * 1.1)\n\n  def greatPromotion(salaries: List[Double]): List[Double] =\n    promotion(salaries, salary => salary * math.log(salary))\n\n  def hugePromotion(salaries: List[Double]): List[Double] =\n    promotion(salaries, salary => salary * salary)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Tuple in Scala\nDESCRIPTION: Demonstrates how to create a simple tuple with two elements (String and Int) in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/tuples.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval ingrediente = (\"Açucar\" , 25)\n```\n\n----------------------------------------\n\nTITLE: Handling Messages Using Pattern Matching with Case Objects in Scala\nDESCRIPTION: Defines a function `handleMessages` that takes a `Message` and uses pattern matching to process different message types, including case classes and the case object `StopPlaying`. This demonstrates how case objects can be directly matched in `case` statements, making them useful for representing discrete commands or states in messaging systems. Shows syntax for Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_51\n\nLANGUAGE: Scala 2\nCODE:\n```\ndef handleMessages(message: Message): Unit = message match {\n  case PlaySong(name)         => playSong(name)\n  case IncreaseVolume(amount) => changeVolume(amount)\n  case DecreaseVolume(amount) => changeVolume(-amount)\n  case StopPlaying            => stopPlayingSong()\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ndef handleMessages(message: Message): Unit = message match\n  case PlaySong(name)         => playSong(name)\n  case IncreaseVolume(amount) => changeVolume(amount)\n  case DecreaseVolume(amount) => changeVolume(-amount)\n  case StopPlaying            => stopPlayingSong()\n```\n\n----------------------------------------\n\nTITLE: Calling Methods with Default Parameters\nDESCRIPTION: Shows different ways to call methods that have default parameter values, demonstrating how parameters can be omitted when defaults are available.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/methods-most.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nmakeConnection()                 // timeout = 5000, protocol = http\nmakeConnection(2_000)            // timeout = 2000, protocol = http\nmakeConnection(3_000, \"https\")   // timeout = 3000, protocol = https\n```\n\n----------------------------------------\n\nTITLE: Unapply Method Returning Tuple for Pattern Matching in Scala\nDESCRIPTION: This version of the unapply method demonstrates how to return a Tuple2 containing a Person's name and age, making it compatible with Scala's pattern matching. The function requires a Person as input and produces a (String, Int) tuple, promoting destructuring in match expressions. No external dependencies are required. It enables developers to leverage natural idioms like val (name, age) = Person.unapply(p) in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/companion-objects.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass Person(var name: String, var age: Int)\n\nobject Person {\n    def unapply(p: Person): Tuple2[String, Int] = (p.name, p.age)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Scala Future for Asynchronous Operations\nDESCRIPTION: Demonstrates creating a Scala `Future` using `Future.apply` to perform an asynchronous operation, like fetching friends from a social network API (`session.getFriends()`). It requires importing `scala.concurrent._` and an `ExecutionContext` (implicitly provided by `ExecutionContext.Implicits.global`). The result (`List[Friend]`) becomes available in the `Future` `f` once the computation completes successfully.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_6\n\nLANGUAGE: Scala 2\nCODE:\n```\nimport scala.concurrent._\nimport ExecutionContext.Implicits.global\n\nval session = socialNetwork.createSessionFor(\"user\", credentials)\nval f: Future[List[Friend]] = Future {\n  session.getFriends()\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nimport scala.concurrent.*\nimport ExecutionContext.Implicits.global\n\nval session = socialNetwork.createSessionFor(\"user\", credentials)\nval f: Future[List[Friend]] = Future {\n  session.getFriends()\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating type inference in Scala variable declarations and methods\nDESCRIPTION: This snippet shows how Scala automatically infers types for variables and simple methods, such as arithmetic operations and string conversions. It highlights that the compiler deduces types based on initialization expressions and method bodies, reducing the need for explicit type annotations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/type-inference.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject InferenceTest1 extends App {\n  val x = 1 + 2 * 3         // el tipo de  x es Int\n  val y = x.toString()      // el tipo de y es String\n  def succ(x: Int) = x + 1  // el método succ retorna valores Int\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Arity-0 Methods with Side Effects in Scala (2 & 3)\nDESCRIPTION: Shows the convention for defining an arity-0 (zero-parameter) method (`speak`) that performs side effects, such as printing to the console. The convention is to include empty parentheses `()` in the definition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\ndef speak() = println(\"hi\")\n```\n\n----------------------------------------\n\nTITLE: Working with anonymous functions in Scala\nDESCRIPTION: Shows how to create and use anonymous functions (lambdas) in Scala with various syntax forms including underscore notation and block-style functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n(x: R) => x * x\n```\n\nLANGUAGE: scala\nCODE:\n```\n(1 to 5).map(_ * 2)\n```\n\nLANGUAGE: scala\nCODE:\n```\n(1 to 5).reduceLeft(_ + _)\n```\n\nLANGUAGE: scala\nCODE:\n```\n(1 to 5).map(x => x * x)\n```\n\nLANGUAGE: scala\nCODE:\n```\n(1 to 5).map { x =>\n  val y = x * 2\n  println(y)\n  y\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\n(1 to 5) filter {\n  _ % 2 == 0\n} map {\n  _ * 2\n}\n```\n\n----------------------------------------\n\nTITLE: Using for-comprehension with flatMap and withFilter for Futures in Scala 3\nDESCRIPTION: Scala 3 syntax version of the above example that composes Futures with 'for' comprehension using the concise 'for...yield' syntax. Fetches USD and CHF currency quotes asynchronously, filters for profitability, and then performs the purchase operation. The for-comprehension desugars to flatMap and withFilter combinators under the hood.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\nval usdQuote = Future { connection.getCurrentValue(USD) }\nval chfQuote = Future { connection.getCurrentValue(CHF) }\n\nval purchase = for\n  usd <- usdQuote\n  chf <- chfQuote\n  if isProfitable(usd, chf)\nyield connection.buy(amount, chf)\n\npurchase.foreach { amount =>\n  println(\"Purchased \" + amount + \" CHF\")\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Factory Method in a Companion Object (Scala)\nDESCRIPTION: Demonstrates an 'Email' class with a companion object that includes a factory method 'fromString'. This method attempts to parse an email string, returning an 'Option[Email]' to safely handle valid email creation or parsing failures. The example also shows how to handle the 'Option' result using pattern matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/singleton-objects.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass Email(val username: String, val domainName: String)\n\nobject Email {\n  def fromString(emailString: String): Option[Email] = {\n    emailString.split('@') match {\n      case Array(a, b) => Some(new Email(a, b))\n      case _ => None\n    }\n  }\n}\n\nval scalaCenterEmail = Email.fromString(\"scala.center@epfl.ch\")\nscalaCenterEmail match {\n  case Some(email) => println(\n    s\"\"\"Registered an email\n       |Username: ${email.username}\n       |Domain name: ${email.domainName}\n     \"\"\".stripMargin)\n  case None => println(\"Error: could not parse email\")\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass Email(val username: String, val domainName: String)\n\nobject Email:\n  def fromString(emailString: String): Option[Email] = \n    emailString.split('@') match\n      case Array(a, b) => Some(Email(a, b))\n      case _ => None\n\nval scalaCenterEmail = Email.fromString(\"scala.center@epfl.ch\")\nscalaCenterEmail match\n  case Some(email) => println(\n    s\"\"\"Registered an email\n       |Username: ${email.username}\n       |Domain name: ${email.domainName}\n     \"\"\".stripMargin)\n  case None => println(\"Error: could not parse email\")\n```\n\n----------------------------------------\n\nTITLE: Methods with Default Parameter Values\nDESCRIPTION: Demonstrates how to define methods with default parameter values, allowing callers to omit parameters and use the default values automatically.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/methods-most.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n// Scala 2\ndef makeConnection(timeout: Int = 5_000, protocol: String = \"http\") = {\n  println(f\"timeout = ${timeout}%d, protocol = ${protocol}%s\")\n  // more code here ...\n}\n\n// Scala 3\ndef makeConnection(timeout: Int = 5_000, protocol: String = \"http\") =\n  println(f\"timeout = ${timeout}%d, protocol = ${protocol}%s\")\n  // more code here ...\n```\n\n----------------------------------------\n\nTITLE: Embedding Variables with the `s` Interpolator in Scala\nDESCRIPTION: Illustrates the use of the `s` string interpolator in Scala to embed the values of variables (`name`, `age`) directly into a string. The variables are referenced using the `$` prefix after the initial `s` prefix on the string literal.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval name = \"James\"\nval age = 30\nprintln(s\"$name is $age years old\")   // \"James is 30 years old\"\n```\n\n----------------------------------------\n\nTITLE: 调用接受函数参数的方法\nDESCRIPTION: 使用 `sayHello` 方法并传入定义的 `helloJoe` 函数，展示执行该函数的输出结果。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-hofs.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nsayHello(helloJoe)   // prints \"Hello, Joe\"\n```\n\n----------------------------------------\n\nTITLE: Calling Methods in Scala 2 and 3\nDESCRIPTION: Demonstrates invoking previously defined methods and assigning their returned values to variables. Shows typical method call syntax with positional arguments. Inputs correspond to parameter values, outputs are method return results stored in variables.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-methods.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval x = sum(1, 2)\nval y = concatenate(\"foo\", \"bar\")\n```\n\n----------------------------------------\n\nTITLE: Functional Composition of Futures with Exception Handling in Scala 3\nDESCRIPTION: This snippet presents the same 'map' based approach in Scala 3 syntax, demonstrating functional composition and exception propagation when using 'map' with Futures in currency trading scenarios.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\nval rateQuote = Future {\n  connection.getCurrentValue(USD)\n}\n\nval purchase = rateQuote.map { quote =>\n  if isProfitable(quote) then connection.buy(amount, quote)\n  else throw Exception(\"not profitable\")\n}\n\npurchase.foreach { amount =>\n  println(\"Purchased \" + amount + \" USD\")\n```\n\n----------------------------------------\n\nTITLE: Scala Class Constructor Parameter Restrictions\nDESCRIPTION: Explains that parameters marked with 'val' are immutable and accessible externally, while parameters without 'val' or 'var' are private to the class. Demonstrates that attempting to modify a 'val' parameter outside the class results in a compilation error.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/classes.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass Point(val x: Int, val y: Int)\nval point = new Point(1, 2)\npoint.x = 3  // <-- compilation error\n```\n\n----------------------------------------\n\nTITLE: Using Lambdas with List.map in Scala\nDESCRIPTION: Demonstrates two equivalent ways to use lambdas with the map method to multiply each element in a list by 2 - either with a full lambda expression or with the underscore shorthand notation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-functions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval a = List(1, 2, 3).map(i => i * 2)   // List(2,4,6)\nval b = List(1, 2, 3).map(_ * 2)        // List(2,4,6)\n```\n\n----------------------------------------\n\nTITLE: Exception Handling with 'recoverWith' in Futures\nDESCRIPTION: This snippet illustrates using 'recoverWith' to handle exceptions by mapping a failed future to another future, enabling conditional fallback logic in asynchronous currency exchanges, akin to 'flatMap'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\nval purchase = rateQuote.recoverWith {\n  case QuoteChangedException() => Future.successful(0)\n}\n```\n\n----------------------------------------\n\nTITLE: Function Definition in Scala\nDESCRIPTION: Various ways to define and use functions in Scala, including best practices, anonymous functions, and proper return type handling.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/cheatsheets/index.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: Int) = { x*x }\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: Int)   { x*x }\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: Any) = println(x)\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x) = println(x)\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntype R = Double\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: R)\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: => R)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(x:R) => x*x\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(1 to 5).map(_*2)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(1 to 5).reduceLeft( _+_ )\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(1 to 5).map( x => x*x )\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(1 to 5).map(2*)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(1 to 5).map(*2)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(1 to 5).map { x => val y=x*2; println(y); y }\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(1 to 5) filter {_%2 == 0} map {_*2}\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef compose(g:R=>R, h:R=>R) = (x:R) => g(h(x))\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval f = compose({_*2}, {_-1})\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval zscore = (mean:R, sd:R) => (x:R) => (x-mean)/sd\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef zscore(mean:R, sd:R) = (x:R) => (x-mean)/sd\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef zscore(mean:R, sd:R)(x:R) = (x-mean)/sd\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval normer = zscore(7, 0.4) _\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef mapmake[T](g:T=>T)(seq: List[T]) = seq.map(g)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n5.+(3); 5 + 3\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(1 to 5) map (_*2)\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef sum(args: Int*) = args.reduceLeft(_+_)\n```\n\n----------------------------------------\n\nTITLE: Writing a Hello World Scala Object in IntelliJ Scala\nDESCRIPTION: Defines a Scala singleton object named Hello that extends the App trait, implementing a simple Hello World program. Requires Scala SDK installed and configured in IntelliJ. The code outputs the string \"Hello, World!\" to the console when run. This serves as a minimal example to verify the Scala project setup and execution within IntelliJ.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/getting-started/intellij-track/getting-started-with-scala-in-intellij.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject Hello extends App {\n  println(\"Hello, World!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Main Method for Application Entry Point\nDESCRIPTION: Defines a singleton object with a 'main' method accepting an array of strings. Serves as the program's entry point following JVM conventions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/basics.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nobject Main {\n  def main(args: Array[String]): Unit =\n    println(\"Hello, Scala developer!\")\n}\n```\n\n----------------------------------------\n\nTITLE: 使用枚举(enum)定义ADT(Scala 3)\nDESCRIPTION: 展示如何在Scala 3中使用enum构造来定义代数数据类型(ADT)。这个例子定义了三个枚举CrustSize、CrustType和Topping，用于模拟披萨的属性。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-modeling.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nenum CrustSize:\n  case Small, Medium, Large\n\nenum CrustType:\n  case Thin, Thick, Regular\n\nenum Topping:\n  case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions\n```\n\n----------------------------------------\n\nTITLE: Using the copy method to create modified instances of a Scala case class\nDESCRIPTION: This snippet demonstrates creating a copy of an existing 'Message' object with modified 'sender' and 'recipient' fields, using the 'copy' method. It emphasizes that other fields, like 'body', remain unchanged unless explicitly modified.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/case-classes.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Message(sender: String, recipient: String, body: String)\nval message4 = Message(\"julien@bretagne.fr\", \"travis@washington.us\", \"Me zo o komz gant ma amezeg\")\nval message5 = message4.copy(sender = message4.recipient, recipient = \"claire@bourgogne.fr\")\nmessage5.sender  // travis@washington.us\nmessage5.recipient // claire@bourgogne.fr\nmessage5.body  // \"Me zo o komz gant ma amezeg\"\n```\n\n----------------------------------------\n\nTITLE: Declaring Traits and Extending Them with Classes in Scala - Scala\nDESCRIPTION: Shows trait declaration as a type that can contain abstract and concrete methods. Traits support default implementations and multiple trait inheritance. Classes extend traits using extends and override trait methods with override keyword. Trait composition facilitates code reuse.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/tour/basics.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Greeter {\n  def greet(name: String): Unit\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Greeter {\n  def greet(name: String): Unit =\n    println(\"Hello, \" + name + \"!\")\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass DefaultGreeter extends Greeter\n\nclass CustomizableGreeter(prefix: String, postfix: String) extends Greeter {\n  override def greet(name: String): Unit = {\n    println(prefix + name + postfix)\n  }\n}\n\nval greeter = new DefaultGreeter()\ngreeter.greet(\"Scala developer\") // Hello, Scala developer!\n\nval customGreeter = new CustomizableGreeter(\"How are you, \", \"?\")\ncustomGreeter.greet(\"Scala developer\") // How are you, Scala developer?\n```\n\n----------------------------------------\n\nTITLE: Basic match expression example in Scala 3\nDESCRIPTION: Shows the Scala 3 syntax for match expressions, which don't require curly braces and use indentation to denote the case structure. It matches integer values to day names.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\n// `i` is an integer\nval day = i match\n  case 0 => \"Sunday\"\n  case 1 => \"Monday\"\n  case 2 => \"Tuesday\"\n  case 3 => \"Wednesday\"\n  case 4 => \"Thursday\"\n  case 5 => \"Friday\"\n  case 6 => \"Saturday\"\n  case _ => \"invalid day\"   // the default, catch-all\n```\n\n----------------------------------------\n\nTITLE: Creating a Function Variable by Assigning an Anonymous Function in Scala\nDESCRIPTION: Demonstrates how to convert an anonymous function into a named function variable by assigning it to a val. The function takes an Int parameter and returns that value multiplied by 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-function-variables.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval double = (i: Int) => i * 2\n```\n\n----------------------------------------\n\nTITLE: Expression Interpolation in Scala Strings\nDESCRIPTION: Demonstrates how to embed expressions in strings using the ${} syntax with string interpolation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-vars-data-types.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nprintln(s\"2 + 2 = ${2 + 2}\") // 打印 \"2 + 2 = 4\"\n\nval x = -1\nprintln(s\"x.abs = ${x.abs}\") // 打印 \"x.abs = 1\"\n```\n\n----------------------------------------\n\nTITLE: Filtering with Lambdas in Scala Collection Methods\nDESCRIPTION: This snippet shows multiple ways to filter elements from a Scala collection using various lambda syntax forms, all of which result in the same filtered list. Required input is a List[Int], and the output is the list filtered by the predicate. There are no external dependencies. The example demonstrates explicit to concise anonymous function forms, emphasizing type inference and parameter shorthand. Useful as a reference for idiomatic lambda usage.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-methods.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// these functions are all equivalent and return\n// the same data: List(10, 20, 10)\n\na.filter((i: Int) => i < 25)   // 1. most explicit form\na.filter((i) => i < 25)        // 2. `Int` is not required\na.filter(i => i < 25)          // 3. the parens are not required\na.filter(_ < 25)               // 4. `i` is not required\n```\n\n----------------------------------------\n\nTITLE: Handling Option Result with Pattern Matching and For Expressions in Scala\nDESCRIPTION: These snippets demonstrate handling the Option[Int] result from toInt using pattern matching and for-comprehensions. Pattern matching allows differentiating between successful and failed conversions, while the for-expression combines multiple Option results succinctly. Inputs are Option[Int] values; outputs either perform side-effects (e.g., println) or produce an Option of summed integers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/functional-error-handling.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntoInt(x) match {\n    case Some(i) => println(i)\n    case None => println(\"That didn't work.\")\n}\n\nval y = for {\n    a <- toInt(stringA)\n    b <- toInt(stringB)\n    c <- toInt(stringC)\n} yield a + b + c\n```\n\n----------------------------------------\n\nTITLE: Defining and Instantiating a Scala Case Class without 'new'\nDESCRIPTION: Shows how to define a simple 'Person' case class in Scala and create an instance without using the 'new' keyword. This is possible because the compiler automatically generates an 'apply' method in the companion object for case classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/case-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nscala> case class Person(name: String, relation: String)\ndefined class Person\n\n// \"new\" not needed before Person\nscala> val christina = Person(\"Christina\", \"niece\")\nchristina: Person = Person(Christina,niece)\n```\n\n----------------------------------------\n\nTITLE: Pattern matching by type in Scala 3\nDESCRIPTION: Equivalent to the Scala 2 example, this snippet uses Scala 3 syntax with indentation for pattern matching functions. It matches on 'Device' types 'Phone' and 'Computer' and calls respective methods. The structural pattern matching simplifies syntax while maintaining type safety, assuming the same dependencies on Scala 3 and case classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/pattern-matching.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nsealed trait Device\ncase class Phone(model: String) extends Device:\n  def screenOff = \"Turning screen off\"\n\ncase class Computer(model: String) extends Device:\n  def screenSaverOn = \"Turning screen saver on...\"\n\n\ndef goIdle(device: Device): String = device match\n  case p: Phone => p.screenOff\n  case c: Computer => c.screenSaverOn\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Traits (Mixins) in Scala\nDESCRIPTION: Introduces Scala traits (`trait T`), which are similar to interfaces but can contain implemented methods and fields. Demonstrates how a class `C` can extend a single trait (`extends T`) or mix a trait into a class hierarchy (`extends D with T`), enabling mixin composition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/cheatsheets/index.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ntrait T { /* trait members */ }\nclass C extends T { /* ... */ }\nclass C extends D with T { /* ... */ }\n```\n\n----------------------------------------\n\nTITLE: Sending a Simple GET Request with sttp in Scala\nDESCRIPTION: Demonstrates how to send a basic GET request using sttp's quickRequest method and process the response. The example shows importing required libraries, creating and sending a request, and accessing response properties like status code and body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/http-client-request.md#_snippet_0\n\nLANGUAGE: scala 2\nCODE:\n```\nimport sttp.client4.quick._\nimport sttp.client4.Response\n\nval response: Response[String] = quickRequest\n  .get(uri\"https://httpbin.org/get\")\n  .send()\n\nprintln(response.code)\n// prints: 200\n\nprintln(response.body)\n// prints some JSON string\n```\n\nLANGUAGE: scala 3\nCODE:\n```\nimport sttp.client4.quick.*\nimport sttp.client4.Response\n\nval response: Response[String] = quickRequest\n  .get(uri\"https://httpbin.org/get\")\n  .send()\n\nprintln(response.code)\n// prints: 200\n\nprintln(response.body)\n// prints some JSON string\n```\n\n----------------------------------------\n\nTITLE: Matching integers with 'match' expression in Scala\nDESCRIPTION: This snippet demonstrates basic pattern matching in Scala by assigning a random integer to variable 'x' and matching its value against specific cases, returning string representations. It highlights handling of multiple cases with a default fallback.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/pattern-matching.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.util.Random\n\nval x: Int = Random.nextInt(10)\n\nx match {\n  case 0 => \"zero\"\n  case 1 => \"one\"\n  case 2 => \"two\"\n  case _ => \"other\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Equivalent Method and Function in Scala\nDESCRIPTION: Illustrates the distinct syntax for defining a method (`isEvenMethod`) using `def` and an equivalent function (`isEvenFunction`) using lambda syntax (`=>`) in Scala. Both implementations check if an integer is even.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-eta-expansion.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef isEvenMethod(i: Int) = i % 2 == 0         // a method\nval isEvenFunction = (i: Int) => i % 2 == 0   // a function\n```\n\n----------------------------------------\n\nTITLE: Using 'copy' method in Scala 'case' classes to create modified instances\nDESCRIPTION: This snippet demonstrates copying an existing 'case' class instance while updating specific fields using 'copy'. It creates a new immutable object with modified data, exemplifying functional data mutation without side effects, compatible with Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fp-immutable-values.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval elton = reginald.copy(\n  firstName = \"Elton\",   // update the first name\n  lastName = \"John\"      // update the last name\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Factory Methods with Companion Objects - Scala\nDESCRIPTION: Shows a common use case for companion objects: defining `apply` methods to serve as factory methods, allowing object creation without explicitly using the `new` keyword.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_25\n\nLANGUAGE: Scala 2\nCODE:\n```\nclass Person {\n  var name = \"\"\n  var age = 0\n  override def toString = s\"$name is $age years old\"\n}\n\nobject Person {\n  // a one-arg factory method\n  def apply(name: String): Person = {\n    var p = new Person\n    p.name = name\n    p\n  }\n\n  // a two-arg factory method\n  def apply(name: String, age: Int): Person = {\n    var p = new Person\n    p.name = name\n    p.age = age\n    p\n  }\n}\n\nval joe = Person(\"Joe\")\nval fred = Person(\"Fred\", 29)\n\n//val joe: Person = Joe is 0 years old\n//val fred: Person = Fred is 29 years old\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nclass Person:\n  var name = \"\"\n  var age = 0\n  override def toString = s\"$name is $age years old\"\n\nobject Person:\n\n  // a one-arg factory method\n  def apply(name: String): Person =\n    var p = new Person\n    p.name = name\n    p\n\n  // a two-arg factory method\n  def apply(name: String, age: Int): Person =\n    var p = new Person\n    p.name = name\n    p.age = age\n    p\n\nend Person\n\nval joe = Person(\"Joe\")\nval fred = Person(\"Fred\", 29)\n\n//val joe: Person = Joe is 0 years old\n//val fred: Person = Fred is 29 years old\n```\n\n----------------------------------------\n\nTITLE: Mixing Multiple Traits into a Class in Scala\nDESCRIPTION: Demonstrates how a Scala class `C` can inherit from multiple traits (`T1`, `T2`) using the `with` keyword. This allows for flexible composition of behaviors. Multiple traits can be mixed in directly or after extending a superclass.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/cheatsheets/index.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ntrait T1; trait T2\nclass C extends T1 with T2\nclass C extends D with T1 with T2\n```\n\n----------------------------------------\n\nTITLE: Extending Multiple Traits with Concrete Methods in Scala\nDESCRIPTION: Shows two Scala traits Adder and Multiplier with concrete method implementations for add and multiply. Then defines a class ScalaMath extending both traits, inheriting their method implementations. Demonstrates instantiating ScalaMath and invoking the methods. This illustrates Scala's trait composition and method inheritance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\ntrait Adder:\n  def add(a: Int, b: Int) = a + b\n\ntrait Multiplier:\n  def multiply(a: Int, b: Int) = a * b\n\nclass ScalaMath extends Adder, Multiplier\n\nval sm = new ScalaMath\nsm.add(1,1)\nsm.multiply(2,2)\n```\n\n----------------------------------------\n\nTITLE: Anonymous Function with Arrow Syntax\nDESCRIPTION: Demonstrates the core syntax of an anonymous function using the arrow notation, showing how parameters are transformed to a result.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-anonymous-functions.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n(i: Int) => i * 2\n```\n\n----------------------------------------\n\nTITLE: Defining OOP Style Class with Primary Constructor in Scala 3\nDESCRIPTION: Defines a Scala class named Person with mutable fields for first name, last name, and age using primary constructor syntax. The class overrides the toString method to produce a descriptive string. This concise Scala syntax contrasts with the more verbose Java style, showing expressive capabilities of Scala classes without adherence to JavaBeans standards.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass Person (\n  var firstName: String,\n  var lastName: String,\n  var age: Int\n):  \n  override def toString = s\"$firstName $lastName is $age years old.\"\n```\n\n----------------------------------------\n\nTITLE: Using match expressions for conditional logic in Scala\nDESCRIPTION: Shows the use of Scala's match expressions for multi-way branching on a month's numeric value. Uses concise arrow syntax to map integer cases to string literals. The underscore (_) acts as a default catch-all case. Matches are exhaustive and prefer expression-based branching rather than statements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_46\n\nLANGUAGE: scala\nCODE:\n```\nval monthAsString = month match\n  case 1 => \"January\"\n  case 2 => \"February\"\n  case _ => \"Other\"\n```\n\n----------------------------------------\n\nTITLE: Creating an Instance with Some Value for Optional Field in Scala 2\nDESCRIPTION: An example showing how to create an Address instance with Some(\"Apt. 2B\") for the optional street2 field in Scala 2, properly wrapping a present value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fp-functional-error-handling.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval santa = new Address(\n  \"123 Main Street\",\n  Some(\"Apt. 2B\"),\n  \"Talkeetna\",\n  \"Alaska\",\n  \"99676\"\n)\n```\n\n----------------------------------------\n\nTITLE: Создание конкретных реализаций коллекций в Scala\nDESCRIPTION: Пример показывает создание конкретных реализаций коллекций типа List и HashMap с использованием инициализации элементами. Код иллюстрирует базовый способ создания коллекций с известными типами, пригодный для типичных сценариев работы с данными в Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/overview.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nList(1, 2, 3)\nHashMap(\"x\" -> 24, \"y\" -> 25, \"z\" -> 26)\n```\n\n----------------------------------------\n\nTITLE: Iterating Map with For Loop in Scala\nDESCRIPTION: Shows how to iterate over the key-value pairs of the `ratings` map using a `for` loop. Tuple destructuring `(name, rating)` is used in the generator to extract the key and value for each map entry, which are then used within a formatted string for printing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/for-loops.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nfor ((name,rating) <- ratings) println(s\"Movie: $name, Rating: $rating\")\n```\n\n----------------------------------------\n\nTITLE: Type-only pattern matching calling methods on matched types - Scala\nDESCRIPTION: Defines an abstract class Device and two case classes (Phone, Computer) extending Device, each with a device-specific method: screenOff or screenSaverOn. The function goIdle matches on the runtime type of the device parameter and calls the relevant method on the matched instance. This demonstrates type test patterns where variables are bound to specific subtypes to invoke subtype-specific behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/pattern-matching.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Device\ncase class Phone(model: String) extends Device {\n  def screenOff = \"Turning screen off\"\n}\ncase class Computer(model: String) extends Device {\n  def screenSaverOn = \"Turning screen saver on...\"\n}\n\ndef goIdle(device: Device) = device match {\n  case p: Phone => p.screenOff\n  case c: Computer => c.screenSaverOn\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Conversion Errors with Option, Scala\nDESCRIPTION: Refactors the string-to-integer conversion method to use functional error handling with Option types. If the conversion is successful, the result is wrapped in `Some`; otherwise, if an exception occurs, it returns `None`. This approach explicitly signals whether a valid integer was produced.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-functional-error-handling.md#_snippet_1\n\nLANGUAGE: Scala 2\nCODE:\n```\ndef makeInt(s: String): Option[Int] =\n  try {\n    Some(Integer.parseInt(s.trim))\n  } catch {\n    case e: Exception => None\n  }\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ndef makeInt(s: String): Option[Int] =\n  try\n    Some(Integer.parseInt(s.trim)\n  catch\n    case e: Exception => None\n```\n\n----------------------------------------\n\nTITLE: Transforming Immutable Collections in Scala\nDESCRIPTION: Demonstrates how to use filter and map functions on an immutable List to create new collections without mutating the original list. This example filters names starting with 'j' and capitalizes them.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-immutable-values.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval a = List(\"jane\", \"jon\", \"mary\", \"joe\")\nval b = a.filter(_.startsWith(\"j\"))\n         .map(_.capitalize)\n```\n\n----------------------------------------\n\nTITLE: Declaring Variables with Type Inference in Scala 2 and 3\nDESCRIPTION: Demonstrates declaring a variable without an explicit type. The Scala compiler infers that the variable holds a String based on the assigned value. Dependencies: none. Input is a string literal assigned to the variable, and output is a variable of inferred type String.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/type-inference.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval businessName = \"Montreux Jazz Café\"\n```\n\n----------------------------------------\n\nTITLE: Calling Methods on a Singleton Object in Scala 2 and Scala 3\nDESCRIPTION: This snippet demonstrates calling methods directly on the singleton object StringUtils to check for empty or null strings. It shows that methods can be accessed without creating an instance, emphasizing the singleton pattern as a replacement for static methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-objects.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval x = StringUtils.isNullOrEmpty(\"\")    // true\nval x = StringUtils.isNullOrEmpty(\"a\")   // false\n```\n\n----------------------------------------\n\nTITLE: Retrieving Keys and Values from a Scala Map\nDESCRIPTION: These snippets illustrate how to extract the keys and values from a Scala Map using the 'keys' and 'values' properties. Input is a Map instance. The 'keys' expression returns an Iterable of keys; 'values' returns an Iterable of values from the Map. No external dependencies are required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/collections-maps.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval keys = m.keys\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval values = m.values\n```\n\n----------------------------------------\n\nTITLE: Using a Singleton Object Method via Import in Scala 2 and 3\nDESCRIPTION: Shows how to import the 'Logger.info' method for use in different classes, enabling logging without qualifying the object. Demonstrates usage in Scala 2 and Scala 3 syntax with example classes creating projects and logging messages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/singleton-objects.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport logging.Logger.info\n\nclass Project(name: String, daysToComplete: Int)\n\nclass Test {\n  val project1 = new Project(\"TPS Reports\", 1)\n  val project2 = new Project(\"Website redesign\", 5)\n  info(\"Created projects\")  // Prints \"INFO: Created projects\"\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport logging.Logger.info\n\nclass Project(name: String, daysToComplete: Int)\n\nclass Test:\n  val project1 = Project(\"TPS Reports\", 1)\n  val project2 = Project(\"Website redesign\", 5)\n  info(\"Created projects\")  // Prints \"INFO: Created projects\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Singleton Object in Scala\nDESCRIPTION: This snippet defines a singleton object `Blah` containing a method `sum` that calculates the sum of a list of integers. It demonstrates how to create globally accessible methods using the `object` keyword and highlights how such objects can be imported or referenced directly. Prerequisites include understanding Scala's `object` keyword and list operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/singleton-objects.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\npackage test\n\nobject Blah {\n  def sum(l: List[Int]): Int = l.sum\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Cloneable and Resetable Traits in Scala\nDESCRIPTION: Defines two Scala traits: Cloneable extends java.lang.Cloneable overriding the clone method to return a Cloneable type, and Resetable providing an abstract reset method with no parameters or return value. These traits represent behaviors for cloning and resetting an object respectively and serve as building blocks for compound types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/compound-types.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Cloneable extends java.lang.Cloneable {\n  override def clone(): Cloneable = { \n    super.clone().asInstanceOf[Cloneable]\n  }\n}\ntrait Resetable {\n  def reset: Unit\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Optional Query Parameter with Cask (Scala 2)\nDESCRIPTION: Defines a Cask web application with an endpoint `/time` that accepts an optional query parameter `city`. The endpoint uses the `Option` type and a default value of `None` to indicate the parameter is optional. It attempts to find a timezone for the provided city and returns the current time formatted for that zone, falling back to the default timezone if no city is provided or found.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/web-server-query-parameters.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport java.time.{ZoneId, ZonedDateTime}\n\nobject Example extends cask.MainRoutes {\n\n  private def getZoneIdForCity(city: String): Option[ZoneId] = {\n    import scala.jdk.CollectionConverters._\n    ZoneId.getAvailableZoneIds.asScala.find(_.endsWith(\"/\" + city)).map(ZoneId.of)\n  }\n\n  @cask.get(\"/time\")\n  def dynamicWithParam(city: Option[String] = None): String = {\n    city match {\n      case Some(value) => getZoneIdForCity(value) match {\n        case Some(zoneId) => s\"Current date is: ${ZonedDateTime.now().withZoneSameInstant(zoneId)}\"\n        case None => s\"Couldn't find time zone for city $value\"\n      }\n      case None => s\"Current date is: ${ZonedDateTime.now()}\"\n    }\n  }\n\n  initialize()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Multi-line Method in Scala 2\nDESCRIPTION: Shows a Scala 2 style method where the body spans multiple lines, featuring local variable assignment and string conversion. Typically used when complex computation or intermediate variables are needed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\ndef getSquareString(input: Double): String = {\n  val square = input * input\n  square.toString\n}\nprintln(getSquareString(2.5)) // 6.25\n```\n\n----------------------------------------\n\nTITLE: Using Generic Stack with Int Type in Scala 2\nDESCRIPTION: Shows how to instantiate the generic Stack class with type parameter Int and perform push and pop operations. Demonstrates that only Int values can be pushed and popped. The example uses Scala 2 new syntax with the new operator and prints results to the console. Requires the previously defined generic Stack class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/generic-classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval stack = new Stack[Int]\nstack.push(1)\nstack.push(2)\nprintln(stack.pop())  // prints 2\nprintln(stack.pop())  // prints 1\n```\n\n----------------------------------------\n\nTITLE: Using Named Parameters for Scala Class Instantiation\nDESCRIPTION: This snippet demonstrates how to use named parameters when instantiating a Scala class. Naming the parameters explicitly can improve code readability, especially when parameters have the same type or when skipping optional (defaulted) parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/constructors-default-values.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass Socket(var timeout: Int, var linger: Int) {\n    override def toString = s\"timeout: $timeout, linger: $linger\"\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval s = new Socket(timeout=2000, linger=3000)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval s = new Socket(2000, 3000)\n```\n\n----------------------------------------\n\nTITLE: Using .map to Transform the Result of a Future in Scala\nDESCRIPTION: Demonstrates use of the map method on a Future to apply a transformation to its eventual result. Dependency on the concurrent Future API is assumed. In this example, the result value is doubled. Input is an existing Future[Int]; output is another Future[Int] representing the mapped result.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/futures.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval b = a.map(_ * 2)\n```\n\n----------------------------------------\n\nTITLE: Using Sequence Methods Directly on Arrays via Implicit ArrayOps (REPL)\nDESCRIPTION: Shows the standard and preferred way to use sequence methods on arrays. Calling 'reverse' directly on the array 'a1' works because of an implicit conversion to ArrayOps, which provides the method. The result remains an Array.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/arrays.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nscala> a1.reverse\nres4: Array[Int] = Array(3, 2, 1)\n```\n\n----------------------------------------\n\nTITLE: Declaring Standard Numeric Types Explicitly Scala\nDESCRIPTION: Demonstrates how to declare variables using `val` and explicitly specify the data type for standard numeric types like `Byte`, `Int`, `Long`, `Short`, `Double`, and `Float` in Scala. This is necessary when the literal value's default type is not the desired one (e.g., `1` defaults to `Int`, but you want `Byte`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/built-in-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval b: Byte = 1\nval x: Int = 1\nval l: Long = 1\nval s: Short = 1\nval d: Double = 2.0\nval f: Float = 3.0\n```\n\n----------------------------------------\n\nTITLE: Constructing Immutable ListMaps in Scala\nDESCRIPTION: This snippet illustrates how to create and query a ListMap in Scala, an immutable map represented as a linked list of key-value pairs. No external dependencies are necessary. The example demonstrates initializing a ListMap with pairs, inspecting its printed structure, and retrieving the value for a key using the standard apply syntax. ListMaps provide linear-time operations and are only practical for very small or frequently front-accessed datasets.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/concrete-immutable-collection-classes.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nscala> val map = scala.collection.immutable.ListMap(1->\"one\", 2->\"two\")\nmap: scala.collection.immutable.ListMap[Int,java.lang.String] =\n   Map(1 -> one, 2 -> two)\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> map(2)\nres30: String = \"two\"\n```\n\n----------------------------------------\n\nTITLE: Testing Membership in Immutable Scala Set - Scala\nDESCRIPTION: Illustrates how to create an immutable Scala Set and test for element membership using both the apply method and contains method. Demonstrates that the apply method on a set acts as a predicate returning true if the element is present, and false if not. No external dependencies are required beyond Scala's standard library. Input is a Set of strings, output is Boolean values indicating membership.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/sets.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval fruit = Set(\"apple\", \"orange\", \"peach\", \"banana\")\nfruit(\"peach\")\nfruit(\"potato\")\n```\n\n----------------------------------------\n\nTITLE: Using Scala 3 Enum Values in Code\nDESCRIPTION: This snippet shows how to import and assign enum values such as 'Small' from 'CrustSize', enabling the use of enumeration options in conditional statements and pattern matching, facilitating control flow based on fixed sets.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\nimport CrustSize.*\nval currentCrustSize = Small\n```\n\n----------------------------------------\n\nTITLE: ケースクラスの比較と値の等価性\nDESCRIPTION: このコードは複数の`Message`インスタンスを生成し、それらの内容の比較を行っています。ケースクラスは参照ではなく内容（構造）により比較されるため、異なるインスタンスでも同一の値なら`==`で等しいと判定されることを示しています。比較の結果は`true`です。依存関係はありません。出力は`true`です。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/case-classes.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Message(sender: String, recipient: String, body: String)\n\nval message2 = Message(\"jorge@catalonia.es\", \"guillaume@quebec.ca\", \"Com va?\")\nval message3 = Message(\"jorge@catalonia.es\", \"guillaume@quebec.ca\", \"Com va?\")\nval messagesAreTheSame = message2 == message3  // true\n```\n\n----------------------------------------\n\nTITLE: Defining Classes, Constructors, and Access Modifiers in Scala\nDESCRIPTION: Multiple snippets illustrating class declarations with constructor parameters, variable visibility, and initialization requirements in Scala. Parameters declared with 'val' or 'var' become class members with public visibility, while unnamed parameters are local only. The class body acts as the constructor and may include assertions. Private members, immutable values via 'val', mutable variables via 'var', and auxiliary constructors (auxiliary constructors require proper syntax though example shows a simplification) are shown. These examples provide a foundation for object-oriented programming in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/cheatsheets/index.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nclass C(x: R)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass C(val x: R)\n\nvar c = new C(4)\nc.x\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass C(var x: R) {\n  assert(x > 0, \"positive please\")\n  var y = x\n  val readonly = 5\n  private var secret = 1\n  def this = this(42)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Stack Class in Scala\nDESCRIPTION: Implementation of a generic Stack class that can store elements of any specified type A. The class includes methods for pushing elements onto the stack, peeking at the top element, and popping elements from the stack using a List as the underlying data structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/generic-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Stack[A] {\n  private var elements: List[A] = Nil\n  def push(x: A): Unit =\n    elements = x :: elements \n  def peek: A = elements.head\n  def pop(): A = {\n    val currentTop = peek\n    elements = elements.tail\n    currentTop\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Class with Methods and Initialization in Scala 3\nDESCRIPTION: Example of a Scala 3 class with constructor parameters, additional fields, methods, and initialization code in the class body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-tools.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass Person(var firstName: String, var lastName: String):\n\n  println(\"initialization begins\")\n  val fullName = firstName + \" \" + lastName\n\n  // a class method\n  def printFullName: Unit =\n    // access the `fullName` field, which is created above\n    println(fullName)\n\n  printFullName\n  println(\"initialization ends\")\n```\n\n----------------------------------------\n\nTITLE: Copying Case Class Instances in Scala\nDESCRIPTION: This example demonstrates the built-in `copy` method available for case classes, which allows creating a new instance by copying an existing one. It shows how to modify specific fields during the copy process (changing `sender` and `recipient` for `message5`), while other fields (`body`) are copied unchanged. This is useful for creating modified versions of immutable data.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/case-classes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ncase class Message(sender: String, recipient: String, body: String)\nval message4 = Message(\"julien@bretagne.fr\", \"travis@washington.us\", \"Me zo o komz gant ma amezeg\")\nval message5 = message4.copy(sender = message4.recipient, recipient = \"claire@bourgogne.fr\")\nmessage5.sender  // travis@washington.us\nmessage5.recipient // claire@bourgogne.fr\nmessage5.body  // \"Me zo o komz gant ma amezeg\"\n```\n\n----------------------------------------\n\nTITLE: Type Safety Check in 'f' Interpolator (Scala 2 & 3)\nDESCRIPTION: Shows compile-time errors in Scala 2 and Scala 3 when an incorrect format specifier (e.g., `%d` expecting an Int) is used with a variable of an incompatible type (e.g., `Double`) in an `f` interpolated string, demonstrating the type safety of the `f` interpolator.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/string-interpolation.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 2 Example Code & Error\nval height: Double = 1.9d\n\nscala> f\"$height%4d\"\n<console>:9: error: type mismatch;\n  found   : Double\n  required: Int\n            f\"$height%4d\"\n              ^\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 3 Example Code & Error\nval height: Double = 1.9d\n\nscala> f\"$height%4d\"\n-- Error: ----------------------------------------------------------------------\n1 |f\"$height%4d\"\n  |   ^^^^^^\n  |   Found: (height : Double), Required: Int, Long, Byte, Short, BigInt\n1 error found\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Covariance with a Method in Scala\nDESCRIPTION: Defines a method `makeTwo` that accepts a `Producer[Buyable]`. Because `Producer` is covariant (`+T`), this method can safely accept producers of subtypes, like `Producer[Book]`, as shown in the subsequent example. The method uses the `price` member, which exists on `Buyable` and its subtypes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-variance.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef makeTwo(p: Producer[Buyable]): Int =\n  p.make.price + p.make.price\n```\n\n----------------------------------------\n\nTITLE: Handling Type Mismatch Errors When Accessing JSON in Scala with uJson\nDESCRIPTION: Shows how uJson handles attempts to cast a JSON value to an incompatible type. It demonstrates that a `ujson.Value.InvalidData` exception is thrown if a value does not conform to the expected type when using methods like `.bool`, `.str`, `.num`, etc. The example attempts to cast a String value to a Boolean, triggering the exception.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-parse.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval name: Boolean = person(\"name\").bool\n// throws a ujson.Value.InvalidData: Expected ujson.Bool (data: \"Peter\")\n```\n\n----------------------------------------\n\nTITLE: Defining immutable data classes with 'case' classes in Scala\nDESCRIPTION: This snippet shows how to define an immutable data model using a 'case' class, where constructor parameters are by default 'val'. It promotes immutability and pattern matching capabilities essential in functional programming. Compatible with Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fp-immutable-values.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class Person(firstName: String, lastName: String)\n```\n\n----------------------------------------\n\nTITLE: Updating elements in mutable Map in Scala\nDESCRIPTION: Updates the value for an existing key in a mutable Map by assigning a new value to that key using the syntax Map(key) = newValue. This operation modifies the Map in place. The input is the key to be updated and the new corresponding value; the output is the Map with the updated entry.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/map-class.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nstates(\"AK\") = \"Alaska, A Really Big State\"\n```\n\n----------------------------------------\n\nTITLE: Declaring Covariant, Contravariant, and Invariant Classes in Scala - scala\nDESCRIPTION: Defines three generic classes in Scala demonstrating covariance (+A), contravariance (-A), and invariance (A) annotations on type parameters. This snippet illustrates the syntax and basic concept of how variance is declared in generic class parameters with no further implementation details.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/variances.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Foo[+A] // 共変クラス\nclass Bar[-A] // 反変クラス\nclass Baz[A]  // 非変クラス\n```\n\n----------------------------------------\n\nTITLE: Defining an ADT with Methods and Companion Object in Scala\nDESCRIPTION: Shows an enhanced ADT (`Option`) definition using Scala 3 `enum`, including an instance method (`isDefined`) within the enum and a factory method (`apply`) in its companion object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-adts-gadts.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nenum Option[+T]:\n  case Some(x: T)\n  case None\n\n  def isDefined: Boolean = this match\n    case None => false\n    case Some(_) => true\n\nobject Option:\n  def apply[T >: Null](x: T): Option[T] =\n    if (x == null) None else Some(x)\n```\n\n----------------------------------------\n\nTITLE: Composing FunFixtures with map2 in MUnit (Scala)\nDESCRIPTION: Illustrates how to combine two `FunFixture` instances using `FunFixture.map2`. This example composes the previously defined `usingTempFile` fixture with itself, resulting in a new `FunFixture[(os.Path, os.Path)]` named `using2TempFiles`. Tests using this composed fixture receive a tuple containing the resources managed by both original fixtures (in this case, two temporary file paths).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-resources.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval using2TempFiles: FunFixture[(os.Path, os.Path)] =\n  FunFixture.map2(usingTempFile, usingTempFile)\n\nusing2TempFiles.test(\"merge two files\") {\n  (file1, file2) =>\n    // body of the test\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval using2TempFiles: FunFixture[(os.Path, os.Path)] =\n  FunFixture.map2(usingTempFile, usingTempFile)\n\nusing2TempFiles.test(\"merge two files\") {\n  (file1, file2) =>\n    // body of the test\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Class Constructors with Default Parameter Values\nDESCRIPTION: Shows how to provide default values for class constructor parameters, allowing for flexible instantiation of objects by optionally omitting some arguments. The 'Point' class parameters 'x' and 'y' default to 0. Demonstrates creating objects with zero or one parameter specified, as well as the importance of named parameters to assign a value out of order.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass Point(var x: Int = 0, var y: Int = 0)\n\nval origin = new Point  // x i y są mają wartość 0\nval point1 = new Point(1)\nprintln(point1.x)  // wyświetla 1\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Point(var x: Int = 0, var y: Int = 0)\nval point2 = new Point(y = 2)\nprintln(point2.y)  // wyświetla 2\n```\n\n----------------------------------------\n\nTITLE: Implementing a Generic Stack Class in Scala\nDESCRIPTION: A basic implementation of a generic Stack data structure in Scala using type parameter T. The class includes methods for push, pop, and accessing the top element, with all operations constrained to the parameterized type T.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/generic-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Stack[T] {\n  var elems: List[T] = Nil\n  def push(x: T): Unit =\n    elems = x :: elems\n  def top: T = elems.head\n  def pop(): Unit = { elems = elems.tail }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Immutable Collections in Scala\nDESCRIPTION: This snippet illustrates the creation of immutable `List` and `Map` instances, which are the default collection types in Scala. Using immutable collections encourages pure functions and simplifies reasoning about code state. Attempts to modify these collections will result in new collection instances or compiler errors depending on the operation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/why-scala-3.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval b = List(1,2,3)       // List is immutable\nval c = Map(1 -> \"one\")   // Map is immutable\n```\n\n----------------------------------------\n\nTITLE: Defining Scala 3 Method Body with Match Expression\nDESCRIPTION: This snippet demonstrates defining a method body using a `match` expression with Scala 3's indentation-based syntax. The `isTruthy` method concisely returns a boolean value determined by pattern matching on the input `a`, illustrating how `match` expressions are commonly used as method bodies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/why-scala-3.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ndef isTruthy(a: Matchable) = a match\n  case 0 | \"\" => false\n  case _ => true\n```\n\n----------------------------------------\n\nTITLE: Converting String to Int Using Option/Some/None (Scala)\nDESCRIPTION: Implements a robust `toInt` function that returns an `Option[Int]`. It wraps the successfully parsed integer in `Some` and returns `None` if the string cannot be parsed, avoiding the ambiguity of the previous example and providing a functional way to handle potential errors.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/no-null-values.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef toInt(s: String): Option[Int] = {\n    try {\n        Some(Integer.parseInt(s.trim))\n    } catch {\n        case e: Exception => None\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dropping elements from a list using drop, dropRight, and dropWhile in Scala\nDESCRIPTION: Illustrates how to use drop, dropRight, and dropWhile methods to remove elements from lists in Scala. Examples demonstrate dropping fixed counts from start or end and dropping elements conditionally with a predicate. Edge cases such as dropping more elements than exist and dropping zero elements are also shown. These methods return new lists reflecting the removals without changing the original lists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-methods.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\noneToTen.drop(1)        // List(2, 3, 4, 5, 6, 7, 8, 9, 10)\noneToTen.drop(5)        // List(6, 7, 8, 9, 10)\n\noneToTen.dropRight(8)   // List(1, 2)\noneToTen.dropRight(7)   // List(1, 2, 3)\n```\n\nLANGUAGE: scala\nCODE:\n```\noneToTen.drop(Int.MaxValue)        // List()\noneToTen.dropRight(Int.MaxValue)   // List()\noneToTen.drop(0)                   // List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\noneToTen.dropRight(0)              // List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n```\n\nLANGUAGE: scala\nCODE:\n```\noneToTen.dropWhile(_ < 5)       // List(5, 6, 7, 8, 9, 10)\nnames.dropWhile(_ != \"chris\")   // List(chris, david)\n```\n\n----------------------------------------\n\nTITLE: Defining a compatible zero-argument function for passing to a higher-order method in Scala\nDESCRIPTION: Defines a method `helloJoe` with no input parameters and no meaningful return value, matching the required function signature `() => Unit`. This function can be passed as an argument to methods like `sayHello` that expect a zero-argument function returning Unit, enabling demonstration of higher-order function invocation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-hofs.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef helloJoe(): Unit = println(\"Hello, Joe\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Point String Interpolator Using Extension Method in Scala 3\nDESCRIPTION: This snippet provides a Scala 3 idiomatic implementation of the custom string interpolator 'p' by defining an extension method on the StringContext class. Similar to the Scala 2 approach, it builds upon the standard 's' interpolator to produce a formatted string, splits the input at the first comma, safely converts both string fragments to Double values with fallback defaults, and returns a Point instance initialized with those x and y values. This approach leverages Scala 3's extension syntax for more concise and modern API design while maintaining the same functionality and usage examples.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\nextension (sc: StringContext)\n  def p(args: Double*): Point = {\n    // reuse the `s`-interpolator and then split on ','\n    val pts = sc.s(args: _*).split(\",\", 2).map { _.toDoubleOption.getOrElse(0.0) }\n    Point(pts(0), pts(1))\n  }\n\nval x=12.0\n\np\"1, -2\"        // Point(1.0, -2.0)\np\"${x/5}, $x\"   // Point(2.4, 12.0)\n```\n\n----------------------------------------\n\nTITLE: Reading List.range Output in Scala REPL\nDESCRIPTION: Demonstrates the result of initializing an integer list using List.range when executed in the Scala REPL. Outputs the contents of the variable and its type. No dependencies or parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/anonymous-functions.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> val ints = List.range(1, 10)\nx: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9)\n```\n\n----------------------------------------\n\nTITLE: Scala 'maxElement' rewritten with context bounds syntax\nDESCRIPTION: Presents a concise version of 'maxElement' employing context bounds syntax '[A: Ord]', which corresponds to an implicit 'Ord[A]' parameter. The method uses 'reduceLeft' with 'max' to determine the maximum element, simplifying code and making the usage of type class constraints more idiomatic in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-context-bounds.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ndef maxElement[A: Ord](as: List[A]): A =\n  as.reduceLeft(max(_, _))\n```\n\n----------------------------------------\n\nTITLE: Creating Vectors in Scala - Scala\nDESCRIPTION: Illustrates different ways to initialize a Vector in Scala, including with integers, strings, and custom Person objects. No external dependencies are required except the definition of a Person class for the third example. All instances are immutable, with types inferred by the Scala compiler. Input: variable assignment with literals or case class instances; Output: Vector containing specified values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/vector-class.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval nums = Vector(1, 2, 3, 4, 5)\n\nval strings = Vector(\"one\", \"two\")\n\nval peeps = Vector(\n    Person(\"Bert\"),\n    Person(\"Ernie\"),\n    Person(\"Grover\")\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a type class 'Showable' in Scala 3\nDESCRIPTION: Defines a parameterized trait 'Showable' with an extension method 'show' for the type 'A' to implement custom string conversion in Scala 3, mimicking Scala 2 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-type-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// a type class\ntrait Showable[A]:\n  extension (a: A) def show: String\n```\n\n----------------------------------------\n\nTITLE: Modeling Compound Data with Case Classes\nDESCRIPTION: This snippet defines the `Pizza` data structure using a `case class`, illustrating how to model compound data (product types) that aggregate multiple attributes. It includes imports for the previously defined enumeration members, showing the slight syntax variation for wildcard imports between Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-fp.md#_snippet_1\n\nLANGUAGE: Scala 2\nCODE:\n```\nimport CrustSize._\nimport CrustType._\nimport Topping._\n\ncase class Pizza(\n  crustSize: CrustSize,\n  crustType: CrustType,\n  toppings: Seq[Topping]\n)\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nimport CrustSize.*\nimport CrustType.*\nimport Topping.*\n\ncase class Pizza(\n  crustSize: CrustSize,\n  crustType: CrustType,\n  toppings: Seq[Topping]\n)\n```\n\n----------------------------------------\n\nTITLE: Scala 3 'maxElement' using 'using' clause, implicit 'Ord' parameter omitted\nDESCRIPTION: Defines 'maxElement' in Scala 3 that reduces a list to find its maximum, utilizing the 'using' syntax to implicitly pass the 'Ord' instance. The method further simplifies by removing the explicit context parameter, showing idiomatic Scala 3 style for implicit context parameters. It depends on the 'max' function to compare elements based on 'Ord'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-context-bounds.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ndef maxElement[A](as: List[A])(using Ord[A]): A =\n  as.reduceLeft(max(_, _))\n```\n\n----------------------------------------\n\nTITLE: Method filter definition using a predicate function parameter in Scala\nDESCRIPTION: Shows the `filter` method signature from Scala's List class, defined as `def filter(p: A => Boolean): List[A]`. This method accepts a predicate function `p` taking an element of type `A` and returning a Boolean, and returns a filtered List of type `A`. This illustrates a common higher-order function pattern where a function parameter controls filtering behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-hofs.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ndef filter(p: A => Boolean): List[A]\n```\n\n----------------------------------------\n\nTITLE: Underscore Syntax for Anonymous Functions in Scala\nDESCRIPTION: Shows the underscore syntax which is a concise way to represent a parameter that appears only once in the function body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-anonymous-functions.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n_ * 2\n```\n\n----------------------------------------\n\nTITLE: Creating Scala 2 'Hello, World!' Entry Point\nDESCRIPTION: Defines a Scala 2 object `Hello` that extends the `App` trait. The code within the object body serves as the main executable block, printing 'Hello, World!' to the console when run. This is the standard way to create a simple executable application in Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/getting-started/intellij-track/getting-started-with-scala-in-intellij.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject Hello extends App {\n  println(\"Hello, World!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Default Value Fallback with getOrElse Pattern - Scala\nDESCRIPTION: This snippet illustrates Option.getOrElse using pattern matching. It yields the contained value if present, else returns a provided default. Inputs are an Option and a default value; output is the wrapped type or the default. No dependencies required. Throws no exceptions and always produces a value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\noption match {\n  case Some(x) => x\n  case None    => y\n}\n```\n\n----------------------------------------\n\nTITLE: Calling Methods Using Named Parameters in Scala 2 and 3\nDESCRIPTION: Illustrates method invocation with named parameters to explicitly associate argument values with parameter names. Improves readability especially when multiple parameters have the same type or default values are involved. The input parameters url and timeout are explicitly named, output is side effect printing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-methods.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nmakeConnection(\n  url = \"https://localhost\",\n  timeout = 2500\n)\n```\n\n----------------------------------------\n\nTITLE: Using headOption for Safe Access in Scala\nDESCRIPTION: Using headOption as a safer alternative to head for accessing the first element of a collection, avoiding exceptions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/collections-methods.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nemptyList.headOption          // None\n```\n\n----------------------------------------\n\nTITLE: Initializing Various Scala Collections Using Apply Syntax\nDESCRIPTION: Demonstrates the standard Scala syntax for creating different types of collections (Iterable, List, Vector, Iterator, Set, HashSet, Map) by invoking the companion object's `apply` method implicitly with initial elements. This concise syntax is a common way to initialize collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/creating-collections-from-scratch.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval a = Iterable()                // An empty collection\nval b = List()                    // The empty list\nval c = List(1.0, 2.0)            // A list with elements 1.0, 2.0\nval d = Vector(1.0, 2.0)          // A vector with elements 1.0, 2.0\nval e = Iterator(1, 2, 3)         // An iterator returning three integers.\nval f = Set(dog, cat, bird)       // A set of three animals\nval g = HashSet(dog, cat, bird)   // A hash set of the same animals\nval h = Map('a' -> 7, 'b' -> 0)   // A map from characters to integers\n```\n\n----------------------------------------\n\nTITLE: Example Successful For Comprehension, Scala\nDESCRIPTION: Provides concrete string inputs that can all be successfully converted to integers using `makeInt`. When executed within the `for` comprehension, the results are combined, and the final output `y` is a `Some` containing the sum of the integers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-functional-error-handling.md#_snippet_5\n\nLANGUAGE: Scala 2\nCODE:\n```\nval stringA = \"1\"\nval stringB = \"2\"\nval stringC = \"3\"\n\nval y = for {\n  a <- makeInt(stringA)\n  b <- makeInt(stringB)\n  c <- makeInt(stringC)\n} yield {\n  a + b + c\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nval stringA = \"1\"\nval stringB = \"2\"\nval stringC = \"3\"\n\nval y = for \n  a <- makeInt(stringA)\n  b <- makeInt(stringB)\n  c <- makeInt(stringC)\nyield\n  a + b + c\n```\n\n----------------------------------------\n\nTITLE: Implementing a filter function with currying to filter integers in Scala\nDESCRIPTION: This Scala function 'filter' takes a list of integers and a predicate function, returning a new list containing only elements that satisfy the predicate. It is utilized with partially applied functions to filter integers divisible by specific numbers. This example illustrates Scala's support for currying and higher-order functions, enabling concise and flexible code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/multiple-parameter-lists.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject CurryTest extends App {\n  \n  def filter(xs: List[Int], p: Int => Boolean): List[Int] =\n    if (xs.isEmpty) xs\n    else if (p(xs.head)) xs.head :: filter(xs.tail, p)\n    else filter(xs.tail, p)\n  \n  def modN(n: Int)(x: Int) = ((x % n) == 0)\n  \n  val nums = List(1, 2, 3, 4, 5, 6, 7, 8)\n  println(filter(nums, modN(2)))\n  println(filter(nums, modN(3)))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Anonymous Functions in Scala\nDESCRIPTION: Examples of anonymous functions in Scala, showing how an inline function can be used with the map method to transform a collection of integers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-function-variables.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval doubledInts = ints.map((i: Int) => i * 2)\n```\n\nLANGUAGE: scala\nCODE:\n```\n(i: Int) => i * 2\n```\n\n----------------------------------------\n\nTITLE: Defining a Case Class in Scala\nDESCRIPTION: Introduces case classes, useful for defining immutable value types with structural equality and pattern matching support. Demonstrates a simple 2D Point data structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Point(x: Int, y: Int)\n```\n\n----------------------------------------\n\nTITLE: Adding Elements to Scala mutable Set in Scala\nDESCRIPTION: Demonstrates how to add elements to a mutable Set using += (single element), chaining += calls, and ++= (multiple elements using a collection). This snippet shows the incremental addition of elements into the set, highlighting that duplicates are ignored silently when added.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/set-class.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nset += 1\nset += 2 += 3\nset ++= Vector(4, 5)\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Integer Values in Scala\nDESCRIPTION: This snippet demonstrates defining a function that uses pattern matching to assign strings based on integer inputs. It showcases matching specific integer values and a default case, illustrating Scala's concise syntax for control flow based on data values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/pattern-matching.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject MatchTest1 extends App {\n  def matchTest(x: Int): String = x match {\n    case 1 => \"one\"\n    case 2 => \"two\"\n    case _ => \"many\"\n  }\n  println(matchTest(3))\n}\n```\n\n----------------------------------------\n\nTITLE: String Interpolation in Scala\nDESCRIPTION: Demonstrates how to embed variables inside strings using the s interpolator and expression evaluation with ${}.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-vars-data-types.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval firstName = \"John\"\nval mi = 'C'\nval lastName = \"Doe\"\n\nprintln(s\"Name: $firstName $mi $lastName\")   // \"Name: John C Doe\"\n```\n\n----------------------------------------\n\nTITLE: クラスのインスタンス生成とメソッド呼び出し - Scala\nDESCRIPTION: newキーワードでGreeterクラスのインスタンスを作成し、greetメソッドを呼び出して挨拶文を表示する例です。コンストラクター引数に必要な文字列を渡しています。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nval greeter = new Greeter(\"Hello, \", \"!\")\ngreeter.greet(\"Scala developer\") // Hello, Scala developer!\n```\n\n----------------------------------------\n\nTITLE: Using Java Date/Time Libraries in Scala\nDESCRIPTION: Demonstrates how to import and use Java's date/time libraries in Scala to format the current date according to French locale conventions. Shows Scala's powerful import syntax and seamless Java interoperability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport java.time.format.{DateTimeFormatter, FormatStyle}\nimport java.time.LocalDate\nimport java.util.Locale._\n\nobject FrenchDate {\n  def main(args: Array[String]): Unit = {\n    val now = LocalDate.now\n    val df = DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG).withLocale(FRANCE)\n    println(df.format(now))\n  }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport java.time.format.{DateTimeFormatter, FormatStyle}\nimport java.time.LocalDate\nimport java.util.Locale.*\n\n@main def FrenchDate: Unit =\n  val now = LocalDate.now\n  val df = DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG).withLocale(FRANCE)\n  println(df.format(now))\n```\n\n----------------------------------------\n\nTITLE: Scala函数定义披萨价格（pizzaPrice）\nDESCRIPTION: 定义纯函数`pizzaPrice`，基于披萨对象模式匹配计算总价格，包括基础价、面饼和配料价格。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-fp.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef pizzaPrice(p: Pizza): Double = p match {\n  case Pizza(crustSize, crustType, toppings) => {\n    val base  = 6.00\n    val crust = crustPrice(crustSize, crustType)\n    val tops  = toppings.map(toppingPrice).sum\n    base + crust + tops\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: For Comprehension with Multiple Generators in Scala\nDESCRIPTION: Shows a more complex for comprehension with two generators and a guard. This example computes all pairs of numbers between 0 and n-1 whose sum equals a given value v, demonstrating how multiple generators can be combined.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/for-comprehensions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef foo(n: Int, v: Int) =\n   for (i <- 0 until n;\n        j <- 0 until n if i + j == v)\n   yield (i, j)\n\nfoo(10, 10).foreach {\n  case (i, j) =>\n    println(s\"($i, $j) \")  // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef foo(n: Int, v: Int) =\n   for i <- 0 until n\n       j <- 0 until n if i + j == v\n   yield (i, j)\n\nfoo(10, 10).foreach {\n  (i, j) => println(s\"($i, $j) \")  // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)\n}\n```\n\n----------------------------------------\n\nTITLE: Functional List Methods in Scala 2 and 3\nDESCRIPTION: Shows various functional operations on an immutable List[Int] that return new lists without mutating the original, including drop, dropWhile, filter, slice, tail, take, and takeWhile. Demonstrates flattening nested lists of integers and applying map and flatMap to convert strings to uppercase and flatten characters. All methods illustrate Scala collections’ focus on immutability and expressive transformations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-collections.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// a sample list\nval a = List(10, 20, 30, 40, 10)      // List(10, 20, 30, 40, 10)\n\na.drop(2)                             // List(30, 40, 10)\na.dropWhile(_ < 25)                   // List(30, 40, 10)\na.filter(_ < 25)                      // List(10, 20, 10)\na.slice(2,4)                          // List(30, 40)\na.tail                                // List(20, 30, 40, 10)\na.take(3)                             // List(10, 20, 30)\na.takeWhile(_ < 30)                   // List(10, 20)\n\n// flatten\nval a = List(List(1,2), List(3,4))\na.flatten                             // List(1, 2, 3, 4)\n\n// map, flatMap\nval nums = List(\"one\", \"two\")\nnums.map(_.toUpperCase)               // List(\"ONE\", \"TWO\")\nnums.flatMap(_.toUpperCase)           // List('O', 'N', 'E', 'T', 'W', 'O')\n```\n\n----------------------------------------\n\nTITLE: Creating and Inspecting Data Instances\nDESCRIPTION: This snippet demonstrates how to create an instance of the `Pizza` case class and access its attributes. It shows that once data structures are defined, creating specific data values and inspecting them is straightforward and identical in both Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-fp.md#_snippet_2\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\nval myFavPizza = Pizza(Small, Regular, Seq(Cheese, Pepperoni))\nprintln(myFavPizza.crustType) // prints Regular\n```\n\n----------------------------------------\n\nTITLE: Using extension methods on Circle instances in Scala\nDESCRIPTION: Examples showing how to call the extension methods on a Circle instance, accessing the added functionality as if it were part of the original class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/methods-most.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\naCircle.circumference\naCircle.diameter\naCircle.area\n```\n\n----------------------------------------\n\nTITLE: Defining Companion Objects for Pizza and Topping in Scala 3\nDESCRIPTION: Example showing how to define a Pizza case class with a companion object, alongside a Topping enum with its companion object in Scala 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-fp.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class Pizza(\n  crustSize: CrustSize,\n  crustType: CrustType,\n  toppings: Seq[Topping]\n)\n\n// сопутствующий объект для case class Pizza\nobject Pizza:\n  // тоже самое, что и `pizzaPrice`\n  def price(p: Pizza): Double = ...\n\nenum Topping:\n  case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions\n\n// сопутствующий объект для перечисления Topping\nobject Topping:\n  // тоже самое, что и `toppingPrice`\n  def price(t: Topping): Double = ...\n```\n\n----------------------------------------\n\nTITLE: Trait with Mixed Abstract and Concrete Members in Scala\nDESCRIPTION: Creating a trait with both abstract members that need implementation and concrete methods with default behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ntrait HasLegs {\n  def numLegs: Int\n  def walk(): Unit\n  def stop() = println(\"Stopped walking\")\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait HasLegs:\n  def numLegs: Int\n  def walk(): Unit\n  def stop() = println(\"Stopped walking\")\n```\n\n----------------------------------------\n\nTITLE: Conditional Expressions Returning Values in Scala\nDESCRIPTION: Demonstrates an if-then-else expression returning a value assigned to 'minValue', choosing between 'a' and 'b'. Scala treats if expressions as expressions returning values, allowing concise inline conditional value assignment.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nval minValue = if a < b then a else b\n```\n\n----------------------------------------\n\nTITLE: Using a Function Variable in Scala\nDESCRIPTION: Shows how to call a function variable directly with arguments and how to pass it to higher-order functions like map.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-function-variables.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval x = double(2)   // 4\n```\n\nLANGUAGE: scala\nCODE:\n```\nList(1, 2, 3).map(double)   // List(2, 4, 6)\n```\n\n----------------------------------------\n\nTITLE: Explicitly Providing Contextual Arguments in Scala 2\nDESCRIPTION: Demonstrates how to explicitly provide a value for a contextual parameter in Scala 2 by passing it like a regular argument.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-context-parameters.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nrenderWebsite(\"/home\")(config)\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterized Enum (Scala)\nDESCRIPTION: This Scala snippet demonstrates defining a parameterized enum. The enum itself declares parameters, and each case member extends the enum type, passing the specific parameter values to the primary constructor.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_68\n\nLANGUAGE: Scala\nCODE:\n```\nenum Color(val rgb: Int):\n  case Red   extends Color(0xFF0000)\n  case Green extends Color(0x00FF00)\n  case Blue  extends Color(0x0000FF)\n```\n\n----------------------------------------\n\nTITLE: Defining a Singleton Object in Scala\nDESCRIPTION: Shows the definition of a singleton object `O` using the `object` keyword in Scala. Objects provide a single instance, often used for utility methods, constants, factory methods (companion objects), or application entry points. Objects can also extend classes or traits (`extends D`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/cheatsheets/index.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nobject O extends D { /* object members */ }\n```\n\n----------------------------------------\n\nTITLE: Scala Class with Default Constructor Parameters\nDESCRIPTION: Defines a 'Point' class with default values for constructor parameters x and y. Enables instantiation with no arguments or specific values for parameters, including named arguments for clarity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/classes.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass Point(var x: Int = 0, var y: Int = 0)\n\nval origin = new Point  // x and y are both 0\nval point1 = new Point(1)\nprintln(point1.x)  // outputs 1\n\n// Creating a point with only y specified via named parameter\nval point2 = new Point(y=2)\nprintln(point2.y)  // outputs 2\n```\n\n----------------------------------------\n\nTITLE: Collapsing Consecutive Zeros in an Iterator in Scala\nDESCRIPTION: Presents two methods for collapsing consecutive zeros in an `Iterator[Int]` down to a single zero. The first uses conditional logic with `next()` and `dropWhile`. The second, more idiomatic approach uses `span` to separate leading zeros and `take(1)` to keep only one, then concatenates (`++`) the result with the rest of the iterator. Both versions are shown for Scala 2 and 3, yielding the same result.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/iterators.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 2 Version 1\nscala> def collapse(it: Iterator[Int]) = if (!it.hasNext) Iterator.empty else {\n      |  var head = it.next\n      |  val rest = if (head == 0) it.dropWhile(_ == 0) else it\n      |  Iterator.single(head) ++ rest\n      |}\ndef collapse(it: Iterator[Int]): Iterator[Int]\n\n// Scala 2 Version 2\nscala> def collapse(it: Iterator[Int]) = {\n      |  val (zeros, rest) = it.span(_ == 0)\n      |  zeros.take(1) ++ rest\n      |}\ndef collapse(it: Iterator[Int]): Iterator[Int]\n\nscala> collapse(Iterator(0, 0, 0, 1, 2, 3, 4)).toList\nval res14: List[Int] = List(0, 1, 2, 3, 4)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 3 Version 1\nscala> def collapse(it: Iterator[Int]) = if !it.hasNext then Iterator.empty else\n      |  var head = it.next\n      |  val rest = if head == 0 then it.dropWhile(_ == 0) else it\n      |  Iterator.single(head) ++ rest\n      |\ndef collapse(it: Iterator[Int]): Iterator[Int]\n\n// Scala 3 Version 2\nscala> def collapse(it: Iterator[Int]) =\n      |  val (zeros, rest) = it.span(_ == 0)\n      |  zeros.take(1) ++ rest\n      |\ndef collapse(it: Iterator[Int]): Iterator[Int]\n\nscala> collapse(Iterator(0, 0, 0, 1, 2, 3, 4)).toList\nval res14: List[Int] = List(0, 1, 2, 3, 4)\n```\n\n----------------------------------------\n\nTITLE: Nesting Scala Value Classes (Disallowed)\nDESCRIPTION: This snippet attempts to define a value class `Outer` whose single parameter is another user-defined value class `Inner`. This form of nesting, where a value class wraps another value class, is currently disallowed due to implementation restrictions, as confirmed by the compiler error.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\nclass Outer(val inner: Inner) extends AnyVal\nclass Inner(val value: Int) extends AnyVal\n```\n\nLANGUAGE: text\nCODE:\n```\nNested.scala:1: error: value class may not wrap another user-defined value class\nclass Outer(val inner: Inner) extends AnyVal\n                ^\n```\n\n----------------------------------------\n\nTITLE: Defining a Named Implicit Conversion using 'given' in Scala 3\nDESCRIPTION: Shows the standard Scala 3 way to define a named implicit conversion from `Int` to `Long`. It uses a `given` instance named `int2long` of the type `scala.Conversion[Int, Long]`, implementing the `apply` method for the conversion logic.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-implicit-conversions.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ngiven int2long: Conversion[Int, Long] with\n  def apply(x: Int): Long = x.toLong\n```\n\n----------------------------------------\n\nTITLE: Simple Hello World Program in Scala\nDESCRIPTION: A minimal Scala program that extends App and prints 'Hello, world' to the console when executed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/scala-build-tool-sbt.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nobject HelloWorld extends App {\n    println(\"Hello, world\")\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Case Classes with Value Semantics and Immutability in Scala - Scala\nDESCRIPTION: Introduces case classes, a special immutable class type that enjoys compiler-generated methods such as equals and toString. Instances can be created without new, and case classes support value equality comparisons out of the box.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/tour/basics.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Point(x: Int, y: Int)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval point = Point(1, 2)\nval anotherPoint = Point(1, 2)\nval yetAnotherPoint = Point(2, 2)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nif (point == anotherPoint) {\n  println(s\"$point and $anotherPoint are the same.\")\n} else {\n  println(s\"$point and $anotherPoint are different.\")\n} // Point(1,2) and Point(1,2) are the same.\n\nif (point == yetAnotherPoint) {\n  println(s\"$point and $yetAnotherPoint are the same.\")\n} else {\n  println(s\"$point and $yetAnotherPoint are different.\")\n} // Point(1,2) and Point(2,2) are different.\n```\n\n----------------------------------------\n\nTITLE: Defining Given Instances in Scala 3\nDESCRIPTION: Shows how to define given instances in Scala 3 that the compiler can use to automatically provide arguments for contextual parameters of matching types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-context-parameters.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval config = Config(8080, \"docs.scala-lang.org\")\n\n// this is the type that we want to provide the\n// canonical value for\n//    vvvvvv\ngiven Config = config\n//             ^^^^^^\n// this is the value the Scala compiler will infer\n// as argument to contextual parameters of type Config\n```\n\n----------------------------------------\n\nTITLE: Using the Custom Generic `map` Method in Scala\nDESCRIPTION: Provides examples demonstrating the usage of the custom generic `map` function. It shows how to define helper functions (`double` for Ints, `strlen` for Strings) and pass them along with corresponding lists (`List[Int]`, `List[String]`) to the `map` function. The comments indicate the expected output lists after the transformations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-write-map-function.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ndef double(i : Int): Int = i * 2\nmap(double, List(1, 2, 3))            // List(2, 4, 6)\n\ndef strlen(s: String): Int = s.length\nmap(strlen, List(\"a\", \"bb\", \"ccc\"))   // List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Converting Java Map to Scala Map using asScala (Scala 2 & 3)\nDESCRIPTION: Shows how to convert a Java Map to a Scala mutable map for Scala collection operations, using the 'asScala' extension method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/conversions-between-java-and-scala-collections.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval m: java.util.Map[String, Int] = HashMap(\"abc\" -> 1, \"hello\" -> 2).asJava\n```\n\n----------------------------------------\n\nTITLE: Triggering Value Class Allocation via Pattern Matching in Scala\nDESCRIPTION: Demonstrates that performing pattern matching on an instance (`p`) of a value class (`P`) necessitates the runtime instantiation of the `P` object. Runtime type checks, like those used in pattern matching, require an actual object instance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nval p = P(3)\np match { // new P instantiated here\n  case P(3) => println(\"Matched 3\")\n  case P(_) => println(\"Not 3\")\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Tail of Sequence in Scala\nDESCRIPTION: Describes the `tail` method, which returns a new sequence containing all elements of the original sequence except for the first one. Like `head`, it works on Strings and throws an `UnsupportedOperationException` when called on an empty sequence.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/collections-methods.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nnums.tail\n```\n\nLANGUAGE: scala\nCODE:\n```\nnames.tail\n```\n\nLANGUAGE: scala\nCODE:\n```\n\"foo\".tail\n```\n\nLANGUAGE: scala\nCODE:\n```\n\"bar\".tail\n```\n\nLANGUAGE: scala\nCODE:\n```\nemptyList.tail\n```\n\n----------------------------------------\n\nTITLE: Scala Swap Collection Elements via Multiple Assignment\nDESCRIPTION: Uses multiple assignment syntax to interchange elements within a collection, emphasizing its convenience over traditional element swapping methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/multiple-assignments.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval a = mutable.ArrayBuffer(1, 2, 3)\n(a(0), a(2)) = (a(2), a(0))\nprintln(a) // ArrayBuffer(3, 2, 1)\n```\n\n----------------------------------------\n\nTITLE: Type Signature Examples for Higher-Order Function Parameters in Scala\nDESCRIPTION: Illustrates general syntax forms for function parameter type signatures used in higher-order functions: () => Unit for functions with no input and no meaningful output, String => Int for functions taking a String and returning an Int, and (Int, Int) => Int for functions with two Int inputs returning Int results. These type signatures establish the contract required for passed functions in Scala methods. They require no dependencies beyond the Scala language. Inputs and outputs vary per signature definition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-hofs.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ndef sayHello(f: () => Unit): Unit\n```\n\nLANGUAGE: Scala\nCODE:\n```\nf: String => Int\n```\n\nLANGUAGE: Scala\nCODE:\n```\nf: (Int, Int) => Int\n```\n\n----------------------------------------\n\nTITLE: Defining a Higher-Order Method Accepting a Function Parameter in Scala\nDESCRIPTION: Defines a method named sayHello that accepts a parameter f, which is a function with no input parameters and no meaningful return value (Unit). The method calls f() within its body. This snippet illustrates the core syntax for declaring a higher-order method that consumes a function. The passed function must conform to the signature () => Unit, meaning it takes no arguments and returns Unit. This example requires the Scala standard library and no additional dependencies. Inputs are the function f itself; the output is Unit after invoking f.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-hofs.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef sayHello(f: () => Unit): Unit = f()\n```\n\n----------------------------------------\n\nTITLE: Iterating Lists with For Loops in Scala 3\nDESCRIPTION: Iterates over ints using Scala 3's indentation-based syntax to print each value. ints must exist and be a collection. Each element triggers a println call for side effects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval ints = List(1, 2, 3, 4, 5)\n\nfor i <- ints do println(i)\n\n```\n\n----------------------------------------\n\nTITLE: 示范传入具体函数（sum 和 multiply）进行调用\nDESCRIPTION: 定义 `sum` 和 `multiply` 方法，并通过 `executeAndPrint` 传入，演示输出结果。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-hofs.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ndef sum(x: Int, y: Int) = x + y\ndef multiply(x: Int, y: Int) = x * y\n\nexecuteAndPrint(sum, 3, 11)       // prints 14\nexecuteAndPrint(multiply, 3, 9)   // prints 27\n```\n\n----------------------------------------\n\nTITLE: Using Option in a for-comprehension with Set - Scala 3\nDESCRIPTION: Illustrates the usage of Option in a for-comprehension together with a Set in Scala 3, showing updated syntax and interoperability provided by IterableOnce. Requires Scala 3.x. The snippet sums values from Set(1) and Option(41) to yield Set(42). Demonstrates syntactic differences and interoperability for Option in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/conversion-between-option-and-the-collections.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nfor\n  a <- Set(1)\n  b <- Option(41)\nyield (a + b)\n// : Set[Int] = Set(42)\n```\n\n----------------------------------------\n\nTITLE: Concise While Loop (Scala 2)\nDESCRIPTION: Shows the single-line syntax for a `while` loop in Scala 2. The loop continues as long as the condition `x >= 0` is true, executing the single statement `x = f(x)`. Requires `x` to be a mutable variable and `f` to be a defined function.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_28\n\nLANGUAGE: Scala\nCODE:\n```\nwhile (x >= 0) { x = f(x) }\n```\n\n----------------------------------------\n\nTITLE: Using Imports Locally Within a Function in Scala 3\nDESCRIPTION: Illustrates local import usage in Scala 3 with the 'sqrtplus1' function, leveraging indentation-based syntax. The function takes an Int parameter 'x', imports 'scala.math.sqrt' inside the function, and returns its square root plus 1.0. No dependencies are required, emphasizing local scoping for imports. The function accepts an integer input and produces a double output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/packages-and-imports.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ndef sqrtplus1(x: Int) =\n  import scala.math.sqrt\n  sqrt(x) + 1.0\n```\n\n----------------------------------------\n\nTITLE: Type-based pattern matching for devices in Scala\nDESCRIPTION: Defines a base trait 'Device' and two case classes 'Phone' and 'Computer'. The function 'goIdle' matches on device type to invoke specific methods, illustrating type-based pattern matching for polymorphic behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/pattern-matching.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Device\ncase class Phone(model: String) extends Device {\n  def screenOff = \"Turning screen off\"\n}\ncase class Computer(model: String) extends Device {\n  def screenSaverOn = \"Turning screen saver on...\"\n}\n\ndef goIdle(device: Device) = device match {\n  case p: Phone => p.screenOff\n  case c: Computer => c.screenSaverOn\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning Tuple Return Values to Named Variables in Scala\nDESCRIPTION: Demonstrates calling a method that returns a tuple and assigning each returned tuple element to separate variables using tuple destructuring. This enables easy access to multiple return values individually with meaningful variable names. Inputs are method invocation, outputs are assigned variables.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/tuples.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval (symbol, currentPrice, bidPrice) = getStockInfo\n```\n\n----------------------------------------\n\nTITLE: Scala 3 'given' import syntax example in object A and B\nDESCRIPTION: This snippet demonstrates how to import all non-given members versus only 'given' instances using different import statements in Scala 3, illustrating scope control of 'given' objects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-given-imports.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject A:\n  class TC\n  given tc: TC = ???\n  def f(using TC) = ???\n\nobject B:\n  import A.*       // import all non-given members\n  import A.given   // import the given instance\n```\n\n----------------------------------------\n\nTITLE: Initializing an Immutable Map in Scala\nDESCRIPTION: This snippet demonstrates how to create an immutable Map in Scala with integer keys and string values using the Map companion object and the '->' syntax for key-value pairs. No special dependencies are needed. Expects properly typed key-value pairs and outputs a Map object that cannot be mutated after construction.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/collections-maps.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval m = Map(\n    1 -> \"a\", \n    2 -> \"b\", \n    3 -> \"c\",\n    4 -> \"d\"\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a type class 'Showable' in Scala 2\nDESCRIPTION: Defines a parameterized trait 'Showable' with an abstract method 'show' to implement custom string representation behavior for any type 'A'. This snippet is for Scala 2 environments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-type-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// a type class\ntrait Showable[A] {\n  def show(a: A): String\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Covariant Linked List with Lower Type Bounds in Scala\nDESCRIPTION: An improved implementation of the linked list that uses covariance (+T) and lower type bounds (U >: T) to properly handle subtyping relationships. This allows for more flexible use while maintaining type safety.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/lower-type-bounds.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class ListNode[+T](h: T, t: ListNode[T]) {\n  def head: T = h\n  def tail: ListNode[T] = t\n  def prepend[U >: T](elem: U): ListNode[U] =\n    ListNode(elem, this)\n}\n```\n\n----------------------------------------\n\nTITLE: Prepending Element to Buffer in Scala\nDESCRIPTION: Prepends a single element 'x' to the beginning of the buffer 'buf'. Note the operator direction: the element is on the left side.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/seqs.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nx +=: buf\n```\n\n----------------------------------------\n\nTITLE: While loop example in Python and Scala\nDESCRIPTION: Illustrates looping constructs executing while a condition remains true, printing values of i from 1 to 2. Inputs: variable i initialized to 1; outputs: printed integers 1 and 2. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_30\n\nLANGUAGE: Scala\nCODE:\n```\nvar i = 1\nwhile i < 3 do\n  println(i)\n  i += 1\n```\n\n----------------------------------------\n\nTITLE: Using if/then/else Conditional Statements in Scala 2 and Scala 3\nDESCRIPTION: Demonstrates the syntax for single-line and multi-line if statements in Scala 2 and Scala 3, including if, if-else, and if-else if-else constructs. Shows how Scala uses expressions that return values instead of statements, supporting assignment from if-else expressions. It includes the optional Scala 3 'end if' syntax for block termination.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nif (x == 1) println(x)\n```\n\nLANGUAGE: scala\nCODE:\n```\nif x == 1 then println(x)\n```\n\nLANGUAGE: scala\nCODE:\n```\nif (x == 1) {\n  println(\"x is 1, as you can see:\")\n  println(x)\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nif x == 1 then\n  println(\"x is 1, as you can see:\")\n  println(x)\n```\n\nLANGUAGE: scala\nCODE:\n```\nif (x == 1) {\n  println(\"x is 1, as you can see:\")\n  println(x)\n} else {\n  println(\"x was not 1\")\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nif x == 1 then\n  println(\"x is 1, as you can see:\")\n  println(x)\nelse\n  println(\"x was not 1\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nif (x < 0)\n  println(\"negative\")\nelse if (x == 0)\n  println(\"zero\")\nelse\n  println(\"positive\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nif x < 0 then\n  println(\"negative\")\nelse if x == 0 then\n  println(\"zero\")\nelse\n  println(\"positive\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nif x == 1 then\n  println(\"x is 1, as you can see:\")\n  println(x)\nend if\n```\n\nLANGUAGE: scala\nCODE:\n```\nval minValue = if (a < b) a else b\n```\n\nLANGUAGE: scala\nCODE:\n```\nval minValue = if a < b then a else b\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef compare(a: Int, b: Int): Int =\n  if (a < b)\n    -1\n  else if (a == b)\n    0\n  else\n    1\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef compare(a: Int, b: Int): Int =\n  if a < b then\n    -1\n  else if a == b then\n    0\n  else\n    1\n```\n\nLANGUAGE: scala\nCODE:\n```\nif (a == b) action()\nprintln(\"Hello\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nif a == b then action()\nprintln(\"Hello\")\n```\n\n----------------------------------------\n\nTITLE: Pattern matching with class field conditions\nDESCRIPTION: Illustrates pattern matching where class fields are filtered with 'if' guards, demonstrating how to incorporate object properties into pattern matching logic.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/match-expressions.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nstock match {\n  case x if (x.symbol == \"XYZ\" && x.price < 20) => buy(x)\n  case x if (x.symbol == \"XYZ\" && x.price > 50) => sell(x)\n  case x => doNothing(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Basic usage of `map` with named function in Scala\nDESCRIPTION: Demonstrates applying a named function `doubleSalary` to each element in a salary sequence using `map`. Highlights collection transformation with first-class functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/higher-order-functions.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval salaries = Seq(20_000, 70_000, 40_000)\nval doubleSalary = (x: Int) => x * 2\nval newSalaries = salaries.map(doubleSalary) // List(40000, 140000, 80000)\n```\n\n----------------------------------------\n\nTITLE: Serializing a Map to JSON with uPickle in Scala\nDESCRIPTION: This code demonstrates how to serialize a Map<String, Int> to a JSON string using uPickle in Scala 2 and 3. It shows the creation of the map, serialization via `upickle.default.write`, and output of the resulting JSON string, which can be used for file storage or network transmission.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-serialize.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval map: Map[String, Int] =\n  Map(\"Toolkitty\" -> 3, \"Scaniel\" -> 5)\nval jsonString: String = upickle.default.write(map)\nprintln(jsonString)\n// prints: {\"Toolkitty\":3,\"Scaniel\":5}\n```\n\n----------------------------------------\n\nTITLE: Using Scala Futures for Asynchronous File I/O\nDESCRIPTION: Provides an example of using `Future.apply` to perform a potentially blocking file I/O operation asynchronously. The code reads a file (`myText.txt`) and searches for the first occurrence of a keyword (`myKeyword`). This operation runs concurrently, returning a `Future[Int]` that will hold the index of the keyword once the file is read and searched.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nval firstOccurrence: Future[Int] = Future {\n  val source = scala.io.Source.fromFile(\"myText.txt\")\n  source.toSeq.indexOfSlice(\"myKeyword\")\n}\n```\n\n----------------------------------------\n\nTITLE: Defining filter Operation for List and Map Traits in Scala 2\nDESCRIPTION: This code provides individual implementations of the filter transformation for both List and Map traits in Scala 2. The List filter accepts a function from A to Boolean, returning a filtered List[A], whereas Map's filter uses a function on key-value pairs, returning a Map[K, V]. This exemplifies the need for abstracting over both collection types and their element types in template-based collections design.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ntrait List[A] {\n  def filter(p: A => Boolean): List[A]\n}\n\ntrait Map[K, V] {\n  def filter(p: ((K, V)) => Boolean): Map[K, V]\n}\n```\n\n----------------------------------------\n\nTITLE: Open Class Declaration for Extension in Scala 3\nDESCRIPTION: This snippet demonstrates how to declare a class as open in Scala 3, allowing it to be extended in other files. The open modifier is required for extensibility outside the class’s source file in Scala 3. No dependencies other than Scala 3 are needed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nopen class Person(name: String)\n```\n\n----------------------------------------\n\nTITLE: Default Parameters in Scala Class and Java Compatibility\nDESCRIPTION: Shows the 'Point' class with default parameters defined in Scala. The Java example demonstrates that attempting to instantiate 'Point' with a single argument causes a compile-time error because Java requires explicit parameter specification due to its lack of native default parameter support.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/default-parameter-values.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n// Point.scala\nclass Point(val x: Double = 0, val y: Double = 0)\n```\n\n----------------------------------------\n\nTITLE: Converting Sequential to Parallel Collections via `.par` in Scala\nDESCRIPTION: Illustrates converting an existing sequential Scala collection (a `Vector`) into its parallel counterpart (`ParVector`) by calling the `.par` method on the sequential instance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/overview.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval pv = Vector(1,2,3,4,5,6,7,8,9).par\n```\n\n----------------------------------------\n\nTITLE: Использование выражений в интерполяции строк (`s`) в Scala\nDESCRIPTION: Демонстрирует вставку произвольных выражений Scala в интерполированную строку с использованием интерполятора `s` и фигурных скобок `${expression}`. Примеры включают сложение и вызов метода.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-vars-data-types.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nprintln(s\"2 + 2 = ${2 + 2}\")   // prints \"2 + 2 = 4\"\n\nval x = -1\nprintln(s\"x.abs = ${x.abs}\")   // prints \"x.abs = 1\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Stack Class in Scala 2\nDESCRIPTION: Defines a generic Stack class that uses a type parameter A to specify the stored element type. It internally manages elements with a List[A], and provides methods push to add elements, peek to return the top element, and pop to remove and return the top element. The class depends on Scala's standard List collection and operates with mutability using a var for elements. Nil represents an empty list, not null.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/generic-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Stack[A] {\n  private var elements: List[A] = Nil\n  def push(x: A): Unit =\n    elements = x :: elements\n  def peek: A = elements.head\n  def pop(): A = {\n    val currentTop = peek\n    elements = elements.tail\n    currentTop\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Thread-Safe Mutable HashMap in Scala\nDESCRIPTION: Demonstrates creating a thread-safe mutable `HashMap` by mixing in the `SynchronizedMap` trait. It defines a `MapMaker` object with a `makeMap` method that returns a new `HashMap` instance mixed with `SynchronizedMap`. The example also overrides the `default` method to provide a custom return value for non-existent keys. Requires importing `Map`, `SynchronizedMap`, and `HashMap` from `scala.collection.mutable`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/maps.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable.{Map,\n    SynchronizedMap, HashMap}\nobject MapMaker {\n  def makeMap: Map[String, String] = {\n      new HashMap[String, String] with\n          SynchronizedMap[String, String] {\n        override def default(key: String) =\n          \"Why do you want to know?\"\n      }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Extension Methods in Scala\nDESCRIPTION: Shows how to add methods to existing classes using extension methods. The example adds geometry-related functionality to a Circle class that cannot be modified directly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_27\n\nLANGUAGE: scala\nCODE:\n```\nimplicit class CircleOps(c: Circle) {\n  def circumference: Double = c.radius * math.Pi * 2\n  def diameter: Double = c.radius * 2\n  def area: Double = math.Pi * c.radius * c.radius\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nextension (c: Circle)\n  def circumference: Double = c.radius * math.Pi * 2\n  def diameter: Double = c.radius * 2\n  def area: Double = math.Pi * c.radius * c.radius\n```\n\n----------------------------------------\n\nTITLE: Deserializing JSON to a Map[String, List[Int]] in Scala\nDESCRIPTION: Demonstrates using `upickle.default.read` to parse a JSON string containing key-value pairs into a Scala `Map`. It specifically targets a `Map[String, List[Int]]`, validating that values are lists of integers. Requires the uPickle library.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-deserialize.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval json = \"\"\"{\"primes\": [2, 3, 5], \"evens\": [2, 4, 6]} \"\"\"\nval map: Map[String, List[Int]] =\n  upickle.default.read[Map[String, List[Int]]](json)\n\nprintln(map(\"primes\"))\n// prints: List(2, 3, 5)\n```\n\n----------------------------------------\n\nTITLE: Creating Immutable Set (Scala)\nDESCRIPTION: This Scala snippet shows how to create an immutable Set instance. It uses `val` for immutability and the `Set()` factory method to initialize the set with elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_57\n\nLANGUAGE: Scala\nCODE:\n```\nval set = Set(\"a\", \"b\", \"c\")\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Tuples in for Comprehension (Scala 2)\nDESCRIPTION: Demonstrates how to destructure tuples within a for comprehension in Scala 2. No special dependencies are needed. The list 'numPairs' contains pairs of Ints, and for each tuple, values 'a' and 'b' are bound and their product is printed. This highlights concise tuple unpacking in iteration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/tuples.md#_snippet_5\n\nLANGUAGE: Scala mdoc\nCODE:\n```\nval numPairs = List((2, 5), (3, -7), (20, 56))\nfor ((a, b) <- numPairs) {\n  println(a * b)\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Hello World Program in Scala 2\nDESCRIPTION: Defines a singleton object 'hello' with a 'main' method which takes command-line arguments and prints \"Hello, World!\" to the standard output. The singleton object pattern is used to create an entry point for the JVM to invoke. This snippet uses standard Scala 2 syntax requiring the 'main' method with an 'Array[String]' parameter. No external dependencies are needed beyond Scala standard library. It demonstrates basic program structure and output. The input parameter 'args' is currently unused and can be ignored.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-hello-world.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject hello {\n  def main(args: Array[String]) = {\n    println(\"Hello, World!\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Java Collections to Scala Collections\nDESCRIPTION: Illustrates the process of converting Java collection types into their corresponding Scala collection types. By importing `scala.jdk.CollectionConverters`, developers can easily bridge the gap between Java and Scala collections, enabling the use of Scala's extensive collection API on data originating from Java libraries.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-features.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.jdk.CollectionConverters.*\nval scalaList: Seq[Integer] = JavaClass.getJavaList().asScala.toSeq\n```\n\n----------------------------------------\n\nTITLE: Defining and Mixing Traits in Scala\nDESCRIPTION: Demonstrates how to define traits with abstract and concrete methods in Scala and combine them in classes. Three traits, Speaker (abstract method), TailWagger, and Runner (concrete methods), are defined. Classes Dog and Cat extend these traits and provide implementations or overrides of trait methods, illustrating trait composition and method overriding. Dependencies include the Scala standard library. Inputs include class constructor parameters or method calls, and outputs are method behaviors such as string returns or printing to the console. This snippet exemplifies modular behavior composition using Scala traits.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/prelude-taste-of-scala.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Speaker {\n    def speak(): String  // has no body, so it’s abstract\n}\n\ntrait TailWagger {\n    def startTail(): Unit = println(\"tail is wagging\")\n    def stopTail(): Unit = println(\"tail is stopped\")\n}\n\ntrait Runner {\n    def startRunning(): Unit = println(\"I’m running\")\n    def stopRunning(): Unit = println(\"Stopped running\")\n}\n\nclass Dog(name: String) extends Speaker with TailWagger with Runner {\n    def speak(): String = \"Woof!\"\n}\n\nclass Cat extends Speaker with TailWagger with Runner {\n    def speak(): String = \"Meow\"\n    override def startRunning(): Unit = println(\"Yeah ... I don’t run\")\n    override def stopRunning(): Unit = println(\"No need to stop\")\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling and Managing Scala Dependencies with sbt in Shell\nDESCRIPTION: This shell snippet shows how to compile a Scala project using the sbt build tool. sbt automatically manages and resolves all project dependencies defined in the 'build.sbt' file without requiring manual virtual environment setup, contrasting with Python's manual environment management. The snippet includes commands to navigate into the project directory and run 'sbt compile' to trigger compilation and dependency resolution.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_44\n\nLANGUAGE: Shell\nCODE:\n```\ncd myapp\nsbt compile\n```\n\n----------------------------------------\n\nTITLE: Creating an Instance of a Case Class in Scala\nDESCRIPTION: Shows how to instantiate a case class 'Email' without using 'new' keyword. Demonstrates ease of object creation and the standard Scala syntax for constructing case class instances with parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/case-classes.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval emailDeJohn = Email(\"john.doe@mail.com\", \"Saudações do John!\", \"Olá Mundo\")\n```\n\n----------------------------------------\n\nTITLE: Partial application using multiple parameter lists in Scala\nDESCRIPTION: This example shows creating a partially applied function from the foldLeft method by fixing the initial collection parameter, resulting in a new function that can later be called with a custom combining function. It demonstrates partial application facilitated by multiple parameter lists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/multiple-parameter-lists.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nval numberFunc = numbers.foldLeft(List[Int]()) _\nval squares = numberFunc((xs, x) => xs :+ x*x)\nprint(squares) // List(1, 4, 9, 16, 25, 36, 49, 64, 81, 100)\nval cubes = numberFunc((xs, x) => xs :+ x*x*x)\nprint(cubes)  // List(1, 8, 27, 64, 125, 216, 343, 512, 729, 1000)\n```\n\n----------------------------------------\n\nTITLE: Mapping with Explicit Parameter Types in Scala Anonymous Functions\nDESCRIPTION: Demonstrates alternative syntax for anonymous functions in Scala by specifying parameter names and/or types explicitly within the map function. Accepts a List[Int] as input and doubles each element. Output: List[Int] with all values multiplied by two. No dependencies. Three syntaxes shown for clarity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/anonymous-functions.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval doubledInts = ints.map(_ * 2)\nval doubledInts = ints.map((i: Int) => i * 2)\nval doubledInts = ints.map(i => i * 2)\n```\n\n----------------------------------------\n\nTITLE: 使用case类特性示例\nDESCRIPTION: 演示了case类的主要特性，包括不可变性、默认的toString方法、字段访问以及copy方法。这个例子创建了Person case类，并展示了如何创建和操作case类实例。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-modeling.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\n// define a case class\ncase class Person(\n  name: String,\n  vocation: String\n)\n\n// create an instance of the case class\nval p = Person(\"Reginald Kenneth Dwight\", \"Singer\")\n\n// a good default toString method\np                // : Person = Person(Reginald Kenneth Dwight,Singer)\n\n// can access its fields, which are immutable\np.name           // \"Reginald Kenneth Dwight\"\np.name = \"Joe\"   // error: can't reassign a val field\n\n// when you need to make a change, use the `copy` method\n// to \"update as you copy\"\nval p2 = p.copy(name = \"Elton John\")\np2               // : Person = Person(Elton John,Singer)\n```\n\n----------------------------------------\n\nTITLE: Defining & Using Extractor Object with Pattern Matching - Scala 3\nDESCRIPTION: Defines a Scala 3 object `CustomerID` as an extractor with `apply` for creating IDs and `unapply` for extracting the name from an ID string. Shows how the extractor is used in a pattern match with Scala 3 syntax, implicitly invoking the `unapply` method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/extractor-objects.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.util.Random\n\nobject CustomerID:\n\n  def apply(name: String) = s\"$name--${Random.nextLong()}\"\n\n  def unapply(customerID: String): Option[String} = \n    val stringArray: Array[String} = customerID.split(\"--\")\n    if stringArray.tail.nonEmpty then Some(stringArray.head) else None\n\nval customer1ID = CustomerID(\"Sukyoung\")  // Sukyoung--23098234908\ncustomer1ID match\n  case CustomerID(name) => println(name)  // prints Sukyoung\n  case _ => println(\"Could not extract a CustomerID\")\n```\n\n----------------------------------------\n\nTITLE: Importing Specific Object Members - Scala\nDESCRIPTION: Shows how to selectively import only certain members from an object using curly braces, preventing the import of unwanted members and potentially avoiding naming conflicts.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_22\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\nimport StringUtils.{truncate, containsWhitespace}\ntruncate(\"Charles Carmichael\", 7)       // \"Charles\"\ncontainsWhitespace(\"Captain Awesome\")   // true\nisNullOrEmpty(\"Morgan Grimes\")          // Not found: isNullOrEmpty (error)\n```\n\n----------------------------------------\n\nTITLE: Generators with if-guards in for loops in Python and Scala\nDESCRIPTION: Demonstrates filtering elements during iteration with conditional guards inside loop bodies. Inputs: integer ranges; outputs: printing values that satisfy nested conditions. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_40\n\nLANGUAGE: Scala\nCODE:\n```\nfor\n  i <- 1 to 10\n  if i % 2 == 0\n  if i < 5\n do\n  println(i)\n```\n\n----------------------------------------\n\nTITLE: Function composition and currying in Scala\nDESCRIPTION: Demonstrates function composition and currying patterns in Scala, including syntax for creating and using higher-order functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef compose(g: R => R, h: R => R) =\n  (x: R) => g(h(x))\n```\n\nLANGUAGE: scala\nCODE:\n```\nval f = compose(_ * 2, _ - 1)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval zscore =\n  (mean: R, sd: R) =>\n    (x: R) =>\n      (x - mean) / sd\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef zscore(mean: R, sd: R) =\n  (x: R) =>\n    (x - mean) / sd\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef zscore(mean: R, sd: R)(x: R) =\n  (x - mean) / sd\n```\n\nLANGUAGE: scala\nCODE:\n```\nval normer =\n  zscore(7, 0.4) _\n```\n\n----------------------------------------\n\nTITLE: Implementing a Recursive Pure Function for List Summation in Scala\nDESCRIPTION: This snippet presents a recursive pure function `sum` to calculate the sum of integers in a `List[Int]`. It uses pattern matching: if the list is empty (`Nil`), it returns 0; otherwise, it adds the `head` element to the recursive sum of the `tail`. This function is pure because its output depends only on the input list, and it doesn't cause side effects. Examples are provided for both Scala 2 and Scala 3 syntax, differing slightly in the `match` expression formatting.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-pure-functions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// Scala 2 Syntax\ndef sum(xs: List[Int]): Int = xs match {\n  case Nil => 0\n  case head :: tail => head + sum(tail)\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\n// Scala 3 Syntax\ndef sum(xs: List[Int]): Int = xs match\n  case Nil => 0\n  case head :: tail => head + sum(tail)\n```\n\n----------------------------------------\n\nTITLE: Using 'flatMap' and 'withFilter' in Scala 3 for Currency Trading\nDESCRIPTION: This snippet demonstrates the same complex future chaining with 'flatMap' and 'withFilter' in Scala 3 syntax, showing how to coordinate multiple asynchronous data fetches (USD and CHF quotes) for a conditional purchase operation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\nval usdQuote = Future { connection.getCurrentValue(USD) }\nval chfQuote = Future { connection.getCurrentValue(CHF) }\n\nval purchase = for\n  usd <- usdQuote\n  chf <- chfQuote\n  if isProfitable(usd, chf)\nyield connection.buy(amount, chf)\n\npurchase.foreach { amount =>\n  println(\"Purchased \" + amount + \" CHF\")\n```\n\n----------------------------------------\n\nTITLE: Scala 2 and 3: Passing a Method to `map` Function\nDESCRIPTION: Demonstrates passing a method `times10` to the `map` function of a list, relying on implicit eta-expansion to convert the method into a function of type `Int => Int`. It highlights Scala’s automatic conversion from methods to functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-eta-expansion.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef times10(i: Int) = i * 10\nList(1, 2, 3).map(times10)\n// Result: List(10, 20, 30)\n```\n\n----------------------------------------\n\nTITLE: Basic Integer Pattern Matching in Scala\nDESCRIPTION: A basic example showing pattern matching on random integer values with specific cases for 0, 1, 2, and a catch-all case for other values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/pattern-matching.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.util.Random\n\nval x: Int = Random.nextInt(10)\n\nx match {\n  case 0 => \"zero\"\n  case 1 => \"one\"\n  case 2 => \"two\"\n  case _ => \"other\"\n}\n```\n\n----------------------------------------\n\nTITLE: ブロック式による複数式のまとめ - Scala\nDESCRIPTION: 複数の式を{}で囲み一つのブロック式としてまとめる例です。ブロック内の最後の式の結果がブロック全体の値となることを示しています。ローカルなvalの定義と利用の流れを理解可能です。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nprintln({\n  val x = 1 + 1\n  x + 1\n}) // 3\n```\n\n----------------------------------------\n\nTITLE: Universal Predicate Check with forall Pattern - Scala\nDESCRIPTION: This snippet models Option.forall using pattern matching. Returns true if the Option is empty, or if present and the value satisfies predicate f; returns false otherwise. Input: Option, predicate function; Output: Boolean. No special dependencies required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\noption match {\n  case Some(x) if f(x) => true\n  case Some(_)         => false\n  case None            => true\n}\n```\n\n----------------------------------------\n\nTITLE: Using if Guards in Scala match Expression Cases\nDESCRIPTION: Explains how to use `if` guards within `case` statements to add further conditional logic to pattern matching. The guard (`if x == 2 || x == 3` or `if x > 3`) is evaluated only if the pattern (`x`) matches, allowing for more refined matching criteria. Shows syntax for Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_26\n\nLANGUAGE: Scala 2\nCODE:\n```\ni match {\n  case 1 => println(\"one, a lonely number\")\n  case x if x == 2 || x == 3 => println(\"two’s company, three’s a crowd\")\n  case x if x > 3 => println(\"4+, that’s a party\")\n  case _ => println(\"i’m guessing your number is zero or less\")\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ni match\n  case 1 => println(\"one, a lonely number\")\n  case x if x == 2 || x == 3 => println(\"two’s company, three’s a crowd\")\n  case x if x > 3 => println(\"4+, that’s a party\")\n  case _ => println(\"i’m guessing your number is zero or less\")\n```\n\n----------------------------------------\n\nTITLE: Using Advanced Features of Scala Case Classes: Pattern Matching, equals, hashCode, toString, and copy (Scala 2 and 3)\nDESCRIPTION: Illustrates how Scala case classes auto-generate important methods. Pattern matching extracts values using unapply. equals and hashCode enable structural equality checks. toString provides human-readable representation. copy creates modified copies of instances without mutation. The snippets use matches on Person instances and copying of BaseballTeam instances with updated fields.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-tools.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\n// Case classes can be used as patterns\nchristina match {\n  case Person(n, r) => println(\"name is \" + n)\n}\n\n// `equals` and `hashCode` methods generated for you\nval hannah = Person(\"Hannah\", \"niece\")\nchristina == hannah       // false\n\n// `toString` method\nprintln(christina)        // Person(Christina,niece)\n\n// built-in `copy` method\ncase class BaseballTeam(name: String, lastWorldSeriesWin: Int)\nval cubs1908 = BaseballTeam(\"Chicago Cubs\", 1908)\nval cubs2016 = cubs1908.copy(lastWorldSeriesWin = 2016)\n// result:\n// cubs2016: BaseballTeam = BaseballTeam(Chicago Cubs,2016)\n```\n\n----------------------------------------\n\nTITLE: Function Definitions and Syntax in Scala\nDESCRIPTION: Shows correct and incorrect ways of defining functions, highlighting the importance of syntax, return types, and proper parameter typing. Also covers anonymous functions, function composition, and lambda expressions with examples.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/cheatsheets/index.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: Int) = { x * x }\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: Int)   { x * x }\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: Any) = println(x)\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x) = println(x)\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntype R = Double\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: R)\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: => R)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(x: R) => x * x\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(1 to 5).map(_ * 2)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(1 to 5).reduceLeft(_ + _)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(1 to 5).map(x => x * x)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(1 to 5).map { x =>\n  val y = x * 2\n  println(y)\n  y\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(1 to 5) filter {\n  _ % 2 == 0\n} map {\n  _ * 2\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef compose(g: R => R, h: R => R) =\n  (x: R) => g(h(x))\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval f = compose(_ * 2, _ - 1)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval zscore =\n  (mean: R, sd: R) =>\n    (x: R) =>\n      (x - mean) / sd\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef zscore(mean: R, sd: R) =\n  (x: R) =>\n    (x - mean) / sd\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef zscore(mean: R, sd: R)(x: R) =\n  (x - mean) / sd\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval normer =\n  zscore(7, 0.4) _\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef mapmake[T](g: T => T)(seq: List[T]) =\n  seq.map(g)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n5.+(3); 5 + 3\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(1 to 5) map (_ * 2)\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef sum(args: Int*) =\n  args.reduceLeft(_+_)\n```\n\n----------------------------------------\n\nTITLE: Using Methods as Parameters to Higher-Order Functions in Scala\nDESCRIPTION: Examples showing how to pass methods as parameters to higher-order functions like map, demonstrating different syntax variations for the same operation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-methods.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef double(i: Int) = i * 2\n\n// these all return `List(20, 40, 60, 80, 20)`\na.map(i => double(i))\na.map(double(_))\na.map(double)\n```\n\n----------------------------------------\n\nTITLE: Defining Pizza Functional Methods Using Extension Methods in Scala 3\nDESCRIPTION: Defines functional methods for the Pizza class as Scala 3 extension methods using the `extension` keyword. The extension applies to objects of type Pizza (denoted by parameter `p`) and adds price, addTopping, removeAllToppings, updateCrustSize, and updateCrustType methods that return updated immutable copies or a computed price. This modern Scala 3 pattern allows adding behavior modularly without altering the original data type and provides concise syntax for retroactive enrichment.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-fp.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ncase class Pizza(\n  crustSize: CrustSize,\n  crustType: CrustType,\n  toppings: Seq[Topping]\n)\n\nextension (p: Pizza)\n  def price: Double =\n    pizzaPrice(p) // такая же имплементация, как и выше\n\n  def addTopping(t: Topping): Pizza =\n    p.copy(toppings = p.toppings :+ t)\n\n  def removeAllToppings: Pizza =\n    p.copy(toppings = Seq.empty)\n\n  def updateCrustSize(cs: CrustSize): Pizza =\n    p.copy(crustSize = cs)\n\n  def updateCrustType(ct: CrustType): Pizza =\n    p.copy(crustType = ct)\n```\n\n----------------------------------------\n\nTITLE: Mapping collections with map function in Python and Scala\nDESCRIPTION: Shows using the map function applying lambda functions or anonymous function literals to transform collections. Python uses map with a lambda to multiply each element by 10, returning an iterator. Scala uses the collections' map method with a concise function literal to achieve the same result, returning a new sequence. Illustrates functional programming style usage.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_66\n\nLANGUAGE: python\nCODE:\n```\nx = map(lambda x: x * 10, numbers)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval x = numbers.map(_ * 10)\n```\n\n----------------------------------------\n\nTITLE: Filter Operation Using Filter Method and For-Yield in Scala\nDESCRIPTION: Shows two ways to filter even numbers in Scala: using 'filter' method with an anonymous function, and a 'for-yield' comprehension with an if guard to select even elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_28\n\nLANGUAGE: Scala\nCODE:\n```\nval evens = numbers.filter(_ % 2 == 0)\n// or\nval evens = for i <- numbers if i % 2 == 0 yield i\n```\n\n----------------------------------------\n\nTITLE: Pairing Elements with Indices Using zipWithIndex in Scala\nDESCRIPTION: Attaches the index to each element of a collection, producing a sequence of (element, index) tuples. This operation works on any sequence, requiring only core Scala library. The output is a sequence where each element from xs is paired with its zero-based index; inputs are the target collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/trait-iterable.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nxs.zipWithIndex\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Class and Instantiating Objects in Scala\nDESCRIPTION: Demonstrates the simplest form of a Scala class with no parameters and instantiating an object of that class using the 'new' keyword. The class 'User' has no constructor parameters; hence it uses the default no-argument constructor. Shows basic object creation syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass User\n\nval user1 = new User\n```\n\n----------------------------------------\n\nTITLE: Adding Rich Iterator Functionality with a Mixin Trait in Scala\nDESCRIPTION: Defines trait `RichIterator` extending the abstract `AbsIterator` to add a concrete method `foreach` which accepts a function `f` that is applied repeatedly to each element as long as `hasNext` is true. This trait leverages the abstract iterator interface to provide iteration utilities without needing to reimplement basic iterator methods. Dependencies: requires the `AbsIterator` abstract class for abstract members. Inputs: function `f` of type `T => Unit`. Outputs: applies side-effectful function to all remaining elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/mixin-class-composition.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ntrait RichIterator extends AbsIterator {\n  def foreach(f: T => Unit): Unit = while (hasNext) f(next())\n}\n```\n\n----------------------------------------\n\nTITLE: Main method demonstrating 'given' usage in Scala\nDESCRIPTION: In the main method, calls 'genericMonthConverter' with an Int and String, showing how imported 'given' instances from 'MonthConversions' are used to produce month names.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/packaging-imports.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\n@main def main =\n  println(genericMonthConverter(1))       // January\n  println(genericMonthConverter(\"jan\"))   // January\n```\n\n----------------------------------------\n\nTITLE: Adding Scala Parser Combinators dependency to build.sbt\nDESCRIPTION: This code snippet demonstrates how to add an external library dependency using sbt in the build.sbt file. It specifies the scala-parser-combinators library version 1.1.2 to be included in the project dependencies, enabling access to parser combinator APIs in Scala code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/getting-started/intellij-track/building-a-scala-project-with-intellij-and-sbt.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nlibraryDependencies += \"org.scala-lang.modules\" %% \"scala-parser-combinators\" % \"1.1.2\"\n```\n\n----------------------------------------\n\nTITLE: Type Inference with Polymorphic Methods and Generic Classes in Scala 2 and 3\nDESCRIPTION: Demonstrates type inference of generic type parameters from constructor arguments and method calls. Dependencies: requires case class definition and generic method. Input includes values for generic types A and B, and generic method parameter; output includes inferred types MyPair[Int, String] and Int.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/type-inference.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ncase class MyPair[A, B](x: A, y: B)\nval p = MyPair(1, \"scala\") // type: MyPair[Int, String]\n\ndef id[T](x: T) = x\nval q = id(1)              // type: Int\n```\n\n----------------------------------------\n\nTITLE: Defining a Single-Parameter Method in Scala\nDESCRIPTION: Defines a basic Scala method named `double` that accepts a single integer parameter `a`. The method body `a * 2` is a single expression, and its result is implicitly returned. This demonstrates the fundamental `def` keyword and parameter declaration syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/methods-first-look.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef double(a: Int) = a * 2\n```\n\n----------------------------------------\n\nTITLE: Defining Case Classes for Pattern Matching\nDESCRIPTION: Defining a sealed trait Notification with three case classes (Email, SMS, VoiceRecording) that extend it, which will be used for pattern matching examples.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/pattern-matching.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait Notification\n\ncase class Email(sender: String, title: String, body: String) extends Notification\n\ncase class SMS(caller: String, message: String) extends Notification\n\ncase class VoiceRecording(contactName: String, link: String) extends Notification\n```\n\n----------------------------------------\n\nTITLE: Using the Option-based toInt Function in Scala REPL\nDESCRIPTION: Shows examples of calling the `toInt` function with valid and invalid string inputs within the Scala REPL, illustrating the `Some(value)` and `None` return types provided by the Option/Some/None pattern.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/no-null-values.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> val a = toInt(\"1\")\na: Option[Int] = Some(1)\n\nscala> val a = toInt(\"foo\")\na: Option[Int] = None\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Notification and Case Classes in Scala\nDESCRIPTION: Defines an abstract superclass 'Notification' with three concrete case subclasses: Email, SMS, and VoiceRecording. Each case class contains immutable constructor parameters for use in modeling different types of notifications. This snippet sets the core hierarchy for use in pattern matching and instantiation. It requires Scala as the language and uses basic case class syntax including extension of an abstract class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/case-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Notification\ncase class Email(sourceEmail: String, title: String, body: String) extends Notification\ncase class SMS(sourceNumber: String, message: String) extends Notification\ncase class VoiceRecording(contactName: String, link: String) extends Notification\n```\n\n----------------------------------------\n\nTITLE: Default Immutable IndexedSeq Implementation in Scala\nDESCRIPTION: Illustrates that `Vector` is the default implementation returned when creating a generic immutable `IndexedSeq` in Scala 2.8+, chosen for its good balance of random access and update performance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/concrete-immutable-collection-classes.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ncollection.immutable.IndexedSeq(1, 2, 3)\n```\n\nLANGUAGE: output\nCODE:\n```\nres2: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Defining and Passing Regular Functions to Map in Scala\nDESCRIPTION: Defines a regular method named double that takes an integer and returns its double. This method is then passed as a function parameter to the map method on a list of integers. This snippet illustrates that methods defined with def can be passed as first-class functions, leveraging Scala's ability to convert methods into function values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/passing-functions-around.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef double(i: Int): Int = i * 2   //a method that doubles an Int\nval doubles = nums.map(double)\n```\n\n----------------------------------------\n\nTITLE: Filtering a list of users with for comprehension in Scala\nDESCRIPTION: Example demonstrating how to use a for comprehension with a filter to extract names of users in their twenties from a list of User objects. The comprehension iterates over a user list, filters by age criteria, and yields a new list of names.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/for-comprehensions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class User(name: String, age: Int)\n\nval userBase = List(User(\"Travis\", 28),\n  User(\"Kelly\", 33),\n  User(\"Jennifer\", 44),\n  User(\"Dennis\", 23))\n\nval twentySomethings = for (user <- userBase if (user.age >=20 && user.age < 30))\n  yield user.name  // i.e. add this to a list\n\ntwentySomethings.foreach(name => println(name))  // prints Travis Dennis\n```\n\n----------------------------------------\n\nTITLE: Using Anonymous Functions (Lambdas) in Scala\nDESCRIPTION: Refactors the previous Timer example to use an anonymous function (lambda) instead of a named function for the callback. Introduces the `() => ...` syntax for defining anonymous functions inline when passing them to the `oncePerSecond` higher-order function.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tutorials/scala-for-java-programmers.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nobject TimerAnonymous {\n  def oncePerSecond(callback: () => Unit) {\n    while (true) { callback(); Thread sleep 1000 }\n  }\n  def main(args: Array[String]): Unit = {\n    oncePerSecond(() =>\n      println(\"time flies like an arrow...\"))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using pattern guards in Scala pattern matching - Scala\nDESCRIPTION: Defines a function showImportantNotification that filters matched cases using additional boolean expressions called pattern guards (the 'if' clauses). It checks if notification senders or callers are present in an importantPeopleInfo sequence. If matched, it returns a special message; otherwise, it delegates to the original showNotification function. The snippet shows conditional matching enhancing pattern specificity and handling an 'other' fallback. Multiple sample values showcase output variations depending on the guards.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/pattern-matching.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef showImportantNotification(notification: Notification, importantPeopleInfo: Seq[String]): String = {\n  notification match {\n    case Email(sender, _, _) if importantPeopleInfo.contains(sender) =>\n      \"You got an email from special someone!\"\n    case SMS(number, _) if importantPeopleInfo.contains(number) =>\n      \"You got an SMS from special someone!\"\n    case other =>\n      showNotification(other) // 特別なものではなく、オリジナルのshowNotification関数に委譲します。\n  }\n}\n\nval importantPeopleInfo = Seq(\"867-5309\", \"jenny@gmail.com\")\n\nval someSms = SMS(\"867-5309\", \"Are you there?\")\nval someVoiceRecording = VoiceRecording(\"Tom\", \"voicerecording.org/id/123\")\nval importantEmail = Email(\"jenny@gmail.com\", \"Drinks tonight?\", \"I'm free after 5!\")\nval importantSms = SMS(\"867-5309\", \"I'm here! Where are you?\")\n\nprintln(showImportantNotification(someSms, importantPeopleInfo))\nprintln(showImportantNotification(someVoiceRecording, importantPeopleInfo))\nprintln(showImportantNotification(importantEmail, importantPeopleInfo))\nprintln(showImportantNotification(importantSms, importantPeopleInfo))\n```\n\n----------------------------------------\n\nTITLE: Companion Object with Multiple Apply Methods (Overloaded Constructors) in Scala\nDESCRIPTION: This example extends the apply method pattern to allow multiple constructor variants using Option types. The Person class tracks optional name and age fields, and the companion object overloads apply to support both one-argument and two-argument forms. These methods enable robust instance creation while handling absent values gracefully. No dependencies outside the standard Scala Option library are needed. Input parameters are Option[String] and Option[Int]; outputs are properly initialized Person instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/companion-objects.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass Person {\n    var name: Option[String] = None\n    var age: Option[Int] = None\n    override def toString = s\"$name, $age\"\n}\n\nobject Person {\n\n    // a one-arg constructor\n    def apply(name: Option[String]): Person = {\n        var p = new Person\n        p.name = name\n        p\n    }\n\n    // a two-arg constructor\n    def apply(name: Option[String], age: Option[Int]): Person = {\n        var p = new Person\n        p.name = name\n        p.age = age\n        p\n    }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Chained if, else if, else Expressions in Scala\nDESCRIPTION: Expresses chained conditional logic in Scala without parentheses or braces, using 'if', 'else if', and 'else' keywords with indentation, enhancing code readability and conciseness.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\nif x < 0 then\n  println(\"negative\")\nelse if x == 0\n  println(\"zero\")\nelse\n  println(\"positive\")\n```\n\n----------------------------------------\n\nTITLE: Multiline for Loop with Computation in Scala\nDESCRIPTION: Demonstrates Scala multiline 'for' loop over collection 'ints' with a 'do' block. Computes 'x' as double of 'i', then prints an interpolated string with variable values. Shows Scala's emphasis on expression-based iteration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\nfor\n  i <- ints\ndo\n  val x = i * 2\n  println(s\"i = $i, x = $x\")\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Tuples in Scala\nDESCRIPTION: Shows how to define tuples as heterogenous containers holding different types and access their elements either by indexing or pattern matching. The example includes a Tuple3 of an Int, Double, and String, a method returning a tuple representing stock data, and variable assignments unpacking the tuple values. It demonstrates Scala's lightweight alternative to ad-hoc classes and how tuples can be used for grouping related values temporarily. Dependencies: Scala standard library. Inputs: tuple literals or method returns; outputs: tuple elements accessible by position or destructuring. Also suggests creating case classes for repeated tuple structures.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/prelude-taste-of-scala.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n(11, 11.0, \"Eleven\")\n\ndef getAaplInfo(): (String, BigDecimal, Long) = {\n    // get the stock symbol, price, and volume\n    (\"AAPL\", BigDecimal(123.45), 101202303L)\n}\n\nval t = getAaplInfo()\n\nt._1\nt._2\nt._3\n\nval (symbol, price, volume) = getAaplInfo()\n\ncase class StockInfo(symbol: String, price: BigDecimal, volume: Long)\n```\n\n----------------------------------------\n\nTITLE: Match Expression in Scala\nDESCRIPTION: Scala match expression returns a value based on pattern matching against the variable day, assigning corresponding month names or a default value with underscore (_). This replaces switch with more powerful pattern matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_49\n\nLANGUAGE: scala\nCODE:\n```\nval monthAsString = day match\n  case 1 => \"January\"\n  case 2 => \"February\"\n  _ => \"Other\"\n```\n\n----------------------------------------\n\nTITLE: Creating Instances of Scala Case Classes\nDESCRIPTION: Shows how to create instances of the `Student` and `Teacher` case classes. Case classes have an automatically generated `apply` method in their companion object, allowing instantiation without the `new` keyword in Scala 3 and typically used without it in Scala 2 as well. Shows instantiation syntax for both Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_46\n\nLANGUAGE: Scala 2\nCODE:\n```\nval s = new Student(\"Al\", 1)\nval t = new Teacher(\"Bob Donnan\", \"Mathematics\")\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nval s = Student(\"Al\", 1)\nval t = Teacher(\"Bob Donnan\", \"Mathematics\")\n```\n\n----------------------------------------\n\nTITLE: Defining a Probability Opaque Type with Range-Restricted Double in Scala\nDESCRIPTION: Defines an opaque type Probability to represent a Double restricted to the [0, 1] interval, guaranteeing compile-time safety for probability values. The companion object provides a safe constructor returning an Option[Probability], an unsafe constructor with runtime checks, and utility values and operations including logical combinators (&, |), negation, comparisons, sampling, and implicit ordering. Expected input is a Double constrained to [0,1], and output is wrapped as Probability to prevent invalid usage externally. The opaque nature guarantees zero runtime overhead outside the companion object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/opaque-types.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\npackage object prob {\n  opaque type Probability = Double\n\n  object Probability {\n    def apply(n: Double): Option[Probability] =\n      if (0.0 <= n && n <= 1.0) Some(n) else None\n\n    def unsafe(p: Double): Probability = {\n      require(0.0 <= p && p <= 1.0, s\"probabilities lie in [0, 1] (got $p)\")\n      p\n    }\n\n    def asDouble(p: Probability): Double = p\n\n    val Never: Probability = 0.0\n    val CoinToss: Probability = 0.5\n    val Certain: Probability = 1.0\n\n    implicit val ordering: Ordering[Probability] =\n      implicitly[Ordering[Double]]\n\n    implicit class ProbabilityOps(p1: Probability) extends AnyVal {\n      def unary_~ : Probability = Certain - p1\n      def &(p2: Probability): Probability = p1 * p2\n      def |(p2: Probability): Probability = p1 + p2 - (p1 * p2)\n\n      def isImpossible: Boolean = p1 == Never\n      def isCertain: Boolean = p1 == Certain\n\n      import scala.util.Random\n\n      def sample(r: Random = Random): Boolean = r.nextDouble <= p1\n      def toDouble: Double = p1\n    }\n\n    val caughtTrain = Probability.unsafe(0.3)\n    val missedTrain = ~caughtTrain\n    val caughtCab = Probability.CoinToss\n    val arrived = caughtTrain | (missedTrain & caughtCab)\n\n    println((1 to 5).map(_ => arrived.sample()).toList)\n    // List(true, true, false, true, false)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring an Abstract Class with Constructor Arguments in Scala 2 and Scala 3\nDESCRIPTION: Defines an abstract class `Pet` with a constructor argument `name`, abstract members `greeting` and `age`, and a customized `toString` method. The snippet demonstrates subclassing `Pet` with class `Dog` which provides concrete implementations. It highlights the traditional use of abstract classes in Scala to accept constructor parameters, showing both Scala 2 and Scala 3 syntax. Dependencies include standard Scala language features. Inputs are constructor parameters; output is an instance of subclass with accessible members.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Pet(name: String) {\n  def greeting: String\n  def age: Int\n  override def toString = s\"My name is $name, I say $greeting, and I’m $age\"\n}\n\nclass Dog(name: String, var age: Int) extends Pet(name) {\n  val greeting = \"Woof\"\n}\n\nval d = new Dog(\"Fido\", 1)\n```\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Pet(name: String):\n  def greeting: String\n  def age: Int\n  override def toString = s\"My name is $name, I say $greeting, and I’m $age\"\n\nclass Dog(name: String, var age: Int) extends Pet(name):\n  val greeting = \"Woof\"\n\nval d = Dog(\"Fido\", 1)\n```\n\n----------------------------------------\n\nTITLE: Implementando un método polimórfico en Scala\nDESCRIPTION: Definición e invocación de un método polimórfico 'dup' que crea una lista duplicando un elemento un número específico de veces. El ejemplo muestra cómo Scala puede inferir tipos automáticamente.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/polymorphic-methods.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject PolyTest extends App {\n  def dup[T](x: T, n: Int): List[T] =\n    if (n == 0) Nil\n    else x :: dup(x, n - 1)\n  println(dup[Int](3, 4)) // linea 5\n  println(dup(\"three\", 3)) // linea 6\n}\n```\n\n----------------------------------------\n\nTITLE: Using Partial Functions with Collection Methods in Scala\nDESCRIPTION: Demonstrates how to pass a partial function as an argument to collection methods like collect, which applies the function only to elements where it's defined.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-partial-functions.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval res = List(1, 2, 3).collect({ case i if i % 2 == 1 => i * 2 }) // List(2, 6)\n```\n\n----------------------------------------\n\nTITLE: Taking Elements from Sequence in Scala\nDESCRIPTION: Introduces `take` and `takeWhile`. `take(n)` returns the first `n` elements, while `takeWhile(predicate)` returns the longest prefix whose elements all satisfy the predicate.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/collections-methods.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nnums.take(1)\nnums.take(2)\nnames.take(1)\nnames.take(2)\n```\n\nLANGUAGE: scala\nCODE:\n```\nnums.takeWhile(_ < 5)\nnames.takeWhile(_.length < 5)\n```\n\n----------------------------------------\n\nTITLE: Failing a Promise in Scala\nDESCRIPTION: This example demonstrates how to complete a Promise with a failure, using either Scala 2 or Scala 3 syntax. It checks the validity of a computed result and fails the Promise with an exception if invalid, otherwise succeeds with a valid result.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_36\n\nLANGUAGE: Scala\nCODE:\n```\nval p = Promise[T]()\nval f = p.future\n\nval producer = Future {\n  val r = someComputation\n  if (isInvalid(r))\n    p.failure(new IllegalStateException)\n  else {\n    val q = doSomeMoreComputation(r)\n    p.success(q)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing For Comprehensions in Scala\nDESCRIPTION: Demonstrates various for-comprehension patterns in Scala, including using yield for transformations, cartesian products, imperative style, and iteration techniques with to/until range expressions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/cheatsheets/index.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nfor (x <- xs; y <- ys)\n  yield x * y\n```\n\nLANGUAGE: scala\nCODE:\n```\nxs flatMap { x =>\n  ys map { y =>\n    x * y\n  }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor (x <- xs; y <- ys) {\n  val div = x / y.toFloat\n  println(\"%d/%d = %.1f\".format(x, y, div))\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor (i <- 1 to 5) {\n  println(i)\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor (i <- 1 until 5) {\n  println(i)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing and Overriding Trait Methods in Scala Classes\nDESCRIPTION: Demonstrates class inheritance with traits in Scala 2 and Scala 3. The `DefaultGreeter` class uses the trait's default method, while `CustomizableGreeter` extends the trait and overrides the `greet` method using the `override` keyword to provide custom functionality. It also shows instantiation and usage.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\nclass DefaultGreeter extends Greeter\n\nclass CustomizableGreeter(prefix: String, postfix: String) extends Greeter {\n  override def greet(name: String): Unit = {\n    println(prefix + name + postfix)\n  }\n}\n\nval greeter = new DefaultGreeter()\ngreeter.greet(\"Scala developer\") // Hello, Scala developer!\n\nval customGreeter = new CustomizableGreeter(\"How are you, \", \"?\")\ncustomGreeter.greet(\"Scala developer\") // How are you, Scala developer?\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass DefaultGreeter extends Greeter\n\nclass CustomizableGreeter(prefix: String, postfix: String) extends Greeter:\n  override def greet(name: String): Unit =\n    println(prefix + name + postfix)\n\nval greeter = DefaultGreeter()\ngreeter.greet(\"Scala developer\") // Hello, Scala developer!\n\nval customGreeter = CustomizableGreeter(\"How are you, \", \"?\")\ncustomGreeter.greet(\"Scala developer\") // How are you, Scala developer?\n```\n\n----------------------------------------\n\nTITLE: Using Traits in Scala 3: Creating Animal Instances\nDESCRIPTION: Scala 3 version of creating Dog and Cat objects and calling their methods, exemplifying trait usage in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-modeling.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval d = Dog(\"Rover\")\nprintln(d.speak())      // prints \"Woof!\"\n\nval c = Cat(\"Morris\")\nprintln(c.speak())      // \"Meow\"\n c.startRunning()        // \"Yeah ... I don’t run\"\n c.stopRunning()         // \"No need to stop\"\n```\n\n----------------------------------------\n\nTITLE: Returning Value from Conditional Logic - JavaScript & Scala\nDESCRIPTION: Compares how to return a value based on a condition. JavaScript uses a ternary operator, while Scala utilizes the 'if' expression which inherently returns a value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_21\n\nLANGUAGE: JavaScript\nCODE:\n```\nlet minVal = a < b ? a : b;\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval minValue = if a < b then a else b\n```\n\n----------------------------------------\n\nTITLE: Generic Reference Container Implementation in Scala\nDESCRIPTION: Definition of a generic class Reference that acts as a container for any type T, with methods to get and set the contained value, demonstrating Scala's support for generic programming.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_de/tutorials/scala-for-java-programmers.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass Reference[T] {\n  private var contents: T = _\n\n  def get: T = contents\n\n  def set(value: T) {\n    contents = value\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring an SBT Dependency Syntax for Maven Central (Scala)\nDESCRIPTION: Shows how to declare a library dependency in SBT build files for a Scala project. This snippet specifies the Maven group ID, artifact ID, and version, informing SBT where to fetch the dependency from. Required in build.sbt when third-party libraries such as logging or testing frameworks are needed. Inputs: valid groupId, artifactId, and version strings. Output: SBT resolves and includes the dependency for compilation and runtime. Limitation: The exact syntax shown is for dependencies published for the JVM; cross-building with Scala-specific modules may require %% instead of %.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n\"org.slf4j\" % \"slf4j-simple\" % \"1.7.25\"\n```\n\n----------------------------------------\n\nTITLE: Type Inference for Anonymous Function Parameters in Scala\nDESCRIPTION: Shows that while method parameter types must be explicitly declared, Scala can infer types of parameters inside anonymous functions passed as arguments. Here, the integer list is mapped by an anonymous function 'x => x * 2'. Since the input list is of type Seq[Int], the compiler infers 'x' as Int and thus the output list elements as Int.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/type-inference.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nSeq(1, 3, 4).map(x => x * 2)  // List(2, 6, 8)\n```\n\n----------------------------------------\n\nTITLE: Pattern matching with ranges using 'if' guards\nDESCRIPTION: Shows matching number ranges with 'if' guards and the 'contains' method, enabling concise handling of numeric intervals within pattern matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/match-expressions.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\ni match {\n  case a if 0 to 9 contains a => println(\"0-9 range: \" + a)\n  case b if 10 to 19 contains b => println(\"10-19 range: \" + b)\n  case c if 20 to 29 contains c => println(\"20-29 range: \" + c)\n  case _ => println(\"Hmmm...\")\n}\n```\n\n----------------------------------------\n\nTITLE: For loop with range iteration in Python and Scala\nDESCRIPTION: Shows looping over a numeric range with printing of the index. Inputs: loop indices from 0 to 2 inclusive or exclusive depending on language. Outputs: printed numbers. Scala has multiple syntaxes demonstrated including preferred forms and multiline options.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_31\n\nLANGUAGE: Python\nCODE:\n```\nfor i in range(0,3):\n  print(i)\n```\n\n----------------------------------------\n\nTITLE: Incompatible Libraries Output (Sbt Console)\nDESCRIPTION: This snippet shows the 'Incompatible Libraries' section from the `migrateDependencies` command output. It lists dependencies, such as macro libraries or certain compiler plugins, that are not compatible with Scala 3 and typically must be removed from the project or replaced with Scala 3 alternatives.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/scala3-migrate.md#_snippet_7\n\nLANGUAGE: Sbt Console\nCODE:\n```\n[error] <span style=\"color:red\">Incompatible Libraries:</span>\n[error] \"com.softwaremill.scalamacrodebug\" %% \"macros\" % \"0.4.1\" % Test <span style=\"color:red\">(Macro Library)</span>\n[error] addCompilerPlugin(\"com.olegpy\" %% \"better-monadic-for\" % \"0.3.1\") <span style=\"color:red\">(Compiler Plugin)</span>\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on TypeBounds Using Scala Reflection API\nDESCRIPTION: Demonstrates pattern matching on types using the extractor methods available on `TypeBounds`, which is a subtype of `TypeRepr`. It shows how to decompose a `TypeRepr` into its lower and upper bounds via the `TypeBounds` unapply method to access bounds `l` and `u`. This snippet leverages the relationship between `TypeBounds` and `TypeRepr` to use both specific and inherited methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/reflection.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef f(tpe: TypeRepr) =\n  tpe match \n    case TypeBounds(l, u) =>\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef f(tpe: TypeRepr) =\n  tpe match\n    case tpe: TypeBounds =>\n      val low = tpe.low\n      val hi  = tpe.hi\n```\n\n----------------------------------------\n\nTITLE: Importing Packages and Members in Scala 2\nDESCRIPTION: This set of import statements demonstrates several ways to import packages and their members in Scala 2. It covers importing all members, specific classes, multiple selected members, and renaming an import for convenience. No parameters are used, and all forms show how to access external classes or streamline naming in client code. There are no dependencies except that the referenced packages must be resolved at compile time.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/packages-and-imports.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport users._  // import everything from the users package\nimport users.User  // import the class User\nimport users.{User, UserPreferences}  // Only imports selected members\nimport users.{UserPreferences => UPrefs}  // import and rename for convenience\n```\n\n----------------------------------------\n\nTITLE: Recovering from Exceptions in Scala Futures with recover Combinator\nDESCRIPTION: Illustrates the use of the recover combinator to handle exceptions in Futures, specifically to replace a QuoteChangedException with a default value 0 in the purchase Future. It depends on the original rateQuote Future and a partial function to match the exception type. The input is a Future of purchase result which may fail; the output is a Future that recovers to 0 if the specified exception occurs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/futures-promises.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nval purchase: Future[Int] = rateQuote map {\n  quote => connection.buy(amount, quote)\n} recover {\n  case quoteExc: QuoteChangedException => 0\n}\n```\n\n----------------------------------------\n\nTITLE: Type inference with polymorphic methods and generic classes\nDESCRIPTION: This code illustrates how Scala infers types in polymorphic functions and generic classes. The 'id' method is polymorphic, and the 'MyPair' class is generic. The example shows inferred types for instances where explicit type annotations are omitted, as well as how to explicitly specify type parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/type-inference.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ncase class MyPair[A, B](x: A, y: B)\nobject InferenceTest3 extends App {\n  def id[T](x: T) = x\n  val p = MyPair(1, \"scala\") // tipo: MyPair[Int, String]\n  val q = id(1)              // tipo: Int\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Iterator Interface (Scala)\nDESCRIPTION: Defines an abstract class `AbsIterator` that serves as a base interface for iterators. It includes an abstract type member `T` and abstract methods `hasNext` and `next` that concrete implementations must provide.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/mixin-class-composition.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class AbsIterator {\n  type T\n  def hasNext: Boolean\n  def next(): T\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class AbsIterator:\n  type T\n  def hasNext: Boolean\n  def next(): T\n```\n\n----------------------------------------\n\nTITLE: Initializing Variables Using Type Inference in Scala 2 and 3\nDESCRIPTION: Demonstrates Scala's automatic type inference where variable types are deduced without explicit type annotations. Includes primitive and collection types like Int, List of Int, and Map from Int to String. Requires Scala compiler or REPL supporting Scala 2 or 3. Variables `a`, `b`, and `m` are assigned values and Scala infers their types based on assigned expressions. Expected behavior is inferred typing with no need for explicit declarations, aiding concise and readable code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-inferred.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval a = 1\nval b = List(1, 2, 3)\nval m = Map(1 -> \"one\", 2 -> \"two\")\n```\n\n----------------------------------------\n\nTITLE: For loop iterating over a list in Python and Scala\nDESCRIPTION: Demonstrates iterating over elements in an iterable collection with printing of elements. Inputs: list or collection named ints; outputs: printed elements one per line. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_34\n\nLANGUAGE: Scala\nCODE:\n```\nfor i <- ints do println(i)\n```\n\n----------------------------------------\n\nTITLE: String and Char Data Types in Scala\nDESCRIPTION: Demonstrates the declaration of String and Char variables in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-vars-data-types.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval name = \"Bill\"   // String\nval c = 'a'         // Char\n```\n\n----------------------------------------\n\nTITLE: Instantiating Class with Default/Named Parameters in Scala 3\nDESCRIPTION: This snippet illustrates various ways to instantiate a class with default parameter values in Scala 3 without the `new` keyword, including using positional arguments, providing all arguments, or using named parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nval s = Socket()                  // timeout: 5000, linger: 5000\nval s = Socket(2_500)             // timeout: 2500, linger: 5000\nval s = Socket(10_000, 10_000)    // timeout: 10000, linger: 10000\nval s = Socket(timeout = 10_000)  // timeout: 10000, linger: 5000\nval s = Socket(linger = 10_000)   // timeout: 5000, linger: 10000\n```\n\n----------------------------------------\n\nTITLE: Defining Case Classes Extending a Trait in Scala\nDESCRIPTION: Defines two case classes, `Student` and `Teacher`, that extend the `Person` trait. Case classes automatically generate useful methods, including an `unapply` method which makes them suitable for pattern matching using constructor patterns. This example uses syntax compatible with both Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_43\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\ncase class Student(name: String, year: Int) extends Person\ncase class Teacher(name: String, specialty: String) extends Person\n```\n\n----------------------------------------\n\nTITLE: List Literals and Indexing - Scala\nDESCRIPTION: Creates immutable lists and accesses elements by parenthesis indexing. Dependencies: standard Scala List type. Useful for general purpose immutable collections where indexed access is required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nvar xs = List(1,2,3)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nxs(2)\n```\n\n----------------------------------------\n\nTITLE: Implementing Graph with Inner Class Nodes in Scala\nDESCRIPTION: A simple graph implementation in Scala where nodes are represented as inner classes. Each node contains a list of connected nodes, and the graph class maintains a list of all nodes. The inner class relationship binds nodes to their specific graph instance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/inner-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Graph {\n  class Node {\n    var connectedNodes: List[Node] = Nil\n    def connectTo(node: Node): Unit = {\n      if (!connectedNodes.exists(node.equals)) {\n        connectedNodes = node :: connectedNodes\n      }\n    }\n  }\n  var nodes: List[Node] = Nil\n  def newNode: Node = {\n    val res = new Node\n    nodes = res :: nodes\n    res\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Generalized Algebraic Data Type (GADT) in Scala\nDESCRIPTION: Demonstrates the definition of a GADT (`Box`) using Scala 3 `enum`. Each case (`IntBox`, `BoolBox`) extends the base enum with a *specific* type parameter (`Box[Int]`, `Box[Boolean]`), constraining the type based on the case.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-adts-gadts.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nenum Box[T](contents: T):\n  case IntBox(n: Int) extends Box[Int](n)\n  case BoolBox(b: Boolean) extends Box[Boolean](b)\n```\n\n----------------------------------------\n\nTITLE: Instantiating Class with Auxiliary Constructors in Scala 2\nDESCRIPTION: This snippet shows how to instantiate the `Student` class using its different constructors in Scala 2. Instances can be created using the primary constructor or either of the two auxiliary constructors, each requiring `new`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\nval s1 = new Student(\"Mary\", \"123\")\nval s2 = new Student(\"Mary\", \"123\", LocalDate.now())\nval s3 = new Student(\"Mary\", \"123\", 456)\n```\n\n----------------------------------------\n\nTITLE: Declaring Variables Concisely in Scala\nDESCRIPTION: This snippet demonstrates the concise syntax for variable declaration in Scala using `val` (for immutable variables). Scala's type inference allows omitting explicit type annotations for common cases like lists or case class instances, resulting in clean and readable code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-features.md#_snippet_2\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\nval nums = List(1,2,3)\nval p = Person(\"Martin\", \"Odersky\")\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Methods in Scala 2 and 3\nDESCRIPTION: Defines simple Scala methods with explicit return types. Demonstrates declaring parameters with types and specifying a return type, followed by the method body. Requires Scala 2 or Scala 3 environment. Input parameters are typed values, and output is specified by the return type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-methods.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef methodName(param1: Type1, param2: Type2): ReturnType =\n  // the method body\n  // goes here\n```\n\n----------------------------------------\n\nTITLE: Using a Generic Stack with Integer Type in Scala\nDESCRIPTION: Example demonstrating how to instantiate and use a generic Stack class with the Int type. The code creates a new stack, pushes integers onto it, and then pops them back off, showing the LIFO (Last-In-First-Out) behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/generic-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval stack = new Stack[Int]\nstack.push(1)\nstack.push(2)\nprintln(stack.pop)  // prints 2\nprintln(stack.pop)  // prints 1\n```\n\n----------------------------------------\n\nTITLE: Creating ScalaTest BDD-style unit tests using AnyFunSpec in Scala\nDESCRIPTION: This Scala snippet demonstrates BDD-style unit tests for the MathUtils object using ScalaTest's AnyFunSpec testing style. It resides in the package simpletest and imports org.scalatest.funspec.AnyFunSpec. The test class MathUtilsSpec uses the describe block to specify the method under test and multiple it blocks describing individual test cases as readable behavior sentences. It asserts correct doubling behavior for zero and one, and marks a test for large integers as pending. Dependencies include ScalaTest and sbt for running the tests. Inputs are method parameters for double, and outputs are validated against expected doubled values. This style promotes readability and business-domain friendliness.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/sbt-scalatest-bdd.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\npackage simpletest\n\nimport org.scalatest.funspec.AnyFunSpec\n\nclass MathUtilsSpec extends AnyFunSpec {\n  \n    describe(\"MathUtils::double\") {\n\n        it(\"should handle 0 as input\") {\n            val result = MathUtils.double(0)\n            assert(result == 0)\n        }\n\n        it(\"should handle 1\") {\n            val result = MathUtils.double(1)\n            assert(result == 2)\n        }\n\n        it(\"should handle really large integers\") (pending)\n        \n    }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Variables with Type Inference in Scala\nDESCRIPTION: Demonstrates variable declaration using `val` without explicit type annotations. Scala's compiler infers the types (Int, String, List[Int], Tuple3) based on the assigned values, making the code feel more dynamically typed despite being statically typed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/why-scala-3.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval a = 1\nval b = \"Hello, world\"\nval c = List(1,2,3,4,5)\nval stuff = (\"fish\", 42, 1_234.5)\n```\n\n----------------------------------------\n\nTITLE: Implementing a reduce Method with Anonymous Context Bound\nDESCRIPTION: Definition of a reduce method using an anonymous context bound for Monoid, demonstrating the current approach requiring summon to access the Monoid instance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef reduce[A : Monoid](xs: List[A]): A = ???\n```\n\n----------------------------------------\n\nTITLE: Using sbt New Template to Create Scala 3 Project - Bash Commands\nDESCRIPTION: This bash snippet shows using the 'sbt new' command with the 'scala/scala3.g8' template to automatically create a standard Scala 3 sbt project. The command downloads the template, interactively requests project parameters, and generates a fully structured project with example source and test files.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt new scala/scala3.g8\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Enum - Java\nDESCRIPTION: This snippet defines a simple enumeration in Java named Color with three possible values: RED, GREEN, and BLUE. The enum is declared using the enum keyword and does not contain methods or parameters. No dependencies other than Java SE are required, and the output is an enum type with three fields.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_56\n\nLANGUAGE: Java\nCODE:\n```\nenum Color {\n  RED, GREEN, BLUE\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing list elements in Python and Scala\nDESCRIPTION: Shows syntax differences for accessing elements of list/sequence collections in Python and Scala. Python uses square bracket indexing (a[0]), while Scala uses parentheses (a(0)) which is syntactic sugar for method calls. Demonstrates basic element access in both languages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_52\n\nLANGUAGE: python\nCODE:\n```\na[0]\na[1]\n```\n\nLANGUAGE: scala\nCODE:\n```\na(0)\na(1)\n```\n\n----------------------------------------\n\nTITLE: Mixing Named and Positional Arguments in Scala\nDESCRIPTION: Shows how to combine named and positional arguments in method calls. Positional arguments must form a prefix of the argument list, and parameters cannot be specified twice.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-and-default-arguments.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nf(0, b = \"1\")     // valid\nf(b = \"1\", a = 0) // valid\n// f(b = \"1\", 0)  // invalid, a positional after named argument\n// f(0, a = 1)    // invalid, parameter 'a' specified twice\n```\n\n----------------------------------------\n\nTITLE: Defining and Calling Methods in the Scala REPL\nDESCRIPTION: Shows how to define a simple method named `sum` with two Int parameters directly within the Scala REPL session. It then demonstrates calling this newly defined method with arguments (2, 2) and shows the REPL assigning the result (4) to a new default variable `res2`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-repl.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nscala> def sum(a: Int, b: Int): Int = a + b\ndef sum(a: Int, b: Int): Int\n\nscala> sum(2, 2)\nval res2: Int = 4\n```\n\n----------------------------------------\n\nTITLE: Find First Palindrome in a Sequence Using Views to Optimize Performance\nDESCRIPTION: Defines a function to check palindromes and find a palindrome in a sequence. Using views, it processes only as many elements as needed to find a palindrome, avoiding full sequence traversal or unnecessary copying for large data sets.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/views.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef isPalindrome(x: String) = x == x.reverse\n def findPalindrome(s: Seq[String]) = s.find(isPalindrome)\n```\n\n----------------------------------------\n\nTITLE: Matching Selection Quasiquotes - Scala\nDESCRIPTION: Illustrates how to pattern match on member selection (`RefTree`) AST nodes using quasiquotes. The pattern `q\"foo.$name\"` matches a selection with the prefix `foo` and extracts the selected member's name into the `$name` variable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"foo.$name\" = selected\nname: universe.TermName = bar\n```\n\n----------------------------------------\n\nTITLE: Matching Typechecked Applications (Implicit Arguments) - Scala\nDESCRIPTION: Shows how typechecking resolves and adds implicit arguments to function calls. Matching a typechecked tree containing a call with an implicit parameter using `q\"..$stats; g(...$argss)\"` reveals the compiler-inferred implicit argument as part of the `$argss` lists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"..$stats; g(...$argss)\" = toolbox.typecheck(q\"\"\"\n             def g(x: Int)(implicit y: Int) = x + y\n             implicit val y = 3\n             g(2)\n           \"\"\")\nstats: List[universe.Tree] = List(def g(x: Int)(implicit y: Int): Int = x.+(y), implicit val y: Int = 3)\nargss: List[List[universe.Tree]] = List(List(2), List(y))\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Elements to Scala TreeSet\nDESCRIPTION: This Scala snippet adds multiple string elements (\"one\", \"two\", \"three\", \"four\") to the `TreeSet` stored in `res2`. Since `res2` was created with the default ascending ordering, the resulting set `res3` contains the elements sorted alphabetically.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/sets.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nscala> res2 + (\"one\", \"two\", \"three\", \"four\")\nres3: scala.collection.immutable.TreeSet[String] = TreeSet(four, one, three, two)\n```\n\n----------------------------------------\n\nTITLE: Adding Elements to a TreeSet While Preserving Ordering in Scala\nDESCRIPTION: Demonstrates how to add multiple String elements to an existing TreeSet in Scala using consecutive '+' operations. The resulting TreeSet maintains the inherent ordering (default or custom) of its elements after modification.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/sets.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nres2 + \"one\" + \"two\" + \"three\" + \"four\"\n```\n\n----------------------------------------\n\nTITLE: Companion Object with Factory Method Returning Option Type - scala\nDESCRIPTION: Defines a class 'Email' with username and domainName fields and a companion singleton object providing a factory method 'fromString', which parses an email string into an Email instance wrapped in an Option to handle invalid format cases. Pattern matching is used for safe parsing. This snippet illustrates companion objects as factory providers and use of Scala's Option type for safe construction with error handling.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/singleton-objects.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass Email(val username: String, val domainName: String)\n\nobject Email {\n  def fromString(emailString: String): Option[Email] = {\n    emailString.split('@') match {\n      case Array(a, b) => Some(new Email(a, b))\n      case _ => None\n    }\n  }\n}\n\nval scalaCenterEmail = Email.fromString(\"scala.center@epfl.ch\")\nscalaCenterEmail match {\n  case Some(email) => println(\n    s\"\"\"Registered an email\n       |Username: ${email.username}\n       |Domain name: ${email.domainName}\n     \"\"\")\n  case None => println(\"Error: could not parse email\")\n}\n```\n\n----------------------------------------\n\nTITLE: Sending POST Request with String Body in Scala 2\nDESCRIPTION: This snippet demonstrates how to use sttp's quickRequest to send a POST request with a string body in Scala 2. The example posts 'Lorem ipsum' to example.com and prints the response code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/http-client-request-body.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport sttp.client4.quick._\n\nval response = quickRequest\n  .post(uri\"https://example.com/\")\n  .body(\"Lorem ipsum\")\n  .send()\n\nprintln(response.code)\n// prints: 200\n```\n\n----------------------------------------\n\nTITLE: Defining a Class with Constructor, Methods, and Overriding in Scala\nDESCRIPTION: Defines a `Point` class with a primary constructor accepting two integer variables `x` and `y`. It includes a `move` method to modify coordinates and overrides the `toString` method for string representation. It demonstrates instantiation and accessing members/methods. Scala 3 uses colon syntax for the class body and omits `new` for instantiation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass Point(var x: Int, var y: Int) {\n\n  def move(dx: Int, dy: Int): Unit = {\n    x = x + dx\n    y = y + dy\n  }\n\n  override def toString: String =\n    s\"($x, $y)\"\n}\n\nval point1 = new Point(2, 3)\nprintln(point1.x)  // prints 2\nprintln(point1)    // prints (2, 3)\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Point(var x: Int, var y: Int):\n\n  def move(dx: Int, dy: Int): Unit =\n    x = x + dx\n    y = y + dy\n\n  override def toString: String =\n    s\"($x, $y)\"\nend Point\n\nval point1 = Point(2, 3)\nprintln(point1.x)  // prints 2\nprintln(point1)    // prints (2, 3)\n```\n\n----------------------------------------\n\nTITLE: Mapping Lists with Various Anonymous Functions in Scala\nDESCRIPTION: Multiple examples illustrating use of anonymous functions for mapping and filtering over lists of strings and integers. Functions include uppercase conversion, capitalization, length calculation, multiplication, filtering by condition, and takeWhile usage. These examples demonstrate common functional programming idioms in Scala's collection API.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/passing-functions-around.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nList(\"foo\", \"bar\").map(_.toUpperCase)\nList(\"foo\", \"bar\").map(_.capitalize)\nList(\"adam\", \"scott\").map(_.length)\nList(1,2,3,4,5).map(_ * 10)\nList(1,2,3,4,5).filter(_ > 2)\nList(5,1,3,11,7).takeWhile(_ < 6)\n```\n\n----------------------------------------\n\nTITLE: Package Management in Scala\nDESCRIPTION: Different ways to import and manage packages in Scala, including importing entire packages, selective imports, renaming imports, and declaring packages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/cheatsheets/index.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection._\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.Vector\nimport scala.collection.{Vector, Sequence}\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.{Vector => Vec28}\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport java.util.{Date => _, _}\n```\n\nLANGUAGE: scala\nCODE:\n```\npackage pkg\n```\n\n----------------------------------------\n\nTITLE: Using Underscore Shorthand\nDESCRIPTION: Demonstrates the underscore shorthand notation for a parameter that appears only once in the function body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-anonymous-functions.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval doubledInts = ints.map(_ * 2)\n```\n\n----------------------------------------\n\nTITLE: Scala Test Object Combining String Iterator and RichIterator Traits\nDESCRIPTION: This snippet defines an object 'StringIteratorTest' with a class 'Iter' that extends 'StringIterator' and mixes in 'RichIterator'. It creates an iterator over 'Scala' and applies 'println' to each element, demonstrating trait mixing to empower iterator objects with additional behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/mixin-class-composition.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nobject StringIteratorTest extends App {\n  class Iter extends StringIterator(\"Scala\") with RichIterator\n  val iter = new Iter\n  iter foreach println\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Integer List Using List Constructor in Scala\nDESCRIPTION: Creates a new List of integers in Scala using the List constructor. No additional libraries are required beyond the Scala standard library. The list is initialized with hardcoded values provided as arguments. Input: None. Output: List[Int] containing 1, 2, 3. No constraints or parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/anonymous-functions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval ints = List(1,2,3)\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Extension Methods in Scala 3\nDESCRIPTION: Demonstrates the syntax for defining multiple extension methods (`circumference`, `diameter`, `area`) for the `Circle` type within a single `extension` block, all referencing the receiver parameter `c`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/ca-extension-methods.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nextension (c: Circle)\n  def circumference: Double = c.radius * math.Pi * 2\n  def diameter: Double = c.radius * 2\n  def area: Double = math.Pi * c.radius * c.radius\n```\n\n----------------------------------------\n\nTITLE: Creating Method Returning Future Scala\nDESCRIPTION: Defines a Scala method `slowlyDouble` that simulates a time-consuming operation by sleeping for a specified delay before returning a value. The computation `x * 2` is wrapped within a `Future`, allowing it to execute asynchronously off the main thread.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/concurrency.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// simulate a slow-running method\ndef slowlyDouble(x: Int, delay: Long): Future[Int] = Future {\n  sleep(delay)\n  x * 2\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract and Concrete Classes in Scala\nDESCRIPTION: Examples showing how to define abstract classes and concrete implementation classes that extend them. Includes syntax for basic class definitions and inheritance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/cheatsheets/index.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nabstract class D { ... }\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass C extends D { ... }\n```\n\n----------------------------------------\n\nTITLE: Using 'f' Interpolator for Formatted Strings in Scala\nDESCRIPTION: Introduces the `f` interpolator, which enables `printf`-style formatting within strings. Variables are followed by format specifiers (e.g., `%s`, `%2.2f`). It leverages Java's `Formatter` for type-safe formatting.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/string-interpolation.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval height = 1.9d\nval name = \"James\"\nprintln(f\"$name%s is $height%2.2f meters tall\")  // \"James is 1.90 meters tall\"\n```\n\n----------------------------------------\n\nTITLE: Evaluating Expressions in Scala\nDESCRIPTION: Demonstrates simple expressions and printing their results via println, illustrating how computations are performed and outputted in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/basics.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n1 + 1\nprintln(1)\nprintln(1 + 1)\nprintln(\"Hello!\")\nprintln(\"Hello,\" + \" world!\")\n```\n\n----------------------------------------\n\nTITLE: Function Composition and Currying - Scala\nDESCRIPTION: Details techniques for composing functions and currying, including multi-block parameter syntax, and partial application underscoring. Dependencies: none. Inputs and outputs are higher-order functions using aliases. Useful for mathematical and functional composition practices.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef compose(g:R=>R, h:R=>R) = (x:R) => g(h(x))\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval f = compose({_*2}, {_-1})\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval zscore = (mean:R, sd:R) => (x:R) => (x-mean)/sd\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef zscore(mean:R, sd:R) = (x:R) => (x-mean)/sd\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef zscore(mean:R, sd:R)(x:R) = (x-mean)/sd\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval normer = zscore(7, 0.4)_\n```\n\n----------------------------------------\n\nTITLE: Declaring Class and Companion Object - Scala\nDESCRIPTION: Explains the concept of companion objects, which share the same name as a class and are declared in the same file. They can access private members of their companion class and provide class-level functionality.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_24\n\nLANGUAGE: Scala 2\nCODE:\n```\nimport scala.math._\n\nclass Circle(val radius: Double) {\n  def area: Double = Circle.calculateArea(radius)\n}\n\nobject Circle {\n  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)\n}\n\nval circle1 = new Circle(5.0)\ncircle1.area\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nimport scala.math.*\n\nclass Circle(val radius: Double):\n  def area: Double = Circle.calculateArea(radius)\n\nobject Circle:\n  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)\n\nval circle1 = Circle(5.0)\ncircle1.area\n```\n\n----------------------------------------\n\nTITLE: Syntax for Processed String Literals in Scala\nDESCRIPTION: Shows the general syntax (`id\"string content\"`) for processed string literals in Scala. The compiler transforms this into a method call on the `id` interpolator.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/string-interpolation.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nid\"string content\"\n```\n\n----------------------------------------\n\nTITLE: Importing specific classes and members in Scala 2 and 3\nDESCRIPTION: Shows how to selectively import specific classes or members from a package, such as 'User' and 'UserPreferences', in Scala, using syntax for both Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/packaging-imports.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport users.User                         // Scala 2 and 3\nimport users.{User, UserPreferences}      // Scala 2 and 3\n```\n\n----------------------------------------\n\nTITLE: Calling Function Variables in Scala\nDESCRIPTION: Demonstrates how to call a function variable directly and how to pass it as a parameter to higher-order functions like map.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-function-variables.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval x = double(2)   // 4\n```\n\nLANGUAGE: scala\nCODE:\n```\nList(1, 2, 3).map(double)   // List(2, 4, 6)\n```\n\n----------------------------------------\n\nTITLE: Using ADT Cases Defined with `enum` in Scala\nDESCRIPTION: Demonstrates how to create instances of ADT cases (`Option.Some` and `Option.None`) defined using the `enum` keyword in Scala 3. The cases reside within the enum's namespace.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-adts-gadts.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nscala> Option.Some(\"hello\")\nval res1: t2.Option[String] = Some(hello)\n\nscala> Option.None\nval res2: t2.Option[Nothing] = None\n```\n\n----------------------------------------\n\nTITLE: Lambda Syntax Variations in Scala Collections\nDESCRIPTION: Different forms of lambda syntax in Scala collections, showing the progression from the most explicit form to the most concise form using placeholders (_).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-methods.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// these functions are all equivalent and return\n// the same data: List(10, 20, 10)\n\na.filter((i: Int) => i < 25)   // 1. most explicit form\na.filter((i) => i < 25)        // 2. `Int` is not required\na.filter(i => i < 25)          // 3. the parens are not required\na.filter(_ < 25)               // 4. `i` is not required\n```\n\n----------------------------------------\n\nTITLE: Adding Elements to a List\nDESCRIPTION: Shows how to create new Lists by prepending elements with :: and prepending another List with :::. Lists in Scala are immutable, so these operations create new Lists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval b = 0 :: a              // List(0, 1, 2, 3)\nval c = List(-1, 0) ::: a   // List(-1, 0, 1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Using Type Inference for Common Numeric Types in Scala\nDESCRIPTION: Here, variables are declared without explicit types; Scala infers their types. An integer literal defaults to Int and a decimal to Double. This pattern is idiomatic in Scala for common cases, relying on the compiler's type inference abilities.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/first-look-at-types.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval i = 123   // defaults to Int\nval x = 1.0   // defaults to Double\n```\n\n----------------------------------------\n\nTITLE: Yielding Values with For Expressions in Scala 3 (Simple Form)\nDESCRIPTION: Produces a new list, doubles, containing each value of ints multiplied by 2 using Scala 3's for/yield expression syntax. ints must be a List[Int]. Assigns a List[Int] result.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nscala> val doubles = for i <- ints yield i * 2\nval doubles: List[Int] = List(2, 4, 6, 8, 10)\n\n```\n\n----------------------------------------\n\nTITLE: Iterating through a Map with for-loop in Scala 3\nDESCRIPTION: Shows how to iterate through a Map's key-value pairs using a for-loop with Scala 3 syntax, which uses the 'do' keyword instead of curly braces.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nfor (abbrev, fullName) <- states do println(s\"$abbrev: $fullName\")\n```\n\n----------------------------------------\n\nTITLE: Scala and Python Variables and Data Structures\nDESCRIPTION: This section compares variable assignment and collection data structures such as lists, dictionaries, sets, and tuples in Scala and Python. It highlights syntax differences and the use of immutable versus mutable variables. The snippets demonstrate creating integers, strings, lists, maps, sets, and tuples in both languages, illustrating their syntax and conventions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nx = 1\nx = \"Hi\"\n y = \"\"\"foo\n        bar\n        baz\"\"\"\n```\n\nLANGUAGE: scala\nCODE:\n```\nval x = 1\nval x = \"Hi\"\nval y = \"\"\"foo\n        bar\n        baz\"\"\"\n```\n\nLANGUAGE: python\nCODE:\n```\nx = [1,2,3]\n```\n\nLANGUAGE: scala\nCODE:\n```\nval x = List(1,2,3)\n```\n\nLANGUAGE: python\nCODE:\n```\nx = {\n  \"Toy Story\": 8.3,\n  \"Forrest Gump\": 8.8,\n  \"Cloud Atlas\": 7.4\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval x = Map(\n  \"Toy Story\" -> 8.3,\n  \"Forrest Gump\" -> 8.8,\n  \"Cloud Atlas\" -> 7.4\n)\n```\n\nLANGUAGE: python\nCODE:\n```\nx = {1,2,3}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval x = Set(1,2,3)\n```\n\nLANGUAGE: python\nCODE:\n```\nx = (11, \"Eleven\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nval x = (11, \"Eleven\")\n```\n\n----------------------------------------\n\nTITLE: Declaring and Updating Variables with var in Scala\nDESCRIPTION: Shows the use of var to declare mutable variables that can be updated after assignment. Demonstrates reassignment and use in expressions. Key for scenarios needing mutable state.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nvar x = 1 + 1\nx = 3 // This compiles because \"x\" is declared with the \"var\" keyword.\nprintln(x * x) // 9\n```\n\n----------------------------------------\n\nTITLE: Creating Multi-line Interpolated Strings with `stripMargin` in Scala\nDESCRIPTION: Demonstrates creating multi-line strings using triple quotes and the `s` interpolator in Scala. The `stripMargin` method is used with a default `|` character to remove leading whitespace up to the margin character, allowing for readable indented code while producing clean output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nprintln(s\"\"\"name: \"$name\",\n           |age: $age\"\"\".stripMargin)\n```\n\n----------------------------------------\n\nTITLE: Using Named Methods with List.map in Scala\nDESCRIPTION: Shows how to use a named method instead of a lambda with the map function, demonstrating both explicit parameter passing and method reference syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-functions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef double(i: Int): Int = i * 2\n\nval a = List(1, 2, 3).map(i => double(i))   // List(2,4,6)\nval b = List(1, 2, 3).map(double)           // List(2,4,6)\n```\n\n----------------------------------------\n\nTITLE: 测试集合元素存在性 - Scala\nDESCRIPTION: 演示如何使用Scala集合的contains和apply方法检测元素是否存在。示例中定义一个不可变集合fruit，分别测试\"peach\"和\"potato\"是否包含在集合中，说明apply方法和contains方法的等价性。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/sets.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval fruit = Set(\"apple\", \"orange\", \"peach\", \"banana\")\nfruit: scala.collection.immutable.Set[java.lang.String] =\nSet(apple, orange, peach, banana)\nscala> fruit(\"peach\")\nres0: Boolean = true\nscala> fruit(\"potato\")\nres1: Boolean = false\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait with an Implemented Method in Scala\nDESCRIPTION: Scala traits can contain concrete, implemented methods in addition to abstract ones. Classes mixing in the trait inherit these implementations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Adder:\n  def add(a: Int, b: Int): Int\n  def multiply(a: Int, b: Int): Int =\n    a * b\n```\n\n----------------------------------------\n\nTITLE: Implementing Logic Functions with Infix Operators - Scala\nDESCRIPTION: This code defines `not` and `xor` functions for the `MyBool` type. It illustrates how the `and` and `or` methods, defined in `MyBool`, can be invoked using the more readable infix operator syntax (`x or y`), enhancing the clarity of logical expressions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/operators.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef not(x: MyBool) = x.negate\ndef xor(x: MyBool, y: MyBool) = (x or y) and not(x and y)\n```\n\n----------------------------------------\n\nTITLE: Taking elements from a list using take, takeRight, and takeWhile in Scala\nDESCRIPTION: Shows usage of take, takeRight, and takeWhile methods on Scala lists to select elements from the start, end, or based on a predicate. Examples cover normal usage and edge cases where the requested number of elements exceeds the list size or is zero. These methods return new lists without modifying the original collection, providing flexible slicing capabilities.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-methods.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\noneToTen.take(1)        // List(1)\noneToTen.take(2)        // List(1, 2)\n\noneToTen.takeRight(1)   // List(10)\noneToTen.takeRight(2)   // List(9, 10)\n```\n\nLANGUAGE: scala\nCODE:\n```\noneToTen.take(Int.MaxValue)        // List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\noneToTen.takeRight(Int.MaxValue)   // List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\noneToTen.take(0)                   // List()\noneToTen.takeRight(0)              // List()\n```\n\nLANGUAGE: scala\nCODE:\n```\noneToTen.takeWhile(_ < 5)       // List(1, 2, 3, 4)\nnames.takeWhile(_.length < 5)   // List(adam)\n```\n\n----------------------------------------\n\nTITLE: Checking for Key Existence in a Scala Map\nDESCRIPTION: This example demonstrates how to test if a Map contains a specified key using the 'contains' method. Requires a Map and a key as input. Output is a Boolean indicating the key's existence. This is an efficient and idiomatic way to perform key existence checks in Scala Maps.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/collections-maps.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval contains3 = m.contains(3)\n```\n\n----------------------------------------\n\nTITLE: Combining mapping and filtering with comprehensions in Python and Scala\nDESCRIPTION: Demonstrates chaining filtering and mapping operations in collection pipelines. Python uses list comprehension with if clause and expression transformation. Scala shows first filtering with 'filter' then mapping with 'map', or an alternative using for-comprehensions combining both filtering and mapping in one expression. Both approaches produce transformed collections of filtered elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_65\n\nLANGUAGE: python\nCODE:\n```\nx = [i * 10 for i in numbers if i % 2 == 0]\n```\n\nLANGUAGE: scala\nCODE:\n```\nval x = numbers.filter(_ % 2 == 0).map(_ * 10)\n// or\nval x = for i <- numbers if i % 2 == 0 yield i * 10\n```\n\n----------------------------------------\n\nTITLE: Implementing a Cached Function Using Mutable Map and getOrElseUpdate in Scala\nDESCRIPTION: Demonstrates defining a Scala function 'cachedF' that leverages a mutable Map to cache previously computed results of an expensive function 'f'. Uses the 'getOrElseUpdate' method of mutable Map to either retrieve the cached value for a given input or compute it by calling 'f' and then store it. This implementation ensures the expensive computation is only performed once per unique input string. The snippet is applicable for both Scala 2 and Scala 3 versions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/maps.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef cachedF(s: String): String = cache.getOrElseUpdate(s, f(s))\n```\n\n----------------------------------------\n\nTITLE: Defining Package-Level Variable and Method Using Scala 3 Top Level Definitions\nDESCRIPTION: Defines the variable `planted` and method `showFruit` directly at the top level of the package `gardening.fruits` without wrapping them in a package object, a Scala 3 feature. This enables more concise and readable code for package members. It uses string interpolation for output formatting and depends on the previously defined Fruit class and objects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/package-objects.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\npackage gardening.fruits\n\nval planted = List(Apple, Plum, Banana)\ndef showFruit(fruit: Fruit): Unit =\n  println(s\"${fruit.name}s are ${fruit.color}\")\n```\n\n----------------------------------------\n\nTITLE: String Interpolation in Scala\nDESCRIPTION: This snippet demonstrates simple (s) and formatted (f) string interpolation in Scala. Variables or expressions starting with $ are evaluated and inserted. The f interpolator allows printf-style formatting.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nval name = \"Joe\"\nval age = 42\nval weight = 180.5\n\n// use `s` before a string for simple interpolation\nprintln(s\"Hi, $name\")  // \"Hi, Joe\"\nprintln(s\"${1 + 1}\")   // \"2\"\n\n// `f` before a string allows printf-style formatting.\n// this example prints:\n// \"Joe is 42 years old, and weighs\"\n// \"180.5 pounds.\"\nprintln(f\"$name is $age years old, and weighs $weight%.1f pounds.\")\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Tuples in foreach (Scala mdoc)\nDESCRIPTION: Shows how to use pattern matching on tuples when iterating over a list with foreach in Scala. No external dependencies are required. The list 'planets' contains tuples (planet name, distance). The code matches the tuple for 'Earth' and prints a formatted message; other elements are ignored using the wildcard pattern.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/tuples.md#_snippet_4\n\nLANGUAGE: Scala mdoc\nCODE:\n```\nval planets =\n  List((\"Mercury\", 57.9), (\"Venus\", 108.2), (\"Earth\", 149.6),\n       (\"Mars\", 227.9), (\"Jupiter\", 778.3))\nplanets.foreach {\n  case (\"Earth\", distance) =>\n    println(s\"Our planet is $distance million kilometers from the sun\")\n  case _ =>\n}\n```\n\n----------------------------------------\n\nTITLE: Using Enum Members in Scala 3\nDESCRIPTION: Imports enum members in Scala 3 and uses pattern matching and comparisons similarly to Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-modeling.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nimport CrustSize.*\nval currentCrustSize = Small\n\n// enums in a `match` expression\ncurrentCrustSize match\n  case Small => println(\"Small crust size\")\n  case Medium => println(\"Medium crust size\")\n  case Large => println(\"Large crust size\")\n\n// enums in an `if` statement\nif currentCrustSize == Small then println(\"Small crust size\")\n```\n\n----------------------------------------\n\nTITLE: Standard sbt Directory Structure\nDESCRIPTION: Shows the standard directory structure expected by sbt for Scala projects, including main source directories, test directories, and build configuration files.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/scala-build-tool-sbt.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbuild.sbt\nproject/\nsrc/\n-- main/\n   |-- java/\n   |-- resources/\n   |-- scala/\n|-- test/\n   |-- java/\n   |-- resources/\n   |-- scala/\ntarget/\n```\n\n----------------------------------------\n\nTITLE: Creating dictionaries and maps in Python and Scala\nDESCRIPTION: Shows how to create associative collections: Python's dictionary and Scala's immutable Map. Python dict uses curly braces with key-value pairs. Scala Map uses 'Map' constructor with arrow (->) syntax for key-value pairs. Used to compare mutable (Python) vs immutable (Scala default) collection types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_56\n\nLANGUAGE: python\nCODE:\n```\nmy_dict = {\n  'a': 1,\n  'b': 2,\n  'c': 3\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval myMap = Map(\n  \"a\" -> 1,\n  \"b\" -> 2,\n  \"c\" -> 3\n)\n```\n\n----------------------------------------\n\nTITLE: Sending Asynchronous HTTP Requests with sttp in Scala 2\nDESCRIPTION: This snippet demonstrates how to perform asynchronous HTTP GET requests using sttp and Scala Futures in Scala 2. It imports the required 'sttp.client4._' library and uses 'DefaultFutureBackend' to enable async execution. The request targets a sample URL and returns a Future-wrapped Response. Dependencies: sttp.client4, Scala standard library (Future), active internet connection. Key parameters include the URL and the backend; outputs a Future[Response[String]]. Only works with Future-compatible backends.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/http-client-what-else.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.concurrent.Future\nimport sttp.client4._\n\nval asyncBackend = DefaultFutureBackend()\nval response: Future[Response[String]] = quickRequest\n  .get(uri\"https://example.com\")\n  .send(asyncBackend)\n```\n\n----------------------------------------\n\nTITLE: Creating a fixed thread pool ExecutionContext in Scala\nDESCRIPTION: Demonstrates how to create an ExecutionContext from a fixed thread pool, which does not implement the 'blocking' construct in a special way.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\nExecutionContext.fromExecutor(Executors.newFixedThreadPool(x))\n```\n\n----------------------------------------\n\nTITLE: Inheriting Scala SortedSetOps Template Trait\nDESCRIPTION: Illustrates how the `SortedSet` trait extends `SortedSetOps`. By instantiating the template trait's type parameters `CC[_]` and `C` with `SortedSet` and `SortedSet[A]`, respectively, `SortedSet` gains access to the specialized transformation methods (like the `map` requiring `Ordering`) defined within `SortedSetOps`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_13\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\ntrait SortedSet[A] extends SortedSetOps[A, SortedSet, SortedSet[A]]\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Trait with Abstract Methods in Scala\nDESCRIPTION: Defines a generic trait 'Iterator[A]' with two abstract methods: 'hasNext', returning a Boolean indicating if more elements exist, and 'next()', which returns an element of generic type A. This snippet requires Scala, and implementations extending this trait must provide concrete definitions for these methods. It exemplifies a common pattern of type-parameterized traits with abstract members to define interfaces.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/traits.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Iterator[A] {\n  def hasNext: Boolean\n  def next(): A\n}\n```\n\n----------------------------------------\n\nTITLE: Using Java IO Classes in Scala\nDESCRIPTION: Demonstrates how Scala code can seamlessly utilize standard Java libraries. This snippet shows how to import and instantiate `BufferedReader` and `FileReader` classes from Java's `java.io` package directly within a Scala application to facilitate file reading.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-features.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nimport java.io.*\nval br = BufferedReader(FileReader(filename))\n// read the file with `br` ...\n```\n\n----------------------------------------\n\nTITLE: Using Singleton-ops Library with Typelevel Scala for Intuitive Type-Level Operations\nDESCRIPTION: This example demonstrates how the singleton-ops library with Typelevel Scala enables developers to perform type-level operations intuitively. It shows type-level arithmetic and instantiating type-parameterized classes with computed type parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/priority-based-infix-type-precedence.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport singleton.ops._\n\nval four1 : 4 = implicitly[2 + 2]\nval four2 : 2 + 2 = 4\nval four3 : 1 + 3 = implicitly[2 + 2]\n\nclass MyVec[L] {\n  def doubleSize = new MyVec[2 * L]\n  def nSize[N] = new MyVec[N * L]\n}\nobject MyVec {\n  implicit def apply[L](implicit check : Require[L > 0]) : MyVec[L] = new MyVec[L]()\n}\nval myVec : MyVec[10] = MyVec[4 + 1].doubleSize\nval myBadVec = MyVec[-1] //fails compilation, as required\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Extractor Macros with Macro Implementations in Scala\nDESCRIPTION: This snippet shows how to define an extractor macro in Scala that generates extraction signatures for the unapply method at call time. It declares an unapply method as a macro that delegates to an implementation method using Scala's macro Context. The implementation dynamically constructs a matcher class with isEmpty and get methods, used to support pattern matching without runtime reflection. The macro leverages quasiquotes to generate the necessary extraction logic in the abstract syntax tree. Dependencies include Scala's macro Context and quasiquotes. The input is a tree representing the scrutinee to extract from. The output is a tree representing the generated matcher for pattern matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/extractors.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef unapply(x: SomeType) = macro impl\n\ndef impl(c: Context)(x: c.Tree) = {\n  q\"\"\"\n    new {\n      class Match(x: SomeType) {\n        def isEmpty = false\n        def get = x\n      }\n      def unapply(x: SomeType) = new Match(x)\n    }.unapply($x)\n  \"\"\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Scala Class Extending an Abstract Class\nDESCRIPTION: Illustrates how to define a Scala class that inherits from an abstract superclass, overriding or implementing required members. This snippet models classical inheritance patterns using the 'extends' keyword, allowing reuse and polymorphism. It depends on the presence of the abstract class D and follows Scala inheritance rules.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/cheatsheets/index.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass C extends D { ... }\n```\n\n----------------------------------------\n\nTITLE: Implicit Conversion to ArrayOps and Priority in Method Selection\nDESCRIPTION: Shows how calling sequence methods on arrays triggers implicit conversion to ArrayOps, leading to method calls that return arrays. Explains how implicit conversion priorities (defined in Predef and inherited classes) determine which conversion is chosen when multiple are applicable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/arrays.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nintArrayOps(a1).reverse\n```\n\n----------------------------------------\n\nTITLE: Defining RNA2 class in Scala 3\nDESCRIPTION: This Scala 3 class implementation of RNA2 provides an immutable collection for RNA sequences, extending IndexedSeq and IndexedSeqOps with similar methods as Scala 2 but using Scala 3 syntax, such as colon suffix notation and inline modifiers for method overloading. It improves code readability and performance optimizations for collection operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.{ View, mutable }\nimport scala.collection.immutable.{ IndexedSeq, IndexedSeqOps }\n\nfinal class RNA2 private (val groups: Array[Int], val length: Int)\n  extends IndexedSeq[Base], IndexedSeqOps[Base, IndexedSeq, RNA2]:\n\n  import RNA2.*\n\n  def apply(idx: Int): Base = // as before\n  override protected def fromSpecific(coll: IterableOnce[Base]): RNA2 = // as before\n  override protected def newSpecificBuilder: mutable.Builder[Base, RNA2] = // as before\n  override def empty: RNA2 = // as before\n  override def className = \"RNA2\"\n\n  // Overloading of `appended`, `prepended`, `appendedAll`,\n  // `prependedAll`, `map`, `flatMap` and `concat` to return an `RNA2`\n  // when possible\n  def concat(suffix: IterableOnce[Base]): RNA2 =\n    fromSpecific(iterator ++ suffix.iterator)\n  // symbolic alias for `concat`\n  inline final def ++ (suffix: IterableOnce[Base]): RNA2 = concat(suffix)\n  def appended(base: Base): RNA2 =\n    fromSpecific(View.Appended(this, base))\n  def appendedAll(suffix: IterableOnce[Base]): RNA2 =\n    concat(suffix)\n  def prepended(base: Base): RNA2 =\n    fromSpecific(View.Prepended(base, this))\n  def prependedAll(prefix: IterableOnce[Base]): RNA2 =\n    fromSpecific(prefix.iterator ++ iterator)\n  def map(f: Base => Base): RNA2 =\n    fromSpecific(View.Map(this, f))\n  def flatMap(f: Base => IterableOnce[Base]): RNA2 =\n    fromSpecific(View.FlatMap(this, f))\nend RNA2\n\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Contextual Parameters (givens) for Generic Comparison in Scala 3\nDESCRIPTION: Defines a 'Comparator' trait and provides 'given' instances for 'Int' and 'String' within its companion object. Implements a generic 'max' function that requires a 'using' 'Comparator[A]'. Demonstrates calling 'max' with 'Int' and 'String' arguments, showing how Scala 3 automatically resolves and provides the appropriate 'given' 'Comparator' instances using the new syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/implicit-parameters.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait Comparator[A]:\n  def compare(x: A, y: A): Int\n\nobject Comparator:\n  given Comparator[Int] with\n    def compare(x: Int, y: Int): Int = Integer.compare(x, y)\n\n  given Comparator[String] with\n    def compare(x: String, y: String): Int = x.compareTo(y)\nend Comparator\n\ndef max[A](x: A, y: A)(using comparator: Comparator[A]): A =\n  if comparator.compare(x, y) >= 0 then x\n  else y\n\nprintln(max(10, 6))             // 10\nprintln(max(\"hello\", \"world\"))  // world\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lower Type Bounds in Scala with Practical Usage Examples\nDESCRIPTION: This snippet illustrates practical application of the `ListNode` class with lower type bounds in a Scala `App` object. It creates an empty list of `Null`, prepends `String` elements, and extends the list with an `Int`, demonstrating how lower bounds facilitate safe subtype relations and list flexibility in Scala's type hierarchy.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/lower-type-bounds.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject LowerBoundTest extends App {\n  val empty: ListNode[Null] = ListNode(null, null)\n  val strList: ListNode[String] = empty.prepend(\"hello\")\n                                       .prepend(\"world\")\n  val anyList: ListNode[Any] = strList.prepend(12345)\n}\n```\n\n----------------------------------------\n\nTITLE: Scala 2 and 3: Method Type Signature for `map` Function\nDESCRIPTION: Shows the signature of Scala collection's `map` method, which accepts a function from `A` to `B`. This illustrates that methods can be used where functions are expected due to eta-expansion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-eta-expansion.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef map[B](f: A => B): List[B]\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait in Scala\nDESCRIPTION: Defines a basic trait named HairColor without any members. This snippet illustrates the simplest form of declaring a trait using the keyword `trait` followed by an identifier. It introduces the concept that traits can be type abstractions used for code reuse and interface definition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/tour/traits.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait HairColor\n```\n\n----------------------------------------\n\nTITLE: Using andThen combinator for side-effecting operations on Futures in Scala 2\nDESCRIPTION: Illustrates chaining side-effecting operations on a Future via the 'andThen' combinator. The example creates a mutable set to accumulate posts retrieved asynchronously from a session, then clears any rendering and re-renders all posts. The andThen combinator does not modify the Future's result but ensures the provided side-effecting callbacks run sequentially upon completion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\nval allposts = mutable.Set[String]()\n\nFuture {\n  session.getRecentPosts\n} andThen {\n  case Success(posts) => allposts ++= posts\n} andThen {\n  case _ =>\n    clearAll()\n    for (post <- allposts) render(post)\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Dependencies and Counting Files Using os-lib in Scala\nDESCRIPTION: This snippet defines a main method 'countFiles' that utilizes the os-lib library to list the current working directory and print the total number of entries, including hidden directories. It demonstrates how to add dependencies via Scala CLI directives and perform filesystem operations in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/getting-started/install-scala.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n//> using scala {{site.scala-3-version}}\n//> using dep \"com.lihaoyi::os-lib:0.11.4\"\n\n@main\ndef countFiles(): Unit =\n  val paths = os.list(os.pwd)\n  println(paths.length)\n```\n\n----------------------------------------\n\nTITLE: Using nested packages with package clauses in Scala 2\nDESCRIPTION: Shows how to define nested packages within a single source file using package clauses, allowing for scope control and encapsulation at different nesting levels in Scala 2. The full package names are constructed by nesting and concatenation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/packaging-imports.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\npackage users {\n\n  package administrators {  // the full name of this package is users.administrators\n    class AdminUser        // the full name of this class users.administrators.AdminUser\n  }\n  package normalusers {     // the full name of this package is users.normalusers\n    class NormalUser       // the full name of this class is users.normalusers.NormalUser\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Trait in a Class in Scala 2\nDESCRIPTION: This snippet demonstrates how to implement a trait in a Scala 2 class. The Document class extends Showable and provides the required implementation of show, exposing the text parameter as its string representation. No additional dependencies are needed, and this pattern is foundational for OOP in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass Document(text: String) extends Showable {\n  def show = text\n}\n```\n\n----------------------------------------\n\nTITLE: Using Set as a Test Function in Scala 2 and 3\nDESCRIPTION: This Scala code snippet demonstrates how to create an immutable set of strings and utilize it as a test function to check whether specific elements are contained within the set, illustrating that sets can act as predicate functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/sets.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val fruit = Set(\"apple\", \"orange\", \"peach\", \"banana\")\nfruit: scala.collection.immutable.Set[java.lang.String] = Set(apple, orange, peach, banana)\nscala> fruit(\"peach\")\nres0: Boolean = true\nscala> fruit(\"potato\")\nres1: Boolean = false\n```\n\n----------------------------------------\n\nTITLE: Null Fallback Extraction with orNull Pattern - Scala\nDESCRIPTION: This snippet replicates Option.orNull using pattern matching. If the Option contains a value, returns it; if not, returns null. Input is an Option; output is the underlying type or null. No external dependencies are required. Suitable for interop with Java APIs requiring nulls.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\noption match {\n  case Some(x) => x\n  case None    => null\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Java annotation with named arguments in Scala\nDESCRIPTION: Shows the syntax for applying a Java annotation with multiple elements in Scala. Similar to Java, named arguments (`elementName = value`) are used to initialize the annotation elements when applied to a Scala definition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/annotations.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\n@Source(url = \"https://coders.com/\",\n        mail = \"support@coders.com\")\nclass MyScalaClass ...\n```\n\n----------------------------------------\n\nTITLE: Defining ParString Class with GenericParTemplate Integration in Scala\nDESCRIPTION: This Scala class defines ParString as a parallel immutable sequence of characters integrating the GenericParTemplate trait for collection compatibility. ParString extends immutable.ParSeq and ParSeqLike to provide parallel collection behavior. The companion object is referenced via the companion method, linking the collection to its builder. This setup allows usage of parallel transformer methods requiring implicit CanBuildFrom evidence.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/custom-parallel-collections.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass ParString(val str: String)\nextends immutable.ParSeq[Char]\n   with GenericParTemplate[Char, ParString]\n   with ParSeqLike[Char, ParString, collection.immutable.WrappedString] {\n\n  def companion = ParString\n```\n\n----------------------------------------\n\nTITLE: Including upickle in Mill build.sc file\nDESCRIPTION: This snippet illustrates how to declare upickle as a dependency within a Mill build.sc build script by extending ScalaModule and specifying ivyDeps, either by adding the full toolkit or just the upickle library. It follows Mill's dependency configuration syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-upickle.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nobject example extends ScalaModule {\n  def scalaVersion = \"3.4.2\"\n  def ivyDeps =\n    Agg(\n      ivy\"org.scala-lang::toolkit:0.7.0\"\n    )\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nivy\"com.lihaoyi::upickle:4.1.0\"\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Option for Result Handling in Scala\nDESCRIPTION: This snippet shows how to work with an Option[Int] returned from the makeInt function using Scala's pattern matching. It matches the Option value: on Some(i), it prints the integer; on None, it reports the conversion failure. No dependencies are required beyond a valid Option value and an input aString. Inputs include an Option[Int] and aString, with output being printed messages to the console. The approach provides exhaustive handling for the Option type and clearly separates the logic for success and failure cases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_65\n\nLANGUAGE: Scala\nCODE:\n```\nmakeInt(aString) match\n  case Some(i) => println(s\"Int i = $i\")\n  case None => println(s\"Could not convert $aString to an Int.\")\n```\n\n----------------------------------------\n\nTITLE: Exception Handling with try/catch/finally Using Pattern Matching in Scala 3\nDESCRIPTION: Replicates the Scala 2 example of reading a file and handling `FileNotFoundException` and `IOException` exceptions with pattern matched catch clauses, but with Scala 3's indentation-based syntax omitting braces. The finally block executes cleanup code with an illustrative println statement. The example depends on `openAndReadAFile` method throwing Java IO exceptions and standard library classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_40\n\nLANGUAGE: scala\nCODE:\n```\nvar text = \"\"\ntry\n  text = openAndReadAFile(filename)\ncatch\n  case fnf: FileNotFoundException => fnf.printStackTrace()\n  case ioe: IOException => ioe.printStackTrace()\nfinally\n  // close your resources here\n  println(\"Came to the 'finally' clause.\")\n```\n\n----------------------------------------\n\nTITLE: Creating a package in Scala 2 and 3\nDESCRIPTION: Defines a package named 'com.acme.myapp.model' and shows how to declare a class 'Person' within it. Demonstrates package declaration syntax and conventions for directory structure alignment.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/packaging-imports.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\npackage com.acme.myapp.model\n\nclass Person ...\n```\n\n----------------------------------------\n\nTITLE: Implementing a Timer with Callback Functions in Scala\nDESCRIPTION: Demonstrates how to implement a timer function that executes a callback every second. Shows how functions can be passed as arguments, highlighting Scala's functional programming capabilities.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nobject Timer {\n  def oncePerSecond(callback: () => Unit): Unit = {\n    while (true) { callback(); Thread.sleep(1000) }\n  }\n  def timeFlies(): Unit = {\n    println(\"time flies like an arrow...\")\n  }\n  def main(args: Array[String]): Unit = {\n    oncePerSecond(timeFlies)\n  }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef oncePerSecond(callback: () => Unit): Unit =\n  while true do { callback(); Thread.sleep(1000) }\n\ndef timeFlies(): Unit =\n  println(\"time flies like an arrow...\")\n\n@main def Timer: Unit =\n  oncePerSecond(timeFlies)\n```\n\n----------------------------------------\n\nTITLE: 定义接受函数参数的示例方法\nDESCRIPTION: 展示如何在 Scala 中定义一个接受无参数函数的 `sayHello` 方法，并在主程序中调用传入的函数。此代码强调函数参数的类型签名以及调用方式。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-hofs.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef sayHello(f: () => Unit): Unit = f()\n```\n\n----------------------------------------\n\nTITLE: Functionally Updating an Immutable Vector in Scala\nDESCRIPTION: Demonstrates the `updated` method on an immutable Vector. It creates a *new* Vector with the element at the specified index (2) changed to the new value (4), leaving the original Vector `vec` unmodified.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/concrete-immutable-collection-classes.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval vec = Vector(1, 2, 3)\n```\n\nLANGUAGE: output\nCODE:\n```\nvec: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3)\n```\n\nLANGUAGE: scala\nCODE:\n```\nvec updated (2, 4)\n```\n\nLANGUAGE: output\nCODE:\n```\nres0: scala.collection.immutable.Vector[Int] = Vector(1, 2, 4)\n```\n\nLANGUAGE: scala\nCODE:\n```\nvec\n```\n\nLANGUAGE: output\nCODE:\n```\nres1: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Creating a List of Any Type Elements and Iterating in Scala\nDESCRIPTION: Creates a Scala List typed to hold elements of type Any, initialized with diverse data types including String, Int, Char, Boolean, and an anonymous function. Iterates over the list, printing each element. Illustrates that heterogeneous types can be stored since all inherit from Any. Dependencies include Scala collections library.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/first-look-at-types.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval list: List[Any] = List(\n  \"a string\",\n  732,  // число\n  'c',  // буква\n  '\\'', // Экранированный символ\n  true, // булево значение\n  () => \"an anonymous function returning a string\"\n)\n\nlist.foreach(element => println(element))\n```\n\n----------------------------------------\n\nTITLE: Numeric Operators in JavaScript and Scala\nDESCRIPTION: This snippet illustrates common numeric operators (+, -, *, /, %) in both JavaScript and Scala. The syntax and basic usage for these operators are largely the same between the two languages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_11\n\nLANGUAGE: JavaScript\nCODE:\n```\nlet x = 1;\nlet y = 2.0;\n \nlet a = 1 + 1;\nlet b = 2 - 1;\nlet c = 2 * 2;\nlet d = 4 / 2;\nlet e = 5 % 2;\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval x = 1\nval y = 2.0\n \nval a = 1 + 1\nval b = 2 - 1\nval c = 2 * 2\nval d = 4 / 2\nval e = 5 % 2\n```\n\n----------------------------------------\n\nTITLE: Combining Concrete Class with Mixin Trait for Rich Iterator in Scala\nDESCRIPTION: Creates class `RichStringIter` which extends the concrete `StringIterator` initialized to iterate over \"Scala\" and mixes in the `RichIterator` trait to obtain `foreach` functionality. Instantiates this class and calls `foreach` with `println`, effectively printing each character of the string. Dependencies: requires concrete `StringIterator` class and `RichIterator` trait. Inputs: none at runtime beyond hardcoded string. Outputs: prints each character of \"Scala\" on a separate line.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/mixin-class-composition.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass RichStringIter extends StringIterator(\"Scala\") with RichIterator\nval richStringIter = new RichStringIter\nrichStringIter foreach println\n```\n\n----------------------------------------\n\nTITLE: Another Trait with Mixed Members in Scala\nDESCRIPTION: Defining a trait with one abstract property and two concrete methods related to tail functionality.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ntrait HasTail {\n  def tailColor: String\n  def wagTail() = println(\"Tail is wagging\")\n  def stopTail() = println(\"Tail is stopped\")\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait HasTail:\n  def tailColor: String\n  def wagTail() = println(\"Tail is wagging\")\n  def stopTail() = println(\"Tail is stopped\")\n```\n\n----------------------------------------\n\nTITLE: Defining singleton objects in Scala\nDESCRIPTION: Demonstrates the syntax to create a singleton object `O` using `object` keyword, which acts like a module or static object extending a class or trait. This design ensures a single instance existence throughout the application lifecycle.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\nobject O extends D { ... }\n```\n\n----------------------------------------\n\nTITLE: Assigning Match Expression Result (Scala 3)\nDESCRIPTION: Shows how a `match` expression in Scala 3 can return a value which is assigned to a variable, illustrating its use as a true expression using the new indentation-based syntax. Matches integer values and returns corresponding string representations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\nval result = i match\n  case 1 => \"one\"\n  case 2 => \"two\"\n  case _ => \"other\"\n```\n\n----------------------------------------\n\nTITLE: Scala Enumeration for Sum Types in Scala 3\nDESCRIPTION: Uses the 'enum' construct in Scala 3 to define enumerations such as crust sizes, types, and toppings, replacing Scala 2 sealed traits.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-modeling.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nenum CrustSize:\n  case Small, Medium, Large\n\nenum CrustType:\n  case Thin, Thick, Regular\n\nenum Topping:\n  case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions\n```\n\n----------------------------------------\n\nTITLE: Importing All Members from an Object in Scala 3\nDESCRIPTION: Example of importing all members from a singleton object in Scala 3 to use them without qualification.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-tools.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nimport StringUtils.*\ntruncate(\"Chuck Bartowski\", 5)       // \"Chuck\"\ncontainsWhitespace(\"Sarah Walker\")   // true\nisNullOrEmpty(\"John Casey\")          // false\n```\n\n----------------------------------------\n\nTITLE: Exception Handling with Try/Catch/Finally (Scala 3)\nDESCRIPTION: Illustrates the `try`/`catch`/`finally` structure in Scala 3 for handling exceptions using the new indentation-based syntax. The `catch` block uses pattern matching on specific exception types (`IOException`, `NumberFormatException`), and the `finally` block ensures cleanup code runs regardless of whether an exception occurred. Requires definition of `writeTextToFile` and a `text` variable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_27\n\nLANGUAGE: Scala\nCODE:\n```\ntry\n  writeTextToFile(text)\ncatch\n  case ioe: IOException => println(\"Got an IOException.\")\n  case nfe: NumberFormatException => println(\"Got a NumberFormatException.\")\nfinally\n  println(\"Clean up your resources here.\")\n```\n\n----------------------------------------\n\nTITLE: Implementing String Iterator (Scala)\nDESCRIPTION: Provides a concrete implementation of the `AbsIterator` interface specifically for iterating over characters in a string. It defines the type member `T` as `Char` and implements the `hasNext` and `next` methods using internal state to track the current position.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/mixin-class-composition.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass StringIterator(s: String) extends AbsIterator {\n  type T = Char\n  private var i = 0\n  def hasNext = i < s.length\n  def next() = {\n    val ch = s charAt i\n    i += 1\n    ch\n  }\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass StringIterator(s: String) extends AbsIterator:\n  type T = Char\n  private var i = 0\n  def hasNext = i < s.length\n  def next() =\n    val ch = s charAt i\n    i += 1\n    ch\n```\n\n----------------------------------------\n\nTITLE: Examples of Common Scala Collection Methods\nDESCRIPTION: Illustrates usage of various Scala collection methods such as distinct, drop, dropRight, filter, find, head, init, intersect, last, slice, tail, take, takeRight, and takeWhile on a sample list 'a' demonstrating their outputs and usage.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_35\n\nLANGUAGE: Scala\nCODE:\n```\nval a = List(10, 20, 30, 40, 10)      // List(10, 20, 30, 40, 10)\na.distinct                            // List(10, 20, 30, 40)\na.drop(2)                             // List(30, 40, 10)\na.dropRight(2)                        // List(10, 20, 30)\na.dropWhile(_ < 25)                   // List(30, 40, 10)\na.filter(_ < 25)                      // List(10, 20, 10)\na.filter(_ > 100)                     // List()\na.find(_ > 20)                        // Some(30)\na.head                                // 10\na.headOption                          // Some(10)\na.init                                // List(10, 20, 30, 40)\na.intersect(List(19,20,21))           // List(20)\na.last                                // 10\na.lastOption                          // Some(10)\na.slice(2,4)                          // List(30, 40)\na.tail                                // List(20, 30, 40, 10)\na.take(3)                             // List(10, 20, 30)\na.takeRight(2)                        // List(40, 10)\na.takeWhile(_ < 30)                   // List(10, 20)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Generic Scala Trait with Methods\nDESCRIPTION: Shows the implementation of a generic trait 'Iterator[A]' with abstract methods 'hasNext' and 'next()', illustrating how traits can define contract methods for subclasses to implement, especially with generics to handle varying data types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/traits.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Iterator[A] {\n  def hasNext: Boolean\n  def next(): A\n}\n```\n\n----------------------------------------\n\nTITLE: Using 'flatMap' and 'withFilter' for Currency Buying with Multiple Futures in Scala 2\nDESCRIPTION: This snippet illustrates fetching quotes for USD and CHF using 'flatMap' and 'withFilter' within a for-comprehension, executing a purchase only if both quotes satisfy the profitability condition, exemplifying complex asynchronous logic composition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\nval usdQuote = Future { connection.getCurrentValue(USD) }\nval chfQuote = Future { connection.getCurrentValue(CHF) }\n\nval purchase = for {\n  usd <- usdQuote\n  chf <- chfQuote\n  if isProfitable(usd, chf)\n} yield connection.buy(amount, chf)\n\npurchase foreach { amount =>\n  println(\"Purchased \" + amount + \" CHF\")\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Type Preservation with RNA2 (`take`, `filter`) in Scala REPL\nDESCRIPTION: Demonstrates creating an `RNA2` instance and using collection methods (`take`, `filter`) in the Scala REPL. These methods correctly return new `RNA2` instances, showcasing the effect of implementing `newBuilder` correctly within the `IndexedSeqLike` hierarchy.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-collections.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val rna2 = RNA2(A, U, G, G, C)\nrna2: RNA2 = RNA2(A, U, G, G, C)\n\nscala> rna2 take 3\nres5: RNA2 = RNA2(A, U, G)\n\nscala> rna2 filter (U !=)\nres6: RNA2 = RNA2(A, G, G, C)\n```\n\n----------------------------------------\n\nTITLE: 定义和使用函数变量（函数字面量）\nDESCRIPTION: 定义一个函数类型变量 `f`，作为匿名函数 `(a, b) => a + b`，演示其类型签名一致性和创建方式。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-hofs.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nval f: (Int, Int) => Int = (a, b) => a + b\n```\n\n----------------------------------------\n\nTITLE: Duplicating an iterator for independent traversal\nDESCRIPTION: Illustrates duplicate method to create two independent iterators from a single source, allowing separate traversals without interference. Useful for cases where multiple passes over the same data are needed without affecting the original iterator.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/iterators.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval (words, ns) = Iterator(\"a\", \"number\", \"of\", \"words\").duplicate\nval shorts = words.filter(_.length < 3).toList\nval count = ns.map(_.length).sum\n```\n\n----------------------------------------\n\nTITLE: Defining Timer with Anonymous Function Callback in Scala\nDESCRIPTION: An improved version of the timer example where instead of defining a named callback function, an anonymous function (lambda) is passed directly to oncePerSecond. The anonymous function prints a message every second. This snippet highlights Scala's support for unnamed functions using the syntax () => expression and shows function literals in place, improving code conciseness and clarity. Inputs are an anonymous function instance passed inline; outputs are timed console prints.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tutorials/scala-for-java-programmers.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nobject TimerAnonymous {\n  def oncePerSecond(callback: () => Unit): Unit = {\n    while (true) { callback(); Thread sleep 1000 }\n  }\n  def main(args: Array[String]): Unit = {\n    oncePerSecond(() =>\n      println(\"time flies like an arrow...\"))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Traits for Polymorphism in Scala\nDESCRIPTION: Demonstration of trait subtyping for polymorphism. Defines a Pet trait with subclasses Cat and Dog, showing how collections can store different implementations of the same trait.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/traits.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable.ArrayBuffer\n\ntrait Pet {\n  val name: String\n}\n\nclass Cat(val name: String) extends Pet\nclass Dog(val name: String) extends Pet\n\nval dog = new Dog(\"Harry\")\nval cat = new Cat(\"Sally\")\n\nval animals = ArrayBuffer.empty[Pet]\nanimals.append(dog)\nanimals.append(cat)\nanimals.foreach(pet => println(pet.name))  // Prints Harry Sally\n```\n\n----------------------------------------\n\nTITLE: Using Map with Concise Anonymous Function in Scala\nDESCRIPTION: Demonstrates using the map method with a concise anonymous function to double each element in a list. The underscore syntax is used as a shorthand for the parameter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-anonymous-functions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval doubledInts = ints.map(_ * 2)   // List(2, 4, 6)\n```\n\n----------------------------------------\n\nTITLE: Utilisation de fonctions anonymes inline avec map en Scala\nDESCRIPTION: Démontre l'utilisation d'une fonction anonyme directement passée en argument de la méthode map d'une collection Seq[Int]. Le compilateur infère automatiquement le type du paramètre x. Cette forme favorise un code plus concis et idiomatique. Entrée: liste d'entiers; sortie: liste doublée. Requiert Scala standard library.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tour/higher-order-functions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval salaries = Seq(20000, 70000, 40000)\nval newSalaries = salaries.map(x => x * 2) // List(40000, 140000, 80000)\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Behavior Traits in Scala\nDESCRIPTION: Creates three traits: Speaker with an abstract method, and TailWagger and Runner with concrete method implementations that can be mixed into classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/traits-abstract-mixins.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ntrait Speaker {\n    def speak(): String   //abstract\n}\n\ntrait TailWagger {\n    def startTail(): Unit = println(\"tail is wagging\")\n    def stopTail(): Unit = println(\"tail is stopped\")\n}\n\ntrait Runner {\n    def startRunning(): Unit = println(\"I'm running\")\n    def stopRunning(): Unit = println(\"Stopped running\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Utility Methods Object in Scala\nDESCRIPTION: Demonstrates how to create a singleton object containing utility methods for string manipulation. The object includes methods for checking if a string is null or empty and trimming whitespace from the left or right side of a string.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-objects.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject StringUtils:\n  def isNullOrEmpty(s: String): Boolean = s == null || s.trim.isEmpty\n  def leftTrim(s: String): String = s.replaceAll(\"^\\\\s+\", \"\")\n  def rightTrim(s: String): String = s.replaceAll(\"\\\\s+$\", \"\")\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Enumerations for Pizza Attributes\nDESCRIPTION: This code defines enumeration types for pizza components such as crust size, crust type, and toppings, utilizing Scala 3's 'enum' syntax. These enums enable type-safe, fixed sets of options for pizza configuration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nenum CrustSize:\n  case Small, Medium, Large\n\nenum CrustType:\n  case Thin, Thick, Regular\n\nenum Topping:\n  case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions\n```\n\n----------------------------------------\n\nTITLE: Using implicit 'given' Config instance in Scala 3 functions\nDESCRIPTION: Demonstrates calling a function that requires a 'using' Config clause without explicitly passing the configuration. The compiler infers and injects the 'given' instance automatically, streamlining dependency management and reducing boilerplate.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/ca-context-parameters.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nrenderWebsite(\"/home\")\n```\n\n----------------------------------------\n\nTITLE: Using Traits as Mixins in Scala\nDESCRIPTION: Scala allows mixing traits into a class definition or directly into an instance when it is created. This enables creating objects that compose behavior from multiple traits dynamically.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_29\n\nLANGUAGE: Scala\nCODE:\n```\nclass DavidBanner\n\ntrait Angry:\n  def beAngry() =\n    println(\"You won’t like me ...\")\n\ntrait Big:\n  println(\"I’m big\")\n\ntrait Green:\n  println(\"I’m green\")\n\n// mix in the traits as DavidBanner\n// is created\nval hulk = new DavidBanner with Big with Angry with Green\n```\n\n----------------------------------------\n\nTITLE: Processing Future Success with For-Comprehension - Scala 3\nDESCRIPTION: Demonstrates using a Scala 3 for-comprehension to print posts from a Future if the operation succeeds. Requires scala.concurrent.Future. session.getRecentPosts() provides List[String]. Only successful futures are processed; failures are ignored. The main output is a print of each post. No explicit error handling.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nval f: Future[List[String]] = Future {\n  session.getRecentPosts()\n}\n\nfor\n  posts <- f\n  post <- posts\ndo println(post)\n```\n\n----------------------------------------\n\nTITLE: Example of Instantiating Scala Address Class with Null for Optional Field (Scala 2 and 3)\nDESCRIPTION: These snippets show creating an instance of the Address class with street2 set to null, representing the absence of a value. This illustrates the problematic use of null as a substitute for optional data, which can lead to runtime errors and requires additional null checks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-functional-error-handling.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nval santa = new Address(\n  \"1 Main Street\",\n  null,               // <-- D’oh! A null value!\n  \"North Pole\",\n  \"Alaska\",\n  \"99705\"\n)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval santa = Address(\n  \"1 Main Street\",\n  null,               // <-- D’oh! A null value!\n  \"North Pole\",\n  \"Alaska\",\n  \"99705\"\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Data Type with a Case Class in Scala\nDESCRIPTION: Shows the definition of a simple Scala `case class` named `PetOwner` with `name` (String) and `pets` (List[String]) fields. This class serves as the target type for custom JSON deserialization.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-deserialize.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncase class PetOwner(name: String, pets: List[String])\n```\n\n----------------------------------------\n\nTITLE: Доработанный вариант makeInt с использованием Option в Scala 2 и Scala 3\nDESCRIPTION: Реализация функции makeInt, возвращающей тип Option[Int], которая либо содержит преобразованное целое число внутри Some, либо возвращает None при ошибках. Такой подход позволяет избегать исключений и четко сигнализировать о результате.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fp-functional-error-handling.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef makeInt(s: String): Option[Int] =\n  try {\n    Some(Integer.parseInt(s.trim))\n  } catch {\n    case e: Exception => None\n  }\n```\n\n----------------------------------------\n\nTITLE: Overriding Methods in Scala Inheritance\nDESCRIPTION: Shows the mandatory use of the `override` keyword in Scala when a subclass `C` provides a specific implementation for a method `f` that is already defined in its superclass `D` or a mixed-in trait.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/cheatsheets/index.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nclass C extends D { override def f = /* new implementation */ }\n```\n\n----------------------------------------\n\nTITLE: Best Practice: Using Scala Factory Methods Instead of Abstract Types\nDESCRIPTION: Highlights a common error in Scala of attempting to instantiate an abstract type like 'List' directly using 'new'. The recommended practice is to use the companion object's factory method 'List(1,2,3)' to create instances, adhering to Scala collections API conventions. This avoids runtime errors and leverages immutability and abstraction.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/cheatsheets/index.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nnew List[Int]\nList(1,2,3)\n```\n\n----------------------------------------\n\nTITLE: Listing Directory Contents with os.list in Scala\nDESCRIPTION: This snippet demonstrates how to retrieve all entries within a specific directory (/etc) by using os.list, which returns a sequence of os.Path objects representing each contained item.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/os-read-directory.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval entries: Seq[os.Path] = os.list(os.root / \"etc\")\n```\n\n----------------------------------------\n\nTITLE: Автоматический вывод типов в Scala\nDESCRIPTION: Пример того, как Scala автоматически выводит типы переменных. Показывает объявление переменных без явного указания их типов, позволяя компилятору определить типы самостоятельно.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-inferred.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval a = 1\nval b = List(1, 2, 3)\nval m = Map(1 -> \"one\", 2 -> \"two\")\n```\n\n----------------------------------------\n\nTITLE: Inferring Return Type of a Simple Scala Method\nDESCRIPTION: Shows Scala's capability to infer that a method 'squareOf' returning 'x * x' has return type Int, avoiding explicit type declaration. Applicable to non-recursive methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/type-inference.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef squareOf(x: Int) = x * x\n```\n\n----------------------------------------\n\nTITLE: Populating Scala Lists\nDESCRIPTION: Various methods for creating and populating Scala Lists including range operations, fill methods, and tabulate functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\n// to, until\n(1 to 5).toList                   // List(1, 2, 3, 4, 5)\n(1 until 5).toList                // List(1, 2, 3, 4)\n\n(1 to 10 by 2).toList             // List(1, 3, 5, 7, 9)\n(1 until 10 by 2).toList          // List(1, 3, 5, 7, 9)\n(1 to 10).by(2).toList            // List(1, 3, 5, 7, 9)\n\n('d' to 'h').toList               // List(d, e, f, g, h)\n('d' until 'h').toList            // List(d, e, f, g)\n('a' to 'f').by(2).toList         // List(a, c, e)\n\n// range method\nList.range(1, 3)                  // List(1, 2)\nList.range(1, 6, 2)               // List(1, 3, 5)\n\nList.fill(3)(\"foo\")               // List(foo, foo, foo)\nList.tabulate(3)(n => n * n)      // List(0, 1, 4)\nList.tabulate(4)(n => n * n)      // List(0, 1, 4, 9)\n```\n\n----------------------------------------\n\nTITLE: Accessing Scala Case Class Fields\nDESCRIPTION: Illustrates accessing the 'name' field of a 'Person' case class instance. Case class constructor parameters are public 'val' fields by default, providing automatic accessor methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/case-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nscala> christina.name\nres0: String = Christina\n```\n\n----------------------------------------\n\nTITLE: Объявление стандартных числовых типов в Scala\nDESCRIPTION: Показывает, как явно объявлять переменные стандартных числовых типов: `Byte`, `Int`, `Long`, `Short`, `Double` и `Float`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-vars-data-types.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval b: Byte = 1\nval i: Int = 1\nval l: Long = 1\nval s: Short = 1\nval d: Double = 2.0\nval f: Float = 3.0\n```\n\n----------------------------------------\n\nTITLE: Overriding toString Method in Scala Complex Class\nDESCRIPTION: Extends the 'Complex' class by overriding the 'toString' method inherited from 'java.lang.Object' to provide a customized string representation of complex numbers. The override uses the explicit 'override' keyword as required by Scala to avoid accidental overriding. The method concatenates the real and imaginary parts with a sign and the 'i' suffix to format the complex number representation. This snippet demonstrates inheritance, method overriding, and string concatenation in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_it/tutorials/scala-for-java-programmers.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass Complex(real: Double, imaginary: Double) {\n  def re = real\n  def im = imaginary\n  override def toString() =\n    \"\" + re + (if (im < 0) \"\" else \"+\") + im + \"i\"\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Tuples in 'for' Loops for Map Iteration (Scala)\nDESCRIPTION: Explains the generator syntax used for iterating over Maps, where each key-value pair is treated as a tuple `(key, value)` and destructured into variables (`abbrev`, `fullName`) using pattern matching. Syntax is common to Scala 2 and 3 within the generator expression. Assumes `states` is a Map.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_16\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\n(abbrev, fullName) <- states\n```\n\n----------------------------------------\n\nTITLE: Overriding methods in Scala subclass\nDESCRIPTION: Illustrates the necessity of declaring method overrides explicitly using `override` keyword in subclasses to redefine or extend behavior of superclass methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\nclass C extends D { override def f = ... }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating String Operations in Scala\nDESCRIPTION: This snippet shows various sequence operations that can be performed on strings in Scala, including reverse, map, drop, and slice. It also demonstrates converting a String to a Seq[Char].\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/strings.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval str = \"hello\"\nstr: java.lang.String = hello\nstr.reverse\nres6: String = olleh\nstr.map(_.toUpper)\nres7: String = HELLO\nstr drop 3\nres8: String = lo\nstr.slice(1, 4)\nres9: String = ell\nval s: Seq[Char] = str\ns: Seq[Char] = hello\n```\n\n----------------------------------------\n\nTITLE: Defining Algebraic Structures with Implicit Monoids in Scala\nDESCRIPTION: Defines abstract classes SemiGroup and Monoid to represent algebraic structures with associative add operations and a neutral unit element. Implements implicit objects StringMonoid and IntMonoid to provide specific monoid instances for String concatenation and integer addition. Demonstrates Scala's implicit keyword usage to enable automatic parameter resolution. The sum method recursively sums list elements using the implicit Monoid instance found in scope.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/implicit-parameters.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n/** Ten przykład wykorzystuje strukturę z algebry abstrakcyjnej aby zilustrować działanie parametrów domniemanych. Półgrupa jest strukturą algebraiczną na zbiorze A z łączną operacją (czyli taką, która spełnia warunek: add(x, add(y, z)) == add(add(x, y), z)) nazwaną add, która łączy parę obiektów A by zwrócić inny obiekt A. */\nabstract class SemiGroup[A] {\n  def add(x: A, y: A): A\n}\n/** Monoid jest półgrupą z elementem neutralnym typu A, zwanym unit. Jest to element, który połączony z innym elementem (przez metodę add) zwróci ten sam element. */\nabstract class Monoid[A] extends SemiGroup[A] {\n  def unit: A\n}\nobject ImplicitTest extends App {\n  /** Aby zademonstrować jak działają parametry domniemane, najpierw zdefiniujemy monoidy dla łańcuchów znaków oraz liczb całkowitych. Słowo kluczowe implicit sprawia, że oznaczone nimi wartości mogą być użyte aby zrealizować parametry domniemane. */\n  implicit object StringMonoid extends Monoid[String] {\n    def add(x: String, y: String): String = x concat y\n    def unit: String = \"\"\n  }\n  implicit object IntMonoid extends Monoid[Int] {\n    def add(x: Int, y: Int): Int = x + y\n    def unit: Int = 0\n  }\n  /** Metoda sum pobiera List[A] i zwraca A, który jest wynikiem zastosowania monoidu do wszystkich kolejnych elementów listy. Oznaczając parametr m jako domniemany, sprawiamy że potrzebne jest tylko podanie parametru xs podczas wywołania, ponieważ mamy już List[A], zatem wiemy jakiego typu jest w rzeczywistości A, zatem wiemy też jakiego typu Monoid[A] potrzebujemy. Możemy więc wyszukać wartość val lub obiekt w aktualnym zasięgu, który ma odpowiadający typu i użyć go bez jawnego określania referencji do niego. */\n  def sum[A](xs: List[A])(implicit m: Monoid[A]): A =\n    if (xs.isEmpty) m.unit\n    else m.add(xs.head, sum(xs.tail))\n\n  /** Wywołamy tutaj dwa razy sum podając za każdym razem tylko listę. Ponieważ drugi parametr (m) jest domniemany, jego wartość jest wyszukiwana przez kompilator w aktualnym zasięgu na podstawie typu monoidu wymaganego w każdym przypadku, co oznacza że oba wyrażenia mogą być w pełni ewaluowane. */\n  println(sum(List(1, 2, 3)))          // używa IntMonoid\n  println(sum(List(\"a\", \"b\", \"c\")))    // używa StringMonoid\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Tuples in Collections with Scala\nDESCRIPTION: Illustrates the use of pattern matching on tuples within a List of planetary data. The code iterates over each tuple and matches the first element to \"Earth\", printing the corresponding distance. Other cases are ignored via a wildcard match. This snippet requires understanding of pattern matching and collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/tuples.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval planets =\n  List((\"Mercury\", 57.9), (\"Venus\", 108.2), (\"Earth\", 149.6),\n       (\"Mars\", 227.9), (\"Jupiter\", 778.3))\nplanets.foreach{\n  case (\"Earth\", distance) =>\n    println(s\"Our planet is $distance million kilometers from the sun\")\n  case _ =>\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Option for Non-Empty Check - Scala\nDESCRIPTION: This snippet demonstrates how to use pattern matching to determine if an Option is non-empty, equivalent to checking Option.isDefined. It does not require external dependencies. The Option is matched to Some or None, returning true if Some and false if None. Input is an Option value, and the output is a Boolean indicating if the Option is non-empty. No constraints beyond standard Scala Option usage.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\noption match {\n  case Some(_) => true\n  case None    => false\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Companion Object for a Class in Scala\nDESCRIPTION: Provides an example of a 'Circle' case class and its companion object. The companion object holds a private helper method 'calculateArea', which is accessible and used by the 'area' method within the 'Circle' class instances, demonstrating the ability of companions to access each other's private members.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/singleton-objects.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.math.{Pi, pow}\n\ncase class Circle(radius: Double) {\n  import Circle._\n  def area: Double = calculateArea(radius)\n}\n\nobject Circle {\n  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)\n}\n\nval circle1 = Circle(5.0)\n\ncircle1.area\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.math.{Pi, pow}\n\ncase class Circle(radius: Double):\n  import Circle.*\n  def area: Double = calculateArea(radius)\n\nobject Circle:\n  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)\n\n\nval circle1 = Circle(5.0)\n\ncircle1.area\n```\n\n----------------------------------------\n\nTITLE: Using sbt shell for faster rebuilds and execution\nDESCRIPTION: Commands to start sbt shell and run the project interactively, which accelerates subsequent builds and tests by maintaining a background server process.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/tools-sbt.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt\n\n[info] welcome to sbt\n[info] loading settings for project ...\n[info] loading project definition ...\n[info] sbt server started at\n       local:///${HOME}/.sbt/1.0/server/7d26bae822c36a31071c/sock\nsbt:hello-world> \n\n// Then, from the sbt prompt\n\nsbt:hello-world> run\n\n[info] running helloWorld \nHello, world\n[success] Total time: 0 s\n```\n\n----------------------------------------\n\nTITLE: Capturing the Default Value in a Scala match Expression\nDESCRIPTION: Explains how to capture the value matched by the default case in a `match` expression by assigning it to a variable (e.g., `what`) instead of using `_`. The captured value can then be used on the right-hand side of the case. Shows syntax for Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_23\n\nLANGUAGE: Scala 2\nCODE:\n```\ni match {\n  case 0 => println(\"1\")\n  case 1 => println(\"2\")\n  case what => println(s\"You gave me: $what\")\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ni match\n  case 0 => println(\"1\")\n  case 1 => println(\"2\")\n  case what => println(s\"You gave me: $what\" )\n```\n\n----------------------------------------\n\nTITLE: Test suite definition for 'CubeCalculator' using ScalaTest's AnyFunSuite\nDESCRIPTION: This code defines a test class that extends ScalaTest's AnyFunSuite to enable writing unit tests for the 'CubeCalculator' object. It includes a test case verifying that the 'cube' function returns 27 when input is 3. The class uses assertions to check expected outputs, facilitating automated testing of the 'cube' method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_it/getting-started/sbt-track/testing-scala-with-sbt-on-the-command-line.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport org.scalatest.funsuite.AnyFunSuite\n\nclass CubeCalculatorTest extends AnyFunSuite {\n    test(\"CubeCalculator.cube\") {\n        assert(CubeCalculator.cube(3) === 27)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ケースクラスのコピーメソッドの使用例\nDESCRIPTION: この例は`copy`メソッドを用いて既存のケースクラス`Message`のインスタンスから新たなインスタンスを作成しています。`copy`を使うことで、既存の属性を維持しつつ一部だけ変更した新しいオブジェクトを簡単に生成できます。パラメータを変更しながら複製可能です。依存関係は不要です。出力例は`travis@washington.us`と`claire@bourgogne.fr`になります。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/case-classes.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Message(sender: String, recipient: String, body: String)\nval message4 = Message(\"julien@bretagne.fr\", \"travis@washington.us\", \"Me zo o komz gant ma amezeg\")\nval message5 = message4.copy(sender = message4.recipient, recipient = \"claire@bourgogne.fr\")\nmessage5.sender  // travis@washington.us\nmessage5.recipient // claire@bourgogne.fr\nmessage5.body  // \"Me zo o komz gant ma amezeg\"\n```\n\n----------------------------------------\n\nTITLE: Using foreach with Scala Option to Handle Optional Values\nDESCRIPTION: This snippet shows how to use the foreach method on an Option returned by the makeInt function to process its content only if it is present (Some). It simplifies handling the presence or absence of a value by executing the println function when the Option contains a value. No explicit handling of None is needed within the foreach. The snippet depends on makeInt returning an Option[Int].\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-functional-error-handling.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nmakeInt(aString).foreach(println)\n```\n\n----------------------------------------\n\nTITLE: Using Scala collection classes after hiding Java classes in Scala 2 and 3\nDESCRIPTION: Demonstrates that despite hiding Java collection classes, Scala's own 'List', 'Set', and 'Map' are available and usable without conflicts.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/packaging-imports.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval a = List(1, 2, 3)\nval b = Set(1, 2, 3)\nval c = Map(1 -> 1, 2 -> 2)\n```\n\n----------------------------------------\n\nTITLE: Defining a One-Line Method in Scala\nDESCRIPTION: In Scala, a method with a single expression body can be defined without curly braces and an explicit `return` keyword. The result of the expression is implicitly returned. The return type can often be inferred but is shown here explicitly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\ndef add(a: Int, b: Int): Int = a + b\n```\n\n----------------------------------------\n\nTITLE: Coercing methods into functions in Scala\nDESCRIPTION: Demonstrates passing a private method `convertCtoF` as an argument to `map`, leveraging Scala's compiler coercion of methods into functions for reuse. Shows implementation in both Scala 2 and Scala 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/higher-order-functions.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ncase class WeeklyWeatherForecast(temperatures: Seq[Double]) {\n\n  private def convertCtoF(temp: Double) = temp * 1.8 + 32\n\n  def forecastInFahrenheit: Seq[Double] = temperatures.map(convertCtoF) // <-- passing the method convertCtoF\n}\n```\n\n----------------------------------------\n\nTITLE: Using Traits for Subtyping with Concrete Implementations in Scala\nDESCRIPTION: Illustrates trait-based subtyping through a 'Pet' trait defining an abstract field 'name', and two classes 'Cat' and 'Dog' implementing this trait. Instances of these subclasses are stored in a mutable ArrayBuffer typed as 'Pet', demonstrating polymorphism. The example prints the names of all pets, showing that trait subtypes can be used wherever the trait type is expected. Dependencies include 'scala.collection.mutable.ArrayBuffer'. Input consists of pet names, and output is printing those names.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/traits.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.mutable.ArrayBuffer\n\ntrait Pet {\n  val name: String\n}\n\nclass Cat(val name: String) extends Pet\nclass Dog(val name: String) extends Pet\n\nval dog = new Dog(\"Harry\")\nval cat = new Cat(\"Sally\")\n\nval animals = ArrayBuffer.empty[Pet]\nanimals.append(dog)\nanimals.append(cat)\nanimals.foreach(pet => println(pet.name))  // Prints Harry Sally\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Stack Class in Scala 3\nDESCRIPTION: Defines the same generic Stack class as in Scala 2 but using Scala 3's new syntax with significant indentation and no braces. The type parameter A generically defines the type of elements stored in a private List[A]. Methods push, peek, and pop have identical functionality and are implemented using Scala 3 syntax conventions. This example depends on Scala 3 features and standard List.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/generic-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass Stack[A]:\n  private var elements: List[A] = Nil\n  def push(x: A): Unit =\n    elements = x :: elements\n  def peek: A = elements.head\n  def pop(): A =\n    val currentTop = peek\n    elements = elements.tail\n    currentTop\n```\n\n----------------------------------------\n\nTITLE: Passer une méthode comme fonction d'ordre supérieur en Scala\nDESCRIPTION: Définit une classe WeeklyWeatherForecast avec une méthode privée convertCtoF qui convertit une température Celsius en Fahrenheit. Cette méthode est passée directement en argument à la fonction map, illustrant la conversion implicite des méthodes en fonctions par le compilateur Scala. Nécessite Scala standard library, notamment Seq et map. Entrée: Seq[Double]; sortie: Seq[Double] transformée.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tour/higher-order-functions.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ncase class WeeklyWeatherForecast(temperatures: Seq[Double]) {\n\n  private def convertCtoF(temp: Double) = temp * 1.8 + 32\n\n  def forecastInFahrenheit: Seq[Double] = temperatures.map(convertCtoF) // <-- passing the method convertCtoF\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Function Arguments with Indentation in Scala\nDESCRIPTION: This snippet demonstrates calling a function with an indented code block as an argument using Scala's fewerBraces syntax. The function 'times' is given a numeric argument, followed by a colon and an indented block of statements, which are treated as the function body. This requires fewerBraces support and is intended to improve code readability by eliminating braces; the statements execute as part of the provided function argument.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntimes(10):\n  println(\"ah\")\n  println(\"ha\")\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a FunFixture for Temporary Files in MUnit (Scala)\nDESCRIPTION: Demonstrates creating a `FunFixture[os.Path]` named `usingTempFile` within an `munit.FunSuite`. The fixture uses `os.temp` in its `setup` function to create a temporary file before each test and `os.remove` in its `teardown` function to delete it afterward. A test named 'overwrite on file' uses this fixture, receiving the temporary file path as an argument to write to and read from.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-resources.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass FileTests extends munit.FunSuite {\n  val usingTempFile: FunFixture[os.Path] = FunFixture(\n    setup = _ => os.temp(prefix = \"file-tests\"),\n    teardown = tempFile => os.remove(tempFile)\n  )\n  usingTempFile.test(\"overwrite on file\") { tempFile =>\n    os.write.over(tempFile, \"Hello, World!\")\n    val obtained = os.read(tempFile)\n    assertEquals(obtained, \"Hello, World!\")\n  }\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass FileTests extends munit.FunSuite:\n  val usingTempFile: FunFixture[os.Path] = FunFixture(\n    setup = _ => os.temp(prefix = \"file-tests\"),\n    teardown = tempFile => os.remove(tempFile)\n  )\n  usingTempFile.test(\"overwrite on file\") { tempFile =>\n    os.write.over(tempFile, \"Hello, World!\")\n    val obtained = os.read(tempFile)\n    assertEquals(obtained, \"Hello, World!\")\n  }\n```\n\n----------------------------------------\n\nTITLE: Embedding Expressions with the `s` Interpolator in Scala\nDESCRIPTION: Demonstrates embedding arbitrary Scala expressions within an `s`-interpolated string using `${expression}` syntax. Examples include arithmetic operations (`2 + 2`) and method calls (`x.abs`). Any valid Scala expression can be placed inside the curly braces.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nprintln(s\"2 + 2 = ${2 + 2}\")   // \"2 + 2 = 4\"\nval x = -1\nprintln(s\"x.abs = ${x.abs}\")   // \"x.abs = 1\"\n```\n\n----------------------------------------\n\nTITLE: Matching values in scope in Scala 2\nDESCRIPTION: Shows how match expressions can check against existing values in scope. Names starting with uppercase letters are treated as values to match against, not as variables to bind.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nval N = 42\ni match {\n  case 0 => println(\"1\")\n  case 1 => println(\"2\")\n  case N => println(\"42\")\n  case n => println(s\"You gave me: $n\" )\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing JSON Responses from HTTP GET with sttp in Scala\nDESCRIPTION: Sends an authenticated GET request to the GitHub API user endpoint (`https://api.github.com/user`) using `sttp.client4.quick`, retrieves the response body, and parses it using `ujson.read`. Requires `ujson`, `sttp.client4.quick`, and a `GITHUB_TOKEN` environment variable for bearer authentication. Prints the 'login' field extracted from the parsed JSON response.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/http-client-json.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport sttp.client4.quick._\n\nval response = quickRequest\n  .get(uri\"https://api.github.com/user\")\n  .auth.bearer(sys.env(\"GITHUB_TOKEN\"))\n  .send()\n\nval json = ujson.read(response.body)\n\nprintln(json(\"login\").str)\n// prints your login\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport sttp.client4.quick.*\n\nval response = quickRequest\n  .get(uri\"https://api.github.com/user\")\n  .auth.bearer(sys.env(\"GITHUB_TOKEN\"))\n  .send()\n\nval json = ujson.read(response.body)\n\nprintln(json(\"login\").str)\n// prints your login\n```\n\n----------------------------------------\n\nTITLE: Matching multiple cases with pattern matching in Scala\nDESCRIPTION: Illustrates Scala's match expression that supports combining multiple case values in one line separated by pipe operators (|). It classifies integers as 'odd', 'even', or 'too big', similar to Python's pattern matching example. Scala's match expressions are used as expressions returning values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_48\n\nLANGUAGE: scala\nCODE:\n```\nval numAsString = i match\n  case 1 | 3 | 5 | 7 | 9 => \"odd\"\n  case 2 | 4 | 6 | 8 | 10 => \"even\"\n  case _ => \"too big\"\n```\n\n----------------------------------------\n\nTITLE: Defining a higher-order function `executeAndPrint` in Scala\nDESCRIPTION: Defines a function `executeAndPrint` that takes another function `f` of type `(Int, Int) => Int` along with two integer parameters. It executes `f` with these parameters and prints the result, illustrating how to create flexible higher-order functions in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-hofs.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\ndef executeAndPrint(f: (Int, Int) => Int, i: Int, j: Int): Unit =\n  println(f(i, j))\n```\n\n----------------------------------------\n\nTITLE: トレイトの定義 - 抽象メソッドあり - Scala\nDESCRIPTION: traitキーワードでGreeterトレイトを宣言し、greet抽象メソッドを含む定義例です。メソッドの戻り値型はUnitで、実装クラスで必須の実装を強制する構造となります。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\ntrait Greeter {\n  def greet(name: String): Unit\n}\n```\n\n----------------------------------------\n\nTITLE: Method getClassAsString Using match with Multiple Type Cases in Scala 3\nDESCRIPTION: Implements method 'getClassAsString' in Scala 3 with parameter of type 'Matchable' for safer pattern matching across various types. Uses match expression without braces, case type testing, and wildcard matching to classify input values. Input is any 'Matchable' value; output is string describing the type. Requires Scala 3 compiler supporting 'Matchable'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\n// getClassAsString - метод, принимающий один параметр любого типа.\ndef getClassAsString(x: Matchable): String = x match\n  case s: String => s\"'$s' is a String\"\n  case i: Int => \"Int\"\n  case d: Double => \"Double\"\n  case l: List[?] => \"List\"\n  case _ => \"Unknown\"\n\n// примеры\ngetClassAsString(1)               // Int\ngetClassAsString(\"hello\")         // 'hello' is a String\ngetClassAsString(List(1, 2, 3))   // List\n```\n\n----------------------------------------\n\nTITLE: Scala REPL Demonstrating Type Inference for Variables and Collections in Scala 2 and 3\nDESCRIPTION: Shows interaction with the Scala REPL illustrating how types are automatically inferred and displayed. The snippet includes assignment of primitive numeric value, a List of integers, and a Map from integers to strings. The REPL output explicitly displays inferred types corresponding to value bindings. This snippet depends on using the Scala REPL environment (both Scala 2 and 3). Outputs confirmation of types inferred, which helps in learning and debugging type inference.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-inferred.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> val a = 1\nval a: Int = 1\n\nscala> val b = List(1, 2, 3)\nval b: List[Int] = List(1, 2, 3)\n\nscala> val m = Map(1 -> \"one\", 2 -> \"two\")\nval m: Map[Int, String] = Map(1 -> one, 2 -> two)\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with By-name Parameters in Scala\nDESCRIPTION: This code snippet demonstrates how to define a function with a by-name parameter in Scala. The function `calculate` takes an argument `input` of type `=> Int`, meaning its argument will be repeatedly evaluated each time it is accessed inside the function. No external dependencies are required. The parameter is not evaluated upon function call but each time it is used, with the return value computed as `input * 37`. The input should be any integer expression and the function returns its value multiplied by 37.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/by-name-parameters.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef calculate(input: => Int) = input * 37\n```\n\n----------------------------------------\n\nTITLE: Базовая интерполяция строк с использованием `s` в Scala\nDESCRIPTION: Показывает, как использовать интерполятор строк `s` для вставки значений переменных непосредственно в строку с помощью префикса `$`. Выводит \"Name: John C Doe\".\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-vars-data-types.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nprintln(s\"Name: $firstName $mi $lastName\")   // \"Name: John C Doe\"\n```\n\n----------------------------------------\n\nTITLE: Implementing a Trait in a Class in Scala 3\nDESCRIPTION: This Scala 3 snippet defines the Document class that extends Showable and implements the show method. The class takes text as a constructor parameter, and show simply returns it. This approach fits the idiomatic use of traits and classes in Scala 3 and is dependency-free.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass Document(text: String) extends Showable:\n  def show = text\n```\n\n----------------------------------------\n\nTITLE: Recursive Method Requires Explicit Return Type in Scala\nDESCRIPTION: Illustrates that Scala's type inference cannot deduce the return type of a recursive method. The recursive factorial method 'fac' without an explicit return type causes compilation to fail. This is because the compiler needs an explicit type annotation to prevent infinite recursion during type checking.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/type-inference.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef fac(n: Int) = if (n == 0) 1 else n * fac(n - 1)\n```\n\n----------------------------------------\n\nTITLE: Comparing Case Class Instances by Value in Scala 3\nDESCRIPTION: Similar to the Scala 2 snippet, but uses Scala 3's indentation-based control flow. Shows value equality and tailored print messages based on equality results for data classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\nif point == anotherPoint then\n  println(s\"$point and $anotherPoint are the same.\")\nelse\n  println(s\"$point and $anotherPoint are different.\")\n// ==> Point(1,2) and Point(1,2) are the same.\n\nif point == yetAnotherPoint then\n  println(s\"$point and $yetAnotherPoint are the same.\")\nelse\n  println(s\"$point and $yetAnotherPoint are different.\")\n// ==> Point(1,2) and Point(2,2) are different.\n```\n\n----------------------------------------\n\nTITLE: Handling multiple cases with 'match' in Scala\nDESCRIPTION: Shows how to handle multiple values or strings in a single 'case' statement using the pipe '|' operator, such as evaluating Boolean-like expressions or multiple string commands, enhancing pattern matching flexibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/match-expressions.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef isTrue(a: Any) = a match {\n    case 0 | \"\" => false\n    case _ => true\n}\n\n// Examples:\n// isTrue(0)\n// isTrue(\"\")\n// isTrue(1.1F)\n// isTrue(new java.io.File(\"/etc/passwd\"))\n```\n\n----------------------------------------\n\nTITLE: Declaring Packages - Scala\nDESCRIPTION: Shows the declaration of a package at the file root or as a nested block. Requires placing at the file beginning or enclosing source within a package block. Helps organize code into logical namespaces.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\npackage pkg\n```\n\nLANGUAGE: Scala\nCODE:\n```\npackage pkg { ... }\n```\n\n----------------------------------------\n\nTITLE: Defining Class Body with Fields and Methods in Scala 3\nDESCRIPTION: This snippet shows how to add fields and methods to a class body in Scala 3 using the colon syntax. The code within the class body is executed during initialization, demonstrating how fields and methods are defined and accessed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nclass Person(var firstName: String, var lastName: String):\n\n  println(\"initialization begins\")\n  val fullName = firstName + \" \" + lastName\n\n  // a class method\n  def printFullName: Unit =\n    // access the `fullName` field, which is created above\n    println(fullName)\n\n  printFullName\n  println(\"initialization ends\")\n```\n\n----------------------------------------\n\nTITLE: Serving Resources with @cask.staticResources Annotation in Scala 3\nDESCRIPTION: Simplified Scala 3 implementation that uses @cask.staticResources annotation to serve files directly from the resources directory. The \".\" path indicates the root of the resources directory.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/web-server-static.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nobject Example extends cask.MainRoutes:\n  @cask.staticResources(\"/static\")\n  def staticEndpoint(): String = \".\"\n\n  initialize()\n```\n\n----------------------------------------\n\nTITLE: Using andThen for sequencing side-effects in Scala Futures\nDESCRIPTION: Demonstrates chaining of `andThen` combinators to perform side-effects such as accumulating posts and rendering, while preserving the original future's result. Illustrates the functional nature of Future combinators and their sequencing. Requires a `session` object and functions like `clearAll()` and `render()`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_25\n\nLANGUAGE: Scala\nCODE:\n```\nval allPosts = mutable.Set[String]()\n\nFuture {\n  session.getRecentPosts()\n}.andThen {\n  case Success(posts) => allPosts ++= posts\n}.andThen {\n  case _ =>\n    clearAll()\n    for (post <- allPosts) render(post)\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Covering Sets for Scala Types\nDESCRIPTION: Illustrates the covering sets corresponding to the previously defined Scala type aliases `A`, `B`, and `C`. The covering set includes all unique type constructors and base types mentioned within a type definition. This example highlights that `A` and `B` share the same covering set (`List`, `Tuple2`, `Int`), distinct from that of `C` (`List`, `Tuple2`, `Int`, `String`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nA: List, Tuple2, Int\nB: List, Tuple2, Int\nC: List, Tuple2, Int, String\n```\n\n----------------------------------------\n\nTITLE: Enabling comparison with CanEqual derives\nDESCRIPTION: Shows how to enable comparison between instances of the same class using the 'derives CanEqual' syntax in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-multiversal-equality.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n// Option 1\ncase class Dog(name: String) derives CanEqual\n```\n\n----------------------------------------\n\nTITLE: Defining algebraic structures SemiGroup and Monoid in Scala\nDESCRIPTION: These snippets declare abstract classes `SemiGroup` and `Monoid` representing algebraic structures, where `Monoid` extends `SemiGroup` by adding a `unit` element. These classes are used as prerequisites for implementing implicit monoid instances for specific types, enabling generic summation functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/implicit-parameters.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n/** Este exemplo usa uma estrutura da álgebra abstrata para mostrar como funcionam os parâmetros implícitos. Um semigrupo é uma estrutura algébrica em um conjunto A com uma operação (associativa), chamada add, que combina um par de A's e retorna um outro A. */\nabstract class SemiGroup[A] {\n  def add(x: A, y: A): A\n}\n/** Um monóide é um semigrupo com um elemento distinto de A, chamado unit, que quando combinado com qualquer outro elemento de A retorna esse outro elemento novamente. */\nabstract class Monoid[A] extends SemiGroup[A] {\n  def unit: A\n}\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Manual Eta-Expansion Using Wildcard and Lambda\nDESCRIPTION: Shows how manual eta-expansion in Scala 3 is simplified to using wildcard syntax (`isLessThan(_, _)`) and anonymous functions, similar to Scala 2, allowing explicit conversion of methods into function values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-eta-expansion.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval methodsA = List(isLessThan(_, _))           // wildcard application\nval methodsB = List((x, y) => isLessThan(x, y)) // anonymous function\n```\n\n----------------------------------------\n\nTITLE: Creating Singleton Objects with 'object'\nDESCRIPTION: Illustrates singleton object definition with methods and mutable state. Shows how to invoke object methods directly and demonstrates encapsulation of state.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/basics.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nobject IdFactory {\n  private var counter = 0\n  def create(): Int = {\n    counter += 1\n    counter\n  }\n}\nval newId: Int = IdFactory.create()\nprintln(newId) // 1\nval newerId: Int = IdFactory.create()\nprintln(newerId) // 2\n```\n\n----------------------------------------\n\nTITLE: Adding Cask Dependency in sbt Build Configuration in Scala\nDESCRIPTION: This snippet shows how to configure sbt to include the Cask web framework as a dependency in a Scala project. It creates a lazy project with custom 'scalaVersion', adds the Cask library to 'libraryDependencies', and ensures the process is forked for isolation. The build.sbt file must be correctly structured; adjust the version numbers as required for the desired Cask and Scala versions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-cask.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nlazy val example = project.in(file(\"example\"))\n  .settings(\n    scalaVersion := \"3.4.2\",\n    libraryDependencies += \"com.lihaoyi\" %% \"cask\" % \"0.10.2\",\n    fork := true\n  )\n```\n\n----------------------------------------\n\nTITLE: Pattern matching with sealed classes in Scala\nDESCRIPTION: Creates a sealed abstract class 'Furniture' with case classes 'Couch' and 'Chair'. The 'findPlaceToSit' function pattern matches on specific subclasses, enabling exhaustive and type-safe handling for furniture objects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/pattern-matching.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nsealed abstract class Furniture\ncase class Couch() extends Furniture\ncase class Chair() extends Furniture\n\ndef findPlaceToSit(piece: Furniture): String = piece match {\n  case a: Couch => \"Lie on the couch\"\n  case b: Chair => \"Sit on the chair\"\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern matching by type in Scala 2\nDESCRIPTION: Defines a sealed trait 'Device' with case classes 'Phone' and 'Computer', each with specific methods. Implements 'goIdle' function that matches on the device's runtime type, invoking corresponding methods. This pattern ensures type-safe behavior based on the specific subclass of 'Device'. Dependencies include Scala 2 syntax and case classes. The function takes a 'Device' and returns a string indicating the action taken depending on the device type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/pattern-matching.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nsealed trait Device\ncase class Phone(model: String) extends Device {\n  def screenOff = \"Turning screen off\"\n}\ncase class Computer(model: String) extends Device {\n  def screenSaverOn = \"Turning screen saver on...\"\n}\n\ndef goIdle(device: Device): String = device match {\n  case p: Phone => p.screenOff\n  case c: Computer => c.screenSaverOn\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Complex Number Class with Parameters in Scala\nDESCRIPTION: Defines a Scala class named 'Complex' that takes two constructor parameters, 'real' and 'imaginary', both of type Double. The class has two methods 're' and 'im' that return the real and imaginary parts respectively. The return types are inferred by the compiler. This snippet demonstrates basic class definition and parameter handling in Scala and the similarity to Java. It requires Scala compiler support for type inference and is used by instantiating objects with 'new Complex(1.5, 2.3)'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_it/tutorials/scala-for-java-programmers.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass Complex(real: Double, imaginary: Double) {\n  def re() = real\n  def im() = imaginary\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring sbt for Scala 2.13 project depending on Scala 3 module\nDESCRIPTION: This snippet shows how to set up an sbt build to include a Scala 3 dependency in a Scala 2.13 project by enabling the `-Ytasty-reader` compiler option and resolving the dependency with `CrossVersion.for2_13Use3`, allowing cross-version compatibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/compatibility-classpath.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// build.sbt (sbt 1.5 or higher)\nlazy val foo = project.in.file(\"foo\")\n  .settings(\n    scalaVersion := \"2.13.11\",\n    scalacOptions += \"-Ytasty-reader\"\n  )\n  .dependsOn(bar)\n\nlazy val bar = project.in(file(\"bar\"))\n  .settings(scalaVersion := \"3.3.1\")\n```\n\nLANGUAGE: scala\nCODE:\n```\n// build.sbt\nlazy val foo = project.in.file(\"foo\")\n  .settings(\n    scalaVersion := \"2.13.11\",\n    scalacOptions += \"-Ytasty-reader\",\n    libraryDependencies += (\"org.bar\" %% \"bar\" % \"1.0.0\").cross(CrossVersion.for3Use2_13)\n  )\n```\n\n----------------------------------------\n\nTITLE: Creating PrefixMap Collection Instances with Companion Object in Scala\nDESCRIPTION: Demonstrates the use of the PrefixMap companion object's apply and empty factory methods to instantiate and add elements to a PrefixMap[Int]. The snippet shows how to create a map literal and dynamically add key-value pairs. It requires Scala's standard library and proper import of the PrefixMap class. Inputs are key-value pairs of type (String, Int), and outputs are PrefixMap instances containing these pairs. This snippet highlights how implicit conversions to Factory enable the use of to(PrefixMap) with collections such as List.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_27\n\nLANGUAGE: scala\nCODE:\n```\nscala> PrefixMap(\"hello\" -> 5, \"hi\" -> 2)\nval res0: PrefixMap[Int] = PrefixMap(hello -> 5, hi -> 2)\n\nscala> res0 += \"foo\" -> 3\nval res1: res0.type = PrefixMap(hello -> 5, hi -> 2, foo -> 3)\n```\n\n----------------------------------------\n\nTITLE: Companion Object with Factory Methods in Scala\nDESCRIPTION: Using apply methods in a companion object to create factory methods for instantiating a Person class with different parameter combinations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nclass Person {\n  var name = \"\"\n  var age = 0\n  override def toString = s\"$name is $age years old\"\n}\n\nobject Person {\n  // фабричный метод с одним аргументом\n  def apply(name: String): Person = {\n    var p = new Person\n    p.name = name\n    p\n  }\n\n  // фабричный метод с двумя аргументами\n  def apply(name: String, age: Int): Person = {\n    var p = new Person\n    p.name = name\n    p.age = age\n    p\n  }\n}\n\nval joe = Person(\"Joe\")\nval fred = Person(\"Fred\", 29)\n\n//val joe: Person = Joe is 0 years old\n//val fred: Person = Fred is 29 years old\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Person:\n  var name = \"\"\n  var age = 0\n  override def toString = s\"$name is $age years old\"\n\nobject Person:\n\n  // фабричный метод с одним аргументом\n  def apply(name: String): Person =\n    var p = new Person\n    p.name = name\n    p\n\n  // фабричный метод с двумя аргументами\n  def apply(name: String, age: Int): Person =\n    var p = new Person\n    p.name = name\n    p.age = age\n    p\n\nend Person\n\nval joe = Person(\"Joe\")\nval fred = Person(\"Fred\", 29)\n\n//val joe: Person = Joe is 0 years old\n//val fred: Person = Fred is 29 years old\n```\n\n----------------------------------------\n\nTITLE: Using traits for multiple behaviors and class composition in Scala\nDESCRIPTION: Demonstrates defining Scala traits Adder and Multiplier with basic math methods and composing them in a class to combine functionality. Dependencies: Scala 3 trait and class syntax. The class SimpleMath inherits both behaviors, allowing usage of add and multiply. Outputs are integer sums and products. No Python equivalent provided.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Adder:\n  def add(a: Int, b: Int) = a + b\n\ntrait Multiplier:\n  def multiply(a: Int, b: Int) = a * b\n\n// create a class from the traits\nclass SimpleMath extends Adder, Multiplier\nval sm = new SimpleMath\nsm.add(1,1)        // 2\nsm.multiply(2,2)   // 4\n```\n\n----------------------------------------\n\nTITLE: Calling a Single-Parameter Scala Method in the REPL\nDESCRIPTION: Demonstrates invoking the `double` method defined previously from the Scala REPL (Read-Eval-Print Loop). It shows how to pass different integer arguments to the method and illustrates the REPL output, including the calculated result and its inferred type (`Int`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/methods-first-look.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nscala> double(2)\nres0: Int = 4\n\nscala> double(10)\nres1: Int = 20\n```\n\n----------------------------------------\n\nTITLE: Defining a Pattern Matching Method with Various Patterns in Scala 3\nDESCRIPTION: Defines a `pattern` method like its Scala 2 counterpart but using Scala 3's simplified match expression syntax without braces and braces replaced with indentation, providing the same pattern coverage and behavior. It matches constants, sequences, tuples, constructors, and types on a `Matchable` input to return descriptive strings. It requires custom classes Person and Dog and the Matchable trait. The method returns a string description or \"Unknown\" if unmatched.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_34\n\nLANGUAGE: scala\nCODE:\n```\ndef pattern(x: Matchable): String = x match\n\n  // constant patterns\n  case 0 => \"zero\"\n  case true => \"true\"\n  case \"hello\" => \"you said 'hello'\"\n  case Nil => \"an empty List\"\n\n  // sequence patterns\n  case List(0, _, _) => \"a 3-element list with 0 as the first element\"\n  case List(1, _*) => \"list, starts with 1, has any number of elements\"\n  case Vector(1, _*) => \"vector, starts w/ 1, has any number of elements\"\n\n  // tuple patterns\n  case (a, b) => s\"got $a and $b\"\n  case (a, b, c) => s\"got $a, $b, and $c\"\n\n  // constructor patterns\n  case Person(first, \"Alexander\") => s\"Alexander, first name = $first\"\n  case Dog(\"Zeus\") => \"found a dog named Zeus\"\n\n  // type test patterns\n  case s: String => s\"got a string: $s\"\n  case i: Int => s\"got an int: $i\"\n  case f: Float => s\"got a float: $f\"\n  case a: Array[Int] => s\"array of int: ${a.mkString(\",\") }\"\n  case as: Array[String] => s\"string array: ${as.mkString(\",\") }\"\n  case d: Dog => s\"dog: ${d.name}\"\n  case list: List[?] => s\"got a List: $list\"\n  case m: Map[?, ?] => m.toString\n\n  // the default wildcard pattern\n  case _ => \"Unknown\"\n```\n\n----------------------------------------\n\nTITLE: Extending and Overriding Trait Methods in Scala 2 Classes\nDESCRIPTION: Defines a Cat class that extends the same traits, overrides behavior methods to customize responses. Exhibits inheritance and method overriding in Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-modeling.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass Cat(name: String) extends Speaker with TailWagger with Runner {\n  def speak(): String = \"Meow\"\n  override def startRunning(): Unit = println(\"Yeah ... I don’t run\")\n  override def stopRunning(): Unit = println(\"No need to stop\")\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Privacy of Non-`val`/`var` Constructor Parameters in Scala\nDESCRIPTION: Demonstrates that primary constructor parameters declared without `val` or `var` (like `x` and `y` in the `Point` class) are private to the class. They cannot be accessed directly from outside the class (`point.x`), resulting in a compilation error.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/classes.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nclass Point(x: Int, y: Int)\nval point = new Point(1, 2)\npoint.x  // <-- does not compile\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Point(x: Int, y: Int)\nval point = Point(1, 2)\npoint.x  // <-- does not compile\n```\n\n----------------------------------------\n\nTITLE: Instantiating a Class in Scala 3\nDESCRIPTION: This snippet shows how to create a new instance of a class in Scala 3 without using the `new` keyword, leveraging universal apply methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval p = Person(\"Robert Allen Zimmerman\", \"Harmonica Player\")\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic while Loop in Scala\nDESCRIPTION: Illustrates the syntax for a `while` loop in Scala. The loop continues as long as the condition (`i < 3`) is true, performing side effects (printing the value of `i`) and updating a mutable variable (`i`) in each iteration. Shows syntax for Scala 2 and Scala 3 (using the optional `do` keyword).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_21\n\nLANGUAGE: Scala 2\nCODE:\n```\nvar i = 0\n\nwhile (i < 3) {\n  println(i)\n  i += 1\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nvar i = 0\n\nwhile i < 3 do\n  println(i)\n  i += 1\n```\n\n----------------------------------------\n\nTITLE: Adding MUnit via Toolkit using sbt\nDESCRIPTION: Configures an sbt project in `build.sbt` to include the `toolkit-test` artifact, which provides MUnit. The dependency is scoped to the `Test` configuration, meaning it's only available for source files under `src/test`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-munit.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nlazy val example = project.in(file(\".\"))\n  .settings(\n    scalaVersion := \"3.4.2\",\n    libraryDependencies += \"org.scala-lang\" %% \"toolkit-test\" % \"0.7.0\" % Test\n  )\n```\n\n----------------------------------------\n\nTITLE: Adding MUnit via Toolkit using Mill\nDESCRIPTION: Configures a Mill build (`build.sc`) by defining a `test` object that extends `Tests` and `TestModule.Munit`. It adds the `toolkit-test` dependency using the `ivy` string interpolator within the `ivyDeps` definition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-munit.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nobject example extends ScalaModule {\n  def scalaVersion = \"3.4.2\"\n  object test extends Tests with TestModule.Munit {\n    def ivyDeps =\n      Agg(\n        ivy\"org.scala-lang::toolkit-test:0.7.0\"\n      )\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Types in Scala Traits\nDESCRIPTION: Demonstrates how to define an abstract type T in a trait Buffer that is used to describe the element member. This shows the basic syntax for declaring abstract types in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/abstract-type-members.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Buffer {\n  type T\n  val element: T\n}\n```\n\n----------------------------------------\n\nTITLE: Scala 2 and 3 variable declarations with type inference\nDESCRIPTION: This snippet demonstrates how Scala allows variable declarations without explicit type annotations, leveraging type inference to make code feel flexible and dynamic. It uses `val` keyword with different data types to declare variables.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-introduction.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval a = 1\nval b = 2.0\nval c = \"Hi!\"\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Case Class in Scala\nDESCRIPTION: This snippet demonstrates the basic syntax for defining a case class in Scala, `Book`, with a single parameter `isbn`. It also shows how to instantiate the case class using the default `apply` method generated by the compiler. Case classes are designed for modeling immutable data.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/case-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Book(isbn: String)\n\nval frankenstein = Book(\"978-0486282114\")\n```\n\n----------------------------------------\n\nTITLE: Defining Given and Implicit Instances for Context Parameters in Scala 2 and Scala 3\nDESCRIPTION: This pair of snippets shows how to define canonical implicit or given instances of the `Config` type in Scala 2 and Scala 3, respectively. These instances allow the compiler to automatically supply the configuration argument to context parameters without explicit passing. In Scala 2, the value is declared as `implicit val`; in Scala 3, the `given` keyword is used to associate the value with the type. The instance should be in scope at the point of the call. Inputs include no explicit parameters for the context argument, relying on implicit/given resolution; outputs use the context value implicitly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/ca-context-parameters.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimplicit val config: Config = Config(8080, \"docs.scala-lang.org\")\n//           ^^^^^^\n// это значение, которое выведет компилятор Scala\n// в качестве аргумента контекстного параметра типа Config\n```\n\nLANGUAGE: scala\nCODE:\n```\nval config = Config(8080, \"docs.scala-lang.org\")\n\n// это тип, который мы хотим предоставить для канонического значения\n//    vvvvvv\ngiven Config = config\n//             ^^^^^^\n// это значение, которое выведет компилятор Scala\n// в качестве аргумента контекстного параметра типа Config\n```\n\n----------------------------------------\n\nTITLE: Using foldLeft with Multiple Parameter Lists in Scala\nDESCRIPTION: Provides a practical example of applying the `foldLeft` method to a `List`. It initializes the accumulation with `0` in the first parameter list and provides a lambda `(m, n) => m + n` for the second list to sum the elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/multiple-parameter-lists.md#_snippet_1\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\nval numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nval res = numbers.foldLeft(0)((m, n) => m + n)\nprintln(res) // 55\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Configuration without Context Parameters in Scala\nDESCRIPTION: Defines a configuration class and methods that pass the configuration explicitly as regular parameters. This demonstrates the standard approach before applying contextual abstraction.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-context-parameters.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Config(port: Int, baseUrl: String)\n\ndef renderWebsite(path: String, config: Config): String =\n  \"<html>\" + renderWidget(List(\"cart\"), config)  + \"</html>\"\n\ndef renderWidget(items: List[String], config: Config): String = ???\n\nval config = Config(8080, \"docs.scala-lang.org\")\nrenderWebsite(\"/home\", config)\n```\n\n----------------------------------------\n\nTITLE: Overriding Methods in Scala Classes\nDESCRIPTION: Shows the requirement to explicitly mark method overrides with the 'override' keyword when implementing or extending existing methods from parent classes or traits. This prevents accidental overriding and enforces clarity in Scala’s type system and inheritance mechanism.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/cheatsheets/index.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nclass C extends D { override def f = ...}\n```\n\n----------------------------------------\n\nTITLE: Using Named Tuples with Regular Tuples and Implicit Conversion toTuple in Scala 3\nDESCRIPTION: Shows how named tuples interoperate with regular (unnamed) tuples. Regular tuples can be assigned to named tuple types directly. Named tuples can be converted to regular tuples using the `.toTuple` method, which is inserted implicitly by the compiler when expected. This conversion does not work inside generic type constructors, requiring explicit mapping. This snippet illustrates both direct assignment and explicit conversion usage patterns.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-tuples.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval Laura: Person = (\"Laura\", 25)\n\ndef register(person: Person) = ...\nregister(person = (\"Silvain\", 16))\nregister((\"Silvain\", 16))\n\nval x: (String, Int) = Bob.toTuple // ok\nval x2: (String, Int) = Bob  // works, expanded to Bob.toTuple\n\nval pairs: List[(String, Int)] = persons.map(_.toTuple) // explicit conversion in generics\n```\n\n----------------------------------------\n\nTITLE: Defining Methods without Arguments in Scala 3\nDESCRIPTION: This snippet demonstrates the syntax for parameterless methods in Scala 3, aligning with idiomatic Scala style by removing parentheses from method definitions and calls.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\n```scala\nclass Complex(real: Double, imaginary: Double):\n  def re = real\n  def im = imaginary\n```\n```\n\n----------------------------------------\n\nTITLE: Scala样例类定义其他系统元素（Address, Customer, Order）\nDESCRIPTION: 定义Address、Customer和Order样例类，用于建模披萨订购系统中的地址、客户信息和订单内容。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-fp.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ncase class Address(\n  street1: String,\n  street2: Option[String],\n  city: String,\n  state: String,\n  zipCode: String\n)\n\ncase class Customer(\n  name: String,\n  phone: String,\n  address: Address\n)\n\ncase class Order(\n  pizzas: Seq[Pizza],\n  customer: Customer\n)\n```\n\n----------------------------------------\n\nTITLE: Fixing Variance Issues with Lower Type Bounds in Scala Prepend Method\nDESCRIPTION: This snippet corrects the variance problem in the prepend method by introducing a new type parameter B with a lower type bound B >: A. The prepend method accepts an element of type B (a supertype of A) and returns a NonEmptyList[B]. This adjustment allows the method parameter to be contravariant, ensuring proper variance behavior in the covariant List trait. The rest of the implementation remains unchanged, maintaining covariant definitions for List and NonEmptyList, and Nil as an empty list.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/lower-type-bounds.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntrait List[+A] {\n  def prepend[B >: A](elem: B): NonEmptyList[B] = NonEmptyList(elem, this)\n}\n\ncase class NonEmptyList[+A](head: A, tail: List[A]) extends List[A]\n\nobject Nil extends List[Nothing]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Scala's Universality of Objects for Numbers and Functions\nDESCRIPTION: This example illustrates that numeric types and functions are objects in Scala. Arithmetic operations are method calls, and functions can be passed as arguments or stored in variables. It emphasizes Scala's support for functional programming and object-oriented features, with dependencies being core language features. Inputs are no parameters; output is the result of expressions or printed strings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tutorials/scala-for-java-programmers.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n1 + 2 * 3 / x\n// Equivalent to:\n1.+(2.*(3)./(x)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nobject Minuteur {\n  def uneFoisParSeconde(retour: () => Unit): Unit = {\n    while (true) {\n      retour()\n      Thread sleep 1000\n    }\n  }\n  \n  def leTempsPasse(): Unit = {\n    println(\"le temps passe comme une flèche\")\n  }\n  \n  def main(args: Array[String]): Unit = {\n    uneFoisParSeconde(leTempsPasse)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Future Completion with onComplete in Scala 2/3\nDESCRIPTION: Demonstrates fetching recent posts asynchronously using a `Future` and registering an `onComplete` callback. The callback uses pattern matching on `Try[T]` to handle both successful completion (printing each post) and failure (printing an error message). This approach ensures that both outcomes of the asynchronous operation are explicitly managed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_9\n\nLANGUAGE: Scala 2\nCODE:\n```\nimport scala.util.{Success, Failure}\n\nval f: Future[List[String]] = Future {\n  session.getRecentPosts()\n}\n\nf.onComplete {\n  case Success(posts) => for (post <- posts) println(post)\n  case Failure(t) => println(\"An error has occurred: \" + t.getMessage)\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nimport scala.util.{Success, Failure}\n\nval f: Future[List[String]] = Future {\n  session.getRecentPosts()\n}\n\nf.onComplete {\n  case Success(posts) => for post <- posts do println(post)\n  case Failure(t) => println(\"An error has occurred: \" + t.getMessage)\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative For/Yield Syntax Variations in Scala 2\nDESCRIPTION: Illustrates different syntactic forms for for/yield expressions, each resulting in doubles where elements are the original ints multiplied by 2. Requires ints to be in scope. All options yield an identical List[Int] result.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval doubles = for (i <- ints) yield i * 2\nval doubles = for (i <- ints) yield (i * 2)\nval doubles = for { i <- ints } yield (i * 2)\n\n```\n\n----------------------------------------\n\nTITLE: Instantiating Scala Classes with Default Parameters Using Named Arguments\nDESCRIPTION: This snippet shows a Scala class `Point` with two constructor parameters `x` and `y`, both having default values of 0. It illustrates creating an instance of `Point` by specifying only the `y` coordinate using a named argument, relying on the default for `x`. Dependencies include Scala class construction with default parameters and named argument syntax. Inputs are parameter values `x` and `y`, with `y` explicitly set post-default; output is an instance of the class with corresponding values. Enforces named arguments when skipping earlier parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/default-parameter-values.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass Point(val x: Double = 0, val y: Double = 0)\n\nval point1 = new Point(y = 1)\n```\n\n----------------------------------------\n\nTITLE: Using the Default 'toString' Method of Scala Case Classes\nDESCRIPTION: Shows the default string representation of a 'Person' case class instance ('christina') when evaluated in the Scala REPL. Case classes automatically generate a 'toString' method that provides a readable representation of the object and its fields, which is useful for debugging.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/case-classes.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nscala> christina\nres0: Person = Person(Christina,niece)\n```\n\n----------------------------------------\n\nTITLE: Scala 3 'given' import merging syntax example\nDESCRIPTION: This snippet shows how to merge import statements into a single statement to include both all members except 'givens' and the 'given' instance specifically, clarifying import control.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-given-imports.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject B:\n  import A.{given, *}\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterized Enums in Scala 3\nDESCRIPTION: Illustrates defining a parameterized enumeration (`Color`) in Scala 3, where each case (`Red`, `Green`, `Blue`) extends the enum and provides a value for its parameter (`rgb: Int`). This feature doesn't have a direct equivalent in standard Python enums.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_74\n\nLANGUAGE: Scala\nCODE:\n```\nenum Color(val rgb: Int):\n  case Red   extends Color(0xFF0000)\n  case Green extends Color(0x00FF00)\n  case Blue  extends Color(0x0000FF)\n```\n\n----------------------------------------\n\nTITLE: Using flatMap with for-Comprehensions for Multi-Currency Purchase in Scala\nDESCRIPTION: Demonstrates how to compose multiple Futures using flatMap through a Scala for-comprehension to fetch currency quotes in parallel and decide on a purchase based on both. The snippet depends on Futures for USD and CHF rates and a predicate isProfitable. It receives two Future inputs and outputs a Future purchase result. It shows how filtering can be used to conditionally proceed and how for-comprehensions yield clearer asynchronous flow control.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/futures-promises.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nval usdQuote = Future { connection.getCurrentValue(USD) }\nval chfQuote = Future { connection.getCurrentValue(CHF) }\n\nval purchase = for {\n  usd <- usdQuote\n  chf <- chfQuote\n  if isProfitable(usd, chf)\n} yield connection.buy(amount, chf)\n\npurchase onSuccess {\n  case _ => println(\"Purchased \" + amount + \" CHF\")\n}\n```\n\n----------------------------------------\n\nTITLE: Scala 2 'if'/'else' statement\nDESCRIPTION: Demonstrates the traditional 'if'/'else' statement in Scala 2 for conditional logic, printing text based on the value of x.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nif (x < 0) {\n  println(\"negative\")\n} else if (x == 0) {\n  println(\"zero\")\n} else {\n  println(\"positive\")\n}\n```\n\n----------------------------------------\n\nTITLE: 导入JavaConverters实现Scala与Java容器互转 - Scala\nDESCRIPTION: 展示如何通过导入collection.JavaConverters对象启用Scala和Java容器类型的双向转换。该导入是使用asScala和asJava扩展方法实现隐式转换的前提，允许对Scala和Java容器之间无缝操作。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/conversions-between-java-and-scala-collections.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nscala> import collection.JavaConverters._\nimport collection.JavaConverters._\n```\n\n----------------------------------------\n\nTITLE: Implementing the 'foreach' method in Scala's 'Iterable' trait (Scala)\nDESCRIPTION: This code defines the 'foreach' method in Scala's 'Iterable' trait, which iterates over each element of the collection using its 'iterator'. The implementation ensures that a function 'f' is applied to every element in order, with potential for subclasses to override for more efficient processing. It is a fundamental component for traversal operations in collection subclasses.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/trait-iterable.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef foreach[U](f: Elem => U): Unit = {\n  val it = iterator\n  while (it.hasNext) f(it.next())\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Scala Array Operations and Sequence Compatibility\nDESCRIPTION: Shows how to create arrays and perform sequence operations like map, filter, and reverse on Scala arrays, emphasizing their support for all sequence methods through implicit conversions. Utilizes examples for Scala 2 and 3 environments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/arrays.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval a1 = Array(1, 2, 3)\nval a2 = a1.map(_ * 3)\nval a3 = a2.filter(_ % 2 != 0)\na3.reverse\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterized Traits in Scala 3 - Scala\nDESCRIPTION: This snippet demonstrates how to define parameterized traits in Scala, where a trait `T` takes a parameter `x` of type `A`. It also shows a trait `U` extending `T` without passing parameters, illustrating that secondary constructors are not permitted for traits and that trait parameters replace early definitions. The snippet assumes appropriate type definitions for `A` and shows valid parameter syntax in trait declarations as supported by Scala 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/trait-parameters.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait T(x: A)\ntrait U extends T\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Command-Line Parameter Types with @main in Scala 3\nDESCRIPTION: Illustrates how to use a user-defined enum type as a parameter for an @main method by providing a given instance of scala.util.CommandLineParser.FromString for the custom type. This enables automatic parsing of command-line string arguments into the custom Color enum, which contains three cases. Dependencies include the custom enum definition and an implicit parser instance enabling conversion from String. The input is a color name provided as a command-line argument, and the output prints the color as a string.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/methods-main-methods.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nenum Color:\n  case Red, Green, Blue\n\ngiven ComamndLineParser.FromString[Color] with\n  def fromString(value: String): Color = Color.valueOf(value)\n\n@main def run(color: Color): Unit =\n  println(s\"The color is ${color.toString}\")\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Map Key-Value Pairs Using 'for' in Scala\nDESCRIPTION: Demonstrates how to iterate over the key-value pairs of a Map using a `for` loop and pattern matching (tuple `(abbrev, fullName)`). Compares Scala 2 and Scala 3 syntax (`do` keyword). Requires a Map named `states` to be defined.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_15\n\nLANGUAGE: Scala 2\nCODE:\n```\nfor ((abbrev, fullName) <- states) println(s\"$abbrev: $fullName\")\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nfor (abbrev, fullName) <- states do println(s\"$abbrev: $fullName\")\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Case Class for Immutable Data Structures (Scala 2 and 3)\nDESCRIPTION: Defines a case class named Person with immutable and public fields name and relation. This declaration automatically generates equals, hashCode, toString, copy, and unapply methods, supporting pattern matching and structural equality. The fields are immutable val by default. No explicit dependencies beyond Scala standard library are required. Input is string values for name and relation; output is an instance of Person.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-tools.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ncase class Person(name: String, relation: String)\n```\n\n----------------------------------------\n\nTITLE: ケースクラスの宣言とインスタンス化\nDESCRIPTION: このコードはScalaでシンプルなケースクラスを宣言し、そのインスタンスを作成する例です。`case class`キーワードを用いて不変なデータオブジェクトを定義し、`apply`メソッドを使ったインスタンス化により`new`キーワードなしでオブジェクト生成が可能であることを示しています。依存関係は特に不要です。出力は`Book`のISBN文字列になります。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/case-classes.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Book(isbn: String)\n\nval frankenstein = Book(\"978-0486282114\")\n```\n\n----------------------------------------\n\nTITLE: Type Casting Between Numeric Types in Scala\nDESCRIPTION: This code demonstrates how numeric types can be cast in Scala, showing conversion from Long to Float and Char to Int. The example illustrates the one-way nature of type casting in Scala's type hierarchy.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/unified-types.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval x: Long = 987654321\nval y: Float = x.toFloat  // 9.8765434E8 (заметьте, что некоторая точность теряется в этом случае.)\n\nval face: Char = '☺'\nval number: Int = face  // 9786\n```\n\n----------------------------------------\n\nTITLE: Ensuring tail recursion with @tailrec in Scala\nDESCRIPTION: Illustrates the use of `@tailrec` from `scala.annotation` to verify that a recursive helper function is tail-recursive. This enables the compiler to optimize the recursion into a loop, preventing stack overflow errors. Requires importing `scala.annotation.tailrec`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/annotations.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.annotation.tailrec\n\ndef factorial(x: Int): Int = {\n\n  @tailrec\n  def factorialHelper(x: Int, accumulator: Int): Int = {\n    if (x == 1) accumulator else factorialHelper(x - 1, accumulator * x)\n  }\n  factorialHelper(x, 1)\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.annotation.tailrec\n\ndef factorial(x: Int): Int =\n\n  @tailrec\n  def factorialHelper(x: Int, accumulator: Int): Int =\n    if x == 1 then accumulator else factorialHelper(x - 1, accumulator * x)\n  factorialHelper(x, 1)\n```\n\n----------------------------------------\n\nTITLE: Exception Handling with try/catch/finally in Scala 3\nDESCRIPTION: Shows Scala 3's simplified try/catch/finally syntax without braces, maintaining functionality for catching specific exceptions and cleaning resources. Requires matching exception classes and 'writeTextToFile' method. Inputs and outputs mirror Scala 2 but with clearer, compact syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\ntry\n  writeTextToFile(text)\ncatch\n  case ioe: IOException => println(\"Got an IOException.\")\n  case nfe: NumberFormatException => println(\"Got a NumberFormatException.\")\nfinally\n  println(\"Clean up your resources here.\")\n```\n\n----------------------------------------\n\nTITLE: 定义参数为函数类型的多种签名示例\nDESCRIPTION: 列出不同函数类型签名示例，包括接受单个参数、多个参数并返回值的签名，以帮助理解如何定义各种函数签名匹配不同函数。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-hofs.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nf: (String) => Int\n```\n\nLANGUAGE: Scala\nCODE:\n```\nf: (Int, Int) => Int\n```\n\n----------------------------------------\n\nTITLE: For Expression with Multiple Generators in Scala\nDESCRIPTION: This example uses a for expression with two generators and a filter to find pairs of numbers that sum to a specific value. It demonstrates nested iteration and filtering within for comprehensions to generate specific tuples.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/for-comprehensions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef foo(n: Int, v: Int) =\n   for (i <- 0 until n;\n        j <- i until n if i + j == v)\n   yield (i, j)\n\nfoo(10, 10) foreach {\n  case (i, j) =>\n    println(s\"($i, $j) \")  // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5)\n}\n```\n\n----------------------------------------\n\nTITLE: 定义并使用带 Showable 类型类约束的通用方法 showAll (Scala 2 和 Scala 3)\nDESCRIPTION: 定义一个泛型方法 showAll，接受任意类型列表和对应的 Showable 实例，遍历列表并打印每个元素的字符串表示。Scala 2 使用隐式参数传递类型类实例，Scala 3 使用上下文界定（context bound）和扩展方法调用。演示类型类在泛型编程中的集成方式和约束表达。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/ca-type-classes.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ndef showAll[A](as: List[A])(implicit showable: Showable[A]): Unit =\n  as.foreach(a => println(showable.show(a)))\n\nshowAll(List(Person(\"Jane\"), Person(\"Mary\")))\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef showAll[A: Showable](as: List[A]): Unit =\n  as.foreach(a => println(a.show))\n\nshowAll(List(Person(\"Jane\"), Person(\"Mary\")))\n```\n\n----------------------------------------\n\nTITLE: Creating Classes with Default Constructor Parameters in Scala\nDESCRIPTION: This example shows how to define a Point class with default values for its constructor parameters. When instantiating the class, named arguments must be used if earlier parameters are omitted.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/default-parameter-values.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass Point(val x: Double = 0, val y: Double = 0)\n\nval point1 = new Point(y = 1)\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait with a Default Method Implementation (Greeter) in Scala\nDESCRIPTION: Shows how to define a `Greeter` trait that includes a default implementation for its `greet` method in both Scala 2 and Scala 3. Classes extending this trait can use this default behavior or override it.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\ntrait Greeter {\n  def greet(name: String): Unit =\n    println(\"Hello, \" + name + \"!\")\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait Greeter:\n  def greet(name: String): Unit =\n    println(\"Hello, \" + name + \"!\")\n```\n\n----------------------------------------\n\nTITLE: Converting Java List to Scala Sequence using asScala (Scala 2 & 3)\nDESCRIPTION: Demonstrates converting a Java List to a Scala mutable sequence with the 'asScala' extension method. Enables Scala code to operate on Java collections seamlessly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/conversions-between-java-and-scala-collections.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval jul: java.util.List[Int] = ArrayBuffer(1, 2, 3).asJava\nval buf: Seq[Int] = jul.asScala\n```\n\n----------------------------------------\n\nTITLE: Using reduce with anonymous functions for multiplication in Scala\nDESCRIPTION: Using reduce with an anonymous function to multiply all elements in a list together.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-methods.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nscala> a.reduce(_ * _)\nres1: Int = 24\n```\n\n----------------------------------------\n\nTITLE: Scala 3 'if'/'else' expression\nDESCRIPTION: Shows the Scala 3 syntax for 'if'/'else' as an expression, enabling assignment of conditional results to variables.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nif x < 0 then\n  println(\"negative\")\nelse if x == 0 then\n  println(\"zero\")\nelse\n  println(\"positive\")\n```\n\n----------------------------------------\n\nTITLE: Adding foreach to Iterator Trait (Scala)\nDESCRIPTION: Creates a trait `RichIterator` that extends the abstract `AbsIterator` and adds a concrete method `foreach`. This method utilizes the abstract `hasNext` and `next` methods from `AbsIterator` to iterate and apply a function to each element, showcasing how traits can add rich functionality to a base type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/mixin-class-composition.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ntrait RichIterator extends AbsIterator {\n  def foreach(f: T => Unit): Unit = while (hasNext) f(next())\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntrait RichIterator extends AbsIterator:\n  def foreach(f: T => Unit): Unit = while hasNext do f(next())\n```\n\n----------------------------------------\n\nTITLE: Iterating Ranges Inclusively and Exclusively with for-Loop in Scala\nDESCRIPTION: Two snippets showing iteration over integer ranges using a for-loop: one including the upper bound (using 'to') and one excluding the upper bound (using 'until'). The code prints each integer in the specified range to the console. This is useful for controlled iteration in Scala within specified numeric bounds.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/cheatsheets/index.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nfor (i <- 1 to 5) {\n  println(i)\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor (i <- 1 until 5) {\n  println(i)\n}\n```\n\n----------------------------------------\n\nTITLE: Добавление нескольких тестов с AnyFunSuite в Scala (Scala)\nDESCRIPTION: Расширенный пример тестового класса на Scala с использованием ScalaTest AnyFunSuite, демонстрирующий добавление двух тестовых блоков. Первый тест проверяет, что куб числа 3 равен 27, второй — что куб числа 0 равен 0. Каждый тест оформлен функцией test с уникальным именем. Используется assert с оператором === для проверки равенства ожидаемого и фактического результата.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/getting-started/sbt-track/testing-scala-with-sbt-on-the-command-line.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport org.scalatest.funsuite.AnyFunSuite\n\nclass CubeCalculatorTest extends AnyFunSuite {\n    test(\"CubeCalculator.cube 3 should be 27\") {\n        assert(CubeCalculator.cube(3) === 27)\n    }\n\n    test(\"CubeCalculator.cube 0 should be 0\") {\n        assert(CubeCalculator.cube(0) === 0)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: 距離を表すScala値クラス例\nDESCRIPTION: `Meter`値クラスは、`AnyVal`を継承して距離の型安全性を提供。実行時には`Double`型のデータのみが使われ、`+`演算子で距離を加算できる。これにより、型安全を保ったままパフォーマンス向上が期待できる。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/value-classes.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass Meter(val value: Double) extends AnyVal {\n  def +(m: Meter): Meter = new Meter(value + m.value)\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Usage and Common Mistakes in Scala\nDESCRIPTION: Illustrates correct pattern matching with tuples in function arguments and common pitfalls when matching against variable values versus pattern variables. Shows how backticks around a variable name interpret it as a constant rather than a pattern variable. Demonstrates how uppercase identifiers in cases are matched as existing vals. No external dependencies beyond standard Scala. Inputs are pattern match targets; outputs are conditional actions like printing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\n(xs zip ys) map {\n  case (x, y) => x * y\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(xs zip ys) map {\n  (x, y) => x * y\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval v42 = 42\n3 match {\n  case v42 => println(\"42\")\n  case _   => println(\"Not 42\")\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval v42 = 42\n3 match {\n  case `v42` => println(\"42\")\n  case _     => println(\"Not 42\")\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval UppercaseVal = 42\n3 match {\n  case UppercaseVal => println(\"42\")\n  case _            => println(\"Not 42\")\n}\n```\n\n----------------------------------------\n\nTITLE: Wrapping Java Executor as Scala ExecutionContext\nDESCRIPTION: Shows how to convert a Java Executor such as ThreadPoolExecutor into a Scala ExecutionContext using `ExecutionContext.fromExecutor`, enabling integration with Java concurrency utilities.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nExecutionContext.fromExecutor(new ThreadPoolExecutor( /* your configuration */ ))\n```\n\nLANGUAGE: Scala\nCODE:\n```\nExecutionContext.fromExecutor(ThreadPoolExecutor( /* your configuration */ ))\n```\n\n----------------------------------------\n\nTITLE: Iterating with For Loops (Single Line) - JavaScript & Scala\nDESCRIPTION: Demonstrates single-line syntax for iterating over collections using 'for' loops in JavaScript and Scala. Includes both newer and older JavaScript syntaxes and preferred/alternative Scala 3 syntaxes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_26\n\nLANGUAGE: JavaScript\nCODE:\n```\n// newer syntax\nfor (let i of nums) {\n  console.log(i);\n}\n\n// older\nfor (i=0; i<nums.length; i++) {\n  console.log(nums[i]);\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// preferred\nfor i <- nums do println(i)\n\n// also available\nfor (i <- nums) println(i)\n```\n\n----------------------------------------\n\nTITLE: Type Inference for Function Parameters in Scala Collections Method\nDESCRIPTION: Highlights Scala's ability to infer the element type in lambda functions passed to collection methods like 'map', identifying the input as 'Int' based on the collection content.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/type-inference.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nSeq(1, 3, 4).map(x => x * 2) // List(2, 6, 8)\n```\n\n----------------------------------------\n\nTITLE: Invalid Assignments Involving Opaque Type Logarithm in Scala\nDESCRIPTION: Shows code that attempts to assign values between Double and Logarithm without using the correct lifting/unlifting API, resulting in type errors. Specifically, assigning Logarithm directly from Double or the implicit conversion from Logarithm to Double fails, illustrating the enforced opacity outside the companion object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/opaque-types.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\npackage object usesites {\n  import opaquetypes._\n  val l: Logarithm = Logarithm(1.0)\n  val d: Double = l // fails to typecheck\n  val l2: Logarithm = 1.0 // fails to typecheck\n}\n```\n\n----------------------------------------\n\nTITLE: Matching multiple values in pattern matching\nDESCRIPTION: Demonstrates pattern matching multiple specific values in a single 'case' statement, labeling as 'odd', 'even', or other, based on pattern matching multiple integers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/match-expressions.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval evenOrOdd = i match {\n    case 1 | 3 | 5 | 7 | 9 => println(\"odd\")\n    case 2 | 4 | 6 | 8 | 10 => println(\"even\")\n    case _ => println(\"some other number\")\n}\n```\n\n----------------------------------------\n\nTITLE: Scala Collection Type Aliases and Package Usage\nDESCRIPTION: This snippet shows how to access collection types like 'List' via full package names or aliases, highlighting that 'scala.List' and 'scala.collection.immutable.List' are interchangeable due to the alias, and that simple 'List' refers to the immutable version automatically imported from 'scala._'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/overview.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nscala.collection.immutable.List   // that's where it is defined\nscala.List                        // via the alias in the scala package\nList                              // because scala._\n                                  // is always automatically imported\n```\n\n----------------------------------------\n\nTITLE: Using assert to Check Boolean Conditions in MUnit - Scala 3\nDESCRIPTION: This snippet presents the Scala 3 version of the test verifying that all elements in a transformed list are even, using MUnit's assert method. It uses Scala 3 syntax with significant indentation and defines a test \"all even numbers\" which doubles a list and asserts all results are even. Required dependencies include MUnit.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-suite.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntest(\"all even numbers\") {\n  val input: List[Int] = List(1, 2, 3, 4)\n  val obtainedResults: List[Int] = input.map(_ * 2)\n  // check that obtained values are all even numbers\n  assert(obtainedResults.forall(x => x % 2 == 0))\n}\n```\n\n----------------------------------------\n\nTITLE: Default Numeric Types in Scala\nDESCRIPTION: Demonstrates that Scala defaults to Int and Double types when no explicit type is declared for numeric literals.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-vars-data-types.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval i = 123   // defaults to Int\nval j = 1.0   // defaults to Double\n```\n\n----------------------------------------\n\nTITLE: Defining Implicit Monoids and Summation Using Implicit Parameters in Scala\nDESCRIPTION: This Scala snippet demonstrates defining abstract algebraic structures (SemiGroup and Monoid) and implementing implicit monoid instances for String and Int types within an object. It defines a generic 'sum' method that takes a list and an implicit Monoid parameter to recursively combine elements using the monoid operations. The implicit keyword allows automatic passing of the appropriate monoid instance based on the element type, enabling concise invocation of the sum method without explicitly specifying the monoid argument. The snippet’s output shows the sum of integers and concatenation of strings. Dependencies include Scala's standard library and the implicit resolution mechanism. Input parameters include a list of elements whose combined results are computed using the implicit monoid. The output is a single monoid-combined value. Constraints include that implicit values must be members of a template (not top-level) and be available in the current scope.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/implicit-parameters.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nabstract class SemiGroup[A] {\n  def add(x: A, y: A): A\n}\nabstract class Monoid[A] extends SemiGroup[A] {\n  def unit: A\n}\nobject ImplicitTest extends App {\n  implicit object StringMonoid extends Monoid[String] {\n    def add(x: String, y: String): String = x concat y\n    def unit: String = \"\"\n  }\n  implicit object IntMonoid extends Monoid[Int] {\n    def add(x: Int, y: Int): Int = x + y\n    def unit: Int = 0\n  }\n  def sum[A](xs: List[A])(implicit m: Monoid[A]): A =\n    if (xs.isEmpty) m.unit\n    else m.add(xs.head, sum(xs.tail))\n\n  println(sum(List(1, 2, 3)))       // uses IntMonoid implicitly\n  println(sum(List(\"a\", \"b\", \"c\"))) // uses StringMonoid implicitly\n}\n```\n\n----------------------------------------\n\nTITLE: Default Arguments with Implicit Parameters in Scala\nDESCRIPTION: Shows how default arguments can be used with implicit parameters in Scala. Default values are used when no matching implicit value can be found for the parameter type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-and-default-arguments.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ndef f(implicit a: String = \"value\", y: Int = 0) = a +\": \"+ y\nimplicit val s = \"size\"\nprintln(f)              // prints \"size: 0\"\n```\n\n----------------------------------------\n\nTITLE: Using sealed abstract class with case classes for exhaustive pattern matching - Scala\nDESCRIPTION: Defines a sealed abstract class Furniture and two case classes (Couch, Chair) inheriting it. The function findPlaceToSit uses pattern matching on Furniture values to return a String indicating how to sit. The sealed modifier enforces that all subclasses must be declared in the same source file, enabling the compiler to check match exhaustiveness. This snippet illustrates how sealed classes improve safety and flexibility in pattern matching by eliminating the need for catch-all cases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/pattern-matching.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nsealed abstract class Furniture\ncase class Couch() extends Furniture\ncase class Chair() extends Furniture\n\ndef findPlaceToSit(piece: Furniture): String = piece match {\n  case a: Couch => \"Lie on the couch\"\n  case b: Chair => \"Sit on the chair\"\n}\n```\n\n----------------------------------------\n\nTITLE: Matching on Type Only - Scala 2\nDESCRIPTION: Demonstrates pattern matching on the type of an object (`case p: Phone`). This allows executing type-specific logic, like calling a method (`p.screenOff`). Requires the input type (`Device`) to be a trait or class with defined subtypes (`Phone`, `Computer`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/pattern-matching.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait Device\ncase class Phone(model: String) extends Device {\n  def screenOff = \"Turning screen off\"\n}\ncase class Computer(model: String) extends Device {\n  def screenSaverOn = \"Turning screen saver on...\"\n}\n\ndef goIdle(device: Device): String = device match {\n  case p: Phone => p.screenOff\n  case c: Computer => c.screenSaverOn\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Scala Class with Constructor and Methods\nDESCRIPTION: Shows a class 'Point' with a primary constructor accepting two mutable integer members, x and y. Includes an instance method 'move' to modify coordinates and an overridden 'toString' method for string representation. Highlights class design with mutable state and method definitions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/classes.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass Point(var x: Int, var y: Int) {\n\n  def move(dx: Int, dy: Int): Unit = {\n    x = x + dx\n    y = y + dy\n  }\n\n  override def toString: String =\n    s\"($x, $y)\"\n}\n\nval point1 = new Point(2, 3)\npoint1.x  // 2\nprintln(point1)  // prints (2, 3)\n```\n\n----------------------------------------\n\nTITLE: Hiding multiple members and using other classes in Scala 2 and 3\nDESCRIPTION: Imports all but specific members such as 'List', 'Map', and 'Set', allowing their usage without conflicts with Scala’s collection classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/packaging-imports.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport java.util.{List => _, Map => _, Set => _, *}  // Scala 2\nimport java.util.{List as _, Map as _, Set as _, *}  // Scala 3\n```\n\n----------------------------------------\n\nTITLE: Scala 2 'if'/'else' expression assignment\nDESCRIPTION: Illustrates assigning the result of an 'if'/'else' expression to a variable in Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval x = if (a < b) { a } else { b }\n```\n\n----------------------------------------\n\nTITLE: Команда створення нового проекту Scala через sbt (bash)\nDESCRIPTION: Цей фрагмент демонструє команди для створення нового Scala проекту за допомогою інструменту збірки sbt у bash. Команда `sbt new scala/scala3.g8` створює шаблон проекту для Scala 3, а команда `sbt new scala/hello-world.g8` — для Scala 2. Після запуску цих команд sbt завантажує шаблон з GitHub, створює базову структуру директорій, включно з файлом конфігурації `build.sbt` та директорією `src/main/scala` для коду, а також запитує назву проекту для налаштування.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/getting-started/install-scala.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsbt new scala/scala3.g8\n# або\nsbt new scala/hello-world.g8\n```\n\n----------------------------------------\n\nTITLE: Aggregating Multiple Traits Using Exports in Scala 3 Top Level Definitions\nDESCRIPTION: Demonstrates preferred Scala 3 approach to compose package members from multiple traits by defining private objects inheriting those traits and exporting their members at the package top level. This allows modular design while exposing aggregated members cleanly without inheritance on package objects, which are deprecated.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/package-objects.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\npackage gardening.fruits\n\nprivate object FruitAliases extends FruitAliases\nprivate object FruitHelpers extends FruitHelpers\n\nexport FruitHelpers.*, FruitAliases.*\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Case Classes and Guards in Scala 3\nDESCRIPTION: Mirrors Scala 2 case class pattern matching example with guards, using Scala 3's indentation syntax without braces. Matches 'Person' instances by their 'name' property and prints messages accordingly. Requires 'Person' case class and Scala 3 compiler.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\nval p = Person(\"Fred\")\n\n// позже в этом коде ...\np match\n  case Person(name) if name == \"Fred\" =>\n    println(s\"$name says, Yubba dubba doo\")\n\n  case Person(name) if name == \"Bam Bam\" =>\n    println(s\"$name says, Bam bam!\")\n\n  case _ => println(\"Watch the Flintstones!\")\n```\n\n----------------------------------------\n\nTITLE: Variable Declarations in Scala\nDESCRIPTION: Demonstrates mutable (var) and immutable (val) variable declarations, explicit type annotations, and reassignment capabilities.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/cheatsheets/index.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nvar x = 5\n```\n\nLANGUAGE: Scala\nCODE:\n```\nx = 6\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval x = 5\n```\n\nLANGUAGE: Scala\nCODE:\n```\nx = 6\n```\n\nLANGUAGE: Scala\nCODE:\n```\nvar x: Double = 5\n```\n\n----------------------------------------\n\nTITLE: Configuring SBT for Scala 2.13 Macro Library\nDESCRIPTION: Demonstrates the setup of a minimal SBT project for a Scala 2.13 macro library. It sets the Scala version and adds the 'scala-reflect' dependency required for Scala 2 macros. The code is placed in 'build.sbt' and is prerequisite for all Scala 2 macro work. No user input is required; outputs depend on subsequent source code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-macro-cross-building.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// build.sbt\nlazy val example = project\n  .in(file(\"example\"))\n  .settings(\n    scalaVersion := \"2.13.11\",\n    libraryDependencies ++= Seq(\n      \"org.scala-lang\" % \"scala-reflect\" % scalaVersion.value\n    )\n  )\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Scala Option to Handle Success and Failure Cases (Scala 2 and Scala 3 Syntax)\nDESCRIPTION: This snippet uses pattern matching on the Option value returned by makeInt(x) to explicitly handle both cases: Some(i) indicates success and prints the integer, while None indicates failure and prints an error message. It requires makeInt to return Option[Int]. This approach allows separate code paths depending on the presence of a value and is useful when subsequent handling differs significantly for Some and None.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-functional-error-handling.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nmakeInt(x) match {\n  case Some(i) => println(i)\n  case None => println(\"That didn't work.\")\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nmakeInt(x) match\n  case Some(i) => println(i)\n  case None => println(\"That didn't work.\")\n```\n\n----------------------------------------\n\nTITLE: Defining Key Types for Dependent Method Implementation\nDESCRIPTION: Creates concrete key objects that specify their associated value types using path-dependent types, allowing type-safe retrieval from the database.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-dependent-function.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject Name extends Key { type Value = String }\nobject Age extends Key { type Value = Int }\n```\n\n----------------------------------------\n\nTITLE: Basic Integer Match Expression (Scala 3)\nDESCRIPTION: Demonstrates the basic syntax of a `match` expression in Scala 3, analogous to a Java `switch` statement, matching against integer literals using the new indentation-based syntax. Includes a default case using `_` to handle all other values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\nval i = 1\n\n// later in the code ...\ni match\n  case 1 => println(\"one\")\n  case 2 => println(\"two\")\n  case _ => println(\"other\")\n```\n\n----------------------------------------\n\nTITLE: Running a Scala program with sbt\nDESCRIPTION: Command sequence to compile and execute the Scala program within the sbt build tool, showing the typical output and process flow for a Scala project.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/tools-sbt.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt run\n\n[info] welcome to sbt\n[info] loading settings for project ...\n[info] loading project definition\n[info] loading settings for project ...\n[info] Compiling 1 Scala source ...\n[info] running helloWorld \nHello, world\n[success] Total time: 4 s\n```\n\n----------------------------------------\n\nTITLE: Using an Abstract Class Implementation in Scala REPL\nDESCRIPTION: This Scala REPL session shows the instantiation of the 'Dog' class (which extends the abstract 'Pet' class) and the invocation of its methods. It confirms that the overridden 'speak' method and the implemented 'comeToMaster' method execute as expected.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/abstract-classes.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nscala> val d = new Dog(\"Rover\")\nd: Dog = Dog@51f1fe1c\n\nscala> d.speak\nWoof\n\nscala> d.comeToMaster\nHere I come!\n```\n\n----------------------------------------\n\nTITLE: Defining Traits for Compound Types in Scala 2\nDESCRIPTION: Defines two traits, `Cloneable` extending `java.lang.Cloneable` (overriding `clone` to be public) and `Resetable` with an abstract `reset` method, using Scala 2 syntax. These traits serve as components for demonstrating compound types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/compound-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Cloneable extends java.lang.Cloneable {\n  override def clone(): Cloneable = { // makes clone public\n    super.clone().asInstanceOf[Cloneable]\n  }\n}\ntrait Resetable {\n  def reset: Unit\n}\n```\n\n----------------------------------------\n\nTITLE: Class Extending Composed Traits in Scala 2\nDESCRIPTION: This Scala 2 snippet defines a class MyService that takes a name as a constructor parameter and extends ComposedService and Showable traits. It implements the show method by combining the name and sayHello functionality. There are no external dependencies; it demonstrates how to bring together multiple traits in a class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nclass MyService(name: String) extends ComposedService with Showable {\n  def show = s\"$name says $sayHello\"\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Numeric Ranges with Inclusive and Step Operations in Scala\nDESCRIPTION: This snippet demonstrates creation of numerical ranges using the 'to' and 'by' methods in Scala, resulting in inclusive and stepped integer sequences, respectively. Also illustrated is the use of 'until' to create exclusive ranges. No extra dependencies are needed. Inputs are integer start, stop, and optional step; outputs are 'Range' objects that represent ordered sequences. This utilizes methods available in the standard library and is suited for iteration, comprehensions, and index-based processing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/concrete-immutable-collection-classes.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nscala> 1 to 3\nres2: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3)\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> 5 to 14 by 3\nres3: scala.collection.immutable.Range = Range(5, 8, 11, 14)\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> 1 until 3\nres2: scala.collection.immutable.Range = Range(1, 2)\n```\n\n----------------------------------------\n\nTITLE: Attempting to Reassign a val in Scala\nDESCRIPTION: Illustrates that reassigning a val variable leads to a compile-time error, reinforcing immutability constraints.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-vars-data-types.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval msg = \"Hello, world\"\nmsg = \"Aloha\"   // \"reassignment to val\" error; this won’t compile\n```\n\n----------------------------------------\n\nTITLE: Scala REPL Behavior: Reassignment to val Causes Error\nDESCRIPTION: This REPL example demonstrates that attempting to reassign an immutable val variable results in a compile-time error labeled \"reassignment to val.\" It highlights val immutability enforced by the Scala compiler in interactive mode. It takes a val character variable a initialized to 'a' and tries assigning 'b' to it, causing an error.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/two-types-variables.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nscala> val a = 'a'\na: Char = a\n\nscala> a = 'b'\n<console>:12: error: reassignment to val\n       a = 'b'\n         ^\n```\n\n----------------------------------------\n\nTITLE: Compiler Desugaring of Custom Interpolator Call in Scala 2\nDESCRIPTION: Explains how the Scala 2 compiler transforms a custom interpolator call like `p\"1, $someVar\"`. It first creates a `StringContext` with the static parts (`\"1, \"`, `\"\"`) and calls its `p` method with the expression (`someVar`). The implicit `PointHelper` class facilitates this call.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nnew StringContext(\"1, \", \"\").p(someVar)\n\n// The implicit class is then used to rewrite it to the following:\n\nnew PointHelper(new StringContext(\"1, \", \"\")).p(someVar)\n```\n\n----------------------------------------\n\nTITLE: Blocking outside a Scala Future using Await.result\nDESCRIPTION: Illustrates waiting synchronously for a future's completion using `Await.result`, potentially throwing exceptions if the future fails. Used at program termination or initialization, but generally discouraged during regular asynchronous workflows. Demonstrates error propagation via exceptions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_31\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.concurrent._\nimport scala.concurrent.duration._\n\nobject awaitPurchase {\n  def main(args: Array[String]): Unit = {\n    val rateQuote = Future {\n      connection.getCurrentValue(USD)\n    }\n\n    val purchase = rateQuote.map { quote =>\n      if (isProfitable(quote)) connection.buy(amount, quote)\n      else throw new Exception(\"not profitable\")\n    }\n\n    Await.result(purchase, 0.nanos)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Enumerations using Sealed Traits and Case Objects (Scala)\nDESCRIPTION: Defines standard values for pizza toppings, crust sizes, and crust types using Scala's `sealed trait` and `case object` pattern, which acts like an enumeration. These types provide a set of well-defined options used throughout the pizza order system example. No external dependencies are required for these definitions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/oop-pizza-example.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait Topping\ncase object Cheese extends Topping\ncase object Pepperoni extends Topping\ncase object Sausage extends Topping\ncase object Mushrooms extends Topping\ncase object Onions extends Topping\n\nsealed trait CrustSize\ncase object SmallCrustSize extends CrustSize\ncase object MediumCrustSize extends CrustSize\ncase object LargeCrustSize extends CrustSize\n\nsealed trait CrustType\ncase object RegularCrustType extends CrustType\ncase object ThinCrustType extends CrustType\ncase object ThickCrustType extends CrustType\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom equals Method for AudioBook\nDESCRIPTION: This snippet demonstrates how to override the equals method to provide meaningful comparisons between AudioBook and PrintedBook instances beyond type compatibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/ca-multiversal-equality.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ncase class AudioBook(\n    author: String,\n    title: String,\n    year: Int,\n    lengthInMinutes: Int\n) extends Book:\n    // переопределить, чтобы разрешить сравнение AudioBook с PrintedBook\n    override def equals(that: Any): Boolean = that match\n        case a: AudioBook =>\n            this.author == a.author\n            && this.title == a.title\n            && this.year == a.year\n            && this.lengthInMinutes == a.lengthInMinutes\n        case p: PrintedBook =>\n            this.author == p.author && this.title == p.title\n        case _ =>\n            false\n\nprintln(aBook == pBook)   // true (работает из-за переопределенного `equals` в `AudioBook`)\nprintln(pBook == aBook)   // false\n```\n\n----------------------------------------\n\nTITLE: Chaining Transformations on a Scala Vector - Scala\nDESCRIPTION: Illustrates eager transformation of a Vector by chaining two map operations that first add 1 to each element and then multiply by 2. Each map call returns a new Vector resulting in intermediate allocations. The example shows how eager maps create intermediate collections and execute immediately.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/views.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval v = Vector(1 to 10: _*)\nv map (_ + 1) map (_ * 2)\n```\n\n----------------------------------------\n\nTITLE: Applying Lazy Transformations with View and Force - Scala REPL\nDESCRIPTION: This example demonstrates applying multiple map operations lazily using a collection view. The transformations are recorded on the view but not executed until `.force` is called, which materializes the final result as a new collection without intermediate ones.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/views.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n(v.view map (_ + 1) map (_ * 2)).force\n```\n\nLANGUAGE: text\nCODE:\n```\nres12: Seq[Int] = Vector(4, 6, 8, 10, 12, 14, 16, 18, 20, 22)\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Multiple Parameters in Scala\nDESCRIPTION: Shows how to define and use a function that takes multiple arguments, supporting more complex computations. Parameters are explicitly typed; output is computed by combining inputs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nval add = (x: Int, y: Int) => x + y\nprintln(add(1, 2)) // 3\n```\n\n----------------------------------------\n\nTITLE: Using 'if' guards with parentheses and multiple lines\nDESCRIPTION: Shows syntax variation with 'if' guards enclosed in parentheses and multi-line code blocks within 'case' statements to improve readability and formatting flexibility in pattern matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/match-expressions.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ncount match {\n    case 1 => \n        println(\"one, a lonely number\")\n    case x if (x == 2 || x == 3) => \n        println(\"two's company, three's a crowd\")\n    case x if (x > 3) => \n        println(\"4+, that's a party\")\n    case _ => \n        println(\"i'm guessing your number is zero or less\")\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Imperative List Doubling in Scala\nDESCRIPTION: This snippet demonstrates an imperative approach to transforming a list in Scala. It uses a mutable `ListBuffer` and a `for` loop to iterate through the input list, double each element, and append it to the buffer before converting it back to an immutable `List`. This style contrasts with Scala's more idiomatic functional approach.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-features.md#_snippet_0\n\nLANGUAGE: Scala 2\nCODE:\n```\nimport scala.collection.mutable.ListBuffer\n\ndef double(ints: List[Int]): List[Int] = {\n  val buffer = new ListBuffer[Int]()\n  for (i <- ints) {\n    buffer += i * 2\n  }\n  buffer.toList\n}\n\nval oldNumbers = List(1, 2, 3)\nval newNumbers = double(oldNumbers)\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nimport scala.collection.mutable.ListBuffer\n\ndef double(ints: List[Int]): List[Int] =\n  val buffer = new ListBuffer[Int]()\n  for i <- ints do\n    buffer += i * 2\n  buffer.toList\n\nval oldNumbers = List(1, 2, 3)\nval newNumbers = double(oldNumbers)\n```\n\n----------------------------------------\n\nTITLE: Creating a Factory Method Returning Language-Specific Greeting Functions in Scala\nDESCRIPTION: Defines a method `createGreetingFunction` that takes a language identifier string (`desiredLanguage`) and returns a corresponding greeting function (`String => Unit`). Inside the method, two anonymous functions for English and French greetings are defined. Using pattern matching on `desiredLanguage`, the correct greeting function is returned. This method demonstrates conditional function factory creation and can be implemented in both Scala 2 and Scala 3 syntax without dependencies beyond Scala standard library.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-write-method-returns-function.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef createGreetingFunction(desiredLanguage: String): String => Unit = {\n  val englishGreeting = (name: String) => println(s\"Hello, $name\")\n  val frenchGreeting = (name: String) => println(s\"Bonjour, $name\")\n  desiredLanguage match {\n    case \"english\" => englishGreeting\n    case \"french\" => frenchGreeting\n  }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef createGreetingFunction(desiredLanguage: String): String => Unit =\n  val englishGreeting = (name: String) => println(s\"Hello, $name\")\n  val frenchGreeting = (name: String) => println(s\"Bonjour, $name\")\n  desiredLanguage match\n    case \"english\" => englishGreeting\n    case \"french\" => frenchGreeting\n```\n\n----------------------------------------\n\nTITLE: Using match Expression for Pattern Matching in Scala 3\nDESCRIPTION: Shows Scala 3's streamlined match expression syntax matching an integer variable 'i' with cases executed accordingly. Requires Scala 3 compiler. Demonstrates cleaner indentation and no braces. Outputs text matching the integer's value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\nval i = 1\n\n// позже в этом коде ...\ni match\n  case 1 => println(\"one\")\n  case 2 => println(\"two\")\n  case _ => println(\"other\")\n```\n\n----------------------------------------\n\nTITLE: Sample build.sbt configuration for sbt project\nDESCRIPTION: Defines project properties such as project name, version, and Scala version using sbt syntax, enabling sbt to compile and run Scala code within the project.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/tools-sbt.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nname := \"HelloWorld\"\nversion := \"0.1\"\nscalaVersion := \"{{ site.scala-3-version }}\"\n```\n\n----------------------------------------\n\nTITLE: Various Syntaxes for Anonymous Functions with `map` in Scala\nDESCRIPTION: Illustrates multiple ways to write the same anonymous function for the `map` method, starting from the most explicit form `(i: Int) => i * 2` and progressively shortening it by omitting the type (`(i) => i * 2`) and then the parentheses (`i => i * 2`). All forms achieve the same result of doubling list elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-anonymous-functions.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval doubledInts = ints.map((i: Int) => i * 2)\nval doubledInts = ints.map((i) => i * 2)\nval doubledInts = ints.map(i => i * 2)\n```\n\n----------------------------------------\n\nTITLE: Extending Multiple Traits with Implemented Methods in Scala\nDESCRIPTION: Scala allows a class to extend (mix in) multiple traits, even if those traits contain implemented methods. This provides a form of multiple inheritance of implementation. Conflicts are resolved by linearization order.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_27\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Adder:\n  def add(a: Int, b: Int) = a + b\n\ntrait Multiplier:\n  def multiply(a: Int, b: Int) = a * b\n\nclass ScalaMath extends Adder, Multiplier\n\nval sm = new ScalaMath\nsm.add(1,1)\nsm.multiply(2,2);\n```\n\n----------------------------------------\n\nTITLE: Defining Arithmetic Expression Trees with Scala Case Classes\nDESCRIPTION: Defines an abstract base class Arbol and three case classes Sum, Var, and Const to represent arithmetic expressions as trees. Sum nodes represent addition operations with left and right subtrees, Var nodes represent variables with names as strings, and Const nodes represent integer constants. Declaring these as case classes enables convenient instance creation without the 'new' keyword, automatic getters, structural equality, and pattern matching capabilities.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tutorials/scala-for-java-programmers.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Arbol\ncase class Sum(l: Arbol, r: Arbol) extends Arbol\ncase class Var(n: String) extends Arbol\ncase class Const(v: Int) extends Arbol\n```\n\n----------------------------------------\n\nTITLE: Using 'recover' to Handle Exceptions in Futures in Scala 3\nDESCRIPTION: This snippet shows the application of 'recover' in Scala 3 syntax for exception handling,retaining similar functionality to handle 'QuoteChangedException' by providing a default value of zero, ensuring robust asynchronous execution.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\nval purchase = rateQuote.map { quote =>\n  connection.buy(amount, quote)\n}.recover {\n  case QuoteChangedException() => 0\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Exceptions with try/catch/finally (Scala)\nDESCRIPTION: This snippet shows the Scala equivalent of the try-catch-finally block for exception handling. It uses pattern matching within the 'catch' clause to handle different exception types ('IOException', 'NumberFormatException'). The 'finally' block is used for resource cleanup, similar to Java.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_53\n\nLANGUAGE: Scala\nCODE:\n```\ntry\n  writeTextToFile(text)\ncatch\n  case ioe: IOException =>\n    println(ioe.getMessage)\n  case nfe: NumberFormatException =>\n    println(nfe.getMessage)\nfinally\n  println(\"Clean up resources here.\")\n```\n\n----------------------------------------\n\nTITLE: Using foreach with Option Values (Scala)\nDESCRIPTION: Shows how the `foreach` method can be called on an `Option`. `foreach` executes its given function only if the `Option` is a `Some` (the \"Happy Path\"); it does nothing if the `Option` is `None` (the \"Unhappy Path\"), treating the Option like a collection of 0 or 1 elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/no-null-values.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ntoInt(\"1\").foreach(println)\ntoint(\"x\").foreach(println)\n```\n\n----------------------------------------\n\nTITLE: Complete printf Macro Definition and Implementation in a Scala Object\nDESCRIPTION: Provides the entire macro definition and implementation in a single Scala object `Macros`. The object defines the macro facade `printf` and the implementation method `printf_impl`. This snippet is self-contained, includes imports for macro context and mutable collections, and implements format parsing, parameter binding, and AST generation required for the macro functionality.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/overview.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.macros.Context\nimport scala.collection.mutable.{ListBuffer, Stack}\n\nobject Macros {\n  def printf(format: String, params: Any*): Unit = macro printf_impl\n\n  def printf_impl(c: Context)(format: c.Expr[String], params: c.Expr[Any]*): c.Expr[Unit] = {\n    import c.universe._\n    val Literal(Constant(s_format: String)) = format.tree\n\n    val evals = ListBuffer[ValDef]()\n    def precompute(value: Tree, tpe: Type): Ident = {\n      val freshName = TermName(c.fresh(\"eval$\"))\n      evals += ValDef(Modifiers(), freshName, TypeTree(tpe), value)\n      Ident(freshName)\n    }\n\n    val paramsStack = Stack[Tree]((params map (_.tree)): _*)\n    val refs = s_format.split(\"(?<=%[\\\\w%])|(?=%[\\\\w%])\") map {\n      case \"%d\" => precompute(paramsStack.pop, typeOf[Int])\n      case \"%s\" => precompute(paramsStack.pop, typeOf[String])\n      case \"%%\" => Literal(Constant(\"%\"))\n      case part => Literal(Constant(part))\n    }\n\n    val stats = evals ++ refs.map(ref => reify(print(c.Expr[Any](ref).splice)).tree)\n    c.Expr[Unit](Block(stats.toList, Literal(Constant(()))))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Auxiliary Constructors in Scala\nDESCRIPTION: This Scala code defines a `Person` class using a primary constructor defined in the class signature. It then adds auxiliary constructors using `def this(...) = ...`. Auxiliary constructors must call the primary constructor or another auxiliary constructor as their first action.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nclass Person (\n  var firstName: String,\n  var lastName: String,\n  var age: Int\n):\n  // zero-arg auxiliary constructor\n  def this() = this(\"\", \"\", 0)\n\n  // one-arg auxiliary constructor\n  def this(firstName: String) =\n    this(firstName, \"\", 0)\n\n  // two-arg auxiliary constructor\n  def this(\n    firstName: String,\n    lastName: String\n  ) =\n    this(firstName, lastName, 0)\n\nend Person\n```\n\n----------------------------------------\n\nTITLE: Embedding Expressions in 's' Interpolated Strings in Scala\nDESCRIPTION: Illustrates how arbitrary Scala expressions can be embedded within an `s` interpolated string using the `${expression}` syntax. The expression is evaluated, and its result is converted to a string.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/string-interpolation.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nprintln(s\"2 + 2 = ${2 + 2}\")   // \"2 + 2 = 4\"\nval x = -1\nprintln(s\"x.abs = ${x.abs}\")   // \"x.abs = 1\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Single Extension Method in Scala 3\nDESCRIPTION: Introduces the Scala 3 `extension` keyword to define a `circumference` method for the `Circle` type. The `(c: Circle)` syntax specifies the receiver parameter, allowing `circumference` to be called directly on `Circle` instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/ca-extension-methods.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nextension (c: Circle)\n  def circumference: Double = c.radius * math.Pi * 2\n```\n\n----------------------------------------\n\nTITLE: Applying Multiple Guards in Scala 'for' Loops\nDESCRIPTION: Shows how to apply multiple `if` guards sequentially within a `for` loop to implement more complex filtering logic. Compares Scala 2 and Scala 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_13\n\nLANGUAGE: Scala 2\nCODE:\n```\nfor {\n  i <- 1 to 10\n  if i > 3\n  if i < 6\n  if i % 2 == 0\n} {\n  println(i)\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nfor\n  i <- 1 to 10\n  if i > 3\n  if i < 6\n  if i % 2 == 0\ndo\n  println(i)\n```\n\n----------------------------------------\n\nTITLE: Using Generic Stack with Class Hierarchy in Scala 3\nDESCRIPTION: Provides a Scala 3 version of a class hierarchy with base class Fruit and subclasses Apple and Banana. A Stack parameterized with Fruit stores instances of subclasses, demonstrating polymorphism in generics. Elements are created using Scala 3 instantiation syntax and pushed onto the stack. Depends on the generic Stack class and standard Scala class definitions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/generic-classes.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass Fruit\nclass Apple extends Fruit\nclass Banana extends Fruit\n\nval stack = Stack[Fruit]\nval apple = Apple()\nval banana = Banana()\n\nstack.push(apple)\nstack.push(banana)\n```\n\n----------------------------------------\n\nTITLE: Creating a new Scala 3 project from a template using sbt\nDESCRIPTION: Command to generate a new Scala 3 project based on a predefined template (`scala/scala3.g8`) via sbt's `new` command, including the typical project structure and sample source files.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/tools-sbt.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt new scala/scala3.g8\n\n```\n\n----------------------------------------\n\nTITLE: Using Higher-Order Functions on List in Scala\nDESCRIPTION: Illustrates applying common functional methods (`map`, `filter`, `find`, `takeWhile`) to an immutable Scala List. These methods return new collections or Optionals based on the original list and provided anonymous functions, showcasing the functional style.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/why-scala-3.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval xs = List(1, 2, 3, 4, 5)\n\nxs.map(_ + 1)         // List(2, 3, 4, 5, 6)\nxs.filter(_ < 3)      // List(1, 2)\nxs.find(_ > 3)        // Some(4)\nxs.takeWhile(_ < 3)   // List(1, 2)\n```\n\n----------------------------------------\n\nTITLE: Iterating Using For-Comprehensions in Scala\nDESCRIPTION: Demonstrates two forms of for-comprehensions for iteration: including the upper bound with 'to' and excluding the upper bound with 'until'. Useful for sequential iteration over ranges. Requires basic Scala knowledge and standard library usage. Prints integer values from 1 to 5 or 1 to 4 respectively.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nfor (i <- 1 to 5) {\n  println(i)\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor (i <- 1 until 5) {\n  println(i)\n}\n```\n\n----------------------------------------\n\nTITLE: Extending a Class and Mixing in Traits in Scala\nDESCRIPTION: In Scala, a class extends a single class using the `extends` keyword and mixes in traits using `extends` for the first trait and `with` for subsequent traits. If not extending a class, the first trait uses `extends`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_25\n\nLANGUAGE: Scala\nCODE:\n```\nclass Dog extends Animal, HasLegs, HasTail\n```\n\n----------------------------------------\n\nTITLE: Using Option Methods with Examples in Scala\nDESCRIPTION: Simple examples showing how the Option-based makeInt method returns Some(1) for valid conversions and None for invalid input, demonstrating the basic usage pattern.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fp-functional-error-handling.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval a = makeInt(\"1\")     // Some(1)\nval b = makeInt(\"one\")   // None\n```\n\n----------------------------------------\n\nTITLE: Working with Dates in Scala using java.time Package\nDESCRIPTION: Shows how to get the current date and time in various formats using the java.time package in Scala, which offers more specialized date/time classes compared to JavaScript's Date object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\n// different ways to get the current date and time\nimport java.time.*\n\nval a = LocalDate.now\n   // 2020-11-29\nval b = LocalTime.now\n   // 18:46:38.563737\nval c = LocalDateTime.now\n   // 2020-11-29T18:46:38.563750\nval d = Instant.now\n   // 2020-11-30T01:46:38.563759Z\n```\n\nLANGUAGE: scala\nCODE:\n```\nval d = LocalDate.of(2020, 1, 21)\nval d = LocalDate.of(2020, Month.JANUARY, 21)\nval d = LocalDate.of(2020, 1, 1).plusDays(20)\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom `map` Function for `List[Int]` in Scala\nDESCRIPTION: Defines a standalone higher-order function `map` that takes a function `f` (Int => A) and a `List[Int]`, applies `f` to each element using a for-expression, and returns a new `List[A]`. Includes implementations for Scala 2 and Scala 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-write-map-function.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef map[A](f: (Int) => A, xs: List[Int]): List[A] =\n  for (x <- xs) yield f(x)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef map[A](f: (Int) => A, xs: List[Int]): List[A] =\n  for x <- xs yield f(x)\n```\n\n----------------------------------------\n\nTITLE: Defining a Date class that extends the Ord trait\nDESCRIPTION: Initial definition of a Date class that extends the Ord trait to make dates comparable. The class includes year, month, and day properties along with a custom toString implementation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_27\n\nLANGUAGE: scala\nCODE:\n```\nclass Date(y: Int, m: Int, d: Int) extends Ord {\n  def year = y\n  def month = m\n  def day = d\n  override def toString(): String = s\"$year-$month-$day\"\n\n  // rest of implementation will go here\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Date(y: Int, m: Int, d: Int) extends Ord:\n  def year = y\n  def month = m\n  def day = d\n  override def toString(): String = s\"$year-$month-$day\"\n\n  // rest of implementation will go here\nend Date\n```\n\n----------------------------------------\n\nTITLE: Declaring and Evaluating Variables in REPL - Scala\nDESCRIPTION: Shows how to declare variables and perform arithmetic expressions interactively in the Scala REPL. No external dependencies are needed; all expressions are evaluated immediately. Users input variable declarations and arithmetic operations, and the REPL prints the resulting value and inferred type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/scala-repl.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val x = 1\nx: Int = 1\n\nscala> val y = x + 1\ny: Int = 2\n```\n\n----------------------------------------\n\nTITLE: Defining Path Extension Method for '/' Operator in Scala\nDESCRIPTION: This snippet implements an extension method `/` for Java NIO `Path` objects, enabling a more intuitive operation for resolving child paths. The extension method is declared in `PathExtensions` object and imported where used. This snippet shows Scala's extension methods facilitating DSL-like usage and highlights how extension methods extend classes from external libraries seamlessly. It requires Scala 3 support and the Java NIO API (`java.nio.file.*`). The input is a `Path` instance and a child string; the output is the resolved `Path`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/multi-source-extension-overloads.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport java.nio.file.*\n\nobject PathExtensions:\n  extension (path: Path)\n    def /(child: String): Path = path.resolve(child).nn\n\ndef app1(): Unit =\n  import PathExtensions.*\n  val projectDir = Paths.get(\".\") / \"project\"\n```\n\n----------------------------------------\n\nTITLE: Destructuring Tuple Using Pattern Matching in Scala\nDESCRIPTION: Demonstrates unpacking a tuple into separate variables via pattern matching assignment. It assigns each element of the tuple (Int, String, Person) to distinct variables x, y, and z respectively, providing a concise way to extract tuple contents into named variables. Inputs are the tuple to deconstruct, outputs are assigned variables.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/tuples.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval (x, y, z) = (3, \"Three\", new Person(\"David\"))\n```\n\n----------------------------------------\n\nTITLE: Filtering Scala Map by Keys\nDESCRIPTION: This snippet demonstrates interacting with a Map's view to filter elements by a specific set of keys, then converting the result back into a Map for standard usage. It uses the filterKeys method. Expects a Map and a collection of keys to retain; returns a new Map with only those keys. Note: view-based processing may defer execution until toMap is called.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/collections-maps.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval twoAndThree = m.view.filterKeys(Set(2,3)).toMap\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Examples of ArrayBuffer Usage in Scala\nDESCRIPTION: Provides a collection of methods for working with ArrayBuffer, such as appending, inserting, prepending, removing, and dropping elements, with code snippets demonstrating each operation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/arraybuffer-examples.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval a = ArrayBuffer(1, 2, 3)\n// append single element\n a.append(4)\n// append multiple elements\n a.appendAll(Seq(5, 6))\n// clear ArrayBuffer\n a.clear\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval a = ArrayBuffer(9, 10)\n// insert element at index\n a.insert(0, 8)\n// insert multiple elements at index\n a.insertAll(0, Vector(4, 5, 6, 7))\n// prepend elements\n a.prepend(3)\n// prepend multiple elements\n a.prependAll(Array(0, 1, 2))\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// remove element at index\n val a = ArrayBuffer.range('a', 'h')\n a.remove(0)\n// remove multiple elements starting at index\n a.remove(2, 3)\n// drop elements in place from start\n a.dropInPlace(2)\n// drop elements in place from end\n a.dropRightInPlace(2)\n```\n\n----------------------------------------\n\nTITLE: Defining & Using Extractor Object with Pattern Matching - Scala 2\nDESCRIPTION: Defines a Scala 2 object `CustomerID` as an extractor with `apply` for creating IDs and `unapply` for extracting the name from an ID string. Demonstrates using the extractor in a pattern match, where `unapply` is implicitly called to deconstruct the input string.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/extractor-objects.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.util.Random\n\nobject CustomerID {\n\n  def apply(name: String) = s\"$name--${Random.nextLong()}\"\n\n  def unapply(customerID: String): Option[String] = {\n    val stringArray: Array[String} = customerID.split(\"--\")\n    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None\n  }\n}\n\nval customer1ID = CustomerID(\"Sukyoung\")  // Sukyoung--23098234908\ncustomer1ID match {\n  case CustomerID(name) => println(name)  // prints Sukyoung\n  case _ => println(\"Could not extract a CustomerID\")\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Trait with Abstract and Concrete Members - Scala\nDESCRIPTION: Shows that Scala traits can contain both abstract members (without implementation) and concrete members (with implementation), providing default behavior that classes can inherit.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_27\n\nLANGUAGE: Scala 2\nCODE:\n```\ntrait HasLegs {\n  def numLegs: Int\n  def walk(): Unit\n  def stop() = println(\"Stopped walking\")\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ntrait HasLegs:\n  def numLegs: Int\n  def walk(): Unit\n  def stop() = println(\"Stopped walking\")\n```\n\n----------------------------------------\n\nTITLE: Mocking an Asynchronous, Random-delay Stock Price Lookup with Futures in Scala\nDESCRIPTION: Implements a mocked version of getStockPrice that sleeps for a random duration and returns a random price. Utilizes scala.util.Random, sleep, and the Future API. Requires ExecutionContext and standard Scala/Java library access. Inputs: stockSymbol; Output: Future[Double] containing a random price after a random delay.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/futures.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ndef getStockPrice(stockSymbol: String): Future[Double] = Future {\n    val r = scala.util.Random\n    val randomSleepTime = r.nextInt(3000)\n    val randomPrice = r.nextDouble * 1000\n    sleep(randomSleepTime)\n    randomPrice\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Implicit Parameters for Generic Comparison in Scala 2\nDESCRIPTION: Defines a 'Comparator' trait and provides implicit instances for 'Int' and 'String' within its companion object. Implements a generic 'max' function that requires an implicit 'Comparator[A]'. Demonstrates calling 'max' with 'Int' and 'String' arguments, showing how Scala 2 automatically resolves and provides the appropriate implicit 'Comparator' instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/implicit-parameters.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Comparator[A] {\n  def compare(x: A, y: A): Int\n}\n\nobject Comparator {\n  implicit object IntComparator extends Comparator[Int] {\n    def compare(x: Int, y: Int): Int = Integer.compare(x, y)\n  }\n\n  implicit object StringComparator extends Comparator[String] {\n    def compare(x: String, y: String): Int = x.compareTo(y)\n  }\n}\n\ndef max[A](x: A, y: A)(implicit comparator: Comparator[A]): A =\n  if (comparator.compare(x, y) >= 0) x\n  else y\n\nprintln(max(10, 6))             // 10\nprintln(max(\"hello\", \"world\"))  // world\n```\n\n----------------------------------------\n\nTITLE: Defining Function Returning Future in Scala\nDESCRIPTION: Shows the signature of a function (`getStockPrice`) that returns a `Future[Double]`. The `Future { ... }` construct is used to wrap the asynchronous computation (represented by `...`) within a `Future` container, indicating that the result (`Double`) will be available later.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/futures.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ndef getStockPrice(stockSymbol: String): Future[Double] = Future { ...\n```\n\n----------------------------------------\n\nTITLE: Concrete Implementation of PizzaServiceInterface in Scala\nDESCRIPTION: This snippet provides a concrete object PizzaService implementing the PizzaServiceInterface, defining behavior for each method declared in the trait. It uses immutable copy operations on Pizza instances to add or remove toppings and update crust properties, returning new modified Pizza objects. The pricing method is declared but details are omitted with ellipsis. Both Scala 2 and Scala 3 syntax versions are shown.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-fp.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nobject PizzaService extends PizzaServiceInterface {\n\n  def price(p: Pizza): Double =\n    ... // implementation from above\n\n  def addTopping(p: Pizza, t: Topping): Pizza =\n    p.copy(toppings = p.toppings :+ t)\n\n  def removeAllToppings(p: Pizza): Pizza =\n    p.copy(toppings = Seq.empty)\n\n  def updateCrustSize(p: Pizza, cs: CrustSize): Pizza =\n    p.copy(crustSize = cs)\n\n  def updateCrustType(p: Pizza, ct: CrustType): Pizza =\n    p.copy(crustType = ct)\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nobject PizzaService extends PizzaServiceInterface:\n\n  def price(p: Pizza): Double =\n    ... // implementation from above\n\n  def addTopping(p: Pizza, t: Topping): Pizza =\n    p.copy(toppings = p.toppings :+ t)\n\n  def removeAllToppings(p: Pizza): Pizza =\n    p.copy(toppings = Seq.empty)\n\n  def updateCrustSize(p: Pizza, cs: CrustSize): Pizza =\n    p.copy(crustSize = cs)\n\n  def updateCrustType(p: Pizza, ct: CrustType): Pizza =\n    p.copy(crustType = ct)\n\nend PizzaService\n```\n\n----------------------------------------\n\nTITLE: Scala 2 Implementation of 'Ord' trait and 'max' function using implicit\nDESCRIPTION: Defines the 'Ord' type class trait with a 'greaterThan' method, and a 'max' function that returns the larger of two values based on comparison. Both use implicit parameters in Scala 2, relying on implicit resolution to supply the 'Ord[A]' instance. This setup enables comparison operations for generic types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-context-bounds.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n/** Defines how to compare values of type `A` */\ntrait Ord[A] {\n  def greaterThan(a1: A, a2: A): Boolean\n}\n\n/** Returns the maximum of two values */\ndef max[A](a1: A, a2: A)(implicit ord: Ord[A]): A =\n  if (ord.greaterThan(a1, a2)) a1 else a2\n```\n\n----------------------------------------\n\nTITLE: Defining a Higher-Order Method That Executes a Function Multiple Times in Scala 2 and 3\nDESCRIPTION: Defines a method executeNTimes accepting two parameters: a parameter f of type () => Unit (a function taking no parameters and returning Unit), and an integer n specifying how many times to execute the function. The method uses a for-loop to call f n times and returns Unit. Two syntaxes are shown: Scala 2 uses curly braces and arrows, Scala 3 demonstrates streamlined syntax with 'do'. This snippet illustrates combining functional parameters with data arguments to perform repeated actions. Dependencies include core Scala libraries. Inputs are a function f and the integer n, output is Unit after executing f repeatedly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-hofs.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef executeNTimes(f: () => Unit, n: Int): Unit =\n  for (i <- 1 to n) f()\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef executeNTimes(f: () => Unit, n: Int): Unit =\n  for i <- 1 to n do f()\n```\n\n----------------------------------------\n\nTITLE: Defining RNA Base Types and Integer Mapping - Scala 3\nDESCRIPTION: Defines the four RNA bases using a Scala 3 enum (A, U, G, C) and provides a companion object with functions to convert between bases and their integer ordinal positions for efficient bidirectional mapping. The toInt method uses ordinal values auto-supplied by enums, and fromInt accesses the enum's values array; both enable performant and type-safe encoding of biological sequences. Uses only standard Scala 3 features, accepts an Int 0..3 or a Base value. Designed for compact storage, only handles the four canonical bases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_9\n\nLANGUAGE: Scala 3\nCODE:\n```\nenum Base:\n  case A, U, G, C\n\nobject Base:\n  val fromInt: Int => Base = values\n  val toInt: Base => Int = _.ordinal\n```\n\n----------------------------------------\n\nTITLE: Anonymous Functions in Scala\nDESCRIPTION: Shows how to define and use anonymous functions in Scala, including both long-form and short-form syntax for common higher-order functions like map and filter on collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\n// a function (an anonymous function assigned to a variable)\nval log = (s: String) => console.log(s)\n\n// a scala method. methods tend to be used much more often,\n// probably because they're easier to read.\ndef log(a: Any) = console.log(a)\n\n// a function or a method can be passed into another\n// function or method\ndef printA(a: Any, f: log: Any => Unit) = log(a)\n```\n\nLANGUAGE: scala\nCODE:\n```\n// map method, long form\nList(1,2,3).map(i => i * 10)   // List(10,20,30)\n\n// map, short form (which is more commonly used)\nList(1,2,3).map(_ * 10)        // List(10,20,30)\n\n// filter, short form\nList(1,2,3).filter(_ < 3)      // List(1,2)\n\n// filter and then map\nList(1,2,3,4,5).filter(_ < 3).map(_ * 10)   // List(10, 20)\n```\n\n----------------------------------------\n\nTITLE: Defining Functions With Parameters and Return Values in Scala\nDESCRIPTION: Shows examples of methods named add, subtract, and multiply that each take two Int parameters and return an Int result. These functions match the signature (Int, Int) => Int and illustrate how to define functions with input parameters and a return value, forming signatures suitable for higher-order functions expecting such signatures. These methods rely on basic Scala standard library and do not have external dependencies. Inputs are two integers and output is an integer result of the respective arithmetic operation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-hofs.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef add(a: Int, b: Int): Int = a + b\ndef subtract(a: Int, b: Int): Int = a - b\ndef multiply(a: Int, b: Int): Int = a * b\n```\n\n----------------------------------------\n\nTITLE: Basic Class Composition with Mixins (Scala)\nDESCRIPTION: Demonstrates simple class composition where class D extends superclass B and mixes in trait C. Shows how methods and values are inherited and accessed through the composed instance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/mixin-class-composition.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class A {\n  val message: String\n}\nclass B extends A {\n  val message = \"I'm an instance of class B\"\n}\ntrait C extends A {\n  def loudMessage = message.toUpperCase()\n}\nclass D extends B with C\n\nval d = new D\nprintln(d.message)  // I'm an instance of class B\nprintln(d.loudMessage)  // I'M AN INSTANCE OF CLASS B\n```\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class A:\n  val message: String\nclass B extends A:\n  val message = \"I'm an instance of class B\"\ntrait C extends A:\n  def loudMessage = message.toUpperCase()\nclass D extends B, C\n\nval d = D()\nprintln(d.message)  // I'm an instance of class B\nprintln(d.loudMessage)  // I'M AN INSTANCE OF CLASS B\n```\n\n----------------------------------------\n\nTITLE: Iterating Over List Elements Using for Loop in Scala\nDESCRIPTION: Shows Scala 'for' loop iterating over a collection 'ints' with the generator '<-', printing each element. Demonstrates idiomatic Scala collection iteration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\nfor i <- ints do println(i)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using PrefixMap in Scala REPL\nDESCRIPTION: This snippet demonstrates the usage of a custom `PrefixMap` collection in the Scala REPL. It first creates an instance `m` of `PrefixMap` initialized with string keys and integer values. Then, it calls the `withPrefix` method on `m` with the prefix \"a\" to create a new `PrefixMap` containing only the key-value pairs whose keys start with \"a\", illustrating the prefix-based filtering feature.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-collections.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val m = PrefixMap(\"abc\" -> 0, \"abd\" -> 1, \"al\" -> 2,\n         \"all\" -> 3, \"xy\" -> 4)\nm: PrefixMap[Int] = Map((abc,0), (abd,1), (al,2), (all,3), (xy,4))\n\nscala> m withPrefix \"a\"\nres14: PrefixMap[Int] = Map((bc,0), (bd,1), (l,2), (ll,3))\n```\n\n----------------------------------------\n\nTITLE: Package management in Scala\nDESCRIPTION: Demonstrates different approaches to importing and managing packages in Scala, including wildcard imports, selective imports, renaming, and package declarations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection._\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.Vector\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.{Vector, Sequence}\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.{Vector => Vec28}\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport java.util.{Date => _, _}\n```\n\nLANGUAGE: scala\nCODE:\n```\npackage pkg\n```\n\nLANGUAGE: scala\nCODE:\n```\npackage pkg {\n  ...\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\npackage object pkg {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Lists with Scala List Class - Scala\nDESCRIPTION: This snippet demonstrates how to create immutable Scala Lists with both inferred and explicitly specified element types. No external dependencies are required. Lists can be initialized with mixed or homogeneous elements, and both approaches show how to store integers and strings within a typed immutable collection. Inputs are static values and outputs are List instances assigned to variables.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/list-class.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval ints = List(1, 2, 3)\nval names = List(\"Joel\", \"Chris\", \"Ed\")\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval ints: List[Int] = List(1, 2, 3)\nval names: List[String] = List(\"Joel\", \"Chris\", \"Ed\")\n```\n\n----------------------------------------\n\nTITLE: Interacting with Java Libraries in Scala\nDESCRIPTION: Demonstrates Scala's seamless Java interoperability by importing and using Java's `Date`, `Locale`, and `DateFormat` classes to format the current date according to French locale conventions. Highlights Scala's import syntax (multiple classes, wildcard `_`) and infix notation for single-argument methods (`df format now`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tutorials/scala-for-java-programmers.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport java.util.{Date, Locale}\nimport java.text.DateFormat\nimport java.text.DateFormat._\n\nobject FrenchDate {\n  def main(args: Array[String]): Unit = {\n    val now = new Date\n    val df = getDateInstance(LONG, Locale.FRANCE)\n    println(df format now)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Partial Application and Reuse with foldLeft in Scala\nDESCRIPTION: This code demonstrates partially applying the first argument of foldLeft to create a reusable function, numberFunc, for accumulating over a list. The snippet then uses this function to generate lists of squares and cubes by supplying different binary operations. This approach leverages currying for functional reuse. Inputs are the accumulation functions; outputs are lists of squared and cubed numbers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/multiple-parameter-lists.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nval numberFunc = numbers.foldLeft(List[Int]())_\n\nval squares = numberFunc((xs, x) => xs:+ x*x)\nprint(squares.toString()) // List(1, 4, 9, 16, 25, 36, 49, 64, 81, 100)\n\nval cubes = numberFunc((xs, x) => xs:+ x*x*x)\nprint(cubes.toString())  // List(1, 8, 27, 64, 125, 216, 343, 512, 729, 1000)\n```\n\n----------------------------------------\n\nTITLE: Différentes méthodes promotionnelles utilisant map en Scala\nDESCRIPTION: Définit un objet SalaryRaiser avec trois méthodes qui donnent différentes promotions aux salaires en utilisant la fonction map. Chaque méthode applique un calcul unique sur chaque salaire, exposant une redondance dans la logique. Entrée: List[Double] des salaires; sortie: List[Double] transformée en fonction de la promotion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tour/higher-order-functions.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nobject SalaryRaiser {\n\n  def smallPromotion(salaries: List[Double]): List[Double] =\n    salaries.map(salary => salary * 1.1)\n\n  def greatPromotion(salaries: List[Double]): List[Double] =\n    salaries.map(salary => salary * math.log(salary))\n\n  def hugePromotion(salaries: List[Double]): List[Double] =\n    salaries.map(salary => salary * salary)\n}\n```\n\n----------------------------------------\n\nTITLE: Using andThen combinator for side-effecting operations on Futures in Scala 3\nDESCRIPTION: Scala 3 version of the prior andThen chaining example. Uses dot notation for 'andThen' and concise 'for' comprehension to render posts from a mutable set after asynchronously fetching recent posts. Maintains the original Future's result while scheduling side-effecting callbacks orderly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\nval allPosts = mutable.Set[String]()\n\nFuture {\n  session.getRecentPosts()\n}.andThen {\n  case Success(posts) => allPosts ++= posts\n}.andThen {\n  case _ =>\n    clearAll()\n    for post <- allPosts do render(post)\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Companion Object for a Class in Scala\nDESCRIPTION: This snippet defines a class `IntPair` with two integer members, and a companion object that provides an implicit ordering instance. It illustrates how companion objects can contain type class instances like implicit `Ordering`, which are automatically considered during implicit resolution. The example emphasizes that companion objects should be in the same source file as their class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/singleton-objects.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass IntPair(val x: Int, val y: Int)\n\nobject IntPair {\n  import math.Ordering\n\n  implicit def ipord: Ordering[IntPair] =\n    Ordering.by(ip => (ip.x, ip.y))\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Topping Price with Pattern Matching in Scala\nDESCRIPTION: Defines a function `toppingPrice` that calculates the price for a single `Topping`. It uses pattern matching on the `Topping` enumeration variants to return a fixed price (0.50 or 0.75) based on the specific topping type. Requires the `Topping` enumeration to be defined.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-fp.md#_snippet_5\n\nLANGUAGE: Scala 2\nCODE:\n```\ndef toppingPrice(t: Topping): Double = t match {\n  case Cheese | Onions => 0.5\n  case Pepperoni | BlackOlives | GreenOlives => 0.75\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ndef toppingPrice(t: Topping): Double = t match\n  case Cheese | Onions => 0.5\n  case Pepperoni | BlackOlives | GreenOlives => 0.75\n```\n\n----------------------------------------\n\nTITLE: Defining a Curried foldLeft Method in Scala\nDESCRIPTION: This snippet demonstrates the declaration of the curried foldLeft method as commonly found in Scala collections such as TraversableOnce. The method applies a binary operation 'op' to an initial seed value 'z' and each element of the collection from left to right. The first parameter list receives the initial value, and the second is a function defining the binary operation. Requires a collection supporting foldLeft, and functions as a core utility for reducing data structures. Inputs are the initial value and the binary operation function; output is the accumulated result. No concrete implementation is shown.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/multiple-parameter-lists.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef foldLeft[B](z: B)(op: (B, A) => B): B\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Tuples in for Comprehension (Scala 3)\nDESCRIPTION: Explains how to destructure tuples in a for-do comprehension using Scala 3 syntax. No additional dependencies are necessary. 'numPairs' is a list of integer pairs, and each tuple is unpacked into 'a' and 'b', whose product is printed. This syntax adds readability through indentation and pattern binding.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/tuples.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval numPairs = List((2, 5), (3, -7), (20, 56))\nfor (a, b) <- numPairs do\n  println(a * b)\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Scala Union Types\nDESCRIPTION: Demonstrates defining case classes `Username` and `Password` and a `help` method that accepts a parameter `id` of the union type `Username | Password`. The method uses pattern matching to differentiate and handle the specific type received.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-union.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Username(name: String)\ncase class Password(hash: Hash)\n\ndef help(id: Username | Password) =\n  val user = id match\n    case Username(name) => lookupName(name)\n    case Password(hash) => lookupPassword(hash)\n  // more code here ...\n```\n\n----------------------------------------\n\nTITLE: Iterating Over List of Tuple Pairs with Pattern Matching in For Loop\nDESCRIPTION: Demonstrates iterating over a list of integer pairs using a for loop with pattern matching to compute and print the product of each pair.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/tuples.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval numPairs = List((2, 5), (3, -7), (20, 56))\nfor ((a, b) <- numPairs) {\n  println(a * b)\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating a Class in Scala\nDESCRIPTION: Shows how to create an instance of the `MyService` class. Highlights the difference in instantiation syntax between Scala 2 (`new MyService(...)`) and Scala 3 (`MyService(...)`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-oop.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval s1: MyService = new MyService(\"Service 1\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nval s1: MyService = MyService(\"Service 1\")\n```\n\n----------------------------------------\n\nTITLE: Performing Sequence Operations on Strings in Scala 2 and 3\nDESCRIPTION: This snippet shows how to use common sequence operations on strings in Scala, such as reversing, mapping characters to uppercase, dropping characters, slicing substrings, and converting a string to a sequence of characters. It depends on Scala's implicit conversions that convert strings to StringOps or WrappedString, enabling these methods. Input strings are simple string literals, and outputs are transformed strings or character sequences reflecting the operation applied.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/strings.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nscala> val str = \"hello\"\nval str: java.lang.String = hello\n\nscala> str.reverse\nval res6: String = olleh\n\nscala> str.map(_.toUpper)\nval res7: String = HELLO\n\nscala> str.drop(3)\nval res8: String = lo\n\nscala> str.slice(1, 4)\nval res9: String = ell\n\nscala> val s: Seq[Char] = str\nval s: Seq[Char] = hello\n```\n\n----------------------------------------\n\nTITLE: Package Import Variants in Scala\nDESCRIPTION: Illustrates different methods for importing packages or specific entities within packages, including full import, selective import, renaming, and excluding certain classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/cheatsheets/index.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection._\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.Vector\nimport scala.collection.{Vector, Sequence}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.{Vector => Vec28}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport java.util.{Date => _, _}\n```\n\nLANGUAGE: Scala\nCODE:\n```\npackage pkg {\n  ...\n}\n\npackage object pkg {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Nested Packages in One Scala 3 File Using Colon Notation - Scala\nDESCRIPTION: Shows how to create nested packages within a single Scala file using Scala 3’s colon-based indentation syntax. Each nested package introduces its own scope for definitions, allowing distinct classes to belong to sub-packages nested under a parent package declared with indentation. This approach improves code modularization and scope control within a single source file. Requires Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/packaging-imports.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\npackage users:\n\n  package administrators:  // full package name: users.administrators\n    class AdminUser        // full class name: users.administrators.AdminUser\n\n  package normalusers:     // full package name: users.normalusers\n    class NormalUser       // full class name: users.normalusers.NormalUser\n```\n\n----------------------------------------\n\nTITLE: Adding Library Dependency in sbt - Scala\nDESCRIPTION: Adds the 'library-example' dependency to the build.sbt file using the correct version via variable substitution. Requires sbt build tool and variable injection for version number. Expects a valid project.version variable; outputs an updated libraryDependencies setting. Limitation: Ensure $project.version$ gets correctly replaced during documentation/site generation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"ch.epfl.scala\" %% \"library-example\" % \"$project.version$\"\n```\n\n----------------------------------------\n\nTITLE: Определение неизменяемых и изменяемых переменных в Scala\nDESCRIPTION: Демонстрирует объявление неизменяемой переменной `a` с помощью `val` и изменяемой переменной `b` с помощью `var`. Scala выводит тип (`Int`) для обеих переменных.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-vars-data-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// неизменяемая\nval a = 0\n\n// изменяемая\nvar b = 1\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Using a Class in Scala 3\nDESCRIPTION: Illustrates instance creation without the new keyword due to Scala 3 universal apply method. Shows usage of custom classes in modern Scala style.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\nval greeter = Greeter(\"Hello, \", \"!\")\ngreeter.greet(\"Scala developer\") // Hello, Scala developer!\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Trait 'Pet' with Parameters\nDESCRIPTION: This snippet exemplifies defining a trait 'Pet' with constructor parameters in Scala 3. Classes implementing this trait can pass parameters directly, enabling more flexible trait-based behavior sharing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Pet(name: String):\n  def greeting: String\n  def age: Int\n  override def toString = s\"My name is $name, I say $greeting, and I’m $age\"\n\nclass Dog(name: String, var age: Int) extends Pet(name):\n  val greeting = \"Woof\"\n\nval d = Dog(\"Fido\", 1)\n```\n\n----------------------------------------\n\nTITLE: Additional Collection Operations distinctBy and partitionMap in Scala Collections - Scala\nDESCRIPTION: This snippet introduces two additional collection operations: distinctBy and partitionMap. distinctBy takes a function that projects elements to keys and returns a collection of elements with distinct keys as determined by the projection function. The return type C can be any collection type like List. partitionMap accepts a function returning an Either type and splits the collection into two collections containing values from the Left and Right cases respectively, returning a tuple of collections of types CC[A1] and CC[A2]. These methods enhance data partitioning and transformation capabilities within collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/collections-migration-213.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ndef distinctBy[B](f: A => B): C // `C` can be `List[Int]`, for instance\ndef partitionMap[A1, A2](f: A => Either[A1, A2]): (CC[A1], CC[A2]) // `CC` can be `List`, for instance\n```\n\n----------------------------------------\n\nTITLE: Using `inline if` for Compile-Time Branching in Scala\nDESCRIPTION: Revises the `power` function to use `inline if`. This construct guarantees that the condition is evaluated at compile time. If the condition is a compile-time constant, the appropriate branch is selected and inlined; otherwise, a compile-time error occurs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\ninline def power(x: Double, inline n: Int): Double =\n  inline if (n == 0) 1.0\n  else inline if (n % 2 == 1) x * power(x, n - 1)\n  else power(x * x, n / 2)\n```\n\n----------------------------------------\n\nTITLE: Standard sbt project directory structure\nDESCRIPTION: Hierarchical layout of files and folders that sbt uses to organize source code, resources, dependencies, and build artifacts for a Scala project, following common conventions for easy project management.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/tools-sbt.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n.\n├── build.sbt\n├── project/\n│   └── build.properties\n├── src/\n│   ├── main/\n│   │   ├── java/\n│   │   ├── resources/\n│   │   └── scala/\n│   └── test/\n│       ├── java/\n│       ├── resources/\n│       └── scala/\n└── target/\n```\n\n----------------------------------------\n\nTITLE: Creating Generic Array Function with ClassManifest (Scala 2.8+) in Scala\nDESCRIPTION: This updated Scala `tabulate` function works in Scala 2.8+ by requiring runtime type information via an implicit `ClassManifest[T]` parameter. The `ClassManifest` provides the necessary details to instantiate the correct underlying array representation (e.g., `int[]` for `Array[Int]`). The compiler automatically supplies this manifest when calling `tabulate` with a known type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/scala-2-8-arrays.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef tabulate[T](len: Int, f: Int => T)(implicit m: ClassManifest[T]) = {\n\tval xs = new Array[T](len)\n\tfor (i <- 0 until len) xs(i) = f(i)\n\txs\n}\n```\n\n----------------------------------------\n\nTITLE: Appending Multiple Elements to Buffer in Scala\nDESCRIPTION: Appends a sequence of elements (x, y, z, etc.) to the end of the buffer 'buf'. This operator provides a convenient way to add several individual elements at once.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/seqs.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nbuf += (x, y, z)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Class Initialization and Method Call in Scala 2 REPL\nDESCRIPTION: This REPL session demonstrates instantiating the `Person` class defined with a body in Scala 2 using `new`, showing the initialization output and the result of calling the `printFullName` method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val john = new Person(\"John\", \"Doe\")\ninitialization begins\nJohn Doe\ninitialization ends\nval john: Person = Person@55d8f6bb\n\nscala> john.printFullName\nJohn Doe\n```\n\n----------------------------------------\n\nTITLE: Defining Method with Implicit/Using Parameter List in Scala\nDESCRIPTION: Defines a method `execute` that takes a standard argument `arg` in the first parameter list and an `implicit` (Scala 2) or `using` (Scala 3) parameter `ec` of type `scala.concurrent.ExecutionContext` in the second list. This pattern allows the compiler to automatically provide the parameter if an instance is available in the scope.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/multiple-parameter-lists.md#_snippet_6\n\nLANGUAGE: Scala 2\nCODE:\n```\ndef execute(arg: Int)(implicit ec: scala.concurrent.ExecutionContext) = ???\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ndef execute(arg: Int)(using ec: scala.concurrent.ExecutionContext) = ???\n```\n\n----------------------------------------\n\nTITLE: For loops with conditional filtering in Java vs Scala\nDESCRIPTION: Demonstrates how Scala can add guard conditions directly in for loops, making filtering more concise compared to Java's approach with if statements inside the loop.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_43\n\nLANGUAGE: Java\nCODE:\n```\nList ints = \n  ArrayList(1,2,3,4,5,6,7,8,9,10);\n\nfor (int i: ints) {\n  if (i % 2 == 0 && i < 5) {\n    System.out.println(x);\n  }\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor\n  i <- 1 to 10\n  if i % 2 == 0\n  if i < 5\ndo\n  println(i)\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple Interfaces with Default Methods in Java\nDESCRIPTION: Defines two Java interfaces, Adder and Multiplier, each with default methods add and multiply respectively. Then demonstrates a class JavaMath implementing both interfaces to inherit these default method implementations with no additional code. The snippet shows usage by calling add and multiply on a JavaMath instance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_24\n\nLANGUAGE: java\nCODE:\n```\ninterface Adder {\n  default int add(int a, int b) {\n    return a + b;\n  }\n}\n\ninterface Multiplier {\n  default int multiply (\n    int a,\n    int b)\n  {\n    return a * b;\n  }\n}\n\npublic class JavaMath \nimplements Adder, Multiplier {}\n\nJavaMath jm = new JavaMath();\njm.add(1,1);\njm.multiply(2,2);\n```\n\n----------------------------------------\n\nTITLE: Correctly Handling Generic Types in Quoted Code with `Type[T]`\nDESCRIPTION: Shows the correct way to handle abstract type parameters `T` within quoted code. By adding `(using Type[T])` as a context bound, we provide the necessary information for the compiler to represent the type `T` within the generated code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef evalAndUse[T](x: Expr[T])(using Type[T])(using Quotes) = '{\n  val x2: T = $x\n  ... // use x2\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing dictionary/map elements in Python and Scala\nDESCRIPTION: Demonstrates element access in associative collections. Python uses square brackets with keys for dictionary lookup. Scala also uses parentheses with keys to access values in a Map. Highlights syntactic convention differences.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_57\n\nLANGUAGE: python\nCODE:\n```\nmy_dict['a']  # 1\n```\n\nLANGUAGE: scala\nCODE:\n```\nmyMap(\"a\")  // 1\n```\n\n----------------------------------------\n\nTITLE: Defining Covariant Immutable Stack in Scala\nDESCRIPTION: Defines a generic, immutable Stack class with a covariant type parameter \"+T\". It includes a polymorphic push method where the type parameter S has a lower bound of T to preserve covariance while allowing elements of supertype to be pushed. The class uses anonymous subclassing to create updated stacks with overridden top, pop, and toString methods. The Stack's top and pop methods throw errors if called on an empty stack. This snippet demonstrates advanced use of variance annotations alongside polymorphic methods and type bounds in Scala 2/3, with no external dependencies besides Scala standard library.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/variances.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Stack[+T] {\n  def push[S >: T](elem: S): Stack[S] = new Stack[S] {\n    override def top: S = elem\n    override def pop: Stack[S] = Stack.this\n    override def toString: String =\n      elem.toString + \" \" + Stack.this.toString\n  }\n  def top: T = sys.error(\"no element on stack\")\n  def pop: Stack[T] = sys.error(\"no element on stack\")\n  override def toString: String = \"\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Splitter for a Custom Parallel Sequence (Scala)\nDESCRIPTION: Implements the `ParStringSplitter` class, extending `SeqSplitter[Char]`, required by the `ParString` collection. It provides standard iterator methods (`hasNext`, `next`), calculates remaining elements (`remaining`), allows duplication (`dup`), and implements splitting logic (`split`, `psplit`) necessary for parallel task distribution.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/custom-parallel-collections.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass ParStringSplitter(private var s: String, private var i: Int, private val ntl: Int)\nextends SeqSplitter[Char] {\n\n  final def hasNext = i < ntl\n\n  final def next = {\n    val r = s.charAt(i)\n    i += 1\n    r\n  }\n\n  def remaining = ntl - i\n\n  def dup = new ParStringSplitter(s, i, ntl)\n\n  def split = {\n    val rem = remaining\n    if (rem >= 2) psplit(rem / 2, rem - rem / 2)\n    else Seq(this)\n  }\n\n  def psplit(sizes: Int*): Seq[ParStringSplitter] = {\n    val splitted = new ArrayBuffer[ParStringSplitter]\n    for (sz <- sizes) {\n      val next = (i + sz) min ntl\n      splitted += new ParStringSplitter(s, i, next)\n      i = next\n    }\n    if (remaining > 0) splitted += new ParStringSplitter(s, i, ntl)\n    splitted\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Abstract Type Member in a Trait - Scala 2\nDESCRIPTION: Defines a trait 'Buffer' with an abstract type member 'T' and an abstract value 'element' of type 'T'. This pattern allows subclasses to concretize 'T' in their implementations. Does not require external dependencies, and no specific inputs or outputs are defined at this stage.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/abstract-type-members.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Buffer {\n  type T\n  val element: T\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Single Trait Scala\nDESCRIPTION: Demonstrates creating a Scala class `Dog` that implements the `TailWagger` trait. It shows how to use the `extends` keyword to inherit from a single trait and provide concrete implementations for the `startTail` and `stopTail` methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/traits-interfaces.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass Dog extends TailWagger {\n    // the implemented methods\n    def startTail(): Unit = println(\"tail is wagging\")\n    def stopTail(): Unit = println(\"tail is stopped\")\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass Dog extends TailWagger {\n    def startTail() = println(\"tail is wagging\")\n    def stopTail() = println(\"tail is stopped\")\n}\n```\n\n----------------------------------------\n\nTITLE: Подготовка переменных для примера интерполяции строк в Scala\nDESCRIPTION: Объявляет переменные `String` и `Char` (`firstName`, `mi`, `lastName`), которые используются в последующих примерах интерполяции строк.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-vars-data-types.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval firstName = \"John\"\nval mi = 'C'\nval lastName = \"Doe\"\n```\n\n----------------------------------------\n\nTITLE: Parser Type Class with Associated Types\nDESCRIPTION: Definition of a Parser type class with associated type members for Input and Result, demonstrating a use case for context bounds with type members.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ntrait Parser[P]:\n  type Input\n  type Result\n```\n\n----------------------------------------\n\nTITLE: Creating an Instance with None for Optional Field in Scala 2\nDESCRIPTION: An example showing how to create an Address instance with None for the optional street2 field in Scala 2, properly indicating the absence of a value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fp-functional-error-handling.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval santa = new Address(\n  \"1 Main Street\",\n  None,           // 'street2' не имеет значения\n  \"North Pole\",\n  \"Alaska\",\n  \"99705\"\n)\n```\n\n----------------------------------------\n\nTITLE: Running Partest from sbt Console - Shell\nDESCRIPTION: Runs the full Scala test suite (Partest) using the sbt interactive shell. No additional dependencies are required beyond a local clone of the Scala repository and sbt installed. This command executes all configured tests; for partial runs, specify test names as arguments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/partest-guide.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nsbt:root> partest\n```\n\n----------------------------------------\n\nTITLE: Assigning Match Expression Result (Scala 2)\nDESCRIPTION: Shows how a `match` expression in Scala 2 can return a value which is assigned to a variable, illustrating its use as a true expression, not just a statement. Matches integer values and returns corresponding string representations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\nval result = i match {\n  case 1 => \"one\"\n  case 2 => \"two\"\n  case _ => \"other\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Case Class in Scala\nDESCRIPTION: This snippet demonstrates defining a case class called Person with immutable fields, creating an instance, accessing its properties, attempting reassignment (which fails), and using the copy method to create an updated instance. Dependencies: None (requires standard Scala runtime). Parameters include constructor fields (name and vocation). Inputs are the Strings used for instance creation, and outputs are Person objects with the specified values. This showcases case class default methods and their constraints (fields are vals, so reassignment fails).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-modeling.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\n// define a case class\ncase class Person(\n  name: String,\n  vocation: String\n)\n\n// create an instance of the case class\nval p = Person(\"Reginald Kenneth Dwight\", \"Singer\")\n\n// a good default toString method\np                // : Person = Person(Reginald Kenneth Dwight,Singer)\n\n// can access its fields, which are immutable\np.name           // \"Reginald Kenneth Dwight\"\np.name = \"Joe\"   // error: can’t reassign a val field\n\n// when you need to make a change, use the `copy` method\n// to “update as you copy”\nval p2 = p.copy(name = \"Elton John\")\np2               // : Person = Person(Elton John,Singer)\n```\n\n----------------------------------------\n\nTITLE: Declaring Default Closed Class in Scala 3\nDESCRIPTION: Scala classes are closed (final) by default; this snippet declares a standard class Person without 'open' modifier, implying it is not designed for subclassing. This follows recommended practice to design for inheritance or forbid it explicitly, enhancing code safety.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nclass Person\n```\n\n----------------------------------------\n\nTITLE: Using the `raw` Interpolator to Ignore Escape Sequences in Scala\nDESCRIPTION: Introduces the `raw` string interpolator in Scala, which does not process escape sequences like `\\n`. The backslash and the character following it are treated as literal characters in the resulting string.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nscala> raw\"a\\nb\"\nres1: String = a\\nb\n```\n\n----------------------------------------\n\nTITLE: Variable Name vs. Value Pattern Matching in Scala\nDESCRIPTION: These snippets illustrate subtle distinctions in Scala pattern matching regarding variable name interpretation. Without backticks, a variable name in a pattern is treated as a fresh variable binding, matching any value, which can lead to unintended matches. Using backticks (e.g., `v42`) forces the pattern to match the value of an existing variable. Additionally, uppercase variable names are treated as stable identifiers, matching the variable's value. These nuances affect matching behavior and output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/cheatsheets/index.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nval v42 = 42\n24 match {\n  case v42 => println(\"42\")\n  case _   => println(\"Not 42\")\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval v42 = 42\n24 match {\n  case `v42` => println(\"42\")\n  case _     => println(\"Not 42\")\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval UppercaseVal = 42\n24 match {\n  case UppercaseVal => println(\"42\")\n  case _            => println(\"Not 42\")\n}\n```\n\n----------------------------------------\n\nTITLE: Proposed Syntax: Initial Aliases in Scala For Comprehensions\nDESCRIPTION: Example of the proposed syntax change allowing `for` comprehensions in Scala 3 to begin with pure value bindings (`=`) before the first generator (`<-`). This enhances readability for computations involving initial setup values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nfor {\n  x = 1\n  y <- Some(2)\n} yield x + y\n```\n\n----------------------------------------\n\nTITLE: Accessing Tuple Elements in Scala\nDESCRIPTION: Shows how to access elements of a Scala tuple 't' by index using parentheses starting at zero, returning the first (11) and second (11.0) elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\nt(0)  // 11\nt(1)  // 11.0\n```\n\n----------------------------------------\n\nTITLE: Splicing List of Trees with ..$ (Scala)\nDESCRIPTION: Demonstrates using the `..$` syntax within a `q` quasiquote to flatten and insert the elements from a `List[universe.Tree]` (`ab`) as multiple arguments into a function application `f(...)`. This is 'splicing rank' 1.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/intro.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val fab = q\"f(..$ab)\"\nfab: universe.Tree = f(a, b)\n```\n\n----------------------------------------\n\nTITLE: Defining a Lazy Fibonacci Sequence with LazyList in Scala\nDESCRIPTION: This snippet defines a recursive function `fibFrom` that generates an infinite lazy Fibonacci sequence starting from two given integers. It uses the `#::` operator to lazily construct the sequence and avoid infinite recursion. The function takes two integer parameters `a` and `b` and returns a LazyList of integers. This relies on Scala's standard immutable LazyList class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-immutable-collection-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nscala> def fibFrom(a: Int, b: Int): LazyList[Int] = a #:: fibFrom(b, a + b)\nfibFrom: (a: Int,b: Int)LazyList[Int]\n```\n\n----------------------------------------\n\nTITLE: Writing File Content with os-lib in Scala\nDESCRIPTION: This snippet demonstrates how to write a string to a new file using `os.write`. It first creates a temporary directory and file path, then writes the specified string content. It verifies the write by reading the file back and printing the number of lines. Requires the `os-lib` dependency.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/os-write-file.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval path: os.Path = os.temp.dir() / \"output.txt\"\nos.write(path, \"hello\nthere\n\")\nprintln(os.read.lines(path).size)\n// prints: 2\n```\n\n----------------------------------------\n\nTITLE: Defining and Accessing Static Members in Scala Object\nDESCRIPTION: Demonstrates how to declare fields and methods in a Scala `object` as static using the `@static` annotation. It shows the standard way to access these static members directly via the object's name.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/static-members.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Foo\n\nobject Foo {\n  @static val x = 5\n  @static def bar(y: Int): Int = x + y\n}\n\nprintln(Foo.x)\nprintln(Foo.bar(12))\n```\n\n----------------------------------------\n\nTITLE: Performing Parallel Breadth-First Search Using ParTrieMap in Scala\nDESCRIPTION: This Scala snippet implements a parallel breadth-first search (BFS) on a 2D grid represented as a Boolean array map using two parallel concurrent maps (`ParTrieMap`) for open and closed nodes. It defines node movement functions (`up`, `down`, `left`, `right`), uses the maps to store nodes to process and processed nodes, and iteratively expands nodes concurrently until the target is reached or no more nodes remain. The snippet depends on Scala parallel collections and mutable concurrent maps. Inputs include a grid `map` array, start points added to the `open` map, and a target coordinate. Outputs the path from target to start by backtracking parents. It assumes the grid and coordinates are valid and does not handle cyclic or isolated nodes explicitly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/parallel-collections/ctries.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval length = 1000\n\n// объявляем тип Node\ntype Node = (Int, Int);\ntype Parent = (Int, Int);\n\n// операции над типом Node\ndef up(n: Node) = (n._1, n._2 - 1);\ndef down(n: Node) = (n._1, n._2 + 1);\ndef left(n: Node) = (n._1 - 1, n._2);\ndef right(n: Node) = (n._1 + 1, n._2);\n\n// создаем карту и целевую точку\nval target = (length / 2, length / 2);\nval map = Array.tabulate(length, length)((x, y) => (x % 3) != 0 || (y % 3) != 0 || (x, y) == target)\ndef onMap(n: Node) = n._1 >= 0 && n._1 < length && n._2 >= 0 && n._2 < length\n\n// список open - фронт обработки\n// список closed - уже обработанные точки\nval open = ParTrieMap[Node, Parent]()\nval closed = ParTrieMap[Node, Parent]()\n\n// добавляем несколько стартовых позиций\nopen((0, 0)) = null\nopen((length - 1, length - 1)) = null\nopen((0, length - 1)) = null\nopen((length - 1, 0)) = null\n\n// \"жадный\" поиск в ширину\nwhile (open.nonEmpty && !open.contains(target)) {\n  for ((node, parent) <- open) {\n    def expand(next: Node) {\n      if (onMap(next) && map(next._1)(next._2) && !closed.contains(next) && !open.contains(next)) {\n        open(next) = node\n      }\n    }\n    expand(up(node))\n    expand(down(node))\n    expand(left(node))\n    expand(right(node))\n    closed(node) = parent\n    open.remove(node)\n  }\n}\n\n// выводим путь\nvar pathnode = open(target)\nwhile (closed.contains(pathnode)) {\n  print(pathnode + \"->\")\n  pathnode = closed(pathnode)\n}\nprintln()\n```\n\n----------------------------------------\n\nTITLE: Defining a Scala method using a match expression\nDESCRIPTION: Introduces a Scala method 'convertBooleanToStringMessage' that uses an if-else statement to convert a Boolean to its String representation, illustrating basic method structure and dependency on Boolean input.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/match-expressions.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef convertBooleanToStringMessage(bool: Boolean): String = {\n    if (bool) \"true\" else \"false\"        \n}\n```\n\n----------------------------------------\n\nTITLE: Blocking Await of Future Result Using Await.result in Scala\nDESCRIPTION: This snippet demonstrates blocking on a Future's result using Await.result with a timeout of 0 nanos. It initiates an asynchronous currency quote retrieval and, upon completion, initiates a buy operation mapped over the quote. Await.result blocks until the purchase Future completes, throwing its result or failure. This pattern should be used sparingly to avoid performance and deadlock issues. Required imports include scala.concurrent._ and scala.concurrent.duration._.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/futures.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.concurrent._\nimport scala.concurrent.duration._\n\ndef main(args: Array[String]): Unit = {\n  val rateQuote = Future {\n    connection.getCurrentValue(USD)\n  }\n\n  val purchase = rateQuote map { quote =>\n    if (isProfitable(quote)) connection.buy(amount, quote)\n    else throw new Exception(\"有益ではない\")\n  }\n\n  Await.result(purchase, 0 nanos)\n}\n```\n\n----------------------------------------\n\nTITLE: Appending, Prepending, Inserting, and Removing Elements in Scala Buffers\nDESCRIPTION: Details various operations available for mutable Buffers in Scala, a category of mutable sequences allowing flexible element manipulation. Key capabilities include appending single or multiple elements at the end (`append`, `appendAll`, `+=`, `++=`), prepending elements at the start (`prepend`, `prependAll`, `+=:`, `++=:`), inserting elements at specified positions (`insert`, `insertAll`), and removing elements by value or index (`subtractOne`, `subtractAll`, `remove`, `trimStart`, `trimEnd`, `clear`). Also describes methods for padding to a minimum size (`padToInPlace`), patching slices with new elements (`patchInPlace`), and cloning buffers (`clone`). These methods alter the buffer in-place and require Buffers such as ListBuffer or ArrayBuffer. Inputs vary depending on method but generally include elements or collection of elements, indices, and counts; outputs are mutated buffers or new buffer clones.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/seqs.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nbuf append x  // or  buf += x\nbuf appendAll xs  // or  buf ++= xs\nbuf prepend x  // or  x +=: buf\nbuf prependAll xs  // or  xs ++=: buf\nbuf.insert(i, x)\nbuf.insertAll(i, xs)\nbuf.padToInPlace(n, x)\nbuf subtractOne x  // or  buf -= x\nbuf subtractAll xs  // or  buf --= xs\nbuf remove i\nbuf.remove(i, n)\nbuf trimStart n\nbuf trimEnd n\nbuf.clear()\nbuf.patchInPlace(i, xs, n)\nbuf.clone()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Pizza Order System Usage (Scala)\nDESCRIPTION: A standalone Scala `object` named `MainDriver` that extends `App`, serving as the entry point for demonstrating the pizza order system classes. It instantiates `Pizza`, `Address`, `Customer`, and `Order` objects, adds pizzas to the order, and calls an assumed `printOrder` method (not included in the snippet) on the order object. This driver depends on all previously defined classes and `scala.collection.mutable.ArrayBuffer`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/oop-pizza-example.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable.ArrayBuffer\n\nobject MainDriver extends App {\n\n    val p1 = new Pizza (\n        MediumCrustSize,\n        ThinCrustType,\n        ArrayBuffer(Cheese)\n    )\n\n    val p2 = new Pizza (\n        LargeCrustSize,\n        ThinCrustType,\n        ArrayBuffer(Cheese, Pepperoni, Sausage)\n    )\n\n    val address = new Address (\n        \"123 Main Street\",\n        \"Apt. 1\",\n        \"Talkeetna\",\n        \"Alaska\",\n        \"99676\"\n    )\n\n    val customer = new Customer (\n        \"Alvin Alexander\",\n        \"907-555-1212\",\n        address\n    )\n\n    val o = new Order(\n        ArrayBuffer(p1, p2),\n        customer\n    )\n\n    o.addPizza(\n        new Pizza (\n            SmallCrustSize,\n            ThinCrustType,\n            ArrayBuffer(Cheese, Mushrooms)\n        )\n    )\n\n    // print the order\n    o.printOrder\n\n}\n```\n\n----------------------------------------\n\nTITLE: Using Match Expressions as Scala 2 Method Bodies\nDESCRIPTION: Demonstrates using a Scala 2 match expression as the entire body of a method (`isTruthy`), directly returning the result of the match. The method takes a `Matchable` value and uses pattern matching, including multi-value matching (`0 | \"\" | false`), to determine a boolean return value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_30\n\nLANGUAGE: Scala\nCODE:\n```\ndef isTruthy(a: Matchable) = a match {\n  case 0 | \"\" | false => false\n  case _              => true\n}\n```\n\n----------------------------------------\n\nTITLE: Calling '+' Method with Dot Notation in Scala\nDESCRIPTION: Demonstrates that the '+' operator in Scala is a method and can be invoked using standard dot notation on an integer literal.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/operators.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n10.+(1)\n```\n\n----------------------------------------\n\nTITLE: Preventing Name Shadowing with freshName - Scala\nDESCRIPTION: Shows how to prevent name shadowing issues by using `freshTermName` (or `c.freshName` in compile-time macros). A unique name (`xfresh`) is generated for the potentially shadowing variable in the generated code. By using this unique name, the unquoted reference (`$originalRef`) correctly resolves to its original binding, preserving the intended semantics.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/hygiene.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val xfresh = universe.internal.reificationSupport.freshTermName(\"x$\")\nxfresh: universe.TermName = x$1\n\nscala> val generatedTree = q\"$originalDefn; { val $xfresh = 2; println($xfresh); $originalRef }\"\ngeneratedTree: universe.Tree = ...\n\nscala> toolbox.eval(generatedTree)\n2\nres2: Any = 1\n```\n\n----------------------------------------\n\nTITLE: Implementing Symbolic Derivation Function with Pattern Matching in Scala 2\nDESCRIPTION: Defines a function derive that computes the symbolic derivative of an arithmetic expression tree node t with respect to variable v, following standard calculus rules. Uses pattern matching with guards and wildcards to identify the structure of t (sum, variable, or other) for dispatching the correct derivative logic. Requires the Tree algebraic data type with distinct cases for Sum, Var, and Const, as well as proper import of Tree._; expected input is a Tree (t) and a String (v), returning a Tree representing the derivative.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\nimport Tree._\n\ndef derive(t: Tree, v: String): Tree = t match {\n  case Sum(left, right)        => Sum(derive(left, v), derive(right, v))\n  case Var(n) if v == n => Const(1)\n  case _                => Const(0)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Utility Singleton Object in Scala 2 and Scala 3\nDESCRIPTION: This snippet defines a singleton object StringUtils with utility methods for string processing such as null-or-empty checks and trimming whitespace. The methods are implemented as stateless, pure functions accessible directly via the singleton object, mimicking static methods. It highlights syntax differences between Scala 2 and Scala 3 for object definition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-objects.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject StringUtils {\n  def isNullOrEmpty(s: String): Boolean = s == null || s.trim.isEmpty\n  def leftTrim(s: String): String = s.replaceAll(\"^\\\\s+\", \"\")\n  def rightTrim(s: String): String = s.replaceAll(\"\\\\s+$\", \"\")\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nobject StringUtils:\n  def isNullOrEmpty(s: String): Boolean = s == null || s.trim.isEmpty\n  def leftTrim(s: String): String = s.replaceAll(\"^\\\\s+\", \"\")\n  def rightTrim(s: String): String = s.replaceAll(\"\\\\s+$\", \"\")\n```\n\n----------------------------------------\n\nTITLE: Using a Context Bound to Implicitly Obtain a TypeTag and Inspect Type Arguments (Scala)\nDESCRIPTION: Provides a method paramInfo demonstrating the use of a context bound [T: TypeTag] as a succinct way to require implicit TypeTag evidence. The method accesses the type of T at runtime using typeOf[T], extracts its type arguments via pattern matching on TypeRef, and prints them. This requires importing scala.reflect.runtime.universe._. Input is a value of generic type T and output is runtime printed information regarding T's type arguments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/typetags-manifests.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n\ndef paramInfo[T: TypeTag](x: T): Unit = {\n  val targs = typeOf[T] match { case TypeRef(_, _, args) => args }\n  println(s\"type of $x has type arguments $targs\")\n}\n```\n\n----------------------------------------\n\nTITLE: Scala 2 and 3: Static typing with type inference\nDESCRIPTION: Shows Scala's ability to infer variable types, making code succinct while maintaining static type safety for better tooling and error detection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/scala-features.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval s = \"Hello\"\nval p = Person(\"Al\", \"Pacino\")\n\nval sum = nums.reduceLeft(_ + _)\nval y = for (i <- nums) yield i * 2\nval z = nums\n  .filter(_ > 100)\n  .filter(_ < 10_000)\n  .map(_ * 2)\n```\n\n----------------------------------------\n\nTITLE: 创建有序集合 TreeSet 并定义排序规则 - Scala\nDESCRIPTION: 示例展示如何使用自定义排序规则通过Ordering.fromLessThan创建TreeSet的空集合。并演示如何使用默认排序规则创建空的有序集合，以及对已有TreeSet进行元素添加后保持排序的特性。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/sets.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nscala> val myOrdering = Ordering.fromLessThan[String](_ > _)\nmyOrdering: scala.math.Ordering[String] = ...\n\nscala> TreeSet.empty(myOrdering)\nres1: scala.collection.immutable.TreeSet[String] = TreeSet()\n\nscala> TreeSet.empty[String]\nres2: scala.collection.immutable.TreeSet[String] = TreeSet()\n\nscala> res2 + (\"one\", \"two\", \"three\", \"four\")\nres3: scala.collection.immutable.TreeSet[String] = TreeSet(four, one, three, two)\n```\n\n----------------------------------------\n\nTITLE: Importing entire package in Scala 2 and 3\nDESCRIPTION: Imports all members of the 'users' package, enabling access to its classes and objects in Scala 2 and 3 with simplified syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/packaging-imports.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport users._                            // Scala 2\nimport users.*                            // Scala 3\n```\n\n----------------------------------------\n\nTITLE: Demonstrating String Sequence Operations with Scala REPL Examples - Scala\nDESCRIPTION: This Scala snippet illustrates various sequence operations performed on a string, like reversing, mapping characters to uppercase, dropping initial characters, slicing substrings, and converting a string to a sequence of characters. It requires standard Scala library support for implicit conversions. Inputs are the initial string and the invoked methods, and outputs are the resulting transformed strings or sequences. The snippet relies on the Scala REPL syntax and demonstrates idiomatic usage of string operations enabled by implicit conversions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/strings.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nscala> val str = \"hello\"\nstr: java.lang.String = hello\nscala> str.reverse\nres6: String = olleh\nscala> str.map(_.toUpper)\nres7: String = HELLO\nscala> str drop 3\nres8: String = lo\nscala> str slice (1, 4)\nres9: String = ell\nscala> val s: Seq[Char] = str\ns: Seq[Char] = WrappedString(h, e, l, l, o)\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Guards for Conditional Matching on Notifications (Scala 2)\nDESCRIPTION: Defines a function showImportantNotification that extends pattern matching by adding guards (if conditions) to identify notifications from important senders or callers. It matches Email and SMS with a guard that checks if the sender or number exists in a provided list of importantPeopleInfo. If the guard matches, a special message is returned. If none of the guarded cases match, the default case invokes showNotification to handle general notifications. This snippet shows use of guarded patterns to filter matching cases conditionally in Scala 2's syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/pattern-matching.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef showImportantNotification(notification: Notification, importantPeopleInfo: Seq[String]): String = {\n  notification match {\n    case Email(sender, _, _) if importantPeopleInfo.contains(sender) =>\n      \"You got an email from special someone!\"\n    case SMS(number, _) if importantPeopleInfo.contains(number) =>\n      \"You got an SMS from special someone!\"\n    case other =>\n      showNotification(other) // в этом варианте считается подходящими параметры любого типа. Значит этот вариант выполняется во всех случаях и передает исходный параметр в функцию showNotification\n  }\n}\n\nval importantPeopleInfo = Seq(\"867-5309\", \"jenny@gmail.com\")\n\nval someSms = SMS(\"123-4567\", \"Are you there?\")\nval someVoiceRecording = VoiceRecording(\"Tom\", \"voicerecording.org/id/123\")\nval importantEmail = Email(\"jenny@gmail.com\", \"Drinks tonight?\", \"I'm free after 5!\")\nval importantSms = SMS(\"867-5309\", \"I'm here! Where are you?\")\n\nprintln(showImportantNotification(someSms, importantPeopleInfo)) // выводит \"You got an SMS from 123-4567! Message: Are you there?\"\nprintln(showImportantNotification(someVoiceRecording, importantPeopleInfo)) // выводит \"You received a Voice Recording from Tom! Click the link to hear it: voicerecording.org/id/123\"\nprintln(showImportantNotification(importantEmail, importantPeopleInfo)) // выводит \"You got an email from special someone!\"\n\nprintln(showImportantNotification(importantSms, importantPeopleInfo)) // выводит \"You got an SMS from special someone!\"\n```\n\n----------------------------------------\n\nTITLE: Accessing JSON Array Elements by Index in Scala with uJson\nDESCRIPTION: Illustrates how to access elements within a JSON array after retrieving the array field from the parsed JSON object. It shows accessing elements by their numerical index (0-based) and casting them to String using the `.str` method. The example uses string interpolation to display the accessed array elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-parse.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval pets: ujson.Value = json(\"pets\")\n\nval firstPet: String = pets(0).str\nval secondPet: String = pets(1).str\n\nprintln(s\"The pets are $firstPet and $secondPet\")\n// prints: The pets are Toolkitty and Scaniel\n```\n\n----------------------------------------\n\nTITLE: Handling and Reporting Exceptions in Scala Futures - Scala 3\nDESCRIPTION: Provides an overview of exception handling in Scala 3's Futures using custom ExecutionContext and reporters. This snippet illustrates top-level functions that trigger various exceptions, asynchronous computation with Futures, and validation using check(). It leverages Scala 3 syntax such as 'using' for context parameters and demonstrates how to print and inspect results, including underlying causes. Dependencies include scala.concurrent, scala.util, and Java concurrency classes. Main parameters are the ExecutionContext and the thrown exceptions. Output is provided via standard output; the code is designed for demonstration and may block on Await if a Future fails to complete or if exceptions are fatal.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_33\n\nLANGUAGE: Scala\nCODE:\n```\nimport java.util.concurrent.{ForkJoinPool, TimeoutException}\nimport scala.concurrent.{Await, ExecutionContext, Future}\nimport scala.concurrent.duration.DurationInt\nimport scala.util.{Failure, Success}\n\ndef crashing(): Int  = throw new NoSuchMethodError(\"test\")\ndef failing(): Int   = throw new NumberFormatException(\"test\")\ndef interrupt(): Int = throw new InterruptedException(\"test\")\ndef erroring(): Int  = throw new AssertionError(\"test\")\n\n// computations can fail in the middle of a chain of combinators,\n// after the initial Future job has completed\ndef testCrashes()(using ExecutionContext): Future[Int] =\n  Future.unit.map(_ => crashing())\ndef testFails()(using ExecutionContext): Future[Int] =\n  Future.unit.map(_ => failing())\ndef testInterrupted()(using ExecutionContext): Future[Int] =\n  Future.unit.map(_ => interrupt())\ndef testError()(using ExecutionContext): Future[Int] =\n  Future.unit.map(_ => erroring())\n\n// Wait for 1 second for the the completion of the passed `future` value and print it\ndef check(future: Future[Int]): Unit =\n  try\n    Await.ready(future, 1.second)\n    for completion <- future.value do\n      println(s\"completed $completion\")\n      // In case of failure, also print the cause of the exception, when defined\n      completion match\n        case Failure(exception) if exception.getCause != null =>\n          println(s\"  caused by ${exception.getCause}\")\n        case _ => ()\n  catch\n    // If the future value did not complete within 1 second, the call\n    // to `Await.ready` throws a TimeoutException\n    case _: TimeoutException => println(s\"did not complete\")\n\ndef reporter(t: Throwable) = println(s\"reported $t\")\n\n@main def test(): Unit =\n  locally:\n    // using the `global` implicit context\n    import ExecutionContext.Implicits.given\n    // a successful Future\n    check(Future(42))        // completed Success(42)\n    // a Future that completes with an application exception\n    check(Future(failing())) // completed Failure(java.lang.NumberFormatException: test)\n    // same, but the exception is thrown somewhere in the chain of combinators\n    check(testFails())       // completed Failure(java.lang.NumberFormatException: test)\n    // a Future that does not complete because of a linkage error;\n    // the trace is printed to stderr by default\n```\n\n----------------------------------------\n\nTITLE: Defining an Environment Type Alias to Map Variables to Values in Scala\nDESCRIPTION: Creates a type alias `Environment` for a function from `String` to `Int`, representing a mapping from variable names to their integer values. This approach models environments as partial functions which return a variable's value given its name. For example, `{ case \"x\" => 5 }` defines an environment where variable \"x\" maps to 5, throwing an exception for other inputs. This simplifies environment handling and makes the evaluation code cleaner.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_it/tutorials/scala-for-java-programmers.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ntype Environment = String => Int\n```\n\n----------------------------------------\n\nTITLE: Iterating and Deconstructing Tuples Using For-Comprehension in Scala\nDESCRIPTION: Demonstrates iterating over a list of integer pairs (tuples) using a for-comprehension. Each tuple is deconstructed into variables 'a' and 'b', and their product is printed. It highlights Scala's concise syntax for looping with tuple unpacking.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/tuples.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval numPairs = List((2, 5), (3, -7), (20, 56))\nfor ((a, b) <- numPairs) {\n  println(a * b)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Code Inspector Macro in Scala 3\nDESCRIPTION: This snippet shows a macro that prints the expression of the provided argument at compile-time. It demonstrates the basic structure of a macro implementation with the Expr type and how to use inline methods as entry points.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/macros.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.quoted.* // imports Quotes, Expr\n\ndef inspectCode(x: Expr[Any])(using Quotes): Expr[Any] =\n  println(x.show)\n  x\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Trait with Abstract Methods in Scala\nDESCRIPTION: Definition of a generic Iterator trait with type parameter A and two abstract methods: hasNext and next(). This demonstrates traits with generic types and abstract methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/traits.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntrait Iterator[A] {\n  def hasNext: Boolean\n  def next(): A\n}\n```\n\n----------------------------------------\n\nTITLE: Appending Element to Buffer in Scala\nDESCRIPTION: Appends a single element 'x' to the end of the buffer 'buf'. This operation modifies the buffer in place and returns the modified buffer itself.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/seqs.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nbuf += x\n```\n\n----------------------------------------\n\nTITLE: Importing Try Classes from Scala.Util\nDESCRIPTION: Before using Try, Success, and Failure, this snippet imports them from scala.util. These classes enable exception-safe computations without explicit try-catch blocks. There are no inputs or outputs; it simply establishes the required namespace for subsequent snippets.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/functional-error-handling.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.util.{Try,Success,Failure}\n```\n\n----------------------------------------\n\nTITLE: Formal Desugaring Rules for Simplified Alias Handling (Proposal 2)\nDESCRIPTION: Introduces new desugaring rules to handle pure aliases more efficiently when not followed by a guard. It delegates alias handling to the rule for initial aliases within a `flatMap` or `map` (implicitly for the final `yield`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_15\n\nLANGUAGE: text\nCODE:\n```\n// Rule 1: Alias sequence following a generator\nFor any N:\n  for (P <- G; P_1 = E_1; ... P_N = E_N; ...) \n    ==> \n  G.flatMap (P => for (P_1 = E_1; ... P_N = E_N; ...))\n\n// Rule 2: Base case (empty for yielding expression)\nAnd:\n  for () yield E  ==>  E\n\n// Rule 3: (Delegation to initial alias rule - shown previously)\nFor any N:\n  for (P_1 = E_1; ... P_N = E_N; ...) \n    ==> \n  { \n    val x_2 @ P_2 = E_2\n    ...\n    val x_N @ P_N = E_N\n    for (...)\n  }\n```\n\n----------------------------------------\n\nTITLE: Declaring Immutable Values (val) in Scala - Scala\nDESCRIPTION: Illustrates defining an immutable value using the val keyword, which assigns a name to the result of an expression. The value reference does not recompute the expression. Attempts to reassign a val will not compile. The type can be optionally declared explicitly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/tour/basics.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval x = 1 + 1\nprintln(x) // 2\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval x: Int = 1 + 1\n```\n\n----------------------------------------\n\nTITLE: Importing packages in Scala 3\nDESCRIPTION: Details import syntax differences in Scala 3, including wildcard import, import of all given instances, specific class import, multiple imports, and renaming using 'as'. Import statements in Scala 3 can be used anywhere, enhancing flexibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/packages-and-imports.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nimport users.*  // group import, excluding 'given'\nimport users.given  // import all 'given' instances\nimport users.User  // specific class\nimport users.{User, UserPreferences}  // specific multiple classes\nimport users.UserPreferences as UPrefs  // alias for imported class\n```\n\n----------------------------------------\n\nTITLE: Comparing Single vs Multiple Parameter Lists for Type Inference in Scala\nDESCRIPTION: Example showing how multiple parameter lists improve type inference by allowing the compiler to infer types from the first parameter list before processing the second list.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/multiple-parameter-lists.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef foldLeft1[A, B](as: List[A], b0: B, op: (B, A) => B) = ???\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef notPossible = foldLeft1(numbers, 0, _ + _)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef firstWay = foldLeft1[Int, Int](numbers, 0, _ + _)\ndef secondWay = foldLeft1(numbers, 0, (a: Int, b: Int) => a + b)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef foldLeft2[A, B](as: List[A], b0: B)(op: (B, A) => B) = ???\ndef possible = foldLeft2(numbers, 0)(_ + _)\n```\n\n----------------------------------------\n\nTITLE: Using private methods in Scala classes\nDESCRIPTION: A demonstration of private methods in Scala classes that cannot be accessed or overridden in subclasses, showing compiler errors when attempting to override.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/methods-most.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass Animal {\n  private def breathe() = println(\"I'm breathing\")\n}\n\nclass Cat extends Animal {\n  // this method won't compile\n  override def breathe() = println(\"Yo, I'm totally breathing\")\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Animal:\n  private def breathe() = println(\"I'm breathing\")\n\nclass Cat extends Animal:\n  // this method won't compile\n  override def breathe() = println(\"Yo, I'm totally breathing\")\n```\n\n----------------------------------------\n\nTITLE: Using while loops in Scala 3\nDESCRIPTION: Shows the Scala 3 syntax for while loops, which uses the 'do' keyword instead of curly braces and makes the parentheses around the condition optional.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nvar i = 0\n\nwhile i < 3 do\n  println(i)\n  i += 1\n```\n\n----------------------------------------\n\nTITLE: Testing Scala Installation via Command Line\nDESCRIPTION: A command to verify the successful installation of Scala by checking its version, which should display the Scala code runner version and default Scala version.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/getting-started/install-scala.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ scala -version\nScala code runner version: 1.4.3\nScala version (default): {{site.scala-3-version}}\n```\n\n----------------------------------------\n\nTITLE: Invoking a Method with Implicit Conversion in Scala\nDESCRIPTION: Demonstrates calling the `findUserById` method (which expects a `Long`) with an `Int` variable `id`. Scala automatically applies an available implicit conversion (like `Int` to `Long`) to make the call type-correct, avoiding a compilation error.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-implicit-conversions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval id: Int = 42\nfindUserById(id) // OK\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Guards in Scala for Special Notification Handling\nDESCRIPTION: Defines 'mostrarNotificacaoEspecial' using pattern matching with guards ('if') to handle notifications only from specified 'emailEspecial' or 'numeroEspecial'. Delegates to 'mostrarNotificacao' for other cases, enhancing control flow.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/case-classes.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ndef mostrarNotificacaoEspecial(notificacao: Notification, emailEspecial: String, numeroEspecial: String): String = {\n  notificacao.match {\n    case Email(email, _, _) if email == emailEspecial =>\n      \"Você recebeu um email de alguém especial!\"\n    case SMS(numero, _) if numero == numeroEspecial =>\n      \"Você recebeu um SMS de alguém especial!\"\n    case outro =>\n      mostrarNotificacao(outro) // delega para função original\n  }\n}\n\nval NumeroEspecial = \"55555\"\nval EmailEspecial = \"jane@mail.com\"\n\nval algumSMS = SMS(\"12345\", \"Você está aí?\")\nval algumaMsgVoz = VoiceRecording(\"Tom\", \"voicerecording.org/id/123\")\nval emailEspecial = Email(\"jane@mail.com\", \"Beber hoje a noite?\", \"Estou livre depois das 5!\")\nval smsEspecial = SMS(\"55555\", \"Estou aqui! Onde está você?\")\n\nprintln(mostrarNotificacaoEspecial(algumSMS, EmailEspecial, NumeroEspecial))\nprintln(mostrarNotificacaoEspecial(algumaMsgVoz, EmailEspecial, NumeroEspecial))\nprintln(mostrarNotificacaoEspecial(smsEspecial, EmailEspecial, NumeroEspecial))\n```\n\n----------------------------------------\n\nTITLE: Grouping Expressions in Blocks with Curly Braces in Scala - Scala\nDESCRIPTION: Demonstrates grouping multiple expressions into a single block using braces. The block evaluates all expressions sequentially, returning the last expression's value as the block’s result. This allows local value declarations and computations inside the block.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/tour/basics.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nprintln({\n  val x = 1 + 1\n  x + 1\n}) // 3\n```\n\n----------------------------------------\n\nTITLE: Defining Deferred Givens in Scala Traits\nDESCRIPTION: Introduces the proposed `given T = deferred` syntax for traits. This defines a given that must be implemented by inheriting classes, either explicitly with `override` or implicitly through synthesized given search in the subclass's scope. `deferred` is a special method in `scala.compiletime`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ngiven T = deferred\n```\n\n----------------------------------------\n\nTITLE: Interactive Hello World Program in Scala 2 Reading User Input\nDESCRIPTION: Defines a singleton object 'helloInteractive' with a 'main' method that prompts the user to enter their name via standard input. It reads input using the imported 'readLine()' method from 'scala.io.StdIn', stores it in the 'name' variable, and prints a personalized greeting. This snippet requires the Scala standard library and runtime. It illustrates reading from stdin, string concatenation with '+', and basic input-output interaction in a Scala 2 style program structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-hello-world.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.io.StdIn.readLine\n\nobject helloInteractive {\n\n  def main(args: Array[String]) = {\n    println(\"Please enter your name:\")\n    val name = readLine()\n\n    println(\"Hello, \" + name + \"!\")\n  }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Conversion Errors with Try/Catch, Scala\nDESCRIPTION: Demonstrates a basic approach to handling string-to-integer conversion errors using a try-catch block. If the conversion fails, the method catches the exception and returns a default integer value (0), which can be ambiguous as 0 is also a valid conversion result.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-functional-error-handling.md#_snippet_0\n\nLANGUAGE: Scala 2\nCODE:\n```\ndef makeInt(s: String): Int =\n  try {\n    Integer.parseInt(s.trim)\n  } catch {\n    case e: Exception => 0\n  }\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ndef makeInt(s: String): Int =\n  try\n    Integer.parseInt(s.trim)\n  catch\n    case e: Exception => 0\n```\n\n----------------------------------------\n\nTITLE: Использование `BigInt` и `BigDecimal` для больших чисел в Scala\nDESCRIPTION: Показывает, как создавать переменные `BigInt` и `BigDecimal` для обработки очень больших целых чисел и точной десятичной арифметики.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-vars-data-types.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nvar a = BigInt(1_234_567_890_987_654_321L)\nvar b = BigDecimal(123_456.789)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Try Usage in Scala REPL\nDESCRIPTION: These example snippets illustrate how Try-based functions behave in the Scala REPL, showing both successful and failed parsing cases. They assign the result of toInt to a variable and display the wrapped Success or Failure objects, making failure reasons explicit. Inputs are string values, outputs are Try[Int] containing either the parsed integer or the parsing exception.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/functional-error-handling.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val a = toInt(\"1\")\na: scala.util.Try[Int] = Success(1)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val b = toInt(\"boo\")\nb: scala.util.Try[Int] = Failure(java.lang.NumberFormatException: For input string: \"boo\")\n```\n\nLANGUAGE: Scala\nCODE:\n```\nscala.util.Try[Int] = Success(6)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nscala.util.Try[Int] = Failure(java.lang.NumberFormatException: For input string: \"a\")\n```\n\n----------------------------------------\n\nTITLE: 演示asJava方法将Scala容器转换为Java容器 - Scala\nDESCRIPTION: 展示如何将Scala的mutable.ArrayBuffer和mutable.HashMap转换为相应的Java容器类型 java.util.List 和 java.util.Map。代码使用asJava扩展方法，转换后得到的Java容器可以像Java原生容器一样使用。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/conversions-between-java-and-scala-collections.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nscala> import collection.mutable._\nimport collection.mutable._\n\nscala> val jul: java.util.List[Int] = ArrayBuffer(1, 2, 3).asJava\njul: java.util.List[Int] = [1, 2, 3]\n\nscala> val m: java.util.Map[String, Int] = HashMap(\"abc\" -> 1, \"hello\" -> 2).asJava\nm: java.util.Map[String,Int] = {abc=1, hello=2}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Covariant Immutable Box in Scala 2\nDESCRIPTION: This snippet defines an ImmutableBox class parameterized covariantly (+A), then shows that an ImmutableBox[Cat] can be assigned where ImmutableBox[Animal] is expected. It constructs boxed instances for Cat, and demonstrates legal subtyping assignment. All operations are read-only (field is val), making covariance safe. No dependencies outside standard Scala types; the class enforces immutability on its content.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/variances.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nclass ImmutableBox[+A](val content: A)\nval catbox: ImmutableBox[Cat] = new ImmutableBox[Cat](Cat(\"Felix\"))\nval animalBox: ImmutableBox[Animal] = catbox // now this compiles\n```\n\n----------------------------------------\n\nTITLE: Iterating List with For Loop in Scala\nDESCRIPTION: Shows how to use a standard `for` loop to iterate over the `people` list. Each string element is assigned to the variable `p` and printed, mirroring the previous integer sequence example but applied to a list of strings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/for-loops.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nfor (p <- people) println(p)\n```\n\n----------------------------------------\n\nTITLE: Limitation of `Type.of` with Erased Abstract Types\nDESCRIPTION: Shows that `Type.of[T]` cannot be used directly within a generic method to synthesize a `Type[T]` for an abstract type parameter `T` because the type information might have been erased. The `Type[T]` must be passed in as a context parameter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ndef evalAndUse[T](x: Expr[T])(using Quotes) =\n  given Type[T] = Type.of[T] // error\n  '{\n    val x2: T = $x\n    ... // use x2\n  }\n```\n\n----------------------------------------\n\nTITLE: Using BufferedIterator to Peek and Advance in Scala\nDESCRIPTION: Illustrates the creation and usage of a `BufferedIterator` from a standard `Iterator` using the `.buffered` method. It demonstrates how `head` returns the next element without advancing the iterator, while `next()` consumes and returns the element. `headOption` provides an optional value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/iterators.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val it = Iterator(1, 2, 3, 4)\nval it: Iterator[Int] = <iterator>\n\nscala> val bit = it.buffered\nval bit: scala.collection.BufferedIterator[Int] = <iterator>\n\nscala> bit.head\nval res10: Int = 1\n\nscala> bit.next()\nval res11: Int = 1\n\nscala> bit.next()\nval res12: Int = 2\n\nscala> bit.headOption\nval res13: Option[Int] = Some(3)\n```\n\n----------------------------------------\n\nTITLE: Accessing the tail of a list using Scala\nDESCRIPTION: Demonstrates how to retrieve the tail (all elements except the head) of a List or String in Scala versions 2 and 3. Shows direct method calls to tail on lists and strings, explains the exception thrown on empty lists, and introduces pattern matching to extract head and tail. Useful for understanding basic list processing and functional list decomposition in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-methods.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\noneToTen.head   // 1\noneToTen.tail   // List(2, 3, 4, 5, 6, 7, 8, 9, 10)\n\nnames.head      // adam\nnames.tail      // List(brandy, chris, david)\n```\n\nLANGUAGE: scala\nCODE:\n```\n\"foo\".tail   // \"oo\"\n\"bar\".tail   // \"ar\"\n```\n\nLANGUAGE: scala\nCODE:\n```\nval x :: xs = names\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> val x :: xs = names\nval x: String = adam\nval xs: List[String] = List(brandy, chris, david)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef sum(list: List[Int]): Int = list match {\n  case Nil => 0\n  case x :: xs => x + sum(xs)\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef sum(list: List[Int]): Int = list match\n  case Nil => 0\n  case x :: xs => x + sum(xs)\n```\n\n----------------------------------------\n\nTITLE: Defining a Parameterless Unit Function in Scala\nDESCRIPTION: Shows how to define a simple method `helloWorld` matching the function signature `() => Unit`, which prints a greeting message to the console. This method can be passed as a parameter to higher-order functions like `executeNTimes` that expect a no-argument function returning `Unit`. Compatible with both Scala 2 and Scala 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-hofs.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\n// a method of type `() => Unit`\ndef helloWorld(): Unit = println(\"Hello, world\")\n```\n\n----------------------------------------\n\nTITLE: Class Inheritance and Interface Implementation in Java\nDESCRIPTION: Demonstrates single class inheritance and multiple interface implementation in Java. The class Dog extends the class Animal and implements interfaces HasLegs and HasTail, showcasing Java's standard syntax for combining inheritance and interface implementation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_22\n\nLANGUAGE: java\nCODE:\n```\nclass Dog extends Animal implements HasLegs, HasTail\n```\n\n----------------------------------------\n\nTITLE: Mapping Int List with Anonymous Function in Scala\nDESCRIPTION: Demonstrates the use of an anonymous function literal directly within a map call to transform a list of integers by doubling each element. No prerequisites beyond a Scala collection of integers. Input is a list of integers, output is a transformed list with each integer multiplied by two.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-function-variables.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval doubledInts = ints.map((i: Int) => i * 2)\n```\n\n----------------------------------------\n\nTITLE: Data Structures in Scala\nDESCRIPTION: Describes core data structures, including tuples, lists, ranges, and sequences, along with pattern matching and index access. Covers list construction and assertions about mutability and pattern matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/cheatsheets/index.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n(1, 2, 3)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nvar (x, y, z) = (1, 2, 3)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nvar x, y, z = (1, 2, 3)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nvar xs = List(1, 2, 3)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nxs(2)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n1 :: List(2, 3)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n1 to 5\n// same as\n// 1 until 6\n// and\n// 1 to 10 by 2\n```\n\nLANGUAGE: Scala\nCODE:\n```\n()\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Match Expressions - Scala\nDESCRIPTION: Explains Scala's 'match' expression as an alternative to JavaScript's 'switch' statement. Shows basic pattern matching, handling multiple cases, and using 'match' as the body of a method. Highlights that 'match' is an expression and returns a value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_31\n\nLANGUAGE: Scala\nCODE:\n```\nval day = 1\n\n// later in the code ...\nval monthAsString = day match\n  case 1 => \"January\"\n  case 2 => \"February\"\n  case _ => \"Other\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval numAsString = i match\n  case 1 | 3 | 5 | 7 | 9 => \"odd\"\n  case 2 | 4 | 6 | 8 | 10 => \"even\"\n  case _ => \"too big\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef isTruthy(a: Matchable) = a match\n  case 0 | \"\" => false\n  case _ => true\n\ndef isPerson(x: Matchable): Boolean = x match\n  case p: Person => true\n  case _ => false\n```\n\n----------------------------------------\n\nTITLE: Adding Scala Toolkit Dependency Using Scala CLI - Scala\nDESCRIPTION: This snippet demonstrates how to add the entire Scala Toolkit to a project using Scala CLI, by specifying a special directive in a Scala source file. No additional dependencies are required beyond having Scala CLI installed. The directive '//> using toolkit latest' ensures the latest version of the toolkit is pulled automatically on build. No further parameters are needed; all toolkit libraries will be available to the project.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-os-lib.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n//> using toolkit latest\n```\n\n----------------------------------------\n\nTITLE: Invariant Generic Container Class with Mutable State in Scala - scala\nDESCRIPTION: Defines a generic class Container with a type parameter A (invariant by default). It holds a mutable variable _value of type A, with getter and setter methods. This example shows why mutable generic classes usually must be invariant to maintain type safety, preventing subtype substitution errors during mutation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/variances.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nclass Container[A](value: A) {\n  private var _value: A = value\n  def getValue: A = _value\n  def setValue(value: A): Unit = {\n    _value = value\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Performing Arithmetic Operations with BigInt in REPL Scala\nDESCRIPTION: Demonstrates using standard arithmetic operators (`+`, `*`, `+=`) on `BigInt` variables within the Scala REPL. This highlights the convenience of `BigInt` as it supports the same operators as built-in numeric types despite being a class for arbitrary-precision integers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/built-in-types.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nscala> var b = BigInt(1234567890)\nb: scala.math.BigInt = 1234567890\n\nscala> b + b\nres0: scala.math.BigInt = 2469135780\n\nscala> b * b\nres1: scala.math.BigInt = 1524157875019052100\n\nscala> b += 1\n\nscala> println(b)\n1234567891\n```\n\n----------------------------------------\n\nTITLE: Creating immutable sets in Java vs Scala\nDESCRIPTION: Demonstrates the creation of immutable sets in both languages, showing Scala's more concise syntax without requiring an explicit factory method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_49\n\nLANGUAGE: Java\nCODE:\n```\nSet set = Set.of(\"a\", \"b\", \"c\");\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval set = Set(\"a\", \"b\", \"c\")\n```\n\n----------------------------------------\n\nTITLE: Function Composition and Currying in Scala\nDESCRIPTION: Demonstrates function composition, currying, and partial application techniques in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/cheatsheets/index.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef compose(g: R => R, h: R => R) =\n  (x: R) => g(h(x))\n```\n\nLANGUAGE: scala\nCODE:\n```\nval f = compose(_ * 2, _ - 1)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval zscore =\n  (mean: R, sd: R) =>\n    (x: R) =>\n      (x - mean) / sd\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef zscore(mean: R, sd: R) =\n  (x: R) =>\n    (x - mean) / sd\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef zscore(mean: R, sd: R)(x: R) =\n  (x - mean) / sd\n```\n\nLANGUAGE: scala\nCODE:\n```\nval normer =\n  zscore(7, 0.4) _\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef mapmake[T](g: T => T)(seq: List[T]) =\n  seq.map(g)\n```\n\nLANGUAGE: scala\nCODE:\n```\n5.+(3); 5 + 3\n```\n\nLANGUAGE: scala\nCODE:\n```\n(1 to 5) map (_ * 2)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef sum(args: Int*) =\n  args.reduceLeft(_+_)\n```\n\n----------------------------------------\n\nTITLE: Importing multiple 'given' types from Scala object\nDESCRIPTION: Demonstrates importing multiple 'given' instances T1,..., Tn from object A using multiple selectors within the import statement, allowing selective inclusion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/packaging-imports.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nimport A.{given T1, ..., given Tn}\n```\n\n----------------------------------------\n\nTITLE: Using Named Parameters in Scala Method Calls\nDESCRIPTION: Illustrates the syntax for using named parameters in Scala method invocations since version 2.8. Named parameters follow regular spacing rules after the comma, with a space required on both sides of the equals sign.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/method-invocation.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nfoo(x = 6, y = 7)\n```\n\n----------------------------------------\n\nTITLE: ケースクラスインスタンスの生成 - Scala\nDESCRIPTION: newキーワード不要でケースクラスPointのインスタンスを作成する例です。同じ引数で生成された二つのインスタンスは値として同一視されます。異なる引数の場合の差異も示します。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nval point = Point(1, 2)\nval anotherPoint = Point(1, 2)\nval yetAnotherPoint = Point(2, 2)\n```\n\n----------------------------------------\n\nTITLE: Testing Asynchronous Methods in MUnit\nDESCRIPTION: An example test class demonstrating how to test asynchronous methods that return Futures. The test uses for-comprehensions to sequence asynchronous operations and performs assertions on the computed values. MUnit automatically waits for the Future to complete.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-asynchronous.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// Import the global execution context, required to call async methods\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nclass AsyncMathLibTests extends munit.FunSuite {\n  test(\"square\") {\n    for {\n      squareOf3 <- AsyncMathLib.square(3)\n      squareOfMinus4 <- AsyncMathLib.square(-4)\n    } yield {\n      assertEquals(squareOf3, 9)\n      assertEquals(squareOfMinus4, 16)\n    }\n  }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\n// Import the global execution context, required to call async methods\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nclass AsyncMathLibTests extends munit.FunSuite:\n  test(\"square\") {\n    for\n      squareOf3 <- AsyncMathLib.square(3)\n      squareOfMinus4 <- AsyncMathLib.square(-4)\n    yield\n      assertEquals(squareOf3, 9)\n      assertEquals(squareOfMinus4, 16)\n  }\n```\n\n----------------------------------------\n\nTITLE: Limitations of Type Inference and Explicit Type Annotations in Scala\nDESCRIPTION: Advises explicit type annotations for public API members to enhance readability and avoid overly specific types. Demonstrates that variable 'obj' initialized as 'null' cannot be reassigned to other types due to 'Null' type constraints.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/type-inference.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nvar obj = null\n// Cannot assign 'obj = new AnyRef' afterward, as 'obj' has type 'Null'\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Tagging Using Opaque Types in Scala\nDESCRIPTION: This snippet defines an approach to tag types at compile-time using opaque types, enabling safer distinction between otherwise similar types (e.g., Double tagged as Meter vs. Foot) without runtime overhead. It introduces opaque type Tagged, helper aliases (e.g., @@), extension methods for tagging and untagging, and companions for implicit re-export of context bounds like ClassTag. Expected inputs include values to tag or untag, and tag types themselves; outputs are tagged values enforcing compile-time safety. Dependencies: Scala 3, proper ClassTag imports. Limitation: Requires manual handling of implicit contexts for tagged types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/opaque-types.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\npackage object tagging {\n\n  // Tagged[S, T] means that S is tagged with T\n  opaque type Tagged[S, T] = S\n\n  object Tagged {\n    def tag[S, T](s: S): Tagged[S, T] = s\n    def untag[S, T](st: Tagged[S, T]): S = st\n\n    def tags[F[_], S, T](fs: F[S]): F[Tagged[S, T]] = fs\n    def untags[F[_], S, T](fst: F[Tagged[S, T]]): F[S] = fst\n\n    implicit def taggedClassTag[S, T](implicit ct: ClassTag[S]): ClassTag[Tagged[S, T]] =\n      ct\n  }\n\n  type @@[S, T] = Tagged[S, T]\n\n  implicit class UntagOps[S, T](st: S @@ T) extends AnyVal {\n    def untag: S = Tagged.untag(st)\n  }\n\n  implicit class UntagsOps[F[_], S, T](fs: F[S @@ T]) extends AnyVal {\n    def untags: F[S] = Tagged.untags(fs)\n  }\n\n  implicit class TagOps[S](s: S) extends AnyVal {\n    def tag[T]: S @@ T = Tagged.tag(s)\n  }\n\n  implicit class TagsOps[F[_], S](fs: F[S]) extends AnyVal {\n    def tags[T]: F[S @@ T] = Tagged.tags(fs)\n  }\n\n  trait Meter\n  trait Foot\n  trait Fathom\n\n  val x: Double @@ Meter = (1e7).tag[Meter]\n  val y: Double @@ Foot = (123.0).tag[Foot]\n  val xs: Array[Double @@ Meter] = Array(1.0, 2.0, 3.0).tags[Meter]\n\n  val o: Ordering[Double] = implicitly\n  val om: Ordering[Double @@ Meter] = o.tags[Meter]\n  om.compare(x, x) // 0\n  om.compare(x, y) // does not compile\n  xs.min(om) // 1.0\n  xs.min(o) // does not compile\n\n  // uses ClassTag[Double] via 'Tagged.taggedClassTag'.\n  val ys = new Array[Double @@ Foot](20)\n}\n```\n\n----------------------------------------\n\nTITLE: Starting the Scala REPL in Command Line\nDESCRIPTION: Examples showing how to start the Scala REPL in both Scala 2 and Scala 3. The REPL displays a welcome message with version information and waits for user input.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-repl.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ scala\nWelcome to Scala {{site.scala-version}} (OpenJDK 64-Bit Server VM, Java 1.8.0_342).\nType in expressions for evaluation. Or try :help.\n\nscala> _\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ scala\nWelcome to Scala {{site.scala-3-version}} (1.8.0_322, Java OpenJDK 64-Bit Server VM).\nType in expressions for evaluation. Or try :help.\n\nscala> _\n```\n\n----------------------------------------\n\nTITLE: Mutable Field Declaration in Scala 3\nDESCRIPTION: Declares a mutable integer field i using var keyword, initialized to 1. Unlike val, var allows reassignment, enabling mutability within Scala's variable semantics.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nvar i = 1\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Regex Pattern to Validate Passwords in Scala\nDESCRIPTION: This snippet shows how to create a regex pattern to check for the presence of a number in a password string. It imports 'scala.util.matching.Regex', defines the pattern using the '.r' method, and uses pattern matching to output validation messages. Dependencies include Scala standard library; main parameters are the regex pattern and input string.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/regular-expression-patterns.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.util.matching.Regex\n\nval numberPattern: Regex = \"[0-9]\".r\n\nnumberPattern.findFirstMatchIn(\"awesomepassword\") match {\n  case Some(_) => println(\"Password OK\")\n  case None => println(\"Password must contain a number\")\n}\n```\n\n----------------------------------------\n\nTITLE: Writing TDD Tests with ScalaTest FunSuite\nDESCRIPTION: A ScalaTest test class using the FunSuite style to test the Person class. It includes two test cases that verify the constructor sets the name correctly and that the name can be changed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/sbt-scalatest-tdd.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\npackage simpletest\n\nimport org.scalatest.funsuite.AnyFunSuite\n\nclass HelloTests extends AnyFunSuite {\n\n    // test 1\n    test(\"the name is set correctly in constructor\") {\n        val p = new Person(\"Barney Rubble\")\n        assert(p.name == \"Barney Rubble\")\n    }\n\n    // test 2\n    test(\"a Person's name can be changed\") {\n        val p = new Person(\"Chad Johnson\")\n        p.name = \"Ochocinco\"\n        assert(p.name == \"Ochocinco\")\n    }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Working with LazyList in Scala\nDESCRIPTION: Demonstrating Scala's LazyList, which is a lazy immutable linked list that computes its elements only when they are needed, making it suitable for large or infinite sequences.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval x = LazyList.range(1, Int.MaxValue)\nx.take(1)      // LazyList(<not computed>)\nx.take(5)      // LazyList(<not computed>)\nx.map(_ + 1)   // LazyList(<not computed>)\n```\n\nLANGUAGE: scala\nCODE:\n```\nx.take(1).foreach(println)\n```\n\n----------------------------------------\n\nTITLE: Defining and using functions in Scala\nDESCRIPTION: Demonstrates function definitions in Scala, including proper syntax with return values, type annotations, and common errors to avoid.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: Int) = { x * x }\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: Int)   { x * x }\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: Any) = println(x)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x) = println(x)\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype R = Double\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: R)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: => R)\n```\n\n----------------------------------------\n\nTITLE: Context Bound Expansion with Type Aliases in Scala\nDESCRIPTION: Demonstrates how the proposed compiler expansion for context bounds interacts with nested type aliases. The `Comparer2` type alias, defined with a context bound `[X: Ord]`, references `Cmp[X]`, which already contains a context function type (`?=>`). The expansion correctly inserts the context function at the appropriate level.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\ntype Cmp[X] = (x: X, y: X) => Ord[X] ?=> Boolean\ntype Comparer2 = [X: Ord] => Cmp[X]\n```\n\n----------------------------------------\n\nTITLE: Attempting to Mutate Fields of a Scala 'Person' Case Class\nDESCRIPTION: Demonstrates that fields in a case class are immutable ('val') and cannot be reassigned after creation, enforcing data integrity and immutability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\nchristina.name = \"Fred\"   // ошибка: reassignment to val\n```\n\n----------------------------------------\n\nTITLE: Using a Generic Stack Instance (Scala 3)\nDESCRIPTION: Shows the instantiation and usage of the generic `Stack` class in Scala 3. A `Stack[Int]` is created, two integers are pushed, and then popped and printed, utilizing Scala 3's potentially simpler instantiation syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-generics.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval stack = Stack[Int]\nstack.push(1)\nstack.push(2)\nprintln(stack.pop())  // prints 2\nprintln(stack.pop())  // prints 1\n```\n\n----------------------------------------\n\nTITLE: Illegal Multiple Colon-Delimited Arguments for Fold in Scala\nDESCRIPTION: This snippet demonstrates how chaining multiple colon-delimited arguments for a fold operation is not allowed under the fewerBraces rules. The code tries to list several arguments each introduced with a colon, which is disallowed to prevent ambiguity and confusion. Code written in this style will cause compilation errors and needs restructuring.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nxo.fold:\n  defaultValue\n:  // illegal\n  x => f(x)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Comparable Interface using Traits in Scala\nDESCRIPTION: Demonstrates how to create an Ord trait for object comparison that provides default implementations for comparison operators while requiring only minimal implementation in the extending class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tutorials/scala-for-java-programmers.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ntrait Ord {\n  def < (that: Any): Boolean\n  def <=(that: Any): Boolean =  (this < that) || (this == that)\n  def > (that: Any): Boolean = !(this <= that)\n  def >=(that: Any): Boolean = !(this < that)\n}\n```\n\n----------------------------------------\n\nTITLE: Matching integer values with Scala match expression - Scala\nDESCRIPTION: Demonstrates the basic use of the match expression in Scala to decompose an integer value and return corresponding strings for cases 0, 1, 2, and a default case using the wildcard. It uses scala.util.Random to generate a random Int from 0 to 9. The snippet shows key syntax including the match keyword and case clauses. The underscore (_) case acts as a catch-all for unmatched values, ensuring exhaustiveness.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/pattern-matching.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.util.Random\n\nval x: Int = Random.nextInt(10)\n\nx match {\n  case 0 => \"zero\"\n  case 1 => \"one\"\n  case 2 => \"two\"\n  case _ => \"other\"\n}\n```\n\n----------------------------------------\n\nTITLE: Proposal 2: Complex Desugaring with Guard - Example\nDESCRIPTION: Illustrates the scenario where a pure alias (`b = a`) *is* immediately followed by an `if` guard (`if b > 1`). This case retains the more complex desugaring involving tuples.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nfor\n  a <- doSth(arg)\n  b = a\n  if b > 1\nyield a + b\n```\n\n----------------------------------------\n\nTITLE: Scala样例类定义披萨（Pizza）模型\nDESCRIPTION: 定义Pizza作为一个样例类，包含crustSize、crustType和toppings字段，用于描述披萨的属性集合。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-fp.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport CrustSize.*\nimport CrustType.*\nimport Topping.*\n\ncase class Pizza(\n  crustSize: CrustSize,\n  crustType: CrustType,\n  toppings: Seq[Topping]\n)\n```\n\n----------------------------------------\n\nTITLE: Defining New Partitioning Operations on Scala Collections - Scala\nDESCRIPTION: This snippet introduces two new partitioning collection operations: groupMap and groupMapReduce. The groupMap method groups elements by a computed key and then maps each element to a transformed value, returning a Map from keys to collections of these values. The groupMapReduce method extends this by additionally reducing mapped values by a binary operator. Both methods depend on the context type CC representing the collection type parameter (e.g., List). These provide combined grouping and mapping or mapping plus reduction with more efficient and readable code compared to successive groupBy and mapValues calls.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/collections-migration-213.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ndef groupMap[K, B](key: A => K)(f: A => B): Map[K, CC[B]] // (Where `CC` can be `List`, for instance)\ndef groupMapReduce[K, B](key: A => K)(f: A => B)(g: (B, B) => B): Map[K, B]\n```\n\n----------------------------------------\n\nTITLE: Embedding and Interacting with Scala REPL Using javax.script and nsc APIs in Scala\nDESCRIPTION: This Scala code demonstrates initializing the Scala REPL within a JVM application using the scala.tools.nsc and javax.script APIs. It showcases how to obtain and use a ScriptEngine for instantaneous code evaluation, configure REPL compiler settings (e.g., warnings, linting), create an interpreter (IMain), implement a helper function to interpret snippets with result handling, and manage interactive or programmatic input via ILoop. Dependencies include the Scala compiler and its tools modules, and the Java Scripting API. The code expects Scala 2.x and appropriate classpath setup; limitations include a heavy reliance on internal Scala APIs and JVM-specific resource requirements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/repl/embedding.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.tools.nsc.Settings\nimport scala.tools.nsc.interpreter._\nimport javax.script._\n\n/** A simple example showing programmatic usage of the REPL. */\nobject Main extends App {\n\n  // the REPL has some support for javax.script\n  val scripter = new ScriptEngineManager().getEngineByName(\"scala\")\n  scripter.eval(\"\"\"println(\"hello, world\")\"\"\")\n\n  // compiler settings\n  val settings = new Settings\n  settings.processArgumentString(\"-deprecation -feature -Xfatal-warnings -Xlint\")\n\n  // the interpreter is used by the javax.script engine\n  val intp = new IMain(settings)\n  def interpret(code: String): Unit = {\n    import Results._\n    val res = intp.interpret(code) match {\n      case Success => \"OK!\"\n      case _       => \"Sorry, try again.\"\n    }\n    println(res)\n  }\n  interpret(\"\"\"println(\"hello, world\")\"\"\")\n  interpret(\"\"\"println(\"\"\"\")\"\"\")\n  interpret(\"\"\"val who = \"world\" ; println(\"hello, $who\")\"\"\")\n\n  // the REPL uses a line reader and an interpreter interactively\n  val interactive = new ILoop()\n  interactive.process(settings)\n\n  // input to the REPL can be provided programmatically\n  import java.io.{BufferedReader, StringReader, PrintWriter}\n  val reader = new BufferedReader(new StringReader(\"\"\"\"hello, world\"\"\"\"))\n  val canned = new ILoop(reader, new PrintWriter(Console.out, true))\n  canned.process(settings)\n\n  // more canning\n  val code = \"\"\"println(\"hello, world\") ; 42\"\"\"\n  val out = ILoop.run(code)\n  println(s\"Output is $out\")\n}\n```\n\n----------------------------------------\n\nTITLE: Package naming conventions with domain segments in Scala 2 and 3\nDESCRIPTION: Illustrates best practices for naming packages with fully qualified domain names, e.g., 'com.google.selfdrivingcar.camera'. This helps in avoiding naming conflicts and organizing corporate or organizational codebases effectively.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/packages-and-imports.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\npackage com.google.selfdrivingcar.camera\n\nclass Lens\n```\n\n----------------------------------------\n\nTITLE: Handling Try Result with Pattern Matching and For Expressions in Scala\nDESCRIPTION: This snippet shows two ways to handle a Try[Int] result: pattern matching to distinguish successful and failed conversions and for-expressions to chain multiple Try results. Pattern matching can provide detailed error reporting; for-expressions elegantly combine dependent computations. Inputs are Try[Int] values, outputs either perform side-effects or yield Try[Int] containing the result of summing multiple integers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/functional-error-handling.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ntoInt(x) match {\n    case Success(i) => println(i)\n    case Failure(s) => println(s\"Failed. Reason: $s\")\n}\n\nval y = for {\n    a <- toInt(stringA)\n    b <- toInt(stringB)\n    c <- toInt(stringC)\n} yield a + b + c\n```\n\n----------------------------------------\n\nTITLE: Creating an Empty Immutable Queue in Scala\nDESCRIPTION: Demonstrates how to initialize an empty immutable `Queue` explicitly typed to hold `Int` values using `scala.collection.immutable.Queue[Int]()`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/concrete-immutable-collection-classes.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval empty = scala.collection.immutable.Queue[Int]()\n```\n\nLANGUAGE: output\nCODE:\n```\nempty: scala.collection.immutable.Queue[Int] = Queue()\n```\n\n----------------------------------------\n\nTITLE: Handling Failed Pattern Matching with Extractors in Scala\nDESCRIPTION: This example shows what happens when pattern matching with an extractor fails. When the input string doesn't match the expected pattern, it throws a scala.MatchError exception.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/extractor-objects.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval CustomerID(name2) = \"--asdfasdfasdf\"\n```\n\n----------------------------------------\n\nTITLE: Deconstructing Tuples by Pattern Matching in Scala 2 and 3\nDESCRIPTION: Shows how to assign tuple elements to individual variable names using pattern matching (destructuring declaration). This approach provides readable variable bindings corresponding to tuple fields and facilitates further processing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-collections.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval (num, str, person) = t\n\n// result:\n// val num: Int = 11\n// val str: String = eleven\n// val person: Person = Person(Eleven)\n```\n\n----------------------------------------\n\nTITLE: Applying the Map Method to Collections in Scala\nDESCRIPTION: Demonstrates the use of the map method on collection types (List and Set) in Scala's REPL, highlighting the uniform return type principle. The examples show that mapping over a List returns a List, and mapping over a Set returns a Set. These commands require Scala REPL or script and produce transformed collections as output. Inputs are the initial collection and a mapping function; outputs are the new collections with the mapped values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/overview.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nscala> List(1, 2, 3) map (_ + 1)\nres0: List[Int] = List(2, 3, 4)\nscala> Set(1, 2, 3) map (_ * 2)\nres0: Set[Int] = Set(2, 4, 6)\n```\n\n----------------------------------------\n\nTITLE: Summoning Type Instances for All Types in a Tuple and Returning as List\nDESCRIPTION: A recursive function that summons type class instances for each type in a tuple type and returns them as a List of expressions. It reports errors when instances cannot be summoned.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/faq.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef summonAllInList[T](using Type[T])(using Quotes): List[Expr[Any]] = {\n  Type.of[T] match\n    case '[ head *: tail ] =>\n      Expr.summon[head] match\n        case Some(headExpr) => headExpr :: summonAllInList[tail]\n        case _ => quotes.reflect.report.throwError(s\"Could not summon ${Type.show[head]}\")\n    case '[ EmptyTuple ] => Nil\n    case _ => quotes.reflect.report.throwError(s\"Could not `summonAllInList` of tuple with unknown size: ${Type.show[T]}\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using Generated Methods in Scala 'Person' Case Class\nDESCRIPTION: Highlights methods automatically generated for case classes, such as pattern matching with 'unapply', copying with 'copy', structural equality with 'equals', and a helpful 'toString' representation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\nchristina match {\n  case Person(n, r) => println(\"name is \" + n)\n}\n\nval hannah = Person(\"Hannah\", \"niece\")\nchristina == hannah       // false\n\nprintln(christina)        // Person(Christina,niece)\n\nval cubs1908 = BaseballTeam(\"Chicago Cubs\", 1908)\nval cubs2016 = cubs1908.copy(lastWorldSeriesWin = 2016)\n```\n\n----------------------------------------\n\nTITLE: Iterating Map with Foreach Method and Pattern Matching in Scala\nDESCRIPTION: Demonstrates iterating over the `ratings` map using the `foreach` method combined with pattern matching (`case (movie, rating)`). This approach cleanly extracts the key and value of each map entry within the function literal passed to `foreach`, allowing easy access for processing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/for-loops.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nratings.foreach {\n    case(movie, rating) => println(s\"key: $movie, value: $rating\")\n}\n```\n\n----------------------------------------\n\nTITLE: Определение иерархии типов с трейтов Scala 2 и 3\nDESCRIPTION: Этот фрагмент кода определяет базовый набор типов с помощью трейтов: Item, Buyable (расширяет Item) и Book (расширяет Buyable). Эти типы используются как базовые примеры для иллюстрации подтиповых отношений в контексте вариантности. Зависимостей нет, код демонстрирует простую иерархию интерфейсов с методами, возвращающими определённые свойства.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-variance.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Item { def productNumber: String }\ntrait Buyable extends Item { def price: Int }\ntrait Book extends Buyable { def isbn: String }\n```\n\n----------------------------------------\n\nTITLE: Selective Importing from Objects in Scala\nDESCRIPTION: Demonstrating how to import only specific members from an object using import selectors.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport StringUtils.{truncate, containsWhitespace}\ntruncate(\"Charles Carmichael\", 7)       // \"Charles\"\ncontainsWhitespace(\"Captain Awesome\")   // true\nisNullOrEmpty(\"Morgan Grimes\")          // Not found: isNullOrEmpty (error)\n```\n\n----------------------------------------\n\nTITLE: Using Context Bounds for Type Members in Scala\nDESCRIPTION: Demonstrates the proposal to allow context bounds (e.g., `: Ord`) directly on abstract type members (`Element`) within a class or trait definition (`Collection`). This aims to improve orthogonality between type parameters and type members.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nclass Collection:\n  type Element : Ord\n```\n\n----------------------------------------\n\nTITLE: Example of futures failed projection in Scala with Scala 2 syntax\nDESCRIPTION: Creates a future that fails with a division by zero, then uses `failed` projection to catch and print the exception if the future fails. Illustrates how to handle errors in asynchronous computations using the `failed` projection with a for-comprehension.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_27\n\nLANGUAGE: Scala\nCODE:\n```\nval f = Future {\n  2 / 0\n}\nfor (exc <- f.failed) println(exc)\n```\n\n----------------------------------------\n\nTITLE: Filter Function Using Filter Method in Scala\nDESCRIPTION: Demonstrates filtering elements in Scala collection 'numbers' for those greater than 1 using the 'filter' method with an anonymous predicate function.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_34\n\nLANGUAGE: Scala\nCODE:\n```\nval x = numbers.filter(_ > 1)\n```\n\n----------------------------------------\n\nTITLE: Defining Multi-Expression Anonymous Function -- Scala\nDESCRIPTION: This snippet declares a val named f1 and assigns it an anonymous function value that takes two Int parameters (a and b), calculates their sum in a local variable, and returns the result. It follows the recommended Scala style for multi-line, multi-expression functions: using braces, clear parameter listing, and an explicit arrow (=>) on the opening line. Dependencies: None, but requires Scala. Inputs: Two integers a and b. Outputs: The sum of the two integers. This style enhances code readability and leverages type inference where possible.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/declarations.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval f1 = { (a: Int, b: Int) =>\n  val sum = a + b\n  sum\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Mutable Map in Scala\nDESCRIPTION: This code initializes a mutable Map from Scala's 'collection.mutable' package, mapping string keys to string values. Mutable Maps can have their contents updated in place. No dependencies outside the standard Scala library are needed. Provides a starting point for in-place key-value operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/collections-maps.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval states = scala.collection.mutable.Map(\n    \"AL\" -> \"Alabama\", \n    \"AK\" -> \"Alaska\"\n)\n```\n\n----------------------------------------\n\nTITLE: Declaring an Explicit main Method for Cross-Compatibility in Scala 2 and 3\nDESCRIPTION: Provides a Scala source compatible with both Scala 2 and Scala 3, defining an object containing a private helper method with typed parameters and an explicit main method accepting an Array[String]. The main method manually parses and converts command-line strings to typed parameters, then forwards them to the helper method. It uses the :_* syntax to pass variable-length argument sequences. This approach supports both Scala versions and maintains functionality similar to @main methods without requiring Scala 3-specific annotation support.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/methods-main-methods.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nobject happyBirthday {\n  private def happyBirthday(age: Int, name: String, others: String*) = {\n    ... // тоже, что и раньше\n  }\n  def main(args: Array[String]): Unit =\n    happyBirthday(args(0).toInt, args(1), args.drop(2).toIndexedSeq:_*)\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating the Need for Intersection Types in Scala 3 (Incomplete)\nDESCRIPTION: Presents an incomplete function `cloneAndReset` using Scala 3 syntax. It highlights the problem of needing an input object (`obj`) that supports both `clone` and `reset` methods, indicated by the placeholder type `?`, thus motivating the use of intersection types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/compound-types.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef cloneAndReset(obj: ?): Cloneable =\n  val cloned = obj.clone()\n  obj.reset\n  cloned\n```\n\n----------------------------------------\n\nTITLE: Performing Arithmetic with BigInt in Scala\nDESCRIPTION: This snippet demonstrates arithmetic operations (addition and multiplication) with BigInt, showcasing automatic operator overloading. The variables b, c, and d are of type scala.math.BigInt. No special setup needed beyond the Scala standard library.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/first-look-at-types.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval b = BigInt(1234567890)   // scala.math.BigInt = 1234567890\nval c = b + b                // scala.math.BigInt = 2469135780\nval d = b * b                // scala.math.BigInt = 1524157875019052100\n```\n\n----------------------------------------\n\nTITLE: Instantiating a Scala Class at Runtime Using Reflection\nDESCRIPTION: Shows how to instantiate a Scala case class dynamically at runtime by obtaining a class mirror, locating the constructor symbol, and invoking the constructor with arguments. Requires a classloader and the runtime universe.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/overview.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.runtime.{universe => ru}\n\ncase class Person(name: String)\n\nval m = ru.runtimeMirror(getClass.getClassLoader)\nval classSymbol = ru.typeOf[Person].typeSymbol.asClass\nval classMirror = m.reflectClass(classSymbol)\nval constructor = ru.typeOf[Person].decl(ru.termNames.CONSTRUCTOR).asMethod\nval constructorMirror = classMirror.reflectConstructor(constructor)\nval personInstance = constructorMirror(\"Mike\")\nprintln(personInstance)  // Outputs: Person(Mike)\n```\n\n----------------------------------------\n\nTITLE: Defining a Pattern Matching Method with Various Patterns in Scala 2\nDESCRIPTION: Defines a method named `pattern` that accepts a `Matchable` input and returns a descriptive string based on matching the input against numerous pattern types. It showcases constant patterns, sequence patterns (matching lists and vectors), tuple patterns up to three elements, constructor patterns for custom classes like Person and Dog, type test patterns for primitive and collection types, and a default wildcard case. Dependencies include custom classes Person and Dog and the Matchable trait. The method returns a string describing the matched pattern or \"Unknown\" for no match.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\ndef pattern(x: Matchable): String = x match {\n\n  // constant patterns\n  case 0 => \"zero\"\n  case true => \"true\"\n  case \"hello\" => \"you said 'hello'\"\n  case Nil => \"an empty List\"\n\n  // sequence patterns\n  case List(0, _, _) => \"a 3-element list with 0 as the first element\"\n  case List(1, _*) => \"list, starts with 1, has any number of elements\"\n  case Vector(1, _*) => \"vector, starts w/ 1, has any number of elements\"\n\n  // tuple patterns\n  case (a, b) => s\"got $a and $b\"\n  case (a, b, c) => s\"got $a, $b, and $c\"\n\n  // constructor patterns\n  case Person(first, \"Alexander\") => s\"Alexander, first name = $first\"\n  case Dog(\"Zeus\") => \"found a dog named Zeus\"\n\n  // type test patterns\n  case s: String => s\"got a string: $s\"\n  case i: Int => s\"got an int: $i\"\n  case f: Float => s\"got a float: $f\"\n  case a: Array[Int] => s\"array of int: ${a.mkString(\",\") }\"\n  case as: Array[String] => s\"string array: ${as.mkString(\",\") }\"\n  case d: Dog => s\"dog: ${d.name}\"\n  case list: List[?] => s\"got a List: $list\"\n  case m: Map[?, ?] => m.toString\n\n  // the default wildcard pattern\n  case _ => \"Unknown\"\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating Scala Address Class with Some Value for Optional Field (Scala 2 and 3)\nDESCRIPTION: These snippets show creating Address instances where street2 contains a valid secondary address value wrapped in Some, explicitly representing presence of that optional field. This usage ensures clarity and safety compared to using nullable strings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-functional-error-handling.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nval santa = new Address(\n  \"123 Main Street\",\n  Some(\"Apt. 2B\"),\n  \"Talkeetna\",\n  \"Alaska\",\n  \"99676\"\n)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval santa = Address(\n  \"123 Main Street\",\n  Some(\"Apt. 2B\"),\n  \"Talkeetna\",\n  \"Alaska\",\n  \"99676\"\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a Function to Negate Elements in a Mutable Scala Sequence - Scala\nDESCRIPTION: Defines `negate` function that iterates over all elements of a mutable sequence, replacing each element with its negative value. It modifies the sequence in place, demonstrating a simple update operation on mutable collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/views.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ndef negate(xs: collection.mutable.Seq[Int]) =\n  for (i <- 0 until xs.length) xs(i) = -xs(i)\n```\n\n----------------------------------------\n\nTITLE: Basic Default Arguments Usage in Scala\nDESCRIPTION: Shows how to define methods with default arguments and how to call such methods by omitting the parameters with defaults. Default expressions are evaluated when the method is called.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-and-default-arguments.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ndef f(a: Int, b: String = \"defaultString\", c: Int = 5)\nf(1)\nf(1, \"otherString\")\nf(1, c = 10) // c needs to be specified as named argument\n```\n\n----------------------------------------\n\nTITLE: Intercepting Exceptions in MUnit Tests using Scala 2\nDESCRIPTION: Defines a test case using MUnit in Scala 2 that verifies an operation throws a NoSuchFileException. It imports necessary classes, sets up a test suite, and uses the intercept assertion with a type parameter specifying the expected exception. The code attempts to read a missing file, expecting the exception to be thrown, causing the test to pass only if the exception occurs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-exceptions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport java.nio.file.NoSuchFileException\n\nclass FileTests extends munit.FunSuite {\n  test(\"read missing file\") {\n    val missingFile = os.pwd / \"missing.txt\"\n    \n    intercept[NoSuchFileException] { \n      os.read(missingFile)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Scala 2 'maxElement' leveraging implicit 'max' function, no explicit context parameter\nDESCRIPTION: Implements 'maxElement' by reducing a list using the 'max' function, relying on implicit resolution to supply the 'Ord' instance. The method omits explicit context parameters, demonstrating how Scala 2 can use implicits to simplify function signatures. This pattern facilitates concise maximum element retrieval.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-context-bounds.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef maxElement[A](as: List[A])(implicit ord: Ord[A]): A =\n  as.reduceLeft(max(_, _))\n```\n\n----------------------------------------\n\nTITLE: Incorrect usage of custom ExecutionContext with Futures\nDESCRIPTION: Illustrates how using a custom ExecutionContext that executes tasks synchronously can lead to unpredictable behavior when composing Futures, and advises against such practices.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nFuture {\n  doSomething\n}(ExecutionContext.global).map {\n  doSomethingElse\n}(currentThreadExecutionContext)\n```\n\n----------------------------------------\n\nTITLE: Importing Mutable Collections in Scala\nDESCRIPTION: A common convention when using both mutable and immutable collections is to import only the mutable package, which allows using immutable collections without prefix and mutable ones with the 'mutable' prefix.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/overview.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Stack Class in Scala\nDESCRIPTION: This snippet defines a generic Stack class parameterized by type A, implementing common stack operations including push, pop, and peek. It maintains an internal list of elements of type A to ensure type safety for stored values. The class enforces type restrictions on method parameters and return types consistent with the generic type. Dependencies include Scala's standard List collection. The class allows creation of stacks for any type, supporting strong typing throughout. Limitations include no thread safety and use of a mutable var for elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/generic-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Stack[A] {\n  private var elements: List[A] = Nil\n  def push(x: A): Unit =\n    elements = x :: elements\n  def peek: A = elements.head\n  def pop(): A = {\n    val currentTop = peek\n    elements = elements.tail\n    currentTop\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Showing Parameter List in Function Variable Declaration in Scala\nDESCRIPTION: Highlights the parameter list `(i: Int)` in the function variable `double` declaration, indicating that `double` is a function taking a single Int parameter. This snippet helps explain function signature structure, with no input/output beyond the declaration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-function-variables.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval double = (i: Int) => i * 2\n```\n\n----------------------------------------\n\nTITLE: Running sbt Build and Execution - Bash Command and Output\nDESCRIPTION: This snippet shows the command to run the sbt build and execute the main method, as well as the expected detailed output from sbt. It includes steps sbt performs such as loading project definition, compiling Scala sources, running the main class 'helloWorld', and indications of build success and timing information.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt run\n[info] welcome to sbt 1.5.4 (AdoptOpenJDK Java 11.x)\n[info] loading project definition from project ...\n[info] loading settings for project from build.sbt ...\n[info] compiling 1 Scala source to target/scala-3.0.0/classes ...\n[info] running helloWorld\nHello, world\n[success] Total time: 2 s\n```\n\n----------------------------------------\n\nTITLE: Constructing Literal Constant AST Nodes in Scala (Scala)\nDESCRIPTION: Demonstrates the creation of an AST node representing an integer literal constant using the scala.reflect API. The example uses the Constant and Literal classes to wrap a value such as 5, producing a compile-time constant expression node. This snippet illustrates how literals are modeled internally for reflection and macro usage.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/reflection/annotations-names-scopes.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nLiteral(Constant(5))\n```\n\n----------------------------------------\n\nTITLE: Traits and Inheritance in Scala\nDESCRIPTION: Shows how to define traits as interfaces in Scala, implementing them in classes, and using inheritance. Traits can have both abstract and concrete members, enabling code reuse through mixins.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\ntrait HasLegs:\n  def numLegs: Int\n  def walk(): Unit\n  def stop() = println(\"Stopped walking\")\n\ntrait HasTail:\n  def wagTail(): Unit\n  def stopTail(): Unit\n\nclass Dog(var name: String) extends HasLegs, HasTail:\n  val numLegs = 4\n  def walk() = println(\"I'm walking\")\n  def wagTail() = println(\"⎞⎜⎛  ⎞⎜⎛\")\n  def stopTail() = println(\"Tail is stopped\")\n  override def toString = s\"$name is a Dog\"\n\n// create a Dog instance\nval d = Dog(\"Rover\")\n\n// use the class's attributes and behaviors\nprintln(d.numLegs)   // 4\nd.wagTail()          // \"⎞⎜⎛  ⎞⎜⎛\"\nd.walk()             // \"I'm walking\"\n```\n\n----------------------------------------\n\nTITLE: Defining the Liftable Type Class - Scala\nDESCRIPTION: This snippet demonstrates the definition of the Liftable trait, which serves as a type class mapping a value of type T to a Tree. This is a core component required for enabling custom data type unquoting in quasiquotes. It introduces an abstract apply method that must be provided for every Liftable instance, with T being any data type whose instances you want to lift.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/lifting.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Liftable[T] {\n  def apply(value: T): Tree\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating Through Tuple Lists with For Comprehension in Scala\nDESCRIPTION: Demonstrates how to use a for comprehension to iterate through a list of tuples, destructuring each tuple in the process.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/tuples.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval numPars = List((2, 5), (3, -7), (20, 56))\nfor ((a, b) <- numPars) {\n  println(a * b)\n}\n```\n\n----------------------------------------\n\nTITLE: Ambiguity in Overloaded Methods with Named Arguments\nDESCRIPTION: Shows how named arguments can lead to ambiguity in overloaded method resolution when multiple methods are applicable but none is more specific than the others.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-and-default-arguments.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef f(a: Int, b: String)   // #1\ndef f(b: Object, a: Int)   // #2\nf(a = 1, b = \"someString\") // \"error: ambiguous reference to\n                           // overloaded definition\"\n```\n\n----------------------------------------\n\nTITLE: Using a Singleton Object's Method in Scala\nDESCRIPTION: Shows how to import and utilize the 'info' method from the previously defined 'logging.Logger' singleton object within a 'Test' class. This highlights how methods from singleton objects can be accessed globally after importing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/singleton-objects.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport logging.Logger.info\n\nclass Project(name: String, daysToComplete: Int)\n\nclass Test {\n  val project1 = new Project(\"TPS Reports\", 1)\n  val project2 = new Project(\"Website redesign\", 5)\n  info(\"Created projects\")  // Prints \"INFO: Created projects\"\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport logging.Logger.info\n\nclass Project(name: String, daysToComplete: Int)\n\nclass Test:\n  val project1 = Project(\"TPS Reports\", 1)\n  val project2 = Project(\"Website redesign\", 5)\n  info(\"Created projects\")  // Prints \"INFO: Created projects\"\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Dependent Function Types in Scala 3\nDESCRIPTION: Shows how Scala 3 introduces dependent function types, allowing the use of lambda syntax to create DB instances instead of verbose anonymous classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-dependent-function.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ntype DB = (k: Key) => Option[k.Value]\n//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n//      A dependent function type\n```\n\n----------------------------------------\n\nTITLE: Implementing Covariant Linked List with Lower Type Bound in Scala\nDESCRIPTION: Defines a covariant linked list node by marking the type parameter T as covariant and adjusting the prepend method to introduce a lower type bound U >: T. The prepend method takes an element of U (supertype of T) and returns a ListNode[U], allowing the addition of elements with compatible supertypes while preserving covariance. This implementation compiles successfully and supports flexible subtyping. No external dependencies are required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/lower-type-bounds.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ncase class ListNode[+T](h: T, t: ListNode[T]) {\n  def head: T = h\n  def tail: ListNode[T] = t\n  def prepend[U >: T](elem: U): ListNode[U] =\n    ListNode(elem, this)\n}\n```\n\n----------------------------------------\n\nTITLE: 演示asScala方法将Java容器转换为Scala容器 - Scala\nDESCRIPTION: 展示如何利用asScala扩展方法将Java的 java.util.List 转换为Scala的可变序列 Seq。转换过程是通过包装实现，避免了数据拷贝，保持对同一底层容器的引用。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/conversions-between-java-and-scala-collections.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> val buf: Seq[Int] = jul.asScala\nbuf: scala.collection.mutable.Seq[Int] = ArrayBuffer(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Covariant Linked List with Lower Type Bound Prepend Method in Scala\nDESCRIPTION: This snippet shows a covariant linked list declaration using a `+T` variance annotation in the `ListNode` case class. Since covariance restricts how the type parameter can be used, the `prepend` method leverages a lower type bound (`U >: T`) to accept elements of a supertype of `T`. The method returns a `ListNode[U]`, enabling flexible prepend operations without violating covariance constraints. This is a practical demonstration of combining variance annotations and lower type bounds for a more general linked list implementation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/lower-type-bounds.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class ListNode[+T](h: T, t: ListNode[T]) {\n  def head: T = h\n  def tail: ListNode[T] = t\n  def prepend[U >: T](elem: U): ListNode[U] =\n    ListNode(elem, this)\n}\n```\n\n----------------------------------------\n\nTITLE: Using getOrElseUpdate for efficient caching in Scala\nDESCRIPTION: Shows how to create a mutable Map as a cache and define a cached function that uses getOrElseUpdate to store and retrieve results, avoiding expensive recalculations for previously seen inputs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/maps.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval cache = collection.mutable.Map[String, String]()\n\ndef cachedF(s: String) = cache.getOrElseUpdate(s, f(s))\n```\n\n----------------------------------------\n\nTITLE: Indented Lambda Expressions with Fewer Braces in Scala\nDESCRIPTION: This snippet demonstrates mapping over a collection 'xs' with an indented lambda block using the fewerBraces feature. The lambda's logic is separated into lines, improving readability. This approach requires Scala 3 and the fewerBraces feature, either imported or enabled by default, and expects 'xs' is a collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nxs.map:\n  x =>\n    val y = x - 1\n    y * y\n```\n\n----------------------------------------\n\nTITLE: Creating a Parameterized Greeting Function with Custom Greeting Message\nDESCRIPTION: Defines a Scala method 'greet' that accepts a greeting message as a parameter and returns a function which incorporates this greeting when printing. It enables dynamic greetings by passing different messages, producing functions like 'sayHello' or 'sayCiao' that can be invoked with a name to print personalized greetings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-write-method-returns-function.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef greet(theGreeting: String): String => Unit = \n  (name: String) => println(s\"$theGreeting, $name\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Thread-Safe Mutable HashSet in Scala\nDESCRIPTION: Illustrates how to create a thread-safe mutable `HashSet` in Scala by mixing in the `SynchronizedSet` trait. This example imports the `scala.collection.mutable` package and then instantiates a `HashSet[Int]` mixed with `mutable.SynchronizedSet[Int]`, making it suitable for concurrent access.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/maps.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable\nval synchroSet =\n  new mutable.HashSet[Int] with\n      mutable.SynchronizedSet[Int]\n```\n\n----------------------------------------\n\nTITLE: Mapping with Lambdas in Scala 2 and 3\nDESCRIPTION: Demonstrates how to use anonymous functions (lambdas) with the 'map' method on a Scala List to multiply each element by 2. Shows two equivalent lambda syntaxes: a full lambda expression and a placeholder syntax. Requires Scala standard library with List and its 'map' method. Input is a List of integers; output is a new List with each element doubled. Does not mutate the original list.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-functions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval a = List(1, 2, 3).map(i => i * 2)   // List(2,4,6)\nval b = List(1, 2, 3).map(_ * 2)        // List(2,4,6)\n```\n\n----------------------------------------\n\nTITLE: Prepending Elements to an Immutable Vector in Scala\nDESCRIPTION: Shows how to create new `Vector` instances by prepending a single element (`+:`) or another collection (`++:`) to an existing immutable `Vector`. The original `Vector` remains unchanged. This syntax works for both Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\nval a = Vector(1,2,3)         // Vector(1, 2, 3)\nval b = 0 +: a                // Vector(0, 1, 2, 3)\nval c = Vector(-1, 0) ++: a   // Vector(-1, 0, 1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple ScalaTest Suite - Scala\nDESCRIPTION: Defines a test class called 'CubeCalculatorTest' using ScalaTest's AnyFunSuite for unit testing. This example tests the 'cube' function of the CubeCalculator object, asserting that passing the value 3 returns 27. Dependency: ScalaTest library must be present in the build (specified in build.sbt). The class expects CubeCalculator with a static 'cube' method. The input to the test is a hardcoded value of 3, and the expected output is 27.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/getting-started/sbt-track/testing-scala-with-sbt-on-the-command-line.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n  import org.scalatest.funsuite.AnyFunSuite\n\n  class CubeCalculatorTest extends AnyFunSuite {\n      test(\"CubeCalculator.cube\") {\n          assert(CubeCalculator.cube(3) === 27)\n      }\n  }\n```\n\n----------------------------------------\n\nTITLE: Deserializing JSON to a Case Class in Scala 3 using uPickle\nDESCRIPTION: Provides a full example of deserializing a JSON string into a custom `PetOwner` case class in Scala 3. It includes defining the case class with `derives ReadWriter`, calling `upickle.default.read`, and accessing the resulting object's properties. Requires the uPickle library.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-deserialize.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport upickle.default.*\n\ncase class PetOwner(name: String, pets: List[String]) derives ReadWriter\n\nval json = \"\"\"{\"name\": \"Peter\", \"pets\": [\"Toolkitty\", \"Scaniel\"]}\"\"\"\nval petOwner: PetOwner = read[PetOwner](json)\n\nval firstPet = petOwner.pets.head\nprintln(s\"${petOwner.name} has a pet called $firstPet\")\n// prints: Peter has a pet called Toolkitty\n```\n\n----------------------------------------\n\nTITLE: Capitalizing Strings with For/Yield Expressions in Scala 3\nDESCRIPTION: Transforms a list of lower-case name strings into a new list with each name capitalized using Scala 3 syntax. Requires a defined List[String] as names. Returns a value assigned to capNames.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nval names = List(\"chris\", \"ed\", \"maurice\")\nval capNames = for name <- names yield name.capitalize\n\n```\n\n----------------------------------------\n\nTITLE: 为 Person 类型实现 Showable 类型类的实例（Scala 2 和 Scala 3）\nDESCRIPTION: 为 Person 类型创建 Showable 类型类的具体实例，提供自定义的字符串表示。Scala 2 采用 implicit val 定义，并实现 trait 的抽象方法；Scala 3 使用 given 关键字和扩展方法语法。此实现依赖于 Scala 标准库，允许调用类型类的 show 方法得到人名全称。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/ca-type-classes.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit val showablePerson: Showable[Person] = new Showable[Person] {\n  def show(p: Person): String =\n    s\"${p.firstName} ${p.lastName}\"\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\ngiven Showable[Person] with\n  extension(p: Person) def show: String =\n    s\"${p.firstName} ${p.lastName}\"\n```\n\n----------------------------------------\n\nTITLE: Function Definition in Python and Scala\nDESCRIPTION: Shows how to define simple functions that return values, with single-line and multi-line function syntax. Highlights differences in syntax style and return statement usage.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ndef add(a, b): return a + b\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef add(a: Int, b: Int): Int = a + b\n\ndef walkThenRun() =\n  println(\"walk\")\n  println(\"run\")\n```\n\n----------------------------------------\n\nTITLE: Implementing a Variadic Sum Macro in Scala 3\nDESCRIPTION: This snippet defines an inline macro `sumNow` that sums a variable number of integer arguments at compile time using quoted expressions and underscores the use of the `Varargs` extractor to access individual parameters. It converts arguments to values and computes their sum, handling errors when the varargs are improperly provided.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/macros.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.quoted.* // imports `Varargs`, `Quotes`, etc.\n\ninline def sumNow(inline nums: Int*): Int =\n  ${ sumCode('nums)  }\n\ndef sumCode(nums: Expr[Seq[Int]])(using Quotes): Expr[Int] =\n  import quotes.reflect.report\n  nums match\n    case Varargs(numberExprs) => // numberExprs: Seq[Expr[Int]]\n      val numbers: Seq[Int] = numberExprs.map(_.valueOrAbort)\n      Expr(numbers.sum)\n    case _ => report.errorAndAbort(\n      \"Expected explicit varargs sequence. \" +\n      \"Notation `args*` is not supported.\", nums)\n```\n\n----------------------------------------\n\nTITLE: Scala Case Class and Data Manipulation\nDESCRIPTION: Defines a Scala case class 'Person' with immutability, akin to Python's frozen dataclass. Demonstrates instantiation and modification via copying, highlighting immutable data patterns in Scala with 'copy' method, and contrasts with Python's 'dataclasses.replace'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass, replace\n\n@dataclass(frozen=True)\nclass Person:\n  name: str\n  age: int\n```\n\nLANGUAGE: scala\nCODE:\n```\ncase class Person(name: String, age: Int)\n```\n\nLANGUAGE: python\nCODE:\n```\np = Person(\"Alice\", 42)\n p.name  # Alice\n p2 = replace(p, age=43)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval p = Person(\"Alice\", 42)\n p.name  // Alice\n val p2 = p.copy(age = 43)\n```\n\n----------------------------------------\n\nTITLE: Using Subtyping with Trait Inheritance in Scala\nDESCRIPTION: Demonstrates subtyping by assigning an instance of `MyService` to variables typed as its inherited traits (`GreetingService`, `TranslationService`, `Showable`). This works because `MyService` is a subtype of all these traits. The syntax is the same for Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-oop.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval s2: GreetingService = s1\nval s3: TranslationService = s1\nval s4: Showable = s1\n// ... and so on ...\n```\n\n----------------------------------------\n\nTITLE: Creating Objects and Using Factory Methods in Scala\nDESCRIPTION: Examples contrasting incorrect usage of abstract types with direct 'new' and the correct idiomatic use of companion object factory methods to create instances. It also shows class literals, runtime type checking using isInstanceOf, and runtime casting using asInstanceOf. These snippets highlight best practices for object creation, type semantics, and reflections in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/cheatsheets/index.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nnew java.io.File(\"f\")\n```\n\nLANGUAGE: Scala\nCODE:\n```\nnew List[Int]\n```\n\nLANGUAGE: Scala\nCODE:\n```\nList(1, 2, 3)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclassOf[String]\n```\n\nLANGUAGE: Scala\nCODE:\n```\nx.isInstanceOf[String]\n```\n\nLANGUAGE: Scala\nCODE:\n```\nx.asInstanceOf[String]\n```\n\nLANGUAGE: Scala\nCODE:\n```\nx: String\n```\n\n----------------------------------------\n\nTITLE: Implementing a Trait in a Class in Scala\nDESCRIPTION: Defines the `Document` class which extends the `Showable` trait and provides a concrete implementation for the abstract `show` method. Shows Scala 2 and Scala 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-oop.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass Document(text: String) extends Showable {\n  def show = text\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Document(text: String) extends Showable:\n  def show = text\n```\n\n----------------------------------------\n\nTITLE: Class Inheritance with Constructor Parameters in Scala\nDESCRIPTION: Demonstrates how to pass constructor parameters from a subclass to its parent class. Shows the automatic parameter forwarding pattern.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/cheatsheets/index.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nclass D(var x: R)\nclass C(x: R) extends D(x)\n```\n\n----------------------------------------\n\nTITLE: Using stripMargin to Align Multi-line Strings in Scala\nDESCRIPTION: Defines a multi-line string literal where each line after the first starts with a pipe ('|') character to act as a margin marker. The stripMargin method is called to remove leading whitespace up to the margin character, effectively left-aligning the string content for cleaner formatting.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/first-look-at-types.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval quote = \"\"\"The essence of Scala:\n               |Fusion of functional and object-oriented\n               |programming in a typed setting.\"\"\".stripMargin\n```\n\n----------------------------------------\n\nTITLE: Wrapping Blocking Code with scala.concurrent.blocking in a Future (Scala 2 and 3)\nDESCRIPTION: Illustrates the idiomatic way to mark blocking operations inside a Future using the scala.concurrent.blocking construct. This informs the ExecutionContext, especially ForkJoinPool, that blocking is occurring so that it can manage thread resources accordingly and avoid starvation. The example includes locking a resource within the blocking block inside a Future. Dependencies include scala.concurrent.Future and scala.concurrent.blocking. This works equally in Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.concurrent.Future\nimport scala.concurrent.blocking\n\nFuture {\n  blocking {\n    myLock.lock()\n    // ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Abstract Trait (Greeter) in Scala\nDESCRIPTION: Illustrates the definition of an abstract `Greeter` trait using the `trait` keyword in Scala 2 and Scala 3. This trait declares an abstract method `greet` that takes a String parameter and returns Unit, without providing an implementation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_27\n\nLANGUAGE: scala\nCODE:\n```\ntrait Greeter {\n  def greet(name: String): Unit\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait Greeter:\n  def greet(name: String): Unit\n```\n\n----------------------------------------\n\nTITLE: Overriding Methods in Scala Subclasses\nDESCRIPTION: Shows that Scala requires explicit declaration of overridden methods in subclasses using the 'override' modifier. This snippet depicts defining a method 'f' in class C that inherits from D and overrides the superclass method. The snippet emphasizes adherence to Scala's overriding rules and compiler checks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/cheatsheets/index.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nclass C extends D { override def f = ...}\n```\n\n----------------------------------------\n\nTITLE: Defining Methods with 'def'\nDESCRIPTION: Illustrates method definitions using 'def', including returning values, multiple parameter lists, and multi-line bodies, highlighting key syntax details like return types and method invocation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/basics.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ndef add(x: Int, y: Int): Int = x + y\nprintln(add(1, 2)) // 3\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef addThenMultiply(x: Int, y: Int)(multiplier: Int): Int = (x + y) * multiplier\nprintln(addThenMultiply(1, 2)(3)) // 9\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef name: String = System.getProperty(\"user.name\")\nprintln(\"Hello, \" + name + \"!\")\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef getSquareString(input: Double): String = {\n  val square = input * input\n  square.toString\n}\nprintln(getSquareString(2.5)) // 6.25\n```\n\n----------------------------------------\n\nTITLE: Verifying Constructor Parameter Passing in Scala Abstract Classes\nDESCRIPTION: This complete Scala example demonstrates the process of passing a constructor parameter ('name') from a subclass ('Dog') to its abstract superclass ('Pet'). It defines both classes, instantiates the subclass, and calls a method ('speak') in the superclass that uses the passed parameter, verifying the mechanism works correctly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/abstract-classes.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Pet (name: String) {\n    def speak: Unit = println(s\"My name is $name\")\n}\n\nclass Dog(name: String) extends Pet(name)\n\nval d = new Dog(\"Fido\")\nd.speak\n```\n\n----------------------------------------\n\nTITLE: Using Mnemonic Type Parameters in Scala for Brevity\nDESCRIPTION: Illustrates using short, mnemonic names (e.g., 'K' for Key, 'V' for Value) for type parameters when their scope is limited and context is clear, offering a concise alternative to full descriptive names.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/naming-conventions.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nclass Map[K, V] {\n  def get(key: K): V\n  def put(key: K, value: V): Unit\n}\n```\n\n----------------------------------------\n\nTITLE: Using protected methods in Scala class inheritance\nDESCRIPTION: This example illustrates the use of protected methods that are accessible within the class and its subclasses but not externally, alongside private and public methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/methods-most.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass Animal {\n  private def breathe() = println(\"I'm breathing\")\n  def walk() = {\n    breathe()\n    println(\"I'm walking\")\n  }\n  protected def speak() = println(\"Hello?\")\n}\n\nclass Cat extends Animal {\n  override def speak() = println(\"Meow\")\n}\n\nval cat = new Cat\ncat.walk()\ncat.speak()\ncat.breathe()   // won't compile because it's private\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Animal:\n  private def breathe() = println(\"I'm breathing\")\n  def walk() =\n    breathe()\n    println(\"I'm walking\")\n  protected def speak() = println(\"Hello?\")\n\nclass Cat extends Animal:\n  override def speak() = println(\"Meow\")\n\nval cat = new Cat\ncat.walk()\ncat.speak()\ncat.breathe()   // won't compile because it's private\n```\n\n----------------------------------------\n\nTITLE: Example of Utility Object in Scala\nDESCRIPTION: Defines a singleton object `PizzaUtils` with utility functions for pizza operations such as adding or removing toppings. It illustrates the use of Scala's 'object' for creating singleton utility modules. Dependencies include the `Pizza` and `Topping` classes (not shown).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/case-objects.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject PizzaUtils {\n    def addTopping(p: Pizza, t: Topping): Pizza = ...\n    def removeTopping(p: Pizza, t: Topping): Pizza = ...\n    def removeAllToppings(p: Pizza): Pizza = ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Trait in Scala\nDESCRIPTION: In Scala, a trait is a type that can be mixed into classes and other traits. A basic trait can be empty, similar to a Java marker interface, providing a type for classification.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Marker\n```\n\n----------------------------------------\n\nTITLE: Defining Enum with Members (Scala)\nDESCRIPTION: This Scala snippet shows a complex enum definition with parameters (acting as fields), case members extending the enum with specific values, a private constant (`val`), and instance methods (`def`) that utilize the member data and constants.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_70\n\nLANGUAGE: Scala\nCODE:\n```\nenum Planet(\n  mass: Double,\n  radius: Double\n):\n  case Mercury extends\n    Planet(3.303e+23, 2.4397e6)\n  case Venus extends\n    Planet(4.869e+24, 6.0518e6)\n  case Earth extends\n    Planet(5.976e+24, 6.37814e6)\n    // more planets ...\n\n  private final val G = 6.67300E-11\n\n  def surfaceGravity =\n    G * mass / (radius * radius)\n\n  def surfaceWeight(otherMass: Double)\n    = otherMass * surfaceGravity\n```\n\n----------------------------------------\n\nTITLE: Illustrating Scala Collection Methods\nDESCRIPTION: Provides practical examples of various Scala collection methods applied to a sample `List`. Demonstrates methods like `distinct`, `drop`, `filter`, `find`, `head`, `tail`, `slice`, `take`, etc., showing the resulting collection after each operation without mutating the original list `a`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_69\n\nLANGUAGE: Scala\nCODE:\n```\nval a = List(10, 20, 30, 40, 10)      // List(10, 20, 30, 40, 10)\na.distinct                            // List(10, 20, 30, 40)\na.drop(2)                             // List(30, 40, 10)\na.dropRight(2)                        // List(10, 20, 30)\na.dropWhile(_ < 25)                   // List(30, 40, 10)\na.filter(_ < 25)                      // List(10, 20, 10)\na.filter(_ > 100)                     // List()\na.find(_ > 20)                        // Some(30)\na.head                                // 10\na.headOption                          // Some(10)\na.init                                // List(10, 20, 30, 40)\na.intersect(List(19,20,21))           // List(20)\na.last                                // 10\na.lastOption                          // Some(10)\na.slice(2,4)                          // List(30, 40)\na.tail                                // List(20, 30, 40, 10)\na.take(3)                             // List(10, 20, 30)\na.takeRight(2)                        // List(40, 10)\na.takeWhile(_ < 30)                   // List(10, 20)\n```\n\n----------------------------------------\n\nTITLE: Using Regex Patterns with Pattern Matching to Process Contact Information Strings in Scala\nDESCRIPTION: This code defines regex patterns for email and phone numbers, then uses pattern matching in a function to identify and process contact data. The function prints messages based on whether the input matches email, phone, or neither. Dependencies include 'scala.util.matching.Regex'; inputs are various contact strings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/regular-expression-patterns.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef saveContactInformation(contact: String): Unit = {\n  import scala.util.matching.Regex\n\n  val emailPattern: Regex = \"^\\\\w+@(\\\\w+(\\\\.\\\\w+)+)$\".r\n  val phonePattern: Regex = \"^\\d{3}-\\d{3}-\\d{4}$\".r\n\n  contact match {\n    case emailPattern(localPart, domainName, _) => \n      println(s\"Hi $localPart, we have saved your email address.\")\n    case phonePattern(phoneNumber) => \n      println(s\"Hi, we have saved your phone number $phoneNumber.\")\n    case _ => \n      println(\"Invalid contact information, neither an email address nor phone number.\")\n  }\n}\n\nsaveContactInformation(\"123-456-7890\")\nsaveContactInformation(\"JohnSmith@sample.domain.com\")\nsaveContactInformation(\"2 Franklin St, Mars, Milky Way\")\n```\n\n----------------------------------------\n\nTITLE: For Comprehension with flatMap and withFilter for Composing Multiple Futures in Scala\nDESCRIPTION: This snippet shows how to compose multiple dependent Futures using a for-comprehension that desugars to flatMap and withFilter calls. It obtains USD and CHF quotes concurrently, filters them by profitability condition, then yields a buy operation asynchronously. The resulting Future completes only after both futures succeed and satisfy the filter condition. This pattern simplifies combining asynchronous computations needing to access multiple Future results, supporting expressive, declarative asynchronous logic.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/futures.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nval usdQuote = Future { connection.getCurrentValue(USD) }\nval chfQuote = Future { connection.getCurrentValue(CHF) }\n\nval purchase = for {\n  usd <- usdQuote\n  chf <- chfQuote\n  if isProfitable(usd, chf)\n} yield connection.buy(amount, chf)\n\npurchase foreach { _ =>\n  println(amount + \" CHF を購入した\")\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple Traits in a Class in Scala\nDESCRIPTION: Defines the `MyService` class extending the composed `ComposedService` trait and the `Showable` trait. It implements the required `show` method from `Showable`. Shows Scala 2 and 3 syntax differences for multiple inheritance (`with` vs `,`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-oop.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass MyService(name: String) extends ComposedService with Showable {\n  def show = s\"$name says $sayHello\"\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass MyService(name: String) extends ComposedService, Showable:\n  def show = s\"$name says $sayHello\"\n```\n\n----------------------------------------\n\nTITLE: Instantiating Java Objects in Scala\nDESCRIPTION: Demonstrates creating a new instance of a Java class 'java.io.File' from Scala code. This interoperability snippet shows how Scala code can instantiate Java classes directly using 'new', enabling seamless integration with Java libraries.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/cheatsheets/index.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nnew java.io.File(\"f\")\n```\n\n----------------------------------------\n\nTITLE: 定义匹配的无参数函数并调用方法\nDESCRIPTION: 定义一个无参数、无返回值的函数 `helloJoe`，并将其作为参数传入到 `sayHello` 方法中，演示如何使用函数作为参数调用。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-hofs.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef helloJoe(): Unit = println(\"Hello, Joe\")\n```\n\n----------------------------------------\n\nTITLE: Scala's Infix Method Syntax for Java Static Methods\nDESCRIPTION: Highlights Scala's syntactic sugar allowing methods with a single argument to be called using infix notation, e.g., 'df format ahora' instead of 'df.format(ahora)'. This feature simplifies code readability and underscores Scala's flexible method invocation syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tutorials/scala-for-java-programmers.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndf format ahora  // equivalent to df.format(ahora)\n```\n\n----------------------------------------\n\nTITLE: Defining function with conditional return in Python and Scala\nDESCRIPTION: Shows how to define a method returning the minimum of two integer parameters using inline if-else logic within function bodies. Inputs: integers a and b; outputs: minimum value. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_27\n\nLANGUAGE: Python\nCODE:\n```\ndef min(a, b):\n  return a if a < b else b\n```\n\n----------------------------------------\n\nTITLE: Single-line if Expression in Scala\nDESCRIPTION: Shows Scala's concise single-line if expression using 'if condition then expression' syntax without parentheses or braces, printing x if it equals 1.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\nif x == 1 then println(x)\n```\n\n----------------------------------------\n\nTITLE: Defining and Calling Nested Factorial Method in Scala 2 - Scala\nDESCRIPTION: This snippet demonstrates how to define a factorial function using nested methods in Scala 2. The outer function factorial takes an integer x as input and defines a helper function fact inside, which implements the recursive factorial logic using an accumulator parameter for tail recursion. The snippet prints the results for factorial(2) and factorial(3). No external dependencies are required. Inputs must be non-negative integers, and the output is an integer representing the factorial.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/nested-functions.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef factorial(x: Int): Int = {\n  def fact(x: Int, accumulator: Int): Int = {\n    if (x <= 1) accumulator\n    else fact(x - 1, x * accumulator)\n  }  \n  fact(x, 1)\n}\n\nprintln(\"Factorial of 2: \" + factorial(2))\nprintln(\"Factorial of 3: \" + factorial(3))\n```\n\n----------------------------------------\n\nTITLE: Declaring String and Char Implicitly Scala\nDESCRIPTION: Illustrates the concise way to declare variables of type `String` and `Char` in Scala using string literals (double quotes) and character literals (single quotes). Scala infers the types `String` and `Char` automatically.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/built-in-types.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval name = \"Bill\"\nval c = 'a'\n```\n\n----------------------------------------\n\nTITLE: Instantiating Scala Case Classes Extending a Trait\nDESCRIPTION: Creates instances of the 'Student' and 'Teacher' case classes, which extend the 'Person' trait. These instances will be used to test the pattern matching function 'getPrintableString'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/case-classes.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval s = Student(\"Al\", 1)\nval t = Teacher(\"Bob Donnan\", \"Mathematics\")\n```\n\n----------------------------------------\n\nTITLE: Defining Class with Default Parameter Values in Scala 3\nDESCRIPTION: This snippet shows how to define a class in Scala 3 where constructor parameters have default values, using the assignment operator (`=`). This provides flexibility in how instances can be created, using the colon syntax for the class body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nclass Socket(val timeout: Int = 5_000, val linger: Int = 5_000):\n  override def toString = s\"timeout: $timeout, linger: $linger\"\n```\n\n----------------------------------------\n\nTITLE: Multi-Line Void Method in Scala 3\nDESCRIPTION: Defines a Scala method walkThenRun that prints two strings sequentially. Uses indentation-based syntax in the method body without braces. The method returns Unit implicitly, demonstrating Scala's simplified syntax for multiple expressions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\ndef walkThenRun() =\n  println(\"walk\")\n  println(\"run\")\n```\n\n----------------------------------------\n\nTITLE: Traversing Map elements in Scala using for loop\nDESCRIPTION: Illustrates iteration over all key-value pairs of a Map using a for-comprehension syntax that decomposes tuples to keys and values. This provides a concise way to process or print Map contents. The input is a Map object with string keys and numeric values; the output is side effects of printing each key-value pair.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/map-class.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval ratings = Map(\n    \"Lady in the Water\"-> 3.0, \n    \"Snakes on a Plane\"-> 4.0,\n    \"You, Me and Dupree\"-> 3.5\n)\n\nfor ((k,v) <- ratings) println(s\"key: $k, value: $v\")\n```\n\n----------------------------------------\n\nTITLE: Object-oriented Class Declarations and Constructors - Scala\nDESCRIPTION: Shows different forms of class declarations, constructor parameter visibility (private, val, var), initialization blocks, member variables (public, immutable, private), and alternative constructors. Inputs: value of generic type 'R'. Outputs: class instance with appropriate fields. Suitable for OOP design patterns.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\nclass C(x: R)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass C(private val x: R)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nvar c = new C(4)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass C(val x: R)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass C(var x: R) {\nassert(x > 0, \"positive please\")\nvar y = x\nval readonly = 5\nprivate var secret = 1\ndef this = this(42)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Suit Enumeration in Scala\nDESCRIPTION: This code creates an enumeration for card suits using a sealed trait 'Suit' with case objects for Clubs, Spades, Diamonds, and Hearts, illustrating the standard pattern for enumerations in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/enumerations-pizza-class.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nsealed trait Suit\ncase object Clubs extends Suit\ncase object Spades extends Suit\ncase object Diamonds extends Suit\ncase object Hearts extends Suit\n```\n\n----------------------------------------\n\nTITLE: Recommended Pattern for Abstract Type Instantiation in Scala\nDESCRIPTION: Contrasts incorrect and recommended ways to create instances of abstract collection types. Shows the preferred factory method pattern instead of direct constructor calls.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/cheatsheets/index.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nnew List[Int]\n```\n\nLANGUAGE: scala\nCODE:\n```\nList(1,2,3)\n```\n\n----------------------------------------\n\nTITLE: Adding Scala 2 Nightly Resolver and Version in sbt Build (sbt)\nDESCRIPTION: This sbt build configuration code demonstrates how to add the special 'scala-integration' resolver and specify a Scala 2 nightly version. Replace '2.13.15-bin-abcd123' with the required nightly version (or '2.12.20' for Scala 2.12). Requires sbt to be used for building Scala projects. The settings can be placed in 'build.sbt' or entered into the sbt shell.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/nightlies.md#_snippet_2\n\nLANGUAGE: sbt\nCODE:\n```\nGlobal / resolvers += \"scala-integration\" at\n  \"https://scala-ci.typesafe.com/artifactory/scala-integration/\"\n```\n\nLANGUAGE: sbt\nCODE:\n```\nscalaVersion := \"2.13.15-bin-abcd123\"\n```\n\n----------------------------------------\n\nTITLE: Creating PetContainer Class with Upper Type Bound in Scala\nDESCRIPTION: Defines the generic class PetContainer with a type parameter P constrained to be a subtype of Pet (P <: Pet). It has a constructor that accepts an instance of P and provides a method to access it. This enforces at compile-time that only Pet or its subclasses can instantiate PetContainer.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/upper-type-bounds.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass PetContainer[P <: Pet](p: P) {\n  def pet: P = p\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Named Function Value in Scala\nDESCRIPTION: Demonstrates assigning an anonymous function to a val and using it for computation. Key for functional programming paradigms; allows reuse and passing of functions as values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nval addOne = (x: Int) => x + 1\nprintln(addOne(1)) // 2\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple Traits on a Class - Scala\nDESCRIPTION: Demonstrates how a class can mix in multiple traits using `extends` (for the first trait) and `with` (for subsequent traits in Scala 2, or simply commas in Scala 3). The class must provide implementations for any abstract members of the mixed-in traits.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_29\n\nLANGUAGE: Scala 2\nCODE:\n```\nclass IrishSetter(name: String) extends HasLegs with HasTail {\n  val numLegs = 4\n  val tailColor = \"Red\"\n  def walk() = println(\"I’m walking\")\n  override def toString = s\"$name is a Dog\"\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nclass IrishSetter(name: String) extends HasLegs, HasTail:\n  val numLegs = 4\n  val tailColor = \"Red\"\n  def walk() = println(\"I’m walking\")\n  override def toString = s\"$name is a Dog\"\n```\n\n----------------------------------------\n\nTITLE: Defining and Calling a Scala Method with Named Parameters\nDESCRIPTION: This snippet demonstrates defining a Scala function 'printName' with two String parameters and showcases multiple ways to call it using positional and named arguments to achieve flexible argument order. It also highlights how unnamed and named arguments should be ordered properly to avoid errors.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/named-arguments.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef printName(first: String, last: String): Unit = {\n  println(first + \" \" + last)\n}\n\nprintName(\"John\", \"Smith\")  // Prints \"John Smith\"\nprintName(first = \"John\", last = \"Smith\")  // Prints \"John Smith\"\nprintName(last = \"Smith\", first = \"John\")  // Prints \"John Smith\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Recursive Enumeration for Lists in Scala\nDESCRIPTION: Shows the definition of a generic, recursive list data structure using Scala 3 `enum`. The `Cons` case holds an element and refers back to the `List` enum type for the tail.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-adts-gadts.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nenum List[+A]:\n  case Nil\n  case Cons(head: A, tail: List[A])\n```\n\n----------------------------------------\n\nTITLE: Implementing Tree Evaluation using Pattern Matching in Scala\nDESCRIPTION: Defines an `eval` function that evaluates an expression `Tree` within a given `Environment`. Uses pattern matching (`match`) to handle different node types (`Sum`, `Var`, `Const`), recursively evaluating subtrees or retrieving values from the environment.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tutorials/scala-for-java-programmers.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ndef eval(t: Tree, env: Environment): Int = t match {\n  case Sum(l, r) => eval(l, env) + eval(r, env)\n  case Var(n)    => env(n)\n  case Const(v)  => v\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Unit Tests with AnyFunSuite in ScalaTest - Scala\nDESCRIPTION: Defines a suite of tests for the MathUtils object using the AnyFunSuite class from ScalaTest. Imports org.scalatest.funsuite.AnyFunSuite and tests the double method for various integer inputs. One test is marked as pending. Requires ScalaTest dependency and matching main class. Input: test cases and subject class; Output: test results (pass, fail, pending).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\npackage math\n  \nimport org.scalatest.funsuite.AnyFunSuite\n\nclass MathUtilsTests extends AnyFunSuite:\n\n  // test 1\n  test(\"'double' should handle 0\") {\n    val result = MathUtils.double(0)\n    assert(result == 0)\n  }\n\n  // test 2\n  test(\"'double' should handle 1\") {\n    val result = MathUtils.double(1)\n    assert(result == 2)\n  }\n \n  test(\"test with Int.MaxValue\") (pending)\n\nend MathUtilsTests\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Parameters of Enum Cases in Scala\nDESCRIPTION: Shows how to access the parameter value (`rgb`) associated with a specific case (`Green`) of a parameterized Scala 3 enumeration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-adts-gadts.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nprintln(Color.Green.rgb) // prints 65280\n```\n\n----------------------------------------\n\nTITLE: Defining MyBool Case Class with Operator Methods - Scala\nDESCRIPTION: This snippet defines a Scala `case class` named `MyBool` to encapsulate boolean values. It includes methods `and` and `or` that accept a single `MyBool` parameter, demonstrating the pattern required for methods to be used as infix operators, along with a `negate` method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/operators.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class MyBool(x: Boolean) {\n  def and(that: MyBool): MyBool = if (x) that else this\n  def or(that: MyBool): MyBool = if (x) this else that\n  def negate: MyBool = MyBool(!x)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Mutable ArrayBuffer in Scala\nDESCRIPTION: Demonstrates initializing an empty mutable `ArrayBuffer[Int]`, adding elements using `+=`, and converting it to an `Array`. `ArrayBuffer` provides efficient appending and array-like access, backed by an array that resizes as needed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-mutable-collection-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nscala> val buf = scala.collection.mutable.ArrayBuffer.empty[Int]\nbuf: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()\nscala> buf += 1\nres32: buf.type = ArrayBuffer(1)\nscala> buf += 10\nres33: buf.type = ArrayBuffer(1, 10)\nscala> buf.toArray\nres34: Array[Int] = Array(1, 10)\n```\n\n----------------------------------------\n\nTITLE: Defining a function type that takes a String and returns an Int in Scala\nDESCRIPTION: Shows a function type signature `String => Int`, which represents any function that accepts a String argument and returns an Int. Functions matching this type can be used as parameters to higher-order methods expecting this signature.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-hofs.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nf: String => Int\n```\n\n----------------------------------------\n\nTITLE: Nested for Generators with Ranges in Scala\nDESCRIPTION: Shows Scala for expression with multiple generators: 'i' ranges from 1 to 2, 'j' from 4 to 5, and 'k' from 1 until 10 stepping by 3. Body prints formatted strings with the current values. Enables concise nested iteration within one expression.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\nfor\n  i <- 1 to 2\n  j <- 4 to 5\n  k <- 1 until 10 by 3\ndo\n  println(s\"i = $i, j = $j, k = $k\")\n```\n\n----------------------------------------\n\nTITLE: Executing Multi-Line Blocks within 'for' Loops in Scala\nDESCRIPTION: Shows how to execute multiple statements within a `for` loop iteration. Compares Scala 2 syntax (curly braces after generator) and Scala 3 syntax (indented block after `do`). Calculates and prints a value based on the loop variable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_10\n\nLANGUAGE: Scala 2\nCODE:\n```\nfor (i <- ints) {\n  val x = i * 2\n  println(s\"i = $i, x = $x\")\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nfor\n  i <- ints\ndo\n  val x = i * 2\n  println(s\"i = $i, x = $x\")\n```\n\n----------------------------------------\n\nTITLE: Handling Future Completion with onComplete Callback in Scala\nDESCRIPTION: Demonstrates registering an `onComplete` callback on a Scala `Future`. This callback receives a `Try[T]` (either `Success[T]` or `Failure[Throwable]`) allowing unified handling of both successful completion and failure scenarios asynchronously when the Future's result is available.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/futures.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval f: Future[List[String]] = Future {\n  session.getRecentPosts\n}\n\nf onComplete {\n  case Success(posts) => for (post <- posts) println(post)\n  case Failure(t) => println(\"エラーが発生した: \" + t.getMessage)\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating a Class that Extends Traits in Scala\nDESCRIPTION: Creating an instance of the IrishSetter class that inherits functionality from multiple traits.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval d = new IrishSetter(\"Big Red\")   // \"Big Red is a Dog\"\n```\n\nLANGUAGE: scala\nCODE:\n```\nval d = IrishSetter(\"Big Red\")   // \"Big Red is a Dog\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating mutable ArrayBuffer as HashMap key issue in Scala\nDESCRIPTION: This snippet demonstrates a potential issue when using a mutable Scala collection, like `ArrayBuffer`, as a key in a `HashMap`. Modifying the mutable collection after it has been inserted into the map can change its hash code, causing subsequent lookups with the modified collection to fail with `NoSuchElementException`. This highlights the importance of using immutable keys in hash-based collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/equality.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nscala> import collection.mutable.{HashMap, ArrayBuffer}\nimport collection.mutable.{HashMap, ArrayBuffer}\n\nscala> val buf = ArrayBuffer(1, 2, 3)\nval buf: scala.collection.mutable.ArrayBuffer[Int] =\n  ArrayBuffer(1, 2, 3)\n\nscala> val map = HashMap(buf -> 3)\nval map: scala.collection.mutable.HashMap[scala.collection.\n  mutable.ArrayBuffer[Int],Int] = Map((ArrayBuffer(1, 2, 3),3))\n\nscala> map(buf)\nval res13: Int = 3\n\nscala> buf(0) += 1\n\nscala> map(buf)\n  java.util.NoSuchElementException: key not found:\n    ArrayBuffer(2, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Initializing a List using the Cons Operator in Scala\nDESCRIPTION: Demonstrates creating an immutable `List` using the `::` (cons) operator and terminating with `Nil`. This syntax is available in both Scala 2 and 3 and reflects the underlying singly-linked list structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nval list = 1 :: 2 :: 3 :: Nil\n```\n\n----------------------------------------\n\nTITLE: Named Parameters in Method Calls\nDESCRIPTION: Demonstrates how to use named parameters when calling methods to improve readability, especially useful when methods have multiple parameters of the same type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/methods-most.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nmakeConnection(timeout=10_000)\nmakeConnection(protocol=\"https\")\nmakeConnection(timeout=10_000, protocol=\"https\")\nmakeConnection(protocol=\"https\", timeout=10_000)\n\n// Comparison between unnamed and named parameters\nengage(true, true, true, false)\n\n// More readable with named parameters\nengage(\n  speedIsSet = true,\n  directionIsSet = true,\n  picardSaidMakeItSo = true,\n  turnedOffParkingBrake = false\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing Lists and Sequences in Scala\nDESCRIPTION: Illustrates Scala initialization of immutable sequences using List and Vector, as well as mutable sequences using ArrayBuffer, each initialized with elements 1, 2, and 3. Demonstrates choices depending on mutability requirements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_36\n\nLANGUAGE: Scala\nCODE:\n```\n// use different sequence classes\n// as needed\nval a = List(1,2,3)\nval a = Vector(1,2,3)\nval a = ArrayBuffer(1,2,3)\n```\n\n----------------------------------------\n\nTITLE: Handling Exceptions within Scala Futures\nDESCRIPTION: Illustrates how a Scala `Future` handles exceptions thrown during its computation. If the code block inside `Future {}` throws an exception (e.g., a `NullPointerException` due to `session` being null), the `Future` completes with a failure, encapsulating the thrown exception.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/futures.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval session = null\nval f: Future[List[Friend]] = Future {\n  session.getFriends\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Guards and Special Cases in Scala Case Classes\nDESCRIPTION: Shows advanced pattern matching on case classes using guards (if-conditions) to detect special values before proceeding. The function 'showNotificationSpecial' matches Email and SMS cases with conditions checking for special email or phone numbers, returning designated messages. If no special case matches, it delegates to a general notification handler. Illustrates combining pattern matching with conditional logic for expressive control flow.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/case-classes.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef showNotificationSpecial(notification: Notification, specialEmail: String, specialNumber: String): String = {\n  notification match {\n    case Email(email, _, _) if email == specialEmail =>\n      \"You got an email from special someone!\"\n    case SMS(number, _) if number == specialNumber =>\n      \"You got an SMS from special someone!\"\n    case other =>\n      showNotification(other) // nothing special, delegate to our original showNotification function   \n  }\n}\n\nval SPECIAL_NUMBER = \"55555\"\nval SPECIAL_EMAIL = \"jane@mail.com\"\nval someSms = SMS(\"12345\", \"Are you there?\")\nval someVoiceRecording = VoiceRecording(\"Tom\", \"voicerecording.org/id/123\")\nval specialEmail = Email(\"jane@mail.com\", \"Drinks tonight?\", \"I'm free after 5!\")\nval specialSms = SMS(\"55555\", \"I'm here! Where are you?\")\n\nprintln(showNotificationSpecial(someSms, SPECIAL_EMAIL, SPECIAL_NUMBER))\nprintln(showNotificationSpecial(someVoiceRecording, SPECIAL_EMAIL, SPECIAL_NUMBER))\nprintln(showNotificationSpecial(specialEmail, SPECIAL_EMAIL, SPECIAL_NUMBER))\nprintln(showNotificationSpecial(specialSms, SPECIAL_EMAIL, SPECIAL_NUMBER))\n```\n\n----------------------------------------\n\nTITLE: Пример передачи Producer[Book] в функцию, ожидающую Producer[Buyable]\nDESCRIPTION: Здесь определяется значение bookProducer как Producer параметра типа Book. Затем оно передается в функцию makeTwo, демонстрируя ковариантное поведение и расширенную совместимость параметрических типов в Scala, когда производные типы принимаются вместо базовых.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-variance.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval bookProducer: Producer[Book] = ???\nmakeTwo(bookProducer)\n```\n\n----------------------------------------\n\nTITLE: Using Apply Method in Companion Object for Instance Creation in Scala\nDESCRIPTION: This snippet shows how to implement an apply method within a companion object, allowing instance creation without the new keyword. The Person class has a mutable name field, and the companion's apply method is a factory that sets this property before returning the new object. There are no external dependencies; the key parameter is name: String, used for initialization. The output is a Person instance constructed in a concise, idiomatic way.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/companion-objects.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass Person {\n    var name = \"\"\n}\n\nobject Person {\n    def apply(name: String): Person = {\n        var p = new Person\n        p.name = name\n        p\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using a map for query parameters in URI construction\nDESCRIPTION: Shows how to use a Map[String, String] to generate multiple query parameters in a URI with the uri interpolator, with automatic escaping of special characters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/http-client-uris.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval queryParams = Map(\n  \"q\" -> \"scala\",\n  \"limit\" -> \"10\",\n  \"page\" -> \"1\"\n)\nval uriWithQueryParams = uri\"https://example.com/search?$queryParams\"\nprintln(uriWithQueryParams)\n// prints: https://example.com/search?q=scala&limit=10&page=1\n```\n\n----------------------------------------\n\nTITLE: Defining Package-Level Variable and Method Using Scala 2 Package Object\nDESCRIPTION: Creates a package object in package `gardening.fruits` that contains a variable `planted` holding a list of fruit objects and a method `showFruit` to print descriptive information about a fruit. This snippet uses Scala 2 style package objects which bundle shared definitions accessible throughout the package. It requires the three fruit objects to be defined as shown earlier.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/package-objects.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\npackage gardening\npackage object fruits {\n  val planted = List(Apple, Plum, Banana)\n  def showFruit(fruit: Fruit): Unit = {\n    println(s\"${fruit.name}s are ${fruit.color}\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Class and Its Companion Object in Scala\nDESCRIPTION: This snippet illustrates the basic structure of defining a Scala class and its companion object within the same file (e.g., Pizza.scala). By sharing the same name, these entities can access each other's private members, enabling encapsulation and sophisticated internal logic. There are no required dependencies, and the code serves as an introductory template for understanding companion objects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/companion-objects.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Pizza {\n}\n\nobject Pizza {\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming Map Values in Scala\nDESCRIPTION: Illustrates using the 'transform' method to create a new Map with values modified according to a provided function. The example converts all values to uppercase. Input: Map and transformation function. Output: A new Map with the same keys and transformed values. This pattern is key to functional collection processing in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/collections-maps.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval ucMap = m.transform((k,v) => v.toUpperCase)\n```\n\n----------------------------------------\n\nTITLE: Defining and Calling Long-running Functions with Scala Futures\nDESCRIPTION: This snippet demonstrates how to declare a function aLongRunningTask that returns a Future[Int], indicating asynchronous execution, and assigns the resulting Future to a variable. It requires Scala's concurrent library. The function is a stub and would need implementation that computes or obtains an Int result asynchronously. Output is a Future containing an eventual Int value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/futures.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef aLongRunningTask(): Future[Int] = ???\nval x = aLongRunningTask\n```\n\n----------------------------------------\n\nTITLE: Obtaining a Type Mirror for List[Int] in Scala Reflection\nDESCRIPTION: This snippet retrieves the compile-time type representation of List[Int] using typeOf within the Scala reflection universe. It requires importing the universe and enables the reflective inspection of all members and properties of List[Int]. The input is the type expression List[Int] and the output is a reflection Type object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/annotations-names-scopes.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval listTpe = typeOf[List[Int]]\n```\n\n----------------------------------------\n\nTITLE: Accessing Map Elements in Scala\nDESCRIPTION: Shows retrieval of the value for key \"a\" in a Scala Map 'myMap'. Expected to return the value 1. Immutable Map fetch with parentheses syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nmyMap(\"a\")  // 1\n```\n\n----------------------------------------\n\nTITLE: Chained if, else if, else Statements in Java\nDESCRIPTION: Shows standard Java if-else-if-else chain printing different messages based on the value of x. Illustrates common control flow branching with multiple conditional branches.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_31\n\nLANGUAGE: java\nCODE:\n```\nif (x < 0) {\n  System.out.println(\"negative\")\n} else if (x == 0) {\n  System.out.println(\"zero\")\n} else {\n  System.out.println(\"positive\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using if-else-if Chains in Scala\nDESCRIPTION: Scala uses `if`, `else if`, and `else` for conditional logic chains. The block associated with each condition is defined by indentation. Parentheses around conditions are optional.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_35\n\nLANGUAGE: Scala\nCODE:\n```\nif x < 0 then\n  println(\"negative\")\nelse if x == 0\n  println(\"zero\")\nelse\n  println(\"positive\")\n```\n\n----------------------------------------\n\nTITLE: Scala 3 'if'/'else' expression assignment\nDESCRIPTION: Shows the Scala 3 syntax for assigning the result of an 'if'/'else' expression to a variable using 'then' and 'else'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval x = if a < b then a else b\n```\n\n----------------------------------------\n\nTITLE: Defining Case Classes in Scala - Scala\nDESCRIPTION: Provides a canonical example of defining a simple case class in Scala. This snippet introduces the case class Foo with a single integer parameter x. No external libraries are required; the code is valid in both Scala 2 and Scala 3. The snippet demonstrates the syntax for data structures and value classes in Scala. No direct input or output is involved—usage depends on context in other code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/add-guides.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Foo(x: Int)\n```\n\n----------------------------------------\n\nTITLE: Hiding a member during import in Scala 2 and 3\nDESCRIPTION: Demonstrates how to exclude the 'Random' class from 'java.util' during import, effectively hiding it and preventing use in the current scope.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/packaging-imports.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport java.util.{Random => _, _}  // Scala 2\nimport java.util.{Random as _, *}  // Scala 3\n```\n\n----------------------------------------\n\nTITLE: Parameterized Scala 3 Enums with Members and Methods\nDESCRIPTION: Shows how enumerations can be enriched by adding parameters, private values, and methods to define complex behavior per case. The examples include `Color` enum holding RGB integer values, and `Planet` enum with physical properties and computed methods such as `surfaceGravity` and `surfaceWeight`. This advanced usage enables modeling more complex domain concepts with enums.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_36\n\nLANGUAGE: scala\nCODE:\n```\nenum Color(val rgb: Int):\n  case Red   extends Color(0xFF0000)\n  case Green extends Color(0x00FF00)\n  case Blue  extends Color(0x0000FF)\n```\n\nLANGUAGE: scala\nCODE:\n```\nenum Planet(mass: Double, radius: Double):\n  private final val G = 6.67300E-11\n  def surfaceGravity = G * mass / (radius * radius)\n  def surfaceWeight(otherMass: Double) =\n    otherMass * surfaceGravity\n\n  case Mercury extends Planet(3.303e+23, 2.4397e6)\n  case Earth   extends Planet(5.976e+24, 6.37814e6)\n  // more planets here ...\n```\n\n----------------------------------------\n\nTITLE: Workarounds for Quote Characters in Scala Interpolations\nDESCRIPTION: Current workarounds for including quote characters in string interpolations, including triple-quote strings and using blocks to splice in quotes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/interpolation-quote-escape.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ns\"\"\"A common question for Scala programmers is \"How can I represent a literal \" character in Scala interpolations?\"\"\"\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\n//with a normal escape in a string in a block\ns\"A common question for Scala programmers is ${\"\\\"\"} How can I represent a literal ${\"\\\"\"} character in Scala interpolations?${\"\\\"\"}\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\n//with a quote character as a block\ns\"A common question for Scala programmers is ${'\"'}How can I represent a literal ${'\"'} character in Scala interpolations?${'\"'}\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\n//with an identifier referencing a string that contains a single quote\nval quote = \"\\\"\"\ns\"A common question for Scala programmers is ${q}How can I represent a literal $q character in Scala interpolations?$q\"\n```\n\n----------------------------------------\n\nTITLE: Sample usage of Showable with implicit macro provisioning in Scala\nDESCRIPTION: Demonstrates how to use the 'Showable' type class to automatically derive string representations for types like 'Int' and 'List[T]' via implicit macros, reducing boilerplate and improving code maintainability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/implicits.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit object IntShowable extends Showable[Int] {\n  def show(x: Int) = x.toString\n}\n\nshow(42) // \"42\"\nshow(\"42\") // compilation error\n\nimplicit def listShowable[T](implicit s: Showable[T]) =\n  new Showable[List[T]] {\n    def show(x: List[T]) = x.map(s.show).mkString(\"List(\", \", \", \")\")\n  }\n\nshow(List(42)) // prints: List(42)\n```\n\n----------------------------------------\n\nTITLE: Implementing PrefixMap Class for Patricia Trie in Scala\nDESCRIPTION: Core implementation of a Patricia trie as a mutable map that efficiently stores string keys. This implementation extends mutable.Map and mutable.MapLike to inherit collection operations while maintaining the correct return type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-collections.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nimport collection._\n\nclass PrefixMap[T]\nextends mutable.Map[String, T]\n   with mutable.MapLike[String, T, PrefixMap[T]] {\n\n  var suffixes: immutable.Map[Char, PrefixMap[T]] = Map.empty\n  var value: Option[T] = None\n\n  def get(s: String): Option[T] =\n    if (s.isEmpty) value\n    else suffixes get (s(0)) flatMap (_.get(s substring 1))\n\n  def withPrefix(s: String): PrefixMap[T] =\n    if (s.isEmpty) this\n    else {\n      val leading = s(0)\n      suffixes get leading match {\n        case None =>\n          suffixes = suffixes + (leading -> empty)\n        case _ =>\n      }\n      suffixes(leading) withPrefix (s substring 1)\n    }\n\n  override def update(s: String, elem: T) =\n    withPrefix(s).value = Some(elem)\n\n  override def remove(s: String): Option[T] =\n    if (s.isEmpty) { val prev = value; value = None; prev }\n    else suffixes get (s(0)) flatMap (_.remove(s substring 1))\n\n  def iterator: Iterator[(String, T)] =\n    (for (v <- value.iterator) yield (\"\", v)) ++\n    (for ((chr, m) <- suffixes.iterator;\n          (s, v) <- m.iterator) yield (chr +: s, v))\n\n  def += (kv: (String, T)): this.type = { update(kv._1, kv._2); this }\n\n  def -= (s: String): this.type  = { remove(s); this }\n\n  override def empty = new PrefixMap[T]\n}\n```\n\n----------------------------------------\n\nTITLE: Extending a Class in Scala\nDESCRIPTION: Illustrates basic class inheritance where `SoftwareDeveloper` extends `Person`, calling the superclass constructor. The syntax is the same for Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-oop.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nclass Person(name: String)\nclass SoftwareDeveloper(name: String, favoriteLang: String)\n  extends Person(name)\n```\n\n----------------------------------------\n\nTITLE: Testing the isTruthy Method in Scala\nDESCRIPTION: Examples of calling the isTruthy method with different values to demonstrate its behavior with various input types including numbers, strings, and booleans.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nisTruthy(0)      // false\nisTruthy(\"\")     // false\nisTruthy(\"hi\")   // true\nisTruthy(1.0)    // true\n```\n\n----------------------------------------\n\nTITLE: Extracting Elements from Scala TreeSet Starting Point\nDESCRIPTION: This Scala snippet uses the `from` method on the `TreeSet` `res3`. It returns a new `TreeSet` containing all elements from `res3` that are greater than or equal to the specified starting element (\"three\"), according to the set's defined ordering.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/sets.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nscala> res3 from \"three\"\nres5: scala.collection.immutable.TreeSet[String] = TreeSet(three, two)\n```\n\n----------------------------------------\n\nTITLE: Adding sbt-site-paradox Plugin - Scala\nDESCRIPTION: This Scala command registers the sbt-site-paradox plugin in the project/plugins.sbt file, enabling Paradox-powered documentation site generation. Requires sbt and internet access to download the plugin. The plugin provides sbt tasks for site generation and is compatible with settings for further customization. Outputs are new build tasks for generating and previewing docs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\naddSbtPlugin(\"com.github.sbt\" % \"sbt-site-paradox\" % \"1.5.0\")\n```\n\n----------------------------------------\n\nTITLE: Instantiating a Class with Traits in Scala 3\nDESCRIPTION: This snippet demonstrates creating a MyService instance in Scala 3, omitting the new keyword and using modern constructor syntax. The value s1 is typed as MyService and initialized with the string 'Service 1'. No external dependencies are required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nval s1: MyService = MyService(\"Service 1\")\n```\n\n----------------------------------------\n\nTITLE: Using Enum Members in Scala 2\nDESCRIPTION: Demonstrates importing enum members and using pattern matching and comparisons with enums in Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-modeling.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nimport CrustSize._\nval currentCrustSize = Small\n\n// enums in a `match` expression\ncurrentCrustSize match {\n  case Small => println(\"Small crust size\")\n  case Medium => println(\"Medium crust size\")\n  case Large => println(\"Large crust size\")\n}\n\n// enums in an `if` statement\nif (currentCrustSize == Small) println(\"Small crust size\")\n```\n\n----------------------------------------\n\nTITLE: Recursive sum of a list using pattern matching in Scala\nDESCRIPTION: This snippet defines a pure recursive function `sum` that computes the sum of a list of integers (`List[Int]`) using pattern matching. It showcases a typical example of a pure, deterministic function that operates only on its input data without side effects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/pure-functions.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef sum(list: List[Int]): Int = list match {\n    case Nil => 0\n    case head :: tail => head + sum(tail)\n}\n```\n\n----------------------------------------\n\nTITLE: Partial Implementation of DirectedGraph with Abstract Nodes and Edges in Scala\nDESCRIPTION: This Scala snippet attempts a partial implementation of a `DirectedGraph` extending `Graph`. The abstract type `Edge` is bounded by `EdgeImpl`, which encapsulates origin and destination nodes. `NodeImpl` extends the abstract node interface and implements `connectWith` by creating a new edge and adding it to the edges list. Factory methods `newNode` and `newEdge` remain abstract for future concrete definitions. The collections `nodes` and `edges` are mutable lists. However, this snippet contains a type error: the `this` reference in `connectWith` is typed as `NodeImpl`, which conflicts with the expected `Node` type parameter, causing the snippet to fail compilation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/self-types.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nabstract class DirectedGraph extends Graph {\n  type Edge <: EdgeImpl\n  class EdgeImpl(origin: Node, dest: Node) {\n    def from = origin\n    def to = dest\n  }\n  class NodeImpl extends NodeIntf {\n    def connectWith(node: Node): Edge = {\n      val edge = newEdge(this, node)\n      edges = edge :: edges\n      edge\n    }\n  }\n  protected def newNode: Node\n  protected def newEdge(from: Node, to: Node): Edge\n  var nodes: List[Node] = Nil\n  var edges: List[Edge] = Nil\n  def addNode: Node = {\n    val node = newNode\n    nodes = node :: nodes\n    node\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Implicit Parameters in Scala\nDESCRIPTION: This snippet shows a method 'execute' with an explicit parameter and an implicit parameter of type 'ExecutionContext'. The implicit parameter must be provided in scope or explicitly passed, and is typically used for supporting context-dependent operations like asynchronous computations. Dependencies include Scala's implicit parameter mechanism. Inputs include the argument 'arg' and implicit 'ec'; the output depends on the implementation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/multiple-parameter-lists.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ndef execute(arg: Int)(implicit ec: scala.concurrent.ExecutionContext) = ???\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Future Completion Scala REPL\nDESCRIPTION: Illustrates calling the `slowlyDouble` method in a Scala REPL session. It shows the initial state of the `Future` as `<not completed>` and how subsequent checks reveal the `Success` state with the computed result after the specified delay.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/concurrency.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nscala> val f = slowlyDouble(2, 5_000L)\nval f: concurrent.Future[Int] = Future(<not completed>)\n\nscala> f\nval res0: concurrent.Future[Int} = Future(<not completed>)\n\nscala> f\nval res1: concurrent.Future[Int] = Future(Success(4))\n```\n\n----------------------------------------\n\nTITLE: Extending and Implementing a Trait in Scala\nDESCRIPTION: Illustrates extending the generic 'Iterator[Int]' trait in a concrete class 'IntIterator' with a constructor parameter 'to' as the upper bound. The class implements the abstract methods 'hasNext' and 'next()' by maintaining a private mutable variable 'current', iterating from 0 up to 'to'. The snippet also includes example usage of the iterator returning successive integers. Dependencies include the base Iterator trait.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/traits.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait Iterator[A] {\n  def hasNext: Boolean\n  def next(): A\n}\n\nclass IntIterator(to: Int) extends Iterator[Int] {\n  private var current = 0\n  override def hasNext: Boolean = current < to\n  override def next(): Int =  {\n    if (hasNext) {\n      val t = current\n      current += 1\n      t\n    } else 0\n  }\n}\n\n\nval iterator = new IntIterator(10)\niterator.next()  // returns 0\niterator.next()  // returns 1\n```\n\n----------------------------------------\n\nTITLE: Basic String Declaration in Scala\nDESCRIPTION: This snippet demonstrates how to declare simple strings in Scala using only double quotes (\"). Single quotes are used for characters, not strings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\n// use only double-quotes\nval msg = \"Hello, world\"\n```\n\n----------------------------------------\n\nTITLE: Defining Marker Trait in Scala 3\nDESCRIPTION: Defines an empty Scala trait named Marker, serving as a marker or tag trait. Scala traits are more powerful than interfaces and can include method implementations, but here it is used similarly to a marker interface.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Marker\n```\n\n----------------------------------------\n\nTITLE: Implementing custom string interpolator for Point in Scala 2\nDESCRIPTION: Defines an implicit class to add a custom 'p' interpolator to create Point instances from strings, utilizing the existing 's' interpolator and string splitting. Requires Scala 2, and the key functionality involves parsing string parts into Double values to instantiate a Point.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/string-interpolation.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit class PointHelper(val sc: StringContext) extends AnyVal {\n  def p(args: Double*): Point = {\n    // переиспользование интерполятора `s` и затем разбиение по ','\n    val pts = sc.s(args: _*).split(\",\", 2).map { _.toDoubleOption.getOrElse(0.0) }\n    Point(pts(0), pts(1))\n  }\n}\n\nval x=12.0\n\np\"1, -2\"        // Point(1.0, -2.0)\np\"${x/5}, $x\"   // Point(2.4, 12.0)\n```\n\n----------------------------------------\n\nTITLE: Compiler Expansion of Context Bounds in Function Types (Scala)\nDESCRIPTION: Shows the compiler expansion for the proposed context bounds on polymorphic function types. The type alias `Comparer` and the value `less` are expanded to use context function types (`?=>`), making the required given instance (`Ord[X]`) an implicit parameter for the inner function body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\ntype Comparer = [X] => (x: X, y: X) => Ord[X] ?=> Boolean\nval less: Comparer = [X] => (x: X, y: X) => (ord: Ord[X]) ?=>\n  ord.compare(x, y) < 0\n```\n\n----------------------------------------\n\nTITLE: Adding a Scala library dependency in build.sbt\nDESCRIPTION: This code snippet demonstrates how to add an external library dependency to a Scala project using sbt. It specifies the library 'scala-parser-combinators' version 2.1.1, which sbt will fetch during project build to enable additional functionality in the Scala codebase.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/getting-started/sbt-track/getting-started-with-scala-and-sbt-on-the-command-line.md#_snippet_0\n\nLANGUAGE: sbt\nCODE:\n```\nlibraryDependencies += \"org.scala-lang.modules\" %% \"scala-parser-combinators\" % \"2.1.1\"\n```\n\n----------------------------------------\n\nTITLE: Handling optional query parameters in URI construction\nDESCRIPTION: Demonstrates how to use Option values when constructing URIs with query parameters, where the parameter is included only when the Option has a value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/http-client-uris.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef getUri(limit: Option[Int]): Uri =\n  uri\"https://example.com/all?limit=$limit\"\n\nprintln(getUri(Some(10)))\n// prints: https://example.com/all?limit=100\n\nprintln(getUri(None))\n// prints: https://example.com/all\n```\n\n----------------------------------------\n\nTITLE: Declaring Context Parameters Using Implicit and Using Keywords in Scala 2 and Scala 3\nDESCRIPTION: These snippets demonstrate how to declare methods with context parameters in Scala 2 (using `implicit`) and Scala 3 (using `using`), allowing the Scala compiler to automatically supply arguments of the matching type found in the implicit scope. The methods no longer require explicit provision of configuration parameters, improving code readability and reducing boilerplate. The code expects a `Config` type in scope as an implicit or given value. Input parameters for method calls exclude the context parameter, which is inferred. Output remains a rendered HTML string. Limitations include the requirement that an implicit or given value of type `Config` must be available in the calling context.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/ca-context-parameters.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef renderWebsite(path: String)(implicit config: Config): String =\n    \"<html>\" + renderWidget(List(\"cart\")) + \"</html>\"\n    //                                  ^ \n    //                   аргумент config больше не требуется\n\ndef renderWidget(items: List[String])(implicit config: Config): String = ???\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef renderWebsite(path: String)(using config: Config): String =\n    \"<html>\" + renderWidget(List(\"cart\")) + \"</html>\"\n    //                                  ^ \n    //                   аргумент config больше не требуется\n\ndef renderWidget(items: List[String])(using config: Config): String = ???\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Path Instability with Byname Implicits for Dependent Types (Scala)\nDESCRIPTION: Attempts to translate the shapeless `Lazy` pattern using a byname implicit parameter (`foo: => Foo`). This code snippet fails because the path `foo` is not considered stable in Scala when used as a prefix for a type projection (`foo.Out`), highlighting a limitation of byname implicits compared to `Lazy`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\ntrait Foo {\n  type Out\n  def out: Out\n}\n\nobject Test {\n  implicit def bar(implicit foo: => Foo): foo.Out = foo.out\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching in Scala\nDESCRIPTION: Shows the pattern matching syntax in Scala, including case expressions and variable binding considerations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/cheatsheets/index.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\n(xs zip ys) map {\n  case (x, y) => x * y\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\n(xs zip ys) map {\n  (x, y) => x * y\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval v42 = 42\n3 match {\n  case v42 => println(\"42\")\n  case _   => println(\"Not 42\")\n}\n```\n\n----------------------------------------\n\nTITLE: Default Numeric Types in Scala\nDESCRIPTION: Shows how Int and Double are the default numeric types when type inference is used.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-vars-data-types.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval i = 123   // 默认为 Int\nval j = 1.0   // 默认为 Double\n```\n\n----------------------------------------\n\nTITLE: Displaying Scala Reflection Trees Alongside Type Information Using showRaw with printTypes - Scala\nDESCRIPTION: Demonstrates enhanced usage of showRaw to print Scala reflection Trees together with type annotations. Uses scala.tools.reflect.ToolBox to type check trees and print their raw AST with type signatures included, providing insight into type references and symbols with unique IDs and kinds when specified.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/annotations-names-scopes.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nscala> import scala.tools.reflect.ToolBox // requires scala-compiler.jar\nimport scala.tools.reflect.ToolBox\n\nscala> import scala.reflect.runtime.{currentMirror => cm}\nimport scala.reflect.runtime.{currentMirror=>cm}\n\nscala> showRaw(cm.mkToolBox().typeCheck(tree), printTypes = true)\nres2: String = Block[1](List(\n  ClassDef[2](Modifiers(FINAL), TypeName(\"C\"), List(), Template[3](\n    List(Ident[4](TypeName(\"AnyRef\"))),\n    emptyValDef,\n    List(\n      DefDef[2](Modifiers(), termNames.CONSTRUCTOR, List(), List(List()), TypeTree[3](),\n        Block[1](List(\n          Apply[4](Select[5](Super[6](This[3](TypeName(\"C\")), typeNames.EMPTY), ...))),\n          Literal[1](Constant(())))),\n      DefDef[2](Modifiers(), TermName(\"x\"), List(), List(), TypeTree[7](),\n        Literal[8](Constant(2))))))),\n  Literal[1](Constant(())))\n[1] TypeRef(ThisType(scala), scala.Unit, List())\n[2] NoType\n[3] TypeRef(NoPrefix, TypeName(\"C\"), List())\n[4] TypeRef(ThisType(java.lang), java.lang.Object, List())\n[5] MethodType(List(), TypeRef(ThisType(java.lang), java.lang.Object, List()))\n[6] SuperType(ThisType(TypeName(\"C\")), TypeRef(... java.lang.Object ...))\n[7] TypeRef(ThisType(scala), scala.Int, List())\n[8] ConstantType(Constant(2))\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Trait with Abstract Methods in Scala\nDESCRIPTION: A Scala trait can declare abstract methods that classes mixing in the trait must implement. Methods without an implementation body are abstract by default.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Adder:\n  def add(a: Int, b: Int): Int\n```\n\n----------------------------------------\n\nTITLE: Configuring Snippet Compiler with Path-Based Settings (Plain Text)\nDESCRIPTION: Example of advanced Scaladoc configuration using the `-snippet-compiler` option with multiple path-based settings separated by commas. Each setting applies a specific flag (`compile`, `nocompile`, `fail`) to snippets within the specified file or directory path.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/snippet-compiler.md#_snippet_12\n\nLANGUAGE: plaintext\nCODE:\n```\n-snippet-compiler:docs=compile,library/src=compile,library/src/scala/quoted=nocompile,library/src/scala/compiletime=fail\n```\n\n----------------------------------------\n\nTITLE: Chaining Operations on Immutable Collections in Scala\nDESCRIPTION: Demonstrates the functional programming approach of chaining multiple operations (filter and map) on an immutable list, showing how each operation returns a new collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-functions.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n// a sample list\nval nums = (1 to 10).toList   // List(1,2,3,4,5,6,7,8,9,10)\n\n// methods can be chained together as needed\nval x = nums.filter(_ > 3)\n            .filter(_ < 7)\n            .map(_ * 10)\n\n// result: x == List(40, 50, 60)\n```\n\n----------------------------------------\n\nTITLE: Calling a Function That Creates Generic Arrays (REPL)\nDESCRIPTION: Shows successful calls to the generic 'evenElems[T: ClassTag]' function with concrete types (Int and String). The Scala compiler automatically provides the required ClassTag[Int] and ClassTag[String] implicitly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/arrays.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nscala> evenElems(Vector(1, 2, 3, 4, 5))\nres6: Array[Int] = Array(1, 3, 5)\nscala> evenElems(Vector(\"this\", \"is\", \"a\", \"test\", \"run\"))\nres7: Array[java.lang.String] = Array(this, a, run)\n```\n\n----------------------------------------\n\nTITLE: Pretty Printing Scala Types Using show and showRaw (Scala)\nDESCRIPTION: Shows how to represent Scala types in readable and raw AST forms via scala.reflect.runtime.universe.show and showRaw methods. `show` outputs the type as user-friendly Scala syntax, while `showRaw` reveals the underlying refined type structure. This snippet includes example type construction and printing, and demonstrates passing parameters to showRaw to output symbol IDs and kinds, facilitating deep type inspection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/reflection/annotations-names-scopes.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n\ndef tpe = typeOf[{ def x: Int; val y: List[Int] }]\n\nprintln(show(tpe))\nprintln(showRaw(tpe))\nprintln(showRaw(tpe, printIds = true, printKinds = true))\n```\n\n----------------------------------------\n\nTITLE: Defining Boolean Logic Operators 'and', 'or', and 'negate' in Custom MyBool Case Class Scala 2\nDESCRIPTION: Creates a Boolean wrapper class MyBool with methods 'and', 'or', and 'negate' to implement logical operations as instance methods. 'and' returns the second operand if the first is true, otherwise returns the first. 'or' returns the first if true, else the second. 'negate' inverts the boolean value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/operators.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ncase class MyBool(x: Boolean) {\n  def and(that: MyBool): MyBool = if (x) that else this\n  def or(that: MyBool): MyBool = if (x) this else that\n  def negate: MyBool = MyBool(!x)\n}\n```\n\n----------------------------------------\n\nTITLE: Uploading multiple files using multipart requests with sttp in Scala 2\nDESCRIPTION: This snippet illustrates how to upload multiple files via HTTP multipart/form-data requests using sttp in Scala 2. It imports the quick client, converts OS-Lib paths to Java Paths for multiple files, constructs a multipart body with multipartFile helper for each file, sends an HTTP POST request with this multipart body to the specified endpoint, and handles the response. Dependencies include sttp client4 and OS-Lib. The input is multiple local file paths, and the output is the HTTP response indicating success or failure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/http-client-upload-file.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport sttp.client4.quick._\n\nval file1 = (os.pwd / \"avatar1.png\").toNIO\nval file2 = (os.pwd / \"avatar2.png\").toNIO\nval response = quickRequest\n  .post(uri\"https://example.com/\")\n  .multipartBody(\n    multipartFile(\"avatar1.png\", file1),\n    multipartFile(\"avatar2.png\", file2)\n  )\n  .send()\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Value Class Inside Another Class (Disallowed)\nDESCRIPTION: This snippet demonstrates that defining a value class (`Inner`) as a member of another regular class (`Outer`) is prohibited. This is because inner classes implicitly hold a reference to their enclosing class instance, which would violate the single-parameter rule for value classes. The compiler error confirms this restriction.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\nclass Outer {\n  class Inner(val x: Int) extends AnyVal\n}\n```\n\nLANGUAGE: text\nCODE:\n```\nOuter.scala:2: error: value class may not be a member of another class\nclass Inner(val x: Int) extends AnyVal\n      ^\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Connecting Nodes within a Single Graph in Scala\nDESCRIPTION: Demonstrates instantiation of a Graph object and creation of multiple nodes belonging to this graph. Each node is explicitly typed as belonging to the graph instance's Node type, emphasizing the path-dependent type system's effect. The nodes are then connected using the connectTo method. This snippet shows the expected correct usage where nodes are within the same graph context, ensuring compile-time type safety.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/inner-classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval graph1: Graph = new Graph\nval node1: graph1.Node = graph1.newNode\nval node2: graph1.Node = graph1.newNode\nval node3: graph1.Node = graph1.newNode\nnode1.connectTo(node2)\nnode3.connectTo(node1)\n```\n\n----------------------------------------\n\nTITLE: Handling Exceptions and Safe Head Access with Option in Scala\nDESCRIPTION: This snippet demonstrates accessing the head of an empty list, which throws an exception, and then safely accessing the head using headOption. Inputs are an empty List[Int]. No dependencies required. When using head, a java.util.NoSuchElementException is thrown if the list is empty; headOption avoids this by returning None, which is important for robust, functional code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-methods.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval emptyList = List[Int]()   // emptyList: List[Int] = List()\nemptyList.head                // java.util.NoSuchElementException: head of empty list\n```\n\nLANGUAGE: scala\nCODE:\n```\nemptyList.headOption          // None\n```\n\n----------------------------------------\n\nTITLE: 示例：逆变类型在函数（函数对象）中的应用（Scala 2/3）\nDESCRIPTION: 定义函数 trait Function[-A, +B]，简称函数类型，参数A逆变，返回B协变，体现逆变在输入位置的类型安全和兼容性，允许子类型输入。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-variance.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Function[-A, +B] {\n  def apply(a: A): B\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing implicit Monoid instances for String and Int in Scala\nDESCRIPTION: This code defines implicit objects for `StringMonoid` and `IntMonoid`, which implement the `Monoid` trait for common data types. Declaring these objects as implicit allows their automatic use in functions requiring a `Monoid`, such as summation over lists, without explicit parameter passing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/implicit-parameters.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit object StringMonoid extends Monoid[String] {\n  def add(x: String, y: String): String = x concat y\n  def unit: String = \"\"\n}\nimplicit object IntMonoid extends Monoid[Int] {\n  def add(x: Int, y: Int): Int = x + y\n  def unit: Int = 0\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Class Body with Fields and Methods in Scala 2\nDESCRIPTION: This snippet shows how to add fields and methods to a class body in Scala 2. The code within the class body is executed during initialization. The `fullName` field is calculated upon instance creation, and the `printFullName` method accesses it.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nclass Person(var firstName: String, var lastName: String) {\n\n  println(\"initialization begins\")\n  val fullName = firstName + \" \" + lastName\n\n  // a class method\n  def printFullName: Unit =\n    // access the `fullName` field, which is created above\n    println(fullName)\n\n  printFullName\n  println(\"initialization ends\")\n}\n```\n\n----------------------------------------\n\nTITLE: 標準出力で結果を表示する - Scala\nDESCRIPTION: println関数を使用して整数や文字列の式の結果をコンソールに表示する例です。複数の表現の結合や計算結果を順番に出力します。依存関係なし、標準Scala環境で動作可能です。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nprintln(1) // 1\nprintln(1 + 1) // 2\nprintln(\"Hello!\") // Hello!\nprintln(\"Hello,\" + \" world!\") // Hello, world!\n```\n\n----------------------------------------\n\nTITLE: Defining Sample Lists in Scala\nDESCRIPTION: Initializes sample lists 'nums' and 'names' that are used throughout the document to demonstrate various sequence methods. 'nums' is a list of integers from 1 to 10, and 'names' is a list of strings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/collections-methods.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval nums = (1 to 10).toList\nval names = List(\"joel\", \"ed\", \"chris\", \"maurice\")\n```\n\n----------------------------------------\n\nTITLE: Anonymous Functions and Higher-order Collection Operations - Scala\nDESCRIPTION: Illustrates definition and use of anonymous functions, including underscore shorthand, with map, reduce, or other operations on collections. No dependencies needed, works with standard Scala collections. Demonstrates both single-argument and multi-argument styles, as well as block body forms.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n(x:R) => x*x\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(1 to 5).map(_*2)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(1 to 5).reduceLeft( _+_ )\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(1 to 5).map( x => x*x )\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(1 to 5).map { val x=_*2; println(x); x }\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(1 to 5) filter {_%2 == 0} map {_*2}\n```\n\n----------------------------------------\n\nTITLE: Defining Invariant, Covariant, and Contravariant Traits in Scala\nDESCRIPTION: Defines three generic traits illustrating different variance annotations. `Pipeline[T]` is invariant (default), suitable for types that both consume and produce `T`. `Producer[+T]` is covariant, suitable for types that only produce `T`. `Consumer[-T]` is contravariant, suitable for types that only consume `T`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-variance.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 2 Version\n// an example of an invariant type\ntrait Pipeline[T] {\n  def process(t: T): T\n}\n\n// an example of a covariant type\ntrait Producer[+T] {\n  def make: T\n}\n\n// an example of a contravariant type\ntrait Consumer[-T] {\n  def take(t: T): Unit\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 3 Version\n// an example of an invariant type\ntrait Pipeline[T]:\n  def process(t: T): T\n\n// an example of a covariant type\ntrait Producer[+T]:\n  def make: T\n\n// an example of a contravariant type\ntrait Consumer[-T]:\n  def take(t: T): Unit\n```\n\n----------------------------------------\n\nTITLE: Multiple Trait Mixing in Scala\nDESCRIPTION: Demonstrates how to mix multiple traits into a class. Shows both direct implementation of multiple traits and mixing traits with class inheritance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/cheatsheets/index.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ntrait T1; trait T2\nclass C extends T1 with T2\nclass C extends D with T1 with T2\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Enum (Scala)\nDESCRIPTION: This Scala snippet demonstrates the modern syntax for defining a simple enumeration using the `enum` keyword and `case` identifiers for the members.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_66\n\nLANGUAGE: Scala\nCODE:\n```\nenum Color:\n  case Red, Green, Blue\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Generators in Scala 'for' Loops (Nested Iteration)\nDESCRIPTION: Illustrates how to use multiple generators within a single `for` loop to achieve nested iteration over different ranges or collections. Compares Scala 2 (curly braces around generators) and Scala 3 (stacked generators before `do`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_11\n\nLANGUAGE: Scala 2\nCODE:\n```\nfor {\n  i <- 1 to 2\n  j <- 'a' to 'b'\n  k <- 1 to 10 by 5\n} {\n  println(s\"i = $i, j = $j, k = $k\")\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nfor\n  i <- 1 to 2\n  j <- 'a' to 'b'\n  k <- 1 to 10 by 5\ndo\n  println(s\"i = $i, j = $j, k = $k\")\n```\n\n----------------------------------------\n\nTITLE: Building Strings with StringBuilder in Scala\nDESCRIPTION: Demonstrates how to create a StringBuilder and use it to efficiently build a string by appending characters and strings. StringBuilder is automatically imported into the default scope.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/concrete-mutable-collection-classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval buf = new StringBuilder\nbuf += 'a'\nbuf ++= \"bcdef\"\nbuf.toString\n```\n\n----------------------------------------\n\nTITLE: Using Basic 's' String Interpolation in Scala\nDESCRIPTION: Demonstrates the fundamental usage of the `s` interpolator in Scala to embed variables directly into a string literal. Variables prefixed with `$` are replaced by their string representation (`toString` is called).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/string-interpolation.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval name = \"James\"\nval age = 30\nprintln(s\"$name is $age years old\")   // \"James is 30 years old\"\n```\n\n----------------------------------------\n\nTITLE: Using Match Expression Following Method Calls in Scala 3\nDESCRIPTION: Demonstrates a Scala 3 match expression used after a period following chained method calls on a list. It maps all elements in `List(1, 2, 3)` by doubling them, then obtains the optional head element, matching on the `Option` result to print the head value if present or a message if the list is empty. This shows succinct handling of values wrapped in `Option` via pattern matching using Scala 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_38\n\nLANGUAGE: scala\nCODE:\n```\nList(1, 2, 3)\n  .map(_ * 2)\n  .headOption\n  .match\n    case Some(value) => println(s\"The head is: $value\")\n    case None => println(\"The list is empty\")\n```\n\n----------------------------------------\n\nTITLE: Declaring Mutable Variables in Scala\nDESCRIPTION: This snippet shows the 'var' keyword used to declare mutable variables in Scala. Unlike JavaScript, Scala uses 'var' consistently for mutable declarations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nvar  // used for mutable variables\n```\n\n----------------------------------------\n\nTITLE: Using the SensorReader Component (Scala 3)\nDESCRIPTION: Demonstrates Scala 3 usage of the `SensorReader` component. It imports members using `*`, creates instances of `Sensor` and `Display` (without `new`), subscribes displays (observers) to sensors (subjects), and triggers updates via the `changeValue` method, printing notifications.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\nimport SensorReader.*\n\n// setting up a network\nval s1 = Sensor(\"sensor1\")\nval s2 = Sensor(\"sensor2\")\nval d1 = Display()\nval d2 = Display()\ns1.subscribe(d1)\ns1.subscribe(d2)\ns2.subscribe(d1)\n\n// propagating updates through the network\ns1.changeValue(2)\ns2.changeValue(3)\n\n// prints:\n// sensor1 has value 2.0\n// sensor1 has value 2.0\n// sensor2 has value 3.0\n```\n\n----------------------------------------\n\nTITLE: Matching Ranges with If Guards in Scala 3\nDESCRIPTION: Shows how to use `if` guards with the `contains` method on integer ranges (`0 to 9`, `10 to 19`, etc.) within Scala 3 match expressions (using indentation syntax) to efficiently match an input value against different numeric ranges.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_25\n\nLANGUAGE: Scala\nCODE:\n```\ni match\n  case a if 0 to 9 contains a => println(s\"0-9 range: $a\")\n  case b if 10 to 19 contains b => println(s\"10-19 range: $b\")\n  case c if 20 to 29 contains c => println(s\"20-29 range: $c\")\n  case _ => println(\"Hmmm...\")\n```\n\n----------------------------------------\n\nTITLE: Illustrating Statements with Side Effects in Scala\nDESCRIPTION: Contrasts EOP by showing statements, which do not return a value but perform actions (side effects), like conditionally calling `action()` or printing to the console. Compares Scala 2 and Scala 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_8\n\nLANGUAGE: Scala 2\nCODE:\n```\nif (a == b) action()\nprintln(\"Hello\")\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nif a == b then action()\nprintln(\"Hello\")\n```\n\n----------------------------------------\n\nTITLE: Exception Handling with try/catch/finally Using Pattern Matching in Scala 2\nDESCRIPTION: Shows exception handling with a try block executing a file reading function `openAndReadAFile(filename)`, and a catch block that uses pattern matching on exceptions `FileNotFoundException` and `IOException` to call `printStackTrace()` on each. Finally, a finally block runs code to execute regardless of exceptions, intended here for cleaning resources. This uses Scala 2 syntax with braces and requires `openAndReadAFile` throwing Java IO exceptions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_39\n\nLANGUAGE: scala\nCODE:\n```\nvar text = \"\"\ntry {\n  text = openAndReadAFile(filename)\n} catch {\n  case fnf: FileNotFoundException => fnf.printStackTrace()\n  case ioe: IOException => ioe.printStackTrace()\n} finally {\n  // close your resources here\n  println(\"Came to the 'finally' clause.\")\n}\n```\n\n----------------------------------------\n\nTITLE: Importing multiple members concisely in Scala\nDESCRIPTION: Demonstrates importing multiple members from a package in a single line using brace syntax for clarity and brevity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/packaging-imports.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.concurrent.{Future, Promise, blocking}  // Scala 2 and 3\n```\n\n----------------------------------------\n\nTITLE: Using either Combinator to Obtain First Completed Future Result in Scala\nDESCRIPTION: Demonstrates the either combinator which returns a Future holding the result of the first completed Future whether success or failure. Similar Futures for USD and CHF values are created and mapped to strings. The resulting anyQuote Future completes with the first Future that finishes, and its result is printed. This snippet shows how to race Futures for responsiveness.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/futures-promises.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nval usdQuote = Future {\n  connection.getCurrentValue(USD)\n} map {\n  usd => \"Value: \" + usd + \"$\"\n}\nval chfQuote = Future {\n  connection.getCurrentValue(CHF)\n} map {\n  chf => \"Value: \" + chf + \"CHF\"\n}\n\nval anyQuote = usdQuote either chfQuote\n\nanyQuote onSuccess { println(_) }\n```\n\n----------------------------------------\n\nTITLE: Defining a Class in Scala 2\nDESCRIPTION: Introduces class definition with primary constructor and a method member. Shows method with one parameter and Unit return type. This is a foundational construct for OOP in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\nclass Greeter(prefix: String, suffix: String) {\n  def greet(name: String): Unit =\n    println(prefix + name + suffix)\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Variables with Explicit Types in Scala 2 and 3\nDESCRIPTION: Defines variables with explicit type annotations to demonstrate declaring types in Scala. It requires the Scala language environment and shows basic primitive types: Int and Double. The code illustrates stating type explicitly to ensure type safety and clarity, specifying both variable name and type. The expected output is successful compilation and variables with the stated types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-inferred.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval x: Int = 1\nval y: Double = 1\n```\n\n----------------------------------------\n\nTITLE: Defining an Abstract Trait Interface in Scala 3\nDESCRIPTION: This snippet shows the equivalent trait Showable definition in Scala 3, using the modern syntax. It defines an abstract method show, which must be implemented by any subclass. This approach requires no dependencies and is designed for extensibility in Scala 3 projects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntrait Showable:\n  def show: String\n```\n\n----------------------------------------\n\nTITLE: Importing From Root Package in Scala 2\nDESCRIPTION: Shows how to import all members from the 'users' package in Scala 2 while inside the 'accounts' package, using the '_root_' qualifier to resolve naming conflicts. Essential if the local scope causes ambiguity with package names. No parameters are required. This approach is limited to scenarios where top-level access is required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/packages-and-imports.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\npackage accounts\n\nimport _root_.users._\n```\n\n----------------------------------------\n\nTITLE: Selecting a Specific Test within a Suite with .only in Scala\nDESCRIPTION: In-code example showing how to run only a specific test method by appending '.only' in the test definition. Supports Scala 2 and Scala 3 syntax, useful for debugging individual tests during development.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-run-only.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass MathSuite extends munit.FunSuite {\n  test(\"addition\") {\n    assert(1 + 1 == 2)\n  }\n  test(\"multiplication\".only) {\n    assert(3 * 7 == 21)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating through a Map with for-loop in Scala 2\nDESCRIPTION: Demonstrates how to iterate through a Map's key-value pairs using a for-loop in Scala 2. The pattern (abbrev, fullName) destructures each key-value pair.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nfor ((abbrev, fullName) <- states) println(s\"$abbrev: $fullName\")\n```\n\n----------------------------------------\n\nTITLE: Using Trait Subtyping for Polymorphism in Scala\nDESCRIPTION: Demonstrates defining a trait 'Pet' with an abstract value 'name', then creating classes 'Cat' and 'Dog' that implement the trait by providing concrete 'name' values via their constructors. It shows how objects of these classes can be stored in a collection of type 'ArrayBuffer[Pet]' and accessed polymorphically. The snippet requires Scala collections and mutable ArrayBuffer.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/traits.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable.ArrayBuffer\n\ntrait Pet {\n  val name: String\n}\n\nclass Cat(val name: String) extends Pet\nclass Dog(val name: String) extends Pet\n\nval dog = new Dog(\"Harry\")\nval cat = new Cat(\"Sally\")\n\nval animals = ArrayBuffer.empty[Pet]\nanimals.append(dog)\nanimals.append(cat)\nanimals.foreach(pet => println(pet.name))  // Prints Harry Sally\n```\n\n----------------------------------------\n\nTITLE: Switch statements in Java vs match expressions in Scala\nDESCRIPTION: Compares Java's switch statement with Scala's match expression for simple value matching. Scala's match is an expression that returns a value and doesn't require break statements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_45\n\nLANGUAGE: Java\nCODE:\n```\nString monthAsString = \"\";\nswitch(day) {\n  case 1: monthAsString = \"January\";\n         break;\n  case 2: monthAsString = \"February\";\n         break;\n  default: monthAsString = \"Other\";\n         break;\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval monthAsString = day match\n  case 1 => \"January\"\n  case 2 => \"February\"\n  case _ => \"Other\"\n```\n\n----------------------------------------\n\nTITLE: Executing basic statements in a Scala worksheet\nDESCRIPTION: This Scala code snippet demonstrates the fundamental usage of a worksheet. It includes printing output to the console, declaring a variable, and evaluating an expression. Worksheets execute these statements sequentially from top to bottom, displaying the result of each expression.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-worksheets.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nprintln(\"Hello, world!\")\n\nval x = 1\nx + x\n```\n\n----------------------------------------\n\nTITLE: Calculating Factorial Using Nested Methods in Scala\nDESCRIPTION: Defines a factorial function in Scala using an inner recursive method 'fact' to efficiently compute factorial via tail recursion with an accumulator. The outer method takes an integer 'x' as input and returns its factorial as an integer output. The nested 'fact' method handles the recursion, terminating when 'x' is less than or equal to 1, providing an optimized and encapsulated implementation. The code includes print statements to output results for sample values (2 and 3). Dependencies include a Scala runtime environment supporting nested method definitions and standard output. Inputs are expected as non-negative integers; outputs are integer factorial values. No external libraries are required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/nested-functions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n def factorial(x: Int): Int = {\n    def fact(x: Int, accumulator: Int): Int = {\n      if (x <= 1) accumulator\n      else fact(x - 1, x * accumulator)\n    }  \n    fact(x, 1)\n }\n\n println(\"Factorial of 2: \" + factorial(2))\n println(\"Factorial of 3: \" + factorial(3))\n```\n\n----------------------------------------\n\nTITLE: Defining foldLeft with Multiple Parameter Lists in Scala\nDESCRIPTION: Shows the signature of the `foldLeft` method from Scala's `Iterable` trait, demonstrating the use of multiple parameter lists (`(z: B)(op: (B, A) => B)`). The first list takes the initial value, and the second takes the binary operation function.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/multiple-parameter-lists.md#_snippet_0\n\nLANGUAGE: Scala 2\nCODE:\n```\ntrait Iterable[A] {\n  ...\n  def foldLeft[B](z: B)(op: (B, A) => B): B\n  ...\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ntrait Iterable[A]:\n  ...\n  def foldLeft[B](z: B)(op: (B, A) => B): B\n  ...\n```\n\n----------------------------------------\n\nTITLE: Defining a public method in a Scala class\nDESCRIPTION: An example showing how methods in Scala classes are public by default, allowing external access without explicit modifiers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/methods-most.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass Dog {\n  def speak() = println(\"Woof\")\n}\n\nval d = new Dog\nd.speak()   // prints \"Woof\"\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Dog:\n  def speak() = println(\"Woof\")\n\nval d = new Dog\nd.speak()   // prints \"Woof\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication Service with Cookies in Cask (Scala 3)\nDESCRIPTION: This snippet illustrates an authentication flow using cookies within the Cask web framework in Scala 3. It depends on Java libraries (java.util.UUID, java.util.concurrent.ConcurrentHashMap) and Cask routing/decorator APIs. Key features include endpoints for login (generating/saving session ID in cookies), checking authentication (using the request to read cookies), and logout (removing session and expiring the cookie). Inputs are login credentials and session cookies; outputs are HTML forms or status text. The code leverages Scala 3's conciseness, and sessions are held in a thread-safe set. All necessary libraries, especially Cask, must be available.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/web-server-cookies-and-decorators.md#_snippet_1\n\nLANGUAGE: Scala 3\nCODE:\n```\nimport java.util.UUID\nimport java.util.concurrent.ConcurrentHashMap\n\nobject Example extends cask.MainRoutes:\n\n  val sessionIds = ConcurrentHashMap.newKeySet[String]()\n\n  @cask.get(\"/login\")\n  def getLogin(): cask.Response[String] =\n    val html =\n      \"\"\"<!doctype html>\n        |<html>\n        |<body>\n        |<form action=\"/login\" method=\"post\">\n        |  <label for=\"name\">Username:</label><br>\n        |  <input type=\"text\" name=\"name\" value=\"\"><br>\n        |  <label for=\"password\">Password:</label><br>\n        |  <input type=\"text\" name=\"password\" value=\"\"><br><br>\n        |  <input type=\"submit\" value=\"Submit\">\n        |</form>\n        |</body>\n        |</html>\"\"\".stripMargin\n\n    cask.Response(data = html, headers = Seq(\"Content-Type\" -> \"text/html\"))\n\n  @cask.postForm(\"/login\")\n  def postLogin(name: String, password: String): cask.Response[String] =\n    if name == \"user\" && password == \"password\" then\n        val sessionId = UUID.randomUUID().toString\n        sessionIds.add(sessionId)\n        cask.Response(data = \"Success!\", cookies = Seq(cask.Cookie(\"sessionId\", sessionId)))\n    else\n      cask.Response(data = \"Authentication failed\", statusCode = 401)\n\n  @cask.get(\"/check\")\n  def checkLogin(request: cask.Request): String =\n    val sessionId = request.cookies.get(\"sessionId\")\n    if sessionId.exists(cookie => sessionIds.contains(cookie.value)) then\n      \"You are logged in\"\n    else\n      \"You are not logged in\"\n\n  @cask.get(\"/logout\")\n  def logout(sessionId: cask.Cookie): cask.Response[String] = \n    sessionIds.remove(sessionId.value)\n    cask.Response(data = \"Successfully logged out!\", cookies = Seq(cask.Cookie(\"sessionId\", \"\", expires = Instant.EPOCH)))\n\n  initialize()\n```\n\n----------------------------------------\n\nTITLE: Defining Show Type Class and Instances Including Generic Derivation in Scala\nDESCRIPTION: Defines the Show type class for pretty-printing values as strings, the Show object with implicit instances for Int, String, Unit, tuple pairs, Either, and via shapeless Generic. Demonstrates how to support both base types and generic product/sum types. Parameterizes Show instances for product and sum types, requiring appropriate Show and Generic instances for the components. Intended for recursive and generic use cases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Show[T] {\n  def show(x: T): String\n}\n\nobject Show {\n  def apply[T](implicit st: Show[T]): Show[T] = st\n\n  implicit val showInt: Show[Int] = new Show[Int] {\n    def show(x: Int): String = x.toString\n  }\n\n  implicit val showString: Show[String] = new Show[String] {\n    def show(x: String): String = x\n  }\n\n  implicit val showUnit: Show[Unit] = new Show[Unit] {\n    def show(x: Unit): String = \"\"\n  }\n\n  implicit def showPair[T, U]\n    (implicit\n      st: Show[T],\n      su: Show[U]):\n          Show[(T, U)] = new Show[(T, U)] {\n    def show(t: (T, U)): String = {\n      val fst = st.show(t._1)\n      val snd = su.show(t._2)\n      if(snd == \"\") fst else s\"$fst, $snd\"\n    }\n  }\n\n  implicit def showEither[T, U]\n    (implicit\n      st: Show[T],\n      su: Show[U]):\n          Show[Either[T, U]] = new Show[Either[T, U]] {\n    def show(x: Either[T, U]): String = x match {\n      case Left(t)  => st.show(t)\n      case Right(u) => su.show(u)\n    }\n  }\n\n  implicit def showGeneric[T, R]\n    (implicit\n      gen: Generic.Aux[T, R],\n      sr:  Show[R]):\n           Show[T] = new Show[T] {\n    def show(x: T): String = sr.show(gen.to(x))\n  }\n}\n\nval sl = Show[List[Int]] // diverges\nassert(\n  sl.show(Cons(1, Cons(2, Cons(3, Nil)))) == \"1, 2, 3\"\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing an Invariant Linked List in Scala\nDESCRIPTION: A simple implementation of an immutable linked list without variance annotations. The ListNode class defines a singly-linked list with methods for accessing the head, tail, and prepending elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/lower-type-bounds.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class ListNode[T](h: T, t: ListNode[T]) {\n  def head: T = h\n  def tail: ListNode[T] = t\n  def prepend(elem: T): ListNode[T] =\n    ListNode(elem, this)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Empty ArrayBuffer Instances in Scala\nDESCRIPTION: Shows how to create empty mutable ArrayBuffer instances for integers and strings, enabling dynamic addition of elements later.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/arraybuffer-examples.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval ints = ArrayBuffer[Int]()\nval names = ArrayBuffer[String]()\n```\n\n----------------------------------------\n\nTITLE: Selective import of 'given' implicit instances with wildcards\nDESCRIPTION: Illustrates importing specific 'given' instances like 'Ordering' and 'ExecutionContext' from an object, while ignoring others such as 'im'; shows how to filter imported 'given' instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/packaging-imports.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nimport Instances.{given Ordering[?], given ExecutionContext}\n```\n\n----------------------------------------\n\nTITLE: Extending List from Iterable and Implementing IterableOps in Scala 2 and 3\nDESCRIPTION: This concise trait declaration shows List[A] extending the base Iterable[A] trait and mixing in IterableOps[A, List, List[A]]. This demonstrates instantiation of the IterableOps type parameters in a concrete collection, a key step in tying together the abstract operations with their concrete implementations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ntrait List[+A] extends Iterable[A]\n  with IterableOps[A, List, List[A]]\n```\n\n----------------------------------------\n\nTITLE: Constructing Throw Quasiquotes - Scala\nDESCRIPTION: Shows how to create an AST node for a `throw` expression using quasiquotes. The example `q\"throw new Exception\"` demonstrates creating a tree that represents throwing an exception.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_25\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val thr = q\"throw new Exception\"\nthr: universe.Throw = throw new Exception()\n```\n\n----------------------------------------\n\nTITLE: Using For and For-Yield Comprehensions in Scala Macros\nDESCRIPTION: This code demonstrates how to construct Scala 'for' and 'for-yield' expressions with quasiquotes, including enumerators with pattern bindings, guards, and value definitions. It also shows how to deconstruct such comprehensions back into enumerators and body, which is essential for macros that generate or analyze monadic code structures.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_52\n\nLANGUAGE: Scala\nCODE:\n```\nval `for-yield` = q\"for (x <- xs; if x > 0; y = x * 2) yield x\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval enums = List(fq\"x <- xs\", fq\"if x > 0\", fq\"y = x * 2\")\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval `for-yield` = q\"for (..$enums) yield y\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval q\"for (..$enums) yield $body\" = `for-yield`\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval q\"for (..$enums) $body\" = `for-yield`\n```\n\n----------------------------------------\n\nTITLE: Defining a Scala Class with Constructor Parameters, Methods, and Overriding toString\nDESCRIPTION: Defines a 'Point' class with mutable variables 'x' and 'y' as constructor parameters and methods to modify and represent the object as a string. The 'move' method updates coordinates by given deltas, returning Unit (void). The 'toString' method overrides the default method from AnyRef to provide a string representation of the point. Illustrates primary constructor syntax and method overriding in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass Point(var x: Int, var y: Int) {\n\n  def move(dx: Int, dy: Int): Unit = {\n    x = x + dx\n    y = y + dy\n  }\n\n  override def toString: String =\n    s\"($x, $y)\"\n}\n\nval point1 = new Point(2, 3)\npoint1.x  // 2\nprintln(point1)  // wyświetla (2, 3)\n```\n\n----------------------------------------\n\nTITLE: Example Usage of collapse Function in Scala\nDESCRIPTION: This interactive Scala console snippet shows how to use the `collapse` function (referencing the second version) with an iterator containing leading zeros. It demonstrates that the function successfully transforms `Iterator(0, 0, 0, 1, 2, 3, 4)` into an iterator that, when converted to a list, results in `List(0, 1, 2, 3, 4)`, correctly keeping only one leading zero.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/iterators.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nscala> collapse(Iterator(0, 0, 0, 1, 2, 3, 4)).toList\nres14: List[Int] = List(0, 1, 2, 3, 4)\n```\n\n----------------------------------------\n\nTITLE: Using Fully-Qualified Imports with _root_ in Scala\nDESCRIPTION: Explains usage of the special `_root_` prefix to fully qualify imports in the presence of nested packages or shadowing. This avoids ambiguities by referring directly to the root package hierarchy but should be used sparingly to reduce clutter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/naming-conventions.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport _root_.net.liftweb._\n```\n\n----------------------------------------\n\nTITLE: Modifying Immutable Scala Sets with Addition and Removal Operators - Scala\nDESCRIPTION: Demonstrates how to add and remove elements from an immutable Scala Set using + and - operators. These operators create new sets since the original is immutable, thus necessitating variable reassignment. This example shows a mutable variable holding the set, so operations like += and -= implicitly replace the set with a new one including or excluding specified elements. The input is a variable of type immutable Set[Int], and output is the updated variable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/sets.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nvar s = Set(1, 2, 3)\ns += 4\ns -= 2\ns\n```\n\n----------------------------------------\n\nTITLE: Using import within function scope in Scala 2\nDESCRIPTION: Demonstrates Scala 2 syntax for importing a package member inside a function, limiting scope of the import to the function. This local import reduces namespace pollution and helps in managing dependencies within specific contexts.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/packages-and-imports.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ndef sqrtplus1(x: Int) = {\n  import scala.math.sqrt\n  sqrt(x) + 1.0\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Immutable Fields with final in Java\nDESCRIPTION: In Java, the `final` keyword is used to declare a field whose value cannot be reassigned after it has been initialized. This makes the field immutable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_14\n\nLANGUAGE: Java\nCODE:\n```\nfinal int i = 1;\n```\n\n----------------------------------------\n\nTITLE: Alternative For/Yield Syntax Variations in Scala 3\nDESCRIPTION: Shows several legal forms for for/yield in Scala 3, all producing a new List with elements doubled. Prerequisites: ints must be a valid collection. All statements assign a new List as doubles.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nval doubles = for i <- ints yield i * 2     // style shown above\nval doubles = for (i <- ints) yield i * 2\nval doubles = for (i <- ints) yield (i * 2)\nval doubles = for { i <- ints } yield (i * 2)\n\n```\n\n----------------------------------------\n\nTITLE: Using Contravariant Printers to Print Cats in Scala - scala\nDESCRIPTION: Defines an object demonstrating usage of contravariant Printer types. The method printMyCat accepts a Printer for Cats and prints a Cat instance. It shows that both CatPrinter and AnimalPrinter instances can be passed due to contravariance. The output confirms correct operation, illustrating contravariance allowing broader printer types to be used.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/variances.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nobject ContravarianceTest extends App {\n  val myCat: Cat = Cat(\"Boots\")\n\n  def printMyCat(printer: Printer[Cat]): Unit = {\n    printer.print(myCat)\n  }\n\n  val catPrinter: Printer[Cat] = new CatPrinter\n  val animalPrinter: Printer[Animal] = new AnimalPrinter\n\n  printMyCat(catPrinter)\n  printMyCat(animalPrinter)\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Iterator to BufferedIterator and Using head in Scala\nDESCRIPTION: This interactive Scala console snippet demonstrates converting a standard `Iterator` to a `BufferedIterator` using the `buffered` method. It shows that calling `bit.head` returns the next element (`1`) but does not advance the iterator, whereas `bit.next()` consumes the element and moves the iterator forward. `headOption` is also shown as a safe way to peek.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/iterators.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nscala> val it = Iterator(1, 2, 3, 4)\nit: Iterator[Int] = non-empty iterator\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> val bit = it.buffered\nbit: scala.collection.BufferedIterator[Int] = non-empty iterator\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> bit.head\nres10: Int = 1\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> bit.next()\nres11: Int = 1\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> bit.next()\nres12: Int = 2\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> bit.headOption\nres13: Option[Int] = Some(3)\n```\n\n----------------------------------------\n\nTITLE: Adding sbt-scala3-migrate Plugin in plugins.sbt (Scala)\nDESCRIPTION: This snippet demonstrates how to add the `sbt-scala3-migrate` plugin to your sbt project. It should be placed in the `project/plugins.sbt` file. This makes the migration commands available in the sbt shell.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/scala3-migrate.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n// project/plugins.sbt\naddSbtPlugin(\"ch.epfl.scala\" % \"sbt-scala3-migrate\" % \"0.6.1\")\n```\n\n----------------------------------------\n\nTITLE: Invalid Method Overloading with Default Parameters in Scala 2\nDESCRIPTION: This example shows that Scala doesn't allow having two methods with default parameters and the same name. This prevents ambiguity when calling the method without parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/default-parameter-values.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nobject A {\n  def func(x: Int = 34): Unit\n  def func(y: String = \"abc\"): Unit\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Builder Trait for Strict Construction - Scala 2\nDESCRIPTION: This snippet defines the mutable Builder trait for strict construction of collection instances in Scala 2. Builders accumulate elements via addOne and yield the final collection with result. This approach is preferred for operations that require immediate evaluation, and is foundational for implementing strict variants of collection operations. It depends on scala.collection.mutable and is generic in both element and collection type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\npackage scala.collection.mutable\n\ntrait Builder[-A, +C] {\n  def addOne(elem: A): this.type\n  def result(): C\n}\n```\n\n----------------------------------------\n\nTITLE: Rewriting `Lambda` keyword using Scala 3 native syntax (Scala 3 Only)\nDESCRIPTION: Shows how to replace the `kind-projector` `Lambda` keyword using Scala 3's native type lambda syntax (`[E, A] =>> ...`). This approach is specific to Scala 3 and infers variance markers automatically, making explicit `+` or `-` unnecessary.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/plugin-kind-projector.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\n[E, A] =>> Either[E, A]\n```\n\n----------------------------------------\n\nTITLE: Using WeakTypeTag in Scala\nDESCRIPTION: Example demonstrating WeakTypeTag which can represent type parameters or abstract types, preserving as much concrete type information as possible.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/reflection/typetags-manifests.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef weakParamInfo[T](x: T)(implicit tag: WeakTypeTag[T]): Unit = {\n  val targs = tag.tpe match { case TypeRef(_, _, args) => args }\n  println(s\"type of $x has type arguments $targs\")\n}\n\nscala> def foo[T] = weakParamInfo(List[T]())\nfoo: [T]=> Unit\n\nscala> foo[Int]\ntype of List() has type arguments List(T)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Function Subtyping with Variance in Scala\nDESCRIPTION: Provides examples of function subtyping based on variance. A base function `f` of type `Function[Buyable, Buyable]` is defined. Due to covariance in the return type, it can be assigned to `g` which expects a `Function[Buyable, Item]` (returning a supertype `Item`). Due to contravariance in the argument type, it can be assigned to `h` which expects a `Function[Book, Buyable]` (accepting a subtype `Book`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-variance.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nval f: Function[Buyable, Buyable] = b => b\n\n// OK to return a Buyable where a Item is expected\nval g: Function[Buyable, Item] = f\n\n// OK to provide a Book where a Buyable is expected\nval h: Function[Book, Buyable] = f\n```\n\n----------------------------------------\n\nTITLE: Comparing Scala Case Class Instances with Structural Equality and Printing\nDESCRIPTION: Creates two SMS case class instances with identical field values and demonstrates equality comparison using '==', which internally calls equals with structural equality. Also prints one instance to show the compiler-generated toString method formatting. It validates value-based equality semantics of case classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/case-classes.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval firstSms = SMS(\"12345\", \"Hello!\")\nval secondSms = SMS(\"12345\", \"Hello!\")\n\nif (firstSms == secondSms) {\n    println(\"They are equal!\")\n}\n\nprintln(\"SMS is: \" + firstSms)\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests with sbt - Bash\nDESCRIPTION: Provides an example of running the suite of ScalaTest tests using the sbt test command. The sample output indicates compilation, suite execution, individual test results, and test statistics. Requires correct project setup and existing tests; output includes summary and any pending or failed tests.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_25\n\nLANGUAGE: Bash\nCODE:\n```\nsbt:HelloScalaTest> test\n\n[info] Compiling 1 Scala source ...\n[info] MathUtilsTests:\n[info] - 'double' should handle 0\n[info] - 'double' should handle 1\n[info] - test with Int.MaxValue (pending)\n[info] Total number of tests run: 2\n[info] Suites: completed 1, aborted 0\n[info] Tests: succeeded 2, failed 0, canceled 0, ignored 0, pending 1\n[info] All tests passed.\n[success] Total time: 1 s\n\n```\n\n----------------------------------------\n\nTITLE: Control structures in Scala\nDESCRIPTION: Demonstrates various control flow constructs in Scala including conditionals, loops, and break statements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nif (check) happy else sad\n```\n\nLANGUAGE: scala\nCODE:\n```\nif (check) happy\n```\n\nLANGUAGE: scala\nCODE:\n```\nif (check) happy else ()\n```\n\nLANGUAGE: scala\nCODE:\n```\nwhile (x < 5) {\n  println(x)\n  x += 1\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ndo {\n  println(x)\n  x += 1\n} while (x < 5)\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.util.control.Breaks._\nbreakable {\n  for (x <- xs) {\n    if (Math.random < 0.1)\n      break\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Overloaded Map Operations on Map Collections - Scala\nDESCRIPTION: This example clarifies the new overloads for the \"map\" method on Scala's Map type. It demonstrates the dual signatures: one mapping to generic iterable, the other mapping to a Map, with improved type inference. Usage of function literals is supported, while direct method references require eta-expansion prior to Scala 2.13.0-M4. Requires immutable Map from scala.collection.immutable. Inputs are Map elements, outputs are either Map or Iterable collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/collections-migration-213.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nMap(1 -> \"a\").map\n  def map[B](f: ((Int, String)) => B): scala.collection.immutable.Iterable[B]\n  def map[K2, V2](f: ((Int, String)) => (K2, V2)): scala.collection.immutable.Map[K2,V2]\n\ndef f(t: (Int, String)) = (t._1 + 1, t._2)\nMap(1 -> \"a\").map(f) // error: missing argument list for method f\nMap(1 -> \"a\").map(f _) // OK: eta-expansion required\n```\n\n----------------------------------------\n\nTITLE: Single-line if statement in Scala 2 and 3\nDESCRIPTION: A comparison of single-line if statement syntax between Scala 2 and Scala 3. Scala 3 uses a more readable keyword-based syntax without parentheses.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/control-structures.md#_snippet_0\n\nLANGUAGE: Scala 2\nCODE:\n```\nif (x == 1) println(x)\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nif x == 1 then println(x)\n```\n\n----------------------------------------\n\nTITLE: Writing and Running a Failing MUnit Test - Scala 3\nDESCRIPTION: Declares a failing test in Scala 3 with MUnit, showing the standard way to define unit tests that check for value equality. The test deliberately sets an incorrect expected result, causing the assertion to fail and produce a detailed comparison error in the output. This snippet can be used to familiarize with MUnit's error reporting format and requires MUnit configured for Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-run.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ntest(\"failing test\") {\n  val obtained = 2 + 3\n  val expected = 4\n  assertEquals(obtained, expected)\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Notification Types to Extract Fields (Scala 2)\nDESCRIPTION: Defines a function showNotification that accepts a Notification parameter and returns a string description depending on the actual runtime type using pattern matching. Each case matches a specific case class (Email, SMS, VoiceRecording) and extracts relevant fields directly to format output messages. The underscore in Email's body field allows ignoring it. Demonstrates how pattern matching can destructure objects and operate on their properties. Examples instantiate SMS and VoiceRecording objects and print formatted messages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/pattern-matching.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef showNotification(notification: Notification): String = {\n  notification match {\n    case Email(sender, title, _) =>\n      s\"You got an email from $sender with title: $title\"\n    case SMS(number, message) =>\n      s\"You got an SMS from $number! Message: $message\"\n    case VoiceRecording(name, link) =>\n      s\"You received a Voice Recording from $name! Click the link to hear it: $link\"\n  }\n}\nval someSms = SMS(\"12345\", \"Are you there?\")\nval someVoiceRecording = VoiceRecording(\"Tom\", \"voicerecording.org/id/123\")\n\nprintln(showNotification(someSms))  // выводит \"You got an SMS from 12345! Message: Are you there?\"\n\nprintln(showNotification(someVoiceRecording))  // выводит \"You received a Voice Recording from Tom! Click the link to hear it: voicerecording.org/id/123\"\n```\n\n----------------------------------------\n\nTITLE: Declaring Variables in Scala with Explicit Types\nDESCRIPTION: This snippet shows Scala variable declarations with explicit type annotations. The val s is explicitly typed as String and the var i as Int. This clarifies the variable types for readability or when the compiler cannot infer them. Requires Scala environment.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/two-types-variables.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval s: String = \"hello\"\nvar i: Int = 42\n```\n\n----------------------------------------\n\nTITLE: Declaring Final Classes in Java\nDESCRIPTION: Shows how to declare a final Java class named Person, which prohibits subclassing. Demonstrates Java's explicit mechanism to prevent inheritance for classes that should not be extended, following design best practices.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_4\n\nLANGUAGE: Java\nCODE:\n```\nfinal class Person\n```\n\n----------------------------------------\n\nTITLE: Executing If Statement - JavaScript & Scala\nDESCRIPTION: Demonstrates basic conditional execution using single-line and multiline if statements/expressions in JavaScript and Scala. Note the optional parentheses and 'then' keyword in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_19\n\nLANGUAGE: JavaScript\nCODE:\n```\nif (x == 1) { console.log(1); }\n```\n\nLANGUAGE: Scala\nCODE:\n```\nif x == 1 then println(x)\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nif (x == 1) {\n  console.log(\"x is 1, as you can see:\")\n  console.log(x)\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nif x == 1 then\n  println(\"x is 1, as you can see:\")\n  println(x)\n```\n\n----------------------------------------\n\nTITLE: トレイト継承とメソッドオーバーライドを伴うクラス定義 - Scala\nDESCRIPTION: Greeterトレイトを継承したDefaultGreeterクラスの定義と、prefixおよびpostfix付きの挨拶文を出力するCustomizableGreeterクラスでgreetメソッドをオーバーライドする例です。複数トレイト継承の示唆も含みます。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\nclass DefaultGreeter extends Greeter\n\nclass CustomizableGreeter(prefix: String, postfix: String) extends Greeter {\n  override def greet(name: String): Unit = {\n    println(prefix + name + postfix)\n  }\n}\n\nval greeter = new DefaultGreeter()\ngreeter.greet(\"Scala developer\") // Hello, Scala developer!\n\nval customGreeter = new CustomizableGreeter(\"How are you, \", \"?\")\ncustomGreeter.greet(\"Scala developer\") // How are you, Scala developer?\n```\n\n----------------------------------------\n\nTITLE: Creating Generic Arrays Using ClassTag Context Bound Syntax (Correct)\nDESCRIPTION: Demonstrates the complete, correct implementation of the 'evenElems' function using the concise context bound syntax '[T: ClassTag]'. This syntax implicitly adds a ClassTag[T] parameter, enabling the creation of 'new Array[T]'. Requires importing 'scala.reflect.ClassTag'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/arrays.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect.ClassTag\n// this works\ndef evenElems[T: ClassTag](xs: Vector[T]): Array[T] = {\n  val arr = new Array[T]((xs.length + 1) / 2)\n  for (i <- 0 until xs.length by 2)\n    arr(i / 2) = xs(i)\n  arr\n}\n```\n\n----------------------------------------\n\nTITLE: 定义类型类 Showable 的 Scala 2 和 Scala 3 实现\nDESCRIPTION: 展示了如何声明一个参数化的 trait 作为类型类，包含一个抽象方法用于将对象转为字符串。Scala 2 版本通过普通 trait 和普通方法定义，Scala 3 版本使用扩展方法语法实现相同功能。该类型类可为任何类型提供自定义的字符串表示。无依赖外部库，适用于向封闭类型添加行为。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/ca-type-classes.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n// a type class\ntrait Showable[A] {\n  def show(a: A): String\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// a type class\ntrait Showable[A]:\n  extension(a: A) def show: String\n```\n\n----------------------------------------\n\nTITLE: Implementing Simple Scala 2 Macro for Source Location - Scala\nDESCRIPTION: This snippet provides a minimal Scala 2 macro implementation for extracting the source line number and file path. It uses 'scala.reflect.macros.blackbox.Context' and expects to be placed near the macro definition for 2.13. This implementation should avoid advanced macro features to be cross-compatible with Scala 3. The output tree constructs a 'Location' object from position info. Dependencies are limited to scala-reflect and macros enabled in the build.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-macro-mixing.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.macros.blackbox.Context\n\ndef locationImpl(c: Context): c.Tree =  {\n  import c.universe._\n  val line = Literal(Constant(c.enclosingPosition.line))\n  val path = Literal(Constant(c.enclosingPosition.source.path))\n  New(c.mirror.staticClass(classOf[Location].getName()), path, line)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Asynchronous Stock Price Lookup as a Scala Future\nDESCRIPTION: Shows how to declare a function getStockPrice that accepts a stock symbol (String) and returns a Future[Double], suitable for slow network or computational tasks. Actual implementation details are omitted (replaced with ???). Requires the Scala concurrent library. Input is the stock symbol; output is the asynchronous stock price.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/futures.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ndef getStockPrice(stockSymbol: String): Future[Double] = ???\n```\n\n----------------------------------------\n\nTITLE: Standard Scala Compiler Implicit Error Output\nDESCRIPTION: This example illustrates the default compiler error message when an implicit value cannot be found using older Scala versions or without enhanced formatting enabled. It shows only the error location and the missing type, lacking detailed implicit resolution information.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/compiler-options/errors.md#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\n[error] /path/Example.scala:20:5: could not find implicit value for parameter a: io.circe.Decoder[A]\n[error]   A.fun\n[error]     ^\n```\n\n----------------------------------------\n\nTITLE: Appending Elements with Symbolic Method\nDESCRIPTION: Demonstrates using the :+ method to append an element to a List.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\na :+ 4\n```\n\n----------------------------------------\n\nTITLE: Invoking Function Variable in Scala\nDESCRIPTION: Demonstrates calling the function variable `double` with an integer argument, showing how to retrieve the computed result. It takes an Int input and returns the doubled Int output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-function-variables.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval x = double(2)   // 4\n```\n\n----------------------------------------\n\nTITLE: Creating DB Instances with Anonymous Classes in Scala 2\nDESCRIPTION: Demonstrates the verbose implementation of DB instances in Scala 2, which requires creating anonymous inner classes implementing the dependent method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-dependent-function.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n// a user of a DB\ndef user(db: DB): Unit =\n  db.get(Name) ... db.get(Age)\n\n// creating an instance of the DB and passing it to `user`\nuser(new DB {\n  def get(k: Key): Option[k.Value] = ... // implementation of DB\n})\n```\n\n----------------------------------------\n\nTITLE: Applying an Anonymous Function with `map` (Shorthand) in Scala\nDESCRIPTION: Demonstrates using the `map` method on a `List` with a shorthand anonymous function (`_ * 2`) to create a new list where each element is doubled. The `_` acts as a placeholder for the single parameter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-anonymous-functions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval doubledInts = ints.map(_ * 2)   // List(2, 4, 6)\n```\n\n----------------------------------------\n\nTITLE: Macro Implementation Using Quasiquotes in Scala 2.11+\nDESCRIPTION: Simplifies macro definition by operating directly on syntax trees, illustrating advancements in Scala 2.11+ macros. Relies on the same dependencies (`Context`, `c.universe._`), but returns a tree without explicit expression wrapping. The macro takes an integer tree, generates code that adds one, and returns it directly; further reduces boilerplate for macro authors.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/usecases.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n// in 2.11 you can also do it like that\nobject Macro {\n  def apply(x: Int): Int = macro impl\n  def impl(c: Context)(x: c.Tree) = { import c.universe._\n    q\"$x + 1\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Snippet Compilation Check with Special Flag in Scala\nDESCRIPTION: This snippet demonstrates the usage of the 'sc:fail' flag in the snippet info section to explicitly indicate that the code should not compile. Required dependencies include the documentation tooling that supports snippet flags (such as 'sc:fail'). The 'val itShouldFail: Int = List(1.1, 2, 3).head' assignment triggers a compilation failure due to type mismatch, confirming the effectiveness of the flag. This approach allows authors to annotate individual Scala snippets with compile-check expectations directly in the documentation source.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/snippet-compiler.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nval itShouldFail: Int = List(1.1, 2, 3).head\n```\n\n----------------------------------------\n\nTITLE: Scala Anonymous Classes, Abstract Classes, and Inheritance\nDESCRIPTION: Examples of defining an anonymous class instance, abstract class without instantiation possibility, subclassing another class with constructor parameter forwarding, and defining a singleton object. These are basic building blocks for flexible and modular design in Scala, enabling runtime specialization, abstract design contracts, inheritance of behavior and state, and single-instance objects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/cheatsheets/index.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nnew {\n  ...\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class D { ... }\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass C extends D { ... }\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass D(var x: R)\nclass C(x: R) extends D(x)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nobject O extends D { ... }\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple Traits Scala\nDESCRIPTION: Illustrates how to define a Scala class `Dog` that extends multiple traits (`Speaker`, `TailWagger`, and `Runner`). It uses the `extends` keyword for the first trait and the `with` keyword for subsequent traits, providing implementations for all abstract methods required by the combined traits.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/traits-interfaces.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nclass Dog extends Speaker with TailWagger with Runner {\n\n    // Speaker\n    def speak(): String = \"Woof!\"\n\n    // TailWagger\n    def startTail(): Unit = println(\"tail is wagging\")\n    def stopTail(): Unit = println(\"tail is stopped\")\n\n    // Runner\n    def startRunning(): Unit = println(\"I'm running\")\n    def stopRunning(): Unit = println(\"Stopped running\")\n\n}\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Implementation of maxElement with using clause\nDESCRIPTION: Defines 'maxElement' to find the maximum element in a list using the 'using' keyword for context parameters in Scala 3. The 'Ord' type class provides comparison, and the method omits explicit passing of the 'ord' parameter by relying on implicit context resolution. Dependencies include the 'Ord' trait and the 'max' function.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-context-bounds.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef maxElement[A](as: List[A])(using ord: Ord[A]): A =\n  as.reduceLeft(max(_, _)(using ord))\n```\n\n----------------------------------------\n\nTITLE: Applying Custom Java Annotation in Scala with Named Parameters\nDESCRIPTION: This Scala snippet demonstrates using a Java-defined annotation in Scala code by applying '@Source' with parameters 'URL' and 'mail' supplied using named argument syntax. The example highlights Scala’s support for Java annotations and syntax similarity where annotation use looks like constructor invocation with named parameters. This is useful for interoperability and maintaining consistency with Java annotation semantics when using Java annotations in Scala projects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/annotations.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\n@Source(URL = \"https://coders.com/\",\n        mail = \"support@coders.com\")\nclass MyScalaClass ...\n```\n\n----------------------------------------\n\nTITLE: Instantiating Scala Address Class with None for Optional Field (Scala 2 and 3)\nDESCRIPTION: These examples instantiate Address objects with street2 set to None, explicitly signaling the absence of a secondary street address. This approach avoids nulls and aligns with idiomatic Scala usage of Option for optional fields.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-functional-error-handling.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nval santa = new Address(\n  \"1 Main Street\",\n  None,           // 'street2' has no value\n  \"North Pole\",\n  \"Alaska\",\n  \"99705\"\n)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval santa = Address(\n  \"1 Main Street\",\n  None,           // 'street2' has no value\n  \"North Pole\",\n  \"Alaska\",\n  \"99705\"\n)\n```\n\n----------------------------------------\n\nTITLE: Implement SubjectObserver with Concrete Types (Scala 2)\nDESCRIPTION: Implements the `SubjectObserver` component in Scala 2 by creating a singleton object `SensorReader`. It defines concrete types `Sensor` for abstract type `S` and `Display` for abstract type `O`. Nested classes `Sensor` (extending `Subject`) and `Display` (extending `Observer`) provide the specific implementations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\nobject SensorReader extends SubjectObserver {\n  type S = Sensor\n  type O = Display\n\n  class Sensor(val label: String) extends Subject {\n    private var currentValue = 0.0\n    def value = currentValue\n    def changeValue(v: Double) = {\n      currentValue = v\n      publish()\n    }\n  }\n\n  class Display extends Observer {\n    def notify(sub: Sensor) =\n      println(s\"${sub.label} has value ${sub.value}\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the abstract foreach method in Scala Traversable trait\nDESCRIPTION: Declares the essential abstract method foreach in the Traversable trait. This method accepts a function f which is applied as a side effect to each element of the collection. The parameter Elem represents the element type stored in the collection, and U is an arbitrary return type ignored by foreach. It is the minimum operation that must be implemented for any Traversable container, allowing other collection methods to be derived from it.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/trait-traversable.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef foreach[U](f: Elem => U)\n```\n\n----------------------------------------\n\nTITLE: Processing Future Success with For-Comprehension - Scala 2\nDESCRIPTION: Shows how to process only successful results from a Future using a for-comprehension in Scala 2. No manual error handling is done; the posts are printed only on success. Requires scala.concurrent.Future. session.getRecentPosts() must return List[String]; the output prints posts to standard output. Limitations: errors are ignored.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nval f: Future[List[String]] = Future {\n  session.getRecentPosts()\n}\n\nfor {\n  posts <- f\n  post <- posts\n} println(post)\n```\n\n----------------------------------------\n\nTITLE: Appliquer la fonction map avec une fonction nommée en Scala\nDESCRIPTION: Montre comment utiliser la fonction d'ordre supérieur map sur une collection Seq[Int] en Scala. La fonction doubleSalary, qui multiplie un entier par 2, est définie explicitement et passée à map pour transformer chaque élément. Le snippet illustre la syntaxe d'une fonction lambda nommée et son application sur une liste. Nécessite Scala standard library pour Seq et fonctions lambda. Entrées: liste d'entiers; sortie: nouvelle liste avec valeurs doublées.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tour/higher-order-functions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval salaries = Seq(20000, 70000, 40000)\nval doubleSalary = (x: Int) => x * 2\nval newSalaries = salaries.map(doubleSalary) // List(40000, 140000, 80000)\n```\n\n----------------------------------------\n\nTITLE: Handling Type Mismatches When Deserializing JSON to a Map in Scala\nDESCRIPTION: Illustrates how uPickle throws a `upickle.core.AbortException` when attempting to deserialize a JSON string into a `Map[String, List[Int]]` if a value's type (e.g., String) does not match the expected type (List[Int]). Requires the uPickle library.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-deserialize.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval json = \"\"\"{\"name\": \"Peter\"} \"\"\"\nupickle.default.read[Map[String, List[Int]]](json)\n// throws: upickle.core.AbortException: expected sequence got string at index 9\n```\n\n----------------------------------------\n\nTITLE: Using 'if/else' Blocks for Conditional Execution in Scala\nDESCRIPTION: Illustrates the `if/else` structure for executing one block of code if a condition is true and another block if it's false. Compares Scala 2 (curly braces) and Scala 3 (indentation/optional `then`/`else`) syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_2\n\nLANGUAGE: Scala 2\nCODE:\n```\nif (x == 1) {\n  println(\"x is 1, as you can see:\")\n  println(x)\n} else {\n  println(\"x was not 1\")\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nif x == 1 then\n  println(\"x is 1, as you can see:\")\n  println(x)\nelse\n  println(\"x was not 1\")\n```\n\n----------------------------------------\n\nTITLE: Deconstructing Tuples with Pattern Matching\nDESCRIPTION: Illustrates deconstructing a tuple into variables using pattern matching, enhancing readability and convenience when handling tuple data. Used in variable assignment and matching cases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/tuples.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval (name, quantity) = ingredient\n\nprintln(name) // wyświetli Sugar\nprintln(quantity) // wyświetli 25\n```\n\n----------------------------------------\n\nTITLE: Comparing and Matching Scala 3 Enumeration Values\nDESCRIPTION: The code demonstrates comparing enum values using '==' and pattern matching 'match' to execute different code paths depending on the enum value, showcasing idiomatic Scala 3 enum usage for control flow.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\n// if/then\nif currentCrustSize == Large then\n  println(\"You get a prize!\")\n\n// match\ncurrentCrustSize match\n  case Small => println(\"small\")\n  case Medium => println(\"medium\")\n  case Large => println(\"large\")\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Covariant Immutable Box in Scala 3\nDESCRIPTION: This snippet defines and uses a covariant ImmutableBox class with Scala 3 syntax. Like the Scala 2 version, it shows that an ImmutableBox[Cat] is a subtype of ImmutableBox[Animal]. The field is a val, guaranteeing immutability. No additional dependencies or imports required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/variances.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nclass ImmutableBox[+A](val content: A)\nval catbox: ImmutableBox[Cat] = ImmutableBox[Cat](Cat(\"Felix\"))\nval animalBox: ImmutableBox[Animal] = catbox // now this compiles\n```\n\n----------------------------------------\n\nTITLE: 类型类 Showable 的使用示例（Scala 2 和 Scala 3）\nDESCRIPTION: 演示如何在程序中调用为 Person 定义的 Showable 类型类实例的 show 方法。Scala 2 显式调用 implicit 实例的 show 方法；Scala 3 在给定实例作用下，支持直接对 Person 对象调用扩展方法 show。该例体现了类型类接口的透明调用模式。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/ca-type-classes.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval person = Person(\"John\", \"Doe\")\nprintln(showablePerson.show(person))\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval person = Person(\"John\", \"Doe\")\nprintln(person.show)\n```\n\n----------------------------------------\n\nTITLE: 示例：协变容器的实例（Scala 2/3）\nDESCRIPTION: 展示不可变容器（如 List 和 Vector）定义为协变，允许用子类型的集合（如 List[Book]）代替父类型集合（List[Buyable]），增强代码的复用性。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-variance.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nclass List[+A] ...\nclass Vector[+A] ...\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Singleton Object in Scala\nDESCRIPTION: Demonstrates the basic syntax for defining a singleton object named `Blah` within a package `test`. The object contains a method `sum` that calculates the sum of integers in a list. Methods defined in singleton objects are globally accessible.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/singleton-objects.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\npackage test\n\nobject Blah {\n  def sum(l: List[Int]): Int = l.sum\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling the Scala Project with sbt - Bash\nDESCRIPTION: Demonstrates the use of the `$ sbt compile` command to build the Scala project's source code. Requires sbt to be installed and project files to be correctly set up. Input: compilation command; Output: compilation logs, culminating in 'success' or error details.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_22\n\nLANGUAGE: Bash\nCODE:\n```\n$ sbt compile\n\n[info] welcome to sbt\n[info] loading settings for project ...\n[info] loading project definition ...\n[info] loading settings for project ...\n[info] Executing in batch mode. For better performance use sbt's shell\n[success] Total time: 1 s\n\n```\n\n----------------------------------------\n\nTITLE: Computing Filtered List Lengths with For/Yield Expressions in Scala 3\nDESCRIPTION: Applies a for/yield with a guard to filter a list of strings and yield their lengths if greater than 4, using multi-line Scala 3 syntax. Requires fruits to be a List[String]. Returns a List[Int] as fruitLengths.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nval fruits = List(\"apple\", \"banana\", \"lime\", \"orange\")\n\nval fruitLengths = for\n  f <- fruits\n  if f.length > 4\nyield\n  // you can use multiple lines\n  // of code here\n  f.length\n\n// fruitLengths: List[Int] = List(5, 6, 6)\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Traits in Scala 3 Classes\nDESCRIPTION: Scala 3 version of a Dog class extending traits with concise syntax using commas. Shows how to combine behaviors in classes in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-modeling.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass Dog(name: String) extends Speaker, TailWagger, Runner:\n  def speak(): String = \"Woof!\"\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Collections with Basic 'for' Loops in Scala\nDESCRIPTION: Demonstrates a simple `for` loop iterating over a sequence (`Seq`) of integers and printing each element. Shows the generator syntax (`<-`) and the difference between Scala 2 and Scala 3 (`do` keyword).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_9\n\nLANGUAGE: Scala 2\nCODE:\n```\nval ints = Seq(1, 2, 3)\nfor (i <- ints) println(i)\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nval ints = Seq(1, 2, 3)\nfor i <- ints do println(i)\n```\n\n----------------------------------------\n\nTITLE: Defining Classes with Constructor and Methods\nDESCRIPTION: Shows class declaration with constructor parameters, methods with 'def', and the use of 'Unit' return type for procedures. Demonstrates creating class instances with 'new'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/basics.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nclass Greeter(prefix: String, suffix: String) {\n  def greet(name: String): Unit =\n    println(prefix + name + suffix)\n}\nval greeter = new Greeter(\"Hello, \", \"!\")\ngreeter.greet(\"Scala developer\") // Hello, Scala developer!\n```\n\n----------------------------------------\n\nTITLE: Adding ScalaTest dependency in sbt\nDESCRIPTION: Configures the sbt build with the ScalaTest library dependency for version 3.2.19, enabling writing and running tests using ScalaTest framework.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/tools-sbt.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies ++= Seq(\n  \"org.scalatest\" %% \"scalatest\" % \"3.2.19\" % Test\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a Singleton Object with Constants in Scala 3\nDESCRIPTION: Example of creating a singleton object with constant values in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-tools.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nobject MathConstants:\n  val PI = 3.14159\n  val E = 2.71828\n\nprintln(MathConstants.PI)   // 3.14159\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Greeting Function Returning a Function in Scala\nDESCRIPTION: Defines a Scala method 'greet' with no parameters that returns an anonymous function which takes a String argument and prints a greeting. The function type is String => Unit, and the method illustrates how to create and return this function for later invocation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-write-method-returns-function.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef greet(): String => Unit = \n  (name: String) => println(s\"Hello, $name\")\n```\n\n----------------------------------------\n\nTITLE: For loops with multiple conditional filters in Python and Scala\nDESCRIPTION: Shows combining multiple conditions with logical operators in loops to selectively print values. Inputs: integer range 1 to 10; outputs: printed even numbers less than 5. No dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_42\n\nLANGUAGE: Scala\nCODE:\n```\nfor\n  i <- 1 to 10\n  if i % 2 == 0 && i < 5\n do\n  println(i)\n```\n\n----------------------------------------\n\nTITLE: Automatically deriving ReadWriter in Scala 3 for PetOwner\nDESCRIPTION: This snippet utilizes the `derives` keyword to automatically generate a `ReadWriter[PetOwner]` instance, simplifying setup for JSON serialization in Scala 3. The compiler creates the necessary serialization logic based on the case class's fields, enabling seamless read/write operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-serialize.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport upickle.default.*\n\ncase class PetOwner(name: String, pets: List[String]) derives ReadWriter\n```\n\n----------------------------------------\n\nTITLE: Scala 2 和 Scala 3 中 Java 交互示例\nDESCRIPTION: 示范如何在 Scala 中无缝调用Java类和库，包括读取文件和转换Java集合为Scala集合，突出Scala与Java的互操作性。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-features.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport java.io.*\nval br = BufferedReader(FileReader(filename))\n// 读取文件...\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.jdk.CollectionConverters.*\nval scalaList: Seq[Integer] = JavaClass.getJavaList().asScala.toSeq\n```\n\n----------------------------------------\n\nTITLE: Match Expression With Multiple Conditions in Scala\nDESCRIPTION: Scala match expression using pattern alternatives separated by | to categorize integers as \"odd\", \"even\", or defaulting to \"too big\", showing concise multi-condition cases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_51\n\nLANGUAGE: scala\nCODE:\n```\nval numAsString = i match\n  case 1 | 3 | 5 | 7 | 9 => \"odd\"\n  case 2 | 4 | 6 | 8 | 10 => \"even\"\n  case _ => \"too big\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Graph with Path-Dependent Inner Node Class in Scala\nDESCRIPTION: Demonstrates defining a `Graph` class with an inner `Node` class in both Scala 2 and Scala 3 syntax. In Scala, instances of the inner `Node` class are bound to the specific `Graph` instance they were created from (path-dependent types). The `Node` class maintains a list of connected nodes, and the `Graph` class manages a list of its nodes and provides a method to create new nodes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/inner-classes.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass Graph {\n  class Node {\n    var connectedNodes: List[Node] = Nil\n    def connectTo(node: Node): Unit = {\n      if (!connectedNodes.exists(node.equals)) {\n        connectedNodes = node :: connectedNodes\n      }\n    }\n  }\n  var nodes: List[Node] = Nil\n  def newNode: Node = {\n    val res = new Node\n    nodes = res :: nodes\n    res\n  }\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass Graph:\n  class Node:\n    var connectedNodes: List[Node] = Nil\n    def connectTo(node: Node): Unit =\n      if !connectedNodes.exists(node.equals) then\n        connectedNodes = node :: connectedNodes\n\n  var nodes: List[Node] = Nil\n  def newNode: Node =\n    val res = Node()\n    nodes = res :: nodes\n    res\n```\n\n----------------------------------------\n\nTITLE: Applying onComplete Callback to File Reading Future in Scala\nDESCRIPTION: Shows how to attach an `onComplete` callback to the file reading `Future` example. The callback handles both the success case (printing the found index) and the failure case (printing an error message) based on the `Try[Int]` result.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/futures.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval firstOccurence: Future[Int] = Future {\n  val source = scala.io.Source.fromFile(\"myText.txt\")\n  source.toSeq.indexOfSlice(\"myKeyword\")\n}\n\nfirstOccurence onComplete {\n  case Success(idx) => println(\"キーワードの初出位置: \" + idx)\n  case Failure(t) => println(\"処理失敗：\" + t.getMessage)\n}\n```\n\n----------------------------------------\n\nTITLE: Mixing Multiple Traits in Scala\nDESCRIPTION: Illustrates extending a Scala class from multiple traits by chaining 'with' keywords. This allows combining behavior across several modules that implement partial functionality. The snippet includes both pure traits and a class inheriting a superclass plus multiple traits, showing the flexibility of traits in Scala's type system and composition model.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/cheatsheets/index.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ntrait T1; trait T2\nclass C extends T1 with T2\nclass C extends D with T1 with T2\n```\n\n----------------------------------------\n\nTITLE: Uploading multiple files using multipart requests with sttp in Scala 3\nDESCRIPTION: This snippet demonstrates the multipart file upload technique in Scala 3 using sttp. It shows Scala 3 import syntax, defines multiple Java Paths from OS-Lib paths, creates a multipart body with multiple files using multipartFile, sends an HTTP POST request with multipart content, and manages the server response. Required libraries are sttp client4 and OS-Lib. Inputs are multiple file paths; output is the HTTP response status and message.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/http-client-upload-file.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport sttp.client4.quick.*\n\nval file1 = (os.pwd / \"avatar1.png\").toNIO\nval file2 = (os.pwd / \"avatar2.png\").toNIO\nval response = quickRequest\n  .post(uri\"https://example.com/\")\n  .multipartBody(\n    multipartFile(\"avatar1.png\", file1),\n    multipartFile(\"avatar2.png\", file2)\n  )\n  .send()\n```\n\n----------------------------------------\n\nTITLE: Defining a Class with Default Parameter Values in Scala 3\nDESCRIPTION: Example of defining a Scala 3 class with default values for constructor parameters, allowing flexible instantiation options.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-tools.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass Socket(val timeout: Int = 5_000, val linger: Int = 5_000):\n  override def toString = s\"timeout: $timeout, linger: $linger\"\n```\n\n----------------------------------------\n\nTITLE: Implementing extension methods for Circle class in Scala\nDESCRIPTION: This snippet shows how to extend the functionality of a class you can't modify by adding extension methods for calculating circle properties like circumference, diameter, and area.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/methods-most.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimplicit class CircleOps(c: Circle) {\n  def circumference: Double = c.radius * math.Pi * 2\n  def diameter: Double = c.radius * 2\n  def area: Double = math.Pi * c.radius * c.radius\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nextension (c: Circle)\n  def circumference: Double = c.radius * math.Pi * 2\n  def diameter: Double = c.radius * 2\n  def area: Double = math.Pi * c.radius * c.radius\n```\n\n----------------------------------------\n\nTITLE: Explicit Type Annotation for Values in Scala\nDESCRIPTION: Demonstrates how to optionally annotate val declarations with explicit types for clarity or type safety. Input expression returns an Int that is explicitly typed, an important pattern for larger codebases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval x: Int = 1 + 1\n```\n\n----------------------------------------\n\nTITLE: Assigning a Subtype to a Supertype in Scala\nDESCRIPTION: This snippet assigns an instance of the Cat class to a variable of type Animal, illustrating standard subtyping. No dependencies beyond the earlier type hierarchy. The example demonstrates that a Cat instance (with name \"Felix\") can be treated as an Animal due to class inheritance. There are no special parameters or return values; the variable myAnimal is typed as Animal but holds a Cat.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/variances.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval myAnimal: Animal = Cat(\"Felix\")\n```\n\n----------------------------------------\n\nTITLE: Matching Integer Values in Scala - Scala\nDESCRIPTION: Defines a Scala application object with a method that matches an integer input against specific cases (1, 2) and a default case. It outputs a string representation based on the matched case, demonstrating basic pattern matching on integer values. Requires standard Scala environment. The function 'matchTest' takes an Int as input and returns a corresponding String. The method illustrates the use of the match keyword and case statements for integer values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/pattern-matching.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject MatchTest1 extends App {\n  def matchTest(x: Int): String = x match {\n    case 1 => \"um\"\n    case 2 => \"dois\"\n    case _ => \"muitos\"\n  }\n  println(matchTest(3))\n}\n```\n\n----------------------------------------\n\nTITLE: Launching Multiple Blocking Futures Using the Global ExecutionContext in Scala 2 and 3\nDESCRIPTION: Demonstrates spawning a large number of futures that each execute a long-lasting blocking operation (here simulated with Thread.sleep) within the global ExecutionContext. The blocking call is wrapped inside scala.concurrent.blocking to notify the ForkJoinPool. This snippet cautions that the global thread pool is not optimized for many long blocking calls and may create excessive threads. It serves as an example of the upper limits and risks when using the global ExecutionContext for blocking tasks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimplicit val ec = ExecutionContext.global\n\nfor (i <- 1 to 32000) {\n  Future {\n    blocking {\n      Thread.sleep(999999)\n    }\n  }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ngiven ExecutionContext = ExecutionContext.global\n\nfor i <- 1 to 32000 do\n  Future {\n    blocking {\n      Thread.sleep(999999)\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining Methods with Inferred Return Types in Scala 2 and 3\nDESCRIPTION: Defines a method without an explicit return type. The compiler infers the return type from the method body (an Int in this case). Dependencies: none. Input is an integer parameter, output is the square of the integer as an Int.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/type-inference.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef squareOf(x: Int) = x * x\n```\n\n----------------------------------------\n\nTITLE: Defining Functions and Methods in Scala\nDESCRIPTION: Demonstrates how to define both single-line and multi-line functions in Scala, showing optional type annotations and the difference between methods and functions in Scala terminology.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\n// technically this is a method, not a function\ndef add(a: Int, b: Int) = a + b\nadd(2, 2)  // 4\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef addAndDouble(a: Int, b: Int): Int =\n  // imagine this requires\n  // multiple lines\n  (a + b) * 2\n```\n\n----------------------------------------\n\nTITLE: Failed Execution of For-Comprehension with Options (Scala REPL)\nDESCRIPTION: Shows the expected output (`None`) in the Scala REPL when the `for`/`yield` comprehension is executed after changing one of the input strings (`stringA`, `stringB`, or `stringC`) to a value that cannot be converted to an integer by `toInt`. This demonstrates the short-circuiting behavior of for-comprehensions on `Option`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/no-null-values.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ny: Option[Int] = None\n```\n\n----------------------------------------\n\nTITLE: Successful Execution of For-Comprehension with Options (Scala REPL)\nDESCRIPTION: Demonstrates running the `for`/`yield` comprehension in the Scala REPL with valid string inputs previously defined. The result `y` is `Some(6)`, indicating all `toInt` conversions succeeded and the resulting integer values were summed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/no-null-values.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nscala> val y = for {\n     |     a <- toInt(stringA)\n     |     b <- toInt(stringB)\n     |     c <- toInt(stringC)\n     | } yield a + b + c\ny: Option[Int] = Some(6)\n```\n\n----------------------------------------\n\nTITLE: Yielding Values with For Expressions in Scala 2 (Simple Form)\nDESCRIPTION: Creates a new list, doubles, by mapping each value in ints to i * 2 using a for/yield expression. ints must be defined as a List[Int]. The output is assigned to doubles as a new List[Int].\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nscala> val doubles = for (i <- ints) yield i * 2\nval doubles: List[Int] = List(2, 4, 6, 8, 10)\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Hybrid Enumeration/ADT in Scala\nDESCRIPTION: Demonstrates combining simple enum cases (`Red`, `Green`, `Blue`) with a parameterized case (`Mix`) within the same Scala 3 `enum` definition, creating a hybrid structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-adts-gadts.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nenum Color(val rgb: Int):\n  case Red   extends Color(0xFF0000)\n  case Green extends Color(0x00FF00)\n  case Blue  extends Color(0x0000FF)\n  case Mix(mix: Int) extends Color(mix)\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with a Default Parameter in Scala\nDESCRIPTION: Defines a Scala function 'log' with a message parameter and a level parameter that has a default value 'INFO'. Demonstrates calling the function with and without specifying the level argument. The default enables calling log with only the message, simplifying common cases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/default-parameter-values.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef log(message: String, level: String = \"INFO\") = println(s\"$level: $message\")\n\nlog(\"System starting\")  // outputs \"INFO: System starting\"\nlog(\"User not found\", \"WARNING\")  // outputs \"WARNING: User not found\"\n```\n\n----------------------------------------\n\nTITLE: Type Inference Examples in Scala REPL\nDESCRIPTION: Demonstrates Scala's type inference capability in the REPL, showing how the compiler automatically determines appropriate types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-vars-data-types.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nscala> val x = 1\nval x: Int = 1\n\nscala> val s = \"a string\"\nval s: String = a string\n\nscala> val nums = List(1, 2, 3)\nval nums: List[Int] = List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Prepending Elements to a Vector - Scala\nDESCRIPTION: Demonstrates how to prepend elements to a Vector using +: for a single element and ++: for multiple elements. The original Vector is not modified; each operation returns a new Vector reflecting the changes. Input: source Vector and element(s) to prepend; Output: newly created Vector. Only the Scala standard library is needed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/vector-class.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval b = 0 +: a\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval b = Vector(-1, 0) ++: a\n```\n\n----------------------------------------\n\nTITLE: Inspecting Results of Filter Operations in Scala REPL\nDESCRIPTION: Displays example outputs of List.filter operations with various predicates, as would appear in the Scala REPL. Input: List[Int] named ints. Outputs: filtered lists containing elements >5, <5, or even. Shows variable type and resulting value for each filter case.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/anonymous-functions.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nscala> val x = ints.filter(_ > 5)\nx: List[Int] = List(6, 7, 8, 9)\n\nscala> val x = ints.filter(_ < 5)\nx: List[Int] = List(1, 2, 3, 4)\n\nscala> val x = ints.filter(_ % 2 == 0)\nx: List[Int] = List(2, 4, 6, 8)\n```\n\n----------------------------------------\n\nTITLE: Mixed enum variants with parameterized and regular cases in Scala 3\nDESCRIPTION: This snippet combines simple enumeration cases with a parameterized variant 'Mix' that takes an 'Int'. It shows how enums can serve as flexible unions of different case forms, supporting both static values and variants with data.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-adts-gadts.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nenum Color(val rgb: Int):\n  case Red   extends Color(0xFF0000)\n  case Green extends Color(0x00FF00)\n  case Blue  extends Color(0x0000FF)\n  case Mix(mix: Int) extends Color(mix)\n```\n\n----------------------------------------\n\nTITLE: Class Extending Composed Traits in Scala 3\nDESCRIPTION: This Scala 3 implementation defines the MyService class, which takes a string parameter name and extends ComposedService and Showable. It implements the show method by interpolating name with the sayHello result. No dependencies are needed beyond the defined traits.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nclass MyService(name: String) extends ComposedService, Showable:\n  def show = s\"$name says $sayHello\"\n```\n\n----------------------------------------\n\nTITLE: Recursive Directory Traversal with os.walk and Stream in Scala\nDESCRIPTION: This explanation indicates how to recursively traverse an entire directory subtree using os.walk, which lists all nested entries, or os.walk.stream for processing results incrementally without loading everything into memory.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/os-read-directory.md#_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Traversing Map elements in Scala using foreach with match\nDESCRIPTION: Demonstrates traversing a Map by applying the foreach method with a partial function using a match expression to bind each key and value to variables. This approach offers a readable and functional style to handle Map entries. Input is a Map of movie ratings; output consists of printed key-value string representations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/map-class.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nratings.foreach {\n    case(movie, rating) => println(s\"key: $movie, value: $rating\")\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Subtypes in Generic Classes in Scala 3\nDESCRIPTION: Example demonstrating how generic classes handle subtypes in Scala 3. Shows a class hierarchy and how a Stack parameterized with a supertype can accept instances of subtypes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/generic-classes.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass Fruit\nclass Apple extends Fruit\nclass Banana extends Fruit\n\nval stack = Stack[Fruit]\nval apple = Apple()\nval banana = Banana()\n\nstack.push(apple)\nstack.push(banana)\n```\n\n----------------------------------------\n\nTITLE: Declaring a Conventionally Named Top-Level Package in Scala\nDESCRIPTION: Demonstrates the recommended convention for naming packages in institutional projects, using reverse domain notation. The code declares a package \"com.google.selfdrivingcar.camera\" and defines a class \"Lens\" in it. No parameters or special dependencies are required. The convention supports organization-wide naming and prevents namespace conflicts. The directory structure typically mirrors the package declaration but is not enforced by Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/packages-and-imports.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\npackage com.google.selfdrivingcar.camera\n\nclass Lens\n```\n\n----------------------------------------\n\nTITLE: Factory Method in Companion Object for Creating Instances\nDESCRIPTION: Provides an example of a companion object with a factory method 'fromString' that parses an email string to produce an 'Email' instance wrapped in 'Option'. Demonstrates encapsulating creation logic and handling parsing errors gracefully.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/singleton-objects.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass Email(val username: String, val domainName: String)\n\nobject Email {\n  def fromString(emailString: String): Option[Email] = {\n    emailString.split('@') match {\n      case Array(a, b) => Some(new Email(a, b))\n      case _ => None\n    }\n  }\n}\n\nval scalaCenterEmail = Email.fromString(\"scala.center@epfl.ch\")\nscalaCenterEmail match {\n  case Some(email) => println(\n    s\"\"\"Registered an email\n       |Username: ${email.username}\n       |Domain name: ${email.domainName}\n     \"\"\".stripMargin)\n  case None => println(\"Error: could not parse email\")\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass Email(val username: String, val domainName: String)\n\nobject Email:\n  def fromString(emailString: String): Option[Email] =\n    emailString.split('@') match\n      case Array(a, b) => Some(Email(a, b))\n      case _ => None\n\nval scalaCenterEmail = Email.fromString(\"scala.center@epfl.ch\")\nscalaCenterEmail match\n  case Some(email) => println(\n    s\"\"\"Registered an email\n       |Username: ${email.username}\n       |Domain name: ${email.domainName}\n     \"\"\".stripMargin)\n  case None => println(\"Error: could not parse email\")\n```\n\n----------------------------------------\n\nTITLE: Capitalizing Strings with For/Yield Expressions in Scala 2\nDESCRIPTION: Maps over a list of lowercase names, assigning capNames to the new List resulting from capitalizing each element. Requires names as a List[String]. The output is a transformed list with capitalized names.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nval names = List(\"chris\", \"ed\", \"maurice\")\nval capNames = for (name <- names) yield name.capitalize\n\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Pattern Guards\nDESCRIPTION: Using boolean expressions as pattern guards to make pattern matching cases more specific, filtering matches based on additional conditions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/pattern-matching.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef showImportantNotification(notification: Notification, importantPeopleInfo: Seq[String]): String = {\n  notification match {\n    case Email(sender, _, _) if importantPeopleInfo.contains(sender) =>\n      \"You got an email from special someone!\"\n    case SMS(number, _) if importantPeopleInfo.contains(number) =>\n      \"You got an SMS from special someone!\"\n    case other =>\n      showNotification(other) // nothing special, delegate to our original showNotification function\n  }\n}\n\nval importantPeopleInfo = Seq(\"867-5309\", \"jenny@gmail.com\")\n\nval someSms = SMS(\"123-4567\", \"Are you there?\")\nval someVoiceRecording = VoiceRecording(\"Tom\", \"voicerecording.org/id/123\")\nval importantEmail = Email(\"jenny@gmail.com\", \"Drinks tonight?\", \"I'm free after 5!\")\nval importantSms = SMS(\"867-5309\", \"I'm here! Where are you?\")\n\nprintln(showImportantNotification(someSms, importantPeopleInfo)) // prints You got an SMS from 123-4567! Message: Are you there?\nprintln(showImportantNotification(someVoiceRecording, importantPeopleInfo)) // prints You received a Voice Recording from Tom! Click the link to hear it: voicerecording.org/id/123\nprintln(showImportantNotification(importantEmail, importantPeopleInfo)) // prints You got an email from special someone!\n\nprintln(showImportantNotification(importantSms, importantPeopleInfo)) // prints You got an SMS from special someone!\n```\n\n----------------------------------------\n\nTITLE: Iterating over lists in Python and Scala\nDESCRIPTION: Demonstrates iteration over list elements. Python uses the for-in loop with colon syntax. Scala shows two idiomatic for loops: preferred for comprehension style using 'for i <- ints do println(i)' and simpler 'for (i <- ints) println(i)'. Explains stylistic options in both languages for looping.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_55\n\nLANGUAGE: python\nCODE:\n```\nfor i in ints: print(i)\n\nfor i in ints:\n    print(i)\n```\n\nLANGUAGE: scala\nCODE:\n```\n// preferred\nfor i <- ints do println(i)\n\n// also available\nfor (i <- ints) println(i)\n```\n\n----------------------------------------\n\nTITLE: Applying Multiple Transformations on a View and Forcing Evaluation (Scala 2 and 3)\nDESCRIPTION: Shows how to chain transformations on a view (e.g., map operations), resulting in a lazily evaluated collection. Calling `to(Vector)` triggers execution, applying all recorded transformations efficiently without intermediate structures.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/views.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval res13 = vv.map(_ + 1)\nval res14 = res13.map(_ * 2)\nval result = res14.to(Vector)\n```\n\n----------------------------------------\n\nTITLE: Progressive Simplification of Anonymous Functions\nDESCRIPTION: Shows how to gradually simplify an anonymous function from its most explicit form to more concise versions using Scala's type inference.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-anonymous-functions.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval doubledInts = ints.map((i: Int) => i * 2)\n```\n\n----------------------------------------\n\nTITLE: Handling Futures with Different Execution Contexts in Scala\nDESCRIPTION: This snippet demonstrates executing Futures with various execution contexts, including global, custom, and reporter-enabled contexts. It shows how the context configuration affects exception reporting and Future completion status.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_34\n\nLANGUAGE: Scala\nCODE:\n```\ncheck(testCrashes())     // did not complete\n// a Future that completes with an operational exception that is wrapped\ncheck(testInterrupted()) // completed Failure(java.util.concurrent.ExecutionException: Boxed Exception)\n//   caused by java.lang.InterruptedException: test\n// a Future that completes due to a failed assert, which is bad for the app,\n// but is handled the same as interruption\ncheck(testError())       // completed Failure(java.util.concurrent.ExecutionException: Boxed Exception)\n//   caused by java.lang.AssertionError: test\n\nlocally:\n// same as `global`, but adds a custom reporter that will handle uncaught\n// exceptions and errors reported to the context\ngiven ExecutionContext = ExecutionContext.fromExecutor(null, reporter)\ncheck(testCrashes())     // reported java.lang.NoSuchMethodError: test\n// did not complete\n\nlocally:\n// does not handle uncaught exceptions; the executor would have to be\n// configured separately\nval executor = ForkJoinPool.commonPool()\ngiven ExecutionContext = ExecutionContext.fromExecutor(executor, reporter)\n// the reporter is not invoked and the Future does not complete\ncheck(testCrashes())     // did not complete\n\nlocally:\n// sample minimal configuration for a context and underlying pool that\n// use the reporter\nval handler: Thread.UncaughtExceptionHandler =\n  (_: Thread, t: Throwable) => reporter(t)\nval executor = new ForkJoinPool(\n  Runtime.getRuntime.availableProcessors,\n  ForkJoinPool.defaultForkJoinWorkerThreadFactory, // threads use the pool's handler\n  handler,\n  /*asyncMode=*/ false\n)\ngiven ExecutionContext = ExecutionContext.fromExecutor(executor, reporter)\ncheck(testCrashes())     // reported java.lang.NoSuchMethodError: test\n// did not complete\n```\n\n----------------------------------------\n\nTITLE: Function Definition in Scala\nDESCRIPTION: Demonstrates various ways to define functions in Scala, including proper syntax, type annotations, and common pitfalls.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/cheatsheets/index.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: Int) = { x * x }\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: Int)   { x * x }\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: Any) = println(x)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x) = println(x)\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype R = Double\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: R)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: => R)\n```\n\n----------------------------------------\n\nTITLE: Attempting Invalid Instantiation with Upper Type Bound in Scala\nDESCRIPTION: Demonstrates an attempt to instantiate the PetContainer with the type parameter Lion. This results in a compile-time error because Lion is not a subtype of Pet, violating the P <: Pet upper type bound defined by the PetContainer class. This highlights how type bounds enforce type safety.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/upper-type-bounds.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// this would not compile\nval lionContainer = new PetContainer[Lion](new Lion)\n```\n\nLANGUAGE: scala\nCODE:\n```\n// this would not compile\nval lionContainer = PetContainer[Lion](Lion())\n```\n\n----------------------------------------\n\nTITLE: Method Returning a Value Using if Expression in Scala\nDESCRIPTION: Defines a Scala method min returning the smaller of two integers using a single-line if-else expression without braces or parentheses, showcasing expression-based syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_34\n\nLANGUAGE: scala\nCODE:\n```\ndef min(a: Int, b: Int): Int =\n  if a < b then a else b\n```\n\n----------------------------------------\n\nTITLE: Defining a multi-method type class 'HasLegs' in Scala 2\nDESCRIPTION: Creates a trait 'HasLegs' parameterized by 'A' with methods 'walk' and 'run', demonstrating multi-method type classes with multiple behaviors for a type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-type-classes.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ntrait HasLegs[A] {\n  def walk(a: A): Unit\n  def run(a: A): Unit\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a function with pattern matching returning String - Scala\nDESCRIPTION: Defines a function matchTest that takes an Int and uses pattern matching to return a String representing the numeric word if the input is 1 or 2, or \"other\" for all other values. This example highlights that match expressions return a value, allowing concise function implementations. Dependencies include standard Scala syntax and types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/pattern-matching.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef matchTest(x: Int): String = x match {\n  case 1 => \"one\"\n  case 2 => \"two\"\n  case _ => \"other\"\n}\nmatchTest(3)  // other\nmatchTest(1)  // one\n```\n\n----------------------------------------\n\nTITLE: Implementing getStackTraceAsString in Scala 3\nDESCRIPTION: Provides a practical example of a multiline method in Scala 3 (using indentation syntax) that takes a `Throwable`, uses `java.io.StringWriter` and `java.io.PrintWriter` (with optional `new` keyword) to capture the stack trace, and returns it as a String. Requires importing Java IO classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport java.io.{PrintWriter, StringWriter}\n\ndef getStackTraceAsString(t: Throwable): String =\n  val sw = StringWriter()\n  t.printStackTrace(PrintWriter(sw))\n  sw.toString\n```\n\n----------------------------------------\n\nTITLE: Capturing and Asserting on Thrown Exceptions in MUnit (Scala 2 and 3)\nDESCRIPTION: Demonstrates capturing the thrown exception from an intercept assertion for further validation. The snippet shows using intercept to execute a code block expected to throw NoSuchFileException and storing the returned exception in a val. It then asserts that the exception message contains the expected substring, verifying both the exception type and message.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-exceptions.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval exception = intercept[NoSuchFileException](os.read(missingFile))\nassert(clue(exception.getMessage).contains(\"missing.txt\"))\n```\n\n----------------------------------------\n\nTITLE: Defining an Object with Utility Methods in Scala\nDESCRIPTION: Creating a StringUtils object containing utility methods for string manipulation like truncate, containsWhitespace, and isNullOrEmpty.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject StringUtils {\n  def truncate(s: String, length: Int): String = s.take(length)\n  def containsWhitespace(s: String): Boolean = s.matches(\".*\\\\s.*\")\n  def isNullOrEmpty(s: String): Boolean = s == null || s.trim.isEmpty\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nobject StringUtils:\n  def truncate(s: String, length: Int): String = s.take(length)\n  def containsWhitespace(s: String): Boolean = s.matches(\".*\\\\s.*\")\n  def isNullOrEmpty(s: String): Boolean = s == null || s.trim.isEmpty\n```\n\n----------------------------------------\n\nTITLE: Renaming multiple members during import in Scala 2 and 3\nDESCRIPTION: Shows how to import and rename multiple Java utility classes to prevent naming collisions with Scala classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/packaging-imports.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport java.util.{Date => JDate, HashMap => JHashMap, _}  // Scala 2\nimport java.util.{Date as JDate, HashMap as JHashMap, *}  // Scala 3\n```\n\n----------------------------------------\n\nTITLE: Explicit Variable Declaration in Scala\nDESCRIPTION: Illustrates how to explicitly declare variable types in Scala using type annotations. These snippets require a Scala environment to compile and run, and they demonstrate explicit type assignment to variables for clarity or when specific data types are necessary.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/type-is-optional.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval count: Int = 1\nval name: String = \"Alvin\"\n```\n\n----------------------------------------\n\nTITLE: Handling failures with Promise in Scala\nDESCRIPTION: Shows how to handle computation failures by completing a Promise with either a success or a failure, which affects the state of the associated Future.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\nval p = Promise[T]()\nval f = p.future\n\nval producer = Future {\n  val r = someComputation\n  if (isInvalid(r))\n    p.failure(new IllegalStateException)\n  else {\n    val q = doSomeMoreComputation(r)\n    p.success(q)\n  }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval p = Promise[T]()\nval f = p.future\n\nval producer = Future {\n  val r = someComputation\n  if isInvalid(r) then\n    p.failure(new IllegalStateException)\n  else\n    val q = doSomeMoreComputation(r)\n    p.success(q)\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping and Summing a List with Functional Programming - Scala\nDESCRIPTION: Illustrates idiomatic functional collection operations in Scala. The snippet maps over a list of integers, incrementing each element by one and then computing the sum. It is valid in both Scala 2 and Scala 3 and relies only on the core Scala collections API. There are no required parameters—'List(1, 2, 3)' is hardcoded. Expected output is 9.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/add-guides.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nList(1, 2, 3).map(x => x + 1).sum\n```\n\n----------------------------------------\n\nTITLE: Asynchronous file reading with Future\nDESCRIPTION: Shows how to perform a blocking I/O operation asynchronously using Future, such as reading a file to find the first occurrence of a keyword without blocking the main thread.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval firstOccurrence: Future[Int] = Future {\n  val source = scala.io.Source.fromFile(\"myText.txt\")\n  source.toSeq.indexOfSlice(\"myKeyword\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Higher-Order Function to Execute Another Function Multiple Times in Scala REPL\nDESCRIPTION: Example Scala REPL commands to invoke executeNTimes, passing the helloWorld function and the integer 3, resulting in 'Hello, world' being printed three times. This snippet shows practical usage and expected output of a method accepting a function and running it multiple times. Dependencies are the previously defined methods and Scala REPL environment. Input is the function and repetition count, output is repeated console output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-hofs.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nscala> executeNTimes(helloWorld, 3)\nHello, world\nHello, world\nHello, world\n```\n\n----------------------------------------\n\nTITLE: Example of File Utility Object in Scala\nDESCRIPTION: Defines a singleton object `FileUtils` containing methods for file operations such as reading text files and copying files, all returning `Try` types for handling potential errors. Dependencies include `File`, `String`, and `Try`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/case-objects.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject FileUtils {\n    def readTextFileAsString(filename: String): Try[String] = ...\n    def copyFile(srcFile: File, destFile: File): Try[Boolean] = ...\n    def readFileToByteArray(file: File): Try[Array[Byte]] = ...\n    def readFileToString(file: File): Try[String] = ...\n    def readFileToString(file: File, encoding: String): Try[String] = ...\n    def readLines(file: File, encoding: String): Try[List[String]] = ...\n}\n```\n\n----------------------------------------\n\nTITLE: ジェネリクスクラスの定義例\nDESCRIPTION: 型パラメータ`T`を持つ汎用リファレンスクラス`Reference[T]`。`set`と`get`メソッドを通じて、さまざまな型の値を格納・取得可能。これにより、異なる型のコンテナを一つのクラスで表現できることを示し、型安全なコードの例を示す。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tutorials/scala-for-java-programmers.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nclass Reference[T] {\n  private var contents: T = _\n  def set(value: T) { contents = value }\n  def get: T = contents\n}\n```\n\n----------------------------------------\n\nTITLE: 实例化和使用Dog和Cat类(Scala 3)\nDESCRIPTION: 演示如何在Scala 3中实例化和使用Dog和Cat类的对象。这个例子创建了Dog和Cat的实例，并调用它们的方法来展示不同的行为实现。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-modeling.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval d = Dog(\"Rover\")\nprintln(d.speak())      // prints \"Woof!\"\n\nval c = Cat(\"Morris\")\nprintln(c.speak())      // \"Meow\"\nc.startRunning()        // \"Yeah ... I don't run\"\nc.stopRunning()         // \"No need to stop\"\n```\n\n----------------------------------------\n\nTITLE: Handling Both Success and Failure Cases with onComplete for a Future in Scala\nDESCRIPTION: This snippet shows the standard way to process the result of a Future asynchronously via the onComplete method. It provides a partial function handling both Success and Failure outcomes. Requires Futures, an ExecutionContext, and Scala's Try classes. Inputs are a Future and the callback handler; output is side-effecting code (printing the value or the exception trace).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/futures.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\na.onComplete {\n    case Success(value) => println(s\"Got the callback, value = $value\")\n    case Failure(e) => e.printStackTrace\n}\n```\n\n----------------------------------------\n\nTITLE: Using the 'map' Method on Different Collection Types\nDESCRIPTION: This example demonstrates how the 'map' method behaves differently depending on the collection type, returning a new collection of the same type as the receiver, showcasing the 'uniform return type principle'. It produces a 'List' from a 'List' and a 'Set' from a 'Set'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/overview.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nscala> List(1, 2, 3) map (_ + 1)\nres0: List[Int] = List(2, 3, 4)\nscala> Set(1, 2, 3) map (_ * 2)\nres0: Set[Int] = Set(2, 4, 6)\n```\n\n----------------------------------------\n\nTITLE: Creating Specific Collection Implementations in Scala\nDESCRIPTION: Examples of creating specific collection implementations in Scala using the same unified syntax pattern as the abstract collection types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/overview.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nList(1, 2, 3)\nHashMap(\"x\" -> 24, \"y\" -> 25, \"z\" -> 26)\n```\n\n----------------------------------------\n\nTITLE: For Comprehension without Yield in Scala\nDESCRIPTION: Demonstrates a for comprehension without the yield statement, which performs side effects and returns Unit. This example shows how to use for loops purely for their side effects rather than for generating a new collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/for-comprehensions.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef foo(n: Int, v: Int) =\n   for (i <- 0 until n;\n        j <- 0 until n if i + j == v)\n   println(s\"($i, $j)\")\n\nfoo(10, 10)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef foo(n: Int, v: Int) =\n   for i <- 0 until n\n       j <- 0 until n if i + j == v\n   do println(s\"($i, $j)\")\n\nfoo(10, 10)\n```\n\n----------------------------------------\n\nTITLE: Creating Generic Arrays Using Implicit ClassTag Parameter (Signature)\nDESCRIPTION: Shows the signature for a correctly defined generic function that creates an Array[T]. It includes an implicit parameter 'm: ClassTag[T]', which provides the necessary runtime type information to the compiler for array creation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/arrays.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef evenElems[T](xs: Vector[T])(implicit m: ClassTag[T]): Array[T] = ...\n```\n\n----------------------------------------\n\nTITLE: Handling Unchecked Warnings with runtimeCheck in Scala\nDESCRIPTION: This snippet demonstrates using `xs.runtimeChecked` in a pattern match. It shows that a type test like `::[Int]` on a `List[Any]` still produces an unchecked warning because the type argument `[Int]` cannot be verified at runtime. The match successfully extracts the head of the list if the runtime check passes, despite the warning.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/replace-nonsensical-unchecked-annotation.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nscala> xs.runtimeChecked match {\n     |   case is: ::[Int] => is.head\n     | }\n1 warning found\n-- Unchecked Warning: ----------------------------------------------------------\n2 |  case is: ::[Int] => is.head\n  |       ^\n  |the type test for ::[Int] cannot be checked at runtime because its type arguments can't be determined from List[Any]\nval res13: Int = 1\n```\n\n----------------------------------------\n\nTITLE: Using dropWhile to Skip Elements in a Scala Iterator\nDESCRIPTION: This snippet demonstrates using dropWhile to skip initial elements of an iterator based on a predicate, then access the rest. Here, it finds the first word with at least two characters. Dependencies: Scala collections. Input: iterator of strings. Output: an iterator positioned at the first element that does not match the predicate, demonstrated by calling next. Limitation: the original iterator’s state is mutated along with the result iterator; both point to the new position and should not be reused as the same sequence.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/iterators.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval it = Iterator(\"a\", \"number\", \"of\", \"words\")\nit dropWhile (_.length < 2)\nres4.next()\n```\n\n----------------------------------------\n\nTITLE: Defining map Operation on List and Vector Traits in Scala 3\nDESCRIPTION: Here, the map operation for List and Vector is implemented using Scala 3's concise syntax. Each trait supports the map function, parameterized by a transformation function f from A to B, and returns an appropriately typed collection. This highlights parameterization necessary for code generalization in Scala's collections framework.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntrait List[A]:\n  def map[B](f: A => B): List[B]\n\ntrait Vector[A]:\n  def map[B](f: A => B): Vector[B]\n```\n\n----------------------------------------\n\nTITLE: Marking a Snippet Expected to Fail Compilation\nDESCRIPTION: This Scala snippet demonstrates how to mark a code block that is intentionally designed to fail compilation. The `sc:fail` flag indicates that the snippet compiler should expect a compilation error for the enclosed code (attempting to call `toMap` on a `List[Int]`). This is useful for documenting incorrect usage or expected compile-time errors.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/snippet-compiler.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n```scala sc:fail\nList(1,2,3).toMap\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Toolkit Dependency with Scala CLI - Scala\nDESCRIPTION: This code snippet shows how to require the entire Scala toolkit, including sttp, in a Scala CLI project. No additional configuration is necessary; the latest toolkit version will be included. The directive is added as a special comment at the top of the Scala source file.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-sttp.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n//> using toolkit latest\n```\n\n----------------------------------------\n\nTITLE: Showing Invalid Argument Type Error Bash\nDESCRIPTION: Illustrates the error message when a command line argument string cannot be converted to the expected parameter type for a `@main` method using the implicit `FromString` instance. The `scala run` command reports a `ParseError` with details.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-main-methods.md#_snippet_5\n\nLANGUAGE: Bash\nCODE:\n```\n$ scala run happyBirthday.scala -- sixty Fred\nIllegal command line: java.lang.NumberFormatException: For input string: \"sixty\"\n```\n\n----------------------------------------\n\nTITLE: Configuring allowed equality comparisons with CanEqual\nDESCRIPTION: Shows how to define which class comparisons are allowed by providing given instances of CanEqual, along with example usage.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-multiversal-equality.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n// [3] create type class instances to define the allowed comparisons.\n//     allow `PrintedBook == PrintedBook`\n//     allow `AudioBook == AudioBook`\ngiven CanEqual[PrintedBook, PrintedBook] = CanEqual.derived\ngiven CanEqual[AudioBook, AudioBook] = CanEqual.derived\n\n// [4a] comparing two printed books works as desired\nval p1 = PrintedBook(\"1984\", \"George Orwell\", 1961, 328)\nval p2 = PrintedBook(\"1984\", \"George Orwell\", 1961, 328)\nprintln(p1 == p2)         // true\n\n// [4b] you can't compare a printed book and an audiobook\nval pBook = PrintedBook(\"1984\", \"George Orwell\", 1961, 328)\nval aBook = AudioBook(\"1984\", \"George Orwell\", 2006, 682)\nprintln(pBook == aBook)   // compiler error\n```\n\n----------------------------------------\n\nTITLE: Defining Expression Trees with Scala Case Classes\nDESCRIPTION: Defines an abstract base class `Tree` and three case classes `Sum`, `Var`, and `Const` to represent arithmetic expressions as trees. `Sum` nodes represent addition with left and right subtrees, `Var` nodes represent variables identified by a string name, and `Const` nodes hold integer constants. Case classes automatically provide useful features like pattern matching support, getters, and sensible default implementations of `equals`, `hashCode`, and `toString`. This structure models arithmetic expressions naturally as tree data structures.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_it/tutorials/scala-for-java-programmers.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Tree\ncase class Sum(l: Tree, r: Tree) extends Tree\ncase class Var(n: String) extends Tree\ncase class Const(v: Int) extends Tree\n```\n\n----------------------------------------\n\nTITLE: Calling Methods Using Default Parameters in Scala (2 & 3)\nDESCRIPTION: Demonstrates various ways to call the `makeConnection` method, which has default parameters. Shows calling with no arguments (uses all defaults), one argument (overrides first default), and two arguments (overrides both defaults).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nmakeConnection()                 // timeout = 5000, protocol = http\nmakeConnection(2_000)            // timeout = 2000, protocol = http\nmakeConnection(3_000, \"https\")   // timeout = 3000, protocol = https\n```\n\n----------------------------------------\n\nTITLE: Using for-expression to iterate over Scala Iterator\nDESCRIPTION: Illustrates using for-expressions as an alternative syntax to iterate over each element with a println action, compatible with both Scala 2 and Scala 3 versions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/iterators.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nfor (elem <- it) println(elem)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor elem <- it do println(elem)\n```\n\n----------------------------------------\n\nTITLE: Reducing Associative Non-Commutative String Concatenation in Scala Parallel Collections\nDESCRIPTION: Shows the use of an associative but non-commutative operation, string concatenation, with Scala's parallel collection reduce function. A parallel collection of strings is concatenated using the reduce operator with string concatenation, producing a deterministic, correctly ordered combined string despite the operation being executed out-of-order in time. Dependencies include Scala parallel collections. The input is a parallel collection of strings, and the output is a concatenated string representing the combined elements in order. This example demonstrates that associative operations produce deterministic results even when non-commutative.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/overview.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nval strings = List(\"abc\",\"def\",\"ghi\",\"jk\",\"lmnop\",\"qrs\",\"tuv\",\"wx\",\"yz\").par\nval alphabet = strings.reduce(_++_)\n```\n\n----------------------------------------\n\nTITLE: Representing the Implicit Expansion Tree for Divergence Analysis - Scala (diagram)\nDESCRIPTION: This block represents the tree structure of implicit expansion as a comment, illustrating the chain of implicit definitions and how the resolution proceeds from List[Int] to (Int, Int) to Int. This is an abstract diagram, useful for understanding how Scala's divergence checking manages the expansion path and avoids false positives by striping comparisons by definition. It is presented in code format to depict the hierarchy of implicits applied in the sample code and does not require execution or dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\n<requiresPair, List[Int]>\n\n           V\n\n<providesPair, (Int, Int)>\n\n           V\n\n   <singleInt, Int>\n```\n\n----------------------------------------\n\nTITLE: ClassTagを要求しないジェネリック関数使用時のエラー例 - Scala\nDESCRIPTION: ClassTagの暗黙パラメータを要求しない型パラメータUを持つ関数で、ClassTagを必要とするevenElemsを呼び出した結果発生するエラーのREPL例です。暗黙のClassTagが提供されていないためコンパイルエラーになります。解決にはUに対してClassTagのcontext boundを付与する必要があります。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/arrays.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef wrap[U](xs: Vector[U]) = evenElems(xs)\n```\n\n----------------------------------------\n\nTITLE: Defining a Class with a Public Constructor Parameter in Scala\nDESCRIPTION: Defines a Scala class `C` with a primary constructor taking a parameter `x` of type `R`. Using `val` makes `x` a public, immutable field accessible via `c.x`. The example shows instantiation using `new C(4)`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/cheatsheets/index.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass C(val x: R)\nvar c = new C(4)\nc.x\n```\n\n----------------------------------------\n\nTITLE: Defining an Invariant Linked List in Scala\nDESCRIPTION: This snippet defines a simple generic linked list data structure as a case class `ListNode` with an invariant type parameter `T`. It includes methods to get the head and tail of the list, and a `prepend` method to add elements. Being invariant, this type does not allow subtype relations between lists of different element types. This is the foundational implementation illustrating the baseline before variance annotations and lower bounds are applied.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/lower-type-bounds.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class ListNode[T](h: T, t: ListNode[T]) {\n  def head: T = h\n  def tail: ListNode[T] = t\n  def prepend(elem: T): ListNode[T] =\n    ListNode(elem, this)\n}\n```\n\n----------------------------------------\n\nTITLE: Using Type Aliases for List in Scala\nDESCRIPTION: Illustrates accessing the List collection using different type aliases available in Scala: fully qualified, via the scala package, or unqualified. No dependencies are required beyond the Scala standard library, and there is no runtime input or output, as these are type references. This highlights Scala's design decision for backward compatibility and convenience.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/overview.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nscala.collection.immutable.List   // that's where it is defined\n```\n\nLANGUAGE: Scala\nCODE:\n```\nscala.List                        // via the alias in the scala package\n```\n\nLANGUAGE: Scala\nCODE:\n```\nList                              // because scala._\n                                  // is always automatically imported\n```\n\n----------------------------------------\n\nTITLE: Comparing Verbose and Concise Function Type Notation in Scala\nDESCRIPTION: Compares the verbose (incorrect) and concise (preferred) ways of declaring nested function types, showing how omitting parentheses improves readability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/types.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\n// wrong!\ndef foo(f: (Int) => (String) => (Boolean) => Double) = ...\n\n// right!\ndef foo(f: Int => String => Boolean => Double) = ...\n```\n\n----------------------------------------\n\nTITLE: Defining a Lazy Map Transformer Using Scala Iterable - Scala\nDESCRIPTION: Defines a lazy map function `lazyMap` that takes a source iterable and a function to apply, returning a new lazy iterable where the mapping is deferred until iteration. It constructs an anonymous Iterable that overrides the iterator method to return an iterator applying the function `f` on-the-fly without eagerly transforming the entire collection. This demonstrates lazy transformation by proxying the original collection and applying transformations only as elements are accessed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/views.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef lazyMap[T, U](coll: Iterable[T], f: T => U) = new Iterable[U] {\n  def iterator = coll.iterator map f\n}\n```\n\n----------------------------------------\n\nTITLE: Using Higher-Order Functions with Scala Collections\nDESCRIPTION: This snippet provides examples of using higher-order functions (specifically, anonymous functions) with various Scala collection methods such as `dropWhile`, `filter`, `takeWhile`, `map`, and `sortWith`. These methods accept functions as arguments, enabling concise and expressive data transformations and filtering operations common in functional programming. The examples refer back to previously defined `a` and `nums` lists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/why-scala-3.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\na.dropWhile(_ < 25)\na.filter(_ < 25)\na.takeWhile(_ < 30)\na.filter(_ < 30).map(_ * 10)\nnums.sortWith(_ < _)\nnums.sortWith(_ > _)\n```\n\n----------------------------------------\n\nTITLE: Printing the Value of a Completed Future in Scala REPL\nDESCRIPTION: This REPL snippet illustrates how to check the result of a Future once computation is complete. Output is typically a Future wrapped in a Success, such as Future(Success(84)). No dependencies other than prior creation of the Future and map call are needed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/futures.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nb\n```\n\n----------------------------------------\n\nTITLE: Creating an Iterator with Indexed Elements in Scala\nDESCRIPTION: Defines a function `zipWithIndex` that takes an Iterator[A] and returns an Iterator[(Int, A)], pairing each element with its zero-based index. It achieves this by zipping the input iterator with an infinite iterator starting from 0 created using `Iterator.from(0)`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/iterators.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ndef zipWithIndex[A](i: Iterator[A]): Iterator[(Int, A)] =\n  Iterator.from(0).zip(i)\n```\n\n----------------------------------------\n\nTITLE: Defining an Extension Method on quotes.reflect.Term in Scala 3 Macros\nDESCRIPTION: Example of defining an extension method on the `quotes.reflect.Term` type with an implicit `Quotes` parameter. The extension returns a `Tree` and allows adding custom behavior or transformations that can be invoked directly on terms inside macro code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/reflection.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nextension (using Quotes)(term: quotes.reflect.Term)\n  def g: quotes.reflect.Tree = ...\n```\n\n----------------------------------------\n\nTITLE: Extending a Generic Trait and Implementing Abstract Methods in Scala\nDESCRIPTION: Shows how to extend the generic trait 'Iterator[Int]' by implementing it in the 'IntIterator' class. The class takes an upper limit parameter 'to' and maintains a mutable internal state 'current'. It overrides the abstract methods 'hasNext' to check if more elements exist and 'next' to return the current integer and increment the state. This snippet illustrates trait extension using 'extends', method overriding using 'override', and instantiation with example usage. Expected input is a maximum integer, and outputs are integers from 0 up to but not including 'to'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/traits.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Iterator[A] {\n  def hasNext: Boolean\n  def next(): A\n}\n\nclass IntIterator(to: Int) extends Iterator[Int] {\n  private var current = 0\n  override def hasNext: Boolean = current < to\n  override def next(): Int = {\n    if (hasNext) {\n      val t = current\n      current += 1\n      t\n    } else 0\n  }\n}\n\n\nval iterator = new IntIterator(10)\niterator.next()  // returns 0\niterator.next()  // returns 1\n```\n\n----------------------------------------\n\nTITLE: Defining Sample Lists in Python and Scala\nDESCRIPTION: Illustrates defining a sample list of integers in Python and Scala to demonstrate further functional operations. Python uses a list literal, Scala uses an immutable List with the same elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_24\n\nLANGUAGE: Python\nCODE:\n```\nnumbers = [1,2,3]           // python\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval numbers = List(1,2,3)   // scala\n```\n\n----------------------------------------\n\nTITLE: Tworzenie płytkiej kopii instancji case class oraz modyfikacja parametrów w Scali\nDESCRIPTION: Pokazuje użycie metody copy do stworzenia nowej instancji klasy przypadku na podstawie istniejącej, ze zmienionymi wybranymi parametrami konstruktora. Przykład kopiuje obiekt, zmieniając pola sender i recipient, pozostawiając body bez zmian, dowodząc elastyczności metody copy.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/case-classes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ncase class Message(sender: String, recipient: String, body: String)\nval message4 = Message(\"julien@bretagne.fr\", \"travis@washington.us\", \"Me zo o komz gant ma amezeg\")\nval message5 = message4.copy(sender = message4.recipient, recipient = \"claire@bourgogne.fr\")\nmessage5.sender  // travis@washington.us\nmessage5.recipient // claire@bourgogne.fr\nmessage5.body  // \"Me zo o komz gant ma amezeg\"\n```\n\n----------------------------------------\n\nTITLE: Enqueuing Multiple Elements to an Immutable Queue in Scala\nDESCRIPTION: Illustrates adding multiple elements (2, 3) from another collection (a `List`) to an existing immutable `Queue` (`has1`) using the `enqueueAll` method. It returns a new queue containing all elements in FIFO order.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-immutable-collection-classes.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nscala> val has123 = has1.enqueueAll(List(2, 3))\nhas123: scala.collection.immutable.Queue[Int]\n    = Queue(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Using Value Classes in Collection Operations in Scala\nDESCRIPTION: This snippet showcases using the previously defined value class `Logarithm` in list operations, including mapping with a function that adds another logarithm. It highlights how generic usage (such as in collections) triggers boxing and allocation overhead, thus illustrating a primary limitation motivating the adoption of opaque types, which would avoid these allocations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/opaque-types.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval x = Logarithm(1e5)\nval xs = List(Logarithm(12345.0), Logarithm(67890.0)).map(_ + x)\n```\n\n----------------------------------------\n\nTITLE: Performing Parallel Fold Operation in Scala\nDESCRIPTION: Illustrates using the `fold` operation on a parallel array (`ParArray`) to compute the sum of its elements. The operation starts with a zero value (0) and uses the addition operator (`_ + _`) to combine elements in parallel.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/overview.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> val parArray = (1 to 10000).toArray.par\nparArray: scala.collection.parallel.mutable.ParArray[Int] = ParArray(1, 2, 3, ...\n\nscala> parArray.fold(0)(_ + _)\nres0: Int = 50005000\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterized Enums in Scala\nDESCRIPTION: This Scala snippet defines an enum named Planet with parameters mass and radius representing physical properties of planets. It declares enum cases Mercury, Venus, and Earth, each initialized with respective mass and radius values. The enum includes private constants and methods to calculate surface gravity and the surface weight of objects based on their mass. The snippet demonstrates how Scala enums can encapsulate data and behavior together. Dependencies include Scala 3 or later to support enums with parameters. Inputs are physical parameters for each case, outputs are computed gravitational properties.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_43\n\nLANGUAGE: Scala\nCODE:\n```\nenum Planet(\n   mass: Double,\n   radius: Double\n ):\n  case Mercury extends\n    Planet(3.303e+23, 2.4397e6)\n  case Venus extends\n    Planet(4.869e+24, 6.0518e6)\n  case Earth extends\n    Planet(5.976e+24, 6.37814e6)\n  // more planets ...\n\n  // fields and methods\n  private final val G = 6.67300E-11\n  def surfaceGravity = G * mass /\n    (radius * radius)\n  def surfaceWeight(otherMass: Double)\n    = otherMass * surfaceGravity\n```\n\n----------------------------------------\n\nTITLE: Implicit Context Wrapper for Snippets\nDESCRIPTION: This Scala code illustrates the wrapper automatically generated by Scaladoc's snippet compiler for snippets within documentation comments. It places the original snippet (`slice(2,5) == drop(2).take(3)`) inside a trait within the correct package (`scala.collection`) and applies the context of the documented entity (`List[A]`), ensuring necessary methods and members are in scope.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/snippet-compiler.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\npackage scala.collection\ntrait Snippet[A] { self: List[A] =>\n  slice(2,5) == drop(2).take(3)\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating Specific Collections in Scala\nDESCRIPTION: Presents how to create specific collection implementations, such as List and HashMap, using their factory methods. These are part of the Scala collection library and require the relevant imports. Inputs are the collection elements; the output is the respective collection instance (e.g., List[Int], HashMap[String, Int]). This reinforces consistent initialization across both generic and specific collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/overview.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nList(1, 2, 3)\nHashMap(\"x\" -> 24, \"y\" -> 25, \"z\" -> 26)\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Scala Class\nDESCRIPTION: Demonstrates a minimal class declaration in Scala using the 'class' keyword and creating an instance with 'new'. Highlights the default constructor behavior when no parameters are specified.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/classes.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass User\n\nval user1 = new User\n```\n\n----------------------------------------\n\nTITLE: Named Given Instances for Typeclasses and Aliases in Scala 3\nDESCRIPTION: Provides examples of defining named given instances as typeclass implementations or aliases. Demonstrates variations including simple typeclasses (e.g., for Int), parameterized typeclasses with and without named context parameters, and simple or parameterized type aliases. It also shows abstract deferred givens and by-name given definitions. Dependencies include existing Ord and Context types and value instances like IntOrd and ListOrd. These definitions facilitate precise and reusable typeclass instances under the new syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\n  // Simple typeclass\ngiven intOrd: Ord[Int] with\n  def compare(x: Int, y: Int) = ...\n\n  // Parameterized typeclass with context bound\ngiven listOrd[A: Ord]: Ord[List[A]] with\n  def compare(x: List[A], y: List[A]) = ...\n\n  // Parameterized typeclass with context parameter\ngiven listOrd[A](using Ord[A]): Ord[List[A]] with\n  def compare(x: List[A], y: List[A]) = ...\n\n  // Parameterized typeclass with named context parameter\ngiven listOrd[A](using ord: Ord[A]): Ord[List[A]] with\n  def compare(x: List[A], y: List[A]) = ...\n\n  // Simple alias\ngiven intOrd: Ord[Int] = IntOrd()\n\n  // Parameterized alias with context bound\ngiven listOrd[A: Ord]: Ord[List[A]] =\n  ListOrd[A]\n\n  // Parameterized alias with context parameter\ngiven listOrd[A](using Ord[A]): Ord[List[A]] =\n  ListOrd[A]\n\n  // Abstract or deferred given\ngiven context: Context\n\n  // By-name given\ngiven context[DummySoItsByName]: Context = curCtx\n```\n\n----------------------------------------\n\nTITLE: Defining and Eta-Expanding a Polymorphic Method in Scala\nDESCRIPTION: This snippet demonstrates a simple polymorphic method `f1` and its automatic eta-expansion under the proposed SIP-49. The key feature is converting a method with a type parameter into a polymorphic function value, enabling standard higher-order usage. No dependencies are required beyond a Scala 3 compiler implementing the proposal. Input is a type `A` and value of type `A`, output matches the input type, and the limitation is that the method must be properly shaped for eta-expansion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/polymorphic-eta-expansion.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef f1[A](x: A): A = ???\nval v1_1: [B] => B => B = f1 // f1 becomes [B'] => (y: B') => f1[B'](y)\n```\n\n----------------------------------------\n\nTITLE: Defining a 'given' instance for Config in Scala 3\nDESCRIPTION: Illustrates creating a singleton 'given' instance for a specific Config object, making it implicitly available in the scope. This pattern simplifies passing common configurations throughout the codebase without explicit parameter passing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/ca-context-parameters.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval config = Config(8080, \"docs.scala-lang.org\")\n\ngiven Config = config\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Dictionary Items in Python\nDESCRIPTION: Uses a Python 'for' loop to iterate over key-value pairs of 'my_dict' using the .items() method, printing each key and value separately.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\nfor key, value in my_dict.items():\n  print(key)\n  print(value)\n```\n\n----------------------------------------\n\nTITLE: Using if-else Conditional Statements in Python\nDESCRIPTION: Demonstrates the use of if, elif, and else conditional statements to evaluate a variable and print a descriptive result. The variable 'x' is checked for being negative, zero, or positive, with corresponding printed output. Applicable in scenarios requiring branching logic.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nif x < 0:\n  print(\"negative\")\nelif x == 0:\n  print(\"zero\")\nelse:\n  print(\"positive\")\n```\n\n----------------------------------------\n\nTITLE: Compile error example due to missing ClassTag for type parameter in Scala 3\nDESCRIPTION: This Scala 3 snippet demonstrates a compilation error similar to Scala 2 when an unconstrained generic type parameter U is used with 'evenElems' that demands a ClassTag. The compiler message explicitly indicates the missing ClassTag for U, showing the importance of adding the context bound to guarantee runtime type information for array creation in generic methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/arrays.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\n-- Error: ----------------------------------------------------------------------\n6 |def wrap[U](xs: Vector[U]) = evenElems(xs)\n  |                                          ^\n  |                                          No ClassTag available for U\n```\n\n----------------------------------------\n\nTITLE: Creating Customer Data Class (Scala)\nDESCRIPTION: Defines the `Customer` class as a data structure to hold customer information. It contains mutable properties for `name`, `phone`, and an `Address` object. This class depends on the `Address` class and is intended for use within the `Order` class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/oop-pizza-example.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass Customer (\n    var name: String,\n    var phone: String,\n    var address: Address\n)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a View to Avoid Intermediate Sequence Allocations in Scala - Scala\nDESCRIPTION: Shows usage of a view on a long sequence to avoid constructing a large intermediate sequence during filtering or searching by creating a lazy transformation pipeline. Using `words.view take 1000000` creates a lightweight view limiting to the first million elements lazily, improving performance by deferring evaluation until elements are actually accessed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/views.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nfindPalindrome(words.view take 1000000)\n```\n\n----------------------------------------\n\nTITLE: Handling failed Futures with failed projection in Scala 2\nDESCRIPTION: Shows how to use the 'failed' projection of Futures to obtain a Future containing the Throwable if the original Future failed. The for-comprehension iterates over the failed Future to print the captured exception to the standard output, allowing asynchronous handling of failure cases distinct from successes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\nval f = Future {\n  2 / 0\n}\nfor (exc <- f.failed) println(exc)\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Ordering for TreeSet in Scala\nDESCRIPTION: Defines a custom ordering for String elements in Scala using Ordering.fromLessThan, where the ordering is reversed (descending lexicographic order). This ordering is essential for creating sorted collections like TreeSet that maintain elements in the specified order.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/sets.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval myOrdering = Ordering.fromLessThan[String](_ > _)\n```\n\n----------------------------------------\n\nTITLE: Accessing the Head Element of Collections in Scala\nDESCRIPTION: This snippet shows how to use head to access the first element of a List and a String in Scala. Inputs are List[Int] and String; outputs are Int or Char respectively. No dependencies. Demonstrates indexing into sequences and works also with string arguments, as strings are treated as sequences of characters in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-methods.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\noneToTen.head   // 1\nnames.head      // adam\n```\n\nLANGUAGE: scala\nCODE:\n```\n\"foo\".head   // 'f'\n\"bar\".head   // 'b'\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Inference in Scala\nDESCRIPTION: Example showing how Scala's type inference allows declaring variables without explicitly specifying their types, making the code feel more dynamic despite being statically typed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-introduction.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval a = 1\nval b = 2.0\nval c = \"Hi!\"\n```\n\n----------------------------------------\n\nTITLE: Using a Generic Stack with Integers in Scala\nDESCRIPTION: This snippet demonstrates the creation and usage of a Stack instance with Int type elements. It shows pushing elements onto the stack, including an attempt to push a character (which compiles due to Scala's type coercion but effectively uses the character code), then retrieving and popping elements from the stack. The output illustrates the ASCII value of the character and the behavior of the stack operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/generic-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject GenericsTest extends App {\n  val stack = new Stack[Int]\n  stack.push(1)\n  stack.push('a')\n  println(stack.top)\n  stack.pop()\n  println(stack.top)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Main Method with Arguments Scala 3\nDESCRIPTION: Defines a Scala 3 program entry point using `@main` that accepts command line arguments with automatic type conversion. It takes an `Int`, a `String`, and a variable number of `String` arguments (`String*`). The compiler automatically parses arguments based on parameter types using available `FromString` instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-main-methods.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n@main def happyBirthday(age: Int, name: String, others: String*) =\n  val suffix = (age % 100) match\n    case 11 | 12 | 13 => \"th\"\n    case _ => (age % 10) match\n      case 1 => \"st\"\n      case 2 => \"nd\"\n      case 3 => \"rd\"\n      case _ => \"th\"\n\n  val sb = StringBuilder(s\"Happy $age$suffix birthday, $name\")\n  for other <- others do sb.append(\" and \").append(other)\n  println(sb.toString)\n```\n\n----------------------------------------\n\nTITLE: Объявление ковариантных классов List и Vector в Scala 2 и 3\nDESCRIPTION: Пример показывает объявление популярных неизменяемых коллекций Scala — List и Vector — как ковариантных по параметру типа A, с явным префиксом '+'. Это объясняет, почему коллекции можно безопасно использовать с более узкими типами элементов в местах, ожидающих более общие типы.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-variance.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nclass List[+A] ...\nclass Vector[+A] ...\n```\n\n----------------------------------------\n\nTITLE: Multi-line for Loop with Block in Scala\nDESCRIPTION: Scala's multi-line for loop iterating over ints with generator, defining local val x, and printing formatted string, using 'for...do' with indentation instead of braces.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_42\n\nLANGUAGE: scala\nCODE:\n```\nfor\n  i <- ints\n do\n  val x = i * 2\n  println(s\"i = $i, x = $x\")\n```\n\n----------------------------------------\n\nTITLE: Idiomatic Scala syntax using underscore in `map`\nDESCRIPTION: Utilizes placeholder syntax `_` to create a concise expression doubling each salary. Simplifies lambda syntax when parameters are used once.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/higher-order-functions.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval salaries = Seq(20_000, 70_000, 40_000)\nval newSalaries = salaries.map(_ * 2)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Implicit Value Type Casting in Scala\nDESCRIPTION: This snippet shows how Scala implicitly casts value types like `Byte` to `Int` and `Char` to `Int` when no information is lost. It illustrates that a `Byte` value is widened to an `Int` and a `Char` representing a Unicode character is converted to its integer code point. These conversions happen automatically because the target type can fully represent the source value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/first-look-at-types.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval b: Byte = 127\nval i: Int = b  // 127\n\nval face: Char = '☺'\nval number: Int = face  // 9786\n```\n\n----------------------------------------\n\nTITLE: Instantiating Case Classes in Scala\nDESCRIPTION: Shows how to create an instance of an immutable case class and assign it to a val variable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-immutable-values.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval reginald = Person(\"Reginald\", \"Dwight\")\n```\n\n----------------------------------------\n\nTITLE: Using only immutable sequences for parameters and return types in Scala 2.13 - Scala\nDESCRIPTION: This snippet illustrates the most strict migration strategy involving exclusively immutable sequences for both parameters and return types, by importing scala.collection.immutable and using immutable.Seq. This approach simplifies API semantics enforcing immutability everywhere but may break source and binary compatibility when cross-building between Scala 2.12 and 2.13. It requires defining all method signatures with immutable.Seq types. Inputs and outputs are immutable sequences of domain-specific types Order and Food.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/collections-migration-213.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.immutable\n\nobject FoodToGo {\n  def orderFood(order: immutable.Seq[Order]): immutable.Seq[Food]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with a Call-by-Name Parameter in Scala\nDESCRIPTION: This snippet defines a function 'calculate' that takes a call-by-name parameter 'input' of type Int. The parameter 'input' is not evaluated until it is used in the function body, allowing for delayed computation. No additional dependencies are required. The function multiplies the evaluated 'input' by 37 and returns the result.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/by-name-parameters.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef calculate(input: => Int) = input * 37\n```\n\n----------------------------------------\n\nTITLE: Providing Default Values for Partial Functions in Scala\nDESCRIPTION: Shows how to use applyOrElse method to provide a default value or transformation for inputs outside a partial function's domain.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-partial-functions.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndoubledOdds.applyOrElse(4, _ + 1)  // 5\n```\n\n----------------------------------------\n\nTITLE: Declaring Numeric Value Types in Scala\nDESCRIPTION: Declares variables of several built-in numeric value types (Byte, Int, Long, Short, Double, Float) with explicit type annotations. Shows Scala syntax for fixed-size integral and floating-point types and how to specify types explicitly when needed despite default inference (e.g., Int for integral literals, Double for floating-point literals).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/first-look-at-types.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval b: Byte = 1\nval i: Int = 1\nval l: Long = 1\nval s: Short = 1\nval d: Double = 2.0\nval f: Float = 3.0\n```\n\n----------------------------------------\n\nTITLE: Checking password with regex pattern in Scala\nDESCRIPTION: This snippet demonstrates creating a simple regular expression pattern to check if a password contains a digit. It imports the Regex class, creates a pattern that matches any digit, and uses pattern matching to verify the presence of a number in a password.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/regular-expression-patterns.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.util.matching.Regex\n\nval numberPattern: Regex = \"[0-9]\".r\n\nnumberPattern.findFirstMatchIn(\"awesomepassword\") match {\n  case Some(_) => println(\"Password OK\")\n  case None => println(\"Password must contain a number\")\n}\n```\n\n----------------------------------------\n\nTITLE: Example Failed For Comprehension Result, Scala\nDESCRIPTION: Shows the resulting type and value of the `for` comprehension when one or more of the inputs to `makeInt` cannot be converted, causing `makeInt` to return `None`. The `for` comprehension short-circuits, and the final result is `None`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-functional-error-handling.md#_snippet_6\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\ny: Option[Int] = None\n```\n\n----------------------------------------\n\nTITLE: Defining an Animal Type Hierarchy in Scala 3\nDESCRIPTION: This snippet declares an abstract Animal class and its subclasses Cat and Dog using Scala 3's significant indentation (no braces). Like the Scala 2 version, it provides a type hierarchy for illustrating variance in later examples. No dependencies beyond the Scala 3 syntax. Each class exposes a name field and demonstrates base and derived type relationships.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/variances.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Animal:\n  def name: String\n\ncase class Cat(name: String) extends Animal\ncase class Dog(name: String) extends Animal\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Methods for Factorial Calculation in Scala\nDESCRIPTION: Defines a factorial method that calculates the factorial of an integer using a nested inner method `fact` for tail-recursive computation. The inner method accepts the current integer and an accumulator to carry the intermediate factorial product. The code requires Scala environment to compile and run. It takes an integer input and outputs the factorial as an integer. The snippet includes example usage printing the factorial of 2 and 3. There are no external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/nested-functions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n def factorial(x: Int): Int = {\n    def fact(x: Int, accumulator: Int): Int = {\n      if (x <= 1) accumulator\n      else fact(x - 1, x * accumulator)\n    }  \n    fact(x, 1)\n }\n\n println(\"Factorial of 2: \" + factorial(2))\n println(\"Factorial of 3: \" + factorial(3))\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Using the 'Ponto' Class in a Main Application\nDESCRIPTION: This code snippet demonstrates creating an object 'pt' of the 'Ponto' class using 'new' with initial coordinates. It shows how to invoke the 'move' method to change the object state and print the object, which triggers the overridden 'toString' method. The snippet highlights class instantiation, method calls, and output generation in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/classes.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject Classes {\n  def main(args: Array[String]): Unit = {\n    val pt = new Ponto(1, 2)\n    println(pt)\n    pt.move(10, 10)\n    println(pt)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Infix Notation for Method Calls in Scala\nDESCRIPTION: Explains that the infix notation `df format now` is syntactic sugar for the standard method call `df.format(now)` when a method takes a single argument.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tutorials/scala-for-java-programmers.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// Infix notation\ndf format now\n\n// Equivalent standard method call\ndf.format(now)\n```\n\n----------------------------------------\n\nTITLE: Multi-line for loops in Java vs Scala\nDESCRIPTION: Demonstrates multi-line for loop implementation in both languages. Scala uses a more structured approach with explicit 'do' keyword for the loop body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_41\n\nLANGUAGE: Java\nCODE:\n```\nfor (int i: ints) {\n  int x = i * 2;\n  System.out.println(x);\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor\n  i <- ints\ndo\n  val x = i * 2\n  println(s\"i = $i, x = $x\")\n```\n\n----------------------------------------\n\nTITLE: Using Named Function toUpper Passed to Map in Scala\nDESCRIPTION: Defines a named function toUpper which converts a string to uppercase. The function is then passed to the map method in a list of strings. This example shows how regular functions can be used as parameters to higher-order functions, providing an alternative to anonymous functions for clarity or reuse.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/passing-functions-around.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef toUpper(s: String): String = s.toUpperCase\n\nList(\"foo\", \"bar\").map(toUpper)\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic build.sbt Configuration\nDESCRIPTION: A minimal build.sbt file for an sbt project, specifying the project name, version, and Scala version to use for compilation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/scala-build-tool-sbt.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nname := \"HelloWorld\"\nversion := \"1.0\"\nscalaVersion := \"{{ site.scala-version }}\"\n```\n\n----------------------------------------\n\nTITLE: Defining implicit conversion from Int to Ordered in Scala\nDESCRIPTION: This implicit method allows an Int to be implicitly converted to an Ordered[Int], facilitating ordered comparisons and operations involving integer values. It is a prerequisite for features like list ordering and numeric type interoperability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/implicit-conversions.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit def int2ordered(x: Int): Ordered[Int] =\n  new Ordered[Int] { /* .. */ }\n```\n\n----------------------------------------\n\nTITLE: Creating Specific Collections with Constructors in Scala\nDESCRIPTION: This snippet shows how to create specific collection instances like 'List' and 'HashMap' using their constructors with elements. It demonstrates the syntax for instantiating concrete implementations of Scala collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/overview.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nList(1, 2, 3)\nHashMap(\"x\" -> 24, \"y\" -> 25, \"z\" -> 26)\n```\n\n----------------------------------------\n\nTITLE: Partial Application of 'foldLeft' in Scala for List Operations\nDESCRIPTION: This example illustrates partial application by creating a 'numberFunc' by partially applying 'foldLeft' with an initial empty list. The resulting function accepts a binary operation to generate new lists based on the collection. Two examples show creating lists of squares and cubes by applying different lambda functions. Inputs are the list and binary functions; outputs are new lists with computed values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/multiple-parameter-lists.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nval numberFunc = numbers.foldLeft(List[Int]()) _\n\nval squares = numberFunc((xs, x) => xs :+ x * x)\nprintln(squares) // List(1, 4, 9, 16, 25, 36, 49, 64, 81, 100)\n\nval cubes = numberFunc((xs, x) => xs :+ x * x * x)\nprintln(cubes)  // List(1, 8, 27, 64, 125, 216, 343, 512, 729, 1000)\n```\n\n----------------------------------------\n\nTITLE: Simple Method Examples with Optional Return Type\nDESCRIPTION: Shows examples of single-line methods with and without explicit return type annotations, highlighting how Scala can infer return types in simple cases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/methods-most.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef add(a: Int, b: Int): Int = a + b\ndef add(a: Int, b: Int) = a + b\n```\n\n----------------------------------------\n\nTITLE: Declaring Numeric Value Types Explicitly in Scala\nDESCRIPTION: This snippet demonstrates explicit variable type declarations for all major Scala numeric types: Byte, Int, Long, Short, Double, and Float. It shows that integer literals default to Int and decimal literals to Double, requiring explicit type annotation for other value types. No external libraries are required for base number handling.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/first-look-at-types.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval b: Byte = 1\nval i: Int = 1\nval l: Long = 1\nval s: Short = 1\nval d: Double = 2.0\nval f: Float = 3.0\n```\n\n----------------------------------------\n\nTITLE: Using Traits in Scala 2: Creating Animal Instances\nDESCRIPTION: Example demonstrating instantiation of Dog and Cat classes, calling methods to showcase behavior. Shows practical usage of trait-based classes in Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-modeling.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval d = new Dog(\"Rover\")\nprintln(d.speak())      // prints \"Woof!\"\n\nval c = new Cat(\"Morris\")\nprintln(c.speak())      // \"Meow\"\nc.startRunning()        // \"Yeah ... I don’t run\"\nc.stopRunning()         // \"No need to stop\"\n```\n\n----------------------------------------\n\nTITLE: Using PizzaServiceInterface Methods to Manipulate Pizza in Scala\nDESCRIPTION: Shows a sample usage scenario of the PizzaServiceInterface methods by constructing an initial Pizza instance and applying multiple toppings and crust updates in a chained manner. This exemplifies intended client code interaction with the API. Demonstrates immutable transformations where each method returns a new Pizza instance reflecting the applied change.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-fp.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nval p = Pizza(Small, Thin, Seq(Cheese))\n\n// how you want to use the methods in PizzaServiceInterface\nval p1 = addTopping(p, Pepperoni)\nval p2 = addTopping(p1, Onions)\nval p3 = updateCrustType(p2, Thick)\nval p4 = updateCrustSize(p3, Large)\n```\n\n----------------------------------------\n\nTITLE: Defining a Class with Members and Auxiliary Constructor in Scala\nDESCRIPTION: Defines a Scala class `C` with a primary constructor taking a mutable parameter `x` (declared with `var`). The class body contains an assertion, public mutable (`y`) and immutable (`readonly`) members, a private mutable member (`secret`), and an auxiliary constructor `def this = this(42)` that calls the primary constructor.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/cheatsheets/index.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass C(var x: R) {\n  assert(x > 0, \"positive please\")\n  var y = x\n  val readonly = 5\n  private var secret = 1\n  def this = this(42) // Auxiliary constructor\n}\n```\n\n----------------------------------------\n\nTITLE: Combining ..$ Splicing and $ Unquoting (Suffix) (Scala)\nDESCRIPTION: Illustrates inserting a list of trees using `..$` splicing (`ab`) followed by a single tree using `$` unquoting (`c`) within a function application in a `q` quasiquote. Shows flexible argument construction.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/intro.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val fabc = q\"f(..$ab, $c)\"\nfabc: universe.Tree = f(a, b, c)\n```\n\n----------------------------------------\n\nTITLE: Creating immutable sequences in Java vs Scala\nDESCRIPTION: Shows the syntax for creating immutable sequences in both languages. Scala provides concise syntax with both List and Vector implementations readily available.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_48\n\nLANGUAGE: Java\nCODE:\n```\nList strings = List.of(\"a\", \"b\", \"c\");\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval strings = List(\"a\", \"b\", \"c\")\nval strings = Vector(\"a\", \"b\", \"c\")\n```\n\n----------------------------------------\n\nTITLE: Comparing instances of different classes with universal equality\nDESCRIPTION: Example showing how universal equality allows comparison between different classes in Scala, which compiles but returns false.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-multiversal-equality.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class Cat(name: String)\ncase class Dog(name: String)\nval d = Dog(\"Fido\")\nval c = Cat(\"Morris\")\n\nd == c  // false, but it compiles\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Interpolator Structure (Scala 2 & 3)\nDESCRIPTION: Shows the basic structure for defining a custom string interpolator method (`p` in this case) for `StringContext`. It presents the Scala 2 approach using an implicit class extending `AnyVal` and the Scala 3 approach using an extension method. The method implementation is deferred (`???`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/string-interpolation.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 2 using Implicit Class\nimplicit class PointHelper(val sc: StringContext) extends AnyVal {\n  def p(args: Any*): Point = ???\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 3 using Extension Method\nextension (sc: StringContext)\n  def p(args: Any*): Point = ???\n```\n\n----------------------------------------\n\nTITLE: Passing a function directly without multiple parameter lists\nDESCRIPTION: This snippet shows an alternative usage where foldLeft is called with an initial value and a function passed directly, but without utilizing multiple parameter lists, illustrating less idiomatic Scala code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/multiple-parameter-lists.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nnumbers.foldLeft(0, (m: Int, n: Int) => m + n)\n```\n\n----------------------------------------\n\nTITLE: Filtering with Explicit Parameter Types in Scala Anonymous Functions\nDESCRIPTION: Shows alternative filter method invocations using anonymous functions, both with and without explicit type annotations. Requires a List[Int] and outputs filtered lists based on the provided predicates (e.g., keeping even numbers). All forms are semantically equivalent. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/anonymous-functions.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval x = ints.filter((i: Int) => i % 2 == 0)\nval x = ints.filter(i => i % 2 == 0)\n```\n\n----------------------------------------\n\nTITLE: Using sequences for multiple values of the same query parameter\nDESCRIPTION: Shows how to use a Seq, List, or Array to represent multiple values for the same query parameter when constructing URIs with the uri interpolator.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/http-client-uris.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef getUri(versions: Seq[String]): Uri =\n  uri\"https://example.com/scala?version=$versions\"\n\nprintln(getUri(Seq(\"3.2.2\")))\n// prints: https://example.com/scala?version=3.2.2\n\nprintln(getUri(Seq(\"2.13.8\", \"2.13.9\", \"2.13.10\")))\n// prints: https://example.com/scala?version=2.13.8&version=2.13.9&version=2.13.10\n\nprintln(getUri(Seq.empty))\n// prints: https://example.com/scala\n```\n\n----------------------------------------\n\nTITLE: Implementing the second version of RNA sequence class with proper return types\nDESCRIPTION: An improved RNA2 class that extends both IndexedSeq[Base] and IndexedSeqLike[Base, RNA2] to ensure that operations like take, drop, and filter return RNA2 instances instead of generic IndexedSeq.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/architecture-of-scala-collections.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nfinal class RNA2 private (\n  val groups: Array[Int],\n  val length: Int\n) extends IndexedSeq[Base] with IndexedSeqLike[Base, RNA2] {\n\n  import RNA2._\n\n  override def newBuilder: Builder[Base, RNA2] =\n    new ArrayBuffer[Base] mapResult fromSeq\n\n  def apply(idx: Int): Base = // as before\n}\n```\n\n----------------------------------------\n\nTITLE: Scala値クラス内で`def`メソッドの定義例\nDESCRIPTION: 値クラス内に`val`や`var`、入れ子のクラスやトレイトを持たずに、`def`を定義する例。内部の`underlying`を操作し、新たな`Wrapper`を返すメソッドを実装可能。ただし、`val`や`var`、入れ子のクラスは許されない。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/value-classes.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass Wrapper(val underlying: Int) extends AnyVal {\n  def foo: Wrapper = new Wrapper(underlying * 19)\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring String and Char Types in Scala\nDESCRIPTION: Declares string and character variables in Scala without explicit typing by leveraging type inference. Demonstrates syntax for string literals with double quotes and character literals with single quotes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/first-look-at-types.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval s = \"Bill\"\nval c = 'a'\n```\n\n----------------------------------------\n\nTITLE: Polymorphic Unfolder as Anonymous Function in Shapeless Example (Scala)\nDESCRIPTION: This snippet defines a large inline polymorphic anonymous function as an argument to `unfold` when processing heterogeneous data such as tuples. The function is parameterized by a type `[t]` and uses auxiliary types and label lists, making heavy use of advanced Scala 3 syntax. Dependencies include companion types and methods like `inst`, `unfold`, `head`, `labelling`, and `Read`. Inputs are a string and internal types, outputs are options with transformed tuples. Limitation: the function is verbose and less reusable unless factored out.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/polymorphic-eta-expansion.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n...  \n  def readElems(s: String): Option[(T, String)] = {\n    type Acc = (String, Seq[String], Boolean)\n    inst.unfold[Acc]((s, labelling.elemLabels, true))( \n      [t] => (acc: Acc, rt: Read[t]) => {\n        val (s, labels, first) = acc\n        (for {\n          (_, tl0) <- if(first) Some((\"\", s)) else head(s, \"(,)(.*)\".r)\n          (_, tl1) <- head(tl0, s\"(${labels.head}):(.*)\".r)\n          (t, tl2) <- rt.read(tl1)\n          } yield (t, tl2)) match {\n            case Some(t, tl2) => ((tl2, labels.tail, false), Some(t))\n            case None => ((s, labels, first), None)\n          }\n      }\n      ) match {\n        case (s, None) => None\n        case (acc, Some(t)) => Some((t, acc._1))\n      }\n  }\n```\n\n----------------------------------------\n\nTITLE: Commenting Out Last Element - Error Before Trailing Commas\nDESCRIPTION: Demonstrates the issue encountered when commenting out the last element in a multi-line sequence under the old syntax. The comma on the preceding line causes a syntax error because it's no longer followed by an element before the closing parenthesis.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/trailing-commas.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nSeq(\n  foo,\n  bar,\n//  baz\n)       // error: illegal start of simple expression\n```\n\n----------------------------------------\n\nTITLE: Applying @unroll to a Class Primary Constructor in Scala\nDESCRIPTION: Demonstrates using the `@unroll` annotation on default parameters within a class's primary constructor. This instructs the compiler to generate synthetic secondary constructors (`this(...)`) for binary compatibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/unroll-default-arguments.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nclass Unrolled(s: String, n: Int = 1, @unroll b: Boolean = true, @unroll l: Long = 0){\n   def foo = s + n + b + l\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Observer Pattern Components in Scala 3\nDESCRIPTION: This Scala 3 implementation uses the new syntax to define the SensorReader singleton extending SubjectObserver, setting type members for Sensor and Display. Sensor class maintains state and notifies subscribers on value change; Display class prints update events when notified. Dependencies: SubjectObserver, Subject, and Observer traits are required and assumed defined elsewhere. Sensor objects require a label string, and Display requires none. Output: notifications are printed. Inputs and outputs mirror the Scala 2 version but leverage Scala 3 idioms.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-oop.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nobject SensorReader extends SubjectObserver:\n  type S = Sensor\n  type O = Display\n\n  class Sensor(val label: String) extends Subject:\n    private var currentValue = 0.0\n    def value = currentValue\n    def changeValue(v: Double) =\n      currentValue = v\n      publish()\n\n  class Display extends Observer:\n    def notify(sub: Sensor) =\n      println(s\"${sub.label} has value ${sub.value}\")\n```\n\n----------------------------------------\n\nTITLE: Inserting Element at Index in Buffer in Scala\nDESCRIPTION: Inserts a single element 'x' at a specific index 'i' within the buffer 'buf'. Existing elements from index 'i' onwards are shifted to the right.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/seqs.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nbuf insert (i, x)\n```\n\n----------------------------------------\n\nTITLE: Main Function Demonstrating Expression Construction, Evaluation, and Differentiation in Scala\nDESCRIPTION: Provides a main method that constructs an arithmetic expression `(x+x) + (7+y)` using the previously defined Arbol case classes, defines a variable environment mapping x to 5 and y to 7 using pattern function syntax, and demonstrates printing the expression's structure, its evaluation result, and symbolic derivatives with respect to 'x' and 'y'. It showcases the integration of expression creation, evaluation, and differentiation in a practical example.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tutorials/scala-for-java-programmers.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\ndef main(args: Array[String]): Unit = {\n  val exp: Arbol = Sum(Sum(Var(\"x\"),Var(\"x\")),Sum(Const(7),Var(\"y\")))\n  val ent: Entorno = { case \"x\" => 5 case \"y\" => 7 }\n  println(\"Expresión: \" + exp)\n  println(\"Evaluación con x=5, y=7: \" + eval(exp, ent))\n  println(\"Derivada con respecto a x:\\n \" + derivada(exp, \"x\"))\n  println(\"Derivada con respecto a y:\\n \" + derivada(exp, \"y\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Compile-Time Error for Invalid Union Type Usage\nDESCRIPTION: Illustrates the type safety of union types. Attempting to call the `help` method (expecting `Username | Password`) with an incompatible type like `String` results in a compile-time error, as shown in the example error message.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-union.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nhelp(\"hi\")   // error: Found: (\"hi\" : String)\n             //        Required: Username | Password\n```\n\n----------------------------------------\n\nTITLE: Defining a generic trait with abstract methods in Scala\nDESCRIPTION: Demonstrates how to create a generic trait with type parameter A and two abstract methods that must be implemented by any class extending this trait.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/traits.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntrait Iterator[A] {\n  def hasNext: Boolean\n  def next(): A\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait Iterator[A]:\n  def hasNext: Boolean\n  def next(): A\n```\n\n----------------------------------------\n\nTITLE: Generating Scaladoc using direct scaladoc command\nDESCRIPTION: Use the scaladoc command-line utility to generate documentation for a specific Scala file. This approach is less common but useful for simple cases or when debugging Scaladoc issues.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scaladoc/generate.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ scaladoc src/main/scala/App.scala\nmodel contains 1 documentable templates\n```\n\n----------------------------------------\n\nTITLE: Определение контравариантного трейта Function в Scala 2\nDESCRIPTION: Функциональный тип Function определён с контравариантным параметром A (аргумент) и ковариантным параметром B (результат). Использование аннотаций вариантности отображает правила безопасности типов: аргументы являются потребляемыми значениями (контравариантность), выходные данные — производимыми (ковариантность). Это фундаментально для типовой системы функций в Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-variance.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Function[-A, +B] {\n  def apply(a: A): B\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified foldLeft with Type Inference in Scala\nDESCRIPTION: This snippet illustrates how currying and Scala's type inference can simplify foldLeft invocations. By passing an underscore-based anonymous function, the addition is performed succinctly. Works with any collection supporting foldLeft, with the initial value and operation as inputs, yielding the computed sum as output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/multiple-parameter-lists.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nnumbers.foldLeft(0)(_ + _)\n```\n\n----------------------------------------\n\nTITLE: Example of class inheritance highlighting val initialization order in Scala\nDESCRIPTION: This code illustrates how fields in Scala classes are initialized during object creation, especially when involving inheritance and overriding. It demonstrates potential issues with null-valued fields when overridden vals are accessed during superclass construction.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/FAQ/initialization-order.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class A {\n  val x1: String\n  val x2: String = \"mom\"\n\n  println(s\"A: $x1, $x2\")\n}\nclass B extends A {\n  val x1: String = \"hello\"\n\n  println(s\"B: $x1, $x2\")\n}\nclass C extends B {\n  override val x2: String = \"dad\"\n\n  println(s\"C: $x1, $x2\")\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Interface with a Default Method in Java\nDESCRIPTION: Java 8 introduced default methods in interfaces, allowing interfaces to provide a concrete implementation for a method. Classes implementing the interface can use this default implementation or override it.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_22\n\nLANGUAGE: Java\nCODE:\n```\npublic interface Adder {\n  int add(int a, int b);\n  default int multiply(\n    int a, int b\n  ) {\n    return a * b;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Declared Scala Exceptions in Java\nDESCRIPTION: Shows an example of Java code attempting to call a Scala method annotated with `@throws`. This code will fail to compile unless the potential exception is handled (e.g., with a try-catch block) or declared in the calling Java method's signature.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/interacting-with-java.md#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\n// won’t compile because the exception isn’t handled\npublic class ScalaExceptionsInJava {\n  public static void main(String[] args) {\n    SExceptionThrower.exceptionThrower();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Non-Exhaustive Sealed Match - Scala 2\nDESCRIPTION: Demonstrates how pattern matching on a `sealed` type helps the compiler check for exhaustivity. When a `case` for a subtype (`VoiceRecording`) is missing, the compiler issues a warning indicating the potential failure case. Requires `sealed trait Notification` and its subtypes (`Email`, `SMS`, `VoiceRecording`) to be defined in the same file.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/pattern-matching.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ndef showNotification(notification: Notification): String = {\n  notification match {\n    case Email(sender, title, _) =>\n      s\"You got an email from $sender with title: $title\"\n    case SMS(number, message) =>\n      s\"You got an SMS from $number! Message: $message\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using pattern guards with Notifications in Scala\nDESCRIPTION: Defines 'showImportantNotification', which adds conditional guards to pattern matching, checking if the sender or number is in a list of important contacts before matching. It enables more precise control based on additional conditions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/pattern-matching.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef showImportantNotification(notification: Notification, importantPeopleInfo: Seq[String]): String = {\n  notification match {\n    case Email(sender, _, _) if importantPeopleInfo.contains(sender) =>\n      \"You got an email from special someone!\"\n    case SMS(number, _) if importantPeopleInfo.contains(number) =>\n      \"You got an SMS from special someone!\"\n    case other =>\n      showNotification(other) // nothing special, delegate to our original showNotification function\n  }\n}\n\nval importantPeopleInfo = Seq(\"867-5309\", \"jenny@gmail.com\")\n\nval someSms = SMS(\"867-5309\", \"Are you there?\")\nval someVoiceRecording = VoiceRecording(\"Tom\", \"voicerecording.org/id/123\")\nval importantEmail = Email(\"jenny@gmail.com\", \"Drinks tonight?\", \"I'm free after 5!\")\nval importantSms = SMS(\"867-5309\", \"I'm here! Where are you?\")\n\nprintln(showImportantNotification(someSms, importantPeopleInfo))\nprintln(showImportantNotification(someVoiceRecording, importantPeopleInfo))\nprintln(showImportantNotification(importantEmail, importantPeopleInfo))\nprintln(showImportantNotification(importantSms, importantPeopleInfo))\n```\n\n----------------------------------------\n\nTITLE: Definition and Implementation of RNA Class in Scala 3\nDESCRIPTION: The Scala 3 implementation of the `RNA` class uses the new syntax for class and object definitions, including indentation and colon-based structure. It maintains the same functionality as the Scala 2 version, providing a sequence class for RNA strands with optimized methods and a companion object with factory methods. The overriding `iterator` method is also optimized for efficient traversal, leveraging Scala 3 syntax and idioms.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.{ AbstractIterator, SpecificIterableFactory, StrictOptimizedSeqOps, View, mutable }\nimport scala.collection.immutable.{ IndexedSeq, IndexedSeqOps }\n\nfinal class RNA private\n( val groups: Array[Int],\n  val length: Int\n) extends IndexedSeq[Base],\n  IndexedSeqOps[Base, IndexedSeq, RNA],\n  StrictOptimizedSeqOps[Base, IndexedSeq, RNA]:\n  rna =>\n\n  import RNA.*\n\n  // Mandatory implementation of `apply` in `IndexedSeqOps`\n  def apply(idx: Int): Base =\n    if idx < 0 || length <= idx then\n      throw new IndexOutOfBoundsException\n    Base.fromInt(groups(idx / N) >> (idx % N * S) & M)\n\n  // Mandatory overrides of `fromSpecific`, `newSpecificBuilder`,\n  // and `empty`, from `IterableOps`\n  override protected def fromSpecific(coll: IterableOnce[Base]): RNA =\n    RNA.fromSpecific(coll)\n  override protected def newSpecificBuilder: mutable.Builder[Base, RNA] =\n    RNA.newBuilder\n  override def empty: RNA = RNA.empty\n\n  // Overloading of `appended`, `prepended`, `appendedAll`, `prependedAll`,\n  // `map`, `flatMap` and `concat` to return an `RNA` when possible\n  def concat(suffix: IterableOnce[Base]): RNA =\n    strictOptimizedConcat(suffix, newSpecificBuilder)\n  inline final def ++ (suffix: IterableOnce[Base]): RNA = concat(suffix)\n  def appended(base: Base): RNA =\n    (newSpecificBuilder ++= this += base).result()\n  def appendedAll(suffix: Iterable[Base]): RNA =\n    strictOptimizedConcat(suffix, newSpecificBuilder)\n  def prepended(base: Base): RNA =\n    (newSpecificBuilder += base ++= this).result()\n  def prependedAll(prefix: Iterable[Base]): RNA =\n    (newSpecificBuilder ++= prefix ++= this).result()\n  def map(f: Base => Base): RNA =\n    strictOptimizedMap(newSpecificBuilder, f)\n  def flatMap(f: Base => IterableOnce[Base]): RNA =\n    strictOptimizedFlatMap(newSpecificBuilder, f)\n\n  // Optional re-implementation of iterator,\n  // to make it more efficient.\n  override def iterator: Iterator[Base] = new AbstractIterator[Base]:\n    private var i = 0\n    private var b = 0\n    def hasNext: Boolean = i < rna.length\n    def next(): Base =\n      b = if i % N == 0 then groups(i / N) else b >>> S\n      i += 1\n      Base.fromInt(b & M)\n\n  override def className = \"RNA\"\n end RNA\n\nobject RNA extends SpecificIterableFactory[Base, RNA]:\n\n  private val S = 2            // number of bits in group\n  private val M = (1 << S) - 1 // bitmask to isolate a group\n  private val N = 32 / S       // number of groups in an Int\n\n  def fromSeq(buf: collection.Seq[Base]): RNA =\n    val groups = new Array[Int]((buf.length + N - 1) / N)\n    for i <- 0 until buf.length do\n      groups(i / N) |= Base.toInt(buf(i)) << (i % N * S)\n    new RNA(groups, buf.length)\n\n  // Mandatory factory methods: `empty`, `newBuilder`\n  // and `fromSpecific`\n  def empty: RNA = fromSeq(Seq.empty)\n\n  def newBuilder: mutable.Builder[Base, RNA] =\n    mutable.ArrayBuffer.newBuilder[Base].mapResult(fromSeq)\n\n  def fromSpecific(it: IterableOnce[Base]): RNA = it match\n    case seq: collection.Seq[Base] => fromSeq(seq)\n    case _ => fromSeq(mutable.ArrayBuffer.from(it))\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Standard Int Type Definition\nDESCRIPTION: Accesses the predefined reflection `Type` for the primitive `Int` type. It uses the imported `universe` object and navigates to `universe.definitions.IntTpe` to retrieve the standard type instance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nscala> val intTpe = universe.definitions.IntTpe\nintTpe: scala.reflect.runtime.universe.Type = Int\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Multiple Cases in Python\nDESCRIPTION: Demonstrates Python 3.10's 'match' statement matching integer 'i' against multiple literal patterns using pipe '|' as alternatives. Classifies numbers as \"odd\", \"even\", or \"too big\" based on their value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_31\n\nLANGUAGE: Python\nCODE:\n```\n# Only from Python 3.10\nmatch i:\n  case 1 | 3 | 5 | 7 | 9:\n    numAsString = \"odd\"\n  case 2 | 4 | 6 | 8 | 10:\n    numAsString = \"even\"\n  case _:\n    numAsString = \"too big\"\n```\n\n----------------------------------------\n\nTITLE: Checking and Binding Type Patterns with Scala Quasiquotes\nDESCRIPTION: Demonstrates patterns for performing type checks against scrutinees and binding variables with specified types. Includes representing a non-wildcard name combined with a type pattern as a bind pattern over a typed wildcard. Also covers construction and deconstruction of type variable patterns, requiring knowledge of Scala TypeName and quasi-quotes for types. Inputs are typed AST fragments; outputs include names and type pattern subtrees.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/pattern-details.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval isT = pq\"_: T\"\nisT: universe.Typed = (_: T)\n\nval pq\"_: $tpt\" = isT\ntpt: universe.Tree = T\n\nval fooIsT = pq\"foo: T\"\nfooIsT: universe.Bind = (foo @ (_: T))\n\nval pq\"$name @ (_: $tpt)\" = fooIsT\nname: universe.Name = foo\ntpt: universe.Tree = T\n\nval typevar = pq\"_: F[t]\"\ntypevar: universe.Typed = (_: F[(t @ <empty>)])\n\nval name = TypeName(\"t\")\nval empty = q\"\"\nval t = pq\"$name @ $empty\"\nval tpt = tq\"F[$t]\"\nval typevar = pq\"_: $tpt\"\ntypevar: universe.Typed = (_: F[(t @ _)])\n```\n\n----------------------------------------\n\nTITLE: Using Quoted Type Classes Within Generated Scala Macro Code\nDESCRIPTION: Shows how to utilize a quoted type class (`Expr[Numeric[Num]]`) within the code generated by the macro. The quoted expression (`$num`) is spliced into the generated quote, typically within a `given` definition, allowing the generated code to use the type class instance for operations defined on it (like `one` or arithmetic operators).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_33\n\nLANGUAGE: Scala\nCODE:\n```\ndef powerCode[Num: Type](x: Expr[Num], n: Int)(using num: Expr[Numeric[Num]])(using Quotes): Expr[Num] =\n  if (n == 0) '{ $num.one }\n  else if (n % 2 == 0) '{\n    given Numeric[Num] = $num\n    val y = $x * $x\n    ${ powerCode('y, n / 2) }\n  }\n  else '{\n    given Numeric[Num] = $num\n    $x * ${ powerCode(x, n - 1) }\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining another zero-argument function compatible with a higher-order method in Scala\nDESCRIPTION: Defines an additional zero-argument function `bonjourJulien` which prints a greeting message. Like `helloJoe`, it matches the function type `() => Unit` and demonstrates that any function matching the type signature can be passed to the same higher-order method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-hofs.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef bonjourJulien(): Unit = println(\"Bonjour, Julien\")\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait with Concrete Methods in Scala\nDESCRIPTION: Extends the `Showable` trait by adding a concrete method `showHtml` which utilizes the abstract `show` method. This demonstrates how traits can provide partial implementations. Shows Scala 2 and Scala 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-oop.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntrait Showable {\n  def show: String\n  def showHtml = \"<p>\" + show + \"</p>\"\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait Showable:\n  def show: String\n  def showHtml = \"<p>\" + show + \"</p>\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Function Currying in Scala\nDESCRIPTION: This example demonstrates method currying in Scala using a filter method and a modN function with multiple parameter lists. The modN function is partially applied in two filter calls to filter a list of integers by divisibility by 2 and 3 respectively.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/multiple-parameter-lists.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject CurryTest extends App {\n\n  def filter(xs: List[Int], p: Int => Boolean): List[Int] =\n    if (xs.isEmpty) xs\n    else if (p(xs.head)) xs.head :: filter(xs.tail, p)\n    else filter(xs.tail, p)\n\n  def modN(n: Int)(x: Int) = ((x % n) == 0)\n\n  val nums = List(1, 2, 3, 4, 5, 6, 7, 8)\n  println(filter(nums, modN(2)))\n  println(filter(nums, modN(3)))\n}\n```\n\n----------------------------------------\n\nTITLE: Recommended Indentation for Long Assignment with Multi-Line Method Invocation - Scala\nDESCRIPTION: Presents the preferred assignment and method invocation pattern when the assignment variable name or number of parameters leads to an overlong line. The assignment is split so the method name and arguments align for clarity. No dependencies are required; inputs include variable assignments and method calls. Output is a variable assigned from a complex function call. This style improves readability in complex code structures.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/indentation.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\n// right!\nval myLongFieldNameWithNoRealPoint =\n  foo(\n    someVeryLongFieldName,\n    andAnotherVeryLongFieldName,\n    \"this is a string\",\n    3.1415)\n```\n\n----------------------------------------\n\nTITLE: Implementing equals for cross-type comparison\nDESCRIPTION: Shows how to override the equals method in AudioBook to properly compare with PrintedBook instances, enabling meaningful cross-type equality.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-multiversal-equality.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ncase class AudioBook(\n    author: String,\n    title: String,\n    year: Int,\n    lengthInMinutes: Int\n) extends Book:\n    // override to allow AudioBook to be compared to PrintedBook\n    override def equals(that: Any): Boolean = that match\n        case a: AudioBook =>\n            this.author == a.author\n            && this.title == a.title\n            && this.year == a.year\n            && this.lengthInMinutes == a.lengthInMinutes\n        case p: PrintedBook =>\n            this.author == p.author && this.title == p.title\n        case _ =>\n            false\n\nprintln(aBook == pBook)   // true (works because of `equals` in `AudioBook`)\nprintln(pBook == aBook)   // false\n```\n\n----------------------------------------\n\nTITLE: Using Methods Without Parentheses in Scala for Field-Like Access\nDESCRIPTION: Revises the 'Complex' class methods to omit parentheses for defining parameterless methods 're' and 'im'. This enables accessing real and imaginary parts like fields without needing to call methods with '()'. This practice improves readability and idiomatic Scala usage. It requires defining methods without parentheses both in declaration and at invocation points, and is supported by Scala's syntax for parameterless methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_it/tutorials/scala-for-java-programmers.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass Complex(real: Double, imaginary: Double) {\n  def re = real\n  def im = imaginary\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dependent Method Types in Scala for a Heterogeneous Database\nDESCRIPTION: Demonstrates a heterogeneous database implementation using dependent method types, where the get method returns values of different types based on the key parameter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-dependent-function.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Key { type Value }\n\ntrait DB {\n  def get(k: Key): Option[k.Value] // a dependent method\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Service Traits for Mixin Composition in Scala 2\nDESCRIPTION: This snippet defines two service traits for illustrating mixin composition in Scala 2. GreetingService includes an abstract translate method and a concrete sayHello method, while TranslationService provides a concrete implementation of translate that returns a placeholder. These traits are building blocks for composing larger components using multiple inheritance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ntrait GreetingService {\n  def translate(text: String): String\n  def sayHello = translate(\"Hello\")\n}\n\ntrait TranslationService {\n  def translate(text: String): String = \"...\"\n}\n```\n\n----------------------------------------\n\nTITLE: Invoking Symbolic Methods (Operators) in Scala\nDESCRIPTION: Demonstrates the correct way to invoke symbolic methods (operators) using infix notation with spaces separating the target, the operator, and the parameter. Incorrect examples show missing spaces or using dot notation (`a.+(b)`), which are discouraged. Short, operator-like methods such as `max` may also commonly use infix notation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/method-invocation.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\n// right!\n\"daniel\" + \" \" + \"spiewak\"\na + b\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// wrong!\n\"daniel\"+\" \"+\"spiewak\"\na+b\na.+(b)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// fairly common\na max b\n```\n\n----------------------------------------\n\nTITLE: Using Scala Properties for Getters and Setters\nDESCRIPTION: Introduces the use of immutable references to property classes that internally manage getter and setter logic, providing a more idiomatic and safer approach to mutable state and bindings in Scala compared to explicit getter/setter methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/naming-conventions.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nclass Company {\n  val string: Property[String] = Property(\"Initial Value\")\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Generated Code into a Block and Returning Macro Expansion Result in Scala\nDESCRIPTION: Combines the precomputed vals (`evals`) and mapped format references into a sequence of statements that print each part. The `reify` method allows embedding code to print each reference. All these statements are packaged into a `Block` expression representing the macro expansion. The macro returns an expression of type `Unit` that sequentially prints formatted components.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/overview.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nval stats = evals ++ refs.map(ref => reify(print(c.Expr[Any](ref).splice)).tree)\nc.Expr[Unit](Block(stats.toList, Literal(Constant(()))))\n```\n\n----------------------------------------\n\nTITLE: Accessing Failure Projections with failed in Scala Futures\nDESCRIPTION: Shows how to use the failed projection of a Future to handle exceptional results within for-comprehensions. The failed Future yields a Throwable if the original Future failed, allowing pattern matching on exceptions or side-effectful printing. It depends on a Future that may fail. The first snippet prints a division by zero exception, while the second snippet demonstrates that no output occurs when the Future completes successfully.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/futures-promises.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nval f = Future {\n  2 / 0\n}\nfor (exc <- f.failed) println(exc)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval f = Future {\n  4 / 2\n}\nfor (exc <- f.failed) println(exc)\n```\n\n----------------------------------------\n\nTITLE: Abstract Iterator Class in Scala 2\nDESCRIPTION: Defines an abstract class AbsIterator with an abstract type T and abstract methods for iteration. This serves as the base for implementing concrete iterators.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/mixin-class-composition.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nabstract class AbsIterator {\n  type T\n  def hasNext: Boolean\n  def next(): T\n}\n```\n\n----------------------------------------\n\nTITLE: Using Promise with completeWith to Combine Futures\nDESCRIPTION: This example shows how to complete a Promise with another Future using `completeWith`, ensuring the Promise's result matches that of the succeeded Future. It simplifies composing multiple futures and propagates their result reliably.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_38\n\nLANGUAGE: Scala\nCODE:\n```\nval f = Future { 1 }\nval p = Promise[Int]()\n\np.completeWith(f)\n\np.future.foreach { x =>\n  println(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Immutability of `val` Constructor Parameters in Scala\nDESCRIPTION: Shows that primary constructor parameters declared with `val` (like `x` and `y` in the `Point` class) are public but immutable. Attempting to reassign a value to `point.x` results in a compilation error.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/classes.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass Point(val x: Int, val y: Int)\nval point = new Point(1, 2)\npoint.x = 3  // <-- does not compile\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Point(val x: Int, val y: Int)\nval point = Point(1, 2)\npoint.x = 3  // <-- does not compile\n```\n\n----------------------------------------\n\nTITLE: Clearing All Elements from Buffer in Scala\nDESCRIPTION: Removes all elements from the buffer 'buf', making it empty. This is equivalent to `buf.remove(0, buf.size)` but more concise.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/seqs.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nbuf.clear()\n```\n\n----------------------------------------\n\nTITLE: Extending Multiple Traits in a Scala Dog Class\nDESCRIPTION: Shows creating a Dog class that extends multiple traits (Speaker, TailWagger, and Runner) while implementing the required abstract method 'speak'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/traits-abstract-mixins.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass Dog(name: String) extends Speaker with TailWagger with Runner {\n    def speak(): String = \"Woof!\"\n}\n```\n\n----------------------------------------\n\nTITLE: Equivalent Anonymous Functions Using Lambda and Underscore Notation in Scala\nDESCRIPTION: Illustrates two concise syntaxes to create anonymous functions that convert strings to uppercase when mapping over a list: one with an explicit lambda parameter and one using the underscore shorthand. Shows interchangeable ways to write anonymous functions in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/passing-functions-around.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nList(\"foo\", \"bar\").map(s => s.toUpperCase)\nList(\"foo\", \"bar\").map(_.toUpperCase)\n```\n\n----------------------------------------\n\nTITLE: Parsing Key-Value Pairs Using Scala Regular Expressions with Groups\nDESCRIPTION: This snippet utilizes Scala Regex with capturing groups to extract key-value pairs from a multi-line string formatted like CSS styles. It defines a regex pattern matching keys and values separated by a colon and space. The example iterates over all matches in the input string, printing each key and corresponding value extracted from groups. Dependencies include scala.util.matching.Regex. The input is a multi-line string containing key-value pairs, and the output is printed lines with parsed keys and their values. Limitations include that values containing closing parentheses or complex nested expressions may not be fully captured as seen in 'background-image' value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/regular-expression-patterns.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.util.matching.Regex\n\nval keyValPattern: Regex = \"([0-9a-zA-Z-#() ]+): ([0-9a-zA-Z-#() ]+)\".r\n\nval input: String =\n  \"\"\"background-color: #A03300;\n    |background-image: url(img/header100.png);\n    |background-position: top center;\n    |background-repeat: repeat-x;\n    |background-size: 2160px 108px;\n    |margin: 0;\n    |height: 108px;\n    |width: 100%;\"\"\".stripMargin\n\nfor (patternMatch <- keyValPattern.findAllMatchIn(input))\n  println(s\"key: ${patternMatch.group(1)} value: ${patternMatch.group(2)}\")\n```\n\n----------------------------------------\n\nTITLE: Writing Output to Standard Error in Scala\nDESCRIPTION: Shows how to write output to standard error (STDERR) using System.err.println. This is useful for error messages that should be separated from normal output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/command-line-io.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nSystem.err.println(\"yikes, an error happened\")\n```\n\n----------------------------------------\n\nTITLE: Using Extractor Object in Value Definition - Scala\nDESCRIPTION: Demonstrates using an extractor object directly in a value definition. The `unapply` method is implicitly called on the right-hand side value (`customer2ID`), and if it successfully extracts a value, that value is assigned to the variable (`name`) on the left-hand side.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/extractor-objects.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval customer2ID = CustomerID(\"Nico\")\nval CustomerID(name) = customer2ID\nprintln(name)  // prints Nico\n```\n\n----------------------------------------\n\nTITLE: Applying Java annotation with 'value' and named argument in Scala (flexible)\nDESCRIPTION: Demonstrates the flexible syntax in Scala for applying a Java annotation with a `value` element and other elements. The `value` element can be provided positionally while other elements are specified using named arguments, offering more flexibility than the equivalent Java syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/annotations.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\n@SourceURL(\"https://coders.com/\",\n           mail = \"support@coders.com\")\nclass MyScalaClass ...\n```\n\n----------------------------------------\n\nTITLE: 名前付き関数の定義と呼び出し - Scala\nDESCRIPTION: valにラムダ関数を代入して名前付き関数とし、定義と呼び出しを示す例です。パラメーター1つの関数を定義し、呼び出し時に引数を渡して結果を出力します。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval addOne = (x: Int) => x + 1\nprintln(addOne(1)) // 2\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invariance with a Method in Scala\nDESCRIPTION: Defines a method `oneOf` that takes two invariant `Pipeline[Buyable]` instances. This illustrates why `Pipeline` must be invariant: it processes a `Buyable` input and returns a `Buyable` output. Accepting a `Pipeline[Book]` would be unsafe (might receive a non-Book `Buyable`), and accepting a `Pipeline[Item]` would also be unsafe (might return a non-`Buyable` `Item`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-variance.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 2 Version\ndef oneOf(\n  p1: Pipeline[Buyable],\n  p2: Pipeline[Buyable],\n  b: Buyable\n): Buyable = {\n  val b1 = p1.process(b)\n  val b2 = p2.process(b)\n  if (b1.price < b2.price) b1 else b2\n }\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 3 Version\ndef oneOf(\n  p1: Pipeline[Buyable],\n  p2: Pipeline[Buyable],\n  b: Buyable\n): Buyable =\n  val b1 = p1.process(b)\n  val b2 = p2.process(b)\n  if b1.price < b2.price then b1 else b2\n```\n\n----------------------------------------\n\nTITLE: 示例：不变类型参数在函数中使用（Scala 2/3）\nDESCRIPTION: 定义一个使用不变Pipeline的函数 oneOf，接受两个Pipeline[Buyable]和一个Buyable对象，演示不变性带来的类型约束，不能用子类型替代。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-variance.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef oneOf(\n  p1: Pipeline[Buyable],\n  p2: Pipeline[Buyable],\n  b: Buyable\n): Buyable = {\n  val b1 = p1.process(b)\n  val b2 = p2.process(b)\n  if (b1.price < b2.price)\n    b1\n  else\n    b2\n}\n```\n\n----------------------------------------\n\nTITLE: Using if-else Expression as Method Body in Scala\nDESCRIPTION: In Scala, `if-else` is an expression that evaluates to a value. This value can be directly used as the body of a method, implicitly returning the result of the expression.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_37\n\nLANGUAGE: Scala\nCODE:\n```\ndef min(a: Int, b: Int): Int =\n  if a < b then a else b\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Vectors in Scala\nDESCRIPTION: Examples showing how to create and use Vectors, which are immutable indexed sequences that provide fast random access and efficient element updates at all positions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval nums = Vector(1, 2, 3, 4, 5)\n\nval strings = Vector(\"one\", \"two\")\n\ncase class Person(name: String)\nval people = Vector(\n  Person(\"Bert\"),\n  Person(\"Ernie\"),\n  Person(\"Grover\")\n)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval a = Vector(1,2,3)         // Vector(1, 2, 3)\nval b = a :+ 4                // Vector(1, 2, 3, 4)\nval c = a ++ Vector(4, 5)     // Vector(1, 2, 3, 4, 5)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval a = Vector(1,2,3)         // Vector(1, 2, 3)\nval b = 0 +: a                // Vector(0, 1, 2, 3)\nval c = Vector(-1, 0) ++: a   // Vector(-1, 0, 1, 2, 3)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval names = Vector(\"Joel\", \"Chris\", \"Ed\")\n\nfor name <- names do println(name)\n```\n\n----------------------------------------\n\nTITLE: Equivalent flatMap and withFilter combinators for for-comprehension in Scala 2/3\nDESCRIPTION: Shows the explicit desugaring of the Futures for-comprehension into nested calls to 'flatMap', 'withFilter', and 'map' to clarify how the Scala compiler processes for-comprehensions involving Futures. This snippet helps understand the chaining mechanism behind composing multiple asynchronous operations with filtering and combining results.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\nval purchase = usdQuote flatMap {\n  usd =>\n    chfQuote\n      .withFilter(chf => isProfitable(usd, chf))\n      .map(chf => connection.buy(amount, chf))\n}\n```\n\n----------------------------------------\n\nTITLE: Using drop and dropRight in Scala\nDESCRIPTION: Examples of using drop and dropRight methods to remove elements from a Scala list. The examples show removing elements from the beginning and end of a list.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-methods.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\noneToTen.drop(1)        // List(2, 3, 4, 5, 6, 7, 8, 9, 10)\noneToTen.drop(5)        // List(6, 7, 8, 9, 10)\n\noneToTen.dropRight(8)   // List(1, 2)\noneToTen.dropRight(7)   // List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Testing Set Membership Using apply in Scala Set\nDESCRIPTION: Determines if a given element is present in a set using the apply method. No dependencies beyond the standard library; input is a set and an element, output is a boolean. Returns true for membership and false otherwise, as shown in Set('a', 'b', 'c')('b') and Set()('a').\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/trait-iterable.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nSet('a', 'b', 'c')('b')\n```\n\nLANGUAGE: Scala\nCODE:\n```\nSet()('a')\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Method in Scala 2\nDESCRIPTION: Shows the basic syntax for defining a method in Scala 2 using the `def` keyword, specifying parameters with types, an optional return type, and curly braces `{}` to enclose the method body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef methodName(param1: Type1, param2: Type2): ReturnType = {\n  // the method body\n  // goes here\n}\n```\n\n----------------------------------------\n\nTITLE: Function that returns another function for URL building in Scala\nDESCRIPTION: Provides a method `urlBuilder` that creates and returns a URL generation function based on SSL preference and domain name, showcasing higher-order function returning a lambda that constructs URLs dynamically.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/higher-order-functions.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ndef urlBuilder(ssl: Boolean, domainName: String): (String, String) => String = {\n  val schema = if (ssl) \"https://\" else \"http://\"\n  (endpoint: String, query: String) => s\"$schema$domainName/$endpoint?$query\"\n}\n\nval domainName = \"www.example.com\"\ndef getURL = urlBuilder(ssl=true, domainName)\nval endpoint = \"users\"\nval query = \"id=1\"\nval url = getURL(endpoint, query) // \"https://www.example.com/users?id=1\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Method Returning a Greeting Function in Scala\nDESCRIPTION: Defines a method named `greet` that returns a function. This returned function takes a `String` input and prints a greeting message to the console. The method has no parameters and returns a function of type `String => Unit`. No external dependencies are required. The input to the returned function is a name string, and the output is a side effect of printing to console.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-write-method-returns-function.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef greet(): String => Unit = \n  (name: String) => println(s\"Hello, $name\")\n```\n\n----------------------------------------\n\nTITLE: Using Mutable Queues in Scala 2\nDESCRIPTION: Demonstrates creating a mutable `Queue[String]` in Scala 2 using `new`, adding single elements with `+=`, adding multiple elements from a list with `++=`, and removing/returning the head element using `dequeue` (which modifies the queue).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-mutable-collection-classes.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nscala> val queue = new scala.collection.mutable.Queue[String]\nqueue: scala.collection.mutable.Queue[String] = Queue()\nscala> queue += \"a\"\nres10: queue.type = Queue(a)\nscala> queue ++= List(\"b\", \"c\")\nres11: queue.type = Queue(a, b, c)\nscala> queue\nres12: scala.collection.mutable.Queue[String] = Queue(a, b, c)\nscala> queue.dequeue\nres13: String = a\nscala> queue\nres14: scala.collection.mutable.Queue[String] = Queue(b, c)\n```\n\n----------------------------------------\n\nTITLE: Sending JSON Data via HTTP PATCH with sttp in Scala\nDESCRIPTION: Constructs a `ujson.Obj`, serializes it using `ujson.write`, and sends it as the body of an authenticated PATCH request to the GitHub API user endpoint (`https://api.github.com/user`) using `sttp.client4.quick`. Requires `ujson`, `sttp.client4.quick`, and a `GITHUB_TOKEN` environment variable for bearer authentication. Prints the response code (expected 200) and the full JSON response body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/http-client-json.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport sttp.client4.quick._\n\nval json = ujson.Obj(\n  \"location\" -> \"hometown\",\n  \"bio\" -> \"Scala programmer\"\n)\n\nval response = quickRequest\n  .patch(uri\"https://api.github.com/user\")\n  .auth.bearer(sys.env(\"GITHUB_TOKEN\"))\n  .header(\"Content-Type\", \"application/json\")\n  .body(ujson.write(json))\n  .send()\n\nprintln(response.code)\n// prints: 200\n\nprintln(response.body)\n// prints the full updated profile in JSON\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport sttp.client4.quick.*\n\nval json = ujson.Obj(\n  \"location\" -> \"hometown\",\n  \"bio\" -> \"Scala programmer\"\n)\n\nval response = quickRequest\n  .patch(uri\"https://api.github.com/user\")\n  .auth.bearer(sys.env(\"GITHUB_TOKEN\"))\n  .header(\"Content-Type\", \"application/json\")\n  .body(ujson.write(json))\n  .send()\n\nprintln(response.code)\n// prints: 200\n\nprintln(response.body)\n// prints the full updated profile in JSON\n```\n\n----------------------------------------\n\nTITLE: Mapping and Filtering Over Arrays - Scala\nDESCRIPTION: This snippet illustrates the use of map and filter functional methods on a Scala Array. It creates an array of integers, doubles the elements with map, and then filters to include only elements greater than 2. The methods require no explicit imports, and the inputs are arrays of integers, yielding new transformed arrays as outputs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_53\n\nLANGUAGE: Scala\nCODE:\n```\nval nums = Array(1, 2, 3, 4, 5)\nval doubledNums = nums.map(_ * 2)\nval filteredNums = nums.filter(_ > 2)\n```\n\n----------------------------------------\n\nTITLE: Explicitly Typing Accessed JSON Values in Scala with uJson\nDESCRIPTION: Explains how to explicitly cast accessed JSON values to specific Scala collection types or primitive types using dedicated uJson methods. Demonstrates casting an object to a mutable Map (`.obj`), a number to a Double (`.num`), and an array to a mutable Buffer (`.arr`). This highlights the type-casting capabilities provided by uJson.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-parse.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.mutable\n\nval jsonString = \"\"\"{\"name\": \"Peter\", \"age\": 13, \"pets\": [\"Toolkitty\", \"Scaniel\"]}\"\"\"\nval json = ujson.read(jsonString)\n\nval person: mutable.Map[String, ujson.Value] = json.obj\nval age: Double = person(\"age\").num\nval pets: mutable.Buffer[ujson.Value] = person(\"pets\").arr\n```\n\n----------------------------------------\n\nTITLE: Method Using Type Matching (Scala 3)\nDESCRIPTION: Shows how a method in Scala 3 can use a `match` expression on a `Matchable` parameter to perform type-based pattern matching, handling different types like `String`, `Int`, `Double`, and `List` using the new syntax. Requires understanding the `Matchable` trait.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_25\n\nLANGUAGE: Scala\nCODE:\n```\n// getClassAsString is a method that takes a single argument of any type.\ndef getClassAsString(x: Matchable): String = x match\n  case s: String => s\"'$s' is a String\"\n  case i: Int => \"Int\"\n  case d: Double => \"Double\"\n  case l: List[?] => \"List\"\n  case _ => \"Unknown\"\n\n// examples\ngetClassAsString(1)               // Int\ngetClassAsString(\"hello\")         // 'hello' is a String\ngetClassAsString(List(1, 2, 3))   // List\n```\n\n----------------------------------------\n\nTITLE: 変数の明示的な型指定 - Scala\nDESCRIPTION: varで宣言した変数に対し明示的にInt型の型注釈を付ける例です。Scalaの型指定の書式を維持しつつ可変性を持つ変数を定義します。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nvar x: Int = 1 + 1\n```\n\n----------------------------------------\n\nTITLE: Illustration of race conditions in concurrent updates to shared variables\nDESCRIPTION: This conceptual pseudocode explains how multiple threads can read and write to a shared variable 'sum' simultaneously, resulting in lost updates and illustrating the occurrence of race conditions during parallel execution.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/overviews/parallel-collections/overview.md#_snippet_5\n\nLANGUAGE: Pseudocode\nCODE:\n```\nHiloA: lee el valor en sum, sum = 0\nHiloB: lee el valor en sum, sum = 0\nHiloA: incrementa el valor de sum a 760, graba sum = 760\nHiloA: incrementa el valor de sum a 12, graba sum = 12\n```\n\n----------------------------------------\n\nTITLE: Defining Notification hierarchy with case classes in Scala\nDESCRIPTION: Creates an abstract class 'Notification' and three case classes 'Email', 'SMS', and 'VoiceRecording' extending it. This setup models different notification types for pattern matching in functions that process various notifications.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/pattern-matching.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Notification\n\ncase class Email(sender: String, title: String, body: String) extends Notification\n\ncase class SMS(caller: String, message: String) extends Notification\n\ncase class VoiceRecording(contactName: String, link: String) extends Notification\n```\n\n----------------------------------------\n\nTITLE: Using 'if' guards in pattern matching\nDESCRIPTION: Illustrates advanced pattern matching with 'if' expressions (guards) to match ranges or class fields, enabling conditional logic within each 'case' statement for more precise pattern matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/match-expressions.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ncount match {\n    case 1 => println(\"one, a lonely number\")\n    case x if x == 2 || x == 3 => println(\"two's company, three's a crowd\")\n    case x if x > 3 => println(\"4+, that's a party\")\n    case _ => println(\"i'm guessing your number is zero or less\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Two-Element Tuple in Scala REPL\nDESCRIPTION: Creates a tuple with two elements of different types—a String and an Int—showing how tuples can mix types in Scala. This snippet is typical REPL usage highlighting type inference and printing output. Inputs are the tuple elements, output shows the tuple content and type signature.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/tuples.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval d = (\"Maggie\", 30)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Immutable Case Class Parameters in Scala\nDESCRIPTION: This snippet defines a `case class` `Person` and shows that its parameters are immutable (`val` by default). An attempt to reassign `p.name` results in a compiler error, reinforcing the immutability principle often used with case classes for domain modeling.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/why-scala-3.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ncase class Person(name: String)\nval p = Person(\"Michael Scott\")\np.name           // Michael Scott\np.name = \"Joe\"   // compiler error (reassignment to val name)\n```\n\n----------------------------------------\n\nTITLE: Data Structures in Scala\nDESCRIPTION: Demonstrates creation and manipulation of common data structures in Scala, including tuples, lists, and ranges.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/cheatsheets/index.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n(1, 2, 3)\n```\n\nLANGUAGE: scala\nCODE:\n```\nvar (x, y, z) = (1, 2, 3)\n```\n\nLANGUAGE: scala\nCODE:\n```\nvar x, y, z = (1, 2, 3)\n```\n\nLANGUAGE: scala\nCODE:\n```\nvar xs = List(1, 2, 3)\n```\n\nLANGUAGE: scala\nCODE:\n```\nxs(2)\n```\n\nLANGUAGE: scala\nCODE:\n```\n1 :: List(2, 3)\n```\n\nLANGUAGE: scala\nCODE:\n```\n1 to 5\n```\n\nLANGUAGE: scala\nCODE:\n```\n1 until 6\n```\n\nLANGUAGE: scala\nCODE:\n```\n1 to 10 by 2\n```\n\nLANGUAGE: scala\nCODE:\n```\n()\n```\n\n----------------------------------------\n\nTITLE: 중첩 패키지 선언으로 스코프 제어 스칼라\nDESCRIPTION: 패키지를 중괄호 블록으로 중첩 선언하여 다중 네임스페이스를 구성하는 예시입니다. 이를 통해 내부 패키지들을 논리적으로 그룹화하고 스코프를 한정지어 캡슐화를 향상시킵니다. 이 예시는 두 개의 중첩된 패키지 administrators 와 normalusers 내 클래스 NormalUser를 각각 정의하여 네임스페이스 충돌 방지와 코드 관리에 도움을 줍니다.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/packages-and-imports.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\npackage users {\n  package administrators {\n    class NormalUser\n  }\n  package normalusers {\n    class NormalUser\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using 'given' instances in generic method in Scala\nDESCRIPTION: Defines a generic method 'genericMonthConverter' that requires a 'given' MonthConverter for type A, utilizing the imported 'given' instances to perform conversions. Demonstrates how 'using' context parameters incorporate 'given' instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/packaging-imports.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\ndef genericMonthConverter[A](a: A)(using monthConverter: MonthConverter[A]): String =\n  monthConverter.convert(a)\n```\n\n----------------------------------------\n\nTITLE: Defining covariant, contravariant, and invariant classes in Scala\nDESCRIPTION: This snippet defines three Scala classes demonstrating variance annotations: a covariant class (+A), a contravariant class (-A), and an invariant class (A). These serve as foundational examples for understanding variance syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/variances.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass Foo[+A] // kovarijantna klasa\nclass Bar[-A] // kontravarijantna klasa\nclass Baz[A]  // invarijantna klasa\n```\n\n----------------------------------------\n\nTITLE: Handling Parameterized Constructors in Inheritance in Scala\nDESCRIPTION: Illustrates how a subclass `C` must call the constructor of its superclass `D` during its own construction, especially when the superclass has parameters. The parameters are passed using `extends D(x)`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/cheatsheets/index.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nclass D(var x: R)\nclass C(x: R) extends D(x)\n```\n\n----------------------------------------\n\nTITLE: Defining a Method with Multiple Parameter Lists in Scala\nDESCRIPTION: Demonstrates advanced method syntax where methods accept multiple groups of parameters (currying). Such constructs facilitate partial application and implicit parameters in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\ndef addThenMultiply(x: Int, y: Int)(multiplier: Int): Int = (x + y) * multiplier\nprintln(addThenMultiply(1, 2)(3)) // 9\n```\n\n----------------------------------------\n\nTITLE: Chaining Extension Methods for Pizza Operations in Scala\nDESCRIPTION: Demonstrates how the defined extension methods can be chained on a Pizza instance for concise and expressive updates: adding a topping, changing crust type, and obtaining the price. Assumes prior definitions of Pizza, CrustSize, CrustType, Topping, and the extension methods, and illustrates expressive method chaining enabled by extension methods. Input must be valid enum values for Pizza and available toppings; output is the result (e.g., price) after applying transformations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-fp.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\nPizza(Small, Thin, Seq(Cheese))\n  .addTopping(Pepperoni)\n  .updateCrustType(Thick)\n  .price\n```\n\n----------------------------------------\n\nTITLE: Creating List Instance in Scala\nDESCRIPTION: Shows the concise syntax for creating a new instance of the immutable Scala List class with initial elements. The `List` constructor is used directly with parenthesized values. This demonstrates a common way to initialize collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/why-scala-3.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval x = List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Defining a Multi-line Method in Scala 3\nDESCRIPTION: Uses Scala 3's optional braces and indentation-based syntax for multi-line method bodies. Shows assignment and conversion logic in a style preferred in Scala 3 codebases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\ndef getSquareString(input: Double): String =\n  val square = input * input\n  square.toString\n\nprintln(getSquareString(2.5)) // 6.25\n```\n\n----------------------------------------\n\nTITLE: Matching values in scope in Scala 3\nDESCRIPTION: Demonstrates Scala 3's syntax for matching against existing values in scope within a match expression. Uppercase-named variables are treated as constants to match against.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nval N = 42\ni match\n  case 0 => println(\"1\")\n  case 1 => println(\"2\")\n  case N => println(\"42\")\n  case n => println(s\"You gave me: $n\" )\n```\n\n----------------------------------------\n\nTITLE: Using 'foldLeft2' with Implicit Parameters for Type Inference in Scala\nDESCRIPTION: This code demonstrates defining 'foldLeft2', where the function takes two parameter lists, facilitating type inference of 'A' and 'B' for the collection and initial value. When invoked with 'numbers' and a lambda '_ + _', Scala infers types without explicit annotations. Dependencies include implicit parameters in Scala. Inputs are list and lambda; output is the fold result.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/multiple-parameter-lists.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef foldLeft2[A, B](as: List[A], b0: B)(op: (B, A) => B) = ???\nval possible = foldLeft2(numbers, 0)(_ + _)\n```\n\n----------------------------------------\n\nTITLE: Using a Generic Reference Container with Integer Type in Scala\nDESCRIPTION: Provides an example Scala object IntegerReference containing a main method that demonstrates the usage of the generic Reference class instantiated with Int as the type parameter. It creates a Reference[Int] object, sets its value to 13, and prints a calculation that doubles the contained integer. This snippet shows how generic classes enable type-safe usage without the need for explicit casting in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-tw/tutorials/scala-for-java-programmers.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nobject IntegerReference {\n  def main(args: Array[String]): Unit = {\n    val cell = new Reference[Int]\n    cell.set(13)\n    println(\"Reference contains the half of \" + (cell.get * 2))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Generic Reference with Integer Type in Scala\nDESCRIPTION: Shows how to instantiate and use a generic Reference class with a specific type (Int). Demonstrates type-safety and the absence of explicit type casting when using generics in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tutorials/scala-for-java-programmers.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nobject ReferenceEntier {\n  def main(args: Array[String]): Unit = {\n    val cellule = new Reference[Int]\n    cellule.set(13)\n    println(\"La référence contient la moitié de \" + (cellule.get * 2))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing a PetOwner object to JSON in Scala\nDESCRIPTION: This comprehensive example creates a `PetOwner` instance and serializes it into JSON using `write`. It demonstrates how automatic derivation eases the process of encoding custom objects, with output matching the object’s fields in JSON format. Suitable for both Scala 2 and 3 depending on the derivation method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-serialize.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport upickle.default._\n\ncase class PetOwner(name: String, pets: List[String])\nimplicit val ownerRw: ReadWriter[PetOwner] = macroRW\n\nval petOwner = PetOwner(\"Peter\", List(\"Toolkitty\", \"Scaniel\"))\nval json: String = write(petOwner)\nprintln(json)\n// prints: {\"name\":\"Peter\",\"pets\":[\"Toolkitty\",\"Scaniel\"]}\n```\n\n----------------------------------------\n\nTITLE: Executing a Parameterless Function Multiple Times in Scala\nDESCRIPTION: Defines a Scala method named `executeNTimes` that takes a parameterless function `f` of type `() => Unit` and an integer `n`, executing `f` exactly `n` times. It employs a simple `for` loop to repeat the execution and returns `Unit` since the loop produces no meaningful return value. Designed to work with Scala 2 and Scala 3 syntax variants.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-hofs.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\ndef executeNTimes(f: () => Unit, n: Int): Unit =\n  for (i <- 1 to n) f()\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef executeNTimes(f: () => Unit, n: Int): Unit =\n  for i <- 1 to n do f()\n```\n\n----------------------------------------\n\nTITLE: Using Enumerations in a Pizza Case Class\nDESCRIPTION: Defines a `Pizza` case class that uses the previously declared enumeration traits as its properties for crust size, crust type, and toppings, illustrating how to incorporate enums into data models.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/case-objects.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Pizza (\n    crustSize: CrustSize,\n    crustType: CrustType,\n    toppings: Seq[Topping]\n)\n```\n\n----------------------------------------\n\nTITLE: Creating an implicit class in Scala\nDESCRIPTION: This snippet shows how to define an implicit class within an object, adding a new method `times` to the Int type. The implicit class provides a way to extend existing types with custom functionality that activates via implicit conversions once imported into scope.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/implicit-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject Helpers {\n  implicit class IntWithTimes(x: Int) {\n    def times[A](f: => A): Unit = {\n      def loop(current: Int): Unit =\n        if(current > 0) {\n          f\n          loop(current - 1)\n        }\n      loop(x)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Scala Applications Using Scala CLI - shell\nDESCRIPTION: This snippet demonstrates how to compile and run a Scala application using Scala CLI through the shell. It shows the usage pattern for passing application arguments using '--' to differentiate Scala CLI options from program arguments, enabling flexible runtime parameterization.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/scala-cli.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nscala-cli MyApp.scala -- first-arg second-arg\n```\n\n----------------------------------------\n\nTITLE: Accessing the default value in match expressions in Scala 2\nDESCRIPTION: Shows how to bind the default value to a variable in a match expression, allowing you to use that value in the result expression or statement.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\ni match {\n  case 0 => println(\"1\")\n  case 1 => println(\"2\")\n  case what => println(s\"You gave me: $what\")\n}\n```\n\n----------------------------------------\n\nTITLE: Obtaining Builders and Factory Methods in IterableOps and IterableFactory - Scala 3\nDESCRIPTION: In Scala 3, IterableOps and IterableFactory traits provide methods for both strict and non-strict collection construction. FromSpecific and newSpecificBuilder enable producing type-preserving collections and builders, while newBuilder supports creation of builders for collections with possibly different element types. It relies on the Builder trait for strict evaluation approaches.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_26\n\nLANGUAGE: Scala\nCODE:\n```\ntrait IterableOps[+A, +CC[_], +C]:\n  def iterableFactory: IterableFactory[CC]\n  protected def fromSpecific(coll: IterableOnce[A]): C\n  protected def newSpecificBuilder: Builder[A, C]\n\ntrait IterableFactory[+CC[_]]:\n  def from[A](source: IterableOnce[A]): CC[A]\n  def newBuilder[A]: Builder[A, CC[A]]\n```\n\n----------------------------------------\n\nTITLE: パラメーターなしメソッドの定義と使用 - Scala\nDESCRIPTION: 引数リストなしで戻り値を返すメソッドの例です。Javaシステムプロパティからユーザー名を取得し、その文字列値を利用し出力しています。パラメーター括弧なしの呼び出しも特徴です。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ndef name: String = System.getProperty(\"user.name\")\nprintln(\"Hello, \" + name + \"!\")\n```\n\n----------------------------------------\n\nTITLE: Proposed Explicit `@` Binding in Alternative Patterns in Scala\nDESCRIPTION: Shows how the proposed feature would allow explicit variable binding using `@` within alternative patterns. The variable `x` is bound either via pattern deconstruction `Baz(x)` or directly to an instance `Bar()` using `x @ Bar()`, resulting in `x` having the type `Foo.Bar` (assuming `Baz` holds a `Bar`). The variable `x` must be bound in all alternatives.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/alternative-bind-variables.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nenum Foo:\n  case Bar()\n  case Baz(bar: Bar)\n\n  def fun = this match\n    case Baz(x) | x @ Bar() => ... // x: Foo.Bar\n```\n\n----------------------------------------\n\nTITLE: Replacing and Cloning Elements in a Mutable Buffer in Scala\nDESCRIPTION: Demonstrates how to replace a segment of the buffer in-place or clone the entire buffer using patchInPlace and clone. Requires a mutable Buffer and source collection for patching; patchInPlace accepts a start index, replacement elements, and a count of how many elements to replace. clone creates a new buffer with identical contents. Outputs are either the mutated original buffer or a new buffer copy. Both methods are useful for managing buffer content and state.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/seqs.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nbuf.patchInPlace(i, xs, n)\nbuf.clone()\n```\n\n----------------------------------------\n\nTITLE: Restricting Visibility of Constructors in Value Classes vs Opaque Types in Scala\nDESCRIPTION: Compares visibility control of constructors and accessors between opaque types and value classes by defining an opaque type XCoord and a value class YCoord with private[pkg] constructor and value. It explains that both require public factory methods for external usage, and notes that opaque types have better default information-hiding behavior due to their nature versus value classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/opaque-types.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\npackage object pkg {\n  opaque type XCoord = Int\n\n  case class private[pkg] YCoord (private[pkg] val n: Int) extends AnyVal\n\n  // in both cases, we'd need public factory constructors\n  // to allow users to produce values of these types.\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NamedTuple and NamedTupleDecomposition Objects in Scala\nDESCRIPTION: This Scala code defines the experimental `NamedTuple` feature within the `scala` package. It includes the `NamedTuple` object containing opaque type definitions (`AnyNamedTuple`, `NamedTuple`), factory/extractor methods (`apply`, `unapply`), extension methods providing tuple-like operations (`toTuple`, `size`, `apply`, `head`, `tail`, `map`, `zip`, etc.) while preserving names, and type aliases for compile-time manipulation (`Size`, `Elem`, `Head`, `Tail`, `Concat`, `Map`, `Zip`, etc.). It also defines the `NamedTupleDecomposition` object with type helpers (`Names`, `DropNames`) to extract name and value types. Depends on `scala.annotation.experimental` and `scala.compiletime.ops.boolean`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-tuples.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\npackage scala\nimport annotation.experimental\nimport compiletime.ops.boolean.*\n\n@experimental\nobject NamedTuple:\n\n  opaque type AnyNamedTuple = Any\n  opaque type NamedTuple[N <: Tuple, +V <: Tuple] >: V <: AnyNamedTuple = V\n\n  def apply[N <: Tuple, V <: Tuple](x: V): NamedTuple[N, V] = x\n\n  def unapply[N <: Tuple, V <: Tuple](x: NamedTuple[N, V]): Some[V] = Some(x)\n\n  extension [V <: Tuple](x: V)\n    inline def withNames[N <: Tuple]: NamedTuple[N, V] = x\n\n  export NamedTupleDecomposition.{Names, DropNames}\n\n  extension [N <: Tuple, V <: Tuple](x: NamedTuple[N, V])\n\n    /** The underlying tuple without the names */\n    inline def toTuple: V = x\n\n    /** The number of elements in this tuple */\n    inline def size: Tuple.Size[V] = toTuple.size\n\n    // This intentionally works for empty named tuples as well. I think NnEmptyTuple is a dead end\n    // and should be reverted, justy like NonEmptyList is also appealing at first, but a bad idea\n    // in the end.\n\n    /** The value (without the name) at index `n` of this tuple */\n    inline def apply(n: Int): Tuple.Elem[V, n.type] =\n      inline toTuple match\n        case tup: NonEmptyTuple => tup(n).asInstanceOf[Tuple.Elem[V, n.type]]\n        case tup => tup.productElement(n).asInstanceOf[Tuple.Elem[V, n.type]]\n\n    /** The first element value of this tuple */\n    inline def head: Tuple.Elem[V, 0] = apply(0)\n\n    /** The tuple consisting of all elements of this tuple except the first one */\n    inline def tail: Tuple.Drop[V, 1] = toTuple.drop(1)\n\n    /** The last element value of this tuple */\n    inline def last: Tuple.Last[V] = apply(size - 1).asInstanceOf[Tuple.Last[V]]\n\n    /** The tuple consisting of all elements of this tuple except the last one */\n    inline def init: Tuple.Init[V] = toTuple.take(size - 1).asInstanceOf[Tuple.Init[V]]\n\n    /** The tuple consisting of the first `n` elements of this tuple, or all\n     *  elements if `n` exceeds `size`.\n     */\n    inline def take(n: Int): NamedTuple[Tuple.Take[N, n.type], Tuple.Take[V, n.type]] =\n      toTuple.take(n)\n\n    /** The tuple consisting of all elements of this tuple except the first `n` ones,\n     *  or no elements if `n` exceeds `size`.\n     */\n    inline def drop(n: Int): NamedTuple[Tuple.Drop[N, n.type], Tuple.Drop[V, n.type]] =\n      toTuple.drop(n)\n\n    /** The tuple `(x.take(n), x.drop(n))` */\n    inline def splitAt(n: Int): NamedTuple[Tuple.Split[N, n.type], Tuple.Split[V, n.type]] =\n      toTuple.splitAt(n)\n\n    /** The tuple consisting of all elements of this tuple followed by all elements\n     *  of tuple `that`. The names of the two tuples must be disjoint.\n     */\n    inline def ++ [N2 <: Tuple, V2 <: Tuple](that: NamedTuple[N2, V2])(using Tuple.Disjoint[N, N2] =:= true)\n      : NamedTuple[Tuple.Concat[N, N2], Tuple.Concat[V, V2]]\n      = toTuple ++ that.toTuple\n\n    // inline def :* [L] (x: L): NamedTuple[Append[N, ???], Append[V, L] = ???\n    // inline def *: [H] (x: H): NamedTuple[??? *: N], H *: V] = ???\n\n    /** The named tuple consisting of all element values of this tuple mapped by\n     *  the polymorphic mapping function `f`. The names of elements are preserved.\n     *  If `x = (n1 = v1, ..., ni = vi)` then `x.map(f) = `(n1 = f(v1), ..., ni = f(vi))`.\n     */\n    inline def map[F[_]](f: [t] => t => F[t]): NamedTuple[N, Tuple.Map[V, F]] =\n      toTuple.map(f).asInstanceOf[NamedTuple[N, Tuple.Map[V, F]]]\n\n    /** The named tuple consisting of all elements of this tuple in reverse */\n    inline def reverse: NamedTuple[Tuple.Reverse[N], Tuple.Reverse[V]] =\n      toTuple.reverse\n\n    /** The named tuple consisting of all elements values of this tuple zipped\n     *  with corresponding element values in named tuple `that`.\n     *  If the two tuples have different sizes,\n     *  the extra elements of the larger tuple will be disregarded.\n     *  The names of `x` and `that` at the same index must be the same.\n     *  The result tuple keeps the same names as the operand tuples.\n     */\n    inline def zip[V2 <: Tuple](that: NamedTuple[N, V2]): NamedTuple[N, Tuple.Zip[V, V2]] =\n      toTuple.zip(that.toTuple)\n\n    /** A list consisting of all element values */\n    inline def toList: List[Tuple.Union[V]] = toTuple.toList.asInstanceOf[List[Tuple.Union[V]]]\n\n    /** An array consisting of all element values */\n    inline def toArray: Array[Object] = toTuple.toArray\n\n    /** An immutable array consisting of all element values */\n    inline def toIArray: IArray[Object] = toTuple.toIArray\n\n  end extension\n\n  /** The size of a named tuple, represented as a literal constant subtype of Int */\n  type Size[X <: AnyNamedTuple] = Tuple.Size[DropNames[X]]\n\n  /** The type of the element value at position N in the named tuple X */\n  type Elem[X <: AnyNamedTuple, N <: Int] = Tuple.Elem[DropNames[X], N]\n\n  /** The type of the first element value of a named tuple */\n  type Head[X <: AnyNamedTuple] = Elem[X, 0]\n\n  /** The type of the last element value of a named tuple */\n  type Last[X <: AnyNamedTuple] = Tuple.Last[DropNames[X]]\n\n  /** The type of a named tuple consisting of all elements of named tuple X except the first one */\n  type Tail[X <: AnyNamedTuple] = Drop[X, 1]\n\n  /** The type of the initial part of a named tuple without its last element */\n  type Init[X <: AnyNamedTuple] =\n    NamedTuple[Tuple.Init[Names[X]], Tuple.Init[DropNames[X]]]\n\n  /** The type of the named tuple consisting of the first `N` elements of `X`,\n   *  or all elements if `N` exceeds `Size[X]`.\n   */\n  type Take[X <: AnyNamedTuple, N <: Int] =\n    NamedTuple[Tuple.Take[Names[X], N], Tuple.Take[DropNames[X], N]]\n\n  /** The type of the named tuple consisting of all elements of `X` except the first `N` ones,\n   *  or no elements if `N` exceeds `Size[X]`.\n   */\n  type Drop[X <: AnyNamedTuple, N <: Int] =\n    NamedTuple[Tuple.Drop[Names[X], N], Tuple.Drop[DropNames[X], N]]\n\n  /** The pair type `(Take(X, N), Drop[X, N]). */\n  type Split[X <: AnyNamedTuple, N <: Int] = (Take[X, N], Drop[X, N])\n\n  /** Type of the concatenation of two tuples `X` and `Y` */\n  type Concat[X <: AnyNamedTuple, Y <: AnyNamedTuple] =\n    NamedTuple[Tuple.Concat[Names[X], Names[Y]], Tuple.Concat[DropNames[X], DropNames[Y]]]\n\n  /** The type of the named tuple `X` mapped with the type-level function `F`.\n   *  If `X = (n1 : T1, ..., ni : Ti)` then `Map[X, F] = `(n1 : F[T1], ..., ni : F[Ti])`.\n   */\n  type Map[X <: AnyNamedTuple, F[_ <: Tuple.Union[DropNames[X]]]] =\n    NamedTuple[Names[X], Tuple.Map[DropNames[X], F]]\n\n  /** A named tuple with the elements of tuple `X` in reversed order */\n  type Reverse[X <: AnyNamedTuple] =\n    NamedTuple[Tuple.Reverse[Names[X]], Tuple.Reverse[DropNames[X]]]\n\n  /** The type of the named tuple consisting of all element values of\n   *  named tuple `X` zipped with corresponding element values of\n   *  named tuple `Y`. If the two tuples have different sizes,\n   *  the extra elements of the larger tuple will be disregarded.\n   *  The names of `X` and `Y` at the same index must be the same.\n   *  The result tuple keeps the same names as the operand tuples.\n   *  For example, if\n   *  ```\n   *     X = (n1 : S1, ..., ni : Si)\n   *     Y = (n1 : T1, ..., nj : Tj)  where j >= i\n   *  ```\n   *  then\n   *  ```\n   *     Zip[X, Y] = (n1 : (S1, T1), ..., ni: (Si, Ti))\n   *  ```\n   *  @syntax markdown\n   */\n  type Zip[X <: AnyNamedTuple, Y <: AnyNamedTuple] =\n    Tuple.Conforms[Names[X], Names[Y]] match\n      case true =>\n        NamedTuple[Names[X], Tuple.Zip[DropNames[X], DropNames[Y]]]\n\n  type From[T] <: AnyNamedTuple\n\nend NamedTuple\n\n/** Separate from NamedTuple object so that we can match on the opaque type NamedTuple. */\n@experimental\nobject NamedTupleDecomposition:\n  import NamedTuple.*\n\n  /** The names of a named tuple, represented as a tuple of literal string values. */\n  type Names[X <: AnyNamedTuple] <: Tuple = X match\n    case NamedTuple[n, _] => n\n\n  /** The value types of a named tuple represented as a regular tuple. */\n  type DropNames[NT <: AnyNamedTuple] <: Tuple = NT match\n    case NamedTuple[_, x] => x\n\n```\n\n----------------------------------------\n\nTITLE: 暗黙の変換によるArrayOpsとWrappedArrayの比較例 - Scala\nDESCRIPTION: この例は、Scalaにおける配列への二種類の暗黙的変換、WrappedArrayとArrayOpsの違いを示しています。Seq型のWrappedArrayはreverse操作でSeqを返しますが、ArrayOpsはArrayを返します。暗黙の変換はそれぞれ異なる優先順位で解決され、配列のメソッド呼び出しで自動的に適用されます。Scala標準の暗黙の変換機能を利用して比較が可能です。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/arrays.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval seq: Seq[Int] = a1\nseq.reverse\nval ops: collection.mutable.ArrayOps[Int] = a1\nops.reverse\n```\n\n----------------------------------------\n\nTITLE: Multi-line Structural Type Declaration in Scala\nDESCRIPTION: Shows the proper way to format complex structural types using a type alias when they exceed 50 characters, improving readability and maintainability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/types.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\n// wrong!\ndef foo(a: { def bar(a: Int, b: Int): String; val baz: List[String => String] }) = ...\n\n// right!\nprivate type FooParam = {\n  val baz: List[String => String]\n  def bar(a: Int, b: Int): String\n}\n\ndef foo(a: FooParam) = ...\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Interface with Abstract Methods in Java\nDESCRIPTION: A simple Java interface declares methods that implementing classes must provide a concrete implementation for. Methods are abstract by default.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_20\n\nLANGUAGE: Java\nCODE:\n```\npublic interface Adder {\n  public int add(int a, int b);\n}\n```\n\n----------------------------------------\n\nTITLE: Organizing Data and Operations with Companion Objects in Scala\nDESCRIPTION: Shows how to define case classes and enumerations (`Pizza`, `Topping`) alongside their companion objects. The companion objects are used to group related functionality, such as the `price` calculation functions, associating the operations directly with the data types they operate on. Requires the data types (`Pizza`, `Topping`, `CrustSize`, `CrustType`) and the price functions (or placeholders like `...`) to be defined.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-fp.md#_snippet_7\n\nLANGUAGE: Scala 2\nCODE:\n```\ncase class Pizza(\n  crustSize: CrustSize,\n  crustType: CrustType,\n  toppings: Seq[Topping]\n)\n\n// the companion object of case class Pizza\nobject Pizza {\n  // the implementation of `pizzaPrice` from above\n  def price(p: Pizza): Double = ...\n}\n\nsealed abstract class Topping\n\n// the companion object of enumeration Topping\nobject Topping {\n  case object Cheese extends Topping\n  case object Pepperoni extends Topping\n  case object BlackOlives extends Topping\n  case object GreenOlives extends Topping\n  case object Onions extends Topping\n\n  // the implementation of `toppingPrice` above\n  def price(t: Topping): Double = ...\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ncase class Pizza(\n  crustSize: CrustSize,\n  crustType: CrustType,\n  toppings: Seq[Topping]\n)\n\n// the companion object of case class Pizza\nobject Pizza:\n  // the implementation of `pizzaPrice` from above\n  def price(p: Pizza): Double = ...\n\nenum Topping:\n  case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions\n\n// the companion object of enumeration Topping\nobject Topping:\n  // the implementation of `toppingPrice` above\n  def price(t: Topping): Double = ...\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Patterns per Case in Scala match Expressions\nDESCRIPTION: Demonstrates using the `|` operator within `case` statements to match multiple possible values for a single outcome. This example groups odd and even numbers within a specific range (1-10) using multi-pattern cases. Shows syntax for Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_25\n\nLANGUAGE: Scala 2\nCODE:\n```\nval evenOrOdd = i match {\n  case 1 | 3 | 5 | 7 | 9 => println(\"odd\")\n  case 2 | 4 | 6 | 8 | 10 => println(\"even\")\n  case _ => println(\"some other number\")\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nval evenOrOdd = i match\n  case 1 | 3 | 5 | 7 | 9 => println(\"odd\")\n  case 2 | 4 | 6 | 8 | 10 => println(\"even\")\n  case _ => println(\"some other number\")\n```\n\n----------------------------------------\n\nTITLE: Combined Iterator Implementation in Scala 3\nDESCRIPTION: Creates a class in Scala 3 syntax that combines StringIterator with RichIterator using comma syntax for multiple inheritance, showing how to apply object composition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/mixin-class-composition.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nclass RichStringIter extends StringIterator(\"Scala\"), RichIterator\nval richStringIter = RichStringIter()\nrichStringIter.foreach(println)\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic sbt Scala Project - Bash Commands\nDESCRIPTION: This snippet includes the bash shell commands required to create a basic sbt project directory and a subdirectory called 'project'. It demonstrates initializing the workspace for a new Scala project by creating directories where build and project configuration files will reside. These steps prepare the folder structure prior to adding configuration files and source code. These commands require a Unix-like shell environment.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ mkdir hello\n$ cd hello\n```\n\n----------------------------------------\n\nTITLE: Rewriting `Lambda` keyword to `λ` (Scala 2/3)\nDESCRIPTION: Demonstrates replacing the unsupported `Lambda` keyword with the `λ` symbol. This `λ` syntax provides the same functionality and is supported by both Scala 2 (with kind-projector) and Scala 3 (with `-Ykind-projector`), enabling cross-compilation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/plugin-kind-projector.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nλ[(`+E`, `+A`) => Either[E, A]]\n```\n\n----------------------------------------\n\nTITLE: Adding Elements to ArrayBuffer in Scala\nDESCRIPTION: Illustrates multiple ways to add single or multiple elements to an ArrayBuffer using '+=' and '++=' operators, including adding from collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/arraybuffer-examples.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval ints = ArrayBuffer[Int]()\nints += 1\nints += 2\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval nums = ArrayBuffer(1, 2, 3)\n// add one element\nnums += 4\n// add multiple elements\nnums += 5 += 6\n// add multiple from another collection\nnums ++= List(7, 8, 9)\n```\n\n----------------------------------------\n\nTITLE: Inspecting Maven Project Classpath and Dependency Updates in Shell\nDESCRIPTION: This snippet combines shell commands for Maven to build the classpath ('mvn dependency:build-classpath') and display available dependency updates ('mvn versions:display-dependency-updates'). These commands require Maven and a defined pom.xml file. The first outputs the resolved classpath as a colon-separated list of JARs; the second lists newer available versions for current dependencies. Useful for tracking outdated libraries and binary compatibility risks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/drop-stdlib-forwards-bin-compat.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\n$> mvn dependency:build-classpath\n[INFO] --- maven-dependency-plugin:2.8:build-classpath (default-cli) @ proj ---\n[INFO] Dependencies classpath:\n/Users/luc/.m2/repository/org/scala-lang/scala-library/2.13.8/scala-library-2.13.8.jar:/Users/luc/.m2/repository/com/softwaremill/sttp/client3/core_2.13/3.8.3/core_2.13-3.8.3.jar:/Users/luc/.m2/repository/com/softwaremill/sttp/model/core_2.13/1.5.2/core_2.13-1.5.2.jar:/Users/luc/.m2/repository/com/softwaremill/sttp/shared/core_2.13/1.3.10/core_2.13-1.3.10.jar:/Users/luc/.m2/repository/com/softwaremill/sttp/shared/ws_2.13/1.2.7/ws_2.13-1.2.7.jar\n$> mvn versions:display-dependency-updates\n[INFO] --- versions-maven-plugin:2.13.0:display-dependency-updates (default-cli) @ proj ---\n[INFO] The following dependencies in Dependencies have newer versions:\n[INFO]   com.softwaremill.sttp.client3:core_2.13 ............... 3.8.3 -> 3.8.5\n[INFO]   com.softwaremill.sttp.shared:ws_2.13 ................. 1.2.7 -> 1.3.12\n[INFO]   org.scala-lang:scala-library ....................... 2.13.8 -> 2.13.10\n```\n\n----------------------------------------\n\nTITLE: Exporting and Publishing PGP Keys - Bash\nDESCRIPTION: These Bash commands help list existing secret PGP keys, export a private key in base64 encoding for storage in CI secrets, and export the public key for public distribution. The commands are compatible with various OS environments including macOS, Ubuntu, Arch, FreeBSD, and Windows, and require gpg and base64 (or equivalent) utilities. Key parameter LONG_ID (or %LONG_ID%) must be set to your key's ID. Outputs are base64-encoded secret keys and ASCII-armored public keys; these are required for artifact signing and deployment in CI pipelines.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngpg --list-secret-keys\n```\n\nLANGUAGE: bash\nCODE:\n```\ngpg --armor --export-secret-keys $LONG_ID | base64\n```\n\nLANGUAGE: bash\nCODE:\n```\ngpg --armor --export-secret-keys $LONG_ID | base64 -w0\n```\n\nLANGUAGE: bash\nCODE:\n```\ngpg --armor --export-secret-keys $LONG_ID | base64 | sed -z 's;\\n;;g'\n```\n\nLANGUAGE: bash\nCODE:\n```\ngpg --armor --export-secret-keys $LONG_ID | base64\n```\n\nLANGUAGE: bash\nCODE:\n```\ngpg --armor --export-secret-keys %LONG_ID% | openssl base64\n```\n\nLANGUAGE: bash\nCODE:\n```\ngpg --armor --export $LONG_ID\n```\n\nLANGUAGE: bash\nCODE:\n```\ngpg --armor --export %LONG_ID%\n```\n\n----------------------------------------\n\nTITLE: Instantiating Cat Class\nDESCRIPTION: Creates an instance of the `Cat` class. This instance is used in a subsequent step to show how type reflection identifies the specific type of an object, even if it's assigned to a superclass variable (though the example uses a `val c: Cat`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nscala> val c = new Cat\nc: Cat = Cat@2302d72d\n```\n\n----------------------------------------\n\nTITLE: Creating a Tuple in Scala\nDESCRIPTION: Demonstrates how to create a tuple with two elements using Scala syntax, inferring types, and understanding tuple classes for fixed-size collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/tuples.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval ingredient = (\"Sugar\", 25)\n```\n\n----------------------------------------\n\nTITLE: Creating a for-expression that yields values in Scala 3\nDESCRIPTION: Shows a for-expression in Scala 3 syntax that iterates through a range and yields transformed values, demonstrating the optional parentheses in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval list =\n  for i <- 10 to 12\n  yield i * 2\n\n// list: IndexedSeq[Int] = Vector(20, 22, 24)\n```\n\n----------------------------------------\n\nTITLE: Define a Mutable PrefixMap Class in Scala using Patricia Trie\nDESCRIPTION: Implements a generic mutable map `PrefixMap[T]` with String keys using a Patricia Trie structure. It extends `mutable.Map[String, T]` and `mutable.MapLike[String, T, PrefixMap[T]]` for integration with the Scala collections framework. Key features include storing suffixes in an immutable map for efficiency with small sub-maps, an optional value at each node, and methods for getting (`get`), updating (`update`), removing (`remove`), iterating (`iterator`), adding (`+=`), subtracting (`-=`), finding sub-maps by prefix (`withPrefix`), and creating an empty instance (`empty`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/architecture-of-scala-collections.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nimport collection._\n\nclass PrefixMap[T]\nextends mutable.Map[String, T]\n   with mutable.MapLike[String, T, PrefixMap[T]] {\n\n  var suffixes: immutable.Map[Char, PrefixMap[T]] = Map.empty\n  var value: Option[T] = None\n\n  def get(s: String): Option[T] =\n    if (s.isEmpty) value\n    else suffixes get (s(0)) flatMap (_.get(s substring 1))\n\n  def withPrefix(s: String): PrefixMap[T] =\n    if (s.isEmpty) this\n    else {\n      val leading = s(0)\n      suffixes get leading match {\n        case None =>\n          suffixes = suffixes + (leading -> empty)\n        case _ =>\n      }\n      suffixes(leading) withPrefix (s substring 1)\n    }\n\n  override def update(s: String, elem: T) =\n    withPrefix(s).value = Some(elem)\n\n  override def remove(s: String): Option[T] =\n    if (s.isEmpty) { val prev = value; value = None; prev }\n    else suffixes get (s(0)) flatMap (_.remove(s substring 1))\n\n  def iterator: Iterator[(String, T)] =\n    (for (v <- value.iterator) yield (\"\", v)) ++\n    (for ((chr, m) <- suffixes.iterator;\n          (s, v) <- m.iterator) yield (chr +: s, v))\n\n  def += (kv: (String, T)): this.type = { update(kv._1, kv._2); this }\n\n  def -= (s: String): this.type = { remove(s); this }\n\n  override def empty = new PrefixMap[T]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing cache functionality manually in Scala\nDESCRIPTION: Shows how to manually implement the same caching functionality using basic Map operations instead of getOrElseUpdate. This demonstrates the pattern matching approach to check for existing values in the cache.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/maps.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef cachedF(arg: String) = cache get arg match {\n  case Some(result) => result\n  case None =>\n    val result = f(x)\n    cache(arg) = result\n    result\n}\n```\n\n----------------------------------------\n\nTITLE: Using nested packages with package clauses in Scala 3\nDESCRIPTION: Demonstrates nested package definitions in Scala 3 syntax using colons and indentation, facilitating scope control and modular structure within a single file.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/packaging-imports.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\npackage users:\n\n  package administrators:  // the full name of this package is users.administrators\n    class AdminUser        // the full name of this class is users.administrators.AdminUser\n\n  package normalusers:     // the full name of this package is users.normalusers\n    class NormalUser       // the full name of this class is users.normalusers.NormalUser\n```\n\n----------------------------------------\n\nTITLE: Filtered for Generator Using if Guards in Scala\nDESCRIPTION: Shows a Scala for expression with two 'if' guards filtering iterations over 1 to 10 range to include only even numbers less than 5, printing each selected 'i'. Demonstrates idiomatic loop filtering within generators.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\nfor\n  i <- 1 to 10\n  if i % 2 == 0\n  if i < 5\ndo\n  println(i)\n```\n\n----------------------------------------\n\nTITLE: Java Reflection-Based Selectable Method Definition (Scala/Java Interop)\nDESCRIPTION: This snippet describes the signature of an applyDynamic method on Selectable that uses Java reflection for dynamic invocation. It requires implicit evidence of SummonAll for argument types and ClassTag, enabling the reflection system to obtain method parameters at runtime. The method accepts a String name and variadic arguments, integrating Java reflection into Scala's dynamic member access system. Requires Scala 3, SummonAll, and ClassTag.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/minutes/2019-03-13-sip-minutes.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef applyDynamic[Ai, U](name: String)(implicit ev: SummonAll[Ai, ClassTag])\n```\n\n----------------------------------------\n\nTITLE: Configuring GraalVM Environment Variables in Bash\nDESCRIPTION: Sets the GRAALVM_HOME and JAVA_HOME environment variables and adds the GraalVM bin directory to the system PATH within the Bash profile (~/.bash_profile). This configuration makes GraalVM the default Java environment and ensures its command-line tools are readily accessible.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-on-android.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport GRAALVM_HOME=<path to GraalVM home directory>\nexport JAVA_HOME=$GRAALVM_HOME\nexport PATH=$GRAALVM_HOME/bin:$PATH\n```\n\n----------------------------------------\n\nTITLE: Defining Classes and Singleton Objects in Scala\nDESCRIPTION: Defines a case class Fruit with name and color properties and three singleton objects (Apple, Plum, Banana) extending this class. This snippet represents basic class and object definitions in a Scala package gardening.fruits, serving as foundational data types used later in the package object and client code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/package-objects.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// in file gardening/fruits/Fruit.scala\npackage gardening.fruits\n\ncase class Fruit(name: String, color: String)\nobject Apple extends Fruit(\"Apple\", \"green\")\nobject Plum extends Fruit(\"Plum\", \"blue\")\nobject Banana extends Fruit(\"Banana\", \"yellow\")\n```\n\n----------------------------------------\n\nTITLE: Declaring Variables in Scala\nDESCRIPTION: Shows different ways to declare variables in Scala, including mutable variables, constants, and type declarations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/cheatsheets/index.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nvar x = 5\n```\n\nLANGUAGE: scala\nCODE:\n```\nx = 6\n```\n\nLANGUAGE: scala\nCODE:\n```\nval x = 5\n```\n\nLANGUAGE: scala\nCODE:\n```\nvar x: Double = 5\n```\n\n----------------------------------------\n\nTITLE: Определение параметризованных трейтов с разной вариантностью в Scala 2\nDESCRIPTION: В этом фрагменте кода представлены три типажа с параметром типа T, демонстрирующих основные режимы вариантности: Pipeline — инвариантный тип, принимающий и возвращающий T; Producer — ковариантный (+T) тип, возвращающий T; Consumer — контравариантный (-T) тип, принимающий T в методе без возвращаемого значения. Код иллюстрирует ограничения и правила использования симпатичных аннотаций вариантности в Scala 2 с целью контроля безопасности типов при параметризации.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-variance.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n// пример инвариантного типа\ntrait Pipeline[T] {\n  def process(t: T): T\n}\n\n// пример ковариантного типа\ntrait Producer[+T] {\n  def make: T\n}\n\n// пример контрвариантного типа\ntrait Consumer[-T] {\n  def take(t: T): Unit\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Immutable Values in Scala\nDESCRIPTION: This snippet shows the 'val' keyword used to declare immutable values in Scala. 'val' is the preferred way to declare variables in Scala unless mutability is explicitly needed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval\n```\n\n----------------------------------------\n\nTITLE: Basic Future example: asynchronous computation with network request\nDESCRIPTION: Demonstrates creating a Future to perform an asynchronous network operation, such as fetching a friend list from a social network API. Shows default use with global ExecutionContext, highlighting how to initiate non-blocking operations that complete in the future.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.concurrent._\nimport ExecutionContext.Implicits.global\n\nval session = socialNetwork.createSessionFor(\"user\", credentials)\nval f: Future[List[Friend]] = Future {\n  session.getFriends()\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval session = null\nval f: Future[List[Friend]] = Future {\n  session.getFriends\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Macro with scala.reflect.macros.Context (Scala)\nDESCRIPTION: Implements the `assertImpl` macro in the `Asserts` object. The method receives a `Context` parameter for compiler interaction and two expression parameters representing the condition and message. It returns an expression that evaluates to `Unit`. Depending on a compile-time flag `assertionsEnabled`, it generates an abstract syntax tree for either a runtime raise of `AssertionError` or an empty unit expression. The implementation requires importing `scala.reflect.macros.Context` and enabling experimental macros through `scala.language.experimental.macros`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/overview.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.macros.Context\nimport scala.language.experimental.macros\n\nobject Asserts {\n  def raise(msg: Any) = throw new AssertionError(msg)\n  def assertImpl(c: Context)\n    (cond: c.Expr[Boolean], msg: c.Expr[Any]) : c.Expr[Unit] =\n   if (assertionsEnabled)\n      <[ if (!cond) raise(msg) ]>\n      else\n      <[ () ]>\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Class Initialization and Method Call in Scala 3 REPL\nDESCRIPTION: This REPL session demonstrates instantiating the `Person` class defined with a body in Scala 3 without `new`, showing the initialization output and the result of calling the `printFullName` method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val john = Person(\"John\", \"Doe\")\ninitialization begins\nJohn Doe\ninitialization ends\nval john: Person = Person@55d8f6bb\n\nscala> john.printFullName\nJohn Doe\n```\n\n----------------------------------------\n\nTITLE: Defining Logarithms Abstract Interface with Type Alias in Scala\nDESCRIPTION: Specifies a trait Logarithms as an abstract interface with a type alias Logarithm. It declares operations for addition and multiplication, conversion functions between Double and Logarithm, and extension methods to allow operator-like syntax. This design separates abstraction from implementation but requires users to program against the interface and handle path-dependent types, and it suffers from boxing overhead and the possibility of leaking type equality.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-opaque-types.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntrait Logarithms:\n\n  type Logarithm\n\n  // operations on Logarithm\n  def add(x: Logarithm, y: Logarithm): Logarithm\n  def mul(x: Logarithm, y: Logarithm): Logarithm\n\n  // functions to convert between Double and Logarithm\n  def make(d: Double): Logarithm\n  def extract(x: Logarithm): Double\n\n  // extension methods to use `add` and `mul` as \"methods\" on Logarithm\n  extension (x: Logarithm)\n    def toDouble: Double = extract(x)\n    def + (y: Logarithm): Logarithm = add(x, y)\n    def * (y: Logarithm): Logarithm = mul(x, y)\n```\n\n----------------------------------------\n\nTITLE: Matching Case Classes with Guards in Scala 2\nDESCRIPTION: Demonstrates pattern matching on a Scala 2 case class (`Person`), extracting a field (`name`), and using that field in an `if` guard to perform actions based on the specific field value. Includes the `Person` case class definition and example calls to the `speak` method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_26\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Person(name: String)\n\ndef speak(p: Person) = p match {\n  case Person(name) if name == \"Fred\" => println(s\"$name says, Yubba dubba doo\")\n  case Person(name) if name == \"Bam Bam\" => println(s\"$name says, Bam bam!\")\n  case _ => println(\"Watch the Flintstones!\")\n}\n\nspeak(Person(\"Fred\"))      // \"Fred says, Yubba dubba doo\"\nspeak(Person(\"Bam Bam\"))   // \"Bam Bam says, Bam bam!\"\n```\n\n----------------------------------------\n\nTITLE: Standard sbt Project Directory Layout - Text\nDESCRIPTION: This snippet shows the conventional directory structure sbt projects follow, which aids standardization across Scala projects. It includes main build files, the 'project' folder containing build properties, 'src' directories for production and test sources separated by language sources and resources, and 'target' directory for output. This layout facilitates modular builds and resource management.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n.\n├── build.sbt\n├── project/\n│   └── build.properties\n├── src/\n│   ├── main/\n│   │   ├── java/\n│   │   ├── resources/\n│   │   └── scala/\n│   └── test/\n│       ├── java/\n│       ├── resources/\n│       └── scala/\n└── target/\n```\n\n----------------------------------------\n\nTITLE: Assigning Variable Using if Expression in Scala\nDESCRIPTION: Assigns the smaller of two integers to a val minValue using Scala's if-else expression syntax. Highlighting Scala's expression-oriented design.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_36\n\nLANGUAGE: scala\nCODE:\n```\nval minValue = if a < b then a else b\n```\n\n----------------------------------------\n\nTITLE: Nested for loops with multiple ranges in Python and Scala\nDESCRIPTION: Shows how to nest for loops to iterate across multiple ranges and print combined values. Inputs: ranges for i, j, k; outputs: printed combinations with formatted strings. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_38\n\nLANGUAGE: Scala\nCODE:\n```\nfor\n  i <- 1 to 2\n  j <- 4 to 5\n  k <- 1 until 10 by 3\n do\n  println(s\"i = $i, j = $j, k = $k\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Return Type Isomorphism in Scala Collections\nDESCRIPTION: Examples showing how the map method preserves the collection type in the result, demonstrating the 'return type isomorphism' principle in Scala collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/overview.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nscala> List(1, 2, 3) map (_ + 1)\nres0: List[Int] = List(2, 3, 4)\nscala> Set(1, 2, 3) map (_ * 2)\nres0: Set[Int] = Set(2, 4, 6)\n```\n\n----------------------------------------\n\nTITLE: Defining Single-Line Methods in Scala (2 & 3)\nDESCRIPTION: Provides examples of defining a simple `add` method on a single line in Scala, both with an explicit `Int` return type annotation and without (allowing type inference). This syntax is valid in both Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef add(a: Int, b: Int): Int = a + b\ndef add(a: Int, b: Int) = a + b\n```\n\n----------------------------------------\n\nTITLE: Declaring Immutable Variables with val in Scala\nDESCRIPTION: This simple snippet demonstrates the Scala idiom of using the `val` keyword to declare an immutable variable. Once assigned, the value of `a` cannot be changed. This promotes functional programming principles and helps prevent unexpected state changes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/why-scala-3.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval a = 1                 // immutable variable\n```\n\n----------------------------------------\n\nTITLE: 루트 네임스페이스에서 임포트하는 예제 스칼라\nDESCRIPTION: 프로젝트 루트 네임스페이스에 대해서 임포트 할 때 이름 충돌을 방지하기 위해 _root_를 붙여 사용한 예제입니다. accounts 패키지 안에서 _root_.users 패키지의 모든 멤버를 임포트하여 참조하는 상황을 다룹니다. 이는 중복 패키지 이름이나 네임스페이스 혼란이 발생할 때 효과적입니다.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/packages-and-imports.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\npackage accounts\n\nimport _root_.users._\n```\n\n----------------------------------------\n\nTITLE: 调用高阶函数 executeNTimes\nDESCRIPTION: 定义 `helloWorld` 函数并传入 `executeNTimes`，演示其执行多次的效果。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-hofs.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ndef helloWorld(): Unit = println(\"Hello, world\")\n```\n\n----------------------------------------\n\nTITLE: Defining an OOP Class with a Primary Constructor in Scala\nDESCRIPTION: Shows the concise Scala syntax for defining a `Person` class. The primary constructor parameters (`firstName`, `lastName`, `age`) declared with `var` directly become public mutable fields. The `toString` method is overridden using string interpolation (`s\"\"`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass Person (\n  var firstName: String,\n  var lastName: String,\n  var age: Int\n):  \n  override def toString = s\"$firstName $lastName is $age years old.\"\n\n```\n\n----------------------------------------\n\nTITLE: Java Interoperability with Scala Default Parameters\nDESCRIPTION: This Java code demonstrates that Scala default parameters are not optional when called from Java code. The attempt to instantiate a Point with just one parameter does not compile.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/default-parameter-values.md#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\n// Main.java\npublic class Main {\n    public static void main(String[] args) {\n        Point point = new Point(1);  // does not compile\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Map Elements in Scala\nDESCRIPTION: This snippet shows how to iterate over key-value pairs in a Scala Map using a for-comprehension. It prints each key-value pair in a formatted string. Requires a Map object and outputs text for each pair, using printf for output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/collections-maps.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nfor ((k,v) <- m) printf(\"key: %s, value: %s\\n\", k, v)\n```\n\n----------------------------------------\n\nTITLE: Type Casting Between Value Types in Scala\nDESCRIPTION: This code demonstrates how to cast between Scala's value types. It shows conversion from Long to Float (with potential precision loss) and from Char to Int. These explicit conversions are necessary because casting in Scala is unidirectional.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/unified-types.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval x: Long = 987654321\nval y: Float = x.toFloat  // 9.8765434E8 (note that some precision is lost in this case)\n\nval face: Char = '☺'\nval number: Int = face  // 9786\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Interpolator using Implicit Class in Scala 2\nDESCRIPTION: Provides the Scala 2 implementation structure for a custom string interpolator (`p`). It uses an implicit class `PointHelper` extending `AnyVal` (for performance) that adds a `p` method to `StringContext`. The `p` method receives arguments (`Any*`) representing the interpolated expressions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nimplicit class PointHelper(val sc: StringContext) extends AnyVal {\n  def p(args: Any*): Point = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Type Literals and Runtime Type Checking in Scala\nDESCRIPTION: Demonstrates usage of Scala's class literals and runtime type checks. 'classOf[String]' gets the class literal, 'x.isInstanceOf[String]' checks at runtime if x is an instance of String, 'x.asInstanceOf[String]' casts x to String at runtime, and 'x: String' is a compile-time type ascription for variable declarations. These operations are fundamental for type-safe programming and reflection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/cheatsheets/index.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nclassOf[String]\nx.isInstanceOf[String]\nx.asInstanceOf[String]\nx: String\n```\n\n----------------------------------------\n\nTITLE: Using map combinator on Futures for currency trading in Scala 2\nDESCRIPTION: Refactors the initial nested callback example by using the 'map' combinator on a Future to transform the USD rate into a purchase Future. This reduces callback nesting and enables better composition. The 'map' function applies a transformation function once the original Future completes successfully. The 'purchase' Future then has a 'foreach' to handle side-effects like printing the result asynchronously.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nval rateQuote = Future {\n  connection.getCurrentValue(USD)\n}\n\nval purchase = rateQuote map { quote =>\n  if (isProfitable(quote)) connection.buy(amount, quote)\n  else throw new Exception(\"not profitable\")\n}\n\npurchase.foreach { amount =>\n  println(\"Purchased \" + amount + \" USD\")\n}\n```\n\n----------------------------------------\n\nTITLE: Matching on Type Only - Scala 3\nDESCRIPTION: Demonstrates pattern matching on the type of an object (`case p: Phone`) using Scala 3 syntax. This allows executing type-specific logic, like calling a method (`p.screenOff`). Requires the input type (`Device`) to be a trait or class with defined subtypes (`Phone`, `Computer`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/pattern-matching.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait Device\ncase class Phone(model: String) extends Device:\n  def screenOff = \"Turning screen off\"\n\ncase class Computer(model: String) extends Device:\n  def screenSaverOn = \"Turning screen saver on...\"\n\n\ndef goIdle(device: Device): String = device match\n  case p: Phone => p.screenOff\n  case c: Computer => c.screenSaverOn\n```\n\n----------------------------------------\n\nTITLE: Creating Immutable List and Vector (Scala)\nDESCRIPTION: This Scala snippet shows how to create immutable sequence collections, specifically a List and a Vector. Both are declared using `val` to indicate immutability and initialized using their respective factory methods or constructors.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_55\n\nLANGUAGE: Scala\nCODE:\n```\nval strings = List(\"a\", \"b\", \"c\")\nval strings = Vector(\"a\", \"b\", \"c\")\n```\n\n----------------------------------------\n\nTITLE: Compiler Special Treatment of NamedTuple.From for Case Classes in Scala 3\nDESCRIPTION: Describes the special type-level computation NamedTuple.From that maps a case class type to a named tuple of its fields' names and types. This enables extracting named tuple representations of case classes, enums with case classes, and similar structures for use in generic programming. NamedTuple.From is idempotent on named tuple types themselves.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-tuples.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ntype From[T] <: AnyNamedTuple\n```\n\nLANGUAGE: scala\nCODE:\n```\ncase class City(zip: Int, name: String, population: Int)\n// NamedTuple.From[City] is (zip: Int, name: String, population: Int)\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Scala 3 Enum Values\nDESCRIPTION: Illustrates using the `import` statement to bring all values of an enum into scope for convenient usage. The example imports all members of the `CrustSize` enum and assigns one of the values to a variable. It demonstrates idiomatic usage of enums in Scala 3 programs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_34\n\nLANGUAGE: scala\nCODE:\n```\nimport CrustSize.*\nval currentCrustSize = Small\n```\n\n----------------------------------------\n\nTITLE: Composing Multiple Traits in a New Trait in Scala 2\nDESCRIPTION: This snippet demonstrates mixin composition by defining a new trait ComposedService that extends both GreetingService and TranslationService in Scala 2. The abstract translate method from GreetingService is fulfilled by TranslationService's implementation. No additional dependencies are required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ntrait ComposedService extends GreetingService with TranslationService\n```\n\n----------------------------------------\n\nTITLE: Defining Book Metadata using YAML Front Matter\nDESCRIPTION: This YAML front matter block defines metadata for a web page or document, likely used by a static site generator (like Jekyll, Hugo) or content management system. It includes key-value pairs specifying the book's title, a relevant web link, path to a cover image, its update status (specifically mentioning Scala 3), authors, publisher, and a link to the publisher.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_books/3-scala-for-the-impatient.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\ntitle: \"Scala for the Impatient\"\nlink: https://horstmann.com/scala/\nimage: /resources/img/books/scala_for_the_impatient.jpg\nstatus: Updated for Scala 3\nauthors: [\"Cay Horstmann\"]\npublisher: Addison-Wesley Professional\npublisherLink: https://www.oreilly.com/publisher/addison-wesley-professional/\n```\n\n----------------------------------------\n\nTITLE: 构建字符串使用 StringBuilder（Scala）\nDESCRIPTION: 示例展示如何使用StringBuilder类构造字符串，包括追加字符和字符串，最后转换为字符串。StringBuilder适合频繁拼接字符串的场景，已导入到默认命名空间中。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/concrete-mutable-collection-classes.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval buf = new StringBuilder\nbuf += 'a'\nbuf ++= \"bcdef\"\nval str = buf.toString\n```\n\n----------------------------------------\n\nTITLE: General syntax for defining function input parameter type signatures in Scala\nDESCRIPTION: Presents the general pattern `variableName: (parameterTypes ...) => returnType` for declaring function parameter types in higher-order methods. This syntax allows precise typing of functions accepted as input parameters, facilitating type-safe functional programming.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-hofs.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nvariableName: (parameterTypes ...) => returnType\n```\n\n----------------------------------------\n\nTITLE: Recursive Method Type Inference Limitation in Scala\nDESCRIPTION: Demonstrates that Scala cannot infer the return type for recursive methods like 'fac' due to self-reference. Explicit return type annotation is necessary in such cases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/type-inference.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef fac(n: Int) = if n == 0 then 1 else n * fac(n - 1)\n```\n\n----------------------------------------\n\nTITLE: Catching File-Related Exceptions Using Scala's try/catch\nDESCRIPTION: This Scala snippet demonstrates how to use the try/catch construct to open and read a file while handling possible exceptions. Specifically, it catches FileNotFoundException and IOException thrown by Java IO classes. The variable 'text' stores the file contents on success. Dependencies include Java's java.io package for exception classes. Inputs are the filename passed to openAndReadAFile, and outputs are console prints on exceptions with no return value. The snippet assumes the existence of a method openAndReadAFile for reading file data.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/try-catch-finally.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nvar text = \"\"\ntry {\n    text = openAndReadAFile(filename)\n} catch {\n    case e: FileNotFoundException => println(\"Couldn't find that file.\")\n    case e: IOException => println(\"Had an IOException trying to read that file\")\n}\n```\n\n----------------------------------------\n\nTITLE: 'for' loop with guard in Scala 3\nDESCRIPTION: Shows Scala 3 syntax for including guard conditions within a 'for' loop to filter elements before processing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nfor\n  i <- ints\n  if i > 2\ndo\n  println(i)\n```\n\n----------------------------------------\n\nTITLE: Defining an Abstract Trait Interface in Scala 2\nDESCRIPTION: This snippet defines a trait Showable with an abstract method show in Scala 2. The trait requires the implementing class to provide its own version of show, returning a String representation. No parameters or dependencies are needed other than the Scala 2 language environment. The trait's purpose is to provide a general contract for objects that can be 'shown'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Showable {\n  def show: String\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Scalatags Dependency (Build Tools)\nDESCRIPTION: Provides instructions for adding the Scalatags library as a project dependency using different Scala build tools. Adding `com.lihaoyi::scalatags` enables the use of Scalatags for generating HTML content within the Cask application. The syntax for adding dependencies varies slightly between Scala CLI, sbt, and Mill.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/web-server-dynamic.md#_snippet_3\n\nLANGUAGE: Scala CLI\nCODE:\n```\n//> using dep com.lihaoyi::scalatags::0.13.1\n```\n\nLANGUAGE: sbt\nCODE:\n```\nlibraryDependencies += \"com.lihaoyi\" %% \"scalatags\" % \"0.13.1\"\n```\n\nLANGUAGE: Mill\nCODE:\n```\nivy\"com.lihaoyi::scalatags::0.13.1\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Scala Abstract Class with Constructor Parameters\nDESCRIPTION: This Scala code snippet demonstrates the correct syntax for defining an abstract class 'Animal' that requires a 'name' string as a constructor parameter. This pattern is used when a base class needs constructor arguments, which traits do not support.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/abstract-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Animal(name: String)\n```\n\n----------------------------------------\n\nTITLE: Defining a Transparent Inline Function for Type Refinement in Scala\nDESCRIPTION: Introduces `transparent inline` functions with an example `default` function. This function uses `inline if` to return a default value based on a string name. The `transparent` keyword allows the call site's type to be refined to the specific type returned by the inlined branch (e.g., `Int` or `String`), rather than the declared `Any`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\ntransparent inline def default(inline name: String): Any =\n  inline if name == \"Int\" then 0\n  else inline if name == \"String\" then \"\"\n  else ...\n```\n\n----------------------------------------\n\nTITLE: Writing Clear Quoted Code in Scala\nDESCRIPTION: Demonstrates how to keep Scala quoted code readable by avoiding complex expressions inside `${...}` and instead using intermediate `Expr` values. Shows the transformation of a direct nested quote into a clearer multi-step expression using helper variables `partExprs` and `partsExpr` to hold parts of a StringContext before splicing into the quote. Requires Scala 3 macros and quoted code support.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/best-practices.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval sc: StringContext = ...\n'{ StringContext(${Varargs(sc.parts.map(Expr(_)))}: _*) }\n```\n\nLANGUAGE: scala\nCODE:\n```\nval sc: StringContext = ...\nval partExprs = sc.parts.map(Expr(_))\nval partsExpr = Varargs(partExprs)\n'{ StringContext($partsExpr: _*) }\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Scala String Ordering\nDESCRIPTION: This Scala snippet defines a custom `Ordering` named `myOrdering` for `String` elements. It uses the `Ordering.fromLessThan` factory method to create an ordering that sorts strings in descending order.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/sets.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val myOrdering = Ordering.fromLessThan[String](_ > _)\nmyOrdering: scala.math.Ordering[String] = ...\n```\n\n----------------------------------------\n\nTITLE: Defining the CanBuildFrom Factory Trait for Type-safe Collection Builders in Scala\nDESCRIPTION: Presents the core interface for collection builder factories in Scala's collection library. CanBuildFrom abstracts the creation of collection builders for arbitrary combinations of source collection, element type, and result collection type. Essential for enabling type-driven selection of appropriate builders in generic collection methods. The apply method receives the originating collection and returns a builder instance. No specific inputs except the source collection, output is a typed Builder.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-collections.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\npackage scala.collection.generic\n\ntrait CanBuildFrom[-From, -Elem, +To] {\n  // Creates a new builder\n  def apply(from: From): Builder[Elem, To]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating synchronized Sets in Scala\nDESCRIPTION: Demonstrates how to create thread-safe Sets by mixing in the SynchronizedSet trait with a HashSet implementation, similar to the approach used for synchronized Maps.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/maps.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable\nval synchroSet = new mutable.HashSet[Int] with mutable.SynchronizedSet[Int]\n```\n\n----------------------------------------\n\nTITLE: Matching Integer Constants with Scala Match Expression (Scala 3)\nDESCRIPTION: Demonstrates pattern matching on an integer value using the Scala 3 syntax. Similar in functionality to the Scala 2 version, it imports Random to generate an integer between 0 and 9, then performs matching with each case corresponding to a string label. Scala 3 syntax uses indentation instead of braces which simplifies the code format. The default case uses the underscore to catch all unmatched values, returning \"other\". The example highlights the stylistic changes introduced in Scala 3 while preserving functional behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/pattern-matching.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.util.Random\n\nval x: Int = Random.nextInt(10)\n\nx match\n  case 0 => \"zero\"\n  case 1 => \"one\"\n  case 2 => \"two\"\n  case _ => \"other\"\n```\n\n----------------------------------------\n\nTITLE: Implementing a Macro to Collect Method Names via Pattern Matching in Scala\nDESCRIPTION: This snippet defines a macro `collectUsedMethods` that inspects an expression of type `FieldName => FieldName` and recursively extracts method names used (`uppercase` or `lowercase`). It leverages pattern matching on quoted expressions to deconstruct the function and collect method calls into a list of strings, illustrating recursive pattern matching with quotes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\ndef collectUsedMethods(func: Expr[FieldName => FieldName])(using Quotes): List[String] = \n  def recurse(current: Expr[FieldName => FieldName], acc: List[String])(using Quotes): List[String] = \n    current match \n      // $body is the next tree with the '.lowercase' call stripped away\n      case '{ (arg: FieldName) => ($body(arg): FieldName).lowercase } =>\n        recurse(body, \"lowercase\" :: acc) // body: Expr[FieldName => FieldName]\n\n      // $body is the next tree with the '.uppercase' call stripped away\n      case '{ (arg: FieldName) => ($body(arg): FieldName).uppercase } =>\n        recurse(body, \"uppercase\" :: acc) // body: Expr[FieldName => FieldName]\n\n      // this matches an identity function, i.e. the end of our loop\n      case '{ (arg: FieldName) => arg } => acc\n  end recurse\n  recurse(func, Nil)\n```\n\n----------------------------------------\n\nTITLE: Invoking Higher-Order Functions in Scala\nDESCRIPTION: Recommends using standard dot notation without spaces after the method name when invoking higher-order functions (e.g., `map`, `filter`). This applies whether parentheses or braces are used for the function argument. Using infix notation or adding extra spaces is discouraged as it can hinder readability, especially in chained method calls.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/method-invocation.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nnames.map(_.toUpperCase)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// wrong! missing dot\nnames map (_.toUpperCase)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// wrong! extra space\nnames.map (_.toUpperCase)\n```\n\n----------------------------------------\n\nTITLE: Parsing Format String and Mapping Parameters to AST Nodes in printf Macro (Scala)\nDESCRIPTION: Splits the printf format string into parts and maps each specifier to corresponding abstract syntax trees representing parameters or literals. Uses a Stack to pop parameters, matches format specifiers like `%d` and `%s` to typed precomputations, and produces a sequence of tree nodes representing the formatted output. This method helps convert format parameters into appropriate Scala AST expressions for code generation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/overview.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval paramsStack = Stack[Tree]((params map (_.tree)): _*)\nval refs = s_format.split(\"(?<=%[\\\\w%])|(?=%[\\\\w%])\") map {\n  case \"%d\" => precompute(paramsStack.pop, typeOf[Int])\n  case \"%s\" => precompute(paramsStack.pop, typeOf[String])\n  case \"%%\" => Literal(Constant(\"%\"))\n  case part => Literal(Constant(part))\n}\n```\n\n----------------------------------------\n\nTITLE: Extending and Overriding Trait Methods in Scala 3 Classes\nDESCRIPTION: Scala 3 implementation of Cat class extending traits and overriding methods for custom behavior, demonstrating syntax and inheritance in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-modeling.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass Cat(name: String) extends Speaker, TailWagger, Runner:\n  def speak(): String = \"Meow\"\n  override def startRunning(): Unit = println(\"Yeah ... I don’t run\")\n  override def stopRunning(): Unit = println(\"No need to stop\")\n```\n\n----------------------------------------\n\nTITLE: For loops with multiple generators in Scala 2 and 3\nDESCRIPTION: Example of for loops with multiple generators, iterating over multiple collections simultaneously to produce combinations of values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/control-structures.md#_snippet_9\n\nLANGUAGE: Scala 2\nCODE:\n```\nfor {\n  i <- 1 to 2\n  j <- 'a' to 'b'\n  k <- 1 to 10 by 5\n} {\n  println(s\"i = $i, j = $j, k = $k\")\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nfor\n  i <- 1 to 2\n  j <- 'a' to 'b'\n  k <- 1 to 10 by 5\ndo\n  println(s\"i = $i, j = $j, k = $k\")\n```\n\n----------------------------------------\n\nTITLE: Defining Reusable Elements with mdoc in Scala\nDESCRIPTION: Shows how to define elements like imports (`java.time.Instant`), methods (`now`), and objects (`Foo`) within an `mdoc` block. These definitions persist and can be used in subsequent `mdoc` snippets within the same file, provided no `mdoc:reset` modifier is used.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/add-guides.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc\nimport java.time.Instant\n\ndef now() = Instant.now()\nobject Foo {}\n```\n```\n\n----------------------------------------\n\nTITLE: 'for' expression with 'yield' in Scala 2\nDESCRIPTION: Creates a new list by doubling each element in the original list using a 'for' expression with 'yield' in Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nval doubles = for (i <- ints) yield i * 2\n// doubles: List[Int] = List(2, 4, 6, 8, 10)\n```\n\n----------------------------------------\n\nTITLE: Defining an Abstract Class in Scala\nDESCRIPTION: Shows how to define an abstract class `D` using the `abstract` keyword in Scala. Abstract classes cannot be instantiated directly and often contain abstract members (methods or fields) to be implemented by subclasses.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/cheatsheets/index.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class D { /* abstract members */ }\n```\n\n----------------------------------------\n\nTITLE: Using HashMap in Scala\nDESCRIPTION: Shows how to create an empty mutable HashMap, add key-value pairs using the += operator with -> syntax, access values by key, and check if a key exists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/concrete-mutable-collection-classes.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval map = scala.collection.mutable.HashMap.empty[Int,String]\nmap += (1 -> \"make a web site\")\nmap += (3 -> \"profit!\")\nmap(1)\nmap contains 2\n```\n\n----------------------------------------\n\nTITLE: Implementing Functional List Doubling with map in Scala\nDESCRIPTION: This snippet shows the high-level, functional approach to doubling elements in a list using Scala's collection methods. It utilizes the `map` higher-order function with a lambda expression (`_ * 2`) to concisely transform each element, producing a new list without mutable state.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-features.md#_snippet_1\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\nval newNumbers = oldNumbers.map(_ * 2)\n```\n\n----------------------------------------\n\nTITLE: Using a Helper Method in Scala\nDESCRIPTION: Illustrates how to call the `circumference` helper method defined in `CircleHelpers`, passing a `Circle` instance (`aCircle`) as an argument. This represents the usage pattern without extension methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-extension-methods.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval aCircle = Circle(2, 3, 5)\n\n// without extension methods\nCircleHelpers.circumference(aCircle)\n```\n\n----------------------------------------\n\nTITLE: Using Pattern Matching with Tuples in Collections in Scala\nDESCRIPTION: Uses pattern matching within a foreach loop to find specific tuple elements in a list of planet data, demonstrating selective pattern matching and output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/tuples.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval planets =\n  List((\"Mercury\", 57.9), (\"Venus\", 108.2), (\"Earth\", 149.6),\n       (\"Mars\", 227.9), (\"Jupiter\", 778.3))\nplanets.foreach{\n  case (\"Earth\", distance) =>\n    println(s\"Nuestro planeta está a $distance millones de kilómetros del Sol.\")\n  case _ =>\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Notification Types to Extract Fields (Scala 3)\nDESCRIPTION: Defines a function showNotification using Scala 3's indentation-based syntax to pattern match a Notification parameter. The function matches on Email, SMS, and VoiceRecording case classes, extracting fields to generate contextual messages. The body field for Email is ignored using the underscore. The snippet includes instantiation of SMS and VoiceRecording and outputs corresponding notification strings. It leverages Scala 3’s clearer syntax for pattern matching without braces.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/pattern-matching.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef showNotification(notification: Notification): String =\n  notification match\n    case Email(sender, title, _) =>\n      s\"You got an email from $sender with title: $title\"\n    case SMS(number, message) =>\n      s\"You got an SMS from $number! Message: $message\"\n    case VoiceRecording(name, link) =>\n      s\"You received a Voice Recording from $name! Click the link to hear it: $link\"\n\nval someSms = SMS(\"12345\", \"Are you there?\")\nval someVoiceRecording = VoiceRecording(\"Tom\", \"voicerecording.org/id/123\")\n\nprintln(showNotification(someSms))  // выводит \"You got an SMS from 12345! Message: Are you there?\"\n\nprintln(showNotification(someVoiceRecording))  // выводит \"You received a Voice Recording from Tom! Click the link to hear it: voicerecording.org/id/123\"\n```\n\n----------------------------------------\n\nTITLE: Attempting Generic Array Creation Without ClassTag (Incorrect)\nDESCRIPTION: Presents an incorrect attempt to define a generic function 'evenElems' that creates an 'Array[T]'. This fails because 'new Array[T]' requires runtime type information, which is lost due to type erasure without a ClassTag.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/arrays.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n//这是错的！\ndef evenElems[T](xs: Vector[T]): Array[T] = {\n  val arr = new Array[T]((xs.length + 1) / 2)\n  for (i <- 0 until xs.length by 2)\n    arr(i / 2) = xs(i)\n  arr\n}\n```\n\n----------------------------------------\n\nTITLE: Example Scala Code Intended to Fail Compilation\nDESCRIPTION: A simple Scala code snippet demonstrating an attempt to convert a `List[Int]` directly to a `Map`, which results in a compile-time error. This type of snippet is often used with the `sc:fail` flag.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/snippet-compiler.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nList(1,2,3).toMap\n```\n\n----------------------------------------\n\nTITLE: Summing a list using implicit monoid in Scala\nDESCRIPTION: The `sum` function takes a list of elements of type `A` and an implicit `Monoid[A]`, returning the aggregated result by successively combining list elements. The implicit monoid object is inferred based on the element type, enabling concise calls for different data types. The function handles empty lists by returning the monoid's `unit` element.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/implicit-parameters.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef sum[A](xs: List[A])(implicit m: Monoid[A]): A =\n  if (xs.isEmpty) m.unit\n  else m.add(xs.head, sum(xs.tail))\n```\n\n----------------------------------------\n\nTITLE: Calling a Method in Scala (2 & 3)\nDESCRIPTION: Demonstrates how to call a previously defined method (`add`) with integer arguments (1 and 2) and assign the returned result (3) to an immutable value `x`. This syntax is applicable to both Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval x = add(1, 2)   // 3\n```\n\n----------------------------------------\n\nTITLE: Usage examples of the isTruthy method in Scala\nDESCRIPTION: Examples showing how the isTruthy method behaves with different input values, demonstrating which values are considered truthy or falsy.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/methods-most.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nisTruthy(0)      // false\nisTruthy(\"\")     // false\nisTruthy(\"hi\")   // true\nisTruthy(1.0)    // true\n```\n\n----------------------------------------\n\nTITLE: Updating Mutable Scala Sets Using += and -= Methods - Scala\nDESCRIPTION: Shows how to mutate a Scala mutable Set by adding and removing elements in place using += and -= methods. Unlike immutable sets, these operations modify the original set rather than returning a new set. The example uses a val to hold the mutable set, emphasizing in-place updates. Inputs are initial elements of type Int and modifications via operators, output is the mutated set reflecting changes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/sets.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval s = collection.mutable.Set(1, 2, 3)\ns += 4\ns -= 2\n```\n\n----------------------------------------\n\nTITLE: Using Extractor Patterns for Delegated Matching in Scala Quasiquotes\nDESCRIPTION: Illustrates the use of extractor patterns which delegate the pattern matching logic to the unapply method of objects, enabling decomposition of AST trees into components. The pattern matches constructor-like applications and extracts identifier and argument lists. Inputs are AST trees representing such applications; outputs are extracted subtrees representing constructor and argument patterns.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/pattern-details.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval extractor = pq\"Foo(1, 2, 3)\"\nextractor: universe.Tree = Foo(1, 2, 3)\n\nval pq\"$id(..$pats)\" = extractor\nid: universe.Tree = Foo\npats: List[universe.Tree] = List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Map and Filter Combined with List Comprehension in Python\nDESCRIPTION: Combines filtering for even numbers and mapping by multiplying by 10 in a single Python list comprehension, producing a list with transformed filtered elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_29\n\nLANGUAGE: Python\nCODE:\n```\nx = [i * 10 for i in numbers if i % 2 == 0]\n```\n\n----------------------------------------\n\nTITLE: Declaring a Scala Abstract Class Requiring a Constructor Parameter\nDESCRIPTION: This Scala code shows the declaration of the 'Pet' abstract class, emphasizing that it requires a 'name' string argument for its constructor. This is a prerequisite for subclasses needing to pass this parameter during extension.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/abstract-classes.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Pet (name: String) { ...\n```\n\n----------------------------------------\n\nTITLE: Building and Accessing Vectors in Scala\nDESCRIPTION: This snippet demonstrates how to initialize an empty immutable Vector, append elements using `:+`, prepend elements using `+:`, and access elements by index. Vectors provide effectively constant time access and updates by representing elements as a tree with a high branching factor. The snippet assumes usage of Scala immutable collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-immutable-collection-classes.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nscala> val vec = scala.collection.immutable.Vector.empty\nvec: scala.collection.immutable.Vector[Nothing] = Vector()\nscala> val vec2 = vec :+ 1 :+ 2\nvec2: scala.collection.immutable.Vector[Int] = Vector(1, 2)\nscala> val vec3 = 100 +: vec2\nvec3: scala.collection.immutable.Vector[Int] = Vector(100, 1, 2)\nscala> vec3(0)\nres1: Int = 100\n```\n\n----------------------------------------\n\nTITLE: 扩展多个Traits创建Dog类(Scala 3)\nDESCRIPTION: 演示如何在Scala 3中创建一个扩展多个traits的类。此示例创建了Dog类，它继承了Speaker、TailWagger和Runner三个trait，并实现了抽象的speak方法。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-modeling.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass Dog(name: String) extends Speaker, TailWagger, Runner:\n  def speak(): String = \"Woof!\"\n```\n\n----------------------------------------\n\nTITLE: Printing Expressions to Console using println in Scala - Scala\nDESCRIPTION: Shows usage of the println function to output results of various expressions, including integers and string concatenations. This snippet illustrates how Scala expressions are evaluated and displayed in the console.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/tour/basics.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nprintln(1) // 1\nprintln(1 + 1) // 2\nprintln(\"Hello!\") // Hello!\nprintln(\"Hello,\" + \" world!\") // Hello, world!\n```\n\n----------------------------------------\n\nTITLE: Iterating List with Foreach Method in Scala\nDESCRIPTION: Demonstrates the use of the `foreach` method available on Scala collections to iterate over the `people` list. It applies the `println` function directly to each element, providing a concise alternative to the `for` loop for performing an action on each element.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/for-loops.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\npeople.foreach(println)\n```\n\n----------------------------------------\n\nTITLE: Defining a custom Scala case class for JSON serialization\nDESCRIPTION: This snippet shows how to define a custom data type `PetOwner` with a `name` and a list of `pets`. This case class can be serialized to JSON after providing an implicit `ReadWriter` instance using macro-based derivation for Scala 2 or `derives` clause for Scala 3, enabling automatic encoding and decoding with uPickle.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-serialize.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ncase class PetOwner(name: String, pets: List[String])\n```\n\n----------------------------------------\n\nTITLE: 再代入不可の値の再代入試行（コンパイルエラー） - Scala\nDESCRIPTION: valで宣言された値に対して再代入しようとした場合のコンパイルエラー例です。Scalaの不変値の制約を示しており、値の安全性を確保するため再代入は認められません。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nx = 3 // この記述はコンパイルされません。\n```\n\n----------------------------------------\n\nTITLE: Filtered for Loop with if Guards in Scala\nDESCRIPTION: Uses for-generator with multiple if guards that filter values during iteration over the range 1 to 10, printing elements that are even and less than 5. Demonstrates combinable guard expressions in for comprehensions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_46\n\nLANGUAGE: scala\nCODE:\n```\nfor\n  i <- 1 to 10\n  if i % 2 == 0\n  if i < 5\n do\n  println(i)\n```\n\n----------------------------------------\n\nTITLE: Creating a method with a for-expression body in Scala 2\nDESCRIPTION: Shows how to use a for-expression as the body of a method to filter values from a list based on multiple conditions. The method returns elements between 3 and 10 inclusive.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ndef between3and10(xs: List[Int]): List[Int] =\n  for {\n    x <- xs\n    if x >= 3\n    if x <= 10\n  } yield x\n\nbetween3and10(List(1, 3, 7, 11))   // : List[Int] = List(3, 7)\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Reference Container Class in Scala 3\nDESCRIPTION: Defines the generic Reference class parametrized by type T using Scala 3 syntax. It imports compiletime.uninitialized to initialize the private mutable variable contents as uninitialized instead of using underscore (_). The class offers set and get methods to update and retrieve the contained element. This approach provides type safety and proper default initialization of contents similar to Scala 2 but adapted to Scala 3's syntax and semantics. Key parameters include T and the value argument to set().\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\nimport compiletime.uninitialized\n\nclass Reference[T]:\n  private var contents: T = uninitialized\n  def set(value: T): Unit = contents = value\n  def get: T = contents\n```\n\n----------------------------------------\n\nTITLE: Using andThen with Scala 3 syntax for side-effect sequencing\nDESCRIPTION: Equivalent to the previous snippet but using Scala 3 syntax (`do` instead of `=>`) for readability. Maintains purpose of accumulating and rendering posts asynchronously. Depends on Scala 3 syntax conventions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_26\n\nLANGUAGE: Scala\nCODE:\n```\nval allPosts = mutable.Set[String]()\n\nFuture {\n  session.getRecentPosts()\n}.andThen {\n  case Success(posts) => allPosts ++= posts\n}.andThen {\n  case _ =>\n    clearAll()\n    for post <- allPosts do render(post)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing and verifying @tailrec annotation for tail recursion in Scala\nDESCRIPTION: This snippet illustrates defining a tail-recursive factorial helper method using @tailrec, which enforces tail recursion at compile-time. Changing the implementation to a non-tail-recursive version results in a compile error, demonstrating the annotation's enforcement.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/annotations.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.annotation.tailrec\n\ndef factorial(x: Int): Int = {\n\n  @tailrec\n  def factorialHelper(x: Int, accumulator: Int): Int = {\n    if (x == 1) accumulator else factorialHelper(x - 1, accumulator * x)\n  }\n  factorialHelper(x, 1)\n}\n\n// Example of non-tail-recursive version causing compile error:\n// def factorial(x: Int): Int = {\n//   @tailrec\n//   def factorialHelper(x: Int): Int = {\n//     if (x == 1) 1 else x * factorialHelper(x - 1)\n//   }\n//   factorialHelper(x)\n// }\n```\n\n----------------------------------------\n\nTITLE: Creating Utility Methods in Scala Objects\nDESCRIPTION: Shows how to define singleton objects containing utility methods. The example creates a StringUtils object with methods for string manipulation, demonstrating how to group related functionality.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\nobject StringUtils {\n\n  /**\n   * Returns a string that is the same as the input string, but\n   * truncated to the specified length.\n   */\n  def truncate(s: String, length: Int): String = s.take(length)\n\n  /**\n    * Returns true if the string contains only letters and numbers.\n    */\n  def lettersAndNumbersOnly_?(s: String): Boolean =\n    s.matches(\"[a-zA-Z0-9]+\")\n\n  /**\n   * Returns true if the given string contains any whitespace\n   * at all. Assumes that `s` is not null.\n   */\n  def containsWhitespace(s: String): Boolean =\n    s.matches(\".*\\\\s.*\")\n\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nobject StringUtils:\n\n  /**\n   * Returns a string that is the same as the input string, but\n   * truncated to the specified length.\n   */\n  def truncate(s: String, length: Int): String = s.take(length)\n\n  /**\n    * Returns true if the string contains only letters and numbers.\n    */\n  def lettersAndNumbersOnly_?(s: String): Boolean =\n    s.matches(\"[a-zA-Z0-9]+\")\n\n  /**\n   * Returns true if the given string contains any whitespace\n   * at all. Assumes that `s` is not null.\n   */\n  def containsWhitespace(s: String): Boolean =\n    s.matches(\".*\\\\s.*\")\n\nend StringUtils\n```\n\n----------------------------------------\n\nTITLE: Using Pattern Binding with Guards in Scala 3\nDESCRIPTION: Shows how to use pattern binding (`@`) in Scala 3 match expressions to bind the matched pattern (`Cat(...)`, `Dog(...)`) to a variable (`c`, `d`), allowing access to type-specific methods (`meow`, `bark`) and fields within the `if` guard and case body. Uses indentation syntax and includes trait, case class definitions, and example calls.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_29\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Animal:\n  val name: String\ncase class Cat(name: String) extends Animal:\n  def meow: String = \"Meow\"\ncase class Dog(name: String) extends Animal:\n  def bark: String = \"Bark\"\n\ndef speak(animal: Animal) = animal match\n  case c @ Cat(name) if name == \"Felix\" => println(s\"$name says, ${c.meow}!\")\n  case d @ Dog(name) if name == \"Rex\" => println(s\"$name says, ${d.bark}!\")\n  case _ => println(\"I don't know you!\")\n\nspeak(Cat(\"Felix\")) // \"Felix says, Meow!\"\nspeak(Dog(\"Rex\"))   // \"Rex says, Bark!\"\n```\n\n----------------------------------------\n\nTITLE: Defining Context Parameters in Scala 3\nDESCRIPTION: Demonstrates how to mark parameters as contextual using the 'using' keyword in Scala 3. This allows the compiler to automatically provide the argument at call sites.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-context-parameters.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef renderWebsite(path: String)(using config: Config): String =\n    \"<html>\" + renderWidget(List(\"cart\")) + \"</html>\"\n    //                                  ^\n    //                   no argument config required anymore\n\ndef renderWidget(items: List[String])(using config: Config): String = ???\n```\n\n----------------------------------------\n\nTITLE: Using Object Methods in Scala\nDESCRIPTION: Demonstrating how to call methods from the StringUtils object directly with the object name.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nStringUtils.truncate(\"Chuck Bartowski\", 5)  // \"Chuck\"\n```\n\n----------------------------------------\n\nTITLE: Using If Guards in Scala 2 Case Clauses\nDESCRIPTION: Demonstrates using `if` conditions (guards) within `case` clauses of a Scala 2 match expression to match against multiple integer values or conditions, providing specific output for matched cases and a default fallback.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\ni match {\n  case 1 => println(\"one, a lonely number\")\n  case x if x == 2 || x == 3 => println(\"two’s company, three’s a crowd\")\n  case x if x > 3 => println(\"4+, that’s a party\")\n  case _ => println(\"i’m guessing your number is zero or less\")\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Scala Dependencies with Gradle in Groovy\nDESCRIPTION: This snippet shows a build.gradle file for a Scala project using Gradle. It applies the Scala plugin, configures Maven Central as a repository, and declares dependencies for the Scala library and sttp modules. Dependencies are resolved for compilation and runtime. Required inputs include Gradle and JDK installations; the output is a workspace set up for compiling Scala code with the specified dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/drop-stdlib-forwards-bin-compat.md#_snippet_4\n\nLANGUAGE: Groovy\nCODE:\n```\nplugins {\n    id 'scala'\n}\nrepositories {\n    mavenCentral()\n}\ndependencies {\n    implementation 'org.scala-lang:scala-library:2.13.8'\n    implementation 'com.softwaremill.sttp.client3:core_2.13:3.8.3'\n    implementation 'com.softwaremill.sttp.shared:ws_2.13:1.2.7'\n}\n```\n\n----------------------------------------\n\nTITLE: Concatenating Sequences in Scala\nDESCRIPTION: Demonstrates concatenation of two sequences 'a' and 'b' using '++' operator to create a new sequence 'c' containing elements of both.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_42\n\nLANGUAGE: Scala\nCODE:\n```\nval c = a ++ b\n```\n\n----------------------------------------\n\nTITLE: Sending Asynchronous HTTP Requests with sttp in Scala 3\nDESCRIPTION: This example shows asynchronous HTTP GET requests with sttp and Futures in Scala 3, using 'DefaultFutureBackend'. The modern Scala 3 syntax is used, including wildcard imports. It requests a sample URL and returns a Future-wrapped Response. Dependencies: sttp.client4, Scala standard library (Future), working Scala 3 toolchain, and an HTTP backend. The URL and backend are configurable; output is a Future[Response[String]]. Ensure proper backend setup for async execution.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/http-client-what-else.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.concurrent.Future\nimport sttp.client4.*\n\nval asyncBackend = DefaultFutureBackend()\nval response: Future[Response[String]] = quickRequest\n  .get(uri\"https://example.com\")\n  .send(asyncBackend)\n```\n\n----------------------------------------\n\nTITLE: Defining Methods Without Explicit Return Types in Scala 2 and 3\nDESCRIPTION: Illustrates the Scala feature allowing omission of return type declarations. The return type is inferred by the compiler from the method body. Same functionality as prior examples but with less verbose syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-methods.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef sum(a: Int, b: Int) = a + b\ndef concatenate(s1: String, s2: String) = s1 + s2\n```\n\n----------------------------------------\n\nTITLE: Selective Importing from an Object in Scala\nDESCRIPTION: Example of selectively importing specific members from a singleton object in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-tools.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nimport StringUtils.{truncate, containsWhitespace}\ntruncate(\"Charles Carmichael\", 7)       // \"Charles\"\ncontainsWhitespace(\"Captain Awesome\")   // true\nisNullOrEmpty(\"Morgan Grimes\")          // Not found: isNullOrEmpty (error)\n```\n\n----------------------------------------\n\nTITLE: Comparing Case Class Instances in Scala\nDESCRIPTION: This snippet illustrates how case class instances are compared for equality in Scala. It defines two `Message` objects, `message2` and `message3`, with identical content but distinct references. The `==` operator performs a structural comparison, resulting in `true`, demonstrating that equality is based on the values of the fields, not the object's memory address.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/case-classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncase class Message(sender: String, recipient: String, body: String)\n\nval message2 = Message(\"jorge@catalonia.es\", \"guillaume@quebec.ca\", \"Com va?\")\nval message3 = Message(\"jorge@catalonia.es\", \"guillaume@quebec.ca\", \"Com va?\")\nval messagesAreTheSame = message2 == message3  // true\n```\n\n----------------------------------------\n\nTITLE: Defining a Binary-Compatible Case Class with Private Constructor in Scala 3\nDESCRIPTION: This snippet shows the Scala 3 approach to a binary-compatible case class, using private constructors, private extractors, and custom with-methods for each field through the copy method. The companion object defines a public apply factory method. Prerequisites are the Scala 3 compiler and recommendations for use with the MiMa tool. Inputs are 'name' and 'age', both Strings or Ints. Matching is restricted to typed patterns. This ensures compatibility while allowing controlled evolution of class structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/binary-compatibility-for-library-authors.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n// Mark the primary constructor as private\ncase class Person private (name: String, age: Int):\n  // Create withXxx methods for every field, implemented by using the (private) copy method\n  def withName(name: String): Person = copy(name = name)\n  def withAge(age: Int): Person = copy(age = age)\n\nobject Person:\n  // Create a public constructor (which uses the private primary constructor)\n  def apply(name: String, age: Int): Person = new Person(name, age)\n  // Make the extractor private\n  private def unapply(p: Person) = p\n```\n\n----------------------------------------\n\nTITLE: Defining a Singleton Object with Utility Methods in Scala 3\nDESCRIPTION: Example of creating a singleton object in Scala 3 with utility methods for string manipulation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-tools.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nobject StringUtils:\n  def truncate(s: String, length: Int): String = s.take(length)\n  def containsWhitespace(s: String): Boolean = s.matches(\".*\\\\s.*\")\n  def isNullOrEmpty(s: String): Boolean = s == null || s.trim.isEmpty\n```\n\n----------------------------------------\n\nTITLE: Defining a Multiline Method in Scala\nDESCRIPTION: In Scala, a multiline method body can be defined using an equals sign `=` followed by the expression block. Indentation is used to define the block scope.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\ndef walkThenRun() =\n  println(\"walk\")\n  println(\"run\")\n```\n\n----------------------------------------\n\nTITLE: Creating Empty Scala TreeSet with Custom Ordering\nDESCRIPTION: This Scala snippet demonstrates creating an empty `immutable.TreeSet`. It passes the previously defined `myOrdering` object, which specifies a descending order for strings, ensuring the resulting set maintains elements according to this custom ordering.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/sets.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nscala> TreeSet.empty(myOrdering)\nres1: scala.collection.immutable.TreeSet[String] = TreeSet()\n```\n\n----------------------------------------\n\nTITLE: Basic Integer Match Expression (Scala 2)\nDESCRIPTION: Demonstrates the basic syntax of a `match` expression in Scala 2, analogous to a Java `switch` statement, matching against integer literals. Includes a default case using `_` to handle all other values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\nval i = 1\n\n// later in the code ...\ni match {\n  case 1 => println(\"one\")\n  case 2 => println(\"two\")\n  case _ => println(\"other\")\n}\n```\n\n----------------------------------------\n\nTITLE: Keeping Main Thread Alive for Futures in Scala\nDESCRIPTION: Illustrates the use of a blocking call like `sleep` at the end of a simple application. This is often necessary in small examples to prevent the main thread from exiting before background `Future` computations, running on other threads, have a chance to complete and report their results.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/futures.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nsleep(5000)\n```\n\n----------------------------------------\n\nTITLE: Calling BuildFrom-based Intersperse in Scala\nDESCRIPTION: Provides a simple example call to the `intersperse` method implemented using `BuildFrom`. This call demonstrates how the compiler resolves the implicit `BuildFrom` parameter based on the receiver type (`List[Int]`), element type (`Int`), and the desired result type, ensuring the output is a `List[Int]` as expected.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collection-operations.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nList(1, 2, 3).intersperse(0)\n```\n\n----------------------------------------\n\nTITLE: Compare Symbols and TypeRepr in Scala Macros\nDESCRIPTION: Shows how Symbols can be used for accurate comparison of API definitions (`==` on Symbols) in contrast to TypeRepr comparisons which may not behave as expected. This highlights the importance of using Symbols for identity-based comparisons within macros. Requires Scala 3 macro reflection API.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/best-practices.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nleafSym == baseSym.children.head // Is true\n```\n\nLANGUAGE: scala\nCODE:\n```\nboxTpe.memberType(baseSym.children.head) == leafTpe // Is false\n```\n\n----------------------------------------\n\nTITLE: Using Intersection Types (`&`) in Function Signatures (Scala 3)\nDESCRIPTION: Shows the updated function signature for `cloneAndReset` in Scala 3, specifying the parameter `obj` type as `Cloneable & Resetable`. This intersection type ensures the object has both `clone` and `reset` capabilities. The function body is indicated as incomplete.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/compound-types.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef cloneAndReset(obj: Cloneable & Resetable): Cloneable = {\n  //...\n}\n```\n\n----------------------------------------\n\nTITLE: Function with Pattern Matching on Integers\nDESCRIPTION: A function that uses pattern matching to convert integer inputs to string representations, demonstrating how match expressions have return values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/pattern-matching.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef matchTest(x: Int): String = x match {\n  case 1 => \"one\"\n  case 2 => \"two\"\n  case _ => \"other\"\n}\nmatchTest(3)  // returns other\nmatchTest(1)  // returns one\n```\n\n----------------------------------------\n\nTITLE: Wrapping a Potentially Blocking Call - Scala\nDESCRIPTION: Illustrates the use of the blocking function to wrap a call that could block, allowing third-party code to run in a safe manner within Scala's concurrency framework. Dependencies: the function potentiallyBlockingCall and the scala.concurrent package. The construction ensures the runtime scheduler can adjust resource allocation accordingly. Inputs: a code block that may block; outputs: the code’s result. Exceptions in the block are propagated.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/futures-promises.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\nblocking {\n  potentiallyBlockingCall()\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing List/Sequence Elements by Index in Scala\nDESCRIPTION: Shows accessing elements from a Scala sequence or ArrayBuffer using parentheses notation, which behaves like method calls.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_38\n\nLANGUAGE: Scala\nCODE:\n```\na(0)\na(1)\n```\n\n----------------------------------------\n\nTITLE: Defining a function with explicit type signature in Scala\nDESCRIPTION: Provides an example of an anonymous function assigned to a val `f` with an explicit type `(Int, Int) => Int`. It computes the sum of two integers. Demonstrates the syntax for function type annotations and their bodies in Scala, emphasizing the connection between function signatures and their implementation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-hofs.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nval f: (Int, Int) => Int = (a, b) => a + b\n```\n\n----------------------------------------\n\nTITLE: Fixing missing ClassTag by adding a context bound in Scala 2 and 3\nDESCRIPTION: This snippet shows the correct definition of the wrapper function 'wrap' in both Scala 2 and 3, where the type parameter U is constrained with a ClassTag context bound. This addition ensures that an implicit ClassTag instance for U is available, satisfying the requirements of 'evenElems'. The REPL output indicates that 'wrap' has an implicit ClassTag parameter, making generic array creation possible for any type U with a ClassTag instance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/arrays.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nscala> def wrap[U: ClassTag](xs: Vector[U]) = evenElems(xs)\ndef wrap[U](xs: Vector[U])(implicit evidence$1: scala.reflect.ClassTag[U]): Array[U]\n```\n\n----------------------------------------\n\nTITLE: 'for' loop over list in Scala 2\nDESCRIPTION: Creates a loop using 'for' in Scala 2 to iterate over a list and print each element.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval ints = List(1, 2, 3, 4, 5)\n\nfor (i <- ints) println(i)\n```\n\n----------------------------------------\n\nTITLE: Using @deprecated annotation in Scala\nDESCRIPTION: Demonstrates how to mark a method as deprecated using the `@deprecated` annotation with a message and a suggested replacement version identifier. Compiling code that calls a method annotated this way will result in a compiler warning.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/annotations.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject DeprecationDemo extends App {\n  @deprecated(\"deprecation message\", \"release # which deprecates method\")\n  def hello = \"hola\"\n\n  hello\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nobject DeprecationDemo extends App:\n  @deprecated(\"deprecation message\", \"release # which deprecates method\")\n  def hello = \"hola\"\n\n  hello\n```\n\n----------------------------------------\n\nTITLE: Using functions `sum` and `multiply` with `executeAndPrint`\nDESCRIPTION: Shows how to define simple functions `sum` and `multiply`, then pass them as arguments to `executeAndPrint` along with integer values. Demonstrates function passing and execution resulting in printed outputs for calculations 3 + 11 and 3 * 9.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-hofs.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\ndef sum(x: Int, y: Int) = x + y\n def multiply(x: Int, y: Int) = x * y\n\n executeAndPrint(sum, 3, 11)       // печатает 14\n executeAndPrint(multiply, 3, 9)   // печатает 27\n```\n\n----------------------------------------\n\nTITLE: Creating a basic package in Scala 2 and 3\nDESCRIPTION: Defines a simple package named 'users' containing a class 'User'. This demonstrates how to declare packages at the top of a Scala file, which helps in organizing code into modular namespaces. Uses standard package declaration syntax suitable for both Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/packages-and-imports.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\npackage users\n\nclass User\n```\n\n----------------------------------------\n\nTITLE: Appending Elements Using ':+': Syntax Reminder for Scala List - Scala\nDESCRIPTION: This snippet illustrates the use of the ':+'' operator to append an element to the end of an immutable List in Scala. No special dependencies are needed. The example demonstrates how operator orientation affects element placement (List on left, new element on right) and serves as a guide to proper method usage. Inputs are an existing List and the value to append; output is a new List instance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/list-class.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\na :+ 4\n```\n\n----------------------------------------\n\nTITLE: Implementing a List Filter with Nested Function in Scala\nDESCRIPTION: This snippet defines an object with an `App` trait, implementing a `filter` method that contains a nested helper function `process`. The `process` function recursively filters elements less than a specified threshold from a list, demonstrating nested function scope and recursion in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/nested-functions.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject FilterTest extends App {\n  def filter(xs: List[Int], threshold: Int) = {\n    def process(ys: List[Int]): List[Int] =\n      if (ys.isEmpty) ys\n      else if (ys.head < threshold) ys.head :: process(ys.tail)\n      else process(ys.tail)\n    process(xs)\n  }\n  println(filter(List(1, 9, 2, 8, 3, 7, 4), 5))\n}\n```\n\n----------------------------------------\n\nTITLE: Using Private Methods in Scala Classes\nDESCRIPTION: Shows how to use the private modifier to restrict method access. Private methods can only be accessed within the same class and cannot be overridden by subclasses.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\nclass Animal {\n  private def breathe() = println(\"I'm breathing\")\n}\n\nclass Cat extends Animal {\n  // this method won't compile\n  override def breathe() = println(\"Yo, I'm totally breathing\")\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Animal:\n  private def breathe() = println(\"I'm breathing\")\n\nclass Cat extends Animal:\n  // this method won't compile\n  override def breathe() = println(\"Yo, I'm totally breathing\")\n```\n\n----------------------------------------\n\nTITLE: Migrating with differing parameter and result types for Scala Seq - Scala\nDESCRIPTION: This snippet presents an intermediate migration strategy for Scala 2.13 where function parameters use the mutable or general scala.collection.Seq while return types use scala.collection.immutable.Seq. It exemplifies a way to improve API robustness following the robustness principle by accepting less strict input types and returning immutable output types. Dependencies include both scala.collection and scala.collection.immutable packages. Inputs and outputs are typed accordingly with collection.Seq for input orders and immutable.Seq for resulting foods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/collections-migration-213.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection\nimport scala.collection.immutable\n\nobject FoodToGo {\n  def orderFood(order: collection.Seq[Order]): immutable.Seq[Food]\n}\n```\n\n----------------------------------------\n\nTITLE: Using @main annotated method with command-line arguments in Scala 3\nDESCRIPTION: This example illustrates a '@main' method that accepts multiple parameters of different types, including a variable-length argument. It shows how the method processes command-line inputs, with parameter type conversions handled via given instances of 'CommandLineParser.FromString'. The method constructs a greeting string based on inputs and demonstrates argument validation and error handling.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/methods-main-methods.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n@main def happyBirthday(age: Int, name: String, others: String*) =\n  val suffix = (age % 100) match\n    case 11 | 12 | 13 => \"th\"\n    case _ => (age % 10) match\n      case 1 => \"st\"\n      case 2 => \"nd\"\n      case 3 => \"rd\"\n      case _ => \"th\"\n\n  val sb = StringBuilder(s\"Happy $age$suffix birthday, $name\")\n  for other <- others do sb.append(\" and \").append(other)\n  sb.toString\n```\n\n----------------------------------------\n\nTITLE: Starting Scala REPL with Dependency using Scala CLI\nDESCRIPTION: Demonstrates using the 'scala-cli repl' command with the '--dep' option to easily launch a Scala REPL session that includes a specified third-party library (com.lihaoyi::os-lib:0.7.8) on the classpath. This simplifies the process compared to manually resolving dependencies or setting up a build tool project.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/scala-cli.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nscala-cli repl --dep com.lihaoyi::os-lib:0.7.8\n```\n\n----------------------------------------\n\nTITLE: Attempting to Reassign an Immutable Value in Scala\nDESCRIPTION: Attempts to reassign a value that was declared immutable with val, which will result in a compilation error. This demonstrates the immutability constraint in Scala. Shows that the left-hand-side identifier of a val cannot be reassigned after its initial definition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nx = 3 // This does not compile.\n```\n\n----------------------------------------\n\nTITLE: Implementing a Generic Trait in Scala\nDESCRIPTION: Implementation of the Iterator trait with a concrete IntIterator class that iterates through integers up to a specified limit. Shows how to extend a trait and implement abstract methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/traits.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait Iterator[A] {\n  def hasNext: Boolean\n  def next(): A\n}\n\nclass IntIterator(to: Int) extends Iterator[Int] {\n  private var current = 0\n  override def hasNext: Boolean = current < to\n  override def next(): Int = {\n    if (hasNext) {\n      val t = current\n      current += 1\n      t\n    } else 0\n  }\n}\n\nval iterator = new IntIterator(10)\niterator.next()  // returns 0\niterator.next()  // returns 1\n```\n\n----------------------------------------\n\nTITLE: Creating Multiline Strings with Triple Quotes in Scala\nDESCRIPTION: This snippet illustrates how to create multiline strings using triple double-quotes, which preserves line breaks and formatting. It also demonstrates the use of the `stripMargin` method with a `|` delimiter to remove indentation, making multiline strings cleaner and easier to read.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/two-notes-about-strings.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval speech = \"\"\"Four score and\n               seven years ago\n               our fathers ...\"\"\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval speech = \"\"\"Four score and\n               |seven years ago\n               |our fathers ...\"\"\".stripMargin\n```\n\n----------------------------------------\n\nTITLE: Method Overriding in Scala\nDESCRIPTION: Shows the syntax for overriding methods from parent classes or traits. The 'override' keyword is required for explicit method overriding in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/cheatsheets/index.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nclass C extends D { override def f = ...}\n```\n\n----------------------------------------\n\nTITLE: Adding Specific MUnit Version using sbt\nDESCRIPTION: Adds a specific version of the MUnit library directly to an sbt project's dependencies in `build.sbt`. The dependency is explicitly scoped to the `Test` configuration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-munit.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"org.scalameta\" %% \"munit\" % \"1.1.0\" % Test\n```\n\n----------------------------------------\n\nTITLE: Using fallbackTo Combinator to Provide Alternate Future Result in Scala\nDESCRIPTION: Shows how to chain Futures such that if obtaining the USD quote fails, the CHF quote is used instead via fallbackTo. It creates two Futures for currency values mapped to strings and combines them with fallbackTo. The inputs are Futures representing currency value fetches; the output is a Future with whichever completes successfully first. This snippet demonstrates failover strategies in Future compositions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/futures-promises.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nval usdQuote = Future {\n  connection.getCurrentValue(USD)\n} map {\n  usd => \"Value: \" + usd + \"$\"\n}\nval chfQuote = Future {\n  connection.getCurrentValue(CHF)\n} map {\n  chf => \"Value: \" + chf + \"CHF\"\n}\n\nval anyQuote = usdQuote fallbackTo chfQuote\n\nanyQuote onSuccess { println(_) }\n```\n\n----------------------------------------\n\nTITLE: Defining Classes and Traits with UpperCamelCase in Scala\nDESCRIPTION: Demonstrates the convention of naming Scala classes and traits using UpperCamelCase to align with Java conventions. This is intended to clearly distinguish types and is the standard styling for class/trait declarations. There are no special dependencies; input is standard Scala code and output is compiled class/trait entities.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/naming-conventions.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass MyFairLady\n```\n\n----------------------------------------\n\nTITLE: Defining generic array creation with ClassTag context bound in Scala 3\nDESCRIPTION: This Scala 3 version of 'evenElems' performs the same functionality as its Scala 2 counterpart: it returns an array of elements from even indices of a Vector of T. The code leverages Scala 3's streamlined syntax (omitting braces and using 'do') while still demanding an implicit ClassTag for T to facilitate array creation. The method initializes an array, iterates through the Vector, and copies even elements into the array. It demonstrates idiomatic Scala 3 context bound usage with maintained runtime type information via ClassTag.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/arrays.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect.ClassTag\n// this works\ndef evenElems[T: ClassTag](xs: Vector[T]): Array[T] =\n  val arr = new Array[T]((xs.length + 1) / 2)\n  for i <- 0 until xs.length by 2 do\n    arr(i / 2) = xs(i)\n  arr\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Grouped vs Sliding Iterators (Scala)\nDESCRIPTION: Illustrates the behavior of the `grouped` and `sliding` methods available on Scala `Iterable` collections using a REPL session. It shows how `grouped(n)` provides an iterator yielding non-overlapping chunks of size `n`, while `sliding(n)` provides an iterator yielding overlapping windows of size `n`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/trait-iterable.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val xs = List(1, 2, 3, 4, 5)\nxs: List[Int] = List(1, 2, 3, 4, 5)\nscala> val git = xs grouped 3\ngit: Iterator[List[Int]] = non-empty iterator\nscala> git.next()\nres3: List[Int] = List(1, 2, 3)\nscala> git.next()\nres4: List[Int] = List(4, 5)\nscala> val sit = xs sliding 3\nsit: Iterator[List[Int]] = non-empty iterator\nscala> sit.next()\nres5: List[Int] = List(1, 2, 3)\nscala> sit.next()\nres6: List[2, 3, 4]\nscala> sit.next()\nres7: List[3, 4, 5]\n```\n\n----------------------------------------\n\nTITLE: Defining foldLeft Method with Multiple Parameter Lists in Scala\nDESCRIPTION: Example of the foldLeft method defined in Scala's Iterable trait, which uses multiple parameter lists to first take an initial value and then a binary operation function.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/multiple-parameter-lists.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Iterable[A] {\n   ...\n   def foldLeft[B](z: B)(op: (B, A) => B): B\n   ...\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait Iterable[A]:\n...\ndef foldLeft[B](z: B)(op: (B, A) => B): B\n...\n```\n\n----------------------------------------\n\nTITLE: Using classes after hiding certain imports in Scala 2 and 3\nDESCRIPTION: Shows that classes like 'Random' are inaccessible after being hidden, but other imported classes remain usable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/packaging-imports.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval r = new Random   // won’t compile\nnew ArrayList        // works\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Generators in For Loops - JavaScript & Scala\nDESCRIPTION: Compares how to achieve nested loop behavior or iteration over multiple collections. JavaScript typically uses nested 'for' loops, while Scala allows multiple 'generators' within a single 'for' expression.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_28\n\nLANGUAGE: JavaScript\nCODE:\n```\nlet str = \"ab\";\nfor (let i = 1; i < 3; i++) {\n  for (var j = 0; j < str.length; j++) {\n    for (let k = 1; k < 11; k += 5) {\n      let c = str.charAt(j);\n      console.log(`i: ${i} j: ${c} k: ${k}`);\n    }\n  }\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor\n  i <- 1 to 2\n  j <- 'a' to 'b'\n  k <- 1 to 10 by 5\ndo\n  println(s\"i: $i, j: $j, k: $k\")\n```\n\n----------------------------------------\n\nTITLE: Defining Implicit Conversion from List to Ordered in Scala\nDESCRIPTION: Showcases an example of an implicit method that converts a List[A] to an Ordered[List[A]] within Scala. It describes how such conversions are declared and used to enable ordering comparisons between lists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/implicit-conversions.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit def list2ordered[A](x: List[A])\n        (implicit elem2ordered: A => Ordered[A]): Ordered[List[A]] =\n      new Ordered[List[A]] {\n        // Implement comparison logic\n        def compare(that: List[A]): Int = 1\n      }\n```\n\n----------------------------------------\n\nTITLE: Using reduce with anonymous functions for sum in Scala\nDESCRIPTION: A concise way to sum all elements in a list using reduce with an anonymous function.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-methods.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nscala> a.reduce(_ + _)\nres0: Int = 10\n```\n\n----------------------------------------\n\nTITLE: Iterating over a Vector - Scala\nDESCRIPTION: Shows how to traverse the elements of a Vector using a for-comprehension and print each item. Inputs: Vector of strings; Outputs: each element printed to standard output on a new line. Dependencies: standard Scala runtime. Appropriate when you need to process or display every item in an immutable collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/vector-class.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val names = Vector(\"Joel\", \"Chris\", \"Ed\")\nval names: Vector[String] = Vector(Joel, Chris, Ed)\n\nscala> for (name <- names) println(name)\nJoel\nChris\nEd\n```\n\n----------------------------------------\n\nTITLE: Defining a Parameterized greet Method Returning a Custom Greeting Function in Scala\nDESCRIPTION: Defines an improved `greet` method that takes a `String` parameter `theGreeting` to customize the greeting message. Returns a function that takes a name string and prints the customized greeting concatenated with the name. This pattern enhances flexibility by allowing the caller to specify different greeting prefixes. The method returns a function of type `String => Unit` with side effects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-write-method-returns-function.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef greet(theGreeting: String): String => Unit =\n  (name: String) => println(s\"$theGreeting, $name\")\n```\n\n----------------------------------------\n\nTITLE: Creating an Immutable Array Wrapper Using Opaque Types in Scala\nDESCRIPTION: Defines an opaque type IArray wrapping a native Array[A], enabling a write-once, immutable array abstraction enforcing safety conventions at compile time. It includes methods to initialize an IArray, access size and elements, create sorted copies, and perform binary search using java.util.Arrays. A manual binary search implementation is also provided. This abstraction enforces immutability without runtime overhead by erasing to the underlying Array, optimizing performance-critical code. Expected inputs are native arrays and indices; outputs include array sizes, elements, sorted arrays, and search indices.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/opaque-types.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\npackage object ia {\n\n  import java.util.Arrays\n\n  opaque type IArray[A] = Array[A]\n\n  object IArray {\n    @inline final def initialize[A](body: => Array[A]): IArray[A] = body\n\n    @inline final def size(ia: IArray[A]): Int = ia.length\n    @inline final def get(ia: IArray[A], i: Int): A = ia(i)\n\n    // return a sorted copy of the array\n    def sorted(ia: IArray[A]): IArray[A] = {\n      val arr = Arrays.copyOf(ia, ia.length)\n      scala.util.Sorting.quickSort(arr)\n      arr\n    }\n\n    // use a standard java method to search a sorted IArray.\n    // (note that this doesn't mutate the array).\n    def binarySearch(ia: IArray[Long], elem: Long): Int =\n      Arrays.binarySearch(ia, elem)\n  }\n\n  // same as IArray.binarySearch but implemented by-hand.\n  //\n  // given a sorted IArray, returns index of `elem`,\n  // or a negative value if not found.\n  def binaryIndexOf(ia: IArray[Long], elem: Long): Int = {\n    var lower: Int = 0\n    var upper: Int = IArray.size(ia)\n    while (lower <= upper) {\n      val middle = (lower + upper) >>> 1\n      val n = IArray.get(ia, middle)\n\n      if (n == elem) return middle\n      else if (n < elem) first = middle + 1\n      else last = middle - 1\n    }\n    -lower - 1\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a pure double function in Scala\nDESCRIPTION: This snippet demonstrates defining a pure function `double` that takes an integer input and returns its doubled value. It illustrates a simple, deterministic, side-effect-free Scala function suitable for functional programming.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/pure-functions.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef double(i: Int): Int = i * 2\n```\n\n----------------------------------------\n\nTITLE: Creating and Using ListBuffer in Scala\nDESCRIPTION: Shows how to create an empty ListBuffer, add elements to it, and convert it to a List. ListBuffer is ideal when you need to build a List by appending elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/concrete-mutable-collection-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval buf = scala.collection.mutable.ListBuffer.empty[Int]\nbuf += 1\nbuf += 10\nbuf.toList\n```\n\n----------------------------------------\n\nTITLE: Defining a Method and Passing it to Map Using def Syntax in Scala\nDESCRIPTION: Shows that a Scala method defined with def can be passed directly as a parameter to a higher-order function such as map, emphasizing the interchangeability between methods and functions in Scala. This example highlights the practical use of def for those familiar with traditional OOP languages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/passing-functions-around.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef double(i: Int): Int = i * 2\n```\n\n----------------------------------------\n\nTITLE: Configuring sbt for Scala 3 project depending on Scala 2.13 module\nDESCRIPTION: This snippet demonstrates how to configure an sbt build to include a Scala 2.13 dependency in a Scala 3 project using the CrossVersion.for3Use2_13 setting, enabling compatibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/compatibility-classpath.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// build.sbt (sbt 1.5 or higher)\nlazy val foo = project.in(file(\"foo\"))\n  .settings(\n    scalaVersion := \"3.3.1\",\n    libraryDependencies += (\"org.bar\" %% \"bar\" % \"1.0.0\").cross(CrossVersion.for3Use2_13)\n  )\n```\n\n----------------------------------------\n\nTITLE: Implementing a Recursive While Loop with By-name Parameters in Scala 2\nDESCRIPTION: This example shows how to define a custom `whileLoop` function in Scala 2 using by-name parameters for both the loop condition and body. The function repeatedly evaluates the condition, recursively calling itself and executing the provided body as long as the condition remains true. The code requires only the standard Scala library, using recursion and pass-by-name semantics. The key parameters are `condition: => Boolean` and `body: => Unit`, both of which are re-evaluated on each recursive call. The output demonstrates printing values while decrementing a variable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/by-name-parameters.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef whileLoop(condition: => Boolean)(body: => Unit): Unit =\n  if (condition) {\n    body\n    whileLoop(condition)(body)\n  }\n\nvar i = 2\n\nwhileLoop (i > 0) {\n  println(i)\n  i -= 1\n}  // prints 2 1\n```\n\n----------------------------------------\n\nTITLE: Using Simplified Java Annotation in Scala\nDESCRIPTION: Applying the SourceURL annotation to a Scala class using the simplified constructor-like syntax for the primary 'value' parameter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/annotations.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n@SourceURL(\"https://coders.com/\")\nclass MyScalaClass ...\n```\n\n----------------------------------------\n\nTITLE: Using a View Subsection to Mutate Part of a Scala Array - Scala\nDESCRIPTION: Applies the `negate` function to the `subarr` view (a slice of the original array `arr`), showing that modifications on the view reflect on the original array. This exemplifies how views enable modular and localized updates without breaking abstraction or creating copies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/views.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nnegate(subarr)\narr\n```\n\n----------------------------------------\n\nTITLE: Iteratively Computing Square Roots Using Parallel Trie Maps in Scala\nDESCRIPTION: This Scala snippet demonstrates computing square roots of a set of numbers using the Babylonian method through iterative updates stored in a `ParTrieMap`. Each iteration updates the approximate square root for elements concurrently, removing those that have converged within a threshold from the map, effectively filtering active elements dynamically. The snippet requires Scala's parallel collections. The `Entry` case class holds the current square root estimate. Inputs are integers mapped to entries; outputs are the approximated square roots in the map until convergence. The concurrent map allows safe in-place modification and removal during iteration without locking. It assumes sufficient floating-point precision and does not handle exceptional numeric inputs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/parallel-collections/ctries.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Entry(num: Double) {\n  var sqrt = num\n}\n\nval length = 50000\n\n// готовим исходные данные\nval entries = (1 until length) map { num => Entry(num.toDouble) }\nval results = ParTrieMap()\nfor (e <- entries) results += ((e.num, e))\n\n// вычисляем квадратные корни\nwhile (results.nonEmpty) {\n  for ((num, e) <- results) {\n    val nsqrt = 0.5 * (e.sqrt + e.num / e.sqrt)\n    if (math.abs(nsqrt - e.sqrt) < 0.01) {\n      results.remove(num)\n    } else e.sqrt = nsqrt\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Stack Class (Scala 2)\nDESCRIPTION: Defines a generic `Stack` class in Scala 2 using a type parameter `A` enclosed in square brackets. The class internally uses a `List[A]` to store elements and provides methods `push(x: A)`, `peek: A`, and `pop(): A` to manipulate the stack.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-generics.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// here we declare the type parameter A\n//          v\nclass Stack[A] {\n  private var elements: List[A] = Nil\n  //                         ^\n  //  Here we refer to the type parameter\n  //          v\n  def push(x: A): Unit =\n    elements = elements.prepended(x)\n  def peek: A = elements.head\n  def pop(): A = {\n    val currentTop = peek\n    elements = elements.tail\n    currentTop\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Cross-Graph Node Connections using Type Projections in Scala\nDESCRIPTION: Presents a modified `Graph` implementation (for Scala 2 and Scala 3) that uses a type projection (`Graph#Node`) for the `connectedNodes` list and the `connectTo` method parameter. This allows instances of `Node` from different `Graph` instances to be treated as compatible, enabling connections between nodes belonging to different graphs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/inner-classes.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass Graph {\n  class Node {\n    var connectedNodes: List[Graph#Node] = Nil\n    def connectTo(node: Graph#Node): Unit = {\n      if (!connectedNodes.exists(node.equals)) {\n        connectedNodes = node :: connectedNodes\n      }\n    }\n  }\n  var nodes: List[Node] = Nil\n  def newNode: Node = {\n    val res = new Node\n    nodes = res :: nodes\n    res\n  }\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass Graph:\n  class Node:\n    var connectedNodes: List[Graph#Node] = Nil\n    def connectTo(node: Graph#Node): Unit =\n      if !connectedNodes.exists(node.equals) then\n        connectedNodes = node :: connectedNodes\n\n  var nodes: List[Node] = Nil\n  def newNode: Node =\n    val res = Node()\n    nodes = res :: nodes\n    res\n```\n\n----------------------------------------\n\nTITLE: Reducing Non-Associative Operations in Scala Parallel Collections\nDESCRIPTION: Demonstrates the behavior of using a non-associative operation, subtraction, within a Scala parallel collection's reduce function. Using a parallel list of integers, repeated runs of reduce with subtraction produce different results due to parallel partitions being combined in an arbitrary temporal order. Dependencies include Scala's parallel collections library, with the key parameter being the binary subtraction function. The input is a parallel collection of integers, and the output is an integer result which is non-deterministic. This snippet highlights the limitation that non-associative operations can lead to unpredictable results in parallel reductions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/overview.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval list = (1 to 1000).toList.par\nlist.reduce(_-_)\nlist.reduce(_-_)\nlist.reduce(_-_)\n```\n\n----------------------------------------\n\nTITLE: Debugging Macros with Expression Visualization in Scala 3\nDESCRIPTION: This macro implementation shows how to debug macros by printing string representations of expressions using the show method. It demonstrates a pattern for logging intermediate states during macro expansion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/macros.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef debugPowerCode(\n  x: Expr[Double],\n  n: Expr[Int]\n)(using Quotes): Expr[Double] =\n  println(\n    s\"powerCode \\n\" +\n    s\"  x := ${x.show}\\n\" +\n    s\"  n := ${n.show}\")\n  val code = powerCode(x, n)\n  println(s\"  code := ${code.show}\")\n  code\n```\n\n----------------------------------------\n\nTITLE: Creating and using mutable OOP instances in Python and Scala\nDESCRIPTION: Demonstrates how to instantiate and modify mutable class instances in Python and Scala. Dependencies include previous class definitions. Inputs are initial names and modifications to the name property. Outputs are printed names before and after modification and the result from speak method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\np = Person(\"John\")\np.name  # John\np.name = 'Fred'\np.name  # Fred\np.speak()\n```\n\n----------------------------------------\n\nTITLE: Defining classes with inheritance in Scala\nDESCRIPTION: Illustrates how to define a class `C` that inherits from another class `D`, enabling reuse and extension of functionality. Constructors parameters and the passing of those parameters in inheritance are also shown to demonstrate delegation to superclass constructors.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\nclass C extends D { ... }\nclass D(var x: R)\nclass C(x: R) extends D(x)\n```\n\n----------------------------------------\n\nTITLE: Source Compatibility Breaking Example in Scala\nDESCRIPTION: Illustrates how the proposal could break source compatibility in cases where implicit conversions were previously used to convert monomorphic to polymorphic functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/polymorphic-eta-expansion.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.language.implicitConversions\n\ngiven conv: Conversion[Any => Any, [T] => T => T] = f => ([T] => (x: T) => x)\n\ndef method[T](x: T): T = x\n\nval function: [T] => T => T = method\n// before: method is eta-expanded to Any => Any, and then converted using conv to [T] => T => T\n// now: method is eta-expanded to [T] => T => T (conv is not called)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Scala Inliner Warnings with @inline\nDESCRIPTION: Provides a Scala code example used to illustrate the inliner's behavior, particularly why an `@inline` annotated method might not be inlined. It shows that a non-final method (`C.f`) cannot be inlined from a superclass context, but an overridden, effectively final method (`T.f`) can.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/compiler-options/optimizer.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nclass C {\n  @inline def f = 1\n  def t = f           // cannot inline: C.f is not final\n}\nobject T extends C {\n  override def t = f  // can inline: T.f is final\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Case Class and Creating a Three-Element Tuple in Scala REPL\nDESCRIPTION: Defines an immutable case class Person with a name and then creates a three-element tuple combining an Int, a String, and an instance of Person. Demonstrates usage of both custom classes and tuples in Scala REPL, highlighting type inference and tuple creation from mixed types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/tuples.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ncase class Person(name: String)\nval t = (3, \"Three\", new Person(\"David\"))\n```\n\n----------------------------------------\n\nTITLE: Reducing a list with a function using reduce in Scala\nDESCRIPTION: Demonstrates the use of the reduce method to aggregate list elements into a single value by repeatedly applying a binary function. Includes an example defining a custom add method with debugging output, initializing a list, and showing the evaluation steps during reduction. Also shows concise reduce calls to sum or multiply all elements. Highlights the concept of reducing a collection down to a single result using a combining function.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-methods.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ndef add(x: Int, y: Int): Int = {\n  val theSum = x + y\n  println(s\"received $x and $y, their sum is $theSum\")\n  theSum\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef add(x: Int, y: Int): Int =\n  val theSum = x + y\n  println(s\"received $x and $y, their sum is $theSum\")\n  theSum\n```\n\nLANGUAGE: scala\nCODE:\n```\nval a = List(1,2,3,4)\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> a.reduce(add)\nreceived 1 and 2, their sum is 3\nreceived 3 and 3, their sum is 6\nreceived 6 and 4, their sum is 10\nres0: Int = 10\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> a.reduce(_ + _)\nres0: Int = 10\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> a.reduce(_ * _)\nres1: Int = 24\n```\n\n----------------------------------------\n\nTITLE: Использование метода 'map' с лямбда-выражением в Scala 2 и 3\nDESCRIPTION: Данный пример демонстрирует применение метода 'map' для умножения каждого элемента списка на 2 с использованием лямбда-выражения. Показывает эквивалентность нескольких способов передачи функции, включая использование анонимной функции и оператора '_'. Требует наличия коллекций типа List.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-functions.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval a = List(1, 2, 3).map(i => i * 2)   // List(2,4,6)\nval b = List(1, 2, 3).map(_ * 2)        // List(2,4,6)\n```\n\n----------------------------------------\n\nTITLE: Concatenating Strings Using + and String Interpolation in Scala\nDESCRIPTION: This snippet demonstrates both traditional string concatenation with `+` and the more readable string interpolation with `s` prefix, showing how to embed variables within strings. It highlights the convenience of string interpolation for constructing strings with variables such as first name, middle initial, and last name.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/two-notes-about-strings.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval firstName = \"John\"\nval mi = 'C'\nval lastName = \"Doe\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval name = firstName + \" \" + mi + \" \" + lastName\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval name = s\"$firstName $mi $lastName\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\nprintln(s\"Name: $firstName $mi $lastName\")\n```\n\n----------------------------------------\n\nTITLE: Reducing Sequence to Single Value in Scala\nDESCRIPTION: Covers the `reduce` method, which combines elements of a sequence into a single value using a specified binary operation. It shows an example with a helper method for debugging the reduction process and then demonstrates the concise syntax for sum and product.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/collections-methods.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ndef add(x: Int, y: Int): Int = {\n    val theSum = x + y\n    println(s\"received $x and $y, their sum is $theSum\")\n    theSum\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval a = List(1,2,3,4)\n```\n\nLANGUAGE: scala\nCODE:\n```\na.reduce(add)\n```\n\nLANGUAGE: scala\nCODE:\n```\na.reduce(_ + _)\n```\n\nLANGUAGE: scala\nCODE:\n```\na.reduce(_ * _)\n```\n\n----------------------------------------\n\nTITLE: Viewing Scala Compiler Syntax Rewriting Options - text\nDESCRIPTION: This snippet displays the relevant Scala compiler options (`scalac`) used for syntax rewriting. It lists options such as `-indent`, `-new-syntax`, `-no-indent`, `-old-syntax`, and `-rewrite`, each controlling different aspects of syntax enforcement or migration. The snippet is used to identify flags that facilitate transforming source code between Scala 2 and Scala 3 styles.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tooling-syntax-rewriting.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n$ scalac\nUsage: scalac <options> <source files>\nwhere possible standard options include:\n...\n-indent</b>            Allow significant indentation\n...\n-new-syntax</b>        Require `then` and `do` in control expressions.\n-no-indent</b>          Require classical {...} syntax, indentation is not significant.\n...\n-old-syntax</b>        Require `(...)` around conditions.\n...\n-rewrite</b>           When used in conjunction with a `...-migration` source version,\n                       rewrites sources to migrate to new version.\n...\n```\n\n----------------------------------------\n\nTITLE: Recursive enum for generic List in Scala 3\nDESCRIPTION: This snippet models a generic singly linked list with 'Nil' for empty list and 'Cons' for an element and tail. It exemplifies recursive data structures commonly used in functional programming.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-adts-gadts.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nenum List[+A]:\n  case Nil\n  case Cons(head: A, tail: List[A])\n```\n\n----------------------------------------\n\nTITLE: Avoiding All-Caps for Descriptive Type Parameters in Scala (Incorrect)\nDESCRIPTION: Shows an incorrect example where all-uppercase names ('KEY', 'VALUE') are used for type parameters. Scala conventions dictate using capitalized words like class names instead of all-caps for descriptive type parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/naming-conventions.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\n// Wrong; don't use all-caps\nclass Map[KEY, VALUE] {\n  def get(key: KEY): VALUE\n  def put(key: KEY, value: VALUE): Unit\n}\n```\n\n----------------------------------------\n\nTITLE: Using a higher-order method with a function argument in Scala\nDESCRIPTION: Demonstrates invoking the higher-order method `sayHello` by passing the function `helloJoe` as an argument. This code shows practical usage of passing functions matching the expected signature into methods, resulting in the side effect of printing \"Hello, Joe\".\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-hofs.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nsayHello(helloJoe)   // prints \"Hello, Joe\"\n```\n\n----------------------------------------\n\nTITLE: Initializing a Java Array with Strings - Java\nDESCRIPTION: This snippet shows how to initialize a Java String array using array initializer syntax. The resulting array is of type String[] and contains two string elements. No specific dependencies are needed beyond core Java. This is used to illustrate the relationship between Scala's Array and Java's arrays.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_52\n\nLANGUAGE: Java\nCODE:\n```\nString[] a = {\"a\", \"b\"};\n```\n\n----------------------------------------\n\nTITLE: Parsing Strings into Scala ASTs using `ToolBox.parse`\nDESCRIPTION: Illustrates how to use `ToolBox.parse` from `scala.tools.reflect` to create an AST from a string representation of code like \"println(2)\". This method requires `scala-compiler.jar` on the classpath and offers more flexibility than `reify` but less robustness regarding type information and symbol binding initially.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\nscala> import scala.reflect.runtime.universe._\nimport scala.reflect.runtime.universe._\n\nscala> import scala.tools.reflect.ToolBox\nimport scala.tools.reflect.ToolBox\n\nscala> val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()\ntb: scala.tools.reflect.ToolBox[scala.reflect.runtime.universe.type] = scala.tools.reflect.ToolBoxFactory$ToolBoxImpl@7bc979dd\n\nscala> showRaw(tb.parse(\"println(2)\"))\nres2: String = Apply(Ident(TermName(\"println\")), List(Literal(Constant(2))))\n```\n\n----------------------------------------\n\nTITLE: Computing Square Roots with ParTrieMap in Scala\nDESCRIPTION: This snippet demonstrates using Scala's `ParTrieMap` to iteratively compute square roots of a set of numbers using the Babylonian method. It defines a case class `Entry` to hold the number and its current square root approximation. Entries are added to a `ParTrieMap` and iteratively updated within a loop. Entries are removed from the map once their square root converges, showcasing the ability to modify the collection during traversal.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/ctries.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Entry(num: Double) {\n  var sqrt = num\n}\n\nval length = 50000\n\t\n// prepare the list\nval entries = (1 until length) map { num => Entry(num.toDouble) }\nval results = ParTrieMap()\nfor (e <- entries) results += ((e.num, e))\n\t\n// compute square roots\nwhile (results.nonEmpty) {\n  for ((num, e) <- results) {\n    val nsqrt = 0.5 * (e.sqrt + e.num / e.sqrt)\n    if (math.abs(nsqrt - e.sqrt) < 0.01) {\n      results.remove(num)\n    } else e.sqrt = nsqrt\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning a Two-Parameter Function Literal to a Value in Scala\nDESCRIPTION: Defines a Scala function literal assigned to a `val` named `f` having the type `(Int, Int) => Int`. The function takes two integers `a` and `b` and returns their sum. This example illustrates the consistent syntax between function type annotations and function literals in Scala, useful for composing functions and passing them as parameters. Compatible with Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-hofs.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nval f: (Int, Int) => Int = (a, b) => a + b\n```\n\n----------------------------------------\n\nTITLE: Using Triple Quotes for Embedded Quotes in Scala `s`-Strings\nDESCRIPTION: Illustrates using triple quotes (`\"\"\"`) with the `s` interpolator in Scala to easily include literal double quotes (`\"`) within the string without needing to escape them individually. This is useful for constructing strings containing JSON or other formats with quotes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nprintln(s\"\"\"{\"name\":\"James\"}\"\"\")     // `{\"name\":\"James\"}`\n```\n\n----------------------------------------\n\nTITLE: 定义依赖方法类型的Scala接口\nDESCRIPTION: 定义一个`Key` trait作为键的抽象，以及`DB` trait，其`get`方法依赖于传入的`Key`类型。`get`方法返回类型为`Option[k.Value]`，实现依赖路径类型，可根据不同键返回不同值类型，展示依赖类型的基本用法。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-dependent-function.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Key { type Value }\n\ntrait DB {\n  def get(k: Key): Option[k.Value] // 依赖路径类型的方法定义\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Graph with Abstract Types in Scala\nDESCRIPTION: Defines an abstract Graph class with abstract type members for Edge and Node. Node is constrained to be a subtype of NodeIntf, an abstract inner class defining a connectWith method. Graph maintains lists of nodes and edges and declares an abstract addNode method to add a node to the graph. This sets the foundation for extensible graph implementations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/self-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Graph {\n  type Edge\n  type Node <: NodeIntf\n  abstract class NodeIntf {\n    def connectWith(node: Node): Edge\n  }\n  def nodes: List[Node]\n  def edges: List[Edge]\n  def addNode: Node\n}\n```\n\n----------------------------------------\n\nTITLE: Scala Min-Max Elements Algorithm with Swap Pattern\nDESCRIPTION: A collection traversal algorithm that finds minimum and maximum elements, illustrating the verbose way of swapping boundary variables before multiple assignment proposal. Highlights the need for concise syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/multiple-assignments.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nextension [T](self: Seq[T])(using Ordering[T])\n  def minMaxElements: Option[(T, T)] =\n    import math.Ordering.Implicits.infixOrderingOps\n\n    var i = self.iterator\n    if (!i.hasNext) { return None }\n    var l = i.next()\n    if (!i.hasNext) { return None }\n    var h = i.next()\n\n    if (h < l) { val t = l; l = h; h = t }\n\n    def loop(): Option[(T, T)] =\n      if (i.hasNext) {\n        val n = i.next()\n        if (n < l) { l = n } else if (n > h) { h = n }\n        loop()\n      } else {\n        Some((l, h))\n      }\n    loop()\n```\n\n----------------------------------------\n\nTITLE: Quoting and Splicing Basic Expressions in Scala\nDESCRIPTION: Demonstrates creating a quoted code block (`'{...}`) which delays execution, and splicing (`$msg`) an existing `Expr[String]` value into it. The `.show` method reveals the structure of the resulting quoted expression.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval msg = Expr(\"Hello\")\nval printHello = '{ print($msg) }\nprintln(printHello.show) // print(\"Hello\")\n```\n\n----------------------------------------\n\nTITLE: Binding Matched Patterns - Scala 2\nDESCRIPTION: Shows how to bind a matched pattern to a variable (`p @ Phone(model)`) while simultaneously extracting fields (`model`). This allows using the bound variable (`p`) to access type-specific members (`p.screenOff`) alongside extracted fields. Requires the input type and its subtypes to be defined (like `Device`, `Phone`, `Computer`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/pattern-matching.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ndef goIdleWithModel(device: Device): String = device match {\n  case p @ Phone(model) => s\"$model: ${p.screenOff}\" \n  case c @ Computer(model) => s\"$model: ${c.screenSaverOn}\"\n}\n```\n\n----------------------------------------\n\nTITLE: Sorting with Explicit Context Parameter in Scala 2\nDESCRIPTION: Demonstrates sorting a list of Address objects with the sortBy method, passing an explicit Ordering for a tuple of two strings as a context parameter. The code shows how the Ordering.Tuple2 and Ordering.String instances can be manually supplied, matching what the compiler would otherwise infer. The required dependency is scala.math.Ordering. Inputs include a list of Address values, and output is the sorted list. Best for scenarios where implicit ordering may be ambiguous or needs customization.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-contextual-abstractions.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\naddresses.sortBy(address => (address.city, address.street))(Ordering.Tuple2(Ordering.String, Ordering.String))\n```\n\n----------------------------------------\n\nTITLE: Defining Cloneable and Resetable Traits in Scala\nDESCRIPTION: This snippet defines two traits: 'Cloneable', which extends Java's 'Cloneable' and overrides the 'clone' method to return a 'Cloneable' type, and 'Resetable', which declares a 'reset' method. These traits form the foundation for composite types that combine cloning and resetting behaviors in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/compound-types.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Cloneable extends java.lang.Cloneable {\n  override def clone(): Cloneable = {\n    super.clone().asInstanceOf[Cloneable]\n  }\n}\ntrait Resetable {\n  def reset: Unit\n}\n```\n\n----------------------------------------\n\nTITLE: Using an implicit class with extension method in Scala\nDESCRIPTION: This snippet demonstrates importing the implicit class from the `Helpers` object and calling the new `times` method on an integer literal. It exemplifies how implicit classes enable adding methods to existing types for more expressive code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/implicit-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nscala> import Helpers._\nimport Helpers._\n\nscala> 5 times println(\"HI\")\nHI\nHI\nHI\nHI\nHI\n```\n\n----------------------------------------\n\nTITLE: Computing Filtered List Lengths with For/Yield Expressions in Scala 2\nDESCRIPTION: Uses a for/yield expression with a guard to create a new list containing only the lengths of strings in fruits where length > 4. Requires fruits as a List[String]. Returns a List[Int] called fruitLengths containing only lengths greater than 4.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nval fruits = List(\"apple\", \"banana\", \"lime\", \"orange\")\n\nval fruitLengths =\n  for (f <- fruits if f.length > 4) yield f.length\n\n// fruitLengths: List[Int] = List(5, 6, 6)\n\n```\n\n----------------------------------------\n\nTITLE: Attempting Extraction with Non-Matching Input - Scala\nDESCRIPTION: Illustrates using an extractor in a value definition with an input string that does *not* match the expected format defined by the `unapply` method (lacks the '--' separator). This specific code snippet, when executed, is expected to cause a `scala.MatchError`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/extractor-objects.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval CustomerID(name2) = \"--asdfasdfasdf\"\n```\n\n----------------------------------------\n\nTITLE: Class Extension and Inheritance Hierarchy\nDESCRIPTION: This code defines a base class Person and a subclass SoftwareDeveloper, which takes additional constructor parameters and extends Person. The subclass calls the superclass constructor explicitly. No dependencies other than the standard Scala language environment are needed; it illustrates classical class inheritance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nclass Person(name: String)\nclass SoftwareDeveloper(name: String, favoriteLang: String)\n  extends Person(name)\n```\n\n----------------------------------------\n\nTITLE: Instantiating a Class in Scala 2\nDESCRIPTION: This snippet shows how to create a new instance of a class in Scala 2 using the `new` keyword, passing arguments to the primary constructor.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval p = new Person(\"Robert Allen Zimmerman\", \"Harmonica Player\")\n//      ---\n```\n\n----------------------------------------\n\nTITLE: Translation of for-comprehension into 'flatMap' and 'map' for Futures\nDESCRIPTION: This snippet shows the explicit translation of the for-comprehension involving USD and CHF quotes into nested 'flatMap' and 'map' calls, elucidating the underlying functional composition of asynchronous operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\nval purchase = usdQuote.flatMap {\n  usd =>\n    chfQuote\n      .withFilter(chf => isProfitable(usd, chf))\n      .map(chf => connection.buy(amount, chf))\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Recursive While Loop with By-name Parameters in Scala 3\nDESCRIPTION: This snippet provides a Scala 3 version of the custom `whileLoop` function using by-name parameters for control flow. The function structure benefits from the new Scala 3 syntax, using `if condition then` instead of parentheses and braces. The approach is identical—recursively executes the body as long as the by-name `condition` remains true. No additional dependencies are required. Parameters are `condition: => Boolean` and `body: => Unit`; the function demonstrates printing and decrementing an integer until zero.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/by-name-parameters.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef whileLoop(condition: => Boolean)(body: => Unit): Unit =\n  if condition then\n    body\n    whileLoop(condition)(body)\n\nvar i = 2\n\nwhileLoop (i > 0) {\n  println(i)\n  i -= 1\n}  // prints 2 1\n```\n\n----------------------------------------\n\nTITLE: Modifying JSON with uPickle in Scala\nDESCRIPTION: This snippet demonstrates the process of modifying a JSON string using the uPickle library. It shows how to parse a JSON string into a mutable `ujson.Value`, update existing fields (`name`), add new fields (`nickname`), and remove elements from an array (`pets`). Finally, it converts the modified `ujson.Value` back into a JSON string using `ujson.write`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-modify.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// Parse the JSON string\nval json: ujson.Value = ujson.read(\"\"\"{\"name\":\"John\",\"pets\":[\"Toolkitty\",\"Scaniel\"]}\"\"\")\n\n// Update it\njson(\"name\") = \"Peter\"\njson(\"nickname\") = \"Pete\"\njson(\"pets\").arr.remove(1)\n\n// Write it back to a String\nval result: String = ujson.write(json)\nprintln(result)\n// prints: {\"name\":\"Peter\",\"pets\":[\"Toolkitty\"],\"nickname\":\"Pete\"}\n```\n\n----------------------------------------\n\nTITLE: Defining and Mixing Traits with Classes in Scala\nDESCRIPTION: Defines an abstract class `A` with a `message` value, a concrete class `B` implementing that message, a trait `C` adding a `loudMessage` method converting the message to uppercase, and a class `D` extending `B` with the mixin trait `C`. Demonstrates mixin usage where class `D` inherits behavior from both superclass `B` and trait `C`. Dependencies: Scala language with trait and class syntax. Inputs: none at runtime; outputs are printed messages from the `D` instance methods. Illustrates how one superclass can be combined with multiple mixins using `extends` and `with` keywords.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/mixin-class-composition.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class A {\n  val message: String\n}\nclass B extends A {\n  val message = \"I'm an instance of class B\"\n}\ntrait C extends A {\n  def loudMessage = message.toUpperCase()\n}\nclass D extends B with C\n\nval d = new D\nprintln(d.message)  // I'm an instance of class B\nprintln(d.loudMessage)  // I'M AN INSTANCE OF CLASS B\n```\n\n----------------------------------------\n\nTITLE: Combining Traits using Mixin Composition in Scala\nDESCRIPTION: Demonstrates mixin composition by creating a `ComposedService` trait that extends both `GreetingService` and `TranslationService`. The concrete `translate` from `TranslationService` fulfills the abstract requirement in `GreetingService`. Shows Scala 2 and 3 syntax differences for multiple inheritance (`with` vs `,`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-oop.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ntrait ComposedService extends GreetingService with TranslationService\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait ComposedService extends GreetingService, TranslationService\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Regex Pattern with Group Capture to Extract CSS Key-Value Pairs in Scala\nDESCRIPTION: This snippet demonstrates constructing a regex with parentheses to capture key-value pairs from CSS-like strings. It imports 'scala.util.matching.Regex', defines the pattern, and iterates over all matches to print extracted keys and values. Dependencies are the Scala regex library; inputs are multiline CSS-style strings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/regular-expression-patterns.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.util.matching.Regex\n\nval keyValPattern: Regex = \"([0-9a-zA-Z- ]+): ([0-9a-zA-Z-#()/. ]+)\".r\n\nval input: String =\n  \"\"\"background-color: #A03300;\n    |background-image: url(img/header100.png);\n    |background-position: top center;\n    |background-repeat: repeat-x;\n    |background-size: 2160px 108px;\n    |margin: 0;\n    |height: 108px;\n    |width: 100%;\"\"\".stripMargin\n\nfor (patternMatch <- keyValPattern.findAllMatchIn(input))\n  println(s\"key: ${patternMatch.group(1)} value: ${patternMatch.group(2)}\")\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Class 'Pet' with Constructor Parameters in Scala 2\nDESCRIPTION: This Scala 2 code snippet demonstrates creating an abstract class 'Pet' that accepts constructor arguments, which serves as a base class for specific pet types such as 'Dog'. It illustrates inheritance, overriding methods, and constructing class instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Pet(name: String) {\n  def greeting: String\n  def age: Int\n  override def toString = s\"My name is $name, I say $greeting, and I’m $age\"\n}\n\nclass Dog(name: String, var age: Int) extends Pet(name) {\n  val greeting = \"Woof\"\n}\n\nval d = new Dog(\"Fido\", 1)\n```\n\n----------------------------------------\n\nTITLE: Defining Comparable Traits with Default Methods in Scala\nDESCRIPTION: Defines a Scala trait named Ord that specifies a set of comparison operators to enable ordered objects. The trait declares an abstract '<' method and provides default implementations for '<=', '>', and '>=' based on '<' and '==' operators. It uses the universal supertype Any to accept any object for comparison, thus modelling Java's Comparable with additional convenience. This trait serves as a reusable interface for custom ordering logic and reduces redundancy by defining only the core comparison method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-tw/tutorials/scala-for-java-programmers.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Ord {\n  def < (that: Any): Boolean\n  def <=(that: Any): Boolean =  (this < that) || (this == that)\n  def > (that: Any): Boolean = !(this <= that)\n  def >=(that: Any): Boolean = !(this < that)\n}\n```\n\n----------------------------------------\n\nTITLE: Attempted Covariant Linked List Node with Type Parameter in Scala\nDESCRIPTION: Modifies the ListNode class to make the type parameter covariant by using '+' before T. However, this code does not compile because the covariant type parameter appears in method parameter position in prepend, which is illegal. This snippet illustrates the variance conflict in Scala's type system and the limitations of using covariance directly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/lower-type-bounds.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ncase class ListNode[+T](h: T, t: ListNode[T]) { ... }\n```\n\n----------------------------------------\n\nTITLE: Removing elements from mutable Map in Scala\nDESCRIPTION: Demonstrates removing elements from a mutable Map using '-=' for single and multiple keys, and '--=' for removing keys contained in a collection like a List. These methods mutate the existing Map by removing specified keys. Inputs are keys or collections of keys; the output is the Map after element removal.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/map-class.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nstates -= \"AR\"\n```\n\nLANGUAGE: scala\nCODE:\n```\nstates -= (\"AL\", \"AZ\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nstates --= List(\"AL\", \"AZ\")\n```\n\n----------------------------------------\n\nTITLE: Completing a Promise with a Producer and Consumer - Scala\nDESCRIPTION: Demonstrates producer-consumer coordination using a Promise: one Future (producer) computes a result and completes the Promise, while another (consumer) performs additional work and processes the result asynchronously via onSuccess. Dependencies: scala.concurrent.{ Future, Promise }. Key parameters: a Promise and its associated Future. Inputs: computation result from the producer; outputs: processed result in consumer. Note: Promise can only be completed once; further attempts will throw IllegalStateException.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/futures-promises.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.concurrent.{ Future, Promise }\n\nval p = Promise[T]()\nval f = p.future\n\nval producer = Future {\n  val r = produceSomething()\n  p success r\n  continueDoingSomethingUnrelated()\n}\n\nval consumer = Future {\n  startDoingSomething()\n  f onSuccess {\n    case r => doSomethingWithResult()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Environment Type Alias and Example (Scala)\nDESCRIPTION: Creates a type alias `Environment` for a function type `String => Int`, representing a mapping from variable names to integer values. It also shows an example `val ev` defined as a partial function that maps the string \"x\" to the integer 5.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\ntype Environment = String => Int\nval ev: Environment = { case \"x\" => 5 }\n```\n\n----------------------------------------\n\nTITLE: Using an Extension Method in Scala 3\nDESCRIPTION: Demonstrates calling the `circumference` extension method directly on a `Circle` instance (`aCircle`), as if the method was originally part of the `Circle` class definition. This highlights the improved syntax and usability provided by extension methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-extension-methods.md#_snippet_4\n\nLANGUAGE: Scala 3\nCODE:\n```\naCircle.circumference\n```\n\n----------------------------------------\n\nTITLE: Default Arguments Method Call Transformation in Scala\nDESCRIPTION: Illustrates how method calls using default arguments are transformed by the Scala compiler. The transformation ensures proper evaluation of default expressions and argument passing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-and-default-arguments.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nf()(\"str\")()\n// transformed to:\n// {\n//   val x$1 = f$default$1\n//   val x$2 = \"str\"\n//   val x$3 = f$default$3(x$1)(x$2)\n//   f(x$1)(x$2)(x$3)\n// }\n```\n\n----------------------------------------\n\nTITLE: Interoperation Techniques with Java: Static Members via Singleton Objects\nDESCRIPTION: This snippet demonstrates how Scala's singleton objects can simulate static members in Java by defining helpers and constants within an object companion. It shows the pattern of importing members from the companion object into a class for easier access. The snippet highlights that members marked as `private` are accessible between the class and its companion object, emphasizing privacy boundaries and static forwarding techniques.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/singleton-objects.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass X {\n  import X._\n\n  def blah = foo\n}\n\nobject X {\n  private def foo = 42\n}\n```\n\n----------------------------------------\n\nTITLE: Evaluating Expressions in the Scala REPL\nDESCRIPTION: Demonstrates evaluating simple arithmetic expressions (1 + 1 and 2 + 2) directly in the Scala REPL. The REPL automatically assigns the results to default variables (`res0`, `res1`) and displays their inferred type (Int) and calculated value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-repl.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> 1 + 1\nval res0: Int = 2\n\nscala> 2 + 2\nval res1: Int = 4\n```\n\n----------------------------------------\n\nTITLE: Defining utility methods in a Scala singleton object\nDESCRIPTION: A StringUtils object containing utility methods for string manipulation, demonstrating how to group related functionality in a singleton object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/methods-most.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nobject StringUtils {\n\n  /**\n   * Returns a string that is the same as the input string, but\n   * truncated to the specified length.\n   */\n  def truncate(s: String, length: Int): String = s.take(length)\n\n  /**\n    * Returns true if the string contains only letters and numbers.\n    */\n  def lettersAndNumbersOnly_?(s: String): Boolean =\n    s.matches(\"[a-zA-Z0-9]+\")\n\n  /**\n   * Returns true if the given string contains any whitespace\n   * at all. Assumes that `s` is not null.\n   */\n  def containsWhitespace(s: String): Boolean =\n    s.matches(\".*\\\\s.*\")\n\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nobject StringUtils:\n\n  /**\n   * Returns a string that is the same as the input string, but\n   * truncated to the specified length.\n   */\n  def truncate(s: String, length: Int): String = s.take(length)\n\n  /**\n    * Returns true if the string contains only letters and numbers.\n    */\n  def lettersAndNumbersOnly_?(s: String): Boolean =\n    s.matches(\"[a-zA-Z0-9]+\")\n\n  /**\n   * Returns true if the given string contains any whitespace\n   * at all. Assumes that `s` is not null.\n   */\n  def containsWhitespace(s: String): Boolean =\n    s.matches(\".*\\\\s.*\")\n\nend StringUtils\n```\n\n----------------------------------------\n\nTITLE: Control Structures: `if` Statements in Python and Scala\nDESCRIPTION: Provides syntactic examples of single-line and multi-line `if` statements in Python and Scala. Emphasizes syntax differences such as indentation versus `then` keyword.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nif x == 1: print(x)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nif x == 1 then println(x)\n\nif x == 1 then\n  println(\"x is 1, as you can see:\")\n  println(x)\n```\n\n----------------------------------------\n\nTITLE: Fallback to an Alternative Future on Failure with fallbackTo Combinator in Scala\nDESCRIPTION: This snippet demonstrates attempting to obtain a USD quote with a Future and mapping it to a string. If that fails, fallbackTo switches to a CHF quote Future similarly mapped. The resulting Future anyQuote completes successfully with one of the currency values if available, or fails only if both Futures fail. This approach allows specifying alternative asynchronous computations to gracefully degrade failure scenarios.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/futures.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nval usdQuote = Future {\n  connection.getCurrentValue(USD)\n} map {\n  usd => \"値: \" + usd + \" USD\"\n}\nval chfQuote = Future {\n  connection.getCurrentValue(CHF)\n} map {\n  chf => \"値: \" + chf + \"CHF\"\n}\n\nval anyQuote = usdQuote fallbackTo chfQuote\n\nanyQuote foreach { println(_) }\n```\n\n----------------------------------------\n\nTITLE: Examples of Legacy and Named Syntax Variants for Scala 3 'given' Definitions\nDESCRIPTION: Illustrates example usages of various proposed and legacy syntaxes for defining given instances, including simple and parameterized typeclasses, aliases, named givens with 'as' clauses, abstract givens, and by-name givens. The snippet highlights how optional names and context parameters can be expressed with different syntaxes, as well as the trade-offs considered in revisions. This aids understanding of syntax evolution and migration choices in the language.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_27\n\nLANGUAGE: scala\nCODE:\n```\n```scala\n  // Simple typeclass\n  given Ord[Int]:\n    def compare(x: Int, y: Int) = ...\n\n  // Parameterized typeclass\n  given [A: Ord] => Ord[List[A]]:\n    def compare(x: List[A], y: List[A]) = ...\n\n  // Typeclass with context parameter\n  given [A](using Ord[A]) => Ord[List[A]]:\n    def compare(x: List[A], y: List[A]) = ...\n\n  // Typeclass with named context parameter\n  given [A](using ord: Ord[A]) => Ord[List[A]]:\n    def compare(x: List[A], y: List[A]) = ...\n\n  // Simple alias\n  given Ord[Int] = IntOrd()\n\n  // Parameterized alias\n  given [A: Ord] => Ord[List[A]] =\n    ListOrd[A]\n\n  // Alias with explicit context parameter\n  given [A](using Ord[A]) => Ord[List[A]] =\n    ListOrd[A]\n\n  // Abstract or deferred given\n  given Context = deferred\n\n  // By-name given\n  given => Context = curCtx\n```\nNamed:\n\n```scala\n  // Simple typeclass\n  given Ord[Int] as intOrd:\n    def compare(x: Int, y: Int) = ...\n\n  // Parameterized typeclass\n  given [A: Ord] => Ord[List[A]] as listOrd:\n    def compare(x: List[A], y: List[A]) = ...\n\n  // Typeclass with context parameter\n  given [A](using Ord[A]) => Ord[List[A]] as listOrd:\n    def compare(x: List[A], y: List[A]) = ...\n\n  // Typeclass with named context parameter\n  given [A](using ord: Ord[A]) => Ord[List[A]] as listOrd:\n    def compare(x: List[A], y: List[A]) = ...\n\n  // Simple alias\n  given Ord[Int] as intOrd = IntOrd()\n\n  // Parameterized alias\n  given [A: Ord] => Ord[List[A]] as listOrd =\n    ListOrd[A]\n\n  // Alias with using clause\n  given [A](using Ord[A]) => Ord[List[A]] as listOrd =\n    ListOrd[A]\n\n  // Abstract or deferred given\n  given Context as context = deferred\n\n  // By-name given\n  given => Context as context = curCtx\n```\n```\n\n----------------------------------------\n\nTITLE: Interactive Console Application in Scala\nDESCRIPTION: A complete Scala program that demonstrates reading user input and displaying output. The program prompts for first and last names, reads them using readLine(), and then outputs the full name.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/command-line-io.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.io.StdIn.readLine\n\nobject HelloInteractive extends App {\n\n    print(\"Enter your first name: \")\n    val firstName = readLine()\n\n    print(\"Enter your last name: \")\n    val lastName = readLine()\n\n    println(s\"Your name is $firstName $lastName\")\n\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Smooth Scroll Animation with jQuery (JavaScript)\nDESCRIPTION: Attaches a click event handler to elements with the class 'scroll' once the DOM is ready. For each click, it prevents the default link behavior, then animates the scroll position of the HTML and body elements to the offset of the target element specified by the link's hash (`this.hash`), with a duration of 500 milliseconds. A second animation adjusts the final scroll position by subtracting 50 pixels.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/cheatsheet-header.txt#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\njQuery(document).ready(function($) {\n\n      $(\".scroll\").click(function(event){\n        event.preventDefault();\n        $('html,body').animate({scrollTop:$(this.hash).offset().top}, 500);\n        $('html,body').animate({scrollTop:$(this.hash).offset().top-=50}, 500);\n      });\n});\n```\n\n----------------------------------------\n\nTITLE: Implement SubjectObserver with Concrete Types (Scala 3)\nDESCRIPTION: Implements the `SubjectObserver` component in Scala 3 by creating a singleton object `SensorReader`. It defines concrete types `Sensor` for abstract type `S` and `Display` for abstract type `O`. Nested classes `Sensor` (extending `Subject`) and `Display` (extending `Observer`) provide the specific implementations, using Scala 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\nobject SensorReader extends SubjectObserver:\n  type S = Sensor\n  type O = Display\n\n  class Sensor(val label: String) extends Subject:\n    private var currentValue = 0.0\n    def value = currentValue\n    def changeValue(v: Double) =\n      currentValue = v\n      publish()\n\n  class Display extends Observer:\n    def notify(sub: Sensor) =\n      println(s\"${sub.label} has value ${sub.value}\")\n```\n\n----------------------------------------\n\nTITLE: 타입 캐스팅 예제 - 스칼라 값 타입 변환 - Scala\nDESCRIPTION: Long 타입 값을 Float 타입으로 변환하는 타입 캐스팅과 Char 값을 Int 타입으로 변환하는 예제를 보여줍니다. 일부 변환에서는 정보 손실이 발생할 수 있음을 주의해야 합니다. 스칼라에서 값 타입 간 캐스팅은 일방향이며 자동 컴파일 변환을 지원하지 않습니다. 이 코드는 표준 스칼라 타입 변환 메서드(toFloat)와 암시적 변환 규칙을 활용합니다.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/unified-types.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval x: Long = 987654321\nval y: Float = x.toFloat  // 9.8765434E8 (이 경우 일부 자리수가 소실되었음을 주의)\n\nval face: Char = '☺'\nval number: Int = face  // 9786\n```\n\n----------------------------------------\n\nTITLE: Basic String Declaration in JavaScript\nDESCRIPTION: This snippet demonstrates how to declare simple strings in JavaScript using either single quotes (') or double quotes (\"). Both are valid.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\n// use single- or double-quotes\nlet msg = 'Hello, world';\nlet msg = \"Hello, world\";\n```\n\n----------------------------------------\n\nTITLE: Instantiating a Java Class in Scala\nDESCRIPTION: Demonstrates Scala's interoperability with Java by showing how to create an instance of a standard Java class (`java.io.File`) using the familiar `new` keyword.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/cheatsheets/index.md#_snippet_10\n\nLANGUAGE: Java\nCODE:\n```\nnew java.io.File(\"f\")\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Packages with Accessible Top-Level Methods - Scala\nDESCRIPTION: This snippet shows how to define methods inside nested package blocks in Scala 3. It demonstrates a method 'double' declared within the 'foo' package, which is accessible inside the nested 'foo.bar' package through package nesting. A main method illustrates calling this method from the nested package and printing the result. This approach replaces Scala 2's package objects and preserves accessibility of definitions across nested packages. It uses standard Scala packages and main method conventions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-toplevel-definitions.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\npackage foo {\n  def double(i: Int) = i * 2\n}\n\npackage foo {\n  package bar {\n    @main def fooBarMain =\n      println(s\"${double(1)}\")   // this works\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using foldLeft to Sum a List of Numbers in Scala\nDESCRIPTION: This code initializes a list of integers and uses 'foldLeft' with an initial value of 0 to compute the sum of all elements. The lambda function '(m, n) => m + n' adds each element to the accumulator, resulting in the total sum. It demonstrates the application of a simple binary operation to a collection to produce a cumulative result. Inputs are the list and the binary addition function, output is the sum.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/multiple-parameter-lists.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nval res = numbers.foldLeft(0)((m, n) => m + n)\nprintln(res) // 55\n```\n\n----------------------------------------\n\nTITLE: Obtaining and Filtering Sorted Final Members of List in Scala Reflection\nDESCRIPTION: This example calls decls on a Type (listTpe) to obtain its member scope, sorts the members in declaration order, and filters them to retain only final members. It demonstrates compound queries with member scopes and result processing. Prerequisites are having a valid Type for reflection. The output is a list of Symbol objects for final members.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/annotations-names-scopes.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval finals = listTpe.decls.sorted.filter(_.isFinal)\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Simple Function Expressions (Identity Function)\nDESCRIPTION: Shows how to pattern match a simple lambda expression using quoted patterns. `case '{ (arg: A) => arg } =>` matches a function `Expr[A => A]` that takes an argument `arg` of type `A` and returns it directly. Requires `Type[A]`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\ndef matchIdentityFunction[A: Type](func: Expr[A => A])(using Quotes): Unit = \n  func match \n    case '{ (arg: A) => arg } => \n```\n\n----------------------------------------\n\nTITLE: Создание коллекций Scala на основе Iterable - Scala\nDESCRIPTION: Пример демонстрирует создание различных типов коллекций Scala, таких как Iterable, Map, Set, SortedSet, Buffer, IndexedSeq и LinearSeq с помощью общего синтаксиса, где имя коллекции указывается с ее элементами. Данный синтаксис применим к большинству коллекций Scala и является базовым способом создания коллекций с исходными данными.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/overview.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nIterable(\"x\", \"y\", \"z\")\nMap(\"x\" -> 24, \"y\" -> 25, \"z\" -> 26)\nSet(Color.red, Color.green, Color.blue)\nSortedSet(\"hello\", \"world\")\nBuffer(x, y, z)\nIndexedSeq(1.0, 2.0)\nLinearSeq(a, b, c)\n```\n\n----------------------------------------\n\nTITLE: Connecting to WebSockets with sttp in Scala 2\nDESCRIPTION: This snippet illustrates establishing a WebSocket connection using sttp and DefaultFutureBackend in Scala 2. It defines a function for sending and receiving text messages over the socket, using Scala Futures for async communication. It includes awaiting the response and printing the received message. Required dependencies: sttp.client4, sttp.ws, Scala's Futures and ExecutionContext, and a reachable WebSocket server. Inputs: WebSocket endpoint URL and a message to send. Output: prints the echoed response; blocking with Await.result may not scale in production.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/http-client-what-else.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.concurrent.duration.Duration\nimport scala.concurrent.{Await, Future}\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nimport sttp.client4._\nimport sttp.ws.WebSocket\n\nval asyncBackend = DefaultFutureBackend()\n\ndef useWebSocket(ws: WebSocket[Future]): Future[Unit] =\n  for {\n    _ <- ws.sendText(\"Hello\")\n    text <- ws.receiveText()\n  } yield {\n    println(text)\n  }\n\nval response = quickRequest\n  .get(uri\"wss://ws.postman-echo.com/raw\")\n  .response(asWebSocketAlways(useWebSocket))\n  .send(asyncBackend)\n\nAwait.result(response, Duration.Inf)\n// prints: Hello\n```\n\n----------------------------------------\n\nTITLE: Using summon with Anonymous Context Bounds\nDESCRIPTION: Implementation of reduce method demonstrating how summon is required to access the Monoid instance when using anonymous context bounds, which is considered cumbersome.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef reduce[A : Monoid](xs: List[A]): A =\n  xs.foldLeft(summon[Monoid[A]].unit)(_ `combine` _)\n```\n\n----------------------------------------\n\nTITLE: Implementing Helper Methods in Scala 2/3\nDESCRIPTION: Shows the traditional approach of defining helper methods within a separate object (`CircleHelpers`) to operate on `Circle` instances without modifying the class. This example provides syntax for both Scala 2 and Scala 3, calculating the circumference.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/ca-extension-methods.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject CircleHelpers {\n  def circumference(c: Circle): Double = c.radius * math.Pi * 2\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nobject CircleHelpers:\n  def circumference(c: Circle): Double = c.radius * math.Pi * 2\n```\n\n----------------------------------------\n\nTITLE: Enhanced Implicit Error Formatting with Line Breaking\nDESCRIPTION: This snippet demonstrates how the enhanced error formatter improves readability by breaking long infix types and type arguments across multiple lines within implicit error messages. It uses `!I` to denote missing implicit parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/compiler-options/errors.md#_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\nimplicit error;\n!I e: String\nf invalid because\n!I impPar4: List[\n  (\n    VeryLongTypeName ::::\n    VeryLongTypeName ::::\n    VeryLongTypeName ::::\n    VeryLongTypeName\n  )\n  ::::\n  (Short :::: Short) ::::\n  (\n    VeryLongTypeName ::::\n    VeryLongTypeName ::::\n    VeryLongTypeName ::::\n    VeryLongTypeName\n  )\n  ::::\n  VeryLongTypeName ::::\n  VeryLongTypeName ::::\n  VeryLongTypeName ::::\n  VeryLongTypeName\n]\n```\n\n----------------------------------------\n\nTITLE: Explicit Typing of Node Instances Bound to Graph Instance in Scala\nDESCRIPTION: Illustrates Scala's path-dependent types by explicitly declaring node variables with types tied to a particular Graph instance using `g.Node`. This enforces type safety, preventing mixing nodes from different graph instances. The snippet reinforces how inner class types depend on the outer object instance and showcases the precision of Scala's type system in this context.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/inner-classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef graphTest: Unit = {\n  val g: Graph = new Graph\n  val n1: g.Node = g.newNode\n  val n2: g.Node = g.newNode\n  val n3: g.Node = g.newNode\n  n1.connectTo(n2)\n  n3.connectTo(n1)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Helper Methods in Scala (Scala 2 vs Scala 3)\nDESCRIPTION: Demonstrates defining a static-like helper method `circumference` within an object (`CircleHelpers`) to operate on `Circle` instances. This shows the traditional approach before extension methods, presenting syntax for both Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-extension-methods.md#_snippet_1\n\nLANGUAGE: Scala 2\nCODE:\n```\nobject CircleHelpers {\n  def circumference(c: Circle): Double = c.radius * math.Pi * 2\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nobject CircleHelpers:\n  def circumference(c: Circle): Double = c.radius * math.Pi * 2\n```\n\n----------------------------------------\n\nTITLE: Creating Function Variables in Scala\nDESCRIPTION: Examples showing how to assign anonymous functions to variables, creating named function variables that can be reused throughout the code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-function-variables.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval double = (i: Int) => i * 2\n```\n\n----------------------------------------\n\nTITLE: Running Failing Tests with Standalone Partest Script - Shell\nDESCRIPTION: Uses the standalone Partest launcher script to execute only previously-failing test cases, while printing detailed diff and log outputs. Run from the root of the Scala project with the script located under the 'test' directory. This approach requires shell/Unix environment and was deprecated in Scala 2.12.2 onwards.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/partest-guide.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n./test/partest --show-diff --show-log --failed\n```\n\n----------------------------------------\n\nTITLE: Function types with variance annotations\nDESCRIPTION: This snippet explains the variance annotations on the Scala Function1 type, which is contravariant in its input type and covariant in its output type. It demonstrates how functions accepting super types and returning subtypes can be compatible thanks to variance annotations, facilitating flexible functional programming.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/variances.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass SmallAnimal\nclass Mouse extends SmallAnimal\n```\n\n----------------------------------------\n\nTITLE: Syntax Extensions for Named Tuples in Scala\nDESCRIPTION: Defines the formal syntax extensions to support named tuples and named constructor arguments in Scala, including the grammar for SimpleType, NameAndType, SimpleExpr, and Patterns.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-tuples.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nSimpleType        ::=  ...\n                |  '(' NameAndType {',' NameAndType} ')'\nNameAndType       ::=  id ':' Type\n\nSimpleExpr        ::=  ...\n                |  '(' NamedExprInParens {',' NamedExprInParens} ')'\nNamedExprInParens ::=  id '=' ExprInParens\n\nPatterns          ::=  Pattern {',' Pattern}\n                |  NamedPattern {',' NamedPattern}\nNamedPattern      ::=  id '=' Pattern\n```\n\n----------------------------------------\n\nTITLE: Shadowing unqualified Seq and IndexedSeq to enforce migration rules - Scala\nDESCRIPTION: This snippet uses Scala's @compileTimeOnly annotation to declare dummy Seq and IndexedSeq traits that shadow the default scala.Seq and scala.IndexedSeq, respectively. Its purpose is to forbid unqualified usage of Seq and IndexedSeq during migration to Scala 2.13 where these type aliases changed. The dummy traits trigger compile-time errors instructing developers to use either immutable.Seq or collection.Seq. This technique aids automated detection of forbidden usages by the compiler within the example package scope, arranging safer migration auditing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/collections-migration-213.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\npackage example\n\nimport scala.annotation.compileTimeOnly\n\n/**\n  * In Scala 2.13, `scala.Seq` changed from aliasing `scala.collection.Seq` to aliasing\n  * `scala.collection.immutable.Seq`.  In this code base usage of unqualified `Seq` is banned: use\n  * `immutable.Seq` or `collection.Seq` instead.\n  *\n  * import scala.collection\n  * import scala.collection.immutable\n  *\n  * This `Seq` trait is a dummy type to prevent the use of `Seq`.\n  */\n@compileTimeOnly(\"Use immutable.Seq or collection.Seq\")\nprivate[example] trait Seq[A1]\n\n/**\n  * In Scala 2.13, `scala.IndexedSeq` changed from aliasing `scala.collection.IndexedSeq` to aliasing\n  * `scala.collection.immutable.IndexedSeq`.  In this code base usage of unqualified `IndexedSeq` is\n  * banned: use `immutable.IndexedSeq` or `collection.IndexedSeq`.\n  *\n  * import scala.collection\n  * import scala.collection.immutable\n  *\n  * This `IndexedSeq` trait is a dummy type to prevent the use of `IndexedSeq`.\n  */\n@compileTimeOnly(\"Use immutable.IndexedSeq or collection.IndexedSeq\")\nprivate[example] trait IndexedSeq[A1]\n```\n\n----------------------------------------\n\nTITLE: Including a Named Snippet (Markdown)\nDESCRIPTION: Shows the Markdown syntax ` ```scala sc-compile-with:<snippet-name>(,<snippet-name>)+ ` used to include the code from one or more previously named snippets. The included code is prepended to the current snippet for compilation purposes. Order matters if multiple snippets are included.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/snippet-compiler.md#_snippet_11\n\nLANGUAGE: markdown\nCODE:\n```\n```scala sc-compile-with:<snippet-name>(,<snippet-name>)+\n```\n\n----------------------------------------\n\nTITLE: Applying Prettyprint Styling to Code Blocks (JavaScript)\nDESCRIPTION: Defines a JavaScript function `styleCode` intended to apply Google Code Prettyprint styling. It checks for a `disableStyleCode` flag, then uses jQuery to iterate through all `<pre><code>` elements. If an element doesn't have the 'prettyprint' class, it adds 'prettyprint lang-scala linenums' and sets a flag `a`. If any elements were modified, it calls the global `prettyPrint()` function.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/cheatsheet-header.txt#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction styleCode()\n  {\n    if (typeof disableStyleCode != \"undefined\")\n    {\n        return;\n    }\n    var a = false;\n    $(\"pre code\").parent().each(function()\n    {\n        if (!$(this).hasClass(\"prettyprint\"))\n        {\n            $(this).addClass(\"prettyprint lang-scala linenums\");\n            a = true\n        }\n    });\n    if (a) { prettyPrint() }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Parentheses to Disable Semicolon Inference in Scala\nDESCRIPTION: Shows how parentheses can be used to disable Scala's automatic semicolon inference, allowing developers to format multi-line expressions by starting subsequent lines with operators (like ||). A closing parenthesis on its own line is acceptable in this formatting style.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/nested-blocks.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n(  someCondition\n|| someOtherCondition\n|| thirdCondition\n)\n```\n\n----------------------------------------\n\nTITLE: Calling a Method with Context Parameter Using Implicit or Given Instance\nDESCRIPTION: This snippet demonstrates calling a method (`renderWebsite`) that has a context parameter without supplying the contextual argument explicitly, relying on the compiler to use the implicit/given instance of `Config` in scope. This shows how the compiler can resolve the argument automatically. Inputs include only the path string; outputs are defined by the method logic using implicit context.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/ca-context-parameters.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nrenderWebsite(\"/home\")\n//                   ^\n//   снова без аргумента\n```\n\n----------------------------------------\n\nTITLE: Calling Methods on a Scala Object - Scala\nDESCRIPTION: Shows how to access and invoke methods defined within a Scala object using dot notation, similar to calling static methods. This example uses the `StringUtils` object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_20\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\nStringUtils.truncate(\"Chuck Bartowski\", 5)  // \"Chuck\"\n```\n\n----------------------------------------\n\nTITLE: Passing Constructor Parameters to a Scala Abstract Superclass\nDESCRIPTION: This Scala code snippet focuses on the inheritance syntax, showing how the 'name' constructor parameter from the 'Dog' subclass is explicitly passed to the constructor of its abstract superclass 'Pet' using 'extends Pet(name)'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/abstract-classes.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass Dog(name: String) extends Pet(name) {\n```\n\n----------------------------------------\n\nTITLE: Accessing Tuple Elements by Index in Scala 2 and 3\nDESCRIPTION: Demonstrates how to access tuple elements directly by their zero-based index, returning the corresponding value contained in the tuple. Useful for quick, positional retrieval of tuple components.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-collections.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nt(0)   // 11\nt(1)   // \"eleven\"\nt(2)   // Person(\"Eleven\")\n```\n\n----------------------------------------\n\nTITLE: Serving Static Files with @cask.staticFiles Annotation in Scala 3\nDESCRIPTION: Scala 3 implementation of a Cask server that serves static files from a resources directory. The endpoint function specifies the file location, and the @cask.staticFiles annotation defines the URL path.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/web-server-static.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nobject Example extends cask.MainRoutes:\n  @cask.staticFiles(\"/static\")\n  def staticEndpoint(): String = \"src/main/resources\" // or \"resources\" if not using SBT\n\n  initialize()\n```\n\n----------------------------------------\n\nTITLE: Importing readLine Method from scala.io.StdIn in Scala 2 and 3\nDESCRIPTION: This Scala snippet imports the `readLine` method from the `scala.io.StdIn` object, which enables reading a line of input from the standard input stream (command line). This import is required to use `readLine` in both Scala 2 and Scala 3 programs, facilitating interactive console input. No additional dependencies are needed beyond the standard Scala library.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-hello-world.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.io.StdIn.readLine\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with No Parameters in Scala\nDESCRIPTION: Demonstrates a function value that takes no parameters and returns a constant. Useful for providers, configuration values, or deferred computation. Returns an integer without requiring input.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nval getTheAnswer = () => 42\nprintln(getTheAnswer()) // 42\n```\n\n----------------------------------------\n\nTITLE: Filtering onFailure Callbacks Using Partial Functions - Scala\nDESCRIPTION: Illustrates how onFailure can be used with a partial function to only handle specific exception types (e.g., NullPointerException). Shows that if the Future fails with a different exception, the callback will not execute. Dependencies are scala.concurrent.Future and the ability to throw exceptions within the Future body. Appropriate for selectively responding to certain errors and ensuring handler compatibility with Scala patterns.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/futures-promises.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval f = Future {\n  2 / 0\n}\n\nf onFailure {\n  case npe: NullPointerException =>\n    println(\"I'd be amazed if this printed out.\")\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating Subclasses with Concrete Type Members in Scala\nDESCRIPTION: This snippet demonstrates creating instances of classes C and D, concretizing the abstract type member T as String for both. It uses anonymous subclassing syntax to assign the type refinement. The dependencies are the previously defined classes E, C, and D. The expected output is instance creation with type refinements; the constraint is that this technique is specific to Scala's type system.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/overview.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval c = new C { type T = String }\nval d = new D { type T = String }\n```\n\n----------------------------------------\n\nTITLE: Creating a Tuple in Scala\nDESCRIPTION: Shows creation of a Scala tuple 't' consisting of three elements: 11 (Int), 11.0 (Double), and the string \"Eleven\". Scala tuples are immutable and can hold heterogeneous types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\nval t = (11, 11.0, \"Eleven\")\n```\n\n----------------------------------------\n\nTITLE: Iterating with While Loops - JavaScript & Scala\nDESCRIPTION: Compares the basic syntax for 'while' loops in JavaScript and Scala. Shows the standard JavaScript syntax and the Scala 3 'while...do' syntax, mentioning the older Scala curly brace style is also available.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_24\n\nLANGUAGE: JavaScript\nCODE:\n```\nlet i = 0;\nwhile (i < 3) {\n  console.log(i);\n  i++;\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nvar i = 0;\nwhile i < 3 do\n  println(i)\n  i += 1\n```\n\n----------------------------------------\n\nTITLE: Higher-Order Functions with Lambda Expressions in Scala\nDESCRIPTION: Examples of using higher-order functions (HOF) with concise lambda syntax, including dropWhile, filter, filterNot, find, and takeWhile.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/collections-methods.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\na.dropWhile(_ < 25)   // List(30, 40, 10)\na.filter(_ > 100)     // List()\na.filterNot(_ < 25)   // List(30, 40)\na.find(_ > 20)        // Some(30)\na.takeWhile(_ < 30)   // List(10, 20)\n```\n\n----------------------------------------\n\nTITLE: Invalid Instantiation of PetContainer with a Non-Subtype\nDESCRIPTION: Demonstrates a compile-time error when attempting to instantiate `PetContainer` with `Lion`, which is not a subtype of `Pet`. The error highlights how the upper type bound `<: Pet` prevents incorrect type assignments, enforcing the intended hierarchy constraint.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/upper-type-bounds.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval lionContainer = new PetContainer[Lion](new Lion) // this would not compile\n```\n\n----------------------------------------\n\nTITLE: Instance Usage and State Change in Counter (Scala 3)\nDESCRIPTION: This Scala 3 example shows how to instantiate a Counter and interact with its methods to observe state changes through tick and count. It demonstrates usage of encapsulated mutable state. Requires the Counter class definition from earlier in the Scala 3 context.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nval c1 = Counter()\nc1.count // 0\nc1.tick()\nc1.tick()\nc1.count // 2\n```\n\n----------------------------------------\n\nTITLE: Class literal, runtime type checking, casting, and type assignment in Scala\nDESCRIPTION: Shows examples of various type-related operations: obtaining a class literal using `classOf[String]`, checking runtime type with `x.isInstanceOf[String]`, performing runtime casts via `x.asInstanceOf[String]`, and compile-time type assignment with `x: String` annotation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_26\n\nLANGUAGE: Scala\nCODE:\n```\nclassOf[String]\nx.isInstanceOf[String]\nx.asInstanceOf[String]\nx: String\n```\n\n----------------------------------------\n\nTITLE: Defining Class with Auxiliary Constructors in Scala 3\nDESCRIPTION: This snippet demonstrates defining a class with a primary constructor and multiple auxiliary constructors in Scala 3 using the `this` keyword. Auxiliary constructors must call a previously defined constructor. The class body uses the colon syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\nimport java.time.*\n\n// [1] the primary constructor\nclass Student(\n  var name: String,\n  var govtId: String\n):\n  private var _applicationDate: Option[LocalDate] = None\n  private var _studentId: Int = 0\n\n  // [2] a constructor for when the student has completed\n  // their application\n  def this(\n    name: String,\n    govtId: String,\n    applicationDate: LocalDate\n  ) =\n    this(name, govtId)\n    _applicationDate = Some(applicationDate)\n\n  // [3] a constructor for when the student is approved\n  // and now has a student id\n  def this(\n    name: String,\n    govtId: String,\n    studentId: Int\n  ) =\n    this(name, govtId)\n    _studentId = studentId\n```\n\n----------------------------------------\n\nTITLE: Correct Way to Create Lists in Scala\nDESCRIPTION: Contrasts the incorrect way to create a List (`new List[Int]`, fails because List is abstract) with the idiomatic Scala approach using the companion object's factory `apply` method (`List(1, 2, 3)`). This factory method handles the instantiation of the appropriate concrete List subclass.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/cheatsheets/index.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\n// Bad: new List[Int]  (Type error: List is abstract)\n// Good: List(1, 2, 3) (Uses companion object factory)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Class Instance That Extends a Trait\nDESCRIPTION: Shows instantiating a Dog class that extends the Pet trait and calling both the inherited concrete method and the implemented abstract method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/traits-abstract-mixins.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval d = new Dog(\"Zeus\")\n```\n\n----------------------------------------\n\nTITLE: Blocking within a Scala Future using blocking construct\nDESCRIPTION: Shows how to notify the execution context of blocking work via the `blocking` method. If used with `ExecutionContext.global`, it manages thread pools properly; otherwise, with fixed thread pools, blocking has no effect. Demonstrates a pattern for integrating blocking code within async computations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_30\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit val ec =\n  ExecutionContext.fromExecutor(Executors.newFixedThreadPool(4))\n\nFuture {\n  blocking { blockingStuff() }\n}\n```\n\n----------------------------------------\n\nTITLE: Calling a Method with Multiple Boolean Parameters (Unclear)\nDESCRIPTION: Shows an example of calling a hypothetical method `engage` with multiple boolean arguments positionally (`true, true, true, false`). This highlights the potential lack of clarity without named parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nengage(true, true, true, false)\n```\n\n----------------------------------------\n\nTITLE: Calculating Crust Price with Pattern Matching in Scala\nDESCRIPTION: Defines a function `crustPrice` that calculates the price based on `CrustSize` and `CrustType`. It uses pattern matching on a tuple `(CrustSize, CrustType)` to determine the price, handling combinations of size and type. Requires `CrustSize` and `CrustType` enumerations or similar structures to be defined.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-fp.md#_snippet_6\n\nLANGUAGE: Scala 2\nCODE:\n```\ndef crustPrice(s: CrustSize, t: CrustType): Double =\n  (s, t) match {\n    // if the crust size is small or medium,\n    // the type is not important\n    case (Small | Medium, _) => 0.25\n    case (Large, Thin) => 0.50\n    case (Large, Regular) => 0.75\n    case (Large, Thick) => 1.00\n  }\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ndef crustPrice(s: CrustSize, t: CrustType): Double =\n  (s, t) match\n    // if the crust size is small or medium,\n    // the type is not important\n    case (Small | Medium, _) => 0.25\n    case (Large, Thin) => 0.50\n    case (Large, Regular) => 0.75\n    case (Large, Thick) => 1.00\n```\n\n----------------------------------------\n\nTITLE: Defining a PizzaServiceInterface Trait in Scala 2\nDESCRIPTION: Example of creating a service interface for Pizza-related operations using a trait in Scala 2, defining the behavior contract.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-fp.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntrait PizzaServiceInterface {\n\n  def price(p: Pizza): Double\n\n  def addTopping(p: Pizza, t: Topping): Pizza\n  def removeAllToppings(p: Pizza): Pizza\n\n  def updateCrustSize(p: Pizza, cs: CrustSize): Pizza\n  def updateCrustType(p: Pizza, ct: CrustType): Pizza\n}\n```\n\n----------------------------------------\n\nTITLE: Using 'Showable' with context bounds in Scala 3\nDESCRIPTION: Defines a generic 'showAll' function with context bound 'A: Showable', iterating over a list and printing each element using the 'show' extension. Simplifies syntax in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-type-classes.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef showAll[A: Showable](as: List[A]): Unit =\n  as.foreach(a => println(a.show))\n```\n\n----------------------------------------\n\nTITLE: Declaring and Assigning Variables - Scala\nDESCRIPTION: Demonstrates variable declaration and assignment using 'var' for mutable and 'val' for immutable variables. Explicit typing is shown using ': Double'. No external dependencies required. The snippet emphasizes differences between mutable and immutable variables and proper syntax for type annotations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nvar x = 5\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval x = 5\n```\n\nLANGUAGE: Scala\nCODE:\n```\nvar x: Double = 5\n```\n\n----------------------------------------\n\nTITLE: Overriding Methods from Superclasses in Scala\nDESCRIPTION: Extends the `Complex` class by overriding the `toString` method inherited from `AnyRef` (Java's `Object`). Requires the `override` keyword to explicitly indicate the intention to override. Provides a custom string representation for complex numbers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tutorials/scala-for-java-programmers.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nclass Complex(real: Double, imaginary: Double) {\n  def re = real\n  def im = imaginary\n  override def toString() =\n    \"\" + re + (if (im < 0) \"\" else \"+\") + im + \"i\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WebSocket Endpoint with Cask (Scala 3)\nDESCRIPTION: This Scala code defines a Cask web server with two endpoints using Scala 3 syntax. The `@cask.staticResources` endpoint serves files from the current directory under the `/static` path. The `@cask.websocket` endpoint handles WebSocket connections, processing incoming city names to return the current time in the corresponding timezone via `cask.Ws.Text` messages or closing the connection on an empty message.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/web-server-websockets.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n@cask.staticResources(\"/static\")\ndef static() = \".\"\n\nprivate def getZoneIdForCity(city: String): Option[ZoneId] =\n  import scala.jdk.CollectionConverters.*\n  ZoneId.getAvailableZoneIds.asScala.find(_.endsWith(\"/\" + city)).map(ZoneId.of)\n\n@cask.websocket(\"/websocket\")\ndef websocket(): cask.WsHandler =\n  cask.WsHandler { channel =>\n    cask.WsActor {\n      case cask.Ws.Text(\"\") => channel.send(cask.Ws.Close())\n      case cask.Ws.Text(city) =>\n        val text = getZoneIdForCity(city) match\n          case Some(zoneId) => s\"Current date is: ${ZonedDateTime.now().withZoneSameInstant(zoneId)}\"\n          case None => s\"Couldn't find time zone for city $city\"\n        channel.send(cask.Ws.Text(text))\n    }\n  }\n\ninitialize()\n```\n\n----------------------------------------\n\nTITLE: Defining a Scala Trait for Case Class Inheritance\nDESCRIPTION: Defines a simple Scala trait named 'Person' with an abstract 'name' method. This trait serves as a base type for different kinds of persons implemented as case classes in subsequent examples.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/case-classes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntrait Person {\n    def name: String\n}\n```\n\n----------------------------------------\n\nTITLE: Checking if a Partial Function is Defined for an Argument in Scala\nDESCRIPTION: Demonstrates how to use the isDefinedAt method to check if a partial function can handle a specific input value before attempting to apply it.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-partial-functions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndoubledOdds.isDefinedAt(3)  // true\ndoubledOdds.isDefinedAt(4)  // false\n```\n\n----------------------------------------\n\nTITLE: Testing Class Composition with Mixins in Scala\nDESCRIPTION: This snippet provides a test object `StringIteratorTest` with a `main` method that creates a new class `Iter` combining `StringIterator` and `RichIterator` using `with`. It demonstrates how to instantiate and utilize the combined iterator to print characters of a string.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/mixin-class-composition.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nobject StringIteratorTest {\n  def main(args: Array[String]): Unit = {\n    class Iter extends StringIterator(\"Scala\") with RichIterator\n    val iter = new Iter\n    iter foreach println\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: In-Place Transformation Operations for Mutable Scala Collections - Scala\nDESCRIPTION: This snippet presents new mutable collection operations that transform the collection in place, modifying the existing instance rather than returning a new collection. The methods include mapInPlace for mapping elements, flatMapInPlace for flat-mapping elements, filterInPlace for filtering according to a predicate, and patchInPlace for replacing a subsequence with another sequence. Each method returns the modified collection itself (this.type), enabling method chaining. These operations improve efficiency by avoiding unnecessary copies and allocations in mutable collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/collections-migration-213.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ndef mapInPlace(f: A => A): this.type\ndef flatMapInPlace(f: A => IterableOnce[A]): this.type\ndef filterInPlace(p: A => Boolean): this.type\ndef patchInPlace(from: Int, patch: scala.collection.Seq[A], replaced: Int): this.type\n```\n\n----------------------------------------\n\nTITLE: Inspecting Raw AST Representation with showRaw - Scala\nDESCRIPTION: This snippet shows how to inspect the internal structure of a Scala abstract syntax tree (AST) generated by a quasiquote using 'showRaw'. It outputs a low-level representation suitable for debugging and metaprogramming. Required dependencies are an initialized reflection universe and access to 'showRaw'. Input is a quasiquoted class definition; output is a string representation of the raw AST. This utility is standard in Scala reflection and available wherever quasiquotes are supported.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/setup.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nprintln(showRaw(q\"class C\"))\nClassDef(Modifiers(), TypeName(\"C\"), List(), Template(List(Select(Ident(scala), TypeName(\"AnyRef\"))), noSelfType, List(DefDef(Modifiers(), termNames.CONSTRUCTOR, List(), List(List()), TypeTree(), Block(List(pendingSuperCall), Literal(Constant(())))))))\n```\n\n----------------------------------------\n\nTITLE: Creating Nested Packages in Scala\nDESCRIPTION: This snippet illustrates defining nested packages using braces, allowing more granular encapsulation. It defines a 'users' package with nested 'administrators' and 'normalusers' sub-packages, each containing classes. This approach helps organize complex projects with hierarchical packages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/packages-and-imports.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\npackage users {\n  package administrators {\n    class NormalUser\n  }\n  package normalusers {\n    class NormalUser\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Impact of @inline annotation on method in Scala\nDESCRIPTION: This explanation describes how the @inline annotation suggests to the compiler to inline methods, potentially affecting runtime performance and binary size. It clarifies that inlining is not guaranteed, and compiler heuristics determine whether inlining occurs based on optimization criteria.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/annotations.md#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Implementing isTruthy method using match expression in Scala\nDESCRIPTION: An alternative implementation of the isTruthy method using a match expression instead of if/else, showing pattern matching with multiple case values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/methods-most.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef isTruthy(a: Any) = a match {\n  case 0 | \"\" | false => false\n  case _ => true\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef isTruthy(a: Matchable) = a match\n  case 0 | \"\" | false => false\n  case _ => true\n```\n\n----------------------------------------\n\nTITLE: Defining Methods in a Scala Value Class\nDESCRIPTION: Illustrates adding a method `foo` to the `Wrapper` value class. Value classes can contain `def` members which operate on the underlying value, but they cannot define `val`s, `var`s, or nested types like traits, classes, or objects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass Wrapper(val underlying: Int) extends AnyVal {\n  def foo: Wrapper = new Wrapper(underlying * 19)\n}\n```\n\n----------------------------------------\n\nTITLE: Importing given Instances and Non-given Members in Scala 3 Using Scala\nDESCRIPTION: This snippet shows how to import non-given members and given instances separately from an object in Scala 3. The object 'A' defines a given instance 'tc' of class 'TC' and a method requiring an implicit parameter. Object 'B' imports non-given members with 'import A.*' and the given instance with 'import A.given' to control scope explicitly. This helps clarify the origin of given instances in the current scope. No external dependencies are required beyond Scala 3 standard features. Inputs include definitions in object 'A', and outputs control which members are accessible in 'B'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/ca-given-imports.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject A:\n  class TC\n  given tc: TC = ???\n  def f(using TC) = ???\n\nobject B:\n  import A.*       // import all non-given members\n  import A.given   // import the given instance\n```\n\n----------------------------------------\n\nTITLE: Declaring Scala Objects with UpperCamelCase Names and Special Cases\nDESCRIPTION: Shows how to define Scala singleton objects named in UpperCamelCase, mirroring class naming style. Exceptions exist when mimicking a package or function, where lowercase names help reflect domain-specific design. This snippet includes usage of sealed traits and case classes within objects for structured representations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/naming-conventions.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject ast {\n  sealed trait Expr\n\n  case class Plus(e1: Expr, e2: Expr) extends Expr\n  ...\n}\n\nobject inc {\n  def apply(x: Int): Int = x + 1\n}\n```\n\n----------------------------------------\n\nTITLE: Negated Predicate Filtering with filterNot Pattern - Scala\nDESCRIPTION: This snippet models Option.filterNot(f) via pattern matching. Returns Some(x) if the Option contains a value not satisfied by predicate f, otherwise None. Takes an Option and predicate f as input, returns Option output. No dependencies required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\noption match {\n  case Some(x) if !f(x) => Some(x)\n  case _                => None\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Anonymous Implicit Conversion using 'given' in Scala 3\nDESCRIPTION: Demonstrates defining an anonymous implicit conversion from `Int` to `Long` in Scala 3. This uses an anonymous `given` instance of `scala.Conversion[Int, Long]`, which is useful when an explicit name for the conversion is not necessary.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-implicit-conversions.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ngiven Conversion[Int, Long] with\n  def apply(x: Int): Long = x.toLong\n```\n\n----------------------------------------\n\nTITLE: 比較のためのトレイト（Ord）と日付クラス例\nDESCRIPTION: 比較可能性を持つ`Ord`トレイトの定義と、それを継承した`Date`クラスの例。`equals`メソッドと比較演算子`<`がオーバーライドされ、日付オブジェクトを年・月・日で比較できるようになっている。これにより、`Date`オブジェクト間の自然な比較操作をサポート。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tutorials/scala-for-java-programmers.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Ord {\n  def < (that: Any): Boolean\n  def <=(that: Any): Boolean =  (this < that) || (this == that)\n  def > (that: Any): Boolean = !(this <= that)\n  def >=(that: Any): Boolean = !(this < that)\n}\n\nclass Date(y: Int, m: Int, d: Int) extends Ord {\n  def year = y\n  def month = m\n  def day = d\n  override def toString(): String = s\"$year-$month-$day\"\n  override def equals(that: Any): Boolean =\n    that.isInstanceOf[Date] && {\n      val o = that.asInstanceOf[Date]\n      o.day == day && o.month == month && o.year == year\n    }\n  def <(that: Any): Boolean = {\n    if (!that.isInstanceOf[Date])\n      sys.error(\"cannot compare \" + that + \" and a Date\")\n\n    val o = that.asInstanceOf[Date]\n    (year < o.year) ||\n    (year == o.year && (month < o.month ||\n                       (month == o.month && day < o.day)))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using 'f' Interpolator for Format-Specified String Output\nDESCRIPTION: Shows how to produce formatted strings similar to printf-style formatting using the 'f' interpolator. Variables are formatted with printf-like specifiers such as '%s' and '%2.2f', with type safety enforced by the compiler. It leverages Java's Formatter class for formatting and requires correct specifiers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/string-interpolation.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval height = 1.9d\nval name = \"James\"\nprintln(f\"$name%s is $height%2.2f meters tall\")  // James is 1.90 meters tall\n```\n\n----------------------------------------\n\nTITLE: Conditional Statements and Loops - Scala\nDESCRIPTION: Demonstrates basic control structures such as 'if', 'while', and 'do while', including both full and shorthand forms. Inputs: conditions and actions. Outputs: conditional execution and side effects. No dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nif (check) happy else sad\n```\n\nLANGUAGE: Scala\nCODE:\n```\nif (check) happy\n```\n\nLANGUAGE: Scala\nCODE:\n```\nwhile (x < 5) { println(x); x += 1}\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndo { println(x); x += 1} while (x < 5)\n```\n\n----------------------------------------\n\nTITLE: Type Inference with Function Values in Scala\nDESCRIPTION: Shows how function values benefit from parameter type inference when the context already provides type information. This avoids redundant type annotations for parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/types.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval ls: List[String] = ...\nls.map(str => str.toInt)\n```\n\n----------------------------------------\n\nTITLE: Defining Types Concisely in Scala 3\nDESCRIPTION: Shows the concise syntax available in Scala 3 for defining traits, enums, classes (including multiversal equality), and case classes. This highlights the reduced boilerplate compared to other languages or potentially previous Scala versions. Requires Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/why-scala-3.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ntrait Tail:\n  def wagTail(): Unit\n  def stopTail(): Unit\n\nenum Topping:\n  case Cheese, Pepperoni, Sausage, Mushrooms, Onions\n\nclass Dog extends Animal, Tail, Legs, RubberyNose\n\ncase class Person(\n  firstName: String,\n  lastName: String,\n  age: Int\n)\n```\n\n----------------------------------------\n\nTITLE: Completing a Promise with another Future in Scala\nDESCRIPTION: Demonstrates how to use completeWith to complete a Promise with the result of another Future, transferring the value or failure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_34\n\nLANGUAGE: scala\nCODE:\n```\nval f = Future { 1 }\nval p = promise[Int]()\n\np.completeWith(f)\n\np.future.foreach { x =>\n  println(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Computing Symbolic Derivatives of Expression Trees Using Pattern Matching with Guards in Scala\nDESCRIPTION: Defines the `derive` function which symbolically differentiates an expression tree `t` with respect to a variable `v`. It uses pattern matching with guards: sums differentiate to the sum of the derivatives of their subtrees; variables differentiate to one when matching the differentiation variable, otherwise zero; any other expression (such as constants) differentiates to zero. The guard `if (v == n)` ensures the derivative is one only for the target variable. A wildcard is used to match all other unmatched cases, enabling concise handling of constants and unrelated variables.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_it/tutorials/scala-for-java-programmers.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ndef derive(t: Tree, v: String): Tree = t match {\n  case Sum(l, r) => Sum(derive(l, v), derive(r, v))\n  case Var(n) if (v == n) => Const(1)\n  case _ => Const(0)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Parameterized Enum - Scala\nDESCRIPTION: This snippet illustrates a Scala 3 enum with per-case parameters. The enum Color is defined with a parameter rgb of type Int, and each case extends the base enum with its own rgb value. Requires Scala 3. The syntax enables each enum value to have unique data much like a class constructor.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_59\n\nLANGUAGE: Scala\nCODE:\n```\nenum Color(val rgb: Int):\n  case Red   extends Color(0xFF0000)\n  case Green extends Color(0x00FF00)\n  case Blue  extends Color(0x0000FF)\n```\n\n----------------------------------------\n\nTITLE: Explicitly Providing Contextual Arguments in Scala 3\nDESCRIPTION: Shows how to explicitly provide a value for a contextual parameter in Scala 3 using the 'using' keyword.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-context-parameters.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nrenderWebsite(\"/home\")(using config)\n```\n\n----------------------------------------\n\nTITLE: Generators with if-guards in for loops in Python and Scala\nDESCRIPTION: Demonstrates filtering elements during iteration with conditional guards inside loop bodies. Inputs: integer ranges; outputs: printing values that satisfy nested conditions. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_39\n\nLANGUAGE: Python\nCODE:\n```\nfor i in range(1,11):\n  if i % 2 == 0:\n    if i < 5:\n      print(i)\n```\n\n----------------------------------------\n\nTITLE: Storing Function Variables in Collections in Scala\nDESCRIPTION: Shows how function variables of type Int => Int, like `double` and `triple`, can be stored in collections such as List and Map. This enables flexible functional programming patterns leveraging collections of functions keyed by strings or stored as sequences.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-function-variables.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval functionList = List(double, triple)\n\nval functionMap = Map(\n  \"2x\" -> double,\n  \"3x\" -> triple\n)\n```\n\n----------------------------------------\n\nTITLE: Defining the Monoid trait with add and unit methods in Scala\nDESCRIPTION: This abstract class defines the Monoid interface with two core functions: add, which combines two elements of type A, and unit, which provides an identity element for A. These are foundational for defining monoids over various data types to support generic aggregation operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/implicit-parameters.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Monoid[A] {\n  def add(x: A, y: A): A\n  def unit: A\n}\n```\n\n----------------------------------------\n\nTITLE: Using Lower Bound Covariant Linked List in Scala Application\nDESCRIPTION: This snippet demonstrates usage of the covariant linked list with the lower bound in an application object extending `App`. It shows creating an initially empty list of type `ListNode[Null]`, then prepending `String` elements resulting in a `ListNode[String]`, and finally prepending an `Int` resulting in a `ListNode[Any]`. This validates the flexibility allowed by the covariant type parameter and lower bound prepend allowing insertion of broader types to existing lists, illustrating safe polymorphic list construction.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/lower-type-bounds.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nobject LowerBoundTest extends App {\n  val empty: ListNode[Null] = ListNode(null, null)\n  val strList: ListNode[String] = empty.prepend(\"hello\")\n                                       .prepend(\"world\")\n  val anyList: ListNode[Any] = strList.prepend(12345)\n}\n```\n\n----------------------------------------\n\nTITLE: Problematic String to Int Conversion Returning Default Value (Scala)\nDESCRIPTION: Demonstrates an initial, flawed approach to converting a String to an Int using a try-catch block. It returns the parsed integer on success but defaults to 0 on failure, which is problematic as it conflates a failed conversion with an actual input of \"0\".\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/no-null-values.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef toInt(s: String): Int = {\n    try {\n        Integer.parseInt(s.trim)\n    } catch {\n        case e: Exception => 0\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Mutable Set Using += and -= Operators - Scala\nDESCRIPTION: Illustrates the use of += and -= operators on a val holding a mutable Set. Unlike immutable Sets, these operators mutate the set in place and return the modified set. This snippet highlights the mutable collection behavior where operations have side effects, modifying the collection directly without reassignment. Dependencies are on Scala's mutable collection classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/sets.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval s = collection.mutable.Set(1, 2, 3)\ns += 4\ns -= 2\n```\n\n----------------------------------------\n\nTITLE: Defining a SubjectObserver Trait with Abstract Type Members in Scala 3\nDESCRIPTION: This Scala 3 snippet redefines the 'SubjectObserver' trait using Scala 3 syntax with indentation-based braces. It includes nested traits 'Subject' and 'Observer' with the same self-type annotation and abstract method, facilitating flexible observer pattern implementations. The approach exemplifies modern Scala syntax for trait design.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-oop.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntrait SubjectObserver:\n\n  type S <: Subject\n  type O <: Observer\n\n  trait Subject:\n    self: S =>\n      private var observers: List[O] = List()\n      def subscribe(obs: O) =\n        observers = obs :: observers\n      def publish() =\n        for obs <- observers do obs.notify(this)\n\n  trait Observer:\n    def notify(sub: S): Unit\n```\n\n----------------------------------------\n\nTITLE: Параллельное выполнение нескольких Future в Scala\nDESCRIPTION: Полный пример запуска нескольких Future параллельно, объединения их результатов в выражении for и обработки комбинированного результата.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/concurrency.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.util.{Failure, Success}\n\nval startTime = System.currentTimeMillis()\ndef delta() = System.currentTimeMillis() - startTime\ndef sleep(millis: Long) = Thread.sleep(millis)\n\n@main def multipleFutures1 =\n\n  println(s\"creating the futures:   ${delta()}\")\n\n  // (1) запуск вычислений, возвращающих Future\n  val f1 = Future { sleep(800); 1 }   // в конце концов возвращается 1\n  val f2 = Future { sleep(200); 2 }   // в конце концов возвращается 2\n  val f3 = Future { sleep(400); 3 }   // в конце концов возвращается 3\n\n  // (2) объединение нескольких Future в выражении `for`\n  val result =\n    for\n      r1 <- f1\n      r2 <- f2\n      r3 <- f3\n    yield\n      println(s\"in the 'yield': ${delta()}\")\n      (r1 + r2 + r3)\n\n  // (3) обработка результата\n  result.onComplete {\n    case Success(x) =>\n      println(s\"in the Success case: ${delta()}\")\n      println(s\"result = $x\")\n    case Failure(e) =>\n      e.printStackTrace\n  }\n\n  println(s\"before the 'sleep(3000)': ${delta()}\")\n\n  // важно для небольшой параллельной демонстрации: не глушить jvm\n  sleep(3000)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Mutable ParArray in Scala\nDESCRIPTION: Demonstrates initializing a mutable `ParArray` using `tabulate` to create an array of odd numbers, performing a parallel reduction (summation) using `reduce`, and applying a parallel transformation using `map`. Shows basic usage and common operations on `ParArray`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/concrete-parallel-collections.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nscala> val pa = scala.collection.parallel.mutable.ParArray.tabulate(1000)(x => 2 * x + 1)\npa: scala.collection.parallel.mutable.ParArray[Int] = ParArray(1, 3, 5, 7, 9, 11, 13,...\n\nscala> pa reduce (_ + _)\nres0: Int = 1000000\n\nscala> pa map (x => (x - 1) / 2)\nres1: scala.collection.parallel.mutable.ParArray[Int] = ParArray(0, 1, 2, 3, 4, 5, 6, 7,...\n```\n\n----------------------------------------\n\nTITLE: Using the copy Method to Create Modified Instance of a Case Class in Scala\nDESCRIPTION: Creates a new 'Email' instance 'emailEditado' based on 'emailDeJohn' with specific fields changed, using the 'copy' method. Demonstrates how to modify immutable case class instances functionally.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/case-classes.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval emailEditado = emailDeJohn.copy(title = \"Estou aprendendo Scala!\", body = \"É muito legal!\")\nprintln(emailDeJohn) // Original instance\nprintln(emailEditado) // Modified copy\n```\n\n----------------------------------------\n\nTITLE: Forbidding Inheritance with final in Java\nDESCRIPTION: In Java, classes are open for extension by default. To prevent a class from being subclassed, the `final` keyword is used before the `class` keyword in the class definition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_6\n\nLANGUAGE: Java\nCODE:\n```\nfinal class Person\n```\n\n----------------------------------------\n\nTITLE: For-Comprehension with Multiple Generators in Scala\nDESCRIPTION: A more complex example using two generators to find pairs of numbers whose sum equals a specific value. The for-comprehension iterates through ranges and uses a filter condition to match pairs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/for-comprehensions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef foo(n: Int, v: Int) =\n   for (i <- 0 until n;\n        j <- 0 until n if i + j == v)\n   yield (i, j)\n\nfoo(10, 10).foreach {\n  case (i, j) =>\n    println(s\"($i, $j) \")  // выводит (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)\n}\n```\n\n----------------------------------------\n\nTITLE: Refinement Type for Type Constraints in Scala\nDESCRIPTION: Illustrates a refinement type in Scala that specifies an Animal with a specific suitable food type. This type indicates an animal that eats only grass.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_glossary/index.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nAnimal { type SuitableFood = Grass }\n```\n\n----------------------------------------\n\nTITLE: Generating Expressions from Arbitrary Scala Code with Quotes in Scala 3\nDESCRIPTION: This snippet illustrates how to create an `Expr[T]` from arbitrary Scala code enclosed in quotes, enabling dynamic code generation within macros. For example, `'{ ${expr}; true }` produces an expression equivalent to a block with side effects followed by `true`, supporting advanced metaprogramming tasks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/macros.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\n`'{ ${expr}; true }` generates an `Expr[Boolean]` similar to `Expr.block(List(expr), Expr(true))`.\n```\n\n----------------------------------------\n\nTITLE: Importing Packages and Members in Scala 3\nDESCRIPTION: This snippet shows Scala 3 import capabilities, including wildcard import, importing givens (implicits), importing specific members, and aliasing. It demonstrates both new and retained syntax from Scala 2, featuring the asterisk (*) for general member imports and the 'given' keyword for implicits. Dependencies are limited to available packages, and usage is determined by scope. Aliasing improves code clarity when managing long or conflicting names.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/packages-and-imports.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nimport users.*  // import everything from the users package except given\nimport users.given // import all given from the users package\nimport users.User  // import the class User\nimport users.{User, UserPreferences}  // Only imports selected members\nimport users.UserPreferences as UPrefs  // import and rename for convenience\n```\n\n----------------------------------------\n\nTITLE: List Comprehension for Generating New List in Python\nDESCRIPTION: Creates a new list 'xs' by multiplying each integer in the range 1 to 3 by 10 using a list comprehension. The result is a list of values [10, 20, 30], demonstrating concise collection transformation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_27\n\nLANGUAGE: Python\nCODE:\n```\nxs = [i * 10 for i in range(1, 4)]\n# xs: [10,20,30]\n```\n\n----------------------------------------\n\nTITLE: For Generator with Combined Conditions in Scala\nDESCRIPTION: Shows Scala for loop generator iterating from 1 to 10 with a single 'if' guard combining two conditions using logical AND, printing 'i' values passing both. Illustrates compact logical filtering in loop comprehensions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_26\n\nLANGUAGE: Scala\nCODE:\n```\nfor\n  i <- 1 to 10\n  if i % 2 == 0 && i < 5\ndo\n  println(i)\n```\n\n----------------------------------------\n\nTITLE: Defining and Matching Function Types with Quasiquotes - Scala\nDESCRIPTION: Illustrates the use of quasiquotes for function types, showing correspondence to FunctionN classes and pattern matching across argument and result types. Requirements: Scala macro reflection universe. Inputs are function type expressions (e.g., '(A, B) => C'); outputs: argument types ('foo') and result type ('bar') extracted from the AST.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/type-details.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nval funtype = tq\"(A, B) => C\"\nval tq\"..$foo => $bar\" = funtype\n```\n\n----------------------------------------\n\nTITLE: Initializing Class and Inlining Method Example in Scala\nDESCRIPTION: Demonstrates the impact of the optimizer's assumption that singleton objects (modules) are never null when extending classes during initialization. The method 'f' in the singleton object 'Test', marked with @inline, may behave differently depending on optimizer settings. No external dependencies are required besides the Scala standard library. The constructor order and module non-null assumptions can lead to NullPointerException or differing results between optimized and non-optimized builds.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/compiler-options/optimizer.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass A {\n  println(Test.f)\n}\nobject Test extends A {\n  @inline def f = 0\n  def main(args: Array[String]): Unit = ()\n}\n```\n\n----------------------------------------\n\nTITLE: Fold with Indented Lambda Argument in Scala\nDESCRIPTION: This snippet applies the fewerBraces syntax to a 'foldLeft' operation in Scala 3. The initial value (0) is passed, followed by a colon and an indented lambda block that sums two values. This improves code clarity by removing braces, while keeping the lambda logic concise. Requires Scala 3 and fewerBraces support.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nxs.foldLeft(0): (x, y) =>\n  x + y\n```\n\n----------------------------------------\n\nTITLE: Macro Implementation for Erasure Technique Dynamic Access\nDESCRIPTION: Provides the macro implementation (`XmlEntity.impl`) for handling `selectDynamic` calls on `XmlEntity`. It extracts the schema URL from the singleton type parameter (`tUrl`) and the requested field name, then validates against a loaded schema before constructing the appropriate code tree.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/typeproviders.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nobject XmlEntity {\n  def impl(c: Context)(field: c.Tree) = {\n    import c.universe._\n    val TypeRef(_, _, tUrl) = c.prefix.tpe\n    val ConstantType(Constant(sUrl: String)) = tUrl\n    val schema = loadSchema(sUrl)\n    val Literal(Constant(sField: String)) = field\n    if (schema.contains(sField)) q\"${c.prefix}($sField)\"\n    else c.abort(s\"value $sField is not a member of $sUrl\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Named Parameters When Instantiating Classes in Scala 3\nDESCRIPTION: Comparing positional vs. named parameters when creating class instances in Scala 3, which improves code readability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-tools.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n// option 1\nval s = Socket(10_000, 10_000)\n\n// option 2\nval s = Socket(\n  timeout = 10_000,\n  linger = 10_000\n)\n```\n\n----------------------------------------\n\nTITLE: Try-catch-finally exception handling in Python\nDESCRIPTION: Shows Python's try-except-finally structure for error handling. Attempts to print an undefined variable, catching a NameError or any other exception, with each except block printing a message. The finally block runs regardless of exceptions. The example illustrates basic exception handling idioms in Python.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_49\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    print(a)\nexcept NameError:\n    print(\"NameError\")\nexcept:\n    print(\"Other\")\nfinally:\n    print(\"Finally\")\n```\n\n----------------------------------------\n\nTITLE: Anti-Pattern: Excessively Aligned Parameters in Method Invocation - Scala\nDESCRIPTION: Depicts a discouraged pattern where method parameters are horizontally aligned by excessive spacing, leading to maintenance and readability issues in Scala code. No dependencies are necessary. Inputs are a long variable assignment and a multi-parameter function call; output is not applicable as this demonstrates improper style. Should be avoided per the style guide's recommendations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/indentation.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\n// wrong!\nval myLongFieldNameWithNoRealPoint = foo(someVeryLongFieldName,\n                                             andAnotherVeryLongFieldName,\n                                             \"this is a string\",\n                                             3.1415)\n```\n\n----------------------------------------\n\nTITLE: Multiline While Loop (Scala 3)\nDESCRIPTION: Demonstrates the multiline syntax for a `while` loop in Scala 3 using the `do` keyword and indentation. The example initializes a mutable variable `x` and increments it within the loop body until the condition `x < 3` is false, printing the value each iteration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_31\n\nLANGUAGE: Scala\nCODE:\n```\nvar x = 1\n\nwhile\n  x < 3\ndo\n  println(x)\n  x += 1\n```\n\n----------------------------------------\n\nTITLE: Manual Implementation of Function Caching in Scala\nDESCRIPTION: This snippet shows how to manually implement function caching logic without using getOrElseUpdate. It checks if a result exists in the cache before computing the function, demonstrating the underlying pattern of the caching mechanism.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/maps.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef cachedF(arg: String) = cache get arg match {\n  case Some(result) => result\n  case None =>\n    val result = f(x)\n    cache(arg) = result\n    result\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Array Creation Function (Pre-Scala 2.8) in Scala\nDESCRIPTION: This Scala function `tabulate` demonstrates generic array creation before Scala 2.8. It takes a length `len` and a function `f` (mapping an integer index to a value of type `T`), creates a new `Array[T]` of the specified length, populates it using the function, and returns the array. This approach fails in Scala 2.8+ due to the lack of runtime type information needed for specialized array representations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/scala-2-8-arrays.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef tabulate[T](len: Int, f: Int => T) = {\n\tval xs = new Array[T](len)\n\tfor (i <- 0 until len) xs(i) = f(i)\n\txs\n}\n```\n\n----------------------------------------\n\nTITLE: Variable Embedding with the `raw` Interpolator in Scala\nDESCRIPTION: Shows that the `raw` interpolator in Scala still performs variable substitution (e.g., replacing `$foo` with its value) while simultaneously ignoring escape sequences like `\\n`. It combines literal interpretation of escapes with variable interpolation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nscala> val foo = 42\nscala> raw\"a\\n$foo\"\nres1: String = a\\n42\n```\n\n----------------------------------------\n\nTITLE: Prepending Collection to Buffer in Scala\nDESCRIPTION: Prepends all elements from a collection 'xs' to the beginning of the buffer 'buf'. Similar to prepending a single element, the collection is on the left side of the operator.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/seqs.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nxs ++=: buf\n```\n\n----------------------------------------\n\nTITLE: Concrete String Iterator Implementation in Scala 3\nDESCRIPTION: Implements the AbsIterator abstract class in Scala 3 syntax to iterate over characters in a string, using significant indentation for code blocks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/mixin-class-composition.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass StringIterator(s: String) extends AbsIterator:\n  type T = Char\n  private var i = 0\n  def hasNext = i < s.length\n  def next() =\n    val ch = s charAt i\n    i += 1\n    ch\n```\n\n----------------------------------------\n\nTITLE: Using trait subtypes for polymorphism in Scala\nDESCRIPTION: Demonstrates how traits enable polymorphism by allowing different implementing classes to be used interchangeably. The example uses a Pet trait with Cat and Dog implementations in a collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/traits.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable.ArrayBuffer\n\ntrait Pet {\n  val name: String\n}\n\nclass Cat(val name: String) extends Pet\nclass Dog(val name: String) extends Pet\n\nval dog = new Dog(\"Harry\")\nval cat = new Cat(\"Sally\")\n\nval animals = ArrayBuffer.empty[Pet]\nanimals.append(dog)\nanimals.append(cat)\nanimals.foreach(pet => println(pet.name))  // выведет \"Harry\" и \"Sally\"\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable.ArrayBuffer\n\ntrait Pet:\n  val name: String\n\nclass Cat(val name: String) extends Pet\nclass Dog(val name: String) extends Pet\n\nval dog = Dog(\"Harry\")\nval cat = Cat(\"Sally\")\n\nval animals = ArrayBuffer.empty[Pet]\nanimals.append(dog)\nanimals.append(cat)\nanimals.foreach(pet => println(pet.name))  // выведет \"Harry\" и \"Sally\"\n```\n\n----------------------------------------\n\nTITLE: Example usage of -snippet-compiler argument for selective snippet type checking - General syntax\nDESCRIPTION: Illustrates how a specific -snippet-compiler argument string configures different snippet checking modes for different source file paths. Snippets in `my/path/nc` are not compiled, snippets in `my/path/f` are expected to fail to compile, and all other snippets are expected to compile successfully. This example demonstrates priority dispatch among snippet checking flags based on source file paths.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/settings.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n\"-snippet-compiler:my/path/nc=nocompile,my/path/f=fail,compile\"\n```\n\n----------------------------------------\n\nTITLE: Implementing a Generic Stack Class in Scala 2\nDESCRIPTION: A generic Stack implementation in Scala 2 that can store elements of any type. The class includes push, peek, and pop operations with a private List to store elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/generic-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Stack[A] {\n  private var elements: List[A] = Nil\n  def push(x: A): Unit =\n    elements = x :: elements\n  def peek: A = elements.head\n  def pop(): A = {\n    val currentTop = peek\n    elements = elements.tail\n    currentTop\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: YAML Frontmatter Configuration for Scala Classes Tour Page\nDESCRIPTION: The YAML frontmatter configuration for a Scala tour page about classes. It defines the layout, title, and navigation structure for the page, which is part of the official Scala documentation. The language is specified as French.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tour/classes.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nlayout: tour\ntitle: Classes\npartof: scala-tour\n\nnum: 4\n\nlanguage: fr\n\nnext-page: traits\nprevious-page: unified-types\n---\n```\n\n----------------------------------------\n\nTITLE: Modifying Immutable Maps in Scala\nDESCRIPTION: Shows how to add, remove, and update elements in immutable Maps, creating new Map instances with the modified data using operators like +, ++, -, --, and the updated method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-classes.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\n// Adding elements to Map\nval a = Map(1 -> \"one\")    // a: Map(1 -> one)\nval b = a + (2 -> \"two\")   // b: Map(1 -> one, 2 -> two)\nval c = b ++ Seq(\n  3 -> \"three\",\n  4 -> \"four\"\n)\n// c: Map(1 -> one, 2 -> two, 3 -> three, 4 -> four)\n\n// Removing elements from Map\nval a = Map(\n  1 -> \"one\",\n  2 -> \"two\",\n  3 -> \"three\",\n  4 -> \"four\"\n)\n\nval b = a - 4       // b: Map(1 -> one, 2 -> two, 3 -> three)\nval c = a - 4 - 3   // c: Map(1 -> one, 2 -> two)\n\n// Updating Map elements\nval a = Map(\n  1 -> \"one\",\n  2 -> \"two\",\n  3 -> \"three\"\n)\n\nval b = a.updated(3, \"THREE!\")   // b: Map(1 -> one, 2 -> two, 3 -> THREE!)\nval c = a + (2 -> \"TWO...\")      // c: Map(1 -> one, 2 -> TWO..., 3 -> three)\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Derivative Function with Dependent Function Types\nDESCRIPTION: Shows how dependent function types make it convenient to pass different numerical programs to a derivative function, improving code ergonomics.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-dependent-function.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef derivative(input: Prog): Double\n\nderivative { nums => x => x }\nderivative { nums => x => nums.add(nums.lit(0.8), x) }\n// ...\n```\n\n----------------------------------------\n\nTITLE: Defining Implicit Conversions for List and Int to Ordered in Scala\nDESCRIPTION: This Scala snippet defines two implicit functions, list2ordered and int2ordered, allowing Lists and Int values to be implicitly converted to Ordered types. The list2ordered function requires an implicit conversion from elements to Ordered, enabling the comparison of lists based on their elements. These implicit conversions enable expressions like comparing lists using <=, which relies on these defined implicit transformations. Both functions return new instances of Ordered with appropriate implementations (represented by placeholders).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/implicit-conversions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimplicit def list2ordered[A](x: List[A])\n    (implicit elem2ordered: A => Ordered[A]): Ordered[List[A]] =\n  new Ordered[List[A]] { /* .. */ }\n\nimplicit def int2ordered(x: Int): Ordered[Int] =\n  new Ordered[Int] { /* .. */ }\n```\n\n----------------------------------------\n\nTITLE: Declaring Immutable Values in JavaScript\nDESCRIPTION: This snippet shows the 'const' keyword used to declare immutable values in JavaScript. Once assigned, a 'const' variable's value cannot be reassigned.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst\n```\n\n----------------------------------------\n\nTITLE: Example Snippet for List Method Documentation\nDESCRIPTION: This Scala code snippet demonstrates the usage of the `slice` method on a `List`, comparing its result to a combination of `drop` and `take`. This snippet relies on the implicit context provided by Scaladoc when processing documentation comments within the `List` class, so `slice`, `drop`, and `take` are directly available.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/snippet-compiler.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nslice(2, 5) == drop(2).take(3)\n```\n\n----------------------------------------\n\nTITLE: Naming Conventions and Abbreviations for Quasiquote Unquotes in Scala - Scala\nDESCRIPTION: This snippet documents the standardized prefixes and suffixes used in variable names when unquoting code fragments inside Scala quasiquotes. It defines how names relate to different types of AST nodes, such as expressions, patterns, statements, and others, clarifying the expected types for each abbreviation. The suffixes 's' and 'ss' indicate lists and lists of lists, respectively, to facilitate consistent interpretation of tree components in metaprogramming.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/syntax-summary.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n* `name: Name`, `tname: TermName`, `tpname: TypeName`\n* `value: T` where `T` is value type that corresponds to given literal (e.g. `Int`, `Char`, `Float` etc)\n* `expr: Tree` an [expression tree](#expressions)\n* `tpt: Tree` a [type tree](#types)\n* `pat: Tree` a [pattern tree](#patterns)\n* `defn: Tree` a [definition tree](#definitions)\n* `earlydefn: Tree` an early definion tree ([val](definition-details.html#val-and-var-definitions) or [type definition](definition-details.html#type-definition))\n* `self: Tree` a self definition tree (i.e. [val definition](definition-details.html#val-and-var-definitions))\n* `stat: Tree` a statement tree ([definition](#definitions), [expression](#expressions) or an [import](expression-details.html#import))\n* `topstat: Tree` a top-level statement tree ([class](definition-details.html#class-definition), [trait](definition-details.html#trait-definition), [package](definition-details.html#package-definition), [package object](definition-details.html#package-object-definition) or [import](expression-details.html#import))\n* `enum: Tree` a [for loop](expression-details.html#for-and-for-yield-loops) enumerator\n* `param: Tree` a value parameter tree (i.e. [val definition](definition-details.html#val-and-var-definitions))\n* `tparam: Tree` a type paremeter tree (i.e. [type definition](definition-details.html#type-definition))\n* `parent: Tree` a [template](definition-details.html#templates) parent\n* `sel: Tree` an [import](expression-details.html#import) selector tree\n\nWhenever a name has suffix `s` it means that it is a `List` of something. `ss` means List of Lists. So for example `exprss` means a `List` of `List`s of expressions.\n```\n\n----------------------------------------\n\nTITLE: Composing Partial Functions in Scala\nDESCRIPTION: Demonstrates how to compose two partial functions using orElse, where the second function handles inputs not covered by the first function.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-partial-functions.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval incrementedEvens: PartialFunction[Int, Int] = {\n  case i if i % 2 == 0 => i + 1\n}\n\nval res2 = List(1, 2, 3).collect(doubledOdds.orElse(incrementedEvens)) // List(2, 3, 6)\n```\n\n----------------------------------------\n\nTITLE: Scala 2 Implementation of PrefixMap Class for Patricia Trie\nDESCRIPTION: This snippet defines the PrefixMap class in Scala 2, implementing a Patricia trie with mutable operations for inserting, removing, and retrieving string keys with associated values. It extends Scala's mutable Map and MapOps, providing efficient prefix-based lookups with internal immutable map for suffixes and optional values. The class includes methods for get, withPrefix, addOne, subtractOne, iterator, and transformations like map and flatMap. It also defines a companion object for instantiation and factory conversions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_25\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection._\nimport scala.collection.mutable.{ GrowableBuilder, Builder }\n\nclass PrefixMap[A]\n  extends mutable.Map[String, A]\n    with mutable.MapOps[String, A, mutable.Map, PrefixMap[A]]\n    with StrictOptimizedIterableOps[(String, A), mutable.Iterable, PrefixMap[A]] {\n\n  private var suffixes: immutable.Map[Char, PrefixMap[A]] = immutable.Map.empty\n  private var value: Option[A] = None\n\n  def get(s: String): Option[A] =\n    if (s.isEmpty) value\n    else suffixes.get(s(0)).flatMap(_.get(s.substring(1)))\n\n  def withPrefix(s: String): PrefixMap[A] =\n    if (s.isEmpty) this\n    else {\n      val leading = s(0)\n      suffixes.get(leading) match {\n        case None =>\n          suffixes = suffixes + (leading -> empty)\n        case _ =>\n      }\n      suffixes(leading).withPrefix(s.substring(1))\n    }\n\n  def iterator: Iterator[(String, A)] =\n    (for (v <- value.iterator) yield (\"\", v)) ++\n      (for ((chr, m) <- suffixes.iterator; (s, v) <- m.iterator) yield (chr +: s, v))\n\n  def addOne(kv: (String, A)): this.type = {\n    withPrefix(kv._1).value = Some(kv._2)\n    this\n  }\n\n  def subtractOne(s: String): this.type  = {\n    if (s.isEmpty) { val prev = value; value = None; prev }\n    else suffixes.get(s(0)).flatMap(_.remove(s.substring(1)))\n    this\n  }\n\n  // Overloading of transformation methods that should return a PrefixMap\n  def map[B](f: ((String, A)) => (String, B)): PrefixMap[B] =\n    strictOptimizedMap(PrefixMap.newBuilder, f)\n  def flatMap[B](f: ((String, A)) => IterableOnce[(String, B)]): PrefixMap[B] =\n    strictOptimizedFlatMap(PrefixMap.newBuilder, f)\n\n  // Override `concat` and `empty` methods to refine their return type\n  override def concat[B >: A](suffix: IterableOnce[(String, B)]): PrefixMap[B] =\n    strictOptimizedConcat(suffix, PrefixMap.newBuilder)\n  override def empty: PrefixMap[A] = new PrefixMap\n\n  // Members declared in scala.collection.mutable.Clearable\n  override def clear(): Unit = suffixes = immutable.Map.empty\n  // Members declared in scala.collection.IterableOps\n  override protected def fromSpecific(coll: IterableOnce[(String, A)]): PrefixMap[A] = PrefixMap.from(coll)\n  override protected def newSpecificBuilder: mutable.Builder[(String, A), PrefixMap[A]] = PrefixMap.newBuilder\n\n  override def className = \"PrefixMap\"\n}\n\nobject PrefixMap {\n  def empty[A] = new PrefixMap[A]\n\n  def from[A](source: IterableOnce[(String, A)]): PrefixMap[A] =\n    source match {\n      case pm: PrefixMap[A] => pm\n      case _ => (newBuilder ++= source).result()\n    }\n\n  def apply[A](kvs: (String, A)*): PrefixMap[A] = from(kvs)\n\n  def newBuilder[A]: mutable.Builder[(String, A), PrefixMap[A]] =\n    new mutable.GrowableBuilder[(String, A), PrefixMap[A]](empty)\n\n  import scala.language.implicitConversions\n\n  implicit def toFactory[A](self: this.type): Factory[(String, A), PrefixMap[A]] =\n    new Factory[(String, A), PrefixMap[A]] {\n      def fromSpecific(it: IterableOnce[(String, A)]): PrefixMap[A] = self.from(it)\n      def newBuilder: mutable.Builder[(String, A), PrefixMap[A]] = self.newBuilder\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing Abstract Type Members with Type Parameters - Scala 2\nDESCRIPTION: Defines 'Buffer' and 'SeqBuffer' abstract classes using type parameters instead of abstract type members, with covariance and upper type bounds applied. Demonstrates a factory method producing a 'SeqBuffer' for integer lists using anonymous class syntax. Requires knowledge of Scala variance and collection types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/abstract-type-members.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Buffer[+T] {\n  val element: T\n}\nabstract class SeqBuffer[U, +T <: Seq[U]] extends Buffer[T] {\n  def length = element.length\n}\n\ndef newIntSeqBuf(e1: Int, e2: Int): SeqBuffer[Int, Seq[Int]] =\n  new SeqBuffer[Int, List[Int]] {\n    val element = List(e1, e2)\n  }\n\nval buf = newIntSeqBuf(7, 8)\nprintln(\"length = \" + buf.length)\nprintln(\"content = \" + buf.element)\n```\n\n----------------------------------------\n\nTITLE: Defining the Function Trait with Variance in Scala\nDESCRIPTION: Shows the approximate definition of the `Function` trait (Function1) in Scala. It demonstrates both contravariance (`-A`) on the input parameter type and covariance (`+B`) on the return type parameter. This means functions accepting supertypes or returning subtypes can be used where functions accepting subtypes or returning supertypes are expected, respectively.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-variance.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 2 Version\ntrait Function[-A, +B] {\n  def apply(a: A): B\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 3 Version\ntrait Function[-A, +B]:\n  def apply(a: A): B\n```\n\n----------------------------------------\n\nTITLE: Scala函数定义面饼价格（crustPrice）\nDESCRIPTION: 基于面饼大小和类型的纯函数，通过模式匹配计算不同组合的价格，突出参数组合的逻辑关系。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-fp.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef crustPrice(s: CrustSize, t: CrustType): Double =\n  (s, t) match\n    case (Small | Medium, _) => 0.25\n    case (Large, Thin) => 0.50\n    case (Large, Regular) => 0.75\n    case (Large, Thick) => 1.00\n```\n\n----------------------------------------\n\nTITLE: Implementing isTruthy method using if/else in Scala\nDESCRIPTION: This snippet demonstrates how to create a method called isTruthy that implements Perl-like definitions of true and false by using an if/else expression as the method body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/methods-most.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef isTruthy(a: Any) = {\n  if (a == 0 || a == \"\" || a == false)\n    false\n  else\n    true\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef isTruthy(a: Any) =\n  if a == 0 || a == \"\" || a == false then\n    false\n  else\n    true\n```\n\n----------------------------------------\n\nTITLE: Implementing Map Logic with a For-Expression in Scala\nDESCRIPTION: Demonstrates using a Scala `for` expression with `yield` to apply a function `f` to each element `x` of a collection `xs`, effectively implementing the core logic of a map operation. Shows variations for Scala 2 and Scala 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-write-map-function.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nfor (x <- xs) yield f(x)\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor x <- xs yield f(x)\n```\n\n----------------------------------------\n\nTITLE: Type-Inferred Anonymous Function Syntax with `map` in Scala\nDESCRIPTION: Demonstrates shortening the anonymous function syntax by relying on Scala's type inference. The explicit `: Int` type annotation for the parameter `i` is omitted as the compiler can infer it from the context (`ints.map`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-anonymous-functions.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval doubledInts = ints.map((i) => i * 2)\n```\n\n----------------------------------------\n\nTITLE: 複数パラメーターリストを持つメソッド - Scala\nDESCRIPTION: 複数のパラメーターリストを受け取る例で、最初の2つの引数を加算し、後の引数で乗算しています。Scalaのカリー化の基礎を示し、呼び出し時の複数括弧も例示しています。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ndef addThenMultiply(x: Int, y: Int)(multiplier: Int): Int = (x + y) * multiplier\nprintln(addThenMultiply(1, 2)(3)) // 9\n```\n\n----------------------------------------\n\nTITLE: Using Extractors for Variable Initialization in Scala\nDESCRIPTION: This example shows how extractors can be used to initialize variables through pattern matching. The CustomerID extractor is used to directly extract the name from a customer ID string into a variable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/extractor-objects.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval customer2ID = CustomerID(\"Nico\")\nval CustomerID(name) = customer2ID\nprintln(name)  // prints Nico\n```\n\n----------------------------------------\n\nTITLE: Using head Method to Access First Element in Scala\nDESCRIPTION: Examples of using the head method to access the first element of a collection, demonstrated on lists and strings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/collections-methods.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\noneToTen.head   // 1\nnames.head      // adam\n```\n\n----------------------------------------\n\nTITLE: Defining Multi-line Strings with Triple Quotes in Scala\nDESCRIPTION: Creates a multi-line string literal using triple quotes syntax to span multiple lines without string concatenation. Illustrates basic multi-line string literal where indentation is preserved as part of string content.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/first-look-at-types.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval quote = \"\"\"The essence of Scala:\n               Fusion of functional and object-oriented\n               programming in a typed setting.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Byname Implicits in Show Type Class Derivation for Recursive Types in Scala\nDESCRIPTION: Modifies the Show companion to accept and propagate byname implicit parameters, resolving recursive instance derivation for types such as List. The showGeneric now receives Show[R] by name, breaking dependency cycles. Enables constructions like Show[List[Int]] to compile and work recursively without divergence. Requires prior definitions of Show and Generic instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nobject Show {\n  def apply[T](implicit st: => Show[T]): Show[T] = st\n\n  // other definitions unchanged ...\n\n  implicit def showGeneric[T, R]\n    (implicit\n      gen:    Generic.Aux[T, R],\n      sr:  => Show[R]):\n              Show[T] = new Show[T] {\n    def show(x: T): String = sr.show(gen.to(x))\n  }\n}\n\nval sl = Show[List[Int]] // compiles\nassert(\n  sl.show(Cons(1, Cons(2, Cons(3, Nil)))) == \"1, 2, 3\"\n)\n```\n\n----------------------------------------\n\nTITLE: Creating List of Duplicates in Scala 3\nDESCRIPTION: This Scala 3 code provides an equivalent implementation of the polymorphic method `listOfDuplicates`. It takes a type parameter `A`, an element `x` of type `A`, and an integer `length` to create a `List[A]` with `x` repeated `length` times. The syntax differs slightly from Scala 2 (e.g., using `then`), but the logic and examples demonstrating explicit type parameterization and type inference are the same.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/polymorphic-methods.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef listOfDuplicates[A](x: A, length: Int): List[A] =\n  if length < 1 then\n    Nil\n  else\n    x :: listOfDuplicates(x, length - 1)\n\nprintln(listOfDuplicates[Int](3, 4))  // List(3, 3, 3, 3)\nprintln(listOfDuplicates(\"La\", 8))  // List(La, La, La, La, La, La, La, La)\n```\n\n----------------------------------------\n\nTITLE: Creating heterogeneous List with Scala Any type - Scala\nDESCRIPTION: Defines a List of type List[Any] containing a string, integer, character, boolean, and an anonymous function, illustrating how different types can be stored together using Scala's Any supertype. It depends on Scala's core library and uses foreach to print each element. The snippet demonstrates polymorphic handling of objects with different runtime types within a single list.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/tour/unified-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval list: List[Any] = List(\n  \"a string\",\n  732,  // an integer\n  'c',  // a character\n  true, // a boolean value\n  () => \"an anonymous function returning a string\"\n)\n\nlist.foreach(element => println(element))\n```\n\n----------------------------------------\n\nTITLE: Defining Algebraic Structures with Abstract Classes in Scala\nDESCRIPTION: This snippet defines the abstract classes SemiGroup and Monoid to model algebraic structures, where SemiGroup declares a binary operation 'add', and Monoid extends SemiGroup with an identity element 'unit'. It sets the foundation for type classes used in the implicit parameter examples.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/implicit-parameters.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n/** 이 예정은 전첩사이트 이내 이름 SemiGroup 는 등뜻 add(x, y) 수입을 다루는 정도가능한 수입이다. 주의로 add가 결함되기 때마다, A 값이라고 말해도 많이 사용됩니다. */\nabstract class SemiGroup[A] {\n  def add(x: A, y: A): A\n}\n\n/** monoid는 A의 구분되는 좋아도 unit를 달고 자동할 때 아마 monoid 이름의 시입이다. */\nabstract class Monoid[A] extends SemiGroup[A] {\n  def unit: A\n}\n```\n\n----------------------------------------\n\nTITLE: Existential Predicate Check with exists Pattern - Scala\nDESCRIPTION: This snippet shows how to replicate Option.exists using pattern matching. Returns true if the Option is Some and the value satisfies predicate f, otherwise returns false. Input is an Option and predicate function, output is Boolean. No external dependencies. Always returns false for None.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\noption match {\n  case Some(x) if f(x) => true\n  case Some(_)         => false\n  case None            => false\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Quoted Generic Expressions (`Option[T]`)\nDESCRIPTION: Shows pattern matching on generic quoted expressions. `case '{ Some($x) } =>` matches an `Expr[Option[T]]` and extracts the inner part as `x: Expr[T]`. This requires a `Type[T]` context bound on the enclosing method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ndef exprOfOption[T: Type](x: Expr[Option[T]])(using Quotes): Option[Expr[T]] =\n  x match\n    case '{ Some($x) } => Some(x) // x: Expr[T]\n    case '{ None } => Some(None)\n    case _ => None\n```\n\n----------------------------------------\n\nTITLE: Illustrating Illegal Match Type Instantiation with Abstract Type Constructor in Scala\nDESCRIPTION: This example demonstrates potential illegal instantiation of the recursive match type `InverseMap` when supplied with an abstract or illegal type constructor `IsSeq` constrained to subtypes of `Seq[Any]`. The pattern match expands to `case IsSeq[x] *: t` which is not guaranteed to be legal, potentially triggering compiler errors at type checking rather than at source code parsing. This snippet emphasizes type system limitations where warnings cannot be generated due to lack of source position in cached type computations, mandating error propagation instead. It serves to highlight challenges in implementing fully sound match type semantics in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/match-types-spec.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ntype IsSeq[t <: Seq[Any]] = t\nInverseMap[X, IsSeq]\n\n// which internally gives pattern:\n// case IsSeq[x] *: t => x *: InverseMap[t, IsSeq]\n```\n\n----------------------------------------\n\nTITLE: Extending a Trait in a Scala Class\nDESCRIPTION: Demonstrates extending the Pet trait in a Dog class, implementing the required abstract 'comeToMaster' method while inheriting the concrete 'speak' method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/traits-abstract-mixins.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass Dog(name: String) extends Pet {\n    def comeToMaster(): Unit = println(\"Woo-hoo, I'm coming!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Default Arguments Implementation in Scala\nDESCRIPTION: Shows how the Scala compiler implements default arguments by generating helper methods with deterministic names. These methods compute default values and are parametrized by type parameters and preceding value parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-and-default-arguments.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\ndef f[T](a: Int = 1)(b: T = a + 1)(c: T = b)\n// generates:\n// def f$default$1[T]: Int = 1\n// def f$default$2[T](a: Int): Int = a + 1\n// def f$default$3[T](a: Int)(b: T): T = b\n```\n\n----------------------------------------\n\nTITLE: Scala Class with Private Constructor Parameters\nDESCRIPTION: Highlights that constructor parameters without 'val' or 'var' are private and cannot be accessed or modified outside the class, reinforcing encapsulation by restricting direct access.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/classes.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nclass Point(x: Int, y: Int)\nval point = new Point(1, 2)\npoint.x  // <-- compilation error\n```\n\n----------------------------------------\n\nTITLE: Using `*` placeholders for type lambdas in Scala 2 (kind-projector)\nDESCRIPTION: Examples of defining simple type lambdas using the `*` placeholder syntax provided by the Scala 2 `kind-projector` plugin. This syntax is the common pattern before migrating to `_` for type lambdas.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/plugin-kind-projector.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nTuple2[*, Double]        // equivalent to: type R[A] = Tuple2[A, Double]\nEither[Int, +*]          // equivalent to: type R[+A] = Either[Int, A]\nFunction2[-*, Long, +*]  // equivalent to: type R[-A, +B] = Function2[A, Long, B]\n```\n\n----------------------------------------\n\nTITLE: Function Composition and Currying in Scala\nDESCRIPTION: Advanced function techniques including function composition, currying, generic types, and variable-length arguments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/cheatsheets/index.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef compose(g:R=>R, h:R=>R) = (x:R) => g(h(x))\nval f = compose({_*2}, {_-1})\n```\n\nLANGUAGE: scala\nCODE:\n```\nval zscore = (mean:R, sd:R) => (x:R) => (x-mean)/sd\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef zscore(mean:R, sd:R) = (x:R) => (x-mean)/sd\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef zscore(mean:R, sd:R)(x:R) = (x-mean)/sd\n```\n\nLANGUAGE: scala\nCODE:\n```\nval normer = zscore(7, 0.4) _\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef mapmake[T](g:T=>T)(seq: List[T]) = seq.map(g)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef sum(args: Int*) = args.reduceLeft(_+_)\n```\n\n----------------------------------------\n\nTITLE: Proposal 1: Allowing Initial Aliases - Example and Desugaring\nDESCRIPTION: Demonstrates the proposed feature allowing `for` comprehensions to start with pure aliases (`a = 1`) and its corresponding desugaring. The aliases are translated into `val` definitions within an enclosing block.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\n// Example\nfor\n  a = 1\n  b <- Some(2)\n  c <- doSth(a)\nyield b + c\n\n// Desugared Code\n{\n  val a = 1\n  for\n    b <- Some(2)\n    c <- doSth(a)\n  yield b + c\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Compiler Phases with Macro Paradise in Scala\nDESCRIPTION: This snippet demonstrates how to view the compiler phases when the Macro Paradise plugin is active. The output shows the insertion of 'macroparadise' phase early in the compilation process.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/paradise.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n~/210x $ scalac -Xplugin:paradise_*.jar -Xshow-phases\n        phase name  id  description\n        ----------  --  -----------\n            parser   1  parse source into ASTs, perform simple desugaring\n     macroparadise   2  let our powers combine\n             namer   3  resolve names, attach symbols to trees in paradise\n    packageobjects   4  load package objects in paradise\n             typer   5  the meat and potatoes: type the trees in paradise\n                    ...\n```\n\n----------------------------------------\n\nTITLE: Comparing Multiple Parameter Lists with True Currying in Scala\nDESCRIPTION: Example demonstrating the similarities between methods with multiple parameter lists and properly curried functions, showing that they can be called in the same way despite different definitions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/multiple-parameter-lists.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n// версия с множественными списками параметров\ndef addMultiple(n1: Int)(n2: Int) = n1 + n2\n// два различных способа получить каррированную версию\ndef add(n1: Int, n2: Int) = n1 + n2\nval addCurried1 = (add _).curried\nval addCurried2 = (n1: Int) => (n2: Int) => n1 + n2\n// независимо от определения, вызов всех трех идентичен\naddMultiple(3)(4)  // 7\naddCurried1(3)(4)  // 7\naddCurried2(3)(4)  // 7\n```\n\n----------------------------------------\n\nTITLE: map Operation in MapOps with mapFactory - Scala 3\nDESCRIPTION: The Scala 3 implementation of MapOps and MapFactory demonstrates map operations for collections with key-value pairs. The mapFactory provides a from function for constructing a new map with transformed entries, supporting full abstraction over construction and transformation in map collections. The syntax emphasizes parameterization and flexibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\ntrait MapOps[K, +V, +CC[_, _], +C]\n  extends IterableOps[(K, V), Iterable, C]:\n\n  def map[K2, V2](f: ((K, V)) => (K2, V2)): CC[K2, V2] =\n    mapFactory.from(View.Map(this, f))\n\n  // Similar to iterableFactory, but for Map collection types\n  def mapFactory: MapFactory[CC]\n\ntrait MapFactory[+CC[_, _]]:\n  def from[K, V](it: IterableOnce[(K, V)]): CC[K, V]\n```\n\n----------------------------------------\n\nTITLE: Mutating Class Fields in Scala\nDESCRIPTION: This snippet shows how to modify the value of `var` fields in a class instance using the assignment operator (`=`). This operation is possible because the fields were declared with `var`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\np.name = \"Bob Dylan\"\np.vocation = \"Musician\"\n```\n\n----------------------------------------\n\nTITLE: 示例：定义表达程序类型和实例\nDESCRIPTION: 定义`Prog`为依赖`Nums`的函数类型，支持不同数值表达的程序表达。`ex`是一个示例程序，表示将两个数字相加，体现依赖类型在泛型表达式中的应用。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-dependent-function.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ntype Prog = (n: Nums) => n.Num => n.Num\n\nval ex: Prog = nums => x => nums.add(nums.lit(0.8), x)\n```\n\n----------------------------------------\n\nTITLE: Scala 2 Implementation of maxElement with implicit parameter\nDESCRIPTION: Defines a method 'maxElement' that returns the maximum value in a list using a context parameter of type 'Ord[A]' in Scala 2. The 'Ord' trait specifies comparison behavior, and 'max' uses this to determine the larger of two values. Dependencies include the 'Ord' trait and the 'max' function, relying on implicit resolution.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-context-bounds.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef maxElement[A](as: List[A])(implicit ord: Ord[A]): A =\n  as.reduceLeft(max(_, _)(ord))\n```\n\n----------------------------------------\n\nTITLE: 'for' loop over list in Scala 3\nDESCRIPTION: Uses Scala 3 syntax for a 'for' loop with 'do' to iterate and print each element of a list.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval ints = List(1, 2, 3, 4, 5)\n\nfor i <- ints do println(i)\n```\n\n----------------------------------------\n\nTITLE: Custom JSON serialization with ReadWriter in Scala 3\nDESCRIPTION: Defines a custom ReadWriter for the case class `Bar` using Scala 3 syntax, mapping `Bar` objects to JSON arrays with specific element arrangement. Utilizes `given` for implicit resolution and demonstrates serialization with `upickle.default.write`, enhancing JSON customization in Scala 3 environments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-what-else.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport upickle.default.*\n\ncase class Bar(i: Int, s: String)\n\nobject Bar:\n  given ReadWriter[Bar] = readwriter[ujson.Value]\n    .bimap[Bar](\n      x => ujson.Arr(x.s, x.i),\n      json => new Bar(json(1).num.toInt, json(0).str)\n    )\n\nval bar = Bar(5, \"bar\")\nval json = upickle.default.write(bar)\nprintln(json)\n// prints: [5, \"bar\"]\n```\n\n----------------------------------------\n\nTITLE: Extending Scala Language Syntax with Opaque Modifier (YAML Specification Fragment)\nDESCRIPTION: Formalizes the addition of 'opaque' as a local modifier for type alias definitions in the Scala grammar. It shows how opaque types are integrated into the Scala Language Specification, enabling the new opaque type qualifier.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/opaque-types.md#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\nLocalModifier     ::=  ‘abstract’\n                    |  ‘final’\n                    |  ‘sealed’\n                    |  ‘implicit’\n                    |  ‘lazy’\n                    |  ‘opaque’\n```\n\nLANGUAGE: yaml\nCODE:\n```\nDef        ::= [‘opaque’] ‘type’ {nl} TypeDef\nTypeDef    ::=  id [TypeParamClause] ‘=’ Type\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Case Classes and Guards in Scala 2\nDESCRIPTION: Shows pattern matching using case classes with conditional guards in Scala 2. Matches a 'Person' object with specific 'name' values, printing customized strings accordingly. Requires the definition of case class 'Person'. Supports pattern binding and guards for fine-grained matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\nval p = Person(\"Fred\")\n\n// позже в этом коде ...\np match {\n  case Person(name) if name == \"Fred\" =>\n    println(s\"$name says, Yubba dubba doo\")\n\n  case Person(name) if name == \"Bam Bam\" =>\n    println(s\"$name says, Bam bam!\")\n\n  case _ => println(\"Watch the Flintstones!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Traits for Intersection Types in Scala 3\nDESCRIPTION: Defines two traits, `Cloneable` extending `java.lang.Cloneable` (overriding `clone` to be public) and `Resetable` with an abstract `reset` method, using Scala 3 syntax. These traits serve as components for demonstrating intersection types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/compound-types.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntrait Cloneable extends java.lang.Cloneable:\n  override def clone(): Cloneable =  // makes clone public\n    super.clone().asInstanceOf[Cloneable]\ntrait Resetable:\n  def reset: Unit\n```\n\n----------------------------------------\n\nTITLE: Basic Scaladoc Reference Syntax in Scala\nDESCRIPTION: Demonstrates the basic syntax for creating a reference to a Scala class in Scaladoc documentation using double square brackets.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/linking.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n[[scala.collection.immutable.List]]\n```\n\n----------------------------------------\n\nTITLE: Generic Macro Definition and Implementation Using WeakTypeTag (Scala)\nDESCRIPTION: Defines a polymorphic macro method `map` inside a generic class `Queryable[T]` that expands to a macro implementation method `map` in the `QImpl` object. The macro implementation accepts a compiler context and expression parameters, uses context bounds with `WeakTypeTag` to access type information at compile time, and returns an expression of `Queryable[U]`. This snippet demonstrates passing explicit type parameters to macro implementations and type tag usage to propagate static type information during macro expansion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/overview.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass Queryable[T] {\n  def map[U](p: T => U): Queryable[U] = macro QImpl.map[T, U]\n}\n\nobject QImpl {\n  def map[T: c.WeakTypeTag, U: c.WeakTypeTag]\n         (c: Context)\n         (p: c.Expr[T => U]): c.Expr[Queryable[U]] = ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a mutable Map cache in Scala\nDESCRIPTION: Initializes an empty mutable Map from String to String, used as a cache to store previously computed results of expensive operations. Depends on Scala's `collection.mutable.Map` library and mutable collections support. This cache is used later with `getOrElseUpdate` for memoization.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/maps.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval cache = collection.mutable.Map[String, String]()\n```\n\n----------------------------------------\n\nTITLE: Defining the RNA1 Class (Scala 3)\nDESCRIPTION: Defines the initial `RNA1` class using Scala 3 syntax, representing an immutable sequence of `Base` objects. Functionally equivalent to the Scala 2 version, it uses an `Array[Int]` for compact bit-packed storage. The class extends `IndexedSeq[Base]` and `IndexedSeqOps`, providing collection framework integration through `apply`, `fromSpecific`, `newSpecificBuilder`, and `empty` implementations. Instantiation is controlled via the companion object due to the private constructor.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport collection.mutable\nimport collection.immutable.{ IndexedSeq, IndexedSeqOps }\n\nfinal class RNA1 private\n( val groups: Array[Int],\n  val length: Int\n) extends IndexedSeq[Base],\n  IndexedSeqOps[Base, IndexedSeq, RNA1]:\n\n  import RNA1.*\n\n  def apply(idx: Int): Base =\n    if idx < 0 || length <= idx then\n      throw IndexOutOfBoundsException()\n    Base.fromInt(groups(idx / N) >> (idx % N * S) & M)\n\n  override protected def fromSpecific(coll: IterableOnce[Base]): RNA1 =\n    fromSeq(coll.iterator.toSeq)\n  override protected def newSpecificBuilder: mutable.Builder[Base, RNA1] =\n    iterableFactory.newBuilder[Base].mapResult(fromSeq)\n  override def empty: RNA1 = fromSeq(Seq.empty)\n  override def className = \"RNA1\"\nend RNA1\n\nobject RNA1:\n\n  // Number of bits necessary to represent group\n  private val S = 2\n\n  // Number of groups that fit in an Int\n  private val N = 32 / S\n\n  // Bitmask to isolate a group\n  private val M = (1 << S) - 1\n\n  def fromSeq(buf: collection.Seq[Base]): RNA1 =\n    val groups = new Array[Int]((buf.length + N - 1) / N)\n    for i <- 0 until buf.length do\n      groups(i / N) |= Base.toInt(buf(i)) << (i % N * S)\n    new RNA1(groups, buf.length)\n\n  def apply(bases: Base*) = fromSeq(bases)\nend RNA1\n```\n\n----------------------------------------\n\nTITLE: Method Using Type Matching (Scala 2)\nDESCRIPTION: Shows how a method in Scala 2 can use a `match` expression on an `Any` parameter to perform type-based pattern matching, handling different types like `String`, `Int`, `Double`, and `List`. Includes example calls to the method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\n// getClassAsString is a method that takes a single argument of any type.\ndef getClassAsString(x: Any): String = x match {\n  case s: String => s\"'$s' is a String\"\n  case i: Int => \"Int\"\n  case d: Double => \"Double\"\n  case l: List[_] => \"List\"\n  case _ => \"Unknown\"\n}\n\n// examples\ngetClassAsString(1)               // Int\ngetClassAsString(\"hello\")         // 'hello' is a String\ngetClassAsString(List(1, 2, 3))   // List\n```\n\n----------------------------------------\n\nTITLE: Matching Case Classes with Guards (Scala 3)\nDESCRIPTION: Demonstrates using a `match` expression in Scala 3 to match against `case` classes, extract values (e.g., `name`), and use pattern guards (`if condition`) for more specific matching criteria, using the new indentation-based syntax. Includes a default case. Requires a `Person` case class definition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\nval p = Person(\"Fred\")\n\n// later in the code\np match\n  case Person(name) if name == \"Fred\" =>\n    println(s\"$name says, Yubba dubba doo\")\n\n  case Person(name) if name == \"Bam Bam\" =>\n    println(s\"$name says, Bam bam!\")\n\n  case _ => println(\"Watch the Flintstones!\")\n```\n\n----------------------------------------\n\nTITLE: Manually Constructing and Showing a Simple Tree\nDESCRIPTION: Demonstrates how to manually construct a simple Abstract Syntax Tree (AST) representing the Scala expression `x.$plus(2)` using the `Apply`, `Select`, `Ident`, and `Literal` tree nodes. It then uses the `show` method (or `toString`) to display the tree's representation as pseudo-Scala code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/reflection/symbols-trees-types.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n\nval tree = Apply(Select(Ident(TermName(\"x\")), TermName(\"$plus\")), List(Literal(Constant(2))))\n```\n\nLANGUAGE: Scala\nCODE:\n```\nshow(tree)\n```\n\n----------------------------------------\n\nTITLE: Creating Futures with ExecutionContext - Scala\nDESCRIPTION: Demonstrates creation of a Future using the scala.concurrent.Future API to execute an asynchronous computation that retrieves a user\\'s friends from a remote social network service. Requires the scala.concurrent.Future module and a valid socialNetwork session object. The Future instance f will eventually hold either a list of Friend objects or an exception on failure. This usage pattern is intended for parallel API requests where results are required later, and leverages non-blocking concurrency. Limitations include assuming session is valid; if it is not, an exception will occur when evaluating the Future.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/futures-promises.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.concurrent.Future\n\nval session = socialNetwork.createSessionFor(\"user\", credentials)\nval f: Future[List[Friend]] = Future {\n  session.getFriends\n}\n```\n\n----------------------------------------\n\nTITLE: Method with default parameter in Scala 2 and 3\nDESCRIPTION: Defines a method with a default argument for timeout, illustrating how defaults are specified and used in Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-methods.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ndef makeConnection(url: String, timeout: Int = 5000): Unit =\n  println(s\"url=$url, timeout=$timeout\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Case Class Constructor Patterns in Scala\nDESCRIPTION: Highlights the specific pattern matching syntax (`case Student(name, year) =>`, `case Teacher(name, whatTheyTeach) =>`) used with case classes. These are known as constructor patterns and leverage the `unapply` methods automatically generated by case classes to extract their constituent fields for use within the `case` block. The syntax is the same for Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_45\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\ncase Student(name, year) =>\ncase Teacher(name, whatTheyTeach) =>\n```\n\n----------------------------------------\n\nTITLE: Predefined implicit conversion from scala.Int to java.lang.Integer\nDESCRIPTION: This implicit conversion enables passing a Scala Int where a Java Integer is expected by automatically converting the Scala primitive to its Java boxed type. It is part of Scala's default conversions provided by scala.Predef and requires importing scala.language.implicitConversions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/implicit-conversions.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit def int2Integer(x: Int): Integer =\n  Integer.valueOf(x)\n```\n\n----------------------------------------\n\nTITLE: Applying Second Lazy Map to View - Scala REPL\nDESCRIPTION: Applying another map operation to the resulting view from a previous lazy map creates a new view (`SeqViewMM`) that records both pending operations. The 'MM' indicates two consecutive maps have been recorded.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/views.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nres13 map (_ * 2)\n```\n\nLANGUAGE: text\nCODE:\n```\nres14: scala.collection.SeqView[Int,Seq[_]] = SeqViewMM(...)\n```\n\n----------------------------------------\n\nTITLE: Creating and Inspecting a Collection View - Scala REPL\nDESCRIPTION: Shows how to obtain a view from a strict collection using `.view`. The output displays the type of the view (`SeqView`) and indicates it's a lazy representation of the underlying collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/views.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval vv = v.view\n```\n\nLANGUAGE: text\nCODE:\n```\nvv: scala.collection.SeqView[Int,Vector[Int]] =\n   SeqView(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n```\n\n----------------------------------------\n\nTITLE: Running a Single Test Suite in sbt\nDESCRIPTION: Demonstrates execution of a specific test suite with sbt using the 'testOnly' task. Dependencies include sbt build setup with test dependencies, and the test class being correctly specified.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-run-only.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nsbt:example> testOnly example.MyTests\n```\n\n----------------------------------------\n\nTITLE: Obtaining a Class Literal in Scala\nDESCRIPTION: Shows the Scala syntax `classOf[Type]` (e.g., `classOf[String]`) to obtain the runtime `java.lang.Class` object corresponding to the specified type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/cheatsheets/index.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nclassOf[String]\n```\n\n----------------------------------------\n\nTITLE: Dimensional Analysis Using Libra with Scala Literal Types\nDESCRIPTION: Demonstrates use of the Libra library to enforce dimensional correctness of numerical computations at compile time using type-level SI units. Includes examples of adding and multiplying quantities with units, converting units, and checking invalid operations such as adding incompatible units (meters and kilograms), which fails at compile time. Dependencies include spire and libra. Inputs are numeric values with attached unit types; outputs are values with computed units and unit-aware string representations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/42.type.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport spire.implicits._\n\nimport libra._, libra.si._\n\n(3.m + 2.m).show\n// res0: String = 5 m [L]\n\n(3.m * 2.m).show\n// res1: String = 6 m^2 [L^2]\n\n(1.0.km.to[Metre] + 2.0.m + 3.0.mm.to[Metre]).show\n// res2: String = 1002.003 m [L]\n\n(3.0.s.to[Millisecond] / 3.0.ms).show\n// res3: String = 1000.0  []\n\n3.m + 2.kg //this should fail\n// <console>:22: error: These quantities can't be added!\n//        3.m + 2.kg //this should fail\n//            ^\n```\n\n----------------------------------------\n\nTITLE: Matching Case Classes with Guards in Scala 3\nDESCRIPTION: Demonstrates pattern matching on a Scala 3 case class (`Person`), extracting a field (`name`), and using that field in an `if` guard to perform actions based on the specific field value. Uses indentation syntax and includes the `Person` case class definition and example calls to the `speak` method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_27\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Person(name: String)\n\ndef speak(p: Person) = p match\n  case Person(name) if name == \"Fred\" => println(s\"$name says, Yubba dubba doo\")\n  case Person(name) if name == \"Bam Bam\" => println(s\"$name says, Bam bam!\")\n  case _ => println(\"Watch the Flintstones!\")\n\nspeak(Person(\"Fred\"))      // \"Fred says, Yubba dubba doo\"\nspeak(Person(\"Bam Bam\"))   // \"Bam Bam says, Bam bam!\"\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Case Classes for Immutable Data\nDESCRIPTION: Defines a case class 'Point' with immutable fields and showcases creating instances without 'new', comparing instances for equality based on value, and printing output for demonstration purposes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/basics.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Point(x: Int, y: Int)\nval point = Point(1, 2)\nval anotherPoint = Point(1, 2)\nval yetAnotherPoint = Point(2, 2)\nif (point == anotherPoint) {\n  println(s\"$point and $anotherPoint are the same.\")\n} else {\n  println(s\"$point and $anotherPoint are different.\")\n}\nif (point == yetAnotherPoint) {\n  println(s\"$point and $yetAnotherPoint are the same.\")\n} else {\n  println(s\"$point and $yetAnotherPoint are different.\")\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Numeric Data Types in Scala\nDESCRIPTION: Demonstrates how to declare variables with specific numeric data types including Byte, Int, Long, Short, Double, and Float.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-vars-data-types.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval b: Byte = 1\nval i: Int = 1\nval l: Long = 1\nval s: Short = 1\nval d: Double = 2.0\nval f: Float = 3.0\n```\n\n----------------------------------------\n\nTITLE: Defining Scala 2/3 Compatible Main Method Scala\nDESCRIPTION: Provides a method for defining a program entry point that works in both Scala 2 and Scala 3, replacing the deprecated Scala 2 `App` trait. It uses a standard `object` with an explicit `main(args: Array[String])` method. Argument parsing must be handled manually within this `main` method (e.g., accessing array elements and converting types). It calls a private helper method containing the core logic, similar to the `@main` structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-main-methods.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nobject happyBirthday {\n  private def happyBirthday(age: Int, name: String, others: String*) = {\n    // same as before\n    val suffix = (age % 100) match\n      case 11 | 12 | 13 => \"th\"\n      case _ => (age % 10) match\n        case 1 => \"st\"\n        case 2 => \"nd\"\n        case 3 => \"rd\"\n        case _ => \"th\"\n\n    val sb = StringBuilder(s\"Happy $age$suffix birthday, $name\")\n    for other <- others do sb.append(\" and \").append(other)\n    println(sb.toString)\n  }\n  def main(args: Array[String]): Unit =\n    happyBirthday(args(0).toInt, args(1), args.drop(2).toIndexedSeq:_*)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Public Methods in Scala Classes\nDESCRIPTION: Demonstrates that methods in Scala classes are public by default. The example shows a Dog class with a speak method that can be called from outside the class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nclass Dog {\n  def speak() = println(\"Woof\")\n}\n\nval d = new Dog\nd.speak()   // prints \"Woof\"\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Dog:\n  def speak() = println(\"Woof\")\n\nval d = new Dog\nd.speak()   // prints \"Woof\"\n```\n\n----------------------------------------\n\nTITLE: String Pattern Matching with Extractor Objects\nDESCRIPTION: Using extractor objects with string pattern matching to parse and transform structured text, extracting and converting parts to specific types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/pattern-matching.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nobject Age {\n  def unapply(s: String): Option[Int] = s.toIntOption\n}\n\nval input: String = \"Alice is 25 years old\"\n\nval (name, age) = input match {\n  case s\"$name is ${Age(age)} years old\" => (name, age)\n}\n// name: String = Alice\n// age: Int = 25\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Square Function in Scala Worksheet\nDESCRIPTION: Defines a simple function to compute the square of an integer and demonstrates its usage in a Scala Worksheet within IntelliJ. The snippet requires creating a Scala Worksheet and entering the code, which evaluates expressions in real time. Input is an integer argument to the square function, and output is the integer result of squaring the input. This approach facilitates interactive experimentation without needing a main or object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/getting-started/intellij-track/getting-started-with-scala-in-intellij.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef square(x: Int) = x * x\n\nsquare(2)\n```\n\n----------------------------------------\n\nTITLE: Defining a Singleton Object Extending a Class in Scala\nDESCRIPTION: Shows creating a singleton object in Scala using 'object' keyword extending a class D. This defines a single instance of the class D accessible globally as a module-like construct. Prerequisites include understanding Scala objects and their difference from classes. It facilitates global state or utility singletons.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/cheatsheets/index.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nobject O extends D { ... }\n```\n\n----------------------------------------\n\nTITLE: Extracting Values with Pattern Matching in Scala\nDESCRIPTION: This example demonstrates using an extractor in a pattern match with an arbitrary string value. If the string matches the expected format, the extractor will successfully extract the value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/extractor-objects.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval CustomerID(name2) = \"--asdfasdfasdf\"\n```\n\n----------------------------------------\n\nTITLE: Implementing a Singleton Logger in Scala\nDESCRIPTION: Demonstrates defining a 'Logger' singleton object within a 'logging' package in both Scala 2 and Scala 3. This object provides a static-like utility method 'info' for printing log messages, showcasing a common use case for singletons.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/singleton-objects.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\npackage logging\n\nobject Logger {\n  def info(message: String): Unit = println(s\"INFO: $message\")\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\npackage logging\n\nobject Logger:\n  def info(message: String): Unit = println(s\"INFO: $message\")\n```\n\n----------------------------------------\n\nTITLE: Using a Generic Stack with Int and Inheritance Types in Scala\nDESCRIPTION: This snippet demonstrates how to instantiate and use the generic Stack class in Scala with specific type parameters. The first example shows usage with Int type, pushing integers and popping them while preserving type safety. The second example illustrates subclassing with a Fruit superclass and subclasses Apple and Banana, showing that a Stack[Fruit] can hold instances of Apple and Banana. The snippet emphasizes Scala's invariant generic types, meaning Stack[Char] is not considered a subtype of Stack[Int]. Dependencies include the Stack class defined previously and proper subclass relationships.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/generic-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval stack = new Stack[Int]\nstack.push(1)\nstack.push(2)\nprintln(stack.pop)  // prints 2\nprintln(stack.pop)  // prints 1\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Fruit\nclass Apple extends Fruit\nclass Banana extends Fruit\n\nval stack = new Stack[Fruit]\nval apple = new Apple\nval banana = new Banana\n\nstack.push(apple)\nstack.push(banana)\n```\n\n----------------------------------------\n\nTITLE: Workaround for Binding Limitation using Helper Function in Scala\nDESCRIPTION: Demonstrates a common workaround for the restriction on binding variables in alternative patterns. Logic common to multiple patterns (`pickUp(name)`) is extracted into a local helper function `pickUp`, which is then called from separate `case` clauses.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/alternative-bind-variables.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef loop(cmd: Cmd): Unit =\n  def pickUp(item: String): Unit = // Code for picking up item\n    cmd match\n      case Command(Pick :: Up :: Item(name)) => pickUp(name)\n      case Command(Get :: Item(name)) => pickUp(name)\n```\n\n----------------------------------------\n\nTITLE: Using multi-line blocks with for-expressions in Scala 2\nDESCRIPTION: Shows how to use a block of code after the yield keyword in a for-expression to perform more complex transformations on collection elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval names = List(\"_olivia\", \"_walter\", \"_peter\")\n\nval capNames = for (name <- names) yield { \n  val nameWithoutUnderscore = name.drop(1)\n  val capName = nameWithoutUnderscore.capitalize\n  capName\n}\n\n// capNames: List[String] = List(Olivia, Walter, Peter)\n```\n\n----------------------------------------\n\nTITLE: Class and Companion Object with Private Method Access in Scala\nDESCRIPTION: Implementing a Circle class with a companion object that contains a private helper method for area calculation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.math._\n\nclass Circle(val radius: Double) {\n  def area: Double = Circle.calculateArea(radius)\n}\n\nobject Circle {\n  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)\n}\n\nval circle1 = new Circle(5.0)\ncircle1.area\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.math.*\n\nclass Circle(val radius: Double):\n  def area: Double = Circle.calculateArea(radius)\n\nobject Circle:\n  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)\n\nval circle1 = Circle(5.0)\ncircle1.area\n```\n\n----------------------------------------\n\nTITLE: Defining Traits, Classes, and Methods in Scala\nDESCRIPTION: This snippet demonstrates the definition of traits, classes, and methods in Scala, showcasing its support for object-oriented programming. It shows how to define interfaces with `trait`, implement them in `class`, and define methods, highlighting syntax differences between Scala 2 (using `{}`) and Scala 3 (using `: ` and indentation/`do`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-features.md#_snippet_4\n\nLANGUAGE: Scala 2\nCODE:\n```\ntrait Animal {\n  def speak(): Unit\n}\n\ntrait HasTail {\n  def wagTail(): Unit\n}\n\nclass Dog extends Animal with HasTail {\n  def speak(): Unit = println(\"Woof\")\n  def wagTail(): Unit = println(\"⎞⎜⎛  ⎞⎜⎛\")\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ntrait Animal:\n  def speak(): Unit\n\ntrait HasTail:\n  def wagTail(): Unit\n\nclass Dog extends Animal, HasTail:\n  def speak(): Unit = println(\"Woof\")\n  def wagTail(): Unit = println(\"⎞⎜⎛  ⎞⎜⎛\")\n```\n\n----------------------------------------\n\nTITLE: Evaluating Arithmetic Expression with Pattern Matching (Scala 2)\nDESCRIPTION: Defines the `eval` function that takes a `Tree` and an `Environment` (a function mapping strings to integers) and returns an `Int`. It uses pattern matching on the `Tree` to recursively evaluate `Sum` nodes, look up variable values in the environment for `Var` nodes, and return the constant value for `Const` nodes. Requires `import Tree._`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\nimport Tree._\n\ndef eval(t: Tree, ev: Environment): Int = t match {\n  case Sum(left, right) => eval(left, ev) + eval(right, ev)\n  case Var(n)    => ev(n)\n  case Const(v)  => v\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Symbolic Differentiation using Pattern Matching in Scala\nDESCRIPTION: Defines a `derive` function that computes the symbolic derivative of an expression `Tree` with respect to a variable `v`. Uses pattern matching, including a *guard* (`if (v == n)`) on a case to add a condition, and a *wildcard* pattern (`_`) to match any remaining cases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tutorials/scala-for-java-programmers.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\ndef derive(t: Tree, v: String): Tree = t match {\n  case Sum(l, r) => Sum(derive(l, v), derive(r, v))\n  case Var(n) if (v == n) => Const(1)\n  case _ => Const(0)\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Strict Equality in Scala 3\nDESCRIPTION: This snippet shows how to enable strict equality checks using the scala.language.strictEquality import, which prevents comparing objects unless explicitly allowed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/ca-multiversal-equality.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.language.strictEquality\n\nval rover = Dog(\"Rover\")\nval fido = Dog(\"Fido\")\nprintln(rover == fido)   // ошибка компиляции\n\n// сообщение об ошибке компиляции:\n// Values of types Dog and Dog cannot be compared with == or !=\n```\n\n----------------------------------------\n\nTITLE: Invariance in Scala generics with Container class\nDESCRIPTION: This snippet shows an invariant generic class 'Container', where the type parameter A is neither covariant nor contravariant. It highlights that Container[Cat] is not a subtype of Container[Animal], preventing unsafe conversions and maintaining type safety in mutable containers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/variances.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass Container[A](value: A) {\n  private var _value: A = value\n  def getValue: A = _value\n  def setValue(value: A): Unit = {\n    _value = value\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Scala Compiler Plugins and Version-Specific Flags\nDESCRIPTION: This section describes how to enable various Scala compiler plugins for Scala 2.13.x and 3.0.x. Plugins such as Scala.js, SemanticDB, and Kind-Projector are supported, with their respective command-line options for each version. These plugins extend the compiler's capabilities for interop, code analysis, and macro support.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/options-lookup.md#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n## Compiler Plugins\n\nSome useful Scala 2.13 compiler plugins are now shipped into the compiler.\nYou can enable and configure them with some new native options.\n\n### Scala.js\n\n| 2.13.x | 3.0.x |\n|-|-|\n| `-Xplugin:scalajs-compiler_<version>.jar` | `-scalajs` |\n| `-P:scalajs:genStaticForwardersForNonTopLevelObjects` | `-scalajs-genStaticForwardersForNonTopLevelObjects` |\n| `-P:scalajs:mapSourceURI`| `-scalajs-mapSourceURI`|\n\n### SemanticDB\n\n| 2.13.x | 3.0.x |\n|-|-|\n| `-Xplugin:semanticdb-scalac_<version>.jar`| `-Xsemanticdb` |\n| `-P:semanticdb:targetroot:<path>` | `-semanticdb-target:<path>` |\n\n### Kind-Projector\n\n| 2.13.x | 3.0.x |\n|-|-|\n| `-Xplugin:kind-projector_<version>.jar` | `-Ykind-projector` |\n```\n\n----------------------------------------\n\nTITLE: Exhaustive pattern matching with sealed trait 'Notification' (Scala 3)\nDESCRIPTION: Replicates the Scala 2 'showNotification' function in Scala 3 syntax, ensuring all 'Notification' subtypes are matched. The function constructs output strings indicating the notification details. The use of 'sealed trait' enforces compile-time checks for exhaustiveness. It highlights the same dependencies on 'case class' definitions and pattern matching syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/pattern-matching.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\ndef showNotification(notification: Notification): String =\n  notification match\n    case Email(sender, title, _) =>\n      s\"You got an email from $sender with title: $title\"\n    case SMS(number, message) =>\n      s\"You got an SMS from $number! Message: $message\"\n```\n\n----------------------------------------\n\nTITLE: Appending Elements to an Immutable Vector in Scala\nDESCRIPTION: Shows how to create new `Vector` instances by appending a single element (`:+`) or another collection (`++`) to an existing immutable `Vector`. The original `Vector` remains unchanged. This syntax works for both Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\nval a = Vector(1,2,3)         // Vector(1, 2, 3)\nval b = a :+ 4                // Vector(1, 2, 3, 4)\nval c = a ++ Vector(4, 5)     // Vector(1, 2, 3, 4, 5)\n```\n\n----------------------------------------\n\nTITLE: Implementing the Ord trait for comparison operations in Scala\nDESCRIPTION: Definition of an Ord trait that enables objects to be comparable, providing default implementations for less than or equal, greater than, and greater than or equal operations based on an abstract less than method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\ntrait Ord {\n  def < (that: Any): Boolean\n  def <=(that: Any): Boolean =  (this < that) || (this == that)\n  def > (that: Any): Boolean = !(this <= that)\n  def >=(that: Any): Boolean = !(this < that)\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait Ord:\n  def < (that: Any): Boolean\n  def <=(that: Any): Boolean =  (this < that) || (this == that)\n  def > (that: Any): Boolean = !(this <= that)\n  def >=(that: Any): Boolean = !(this < that)\n```\n\n----------------------------------------\n\nTITLE: Defining a Minimal Value Class in Scala\nDESCRIPTION: Demonstrates the basic syntax for defining a value class named `Wrapper` that extends `AnyVal` and has a single public `val` parameter `underlying` of type `Int`. This structure allows the compiler to potentially avoid runtime object allocation for `Wrapper` instances, using the underlying `Int` directly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Wrapper(val underlying: Int) extends AnyVal\n```\n\n----------------------------------------\n\nTITLE: Creating Instances of Classes in Scala 2 and Scala 3\nDESCRIPTION: Shows how to instantiate 'Person' objects using the constructor, with syntax differences between Scala 2 (using 'new') and Scala 3 (direct invocation).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-modeling.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 2\nval p = new Person(\"John\", \"Stephens\")\n\n// Scala 3\nval p = Person(\"John\", \"Stephens\")\n```\n\n----------------------------------------\n\nTITLE: 複数パラメーターを持つ関数の定義 - Scala\nDESCRIPTION: 2つの整数パラメーターを受け取り、それらを加算する無名関数を定義し呼び出す例です。関数の引数リストと呼び出し方の基本を示します。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval add = (x: Int, y: Int) => x + y\nprintln(add(1, 2)) // 3\n```\n\n----------------------------------------\n\nTITLE: Invalid Multi-line Type Ascription in Scala\nDESCRIPTION: Example of incorrectly formatted multi-line type ascription that is not valid in Scala syntax. This demonstrates what not to do when writing type ascriptions across multiple lines.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nanExpr:\n  aType\n```\n\n----------------------------------------\n\nTITLE: Combining onFailure and onSuccess Callbacks - Scala\nDESCRIPTION: Demonstrates registration of both onFailure and onSuccess callbacks on the same Future instance to handle both error and success outcomes. Relies on scala.concurrent.Future and assumes render and session exist. Input is a potentially failing asynchronous request for posts; output is rendered content or error message. onFailure only executes when failed, onSuccess only on success, and registration order does not indicate invocation order.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/futures-promises.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval f: Future[List[String]] = Future {\n  session.getRecentPosts\n}\n\nf onFailure {\n  case t => render(\"An error has occured: \" + t.getMessage)\n}\nf onSuccess {\n  case posts => for (post <- posts) render(post)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Polymorphic List Duplication Method in Scala 2\nDESCRIPTION: This snippet demonstrates how to create a polymorphic method that duplicates an element a specified number of times in a list. It shows both explicit type parameter specification and type inference usage.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/polymorphic-methods.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef listOfDuplicates[A](x: A, length: Int): List[A] = {\n  if (length < 1)\n    Nil\n  else\n    x :: listOfDuplicates(x, length - 1)\n}\nprintln(listOfDuplicates[Int](3, 4))  // List(3, 3, 3, 3)\nprintln(listOfDuplicates(\"La\", 8))  // List(La, La, La, La, La, La, La, La)\n```\n\n----------------------------------------\n\nTITLE: Using 'Showable' in Scala 2 to print a person's info\nDESCRIPTION: Creates a 'Person' instance and prints its string representation using the 'show' method from the 'Showable' type class. Demonstrates practical usage in Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-type-classes.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval person = Person(\"John\", \"Doe\")\nprintln(showablePerson.show(person))\n```\n\n----------------------------------------\n\nTITLE: map Operation in MapOps with mapFactory - Scala 2\nDESCRIPTION: This Scala 2 trait demonstrates how map operations are specialized for map collections, using a mapFactory that supports the from method with key-value pairs. The transformation function (f: ((K,V)) => (K2,V2)) supports transformation of both key and value, enabling highly flexible map transformation. The trait MapFactory abstracts creation of new map collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\ntrait MapOps[K, +V, +CC[_, _], +C]\n  extends IterableOps[(K, V), Iterable, C] {\n\n  def map[K2, V2](f: ((K, V)) => (K2, V2)): CC[K2, V2] =\n    mapFactory.from(new View.Map(this, f))\n\n  // Similar to iterableFactory, but for Map collection types\n  def mapFactory: MapFactory[CC]\n\n}\n\ntrait MapFactory[+CC[_, _]] {\n  def from[K, V](it: IterableOnce[(K, V)]): CC[K, V]\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Trait with Abstract and Concrete Members (Example 2) - Scala\nDESCRIPTION: Another example of a trait containing abstract and concrete members, illustrating how traits can encapsulate specific, modular functionalities or attributes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_28\n\nLANGUAGE: Scala 2\nCODE:\n```\ntrait HasTail {\n  def tailColor: String\n  def wagTail() = println(\"Tail is wagging\")\n  def stopTail() = println(\"Tail is stopped\")\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ntrait HasTail:\n  def tailColor: String\n  def wagTail() = println(\"Tail is wagging\")\n  def stopTail() = println(\"Tail is stopped\")\n```\n\n----------------------------------------\n\nTITLE: Trait with Concrete Implementation in Scala 3\nDESCRIPTION: This snippet provides the same functionality as the Scala 2 version but uses Scala 3 syntax. The trait Showable defines an abstract show method and a concrete showHtml method that returns the string result of show wrapped in paragraph HTML tags. It is self-contained and showcases how to mix implementation and abstraction in Scala 3 traits.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntrait Showable:\n  def show: String\n  def showHtml = \"<p>\" + show + \"</p>\"\n```\n\n----------------------------------------\n\nTITLE: Defining and Calling Functions with Default Parameters in Scala\nDESCRIPTION: This snippet defines a Scala function `log` with a default value for the parameter `level`. The function prints a log message prefixed by its level, which defaults to \"INFO\" if not provided. Callers can omit the `level` argument to use the default or supply a different log level. It requires basic Scala standard library support and string interpolation. Input includes message strings and optional log level strings; output is printed console messages. The snippet demonstrates overriding the default parameter with a provided argument.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/default-parameter-values.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef log(message: String, level: String = \"INFO\") = println(s\"$level: $message\")\n\nlog(\"System starting\")  // prints INFO: System starting\nlog(\"User not found\", \"WARNING\")  // prints WARNING: User not found\n```\n\n----------------------------------------\n\nTITLE: Defining a Class with Potential null Values in Scala\nDESCRIPTION: A class definition for Address that contains string fields where null values could be accidentally used for optional fields like street2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fp-functional-error-handling.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nclass Address(\n  var street1: String,\n  var street2: String,\n  var city: String,\n  var state: String,\n  var zip: String\n)\n```\n\n----------------------------------------\n\nTITLE: Mixing in Multiple Traits at Object Creation in Scala\nDESCRIPTION: Defines a Scala class DavidBanner and three traits Angry, Big, and Green, each with method(s) or code executed during trait initialization. Illustrates mixing in multiple traits dynamically during instance creation using the 'with' keyword. Demonstrates behavioral composition by combining several traits in a single object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\nclass DavidBanner\n\ntrait Angry:\n  def beAngry() =\n    println(\"You won\\u2019t like me ...\")\n\ntrait Big:\n  println(\"I\\u2019m big\")\n\ntrait Green:\n  println(\"I\\u2019m green\")\n\n// mix in the traits as DavidBanner\n// is created\nval hulk = new DavidBanner with Big with Angry with Green\n```\n\n----------------------------------------\n\nTITLE: Configuring sbt Dependencies for Scala 2/3 Cross-Versioning\nDESCRIPTION: Demonstrates how to configure library dependencies in an sbt build file (`build.sbt`) for cross-version compatibility between Scala 2.13 and Scala 3. It shows using a Scala 2.13 library in Scala 3 (`CrossVersion.for3Use2_13`) and a Scala 3 library in Scala 2.13 (`CrossVersion.for2_13Use3`). This feature requires sbt version 1.5 or later.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tooling-tour.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// Use a Scala 2.13 library in Scala 3\nlibraryDependency += (\"org.foo\" %% \"foo\" % \"1.0.0\").cross(CrossVersion.for3Use2_13)\n\n// Use a Scala 3 library in Scala 2.13 \nlibraryDependency += (\"org.bar\" %% \"bar\" % \"1.0.0\").cross(CrossVersion.for2_13Use3)\n```\n\n----------------------------------------\n\nTITLE: Alternative map Method Syntax in Scala\nDESCRIPTION: Using a more verbose lambda expression with the map method, showing an alternative to the underscore syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/collections-methods.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nscala> val doubles = oneToTen.map(i => i * 2)\ndoubles: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)\n```\n\n----------------------------------------\n\nTITLE: Implementing Specific Printers for Animal and Cat in Scala\nDESCRIPTION: This snippet defines two Printer subclasses: AnimalPrinter and CatPrinter, specializing in printing Animal and Cat types respectively. The example demonstrates how Printer can be contravariant in A, allowing an AnimalPrinter to be used where a Printer[Cat] is expected.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/variances.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass AnimalPrinter extends Printer[Animal] {\n  def print(animal: Animal): Unit =\n    println(\"The animal's name is: \" + animal.name)\n}\n\nclass CatPrinter extends Printer[Cat] {\n  def print(cat: Cat): Unit =\n    println(\"The cat's name is: \" + cat.name)\n}\n```\n\n----------------------------------------\n\nTITLE: Using Views to Concatenate Transformations and Conversion to Strict Collection (Scala 2 and 3)\nDESCRIPTION: This snippet demonstrates how to chain multiple transformations lazily using views, then materialize the result into a strict collection such as Vector, thus avoiding intermediate data structures. It shows creating a view, applying multiple map operations, and converting back to a strict collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/views.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval w = v.view.map(_ + 1).map(_ * 2).to(Vector)\n```\n\n----------------------------------------\n\nTITLE: Using Triple Quotes with 's' Interpolation for Quotes in Scala\nDESCRIPTION: Shows how to embed double quotes within an `s` interpolated string by using triple quotes (`\"\"\"...\"\"\"`) for the string literal itself, avoiding the need to escape the inner quotes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/string-interpolation.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nprintln(s\"\"\"{\"name\":\"James\"}\"\"\")     // `{\"name\":\"James\"}`\n```\n\n----------------------------------------\n\nTITLE: Tracing Implicit Resolution Expansion Steps (Scala)\nDESCRIPTION: Illustrates the sequence of type expansions that occur during the implicit resolution process for `Foo[A]`. This trace shows how the types involved become structurally more complex within the context of the same implicit definition (`fooGen`), leading to divergence detection under the older rules.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\n               Foo[A]\n\n                 V\n\n       Foo[(B, (Int, Unit))]\n\n                 V\n\n               Foo[B]\n\n                 V\n\n  Foo[(C, (Int, (Boolean, Unit)))]\n\n                 V\n\n               Foo[C]\n\n                 V\n\nFoo[(Int, (String, (Boolean, Unit)))]\n```\n\n----------------------------------------\n\nTITLE: Passing Indented Blocks as Arguments to Operators in Scala\nDESCRIPTION: This snippet shows passing an indented block to an infix operator '`++`' in Scala using the fewerBraces syntax. A 'file' variable is defined and a conditional logic chooses which 'Credentials' are returned, illustrating that blocks can be used as arguments. The code depends on a valid definition of 'Path', 'Credentials', and assumes use of Scala 3 with fewerBraces enabled.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ncredentials `++`:\n  val file = Path.userHome / \".credentials\"\n  if file.exists\n  then Seq(Credentials(file))\n  else Seq()\n```\n\n----------------------------------------\n\nTITLE: Compiling Scala Source Code Using scalac Command\nDESCRIPTION: Shows the terminal command to compile the Scala source file Hello.scala using scalac. This generates JVM bytecode files (Hello.class and Hello$.class) compatible with Java Virtual Machine execution. It assumes Scala compiler (scalac) is installed and accessible via the command line.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/hello-world-1.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n$ scalac Hello.scala\n```\n\n----------------------------------------\n\nTITLE: Creating an Instance with None for Optional Field in Scala 3\nDESCRIPTION: An example showing how to create an Address instance with None for the optional street2 field in Scala 3, using the more concise syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fp-functional-error-handling.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval santa = Address(\n  \"1 Main Street\",\n  None,           // 'street2' не имеет значения\n  \"North Pole\",\n  \"Alaska\",\n  \"99705\"\n)\n```\n\n----------------------------------------\n\nTITLE: Starting the Scala 2 REPL (Bash)\nDESCRIPTION: Shows the command (`scala`) used to launch the Scala 2 REPL from the operating system's command line. Includes the typical welcome message and prompt displayed upon successful startup.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-repl.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ scala\nWelcome to Scala {{site.scala-version}} (OpenJDK 64-Bit Server VM, Java 1.8.0_342).\nType in expressions for evaluation. Or try :help.\n\nscala> _\n```\n\n----------------------------------------\n\nTITLE: Defining a Method with an Implicit Parameter Using Multiple Parameter Lists in Scala\nDESCRIPTION: This snippet provides a method definition that requires an implicit parameter via currying. The method takes an explicit Int and an implicit ExecutionContext, supporting asynchronous or concurrent execution patterns in Scala. Requires ExecutionContext to be available in implicit scope. Inputs are the argument and implicit context; output is unspecified (as indicated by ???). Demonstrates use case for multi-parameter lists with implicits.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/multiple-parameter-lists.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ndef execute(arg: Int)(implicit ec: ExecutionContext) = ???\n```\n\n----------------------------------------\n\nTITLE: Creating RNA1 Instances in Scala REPL\nDESCRIPTION: Demonstrates creating `RNA1` instances using the factory methods `RNA1.fromSeq` (from an existing `List`) and `RNA1.apply` (variadic arguments) within the Scala REPL.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-collections.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nscala> val xs = List(A, G, U, A)\nxs: List[Product with Serializable with Base] = List(A, G, U, A)\n\nscala> RNA1.fromSeq(xs)\nres1: RNA1 = RNA1(A, G, U, A)\n\nscala> val rna1 = RNA1(A, U, G, G, C)\nrna1: RNA1 = RNA1(A, U, G, G, C)\n```\n\n----------------------------------------\n\nTITLE: Creating and Connecting Nodes within a Single Graph Instance in Scala\nDESCRIPTION: Illustrates creating an instance of the `Graph` class, adding nodes using the `newNode` method, and connecting nodes within the same graph instance. It explicitly shows the type of the nodes as `graph1.Node`, emphasizing that the node type is dependent on the specific `graph1` instance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/inner-classes.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval graph1: Graph = new Graph\nval node1: graph1.Node = graph1.newNode\nval node2: graph1.Node = graph1.newNode\nval node3: graph1.Node = graph1.newNode\nnode1.connectTo(node2)\nnode3.connectTo(node1)\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Main Method Printing \"Hello, world\" - Scala\nDESCRIPTION: This Scala source code snippet defines a main method using Scala 3's @main annotation. The main method named 'helloWorld' prints the string \"Hello, world\" to the standard output when run. It serves as a minimal runnable example for building and running with sbt.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n@main def helloWorld = println(\"Hello, world\")\n```\n\n----------------------------------------\n\nTITLE: Working with Option Type in Scala\nDESCRIPTION: Explains how to use Option types in Scala, including creation, transformation with map/flatMap, composition using for-comprehensions, and various utility methods for handling optional values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/cheatsheets/index.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nSome(42)\n```\n\nLANGUAGE: scala\nCODE:\n```\nNone\n```\n\nLANGUAGE: scala\nCODE:\n```\nOption(null) == None\nOption(obj.unsafeMethod)\n```\n\nLANGUAGE: scala\nCODE:\n```\nSome(null) != None\n```\n\nLANGUAGE: scala\nCODE:\n```\nval optStr: Option[String] = None\n```\n\nLANGUAGE: scala\nCODE:\n```\nval optStr = Option.empty[String]\n```\n\nLANGUAGE: scala\nCODE:\n```\nval name: Option[String] =\n  request.getParameter(\"name\")\nval upper = name.map {\n  _.trim\n} filter {\n  _.length != 0\n} map {\n  _.toUpperCase\n}\nprintln(upper.getOrElse(\"\"))\n```\n\nLANGUAGE: scala\nCODE:\n```\nval upper = for {\n  name <- request.getParameter(\"name\")\n  trimmed <- Some(name.trim)\n    if trimmed.length != 0\n  upper <- Some(trimmed.toUpperCase)\n} yield upper\nprintln(upper.getOrElse(\"\"))\n```\n\nLANGUAGE: scala\nCODE:\n```\noption.map(f(_))\n```\n\nLANGUAGE: scala\nCODE:\n```\noption match {\n  case Some(x) => Some(f(x))\n  case None    => None\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\noption.flatMap(f(_))\n```\n\nLANGUAGE: scala\nCODE:\n```\noption match {\n  case Some(x) => f(x)\n  case None    => None\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\noptionOfOption.flatten\n```\n\nLANGUAGE: scala\nCODE:\n```\noptionOfOption match {\n  case Some(Some(x)) => Some(x)\n  case _             => None\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\noption.foreach(f(_))\n```\n\nLANGUAGE: scala\nCODE:\n```\noption match {\n  case Some(x) => f(x)\n  case None    => ()\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\noption.fold(y)(f(_))\n```\n\nLANGUAGE: scala\nCODE:\n```\noption match {\n  case Some(x) => f(x)\n  case None    => y\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\noption.collect {\n  case x => ...\n```\n\n----------------------------------------\n\nTITLE: Implicit conversion from Array to WrappedArray in Scala 2.8\nDESCRIPTION: This snippet demonstrates how Scala 2.8 uses implicit conversions to wrap arrays in a WrappedArray, allowing compatibility with Seq methods like 'toArray' and 'eq'. It illustrates the conversion process between native arrays and sequence representations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/arrays.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval seq: Seq[Int] = a1\nseq: Seq[Int] = WrappedArray(1, 2, 3)\nval a4: Array[Int] = seq.toArray\na4: Array[Int] = Array(1, 2, 3)\na1 eq a4\nres1: Boolean = true\n```\n\n----------------------------------------\n\nTITLE: Создание многострочных строк в Scala\nDESCRIPTION: Иллюстрирует, как создавать многострочные строки с использованием тройных двойных кавычек (`\"\"\"`). Пробелы и переводы строк внутри кавычек сохраняются.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-vars-data-types.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nval quote = \"\"\"The essence of Scala:\n               Fusion of functional and object-oriented\n               programming in a typed setting.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Concatenating Lists in Python\nDESCRIPTION: Illustrates concatenation of two Python lists 'a' and 'b' using the '+' operator, producing a new list that combines elements of both.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nc = a + b\n```\n\n----------------------------------------\n\nTITLE: Accessing Java Annotation Class and Enum References via Scala Reflection (Scala and Java)\nDESCRIPTION: Illustrates interoperability between Scala and Java annotations using reflection. The Java snippet defines an enum and an annotation with class and enum references. The Scala snippet accesses these annotation arguments via scala.reflect.runtime.universe, extracting Constant values from LiteralArgument AST nodes. It shows how to retrieve Type and Symbol values from annotation arguments and obtain corresponding runtime classes and enum values using RuntimeMirror. This snippet depends on scala.reflect and the Java annotation and enum are prerequisites.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/reflection/annotations-names-scopes.md#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\nenum JavaSimpleEnumeration { FOO, BAR }\n\nimport java.lang.annotation.*;\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE})\npublic @interface JavaSimpleAnnotation {\n  Class<?> classRef();\n  JavaSimpleEnumeration enumRef();\n}\n\n@JavaSimpleAnnotation(\n  classRef = JavaAnnottee.class,\n  enumRef = JavaSimpleEnumeration.BAR\n)\npublic class JavaAnnottee {}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\nimport scala.reflect.runtime.{currentMirror => cm}\n\nobject Test extends App {\n  val jann = typeOf[JavaAnnottee].typeSymbol.annotations(0).javaArgs\n\n  def jarg(name: String) = jann(TermName(name)) match {\n    case LiteralArgument(ct: Constant) => value\n    case _ => sys.error(\"Not a constant\")\n  }\n\n  val classRef = jarg(\"classRef\").value.asInstanceOf[Type]\n  println(showRaw(classRef))         // TypeRef(ThisType(), JavaAnnottee, List())\n  println(cm.runtimeClass(classRef)) // class JavaAnnottee\n\n  val enumRef = jarg(\"enumRef\").value.asInstanceOf[Symbol]\n  println(enumRef)                   // value BAR\n\n  val siblings = enumRef.owner.typeSignature.decls\n  val enumValues = siblings.filter(sym => sym.isVal && sym.isPublic)\n  println(enumValues)                // Scope {\n                                   //   final val FOO: JavaSimpleEnumeration;\n                                   //   final val BAR: JavaSimpleEnumeration\n                                   // }\n\n  val enumClass = cm.runtimeClass(enumRef.owner.asClass)\n  val enumValue = enumClass.getDeclaredField(enumRef.name.toString).get(null)\n  println(enumValue)                 // BAR\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Enumeration with Custom Methods in Scala\nDESCRIPTION: Demonstrates defining a Scala 3 enumeration (`Planet`) with parameters (`mass`, `radius`) and custom methods (`surfaceGravity`, `surfaceWeight`) defined within the enum body, applicable to all cases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-adts-gadts.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nenum Planet(mass: Double, radius: Double):\n\n  private final val G = 6.67300E-11\n  def surfaceGravity = G * mass / (radius * radius)\n  def surfaceWeight(otherMass: Double) =  otherMass * surfaceGravity\n\n  case Mercury extends Planet(3.303e+23, 2.4397e6)\n  case Venus   extends Planet(4.869e+24, 6.0518e6)\n  case Earth   extends Planet(5.976e+24, 6.37814e6)\n  // 5 or 6 more planets ...\n```\n\n----------------------------------------\n\nTITLE: Defining Page Layout and Element Styles (CSS)\nDESCRIPTION: Provides CSS rules for styling various elements within the page, including overall layout (html, body, container, bottom), scrolling menu appearance, typography (h1, h2, h3, small, p.under), list styles (ul, li with custom list-style-image), a special 'box' style with gradients and shadows, table presentation, and table of contents navigation styling.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/cheatsheet-header.txt#_snippet_4\n\nLANGUAGE: CSS\nCODE:\n```\nhtml, body {\n   padding-top: 0px;\n   height: 100%;\n  -webkit-box-shadow: inset 0 10px 50px rgba(0,0,0,.6);\n     -moz-box-shadow: inset 0 10px 50px rgba(0,0,0,.6);\n/*          box-shadow: inset 0 10px 30px rgba(0,0,0,.3);*/\n}\n.scrollingmenu {\n  width: 940px;\n  margin-left: auto;\n  margin-right: auto;\n  height: 70px;\n  zoom: 1;\n}\n.scrollingmenu h1 {\n  padding-bottom: 30px;\n  color: #ffffff;\n  font-size: 42px;\n  line-height: 1;\n  text-shadow: 0 1px 2px rgba(0,0,0,.5);\n}\n.container {\n min-height: 100%;\n}\n.bottom {\n min-height: 100%;\n background-color: #ffffff;\n padding-top: 20px;\n}\n.bottom h1,h2,h3 {\n\ttext-shadow: 0 1px 2px rgba(255,255,255,.5);\n}\n.bottom h1,h2,h3 a {\n            color: #404040;\n\ttext-shadow: 0 1px 2px rgba(255,255,255,.5);\n}\n\n.bottom small {\n            color: #808080;\n\ttext-shadow: 0 1px 1px rgba(255,255,255,.5);\n}\n\n.bottom p.under {\n            color: #808080;\n\ttext-shadow: 0 1px 1px rgba(255,255,255,.5);\n\tfont-size: 18px;\n\tline-height: 36px;\n\tmargin-top: -25px;\n}\n\n    .bottom ul {\n            margin: -4px 0 4px 25px;\n            list-style: square;\n    }\n\n    .bottom ul li {\n            color: #404040;\n            font-size: 18px;\n            line-height: 24px;\n            margin: 0px;\n     }\n\n   .bottom ul li.tour-of-scala {\n            font-size: 16px;\n            line-height: 22px;\n     }\n\n    .bottom ul li p {\n            color: #404040;\n            text-shadow: 0 1px 0 rgba(255, 255,255,.5);\n            font-size: 18px;\n            line-height: 24px;\n            margin: 0px;\n     }\n\n    .bottom ul li a {\n            color: #404040;\n        \ttext-shadow: 0 1px 0 rgba(255, 255,255,.5);\n     }\n\n    .bottom ul li a:hover {\n            color: #00408C;\n     }\n\n    .bottom ul li ul li {\n            font-size: 14px;\n            line-height: 18px;\n\t        text-shadow: 0 1px 0 rgba(255, 255,255,.5);\n     }\n\n    .bottom ul li ul li a {\n            color: #606060;\n     }\n\n    .bottom ul li ul li ul {\n            margin-top: 3px;\n     }\n\n    .bottom ul li ul li ul li {\n            font-size: 12px;\n            line-height: 16px;\n\t        text-shadow: 0 1px 0 rgba(255, 255,255,.5);\n     }\n\n    .bottom ul li ul li ul li a {\n            color: #707070;\n     }\n\n    .box {\n            position:relative;\n            padding:7px 15px;\n            margin-bottom:18px;\n            color:#ffffff;\n            background-color:#b12c67;\n            background-repeat:repeat-x;background-image:-khtml-gradient(linear, left top, left bottom, from(#b12c67), to(#340a06));\n            background-image:-moz-linear-gradient(top, #b12c67, #eedc94);background-image:-ms-linear-gradient(top, #b12c67, #340a06);\n            background-image:-webkit-gradient(linear, left top, left bottom, color-stop(0%, #b12c67), color-stop(100%, #340a06));\n            background-image:-webkit-linear-gradient(top, #b12c67, #340a06);\n            background-image:-o-linear-gradient(top, #b12c67, #340a06);\n            background-image:linear-gradient(top, #b12c67, #340a06);\n            filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#b12c67', endColorstr='#eedc94', GradientType=0);\n            text-shadow:0 -1px 0 rgba(0, 0, 0, 0.25);\n            border-color:#340a06 #340a06 #340a06;\n            border-color:rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);\n            text-shadow:0 1px 0 rgba(0, 0, 0, 0.5);\n            border-width:1px;border-style:solid;-webkit-border-radius:4px;\n            -moz-border-radius:4px;border-radius:4px;-webkit-box-shadow:inset 0 1px 0 rgba(255, 255, 255, 0.25);\n            -moz-box-shadow:inset 0 1px 0 rgba(255, 255, 255, 0.25);\n            box-shadow:inset 0 1px 0 rgba(255, 255, 255, 0.25);\n\t    }\n\n\t    .box h2 {\n\t\t  padding-bottom: 8px;\n\t\t  color: #ffffff;\n\t\t  font-size: 36px;\n\t\t  line-height: 1;\n\t\t  text-shadow: 0 1px 2px rgba(0,0,0,.5);\n   \t    }\n\n\t    .box h3 {\n\t\t  padding-bottom: 8px;\n\t\t  color: #ffffff;\n\t\t  font-size: 24px;\n\t\t  line-height: 1;\n\t\t  text-shadow: 0 1px 2px rgba(0,0,0,.5);\n   \t    }\n\n    .box ul li {\n      list-style-image: url({{ site.baseurl }}/resources/images/check-mark.png);\n \t    }\n\n    .box ul li {\n      color: #cccccc;\n      font-weight: bold;\n      font-size: 26px;\n      line-height: 36px;\n      text-shadow: 0 1px 2px rgba(0,0,0,.5);\n      margin: 0 0 0 150px;\n    }\n\n    .box ul li a {\n      color: #cccccc;\n    }\n\n    .box ul li a:hover {\n      color: #aaaaaa;\n    }\n\n    .bottom table {\n      border-top: 0px;\n      border-left: 0px;\n      border-right: 0px;\n    }\n\n    .bottom table thead {\n      border: 0px;\n    }\n\n    .bottom table tbody {\n      border: 0px;\n    }\n\n    .bottom table th, .bottom table td {\n      padding: 0 0 0 20px;\n      line-height: 20px;\n      border-left: 0px;\n    }\n\n    .page-header-index{margin-bottom:17px;border-bottom:1px solid #808080;-webkit-box-shadow:0 1px 0 rgba(255, 255, 255, 0.5);-moz-box-shadow:0 1px 0 rgba(255, 255, 255, 0.5);box-shadow:0 1px 0 rgba(255, 255, 255, 0.5);}\n\n   p.contents {\n       margin-left: 15px;\n       font-weight: bold;\n       font-size: 16px;\n   }\n\n   div#toc ul {\n       list-style: none;\n       padding-bottom: 20px;\n   }\n\n   div#toc ul a {\n       display: block;\n       list-style: none;\n       line-height: 22px;\n       font-size: 14px;\n       color: #0069D6;\n       font-weight: bold;\n       width: 100%;\n   }\n\n  div#toc ul li ul {\n       list-style: disc;\n  }\n\n  div#toc ul li ul a {\n       line-height: 18px;\n       font-weight: normal;\n  }\n\n  div#toc ul li ul li ul {\n       list-style: square;\n  }\n   div#toc ul li ul li ul a {\n   }\n\n   div#scroller-anchor {\n       width: inherit;\n   }\n\n   div#scroller {\n       width: inherit;\n   }\n\n   div#scroller h6 {\n       padding-left: 14px;\n   }\n\n   p#about {\n  \t margin-top: -8px;\n     padding-left: 14px;\n   }\n\n   input, textarea, select, .uneditable-input {\n\t       width: 165px;\n\t   }\n\n\t.bottom p.under {\n            color: #808080;\n\t\ttext-shadow: 0 1px 1px rgba(255,255,255,.5);\n\t\tfont-size: 18px;\n\t\tline-height: 36px;\n\t\tmargin-top: -25px;\n\t}\n\n\n```\n\n----------------------------------------\n\nTITLE: Configuring sbt Build and Debugging Options for Scala Compiler Development - sbt\nDESCRIPTION: Provides recommended sbt build settings to enhance developer workflow when hacking the Scala compiler. These settings include disabling documentation publishing to speed builds, dynamically setting version suffixes based on git commit hash, enabling detailed test logs for partest runs, and toggling incremental compilation style to reduce excessive recompilation. It also shows how to enable remote debugging via JVM options within the sbt shell to facilitate IDE integration with debugging sessions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/hacker-guide.md#_snippet_1\n\nLANGUAGE: sbt\nCODE:\n```\n// skip docs for local publishing\npublishArtifact in (Compile, packageDoc) in ThisBuild := false\n// set version based on current sha, so that you can easily consume this build from another sbt project\nbaseVersionSuffix := s\"local-${Process(\"tools/get-scala-commit-sha\").lines.head.substring(0, 7)}\"\n// show more logging during a partest run\ntestOptions in IntegrationTest in LocalProject(\"test\") ++= Seq(Tests.Argument(\"--show-log\"), Tests.Argument(\"--show-diff\"))\n// if incremental compilation is compiling too much (should be fine under sbt 0.13.13)\n// antStyle := true\n```\n\nLANGUAGE: sbt\nCODE:\n```\n> set javaOptions in compiler := List(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8002\")\n> scalac test.scala\n[info] Running scala.tools.nsc.Main -usejavacp test.scala\nListening for transport dt_socket at address: 8002\n```\n\n----------------------------------------\n\nTITLE: Trampoline Method Pattern for Context Bounds\nDESCRIPTION: Definition of a companion object with a helper method to access the unit value, providing a workaround for the inability to name context bounds in current Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n  trait Monoid[A] extends SemiGroup[A]:\n    def unit: A\n  object Monoid:\n    def unit[A](using m: Monoid[A]): A = m.unit\n  ...\n  def reduce[A : Monoid](xs: List[A]): A =\n    xs.foldLeft(Monoid.unit)(_ `combine` _)\n```\n\n----------------------------------------\n\nTITLE: Naming a Snippet for Inclusion (Markdown)\nDESCRIPTION: Illustrates the Markdown syntax ` ```scala sc-name:<snippet-name> ` used to assign a unique name to a code snippet. This name allows the snippet's code to be reused in other snippets later in the document.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/snippet-compiler.md#_snippet_10\n\nLANGUAGE: markdown\nCODE:\n```\n```scala sc-name:<snippet-name>\n```\n\n----------------------------------------\n\nTITLE: Определение теста с AnyFunSuite в Scala (Scala)\nDESCRIPTION: Пример классового теста в Scala с использованием ScalaTest и AnyFunSuite для тестирования функции cube в объекте CubeCalculator. Класс наследует AnyFunSuite, чтобы использовать метод test, в котором выполняется проверка результата вызова cube с параметром 3, ожидая значение 27. Зависимость: библиотека ScalaTest и импорт org.scalatest.funsuite.AnyFunSuite.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/getting-started/sbt-track/testing-scala-with-sbt-on-the-command-line.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport org.scalatest.funsuite.AnyFunSuite\n\nclass CubeCalculatorTest extends AnyFunSuite:\n    test(\"CubeCalculator.cube\") {\n        assert(CubeCalculator.cube(3) === 27)\n    }\n```\n\n----------------------------------------\n\nTITLE: 定义基本类型层次结构的Scala trait示例\nDESCRIPTION: 定义一组相关的trait来模拟商品(Item)、可购买项(Buyable)以及书籍(Book)，用于后续演示类型关系的基础类型定义。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-variance.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Item { def productNumber: String }\ntrait Buyable extends Item { def price: Int }\ntrait Book extends Buyable { def isbn: String }\n```\n\n----------------------------------------\n\nTITLE: Instantiating a Class Using Some for Optional Field (Scala)\nDESCRIPTION: Demonstrates creating an `Address` instance where the optional `street2` field (of type `Option[String]`) is set to `Some(\"Apt. 2B\")`, correctly and safely representing the presence of a value for the second street address line.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/no-null-values.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nval santa = new Address(\n    \"123 Main Street\",\n    Some(\"Apt. 2B\"),\n    \"Talkeetna\",\n    \"Alaska\",\n    \"99676\"\n)\n```\n\n----------------------------------------\n\nTITLE: Cross-Compatible Case Class Higher-Order Functions\nDESCRIPTION: Demonstrates a solution that works in both Scala 2 and 3 for accessing higher-order function methods on case class constructors by creating an intermediate function value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-other-changes.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval fooCtr: (Int, Boolean) => Foo = (x, b) => Foo(x, b)\n\nfooCtr.curried(1)(true)\nfooCtr.tupled((2, false))\n```\n\n----------------------------------------\n\nTITLE: Awaiting a Future result in Scala\nDESCRIPTION: Example of how to block and wait for a Future result using Await.result, which is not recommended but sometimes necessary for certain operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.concurrent._\nimport scala.concurrent.duration._\n\nobject awaitPurchase {\n  def main(args: Array[String]): Unit = {\n    val rateQuote = Future {\n      connection.getCurrentValue(USD)\n    }\n\n    val purchase = rateQuote map { quote =>\n      if (isProfitable(quote)) connection.buy(amount, quote)\n      else throw new Exception(\"not profitable\")\n    }\n\n    Await.result(purchase, 0.nanos)\n  }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.concurrent.*\nimport scala.concurrent.duration.*\n\n@main def awaitPurchase =\n  val rateQuote = Future {\n    connection.getCurrentValue(USD)\n  }\n\n  val purchase = rateQuote.map { quote =>\n    if isProfitable(quote) then connection.buy(amount, quote)\n    else throw Exception(\"not profitable\")\n  }\n\n  Await.result(purchase, 0.nanos)\n```\n\n----------------------------------------\n\nTITLE: Understanding the sbt Project Directory Structure\nDESCRIPTION: Illustrates the standard directory layout generated by sbt for a Scala project. Key directories include `.idea` for IntelliJ files, `project` for sbt plugins/settings, `src` for source code (separated into `main` and `test`), `target` for generated files, and `build.sbt` for the build definition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/getting-started/intellij-track/building-a-scala-project-with-intellij-and-sbt.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n- .idea (IntelliJ files)\n- project (plugins and additional settings for sbt)\n- src (source files)\n    - main (application code)\n        - java (Java source files)\n        - scala (Scala source files) <-- This is all we need for now\n        - scala-2.12 (Scala 2.12 specific files)\n    - test (unit tests)\n- target (generated files)\n- build.sbt (build definition file for sbt)\n```\n\n----------------------------------------\n\nTITLE: Callback-based Futures for Currency Trading in Scala 3\nDESCRIPTION: This snippet shows the same callback-based approach as above but using Scala 3 syntax with 'do' notation. It illustrates asynchronous purchase logic with nested 'for' expressions, serving as an example of callback chaining in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nval rateQuote = Future {\n  connection.getCurrentValue(USD)\n}\n\nfor quote <- rateQuote do\n  val purchase = Future {\n    if isProfitable(quote) then connection.buy(amount, quote)\n    else throw Exception(\"not profitable\")\n  }\n\n  for amount <- purchase do\n    println(\"Purchased \" + amount + \" USD\")\n```\n\n----------------------------------------\n\nTITLE: Generating Scaladoc using SBT command\nDESCRIPTION: Use the sbt 'doc' command to generate Scaladoc HTML documentation for a Scala project. The documentation will be created in the target/scala-[version]/api directory.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scaladoc/generate.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n> doc\n[info] Main Scala API documentation to target/scala-2.12/api...\n[info] model contains 1 documentable templates\n[info] Main Scala API documentation successful.\n[success] Total time: 20 s\n```\n\n----------------------------------------\n\nTITLE: Using a Covariant Producer Instance in Scala\nDESCRIPTION: Demonstrates passing a `Producer[Book]` (where `Book` is a subtype of `Buyable`) to the `makeTwo` function, which expects a `Producer[Buyable]`. This is type-safe due to the covariance of `Producer`. The `???` indicates an unimplemented instance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-variance.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval bookProducer: Producer[Book] = ???\nmakeTwo(bookProducer)\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Methods for Pizza with Implicit Class in Scala 2\nDESCRIPTION: Defines an implicit class PizzaOps to add methods such as price, addTopping, removeAllToppings, updateCrustSize, and updateCrustType to instances of the Pizza case class. The implicit class approach requires all dependencies, such as functions like pizzaPrice and types like CrustSize, CrustType, and Topping, to be in scope. Methods are invoked on Pizza instances when PizzaOps is imported, allowing behavior to be added externally without altering the original Pizza definition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-fp.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Pizza(\n  crustSize: CrustSize,\n  crustType: CrustType,\n  toppings: Seq[Topping]\n)\n\nimplicit class PizzaOps(p: Pizza) {\n  def price: Double =\n    pizzaPrice(p) // implementation from above\n\n  def addTopping(t: Topping): Pizza =\n    p.copy(toppings = p.toppings :+ t)\n\n  def removeAllToppings: Pizza =\n    p.copy(toppings = Seq.empty)\n\n  def updateCrustSize(cs: CrustSize): Pizza =\n    p.copy(crustSize = cs)\n\n  def updateCrustType(ct: CrustType): Pizza =\n    p.copy(crustType = ct)\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mutable Collection Pitfalls as HashMap Keys in Scala\nDESCRIPTION: This example shows the potential issues when using mutable collections as keys in a HashMap. When the contents of the mutable key (ArrayBuffer) are modified, its hash code changes, making it impossible to retrieve the value using the modified key.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/equality.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport collection.mutable.{HashMap, ArrayBuffer}\nval buf = ArrayBuffer(1, 2, 3)\nval map = HashMap(buf -> 3)\nmap(buf) // Returns 3\nbuf(0) += 1 // Modifies the buffer\nmap(buf) // Throws NoSuchElementException: key not found\n```\n\n----------------------------------------\n\nTITLE: Dynamic Member Access via selectDynamic (Scala Typing Rule Pseudocode)\nDESCRIPTION: This snippet shows the rewriting of an access to a member of a Dynamic type using the selectDynamic method. When v.a is attempted and v's type is Dynamic, it is redirected to v'.selectDynamic(\"a\"). This is used at the type system and compilation phase, not directly as API code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/minutes/2019-03-13-sip-minutes.md#_snippet_6\n\nLANGUAGE: scala (typing rules pseudocode)\nCODE:\n```\nG |- v.a : U ~> v'.selectDynamic(\"a\")\n```\n\n----------------------------------------\n\nTITLE: Importing readLine Method from scala.io.StdIn in Scala 2 and 3\nDESCRIPTION: Demonstrates how to import the 'readLine' method from the 'scala.io.StdIn' object for both Scala 2 and Scala 3. Importing this method allows reading user input from the command line conveniently. This import is necessary before using 'readLine' to capture text input. The snippet shows the minimal import statement required to access this functionality without importing the entire StdIn object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-hello-world.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.io.StdIn.readLine\n```\n\n----------------------------------------\n\nTITLE: Flexible Mixed-Style Annotation Usage in Scala\nDESCRIPTION: Example demonstrating Scala's more flexible syntax that allows mixing positional and named parameters when using Java annotations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/annotations.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\n@SourceURL(\"https://coders.com/\",\n           mail = \"support@coders.com\")\n    class MyScalaClass ...\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Scala Trait\nDESCRIPTION: Demonstrates how to define a simple trait 'HairColor' in Scala, which acts as an interface-like structure for sharing behavior or properties across classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/traits.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait HairColor\n```\n\n----------------------------------------\n\nTITLE: 初始化和使用 ListBuffer（Scala）\nDESCRIPTION: 代码演示如何创建一个空的ListBuffer，向其中添加元素，并将其转换为列表。ListBuffer内部采用链表实现，适合频繁插入操作后转为不可变列表。依赖Scala collection.mutable包。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/concrete-mutable-collection-classes.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval buf = scala.collection.mutable.ListBuffer.empty[Int]\nbuf += 1\nbuf += 10\nval list = buf.toList\n```\n\n----------------------------------------\n\nTITLE: Testing Weak Conformance Between Numeric Types\nDESCRIPTION: Shows how to use weak_<:< to check for weak conformance between numeric types, which follows Scala's numeric type hierarchy rules defined in the language specification.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nif (true) 1 else 1d // Results in Double due to weak conformance rules\n```\n\nLANGUAGE: scala\nCODE:\n```\ntypeOf[Int] weak_<:< typeOf[Double] // Returns true\ntypeOf[Double] weak_<:< typeOf[Int] // Returns false\n\ntypeOf[Int] <:< typeOf[Double] // Returns false\ntypeOf[Double] <:< typeOf[Int] // Returns false\n```\n\n----------------------------------------\n\nTITLE: Using Pattern Matching with Case Classes in Scala\nDESCRIPTION: Defines a function `getPrintableString` that takes a `Person` object and uses a `match` expression to differentiate between `Student` and `Teacher` instances. The pattern matching uses constructor patterns (`Student(name, year)`, `Teacher(name, whatTheyTeach)`) which rely on the case classes' automatic `unapply` methods to extract fields. Shows syntax for Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_44\n\nLANGUAGE: Scala 2\nCODE:\n```\ndef getPrintableString(p: Person): String = p match {\n  case Student(name, year) =>\n    s\"$name is a student in Year $year.\"\n  case Teacher(name, whatTheyTeach) =>\n    s\"$name teaches $whatTheyTeach.\"\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ndef getPrintableString(p: Person): String = p match\n  case Student(name, year) =>\n    s\"$name is a student in Year $year.\"\n  case Teacher(name, whatTheyTeach) =>\n    s\"$name teaches $whatTheyTeach.\"\n```\n\n----------------------------------------\n\nTITLE: Printing Hello, World! in Scala 2\nDESCRIPTION: Defines a singleton object named `hello` containing a main method which takes command-line arguments and prints \"Hello, World!\" to STDOUT. No external dependencies are required beyond the Scala standard library. The `main` method acts as the JVM application entry point. Input parameter `args` of type `Array[String]` is present but not used. This snippet demonstrates the traditional Scala 2 approach to creating executables.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-hello-world.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject hello {\n  def main(args: Array[String]) = {\n    println(\"Hello, World!\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Tuples in Lists in Scala\nDESCRIPTION: Shows how to use pattern matching with tuples in a list, targeting specific elements based on content.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/tuples.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval planetas =\n List((\"Mercúrio\", 57.9), (\"Vênus\", 108.2), (\"Terra\", 149.6),\n       (\"Marte\", 227.9), (\"Júpiter\", 778.3))\nplanetas.foreach{\n  case (\"Terra\", distancia) =>\n    println(s\"Nosso planeta está a $distancia milhões de quilômetros do sol\")\n  case _ =>\n}\n```\n\n----------------------------------------\n\nTITLE: Using Single-line if Statements in Java\nDESCRIPTION: Shows a single-line if statement in Java that executes a println when the condition is true. Minimal syntax including parentheses around condition and braces for the statement block.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_27\n\nLANGUAGE: java\nCODE:\n```\nif (x == 1) { System.out.println(1); }\n```\n\n----------------------------------------\n\nTITLE: Setting up Variables for For-Comprehension Example (Scala REPL)\nDESCRIPTION: Defines three string variables (`stringA`, `stringB`, `stringC`) in the Scala REPL, intended as inputs for the subsequent `for`/`yield` example demonstrating `Option` processing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/no-null-values.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval stringA = \"1\"\nval stringB = \"2\"\nval stringC = \"3\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Contravariance with Printers in Scala\nDESCRIPTION: This example presents an application object where a method printMyCat accepts a Printer of Cat and prints a Cat instance. Instances of CatPrinter and AnimalPrinter are both passed to the method, illustrating how contravariance allows substituting Printer[Animal] for Printer[Cat]. The outputs confirm correct behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/variances.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nobject ContravarianceTest extends App {\n  val myCat: Cat = Cat(\"Boots\")\n\n  def printMyCat(printer: Printer[Cat]): Unit = {\n    printer.print(myCat)\n  }\n\n  val catPrinter: Printer[Cat] = new CatPrinter\n  val animalPrinter: Printer[Animal] = new AnimalPrinter\n\n  printMyCat(catPrinter)\n  printMyCat(animalPrinter)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Extractor Object Matching quotes.reflect.Term in Scala Macros\nDESCRIPTION: Provides a pattern-matching extractor object with an implicit `Quotes` context for selectively matching on terms of type `quotes.reflect.Term`. This extractor returns an option of some value to aid in writing more expressive and concise pattern matches in macro definitions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/reflection.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nobject MyExtractor:\n  def unapply(using Quotes)(x: quotes.reflect.Term) =\n    ...\n    Some(y)\n```\n\n----------------------------------------\n\nTITLE: Initializing an Empty Immutable Queue in Scala\nDESCRIPTION: Demonstrates how to create an empty instance of `scala.collection.immutable.Queue` using its companion object's `apply` method. The resulting queue is specified to hold `Int` elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-immutable-collection-classes.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nscala> val empty = scala.collection.immutable.Queue[Int]()\nempty: scala.collection.immutable.Queue[Int] = Queue()\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Using a Scala Class\nDESCRIPTION: Demonstrates how to create an instance of the `Complex` class using `new` and call its methods (`c.im()`) within a `main` method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tutorials/scala-for-java-programmers.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nobject ComplexNumbers {\n  def main(args: Array[String]): Unit = {\n    val c = new Complex(1.2, 3.4)\n    println(\"imaginary part: \" + c.im())\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Immutability of val Constructor Parameters in Scala\nDESCRIPTION: Shows that constructor parameters marked with 'val' are immutable and cannot be reassigned after object construction. Attempts to assign a new value to such a parameter result in a compilation error. Highlights the difference between 'val', 'var', and plain parameters regarding mutability and visibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/classes.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass Point(val x: Int, val y: Int)\nval point = new Point(1, 2)\npoint.x = 3  // <-- nie kompiluje się\n```\n\n----------------------------------------\n\nTITLE: Defining a Value Class Wrapper in Scala\nDESCRIPTION: This snippet demonstrates how to define a Scala value class that wraps a primitive Double to represent a logarithmic value in a type-safe way, using the AnyVal parent to avoid allocations in some cases. It provides methods for conversion to Double and arithmetic, plus a companion object factory. This approach is limited by the situations when boxing can still occur, especially when used in collections, as discussed in the proposal.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/opaque-types.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\npackage object valueclass {\n  class Logarithm(val exponent: Double) extends AnyVal {\n    def toDouble: Double = math.exp(exponent)\n    def +(that: Logarithm): Logarithm = Logarithm(toDouble + that.toDouble)\n    def *(that: Logarithm): Logarithm = new Logarithm(exponent + that.exponent)\n  }\n\n  object Logarithm {\n    def apply(x: Double): Logarithm = new Logarithm(math.log(x))\n  }\n}\n\npackage object usesites {\n  // 1e7 is approximately (e ** 16.11809565095832),\n  // so x is encoded as 16.11809565095832.\n  val x: Logarithm = Logarithm(1e7)\n}\n```\n\n----------------------------------------\n\nTITLE: 定义结合数据参数的高阶函数 executeNTimes\nDESCRIPTION: 定义 `executeNTimes` 方法，接受一个无参数函数和一个整数，循环调用函数多次，示例测试输出。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-hofs.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef executeNTimes(f: () => Unit, n: Int): Unit =\n  for (i <- 1 to n) f()\n```\n\n----------------------------------------\n\nTITLE: Defining Arithmetic Expression ADT using Case Classes (Scala 2)\nDESCRIPTION: Defines the structure for arithmetic expressions using Scala 2 case classes within an abstract class `Tree`. `Sum` represents addition, `Var` represents a variable, and `Const` represents an integer constant. Case classes provide automatic getters, `equals`/`hashCode`, `toString`, and support pattern matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Tree\nobject Tree {\n  case class Sum(left: Tree, right: Tree) extends Tree\n  case class Var(n: String) extends Tree\n  case class Const(v: Int) extends Tree\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterless Methods for Property-like Access in Scala\nDESCRIPTION: Revises the `Complex` class to use parameterless methods (`def re = real`). This allows accessing the values like properties (e.g., `c.im`) without needing empty parentheses `()`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tutorials/scala-for-java-programmers.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nclass Complex(real: Double, imaginary: Double) {\n  def re = real\n  def im = imaginary\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing an Empty TreeSet with Default Ordering in Scala\nDESCRIPTION: Creates an empty immutable TreeSet[String] in Scala by specifying the element type without an explicit ordering. The TreeSet uses the default ordering for the String type for sorting elements upon insertion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/sets.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nTreeSet.empty[String]\n```\n\n----------------------------------------\n\nTITLE: Creating sbt Project Subdirectory - Bash Command\nDESCRIPTION: This bash command creates the 'project' directory under the main sbt project directory. The 'project' subdirectory will host build properties and plugin configuration files required by sbt during the build lifecycle.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ mkdir project\n```\n\n----------------------------------------\n\nTITLE: Unquoting Tree into q Quasiquote (Scala)\nDESCRIPTION: Demonstrates the `$` syntax within a `q` quasiquote to structurally substitute a pre-existing `universe.Tree` variable (`aquasiquote`) into the tree being constructed. This allows embedding captured syntax fragments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/intro.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val tree = q\"i am { $aquasiquote }\"\ntree: universe.Tree = i.am(a.quasiquote)\n```\n\n----------------------------------------\n\nTITLE: Defining abstract classes in Scala\nDESCRIPTION: Shows the syntax to define an abstract class which cannot be instantiated directly and typically declares abstract methods or members to be implemented by subclasses. Requires subclassing to create concrete implementations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class D { ... }\n```\n\n----------------------------------------\n\nTITLE: Marking an Intentionally Failing Snippet\nDESCRIPTION: This shows the markdown syntax for a Scala code block that is expected to fail compilation. The `sc:fail` flag instructs the snippet compiler to verify that this code indeed produces a compile-time error. This is used to document cases where code should not compile.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/snippet-compiler.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n```scala sc:fail\nList(1,2,3).toMap\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Named Methods with Parameters and Return Types in Scala - Scala\nDESCRIPTION: Shows declaring named methods using def keyword, specifying parameter lists and return types explicitly. Methods behave like functions, accepting multiple parameter lists, optionally none, and returning computed results. The body can be a single expression or multiple lines wrapped in braces.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/tour/basics.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ndef add(x: Int, y: Int): Int = x + y\nprintln(add(1, 2)) // 3\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef addThenMultiply(x: Int, y: Int)(multiplier: Int): Int = (x + y) * multiplier\nprintln(addThenMultiply(1, 2)(3)) // 9\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef name: String = System.getProperty(\"user.name\")\nprintln(\"Hello, \" + name + \"!\")\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef getSquareString(input: Double): String = {\n  val square = input * input\n  square.toString\n}\nprintln(getSquareString(2.5)) // 6.25\n```\n\n----------------------------------------\n\nTITLE: Performing Lazy Transformation on a Scala Vector by Using Views - Scala\nDESCRIPTION: Demonstrates creating a lazy view of a Vector using `.view` which returns a SeqView. The `.map` transformations are then applied lazily on the view without generating intermediate collections, and finally `.force` is called to build a strict collection. This avoids intermediate data structures and improves efficiency, illustrating the benefit of views for delayed computation in collection transformations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/views.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n(v.view map (_ + 1) map (_ * 2)).force\n```\n\n----------------------------------------\n\nTITLE: Deconstructing a Basic Method Definition in Scala\nDESCRIPTION: Demonstrates using Scala quasiquotes (`q\"...\"`) to pattern match on a simple method definition AST (`def f = 1`). This extracts the method's modifiers, name, type parameters, value parameter lists, return type (inferred as `<?>` here), and body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/definition-details.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"$mods def $name[..$tparams](...$paramss): $tpt = $body\" = q\"def f = 1\"\nmods: universe.Modifiers = Modifiers(, , Map())\nname: universe.TermName = f\ntparams: List[universe.TypeDef] = List()\nparamss: List[List[universe.ValDef]] = List()\ntpt: universe.Tree = <type ?>\nbody: universe.Tree = 1\n```\n\n----------------------------------------\n\nTITLE: Detailed Scala Compiler Private Settings for Versions 2.13.x and 3.0.x\nDESCRIPTION: This section lists various private scaffold options available for Scala compiler versions 2.13.x and 3.0.x. Each setting is accompanied by its status indicated by check or times icons, detailing whether the feature is enabled, disabled, or deprecated for each version. These flags control internal compiler behaviors such as macro expansion, class loader caching, and debugging.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/options-lookup.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## Private settings\n\n| 2.13.x | 3.0.x |\n|-|-|\n| `-Ybackend-parallelism` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ybackend-worker-queue` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ybreak-cycles` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ycache-macro-class-loader` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ycache-plugin-class-loader` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ycheck` |<i class=\"fa fa-check fa-lg\"></i>|\n| `-Ycompact-trees` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ydelambdafy` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ydump-classes` |<i class=\"fa fa-check fa-lg\"></i>|\n| `-Ygen-asmp` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Yimports` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Yissue-debug` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Yjar-compression-level` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-YjarFactory` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ymacro-annotations` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ymacro-classpath` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ymacro-expand` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ymacro-global-fresh-names` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Yno-completion` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Yno-flat-classpath-cache` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Yno-generic-signatures` |<i class=\"fa fa-check fa-lg\"></i>|\n| `-Yno-imports` |<i class=\"fa fa-check fa-lg\"></i>|\n| `-Yno-predef` |<i class=\"fa fa-check fa-lg\"></i>|\n| `-Yopt-inline-heuristics` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ypatmat-exhaust-depth` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ypresentation-any-thread` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ypresentation-debug` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ypresentation-delay` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ypresentation-locate-source-file` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ypresentation-log` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ypresentation-replay` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ypresentation-strict` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ypresentation-verbose` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Yprint-trees` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Yprofile-destination` |<i class=\"fa fa-check fa-lg\"></i>|\n| `-Yprofile-enabled` |<i class=\"fa fa-check fa-lg\"></i>|\n| `-Yprofile-external-tool` |<i class=\"fa fa-check fa-lg\"></i>|\n| `-Yprofile-run-gc` |<i class=\"fa fa-check fa-lg\"></i>|\n| `-Yprofile-trace` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Yrangepos` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Yrecursion` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Yreify-copypaste` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Yrepl-class-based` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Yrepl-outdir` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Yrepl-use-magic-imports` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Yresolve-term-conflict` |<i class=\"fa fa-check fa-lg\"></i>|\n| `-Yscala3-implicit-resolution` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Yscriptrunner` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Yskip` |<i class=\"fa fa-check fa-lg\"></i>|\n| `-Ystop-after` |<i class=\"fa fa-check fa-lg\"></i>|\n| `-Ystop-before` |<i class=\"fa fa-check fa-lg\"></i>|\n| `-Ytasty-no-annotations` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ytasty-reader` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Ytrack-dependencies` | <i class=\"fa fa-times fa-lg\"></i> |\n| `-Yvalidate-pos` | <i class=\"fa fa-times fa-lg\"></i> |\n```\n\n----------------------------------------\n\nTITLE: 实现TraversableLike的通用操作(Scala)\nDESCRIPTION: TraversableLike trait实现了大部分集合操作，如filter方法。它通过两个类型参数实现结果类型保持一致的原则，其中Elem表示元素类型，Repr表示集合类型。所有具体集合类只需实现newBuilder和foreach方法即可获得所有通用操作的实现。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/architecture-of-scala-collections.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\npackage scala.collection\n\nclass TraversableLike[+Elem, +Repr] {\n  def newBuilder: Builder[Elem, Repr] // deferred\n  def foreach[U](f: Elem => U) // deferred\n          ...\n  def filter(p: Elem => Boolean): Repr = {\n    val b = newBuilder\n    foreach { elem => if (p(elem)) b += elem }\n    b.result\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Scala 3 Nightly Version in Script Directive (Scala)\nDESCRIPTION: This directive can be placed in a Scala script to indicate that it should use the latest Scala 3 nightly version. Compatible tools such as scala-cli recognize this directive. No external configuration is required beyond tool support for '//>' directives.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/nightlies.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n//> using scala 3.nightly\n```\n\n----------------------------------------\n\nTITLE: Running Specific Tests with Partest from sbt Console - Shell\nDESCRIPTION: Executes only specified tests using Partest from the sbt shell. List one or more Scala test file paths to target specific test cases. Requires sbt in the Scala project folder and paths to valid test files.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/partest-guide.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nsbt:root> partest test/files/pos/bounds.scala test/scaladoc/run/diagrams-base.scala\n```\n\n----------------------------------------\n\nTITLE: Using the `f` Interpolator for Formatted Output in Scala\nDESCRIPTION: Introduces the `f` string interpolator in Scala for creating formatted strings, similar to `printf`. Variables are followed by format specifiers (e.g., `%s` for string, `%2.2f` for a double formatted to two decimal places) to control their output representation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval height = 1.9d\nval name = \"James\"\nprintln(f\"$name%s is $height%2.2f meters tall\")  // \"James is 1.90 meters tall\"\n```\n\n----------------------------------------\n\nTITLE: Defining Speaker Trait Scala\nDESCRIPTION: Defines a simple Scala trait named `Speaker` that specifies one abstract method, `speak`. This method takes no parameters and returns a String, representing the ability to produce sound.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/traits-interfaces.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Speaker {\n    def speak(): String\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Enum Values in Scala\nDESCRIPTION: Shows the Scala equivalent of comparing two different enum members (`Color.Red` and `Color.Blue`) for equality, which also evaluates to `false`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_73\n\nLANGUAGE: Scala\nCODE:\n```\nColor.Red == Color.Blue  // false\n```\n\n----------------------------------------\n\nTITLE: Interactive Hello World Application in Scala 3 Using @main and readLine\nDESCRIPTION: This Scala 3 snippet provides an interactive console program that prompts for and reads a user name, then prints a greeting. It uses the `@main` annotation on the `helloInteractive` method as the program entry point. The method calls `println` to prompt the user, reads a line from standard input using `readLine()`, stores it in `name`, and concatenates it into a greeting string. It requires importing `readLine` from `scala.io.StdIn` and runs on the Scala 3 compiler runtime.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-hello-world.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.io.StdIn.readLine\n\n@main def helloInteractive() =\n  println(\"Please enter your name:\")\n  val name = readLine()\n\n  println(\"Hello, \" + name + \"!\")\n```\n\n----------------------------------------\n\nTITLE: Benchmarking sequential map with Scala mutable HashMap\nDESCRIPTION: Defines a Scala benchmark object `MapSeq` to measure the performance of a sequential map operation on a mutable HashMap collection. It initializes the map with key-value pairs from 0 to length-1 using JVM property for size. The `run` method invokes a map transformation returning key-value pairs unchanged. This snippet serves as a baseline for the parallel Map benchmark and depends on Scala's mutable HashMap. Input is collection length; output is the mapped collection. Shows conventional sequential mapping over mutable hash maps for performance comparison.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/parallel-collections/performance.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nobject MapSeq extends testing.Benchmark {\n  val length = sys.props(\"length\").toInt\n  val hm = collection.mutable.HashMap((0 until length) zip (0 until length): _*)\n\n  def run = {\n    hm map {\n      kv => kv\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmarking map operation on ParTrieMap using Scala\nDESCRIPTION: Demonstrates a microbenchmark for measuring the performance of a map operation on a concurrent ParTrieMap in Scala. The snippet defines an object extending scala.testing.Benchmark, parses system properties for collection size and parallelism level, initializes a ParTrieMap with key-value pairs, sets up a ForkJoin task support to control parallelism, and defines the run method which performs the map operation to be timed. Dependencies include Scala's parallel collections library, the scala.testing.Benchmark trait for benchmarking infrastructure, and java concurrent forkjoin pool. Inputs are the 'length' and 'par' parameters controlling the size and concurrency, passed as system properties. The output is the execution time statistics recorded by the benchmark framework. This example illustrates JVM performance testing with awareness of JIT warm-up and GC effects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/overviews/parallel-collections/performance.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport collection.parallel.mutable.ParTrieMap\nimport collection.parallel.ForkJoinTaskSupport\n\nobject Map extends testing.Benchmark {\n  val length = sys.props(\"length\").toInt\n  val par = sys.props(\"par\").toInt\n  val partrie = ParTrieMap((0 until length) zip (0 until length): _*)\n\n  partrie.tasksupport = new ForkJoinTaskSupport(new scala.concurrent.forkjoin.ForkJoinPool(par))\n\n  def run = {\n    partrie map {\n      kv => kv\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating sets in Python and Scala\nDESCRIPTION: Demonstrates creating set collections that store unique elements. Python set syntax uses curly braces with comma-separated elements. Scala uses Set constructor. Both support sets with automatic elimination of duplicate elements. Shows basic example of constructing sets containing strings or integers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_59\n\nLANGUAGE: python\nCODE:\n```\nset = {\"a\", \"b\", \"c\"}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval set = Set(1,2,3)\n```\n\n----------------------------------------\n\nTITLE: Composing Futures with map Combinator in Scala\nDESCRIPTION: Refactors the nested callback example using the Future.map combinator to create more readable and linear asynchronous code. This snippet creates a Future for exchange rate and maps it to a Future representing the purchase decision. It depends on the same currency connection API and the isProfitable predicate. Inputs and outputs are the initial rate and the result of the purchase attempt. Advantages include exception propagation and better scoping compared to nested callbacks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/futures-promises.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval rateQuote = Future {\n  connection.getCurrentValue(USD)\n}\n\nval purchase = rateQuote map {\n  quote => if (isProfitable(quote)) connection.buy(amount, quote)\n           else throw new Exception(\"not profitable\")\n}\n\npurchase onSuccess {\n  case _ => println(\"Purchased \" + amount + \" USD\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Class Definition with Modifiers in Scala Reflection\nDESCRIPTION: This snippet demonstrates constructing a ClassDef node representing a class declaration with an empty flag set (NoFlags), giving it the type name 'C', and using Nil for other parameters. Requires importing scala.reflect.runtime.universe and knowledge of how AST nodes (ClassDef, Modifiers, TypeName) are built. No actual body or parents are specified; only the signature structure is shown.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/annotations-names-scopes.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nClassDef(Modifiers(NoFlags), TypeName(\"C\"), Nil, ...)\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Named Tuples in Scala 3\nDESCRIPTION: Demonstrates the flexibility of pattern matching named tuples. Patterns may use named bindings or unnamed bindings and can mention a subset or all names in any order. This facilitates expressive and readable decomposition of named tuples without requiring all elements to be specified.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-tuples.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nBob match\n  case (name, age) => ...\n\nBob match\n  case (name = x, age = y) => ...\n\nBob match\n  case (age = x) => ...\n\nBob match\n  case (age = x, name = y) => ...\n```\n\n----------------------------------------\n\nTITLE: Defining Hierarchy of Notification Classes Using Case Classes in Scala\nDESCRIPTION: Defines an abstract class 'Notification' and three concrete case classes 'Email', 'SMS', and 'VoiceRecording' extending it. Set up for easy instantiation, pattern matching, and comparison of notification types, illustrating Scala's concise syntax and automatic method generation for case classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/case-classes.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Notification\ncase class Email(sourceEmail: String, title: String, body: String) extends Notification\ncase class SMS(sourceNumber: String, message: String) extends Notification\ncase class VoiceRecording(contactName: String, link: String) extends Notification\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Migration Warnings in Scala REPL\nDESCRIPTION: This snippet shows a Scala REPL session demonstrating how to enable and view deprecation and migration warnings using the `-deprecation` and `-Xmigration` flags. It illustrates warnings for using the deprecated `List.unzip` static method and the changed behavior of `Map.keys` in Scala 2.8 collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/migrating-from-scala-27.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n>scala -deprecation -Xmigration\n```\n\nLANGUAGE: text\nCODE:\n```\nWelcome to Scala version 2.8.0.final\nType in expressions to have them evaluated.\nType :help for more information.\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> val xs = List((1, 2), (3, 4))\nxs: List[(Int, Int)] = List((1,2), (3,4))\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> List.unzip(xs)\n<console>:7: warning: method unzip in object List is deprecated: use xs.unzip instead of List.unzip(xs)\n       List.unzip(xs)\n            ^\nres0: (List[Int], List[Int]) = (List(1, 3),List(2, 4))\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> xs.unzip\nres1: (List[Int], List[Int]) = (List(1, 3),List(2, 4))\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> val m = xs.toMap\nm: scala.collection.immutable.Map[Int,Int] = Map((1,2), (3,4))\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> m.keys\n<console>:8: warning: method keys in trait MapLike has changed semantics:\nAs of 2.8, keys returns Iterable[A] rather than Iterator[A].\n       m.keys\n         ^\nres2: Iterable[Int] = Set(1, 3)\n```\n\n----------------------------------------\n\nTITLE: Using Implicit Integer to Long Conversion in Scala\nDESCRIPTION: Example of an implicit conversion from Int to Long where a method expects a Long parameter but receives an Int. The compiler automatically inserts Int.int2long(x) conversion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/implicit-conversions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// Implicit conversion example\nInt.int2long(x)\n```\n\n----------------------------------------\n\nTITLE: Scala 2 和 Scala 3中不变的泛型类型示例\nDESCRIPTION: 定义一个不变的泛型trait Pipeline，其类型参数T用于参数和返回值，反映默认的不变性语义。演示了在类型参数不变情况下类型协作的限制。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-variance.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Pipeline[T] {\n  def process(t: T): T\n}\n```\n\n----------------------------------------\n\nTITLE: Adding scalafmt Plugin for Code Formatting - Scala\nDESCRIPTION: Adds the 'sbt-scalafmt' plugin to project/plugins.sbt, enabling automatic Scala code formatting enforcement in sbt projects. Requires 'sbt' as a build tool. Input: plugin definition; Output: sbt builds with formatting tasks. Limitation: Only affects projects with plugin mechanism enabled.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\naddSbtPlugin(\"org.scalameta\" % \"sbt-scalafmt\" % \"2.4.2\")\n```\n\n----------------------------------------\n\nTITLE: 定义普通 trait Show 的 Scala 2 和 Scala 3 示例\nDESCRIPTION: 展示了无类型参数的普通 trait 定义，只包含一个无参方法用于返回字符串。与类型类相对，传统 trait 需由目标类型继承以获得此行为。示例用于对比类型类和普通 trait 的区别。此 trait 通常作为行为接口被继承实现。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/ca-type-classes.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n// a trait\ntrait Show {\n  def show: String\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// a trait\ntrait Show:\n  def show: String\n```\n\n----------------------------------------\n\nTITLE: Scala Class Definition with Default Parameters\nDESCRIPTION: A simple Point class definition with default parameter values for both x and y coordinates, which will be used to demonstrate Java interoperability limitations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/default-parameter-values.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n// Point.scala\nclass Point(val x: Double = 0, val y: Double = 0)\n```\n\n----------------------------------------\n\nTITLE: Nested for Loops with Multiple Generators in Java\nDESCRIPTION: Demonstrates triple nested for-loops iterating over ints1, chars, and ints2, printing formatted output with all three indices using nested syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_43\n\nLANGUAGE: java\nCODE:\n```\nfor (int i: ints1) {\n  for (int j: chars) {\n    for (int k: ints2) {\n      System.out.printf(\"i = %d, j = %d, k = %d\\n\", i,j,k);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using 'recover' to Handle Exceptions in Futures in Scala 2\nDESCRIPTION: This snippet demonstrates exception recovery using 'recover', ensuring that if a 'QuoteChangedException' occurs during the purchase, the future completes with zero instead of failing, thus providing fault tolerance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\nval purchase: Future[Int] = rateQuote.map {\n  quote => connection.buy(amount, quote)\n}.recover {\n  case QuoteChangedException() => 0\n}\n```\n\n----------------------------------------\n\nTITLE: Evaluating Conditionals with If/Else in Scala 2\nDESCRIPTION: Checks the sign of a value x and prints 'negative', 'zero', or 'positive' accordingly using if/else. No imports or dependencies required; x must be in scope and numeric. The statement takes x as input and performs side effects (printing) without producing a return value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nif (x < 0) {\n  println(\"negative\")\n} else if (x == 0) {\n  println(\"zero\")\n} else {\n  println(\"positive\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Doubling Elements in a List Using map and Anonymous Function in Scala REPL\nDESCRIPTION: Shows the result of using the map method with an anonymous function in the Scala REPL. Demonstrates both the command and its resulting value. Requires a predefined List[Int] named ints. Output: List[Int] with each value doubled.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/anonymous-functions.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nscala> val doubledInts = ints.map(_ * 2)\ndoubledInts: List[Int] = List(2, 4, 6)\n```\n\n----------------------------------------\n\nTITLE: Duplicating a Scala Iterator for Independent Traversals\nDESCRIPTION: This snippet shows how to duplicate a Scala iterator, creating two independent iterators from one. Each resulting iterator can traverse the underlying data separately, enabling multiple passes without re-creating the original iterator. Dependencies: Scala collections. Input: an iterator of strings. Output: two new iterators, one filtered to elements of length < 3 (shorts), another mapping to string lengths and summing. Limitation: the original iterator should be discarded; duplicated iterators are buffered and independent, but not suitable for infinite streams.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/iterators.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval (words, ns) = Iterator(\"a\", \"number\", \"of\", \"words\").duplicate\nval shorts = words.filter(_.length < 3).toList\nval count = ns.map(_.length).sum\n```\n\n----------------------------------------\n\nTITLE: Declaring Anonymous Functions in Scala - Scala\nDESCRIPTION: Shows syntax for defining anonymous (unnamed) functions using parameter lists and arrow notation. The example returns the input parameter incremented by one. This supports functional programming and first-class functions in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/tour/basics.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\n(x: Int) => x + 1\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Scala Main Object in IntelliJ\nDESCRIPTION: Demonstrates a simple Scala object named `Main` using the `@main` annotation for the entry point. The code defines a sequence of integers, finds the maximum value using `.max`, and prints the result using string interpolation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/getting-started/intellij-track/building-a-scala-project-with-intellij-and-sbt.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n@main def run() =\n  val ages = Seq(42, 75, 29, 64)\n  println(s\"The oldest person is ${ages.max}\")\n```\n\n----------------------------------------\n\nTITLE: 哈希表（HashMap）操作示例\nDESCRIPTION: 演示如何建立一个可变HashMap，添加键值对，查询元素，且提及其底层基于HashCode快速存取。示例显示哈希映射的基本用法，适合快速查找场景。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/concrete-mutable-collection-classes.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nval map = scala.collection.mutable.HashMap.empty[Int,String]\nmap += (1 -> \"make a web site\")\nmap += (3 -> \"profit!\")\nval value = map(1)\nval containsTwo = map.contains(2)\n```\n\n----------------------------------------\n\nTITLE: Handling unhandled exceptions during macro expansion in Scala\nDESCRIPTION: This snippet demonstrates that when a macro throws an unhandled exception, the Scala compiler catches it, displays a relevant stack trace, and reports an error without crashing. It showcases the behavior when an invalid input causes a macro to fail during expansion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/overview.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\n~/.Projects/Kepler/sandbox$ scala\nWelcome to Scala version 2.10.0-20120428-232041-e6d5d22d28 (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_25).\nType in expressions to have them evaluated.\nType :help for more information.\n\nscala> import Macros._\nimport Macros._\n\nscala> printf(\"hello %s!\")\n<console>:11: error: exception during macro expansion:\njava.util.NoSuchElementException: head of empty list\n at scala.collection.immutable.Nil$.head(List.scala:318)\n at scala.collection.immutable.Nil$.head(List.scala:315)\n at scala.collection.mutable.Stack.pop(Stack.scala:140)\n at Macros$$anonfun$1.apply(Macros.scala:49)\n at Macros$$anonfun$1.apply(Macros.scala:47)\n at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:237)\n at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:237)\n at scala.collection.IndexedSeqOptimized$class.foreach(IndexedSeqOptimized.scala:34)\n at scala.collection.mutable.ArrayOps.foreach(ArrayOps.scala:39)\n at scala.collection.TraversableLike$class.map(TraversableLike.scala:237)\n at scala.collection.mutable.ArrayOps.map(ArrayOps.scala:39)\n at Macros$.printf_impl(Macros.scala:47)\n\n       printf(\"hello %s!\")\n             ^\n```\n\n----------------------------------------\n\nTITLE: Adding Specific OS-Lib Version Using Scala CLI - Scala\nDESCRIPTION: This snippet shows how to add a specific version of the OS-Lib library to a Scala CLI project by including '//> using dep com.lihaoyi::os-lib:0.11.3' in the source file. This directive declares an explicit dependency, pulling exactly the desired version from a Maven repository. It requires Scala CLI and internet access to resolve the dependency; the library will be available to any code in that source set.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-os-lib.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n//> using dep com.lihaoyi::os-lib:0.11.3\n```\n\n----------------------------------------\n\nTITLE: Defining SemiGroup and Monoid Type Classes in Scala\nDESCRIPTION: Definition of SemiGroup and Monoid type classes with extension methods. SemiGroup provides a combine operation for elements, while Monoid extends SemiGroup with a unit element.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n  trait SemiGroup[A]:\n    extension (x: A) def combine(y: A): A\n\n  trait Monoid[A] extends SemiGroup[A]:\n    def unit: A\n```\n\n----------------------------------------\n\nTITLE: Using if-else Conditional Statements in Scala\nDESCRIPTION: Shows usage of if, else if, and else expressions in Scala using the 'then' syntax to evaluate a variable 'x'. Outputs descriptive messages to the console according to the sign of 'x', illustrating basic conditional control flow.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nif x < 0 then\n  println(\"negative\")\nelse if x == 0 then\n  println(\"zero\")\nelse\n  println(\"positive\")\n```\n\n----------------------------------------\n\nTITLE: Creating a method with a for-expression body in Scala 3\nDESCRIPTION: Demonstrates Scala 3's syntax for using a for-expression as a method body, showing how to filter values from a list based on conditions using guard clauses.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ndef between3and10(xs: List[Int]): List[Int] =\n  for\n    x <- xs\n    if x >= 3\n    if x <= 10\n  yield x\n\nbetween3and10(List(1, 3, 7, 11))   // : List[Int] = List(3, 7)\n```\n\n----------------------------------------\n\nTITLE: Incorrectly Skipping Empty Words Using Iterator in Scala\nDESCRIPTION: This snippet demonstrates an incorrect approach to skip empty strings in an Iterator by advancing the iterator with next() inside a while loop. The code erroneously skips the first non-empty string because next() moves the iterator forward before the check. It highlights the limitation of Iterator when lookahead is required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/iterators.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef skipEmptyWordsNOT(it: Iterator[String]) =\n  while (it.next().isEmpty) {}\n```\n\n----------------------------------------\n\nTITLE: Creating a Future with explicit ExecutionContext in Scala 2 and 3\nDESCRIPTION: Shows how to create a Future that performs a long-running computation, explicitly passing or implicitly using an ExecutionContext in Scala 2 and Scala 3. It demonstrates asynchronous computation delegation to an ExecutionContext, which manages thread execution.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval inverseFuture: Future[Matrix] = Future {\n    fatMatrix.inverse() // non-blocking long lasting computation\n}(executionContext)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit val ec: ExecutionContext = ...\nval inverseFuture : Future[Matrix] = Future {\n  fatMatrix.inverse()\n} // ec is implicitly passed\n```\n\nLANGUAGE: Scala\nCODE:\n```\ngiven ExecutionContext = ...\nval inverseFuture : Future[Matrix] = Future {\n  fatMatrix.inverse()\n} // execution context is implicitly passed\n```\n\n----------------------------------------\n\nTITLE: Using the Generic Reference Class to Store Integer Values in Scala 3\nDESCRIPTION: Demonstrates usage of the generic Reference class in Scala 3 by defining an @main method named IntegerReference. It creates a Reference[Int] instance, sets a value 13, and prints double the contained value without casting. This example illustrates idiomatic Scala 3 syntax for running a main program and shows type-safe usage of parameterized classes. It depends on the Reference class definition and handles integer input/output within the main method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\n@main def IntegerReference: Unit =\n  val cell = new Reference[Int]\n  cell.set(13)\n  println(\"Reference contains the half of \" + (cell.get * 2))\n```\n\n----------------------------------------\n\nTITLE: 不可变Scala容器转换成Java容器导致修改操作抛异常示例 - Scala\nDESCRIPTION: 示例说明将不可变Scala容器 List 转换成 java.util.List 后，尝试对Java容器进行修改操作会抛出 UnsupportedOperationException 的原因。因为Java容器不区分可变与不可变，所有对不可变容器底层的修改操作都会失败。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/conversions-between-java-and-scala-collections.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nscala> val jul = List(1, 2, 3).asJava\njul: java.util.List[Int] = [1, 2, 3]\n\nscala> jul.add(7)\njava.lang.UnsupportedOperationException\n  at java.util.AbstractList.add(AbstractList.java:148)\n```\n\n----------------------------------------\n\nTITLE: Creating BigInt and BigDecimal Instances Scala\nDESCRIPTION: Shows how to instantiate `BigInt` and `BigDecimal` objects using their respective constructors with large integer and decimal values. These types are used for numbers that exceed the range or precision of standard `Long` and `Double`. Note the variable `b` is reassigned or used in separate examples.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/built-in-types.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nvar b = BigInt(1234567890)\nvar b = BigDecimal(123456.789)\n```\n\n----------------------------------------\n\nTITLE: Using Named Arguments for Class Constructor Invocation in Scala\nDESCRIPTION: Illustrates how to use named arguments when instantiating a class (`Point`) with default parameter values. This allows specifying a value for a specific parameter (`y = 2`) without providing preceding ones, improving clarity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/classes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass Point(var x: Int = 0, var y: Int = 0)\nval point2 = new Point(y = 2)\nprintln(point2)               // prints (0, 2)\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Point(var x: Int = 0, var y: Int = 0)\nval point2 = Point(y = 2)\nprintln(point2)           // prints (0, 2)\n```\n\n----------------------------------------\n\nTITLE: Named Arguments with Method Overriding in Scala\nDESCRIPTION: Shows how named arguments work with method overriding. Parameter names can differ in the overriding method, but the static type determines which names must be used in the method call.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-and-default-arguments.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ntrait A           { def f(a: Int): Int }\nclass B extends A { def f(x: Int) = x }\nval a: A = new B\na.f(a = 1) // OK\n```\n\n----------------------------------------\n\nTITLE: Creating a Thread-Safe Map with SynchronizedMap in Scala\nDESCRIPTION: This example demonstrates how to create a thread-safe mutable map by mixing in the SynchronizedMap trait with HashMap. It also shows how to override the default method to provide custom behavior for undefined keys.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/maps.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable.{Map,\n    SynchronizedMap, HashMap}\nobject MapMaker {\n  def makeMap: Map[String, String] = {\n      new HashMap[String, String] with\n          SynchronizedMap[String, String] {\n        override def default(key: String) =\n          \"Why do you want to know?\"\n      }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Type Class (`Showable`) in Scala\nDESCRIPTION: Defines a basic generic type class `Showable[T]` with a single method `show`. It also defines a helper method `show` that takes an explicit value `x` of type `T` and implicitly requires an instance of `Showable[T]` to perform the showing operation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/implicits.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Showable[T] { def show(x: T): String }\ndef show[T](x: T)(implicit s: Showable[T]) = s.show(x)\n```\n\n----------------------------------------\n\nTITLE: Scala 2 and 3: Explicit Eta-Expansion Using Anonymous Function\nDESCRIPTION: Shows explicit eta-expansion by wrapping the method call in an anonymous function, e.g., `x => times10(x)`. This approach manually enforces method-to-function conversion when automatic eta-expansion isn't triggered.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-eta-expansion.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nList(1, 2, 3).map(x => times10(x)) // explicit eta-expansion\n```\n\n----------------------------------------\n\nTITLE: Incorrectly Skipping Leading Empty Strings with Standard Iterator in Scala\nDESCRIPTION: This snippet shows an incorrect approach to skipping leading empty strings from a standard `Iterator[String]`. The `while` loop correctly identifies empty strings, but calling `it.next()` inside the loop advances the iterator past *all* leading empty strings *and* the first non-empty string, which is often not the desired behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/iterators.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ndef skipEmptyWordsNOT(it: Iterator[String]) =\n  while (it.next().isEmpty) {}\n```\n\n----------------------------------------\n\nTITLE: Type Safety Error with `f` Interpolator in Scala 3\nDESCRIPTION: Shows a Scala 3 compiler error when an incorrect format specifier (`%d` for Int) is used with a variable of a different type (`Double`) in an `f`-interpolated string. This demonstrates the type safety feature of the `f` interpolator in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval height: Double = 1.9d\n\nscala> f\"$height%4d\"\n-- Error: ----------------------------------------------------------------------\n1 |f\"$height%4d\"\n  |   ^^^^^^\n  |   Found: (height : Double), Required: Int, Long, Byte, Short, BigInt\n1 error found\n\n```\n\n----------------------------------------\n\nTITLE: Using Graph with Inner Class Nodes in Scala\nDESCRIPTION: Example usage of the Graph class, demonstrating how to create a graph with multiple nodes and connect them. This snippet showcases the basic operations of the Graph implementation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/inner-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef graphTest: Unit = {\n  val g = new Graph\n  val n1 = g.newNode\n  val n2 = g.newNode\n  val n3 = g.newNode\n  n1.connectTo(n2)\n  n3.connectTo(n1)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating immutable maps in Java vs Scala\nDESCRIPTION: Compares the syntax for creating immutable maps in both languages. Scala uses the arrow operator (->) for key-value pairs, creating a more readable mapping syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_50\n\nLANGUAGE: Java\nCODE:\n```\nMap map = Map.of(\n  \"a\", 1, \n  \"b\", 2,\n  \"c\", 3\n);\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval map = Map(\n  \"a\" -> 1, \n  \"b\" -> 2, \n  \"c\" -> 3\n)\n```\n\n----------------------------------------\n\nTITLE: Scala 2 and 3: Defining traits and classes with syntax variations\nDESCRIPTION: Illustrates trait and class definitions in Scala 2 and Scala 3, emphasizing the cleaner, indentation-based syntax introduced in Scala 3 for enhanced readability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/scala-features.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ntrait Animal {\n  def speak(): Unit\n}\n\ntrait HasTail {\n  def wagTail(): Unit\n}\n\nclass Dog extends Animal with HasTail {\n  def speak(): Unit = println(\"Woof\")\n  def wagTail(): Unit = println(\"⎞⎜⎛  ⎞⎜⎛\")\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait Animal:\n  def speak(): Unit\n\ntrait HasTail:\n  def wagTail(): Unit\n\nclass Dog extends Animal, HasTail:\n  def speak(): Unit = println(\"Woof\")\n  def wagTail(): Unit = println(\"⎞⎜⎛  ⎞⎜⎛\")\n```\n\n----------------------------------------\n\nTITLE: Mapping with Anonymous Function Equivalent to Named Method in Scala\nDESCRIPTION: Shows that mapping with an anonymous function (_ * 2) is equivalent to mapping with a named method. No additional dependencies. Input: List[Int] ints. Output: doubled values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/anonymous-functions.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval doubledInts = ints.map(_ * 2)\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Function Variables of the Same Type in Scala\nDESCRIPTION: Defines another function variable `triple` similar to `double`, taking an Int and returning its triple, enabling function composition or storage as values of type Int => Int.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-function-variables.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval triple = (i: Int) => i * 3\n```\n\n----------------------------------------\n\nTITLE: Iterating Lists with For Loops in Scala 2\nDESCRIPTION: Loops over each element in the list ints and prints the value. No additional dependencies required; ints must be defined as a List of values. Outputs to the console for each item in ints.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval ints = List(1, 2, 3, 4, 5)\n\nfor (i <- ints) println(i)\n\n```\n\n----------------------------------------\n\nTITLE: 带参数的枚举类型定义(Scala 3)\nDESCRIPTION: 展示如何在Scala 3中定义带参数的枚举类型。这个例子定义了Nat(自然数)枚举，包含Zero和带有参数的Succ枚举值，用于表示自然数的递归定义。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-modeling.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nenum Nat:\n  case Zero\n  case Succ(pred: Nat)\n```\n\n----------------------------------------\n\nTITLE: Defining a Recursive Enumeration for Natural Numbers in Scala\nDESCRIPTION: Illustrates how to define a recursive data structure (unary representation of natural numbers) using Scala 3 `enum`. The `Succ` case refers back to the `Nat` enum type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-adts-gadts.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nenum Nat:\n  case Zero\n  case Succ(n: Nat)\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Elements Using a While-Loop in Scala\nDESCRIPTION: This snippet demonstrates a basic approach to sequentially accessing and printing each element of an iterator in Scala using a while-loop. The 'hasNext' method checks for available elements, and 'next' retrieves them in order. No additional dependencies are required, and the loop consumes the iterator as it prints each value. Inputs: a Scala Iterator instance. Output: prints elements to STDOUT; iterator is exhausted after the loop. Limitation: calling next after the loop will throw NoSuchElementException.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/iterators.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nwhile (it.hasNext)\n  println(it.next())\n```\n\n----------------------------------------\n\nTITLE: Declaring Strings and Characters in Scala\nDESCRIPTION: This snippet shows implicit creation of a String and a Char variable. String values are enclosed in double quotes and Char in single quotes. No special initialization is needed; supports basic use of text types in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/first-look-at-types.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval s = \"Bill\"\nval c = 'a'\n```\n\n----------------------------------------\n\nTITLE: Handling Scala Future completion with onComplete callback\nDESCRIPTION: Registers a callback with a Future using onComplete, handling both Success and Failure cases. This provides a way to process the result asynchronously once the computation completes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/concurrency.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nFuture(longRunningAlgorithm()).onComplete {\n  case Success(value) => println(s\"Got the callback, value = $value\")\n  case Failure(e) => e.printStackTrace\n}\n```\n\n----------------------------------------\n\nTITLE: Prepending Elements and Displaying Vector in Scala REPL - Scala\nDESCRIPTION: Provides an interactive Scala REPL session prepending elements to a Vector with +: and ++:, showing the results after each statement. Designed for users experimenting with Vector operations interactively. Inputs: prepending expressions in REPL; Outputs: printed new Vectors. Requires no special setup beyond Scala REPL.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/vector-class.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val b = 0 +: a\nb: Vector[Int] = Vector(0, 1, 2, 3)\n\nscala> val b = Vector(-1, 0) ++: a\nb: Vector[Int] = Vector(-1, 0, 1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Specifying function parameter type signature in a higher-order method in Scala\nDESCRIPTION: Illustrates the method parameter type signature for a function that takes no input parameters and returns Unit, shown as `() => Unit`. This pattern describes the expected function parameter shape when declaring higher-order methods, guiding how functions should be passed or defined.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-hofs.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n() => Unit\n```\n\n----------------------------------------\n\nTITLE: Executing Scala Pattern Matching on Case Class Instances\nDESCRIPTION: Shows the results of calling the 'getPrintableString' function with 'Student' and 'Teacher' instances in the Scala REPL. The output demonstrates how the pattern matching correctly identifies the type and extracts the fields of each case class instance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/case-classes.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nscala> getPrintableString(s)\nres0: String = Al is a student in Year 1.\n\nscala> getPrintableString(t)\nres1: String = Bob Donnan teaches Mathematics.\n```\n\n----------------------------------------\n\nTITLE: Writing Hello World Program in Scala 3 Using @main Annotation\nDESCRIPTION: Defines a main method 'hello' using Scala 3's `@main` annotation, which designates the method as an entry point for the program. The method takes no parameters and prints \"Hello, World!\" to standard output using `println`. This approach simplifies the boilerplate required compared to Scala 2 by removing the need for an explicit singleton object and main method signature. The snippet requires Scala 3 compiler and runtime. It demonstrates concise program initialization and invocation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-hello-world.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n@main def hello() = println(\"Hello, World!\")\n```\n\n----------------------------------------\n\nTITLE: Using Named Arguments in Scala Method Calls\nDESCRIPTION: This snippet demonstrates different ways to call a method with named arguments in Scala. It shows a basic method call with positional arguments, then two variants using named arguments in different orders, highlighting Scala's flexibility with parameter ordering when names are specified.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tour/named-arguments.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef printName(first: String, last: String): Unit = {\n  println(first + \" \" + last)\n}\n\nprintName(\"John\", \"Smith\")  // Prints \"John Smith\"\nprintName(first = \"John\", last = \"Smith\")  // Prints \"John Smith\"\nprintName(last = \"Smith\", first = \"John\")  // Prints \"John Smith\"\n```\n\n----------------------------------------\n\nTITLE: Inheritance and Overriding Methods in Scala\nDESCRIPTION: The snippet shows a `Complex` class overriding the `toString` method inherited from `Object`, with the `override` modifier required for safe overriding. It illustrates how inheritance allows customizing object representation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\n```scala\nclass Complex(real: Double, imaginary: Double) {\n  def re = real\n  def im = imaginary\n  override def toString() =\n    \"\" + re + (if (im >= 0) \"+\" else \"\") + im + \"i\"\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Launching a Scala Application with Coursier CLI - Scala\nDESCRIPTION: Illustrates how to use the Coursier command-line tool to launch a Scala application (scalafmt-cli) directly by resolving dependencies from coordinates. Requires Coursier CLI (cs) to be installed on the system. Arguments after `--` are passed to the launched application; here, `--help` displays usage information. Input: dependency coordinates and command-line arguments; Output: application help text or application execution.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\n$ cs launch org.scalameta::scalafmt-cli:2.4.2 -- --help\nscalafmt 2.4.2\nUsage: scalafmt [options] [<file>...]\n\n  -h, --help               prints this usage text\n  -v, --version            print version\n  more ...\n\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Generators and Guards in For Loops in Scala 2\nDESCRIPTION: Uses multiple generators for numbers and characters, plus two guards, to print a value only when i == 2 and j == 'b'. Prerequisites: no special libraries required. The output is only produced for this specific combination.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  i <- 1 to 3\n  j <- 'a' to 'c'\n  if i == 2\n  if j == 'b'\n} {\n  println(s\"i = $i, j = $j\")   // prints: \"i = 2, j = b\"\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Methods with Default Parameter Values in Scala\nDESCRIPTION: This snippet demonstrates how to define a log method with a default parameter value for the level argument. When the level parameter is omitted, it defaults to \"INFO\".\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/default-parameter-values.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef log(message: String, level: String = \"INFO\") = println(s\"$level: $message\")\n\nlog(\"System starting\")  // prints INFO: System starting\nlog(\"User not found\", \"WARNING\")  // prints WARNING: User not found\n```\n\n----------------------------------------\n\nTITLE: Importing Members in Scala\nDESCRIPTION: This snippet explains how to import specific members from other packages, using various import syntax such as wildcards, specific classes, or renaming imports with aliases. It highlights that Scala allows import statements anywhere in the code and can import from the root package using '_root_' prefix to resolve naming conflicts.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/packages-and-imports.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport users._  // 导入包 users 中的所有成员\nimport users.User  // 导入类 User\nimport users.{User, UserPreferences}  // 仅导入选择的成员\nimport users.{UserPreferences => UPrefs}  // 导入类并且设置别名\n```\n\n----------------------------------------\n\nTITLE: Initializing immutable Map in Scala\nDESCRIPTION: Defines an immutable Map with key-value pairs representing state abbreviations and their corresponding names. This snippet introduces the basic syntax for creating a Map using pairs within the Map constructor. No external dependencies besides the Scala standard library are required. Input is a hard-coded list of elements; output is a Map object containing those pairs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/map-class.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval states = Map(\n    \"AK\" -> \"Alaska\",\n    \"IL\" -> \"Illinois\",\n    \"KY\" -> \"Kentucky\"\n)\n```\n\n----------------------------------------\n\nTITLE: Type Casting in Scala\nDESCRIPTION: This snippet demonstrates type casting between numeric types and type conversion using methods like .toFloat. It shows that type conversions are one-directional and must be explicit. Additionally, it shows casting from a Char to Int, illustrating type conversion rules.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/unified-types.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval x: Long = 987654321\nval y: Float = x.toFloat  // 9.8765434E8 (注意：精度が落ちる可能性があります)\n\nval face: Char = '☺'\nval number: Int = face  // 9786\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval x: Long = 987654321\nval y: Float = x.toFloat  // 9.8765434E8\nval z: Long = y  // 不一致のためコンパイルエラーになります\n```\n\n----------------------------------------\n\nTITLE: Defining Covariant, Contravariant, and Invariant Classes in Scala\nDESCRIPTION: This snippet defines three generic Scala classes demonstrating the three variance annotations: covariance (+A), contravariance (-A), and invariance (A). These classes serve as a basis for explaining how Scala's type system handles variance in generic type parameters without methods or additional members.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/variances.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Foo[+A] // A covariant class\nclass Bar[-A] // A contravariant class\nclass Baz[A]  // An invariant class\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Reference Container Class in Scala\nDESCRIPTION: Defines a generic Scala class Reference that can contain a single element of any specified type T. It declares a private mutable variable 'contents' of type T initialized with the default value (underscore syntax). The class exposes methods 'set' and 'get' to mutate and access the contained value. This example demonstrates the use of Scala generics to achieve type-safe containers without requiring explicit casts, addressing limitations present before Java generics.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-tw/tutorials/scala-for-java-programmers.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass Reference[T] {\n  private var contents: T = _\n  def set(value: T) { contents = value }\n  def get: T = contents\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Build with Using Directives in Scala\nDESCRIPTION: Example of a Scala code file utilizing 'using directives' (`//> using ...`) within comments to specify build configuration directly in the source. This snippet configures the platform to 'native', adds the 'os-lib' dependency, and includes a compiler option ('-Xfatal-warnings'), making the code snippet self-contained and reproducible.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/scala-cli.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n//> using platform \"native\"\n//> using \"com.lihaoyi::os-lib:0.7.8\"\n//> using options \"-Xfatal-warnings\"\n\ndef foo = println(\"<here comes the buggy warning with Scala Native and os-lib>\")\n```\n\n----------------------------------------\n\nTITLE: Appending Elements to a Mutable Buffer in Scala\nDESCRIPTION: Demonstrates how to add single or multiple elements to the end or front of a mutable Buffer using methods such as append, appendAll, prepend, and prependAll. Requires importing scala.collection.mutable.Buffer or concrete implementations like ListBuffer or ArrayBuffer. Inputs include the buffer instance and elements to be added; outputs are the updated buffer with the new elements inserted. These operations do not return new buffer instances but mutate the existing object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/seqs.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nbuf.append(x)\nbuf += x\nbuf.appendAll(xs)\nbuf ++= xs\nbuf.prepend(x)\nx +=: buf\nbuf.prependAll(xs)\nxs ++=: buf\n```\n\n----------------------------------------\n\nTITLE: Mapping Elements in Scala Parallel Collections\nDESCRIPTION: Demonstrates how to convert a sequential list of strings into a parallel collection and then apply the map operation to convert each string element to its uppercase form. The snippet uses the `.par` method to convert the sequential List to a parallel collection (ParSeq), allowing parallel execution of the map transformation. Dependencies include the standard Scala collections library. The expected input is a List[String], and the output is a parallel immutable sequence (ParSeq[String]) with all strings uppercased. This illustrates the ease of using parallel collections transparently with collection operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/overviews/parallel-collections/overview.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval apellidos = List(\"Smith\",\"Jones\",\"Frankenstein\",\"Bach\",\"Jackson\",\"Rodin\").par\napellidos.map(_.toUpperCase)\n```\n\n----------------------------------------\n\nTITLE: Dropping Elements from Sequence in Scala\nDESCRIPTION: Explains `drop` and `dropWhile`. `drop(n)` returns a sequence excluding the first `n` elements, while `dropWhile(predicate)` returns a sequence excluding the longest prefix whose elements all satisfy the predicate.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/collections-methods.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nnums.drop(1)\nnums.drop(5)\nnames.drop(1)\nnames.drop(2)\n```\n\nLANGUAGE: scala\nCODE:\n```\nnums.dropWhile(_ < 5)\nnames.dropWhile(_ != \"chris\")\n```\n\n----------------------------------------\n\nTITLE: Accessing Tuple Elements by Position in Scala\nDESCRIPTION: Shows how to access elements of a tuple by position using the underscore notation (_1, _2, etc.), retrieving specific values from a tuple.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/tuples.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nprintln(ingredient._1) // Sugar\nprintln(ingredient._2) // 25\n```\n\n----------------------------------------\n\nTITLE: Defining OOP style classes with methods in Python and Scala\nDESCRIPTION: Shows defining mutable class-based objects with methods using Python classes and Scala classes with primary constructors. Dependencies are language standard environments. The constructor parameter initializes the name property. The class contains a speak method that outputs a greeting using the object's state.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\nclass Person(object):\n  def __init__(self, name):\n    self.name = name\n\n  def speak(self):\n    print(f'Hello, my name is {self.name}')\n```\n\n----------------------------------------\n\nTITLE: Using Pattern Matching with Custom Unapply in Scala\nDESCRIPTION: Demonstrates using pattern matching with an instance of the standard `Person` class which has a custom `unapply` method defined in its companion object. The `match` expression uses `Person(n, a)` as a pattern, which invokes the custom `unapply` to extract the name (`n`) and age (`a`). Includes a `null` case for completeness and shows the expected output. Shows syntax for Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_49\n\nLANGUAGE: Scala 2\nCODE:\n```\nval p = new Person(\"Astrid\", 33)\n\np match {\n  case Person(n,a) => println(s\"name: $n, age: $a\")\n  case null => println(\"No match\")\n}\n\n// that code prints: \"name: Astrid, age: 33\"\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nval p = Person(\"Astrid\", 33)\n\np match\n  case Person(n,a) => println(s\"name: $n, age: $a\")\n  case null => println(\"No match\")\n\n// that code prints: \"name: Astrid, age: 33\"\n```\n\n----------------------------------------\n\nTITLE: Processing Successful Future Results with foreach Callback in Scala\nDESCRIPTION: Illustrates using the `foreach` callback on a Scala `Future` as a convenient way to process only the successful result. The provided function is executed asynchronously only if the `Future` completes successfully, ignoring failures.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/futures.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval f: Future[List[String]] = Future {\n  session.getRecentPosts\n}\n\nf foreach { posts =>\n  for (post <- posts) println(post)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Scala List `map` Method Signature\nDESCRIPTION: Shows the Scaladoc definition of the `map` method on a `List`, indicating it accepts a function parameter `f` with the type `(A) => B`. This sets the context for requiring a function.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-eta-expansion.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef map[B](f: (A) => B): List[B]\n           ------------\n```\n\n----------------------------------------\n\nTITLE: Defining a Class and Companion Object with Indentation Syntax in Scala\nDESCRIPTION: This snippet demonstrates the use of Scala 3's proposed indentation syntax for defining a class and its companion object. Optional braces are omitted in favor of dedented blocks, and an `end` marker indicates the closure of the class and object definitions. No dependencies are required beyond Scala 3, and the snippet serves as a stylistic guide rather than a functional example. Expected usage is for simplifying code organization and improving readability in Scala projects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/minutes/2020-03-13-sip-minutes.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass Foo:\n\n  def foo = ???\n\nobject Foo:\n\n  def bar = ???\n\nend Foo\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Guards for Conditional Matching on Notifications (Scala 3)\nDESCRIPTION: Defines the function showImportantNotification using Scala 3 syntax, applying pattern matching with guards (if statements) to selectively identify emails or SMS messages from important contacts. Matching Email and SMS includes a guard checking if the sender or number is contained within a list of importantPeopleInfo. If the guard fails, the default case invokes showNotification to process the notification generally. This exemplifies conditional matching using guards combined with Scala 3’s new indentation-based syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/pattern-matching.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ndef showImportantNotification(notification: Notification, importantPeopleInfo: Seq[String]): String =\n  notification match\n    case Email(sender, _, _) if importantPeopleInfo.contains(sender) =>\n      \"You got an email from special someone!\"\n    case SMS(number, _) if importantPeopleInfo.contains(number) =>\n      \"You got an SMS from special someone!\"\n    case other =>\n      showNotification(other) // в этом варианте считается подходящими параметры любого типа. Значит этот вариант выполняется во всех случаях и передает исходный параметр в функцию showNotification\n\nval importantPeopleInfo = Seq(\"867-5309\", \"jenny@gmail.com\")\n\nval someSms = SMS(\"123-4567\", \"Are you there?\")\nval someVoiceRecording = VoiceRecording(\"Tom\", \"voicerecording.org/id/123\")\nval importantEmail = Email(\"jenny@gmail.com\", \"Drinks tonight?\", \"I'm free after 5!\")\nval importantSms = SMS(\"867-5309\", \"I'm here! Where are you?\")\n\nprintln(showImportantNotification(someSms, importantPeopleInfo)) // выводит \"You got an SMS from 123-4567! Message: Are you there?\"\nprintln(showImportantNotification(someVoiceRecording, importantPeopleInfo)) // выводит \"You received a Voice Recording from Tom! Click the link to hear it: voicerecording.org/id/123\"\nprintln(showImportantNotification(importantEmail, importantPeopleInfo)) // выводит \"You got an email from special someone!\"\n\nprintln(showImportantNotification(importantSms, importantPeopleInfo)) // выводит \"You got an SMS from special someone!\"\n```\n\n----------------------------------------\n\nTITLE: Deconstructing Method Parameters with Implicits in Scala\nDESCRIPTION: Shows a specific quasiquote pattern to deconstruct a method definition while separating regular parameter lists (`paramss`) from implicit parameter lists (`implparams`). This example extracts parameters from `def g(x: Int)(implicit y: Int) = x + y`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/definition-details.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"def g(...$paramss)(implicit ..$implparams) = $body\" =\n           q\"def g(x: Int)(implicit y: Int) = x + y\"\nparamss: List[List[universe.ValDef]] = List(List(val x: Int = _))\nimplparams: List[universe.ValDef] = List(implicit val y: Int = _)\nbody: universe.Tree = x.$plus(y)\n```\n\n----------------------------------------\n\nTITLE: Applying Sequence Methods on Scala Lists\nDESCRIPTION: Provides examples of fundamental Scala List operations including foreach to apply side-effecting functions, filter to select elements based on predicates, map to transform elements, and foldLeft to aggregate values. Demonstrations include iterating and printing names, filtering numbers less than 4, mapping to double values or capitalize strings, and calculating sums and products via foldLeft with initial seed values. These methods showcase functional programming paradigms for concise and expressive collection manipulation. Dependencies: Scala collections library. Inputs: Lists of Int or String; Outputs: transformed collections or aggregated results.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/prelude-taste-of-scala.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval nums = (1 to 10).toList\nval names = List(\"joel\", \"ed\", \"chris\", \"maurice\")\n\n// foreach example\nnames.foreach(println)\n\n// filter and foreach example\nnums.filter(_ < 4).foreach(println)\n\n// map examples\nval doubles = nums.map(_ * 2)\nval capNames = names.map(_.capitalize)\nval lessThanFive = nums.map(_ < 5)\n\n// foldLeft examples\nnums.foldLeft(0)(_ + _)\nnums.foldLeft(1)(_ * _)\n```\n\n----------------------------------------\n\nTITLE: Method Visibility Control in Classes\nDESCRIPTION: Demonstrates different visibility modifiers for methods in Scala classes, showing how to use public, private, and protected methods and their inheritance implications.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/methods-most.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\n// Scala 3\nclass Animal:\n  private def breathe() = println(\"I'm breathing\")\n  def walk() =\n    breathe()\n    println(\"I'm walking\")\n  protected def speak() = println(\"Hello?\")\n\nclass Cat extends Animal:\n  override def speak() = println(\"Meow\")\n\nval cat = new Cat\ncat.walk()\ncat.speak()\ncat.breathe()   // won't compile because it's private\n```\n\n----------------------------------------\n\nTITLE: Adding Scala 2 Nightly Resolver in sbt Build (sbt)\nDESCRIPTION: Add this resolver setting to your sbt build configuration to access Scala 2 nightly versions. Place this line in 'build.sbt' or other sbt configuration files. This step is required before specifying any nightly version for Scala 2 in your project.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/nightlies.md#_snippet_6\n\nLANGUAGE: sbt\nCODE:\n```\nGlobal / resolvers += \"scala-integration\" at\n  \"https://scala-ci.typesafe.com/artifactory/scala-integration/\"\n```\n\n----------------------------------------\n\nTITLE: Creating a Hello World application using App trait in Scala\nDESCRIPTION: A simplified version of Hello World that extends the App trait instead of defining a main method. The App trait provides its own main method implementation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/hello-world-2.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject Hello2 extends App {\n    println(\"Hello, world\")\n}\n```\n\n----------------------------------------\n\nTITLE: Deconstructing Try Expressions with Scala Quasiquotes\nDESCRIPTION: Illustrates deconstructing `Try` ASTs using the `q\"try $expr catch { case ..$cases } finally $finalizer\"` pattern. This extracts the main expression, a list of `CaseDef`s for the catch block (which can be empty), and the finalizer expression. An absent catch block results in an empty list for `$cases`. An absent `finally` clause results in `$finalizer` being bound to `EmptyTree` (`<empty>`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_45\n\nLANGUAGE: scala\nCODE:\n```\nscala> val q\"try $a catch { case ..$b } finally $c\" = q\"try t\"\na: universe.Tree = t\nb: List[universe.CaseDef] = List()\nc: universe.Tree = <empty>\n\nscala> val q\"try $a catch { case ..$b } finally $c\" = \n               q\"try t catch { case _: C => }\"\na: universe.Tree = t\nb: List[universe.CaseDef] = List(case (_: C) => ())\nc: universe.Tree = <empty>\n\nscala> val q\"try $a catch { case ..$b } finally $c\" = \n               q\"try t finally f\"\na: universe.Tree = t\nb: List[universe.CaseDef] = List()\nc: universe.Tree = f\n```\n\n----------------------------------------\n\nTITLE: Declaring a Case Class for Immutable Data Modeling in Scala 2 and 3\nDESCRIPTION: Defines an immutable case class `Person` with two fields: `name` and `relation`. The case class implicitly makes these fields public and immutable. This concise declaration supports pattern matching and immutability, foundational concepts for functional programming. No external dependencies besides Scala standard library.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_38\n\nLANGUAGE: scala\nCODE:\n```\ncase class Person(name: String, relation: String)\n```\n\n----------------------------------------\n\nTITLE: Full Macro Implementation of printf in Object Macros (Scala)\nDESCRIPTION: Defines an object `Macros` containing a macro method `printf` and its supporting macro implementation `printf_impl`. It imports necessary macro and collection libraries, processes the format string literal and parameters as ASTs, generates intermediate val definitions with fresh names, splits and matches format specifiers, constructs print expressions, and finally returns a combined block expression ready for macro expansion. This snippet is a complete, working example of a compile-time printf macro in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/overview.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.macros.Context\nimport scala.collection.mutable.{ListBuffer, Stack}\n\nobject Macros {\n  def printf(format: String, params: Any*): Unit = macro printf_impl\n\n  def printf_impl(c: Context)(format: c.Expr[String], params: c.Expr[Any]*): c.Expr[Unit] = {\n    import c.universe._\n    val Literal(Constant(s_format: String)) = format.tree\n\n    val evals = ListBuffer[ValDef]()\n    def precompute(value: Tree, tpe: Type): Ident = {\n      val freshName = TermName(c.fresh(\"eval$\"))\n      evals += ValDef(Modifiers(), freshName, TypeTree(tpe), value)\n      Ident(freshName)\n    }\n\n    val paramsStack = Stack[Tree]((params map (_.tree)): _*)\n    val refs = s_format.split(\"(?<=%[\\\\w%])|(?=%[\\\\w%])\") map {\n      case \"%d\" => precompute(paramsStack.pop, typeOf[Int])\n      case \"%s\" => precompute(paramsStack.pop, typeOf[String])\n      case \"%%\" => Literal(Constant(\"%\"))\n      case part => Literal(Constant(part))\n    }\n\n    val stats = evals ++ refs.map(ref => reify(print(c.Expr[Any](ref).splice)).tree)\n    c.Expr[Unit](Block(stats.toList, Literal(Constant(()))))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Subtypes in Scala Generic Classes\nDESCRIPTION: Demonstration of how subtypes work with generic classes in Scala. This example defines a Fruit class hierarchy and shows that a Stack parameterized with a supertype can accept instances of its subtypes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/generic-classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass Fruit\nclass Apple extends Fruit\nclass Banana extends Fruit\n\nval stack = new Stack[Fruit]\nval apple = new Apple\nval banana = new Banana\n\nstack.push(apple)\nstack.push(banana)\n```\n\n----------------------------------------\n\nTITLE: Implementing an Ord Trait in Scala\nDESCRIPTION: Definition of a trait called Ord that provides comparable functionality similar to Java's Comparable interface, with implementation of relational methods based on abstract less-than and equality methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_de/tutorials/scala-for-java-programmers.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Ord {\n  def < (that: Any): Boolean\n  def <=(that: Any): Boolean =  (this < that) || (this == that)\n  def > (that: Any): Boolean = !(this <= that)\n  def >=(that: Any): Boolean = !(this < that)\n}\n```\n\n----------------------------------------\n\nTITLE: Failing Examples of Quote Usage in Scala Interpolations\nDESCRIPTION: Examples showing how attempts to include quote characters in Scala string interpolations fail with the standard syntax, highlighting the problem this SIP addresses.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/interpolation-quote-escape.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ns\"A common question for Scala programmers is \"How can I represent a literal \" character in Scala interpolations?\"\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\ns\"A common question for Scala programmers is \\\"How can I represent a literal \\\" character in Scala interpolations?\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Enumeration in Scala\nDESCRIPTION: Demonstrates the basic syntax for defining an enumeration using the `enum` keyword in Scala 3, listing named values (`Red`, `Green`, `Blue`) for the `Color` type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-adts-gadts.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nenum Color:\n  case Red, Green, Blue\n```\n\n----------------------------------------\n\nTITLE: Defining a Multi-Parameter Method in Scala\nDESCRIPTION: Defines a Scala method named `add` that accepts two integer parameters, `a` and `b`. The method body `a + b` implicitly returns the sum of the two parameters, demonstrating the syntax for declaring multiple parameters in a method signature.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/methods-first-look.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef add(a: Int, b: Int) = a + b\n```\n\n----------------------------------------\n\nTITLE: Manual Invocation of Partest via Scala CLI - Shell\nDESCRIPTION: Manually runs the Partest runner by specifying the classpath to Partest classes and invoking the main class. Additional options may control test selection and execution. This requires a previously built 'quick' target for test classes and the Scala command-line tools in the environment.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/partest-guide.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nscala -cp <path to partest classes> scala.tools.partest.nest.NestRunner <options>\n```\n\n----------------------------------------\n\nTITLE: Accessing Quotes Reflection API in Scala\nDESCRIPTION: Defines and demonstrates how to access the Quotes reflection instance which exposes reflection capabilities within macro contexts. The transparent inline method allows retrieving the Quotes instance available in the current scope, which is required as an implicit context parameter for most reflection operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/reflection.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\npackage scala.quoted\n\ntransparent inline def quotes(using inline q: Quotes): q.type = q\n```\n\n----------------------------------------\n\nTITLE: Causing MatchError with Failing Extractor in Definition - Scala\nDESCRIPTION: Explicitly demonstrates an input string designed to fail the `CustomerID.unapply` check ('-' instead of '--'). Using this string in a value definition where an extraction is expected results in a runtime `scala.MatchError`, highlighting the consequence of the `unapply` method returning `None` in this context.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/extractor-objects.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval CustomerID(name3) = \"-asdfasdfasdf\"\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running a Scala Test File in Sandbox Directory - Scala and Shell\nDESCRIPTION: Demonstrates creating a sandbox directory, writing a simple Scala test object to reproduce a formatting bug with the StringContext.f interpolator, and compiling and running it using the locally built Scala compiler. The snippet highlights shell commands for directory manipulation and executing the Scala compiler (`scalac`) and runtime (`scala`) from a custom build path, showcasing how escaped sequences like `%n` are treated in the output. Inputs are Scala source files and outputs are command line results.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/hacker-guide.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n17:25 ~/Projects/scala (ticket/6725)$ mkdir sandbox\n17:26 ~/Projects/scala (ticket/6725)$ cd sandbox\n17:26 ~/Projects/scala/sandbox (ticket/6725)$ edit Test.scala\n```\n\nLANGUAGE: Scala\nCODE:\n```\nobject Test extends App {\n  val a = 1\n  val s = f\"$a%s%n$a%s\"\n  println(s)\n}\n```\n\nLANGUAGE: Shell\nCODE:\n```\n17:27 ~/Projects/scala/sandbox (ticket/6725)$ ../build/pack/bin/scalac Test.scala\n17:28 ~/Projects/scala/sandbox (ticket/6725)$ ../build/pack/bin/scala Test\n1%n1 // %n should've been replaced by a newline here\n```\n\n----------------------------------------\n\nTITLE: Overriding Trait Methods in a Scala Class\nDESCRIPTION: Demonstrates creating a Cat class that extends the Pet trait, overriding the concrete 'speak' method and implementing the abstract 'comeToMaster' method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/traits-abstract-mixins.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass Cat extends Pet {\n    // override 'speak'\n    override def speak(): Unit = println(\"meow\")\n    def comeToMaster(): Unit = println(\"That's not gonna happen.\")\n}\n```\n\n----------------------------------------\n\nTITLE: Reflectively Accessing a Method by Term Name in Scala\nDESCRIPTION: Given a Type object (listTpe) and a TermName (mapName), this snippet calls member to look up the corresponding symbol (e.g., the 'map' method) defined within List. Dependencies include prior construction of listTpe and mapName. The result is a Symbol representing the method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/annotations-names-scopes.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nlistTpe.member(mapName)\n```\n\n----------------------------------------\n\nTITLE: Proposed Named Context Bound Syntax\nDESCRIPTION: The proposed syntax for naming context bounds using 'as', allowing direct access to the instance without using summon or companion object methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n  def reduce[A : Monoid as m](xs: List[A]): A =\n    xs.foldLeft(m.unit)(_ `combine` _)\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Case Classes Extending a Trait\nDESCRIPTION: Defines two case classes, 'Student' and 'Teacher', both extending the 'Person' trait. These classes represent specific types of 'Person' and will be used to demonstrate pattern matching enabled by the auto-generated 'unapply' methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/case-classes.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ncase class Student(name: String, year: Int) extends Person\ncase class Teacher(name: String, specialty: String) extends Person\n```\n\n----------------------------------------\n\nTITLE: Running a Single Test Suite in Mill\nDESCRIPTION: Illustrates executing a specific test suite in Mill via 'testOnly' task. It requires Mill build configuration and the test class to be reachable from the command line.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-run-only.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n./mill example.test.testOnly example.MyTests\n```\n\n----------------------------------------\n\nTITLE: Applying foreach to Iterate and Print Elements of an Iterator in Scala\nDESCRIPTION: This snippet shows the idiomatic use of the 'foreach' method on a Scala iterator to apply a function (here, println) to each element. It achieves the same effect as the while-loop but in a more concise and expressive manner. No extra dependencies. Input: a Scala Iterator. Output: prints each element. Limitation: the iterator is exhausted after foreach, and further calls to next will result in NoSuchElementException.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/iterators.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nit foreach println\n```\n\n----------------------------------------\n\nTITLE: Mapping Actors Over a Strict Range in Scala\nDESCRIPTION: This snippet shows how to create and start 10 actors using the standard `map` method over a strict range in Scala. The `actor` function is called for each value in the range, ensuring that actors are immediately instantiated. No additional dependencies are required beyond an actor implementation, and each actor receives a different value of `i` from 1 to 10. The enclosing code in the braces represents the actor's behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/views.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval actors = (1 to 10).map(i => actor { ... })\n```\n\n----------------------------------------\n\nTITLE: Демонстрация вывода типов в REPL Scala\nDESCRIPTION: Пример того, как интерактивная среда REPL Scala показывает выведенные типы переменных. Демонстрирует, что Scala правильно определяет Int для числовых значений, List[Int] для списков целых чисел и Map[Int, String] для ассоциативных массивов.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-inferred.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> val a = 1\nval a: Int = 1\n\nscala> val b = List(1, 2, 3)\nval b: List[Int] = List(1, 2, 3)\n\nscala> val m = Map(1 -> \"one\", 2 -> \"two\")\nval m: Map[Int, String] = Map(1 -> one, 2 -> two)\n```\n\n----------------------------------------\n\nTITLE: Executing List Initialization with Cons Operator in Scala REPL\nDESCRIPTION: Shows the Scala REPL execution of creating a `List` using the `::` (cons) operator and `Nil`. The REPL confirms the resulting type (`List[Int]`) and value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nscala> val list = 1 :: 2 :: 3 :: Nil\nlist: List[Int] = List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Named Context Bound with Associated Type Access\nDESCRIPTION: Example of a method using a named context bound to access associated types, demonstrating the need for the proposed change in context bound expansion rules.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ndef run[P : Parser as p](in: p.Input): p.Result\n```\n\n----------------------------------------\n\nTITLE: Defining anonymous classes in Scala\nDESCRIPTION: Demonstrates how to create an anonymous class instance using Scala's `new { ... }` syntax. This allows defining a class without a name and instantiating it immediately. No dependencies are required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\nnew { ... }\n```\n\n----------------------------------------\n\nTITLE: Matching Function Applications with Type/Value Arguments - Scala\nDESCRIPTION: Demonstrates pattern matching on function application AST nodes using quasiquotes, including handling type arguments and variable argument lists. The pattern `q\"f[..$ts](..$args)\"` matches calls to `f`, extracting type arguments into `ts` (a list of trees) and value arguments into `args` (a list of trees).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val apps = List(q\"f[Int](1, 2)\", q\"f('a, 'b)\")\napps: List[universe.Tree] = List(f[Int](1, 2), f(scala.Symbol(\"a\"), scala.Symbol(\"b\")))\nscala> apps.foreach {\n             case q\"f[..$ts](..$args)\" =>\n               println(s\"type arguments: $ts, value arguments: $args\")\n           }\ntype arguments: List(Int), value arguments: List(1, 2)\ntype arguments: List(), value arguments: List(scala.Symbol(\"a\"), scala.Symbol(\"b\"))\n```\n\n----------------------------------------\n\nTITLE: Comparing Plain Strings vs. 's' Interpolated Strings in Scala\nDESCRIPTION: Shows that without the `s` prefix, variable placeholders like `$name` are treated as literal text within the string and are not interpolated.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/string-interpolation.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval name = \"James\"\nval age = 30\nprintln(\"$name is $age years old\")   // \"$name is $age years old\"\n```\n\n----------------------------------------\n\nTITLE: Declaring Mutable Fields with var in Scala\nDESCRIPTION: In Scala, the `var` keyword is used to declare a mutable variable (field). Its value can be reassigned after initialization.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\nvar i = 1\n```\n\n----------------------------------------\n\nTITLE: Defining Vector Addition Operator '+' with Custom Case Class in Scala 3\nDESCRIPTION: Defines a case class Vec with properties x and y and a '+' method to add instances of Vec, using Scala 3 syntax with significant indentation. Demonstrates usage similar to Scala 2, creating two vectors and adding them with the '+' operator, returning a new Vec.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/operators.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ncase class Vec(x: Double, y: Double):\n  def +(that: Vec) = Vec(this.x + that.x, this.y + that.y)\n\nval vector1 = Vec(1.0, 1.0)\nval vector2 = Vec(2.0, 2.0)\n\nval vector3 = vector1 + vector2\nvector3.x  // 3.0\nvector3.y  // 3.0\n```\n\n----------------------------------------\n\nTITLE: Attempting Mutation on Converted Immutable Scala List in Java\nDESCRIPTION: This Scala REPL example converts an immutable `scala.List` to a `java.util.List` using `asJava`. It then demonstrates that calling a mutation method like `add` on the resulting Java list throws an `UnsupportedOperationException`, because the underlying collection remains immutable. This requires the `collection.JavaConverters._` import.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/conversions-between-java-and-scala-collections.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nscala> val jul = List(1, 2, 3).asJava\njul: java.util.List[Int] = [1, 2, 3]\n\nscala> jul.add(7)\njava.lang.UnsupportedOperationException\n  at java.util.AbstractList.add(AbstractList.java:148)\n```\n\n----------------------------------------\n\nTITLE: Resolving Ambiguity in Named Arguments\nDESCRIPTION: Shows how to disambiguate between named arguments and assignments when the parameter name matches a variable in scope, using additional parentheses or block expressions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-and-default-arguments.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef twice(op: => Unit) = { op; op }\nvar op = 1\n// twice(op = op + 1) // error: reference to 'op' is ambiguous\ntwice((op = op + 1))  // assignment, not a named argument\ntwice({op = op + 1})  // assignment\ntwice{ op = op + 1 }  // assignment\n```\n\n----------------------------------------\n\nTITLE: Creating generic arrays with ClassTag for type safety\nDESCRIPTION: This snippet illustrates how to create generic arrays in Scala using an implicit ClassTag parameter, which provides runtime type information necessary for array instantiation. It shows a method 'evenElems' that extracts elements at even indices from a vector, highlighting the use of ClassTag to avoid instantiation errors.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/arrays.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef evenElems[T](xs: Vector[T])(implicit m: ClassTag[T]): Array[T] = {\n  val arr = new Array[T]((xs.length + 1) / 2)\n  for (i <- 0 until xs.length by 2)\n    arr(i / 2) = xs(i)\n  arr\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef evenElems[T: ClassTag](xs: Vector[T]): Array[T] = {\n  val arr = new Array[T]((xs.length + 1) / 2)\n  for (i <- 0 until xs.length by 2)\n    arr(i / 2) = xs(i)\n  arr\n}\n```\n\n----------------------------------------\n\nTITLE: Using Underscore in Method Call\nDESCRIPTION: Shows how to use the underscore shorthand when a parameter is used once in a method call within an anonymous function.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-anonymous-functions.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nints.foreach(println(_))\n```\n\n----------------------------------------\n\nTITLE: Selecting a Value by Key Using apply in Scala Map\nDESCRIPTION: Fetches a value associated with a given key in a map using the apply method. Standard Scala dependencies only; input is a map and a key, output is the value mapped to the key. Throws an exception if the key is not present in the map.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/trait-iterable.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nMap('a' -> 1, 'b' -> 10, 'c' -> 100)('b')\n```\n\n----------------------------------------\n\nTITLE: 定义CanBuildFrom trait用于类型转换(Scala)\nDESCRIPTION: CanBuildFrom trait是一个工厂接口，用于创建适当类型的Builder。它有三个类型参数：From表示源集合类型，Elem表示目标集合元素类型，To表示目标集合类型。通过隐式参数机制，它实现了集合操作（如map）的灵活类型转换。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/architecture-of-scala-collections.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\npackage scala.collection.generic\n\ntrait CanBuildFrom[-From, -Elem, +To] {\n  // 创建一个新的构造器(builder)\n  def apply(from: From): Builder[Elem, To]\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating with for Loop Over Range in Scala\nDESCRIPTION: Demonstrates several Scala 'for' loop syntaxes for iterating over the integer range 0 until 3, including preferred single line, parenthesis enclosed, and multiline 'do' block syntax. Each prints the current index 'i'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\n// preferred\nfor i <- 0 until 3 do println(i)\n\n// also available\nfor (i <- 0 until 3) println(i)\n\n// multiline syntax\nfor\n  i <- 0 until 3\ndo\n  println(i)\n```\n\n----------------------------------------\n\nTITLE: Eta-Expansion in Methods with Implicit or Context Parameters in Scala\nDESCRIPTION: This group of snippets shows eta-expansion for methods with implicit (using) or context parameters. Such methods are converted to context function types as per the SIP proposal. Required dependencies: use of context parameters or context function types. Inputs/outputs follow the generic functional approach; errors documented where context parameters are lacking. Limitation: context functions must have at least one parameter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/polymorphic-eta-expansion.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ndef uf1[A](using x: A): A = ???\nval vuf1_1: [B] => B ?=> B = uf1 // uf1 becomes [B'] => (y: B') ?=> uf1[B']\n\n\ndef uf2[A]: A = ???\nval vuf2: [B] => B ?=> B = uf2 // uf2 becomes [B'] => (y: B') ?=> uf2[B']\n\n//reminder:\nval get: (String) ?=> Int = 22 // 22 becomes (s: String) ?=> 22\nval err: () ?=> Int       = ?? // error: context functions require at least one parameter\n```\n\n----------------------------------------\n\nTITLE: Scala 3 union types in method signatures\nDESCRIPTION: This snippet illustrates the use of union types in Scala 3, allowing functions to accept multiple types as arguments or return multiple types without a common hierarchy. It defines `isTruthy` and `dogCatOrWhatever` functions with union type parameters and return types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-introduction.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef isTruthy(a: Boolean | Int | String): Boolean = ???\ndef dogCatOrWhatever(): Dog | Plant | Car | Sun = ???\n```\n\n----------------------------------------\n\nTITLE: Defining Methods without Arguments in Scala 2\nDESCRIPTION: This snippet modifies the `Complex` class to define `re` and `im` as methods without parentheses, allowing access without parentheses. It showcases Scala 2 syntax for parameterless methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\n```scala\nclass Complex(real: Double, imaginary: Double) {\n  def re = real\n  def im = imaginary\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Unapply to a Standard Class in Scala\nDESCRIPTION: Defines a standard class `Person` and its companion object `Person`. The companion object includes a custom `unapply` method which enables pattern matching for instances of the `Person` class. The `unapply` method extracts the name and age, returning them as a tuple (though the standard requires returning `Option[(T1, ..., Tn)]`). Shows syntax for Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_48\n\nLANGUAGE: Scala 2\nCODE:\n```\nclass Person(var name: String, var age: Int)\nobject Person {\n  def unapply(p: Person): Tuple2[String, Int] = (p.name, p.age)\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nclass Person(var name: String, var age: Int)\nobject Person:\n  def unapply(p: Person): Tuple2[String, Int] = (p.name, p.age)\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Singleton Object Methods across Packages - scala\nDESCRIPTION: Demonstrates importing the 'info' method from the singleton Logger object in another package using a stable path import statement. It then defines classes and calls 'info' directly to log messages. This shows how singleton object methods are accessible via imports, allowing their methods to be used without qualifying the object name. The snippet assumes the 'logging.Logger' object is defined and imported correctly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/singleton-objects.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport logging.Logger.info\n\nclass Project(name: String, daysToComplete: Int)\n\nclass Test {\n  val project1 = new Project(\"TPS Reports\", 1)\n  val project2 = new Project(\"Website redesign\", 5)\n  info(\"Created projects\")  // Prints \"INFO: Created projects\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Methods with Default Parameters in Scala 2\nDESCRIPTION: Shows how to define a method (`makeConnection`) in Scala 2 with default values specified for its parameters (`timeout = 5_000`, `protocol = \"http\"`). This allows callers to omit these arguments, using the defaults instead.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ndef makeConnection(timeout: Int = 5_000, protocol: String = \"http\") = {\n  println(f\"timeout = ${timeout}%d, protocol = ${protocol}%s\")\n  // more code here ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait with Dependent Types in Scala\nDESCRIPTION: This snippet defines the trait 'Key' with an associated type 'Value' and trait 'DB' with a dependent method 'get' that returns an option of 'k.Value'. It demonstrates how dependent types allow methods to return values whose types depend on the input key.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-dependent-function.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Key { type Value }\n\ntrait DB {\n  def get(k: Key): Option[k.Value] // зависимый метод\n}\n```\n\n----------------------------------------\n\nTITLE: Deconstructing Empty Blocks and MatchError on Empty Tree\nDESCRIPTION: Illustrates that deconstructing an empty block `q\"{}\"` results in an empty list of statements. Attempting to deconstruct an `EmptyTree` (represented by `q\"\"`) using the block deconstruction pattern `q\"..$stats\"` results in a `scala.MatchError`. An empty list of stats from deconstruction corresponds to a synthetic `Unit`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_41\n\nLANGUAGE: scala\nCODE:\n```\nscala> val q\"..$stats\" = q\"\"\nscala.MatchError: <empty> (of class scala.reflect.internal.Trees$EmptyTree$)\n  ... 32 elided\n\nscala> val q\"..$stats\" = q\"{}\"\nstats: List[universe.Tree] = List()\n\nscala> val syntheticUnit = q\"..$stats\" // Note: This assigns () to syntheticUnit\nsyntheticUnit: universe.Tree = ()\n```\n\n----------------------------------------\n\nTITLE: Using @unroll to Maintain Binary Compatibility for Method Definitions in Scala\nDESCRIPTION: Demonstrates applying the `@unroll` annotation to the newly added default parameters (`b`, `l`) in the `foo` method. This instructs the compiler to generate forwarder methods, ensuring binary compatibility with older versions of the library. Requires importing `scala.annotation.unroll`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/unroll-default-arguments.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.annotation.unroll\n\nobject Unrolled{\n   def foo(s: String, n: Int = 1, @unroll b: Boolean = true, @unroll l: Long = 0) = s + n + b + l\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Cross Scala Versions in SBT\nDESCRIPTION: Configures SBT to enable cross-compilation for both Scala 2.13 and Scala 3 by specifying 'crossScalaVersions'. Also demonstrates how to conditionally include 'scala-reflect' only for Scala 2.13. This setup is mandatory for building and publishing code for both versions. Requires SBT 1.x and a multi-version-compatible codebase.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-macro-cross-building.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncrossScalaVersions := Seq(\"2.13.11\", \"3.3.1\")\n```\n\nLANGUAGE: scala\nCODE:\n```\n// build.sbt\nlibraryDependencies ++= {\n  CrossVersion.partialVersion(scalaVersion.value) match {\n    case Some((2, 13)) => Seq(\n      \"org.scala-lang\" % \"scala-reflect\" % scalaVersion.value\n    )\n    case _ => Seq.empty\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Callback with Future in Scala\nDESCRIPTION: This snippet demonstrates the use of callbacks (for-comprehension and foreach) with Scala Future to chain asynchronous computations. It shows retrieving a currency exchange rate asynchronously, then conditionally buying the amount if profitable. The inner Future representing the purchase is nested within the foreach callback of the first Future. This approach may lead to nested callbacks and limited scope for further processing. It requires scala.concurrent.Future and an implicit ExecutionContext in scope.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/futures.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval rateQuote = Future {\n  connection.getCurrentValue(USD)\n}\n\nfor (quote <- rateQuote) {\n  val purchase = Future {\n    if (isProfitable(quote)) connection.buy(amount, quote)\n    else throw new Exception(\"有益ではない\")\n  }\n\n  for (amount <- purchase)\n    println(amount + \" USD を購入した\")\n}\n```\n\n----------------------------------------\n\nTITLE: Proposed RuntimeCheck Annotation Implementation in Scala\nDESCRIPTION: Defines the new internal RuntimeCheck annotation class that will replace @unchecked for asserting that patterns are checked at runtime.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/replace-nonsensical-unchecked-annotation.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\npackage scala.annotation.internal\n\nfinal class RuntimeCheck extends Annotation\n```\n\n----------------------------------------\n\nTITLE: Overriding toString Method in Complex Class in Scala\nDESCRIPTION: Expands the Complex class to include an override of the toString() method inherited from scala.AnyRef (Java Object). The toString method is declared with the override modifier to avoid accidental overriding. It returns a string representation of the complex number showing the real part, a '+' or '' sign depending on the imaginary part's sign, and the imaginary part followed by 'i'. This snippet demonstrates class inheritance, method overriding, and string concatenation in Scala with type-safe string conversion. Inputs are the Complex instance fields; output is a formatted string describing the complex number.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tutorials/scala-for-java-programmers.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nclass Complex(real: Double, imaginary: Double) {\n  def re = real\n  def im = imaginary\n  override def toString() =\n    \"\" + re + (if (im >= 0) \"+\" else \"\") + im + \"i\"\n}\n```\n\n----------------------------------------\n\nTITLE: Using Numeric Abstraction in a Program and Derivative Function\nDESCRIPTION: This snippet demonstrates defining a program type '(n: Nums) => n.Num => n.Num' and an example 'ex' that adds a constant to an input. It also shows how to invoke a derivative function with different numeric expressions, utilizing dependent types for flexible and generic numeric code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-dependent-function.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ntype Prog = (n: Nums) => n.Num => n.Num\n\nval ex: Prog = nums => x => nums.add(nums.lit(0.8), x)\n\ndef derivative(input: Prog): Double\n```\n\n----------------------------------------\n\nTITLE: Demo of TypeTag implicit parameter usage in Scala\nDESCRIPTION: Examples showing the output of the paramInfo method when called with different types of arguments, demonstrating how TypeTag preserves complete type information.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/reflection/typetags-manifests.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nscala> paramInfo(42)\ntype of 42 has type arguments List()\n\nscala> paramInfo(List(1, 2))\ntype of List(1, 2) has type arguments List(Int)\n```\n\n----------------------------------------\n\nTITLE: Updating Deprecated Syntax with Still-Supported Alternatives - Scala\nDESCRIPTION: This snippet aggregates examples of collection operations that remain temporarily supported in Scala 2.13 with a deprecation warning. It demonstrates how to change usages of set and map operations, method names, and collection traversal into their modern forms. Dependencies include scala.collection.mutable and scala.collection.immutable as needed. Inputs are old collection expressions; outputs are idiomatic Scala 2.13 code. Limitations: some old APIs will be fully removed in future releases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/collections-migration-213.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nxs ++ Set(1) -- Set(2) // instead of xs + 1 - 2\nmap.to(immutable.Map) -- keys // instead of map -- keys\nSet(1) + 2 + 3 // instead of Set(1) + (2, 3)\nmutable.Map(1 -> 2).clone() += 1 -> 3 // instead of mutable.Map(1 -> 2).updated(1, 3)\nmutable.Set(1).clone() += 2 // instead of mutable.Set(1) + 2\nxs.rangeUntil(42) // instead of xs.until(42)\ndef f(xs: Iterable[Int]): Unit // instead of def f(xs: Traversable[Int]): Unit\nLazyList.from(1) // instead of Stream.from(1)\nxs.concat(ys) // instead of xs.union(ys)\nxs.lazyAppendedAll(ys) // instead of xs.append(ys)\nxs.iterator // instead of xs.toIterator\nbuffer ++= xs // instead of xs.copyToBuffer(buffer)\nxs.lazyZip(ys) // instead of (xs, ys).zipped\nxs.filterInPlace(f.tupled) // instead of xs.retain(f)\nxs.foldRight(y)(f) // instead of (xs :\\ y)(f)\nxs.iterableFactory // instead of xs.companion\n```\n\n----------------------------------------\n\nTITLE: Creating a PrefixMap with String Keys in Scala\nDESCRIPTION: Example demonstrating how to initialize a PrefixMap with string keys and integer values. The PrefixMap is a Patricia trie implementation that efficiently stores string-based keys.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\nval m = PrefixMap(\"abc\" -> 0, \"abd\" -> 1, \"al\" -> 2,\n  \"all\" -> 3, \"xy\" -> 4)\n```\n\n----------------------------------------\n\nTITLE: Applying Significant Indentation Syntax Rewrite - Scala\nDESCRIPTION: Demonstrates use of `-indent -rewrite` compiler options to remove braces and replace them with significant indentation. This transforms method and class bodies, as well as `if` expressions and `for` comprehensions, to indentation-based blocks using colons (`:`) and indentation level rather than braces. This snippet shows the final Scala 3 style code after applying significant indentation rewrite on the previous new syntax transformed code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tooling-syntax-rewriting.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ncase class State(n: Int, minValue: Int, maxValue: Int):\n  \n  def inc: State =\n    if n == maxValue then\n      this\n    else\n      this.copy(n = n + 1)\n  \n  def printAll: Unit =\n    println(\"Printing all\")\n    for\n      i <- minValue to maxValue\n      j <- 0 to n\n    do println(i + j)\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Intersection Types in Scala 3\nDESCRIPTION: Demonstrates how to define traits `Resettable` and `Growable[A]` and a function `f` that accepts a parameter `x` which must be of both types `Resettable` and `Growable[String]` using the `&` operator. This structural approach allows calling methods from both parent traits (`reset()` and `add()`) on the parameter `x` without needing a specific combined nominal type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-intersection.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Resettable:\n  def reset(): Unit\n\ntrait Growable[A]:\n  def add(a: A): Unit\n\ndef f(x: Resettable & Growable[String]): Unit =\n  x.reset()\n  x.add(\"first\")\n```\n\n----------------------------------------\n\nTITLE: Declaring a Scala Case Class Person in Scala 2 and 3\nDESCRIPTION: Defines a simple case class named Person with a single String parameter name. This serves as an example of immutable data-holding classes in Scala, enabling pattern matching, equality checking, and concise syntax for class declaration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-collections.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ncase class Person(name: String)\n```\n\n----------------------------------------\n\nTITLE: Defining Recursive List Algebraic Data Type in Scala\nDESCRIPTION: Defines a recursive List algebraic data type via a sealed trait, with Cons and Nil as case class and case object implementations, respectively. The definition supports generic and recursive structural decomposition for type class derivation using shapeless. No dependencies except the Scala standard library. Used as a motivating example for recursive type class inference.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nsealed trait List[+T]\ncase class Cons[T](hd: T, tl: List[T]) extends List[T]\ncase object Nil extends List[Nothing]\n```\n\n----------------------------------------\n\nTITLE: Casting Numeric Types with Implicit Conversion in Scala\nDESCRIPTION: This Scala code snippet illustrates explicit casting between numeric types using built-in conversion methods. A Long value is converted to a Float using toFloat, highlighting possible precision loss. Additionally, a Char is implicitly cast to an Int to obtain its numeric Unicode representation. The snippet requires understanding of Scala's numeric types and implicit numeric conversions. Inputs are predefined values of Long and Char, and outputs are the corresponding Float and Int values after casting. It also demonstrates Scala's one-way casting limitations through comments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/unified-types.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval x: Long = 987654321\nval y: Float = x.toFloat  // 9.8765434E8 (w tym wypadku tracimy część precyzji)\n\nval face: Char = '☺'\nval number: Int = face  // 9786\n```\n\n----------------------------------------\n\nTITLE: Instantiating Scala Class with Default Parameters\nDESCRIPTION: These examples show different ways to instantiate a Scala class that has default constructor parameters. Instances can be created by providing no arguments, some arguments (overriding initial parameters), or all arguments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/constructors-default-values.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nnew Socket()\n```\n\nLANGUAGE: scala\nCODE:\n```\nnew Socket(1000)\n```\n\nLANGUAGE: scala\nCODE:\n```\nnew Socket(4000, 6000)\n```\n\n----------------------------------------\n\nTITLE: Using Union Types in Scala 3\nDESCRIPTION: Illustrates the Scala 3 union type feature (`|`) for method parameters and variable types. This allows a value or parameter to hold instances of different types while maintaining static type safety, contributing to a dynamic feel. Requires Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/why-scala-3.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n// union type parameter\ndef help(id: Username | Password) =\n  val user = id match\n    case Username(name) => lookupName(name)\n    case Password(hash) => lookupPassword(hash)\n  // more code here ...\n\n// union type value\nval b: Password | Username = if (true) name else password\n```\n\n----------------------------------------\n\nTITLE: Declaring BigInt and BigDecimal for Arbitrary Precision Arithmetic in Scala\nDESCRIPTION: Demonstrates creation of arbitrary precision numeric types BigInt and BigDecimal, which allow representation and computation with very large or precise numbers beyond standard primitive limits. Requires importing scala.math.BigInt and scala.math.BigDecimal. Useful for precision-critical or large-number applications.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/first-look-at-types.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nval a = BigInt(1_234_567_890_987_654_321L)\nval b = BigDecimal(123456.789)\n```\n\n----------------------------------------\n\nTITLE: Inspecting Tree Representation using show in Scala\nDESCRIPTION: This snippet shows how to obtain a human-readable, pseudo-Scala code representation from an abstract syntax tree using the show (or toString) method. The method show takes a Tree as input and returns a String representing the source-level code of the tree; requires the universe import. Output for the example tree corresponds to \\\"x.$plus(2)\\\".\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nshow(tree)\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait as an Interface in Scala\nDESCRIPTION: Creating a trait that serves as an interface with only abstract members that must be implemented by classes that extend it.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ntrait Employee {\n  def id: Int\n  def firstName: String\n  def lastName: String\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait Employee:\n  def id: Int\n  def firstName: String\n  def lastName: String\n```\n\n----------------------------------------\n\nTITLE: Printing Animal Names from Covariant List in Scala\nDESCRIPTION: Defines a function printAnimalNames that takes a List of Animal, and demonstrates that it accepts lists of Cat and Dog thanks to List being covariant. The code creates lists of both Cat and Dog, and passes them to the method. Dependencies include the List standard library and the earlier Animal hierarchy. Key input: List[Animal] (or subtype). The function prints each animal's name to the console. Limitation: relies on covariance of List.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/variances.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\ndef printAnimalNames(animals: List[Animal]): Unit =\n  animals.foreach {\n    animal => println(animal.name)\n  }\n\nval cats: List[Cat] = List(Cat(\"Whiskers\"), Cat(\"Tom\"))\nval dogs: List[Dog] = List(Dog(\"Fido\"), Dog(\"Rex\"))\n\n// prints: Whiskers, Tom\nprintAnimalNames(cats)\n\n// prints: Fido, Rex\nprintAnimalNames(dogs)\n```\n\n----------------------------------------\n\nTITLE: BigInt and BigDecimal Usage in Scala\nDESCRIPTION: Shows how to use BigInt and BigDecimal types for handling very large numbers or precise decimal calculations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-vars-data-types.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nvar a = BigInt(1_234_567_890_987_654_321L)\nvar b = BigDecimal(123_456.789)\n```\n\n----------------------------------------\n\nTITLE: Explicit Grouping Based on Operator Precedence in Scala\nDESCRIPTION: Shows the equivalent grouping using parentheses for the previous complex expression. This clarifies how Scala evaluates the expression based on the precedence of the first character of each operator (`?` > `+` > `=` > `^` > `|` > `l`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/operators.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n((a + b) ^? (c ?^ d)) less ((a ==> b) | c)\n```\n\n----------------------------------------\n\nTITLE: Using '_' as a Type Parameter with a Context Bound - Scala\nDESCRIPTION: Defines a method 'foo' with '_' as a type parameter and a context bound, a workaround legal in Scala 2.13 but unsupported in Scala 3 (syntax error). The method implementation is a placeholder. Dependencies: A class or trait named 'Foo' must be in scope. Key parameter is the type argument ('_') with an implicit Foo instance required. This exploits a compiler quirk and is not portable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-syntactic.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ndef foo[_: Foo]: Unit = ???\n```\n\n----------------------------------------\n\nTITLE: Infix Notation for Operators in Scala\nDESCRIPTION: Shows that methods with a single parameter can be used as infix operators for readability. Presents examples using '+' as an infix operator.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/operators.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n10 + 1\n```\n\n----------------------------------------\n\nTITLE: Importing 'given' MonthConverter instances in Scala\nDESCRIPTION: Provides an example of importing all 'given' instances from 'MonthConversions' object, including specific 'given MonthConverter[?]', to enable conversion methods for different types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/packaging-imports.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nimport MonthConversions.*\nimport MonthConversions.{given MonthConverter[?]}\n```\n\n----------------------------------------\n\nTITLE: Rendering HTML with Cask and Scalatags (Scala)\nDESCRIPTION: Demonstrates how to use the Scalatags templating library to generate HTML responses from a Cask endpoint. The return type of the `dynamicWithCity` method is changed from `String` to `scalatags.Text.all.doctype`. Cask automatically recognizes this type and sets the `Content-Type` header to `text/html`. The code uses the Scalatags DSL to construct a simple HTML document wrapping the time string in a paragraph tag. This requires the `scalatags` dependency to be added to the project.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/web-server-dynamic.md#_snippet_4\n\nLANGUAGE: Scala 2\nCODE:\n```\nimport java.time.{ZoneId, ZonedDateTime}\nimport scalatags.Text.all._\n\nobject Example extends cask.MainRoutes {\n\n  private def getZoneIdForCity(city: String): Option[ZoneId] = {\n    import scala.jdk.CollectionConverters._\n    ZoneId.getAvailableZoneIds.asScala.find(_.endsWith(\"/\" + city)).map(ZoneId.of)\n  }\n  \n  @cask.get(\"/time/:city\")\n  def dynamicWithCity(city: String): doctype = {\n    val text = getZoneIdForCity(city) match {\n      case Some(zoneId) => s\"Current date is: ${ZonedDateTime.now().withZoneSameInstant(zoneId)}\"\n      case None => s\"Couldn't find time zone for city $city\"\n    }\n\n    doctype(\"html\")(\n      html(\n        body(\n          p(text)\n        )\n      )\n    )\n  }\n\n  initialize()\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nimport java.time.{ZoneId, ZonedDateTime}\nimport scalatags.Text.all.*\n\nobject Example extends cask.MainRoutes:\n\n  private def getZoneIdForCity(city: String): Option[ZoneId] =:\n    import scala.jdk.CollectionConverters.*\n    ZoneId.getAvailableZoneIds.asScala.find(_.endsWith(\"/\" + city)).map(ZoneId.of)\n\n  @cask.get(\"/time/:city\")\n  def dynamicWithCity(city: String): doctype =:\n    val text = getZoneIdForCity(city) match:\n      case Some(zoneId) => s\"Current date is: ${ZonedDateTime.now().withZoneSameInstant(zoneId)}\"\n      case None => s\"Couldn't find time zone for city $city\"\n    doctype(\"html\")(\n      html(\n        body(\n          p(text)\n        )\n      )\n    )\n\n  initialize()\n```\n\n----------------------------------------\n\nTITLE: Providing an Alternate Option with orElse Pattern - Scala\nDESCRIPTION: This snippet shows how Option.orElse is implemented via pattern matching. If the Option is Some, returns itself; if None, it returns the provided alternate Option. Input is an Option and an alternate Option. Output is an Option. No external dependencies required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\noption match {\n  case Some(x) => Some(x)\n  case None    => Some(y)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Animal Type Hierarchy in Scala 2\nDESCRIPTION: This snippet defines an abstract Animal base class and two case classes, Cat and Dog, that extend it. Required for subsequent examples about subtyping and variance. No external dependencies. Each animal instance contains a name (String), and all subclasses override the abstract name member. The hierarchy illustrates how variance impacts type safety with generic containers across related types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/variances.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Animal {\n  def name: String\n}\ncase class Cat(name: String) extends Animal\ncase class Dog(name: String) extends Animal\n```\n\n----------------------------------------\n\nTITLE: Anonymous Context Parameters in Scala 3\nDESCRIPTION: Shows how to define context parameters without naming them in Scala 3, useful when the parameter is not directly referenced in the method body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-context-parameters.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n//        no need to come up with a parameter name\n//                             vvvvvvvvvvvvv\ndef renderWebsite(path: String)(using Config): String =\n    \"<html>\" + renderWidget(List(\"cart\")) + \"</html>\"\n```\n\n----------------------------------------\n\nTITLE: Appending Elements to a Vector - Scala\nDESCRIPTION: Demonstrates how to add elements to a Vector using :+ for a single element and ++ for concatenating another Vector. Since Vector is immutable, the original Vector remains unchanged, and a new instance is returned. Input: source Vector and value(s) to append; Output: new Vector including appended elements. Dependencies: standard Scala library.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/vector-class.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval a = Vector(1,2,3)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval b = a :+ 4\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval b = a ++ Vector(4, 5)\n```\n\n----------------------------------------\n\nTITLE: Matching Numeric Patterns with Scala Regular Expressions\nDESCRIPTION: This snippet imports the Scala Regex class and creates a regex pattern to identify digits in strings. It checks if the password string contains at least one digit by attempting to find a match. If a match is found, it prints \"Password OK\"; otherwise, it instructs that \"Password must contain a number.\" Dependencies include Scala's standard library with scala.util.matching.Regex. The input is a string to be checked, and output is printed to the console indicating password validity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/regular-expression-patterns.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.util.matching.Regex\n\nval numberPattern: Regex = \"[0-9]\".r\n\nnumberPattern.findFirstMatchIn(\"awesomepassword\") match {\n  case Some(_) => println(\"Password OK\")\n  case None => println(\"Password must contain a number\")\n}\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing Scala Objects as JSON Files in Scala 3\nDESCRIPTION: This example demonstrates reading a JSON file into a Scala case class, modifying the object, and writing it back as JSON using uPickle and OS-Lib. It uses Scala 3's derives keyword to automatically generate ReadWriter instances without explicit implementation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-files.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport upickle.default.*\n\ncase class PetOwner(name: String, pets: List[String]) derives ReadWriter\n\n// read a PetOwner from a JSON file\nval petOwner: PetOwner = read[PetOwner](os.read(os.pwd / \"pet-owner.json\"))\n\n// create a new PetOwner\nval petOwnerUpdated = petOwner.copy(pets = \"Toolkitty\" :: petOwner.pets)\n\n// write to a new file\nos.write(os.pwd / \"pet-owner-updated.json\", write(petOwnerUpdated))\n```\n\n----------------------------------------\n\nTITLE: 操作可变堆栈（mutable.Stack）示例\nDESCRIPTION: 展示如何使用可变堆栈，包括push、pop和top操作。Stack支持后进先出序列，适合状态回退和递归场景。基于scala.collection.mutable包。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/concrete-mutable-collection-classes.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nval stack = new scala.collection.mutable.Stack[Int]\nstack.push(1)\nstack.push(2)\nval topElem = stack.top\nval popped = stack.pop\n```\n\n----------------------------------------\n\nTITLE: Using 'if' guards with curly braces in 'match' expressions\nDESCRIPTION: Demonstrates 'match' expression with 'case' clauses using curly braces to enclose multiple statements, allowing for structured and multiline code within pattern matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/match-expressions.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\ncount match {\n    case 1 => {\n        println(\"one, a lonely number\")\n    }\n    case x if x == 2 || x == 3 => {\n        println(\"two's company, three's a crowd\")\n    }\n    case x if x > 3 => {\n        println(\"4+, that's a party\")\n    }\n    case _ => {\n        println(\"i'm guessing your number is zero or less\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Showable type class and its implicit derivation in Scala\nDESCRIPTION: This code defines a trait 'Showable' as a type class for string representation of types, along with a companion object that includes an implicit macro method 'materializeShowable' which generates 'Showable' instances dynamically, eliminating manual boilerplate.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/implicits.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Showable[T] { def show(x: T): String }\nobject Showable {\n  implicit def materializeShowable[T]: Showable[T] = macro ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Scala Class with Constructor and Methods\nDESCRIPTION: This code snippet defines a Scala class named 'Ponto' with two mutable parameters 'x' and 'y'. It includes a method 'move' to update coordinates and overrides the 'toString' method to provide a string representation for instances. It demonstrates class syntax, constructor parameter usage, method definition, and override conventions in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/classes.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass Ponto(var x: Int, var y: Int) {\n  def move(dx: Int, dy: Int): Unit = {\n    x = x + dx\n    y = y + dy\n  }\n  override def toString: String =\n    \"(\" + x + \", \" + y + \")\"\n}\n```\n\n----------------------------------------\n\nTITLE: Scala Trait Extending Abstract Iterator with Foreach Method\nDESCRIPTION: This snippet introduces 'RichIterator', a trait extending 'AbsIterator' that adds a 'foreach' method to apply a function to each element. It demonstrates behavior composition without implementing the abstract methods, relying on concrete classes to supply them.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/mixin-class-composition.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ntrait RichIterator extends AbsIterator {\n  def foreach(f: T => Unit): Unit = while (hasNext) f(next())\n}\n```\n\n----------------------------------------\n\nTITLE: Mixing import of named and 'given' instances in Scala\nDESCRIPTION: Shows how to combine name-based and type-based imports in a single Scala import statement, with 'given' imports specified last, to import 'im', 'intOrd', and 'listOrd' but not 'ec'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/packaging-imports.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nimport Instances.{im, given Ordering[?]}\n```\n\n----------------------------------------\n\nTITLE: Creating Tuple-like Structures (Java)\nDESCRIPTION: This Java snippet illustrates how tuple-like structures can be created using dedicated classes like `Pair`, `Triplet`, and `Quartet`. These classes are typically provided by external libraries as Java does not have built-in tuple syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_63\n\nLANGUAGE: Java\nCODE:\n```\nPair<String, Integer> pair =\n  new Pair<String, Integer>(\"Eleven\", 11);\n\nTriplet<String, Integer, Double> triplet =\n  Triplet.with(\"Eleven\", 11, 11.0);\nQuartet<String, Integer, Double,Person> triplet =\n  Quartet.with(\"Eleven\", 11, 11.0, new Person(\"Eleven\"));\n```\n\n----------------------------------------\n\nTITLE: Object-Oriented Programming in Scala\nDESCRIPTION: Object-oriented programming constructs in Scala, including class definitions, constructors, access modifiers, and anonymous classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/cheatsheets/index.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nclass C(x: R)\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass C(val x: R)\nvar c = new C(4)\nc.x\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass C(var x: R) {\nassert(x > 0, \"positive please\")\nvar y = x\nval readonly = 5\nprivate var secret = 1\ndef this = this(42)\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nnew{ ... }\n```\n\n----------------------------------------\n\nTITLE: Указание числовых типов с помощью литералов в Scala\nDESCRIPTION: Демонстрирует использование суффиксов `L`, `D` и `F` для явного определения литералов `Long`, `Double` и `Float` соответственно. Также показано использование символа подчеркивания для читаемости.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-vars-data-types.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval x = 1_000L   // val x: Long = 1000\nval y = 2.2D     // val y: Double = 2.2\nval z = 3.3F     // val z: Float = 3.3\n```\n\n----------------------------------------\n\nTITLE: Переназначение изменяемых переменных (`var`) в Scala\nDESCRIPTION: Иллюстрирует, что переменная, объявленная с помощью `var`, может быть успешно переназначена новому значению без ошибок компиляции.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-vars-data-types.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nvar msg = \"Hello, world\"\nmsg = \"Aloha\"   // этот код скомпилируется, потому что var может быть переназначена\n```\n\n----------------------------------------\n\nTITLE: Callback-based Futures for Currency Trading in Scala 2\nDESCRIPTION: This snippet demonstrates how to chain asynchronous currency exchange operations using nested 'foreach' callbacks in Scala 2, highlighting issues with bulky, hard-to-maintain code caused by callback nesting.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nval rateQuote = Future {\n  connection.getCurrentValue(USD)\n}\n\nfor (quote <- rateQuote) {\n  val purchase = Future {\n    if (isProfitable(quote)) connection.buy(amount, quote)\n    else throw new Exception(\"not profitable\")\n  }\n\n  for (amount <- purchase)\n    println(\"Purchased \" + amount + \" USD\")\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Clues for Better Error Reports in Scala\nDESCRIPTION: Shows how to use clue() inside assertions to provide more context when assertions fail, resulting in more informative error messages that display the values being compared.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-what-else.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nassert(clue(List(a).head) > clue(b))\n// munit.FailException: assertion failed\n// Clues {\n//   List(a).head: Int = 1\n//   b: Int = 2\n// }\n```\n\n----------------------------------------\n\nTITLE: Using Package-Level Members with Wildcard Import in Scala 3\nDESCRIPTION: Shows usage of package-level members in Scala 3 by importing them via wildcard import and defining a @main annotated method. The method iterates through the planted fruit list and prints their details. This illustrates Scala 3's concise syntax for program entry points and package-wide member usage.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/package-objects.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport gardening.fruits.*\n\n@main def printPlanted(): Unit =\n  for fruit <- planted do\n    showFruit(fruit)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Safety with Path-Dependent Types in Scala\nDESCRIPTION: Shows an example that fails compilation due to Scala's path-dependent types. It attempts to connect a node belonging to `graph1` (`graph1.Node`) with a node belonging to `graph2` (`graph2.Node`). This is disallowed by the type system because they are considered distinct types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/inner-classes.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval graph1: Graph = new Graph\nval node1: graph1.Node = graph1.newNode\nval node2: graph1.Node = graph1.newNode\nnode1.connectTo(node2)      // работает\nval graph2: Graph = new Graph\nval node3: graph2.Node = graph2.newNode\nnode1.connectTo(node3)      // не работает!\n```\n\n----------------------------------------\n\nTITLE: Defining a Sealed Trait (ADT) in Scala\nDESCRIPTION: Illustrates defining an Algebraic Data Type (ADT) using a sealed trait (`Option[+A]`). In Scala, all direct subclasses of a sealed trait (here, `Some[A]` and `None`) must be defined in the same source file. This allows the compiler to perform exhaustiveness checks for pattern matching. The file is typically named after the sealed trait, e.g., `Option.scala`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/files.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nsealed trait Option[+A]\n\ncase class Some[A](a: A) extends Option[A]\n\ncase object None extends Option[Nothing]\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Class with Parameters in Scala\nDESCRIPTION: Shows how to define a Scala class (`Complex`) with constructor parameters (`real`, `imaginary`). Defines methods (`re`, `im`) with explicit parentheses `()` required for invocation (e.g., `c.im()`) to access these parameters. Mentions Scala's type inference for return types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tutorials/scala-for-java-programmers.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nclass Complex(real: Double, imaginary: Double) {\n  def re() = real\n  def im() = imaginary\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Sonatype Credentials to SBT (Scala)\nDESCRIPTION: Specifies how to provide Sonatype Nexus credentials in SBT by adding a credentials setting. To be placed in $HOME/.sbt/1.0/sonatype.sbt (never committed to version control). Required for secure publication to Maven Central. Inputs: valid Sonatype username and password. Outputs: sbt authentication when publishing. Limitation: Sensitive information must be kept private; plugin expects specific configuration format.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ncredentials += Credentials(\"Sonatype Nexus Repository Manager\",\n        \"oss.sonatype.org\",\n        \"(Sonatype user name)\",\n        \"(Sonatype password)\")\n```\n\n----------------------------------------\n\nTITLE: Defining Animal Hierarchy Using Abstract and Case Classes in Scala - scala\nDESCRIPTION: Introduces an abstract class Animal with a name method, and two case classes Cat and Dog extending Animal. This forms the base hierarchy for demonstrating variance in generic classes. These classes provide a foundation for subtype relationships used in later examples with covariant Lists and printers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/variances.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Animal {\n  def name: String\n}\ncase class Cat(name: String) extends Animal\ncase class Dog(name: String) extends Animal\n```\n\n----------------------------------------\n\nTITLE: Creating and using a typed Reference instance in Scala\nDESCRIPTION: This example shows how to instantiate a `Reference[Int]` for storing integers, set a value, and retrieve it with type safety, avoiding explicit casting. It illustrates practical usage of generics for type-safe data storage.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tutorials/scala-for-java-programmers.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nobject IntegerReference {\n  def main(args: Array[String]): Unit = {\n    val cell = new Reference[Int]\n    cell.set(13)\n    println(\"Reference contains the half of \" + (cell.get * 2))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Sorting with Explicit Context Parameter Using 'using' in Scala 3\nDESCRIPTION: Shows how to sort a list of Address objects in Scala 3 by specifying an explicit context parameter with the using keyword on sortBy. It manually assigns an Ordering for a tuple of string values, which would normally be supplied implicitly. Required: scala.math.Ordering. This clarifies the new Scala 3 syntax for passing context parameters, taking as input a list of Address instances and yielding a sorted list, mainly for disambiguation or advanced customization.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-contextual-abstractions.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\naddresses.sortBy(address => (address.city, address.street))(using Ordering.Tuple2(Ordering.String, Ordering.String))\n```\n\n----------------------------------------\n\nTITLE: Lazy Evaluation with Side Effects - Scala\nDESCRIPTION: An example illustrating potential confusion when using lazy evaluation (like that of `Range` in older Scala versions) with operations that have side effects (like creating and starting actors). The actors are not started until the lazy collection is actually evaluated.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/views.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nval actors = for (i <- 1 to 10) yield actor { ... }\n```\n\n----------------------------------------\n\nTITLE: Defining a Companion Object for an Enumeration in Scala\nDESCRIPTION: Shows how to define a companion object for a Scala 3 enumeration (`Planet`), allowing for static-like methods and utility functions, such as a `main` method for demonstration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-adts-gadts.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nobject Planet:\n  def main(args: Array[String]) =\n    val earthWeight = args(0).toDouble\n    val mass = earthWeight / Earth.surfaceGravity\n    for (p <- values)\n      println(s\"Your weight on $p is ${p.surfaceWeight(mass)}\")\n```\n\n----------------------------------------\n\nTITLE: Define SubjectObserver Trait with Abstract Types (Scala 3)\nDESCRIPTION: Defines a generic `SubjectObserver` trait in Scala 3 using abstract type members (`S` for Subject, `O` for Observer) with upper bounds, and nested traits (`Subject`, `Observer`). The `Subject` trait includes a self-type annotation (`self: S =>`) to ensure subtypes of `Subject` are also subtypes of `S`. This version uses Scala 3's significant indentation syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\ntrait SubjectObserver:\n\n  type S <: Subject\n  type O <: Observer\n\n  trait Subject:\n    self: S =>\n      private var observers: List[O] = List()\n      def subscribe(obs: O): Unit =\n        observers = obs :: observers\n      def publish() =\n        for obs <- observers do obs.notify(this)\n\n  trait Observer:\n    def notify(sub: S): Unit\n```\n\n----------------------------------------\n\nTITLE: Initializing Mutable ArrayBuffers with Elements in Scala\nDESCRIPTION: Demonstrates creating mutable `ArrayBuffer` instances with initial elements using `ArrayBuffer(...)`, similar to `List` or `Vector` initialization. Requires prior import of `ArrayBuffer` and definition of `Person` class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_25\n\nLANGUAGE: Scala\nCODE:\n```\nval nums = ArrayBuffer(1, 2, 3)\nval people = ArrayBuffer(\n  Person(\"Bert\"),\n  Person(\"Ernie\"),\n  Person(\"Grover\")\n)\n```\n\n----------------------------------------\n\nTITLE: Type Inference with Polymorphic Methods and Generic Classes in Scala\nDESCRIPTION: Demonstrates Scala compiler's ability to infer type parameters in polymorphic methods and generic classes from the context and constructor arguments. The case class \"MyPair\" with generic types is instantiated without specifying type arguments, where Int and String are inferred. Similarly, the polymorphic method 'id' returns the same type as its input, allowing the compiler to infer the return type from the argument type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/type-inference.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ncase class MyPair[A, B](x: A, y: B)\nval p = MyPair(1, \"scala\") // type: MyPair[Int, String]\n\ndef id[T](x: T) = x\nval q = id(1)              // type: Int\n```\n\n----------------------------------------\n\nTITLE: Implementing an Asynchronous Method in Scala\nDESCRIPTION: An example of an asynchronous method that returns a Future in Scala. The AsyncMathLib.square method takes an integer and returns a Future containing the square of that integer. It requires an implicit/given ExecutionContext.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-asynchronous.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.concurrent.{ExecutionContext, Future}\n\nobject AsyncMathLib {\n  def square(x: Int)(implicit ec: ExecutionContext): Future[Int] =\n    Future(x * x)\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.concurrent.{ExecutionContext, Future}\n\nobject AsyncMathLib:\n  def square(x: Int)(using ExecutionContext): Future[Int] =\n    Future(x * x)\n```\n\n----------------------------------------\n\nTITLE: Creating Pizza-Related Enumerations in Scala\nDESCRIPTION: This snippet defines enumerations for pizza toppings, crust sizes, and crust types via sealed traits and case objects, providing a structured way to manage constants related to pizza attributes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/enumerations-pizza-class.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nsealed trait Topping\ncase object Cheese extends Topping\ncase object Pepperoni extends Topping\ncase object Sausage extends Topping\ncase object Mushrooms extends Topping\ncase object Onions extends Topping\n\nsealed trait CrustSize\ncase object SmallCrustSize extends CrustSize\ncase object MediumCrustSize extends CrustSize\ncase object LargeCrustSize extends CrustSize\n\nsealed trait CrustType\ncase object RegularCrustType extends CrustType\ncase object ThinCrustType extends CrustType\ncase object ThickCrustType extends CrustType\n```\n\n----------------------------------------\n\nTITLE: Defining a Method Accepting quotes.reflect.Term Parameter in Scala Macros\nDESCRIPTION: Shows the preferred way to define a macro helper method that directly manipulates the internal representation type `Term`. The method takes an implicit `Quotes` context followed by a `Term` parameter and uses reflection imports internally, enabling operations that require access to the lower-level Scala reflection trees.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/reflection.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef f(using Quotes)(term: quotes.reflect.Term): String =\n  import quotes.reflect.*\n  ...\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing Raw JSON Files in Scala using uJson and OS-Lib\nDESCRIPTION: This code demonstrates how to read a JSON file into a uJson object, modify its content, and write the updated JSON to a new file using OS-Lib for file operations. The example reads from 'raw.json' and writes to 'raw-updated.json'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-files.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// read a JSON file\nval json = ujson.read(os.read(os.pwd / \"raw.json\"))\n\n// modify the JSON content\njson(\"updated\") = \"now\"\n\n//write to a new file\nos.write(os.pwd / \"raw-updated.json\", ujson.write(json))\n```\n\n----------------------------------------\n\nTITLE: Creating a Heterogeneous List Using Scala Any Type in Scala\nDESCRIPTION: This Scala snippet demonstrates declaring a list that holds elements of various types all unified under the supertype Any. It initializes the list with a string, integer, character, boolean, and an anonymous function returning a string. The example showcases Scala's type hierarchy, where Any can represent any value or reference type, enabling mixed-type collections. It requires basic knowledge of Scala collections and function literals. The input is a list with heterogeneous elements, and the output is printing each element, preserving their original type representations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/unified-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval list: List[Any] = List(\n  \"Łancuch znaków\",\n  732,  // liczba całkowita\n  'c',  // znak\n  true, // wartość Boolowska\n  () => \"funkcja anonimowa zwracająca łańcuch znaków\"\n)\n\nlist.foreach(element => println(element))\n```\n\n----------------------------------------\n\nTITLE: Illustrating Binary Compatibility Issues with Method Overrides in Scala\nDESCRIPTION: This example demonstrates why adding method overrides can break forwards binary compatibility, showing how the bytecode signature of an overriding method differs from the one it overrides.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/drop-stdlib-forwards-bin-compat.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass A { def f: Object = \"\" }\nclass B extends A { override def f: String = \"\" }\n```\n\n----------------------------------------\n\nTITLE: Using a class template to generate additional class or object members via macro\nDESCRIPTION: This code demonstrates how a macro can modify or extend the template of a class or object by returning a modified `Template` syntax tree. It retrieves the existing code inside the template and appends generated code, enabling full rewriting of class or object content during macro expansion. This technique allows comprehensive code transformation within class definitions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/typemacros.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ntype H2Db(url: String) = macro impl\n\ndef impl(c: Context)(url: c.Expr[String]): c.Tree = {\n  val Template(_, _, existingCode) = c.enclosingTemplate\n  Template(..., existingCode ++ generateCode())\n}\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Implementation of PrefixMap Class for Patricia Trie\nDESCRIPTION: This snippet provides the Scala 3 version of the PrefixMap class for Patricia trie, utilizing new syntax features like 'then' and indentation-based braces. It implements similar functionality to the Scala 2 version, including get, withPrefix, addOne, subtractOne, iterator, and companion object with factory patterns, optimized for immutability and small collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_26\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.*\nimport scala.collection.mutable.{ GrowableBuilder, Builder }\n\nclass PrefixMap[A]\n  extends mutable.Map[String, A],\n    mutable.MapOps[String, A, mutable.Map, PrefixMap[A]],\n    StrictOptimizedIterableOps[(String, A), mutable.Iterable, PrefixMap[A]]:\n\n  private var suffixes: immutable.Map[Char, PrefixMap[A]] = immutable.Map.empty\n  private var value: Option[A] = None\n\n  def get(s: String): Option[A] =\n    if s.isEmpty then value\n    else suffixes.get(s(0)).flatMap(_.get(s.substring(1)))\n\n  def withPrefix(s: String): PrefixMap[A] =\n    if s.isEmpty then this\n    else\n      val leading = s(0)\n      suffixes.get(leading) match\n        case None =>\n          suffixes = suffixes + (leading -> empty)\n        case _ =>\n      suffixes(leading).withPrefix(s.substring(1))\n\n  def iterator: Iterator[(String, A)] =\n    (for v <- value.iterator yield (\"\", v)) ++\n      (for (chr, m) <- suffixes.iterator\n           (s, v) <- m.iterator yield (chr +: s, v))\n\n  def addOne(kv: (String, A)): this.type =\n    withPrefix(kv._1).value = Some(kv._2)\n    this\n\n  def subtractOne(s: String): this.type  =\n    if s.isEmpty then { val prev = value; value = None; prev }\n    else suffixes.get(s(0)).flatMap(_.remove(s.substring(1)))\n    this\n\n  // Overloading of transformation methods that should return a PrefixMap\n  def map[B](f: ((String, A)) => (String, B)): PrefixMap[B] =\n    strictOptimizedMap(PrefixMap.newBuilder, f)\n  def flatMap[B](f: ((String, A)) => IterableOnce[(String, B)]): PrefixMap[B] =\n    strictOptimizedFlatMap(PrefixMap.newBuilder, f)\n\n  // Override `concat` and `empty` methods to refine their return type\n  override def concat[B >: A](suffix: IterableOnce[(String, B)]): PrefixMap[B] =\n    strictOptimizedConcat(suffix, PrefixMap.newBuilder)\n  override def empty: PrefixMap[A] = PrefixMap()\n\n  // Members declared in scala.collection.mutable.Clearable\n  override def clear(): Unit = suffixes = immutable.Map.empty\n  // Members declared in scala.collection.IterableOps\n  override protected def fromSpecific(coll: IterableOnce[(String, A)]): PrefixMap[A] = PrefixMap.from(coll)\n  override protected def newSpecificBuilder: mutable.Builder[(String, A), PrefixMap[A]] = PrefixMap.newBuilder\n\n  override def className = \"PrefixMap\"\nend PrefixMap\n\nobject PrefixMap:\n  def empty[A] = new PrefixMap[A]\n\n  def from[A](source: IterableOnce[(String, A)]): PrefixMap[A] =\n    source match\n      case pm: PrefixMap[A @unchecked] => pm\n      case _ => (newBuilder ++= source).result()\n\n  def apply[A](kvs: (String, A)*): PrefixMap[A] = from(kvs)\n\n  def newBuilder[A]: mutable.Builder[(String, A), PrefixMap[A]] =\n    mutable.GrowableBuilder[(String, A), PrefixMap[A]](empty)\n\n  import scala.language.implicitConversions\n\n  implicit def toFactory[A](self: this.type): Factory[(String, A), PrefixMap[A]] =\n    new Factory[(String, A), PrefixMap[A]]:\n      def fromSpecific(it: IterableOnce[(String, A)]): PrefixMap[A] = self.from(it)\n      def newBuilder: mutable.Builder[(String, A), PrefixMap[A]] = self.newBuilder\n\n```\n\n----------------------------------------\n\nTITLE: Uploading a single file with sttp in Scala 2\nDESCRIPTION: This snippet demonstrates how to upload a single file over HTTP using the sttp client library in Scala 2. It shows importing the quick client, obtaining a Java Path from an OS-Lib path, setting the file as the request body for a POST request, sending the request to a specified URI, and printing the HTTP response code. Dependencies include sttp client4 and OS-Lib for path manipulation. The input is the file path, and output is the HTTP response code after upload.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/http-client-upload-file.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport sttp.client4.quick._\n\nval file: java.nio.file.Path = (os.pwd / \"image.png\").toNIO\nval response = quickRequest.post(uri\"https://example.com/\").body(file).send()\n\nprintln(response.code)\n// prints: 200\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Methods in Scala 3\nDESCRIPTION: This snippet demonstrates the definition of extension methods within Scala objects using the new Scala 3 syntax. Two classes `Foo` and `Bar` are extended with a method `meth()` in separate objects `A` and `B`. It highlights the concept of extension method syntax, which allows adding new methods to existing types without modifying their code. Dependencies include the Scala 3 compiler and language support for extension methods. The input is instances of class `Foo` or `Bar`, and the output demonstrates calling the extension method `meth` on these instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/multi-source-extension-overloads.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Foo\nclass Bar\n\nobject A:\n  extension (foo: Foo) def meth(): Foo = foo\n  def normalMeth(foo: Foo): Foo = foo\n\nobject B:\n  extension (bar: Bar) def meth(): Bar = bar\n  def normalMeth(bar: Bar): Bar = bar\n```\n\n----------------------------------------\n\nTITLE: Compiling Scala Source File Using Scala CLI\nDESCRIPTION: This shell snippet demonstrates how to compile a Scala source file called HelloWorld.scala using the Scala CLI `scala compile` command, which invokes the Scala compiler `scalac` internally. The `-d .` option directs the output class files into the current directory. The compilation produces Java class files representing the Scala classes, which can be later executed on the JVM. This approach is similar to Java compilation but generates JVM bytecode from Scala sources.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n> scala compile HelloWorld.scala -d .\n```\n\n----------------------------------------\n\nTITLE: Using a Generic Stack Instance with Int and Subtypes in Scala\nDESCRIPTION: This snippet demonstrates how to instantiate and use the generic Stack class with a concrete type Int, performing push and pop operations. It also shows how the same Stack class can be used with a hierarchy of classes (Fruit, Apple, Banana) to store polymorphic objects, illustrating Scala's type invariance behavior for generics. Dependencies are the Stack class and user-defined classes Fruit, Apple, and Banana. It highlights type safety enforced by the generic parameter and the ability to use subtypes with a common supertype. Input includes values of the specified type, output consists of popped elements consistent with the declared type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/generic-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval stack = new Stack[Int]\nstack.push(1)\nstack.push(2)\nprintln(stack.pop)  // prints 2\nprintln(stack.pop)  // prints 1\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Fruit\nclass Apple extends Fruit\nclass Banana extends Fruit\n\nval stack = new Stack[Fruit]\nval apple = new Apple\nval banana = new Banana\n\nstack.push(apple)\nstack.push(banana)\n```\n\n----------------------------------------\n\nTITLE: Creating Symbol Literal Quasiquote - Scala\nDESCRIPTION: Shows the specific representation of a symbol literal when created with a quasiquote. Unlike other literals, `q\"'symbol\"` results in a `scala.Symbol(\"symbol\")` tree, not a `Literal` tree.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val foo = q\"'foo\"\nfoo: universe.Tree = scala.Symbol(\"foo\")\n```\n\n----------------------------------------\n\nTITLE: Building Strings with StringBuilder in Scala 3\nDESCRIPTION: Illustrates creating a `StringBuilder` in Scala 3 using the companion object's `apply` method (`StringBuilder()`), appending a character with `+=`, appending a string with `++=`, and converting to a `String` using `toString`. Provides an efficient way to build strings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-mutable-collection-classes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nscala> val buf = StringBuilder()\nbuf: StringBuilder = \nscala> buf += 'a'\nres38: buf.type = a\nscala> buf ++= \"bcdef\"\nres39: buf.type = abcdef\nscala> buf.toString\nres41: String = abcdef\n```\n\n----------------------------------------\n\nTITLE: Defining and Inlining Methods with Private State in Scala\nDESCRIPTION: Illustrates how inlining interacts with private fields and methods in Scala. The 'inc' method directly modifies a private field 'x' and can only be safely inlined within the class due to JVM access restrictions. Shows how the inliner handles access to private members and why inlining from outside the class may lead to IllegalAccessError if attempted. No additional dependencies required; inputs/outputs are the integer return from method 'inc'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/compiler-options/optimizer.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass C {\n  private[this] var x = 0\n  @inline final def inc(): Int = { x += 1; x }\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Macro Definition and Implementation in Scala\nDESCRIPTION: This code defines a generic macro within a class, where the macro method 'map' uses type parameters and references a macro implementation with compatible type tags. It showcases how to declare a macro with type parameters and the use of context bounds (WeakTypeTag) for type information passing during macro expansion, enabling flexible, type-safe metaprogramming constructs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/overview.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass Queryable[T] {\n def map[U](p: T => U): Queryable[U] = macro QImpl.map[T, U]\n}\n\nobject QImpl {\n def map[T: c.WeakTypeTag, U: c.WeakTypeTag]\n        (c: Context)\n        (p: c.Expr[T => U]): c.Expr[Queryable[U]] = ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ForkJoinTaskSupport for Scala Parallel Collections in Scala\nDESCRIPTION: This snippet demonstrates importing Scala parallel collections, creating a parallel mutable array, assigning a ForkJoinTaskSupport instance with a fork-join pool limited to parallelism level 2, and then applying a map operation. It showcases how to configure parallelism on a collection using the fork-join framework provided in Scala. Dependencies include scala.collection.parallel and scala.concurrent.forkjoin.ForkJoinPool classes. The input is a ParArray[Int] and the output is a ParArray[Int] processed in parallel with incremented values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/parallel-collections/configuration.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.parallel._\n\nval pc = mutable.ParArray(1, 2, 3)\npc.tasksupport = new ForkJoinTaskSupport(new scala.concurrent.forkjoin.ForkJoinPool(2))\npc map { _ + 1 }\n```\n\n----------------------------------------\n\nTITLE: Eta-Expansion of Monomorphic Methods in Scala\nDESCRIPTION: Shows how eta-expansion of a monomorphic method can trigger polymorphic eta-expansion recursively when assigned to a polymorphic function type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/polymorphic-eta-expansion.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval voly: Int => [T] => T => T = poly\n// poly expands to: (x: Int) => [T] => (y: T) => poly(x)[T](y)\n```\n\n----------------------------------------\n\nTITLE: Formatting Curly Braces in Scala Function Definitions\nDESCRIPTION: Demonstrates the required Scala style where the opening curly brace ({) must be placed on the same line as the declaration (e.g., function definition). This convention avoids potential parsing issues related to Scala's semicolon inference, which can occur with GNU-style (brace on the next line).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/nested-blocks.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef foo = {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: 値クラスの制約例：複数パラメータの禁止\nDESCRIPTION: 値クラスは厳密に1つのpublicな`val`パラメータのみを持つ必要があり、複数のパラメータはエラーとなる例。コンストラクタパラメータが`val`でなければならず、複数`val`パラメータを持つ`Complex`クラスはコンパイルエラーになる。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/value-classes.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nclass Complex(val real: Double, val imag: Double) extends AnyVal\n```\n\n----------------------------------------\n\nTITLE: Rich Iterator Trait in Scala 2\nDESCRIPTION: A trait that extends AbsIterator and adds a foreach method to apply a function to each element in the iterator. This adds higher-order function capabilities to any iterator.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/mixin-class-composition.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ntrait RichIterator extends AbsIterator {\n  def foreach(f: T => Unit): Unit = while (hasNext) f(next())\n}\n```\n\n----------------------------------------\n\nTITLE: Removing First N Elements from Buffer in Scala\nDESCRIPTION: Removes the first 'n' elements from the beginning of the buffer 'buf'. This is an efficient way to discard elements from the start.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/seqs.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nbuf trimStart n\n```\n\n----------------------------------------\n\nTITLE: Doubling List Elements Using a for Comprehension in Scala\nDESCRIPTION: Shows the use of a for-comprehension to produce a new list where each integer is doubled. Requires a defined List[Int] named ints. Output: List[Int] with each element multiplied by two. No external libraries required. Serves as another idiomatic approach to mapping collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/anonymous-functions.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval doubledInts = for (i <- ints) yield i * 2\n```\n\n----------------------------------------\n\nTITLE: Constructing and Traversing a Complex Tree with Pattern Matching\nDESCRIPTION: Constructs a more complex AST representing nested operations (`x.$plus(2).$plus(3)`). It then applies the direct assignment pattern matching (`val Apply(...) = tree`) to extract the outermost `Apply` node's components, demonstrating how pattern matching works on the top level of a complex tree and how to inspect the raw structure of the extracted components using `showRaw`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/reflection/symbols-trees-types.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n\nval tree = Apply(Select(Apply(Select(Ident(TermName(\"x\")), TermName(\"$plus\")), List(Literal(Constant(2)))), TermName(\"$plus\")), List(Literal(Constant(3))))\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval Apply(fun, arg :: Nil) = tree\n```\n\nLANGUAGE: Scala\nCODE:\n```\nshowRaw(fun)\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Generated unapply Method\nDESCRIPTION: Shows the option-less unapply method signature that Scala 3 automatically generates for case classes, returning the original instance directly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-other-changes.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nobject Location {\n  def unapply(location: Location): Location = location\n}\n```\n\n----------------------------------------\n\nTITLE: Executing a List Loop in Scala 2 REPL\nDESCRIPTION: Shows the execution and output of a `for` loop iterating over a `List` within the Scala 2 REPL. Demonstrates the immediate evaluation and printing of each element to standard output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nscala> for (name <- names) println(name)\nJoel\nChris\nEd\n```\n\n----------------------------------------\n\nTITLE: Declaring List Types Explicitly\nDESCRIPTION: Shows how to explicitly declare the type of a List when initializing it with values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval ints: List[Int] = List(1, 2, 3)\nval names: List[String] = List(\"Joel\", \"Chris\", \"Ed\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Implicit Parameter Resolution Failure in Scala 2\nDESCRIPTION: Attempts to call the generic 'max' function defined previously with 'Boolean' arguments. This code demonstrates a compile-time error because Scala 2 cannot find an implicit 'Comparator[Boolean]' instance in the scope or companion object, illustrating the failure case of implicit resolution.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/implicit-parameters.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// does not compile:\nprintln(max(false, true))\n//         ^\n//     error: could not find implicit value for parameter comparator: Comparator[Boolean]\n```\n\n----------------------------------------\n\nTITLE: Implementing Zero-Cost Nullable Reference Types via Opaque Types in Scala\nDESCRIPTION: This snippet introduces an opaque Nullable[A] type to represent a reference value that may be null, providing a set of extension methods for functional-style null handling (e.g., exists, filter, flatMap). The design leverages the absence of wrappers at runtime for efficiency, and restricts to A <: AnyRef, avoiding nested Nullable. Inputs: possibly-null references, user functions; outputs: wrapped nullable values or Option. Dependencies: Scala 3. Limitation: Not suitable for value types due to A <: AnyRef bound.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/opaque-types.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\npackage object nullable {\n  opaque type Nullable[A <: AnyRef] = A\n\n  object Nullable {\n    def apply[A <: AnyRef](a: A): Nullable[A] = a\n\n    implicit class NullableOps[A <: AnyRef](na: Nullable[A]) {\n      def exists(p: A => Boolean): Boolean =\n        na != null && p(na)\n      def filter(p: A => Boolean): Nullable[A] =\n        if (na != null && p(na)) na else null\n      def flatMap[B <: AnyRef](f: A => Nullable[B]): Nullable[B] =\n        if (na == null) null else f(na)\n      def forall(p: A => Boolean): Boolean =\n        na == null || p(na)\n      def getOrElse(a: => A): A =\n        if (na == null) a else na\n      def map[B <: AnyRef](f: A => B): Nullable[B] =\n        if (na == null) null else f(na)\n      def orElse(na2: => Nullable[A]): Nullable[A] =\n        if (na == null) na2 else na\n      def toOption: Option[A] =\n        Option(na)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Trait with Concrete Implementation in Scala 2\nDESCRIPTION: This code extends the Showable trait in Scala 2 by adding a concrete method showHtml, which wraps the result of show in HTML paragraph tags. The method show remains abstract, requiring subclass implementation. No external dependencies are necessary, and this pattern enables partial implementations in traits.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait Showable {\n  def show: String\n  def showHtml = \"<p>\" + show + \"</p>\"\n}\n```\n\n----------------------------------------\n\nTITLE: メインメソッドの定義とプログラム開始点指定 - Scala\nDESCRIPTION: Java仮想マシンがプログラムの開始点として呼び出すmainメソッドを、引数として文字列配列を受け取りUnitを返すstatic相当のメソッドとしてobject Main内に定義する例です。標準的なHelloメッセージを出力します。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\nobject Main {\n  def main(args: Array[String]): Unit =\n    println(\"Hello, Scala developer!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Numeric Values with Type Inference in Scala\nDESCRIPTION: Demonstrates Scala's default numeric literal inference where integral literals default to Int and floating literals default to Double without explicit type annotations. Highlights concise variable declarations leveraging Scala's type inference capabilities.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/first-look-at-types.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval i = 123   // по умолчанию Int\nval x = 1.0   // по умолчанию Double\n```\n\n----------------------------------------\n\nTITLE: Functions with Multiple Parameters and No Parameters in Scala - Scala\nDESCRIPTION: Demonstrates defining functions that accept multiple parameters as well as functions that accept no parameters at all. Shows how to call such functions correctly using the appropriate argument lists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/tour/basics.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval add = (x: Int, y: Int) => x + y\nprintln(add(1, 2)) // 3\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval getTheAnswer = () => 42\nprintln(getTheAnswer()) // 42\n```\n\n----------------------------------------\n\nTITLE: Defining an Implicit Macro Materializer for a Type Class (Scala)\nDESCRIPTION: Introduces the concept of using an implicit macro to automatically generate type class instances. An implicit `def` named `materializeShowable` is defined within the companion object of the `Showable` trait. This macro will be invoked by the compiler during implicit search when an explicit instance for `Showable[T]` is not found.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/implicits.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntrait Showable[T] { def show(x: T): String }\nobject Showable {\n  implicit def materializeShowable[T]: Showable[T] = macro ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using Package-Level Members with Wildcard Import in Scala 2\nDESCRIPTION: Demonstrates importing of package-level members `planted` and `showFruit` alongside the class `Fruit` using a wildcard import in Scala 2. Implements an object with a main method that iterates over the planted fruits and invokes the showFruit method for each. This snippet shows compatibility and usage of package objects in client code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/package-objects.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport gardening.fruits._\n\nobject PrintPlanted {\n  def main(args: Array[String]): Unit = {\n    for (fruit <- planted) {\n      showFruit(fruit)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Current Problematic Expansion of Context Bounds\nDESCRIPTION: Illustration of how the current context bound expansion mechanism fails when a parameter type references the bound instance, creating an invalid forward reference.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\n  def run[P](x: p.Input)(using p: Parser[P]): p.Result\n```\n\n----------------------------------------\n\nTITLE: Defining an Extractor Object with 'unapply' Method in Scala\nDESCRIPTION: This code defines an extractor object 'Twice' with 'apply' and 'unapply' methods. The 'apply' method acts as a constructor, while 'unapply' enables pattern matching to recognize even numbers and extract half of the value. The example also includes a usage in pattern matching within an object extending 'App'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/extractor-objects.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject Twice {\n  def apply(x: Int): Int = x * 2\n  def unapply(z: Int): Option[Int] = if (z%2 == 0) Some(z/2) else None\n}\n\nobject TwiceTest extends App {\n  val x = Twice(21)\n  x match { case Twice(n) => Console.println(n) } // imprime 21\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a No-Parameter Function for Testing Higher-Order Execution in Scala\nDESCRIPTION: Defines a simple method helloWorld with no input parameters and returning Unit that prints \"Hello, world\" to the console. This function is designed to be passed to the executeNTimes higher-order method for repeated execution testing. It uses standard Scala printing and requires no additional deps. Inputs none, output is Unit after console print.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-hofs.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\n// тип метода - `() => Unit`\ndef helloWorld(): Unit = println(\"Hello, world\")\n```\n\n----------------------------------------\n\nTITLE: Cutting a Release via Git Tag and Push - Bash\nDESCRIPTION: This Bash command sequence demonstrates tagging a release version in Git and pushing it to the remote repository. When used in a repository configured with a CI-based release workflow (such as GitHub Actions running sbt ci-release on tag pushes), this triggers the automated CI pipeline that builds and publishes the release. Inputs are the chosen version number; outputs are the creation and activation of the tag-triggered publication process.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ git tag v0.2.0\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ git push origin v0.2.0\n```\n\n----------------------------------------\n\nTITLE: Illustrating Declaration Normalization for Type Search (Scala)\nDESCRIPTION: Shows a `Num` class and various functions/vals defined with different parameter list styles (curried, uncurried, vals, defs, extensions). This snippet demonstrates how Inkuire normalizes these varied declarations internally so they can all be matched by a single, unified type signature query (`Num => Int => Int => Int`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/search-engine.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass Num():\n  def a(i: Int, j: Int): Int\n  def b(i: Int)(j: Int): Int\n  def c(i: Int): (Int => Int)\n  val d: Int => Int => Int\n  val e: Int => Int => Int\n  val f: (Int, Int) => Int\nend Num\n\ndef g(i: Num, j: Int, k: Int): Int\nextension (i: Num) def h(j: Int, k: Int): Int\ndef i(i: Num, j: Int)(k: Int): Int\nextension (i: Num) def j(j: Int)(k: Int): Int\n...\n```\n\n----------------------------------------\n\nTITLE: Cross-Compatible Compiler Plugin/Option Configuration (Scala)\nDESCRIPTION: This snippet provides an example of configuring build settings in `build.sbt` to be cross-compatible between Scala 2.13 and Scala 3. It shows how to conditionally add a compiler plugin dependency for Scala 2 and a corresponding compiler option for Scala 3 based on the current `scalaVersion`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/scala3-migrate.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\n// add kind-projector as a dependency on Scala 2\nlibraryDependencies ++= {\n  if (scalaVersion.value.startsWith(\"3.\")) Seq.empty\n  else Seq(\n    compilerPlugin((\"org.typelevel\" %% \"kind-projector\" % \"0.13.2\").cross(CrossVersion.full))\n  )\n},\n// activate kind-projector in Scala 3\nscalacOptions ++= {\n  if (scalaVersion.value.startsWith(\"3.\")) Seq(\"-Ykind-projector\")\n  else Seq.empty\n}\n```\n\n----------------------------------------\n\nTITLE: Using TypeRepr and asType to Reflect Static Types in Scala Macros\nDESCRIPTION: Demonstrates how to obtain a `TypeRepr` from a type `T` given an implicit `Type[T]` using `TypeRepr.of[T]`. It further uses pattern matching with `asType` and the `'[t]` existential pattern to work with a type whose static identity is not known until runtime. This snippet is typically used to generate code fragments dependent on the reflected type inside macros.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/reflection.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef g[T: Type](using Quotes) =\n  import quotes.reflect.*\n  val tpe: TypeRepr = TypeRepr.of[T]\n  tpe.asType match\n    case '[t] => '{ val x: t = ${...} }\n  ...\n```\n\n----------------------------------------\n\nTITLE: Использование ковариантного типажа Producer в Scala 2 и 3\nDESCRIPTION: Функция makeTwo принимает параметр p типа Producer[Buyable], вызывая метод make дважды и складывая цены результатов. Пример показывает, что можно безопасно передавать Producer[Book] там, где ожидается Producer[Buyable], благодаря ковариантности. Параметр make возвращает значение производного типа Book, что расширяет совместимость и повторно использовать интерфейс Buyable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-variance.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ndef makeTwo(p: Producer[Buyable]): Int =\n  p.make.price + p.make.price\n```\n\n----------------------------------------\n\nTITLE: Using an Implicit TypeTag Parameter to Access Type Arguments at Runtime (Scala)\nDESCRIPTION: Shows a generic method paramInfo with an implicit TypeTag parameter, allowing runtime inspection of the type arguments of the input. The method extracts type arguments from the TypeTag's type representation (tpe) by pattern matching on TypeRef and prints them. This requires importing scala.reflect.runtime.universe._ for TypeTag and TypeRef, and implicit evidence of TypeTag for type parameter T. Inputs are generic and output is a console print of type argument information.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/typetags-manifests.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n\ndef paramInfo[T](x: T)(implicit tag: TypeTag[T]): Unit = {\n  val targs = tag.tpe match { case TypeRef(_, _, args) => args }\n  println(s\"type of $x has type arguments $targs\")\n}\n```\n\n----------------------------------------\n\nTITLE: 数组堆栈（ArrayStack）示例\nDESCRIPTION: 说明使用ArrayStack作为高效的可变堆栈实现，支持快速索引操作，适合对性能敏感的场景。依赖Scala collection.mutable包中的ArrayStack。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/concrete-mutable-collection-classes.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\n// 具体代码示例未提供，仅为说明\n```\n\n----------------------------------------\n\nTITLE: Defining Command Structure for Text Adventure Game in Scala\nDESCRIPTION: Defines a Scala `enum` `Word` representing command tokens (like `Get`, `North`, `Item`) and a `case class` `Command` holding a list of `Word`s, used to structure parsed player input in a text adventure game example. This setup illustrates the context for pattern matching scenarios discussed in the proposal.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/alternative-bind-variables.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nenum Word\n  case Get, North, Go, Pick, Up\n  case Item(name: String)\n\n  case class Command(words: List[Word])\n```\n\n----------------------------------------\n\nTITLE: Defining Asynchronous Method Returning Scala Future in Scala\nDESCRIPTION: Defines a method called `slowlyDouble` that takes an integer and a delay in milliseconds, returning a Future[Int] which completes after sleeping for the delay and then doubling the input value. It requires an implicit or explicit ExecutionContext to run the Future. This method simulates a slow, computation-intensive asynchronous task, demonstrating how to create Futures for offloading work from the main thread. The input parameters are `x` (the number to double) and `delay` (the wait time in milliseconds). The output is a Future wrapping the doubled value. Usage context includes assigning the returned Future to a variable to check completion status and retrieve the result asynchronously.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/concurrency.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\n// моделируем медленно работающий метод\ndef slowlyDouble(x: Int, delay: Long): Future[Int] = Future {\n  sleep(delay)\n  x * 2\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Throw Quasiquotes - Scala\nDESCRIPTION: Demonstrates pattern matching on a `throw` expression using quasiquotes. The pattern `q\"throw $expr\"` matches a throw statement and extracts the tree representing the throwable expression into the `$expr` variable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_26\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"throw $expr\" = thr\nexpr: universe.Tree = new Exception()\n```\n\n----------------------------------------\n\nTITLE: Adding @throws Annotation in Scala for Java IOException Handling\nDESCRIPTION: This Scala snippet defines a class Reader that opens a file and reads it using a BufferedReader. The 'read' method is annotated with @throws(classOf[IOException]) to signal that it may throw an IOException. This is essential for interoperability with Java programs, which require checked exceptions to be declared. Dependencies include java.io.BufferedReader, java.io.FileReader, and java.io.IOException from the Java standard library. The input is a filename string provided at construction, and the output is a character integer read from the file. Without the annotation, Java callers will fail to compile if they try to handle the IOException, demonstrating the purpose of the annotation as a bridge between Scala and Java exception handling.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/annotations.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\npackage examples\nimport java.io._\nclass Reader(fname: String) {\n  private val in = new BufferedReader(new FileReader(fname))\n  @throws(classOf[IOException])\n  def read() = in.read()\n}\n```\n\n----------------------------------------\n\nTITLE: Restrictions on defining implicit classes in Scala\nDESCRIPTION: This snippet lists key restrictions for implicit classes: they must be defined within a trait, class, or object; they can only have one non-implicit constructor argument; and they must not be ambiguous with other term members, including avoiding being case classes or having ambiguous implicit defs. These constraints ensure proper implicit resolution and avoid ambiguity conflicts.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/implicit-classes.md#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nobject Helpers {\n   implicit class RichInt(x: Int) // OK!\n}\nimplicit class RichDouble(x: Double) // BAD!\n\n// Only one non-implicit argument allowed:\nimplicit class RichDate(date: java.time.LocalDate) // OK!\nimplicit class Indexer[T](collection: Seq[T], index: Int) // BAD!\nimplicit class Indexer[T](collection: Seq[T])(implicit index: Index) // OK!\n\n// Ambiguity restrictions:\nobject Bar\nimplicit class Bar(x: Int) // BAD!\n\nval x = 5\nimplicit class x(y: Int) // BAD!\n\nimplicit case class Baz(x: Int) // BAD!\n```\n\n----------------------------------------\n\nTITLE: Adding a Type Parameter to the `map` Signature in Scala\nDESCRIPTION: Updates the `map` method signature to include the generic type parameter `A` using square brackets `[]`. This parameter declaration is necessary before the parameter list when using type parameters. The function `f` transforms an `Int` to type `A`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-write-map-function.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef map[A](f: (Int) => A)\n```\n\n----------------------------------------\n\nTITLE: Instantiating Semigroup for Primitive Types in Scala\nDESCRIPTION: Provides implicit Semigroup instances for primitive types Int, String, and Unit. Each instance implements the combine method with type-appropriate logic: integer addition, string concatenation, and unit value. Requires only the Semigroup trait and demonstrates basic implicit instance construction.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject Semigroup {\n  implicit val intSemigroup: Semigroup[Int] =\n    new Semigroup[Int] {\n      def combine(x: Int, y: Int): Int = x + y\n    }\n\n  implicit val stringSemigroup: Semigroup[String] =\n    new Semigroup[String] {\n      def combine(x: String, y: String): String = x + y\n    }\n\n  implicit val unitSemigroup: Semigroup[Unit] =\n    new Semigroup[Unit] {\n      def combine(x: Unit, y: Unit): Unit = ()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Compile-Time Type Ascription in Scala\nDESCRIPTION: Illustrates type ascription syntax `x: Type` (e.g., `x: String`) in Scala. This informs the compiler that the expression `x` is expected to have the type `String`. It's a compile-time check and doesn't perform a runtime cast.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/cheatsheets/index.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nx: String\n```\n\n----------------------------------------\n\nTITLE: Using Pizza Extension Methods with Fluent API in Scala 2 and 3\nDESCRIPTION: Shows the usage of Pizza extension methods to construct and modify a Pizza instance by chaining calls to add toppings, update crust, and calculate the price. This snippet is valid for Scala 2 (with implicit classes) and Scala 3 (with extension methods), demonstrating the fluency and immutability of the resultant operations returning updated Pizza instances and a Double price value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-fp.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nPizza(Small, Thin, Seq(Cheese))\n  .addTopping(Pepperoni)\n  .updateCrustType(Thick)\n  .price\n```\n\n----------------------------------------\n\nTITLE: Constructing Tuples with Scala Quasiquotes\nDESCRIPTION: Demonstrates creating a `Tuple2` AST using quasiquote syntax `q\"(a, b)\"`. This syntax maps directly to `scala.TupleN` calls.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\nscala> val tup = q\"(a, b)\"\ntup: universe.Tree = scala.Tuple2(a, b)\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing Scala Objects as JSON Files in Scala 2\nDESCRIPTION: This example shows how to read a JSON file into a Scala case class, modify the object, and write it back to a new JSON file using uPickle and OS-Lib. It demonstrates explicit ReadWriter derivation using macroRW in Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-files.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport upickle.default._\n\ncase class PetOwner(name: String, pets: List[String])\nimplicit val ownerRw: ReadWriter[PetOwner] = macroRW\n\n// read a PetOwner from a JSON file\nval petOwner: PetOwner = read[PetOwner](os.read(os.pwd / \"pet-owner.json\"))\n\n// create a new PetOwner\nval petOwnerUpdated = petOwner.copy(pets = \"Toolkitty\" :: petOwner.pets)\n\n// write to a new file\nos.write(os.pwd / \"pet-owner-updated.json\", write(petOwnerUpdated))\n```\n\n----------------------------------------\n\nTITLE: Declaring Scala Methods with LowerCamelCase Naming Conventions\nDESCRIPTION: Shows method naming convention in Scala using lower camel case for textual method names. Includes examples of accessors and mutators following Scala idioms without the Java `get`/`set` prefixes. Mutators use a special `_=` suffix to enable assignment-style method calls. Boolean accessors may prefix with `is` but only if no mutator exists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/naming-conventions.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass Foo {\n  def bar = ...\n\n  def bar_=(bar: Bar) {\n    ...\n  }\n\n  def isBaz = ...\n}\n\nval foo = new Foo\nfoo.bar             // accessor\nfoo.bar = bar2      // mutator\nfoo.isBaz           // boolean property\n```\n\n----------------------------------------\n\nTITLE: Declaring Nested Packages Using Scala 3 Syntax\nDESCRIPTION: This snippet provides the Scala 3 syntax for declaring nested packages and classes. It establishes a \"users\" package with two sub-packages: \"administrators\" and \"normalusers\", each containing their own \"NormalUser\" class. No external dependencies are needed, and the colon-based syntax improves readability and reduces braces. Parameters are not applicable, and outputs are scoped classes within nested namespaces.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/packages-and-imports.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\npackage users:\n  package administrators:\n    class NormalUser\n\n  package normalusers:\n    class NormalUser\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Case Class in Scala\nDESCRIPTION: Defines a simple `Circle` case class with `x`, `y`, and `radius` parameters. This class serves as the target type for demonstrating extension methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-extension-methods.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Circle(x: Double, y: Double, radius: Double)\n```\n\n----------------------------------------\n\nTITLE: Mapping Over Elements of an Iterator to Transform Data in Scala\nDESCRIPTION: This snippet shows how to iterate over a sequence of strings using an iterator and transform each string to its length by applying the map method. It then prints the transformed elements. The example also exposes the consumption property: mapping advances the source iterator to the end. Dependencies: Scala collections. Input: an iterator of strings. Output: transformed iterator of integers, each printed to STDOUT. Limitation: the original iterator is exhausted after map; next will throw an exception.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/iterators.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval it = Iterator(\"a\", \"number\", \"of\", \"words\")\nit.map(_.length)\nres1 foreach println\n```\n\n----------------------------------------\n\nTITLE: Implementing a Generic Stack Class in Scala 3\nDESCRIPTION: A generic Stack implementation in Scala 3 using the new syntax. This class can store elements of any type and provides push, peek, and pop operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/generic-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass Stack[A]:\n  private var elements: List[A] = Nil\n  def push(x: A): Unit =\n    elements = x :: elements\n  def peek: A = elements.head\n  def pop(): A =\n    val currentTop = peek\n    elements = elements.tail\n    currentTop\n```\n\n----------------------------------------\n\nTITLE: Invalid Type Casting Example in Scala\nDESCRIPTION: This non-compiling example illustrates that type casting is unidirectional in Scala. While Long can be converted to Float, the reverse conversion is not automatically allowed without explicit casting.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/unified-types.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval x: Long = 987654321\nval y: Float = x.toFloat  // 9.8765434E8\nval z: Long = y  // обратно не подходит\n```\n\n----------------------------------------\n\nTITLE: Creating and Using SortedSet with Custom Order in Scala\nDESCRIPTION: This snippet demonstrates how to create an empty TreeSet with a specified ordering using Scala's Ordering.fromLessThan method, and then initializes the set with default ordering based on type. It highlights how to build ordered sets and a sample sequence of adding elements, showcasing how elements are stored in sorted order given the comparator.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/sets.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval myOrdering = Ordering.fromLessThan[String](_ > _)\nTreeSet.empty(myOrdering)\nTreeSet.empty[String]\nval res = TreeSet.empty[String]\nres + \"one\" + \"two\" + \"three\" + \"four\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Condensed Single-Line Method in Scala (2 & 3)\nDESCRIPTION: Demonstrates how the multiline `addThenDouble` method logic can be condensed into a single line expression `(a + b) * 2`. This highlights that the body of a method is an expression that evaluates to the return value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ndef addThenDouble(a: Int, b: Int): Int = (a + b) * 2\n```\n\n----------------------------------------\n\nTITLE: Defining Alternate Java Names for Scala Methods\nDESCRIPTION: Shows how to use the `@targetName` annotation in Scala (versions 2 and 3) to provide an alternative, Java-friendly name ('add') for a Scala method that uses a symbolic name ('+'). This allows the method to be easily called from Java.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/interacting-with-java.md#_snippet_4\n\nLANGUAGE: Scala 2\nCODE:\n```\nimport scala.annotation.targetName\n\nobject Adder {\n  @targetName(\"add\") def +(a: Int, b: Int) = a + b\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nimport scala.annotation.targetName\n\nobject Adder:\n  @targetName(\"add\") def +(a: Int, b: Int) = a + b\n```\n\n----------------------------------------\n\nTITLE: Behavior of `s` Interpolator with Escape Sequences in Scala\nDESCRIPTION: Demonstrates how the `s` string interpolator in Scala processes standard Java/Scala escape sequences like `\\n`. The escape sequence is converted into its corresponding character (a newline in this case).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nscala> s\"a\\nb\"\nres0: String = \na\nb\n```\n\n----------------------------------------\n\nTITLE: Defining a Value Class for Type Safety in Scala\nDESCRIPTION: Defines a value class `Meter` wrapping a `Double` to represent a distance. This provides compile-time type safety (distinguishing Meters from raw Doubles) while allowing the runtime to potentially use the primitive `Double` directly, avoiding object allocation for instances of `Meter` in many cases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass Meter(val value: Double) extends AnyVal {\n  def +(m: Meter): Meter = new Meter(value + m.value)\n}\n```\n\n----------------------------------------\n\nTITLE: ClassTagを活用したジェネリック配列作成の修正版 - Scala\nDESCRIPTION: ClassTagを暗黙パラメータやcontext boundとして利用することで、ジェネリック型Tに対応した正しい配列を動的に作成する修正版のevenElemsメソッド例です。ClassTagにより実行時型情報が提供され、Arrayの正しいインスタンス生成が可能になります。依存はscala.reflect.ClassTagで、使用者はClassTagを暗黙的に供給する必要があります。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/arrays.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect.ClassTag\n\ndef evenElems[T: ClassTag](xs: Vector[T]): Array[T] = {\n  val arr = new Array[T]((xs.length + 1) / 2)\n  for (i <- 0 until xs.length by 2)\n    arr(i / 2) = xs(i)\n  arr\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Methods of Complex Class Instance in Scala\nDESCRIPTION: Demonstrates creating an instance of the Complex class and accessing its imaginary part by calling the im() method. The snippet uses the main function inside an object ComplexNumbers, printing the imaginary part with string concatenation. It shows the calling syntax requiring parentheses () for methods with zero parameters. Input is the Complex instance; output is a console print of the imaginary value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tutorials/scala-for-java-programmers.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nobject ComplexNumbers {\n  def main(args: Array[String]): Unit = {\n    val c = new Complex(1.2, 3.4)\n    println(\"imaginary part: \" + c.im())\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Map Method in Scala Collections\nDESCRIPTION: Examples of using the map method to transform each element in a collection, demonstrating how it applies a function to each element and returns a new collection with the results.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-methods.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nscala> val doubles = oneToTen.map(_ * 2)\ndoubles: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> val doubles = oneToTen.map(i => i * 2)\ndoubles: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> val capNames = names.map(_.capitalize)\ncapNames: List[String] = List(Adam, Brandy, Chris, David)\n\nscala> val nameLengthsMap = names.map(s => (s, s.length)).toMap\nnameLengthsMap: Map[String, Int] = Map(adam -> 4, brandy -> 6, chris -> 5, david -> 5)\n\nscala> val isLessThanFive = oneToTen.map(_ < 5)\nisLessThanFive: List[Boolean] = List(true, true, true, true, false, false, false, false, false, false)\n```\n\n----------------------------------------\n\nTITLE: Reflecting Methods and Invoking Them Using MethodMirror - Scala\nDESCRIPTION: Obtains a MethodSymbol for method 'x' of class 'C' using the reflective universe, then reflects it to a MethodMirror from an InstanceMirror. Calling the MethodMirror invokes the method reflectively. Inputs: an InstanceMirror 'im' and a MethodSymbol for 'x'; output: method result (here, 2). Dependencies include scala.reflect.runtime.universe.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/environment-universes-mirrors.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval methodX = ru.typeOf[C].decl(ru.TermName(\"x\")).asMethod\nval mm = im.reflectMethod(methodX)\nmm()\n```\n\n----------------------------------------\n\nTITLE: Comparing Trait to Interface Java\nDESCRIPTION: Provides the equivalent definition of the `TailWagger` interface in Java. This snippet highlights the similarity between Scala traits when used purely as interfaces and traditional Java interfaces, both defining abstract methods without implementation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/traits-interfaces.md#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\npublic interface TailWagger {\n    public void startTail();\n    public void stopTail();\n}\n```\n\n----------------------------------------\n\nTITLE: Using Opaque Type Logarithm and Its Operations in Scala\nDESCRIPTION: Demonstrates valid usage scenarios importing the opaque type Logarithm and using its factory methods and extension operations for construction, addition, and conversion back to Double. Also illustrates an unsafe cast to Logarithm. The code respects the opacity rules by lifting/unlifting via the companion API.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/opaque-types.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\npackage object usesites {\n  import opaquetypes._\n  val l = Logarithm(1.0)\n  val l2 = Logarithm(2.0)\n  val l3 = l + l2\n  val d = l3.toDouble\n  val l3: Logarithm = (1.0).asInstanceOf[Logarithm]\n}\n```\n\n----------------------------------------\n\nTITLE: How 's' Interpolator Processes Escape Sequences in Scala\nDESCRIPTION: Demonstrates that the `s` interpolator processes standard string escape sequences like `\\n` (newline), interpreting them as special characters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/string-interpolation.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nscala> s\"a\\nb\"\nres0: String = \na\nb\n```\n\n----------------------------------------\n\nTITLE: Creating Empty Mutable ArrayBuffers in Scala\nDESCRIPTION: Demonstrates how to create empty, mutable `ArrayBuffer` instances for different types (String, Int, custom Person class) using `ArrayBuffer[Type]()`. Requires prior import of `ArrayBuffer`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\nvar strings = ArrayBuffer[String]()\nvar ints = ArrayBuffer[Int]()\nvar people = ArrayBuffer[Person]()\n```\n\n----------------------------------------\n\nTITLE: 初始化和使用 ArrayBuffer（Scala）\nDESCRIPTION: 该代码示例展示如何创建一个空的ArrayBuffer，添加元素，并将其转换为数组。ArrayBuffer用于构建可变数组，支持高效的尾部插入，适合大量数据的构建场景。依赖Scala collection.mutable包。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/concrete-mutable-collection-classes.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval buf = scala.collection.mutable.ArrayBuffer.empty[Int]\nbuf += 1\nbuf += 10\nval arr = buf.toArray\n```\n\n----------------------------------------\n\nTITLE: Creating Indexed Iterator from Existing Iterator Scala\nDESCRIPTION: This snippet defines a function `zipWithIndex` that takes an existing iterator `i` and returns a new iterator. This new iterator yields pairs of elements from the original iterator `i` alongside their integer indices, starting from 0. It demonstrates how laziness allows working with potentially infinite sequences by zipping the input iterator with an infinite `Stream` of integers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/iterators.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ndef zipWithIndex[A](i: Iterator[A]): Iterator[(Int, A)] = Stream.from(0).zip(i)\n```\n\n----------------------------------------\n\nTITLE: Escaping Dollar Signs in 's' Interpolated Strings in Scala\nDESCRIPTION: Explains how to include a literal dollar sign (`$`) within an `s` interpolated string by doubling it (`$$`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/string-interpolation.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nprintln(s\"New offers starting at $$14.99\")   // \"New offers starting at $14.99\"\n```\n\n----------------------------------------\n\nTITLE: Creating a 'Person' instance as an immutable value in Scala\nDESCRIPTION: This snippet illustrates instantiating an immutable 'Person' object with 'val', ensuring the instance reference cannot change. It aligns with the immutability principles of FP and is compatible with Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fp-immutable-values.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval reginald = Person(\"Reginald\", \"Dwight\")\n```\n\n----------------------------------------\n\nTITLE: Using 'raw' Interpolator to Prevent Escape Sequence Processing\nDESCRIPTION: Illustrates the use of the 'raw' interpolator to avoid escape sequence processing within string literals. Unlike 's', 'raw' treats backslash characters like '\\n' as literal text, making it useful for raw string data such as regex patterns or code snippets.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/string-interpolation.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nprintln(\"a\\nb\")  // a\nb\n\nprintln(raw\"a\\nb\")  // a\\nb\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Future That Sleeps then Returns a Value in Scala REPL\nDESCRIPTION: Shows how to construct a Future in Scala that executes a long-running task (sleep) then returns a result. The example involves sleeping for 10 seconds and then yielding 42. It requires the standard concurrent Future and an execution context. The output is a Future[Int], which is initially incomplete.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/futures.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval a = Future { Thread.sleep(10*1000); 42 }\n```\n\n----------------------------------------\n\nTITLE: Defining a Mutable Invariant Box in Scala\nDESCRIPTION: This snippet defines a generic mutable Box class that holds a value of type A as a var field. The absence of a variance annotation means the type parameter is invariant: Box[Cat] and Box[Animal] are unrelated even if Cat extends Animal. No external dependencies are needed. Key parameter: content parameter of type A holds the boxed value. The class allows storing and updating the value, illustrating why mutability forces invariance to maintain type safety.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/variances.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass Box[A](var content: A)\n```\n\n----------------------------------------\n\nTITLE: Using the Logarithm Class in Scala\nDESCRIPTION: Example usage of the Logarithm class showing arithmetic operations with logarithmic values. This demonstrates how to create logarithmic values and perform multiplication and addition operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-opaque-types.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval l2 = Logarithm(2.0)\nval l3 = Logarithm(3.0)\nprintln((l2 * l3).toDouble) // prints 6.0\nprintln((l2 + l3).toDouble) // prints 4.999...\n```\n\n----------------------------------------\n\nTITLE: Defining Context Parameters in Scala 2\nDESCRIPTION: Demonstrates how to mark parameters as contextual using the 'implicit' keyword in Scala 2. This allows the compiler to automatically provide the argument at call sites.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-context-parameters.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef renderWebsite(path: String)(implicit config: Config): String =\n    \"<html>\" + renderWidget(List(\"cart\")) + \"</html>\"\n    //                                  ^\n    //                   no argument config required anymore\n\ndef renderWidget(items: List[String])(implicit config: Config): String = ???\n```\n\n----------------------------------------\n\nTITLE: Implementing Concrete String Iterator Extending Abstract Iterator in Scala\nDESCRIPTION: Concrete implementation of `AbsIterator` named `StringIterator` that iterates over the characters of a given `String`. Defines type `T` as `Char`, uses a private index `i` for tracking current position, `hasNext` returns whether more characters remain, and `next` returns the current character then increments the index. Dependencies: requires the abstract `AbsIterator` class. Inputs: a `String` passed at construction. Outputs: sequential characters of the string upon `next()` calls.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/mixin-class-composition.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass StringIterator(s: String) extends AbsIterator {\n  type T = Char\n  private var i = 0\n  def hasNext = i < s.length\n  def next() = {\n    val ch = s charAt i\n    i += 1\n    ch\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Access Tuple Elements using underscore notation\nDESCRIPTION: Shows how to retrieve individual tuple elements via underscore notation (_1, _2, etc.) in Scala. Useful for extracting specific data from tuple instances, assuming the tuple has sufficient arity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/tuples.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nprintln(ingredient._1) // wyświetli Sugar\nprintln(ingredient._2) // wyświetli 25\n```\n\n----------------------------------------\n\nTITLE: Tuple creation in Python and Scala\nDESCRIPTION: Shows how to define a tuple with mixed data types in Python and Scala. Both languages use parentheses for tuple creation; Scala's tuple syntax is identical to Python.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nx = (11, \"Eleven\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nval x = (11, \"Eleven\")\n```\n\n----------------------------------------\n\nTITLE: Constructing Annotated Expressions with Scala Quasiquotes\nDESCRIPTION: Demonstrates how to create an annotated expression using the `q` quasiquote interpolator in Scala. The expression `1 + 1` is annotated with `@positive`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\nscala> val annotated = q\"(1 + 1): @positive\"\nannotated: universe.Annotated = 1.$plus(1): @positive\n```\n\n----------------------------------------\n\nTITLE: Обработка исключений в Scala 2 и Scala 3 с помощью try/catch\nDESCRIPTION: Демонстрация функции makeInt, которая преобразует строку в целое число, используя блоки try/catch. В случае ошибки возвращается 0. Это базовый пример обработки ошибок с помощью исключений в Scala 2 и Scala 3, показывающий общие принципы работы.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fp-functional-error-handling.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef makeInt(s: String): Int =\n  try {\n    Integer.parseInt(s.trim)\n  } catch {\n    case e: Exception => 0\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining Pizza Functional Methods with Case Class in Scala 3\nDESCRIPTION: Defines the Pizza case class using Scala 3 syntax with a colon and indentation, including the same functional methods as in Scala 2 for price calculation and immutably updating toppings and crust attributes. The `this` reference is implicit and used to update fields with copy. Requires the same dependent types and pricing function. This snippet showcases idiomatic Scala 3 class method syntax while maintaining functional semantics.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-fp.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ncase class Pizza(\n  crustSize: CrustSize,\n  crustType: CrustType,\n  toppings: Seq[Topping]\n):\n\n  // операции этой модели данных\n  def price: Double =\n    pizzaPrice(this) // такая же имплементация, как и выше\n\n  def addTopping(t: Topping): Pizza =\n    this.copy(toppings = this.toppings :+ t)\n\n  def removeAllToppings: Pizza =\n    this.copy(toppings = Seq.empty)\n\n  def updateCrustSize(cs: CrustSize): Pizza =\n    this.copy(crustSize = cs)\n\n  def updateCrustType(ct: CrustType): Pizza =\n    this.copy(crustType = ct)\n```\n\n----------------------------------------\n\nTITLE: Using blocking Construct to Mark Potentially Blocking Calls in Scala\nDESCRIPTION: This snippet explains how to mark calls that may block thread execution using the blocking construct. Wrapping potentially blocking third-party or synchronous code with blocking informs the execution context to manage threads accordingly, helping avoid starvation and deadlocks. Exceptions thrown from inside blocking propagate to the caller. No specific code example is provided but described usage is: blocking { potentiallyBlockingCall() } with appropriate imports.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/futures.md#_snippet_16\n\n\n\n----------------------------------------\n\nTITLE: Registering Callbacks on Future Completion with onComplete - Scala\nDESCRIPTION: Shows how to use the onComplete method to register callbacks for both successful completion and failure of a Future, specifically by pattern-matching on the Either result. Requires the scala.concurrent.Future interface; assumes the existence of a valid session and a render method. The input is a Future result of fetching a user\\'s recent posts; outputs are actions performed via render depending on whether the Future succeeded or failed. Limitation: onComplete discards its return value and should be used for side-effects only.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/futures-promises.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval f: Future[List[String]] = Future {\n  session.getRecentPosts\n}\n\nf onComplete {\n  case Right(posts) => for (post <- posts) render(post)\n  case Left(t)  => render(\"An error has occurred: \" + t.getMessage)\n}\n```\n\n----------------------------------------\n\nTITLE: Analysis of Repeated By-Name Parameters Proposal in SIP-24\nDESCRIPTION: This snippet explains the semantics of repeated by-name parameters, including evaluation rules and implications for language consistency. It emphasizes the need for further examples, platform considerations, and future integration with inline functions. Dependencies involve the Scala compiler internals and Dotty implementation details.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/minutes/2016-11-29-sip-minutes.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nN/A\n```\n\n----------------------------------------\n\nTITLE: Using Custom Boolean Operators as Infix Methods in Scala\nDESCRIPTION: Demonstrates how the custom `and` and `or` methods defined in the `MyBool` class can be used as infix operators. It defines `not` and `xor` functions using these custom methods, showcasing improved readability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/operators.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef not(x: MyBool) = x.negate\ndef xor(x: MyBool, y: MyBool) = (x or y) and not(x and y)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Covariant List Usage with Type Hierarchies in Scala\nDESCRIPTION: An example showing how the covariant ListNode with lower type bounds allows for creating lists that can hold elements of different types through type hierarchy relationships. A String list can be converted to an Any list.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/lower-type-bounds.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nobject LowerBoundTest extends App {\n  val empty: ListNode[Null] = ListNode(null, null)\n  val strList: ListNode[String] = empty.prepend(\"hello\")\n                                       .prepend(\"world\")\n  val anyList: ListNode[Any] = strList.prepend(12345)\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Graph Usage with Mixed Nodes in Scala\nDESCRIPTION: Example that demonstrates how Scala's type system prevents mixing nodes from different graph instances. The code fails when attempting to connect nodes from two separate graphs, showcasing the type safety provided by Scala's inner class implementation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/inner-classes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nobject IllegalGraphTest extends App {\n  val g: Graph = new Graph\n  val n1: g.Node = g.newNode\n  val n2: g.Node = g.newNode\n  n1.connectTo(n2)      // dopuszczalne\n  val h: Graph = new Graph\n  val n3: h.Node = h.newNode\n  n1.connectTo(n3)      // niedopuszczalne!\n}\n```\n\n----------------------------------------\n\nTITLE: If-else if-else ladder in Scala 2 and 3\nDESCRIPTION: Syntax comparison for if-else if-else control structure, showing how Scala 3 requires the 'then' keyword after each condition for improved readability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/control-structures.md#_snippet_3\n\nLANGUAGE: Scala 2\nCODE:\n```\nif (x < 0)\n  println(\"negative\")\nelse if (x == 0)\n  println(\"zero\")\nelse\n  println(\"positive\")\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nif x < 0 then\n  println(\"negative\")\nelse if x == 0 then\n  println(\"zero\")\nelse\n  println(\"positive\")\n```\n\n----------------------------------------\n\nTITLE: Interactive Hello World Application in Scala 2 Using readLine\nDESCRIPTION: This Scala 2 snippet implements a simple interactive console application that prompts the user to enter their name, reads the input using `readLine()`, and prints a personalized greeting. It defines a singleton object `helloInteractive` with a main method serving as the entry point. The program first prints the prompt, then captures user input as a `String` stored in the `name` variable, and finally prints \"Hello, <name>!\" by concatenating strings. It requires importing `readLine` from `scala.io.StdIn` and compiling with `scalac`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-hello-world.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.io.StdIn.readLine\n\nobject helloInteractive {\n\n  def main(args: Array[String]) = {\n    println(\"Please enter your name:\")\n    val name = readLine()\n\n    println(\"Hello, \" + name + \"!\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Java Libraries in Scala for Localized Date Formatting\nDESCRIPTION: This Scala snippet imports Java utilities Date and Locale, and java.text.DateFormat static members, demonstrating Scala's powerful import syntax including selective and wildcard imports using braces and underscore. It defines a singleton object FrenchDate with a main function that creates a current Date instance, obtains a localized French date formatter with LONG style, and prints the formatted date. This code illustrates seamless Java interoperability, static member imports, and infix notation for method calls. Dependencies include java.util and java.text Java packages. Input is no explicit arguments, output is a formatted date string.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tutorials/scala-for-java-programmers.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport java.util.{Date, Locale}\nimport java.text.DateFormat._\n\nobject FrenchDate {\n  def main(args: Array[String]): Unit = {\n    val now = new Date\n    val df = getDateInstance(LONG, Locale.FRANCE)\n    println(df format now)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Assign and Update Uniformly - Scala\nDESCRIPTION: Shows how quasiquotes allow pattern matching both direct assignment (`x = 2`) and update syntax (`array(0) = 1`) using a single uniform pattern `q\"$left = $right\"`. It demonstrates that the left-hand side of the update syntax is matched as if it were a function application.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\nscala> List(assign, update).foreach {\n             case q\"$left = $right\" =>\n               println(s\"left = $left, right = $right\")\n           }\nleft = x, right = 2\nleft = array(0), right = 1\n```\n\n----------------------------------------\n\nTITLE: Applying Java annotation using concise 'value' syntax in Scala\nDESCRIPTION: Shows the concise syntax in Scala for applying a Java annotation that has an element named `value`. Similar to Java, the value for the `value` element can be provided positionally without explicitly naming the parameter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/annotations.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\n@SourceURL(\"https://coders.com/\")\nclass MyScalaClass ...\n```\n\n----------------------------------------\n\nTITLE: Advanced map Method Examples in Scala\nDESCRIPTION: Additional examples of the map method showing transformation of strings and creation of data structures like maps and boolean lists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/collections-methods.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nscala> val capNames = names.map(_.capitalize)\ncapNames: List[String] = List(Adam, Brandy, Chris, David)\n\nscala> val nameLengthsMap = names.map(s => (s, s.length)).toMap\nnameLengthsMap: Map[String, Int] = Map(adam -> 4, brandy -> 6, chris -> 5, david -> 5)\n\nscala> val isLessThanFive = oneToTen.map(_ < 5)\nisLessThanFive: List[Boolean] = List(true, true, true, true, false, false, false, false, false, false)\n```\n\n----------------------------------------\n\nTITLE: Opening Classes for Extension in Scala\nDESCRIPTION: Since Scala classes are closed by default, the `open` keyword is used before the `class` keyword to explicitly permit other classes to subclass it.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nopen class Person\n```\n\n----------------------------------------\n\nTITLE: Creating Immutable Lists Using Scala 2 and 3\nDESCRIPTION: Demonstrates different ways to create an immutable List[Int] in Scala using constructors, ranges, and the List.range method. Shows usage of incremental steps and exclusive range end with to and until methods. Intended for initializing lists with specified integer sequences, the examples produce immutable linked lists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-collections.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval a = List(1, 2, 3)           // a: List[Int] = List(1, 2, 3)\n\n// Range methods\nval b = (1 to 5).toList         // b: List[Int] = List(1, 2, 3, 4, 5)\nval c = (1 to 10 by 2).toList   // c: List[Int] = List(1, 3, 5, 7, 9)\nval e = (1 until 5).toList      // e: List[Int] = List(1, 2, 3, 4)\nval f = List.range(1, 5)        // f: List[Int] = List(1, 2, 3, 4)\nval g = List.range(1, 10, 3)    // g: List[Int] = List(1, 4, 7)\n```\n\n----------------------------------------\n\nTITLE: Parsing JSON and Accessing Object Field in Scala with uJson\nDESCRIPTION: Demonstrates parsing a JSON string into a `ujson.Value` using `ujson.read`. It shows how to access a specific field within the parsed JSON object using the field name as a key and then cast the resulting value to a String using the `.str` method. The example includes printing the accessed value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-parse.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval jsonString = \"\"\"{\"name\": \"Peter\", \"age\": 13, \"pets\": [\"Toolkitty\", \"Scaniel\"]}\"\"\"\nval json: ujson.Value  = ujson.read(jsonString)\nprintln(json(\"name\").str)\n// prints: Peter\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Varargs Methods for Java Usage\nDESCRIPTION: Illustrates how to define a Scala method (versions 2 and 3) with a varargs parameter (`String*`) using the `@varargs` annotation. This annotation ensures the method can be correctly invoked from Java code using variable arguments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/interacting-with-java.md#_snippet_2\n\nLANGUAGE: Scala 2\nCODE:\n```\nimport scala.annotation.varargs\n\nobject VarargsPrinter {\n  @varargs def printAll(args: String*): Unit = args.foreach(println)\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nimport scala.annotation.varargs\n\nobject VarargsPrinter:\n  @varargs def printAll(args: String*): Unit = args.foreach(println)\n```\n\n----------------------------------------\n\nTITLE: Implementing Logarithms Abstract Interface with Type Alias Equal to Double in Scala\nDESCRIPTION: Provides a concrete implementation of the Logarithms trait where the opaque type Logarithm is aliased to Double. It defines addition and multiplication operations based on the logarithmic arithmetic rules, and conversion functions utilizing math.log and math.exp. This implementation exposes the actual underlying type, causing potential type leaking and forcing clients to program against the abstraction carefully.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-opaque-types.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nobject LogarithmsImpl extends Logarithms:\n\n  type Logarithm = Double\n\n  // operations on Logarithm\n  def add(x: Logarithm, y: Logarithm): Logarithm = make(x.toDouble + y.toDouble)\n  def mul(x: Logarithm, y: Logarithm): Logarithm = x + y\n\n  // functions to convert between Double and Logarithm\n  def make(d: Double): Logarithm = math.log(d)\n  def extract(x: Logarithm): Double = math.exp(x)\n```\n\n----------------------------------------\n\nTITLE: Defining Functions - Scala\nDESCRIPTION: Shows correct and incorrect function definitions with required type annotations for parameters. Dependencies: standard Scala interpreter. Key parameters: input 'x' of type Int or Any. Outputs: product or side effect (println). Highlights the need for type safety and the use of '=' for returning values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: Int) = { x*x }\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: Any) = println(x)\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x) = println(x)\n```\n\n----------------------------------------\n\nTITLE: Defining Polymorphic Methods with Type Parameters in Scala\nDESCRIPTION: This Scala snippet defines a recursive method `listOfDuplicates` that takes a type parameter `A` and two value parameters: an element `x` of type `A` and an integer `length`. It returns a List of repeated elements `x` of the given length. The method recursively constructs the list by prepending `x` until the length is less than one, then returns an empty list. The example demonstrates explicit type parameter usage with `Int` and type inference with `String`. Dependencies include Scala collections for List. Input parameters are the element `x` and the desired number of duplicates `length`. Output is a List of type `A` containing `length` duplicates of `x`. The method highlights polymorphic function definitions and recursive list building in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/polymorphic-methods.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef listOfDuplicates[A](x: A, length: Int): List[A] = {\n  if (length < 1)\n    Nil\n  else\n    x :: listOfDuplicates(x, length - 1)\n}\nprintln(listOfDuplicates[Int](3, 4))  // List(3, 3, 3, 3)\nprintln(listOfDuplicates(\"La\", 8))  // List(La, La, La, La, La, La, La, La)\n```\n\n----------------------------------------\n\nTITLE: Creating Parallel Ranges in Scala\nDESCRIPTION: Shows how to create parallel ranges using the par method on sequential ranges. ParRange represents ordered, equally spaced elements and can be efficiently converted to and from sequential Range objects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/parallel-collections/concrete-parallel-collections.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n1 to 3 par\nres0: scala.collection.parallel.immutable.ParRange = ParRange(1, 2, 3)\n\n15 to 5 by -2 par\nres1: scala.collection.parallel.immutable.ParRange = ParRange(15, 13, 11, 9, 7, 5)\n```\n\n----------------------------------------\n\nTITLE: Functional Methods on Scala Sequences\nDESCRIPTION: Demonstrates common functional operations on Scala sequences including filtering, transforming, and extracting elements from collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_34\n\nLANGUAGE: scala\nCODE:\n```\n// these examples use a List, but they're the same with Vector\nval a = List(10, 20, 30, 40, 10)      // List(10, 20, 30, 40, 10)\na.contains(20)                        // true\na.distinct                            // List(10, 20, 30, 40)\na.drop(2)                             // List(30, 40, 10)\na.dropRight(2)                        // List(10, 20, 30)\na.dropWhile(_ < 25)                   // List(30, 40, 10)\na.filter(_ < 25)                      // List(10, 20, 10)\na.filter(_ > 100)                     // List()\na.find(_ > 20)                        // Some(30)\na.head                                // 10\na.headOption                          // Some(10)\na.init                                // List(10, 20, 30, 40)\na.last                                // 10\na.lastOption                          // Some(10)\na.slice(2,4)                          // List(30, 40)\na.tail                                // List(20, 30, 40, 10)\na.take(3)                             // List(10, 20, 30)\na.takeRight(2)                        // List(40, 10)\na.takeWhile(_ < 30)                   // List(10, 20)\n\n// map, flatMap\nval fruits = List(\"apple\", \"pear\")\nfruits.map(_.toUpperCase)             // List(APPLE, PEAR)\nfruits.flatMap(_.toUpperCase)         // List(A, P, P, L, E, P, E, A, R)\n\nval nums = List(10, 5, 8, 1, 7)\nnums.sorted                           // List(1, 5, 7, 8, 10)\nnums.sortWith(_ < _)                  // List(1, 5, 7, 8, 10)\nnums.sortWith(_ > _)                  // List(10, 8, 7, 5, 1)\n\nList(1,2,3).updated(0,10)             // List(10, 2, 3)\nList(2,4).union(List(1,3))            // List(2, 4, 1, 3)\n\n// zip\nval women = List(\"Wilma\", \"Betty\")    // List(Wilma, Betty)\nval men = List(\"Fred\", \"Barney\")      // List(Fred, Barney)\nval couples = women.zip(men)          // List((Wilma,Fred), (Betty,Barney))\n```\n\n----------------------------------------\n\nTITLE: Compilation Instructions for Scala Program\nDESCRIPTION: Guides on compiling a Scala source file using 'scalac', which produces Java-compatible class files. Highlights that the source file 'HolaMundo.scala' compiles into class files like 'HolaMundo.class', ready for execution. Essential for building Scala applications from source.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tutorials/scala-for-java-programmers.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n> scalac HolaMundo.scala\n```\n\n----------------------------------------\n\nTITLE: Example of futures failed projection in Scala with Scala 3 syntax\nDESCRIPTION: Same as the previous snippet but using Scala 3 syntax (`do`) for iteration, demonstrating error handling in futures with a failed projection. Requires Scala 3 syntax features.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_28\n\nLANGUAGE: Scala\nCODE:\n```\nval f = Future {\n  2 / 0\n}\nfor exc <- f.failed do println(exc)\n```\n\n----------------------------------------\n\nTITLE: Parallel iterative process computing square roots and removing converged entries in Scala\nDESCRIPTION: This snippet performs a while-loop that iterates over the concurrent map 'results', updating each Entry's square root via the Babylonian method. When the change falls below a threshold, the entry is removed from the map. It demonstrates thread-safe concurrent updates and removals, leveraging the properties of parallel trie maps in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/parallel-collections/ctries.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nwhile (results.nonEmpty) {\n  for ((num, e) <- results) {\n    val nsqrt = 0.5 * (e.sqrt + e.num / e.sqrt)\n    if (math.abs(nsqrt - e.sqrt) < 0.01) {\n      results.remove(num)\n    } else e.sqrt = nsqrt\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Modifiers using Bitwise OR for ClassDef in Scala Reflection\nDESCRIPTION: The snippet constructs a ClassDef node with combined PRIVATE and FINAL flags using the bitwise OR operator (|). It illustrates the composability of modifiers in the reflection API and how flag combinations are specified in the AST. Other parameters match previous class examples.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/annotations-names-scopes.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nClassDef(Modifiers(PRIVATE | FINAL), TypeName(\"C\"), Nil, ...)\n```\n\n----------------------------------------\n\nTITLE: Defining Marker Interface in Java\nDESCRIPTION: Defines an empty Java interface named Marker, used as a tagging mechanism to mark classes without specifying methods. Marker interfaces are common in Java for metadata purposes or to indicate special behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_16\n\nLANGUAGE: Java\nCODE:\n```\npublic interface Marker;\n```\n\n----------------------------------------\n\nTITLE: Implementing a Sensor System Extending SubjectObserver in Scala 3\nDESCRIPTION: This Scala 3 snippet implements 'SensorReader' as an object extending 'SubjectObserver' with concrete types 'Sensor' and 'Display' for 'S' and 'O', respectively. It defines classes 'Sensor' and 'Display' as nested classes conforming to 'Subject' and 'Observer', encapsulating sensor data and notification logic, compatible with Scala 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-oop.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nobject SensorReader extends SubjectObserver:\n  type S = Sensor\n  type O = Display\n\n  class Sensor(val label: String) extends Subject:\n    private var currentValue = 0.0\n    def value = currentValue\n    def changeValue(v: Double) =\n      currentValue = v\n      publish()\n\n  class Display extends Observer:\n    def notify(sub: Sensor) =\n      println(s\"${sub.label} has value ${sub.value}\")\n```\n\n----------------------------------------\n\nTITLE: Replacing Abstract Type Members with Type Parameters - Scala 3\nDESCRIPTION: Implements 'Buffer' and 'SeqBuffer' using type parameters with variance annotations, written in Scala 3 syntax. Demonstrates creation of a 'SeqBuffer' via a factory method returning an anonymous implementation for integer lists. Showcases how type parameters can substitute for abstract type members when feasible. Relies on Scala collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/abstract-type-members.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Buffer[+T]:\n  val element: T\n\nabstract class SeqBuffer[U, +T <: Seq[U]] extends Buffer[T]:\n  def length = element.length\n\ndef newIntSeqBuf(e1: Int, e2: Int): SeqBuffer[Int, Seq[Int]] =\n  new SeqBuffer[Int, List[Int]]:\n    val element = List(e1, e2)\n\nval buf = newIntSeqBuf(7, 8)\nprintln(\"length = \" + buf.length)\nprintln(\"content = \" + buf.element)\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Type Macro for Database Wrapper Generation in Scala\nDESCRIPTION: Defines a type macro `H2Db` that generates a database wrapper class at compile-time, connecting to a database and producing case classes representing tables with CRUD operations. It uses Scala macro API to generate code as an abstract syntax tree (AST), inserts the generated class as a top-level definition with `c.introduceTopLevel`, and returns an `Apply` node representing a super constructor call. The snippet includes sample usage where an object `Db` extends `H2Db` and interacts with generated code. Dependencies include Scala macro paradise and the macro API. Input parameters include a database URL string, and output is a generated statically-typed object. Limitations include that type macros expand to `c.Tree` nodes representing types rather than expression trees.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/typemacros.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype H2Db(url: String) = macro impl\n\nobject Db extends H2Db(\"coffees\")\n\nval brazilian = Db.Coffees.insert(\"Brazilian\", 99, 0)\nDb.Coffees.update(brazilian.copy(price = 10))\nprintln(Db.Coffees.all)\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype H2Db(url: String) = macro impl\n\ndef impl(c: Context)(url: c.Expr[String]): c.Tree = {\n  val name = c.freshName(c.enclosingImpl.name).toTypeName\n  val clazz = ClassDef(..., Template(..., generateCode()))\n  c.introduceTopLevel(c.enclosingPackage.pid.toString, clazz)\n  val classRef = Select(c.enclosingPackage.pid, name)\n  Apply(classRef, List(Literal(Constant(c.eval(url)))) )\n}\n\nobject Db extends H2Db(\"coffees\")\n// equivalent to: object Db extends Db$1(\"coffees\")\n```\n\n----------------------------------------\n\nTITLE: Creating Programs with Dependent Function Types for Numerical Operations\nDESCRIPTION: Defines a program type using dependent function types that can work with different number implementations, allowing for modular numerical computations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-dependent-function.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ntype Prog = (n: Nums) => n.Num => n.Num\n\nval ex: Prog = nums => x => nums.add(nums.lit(0.8), x)\n```\n\n----------------------------------------\n\nTITLE: Optimized Palindrome Search in Large Data Set with Views (Scala 2 and 3)\nDESCRIPTION: Shows how to use views with the `take` method to perform lazy, efficient search for the first palindrome in the first million elements, minimizing memory usage by avoiding creating large intermediate collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/views.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval palindromes = findPalindrome(words.view.take(1000000))\n```\n\n----------------------------------------\n\nTITLE: Producer-Consumer pattern using Promise in Scala\nDESCRIPTION: Demonstrates a producer-consumer pattern where a value is passed from one computation to another using a Promise and its associated Future.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.concurrent.{ Future, Promise }\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nval p = Promise[T]()\nval f = p.future\n\nval producer = Future {\n  val r = produceSomething()\n  p.success(r)\n  continueDoingSomethingUnrelated()\n}\n\nval consumer = Future {\n  startDoingSomething()\n  f.foreach { r =>\n    doSomethingWithResult()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding shouldSplitFurther Method for Parallel Collections Splitters in Scala\nDESCRIPTION: This Scala method customizes the splitting behavior of parallel collection splitters by overriding shouldSplitFurther. It uses the number of remaining elements and parallelism level to decide whether to split a splitter further to balance workload. The method compares remaining elements to a threshold computed based on collection size and parallelism, optimizing parallel execution by controlling granularity of tasks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/custom-parallel-collections.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ndef shouldSplitFurther[S](coll: ParIterable[S], parallelismLevel: Int) =\n  remaining > thresholdFromSize(coll.size, parallelismLevel)\n```\n\n----------------------------------------\n\nTITLE: Using Conditional Logic as Method Body - JavaScript & Scala\nDESCRIPTION: Illustrates how to define a method (Scala) or function (JavaScript) where the entire body is composed solely of an if/else conditional expression/statement for conciseness.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_22\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction min(a, b) {\n  return (a < b) ? a : b;\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef min(a: Int, b: Int): Int =\n  if a < b then a else b\n```\n\n----------------------------------------\n\nTITLE: Comparing Runtime Classes Using Java Reflection in Scala\nDESCRIPTION: This snippet uses Java reflection methods getClass and isAssignableFrom to compare whether the runtime class of d is a subclass of that of c. The expectation is that it should return true, given D extends C, but due to anonymous subclassing, it returns false. This demonstrates the limitation when using Java reflection with Scala-specific constructs. Inputs are the previously created instances c and d; output is a Boolean indicating subclass relationship.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/overview.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nc.getClass.isAssignableFrom(d.getClass)\n```\n\n----------------------------------------\n\nTITLE: Using Scala CLI to add upickle dependency\nDESCRIPTION: This snippet demonstrates how to include the upickle library using Scala CLI, either by requiring the latest toolkit or a specific version. It simplifies dependency management with single-line commands, suitable for quick setup.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-upickle.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n//> using toolkit latest\n```\n\nLANGUAGE: Scala\nCODE:\n```\n//> using dep com.lihaoyi::upickle:4.1.0\n```\n\n----------------------------------------\n\nTITLE: Creating Multiline Interpolated Strings with 'stripMargin' in Scala\nDESCRIPTION: Demonstrates using `s` interpolation with triple-quoted multiline strings and the `stripMargin` method to format the output neatly. `stripMargin` removes leading whitespace up to the default margin character (`|`). The example output is included.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/string-interpolation.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval name = \"James\" // Assuming name is defined from previous examples\nval age = 30    // Assuming age is defined from previous examples\nprintln(s\"\"\"name: \"$name\",\n           |age: $age\"\"\".stripMargin)\n```\n\nLANGUAGE: text\nCODE:\n```\nname: \"James\"\nage: 30\n```\n\n----------------------------------------\n\nTITLE: Creating thread-safe synchronized Maps in Scala\nDESCRIPTION: Demonstrates how to create thread-safe Maps by mixing in the SynchronizedMap trait with a HashMap implementation. The example also shows how to override the default method to handle missing keys.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/maps.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable.{Map, SynchronizedMap, HashMap}\n\nobject MapMaker {\n  def makeMap: Map[String, String] = {\n    new HashMap[String, String] with SynchronizedMap[String, String] {\n      override def default(key: String) = \"Why do you want to know?\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Scaladoc Site Generation in sbt - Scala\nDESCRIPTION: Activates Scaladoc website support with sbt-site plugins in build.sbt. Requires 'sbt-site' plugin. First line enables the Scaladoc plugin; second specifies the API docs output subdirectory; third makes the base URL available as a Paradox property. Input: none; Output: API docs at site under specified subdirectory. Limitation: Needs sbt-site and Paradox configured.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nenablePlugins(SiteScaladocPlugin)\nSiteScaladoc / siteSubdirName := \"api\"\nparadoxProperties += (\"scaladoc.base_url\" -> \"api\")\n```\n\n----------------------------------------\n\nTITLE: Summoning Givens Programmatically with Expr.summon in Scala Macros\nDESCRIPTION: Illustrates how to find given values programmatically within the macro implementation using `Expr.summon`. This approach allows the macro to handle cases where the given is not found (e.g., by providing a fallback implementation), as the implicit search is performed during macro expansion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_31\n\nLANGUAGE: Scala\nCODE:\n```\ninline def setOf[T]: Set[T] =\n  ${ setOfCode[T] }\n\ndef setOfCode[T: Type](using Quotes): Expr[Set[T]] =\n  Expr.summon[Ordering[T]] match\n    case Some(ord) => '{ TreeSet.empty[T](using $ord) }\n    case _ => '{ HashSet.empty[T] }\n```\n\n----------------------------------------\n\nTITLE: Concise method definitions without explicit return types Scala 2 and 3\nDESCRIPTION: Shows methods defined without specifying return type, relying on type inference in Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-methods.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef sum(a: Int, b: Int) = a + b\ndef concatenate(s1: String, s2: String) = s1 + s2\n```\n\n----------------------------------------\n\nTITLE: Working with Expr and Term Conversion in Scala Macros\nDESCRIPTION: Shows how to convert between `Expr[T]` and its underlying `Term` representation using the `asTerm` and `asExprOf[T]` extension methods after importing from `quotes.reflect`. This example converts the expression `x` of type `Expr[Int]` to `Term`, and back to an expression, illustrating the ability to manipulate typed syntax trees directly within macros. It demonstrates the importance of importing reflection members to access these conversions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/reflection.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: Expr[Int])(using Quotes): Expr[Int] =\n  import quotes.reflect.*\n  val tree: Term = x.asTerm\n  val expr: Expr[Int] = tree.asExprOf[Int]\n  expr\n```\n\n----------------------------------------\n\nTITLE: Handling Generic Types in Quoted Code (Error Example)\nDESCRIPTION: Demonstrates a common error when using an abstract type parameter `T` inside a quoted block (`'{ ... }`). Without evidence that the type `T` can be reconstructed at runtime, the compiler issues an error, typically requiring a `Type[T]` context bound.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef evalAndUse[T](x: Expr[T])(using Quotes) = '{\n  val x2: T = $x // error\n  ... // use x2\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Type of Cat Instance via Helper\nDESCRIPTION: Invokes the `getType` helper function with the created `Cat` instance. This demonstrates that the helper accurately captures and returns the reflection `Type` for the `Cat` class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nscala> getType(c)\nres: scala.reflect.runtime.universe.Type = Cat\n```\n\n----------------------------------------\n\nTITLE: Использование for-comprehensions для обработки нескольких Option в Scala 2 и Scala 3\nDESCRIPTION: Пример использования for-компрехеншена для объединения нескольких вызовов makeInt. Если все строки успешно преобразуются, возвращается сумма внутри Some, иначе результат будет None. Этот подход способствует более читаемому и функциональному стилю обработки ошибок.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fp-functional-error-handling.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval y = for {\n  a <- makeInt(stringA)\n  b <- makeInt(stringB)\n  c <- makeInt(stringC)\n} yield {\n  a + b + c\n}\n```\n\n----------------------------------------\n\nTITLE: Defining simple one-line functions in Python and Scala\nDESCRIPTION: Illustrates compact function definition syntax to add two parameters. No external dependencies required. Parameters a and b are integers, and the output is their sum returned directly. Useful for simple operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\ndef add(a: Int, b: Int): Int = a + b\n```\n\n----------------------------------------\n\nTITLE: Extending a Universal Trait with a Scala Value Class\nDESCRIPTION: Shows a value class `Wrapper` extending `AnyVal` and mixing in a universal trait `Printable` (which extends `Any`). Universal traits allow method inheritance for value classes but invoking methods defined in the trait (like `w.print()`) forces the runtime instantiation of the value class, incurring allocation overhead.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait Printable extends Any {\n  def print(): Unit = println(this)\n}\nclass Wrapper(val underlying: Int) extends AnyVal with Printable\n\nval w = new Wrapper(3)\nw.print() // actually requires instantiating a Wrapper instance\n```\n\n----------------------------------------\n\nTITLE: Testing Location Macro in Both Scala 2 and Scala 3\nDESCRIPTION: Defines a test suite for the 'Macros.location' macro that works in both Scala 2 and Scala 3, using munit's 'FunSuite'. It asserts that the 'line' field in the returned 'Location' instance equals 5. Requires the macro to be visible and 'munit' as a test dependency. By placing the test in a shared directory, the same assertion validates both macro implementations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-macro-cross-building.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n// example/src/test/scala/location/MacrosSpec.scala\npackage location\n\nclass MacrosSpec extends munit.FunSuite {\n  test(\"location\") {\n    assertEquals(Macros.location.line, 5)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Path-Dependent Types with Module Abstraction in Scala\nDESCRIPTION: Example of how path-dependent types are needed when programming against the abstract module interface. This demonstrates the complexity introduced by the abstract module approach.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-opaque-types.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef someComputation(L: Logarithms)(init: L.Logarithm): L.Logarithm = ...\n```\n\n----------------------------------------\n\nTITLE: Matching Secondary Constructor as General Method in Scala\nDESCRIPTION: Shows that a secondary constructor's AST can also be matched using the general method definition quasiquote pattern. This reveals its underlying representation as a method named `<init>` (termNames.CONSTRUCTOR).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/definition-details.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"$mods def $name[..$tparams](...$paramss): $tpt = $body\"\n         = q\"def this() = this(0)\"\nmods: universe.Modifiers = Modifiers(, , Map())\nname: universe.TermName = <init>\ntparams: List[universe.TypeDef] = List()\nparamss: List[List[universe.ValDef]] = List(List())\ntpt: universe.Tree = <type ?>\nbody: universe.Tree = <init>(0)\n```\n\n----------------------------------------\n\nTITLE: 型消去によるジェネリック配列作成エラー示例 - Scala\nDESCRIPTION: このコードはScalaにおけるジェネリック配列作成で発生するエラーの例です。型パラメータTだけでnew Array[T]を作ろうとすると、実行時の型情報消去によりクラスマニフェストが見つからずコンパイルエラーになります。依存はScala標準ライブラリで、この例はClassTagかManifestの必要性を示すためのものです。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/arrays.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef evenElems[T](xs: Vector[T]): Array[T] = {\n  val arr = new Array[T]((xs.length + 1) / 2)\n  for (i <- 0 until xs.length by 2)\n    arr(i / 2) = xs(i)\n  arr\n}\n```\n\n----------------------------------------\n\nTITLE: Using Generic Stack with Class Hierarchy in Scala 2\nDESCRIPTION: Illustrates defining a class hierarchy with Fruit as base class and Apple and Banana subclasses. A Stack of type Fruit is instantiated to hold objects of these subclasses, demonstrating polymorphic behavior. Elements apple and banana of respective subclasses are pushed onto the stack. Requires prior definition of generic Stack and the Fruit classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/generic-classes.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass Fruit\nclass Apple extends Fruit\nclass Banana extends Fruit\n\nval stack = new Stack[Fruit]\nval apple = new Apple\nval banana = new Banana\n\nstack.push(apple)\nstack.push(banana)\n```\n\n----------------------------------------\n\nTITLE: Applying Parallel Map Operation in Scala\nDESCRIPTION: Demonstrates creating a parallel sequence (`ParSeq`) from a List using `.par` and then applying the `map` operation to transform each String element to uppercase in parallel.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/overview.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nscala> val lastNames = List(\"Smith\",\"Jones\",\"Frankenstein\",\"Bach\",\"Jackson\",\"Rodin\").par\nlastNames: scala.collection.parallel.immutable.ParSeq[String] = ParVector(Smith, Jones, Frankenstein, Bach, Jackson, Rodin)\n\nscala> lastNames.map(_.toUpperCase)\nres0: scala.collection.parallel.immutable.ParSeq[String] = ParVector(SMITH, JONES, FRANKENSTEIN, BACH, JACKSON, RODIN)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Contextual Parameter (given) Resolution Failure in Scala 3\nDESCRIPTION: Attempts to call the generic 'max' function defined previously with 'Boolean' arguments. This code demonstrates a compile-time error because Scala 3 cannot find a 'given Comparator[Boolean]' instance, illustrating the failure case of contextual parameter resolution using the new 'given' syntax and error message format.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/implicit-parameters.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n// does not compile:\nprintln(max(false, true))\n-- Error: ----------------------------------------------------------------------\n1 |println(max(false, true))\n  |                        ^\n  |no given instance of type Comparator[Boolean] was found for parameter comparator of method max\n```\n\n----------------------------------------\n\nTITLE: Proposal 3: Redundant Map Call Optimization - Example\nDESCRIPTION: Provides an example where the value yielded (`a`) is identical to the last bound variable (`a <- ...`). This pattern is targeted by the optimization proposal.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nfor\n  a <- List(1, 2, 3)\nyield a\n```\n\n----------------------------------------\n\nTITLE: Extending java.lang.Enum to Make Scala Enums Compatible with Java\nDESCRIPTION: Demonstrates defining a Scala 3 enum that extends `java.lang.Enum` to interoperate with Java code as a Java enum. The snippet defines `Color` enum cases without constructor arguments, enabling native Java enumeration behaviors like `compareTo`. Compiler auto-generates necessary constructor details. This approach facilitates Scala-Java interoperability for enum types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_37\n\nLANGUAGE: scala\nCODE:\n```\nenum Color extends Enum[Color] { case Red, Green, Blue }\n```\n\n----------------------------------------\n\nTITLE: Folding (Summing) Elements in Scala Parallel Collections Using ParArray\nDESCRIPTION: Illustrates how to create a parallel array (ParArray) of integers by converting a sequential array to its parallel counterpart using `.par`. It then computes the sum of all elements in parallel via the `fold` operation, starting from zero and applying integer addition. This example requires Scala's parallel collections support. The input is a range converted to an array, and the output is the integer sum computed efficiently in parallel. This snippet highlights performance benefits of parallel reductions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/overviews/parallel-collections/overview.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval parArray = (1 to 10000).toArray.par\nparArray.fold(0)(_ + _)\n```\n\n----------------------------------------\n\nTITLE: Implementing equals method for the Date class\nDESCRIPTION: Implementation of the equals method for Date class using pattern matching. This method compares dates by comparing their individual fields (year, month, day) rather than using object identity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\nclass Date(y: Int, m: Int, d: Int) extends Ord {\n  // previous decls here\n\n  override def equals(that: Any): Boolean = that match {\n    case d: Date => d.day == day && d.month == month && d.year == year\n    case _ => false\n  }\n\n  // rest of implementation will go here\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Date(y: Int, m: Int, d: Int) extends Ord:\n  // previous decls here\n\n  override def equals(that: Any): Boolean = that match\n    case d: Date => d.day == day && d.month == month && d.year == year\n    case _ => false\n\n  // rest of implementation will go here\nend Date\n```\n\n----------------------------------------\n\nTITLE: Custom parameter type parsing with 'CommandLineParser.FromString' in Scala 3\nDESCRIPTION: This code defines a custom enumerated type 'Color' and provides a 'given' instance of 'CommandLineParser.FromString' to parse string inputs into 'Color' values. The '@main' method 'run' accepts the 'Color' type, enabling command-line arguments to specify colors reliably, illustrating extendability for user-defined types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/methods-main-methods.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nenum Color:\n  case Red, Green, Blue\n\ngiven CommandLineParser.FromString[Color] with\n  def fromString(value: String): Color = Color.valueOf(value)\n\n@main def run(color: Color): Unit =\n  println(s\"The color is ${color.toString}\")\n```\n\n----------------------------------------\n\nTITLE: Creating Actors Lazily Using Views in Scala 3\nDESCRIPTION: This snippet shows the Scala 3 syntax for lazily creating actors over a range using a view. It leverages the simplified for-comprehension syntax but otherwise works like the Scala 2 example: actors are not created until the resulting collection is evaluated. This demonstrates delayed execution in Scala 3 and highlights the importance of being explicit when using views in side-effectful code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/views.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nval actors = for i <- (1 to 10).view yield actor { ... }\n```\n\n----------------------------------------\n\nTITLE: Multi-line if Expression in Scala\nDESCRIPTION: Demonstrates a multi-line if expression in Scala using 'if ... then' followed by indented expressions without braces, showing clean syntax for conditional blocks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\nif x == 1 then\n  println(\"x is 1, as you can see:\")\n  println(x)\n```\n\n----------------------------------------\n\nTITLE: Basic Pattern Matching for Single Command in Scala\nDESCRIPTION: Demonstrates a simple Scala pattern match within a `loop` function to handle the command \"north\", represented as `Command(North :: Nil)`. This shows the initial, basic case before introducing alternative patterns.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/alternative-bind-variables.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport Command.*\n\ndef loop(cmd: Command): Unit =\n  cmd match\n    case Command(North :: Nil) => // Code for going north\n```\n\n----------------------------------------\n\nTITLE: Определение контравариантного трейта Function в Scala 3\nDESCRIPTION: Аналогичное определение контравариантного и ковариантного параметров в трейте Function с использованием синтаксиса Scala 3. Подчеркивает связь использования параметров в позициях аргумента и возвращаемого значения с обозначениями вариантности.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-variance.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Function[-A, +B]:\n  def apply(a: A): B\n```\n\n----------------------------------------\n\nTITLE: Defining Higher-Kinded Type Parameters with Descriptive Names in Scala\nDESCRIPTION: Shows the preferred convention for naming higher-kinded type parameters (types that take type parameters, e.g., `Key[_]`) using descriptive names for clarity, similar to regular type parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/naming-conventions.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nclass HigherOrderMap[Key[_], Value[_]] { ... }\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Variable Binding in Scala\nDESCRIPTION: Extends the pattern match to handle commands like \"pick up jar\". It binds the item's name to the variable `name` using `Item(name)` within the pattern `Command(Pick :: Up :: Item(name) :: Nil)`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/alternative-bind-variables.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n  case Command(Pick :: Up :: Item(name) :: Nil) => // Code for picking up items\n```\n\n----------------------------------------\n\nTITLE: Running Interactive Scala Program\nDESCRIPTION: Shows execution of the compiled interactive Scala program via the 'scala' command and the program's behavior prompting for user input. The running program pauses awaiting input, illustrating how the 'readLine' method accepts text typed by the user. After input is entered with return key, the program outputs a personalized greeting including the entered name. This runtime interaction validates correct compilation and functional input/output flow.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-hello-world.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ scala helloInteractive\nPlease enter your name:\n▌\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ scala helloInteractive\nPlease enter your name:\nAlvin Alexander\nHello, Alvin Alexander!\n```\n\n----------------------------------------\n\nTITLE: Non-private Constructor in Private Class in Scala 2\nDESCRIPTION: Shows a pattern where a private class has a non-private constructor, which was allowed in Scala 2 but is rejected in Scala 3 for consistency of access modifiers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-other-changes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\npackage foo\n\nprivate class Bar private[foo] () {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Race Conditions in Callback Execution with Shared State - Scala\nDESCRIPTION: Illustrates race conditions when multiple callbacks modify a shared, volatile variable on Future completion. The example increments totalA for lowercase and uppercase 'a' letter counts in a text produced by a Future. Due to non-atomicity of +=, the final value of totalA is not deterministic and may vary between 18, 16, or 2. Requires scala.concurrent.Future; demonstrates issues with concurrent callback execution and non-thread-safe variable updates.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\n@volatile var totalA = 0\n\nval text = Future {\n  \"na\" * 16 + \"BATMAN!!!\"\n}\n\n\ntext.foreach { txt =>\n   totalA += txt.count(_ == 'a')\n}\n\ntext.foreach { txt =>\n  totalA += txt.count(_ == 'A')\n}\n```\n\n----------------------------------------\n\nTITLE: Documenting Class Constructors in Scala\nDESCRIPTION: Shows how to document a Scala class and its primary constructor using Scaladoc. The `@constructor` tag explicitly documents the constructor, while `@param` tags describe each constructor parameter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/scaladoc.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\n/** A person who uses our application.\n *\n *  @constructor create a new person with a name and age.\n *  @param name the person's name\n *  @param age the person's age in years\n */\nclass Person(name: String, age: Int) {\n}\n```\n\n----------------------------------------\n\nTITLE: DOM Manipulation with Scala.js\nDESCRIPTION: Examples of DOM manipulation using Scala.js, demonstrating how to handle events, create elements, and modify the DOM in a type-safe way similar to JavaScript.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_38\n\nLANGUAGE: scala\nCODE:\n```\n// show an alert dialog on a button click\njQuery(\"#hello-button\").click{() =>\n  dom.window.alert(\"Hello, world\")\n}\n\n// define a button and what should happen when it's clicked\nval btn = button(\n  \"Click me\",\n  onclick := { () =>\n    dom.window.alert(\"Hello, world\")\n  })\n\n// create two divs with css classes, an h2 element, and the button\nval content =\n  div(cls := \"foo\",\n    div(cls := \"bar\",\n      h2(\"Hello\"),\n      btn\n    )\n  )\n\n// add the content to the DOM\nval root = dom.document.getElementById(\"root\")\nroot.innerHTML = \"\"\nroot.appendChild(content.render)\n```\n\n----------------------------------------\n\nTITLE: 示例：协变类型在函数中使用（Scala 2/3）\nDESCRIPTION: 定义函数 makeTwo 接收 Producer[Buyable]，演示协变类型允许使用 Producer[Book] 作为参数，突出协变在子类型转换中的便利。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-variance.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ndef makeTwo(p: Producer[Buyable]): Int =\n  p.make.price + p.make.price\n```\n\n----------------------------------------\n\nTITLE: Defining a foldLeft method with multiple parameter lists in Scala\nDESCRIPTION: This snippet shows the definition of the foldLeft method in the TraversableOnce trait, taking an initial value and a function with multiple parameter lists to perform a left fold operation over a collection. It demonstrates how the method is structured to accept parameters in separate lists for improved flexibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/multiple-parameter-lists.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef foldLeft[B](z: B)(op: (B, A) => B): B\n```\n\n----------------------------------------\n\nTITLE: Recursive Sum of List in Scala 3\nDESCRIPTION: This snippet shows the same recursive sum function in Scala 3, utilizing the new syntax style with indentation instead of braces. It remains a pure function suitable for summing list elements with pattern matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fp-pure-functions.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef sum(xs: List[Int]): Int = xs match\n  case Nil => 0\n  case head :: tail => head + sum(tail)\n```\n\n----------------------------------------\n\nTITLE: Явное объявление типов переменных в Scala\nDESCRIPTION: Предоставляет примеры явного объявления типов (`Int`, `String`, пользовательский класс `Person`) для переменных, хотя это часто необязательно из-за вывода типов.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-vars-data-types.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval x: Int = 1\nval s: String = \"a string\"\nval p: Person = Person(\"Richard\")\n```\n\n----------------------------------------\n\nTITLE: Importing Scala Reflection Universe in Scala\nDESCRIPTION: This snippet demonstrates importing the scala.reflect.runtime.universe package, which provides types and utilities for reflection, abstract syntax trees, type tags, and related APIs. This import is a prerequisite for all further operations involving trees in Scala Reflection, including construction, inspection, and traversal. No additional dependencies are required besides the Scala standard library.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Mutable ListBuffer in Scala\nDESCRIPTION: Shows how to create an empty mutable `ListBuffer[Int]`, append elements using `+=`, and convert the buffer to an immutable `List`. `ListBuffer` is optimized for building lists efficiently using an internal linked list structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-mutable-collection-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nscala> val buf = scala.collection.mutable.ListBuffer.empty[Int]\nbuf: scala.collection.mutable.ListBuffer[Int] = ListBuffer()\nscala> buf += 1\nres35: buf.type = ListBuffer(1)\nscala> buf += 10\nres36: buf.type = ListBuffer(1, 10)\nscala> buf.to(List)\nres37: List[Int] = List(1, 10)\n```\n\n----------------------------------------\n\nTITLE: Defining Implicit Conversion within an Object using 'given' in Scala 3\nDESCRIPTION: Illustrates defining an implicit conversion (`fromStringToUser`) within a Scala object (`Conversions`) in Scala 3 using a `given` instance of `Conversion`. This conversion needs to be imported using specific Scala 3 `import` syntax for givens.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-implicit-conversions.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nobject Conversions:\n  given fromStringToUser: Conversion[String, User] = (name: String) => User(name)\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Parameter Lists for Type Inference in Scala\nDESCRIPTION: Defines `foldLeft2` using multiple parameter lists, separating the collection/initial value from the operation function. This structure allows Scala to infer types (`A`, `B`) from the first parameter list, making them available for type checking the function (`_ + _`) provided in the second list, resolving the type inference issue.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/multiple-parameter-lists.md#_snippet_5\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\ndef foldLeft2[A, B](as: List[A], b0: B)(op: (B, A) => B) = ???\ndef possible = foldLeft2(numbers, 0)(_ + _)\n```\n\n----------------------------------------\n\nTITLE: Failing a Promise Based on Computation Result - Scala\nDESCRIPTION: Shows how a producer can complete a Promise either by failing it with an exception or successfully with a computed result. The producer checks validity of intermediate result r; if invalid, it fails the Promise with an IllegalStateException, otherwise it continues processing and succeeds the Promise. Dependencies: scala.concurrent.{Future, Promise}, proper error types. Inspects inputs for validity and controls Promise completion accordingly. Promise can only be completed once.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/futures-promises.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\nval p = Promise[T]()\nval f = p.future\n\nval producer = Future {\n  val r = someComputation\n  if (isInvalid(r))\n    p failure (new IllegalStateException)\n  else {\n    val q = doSomeMoreComputation(r)\n    p success q\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Enqueuing Multiple Elements to an Immutable Queue in Scala\nDESCRIPTION: Illustrates how to add multiple elements from another collection (a `List(2, 3)` in this case) to an immutable Queue using the `enqueue` method. This returns a new queue containing all elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/concrete-immutable-collection-classes.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval has123 = has1.enqueue(List(2, 3))\n```\n\nLANGUAGE: output\nCODE:\n```\nhas123: scala.collection.immutable.Queue[Int]\n  = Queue(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: For loops with multiple conditional filters in Python and Scala\nDESCRIPTION: Shows combining multiple conditions with logical operators in loops to selectively print values. Inputs: integer range 1 to 10; outputs: printed even numbers less than 5. No dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_41\n\nLANGUAGE: Python\nCODE:\n```\nfor i in range(1,11):\n  if i % 2 == 0 and i < 5:\n    print(i)\n```\n\n----------------------------------------\n\nTITLE: Importing Package Object Members and Using Them in Scala\nDESCRIPTION: This snippet demonstrates using a wildcard import to bring all members of the `gardening.fruits` package, including the package object members like `planted` and `showFruit`, into scope. The `PrintPlanted` object iterates over `planted` fruits and invokes `showFruit` to print their characteristics. It shows how package objects facilitate convenient access to shared data and functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/package-objects.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport gardening.fruits._\nobject PrintPlanted {\n  def main(args: Array[String]): Unit = {\n    for (fruit <- planted) {\n      showFruit(fruit)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Appending Content to File with os-lib in Scala\nDESCRIPTION: This snippet demonstrates how to add new content to the end of an existing file using `os.write.append`. It appends a string to the file created in the first example and then verifies that the total number of lines has increased. Requires the `os-lib` dependency and assumes the file already exists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/os-write-file.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nos.write.append(path, \"two more\nlines\n\")\nprintln(os.read.lines(path).size)\n// prints: 4\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Trait in Scala\nDESCRIPTION: Demonstrates the simplest form of a trait definition in Scala using the 'trait' keyword followed by an identifier. This trait has no methods or fields and serves as an empty interface. It requires Scala language environment without additional dependencies. It forms the foundational syntax for creating traits.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/traits.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait HairColor\n```\n\n----------------------------------------\n\nTITLE: Package Naming Conventions in Scala\nDESCRIPTION: This snippet discusses recommended naming conventions for packages, emphasizing lowercase names and structured identifiers resembling domain names, such as 'com.google.selfdrivingcar.camera'. It demonstrates aligning package declarations with directory layouts to maintain organization and clarity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/packages-and-imports.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\npackage com.google.selfdrivingcar.camera\n\nclass Lens\n```\n\n----------------------------------------\n\nTITLE: Configuring Scalafmt for Scala 3 Dialect with File Overrides\nDESCRIPTION: Illustrates how to configure Scalafmt (version 3.0.0+) to apply Scala 3 formatting rules selectively within a project using the `.scalafmt.conf` file. The `fileOverride` directive enables the `scala3` dialect for files matching a specific glob pattern (e.g., directories named `scala-3*`), allowing mixed Scala 2/3 codebases to be formatted correctly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tooling-tour.md#_snippet_1\n\nLANGUAGE: conf\nCODE:\n```\n//.scalafmt.conf\nfileOverride {\n  \"glob:**/scala-3*/**\" {\n    runner.dialect = scala3\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Markdown Front Matter for SIP Meeting Results Page\nDESCRIPTION: YAML front matter defining the layout, title, and proposals discussed during the September 16, 2022 SIP meeting. It includes two proposals with their respective GitHub links and current status.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/results/2022-09-16-meeting.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\nlayout: sip-meeting-results\ntitle: SIP Meeting Results - 16th September 2022\npartof: results\nproposals:\n  - url: https://github.com/scala/improvement-proposals/pull/47\n    name: SIP-47 - Clause Interleaving\n    result: under-review\n  - url: https://github.com/scala/improvement-proposals/pull/46\n    name: SIP-46 - Use Scala CLI to implement the 'scala' command\n    result: under-review\n---\n```\n\n----------------------------------------\n\nTITLE: Manually Creating an Apply Tree in Scala Reflection\nDESCRIPTION: This snippet illustrates how to manually construct a Tree representing a method application (specifically, calling x.$plus(2)) using the Scala Reflection API. It combines Apply, Select, Ident, TermName, Literal, and Constant nodes to form the abstract syntax tree. Requires scala.reflect.runtime.universe; inputs are the term name \\\"x\\\" and the numeric constant 2; output is a Tree object representing the apply expression.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nval tree = Apply(Select(Ident(TermName(\"x\")), TermName(\"$plus\")), List(Literal(Constant(2))))\n```\n\n----------------------------------------\n\nTITLE: Blog Configuration File in YAML\nDESCRIPTION: Specifies user-defined configuration parameters in a `blog.yml` file placed in the blog's root directory to customize blog behavior. Parameters include `input` (directory name for Markdown source files), `output` (destination folder for generated HTML files), and `hidden` (a boolean to toggle blog visibility). This allows flexible customization beyond default Scaladoc settings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/blog.md#_snippet_2\n\nLANGUAGE: YAML\nCODE:\n```\ninput: my_posts\noutput: my_docs\nhidden: true\n```\n\n----------------------------------------\n\nTITLE: Ternary conditional assignment in Python and Scala\nDESCRIPTION: Demonstrates concise expression of conditional assignments selecting the minimum of two variables a and b. Inputs: integers a and b; outputs: assignment of min_val or minValue. No dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_26\n\nLANGUAGE: Scala\nCODE:\n```\nval minValue = if a < b then a else b\n```\n\n----------------------------------------\n\nTITLE: Defining an Invariant Container Class in Scala\nDESCRIPTION: This snippet declares a generic Scala class Container without variance annotations, making it invariant. It encapsulates a mutable private variable of type A with getter and setter methods. This example illustrates why mutable containers cannot be safely covariant, since allowing covariance can lead to runtime type errors.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/variances.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nclass Container[A](value: A) {\n  private var _value: A = value\n  def getValue: A = _value\n  def setValue(value: A): Unit = {\n    _value = value\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Scala Reflection Universe Wildcard\nDESCRIPTION: Imports all members from the `scala.reflect.runtime.universe` package. This provides access to key reflection components like `typeOf`, `Symbol`, `Type`, etc., necessary for runtime reflection operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nscala> import scala.reflect.runtime.universe._\nimport scala.reflect.runtime.universe._\n```\n\n----------------------------------------\n\nTITLE: Understanding Scala Collection Initialization: Apply Method Expansion\nDESCRIPTION: Illustrates that the concise collection creation syntax, like `List(1.0, 2.0)`, is syntactic sugar for an explicit call to the `apply` method on the collection's companion object, such as `List.apply(1.0, 2.0)`. This applies universally across Scala collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/creating-collections-from-scratch.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval c = List.apply(1.0, 2.0)\n```\n\n----------------------------------------\n\nTITLE: Single-line if statement in Python and Scala\nDESCRIPTION: Shows the syntax for an inline if statement that executes a print when condition is true. Inputs: integer variable x; output: printing x if equals 1. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\nif x == 1 then println(x)\n```\n\n----------------------------------------\n\nTITLE: 無名関数の宣言 - Scala\nDESCRIPTION: 引数を受け取り計算結果を返す無名関数（ラムダ式）のシンタックス例です。=>の左側にパラメーター・右側に関数式を書き、引数xに1を加算した値を返します。引数の型指定も含みます。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\n(x: Int) => x + 1\n```\n\n----------------------------------------\n\nTITLE: Declaring a Private Class with Scala Reflection Modifiers in Scala\nDESCRIPTION: This example constructs a ClassDef for a class 'C' where the flags include PRIVATE, resulting in a private class declaration. The parameters mirror those in the previous example, except the Modifiers apply PRIVATE, demonstrating how access modifiers are set using flags.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/annotations-names-scopes.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nClassDef(Modifiers(PRIVATE), TypeName(\"C\"), Nil, ...)\n```\n\n----------------------------------------\n\nTITLE: Exception Handling with try/catch/finally in Scala 2\nDESCRIPTION: Illustrates Scala 2's try/catch/finally construct for exception handling, catching IOException and NumberFormatException specifically and printing messages, with a finally block for resource cleanup. Requires appropriate exception classes and a method 'writeTextToFile' defined. Input is variable 'text'; output includes exception messages or cleanup actions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\ntry {\n  writeTextToFile(text)\n} catch {\n  case ioe: IOException => println(\"Got an IOException.\")\n  case nfe: NumberFormatException => println(\"Got a NumberFormatException.\")\n} finally {\n  println(\"Clean up your resources here.\")\n}\n```\n\n----------------------------------------\n\nTITLE: Documenting Objects Providing Implicit Conversions in Scala\nDESCRIPTION: Illustrates how to document a Scala object that provides implicit conversions or helper methods. The example includes an embedded code snippet (`{{{ ... }}}`) demonstrating typical usage.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/scaladoc.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\n/** Implicit conversions and helpers for [[mypackage.Complex]] instances.\n *\n *  {{ \"{{{\" }}\n *  import ComplexImplicits._\n *  val c: Complex = 4 + 3.i\n *  }}}\n */\nobject ComplexImplicits {}\n```\n\n----------------------------------------\n\nTITLE: Declaring Object with Fields - Scala\nDESCRIPTION: Demonstrates that objects can contain fields (values and variables) in addition to methods, which are accessed using dot notation just like methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_23\n\nLANGUAGE: Scala 2\nCODE:\n```\nobject MathConstants {\n  val PI = 3.14159\n  val E = 2.71828\n}\n\nprintln(MathConstants.PI)   // 3.14159\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nobject MathConstants:\n  val PI = 3.14159\n  val E = 2.71828\n\nprintln(MathConstants.PI)   // 3.14159\n```\n\n----------------------------------------\n\nTITLE: Showing Insufficient Arguments Error Bash\nDESCRIPTION: Demonstrates the error message produced by the `scala run` command when a Scala 3 `@main` program receives fewer command line arguments than required by its parameter list. The command line parser validates the number of arguments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-main-methods.md#_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\n$ scala run happyBirthday.scala -- 22\nIllegal command line after first argument: more arguments expected\n```\n\n----------------------------------------\n\nTITLE: Running MUnit Tests with sbt - shell\nDESCRIPTION: Runs all test suites in the current sbt project named 'example' using sbt's interactive shell. Assumes that the project is correctly set up with MUnit as a dependency and test classes are available. The 'test' command triggers compilation and execution of all tests, displaying a summary of passed, failed, and errored cases, timing, and per-test statuses in the output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-run.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nsbt:example> test\n# MyTests:\n#   + sum of two integers 0.006s\n# [info] Passed: Total 1, Failed 0, Errors 0, Passed 1\n# [success] Total time: 0 s, completed Nov 11, 2022 12:54:08 PM\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Scala Array/Seq Compatibility (REPL)\nDESCRIPTION: Illustrates how a Scala Array can be implicitly converted to a Seq (specifically a WrappedArray). It also shows converting a sequence back to an array using the toArray method and confirms that the original and converted-back arrays are the same object using 'eq'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/arrays.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nscala> val seq: Seq[Int] = a1\nseq: Seq[Int] = WrappedArray(1, 2, 3)\nscala> val a4: Array[Int] = seq.toArray\na4: Array[Int] = Array(1, 2, 3)\nscala> a1 eq a4\nres1: Boolean = true\n```\n\n----------------------------------------\n\nTITLE: Using Implicit String Augmentation for Comparison in Scala\nDESCRIPTION: Example demonstrating how string comparison uses implicit conversion since String doesn't have a < member. The compiler inserts Predef.augmentString() to enable this operation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/implicit-conversions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n\"foo\" < \"bar\"\n// Implicitly converted to:\nPredef.augmentString(\"foo\") < \"bar\"\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Immutable ParVector in Scala\nDESCRIPTION: Illustrates the creation of an immutable `ParVector` using the `tabulate` method and performing a parallel `filter` operation to select even numbers. This highlights the usage of immutable parallel vectors for functional-style parallel processing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/concrete-parallel-collections.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nscala> val pv = scala.collection.parallel.immutable.ParVector.tabulate(1000)(x => x)\npv: scala.collection.parallel.immutable.ParVector[Int] = ParVector(0, 1, 2, 3, 4, 5, 6, 7, 8, 9,...\n\nscala> pv filter (_ % 2 == 0)\nres0: scala.collection.parallel.immutable.ParVector[Int] = ParVector(0, 2, 4, 6, 8, 10, 12, 14, 16, 18,...\n```\n\n----------------------------------------\n\nTITLE: Cross-Version Macro Test with MUnit - Scala\nDESCRIPTION: This test file demonstrates a cross-compatible test suite for the Location macro using MUnit. It checks that invoking Macros.location correctly produces the expected line number regardless of Scala version. The snippet is meant for inclusion in a cross-built module and requires both the macro library and MUnit as dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-macro-mixing.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\n// example-test/src/test/scala/location/MacrosSpec.scala\npackage location\n\nclass MacrosSpec extends munit.FunSuite {\n  test(\"location\") {\n    assertEquals(Macros.location.line, 5)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Calling method with default parameters in Scala 2 and 3\nDESCRIPTION: Shows two ways to invoke the method with and without specifying the optional parameter explicitly in Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-methods.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nmakeConnection(\"https://localhost\")         // url=https://localhost, timeout=5000\nmakeConnection(\"https://localhost\", 2500)   // url=https://localhost, timeout=2500\n```\n\n----------------------------------------\n\nTITLE: Defining Concrete Scala Value Class (Pre-Expansion Example)\nDESCRIPTION: Provides a concrete example of a value class named `Meter` before compiler expansion. It demonstrates defining methods within the value class, including arithmetic operations, comparison, and `toString`, extending `AnyVal` and a universal trait (`Printable`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/value-classes.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n    class Meter(val underlying: Double) extends AnyVal with Printable {\n       def plus (other: Meter): Meter =\n          new Meter(this.underlying + other.underlying)\n       def divide (factor: Double): Meter = new Meter(this.underlying / factor)\n       def less (other: Meter): Boolean = this.underlying < other.underlying\n       override def toString: String = underlying.toString + “m”\n    }\n```\n\n----------------------------------------\n\nTITLE: Using the generic evenElems function in the Scala REPL (Scala 2 and 3)\nDESCRIPTION: This snippet shows REPL usage examples for the generic 'evenElems' function, demonstrating successful calls with concrete types Int and String. The Scala compiler automatically provides the ClassTag instances for these concrete types, enabling runtime creation of the resulting arrays. The output shows arrays containing every second element from the input vectors. This illustrates how context bounds enable seamless generic array creation without manually passing class manifests for concrete types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/arrays.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nscala> evenElems(Vector(1, 2, 3, 4, 5))\nval res6: Array[Int] = Array(1, 3, 5)\n\nscala> evenElems(Vector(\"this\", \"is\", \"a\", \"test\", \"run\"))\nval res7: Array[java.lang.String] = Array(this, a, run)\n```\n\n----------------------------------------\n\nTITLE: Using _root_ prefix to avoid name conflicts in Scala 2\nDESCRIPTION: Illustrates how to explicitly import a package from the root namespace using '_root_', useful when conflicting names exist or to ensure unambiguous references across nested packages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/packages-and-imports.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\npackage accounts\n\nimport _root_.users._\n```\n\n----------------------------------------\n\nTITLE: Defining a Multiline Method in Java\nDESCRIPTION: A method with multiple statements in Java requires the body to be enclosed within curly braces `{}`. Each statement typically ends with a semicolon.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_12\n\nLANGUAGE: Java\nCODE:\n```\npublic void walkThenRun() {\n  System.out.println(\"walk\");\n  System.out.println(\"run\");\n}\n```\n\n----------------------------------------\n\nTITLE: Использование инвариантного типа Pipeline в Scala 2\nDESCRIPTION: Функция oneOf принимает два инвариантных значения Pipeline, параметризованных типом Buyable, и объект b также типа Buyable. Она вызывает метод process у каждого Pipeline и возвращает тот объект, у которого цена ниже. Пример демонстрирует ограничения инвариантности на уровне типов и необходимость точного совпадения обобщений для корректной работы функции.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-variance.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef oneOf(\n  p1: Pipeline[Buyable],\n  p2: Pipeline[Buyable],\n  b: Buyable\n): Buyable = {\n  val b1 = p1.process(b)\n  val b2 = p2.process(b)\n  if (b1.price < b2.price) b1 else b2\n }\n```\n\n----------------------------------------\n\nTITLE: Defining and Calling Short-running Functions in Scala\nDESCRIPTION: This snippet illustrates how to declare a synchronous function aShortRunningTask that immediately returns an Int, and how to assign its result to a variable in Scala. No dependencies beyond the Scala standard library are required. Key parameters and variables include the definition of the function and the binding of its result. The output is a direct assignment of the return value to a variable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/futures.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef aShortRunningTask(): Int = 42\nval x = aShortRunningTask\n```\n\n----------------------------------------\n\nTITLE: For loops with multiple guards in Scala 2 and 3\nDESCRIPTION: Example of for loops with multiple guard conditions, demonstrating how to apply several filters to restrict which iterations are executed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/control-structures.md#_snippet_11\n\nLANGUAGE: Scala 2\nCODE:\n```\nfor {\n  i <- 1 to 10\n  if i > 3\n  if i < 6\n  if i % 2 == 0\n} {\n  println(i)\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nfor\n  i <- 1 to 10\n  if i > 3\n  if i < 6\n  if i % 2 == 0\ndo\n  println(i)\n```\n\n----------------------------------------\n\nTITLE: filter Method Signature in Scala List: Understanding Function Parameter Types\nDESCRIPTION: Shows the Scala List method filter definition, specifying it takes a predicate function p: A => Boolean as input and returns a List[A]. This indicates filter is a higher-order method accepting a function that receives an element of type A and returns a Boolean, used to filter the list elements. This snippet explains the contract and type requirements for passing predicate functions to filter, fundamental for comprehension of Scala HOFs. Requires Scala collection library. Input is the predicate function, output is the filtered list.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-hofs.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ndef filter(p: A => Boolean): List[A]\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Named Fields for Case Classes in Scala\nDESCRIPTION: Demonstrates how to use named field patterns when matching case classes. This allows specifying field names explicitly in any order, with the ability to match only a subset of fields.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-tuples.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ncity match\n  case c @ City(name = \"London\") => println(c.population)\n  case City(name = n, zip = 1026, population = pop) => println(pop)\n```\n\n----------------------------------------\n\nTITLE: Implementing Logarithms with Opaque Types in Scala 3\nDESCRIPTION: A modern implementation using Scala 3's opaque types feature. This approach provides type abstraction without boxing overhead while keeping the implementation simple and the abstraction sound.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-opaque-types.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nobject Logarithms:\n//vvvvvv this is the important difference!\n  opaque type Logarithm = Double\n\n  object Logarithm:\n    def apply(d: Double): Logarithm = math.log(d)\n\n  extension (x: Logarithm)\n    def toDouble: Double = math.exp(x)\n    def + (y: Logarithm): Logarithm = Logarithm(math.exp(x) + math.exp(y))\n    def * (y: Logarithm): Logarithm = x + y\n```\n\n----------------------------------------\n\nTITLE: Summon Implicits in Scala Macros Using Implicits.search and Expr.summon\nDESCRIPTION: Demonstrates searching and retrieving implicit values of type `T` within a macro using the `Implicits.search` API and handling search success or failure to produce an expression or throw a compile-time error. Also shows the simpler wrapper `Expr.summon` as a convenient alternative. This code requires macro context with reflective capabilities and implicit search support introduced in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/best-practices.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef summonOrFail[T: Type]: Expr[T] =\n  val tpe = TypeRepr.of[T]\n  Implicits.search(tpe) match\n    case success: ImplicitSearchSuccess =>\n      val implicitTerm = success.tree\n      implicitTerm.asExprOf[T]\n    case failure: ImplicitSearchFailure =>\n      reflect.report.throwError(\"Could not find an implicit for \" + Type.show[T])\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef summonOrFail[T: Type]: Expr[T] =\n  Expr.summon[T] match\n    case Some(imp) => imp\n    case None => reflect.report.throwError(\"Could not find an implicit for \" + Type.show[T])\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Implementation of Capped2 Class Extending Iterable and IterableOps\nDESCRIPTION: This snippet provides the Scala 3 version of the Capped2 class, utilizing the new syntax for class declaration and method overrides. It extends immutable.Iterable and IterableOps, ensuring methods like map or filter return Capped2 instances. The class includes factory delegation and overriding of collection-building methods for better type safety and performance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nclass Capped2[A] private(val capacity: Int, val length: Int, offset: Int, elems: Array[Any])\n  extends immutable.Iterable[A],\n    IterableOps[A, Capped2, Capped2[A]]:\n  self =>\n\n  def this(capacity: Int) = // as before\n\n  def appended[B >: A](elem: B): Capped2[B] = // as before\n  inline def :+[B >: A](elem: B): Capped2[B] = // as before\n  def apply(i: Int): A = // as before\n\n  def iterator: Iterator[A] = // as before\n\n  override def className = \"Capped2\"\n  override val iterableFactory: IterableFactory[Capped2] = Capped2Factory(capacity)\n  override protected def fromSpecific(coll: IterableOnce[A]): Capped2[A] = iterableFactory.from(coll)\n  override protected def newSpecificBuilder: mutable.Builder[A, Capped2[A]] = iterableFactory.newBuilder\n  override def empty: Capped2[A] = iterableFactory.empty\nend Capped2\n\nclass Capped2Factory(capacity: Int) extends IterableFactory[Capped2]:\n\n  def from[A](source: IterableOnce[A]): Capped2[A] =\n    (newBuilder[A] ++= source).result()\n\n  def empty[A]: Capped2[A] = Capped2[A](capacity)\n\n  def newBuilder[A]: mutable.Builder[A, Capped2[A]] =\n    new mutable.ImmutableBuilder[A, Capped2[A]](empty):\n      def addOne(elem: A): this.type =\n        elems = elems :+ elem; this\nend Capped2Factory\n```\n\n----------------------------------------\n\nTITLE: Testing doNothing Function with Scalaprops - Scala 2\nDESCRIPTION: Defines a property-based test for Example.doNothing using Scalaprops in Scala 2. Requires the 'scalaprops' and 'library-example' dependencies. 'testDoNothing' property checks that doNothing returns its argument unmodified for any Int input. Input: Int; Output: Boolean indicating correctness. Limit: Example.doNothing must exist; suitable only for Scala 2 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\npackage ch.epfl.scala\n\nimport scalaprops.{Property, Scalaprops}\n\nobject Usage extends Scalaprops {\n\n  val testDoNothing =\n// #do-nothing\n    Property.forAll { x: Int =>\n      Example.doNothing(x) == x\n    }\n// #do-nothing\n\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering List with Named Predicate Method in Scala\nDESCRIPTION: Applies the filter method to a List using a previously defined predicate method (lessThanFive). Requires List[Int] ints and the method lessThanFive. Output: new List[Int] where each value is less than five. No dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/anonymous-functions.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nval ints = List.range(1, 10)\nval y = ints.filter(lessThanFive)\n```\n\n----------------------------------------\n\nTITLE: Explicit Anonymous Function Syntax with `map` in Scala\nDESCRIPTION: Shows the most explicit form of an anonymous function used with `map`, including the parameter name (`i`) and its explicit type (`Int`). The `=>` symbol separates the parameter list from the function body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-anonymous-functions.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval doubledInts = ints.map((i: Int) => i * 2)\n```\n\n----------------------------------------\n\nTITLE: Defining `Foo` Type Class and Generic Implicits in Scala\nDESCRIPTION: Sets up a type class derivation example by defining a `Generic` trait with an `Aux` pattern, a `Foo` type class, and several implicit instances for `Foo`. These include instances for base types (`Unit`, `Int`, `String`, `Boolean`), pairs (`fooPair`), and a generic derivation rule (`fooGen`) using `Generic.Aux`. This setup is used to demonstrate divergence issues.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ntrait Generic[T] {\n  type Repr\n}\nobject Generic {\n  type Aux[T, R] = Generic[T] { type Repr = R }\n}\n\ntrait Foo[T]\nobject Foo {\n  implicit val fooUnit: Foo[Unit] = ???\n  implicit val fooInt: Foo[Int] = ???\n  implicit val fooString: Foo[String] = ???\n  implicit val fooBoolean: Foo[Boolean] = ???\n\n  implicit def fooPair[T, U]\n    (implicit fooT: Foo[T], fooU: Foo[U]): Foo[(T, U)] = ???\n\n  implicit def fooGen[T, R]\n    (implicit gen: Generic.Aux[T, R], fr: Foo[R]): Foo[T] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative way of executing blocking code in a Future\nDESCRIPTION: Demonstrates an alternative way of executing blocking code in a Future without using the blocking construct, which has the same effect with a fixed thread pool ExecutionContext.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\nFuture { blockingStuff() }\n```\n\n----------------------------------------\n\nTITLE: Forcing Evaluation of a Lazy Scala SeqView - Scala\nDESCRIPTION: Calls `.force` on a SeqView with multiple lazy map operations to realize and produce a strict sequence (`Seq[Int]`). Forcing triggers evaluation of all deferred transformations, creating a new strict collection containing the fully transformed elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/views.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nres14.force\n```\n\n----------------------------------------\n\nTITLE: Custom JSON serialization with ReadWriter in Scala 2\nDESCRIPTION: Defines a custom ReadWriter for a case class `Bar` to control its JSON serialization and deserialization by mapping `Bar` to a JSON array with specific element order. Requires importing `upickle.default._` and creating implicit instances to enable serialization/deserialization compatibility, providing flexible JSON data representation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-what-else.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport upickle.default._\n\ncase class Bar(i: Int, s: String)\n\nobject Bar {\n  implicit val barReadWriter: ReadWriter[Bar] = readwriter[ujson.Value]\n    .bimap[Bar](\n      x => ujson.Arr(x.s, x.i),\n      json => new Bar(json(1).num.toInt, json(0).str)\n    )\n}\n\nval bar = Bar(5, \"bar\")\nval json = upickle.default.write(bar)\nprintln(json)\n// prints: [5, \"bar\"]\n```\n\n----------------------------------------\n\nTITLE: Converting Collections to Expressions in Scala 3\nDESCRIPTION: This snippet illustrates how to convert various collection types containing quoted expressions into their corresponding expression representations, such as `Expr.ofList`, `Expr.ofSeq`, `Expr.ofTupleFromSeq`, and `Expr.ofTuple`. These methods facilitate code generation involving collections within macros.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/macros.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\n* `Expr.ofList`: Transforms a `List[Expr[T]]` into `Expr[List[T]]`\n* `Expr.ofSeq`: Converts a `Seq[Expr[T]]` into `Expr[Seq[T]]`\n* `Expr.ofTupleFromSeq`: Converts a `Seq[Expr[T]]` into an `Expr` of a tuple\n* `Expr.ofTuple`: Constructs an `Expr` of a tuple from individual `Expr[T1], ..., Expr[Tn]`\n```\n\n----------------------------------------\n\nTITLE: Implementing 'Showable' instance for 'Person' in Scala 3\nDESCRIPTION: Defines a 'given' instance for 'Showable[Person]' using extension syntax to provide a 'show' method, enabling syntax like 'person.show' in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-type-classes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ngiven Showable[Person] with\n  extension (p: Person) def show: String =\n    s\"${p.firstName} ${p.lastName}\"\n```\n\n----------------------------------------\n\nTITLE: Unsound Pattern Matching in Scala 2\nDESCRIPTION: Example of unsound pattern matching in Scala 2 where two Fetch instances are incorrectly assumed to have the same type parameter. This compiles in Scala 2 but is rejected by Scala 3's type checker.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-type-checker.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntrait Request\ncase class Fetch[A](ids: Set[A]) extends Request\n\nobject Request {\n  def combineFetch[A](x: Fetch[A], y: Fetch[A]): Fetch[A] = Fetch(x.ids ++ y.ids)\n\n  def combineReq(x: Request, y: Request): Request = {\n    (x, y) match {\n      case (x @ Fetch(_), y @ Fetch(_)) => combineFetch(x, y)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Semantic Change due to Removed `map` Call in Scala `for` Desugaring\nDESCRIPTION: Illustrates a `for`-comprehension where the new optimization (potentially removing a `map` call associated with `yield a`) could change program behavior if the `map` operation itself had side effects. The intermediate assignment `b = a` is shown, followed by `yield a + b`. The change affects whether an identity `map` call occurs implicitly before the final `yield`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\nfor\n  a <- doSth(arg)\n  b = a\nyield a + b\n```\n\n----------------------------------------\n\nTITLE: Defining Multiline Methods in Scala 2 and Scala 3\nDESCRIPTION: Provides examples of multiline methods, showing differences in syntax between Scala 2 and Scala 3. The method extracts stack trace information from a Throwable by using local variables and multiple statements. Requires importing StringWriter and PrintWriter dependencies for full functionality.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-methods.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef getStackTraceAsString(t: Throwable): String = {\n  val sw = new StringWriter\n  t.printStackTrace(new PrintWriter(sw))\n  sw.toString\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef getStackTraceAsString(t: Throwable): String =\n  val sw = new StringWriter\n  t.printStackTrace(new PrintWriter(sw))\n  sw.toString\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Class with Default Constructor Parameters\nDESCRIPTION: Shows an alternative Scala syntax for handling default values in class constructors using default parameter values directly in the primary constructor definition. This method can often eliminate the need for multiple auxiliary constructors for simple default cases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/classes-aux-constructors.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass Pizza(\n    var crustSize: Int = DefaultCrustSize, \n    var crustType: String = DefaultCrustType\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Exclusive Immutable Ranges in Scala\nDESCRIPTION: Demonstrates creating an immutable `Range` that excludes its upper limit using the `until` method. `1 until 3` generates a range containing elements from 1 up to, but not including, 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-immutable-collection-classes.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nscala> 1 until 3\nres2: scala.collection.immutable.Range = Range(1, 2)\n```\n\n----------------------------------------\n\nTITLE: Runtime Implications of Implicit View Changes\nDESCRIPTION: Example showing potential runtime incompatibilities when migrating implicit views to Scala 3. The compiler might find alternative implicit conversions from a broader scope, causing unexpected behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-contextual-abstractions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntrait Pretty {\n  val print: String\n}\n\nimplicit def anyPretty(any: Any): Pretty = new Pretty { val print = \"any\" }\n\ndef pretty[A](a: A)(implicit ev: A => Pretty): String =\n  a.print // always print \"any\"\n```\n\n----------------------------------------\n\nTITLE: Importing From Root Package in Scala 3\nDESCRIPTION: This Scala 3 code demonstrates importing all non-given members from the 'users' package within the context of the 'accounts' package, resolving scope issues using '_root_'. No additional dependencies or parameters are necessary. This pattern is useful for ensuring global access when local naming introduces conflicts.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/packages-and-imports.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\npackage accounts\n\nimport _root_.users.*\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching in Scala\nDESCRIPTION: Examples of pattern matching in Scala, including matching in function arguments, variable binding, and handling existing values versus pattern variables.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/cheatsheets/index.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n(xs zip ys) map { case (x,y) => x*y }\n```\n\nLANGUAGE: scala\nCODE:\n```\nval v42 = 42\nSome(3) match {\n  case Some(`v42`) => println(\"42\")\n  case _ => println(\"Not 42\")\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval UppercaseVal = 42\nSome(3) match {\n  case Some(UppercaseVal) => println(\"42\")\n  case _ => println(\"Not 42\")\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Abstract Type Member in a Trait - Scala 3\nDESCRIPTION: Defines a trait 'Buffer' with an abstract type 'T' and an abstract value 'element' of that type, using Scala 3's indentation syntax. Subclasses define the actual type 'T'. No dependencies beyond core Scala functionality are required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/abstract-type-members.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Buffer:\n  type T\n  val element: T\n```\n\n----------------------------------------\n\nTITLE: Configuring ForkJoinTaskSupport for Scala Parallel Collections\nDESCRIPTION: This snippet demonstrates how to set the task support of a Scala mutable parallel array to use a ForkJoinTaskSupport with a ForkJoinPool of size 2. It requires importing scala.collection.parallel and creating a parallel collection instance. The key parameter is the ForkJoinPool constructor argument which defines the level of parallelism (number of threads). The output is the parallel collection operating with tasks scheduled via the fork-join thread pool.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/parallel-collections/configuration.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.parallel._\n\nval pc = mutable.ParArray(1, 2, 3)\npc.tasksupport = new ForkJoinTaskSupport(new scala.concurrent.forkjoin.ForkJoinPool(2))\npc map { _ + 1 }\n```\n\n----------------------------------------\n\nTITLE: Scala as a Pure Object-Oriented Language with Number and Function Objects\nDESCRIPTION: Explains that in Scala, numbers and functions are objects with associated methods, unlike Java's primitive types. Demonstrates arithmetic as method calls (e.g., '1 + 2 * 3 / x'), and that functions are first-class objects, enabling passing functions as arguments and storing them in variables—fundamental for functional programming.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tutorials/scala-for-java-programmers.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\n1.+(2.*(3)./(x))  // numbers are objects and can invoke methods\n\n// Function as object example:\nobject Timer {\n  def unaVezPorSegundo(callback: () => Unit) {\n    while (true) {\n      callback()\n      Thread sleep 1000\n    }\n  }\n  def tiempoVuela() {\n    println(\"El tiempo vuela como una flecha...\")\n  }\n  def main(args: Array[String]): Unit = {\n    unaVezPorSegundo(tiempoVuela)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing a LazyList in Scala\nDESCRIPTION: This snippet shows how to construct a finite LazyList containing the integers 1, 2, and 3 using the `#::` operator. It demonstrates the lazy evaluation property where elements are not computed until requested. No additional dependencies beyond standard Scala immutable collections are required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-immutable-collection-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nscala> val lazyList = 1 #:: 2 #:: 3 #:: LazyList.empty\nlazyList: scala.collection.immutable.LazyList[Int] = LazyList(<not computed>)\n```\n\n----------------------------------------\n\nTITLE: Importing Reflection API Components in a Scala Macro\nDESCRIPTION: Illustrates importing all reflection API types and extension methods from the `quotes.reflect` module for use inside a macro method. This enables usage of core entities like Tree, TypeRepr, Symbol, Position, and relevant methods within the macro implementation. The example shows a method signature accepting an `Expr[Int]` and a Quotes context parameter to access reflection features.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/reflection.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.quoted.* // Import `quotes`, `Quotes`, and `Expr`\n\ndef f(x: Expr[Int])(using Quotes): Expr[Int] =\n  import quotes.reflect.* // Import `Tree`, `TypeRepr`, `Symbol`, `Position`, .....\n  val tree: Tree = ...\n  ...\n```\n\n----------------------------------------\n\nTITLE: Handling inline methods with @publicInBinary and compiler-generated accessors (Scala)\nDESCRIPTION: This example demonstrates a Scala class with methods annotated and not annotated with @publicInBinary, alongside an inline method that references them. The compiler generates explicit accessors for non-@publicInBinary private/protected members used in inline methods, ensuring binary compatibility. The snippet shows both the original and expanded classes with generated accessor methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/binary-api.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.annotation.publicInBinary\nclass C {\n  @publicInBinary private[C] def a: Int = ...\n  private[C] def b: Int = ...\n  @publicInBinary protected def c: Int = ...\n  protected def d: Int = ...\n  inline def foo: Int = a + b + c + d\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass C {\n  @publicInBinary private[C] def a: Int = ...\n  private[C] def b: Int = ...\n  @publicInBinary protected def c: Int = ...\n  protected def d: Int = ...\n  final def C$$inline$b: Int = ...\n  final def C$$inline$d: Int = ...\n  inline def foo: Int = a + C$$inline$b + c + C$$inline$d\n}\n```\n\n----------------------------------------\n\nTITLE: Defining No-Parameter, Unit-Return Functions Compatible With HOF in Scala\nDESCRIPTION: Provides example functions helloJoe and bonjourJulien that match the signature () => Unit, making them valid arguments for the higher-order method sayHello. Each defined function prints a greeting message to the console. These functions demonstrate creating methods with no parameters and returning Unit, suitable for passing as callbacks or actions. Both functions require the Scala standard library and no external dependencies. They take no inputs and their output is Unit after printing to console.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-hofs.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef helloJoe(): Unit = println(\"Hello, Joe\")\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef bonjourJulien(): Unit = println(\"Bonjour, Julien\")\n```\n\n----------------------------------------\n\nTITLE: Extending Opaque Type Logarithm with Additional Operations in Scala\nDESCRIPTION: Provides a user-defined extension method on the opaque type Logarithm defining a power operator '**'. This method leverages existing operations on Logarithm, showcasing how users can create new behavior without modifying the original companion or invalidating the opaque type constraints.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/opaque-types.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\npackage object usesites {\n  // ...\n  implicit class UserOps(`this`: Logarithm) extends AnyVal {\n    def **(that: Logarithm): Logarithm = Logarithm(`this` * that)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Java Interoperability: Formatting Date in Scala with Java Classes\nDESCRIPTION: This snippet demonstrates importing Java utility classes in Scala to retrieve and format the current date locale-specific. It showcases Scala's import syntax, method calling style, and infix notation for single-argument methods. Dependencies include Java standard library; input is no parameters; output is a formatted date string.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tutorials/scala-for-java-programmers.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport java.util.{Date, Locale}\nimport java.text.DateFormat._\n\nobject DateFrancaise {\n  def main(args: Array[String]): Unit = {\n    val maintenant = new Date\n    val df = getDateInstance(LONG, Locale.FRANCE)\n    println(df format maintenant)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: 複数行式を持つメソッド定義 - Scala\nDESCRIPTION: メソッド本体に複数行のロジックを記述する例です。数値の平方を計算し、結果を文字列として返す処理をブロックで明確に示しています。最終行が戻り値となります。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ndef getSquareString(input: Double): String = {\n  val square = input * input\n  square.toString\n}\nprintln(getSquareString(2.5)) // 6.25\n```\n\n----------------------------------------\n\nTITLE: Equality Check with contains Pattern - Scala\nDESCRIPTION: This code describes how Option.contains is implemented using pattern matching. Returns true if the Option contains a value equal to y, else false. Inputs are Option and a value y; output is Boolean. No external dependencies required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\noption match {\n  case Some(x) => x == y\n  case None    => false\n}\n```\n\n----------------------------------------\n\nTITLE: 继承与上下文函数：定义数字DSL扩展\nDESCRIPTION: 定义`NumsDSL`拓展`Nums`，加入扩展方法`+`和`*`，在语法层简化表达式。`const`函数通过`using`声明依赖`Nums`的隐式参数，实现灵活调用，避免在每次调用中显式传递参数。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-dependent-function.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ntrait NumsDSL extends Nums:\n  extension (x: Num)\n    def +(y: Num) = add(x, y)\n    def *(y: Num) = mul(x, y)\n\n def const(d: Double)(using n: Nums): n.Num = n.lit(d)\n\n type Prog = (n: NumsDSL) ?=> n.Num => n.Num\n```\n\n----------------------------------------\n\nTITLE: Initializing an Empty TreeSet with Custom Ordering in Scala\nDESCRIPTION: Creates an empty immutable TreeSet[String] in Scala using a previously defined custom ordering. This sets up a sorted set structure where elements will be ordered according to the provided ordering instead of the default natural order.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/sets.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nTreeSet.empty(myOrdering)\n```\n\n----------------------------------------\n\nTITLE: Concise foldLeft using underscore notation with multiple parameter lists\nDESCRIPTION: This snippet demonstrates the idiomatic Scala way of using underscore notation for lambda functions with multiple parameter lists, resulting in concise code that adds all elements in a list.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/multiple-parameter-lists.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nnumbers.foldLeft(0)(_ + _)\n```\n\n----------------------------------------\n\nTITLE: Removing Elements from a Mutable Buffer in Scala\nDESCRIPTION: Covers the removal of one or more elements by value or by position using subtractOne, subtractAll, remove, trimStart, trimEnd, and clear. Requires a mutable Buffer implementation with elements to remove or index/range parameters for targeted operations. Inputs may be a value, a collection of values, indices, or counts; outputs are buffers with specified elements removed. Note that remove and trim operations mutate the original buffer and may raise errors if indices are out of range.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/seqs.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nbuf.subtractOne(x)\nbuf -= x\nbuf.subtractAll(xs)\nbuf --= xs\nbuf.remove(i)\nbuf.remove(i, n)\nbuf.trimStart(n)\nbuf.trimEnd(n)\nbuf.clear()\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication Service with Cookies in Cask (Scala 2)\nDESCRIPTION: This snippet shows a rudimentary authentication service built with the Cask web framework in Scala 2. It requires Java standard library classes (java.util.UUID, java.util.concurrent.ConcurrentHashMap) and Cask routes/decorator classes. Endpoints implemented include user login (generates and stores a session ID in a cookie upon success), login status check (reads the cookie directly from the request), and logout (removes session and expires cookie). Inputs are username and password on login, and the 'sessionId' cookie for session tracking. Outputs are HTML pages or plain text HTTP responses. The code must be run as a main object extending cask.MainRoutes, and sessions are stored in a thread-safe key set. Ensure Cask and all related dependencies are present.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/web-server-cookies-and-decorators.md#_snippet_0\n\nLANGUAGE: Scala 2\nCODE:\n```\nimport java.util.UUID\nimport java.util.concurrent.ConcurrentHashMap\n\nobject Example extends cask.MainRoutes {\n\n  val sessionIds = ConcurrentHashMap.newKeySet[String]()\n\n  @cask.get(\"/login\")\n  def getLogin(): cask.Response[String] = {\n    val html =\n      \"\"\"<!doctype html>\n        |<html>\n        |<body>\n        |<form action=\"/login\" method=\"post\">\n        |  <label for=\"name\">Username:</label><br>\n        |  <input type=\"text\" name=\"name\" value=\"\"><br>\n        |  <label for=\"password\">Password:</label><br>\n        |  <input type=\"text\" name=\"password\" value=\"\"><br><br>\n        |  <input type=\"submit\" value=\"Submit\">\n        |</form>\n        |</body>\n        |</html>\"\"\".stripMargin\n\n    cask.Response(data = html, headers = Seq(\"Content-Type\" -> \"text/html\"))\n  }\n\n  @cask.postForm(\"/login\")\n  def postLogin(name: String, password: String): cask.Response[String] = {\n    if (name == \"user\" && password == \"password\") {\n      val sessionId = UUID.randomUUID().toString\n      sessionIds.add(sessionId)\n      cask.Response(data = \"Success!\", cookies = Seq(cask.Cookie(\"sessionId\", sessionId)))\n    } else {\n      cask.Response(data = \"Authentication failed\", statusCode = 401)\n    }\n  }\n\n  @cask.get(\"/check\")\n  def checkLogin(request: cask.Request): String = {\n    val sessionId = request.cookies.get(\"sessionId\")\n    if (sessionId.exists(cookie => sessionIds.contains(cookie.value))) {\n      \"You are logged in\"\n    } else {\n      \"You are not logged in\"\n    }\n  }\n\n  @cask.get(\"/logout\")\n  def logout(sessionId: cask.Cookie) = {\n    sessionIds.remove(sessionId.value)\n    cask.Response(data = \"Successfully logged out!\", cookies = Seq(cask.Cookie(\"sessionId\", \"\", expires = Instant.EPOCH)))\n  }\n\n  initialize()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Inline Methods for Compile-Time Code Expansion in Scala 3\nDESCRIPTION: This snippet demonstrates how to define an inline method `logged` for compile-time inlining of logging behavior. It explains the inlining process, substitution of parameters, and how different parameter types (`by-value`, `by-name`, `inline`) are handled to preserve semantic correctness.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ninline def logged[T](level: Int, message: => String)(inline op: T): T =\n  println(s\"[$level]Computing $message\")\n  val res = op\n  println(s\"[$level]Result of $message: $res\")\n  res\n```\n\nLANGUAGE: Scala\nCODE:\n```\nlogged(logLevel, getMessage()) {\n  computeSomething()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Type Alias in Scala\nDESCRIPTION: Demonstrates how to define a type alias `Environment` for the function type `String => Int` using the `type` keyword, improving code readability and maintainability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tutorials/scala-for-java-programmers.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ntype Environment = String => Int\n```\n\n----------------------------------------\n\nTITLE: Operator Precedence Evaluation Example\nDESCRIPTION: Shows the same expression parsed according to precedence rules, illustrating that operators with higher precedence (e.g., '?^') are evaluated before others according to Scala's rules.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/operators.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\n((a + b) ^? (c ?^ d)) less ((a ==> b) | c)\n```\n\n----------------------------------------\n\nTITLE: Sample Output of the Interactive Hello World Program (Bash)\nDESCRIPTION: This snippet shows a typical interaction session with the `helloInteractive` program. After being prompted, the user inputs the name \"Alvin Alexander\". The program responds by printing a personalized greeting, \"Hello, Alvin Alexander!\". This output verifies correct functioning of command line input reading and string concatenation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-hello-world.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ scala helloInteractive\nPlease enter your name:\nAlvin Alexander\nHello, Alvin Alexander!\n```\n\n----------------------------------------\n\nTITLE: Filter Operation Using List Comprehension in Python\nDESCRIPTION: Demonstrates filtering elements in 'numbers' to retain only even values using a Python list comprehension with a conditional 'if'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_27\n\nLANGUAGE: Python\nCODE:\n```\nevens = [i for i in numbers if i % 2 == 0]\n```\n\n----------------------------------------\n\nTITLE: Creating InstanceMirror for Reflecting on Object Instances in Scala\nDESCRIPTION: This snippet shows how to create an InstanceMirror, which allows reflection on methods, fields, and nested classes or modules of an object instance. Using the runtime mirror, an instance mirror is generated by reflecting on a newly created object. This requires the Scala reflection runtime and the previously obtained runtime mirror. The input is an object instantiation, and the output is an instance mirror bound to that object instance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/reflection/environment-universes-mirrors.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nscala> class C { def x = 2 }\ndefined class C\n\nscala> val im = m.reflect(new C)\nim: scala.reflect.runtime.universe.InstanceMirror = instance mirror for C@3442299e\n```\n\n----------------------------------------\n\nTITLE: Transforming Host Class/Object via Template Expansion in Scala Type Macros\nDESCRIPTION: Shows how a type macro can transform its enclosing class or object by returning a `Template` tree that rewrites or extends the class/object body. The example obtains the existing template code from `c.enclosingTemplate` and appends generated code to it. This expands the macro invocation to a new class/object body that includes both the original and generated code, enabling powerful structural transformations at compile-time. Requires Scala macro API context and knowledge of compiler AST trees. Inputs include the macro context and macro arguments; output is an expanded `Template` tree.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/typemacros.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntype H2Db(url: String) = macro impl\n\ndef impl(c: Context)(url: c.Expr[String]): c.Tree = {\n  val Template(_, _, existingCode) = c.enclosingTemplate\n  Template(..., existingCode ++ generateCode())\n}\n\nobject Db extends H2Db(\"coffees\")\n// equivalent to: object Db {\n//   <existing code>\n//   <generated code>\n// }\n```\n\n----------------------------------------\n\nTITLE: Using map on Scala Iterator to transform elements\nDESCRIPTION: Demonstrates creating a new iterator with the map method to transform elements, e.g., computing string lengths. It highlights that calling map does not consume the original iterator, but traversing the mapped iterator advances the original one as well.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/iterators.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval it = Iterator(\"a\", \"number\", \"of\", \"words\")\nval res1 = it.map(_.length)\nprintln(res1.hasNext)\nres1.foreach(println)\nprintln(it.hasNext)\n```\n\n----------------------------------------\n\nTITLE: Explicit Type Casting in Scala\nDESCRIPTION: Shows how explicit type casting is required when conversion might result in loss of precision. Demonstrates conversion from Long to Float requiring the toFloat method, and how attempting to cast back results in an error.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/first-look-at-types.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nval x: Long = 987654321\nval y: Float = x.toFloat  // 9.8765434E8 (обратите внимание, что требуется `.toFloat`, потому что приведение приводит к потере точности)\nval z: Long = y  // Ошибка\n```\n\n----------------------------------------\n\nTITLE: Создание и использование неизменяемой очереди Queue в Scala\nDESCRIPTION: Демонстрирует создание пустой очереди, добавление элементов с помощью метода `enqueue`, вставку нескольких элементов через `enqueueAll` и удаление с помощью `dequeue`. Операции являются неизменяемыми и возвращают новые экземпляры очереди или пару из элемента и оставшейся части очереди.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/concrete-immutable-collection-classes.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val empty = scala.collection.immutable.Queue[Int]()\nempty: scala.collection.immutable.Queue[Int] = Queue()\nscala> val has1 = empty.enqueue(1)\nhas1: scala.collection.immutable.Queue[Int] = Queue(1)\nscala> val has123 = has1.enqueueAll(List(2, 3))\nhas123: scala.collection.immutable.Queue[Int] = Queue(1, 2, 3)\nscala> val (element, has23) = has123.dequeue\nelement: Int = 1\nhas23: scala.collection.immutable.Queue[Int] = Queue(2, 3)\n```\n\n----------------------------------------\n\nTITLE: Фильтрация и преобразование неизменяемых коллекций в Scala\nDESCRIPTION: Данный код показывает, как создать список чисел, применить последовательные операции 'filter' для отбора элементов, и затем 'map' для их преобразования. Использует цепочку методов для работы с неизменяемыми коллекциями, избегая их изменения, а создавая новые коллекции в каждом шаге.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-functions.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n// пример списка\nval nums = (1 to 10).toList   // List(1,2,3,4,5,6,7,8,9,10)\n\n// методы могут быть сцеплены вместе\nval x = nums.filter(_ > 3)\n            .filter(_ < 7)\n            .map(_ * 10)\n\n// result: x == List(40, 50, 60)\n```\n\n----------------------------------------\n\nTITLE: Defining Animal and Pet Class Hierarchy in Scala\nDESCRIPTION: These class definitions establish a hierarchy for animals and pets used in demonstrating upper type bounds. `Animal` is the base class, with `Pet` extending it, and specific animals like `Cat`, `Dog`, and `Lion` extending either `Pet` or `Animal`. The hierarchy informs type constraints used in `PetContainer`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/upper-type-bounds.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Animal {\n def name: String\n}\n\nabstract class Pet extends Animal {}\n\nclass Cat extends Pet {\n  override def name: String = \"Cat\"\n}\n\nclass Dog extends Pet {\n  override def name: String = \"Dog\"\n}\n\nclass Lion extends Animal {\n  override def name: String = \"Lion\"\n}\n```\n\n----------------------------------------\n\nTITLE: Sample Data for Collection Examples in Scala\nDESCRIPTION: Initialization of sample data collections used throughout the examples, including a list of integers from 1 to 10 and a list of names.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-methods.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval oneToTen = (1 to 10).toList\nval names = List(\"adam\", \"brandy\", \"chris\", \"david\")\n```\n\n----------------------------------------\n\nTITLE: Interacting with Java Date and DateFormat Classes in Scala\nDESCRIPTION: Illustrates importing Java classes 'Date' and 'Locale' via Scala's import syntax, creating and formatting dates using Java's 'DateFormat'. Demonstrates Scala's powerful import capabilities and usage of static methods with infix syntax, e.g., 'df format ahora' equating to 'df.format(ahora)'. Emphasizes Scala's Java interoperability for date handling.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tutorials/scala-for-java-programmers.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport java.util.{Date, Locale}\nimport java.text.DateFormat._\n\nobject FrenchDate {\n  def main(args: Array[String]): Unit = {\n    val ahora = new Date\n    val df = getDateInstance(LONG, Locale.FRANCE)\n    println(df format ahora)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel and Sequential HashMap Map Benchmarks in Scala\nDESCRIPTION: Benchmarks comparing parallel and sequential map operations on HashMap. Configures the parallel version with custom task support and allows for varying collection sizes to determine performance thresholds.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/parallel-collections/performance.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport collection.parallel.mutable.ParHashMap\n\nobject Map extends testing.Benchmark {\n  val length = sys.props(\"length\").toInt\n  val par = sys.props(\"par\").toInt\n  val phm = ParHashMap((0 until length) zip (0 until length): _*)\n\n  phm.tasksupport = new collection.parallel.ForkJoinTaskSupport(new scala.concurrent.forkjoin.ForkJoinPool(par))\n\n  def run = {\n    phm map {\n      kv => kv\n    }\n  }\n}\n\nobject MapSeq extends testing.Benchmark {\n  val length = sys.props(\"length\").toInt\n  val hm = collection.mutable.HashMap((0 until length) zip (0 until length): _*)\n\n  def run = {\n    hm map {\n      kv => kv\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Compatibility Issues with Named Tuples - Assignment in Parentheses\nDESCRIPTION: Illustrates a source compatibility issue where an assignment in parentheses would now be interpreted as a named tuple of arity one.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-tuples.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nvar age: Int\n(age = 1)\n```\n\n----------------------------------------\n\nTITLE: Completing a Promise with Another Future - Scala\nDESCRIPTION: Demonstrates the usage of completeWith to complete a Promise with the result of an existing Future. The Promise’s future mirrors the result of the provided Future after completion. Dependencies: scala.concurrent.{ Future, Promise }. Inputs: a Future; outputs: resolved value or exception, passed to the Promise and its future. Used for delegating completion and bridging between existing asynchronous tasks. Promise is completed as soon as the other Future completes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/futures-promises.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\nval f = Future { 1 }\nval p = Promise[Int]()\n\np completeWith f\n\np.future onSuccess {\n  case x => println(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Actual Current Desugaring of Pure Aliases\nDESCRIPTION: Reveals the actual, more complex desugaring generated by the Scala 3 compiler for a pure alias following a generator. It involves creating an intermediate tuple `(a, b)` and an extra `map` call, primarily to handle the potential presence of an `if` guard immediately after the alias.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ndoSth(arg).map { a =>\n  val b = a\n  (a, b)\n}.map { case (a, b) =>\n  a + b\n}\n```\n\n----------------------------------------\n\nTITLE: Auxiliary Constructors in Scala 3 Class\nDESCRIPTION: Defines a Scala class Person with a primary constructor and multiple auxiliary constructors implemented as def this(...) methods. Each auxiliary constructor delegates to the primary one with default values, providing zero-, one-, and two-argument variants. Illustrates Scala's concise syntax for constructor overloading without Java-style chaining.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass Person (\n  var firstName: String,\n  var lastName: String,\n  var age: Int\n):\n    // zero-arg auxiliary constructor\n    def this() = this(\"\", \"\", 0)\n\n    // one-arg auxiliary constructor\n    def this(firstName: String) = \n      this(firstName, \"\", 0)\n\n    // two-arg auxiliary constructor\n    def this(\n      firstName: String,\n      lastName: String\n    ) = \n      this(firstName, lastName, 0)\n\nend Person\n```\n\n----------------------------------------\n\nTITLE: Propagating ClassManifest Requirement using Context Bound in Scala\nDESCRIPTION: This Scala function `tabTen` demonstrates how to propagate the need for a `ClassManifest` when calling a function like `tabulate` with a type parameter `T`. The context bound `[T: ClassManifest]` is syntactic sugar for requiring an implicit `ClassManifest[T]`, ensuring that the necessary runtime type information is available and passed implicitly to the `tabulate` function.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/scala-2-8-arrays.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef tabTen[T: ClassManifest](f: Int => T) = tabulate(10, f)\n```\n\n----------------------------------------\n\nTITLE: Instantiating Generic Collections in Scala\nDESCRIPTION: Shows how to instantiate various generic collections—such as Traversable, Iterable, Map, Set, SortedSet, Buffer, IndexedSeq, and LinearSeq—using uniform syntax. These constructors are part of the Scala standard library and require only the corresponding collection imports. Inputs are the elements passed to the collection factory, and output is the initialized collection instance. This illustrates Scala's consistent and readable collection initialization approach.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/overview.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nTraversable(1, 2, 3)\nIterable(\"x\", \"y\", \"z\")\nMap(\"x\" -> 24, \"y\" -> 25, \"z\" -> 26)\nSet(Color.red, Color.green, Color.blue)\nSortedSet(\"hello\", \"world\")\nBuffer(x, y, z)\nIndexedSeq(1.0, 2.0)\nLinearSeq(a, b, c)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Problematic map/++ Behavior for RNA Class (Scala)\nDESCRIPTION: Demonstrates scenarios where transformation operations should *not* return an `RNA` instance. Mapping `Base` elements to a different type (`Int` in this case) or concatenating (`++`) with a collection of a different type (`List[String]`) should yield a more general sequence type, like `IndexedSeq`. This code works in both Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nscala> rna.map(Base.toInt)\nval res2: IndexedSeq[Int] = Vector(0, 1, 2, 2, 3)\n\nscala> rna ++ List(\"missing\", \"data\")\nval res3: IndexedSeq[java.lang.Object] =\n  Vector(A, U, G, G, C, missing, data)\n```\n\n----------------------------------------\n\nTITLE: Defining a method with implicit parameter in Scala\nDESCRIPTION: This snippet defines a method that includes an explicitly specified parameter and an implicit parameter, illustrating how implicit parameters are declared in Scala using multiple parameter lists. It enables implicit context passing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/multiple-parameter-lists.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef execute(arg: Int)(implicit ec: scala.concurrent.ExecutionContext) = ???\n```\n\n----------------------------------------\n\nTITLE: Accessing Previous Definitions in mdoc Scala Snippets\nDESCRIPTION: Illustrates how a standard `mdoc` Scala snippet can access definitions (like the `now()` method defined in the first `mdoc` block) made in preceding non-nested, non-reset snippets within the same document. The nested `Foo` definition does not interfere.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/add-guides.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc\nval a = s\"The time is ${now()}\" // still have access to the now method from above\n```\n```\n\n----------------------------------------\n\nTITLE: Executing Multi-Line Conditional Blocks with 'if' in Scala\nDESCRIPTION: Shows how to execute a block of code conditionally using an `if` statement in Scala 2 (with curly braces) and Scala 3 (with indentation or optional braces). Prints two lines if `x` equals 1.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_1\n\nLANGUAGE: Scala 2\nCODE:\n```\nif (x == 1) {\n  println(\"x is 1, as you can see:\")\n  println(x)\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nif x == 1 then\n  println(\"x is 1, as you can see:\")\n  println(x)\n```\n\n----------------------------------------\n\nTITLE: Avoid Nested Contexts in Scala Quoted Macros\nDESCRIPTION: Illustrates how to avoid using nested quote contexts (`quotes.Nested`) by passing all needed `Expr` instances explicitly and using a regular `Quotes` context. This approach allows defining functions outside local scopes and simplifies macro implementations. Shows two variants: one using nested context and one refactored to use explicit parameters with a standard Quotes context. Requires Scala 3 macro quoting.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/best-practices.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval y: Expr[Int] = ...\ndef body(x: Expr[Int])(using quotes.Nested) =  '{ $x + $y }\n'{ (x: Int) => ${ body('x) } }\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef body(x: Expr[Int], y: Expr[Int])(using Quotes) =\n  '{ $x + $y }\n\nval y: Expr[Int] = ...\n'{ (x: Int) => ${ body('x, y) } }\n```\n\n----------------------------------------\n\nTITLE: Installing GraalVM Native Image Component\nDESCRIPTION: Uses the GraalVM Updater ('gu') utility, expected to be in the PATH after environment setup, to install the 'native-image' component. This component is essential for compiling Java or Scala applications ahead-of-time into standalone native executables.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-on-android.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngu install native-image\n```\n\n----------------------------------------\n\nTITLE: Instantiating Parallel Collections Directly in Scala\nDESCRIPTION: Demonstrates creating an empty parallel collection (`ParVector`) directly using the `new` keyword. This requires importing the specific parallel collection class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/overview.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.parallel.immutable.ParVector\nval pv = new ParVector[Int]\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Generic Type Parameters in Scala\nDESCRIPTION: Illustrates the convention for simple generic type parameters using a single upper-case letter starting with 'A'. The example shows a generic 'List' class with a type parameter 'A' and a 'map' method introducing another type parameter 'B'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/naming-conventions.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nclass List[A] {\n  def map[B](f: A => B): List[B] = ...\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Tuples in Scala\nDESCRIPTION: Demonstrates how to destructure a tuple using pattern matching to assign individual elements to variables.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/tuples.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval (nome, quantidade) = ingrediente\nprintln(nome) // Açucar\nprintln(quantidade) // 25\n```\n\n----------------------------------------\n\nTITLE: Creating and copying immutable FP style records in Python and Scala\nDESCRIPTION: Demonstrates creating immutable instances and updating fields using Python's replace function and Scala's copy method. Dependencies are same as previous snippet. Inputs are initial values and updated fields; outputs are new instances with updated values preserving immutability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nval p = Person(\"Alice\", 42)\np.name  // Alice\nval p2 = p.copy(age = 43)\n```\n\n----------------------------------------\n\nTITLE: Using Blocks to Group Expressions in Scala\nDESCRIPTION: Shows how a block delimited by curly braces can group multiple expressions, where the final value is the result of the block. Useful for controlling scope and sequential evaluation in scripts or functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nprintln({\n  val x = 1 + 1\n  x + 1\n}) // 3\n```\n\n----------------------------------------\n\nTITLE: Using a Companion Object to Define Private Helper Members in Scala\nDESCRIPTION: Shows a pattern where a class imports all members from its companion object, enabling the class to utilize private helper methods defined in the companion object. In this example, the class 'X' imports 'X._', allowing it to call the private method 'foo' defined in the companion object 'X'. The private method 'foo' returns 42 and can be accessed within the class due to the 'friend' relationship between a class and its companion object in Scala. This pattern facilitates encapsulation while sharing implementation details between class and companion object members.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/singleton-objects.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass X {\n  import X._\n\n  def blah = foo\n}\n\nobject X {\n  private def foo = 42\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing an Immutable List of Integers in Scala\nDESCRIPTION: Creates an immutable `List` of integers using the standard `List(...)` syntax in Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nval ints = List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Defining a PizzaServiceInterface Trait in Scala 3\nDESCRIPTION: Example of creating a service interface for Pizza-related operations using a trait in Scala 3 syntax, defining the behavior contract.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-fp.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ntrait PizzaServiceInterface:\n\n  def price(p: Pizza): Double\n\n  def addTopping(p: Pizza, t: Topping): Pizza\n  def removeAllToppings(p: Pizza): Pizza\n\n  def updateCrustSize(p: Pizza, cs: CrustSize): Pizza\n  def updateCrustType(p: Pizza, ct: CrustType): Pizza\n```\n\n----------------------------------------\n\nTITLE: Parenthesized Expressions vs. Tuple1\nDESCRIPTION: Illustrates that using parentheses around a single expression `q\"(a)\"` does not create a `Tuple1` AST but returns the expression itself (an `Ident` in this case). There is no direct quasiquote syntax for `Tuple1`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_34\n\nLANGUAGE: scala\nCODE:\n```\nscala> val inparens = q\"(a)\"\ninparens: universe.Ident = a\n```\n\n----------------------------------------\n\nTITLE: Declaring Numeric Types in Scala\nDESCRIPTION: Shows how to declare various numeric types in Scala, including Int, Double, and how type inference works. Also demonstrates the use of BigInt and BigDecimal for large numbers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nval i = 1     // Int\nval d = 1.1   // Double\n```\n\nLANGUAGE: scala\nCODE:\n```\nval a: Byte = 0    // Byte = 0\nval a: Double = 0  // Double = 0.0\nval a: Float = 0   // Float = 0.0\nval a: Int = 0     // Int = 0\nval a: Long = 0    // Long = 0\nval a: Short = 0   // Short = 0\n\nval x = BigInt(1_234_456_789)\nval y = BigDecimal(1_234_456.890)\n```\n\n----------------------------------------\n\nTITLE: Creating Scala Shebang Script with Scala-CLI (Shell/Scala)\nDESCRIPTION: Provides a practical example of using the `scala-cli shebang` command directly within a Unix shebang line (`#!`). This allows a script file containing Scala code to be directly executable. The shebang line specifies the `scala-cli` executable, the `shebang` command, and any required options like `--scala-version` before the inline Scala code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/scala-cli.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n#!/usr/bin/env -S scala-cli shebang --scala-version 2.13\nprintln(\"Hello, world)\n```\n\n----------------------------------------\n\nTITLE: Creating a class hierarchy for a bookstore\nDESCRIPTION: Defines a Book trait and two implementation classes (PrintedBook and AudioBook) for a bookstore domain model.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-multiversal-equality.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n// [2] create your class hierarchy\ntrait Book:\n    def author: String\n    def title: String\n    def year: Int\n\ncase class PrintedBook(\n    author: String,\n    title: String,\n    year: Int,\n    pages: Int\n) extends Book\n\ncase class AudioBook(\n    author: String,\n    title: String,\n    year: Int,\n    lengthInMinutes: Int\n) extends Book\n```\n\n----------------------------------------\n\nTITLE: 値の明示的な型指定 - Scala\nDESCRIPTION: valで定義した値に明示的に型(Int)を指定する例です。Scalaの型注釈の書き方（識別子の後にコロン、続けて型指定）を示しています。動作としては型安全性の向上やドキュメント効果があります。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval x: Int = 1 + 1\n```\n\n----------------------------------------\n\nTITLE: Scala.js Compiled Output for Static Members - JavaScript\nDESCRIPTION: Presents the corresponding JavaScript code generated by Scala.js for the preceding Scala example using `@static`. It shows how static methods are defined directly on the class and how static fields are assigned to the class object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/static-members.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nclass Foo extends Object {\n  static bar(y) {\n    return x + y;\n  }\n}\nFoo.x = 5; // in ES6, there is no declarative syntax for static fields yet\n```\n\n----------------------------------------\n\nTITLE: Formal Desugaring Rule for Aliases Followed by Guard (Proposal 2)\nDESCRIPTION: Specifies the modified desugaring rule for the case where a generator is followed by N aliases, which are then followed by an `if` guard (`E`). This rule preserves the existing complex desugaring logic involving tuple creation and `withFilter`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_16\n\nLANGUAGE: text\nCODE:\n```\nFor any N:\n  for (P <- G; P_1 = E_1; ... P_N = E_N; if E; ...) \n    ==> \n  for (TupleN(P, P_1, ... P_N) <-\n    for (x @ P <- G) yield {\n      val x_1 @ P_1 = E_2\n      ...\n      val x_N @ P_N = E_N\n      TupleN(x, x_1, ..., x_N)\n    }; if E; ...)\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Scala Utility Object - Scala\nDESCRIPTION: Implements a MathUtils singleton object in the 'math' package, providing a static double method that multiplies an integer by 2. No dependencies other than standard Scala. Input: Int; Output: Int (doubled value). Useful for demonstrating ScalaTest or other test frameworks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\npackage math\n\nobject MathUtils:\n  def double(i: Int) = i * 2\n\n```\n\n----------------------------------------\n\nTITLE: Scala Quasiquote Pattern for Object Definition\nDESCRIPTION: Presents the general Scala quasiquote pattern for matching or constructing an object definition AST. The structure resembles a class definition but excludes constructor parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/definition-details.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nq\"$mods object $tname extends { ..$earlydefns } with ..$parents { $self => ..$stats }\"\n```\n\n----------------------------------------\n\nTITLE: Generic sum function for lists using implicit Monoid in Scala\nDESCRIPTION: This method, sum, takes a list of elements of type A and an implicit Monoid instance for A. It recursively sums the list elements by combining them with the add method and uses the unit value as the initial accumulator. The implicit parameter allows Scala to inject the appropriate Monoid instance based on the element type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/implicit-parameters.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef sum[A](xs: List[A])(implicit m: Monoid[A]): A =\n  if (xs.isEmpty) m.unit\n  else m.add(xs.head, sum(xs.tail))\n```\n\n----------------------------------------\n\nTITLE: Registering Success-Only Callbacks with onSuccess - Scala\nDESCRIPTION: Examines the use of onSuccess to register a callback that is triggered only when a Future completes successfully. Requires scala.concurrent.Future; session and render must be defined. The Future yields a list of recent posts which are rendered if present; the callback is never called if the Future fails. Note: onSuccess discards its result and should not be chained.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/futures-promises.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval f: Future[List[String]] = Future {\n  session.getRecentPosts\n}\n\nf onSuccess {\n  case posts => for (post <- posts) render(post)\n}\n```\n\n----------------------------------------\n\nTITLE: Using map combinator on Futures for currency trading in Scala 3\nDESCRIPTION: Scala 3 version of the map-based refactoring which avoids callback nesting. Uses the dot syntax for 'map' and the concise conditional expression with 'then' to create a transformed Future. The 'foreach' processes the purchase result asynchronously with a side effect of printing the purchase amount.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\nval rateQuote = Future {\n  connection.getCurrentValue(USD)\n}\n\nval purchase = rateQuote.map { quote =>\n  if isProfitable(quote) then connection.buy(amount, quote)\n  else throw Exception(\"not profitable\")\n}\n\npurchase.foreach { amount =>\n  println(\"Purchased \" + amount + \" USD\")\n}\n```\n\n----------------------------------------\n\nTITLE: Computing Square Roots using ParTrieMap in Scala\nDESCRIPTION: This example demonstrates using a ParTrieMap to compute square roots of numbers from 1 to 99. It showcases the ability to mutate the collection during iteration, with each iteration improving the square root approximation until the desired precision is reached.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/overviews/parallel-collections/concrete-parallel-collections.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval numbers = scala.collection.parallel.mutable.ParTrieMap((1 until 100) zip (1 until 100): _*) map { case (k, v) => (k.toDouble, v.toDouble) }\n\nwhile (numbers.nonEmpty) {\n  numbers foreach { case (num, sqrt) =>\n    val nsqrt = 0.5 * (sqrt + num / sqrt)\n    numbers(num) = nsqrt\n    if (math.abs(nsqrt - sqrt) < 0.01) {\n      println(num, nsqrt)\n      numbers.remove(num)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Subclassing with Constructor Parameter Forwarding in Scala\nDESCRIPTION: Demonstrates Scala inheritance where a subclass passes constructor parameters to its superclass using parameter forwarding syntax. Both classes accept a constructor parameter of type R, and the subclass forwards the parameter to the superclass constructor, enabling proper initialization at superclass level. This snippet depends on correct type definitions and constructor matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/cheatsheets/index.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass D(var x: R)\nclass C(x: R) extends D(x)\n```\n\n----------------------------------------\n\nTITLE: Declaring a Singleton Object in Scala\nDESCRIPTION: Demonstrates how to declare a basic singleton object using the 'object' keyword in Scala, serving as a lazily instantiated, globally accessible entity. Shows syntax for Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/singleton-objects.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject Box\n```\n\n----------------------------------------\n\nTITLE: Using Anonymous Functions with Higher-Order Functions in Scala\nDESCRIPTION: Shows how to pass concise anonymous functions using the placeholder syntax (`_`) to higher-order functions like `filter` and `map`. Scala infers the parameter type of the anonymous function based on the collection element type, contributing to a dynamic feel.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/why-scala-3.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nlist.filter(_ < 4)\nlist.map(_ * 2)\nlist.filter(_ < 4)\n    .map(_ * 2)\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Lazy Map - Scala\nDESCRIPTION: This Scala function demonstrates the concept of a lazy transformer by creating a new Iterable that applies the mapping function 'f' to elements only when its iterator is requested and traversed. It avoids immediate evaluation of the entire collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/views.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef lazyMap[T, U](coll: Iterable[T], f: T => U) = new Iterable[U] {\n  def iterator = coll.iterator map f\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Macro Paradise Plugin in Maven - XML\nDESCRIPTION: This Maven configuration snippet provides the required XML fragment to include the Macro Paradise compiler plugin in a Scala project. It places the plugin as a <compilerPlugin> within the <compilerPlugins> section, specifying the group ID, artifact ID (including Scala version), and version. Users must replace <YOUR.SCALA.VERSION> with their actual Scala binary version. This method requires that the Sonatype snapshot or releases repository is configured separately and that scala-reflect.jar is also included as a dependency. This setup is specific to Maven-based Scala builds.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/paradise.md#_snippet_1\n\nLANGUAGE: xml\nCODE:\n```\n<compilerPlugins>\n  <compilerPlugin>\n    <groupId>org.scalamacros</groupId>\n    <artifactId>paradise_<YOUR.SCALA.VERSION></artifactId>\n    <version>2.1.0</version>\n  </compilerPlugin>\n</compilerPlugins>\n```\n\n----------------------------------------\n\nTITLE: Creating a Subdirectory for Scala Source Code - Bash\nDESCRIPTION: Bash command to establish a nested directory, src/main/scala/math, within a Scala sbt project. Ensures source files are organized by package, complying with idiomatic Scala project structure. Requires standard shell environment. Input: none; Output: source folder exists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_20\n\nLANGUAGE: Bash\nCODE:\n```\n$ mkdir src/main/scala/math\n            ----\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Parallel Arrays in Scala\nDESCRIPTION: Shows how to create a parallel array using tabulate, then perform reduce and map operations on it. ParArray maintains a linear, continuous array of elements that allows efficient element access and traversal, with a fixed size.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/parallel-collections/concrete-parallel-collections.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval pa = scala.collection.parallel.mutable.ParArray.tabulate(1000)(x => 2 * x + 1)\npa: scala.collection.parallel.mutable.ParArray[Int] = ParArray(1, 3, 5, 7, 9, 11, 13,...\n\npa reduce (_ + _)\nres0: Int = 1000000\n\npa map (x => (x - 1) / 2)\nres1: scala.collection.parallel.mutable.ParArray[Int] = ParArray(0, 1, 2, 3, 4, 5, 6, 7,...\n```\n\n----------------------------------------\n\nTITLE: Defining a Circle case class in Scala\nDESCRIPTION: A simple case class definition for a Circle with x, y coordinates and radius, used to demonstrate extension methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/methods-most.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ncase class Circle(x: Double, y: Double, radius: Double)\n```\n\n----------------------------------------\n\nTITLE: Reverting to standard Scala 3 compiler options after migration\nDESCRIPTION: Once migration warnings are fixed and automatic rewrites are complete, this configuration removes the `-source:3.0-migration` option and restores other compiler options for production. It ensures the project uses the full capabilities of Scala 3 and enforces strict warning checks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-sbt.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nscalacOptions --= Seq(\"-source:3.0-migration\")\n// Add other production-specific options as needed\n```\n\n----------------------------------------\n\nTITLE: Converting Sequential to Parallel Map Operation in Scala\nDESCRIPTION: Compares a sequential `map` operation on a List with its parallel equivalent. The `.par` method is invoked on the sequential collection to obtain a parallel collection, enabling the subsequent `map` operation to execute in parallel.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/overview.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval list = (1 to 10000).toList\nlist.map(_ + 42)\n```\n\nLANGUAGE: scala\nCODE:\n```\nlist.par.map(_ + 42)\n```\n\n----------------------------------------\n\nTITLE: Scala Proposal for Multiple Assignments Syntax\nDESCRIPTION: Defines the syntax for multiple assignment expressions, allowing structures like tuples to be matched with corresponding RHS values, thereby enabling concise variable swaps and simultaneous updates.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/multiple-assignments.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nvar a = 2\nvar b = 4\n(a, b) = (b, a)\nprintln(s\"$a$b\") // 42\n```\n\n----------------------------------------\n\nTITLE: Defining and Calling Nested Factorial Method in Scala 3 - Scala\nDESCRIPTION: This snippet shows the same factorial function implemented in Scala 3, highlighting new syntax for nested methods. The outer factorial function contains an inner function fact which uses tail recursion to compute the result. The method prints results for factorial(2) and factorial(3) when run. No extra dependencies are needed. The function expects integer inputs; output is an integer factorial value. The implementation is constrained to integer, non-negative numbers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/nested-functions.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef factorial(x: Int): Int =\n  def fact(x: Int, accumulator: Int): Int =\n    if x <= 1 then accumulator\n    else fact(x - 1, x * accumulator)\n  fact(x, 1)\n\nprintln(\"Factorial of 2: \" + factorial(2))\nprintln(\"Factorial of 3: \" + factorial(3))\n\n```\n\n----------------------------------------\n\nTITLE: Exception Handling Using try-catch-finally in Scala\nDESCRIPTION: Demonstrates Scala's 'try' block attempting to write text to a file, with multiple specific 'catch' clauses handling IOException and FileNotFoundException by printing their messages. The 'finally' block prints a concluding message, ensuring execution.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_34\n\nLANGUAGE: Scala\nCODE:\n```\ntry\n  writeTextToFile(text)\ncatch\n  case ioe: IOException =>\n    println(ioe.getMessage)\n  case fnf: FileNotFoundException =>\n    println(fnf.getMessage)\nfinally\n  println(\"Finally\")\n```\n\n----------------------------------------\n\nTITLE: Implementing less-than comparison for the Date class\nDESCRIPTION: Implementation of the abstract < method required by the Ord trait for Date class. It compares dates lexicographically by year, month, and day, and throws an error when comparing with non-Date objects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\nclass Date(y: Int, m: Int, d: Int) extends Ord {\n  // previous decls here\n\n  def <(that: Any): Boolean = that match {\n    case d: Date =>\n      (year < d.year) ||\n      (year == d.year && (month < d.month ||\n                         (month == d.month && day < d.day)))\n\n    case _ => sys.error(\"cannot compare \" + that + \" and a Date\")\n  }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Date(y: Int, m: Int, d: Int) extends Ord:\n  // previous decls here\n\n  def <(that: Any): Boolean = that match\n    case d: Date =>\n      (year < d.year) ||\n      (year == d.year && (month < d.month ||\n                         (month == d.month && day < d.day)))\n\n    case _ => sys.error(\"cannot compare \" + that + \" and a Date\")\n  end <\nend Date\n```\n\n----------------------------------------\n\nTITLE: Indexed Access of Tuple Elements (Scala 2)\nDESCRIPTION: Shows how to access elements of a tuple by their position using the _N field notation in Scala 2. No external dependencies are needed. 'ingredient._1' returns the first element ('Sugar') and 'ingredient._2' returns the second element (25). Output is printed directly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/tuples.md#_snippet_1\n\nLANGUAGE: Scala mdoc\nCODE:\n```\nprintln(ingredient._1) // Sugar\nprintln(ingredient._2) // 25\n```\n\n----------------------------------------\n\nTITLE: Indexed Access of Tuple Elements (Scala 3)\nDESCRIPTION: Demonstrates how to access tuple elements by their zero-based index in Scala 3 using the function-call syntax. This requires Scala 3's tuple access improvements. 'ingredient(0)' yields the first element, while 'ingredient(1)' yields the second. Outputs are printed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/tuples.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nprintln(ingredient(0)) // Sugar\nprintln(ingredient(1)) // 25\n```\n\n----------------------------------------\n\nTITLE: Extracting Range from Scala TreeSet\nDESCRIPTION: This Scala snippet uses the `range` method on the `TreeSet` `res3`. It returns a new `TreeSet` containing elements that are greater than or equal to the first argument (\"one\") and strictly less than the second argument (\"two\") according to the set's ordering.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/sets.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nscala> res3 range (\"one\", \"two\")\nres4: scala.collection.immutable.TreeSet[String] = TreeSet(one, three)\n```\n\n----------------------------------------\n\nTITLE: Creating Actors Lazily Using Views in Scala 2\nDESCRIPTION: This snippet demonstrates how to use a view for lazy computation in Scala 2. By converting the range to a view before using a for-comprehension, evaluation of actors is deferred until the result is forced. The `actor` function is not immediately invoked, and no actors are created until the resulting collection is traversed or forced. The pattern is useful for composing transformations but should be avoided when side effects (such as actor creation) are involved.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/views.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval actors = for (i <- (1 to 10).view) yield actor { ... }\n```\n\n----------------------------------------\n\nTITLE: Using BigInt and BigDecimal for Large and Precise Numbers\nDESCRIPTION: Illustrates how to handle large integers and precise decimal numbers with BigInt and BigDecimal types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-vars-data-types.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nvar a = BigInt(1_234_567_890_987_654_321L)\nvar b = BigDecimal(123_456.789)\n```\n\n----------------------------------------\n\nTITLE: Executing Single-Line Conditional Logic with 'if' in Scala\nDESCRIPTION: Demonstrates a basic single-line `if` statement in both Scala 2 and Scala 3. The Scala 3 version uses the optional `then` keyword. Executes `println(x)` only if `x` equals 1.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_0\n\nLANGUAGE: Scala 2\nCODE:\n```\nif (x == 1) println(x)\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nif x == 1 then println(x)\n```\n\n----------------------------------------\n\nTITLE: Matching Multiple Argument Lists in Applications - Scala\nDESCRIPTION: Demonstrates pattern matching on functions with multiple argument lists. The pattern `q\"g(...$argss)\"` uses `...$` to greedily match all subsequent value application lists, binding them to `$argss` as a list of lists of trees.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val apps = List(q\"g(1)\", q\"g(1)(2)\")\napps: List[universe.Tree] = List(g(1), g(1)(2))\nscala> apps.foreach {\n             case q\"g(...$argss)\" if argss.nonEmpty =>\n               println(s\"argss: $argss\")\n           }\nargss: List(List(1))\nargss: List(List(1), List(2))\n```\n\n----------------------------------------\n\nTITLE: Defining Simplified Java Annotation with Default Value\nDESCRIPTION: Creating a Java annotation with a primary 'value' parameter and a secondary parameter with a default value, enabling simplified usage syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/annotations.md#_snippet_5\n\nLANGUAGE: java\nCODE:\n```\n@interface SourceURL {\n    public String value();\n    public String mail() default \"\";\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Instance with null Value in Scala 3\nDESCRIPTION: An example showing how a null value can be passed to the street2 parameter when creating an Address instance in Scala 3, demonstrating the same issue in the newer syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fp-functional-error-handling.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval santa = Address(\n  \"1 Main Street\",\n  null,               // <-- О! Значение null!\n  \"North Pole\",\n  \"Alaska\",\n  \"99705\"\n)\n```\n\n----------------------------------------\n\nTITLE: Using andThen Combinator for Side Effects in Scala Futures\nDESCRIPTION: Illustrates the use of the andThen combinator for performing side effects after a Future completes without altering the Future's result. This example collects recent posts into a mutable set, then clears a UI and renders posts. Inputs include an asynchronous call to getRecentPosts and mutable state allPosts. The output is a Future with unchanged results but with ordered side-effect executions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/futures-promises.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nval allPosts = mutable.Set[String]()\n\nFuture {\n  session.getRecentPosts\n} andThen {\n  case Success(posts) => allPosts ++= posts\n} andThen {\n  case _ =>\n    clearAll()\n    for (post <- allPosts) render(post)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Initial Order Data Class (Scala)\nDESCRIPTION: Defines the initial `Order` class as a data structure representing a customer order. It holds a mutable `ArrayBuffer` of `Pizza` objects and a `Customer` object. This class requires `scala.collection.mutable.ArrayBuffer` and depends on the `Pizza` and `Customer` classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/oop-pizza-example.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass Order (\n    var pizzas: ArrayBuffer[Pizza],\n    var customer: Customer\n)\n```\n\n----------------------------------------\n\nTITLE: 配列のreverseメソッド呼び出しにおける暗黙変換適用例 - Scala\nDESCRIPTION: このスニペットは、Scalaの配列に対して直接reverseメソッドを呼ぶ例です。内部的にintArrayOpsへの暗黙的変換が自動的に適用され、ArrayOps型のオブジェクトに変換された上でreverseが実行されます。これにより配列が新しい逆順の配列として返されます。依存はScalaのPredef暗黙変換機構のみです。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/arrays.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\na1.reverse\nintArrayOps(a1).reverse\n```\n\n----------------------------------------\n\nTITLE: Multi-Line while Loop in Scala 2\nDESCRIPTION: Presents typical Scala 2 multi-line while loop with variable initialization, loop condition, and a block body printing and incrementing 'x'. Demonstrates standard loop structure with braces. Input is 'x' starting at 1; output is printed values up to 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_27\n\nLANGUAGE: Scala\nCODE:\n```\nvar x = 1\n\nwhile (x < 3) {\n  println(x)\n  x += 1\n}\n```\n\n----------------------------------------\n\nTITLE: Intercepting Exceptions in MUnit Tests using Scala 3\nDESCRIPTION: Shows how to write an exception interception test in Scala 3 with MUnit. It declares a test that expects NoSuchFileException when attempting to read a non-existent file. The test uses the intercept method similarly to Scala 2 but adopts Scala 3 syntax including significant indentation and colon-based class declaration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-exceptions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport java.nio.file.NoSuchFileException\n\nclass FileTests extends munit.FunSuite:\n  test(\"read missing file\") {\n    val missingFile = os.pwd / \"missing.txt\"\n    intercept[NoSuchFileException] {\n      // the code that should throw an exception\n      os.read(missingFile)\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Default Arguments with Polymorphic Methods in Scala\nDESCRIPTION: Demonstrates how default arguments work with generic methods and classes. Type parameters are treated specially during type-checking of default arguments to allow flexible polymorphic usage.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-and-default-arguments.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ndef f[T](a: T = 1) = a\nf()    // returns 1: Int\nf(\"s\") // returns \"s\": String\ndef g[T](a: T = 1, b: T = \"2\") = b\ng(a = \"1\")  // OK, returns \"2\": String\ng(b = 2)    // OK, returns 2: Int\ng()         // OK, returns \"2\": Any\n// g[Int]() // \"error: type mismatch; found: String, required: Int\"\nclass A[T](a: T = \"defaultString\")\nnew A()  // creates an instance of A[String]\nnew A(1) // creates an instance of A[Int]\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Contravariant Serializer in Scala 3\nDESCRIPTION: This code defines a contravariant Serializer class with Scala 3's significant indentation, creates an implementation for Animal, and shows safe assignment to Serializer[Cat], then serializes a Cat instance. All key logic is as in the Scala 2 version, but adapted for Scala 3. Purpose: to demonstrate contravariant type variables and safe subtyping behavior in consuming APIs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/variances.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Serializer[-A]:\n  def serialize(a: A): String\n\nval animalSerializer: Serializer[Animal] = new Serializer[Animal]():\n  def serialize(animal: Animal): String = s\"\"\"{ \\\"name\\\": \\\"${animal.name}\\\" }\"\"\"\n\nval catSerializer: Serializer[Cat] = animalSerializer\ncatSerializer.serialize(Cat(\"Felix\"))\n```\n\n----------------------------------------\n\nTITLE: Compile-Time Error for Invalid Pattern Match Case\nDESCRIPTION: Shows that the compiler enforces exhaustiveness and type correctness within pattern matches on union types. Adding a `case` that does not correspond to any type within the `Username | Password` union (like `case 1.0`) leads to a compilation error.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-union.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncase 1.0 => ???   // ERROR: this line won’t compile\n```\n\n----------------------------------------\n\nTITLE: Scala 2 和 Scala 3中协变的泛型类型示例\nDESCRIPTION: 定义一个标记为协变的trait Producer[+T]，只用在返回类型位置，允许子类型转成父类型。示范了协变在函数式数据流中的作用，便于用较子类型实例替代父类型。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-variance.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Producer[+T] {\n  def make: T\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Arithmetic Expressions in Scala REPL\nDESCRIPTION: Examples of basic arithmetic operations in the Scala REPL. The REPL automatically assigns results to variables named res0, res1, etc., and displays both the type and value of each result.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-repl.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nscala> 1 + 1\nval res0: Int = 2\n\nscala> 2 + 2\nval res1: Int = 4\n```\n\n----------------------------------------\n\nTITLE: Alternative to Union Types: Tagged Union with Enum\nDESCRIPTION: Demonstrates modeling alternatives using a Scala 3 `enum` as a tagged union. This approach requires explicitly wrapping values (`IsUsername(u)`, `IsPassword(p)`) and unwrapping them, and the original types (`Username`, `Password`) are not subtypes of the enum.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-union.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nenum UsernameOrPassword:\n  case IsUsername(u: Username)\n  case IsPassword(p: Password)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Partial Application with Multiple Parameter Lists in Scala\nDESCRIPTION: Example showing how methods with multiple parameter lists can be partially applied, creating new functions that expect the remaining parameter lists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/multiple-parameter-lists.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nval numberFunc = numbers.foldLeft(List[Int]()) _\n\nval squares = numberFunc((xs, x) => xs :+ x*x)\nprintln(squares) // List(1, 4, 9, 16, 25, 36, 49, 64, 81, 100)\n\nval cubes = numberFunc((xs, x) => xs :+ x*x*x)\nprintln(cubes)  // List(1, 8, 27, 64, 125, 216, 343, 512, 729, 1000)\n```\n\n----------------------------------------\n\nTITLE: Handling duplicate elements in sets in Python and Scala\nDESCRIPTION: Illustrates that adding duplicate elements to sets results in unique elements only. Python set literal {1,2,1} automatically deduplicates the second '1'. Scala Set constructor does the same, showing the immutable uniqueness guarantee of sets.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_60\n\nLANGUAGE: python\nCODE:\n```\nset = {1,2,1}\n# set: {1,2}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval set = Set(1,2,1)\n// set: Set(1,2)\n```\n\n----------------------------------------\n\nTITLE: Explicit Anonymous Function in Scala\nDESCRIPTION: Shows the most explicit form of an anonymous function with type annotation for the parameter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-anonymous-functions.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n(i: Int) => i * 2\n```\n\n----------------------------------------\n\nTITLE: Adding sttp Core Dependency with Scala CLI - Scala\nDESCRIPTION: This snippet demonstrates how to add a specific version of the sttp core library in Scala CLI with a project-wide directive. It requires no further configuration and ensures that version 4.0.0-RC1 of sttp client4 core is available to the project. Suitable for cases where only sttp is needed, not the entire toolkit.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-sttp.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n//> using dep com.softwaremill.sttp.client4::core:4.0.0-RC1\n```\n\n----------------------------------------\n\nTITLE: Scala 2中枚举的定义（CrustSize, CrustType, Topping）\nDESCRIPTION: 定义CrustSize、CrustType和Topping的枚举类型，使用sealed抽象类配合case object实现枚举，兼容Scala 2环境。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-fp.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nsealed abstract class CrustSize\nobject CrustSize {\n  case object Small extends CrustSize\n  case object Medium extends CrustSize\n  case object Large extends CrustSize\n}\n\nsealed abstract class CrustType\nobject CrustType {\n  case object Thin extends CrustType\n  case object Thick extends CrustType\n  case object Regular extends CrustType\n}\n\nsealed abstract class Topping\nobject Topping {\n  case object Cheese extends Topping\n  case object Pepperoni extends Topping\n  case object BlackOlives extends Topping\n  case object GreenOlives extends Topping\n  case object Onions extends Topping\n}\n```\n\n----------------------------------------\n\nTITLE: Modeling Related Domain Entities\nDESCRIPTION: This snippet expands the pizza ordering system data model by defining additional compound data structures like `Address`, `Customer`, and `Order` using case classes. This further illustrates how case classes are used in FP to aggregate related data fields, maintaining the separation of data from operations, consistent across Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-fp.md#_snippet_3\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\ncase class Address(\n  street1: String,\n  street2: Option[String],\n  city: String,\n  state: String,\n  zipCode: String\n)\n\ncase class Customer(\n  name: String,\n  phone: String,\n  address: Address\n)\n\ncase class Order(\n  pizzas: Seq[Pizza],\n  customer: Customer\n)\n```\n\n----------------------------------------\n\nTITLE: Defining an Abstract Trait in Scala\nDESCRIPTION: Defines the `Showable` trait with a single abstract method `show`. This illustrates the basic syntax for creating traits that specify an interface in both Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-oop.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Showable {\n  def show: String\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait Showable:\n  def show: String\n```\n\n----------------------------------------\n\nTITLE: Initializing Immutable Red-Black Tree Sets in Scala\nDESCRIPTION: This snippet shows how to construct and use an immutable TreeSet, which is backed by a red-black tree for efficient logarithmic-time insertions, deletions, and lookups. Dependencies are limited to the Scala standard library. The example creates an empty TreeSet of Int, then adds values while preserving uniqueness and order. The TreeSet outputs elements in sorted order and supports functional addition with '+'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/concrete-immutable-collection-classes.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nscala> scala.collection.immutable.TreeSet.empty[Int]\nres11: scala.collection.immutable.TreeSet[Int] = TreeSet()\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> res11 + 1 + 3 + 3\nres12: scala.collection.immutable.TreeSet[Int] = TreeSet(1, 3)\n```\n\n----------------------------------------\n\nTITLE: Attempting Covariant Mutable ListBuffer Assignment in Scala (Fails Compilation)\nDESCRIPTION: This snippet tries to assign a mutable ListBuffer[Int] to a ListBuffer[Any], demonstrating why mutable types cannot be covariant. Importing scala.collection.mutable.ListBuffer, it creates two buffers, attempts a subtype assignment (which should fail), mutates the buffer via the parent type, and illustrates how type safety would break (could lead to ClassCastException). Limitation: code is marked for failed compilation (mdoc:fail). This reinforces the requirement that mutable collections are invariant in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/variances.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.mutable.ListBuffer\n\nval bufInt: ListBuffer[Int] = ListBuffer[Int](1,2,3)\nval bufAny: ListBuffer[Any] = bufInt\nbufAny(0) = \"Hello\"\nval firstElem: Int = bufInt(0)\n```\n\n----------------------------------------\n\nTITLE: Defining a Companion Object with Implicit Ordering in Scala\nDESCRIPTION: Illustrates a companion object for the class 'IntPair' that provides an implicit Ordering instance. This companion object imports 'math.Ordering' and defines 'ipord' as an implicit method that returns an Ordering[IntPair] by comparing the tuple (x, y) values of IntPair instances. The implicit ordering allows objects of IntPair to be sorted and used in ordered collections automatically. To use this code, import scala.math.Ordering and define the class 'IntPair' as shown. The implicit def ipord is used by the Scala compiler during implicit resolution for ordering requirements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/singleton-objects.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass IntPair(val x: Int, val y: Int)\n\nobject IntPair {\n  import math.Ordering\n\n  implicit def ipord: Ordering[IntPair] =\n    Ordering.by(ip => (ip.x, ip.y))\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Indentation Inside a Method Returning a Tuple - Scala\nDESCRIPTION: This snippet declares a method 'bar' returning a tuple but has incorrect indentation for the tuple literal, leading to type mismatch and parameter errors in Scala 3. There are no dependencies. For correct compilation in Scala 3, statements in blocks must be consistently aligned. The key issue is improperly indented expressions being interpreted incorrectly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-syntactic.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef bar: (Int, Int) = {\n  val foo = 1.0\n  val bar = foo // [E050] In Scala 3, type Error: value foo does not take parameters.\n    (1, 1)\n} // [E007] In Scala 3, type Mismatch Error: Found Unit, Required (Int, Int).\n```\n\n----------------------------------------\n\nTITLE: Manual Implementation of a Cached Function Using Basic Map Operations in Scala\nDESCRIPTION: Provides a verbose alternative to 'getOrElseUpdate' by manually checking if a key exists in the cache map, returning the cached result if present, or computing, storing, and returning the result if not. Uses pattern matching on the Option type returned by 'get'. This explicitly demonstrates the caching logic and side effects for map updates. The implementation works for both Scala 2 and Scala 3 versions with minor syntax differences.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/maps.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef cachedF(arg: String): String = cache.get(arg) match {\n  case Some(result) => result\n  case None =>\n    val result = f(x)\n    cache(arg) = result\n    result\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Trait in Scala\nDESCRIPTION: Defines the most basic form of a trait in Scala using the 'trait' keyword followed by an identifier. This snippet introduces how to declare a trait without any members or methods, serving as a program interface or marker without implementation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/traits.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait HairColor\n```\n\n----------------------------------------\n\nTITLE: Modeling Messages with Case Objects for Actor Communication\nDESCRIPTION: Defines singleton message objects (`StopSpeakingMessage`, `PauseSpeakingMessage`, `ResumeSpeakingMessage`) and a message class (`StartSpeakingMessage`) for actor-based message passing, common in systems like Akka. `StartSpeakingMessage` includes a parameter for the text to speak.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/case-objects.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ncase class StartSpeakingMessage(textToSpeak: String)\ncase object StopSpeakingMessage\ncase object PauseSpeakingMessage\ncase object ResumeSpeakingMessage\n```\n\n----------------------------------------\n\nTITLE: Multi-line for loop processing elements in Python and Scala\nDESCRIPTION: Illustrates a loop that processes each element of a collection, calculating derived values and printing formatted strings. Inputs: iterable ints; outputs: printed strings showing each element and its transformation. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_35\n\nLANGUAGE: Python\nCODE:\n```\nfor i in ints:\n  x = i * 2\n  print(f\"i = {i}, x = {x}\")\n```\n\n----------------------------------------\n\nTITLE: Representing an Environment using a Function Literal in Scala\nDESCRIPTION: Shows how to represent a simple variable environment (mapping variable names to values) using a Scala function literal (specifically, a `PartialFunction`). Defines an environment where \"x\" maps to 5.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tutorials/scala-for-java-programmers.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\n{ case \"x\" => 5 }\n```\n\n----------------------------------------\n\nTITLE: Implementing a helper method for reduce in Scala\nDESCRIPTION: A helper method implementation to demonstrate how reduce works. The method adds two integers and provides debug output to visualize the reduction process.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-methods.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ndef add(x: Int, y: Int): Int = {\n  val theSum = x + y\n  println(s\"received $x and $y, their sum is $theSum\")\n  theSum\n}\n```\n\n----------------------------------------\n\nTITLE: Dequeuing an Element from an Immutable Queue in Scala\nDESCRIPTION: Demonstrates removing the element at the head of an immutable `Queue` (`has123`) using the `dequeue` method. `dequeue` returns a tuple containing two values: the element that was removed (the first one enqueued) and a new queue instance representing the rest of the queue.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-immutable-collection-classes.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nscala> val (element, has23) = has123.dequeue\nelement: Int = 1\nhas23: scala.collection.immutable.Queue[Int] = Queue(2, 3)\n```\n\n----------------------------------------\n\nTITLE: Accessing and Modifying Fields Using FieldMirror in Scala\nDESCRIPTION: This snippet demonstrates retrieving and modifying instance fields using FieldMirror. It starts by reflecting a class with fields, then obtaining field symbols using term names. Using the InstanceMirror, field mirrors are created which allow getting and setting field values dynamically. The snippet covers both immutable ('val') and mutable ('var') fields. Inputs include field symbols and the instance mirror; outputs are field values retrieved or set at runtime.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/reflection/environment-universes-mirrors.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nscala> class C { val x = 2; var y = 3 }\ndefined class C\n\nscala> val m = ru.runtimeMirror(getClass.getClassLoader)\nm: scala.reflect.runtime.universe.Mirror = JavaMirror ...\n\nscala> val im = m.reflect(new C)\nim: scala.reflect.runtime.universe.InstanceMirror = instance mirror for C@5f0c8ac1\n\nscala> val fieldX = ru.typeOf[C].decl(ru.TermName(\"x\")).asTerm.accessed.asTerm\nfieldX: scala.reflect.runtime.universe.TermSymbol = value x\n\nscala> val fmX = im.reflectField(fieldX)\nfmX: scala.reflect.runtime.universe.FieldMirror = field mirror for C.x (bound to C@5f0c8ac1)\n\nscala> fmX.get\nres0: Any = 2\n\nscala> fmX.set(3)\n\nscala> val fieldY = ru.typeOf[C].decl(ru.TermName(\"y\")).asTerm.accessed.asTerm\nfieldY: scala.reflect.runtime.universe.TermSymbol = variable y\n\nscala> val fmY = im.reflectField(fieldY)\nfmY: scala.reflect.runtime.universe.FieldMirror = field mirror for C.y (bound to C@5f0c8ac1)\n\nscala> fmY.get\nres1: Any = 3\n\nscala> fmY.set(4)\n\nscala> fmY.get\nres2: Any = 4\n```\n\n----------------------------------------\n\nTITLE: 数组序列（ArraySeq）示例\nDESCRIPTION: 示意如何使用ArraySeq来构建具有固定大小的可变序列，适合在无法提前知道元素类型或无法提供ClassTag时替代Array，存储元素在内部为Array。依赖Scala collection.mutable包。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/concrete-mutable-collection-classes.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\n// 具体代码示例未提供，仅为说明\n```\n\n----------------------------------------\n\nTITLE: Implementing a Lazy Map in Scala (Scala 2 and 3)\nDESCRIPTION: This snippet defines a generic lazyMap function that creates a lazily evaluated Iterable by wrapping an existing Iterable. The function applies the transformation function f to elements only when they are accessed, avoiding immediate traversal of all elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/views.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef lazyMap[T, U](iter: Iterable[T], f: T => U) = new Iterable[U] {\n  def iterator = iter.iterator.map(f)\n}\n```\n\n----------------------------------------\n\nTITLE: Using copy Method to Create Modified Instances in Scala\nDESCRIPTION: Demonstrates how to use the copy method that comes with case classes to create a modified version of an immutable object while preserving immutability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-immutable-values.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval elton = reginald.copy(\n  firstName = \"Elton\",   // update the first name\n  lastName = \"John\"      // update the last name\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Parallel String Collection without Combiner in Scala\nDESCRIPTION: Demonstrates creating a simple parallel string collection (`ParString`) by extending `immutable.ParSeq[Char]`. It implements required methods like `apply`, `length`, `seq`, and defines a custom `ParStringSplitter` extending `SeqSplitter[Char]` with `hasNext`, `next`, `remaining`, `dup`, `split`, and `psplit` methods. This version lacks a combiner, so transformation methods return standard parallel collections like `ParVector`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/parallel-collections/custom-parallel-collections.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass ParString(val str: String)\nextends immutable.ParSeq[Char] {\n\n  def apply(i: Int) = str.charAt(i)\n\n  def length = str.length\n\n  def seq = new collection.immutable.WrappedString(str)\n\n  def splitter = new ParStringSplitter(str, 0, str.length)\n\n  class ParStringSplitter(private var s: String, private var i: Int, private val ntl: Int)\n  extends SeqSplitter[Char] {\n\n    final def hasNext = i < ntl\n\n    final def next = {\n      val r = s.charAt(i)\n      i += 1\n      r\n    }\n\n    def remaining = ntl - i\n\n    def dup = new ParStringSplitter(s, i, ntl)\n\n    def split = {\n      val rem = remaining\n      if (rem >= 2) psplit(rem / 2, rem - rem / 2)\n      else Seq(this)\n    }\n\n    def psplit(sizes: Int*): Seq[ParStringSplitter] = {\n      val splitted = new ArrayBuffer[ParStringSplitter]\n      for (sz <- sizes) {\n        val next = (i + sz) min ntl\n        splitted += new ParStringSplitter(s, i, next)\n        i = next\n      }\n      if (remaining > 0) splitted += new ParStringSplitter(s, i, ntl)\n      splitted\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting a Local Server for Viewing Scaladoc Output\nDESCRIPTION: Shell commands to start a Python HTTP server for viewing the generated Scaladoc site locally with all features including search and snippets.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/static-site.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ncd output\npython3 -m http.server 8080\n```\n\n----------------------------------------\n\nTITLE: Checking Structural Equality with equalsStructure (Scala)\nDESCRIPTION: Illustrates using the `equalsStructure` method to compare the structural representation of two `universe.Tree` instances, demonstrating they can be equivalent even if their source text differs. This is the underlying mechanism used by quasiquote pattern matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/intro.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nscala> println(q\"foo + bar\" equalsStructure q\"foo.+(bar)\")\ntrue\n```\n\n----------------------------------------\n\nTITLE: Generated Forwarder Methods by @unroll for Binary Compatibility in Scala\nDESCRIPTION: Shows the conceptual result of applying `@unroll` to the `foo` method. The compiler generates synthetic forwarder methods (overloads of `foo`) that call the primary implementation with the default values, maintaining binary compatibility for callers expecting older signatures.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/unroll-default-arguments.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nobject Unrolled{\n   def foo(s: String, n: Int = 1, @unroll b: Boolean = true, @unroll l: Long = 0) = s + n + b + l\n\n   def foo(s: String, n: Int, b: Boolean) = foo(s, n, b, 0)\n   def foo(s: String, n: Int) = foo(s, n, true, 0)\n}\n```\n\n----------------------------------------\n\nTITLE: For loop iterating over a list in Python and Scala\nDESCRIPTION: Demonstrates iterating over elements in an iterable collection with printing of elements. Inputs: list or collection named ints; outputs: printed elements one per line. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_33\n\nLANGUAGE: Python\nCODE:\n```\nfor i in ints: print(i)\n\nfor i in ints:\n  print(i)\n```\n\n----------------------------------------\n\nTITLE: Using Wrapper Class for Wildcard Type Arguments in Scala 3\nDESCRIPTION: Presents a diff showing a workaround for using wildcard type arguments within other type constructors (like `Seq[Foo[_]]`) when migrating to Scala 3. A new wrapper class `FooWrapper[A]` is introduced to hold the `Foo[A]`, and the method `g` is modified to accept `Seq[FooWrapper[_]]`, applying the wildcard to the wrapper instead.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-other-changes.md#_snippet_14\n\nLANGUAGE: diff\nCODE:\n```\n+class FooWrapper[A](foo: Foo[A])\n\n-def g(foos: Seq[Foo[_]]): Unit\n+def g(foos: Seq[FooWrapper[_]]): Unit\n```\n\n----------------------------------------\n\nTITLE: Using Custom Logical Operators as Infix in Scala\nDESCRIPTION: Defines functions 'not' and 'xor' that utilize the 'and', 'or', and 'not' methods to create complex logical expressions with infix notation for increased readability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/operators.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef not(x: MyBool) = x.negate\ndef xor(x: MyBool, y: MyBool) = (x or y) and not(x and y)\n```\n\n----------------------------------------\n\nTITLE: Reading Output of External Process Using OS-Lib in Scala\nDESCRIPTION: This snippet illustrates how to capture and process the output of an external command executed via OS-Lib's os.proc and call() methods. It uses the 'bc' command as an example for evaluating an expression, accessing the command's standard output text, trimming whitespace, and parsing it to an integer. The snippet requires that the 'bc' command-line tool is available on the system. The key outputs are the command's textual output and the parsed result.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/os-run-process.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval res: os.CommandResult = os.proc(\"bc\", \"-e\", \"2 + 2\").call()\nval text: String = res.out.text()\nprintln(text.trim.toInt)\n// prints: 4\n```\n\n----------------------------------------\n\nTITLE: Mapping over Future with map Combinator in Scala\nDESCRIPTION: This snippet refactors the callback-based code to use the map combinator, removing nested callbacks by transforming the result of one Future into another. rateQuote Future is mapped to purchase Future, conditionally calling the buy method. The purchase Future's result is then processed using foreach for side-effects. This usage of map leads to flatter and more readable asynchronous code, preserving exception propagation. Dependencies include scala.concurrent.Future, ExecutionContext, and proper exception handling for failed Futures.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/futures.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nval rateQuote = Future {\n  connection.getCurrentValue(USD)\n}\n\nval purchase = rateQuote map { quote =>\n  if (isProfitable(quote)) connection.buy(amount, quote)\n  else throw new Exception(\"有益ではない\")\n}\n\npurchase.foreach { amount =>\n  println(amount + \" USD を購入した\")\n}\n```\n\n----------------------------------------\n\nTITLE: Backward compatibility with Scala 2 main method pattern\nDESCRIPTION: This snippet presents a Scala 2 style 'main' method inside an object, enabling cross-build compatibility. It explicitly defines 'main' with 'Array[String]' parameter and calls an internal method with parsed and converted arguments, illustrating how to maintain compatibility with pre-Scala 3 codebases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/methods-main-methods.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nobject happyBirthday {\n  private def happyBirthday(age: Int, name: String, others: String*) = {\n    ... // same as before\n  }\n  def main(args: Array[String]): Unit =\n    happyBirthday(args(0).toInt, args(1), args.drop(2).toIndexedSeq:_*)\n}\n```\n\n----------------------------------------\n\nTITLE: Type Inference for Polymorphic Functions and Classes in Scala\nDESCRIPTION: Shows how Scala infers type parameters for polymorphic classes ('MyPair') and functions ('id') based on actual arguments, reducing the need for explicit type annotations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/type-inference.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ncase class MyPair[A, B](x: A, y: B)\nval p = MyPair(1, \"scala\") // type: MyPair[Int, String]\n\ndef id[T](x: T) = x\nval q = id(1) // type: Int\n```\n\n----------------------------------------\n\nTITLE: Transforming abstract type members to type parameters with variance annotations\nDESCRIPTION: This snippet redefines 'Buffer' and 'SeqBuffer' using type parameters instead of abstract members; 'Buffer' has a covariant type parameter 'T', while 'SeqBuffer' introduces 'U' and parameterizes 'T' with an upper bound 'Seq[U]'. The factory method 'newIntSeqBuf' creates a 'SeqBuffer' with specific type arguments. It showcases converting abstract types into type parameters suited for different use cases, with variance annotations ('+T').\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tour/abstract-type-members.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Buffer[+T] {\n  val element: T\n}\nabstract class SeqBuffer[U, +T <: Seq[U]] extends Buffer[T] {\n  def length = element.length\n}\n\ndef newIntSeqBuf(e1: Int, e2: Int): SeqBuffer[Int, Seq[Int]] =\n  new SeqBuffer[Int, List[Int]] {\n    val element = List(e1, e2)\n  }\n\nval buf = newIntSeqBuf(7, 8)\nprintln(\"length = \" + buf.length)\nprintln(\"content = \" + buf.element)\n```\n\n----------------------------------------\n\nTITLE: Passing Quoted Type Classes to Scala Macro Implementation\nDESCRIPTION: Demonstrates passing a quoted type class (`Expr[Numeric[Num]]`) from the inline method definition to the macro implementation function. The `using Numeric[Num]` parameter in the inline method is quoted (`'num`) and becomes a `using Expr[Numeric[Num]]` parameter in the macro implementation, making the type class instance available as an expression.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_32\n\nLANGUAGE: Scala\nCODE:\n```\ninline def power[Num](x: Num, inline n: Int)(using num: Numeric[Num]) =\n  ${ powerMacro('x, 'n)(using 'num) }\n\ndef powerMacro[Num: Type](x: Expr[Num], n: Expr[Int])(using Expr[Numeric[Num]])(using Quotes): Expr[Num] =\n  powerCode(x, n.valueOrAbort)\n```\n\n----------------------------------------\n\nTITLE: Defining Java Annotation Interface with Default Element Value\nDESCRIPTION: This snippet defines a Java annotation '@SourceURL' with two elements: 'value' (mandatory) and 'mail' (optional with default empty string). It demonstrates that if an element is named 'value', annotation syntax allows for shorter usage (positional) without specifying the element name. The 'mail' element has a default, so it can be omitted when using the annotation. This interface enables flexible metadata declaration with required and optional properties, compatible with Java 1.5+ annotation mechanism.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/annotations.md#_snippet_5\n\nLANGUAGE: Java\nCODE:\n```\n@interface SourceURL {\n    public String value();\n    public String mail() default \"\";\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Scala Package Object with Shared Variables and Methods\nDESCRIPTION: Creates a package object for the package gardening.fruits that contains shared definitions accessible as package members. It defines a val planted as a list of fruit objects and a method showFruit that prints information about a Fruit instance. This snippet shows how to use package objects to hold package-wide members, facilitating convenient import and usage.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/package-objects.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// in file gardening/fruits/package.scala\npackage gardening\npackage object fruits {\n  val planted = List(Apple, Plum, Banana)\n  def showFruit(fruit: Fruit): Unit = {\n    println(s\"${fruit.name}s are ${fruit.color}\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Access Control Decorator in Cask (Scala 3)\nDESCRIPTION: This snippet demonstrates creating and applying a custom decorator, 'loggedIn', in the Cask web framework using Scala 3. The decorator class extends 'cask.RawDecorator' and overrides 'wrapFunction' to check the 'sessionId' cookie against a maintained set of session IDs. On authentication success, it passes the session ID to the endpoint; on failure, it returns a 403 access denied response. It depends on the Cask library and the existence of a 'sessionIds' set. Decorators are attached to endpoints using the '@loggedIn()' annotation to restrict access. Only checks for a fixed cookie name ('sessionId').\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/web-server-cookies-and-decorators.md#_snippet_3\n\nLANGUAGE: Scala 3\nCODE:\n```\nclass loggedIn extends cask.RawDecorator:\n  override def wrapFunction(ctx: cask.Request, delegate: Delegate): Result[Raw] =\n    ctx.cookies.get(\"sessionId\") match\n      case Some(cookie) if sessionIds.contains(cookie.value) =>\n        delegate(Map(\"sessionId\" -> cookie.value))\n      case _ =>\n        cask.router.Result.Success(cask.model.Response(\"You aren't logged in\", 403))\n\n\n@loggedIn()\n@cask.get(\"/decorated\")\ndef decorated()(sessionId: String): String = s\"You are logged in with id: $sessionId\"\n```\n\n----------------------------------------\n\nTITLE: Connecting to WebSocket Server with JavaScript/HTML\nDESCRIPTION: This HTML and JavaScript snippet implements a simple client to connect to a WebSocket server. It establishes a connection to `ws://localhost:8080/websocket`, sends the value of an input field when a button is clicked, and displays messages received from the server in a designated `div`. It also handles the connection closure event.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/web-server-websockets.md#_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<!DOCTYPE html>\n<html>\n<body>\n<div>\n    <input type=\"text\" id=\"input\" placeholder=\"Provide city name\">\n    <button onclick=\"sendMessage()\">Send</button>\n</div>\n<div id=\"time\"></div>\n<script>\n    const ws = new WebSocket('ws://localhost:8080/websocket');\n    ws.onmessage = function(event) {\n        receiveMessage(event.data);\n    };\n\n    ws.onclose = function(event) {\n        receiveMessage('The connection has been closed');\n    };\n\n    function sendMessage() {\n        const inputElement = document.getElementById('input');\n        const message = inputElement.value;\n        ws.send(message);\n    }\n\n    function receiveMessage(message) {\n        const timeElement = document.getElementById('time');\n        timeElement.textContent = message;\n    }\n</script>\n</body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Sample List Data for Collection Examples\nDESCRIPTION: Creating sample lists for demonstration of collection methods, including a numeric list and a list of strings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/collections-methods.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval oneToTen = (1 to 10).toList\nval names = List(\"adam\", \"brandy\", \"chris\", \"david\")\n```\n\n----------------------------------------\n\nTITLE: Defining immutable FP style records in Python and Scala\nDESCRIPTION: Shows how to define immutable data structures using Python frozen dataclasses and Scala case classes. Dependencies include Python's dataclasses module for frozen dataclasses. Key parameters are the fields defining the record. Input is field values during instantiation; output is an immutable object. This introduces fundamental FP style record creation in both languages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nfrom dataclasses import dataclass, replace\n\n@dataclass(frozen=True)\nclass Person:\n  name: str\n  age: int\n```\n\n----------------------------------------\n\nTITLE: Implementing Comparable Date Class Using Scala Trait Ord\nDESCRIPTION: Implements a Date class that extends the Ord trait to represent a calendar date with year, month, and day fields. It overrides the 'equals' method to compare Date instance fields accurately and defines the '<' operator to compare dates chronologically, using pattern matching with isInstanceOf and asInstanceOf for type-safe casting. The class inherits default comparison methods from Ord, enabling six comparison predicates for Date objects. It also includes a string representation via overriding 'toString'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-tw/tutorials/scala-for-java-programmers.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass Date(y: Int, m: Int, d: Int) extends Ord {\n  def year = y\n  def month = m\n  def day = d\n  override def toString(): String = s\"$year-$month-$day\"\n\n  override def equals(that: Any): Boolean =\n    that.isInstanceOf[Date] && {\n      val o = that.asInstanceOf[Date]\n      o.day == day && o.month == month && o.year == year\n    }\n\n  def <(that: Any): Boolean = {\n    if (!that.isInstanceOf[Date])\n      error(\"cannot compare \" + that + \" and a Date\")\n\n    val o = that.asInstanceOf[Date]\n    (year < o.year) ||\n    (year == o.year && (month < o.month ||\n                       (month == o.month && day < o.day)))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Type Member by Name in Scala Reflection\nDESCRIPTION: Shows how to query for a type member using the `member` method. Unlike term members, type members (like type aliases or abstract types) require the name to be passed as a `TypeName`. This example finds the `Self` type member of `List[_]`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/reflection/symbols-trees-types.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n\ntypeOf[List[_]].member(\"Self\": TypeName)\n```\n\n----------------------------------------\n\nTITLE: Partial DirectedGraph Implementation in Scala with Abstract Node and Edge\nDESCRIPTION: Provides a partial implementation of DirectedGraph that extends Graph. The Edge type is abstract but bounded to EdgeImpl. It defines inner classes EdgeImpl and NodeImpl, with NodeImpl implementing connectWith to create edges. Factory methods newNode and newEdge are declared abstract for subclasses to implement. Nodes and edges are mutable lists maintained internally. This design supports extensibility but leads to type mismatch errors when calling newEdge using 'this' without explicit self-types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/self-types.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nabstract class DirectedGraph extends Graph {\n  type Edge <: EdgeImpl\n  class EdgeImpl(origin: Node, dest: Node) {\n    def from = origin\n    def to = dest\n  }\n  class NodeImpl extends NodeIntf {\n    def connectWith(node: Node): Edge = {\n      val edge = newEdge(this, node)\n      edges = edge :: edges\n      edge\n    }\n  }\n  protected def newNode: Node\n  protected def newEdge(from: Node, to: Node): Edge\n  var nodes: List[Node] = Nil\n  var edges: List[Edge] = Nil\n  def addNode: Node = {\n    val node = newNode\n    nodes = node :: nodes\n    node\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing and Printing Quasiquote Trees Using showCode - Scala\nDESCRIPTION: This snippet illustrates how to create an abstract syntax tree (AST) using Scala's quasiquotes and then pretty-print the source-like code with 'showCode'. It creates a simple class definition, demonstrates the AST structure, and outputs the reconstructed source code. Dependencies include an initialized reflection universe and access to 'showCode'. Input is Scala reflection code, output includes class AST and printed source. The 'showCode' pretty printer is only available in Scala 2.11 and higher.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/setup.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval C = q\"class C\"\nC: universe.ClassDef =\nclass C extends scala.AnyRef {\n  def <init>() = {\n    super.<init>();\n    ()\n  }\n}\n\nprintln(showCode(C))\nclass C\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Generators and Guards in For Loops in Scala 3\nDESCRIPTION: In Scala 3, iterates over a numeric and a character range with two guards, printing only when i equals 2 and j is 'b'. Prerequisites: no additional imports required. Only this condition triggers the side effect.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nfor\n  i <- 1 to 3\n  j <- 'a' to 'c'\n  if i == 2\n  if j == 'b'\ndo\n  println(s\"i = $i, j = $j\")   // prints: \"i = 2, j = b\"\n\n```\n\n----------------------------------------\n\nTITLE: Пример вычисления суммы с использованием for-comprehension\nDESCRIPTION: Демонстрация обработки успешной и неудачной конвертации строк в числа с помощью for. В случае успеха возвращается Some с суммой, в противном случае – None, что иллюстрирует преимущества функциональных конструкций.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fp-functional-error-handling.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval stringA = \"1\"\nval stringB = \"2\"\nval stringC = \"3\"\n\nval y = for\n  a <- makeInt(stringA)\n  b <- makeInt(stringB)\n  c <- makeInt(stringC)\nyield\n  a + b + c\n```\n\n----------------------------------------\n\nTITLE: Using @main Method with Typed Command-Line Arguments and Varargs in Scala 3\nDESCRIPTION: Demonstrates a Scala 3 @main method accepting multiple typed parameters, including an integer, a string, and a variable number of additional string arguments. The method determines the correct ordinal suffix for the age, constructs a birthday message combining all inputs, and prints it. Dependencies include the Scala 3 compiler and automatic generation of command-line argument parsers via scala.util.CommandLineParser.FromString typeclasses. Input parameters are parsed from command-line strings, throwing errors on invalid input or insufficient arguments. Output is a formatted birthday message.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/methods-main-methods.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n@main def happyBirthday(age: Int, name: String, others: String*) =\n  val suffix = (age % 100) match\n    case 11 | 12 | 13 => \"th\"\n    case _ => (age % 10) match\n      case 1 => \"st\"\n      case 2 => \"nd\"\n      case 3 => \"rd\"\n      case _ => \"th\"\n\n  val sb = StringBuilder(s\"Happy $age$suffix birthday, $name\")\n  for other <- others do sb.append(\" and \").append(other)\n  println(sb.toString)\n```\n\n----------------------------------------\n\nTITLE: Using the SensorReader Component (Scala 2)\nDESCRIPTION: Demonstrates Scala 2 usage of the `SensorReader` component. It imports members from `SensorReader`, creates instances of `Sensor` and `Display` using `new`, subscribes displays (observers) to sensors (subjects), and triggers updates via the `changeValue` method, which results in notifications being printed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\nimport SensorReader._\n\n// setting up a network\nval s1 = new Sensor(\"sensor1\")\nval s2 = new Sensor(\"sensor2\")\nval d1 = new Display()\nval d2 = new Display()\ns1.subscribe(d1)\ns1.subscribe(d2)\ns2.subscribe(d1)\n\n// propagating updates through the network\ns1.changeValue(2)\ns2.changeValue(3)\n\n// prints:\n// sensor1 has value 2.0\n// sensor1 has value 2.0\n// sensor2 has value 3.0\n```\n\n----------------------------------------\n\nTITLE: Implicit Conversion from Array to ArraySeq and Back\nDESCRIPTION: Demonstrates implicit conversion of a Scala array to a scala.collection.Seq (ArraySeq), and how to convert back to an array using toArray, illustrating intercompatibility and copying behavior. Clarifies that arrays are wrapped as ArraySeqs rather than being subtypes of Seq.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/arrays.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval seq: collection.Seq[Int] = a1\nval a4: Array[Int] = seq.toArray\na1 eq a4\n```\n\n----------------------------------------\n\nTITLE: Ініціалізація простого Scala 3 додатку - Scala\nDESCRIPTION: Цей короткий приклад демонструє визначення основної функції Scala 3 з використанням анотації @main. Після компіляції файлу подається текст \"Hello, world\" у стандартний вивід. Необхідним є Scala 3 компілятор (scalac). Вхідні дані - відсутні, вихід - вивід рядка у консоль.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/scala3/guides/tasty-overview.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n@main def hello = println(\"Hello, world\")\n```\n\n----------------------------------------\n\nTITLE: Multi-line if Statement in Java\nDESCRIPTION: Demonstrates a multi-line if statement in Java with curly braces that executes two println statements if the condition is met. Illustrates conventional block structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_29\n\nLANGUAGE: java\nCODE:\n```\nif (x == 1) {\n  System.out.println(\"x is 1, as you can see:\")\n  System.out.println(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Compile-Time Inline Constants in Scala 3\nDESCRIPTION: This snippet shows how to declare values as inline constants to ensure they are inlined at compile-time, enabling optimizations like constant folding. It highlights that only constant expressions can be assigned to inline vals, and demonstrates compiler behavior for invalid inline definitions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ninline val pi = 3.141592653589793\ninline val pie = \"🥧\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval pi2 = pi + pi // val pi2 = 6.283185307179586\nval pie2 = pie + pie // val pie2 = \"🥧🥧\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval pi = 3.141592653589793\ninline val pi2 = pi + pi // error\n```\n\n----------------------------------------\n\nTITLE: Type Ascription Compatibility Edge Case in Scala\nDESCRIPTION: This snippet demonstrates a compatibility edge case resulting from the fewerBraces feature in Scala, where a type ascription written on a new indented line after a colon is interpreted differently. The code assigns 'y' to 'x' and attempts to ascribe 'Int' in a manner that could become illegal or ambiguous with the SIP. The example highlights rare incompatibilities that may arise and shows alternative legal forms.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval x = y:\n  Int\n```\n\n----------------------------------------\n\nTITLE: Scala Class Instantiation with Constructor in Scala 2\nDESCRIPTION: Shows object creation using constructor with new keyword, illustrating instance creation in Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-modeling.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\n// this code uses that constructor\nval p = new Person(\"John\", \"Stephens\")\n```\n\n----------------------------------------\n\nTITLE: Handling Optional Query Parameter with Cask (Scala 3)\nDESCRIPTION: Defines a Cask web application using Scala 3 syntax. The endpoint `/time` accepts an optional query parameter `city`, modeled with `Option[String] = None`. It looks up the timezone for the given city and returns the current time, defaulting to the system timezone if the city parameter is missing or invalid. This snippet is functionally identical to the Scala 2 version, showcasing the updated syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/web-server-query-parameters.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport java.time.{ZoneId, ZonedDateTime}\n\nobject Example extends cask.MainRoutes:\n\n  private def getZoneIdForCity(city: String): Option[ZoneId] =\n    import scala.jdk.CollectionConverters.*\n    ZoneId.getAvailableZoneIds.asScala.find(_.endsWith(\"/\" + city)).map(ZoneId.of)\n\n  @cask.get(\"/time\")\n  def dynamicWithParam(city: Option[String] = None): String =\n    city match\n      case Some(value) => getZoneIdForCity(value) match\n        case Some(zoneId) => s\"Current date is: ${ZonedDateTime.now().withZoneSameInstant(zoneId)}\"\n        case None => s\"Couldn't find time zone for city $value\"\n      case None => s\"Current date is: ${ZonedDateTime.now()}\"\n\n  initialize()\n```\n\n----------------------------------------\n\nTITLE: Example of YAML Front Matter in Scaladoc Templates\nDESCRIPTION: Shows how to define custom title in the YAML front matter section of a template file, which will be used for page metadata.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/static-site.md#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n---\ntitle: My custom title\n---\n```\n\n----------------------------------------\n\nTITLE: Defining a generic method with 'Showable' in Scala 2\nDESCRIPTION: Defines a method 'showAll' that takes a list of any type 'A' with an implicit 'Showable[A]' instance, printing each element's string representation. Showcases type class electrical wiring for Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-type-classes.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef showAll[A](as: List[A])(implicit showable: Showable[A]): Unit =\n  as.foreach(a => println(showable.show(a)))\n\nshowAll(List(Person(\"Jane\"), Person(\"Mary\")))\n```\n\n----------------------------------------\n\nTITLE: Implementing Intersperse with BuildFrom for Scala 2 and 3\nDESCRIPTION: Shows the revised implementation of the 'intersperse' operation, replacing `Factory` with `scala.collection.BuildFrom`. By taking an implicit `BuildFrom[Repr, B, That]` and passing the source collection `coll` to `bf.fromSpecific`, this version correctly resolves the output type `That` to match the source collection `Repr`, preserving the original collection type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collection-operations.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.{ AbstractView, BuildFrom }\nimport scala.collection.generic.IsSeq\n\nclass IntersperseOperation[Repr, S <: IsSeq[Repr]](coll: Repr, seq: S) {\n  def intersperse[B >: seq.A, That](sep: B)(implicit bf: BuildFrom[Repr, B, That]): That = {\n    val seqOps = seq(coll)\n    bf.fromSpecific(coll)(new AbstractView[B] {\n      // same as before\n    })\n  }\n}\n\nimplicit def IntersperseOperation[Repr](coll: Repr)(implicit seq: IsSeq[Repr]): IntersperseOperation[Repr, seq.type] =\n  new IntersperseOperation(coll, seq)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.{ AbstractIterator, AbstractView, BuildFrom }\nimport scala.collection.generic.IsSeq\n\nextension [Repr](coll: Repr)(using seq: IsSeq[Repr])\n  def intersperse[B >: seq.A, That](sep: B)(using bf: BuildFrom[Repr, B, That]): That =\n    val seqOps = seq(coll)\n    bf.fromSpecific(coll)(new AbstractView[B]:\n      // same as before\n    )\n```\n\n----------------------------------------\n\nTITLE: Importing Scala Reflection Runtime Universe\nDESCRIPTION: Imports the specific `universe` object from `scala.reflect.runtime`. This object contains definitions for standard Scala types, accessible via `universe.definitions`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nscala> import scala.reflect.runtime.universe\nimport scala.reflect.runtime.universe\n```\n\n----------------------------------------\n\nTITLE: Comparing Positional vs. Named Parameters for Instantiation in Scala 2\nDESCRIPTION: This snippet compares instantiating a class using positional arguments versus using named parameters in Scala 2. Named parameters improve code readability, especially when multiple parameters have the same type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\n// option 1\nval s = new Socket(10_000, 10_000)\n\n// option 2\nval s = new Socket(\n  timeout = 10_000,\n  linger = 10_000\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing the Pizza Class in Scala\nDESCRIPTION: This code defines a 'Pizza' class with mutable properties for crust size and type, and a mutable list of toppings using Scala's ArrayBuffer. It includes methods to add, remove, and clear toppings, illustrating encapsulation and state management within an object-oriented design.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/enumerations-pizza-class.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass Pizza (\n    var crustSize: CrustSize = MediumCrustSize, \n    var crustType: CrustType = RegularCrustType\n) {\n\n    // ArrayBuffer is a mutable sequence (list)\n    val toppings = scala.collection.mutable.ArrayBuffer[Topping]()\n\n    def addTopping(t: Topping): Unit = toppings += t\n    def removeTopping(t: Topping): Unit = toppings -= t\n    def removeAllToppings(): Unit = toppings.clear()\n\n}\n```\n\n----------------------------------------\n\nTITLE: Adding MUnit via Toolkit using Scala CLI\nDESCRIPTION: Adds the entire Scala Toolkit, including MUnit, as a dependency using a Scala CLI `//> using` directive. This configuration applies only to test files (in a `test` directory or with a `.test.scala` extension).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-munit.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n//> using toolkit latest\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Arguments in Scala Traits and Classes\nDESCRIPTION: Example showing how default arguments interact with method overriding in Scala inheritance. Demonstrates how a subclass can inherit, override, or add new default arguments to methods defined in a superclass or trait.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-and-default-arguments.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ntrait A { def f(a: Int = 1, b: Int): (Int, Int) }\n// B: inherit & add a default\nclass B extends A { def f(a: Int,     b: Int = 2) = (a, b) }\n// C: override a default\nclass C extends A { def f(a: Int = 3, b: Int    ) = (a, b) }\nval a1: A = new B\nval a2: A = new C\n// a1.f()   // \"error: unspecified parameter: value b\"\na2.f(b = 2) // returns (3, 2)\n```\n\n----------------------------------------\n\nTITLE: Running a Command in Interactive sbt Shell\nDESCRIPTION: Demonstrates running the HelloWorld program from an interactive sbt shell, which executes much faster than running sbt in batch mode.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/scala-build-tool-sbt.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n> run\n[info] Running HelloWorld \nHello, world\n[success] Total time: 0 s\n```\n\n----------------------------------------\n\nTITLE: Defining Custom `ToExpr` Instances for `Boolean` and `StringContext`\nDESCRIPTION: Shows how to define custom `given` instances of `ToExpr` for specific types. Examples for `Boolean` (generating `'{true}` or `'{false}`) and `StringContext` (reconstructing the object using its parts) are provided. Uses `Varargs` helper for splicing sequence elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ngiven ToExpr[Boolean] with {\n  def apply(x: Boolean)(using Quotes) =\n    if x then '{true}\n    else '{false}\n}\n\ngiven ToExpr[StringContext] with {\n  def apply(stringContext: StringContext)(using Quotes) =\n    val parts = Varargs(stringContext.parts.map(Expr(_)))\n    '{ StringContext($parts*) }\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Elements from ArrayBuffer in Scala\nDESCRIPTION: Details how to remove elements individually or from collections using '-=' and '--=' methods, providing examples for the removal of specific elements or collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/arraybuffer-examples.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n// remove one element\nnums -= 9\n// remove multiple elements\nnums -= 7 -= 8\n// remove multiple elements using another collection\nnums --= Array(5, 6)\n```\n\n----------------------------------------\n\nTITLE: Documenting Factory Objects and Apply Methods in Scala\nDESCRIPTION: Demonstrates documenting a companion object that serves as a factory for class instances. It shows how to document the object's purpose and specifically document multiple `apply` factory methods using `@param` and `@return` tags.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/scaladoc.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\n/** Factory for [[mypackage.Person]] instances. */\nobject Person {\n  /** Creates a person with a given name and age.\n   *\n   *  @param name their name\n   *  @param age the age of the person to create\n   */\n  def apply(name: String, age: Int) = {}\n\n  /** Creates a person with a given name and birthdate\n   *\n   *  @param name their name\n   *  @param birthDate the person's birthdate\n   *  @return a new Person instance with the age determined by the\n   *          birthdate and current date.\n   */\n  def apply(name: String, birthDate: java.time.LocalDate) = {}\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom Type as Main Method Argument Scala 3\nDESCRIPTION: Shows how to use a user-defined type (`Color` enum) as a parameter in a `@main` method. This requires defining an implicit `scala.util.CommandLineParser.FromString` instance for the custom type, providing logic to convert a command line string to an instance of that type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-main-methods.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nenum Color:\n  case Red, Green, Blue\n\ngiven CommandLineParser.FromString[Color] with\n  def fromString(value: String): Color = Color.valueOf(value)\n\n@main def run(color: Color): Unit =\n  println(s\"The color is ${color.toString}\")\n```\n\n----------------------------------------\n\nTITLE: Implicit Definition Without Explicit Type Warning Example\nDESCRIPTION: Demonstrates how -Xsource:3 warns about implicit definitions that lack explicit type annotations, which are required in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tooling-scala2-xsource3.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject O { implicit val s = \"\" }\n```\n\n----------------------------------------\n\nTITLE: Instantiating Java objects in Scala\nDESCRIPTION: Shows how to instantiate a Java class object (in this case `java.io.File`) within Scala code using the `new` keyword and constructor parameter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\nnew java.io.File(\"f\")\n```\n\n----------------------------------------\n\nTITLE: Operator Syntax and Varargs - Scala\nDESCRIPTION: Demonstrates infix operator syntax sugar and variable argument lists using '*'. Inputs: integers or sequences. Outputs: arithmetic results or reductions. Highlights how to write more idiomatic and concise code when working with collections and operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\n5.+(3); 5 + 3\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(1 to 5) map (_*2)\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef sum(args: Int*) = args.reduceLeft(_+_)\n```\n\n----------------------------------------\n\nTITLE: Creating and using mutable OOP instances in Python and Scala\nDESCRIPTION: Demonstrates how to instantiate and modify mutable class instances in Python and Scala. Dependencies include previous class definitions. Inputs are initial names and modifications to the name property. Outputs are printed names before and after modification and the result from speak method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nval p = Person(\"John\")\np.name  // John\np.name = \"Fred\"\np.name  // Fred\np.speak()\n```\n\n----------------------------------------\n\nTITLE: Switch Statement With Multiple Cases in Java\nDESCRIPTION: A Java switch statement demonstrating multiple conditions per case (fall-through behavior) for determining if an integer is odd or even, or marking it too big for unsupported values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_50\n\nLANGUAGE: java\nCODE:\n```\nString numAsString = \"\";\nswitch (i) {\n  case 1: case 3:\n  case 5: case 7: case 9: \n    numAsString = \"odd\";\n    break;\n  case 2: case 4:\n  case 6: case 8: case 10: \n    numAsString = \"even\";\n    break;\n  default:\n    numAsString = \"too big\";\n    break;\n}\n```\n\n----------------------------------------\n\nTITLE: Filter Function Using Lambda in Python\nDESCRIPTION: Defines a lambda function 'f' that tests if a value is greater than 1, then uses 'filter' with 'f' over 'numbers' to select matching elements, returning a filter object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_33\n\nLANGUAGE: Python\nCODE:\n```\nf = lambda x: x > 1\nx = filter(f, numbers)\n```\n\n----------------------------------------\n\nTITLE: Defining Companion Objects for Pizza and Topping in Scala 2\nDESCRIPTION: Example showing how to define a Pizza case class with a companion object containing behavior, alongside a Topping enumeration with its companion object in Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-fp.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Pizza(\n  crustSize: CrustSize,\n  crustType: CrustType,\n  toppings: Seq[Topping]\n)\n\n// сопутствующий объект для case class Pizza\nobject Pizza {\n  // тоже самое, что и `pizzaPrice`\n  def price(p: Pizza): Double = ...\n}\n\nsealed abstract class Topping\n\n// сопутствующий объект для перечисления Topping\nobject Topping {\n  case object Cheese extends Topping\n  case object Pepperoni extends Topping\n  case object BlackOlives extends Topping\n  case object GreenOlives extends Topping\n  case object Onions extends Topping\n\n  // тоже самое, что и `toppingPrice`\n  def price(t: Topping): Double = ...\n}\n```\n\n----------------------------------------\n\nTITLE: クラス定義とメソッドの実装 - Scala\nDESCRIPTION: クラスGreeterを定義し、コンストラクター引数に応じてgreetメソッドで挨拶文を出力する例です。メソッドは戻り値Unit（void相当）を持ち、文字列結合で結果を標準出力に表示します。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nclass Greeter(prefix: String, suffix: String) {\n  def greet(name: String): Unit =\n    println(prefix + name + suffix)\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating universal equality issue in Scala\nDESCRIPTION: Shows how universal equality allows comparing values of incompatible types, which may compile but will yield unexpected results during runtime.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-multiversal-equality.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval x = ...   // of type T\nval y = ...   // of type S, but should be T\nx == y        // typechecks, will always yield false\n```\n\n----------------------------------------\n\nTITLE: Scala 3 list comprehension filtering by length\nDESCRIPTION: Uses Scala 3's 'for'-'yield' syntax with multiple lines and comments to filter and transform a list of strings based on length.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nval fruits = List(\"apple\", \"banana\", \"lime\", \"orange\")\n\nval fruitLengths = for\n  f <- fruits\n  if f.length > 4\nyield\n  // здесь можно использовать\n  // несколько строк кода\n  f.length\n// fruitLengths: List[Int] = List(5, 6, 6)\n```\n\n----------------------------------------\n\nTITLE: Using Scala Compiler Options with scalac Command Line - Bash\nDESCRIPTION: Demonstrates how to run the Scala compiler (scalac) specifying compiler flags and options from the command line. Shows usage of boolean flags, options requiring arguments using colon syntax, and options with single arguments using traditional syntax. It illustrates conventions for prefix usage such as -W for warnings, -X for extended options, and others. Examples include enabling warnings as errors, verbose printing phases, and setting output directory.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/compiler-options/index.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nscalac [ <options> ] <source files>\n\nscalac -Werror -Xlint Hello.scala\n\nscalac -Vprint:parser,typer\n\nscalac -d /tmp\n```\n\n----------------------------------------\n\nTITLE: Defining Animal Hierarchy Classes in Scala for Variance Examples\nDESCRIPTION: This snippet defines an abstract class Animal and two case classes Cat and Dog extending Animal. It provides a subclass structure used in subsequent examples demonstrating covariance and contravariance of generic classes with respect to Animal and its subclasses.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/variances.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Animal {\n  def name: String\n}\ncase class Cat(name: String) extends Animal\ncase class Dog(name: String) extends Animal\n```\n\n----------------------------------------\n\nTITLE: Определение параметризованных трейтов с разной вариантностью в Scala 3\nDESCRIPTION: Идентичный предыдущему, этот фрагмент представляет определения инвариантного Pipeline, ковариантного Producer и контравариантного Consumer с использованием синтаксиса Scala 3 (с двоеточиями вместо фигурных скобок). Демонстрирует, как концепции вариантности сохраняются в новой версии языка при использовании современного стиля оформления кода.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-variance.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n// пример инвариантного типа\ntrait Pipeline[T]:\n  def process(t: T): T\n\n// пример ковариантного типа\ntrait Producer[+T]:\n  def make: T\n\n// пример контрвариантного типа\ntrait Consumer[-T]:\n  def take(t: T): Unit\n```\n\n----------------------------------------\n\nTITLE: Implementing cloneAndReset Function Using Compound Types in Scala\nDESCRIPTION: Defines a Scala function cloneAndReset that accepts an object parameter of a compound type combining Cloneable and Resetable traits (Cloneable with Resetable). The function clones the object and then resets it, returning the cloned Copy. This approach enforces at compile time that the object must support both cloning and resetting behaviors, improving type safety by avoiding casts.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/compound-types.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef cloneAndReset(obj: Cloneable with Resetable): Cloneable = {\n  //...\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing StringContext.f Interpolator Bug in Scala Compiler Macro Implementation - Scala and Diff\nDESCRIPTION: Shows the source code patch applied to `MacroImplementations.scala` to fix a bug in the Scala compiler's macro implementation of the `StringContext.f` interpolator. The fix prevents tokens like `%n` from being incorrectly escaped, allowing proper newline transformations. The patch adds a guard condition to exclude `%n` sequences from being replaced with `%%`. The snippet includes the relevant code context and details the modification in the string processing logic within the macro.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/hacker-guide.md#_snippet_2\n\nLANGUAGE: Diff\nCODE:\n```\ndiff --git a/src/compiler/scala/tools/reflect/MacroImplementations.scala b/src/compiler/scala/tools/reflect/MacroImplementations.scala\nindex 002a3fce82..4e8f02084d 100644\n--- a/src/compiler/scala/tools/reflect/MacroImplementations.scala\n+++ b/src/compiler/scala/tools/reflect/MacroImplementations.scala\n@@ -117,7 +117,8 @@ abstract class MacroImplementations {\n       if (!strIsEmpty) {\n         val len = str.length\n         while (idx < len) {\n-          if (str(idx) == '%') {\n+          def notPercentN = str(idx) != '%' || (idx + 1 < len && str(idx + 1) != 'n')\n+          if (str(idx) == '%' && notPercentN) {\n             bldr append (str substring (start, idx)) append \"%%\"\n             start = idx + 1\n           }\n```\n\n----------------------------------------\n\nTITLE: Defining a Class and Companion Object in Scala\nDESCRIPTION: Demonstrates the standard Scala practice where a class (`Inbox`) and its companion object (`Inbox`) must be defined within the same source file. The example suggests naming the file `Inbox.scala` and placing it in a directory structure mirroring the package name (`org/coolness`), following common Java/Scala conventions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/files.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\npackage org.coolness\n\nclass Inbox { ... }\n\n// companion object\nobject Inbox { ... }\n```\n\n----------------------------------------\n\nTITLE: Summoning an Expression for a Statically Unknown Type Using Type\nDESCRIPTION: A pattern matching approach to summon a type class instance for a type represented by Type[_] at compile time, using Expr.summon within a pattern match context.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/faq.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval tpe: Type[_] = ...\ntpe match\n  // (1) Use `a` as the name of the unknown type and (2) bring a given `Type[a]` into scope\n  case '[a] => Expr.summon[a]\n```\n\n----------------------------------------\n\nTITLE: Defining a computationally expensive function in Scala\nDESCRIPTION: Defines a Scala function `f` that takes a `String` argument and returns its reversed value after simulating a delay with print and sleep calls. This function is pure with no side effects other than console output, used here to illustrate performance improvement when cached. Requires standard Scala libraries and an available `sleep` method or similar.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/maps.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: String) = {\n       println(\"taking my time.\"); sleep(100)\n       x.reverse }\n```\n\n----------------------------------------\n\nTITLE: Multi-line if statement in Python and Scala\nDESCRIPTION: Illustrates multiline if control structure syntax to execute multiple instructions when condition is true. Inputs: variable x; outputs: several print calls if x==1. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\nif x == 1 then\n  println(\"x is 1, as you can see:\")\n  println(x)\n```\n\n----------------------------------------\n\nTITLE: Initializing Lists and Sequences in Python\nDESCRIPTION: Shows Python list initialization with elements [1, 2, 3]. Serves as a basic example of mutable sequence creation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_35\n\nLANGUAGE: Python\nCODE:\n```\na = [1,2,3]\n```\n\n----------------------------------------\n\nTITLE: Defining an Enum with Pattern Matching Alternatives in Scala\nDESCRIPTION: This snippet defines a generic enum Foo with two cases (Bar and Baz), each carrying a generic value. It includes a method test that pattern matches on the current instance using a single case with an or-pattern (Bar(id: Int) | Baz(id)), binding the variable id. The compiler infers id's type: if any branch uses type ascription, the union type is inferred. No external dependencies are required. Inputs are instances of Foo; output is the value bound as id. Limitations: the branches must bind the same set of variables, and mixing ascriptions may produce wider types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/alternative-bind-variables.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nenum Foo[A]:\n  case Bar[A](a: A)\n  case Baz[A](a: A)\n\n  def test = this match\n    case Bar(id: Int) | Baz(id) => id\n```\n\n----------------------------------------\n\nTITLE: Implementation of Identity Macro Annotation with Whitebox Context - Scala\nDESCRIPTION: Implements the `identity` macro annotation expanding logic using a whitebox macro context. The macro `impl` receives the annottees as untyped expressions and separates them into an annottee parameter and its expandees (such as companion objects or classes). It logs the processed annottees and returns them unchanged in a block, effectively acting as a no-op identity macro while demonstrating the many-to-many expansion capability in macro annotations. This snippet depends on the macro paradise plugin and Scala's reflection API.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/annotations.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.annotation.{StaticAnnotation, compileTimeOnly}\nimport scala.language.experimental.macros\nimport scala.reflect.macros.whitebox\n\n@compileTimeOnly(\"enable macro paradise to expand macro annotations\")\nclass identity extends StaticAnnotation {\n  def macroTransform(annottees: Any*): Any = macro identityMacro.impl\n}\n\nobject identityMacro {\n  def impl(c: whitebox.Context)(annottees: c.Expr[Any]*): c.Expr[Any] = {\n    import c.universe._\n    val inputs = annottees.map(_.tree).toList\n    val (annottee, expandees) = inputs match {\n      case (param: ValDef) :: (rest @ (_ :: _)) => (param, rest)\n      case (param: TypeDef) :: (rest @ (_ :: _)) => (param, rest)\n      case _ => (EmptyTree, inputs)\n    }\n    println((annottee, expandees))\n    val outputs = expandees\n    c.Expr[Any](Block(outputs, Literal(Constant(()))))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Custom `map` Function in Scala\nDESCRIPTION: Defines a fully generic standalone higher-order function `map` that works with any `List[B]`. It accepts a function `f` (B => A) and a `List[B]`, applies `f` to each element using a for-expression, and returns a new `List[A]`. Includes implementations for Scala 2 and Scala 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-write-map-function.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef map[A, B](f: (B) => A, xs: List[B]): List[A] =\n  for (x <- xs) yield f(x)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef map[A, B](f: (B) => A, xs: List[B]): List[A] =\n  for x <- xs yield f(x)\n```\n\n----------------------------------------\n\nTITLE: Commands to Create Standard sbt Directory Structure - Bash\nDESCRIPTION: This bash snippet demonstrates creating a new sbt project directory with the expected 'src' and 'project' folders using shell commands. It uses mkdir with braces for creating nested source directories for main and test Scala sources, alongside 'project' and 'target' folders, preparing the project for convention-based building and compilation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ mkdir HelloWorld\n$ cd HelloWorld\n$ mkdir -p src/{main,test}/scala\n$ mkdir project target\n```\n\n----------------------------------------\n\nTITLE: Defining Example Class C\nDESCRIPTION: Defines a generic class `C` with a generic method `test`. This class is used as a target for subsequent reflection examples demonstrating how to access symbols and types of class members.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nscala> class C[T] { def test[U](x: T)(y: U): Int = ??? }\ndefined class C\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel BFS with ParTrieMap in Scala\nDESCRIPTION: This snippet illustrates the use of Scala's `ParTrieMap` to implement a parallel Breadth-First Search (BFS) on a 2D grid. It defines node types and movement functions. It uses two `ParTrieMap`s, `open` for nodes to visit and `closed` for visited nodes, mapping nodes to their parent. The algorithm iteratively processes nodes from the `open` map in parallel, expanding neighbors and updating the maps, demonstrating concurrent modification and traversal during the search.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/ctries.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval length = 1000\n\n\t// define the Node type\n  type Node = (Int, Int);\n  type Parent = (Int, Int);\n\n\t// operations on the Node type\n  def up(n: Node) = (n._1, n._2 - 1);\n  def down(n: Node) = (n._1, n._2 + 1);\n  def left(n: Node) = (n._1 - 1, n._2);\n  def right(n: Node) = (n._1 + 1, n._2);\n\n  // create a map and a target\n  val target = (length / 2, length / 2);\n  val map = Array.tabulate(length, length)((x, y) => (x % 3) != 0 || (y % 3) != 0 || (x, y) == target)\n  def onMap(n: Node) = n._1 >= 0 && n._1 < length && n._2 >= 0 && n._2 < length\n\n  // open list - the nodefront\n  // closed list - nodes already processed\n  val open = ParTrieMap[Node, Parent]()\n  val closed = ParTrieMap[Node, Parent]()\n\n  // add a couple of starting positions\n  open((0, 0)) = null\n  open((length - 1, length - 1)) = null\n  open((0, length - 1)) = null\n  open((length - 1, 0)) = null\n\n  // greedy bfs path search\n  while (open.nonEmpty && !open.contains(target)) {\n    for ((node, parent) <- open) {\n      def expand(next: Node) {\n        if (onMap(next) && map(next._1)(next._2) && !closed.contains(next) && !open.contains(next)) {\n          open(next) = node\n        }\n      }\n      expand(up(node))\n      expand(down(node))\n      expand(left(node))\n      expand(right(node))\n      closed(node) = parent\n      open.remove(node)\n    }\n  }\n\n  // print path\n  var pathnode = open(target)\n  while (closed.contains(pathnode)) {\n    print(pathnode + \"->\")\n    pathnode = closed(pathnode)\n  }\n  println()\n```\n\n----------------------------------------\n\nTITLE: Declaring Numeric Data Types in Scala\nDESCRIPTION: Provides examples of variables of common numeric data types in Scala, including Byte, Int, Long, Short, Double, and Float.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-vars-data-types.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval b: Byte = 1\nval i: Int = 1\nval l: Long = 1\nval s: Short = 1\nval d: Double = 2.0\nval f: Float = 3.0\n```\n\n----------------------------------------\n\nTITLE: Unlifting Identifier Name Quasiquotes - Scala\nDESCRIPTION: Shows how to extract the `TermName` value from an identifier AST node using pattern matching with quasiquotes and type ascription. The pattern `q\"${name: TermName}\"` matches an identifier and binds its name to the `name` variable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"${name: TermName}\" = q\"Foo\"\nname: universe.TermName = Foo\n```\n\n----------------------------------------\n\nTITLE: Invoking Infix Operator '+' as a Regular Method in Scala 2 and 3\nDESCRIPTION: Demonstrates that the '+' operator in Scala can be invoked like a regular method using dot notation and parentheses. This example shows the integer 10 calling method '+' with parameter 1, resulting in 11 as output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/operators.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n10.+(1)\n```\n\n----------------------------------------\n\nTITLE: Scala Code Example for Inliner Logging\nDESCRIPTION: A simple Scala class with a method that performs an array operation using a higher-order function. This specific code is used as the input for the `scalac` command that demonstrates the verbose inliner logging (`-Vinline`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/compiler-options/optimizer.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\npackage my.project\nclass C {\n  def f(a: Array[Int]) = a.map(_ + 1)\n}\n```\n\n----------------------------------------\n\nTITLE: 'for' loop with guard in Scala 2\nDESCRIPTION: Demonstrates filtering within a 'for' loop in Scala 2 by including a guard condition, printing only elements greater than 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nfor (i <- ints if i > 2)\n  println(i)\n```\n\n----------------------------------------\n\nTITLE: Comprehensions for creating new collections in Python and Scala\nDESCRIPTION: Demonstrates creating a new collection by transforming elements of a range using list comprehension in Python and yielding a Vector in Scala. Inputs: range 1 to 3; outputs: collection of products (10, 20, 30). No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_44\n\nLANGUAGE: Scala\nCODE:\n```\nval xs = for i <- 1 to 3 yield i * 10\n// xs: Vector(10, 20, 30)\n```\n\n----------------------------------------\n\nTITLE: Using match Expressions as Method Bodies\nDESCRIPTION: Demonstrates how to implement a method using pattern matching with match expressions, providing an alternative implementation of the isTruthy method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/methods-most.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\n// Scala 2\ndef isTruthy(a: Any) = a match {\n  case 0 | \"\" | false => false\n  case _ => true\n}\n\n// Scala 3\ndef isTruthy(a: Matchable) = a match\n  case 0 | \"\" | false => false\n  case _ => true\n```\n\n----------------------------------------\n\nTITLE: Running a Single Test Suite with Scala CLI\nDESCRIPTION: Shows how to run a specific test suite using Scala CLI by specifying the '--test-only' option of the 'test' command. Requires Scala CLI installation and the presence of the test suite class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-run-only.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nscala-cli test example --test-only example.MyTests\n```\n\n----------------------------------------\n\nTITLE: Defining SIP-36 Metadata (YAML)\nDESCRIPTION: This YAML frontmatter defines metadata for Scala Improvement Proposal 36 (SIP-36). It specifies the proposal's title as 'Adding prefix types', its status as 'withdrawn', and links it to pull request number 35.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/adding-prefix-types.md#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\n---\ntitle: SIP-36 - Adding prefix types\nstatus: withdrawn\npull-request-number: 35\n\n---\n```\n\n----------------------------------------\n\nTITLE: Utilizing a Dependent Type Function Alias for 'DB' in Scala 3\nDESCRIPTION: This snippet redefines 'DB' as a function type '(k: Key) => Option[k.Value]', leveraging Scala 3's dependent type functions. It allows for cleaner syntax when creating database instances and using 'get' operations without explicit class implementations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-dependent-function.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ntype DB = (k: Key) => Option[k.Value]\n//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n//        зависимый тип функции\n```\n\n----------------------------------------\n\nTITLE: Importing an Extension Method in Scala 3\nDESCRIPTION: Shows how to import an extension method (`circumference`), assumed to be defined in a package named `lib`, to make it available in the current scope. The import statement `import lib.circumference` brings the extension method into scope, allowing its direct use on `Circle` instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-extension-methods.md#_snippet_5\n\nLANGUAGE: Scala 3\nCODE:\n```\nimport lib.circumference\n\naCircle.circumference\n```\n\n----------------------------------------\n\nTITLE: Example Usage Creating and Connecting Nodes in ConcreteDirectedGraph with Scala\nDESCRIPTION: This Scala snippet demonstrates how to instantiate and use the concrete implementation `ConcreteDirectedGraph`. It creates a new graph, adds three nodes, and connects them using the `connectWith` method. This example validates the functionality of the previous class definitions by showing the construction of nodes and edges in a directed graph setup.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/self-types.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef graphTest: Unit = {\n  val g: Graph = new ConcreteDirectedGraph\n  val n1 = g.addNode\n  val n2 = g.addNode\n  val n3 = g.addNode\n  n1.connectWith(n2)\n  n2.connectWith(n3)\n  n1.connectWith(n3)\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Immutability of Case Class Parameters in Scala\nDESCRIPTION: Shows defining a case class with multiple immutable parameters and demonstrates that trying to reassign a 'val' parameter results in a compilation error. The code outputs the 'sender' field of a 'Message' instance. Dependencies include Scala's immutable data handling. Inputs are strings representing sender, recipient, and body. Outputs include accessing the 'sender' parameter and a comment noting reassignment is illegal.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tour/case-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class Message(sender: String, recipient: String, body: String)\nval message1 = Message(\"guillaume@quebec.ca\", \"jorge@catalonia.es\", \"Ça va ?\")\n\nprintln(message1.sender)  // prints guillaume@quebec.ca\nmessage1.sender = \"travis@washington.us\"  // cette ligne ne compile pas\n```\n\n----------------------------------------\n\nTITLE: Using a Single-Line if Statement in Java\nDESCRIPTION: In Java, an `if` statement can control the execution of a single line of code. Curly braces are often omitted for single statements, though using them is recommended for clarity and to avoid potential errors.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_30\n\nLANGUAGE: Java\nCODE:\n```\nif (x == 1) { System.out.println(1); }\n```\n\n----------------------------------------\n\nTITLE: Legal Use of locally for Block Expressions in Scala\nDESCRIPTION: This snippet shows how to correctly use the 'locally' function (or macro) to rewrite expressions that would otherwise be illegal with colon blocks after infix operators under fewerBraces. It wraps the indented block inside 'locally', which accepts a call-by-name argument and ensures valid syntax. This solution is applicable for Scala 3 codebases making use of SIP-44.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\na < b || locally:\n  val x = f(c)\n  x > 0\n```\n\n----------------------------------------\n\nTITLE: Использование инвариантного типа Pipeline в Scala 3\nDESCRIPTION: Аналог функции oneOf из Scala 2, переписанный с использованием синтаксиса Scala 3. Продемонстрировано выполнение тех же операций — сравнений и вызовов методов — с кратким стилем записи. Показывает, что поведение и ограничения инвариантности сохраняются несмотря на изменение синтаксиса.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-variance.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef oneOf(\n  p1: Pipeline[Buyable],\n  p2: Pipeline[Buyable],\n  b: Buyable\n): Buyable =\n  val b1 = p1.process(b)\n  val b2 = p2.process(b)\n  if b1.price < b2.price then b1 else b2\n```\n\n----------------------------------------\n\nTITLE: Setting Scala 2 Nightly Version in sbt Build (sbt)\nDESCRIPTION: This line sets the version of Scala used in your sbt project to a specific nightly build. Replace the example version string with the full nightly version containing the appropriate 7-character commit SHA. Requires prior addition of the special nightly resolver in build configuration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/nightlies.md#_snippet_7\n\nLANGUAGE: sbt\nCODE:\n```\nscalaVersion := \"2.13.1-bin-abcd123\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Macro in Scala 2.10 (Scala)\nDESCRIPTION: Declares a macro definition named `assert` that refers to a macro implementation method `assertImpl` in the `Asserts` object. It shows that macro definitions resemble ordinary function definitions but delegate the actual expansion to the static implementation method. The macro implementation takes a compiler context and arguments as abstract syntax trees (ASTs). This snippet requires importing Scala's experimental macro language feature and using scala.reflect.macros.Context. The call site macro invocation is replaced at compile-time by a method that receives the compiler context and expression trees representing the macro arguments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/overview.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef assert(cond: Boolean, msg: Any) = macro Asserts.assertImpl\n```\n\n----------------------------------------\n\nTITLE: Defining a Timer with Callback Function in Scala\nDESCRIPTION: Defines an object Timer containing a method oncePerSecond, which accepts a callback function of type () => Unit and invokes it once every second in an infinite loop using Thread.sleep(1000). It also defines a function timeFlies that prints a message. The main function passes timeFlies as the callback to oncePerSecond. This example illustrates treating functions as first-class objects, passing them as parameters, and using infinite loops with thread sleeping for timed callbacks. Inputs are a function taking no parameters and returning Unit; outputs are console prints every second.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tutorials/scala-for-java-programmers.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nobject Timer {\n  def oncePerSecond(callback: () => Unit): Unit = {\n    while (true) { callback(); Thread sleep 1000 }\n  }\n  def timeFlies(): Unit = {\n    println(\"time flies like an arrow...\")\n  }\n  def main(args: Array[String]): Unit = {\n    oncePerSecond(timeFlies)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Method Returning a Value Using if Statement in Java\nDESCRIPTION: Defines a Java method min that returns the smaller of two integers using the ternary conditional operator. Illustrates use of conditional expressions as return values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_33\n\nLANGUAGE: java\nCODE:\n```\npublic int min(int a, int b) {\n  return (a < b) ? a : b;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Covariant Immutable Collections in Scala\nDESCRIPTION: Shows the approximate definitions for standard library immutable collections `List` and `Vector`, highlighting their covariant type parameter `+A`. This covariance allows using a collection of a subtype (e.g., `List[Book]`) where a collection of a supertype (e.g., `List[Buyable]`) is expected.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-variance.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nclass List[+A] ...\nclass Vector[+A] ...\n```\n\n----------------------------------------\n\nTITLE: Macro Implementation Using Quasiquotes in Scala 2.10\nDESCRIPTION: Presents a macro that increments its integer argument by one, demonstrating the 2.10 macro API. Relies on `Context`, `c.universe._`, and the use of `c.Expr` for expression wrapping. The macro receives an integer expression and produces a new expression adding one; input and output are both of type `Int` via macro expansion. Intended for introductory macro writing with explicit expression wrapping required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/usecases.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n// 2.10\nobject Macro {\n  def apply(x: Int): Int = macro impl\n  def impl(c: Context)(x: c.Expr[Int]): c.Expr[Int] = { import c.universe._\n    c.Expr(q\"$x + 1\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Union Type Inference in Scala REPL\nDESCRIPTION: Shows how Scala's type inference handles expressions potentially resulting in a union type, demonstrated in a REPL session. When assigning the result of an `if/else` expression (returning either `Username` or `Password`) without explicit typing (`val a = ...`), the compiler infers a common supertype (`Object`). To get the least upper bound union type (`Password | Username`), an explicit type annotation is required (`val b: ...`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-union.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nscala> val a = if true then name else password\nval a: Object = Username(Eve)\n\nscala> val b: Password | Username = if true then name else password\nval b: Password | Username = Username(Eve)\n```\n\n----------------------------------------\n\nTITLE: Writing Hello World Program Using Scala 2\nDESCRIPTION: This Scala 2 code snippet defines a Hello World program using a singleton object containing a main method. The main method accepts command-line arguments as an array of strings and prints \"Hello, World!\" to standard output. Scala 2 requires the main entry-point method to be contained within an object to emulate Java static methods, as Scala lacks static members. The return type Unit indicates the method does not return a value. The snippet targets developers familiar with Java, highlighting similarities and differences in entry-point declaration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject HelloWorld {\n  def main(args: Array[String]): Unit = {\n    println(\"Hello, World!\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Descriptive Names for Specific Type Parameters in Scala (Correct)\nDESCRIPTION: Demonstrates the preferred method for naming type parameters with specific meanings using descriptive, capitalized names following class naming conventions (e.g., 'Key', 'Value'). This enhances readability for types like 'Map'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/naming-conventions.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\n// Right\nclass Map[Key, Value] {\n  def get(key: Key): Value\n  def put(key: Key, value: Value): Unit\n}\n```\n\n----------------------------------------\n\nTITLE: Anonymous Implementation and Factory with Abstract Types - Scala 2\nDESCRIPTION: Shows how to subclass 'SeqBuffer' into 'IntSeqBuffer' where 'U' is concretely set to Int. Implements a factory method that produces an anonymous 'IntSeqBuffer', concretizing type 'T' as 'List[U]' and assigning 'element' as a list of provided values. Demonstrates instantiation and use of abstract type members for type-safe buffering of sequences. Requires 'Seq' and 'List' from Scala collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/abstract-type-members.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class IntSeqBuffer extends SeqBuffer {\n  type U = Int\n}\n\ndef newIntSeqBuf(elem1: Int, elem2: Int): IntSeqBuffer =\n  new IntSeqBuffer {\n    type T = List[U]\n    val element = List(elem1, elem2)\n  }\nval buf = newIntSeqBuf(7, 8)\nprintln(\"length = \" + buf.length)\nprintln(\"content = \" + buf.element)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating type casting among Scala value types - Scala\nDESCRIPTION: Shows examples of casting between Scala value types such as Long to Float and Char to Int using built-in conversion methods. This snippet highlights the loss of precision during some conversions (Long to Float) and implicit conversions from Char to Int. It requires Scala standard library and illustrates how to safely perform type casts with built-in methods. The snippet also clarifies invalid type conversions via a commented error example.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/tour/unified-types.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval x: Long = 987654321\nval y: Float = x.toFloat  // 9.8765434E8 (หมายเหตุว่าค่าความละเอียดจะสูญหายไปในกรณีนี้)\n\nval face: Char = '☺'\nval number: Int = face  // 9786\n```\n\n----------------------------------------\n\nTITLE: Applying Mutation via View - Scala REPL\nDESCRIPTION: Calls the `negate` function on the mutable view (`subarr`). Because the view references the original array's elements, the mutation applied through the view modifies the corresponding elements in the original array.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/views.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nnegate(subarr)\n```\n\nLANGUAGE: scala\nCODE:\n```\narr\n```\n\nLANGUAGE: text\nCODE:\n```\nres4: Array[Int] = Array(0, 1, 2, -3, -4, -5, 6, 7, 8, 9)\n```\n\n----------------------------------------\n\nTITLE: Using a Structural Type for Dynamic Field Access in Scala 3\nDESCRIPTION: Example demonstrating how to create an instance of the Person structural type and access its fields using dot notation. The example shows how type casting and dynamic selection work together.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-structural.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval person = Record(\n  \"name\" -> \"Emma\",\n  \"age\" -> 42\n).asInstanceOf[Person]\n\nprintln(s\"${person.name} is ${person.age} years old.\")\n```\n\n----------------------------------------\n\nTITLE: Using Strict Take with Find Palindrome - Scala\nDESCRIPTION: Demonstrates finding a palindrome within the first million words of a sequence using the strict `.take` method. This approach creates an intermediate sequence containing up to a million elements, even if the palindrome is found early.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/views.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nfindPalindrome(words take 1000000)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Mutable ParHashSet in Scala\nDESCRIPTION: Demonstrates initializing a mutable `ParHashSet` from a sequence of integers and applying a parallel `map` operation to square each element. This example shows basic creation and transformation of parallel mutable hash sets.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/concrete-parallel-collections.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nscala> val phs = scala.collection.parallel.mutable.ParHashSet(1 until 2000: _*)\nphs: scala.collection.parallel.mutable.ParHashSet[Int] = ParHashSet(18, 327, 736, 1045, 773, 1082,...\n\nscala> phs map (x => x * x)\nres0: scala.collection.parallel.mutable.ParHashSet[Int] = ParHashSet(2181529, 2446096, 99225, 2585664,...\n```\n\n----------------------------------------\n\nTITLE: Example Package Documentation with Overview and Code Snippets in Scala\nDESCRIPTION: Provides a detailed example of package documentation within a `package.scala` file. It includes an overview section using wiki-style headers (`==Overview==`), links to classes using `[[...]]` syntax, and embedded REPL code examples using `{{{ ... }}}` blocks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/scaladoc.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\npackage my.package\n/** Provides classes for dealing with complex numbers.  Also provides\n *  implicits for converting to and from `Int`.\n *\n *  ==Overview==\n *  The main class to use is [[my.package.complex.Complex]], as so\n *  {{ \"{{{\" }}\n *  scala> val complex = Complex(4,3)\n *  complex: my.package.complex.Complex = 4 + 3i\n *  }}}\n *\n *  If you include [[my.package.complex.ComplexConversions]], you can\n *  convert numbers more directly\n *  {{ \"{{{\" }}\n *  scala> import my.package.complex.ComplexConversions._\n *  scala> val complex = 4 + 3.i\n *  complex: my.package.complex.Complex = 4 + 3i\n *  }}}\n */\npackage complex {}\n```\n\n----------------------------------------\n\nTITLE: Defining a Scala 3 Macro using `inline` and `Quotes`\nDESCRIPTION: Presents the basic structure for defining a Scala 3 macro. An `inline` method (`power`) serves as the entry point. It uses the splice operator (`${...}`) to call a macro implementation method (`powerCode`), passing quoted representations of the arguments (`'x`, `'n`). The implementation method uses the `Quotes` context to manipulate code representations (`Expr`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\ninline def power(x: Double, inline n: Int) =\n  ${ powerCode('x, 'n)  }\n\ndef powerCode(x: Expr[Double], n: Expr[Int])(using Quotes): Expr[Double] = ...\n```\n\n----------------------------------------\n\nTITLE: Enabling Cross-Type Equality Between PrintedBook and AudioBook\nDESCRIPTION: This snippet shows how to allow comparisons between different types (PrintedBook and AudioBook) by providing additional CanEqual instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/ca-multiversal-equality.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// разрешить `PrintedBook == AudioBook` и `AudioBook == PrintedBook`\ngiven CanEqual[PrintedBook, AudioBook] = CanEqual.derived\ngiven CanEqual[AudioBook, PrintedBook] = CanEqual.derived\n\nprintln(pBook == aBook)   // false\nprintln(aBook == pBook)   // false\n```\n\n----------------------------------------\n\nTITLE: Using @deprecated annotation in Scala\nDESCRIPTION: Demonstrates how to apply the @deprecated annotation to a method, causing the compiler to emit warnings upon usage. The example shows a method 'hello' marked as deprecated, with accompanying warning message during compilation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/annotations.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject DeprecationDemo extends App {\n  @deprecated(\"deprecation message\", \"release # which deprecates method\")\n  def hello = \"hola\"\n\n  hello  \n}\n```\n\n----------------------------------------\n\nTITLE: Defining filter and map in IterableOps Trait - Scala 3\nDESCRIPTION: Equivalent to the Scala 2 IterableOps, this trait in Scala 3 syntax offers non-strict filter and map implemented through views. fromSpecific and from are abstract and must be provided by the concrete subclass. It depends on the View.Filter and View.Map abstractions and serves as an extensible basis for collection operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\ntrait IterableOps[+A, +CC[_], +C]:\n\n  def filter(pred: A => Boolean): C =\n    fromSpecific(View.Filter(this, pred))\n\n  def map[B](f: A => B): CC[B] = \n    from(View.Map(this, f))\n\n  protected def fromSpecific(coll: IterableOnce[A]): C\n  protected def from[E](it: IterableOnce[E]): CC[E]\n```\n\n----------------------------------------\n\nTITLE: Scala Fibonacci Iterator with Multiple Assignment\nDESCRIPTION: Rewrites the Fibonacci iterator to leverage multiple assignment syntax, enhancing code legibility and safety by updating variables atomically.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/multiple-assignments.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nclass FibonacciIterator() extends Iterator[Int]:\n\n  private var a: Int = 0\n  private var b: Int = 1\n\n  def hasNext = true\n  def next() =\n    val r = a\n    (a, b) = (b, a + b)\n    r\n```\n\n----------------------------------------\n\nTITLE: Defining a Partial Function in Scala\nDESCRIPTION: Shows how to create a partial function in Scala that doubles odd numbers using case expressions. The function is defined only for odd integer inputs and returns their doubled values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-partial-functions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval doubledOdds: PartialFunction[Int, Int] = {\n  case i if i % 2 == 1 => i * 2\n}\n```\n\n----------------------------------------\n\nTITLE: Anonymous Type Provider Macro Expansion Example\nDESCRIPTION: Shows the typical structure of the code generated by the anonymous type provider macro. It defines a local trait containing generated types (like `Coffee`) and values (like `Coffees`), and then instantiates this trait. These local definitions are what contribute to the structural type inference.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/typeproviders.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval db = {\n  trait Db {\n    case class Coffee(...)\n    val Coffees: Table[Coffee] = ...\n  }\n  new Db {}\n}\n```\n\n----------------------------------------\n\nTITLE: Using Public Type Provider Annotated Object\nDESCRIPTION: Demonstrates accessing members of the object after the public type provider macro annotation has expanded. The generated members, such as `Db.Coffees`, are publicly available and can be accessed directly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/typeproviders.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nprintln(Db.Coffees.all)\nDb.Coffees.insert(\"Brazilian\", 99, 0)\n```\n\n----------------------------------------\n\nTITLE: Defining foldLeft1 without Multiple Parameter Lists in Scala\nDESCRIPTION: Defines a hypothetical `foldLeft1` method using a single parameter list for all arguments. This definition is used to demonstrate a type inference limitation that multiple parameter lists help resolve.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/multiple-parameter-lists.md#_snippet_2\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\ndef foldLeft1[A, B](as: List[A], b0: B, op: (B, A) => B) = ???\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterized Given Aliases with Context Bounds in Scala 3\nDESCRIPTION: Defines Scala 3 'given' instances as parameterized type aliases that require context bounds, representing typeclass implementations for lists of elements. Uses context bounds to assert the presence of Ord instances for element type A. These aliases delegate to a concrete implementation ListOrd[A]. The snippet showcases compact definitions of given aliases using context bounds syntax and context parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\n// Parameterized alias with context bound\ngiven [A: Ord]: Ord[List[A]] =\n  ListOrd[A]\n\n// Parameterized alias with context parameter\ngiven [A](using Ord[A]): Ord[List[A]] =\n  ListOrd[A]\n\n// Abstract or deferred given: no unnamed form possible\n\n// By-name given\ngiven [DummySoItsByName]: Context = curCtx\n```\n\n----------------------------------------\n\nTITLE: Passing Functions as Arguments in Scala (Higher-Order Functions)\nDESCRIPTION: Demonstrates the concept of functions as first-class objects in Scala. Defines a `oncePerSecond` higher-order function that accepts another function (`callback: () => Unit`) as an argument and executes it repeatedly. Shows how to pass a named function (`timeFlies`) as the callback.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tutorials/scala-for-java-programmers.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nobject Timer {\n  def oncePerSecond(callback: () => Unit) {\n    while (true) { callback(); Thread sleep 1000 }\n  }\n  def timeFlies() {\n    println(\"time flies like an arrow...\")\n  }\n  def main(args: Array[String]): Unit = {\n    oncePerSecond(timeFlies)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Excluding a Test with .ignore in Scala\nDESCRIPTION: Provides an example of excluding a specific test from execution by adding '.ignore' suffix to the test name within the suite. Compatible with both Scala 2 and Scala 3, allows focused testing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-run-only.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass MathSuite extends munit.FunSuite {\n  test(\"addition\".ignore) {\n    assert(1 + 1 == 2)\n  }\n  test(\"multiplication\") {\n    assert(3 * 7 == 21)\n  }\n  test(\"remainder\") {\n    assert(13 % 5 == 3)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Logical Operators Using Infix Notation in Scala\nDESCRIPTION: Defines a custom MyBool class encapsulating a Boolean value with three methods: 'and' and 'or', which take a MyBool parameter and return a MyBool, implementing logical conjunction and disjunction respectively, and 'negate', a parameterless method that returns the logical negation wrapped in a new MyBool. The methods enable infix usage due to Scala's single-parameter method infix syntax, allowing expressions like 'x and y'. Requires Scala's standard library and uses immutable Boolean logic encapsulation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/operators.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass MyBool(x: Boolean) {\n  def and(that: MyBool): MyBool = if (x) that else this\n  def or(that: MyBool): MyBool = if (x) this else that\n  def negate: MyBool = new MyBool(!x)\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Illegal Node Connections Across Graph Instances in Scala\nDESCRIPTION: An example object illustrating that nodes from different Graph instances have incompatible types, thus connecting nodes from separate graphs is illegal in Scala. This snippet contrasts Scala's strict instance-dependent node types with Java's permissive approach where inner classes are static members.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/inner-classes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nobject IllegalGraphTest extends App {\n  val g: Graph = new Graph\n  val n1: g.Node = g.newNode\n  val n2: g.Node = g.newNode\n  n1.connectTo(n2)      // legal\n  val h: Graph = new Graph\n  val n3: h.Node = h.newNode\n  n1.connectTo(n3)      // illegal!\n}\n```\n\n----------------------------------------\n\nTITLE: Exhaustivity and Type Test Warnings in Scala 3 Pattern Matching\nDESCRIPTION: Demonstrates the two warnings produced by Scala 3 when pattern matching on a type with potential exhaustivity issues and type erasure problems.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/replace-nonsensical-unchecked-annotation.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval xs = List(1: Any)\nxs match {\n  case is: ::[Int] => is.head\n}\n```\n\n----------------------------------------\n\nTITLE: 重写inherited方法的Cat类实现(Scala 3)\nDESCRIPTION: 展示如何在Scala 3中创建一个类并重写从trait继承的方法。这个例子创建了Cat类，它不仅实现了speak抽象方法，还重写了startRunning和stopRunning具体方法。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-modeling.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass Cat(name: String) extends Speaker, TailWagger, Runner:\n  def speak(): String = \"Meow\"\n  override def startRunning(): Unit = println(\"Yeah ... I don't run\")\n  override def stopRunning(): Unit = println(\"No need to stop\")\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Class 'Pet' with Constructor Parameters in Scala 3\nDESCRIPTION: This Scala 3 code snippet shows how to define an abstract class 'Pet' with parameters using the new class syntax, facilitating inheritance and instantiation similar to Scala 2 but with more concise syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Pet(name: String):\n  def greeting: String\n  def age: Int\n  override def toString = s\"My name is $name, I say $greeting, and I’m $age\"\n\nclass Dog(name: String, var age: Int) extends Pet(name):\n  val greeting = \"Woof\"\n\nval d = Dog(\"Fido\", 1)\n```\n\n----------------------------------------\n\nTITLE: Function Definitions: Single and Multiple Line Methods in Scala and Python\nDESCRIPTION: Shows syntax for defining simple and multi-line functions in Scala and Python. Includes examples of functions with return values, multiple statements, and invocation, highlighting differences in syntax such as indentation in Python and braces in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef add(a, b): return a + b\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef add(a: Int, b: Int): Int = a + b\n```\n\nLANGUAGE: python\nCODE:\n```\ndef walkThenRun():\n    print('walk')\n    print('run')\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef walkThenRun() =\n  println(\"walk\")\n  println(\"run\")\n```\n\n----------------------------------------\n\nTITLE: Defining OOP style classes with methods in Python and Scala\nDESCRIPTION: Shows defining mutable class-based objects with methods using Python classes and Scala classes with primary constructors. Dependencies are language standard environments. The constructor parameter initializes the name property. The class contains a speak method that outputs a greeting using the object's state.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nclass Person (var name: String):\n  def speak() = println(s\"Hello, my name is $name\")\n```\n\n----------------------------------------\n\nTITLE: Adding Toolkit Dependency with Mill - Scala\nDESCRIPTION: This Mill build.sc snippet configures a project to use the Scala toolkit by defining a Scala module and adding the toolkit as an Ivy dependency (version 0.7.0). Mill must be installed, and the file build.sc should be placed at the project root for correct application. Ensure the Scala version matches your project requirements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-sttp.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nobject example extends ScalaModule {\n  def scalaVersion = \"3.4.2\"\n  def ivyDeps =\n    Agg(\n      ivy\"org.scala-lang::toolkit:0.7.0\"\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Pattern Matching with @unchecked Usage Example in Scala\nDESCRIPTION: Demonstrates the current usage of @unchecked annotation to silence a warning when a potentially refutable pattern is used in a value definition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/replace-nonsensical-unchecked-annotation.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef xs: List[Any] = ???\nval y :: ys = xs: @unchecked\n```\n\n----------------------------------------\n\nTITLE: Escaping Percent Signs in 'f' Interpolated Strings in Scala\nDESCRIPTION: Explains how to include a literal percent sign (`%`) within an `f` interpolated string by doubling it (`%%`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/string-interpolation.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nprintln(f\"3/19 is less than 20%%\" )  // \"3/19 is less than 20%\"\n```\n\n----------------------------------------\n\nTITLE: Appending Elements and Displaying Vector in Scala REPL - Scala\nDESCRIPTION: Shows practical REPL interactions while appending elements to Vectors using :+ and ++. Demonstrates the resulting Vectors after each operation for interactive exploration. Input: Vector operations, Output: updated Vectors displayed in REPL. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/vector-class.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val a = Vector(1,2,3)\na: Vector[Int] = Vector(1, 2, 3)\n\nscala> val b = a :+ 4\nb: Vector[Int] = Vector(1, 2, 3, 4)\n\nscala> val b = a ++ Vector(4, 5)\nb: Vector[Int] = Vector(1, 2, 3, 4, 5)\n```\n\n----------------------------------------\n\nTITLE: Accessing Top-Level Definitions Across Nested Packages in Scala 3\nDESCRIPTION: This example shows how definitions placed directly within a parent package (`foo`) in Scala 3 are automatically accessible from nested packages (`foo.bar`). It defines a simple function `double` in the parent package and calls it from a `@main` method located in the nested package, demonstrating the scope and accessibility rules for top-level definitions within a package hierarchy.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-toplevel-definitions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\npackage foo {\n  def double(i: Int) = i * 2\n}\n\npackage foo {\n  package bar {\n    @main def fooBarMain =\n      println(s\"${double(1)}\")   // this works\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Projection of Failed Future Values using failed Projection in Scala\nDESCRIPTION: This snippet shows accessing the failure value of a Future via the failed projection, which yields a Future holding the Throwable if the original Future failed. Using a for-comprehension or foreach on the failed Future allows handling exceptions asynchronously. If the Future succeeded, the failed projection itself fails with NoSuchElementException, as demonstrated by the second example, which prints nothing for a successful Future.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/futures.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nval f = Future {\n  2 / 0\n}\nfor (exc <- f.failed) println(exc)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nf.failed.foreach( exc => println(exc))\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval g = Future {\n  4 / 2\n}\nfor (exc <- g.failed) println(exc)\n```\n\n----------------------------------------\n\nTITLE: Using BigInt and BigDecimal in Scala\nDESCRIPTION: This snippet shows instantiation of BigInt and BigDecimal types for handling large or precise numeric values beyond native types. BigInt accepts a Long value, while BigDecimal provides arbitrary-precision decimals. Requires scala.math.BigInt and scala.math.BigDecimal, both from the standard library.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/first-look-at-types.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval a = BigInt(1_234_567_890_987_654_321L)\nval b = BigDecimal(123_456.789)\n```\n\n----------------------------------------\n\nTITLE: Defining Two-Parameter Integer Functions in Scala\nDESCRIPTION: Presents two Scala functions, `sum` and `multiply`, each taking two `Int` parameters and returning their sum or product respectively. These functions match the type signature `(Int, Int) => Int` and demonstrate how to define simple reusable functions that can be passed as arguments to higher-order functions like `executeAndPrint`. Works in Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-hofs.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\ndef sum(x: Int, y: Int) = x + y\ndef multiply(x: Int, y: Int) = x * y\n\nexecuteAndPrint(sum, 3, 11)       // prints 14\nexecuteAndPrint(multiply, 3, 9)   // prints 27\n```\n\n----------------------------------------\n\nTITLE: Using Previous Results in Scala REPL\nDESCRIPTION: Demonstration of how to use automatically generated result variables (res0, res1, etc.) in subsequent expressions within the Scala REPL.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-repl.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> val x = res0 * 10\nval x: Int = 20\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Pattern Matching with Duration in Scala 2\nDESCRIPTION: Demonstrates various ways to instantiate Duration objects and use pattern matching with Duration in Scala 2, including creation from Long and TimeUnit, String parsing, and implicit conversion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_39\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.concurrent.duration._\nimport java.util.concurrent.TimeUnit._\n\n// instantiation\nval d1 = Duration(100, MILLISECONDS) // from Long and TimeUnit\nval d2 = Duration(100, \"millis\") // from Long and String\nval d3 = 100 millis // implicitly from Long, Int or Double\nval d4 = Duration(\"1.2 µs\") // from String\n\n// pattern matching\nval Duration(length, unit) = 5 millis\n```\n\n----------------------------------------\n\nTITLE: Defining an Open Class for Extension in Scala 3\nDESCRIPTION: Shows the use of the `open` keyword in Scala 3, which is required to allow a class defined in one file to be extended by a class in another file. This enforces designing for inheritance explicitly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-oop.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nopen class Person(name: String)\n```\n\n----------------------------------------\n\nTITLE: Using Duration utilities in Scala concurrent programming\nDESCRIPTION: Demonstrates various ways to instantiate and use Duration objects for time management in concurrent Scala applications.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_36\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.concurrent.duration._\nimport java.util.concurrent.TimeUnit._\n\n// instantiation\nval d1 = Duration(100, MILLISECONDS) // from Long and TimeUnit\nval d2 = Duration(100, \"millis\") // from Long and String\nval d3 = 100 millis // implicitly from Long, Int or Double\nval d4 = Duration(\"1.2 µs\") // from String\n\n// pattern matching\nval Duration(length, unit) = 5 millis\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.concurrent.duration.*\nimport java.util.concurrent.TimeUnit.*\n\n// instantiation\nval d1 = Duration(100, MILLISECONDS) // from Long and TimeUnit\nval d2 = Duration(100, \"millis\") // from Long and String\nval d3 = 100.millis // implicitly from Long, Int or Double\nval d4 = Duration(\"1.2 µs\") // from String\n\n// pattern matching\nval Duration(length, unit) = 5.millis\n```\n\n----------------------------------------\n\nTITLE: Using Range Operations on TreeSet in Scala\nDESCRIPTION: Shows how to use range querying methods on a TreeSet[String] in Scala, including 'range' to get all elements starting at one bound and less than another, and 'rangeFrom' to get all elements greater than or equal to a start element. The result is always a sorted subset of the original TreeSet.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/sets.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nres3.range(\"one\", \"two\")\nres3 rangeFrom \"three\"\n```\n\n----------------------------------------\n\nTITLE: Tail Method in Scala Collections\nDESCRIPTION: Examples of using the tail method to access all elements after the head in a collection, including applications with strings and pattern matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-methods.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\noneToTen.head   // 1\noneToTen.tail   // List(2, 3, 4, 5, 6, 7, 8, 9, 10)\n\nnames.head      // adam\nnames.tail      // List(brandy, chris, david)\n```\n\nLANGUAGE: scala\nCODE:\n```\n\"foo\".tail   // \"oo\"\n\"bar\".tail   // \"ar\"\n```\n\nLANGUAGE: scala\nCODE:\n```\nval x :: xs = names\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> val x :: xs = names\nval x: String = adam\nval xs: List[String] = List(brandy, chris, david)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef sum(list: List[Int]): Int = list match\n  case Nil => 0\n  case x :: xs => x + sum(xs)\n```\n\n----------------------------------------\n\nTITLE: Using Mutable Stacks in Scala 3\nDESCRIPTION: Shows how to create a mutable `Stack[Int]` in Scala 3 using the companion object's `apply` method, push elements onto the stack using `push`, inspect the top element using `top`, and remove/return the top element using `pop`. Implements LIFO (Last-In-First-Out) behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-mutable-collection-classes.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nscala> val stack = scala.collection.mutable.Stack[Int]()\nstack: scala.collection.mutable.Stack[Int] = Stack()\nscala> stack.push(1)\nres0: stack.type = Stack(1)\nscala> stack\nres1: scala.collection.mutable.Stack[Int] = Stack(1)\nscala> stack.push(2)\nres0: stack.type = Stack(1, 2)\nscala> stack\nres3: scala.collection.mutable.Stack[Int] = Stack(2, 1)\nscala> stack.top\nres8: Int = 2\nscala> stack\nres9: scala.collection.mutable.Stack[Int] = Stack(2, 1)\nscala> stack.pop\nres10: Int = 2\nscala> stack\nres11: scala.collection.mutable.Stack[Int] = Stack(1)\n```\n\n----------------------------------------\n\nTITLE: Explicit `extends` in Basic Enumeration (Scala)\nDESCRIPTION: Shows the equivalent, more explicit definition of a basic Scala 3 enumeration where each case explicitly extends the enum type. This clarifies the underlying structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-adts-gadts.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nenum Color:\n  case Red   extends Color\n  case Green extends Color\n  case Blue  extends Color\n```\n\n----------------------------------------\n\nTITLE: Defining Core Iterator Method (Scala)\nDESCRIPTION: Documents the abstract `iterator` method required by the Scala `Iterable` trait. This method must be implemented by any class extending `Iterable` and is used to provide sequential access to the collection's elements. All other concrete methods in `Iterable` are built upon this foundation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/trait-iterable.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef iterator: Iterator[A]\n```\n\n----------------------------------------\n\nTITLE: Examples of Scala REPL Type Inference\nDESCRIPTION: Exhibits how Scala infers types in the REPL environment for variables like integers, strings, and lists, showing the inferred types in comments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-vars-data-types.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nscala> val x = 1\nval x: Int = 1\n\nscala> val s = \"a string\"\nval s: String = a string\n\nscala> val nums = List(1, 2, 3)\nval nums: List[Int] = List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Declaring Immutable Values with val in Scala\nDESCRIPTION: Illustrates the use of val to assign the result of an expression to a named constant. Demonstrates value immutability and type inference; the value x is assigned but cannot be changed once set.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval x = 1 + 1\nprintln(x) // 2\n```\n\n----------------------------------------\n\nTITLE: Defining a Scala compiler plugin in Scala with options processing\nDESCRIPTION: This code defines a Scala compiler plugin named 'silly' that processes command-line options and prints a message indicating the current silliness level. It illustrates how to override `processOptions` to handle plugin-specific options and how to provide help messages via the `optionsHelp` value, essential for plugin parameterization and user guidance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/plugins/index.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\npackage localhost\n\nimport scala.tools.nsc\nimport nsc.Global\nimport nsc.Phase\nimport nsc.plugins.Plugin\nimport nsc.plugins.PluginComponent\n\nclass Silly(val global: Global) extends Plugin {\n  import global._\n\n  val name = \"silly\"\n  val description = \"goose\"\n  val components = List[PluginComponent](Component)\n\n  var level = 1000000\n\n  override def processOptions(options: List[String], error: String => Unit): Unit = {\n    for (option <- options) {\n      if (option.startsWith(\"level:\")) {\n        level = option.substring(\"level:\".length).toInt\n      } else {\n        error(\"Option not understood: \" + option)\n      }\n    }\n  }\n\n  override val optionsHelp: Option[String] = Some(\n    \"  -P:silly:level:n             set the silliness to level n\")\n\n  private object Component extends PluginComponent {\n    val global: Silly.this.global.type = Silly.this.global\n    val runsAfter = List[String](\"refchecks\")\n    val phaseName = Silly.this.name\n    def newPhase(_prev: Phase) = new SillyPhase(_prev)\n\n    class SillyPhase(prev: Phase) extends StdPhase(prev) {\n      override def name = Silly.this.name\n      def apply(unit: CompilationUnit): Unit = {\n        println(\"Silliness level: \" + level)\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Concrete DirectedGraph Specialization in Scala with Concrete Node and Edge\nDESCRIPTION: Implements a concrete subclass ConcreteDirectedGraph of DirectedGraph by providing concrete type aliases for Edge and Node as EdgeImpl and NodeImpl respectively. It also defines the factory methods newNode and newEdge to instantiate NodeImpl and EdgeImpl objects. This specialization enables instantiation of NodeImpl with a valid Node subtype, fulfilling the self-type requirement and allowing graph construction and edge creation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/self-types.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass ConcreteDirectedGraph extends DirectedGraph {\n  type Edge = EdgeImpl\n  type Node = NodeImpl\n  protected def newNode: Node = new NodeImpl\n  protected def newEdge(f: Node, t: Node): Edge =\n    new EdgeImpl(f, t)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Method with Unit Return Type in Scala\nDESCRIPTION: Defines a Scala method named printIt that accepts a parameter of any type (Any) and returns Unit, which signifies no meaningful return value. The method prints the argument to the console. Requires Scala standard library; Unit represents functions with no meaningful return output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/first-look-at-types.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef printIt(a: Any): Unit = println(a)\n```\n\n----------------------------------------\n\nTITLE: Defining Typing Rules for Selectable Member Access in Scala (Pseudocode)\nDESCRIPTION: This snippet formally specifies how member access via structural types should be handled in the Scala type system. The rule defines how the type of a member is resolved using the Selectable trait, with strict typing requirements that involve member checks and ascribing types. There are no explicit runtime dependencies; these are rules for compiler implementation and require knowledge of Scala's type-checking internals. Inputs are an expression v and member a, with outputs describing the resultant type U. This pseudocode is not executable code, but technical notation for specification.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/minutes/2019-03-13-sip-minutes.md#_snippet_0\n\nLANGUAGE: scala (typing rules pseudocode)\nCODE:\n```\nG |- v.a : U ~> (v': Q).a   Q =:= C { ... a: U ... }  - Member(C, a, _)    G |- v' : Selectable ~> v''\n```\n\n----------------------------------------\n\nTITLE: Factoring Anonymous Polymorphic Function into a Value in Scala\nDESCRIPTION: Here, the previously inline polymorphic function is moved into a value (`unfolder`), improving readability and reusability. The function structure is unchanged, leveraging Scala's support for first-class polymorphic functions. Dependencies remain the same as the previous snippet. Input and output types are unchanged, but the main benefit is code reorganization and maintenance. Limitation: still requires manual assignment.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/polymorphic-eta-expansion.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n...  \n  def readElems(s: String): Option[(T, String)] = {\n    type Acc = (String, Seq[String], Boolean)\n    val unfolder = [t] => (acc: Acc, rt: Read[t]) => {\n      val (s, labels, first) = acc\n      (for {\n        (_, tl0) <- if(first) Some((\"\", s)) else head(s, \"(,)(.*)\".r)\n        (_, tl1) <- head(tl0, s\"(${labels.head}):(.*)\".r)\n        (t, tl2) <- rt.read(tl1)\n        } yield (t, tl2)) match {\n          case Some(t, tl2) => ((tl2, labels.tail, false), Some(t))\n          case None => ((s, labels, first), None)\n        }\n    }\n    inst.unfold[Acc]((s, labelling.elemLabels, true))(unfolder) match {\n        case (s, None) => None\n        case (acc, Some(t)) => Some((t, acc._1))\n      }\n  }\n```\n\n----------------------------------------\n\nTITLE: Complete Scala Pizza Class with Main Method and Usage\nDESCRIPTION: This comprehensive snippet combines enumerations, the 'Pizza' class, and a main object 'PizzaTest' that initializes a Pizza instance, adds toppings, and prints its state. It demonstrates compiling and running Scala code, and shows how to extend functionality with string representation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/enumerations-pizza-class.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.mutable.ArrayBuffer\n\nsealed trait Topping\ncase object Cheese extends Topping\ncase object Pepperoni extends Topping\ncase object Sausage extends Topping\ncase object Mushrooms extends Topping\ncase object Onions extends Topping\n\nsealed trait CrustSize\ncase object SmallCrustSize extends CrustSize\ncase object MediumCrustSize extends CrustSize\ncase object LargeCrustSize extends CrustSize\n\nsealed trait CrustType\ncase object RegularCrustType extends CrustType\ncase object ThinCrustType extends CrustType\ncase object ThickCrustType extends CrustType\n\nclass Pizza (\n    var crustSize: CrustSize = MediumCrustSize, \n    var crustType: CrustType = RegularCrustType\n) {\n\n    // ArrayBuffer is a mutable sequence (list)\n    val toppings = ArrayBuffer[Topping]()\n\n    def addTopping(t: Topping): Unit = toppings += t\n    def removeTopping(t: Topping): Unit = toppings -= t\n    def removeAllToppings(): Unit = toppings.clear()\n\n    override def toString(): String = {\n        s\"\"\"\n        |Crust Size: $crustSize\n        |Crust Type: $crustType\n        |Toppings:   $toppings\n        \"\"\".stripMargin\n    }\n}\n\n// a little \"driver\" app\nobject PizzaTest extends App {\n   val p = new Pizza\n   p.addTopping(Cheese)\n   p.addTopping(Pepperoni)\n   println(p)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Enum with Methods and Fields - Java\nDESCRIPTION: This snippet defines a Java enum named Planet, where each enum value has parameters mass and radius, and the enum includes fields, a static constant (G), and methods for surfaceGravity and surfaceWeight calculations. Each value uses a constructor, and methods allow calculation of object-specific properties. Inputs are planet parameters, output includes physics calculations. Dependencies include core Java, with custom helper classes for mass, radius, and Person.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_60\n\nLANGUAGE: Java\nCODE:\n```\nenum Planet {\n  MERCURY (3.303e+23, 2.4397e6),\n  VENUS   (4.869e+24, 6.0518e6),\n  EARTH   (5.976e+24, 6.37814e6);\n  // more planets ...\n\n  private final double mass;\n  private final double radius;\n\n  Planet(double mass, double radius) {\n    this.mass = mass;\n    this.radius = radius;\n  }\n\n  public static final double G = \n    6.67300E-11;\n\n  private double mass() {\n    return mass;\n  }\n\n  private double radius() {\n    return radius;\n  }\n\n  double surfaceGravity() {\n    return G * mass / \n           (radius * radius);\n  }\n\n  double surfaceWeight(\n    double otherMass\n  ) {\n    return otherMass *\n           surfaceGravity();\n  }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Value Classes and Opaque Types for Type-Safe Wrappers in Scala\nDESCRIPTION: Demonstrates two different approaches to add type safety when replacing String with domain-specific types: a value class Alphabetic and an opaque type Digits. The value class wraps a String with constructor and accessor visibility restricted to package scope, while the opaque type is a simple alias with controlled construction via fromString method. This example highlights differences in boxing behavior, runtime overhead, and usability between value classes and opaque types when used as type parameters and in collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/opaque-types.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\npackage object pkg {\n\n  import Character.{isAlphabetic, isDigit}\n\n  class Alphabetic private[pkg] (val value: String) extends AnyVal\n\n  object Alphabetic {\n    def fromString(s: String): Option[Alphabetic] =\n      if (s.forall(isAlphabetic(_))) Some(new Alphabetic(s))\n      else None\n  }\n\n  opaque type Digits = String\n\n  object Digits {\n    def fromString(s: String): Option[Digits] =\n      if (s.forall(isDigit(_))) Some(s)\n      else None\n\n    def asString(d: Digits): String = d\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Toplevel Definitions in Scala Package\nDESCRIPTION: This snippet demonstrates how to declare top-level values and methods directly within a Scala package using the proposed syntax. The example shows a tuple assignment to 'a' and a method 'b' accessing an element from 'a', which are both defined outside any class or object, enabled by new packaging rules in Scala 3. Such definitions are wrapped in synthetic objects by the compiler for evaluation semantics, and top-level statements function similarly to worksheet or REPL code. Limitations include possible binary compatibility concerns and restrictions in source file organization.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/minutes/2019-03-13-sip-minutes.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\npackage p\n\nval a = (1, 2)\n\ndef b = a._2\n```\n\n----------------------------------------\n\nTITLE: Implementing a Recursive While Loop Using Call-by-Name Parameters in Scala\nDESCRIPTION: This snippet implements a custom 'whileLoop' function that uses two call-by-name parameters: 'condition' (a Boolean expression) and 'body' (a Unit-returning code block). The 'condition' is evaluated lazily before each iteration, and 'body' is executed only when 'condition' is true, enabling recursion until the condition becomes false. The example includes usage of a mutable variable 'i' that decrements in the loop body and prints the current value. This approach mimics a traditional while loop with delayed evaluation, avoiding unnecessary evaluations for performance efficiency.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/by-name-parameters.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef whileLoop(condition: => Boolean)(body: => Unit): Unit =\n  if (condition) {\n    body\n    whileLoop(condition)(body)\n  }\n\nvar i = 2\n\nwhileLoop (i > 0) {\n  println(i)\n  i -= 1\n}  // prints 2 1\n```\n\n----------------------------------------\n\nTITLE: Defining Service Traits for Mixin Composition in Scala 3\nDESCRIPTION: This Scala 3 example shows two service traits: GreetingService has an abstract translate method and a concrete sayHello method, while TranslationService implements translate as a placeholder return. These are meant for use in mixin composition scenarios, fostering reusable component design. No extra dependencies are needed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ntrait GreetingService:\n  def translate(text: String): String\n  def sayHello = translate(\"Hello\")\n\ntrait TranslationService:\n  def translate(text: String): String = \"...\"\n```\n\n----------------------------------------\n\nTITLE: Specifying Numeric Types Using Suffixes and Underscores in Scala\nDESCRIPTION: Shows how to use suffixes (L for Long, D for Double, F for Float) to explicitly declare numeric literal types differing from default inference, as well as visual formatting of large numbers using underscores for readability. Demonstrates hexadecimal integer literals and corresponding types with suffixes. Useful for precise type control in Scala programs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/first-look-at-types.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval x = 1_000L   // val x: Long = 1000\nval y = 2.2D     // val y: Double = 2.2\nval z = -3.3F    // val z: Float = -3.3\n\nval a = 0xACE    // val a: Int = 2766\nval b = 0xfd_3aL // val b: Long = 64826\n\nval q = .25      // val q: Double = 0.25\nval r = 2.5e-1   // val r: Double = 0.25\nval s = .0025e2F // val s: Float = 0.25\n```\n\n----------------------------------------\n\nTITLE: Extending Traits with Upper Type Bounds - Scala 2\nDESCRIPTION: Declares an abstract class 'SeqBuffer' extending 'Buffer', introducing another abstract type 'U'. Sets 'T' to be a subtype of 'Seq[U]', constraining buffers to sequence types. Implements a 'length' method dependent on 'element'. Requires 'Seq' in scope; inputs/outputs not yet specific.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/abstract-type-members.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class SeqBuffer extends Buffer {\n  type U\n  type T <: Seq[U]\n  def length = element.length\n}\n```\n\n----------------------------------------\n\nTITLE: Legal Application of Multiple Apply Methods for Fold and GroupMapReduce in Scala\nDESCRIPTION: This code sample legally rewrites cases where multiple colon-initiated argument blocks would be illegal in SIP-44. By calling '.apply:' with each subsequent lambda block, the code accommodates the structural constraints introduced in fewerBraces. This approach ensures correct parsing and execution of composed operations on collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\nxo.fold:\n  defaultValue\n.apply:\n  x => f(x)\n\nxs.groupMapReduce: item =>\n  key(item)\n.apply: item =>\n  value(item)\n.apply: (value1, value2) =>\n  reduce(value1, value2)\n```\n\n----------------------------------------\n\nTITLE: Documenting Methods (One-Line Scaladoc) in Scala\nDESCRIPTION: Demonstrates a concise, single-line Scaladoc format suitable for members requiring only a brief description. The entire comment fits between /** and */ on one line.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/scaladoc.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n/** Does something very simple */\ndef simple: Unit = ()\n```\n\n----------------------------------------\n\nTITLE: Combining Precomputed Values and Print Calls into a Block in Macro Implementation (Scala)\nDESCRIPTION: Combines the precomputed value definitions and references to the macro-expanded print calls into a Scala AST Block. Uses `reify` to generate tree nodes invoking `print` on the corresponding expressions and wraps all statements in a block returning a unit literal. This is the final step of macro code generation where the generated code will execute printing according to the format specification.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/overview.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval stats = evals ++ refs.map(ref => reify(print(c.Expr[Any](ref).splice)).tree)\nc.Expr[Unit](Block(stats.toList, Literal(Constant(()))))\n```\n\n----------------------------------------\n\nTITLE: Representing and Unpacking Tuple Types with Quasiquotes - Scala\nDESCRIPTION: Shows tuple type quasiquotes as syntactic sugar for TupleN, and deconstructs both non-empty and empty (Unit) tuple types. Requires importing Scala quasiquotes support. Inputs: tuple type structures, such as '(A, B)' or '_root_.scala.Unit'. Outputs: lists of element types ('tpts'), possibly empty for Unit.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/type-details.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nval tup2 = tq\"(A, B)\"\nval tq\"(..$tpts)\" = tup2\nval tq\"(..$tpts)\" = tq\"_root_.scala.Unit\"\n```\n\n----------------------------------------\n\nTITLE: Streaming File Lines Lazily with OS-Lib in Scala\nDESCRIPTION: Streams lines from the file lazily using os.read.lines.stream, returning a geny.Generator[String] that yields lines on demand instead of loading the entire file into memory. This is efficient for processing large files or when only part of the file is needed. Requires os.Path as input, outputs a lazy line generator. Demonstrated by extracting and printing the first line. OS-Lib manages automatic file closing when the stream is exhausted.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/os-read-file.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval lineStream: geny.Generator[String] = os.read.lines.stream(path)\nval firstLine: String = lineStream.head\nprintln(firstLine)\n// prints: A\n```\n\n----------------------------------------\n\nTITLE: Importing ArrayBuffer in Scala\nDESCRIPTION: Shows the necessary import statement to use the mutable `ArrayBuffer` collection in Scala code. `ArrayBuffer` resides in the `scala.collection.mutable` package.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.mutable.ArrayBuffer\n```\n\n----------------------------------------\n\nTITLE: Defining a Java annotation with 'value' element and default\nDESCRIPTION: Defines a Java annotation interface that includes an element named `value` and another element with a default value. The `value` element allows for a more concise application syntax in Java.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/annotations.md#_snippet_6\n\nLANGUAGE: Java\nCODE:\n```\n@interface SourceURL {\n    public String value();\n    public String mail() default \"\";\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Implicit Monoids and Summation Method in Scala\nDESCRIPTION: This snippet defines implicit Monoids for String and Int types via implicit objects that provide concrete implementations of the 'add' and 'unit' methods. It also defines a generic sum method that takes a List of type A and an implicit Monoid[A], recursively computing the aggregated sum of the list using the monoid's add function or returning the monoid's unit if empty. The example shows usage of implicit parameters to automatically supply appropriate Monoids based on the list element type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/implicit-parameters.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject ImplicitTest extends App {\n  implicit object StringMonoid extends Monoid[String] {\n    def add(x: String, y: String): String = x concat y\n    def unit: String = \"\"\n  }\n\n  implicit object IntMonoid extends Monoid[Int] {\n    def add(x: Int, y: Int): Int = x + y\n    def unit: Int = 0\n  }\n\n  def sum[A](xs: List[A])(implicit m: Monoid[A]): A =\n    if (xs.isEmpty) m.unit\n    else m.add(xs.head, sum(xs.tail))\n\n  println(sum(List(1, 2, 3)))          // uses IntMonoid implicitly\n  println(sum(List(\"a\", \"b\", \"c\")))    // uses StringMonoid implicitly\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Value Class with Multiple Constructor Parameters (Disallowed)\nDESCRIPTION: This snippet attempts to define a Scala value class `Complex` with two `val` parameters (`real` and `imag`), which is not allowed. Value classes must have exactly one public `val` parameter. The accompanying compiler error message confirms this restriction.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nclass Complex(val real: Double, val imag: Double) extends AnyVal\n```\n\nLANGUAGE: text\nCODE:\n```\nComplex.scala:1: error: value class needs to have exactly one public val parameter\nclass Complex(val real: Double, val imag: Double) extends AnyVal\n      ^\n```\n\n----------------------------------------\n\nTITLE: Creating List of Duplicates in Scala 2\nDESCRIPTION: This Scala 2 code defines a polymorphic method `listOfDuplicates` that takes a type parameter `A`, an element `x` of type `A`, and an integer `length`. It recursively constructs a `List[A]` containing `x` repeated `length` times. The examples show explicit type parameterization (`[Int]`) and compiler type inference.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/polymorphic-methods.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef listOfDuplicates[A](x: A, length: Int): List[A] = {\n  if (length < 1)\n    Nil\n  else\n    x :: listOfDuplicates(x, length - 1)\n}\nprintln(listOfDuplicates[Int](3, 4))  // List(3, 3, 3, 3)\nprintln(listOfDuplicates(\"La\", 8))  // List(La, La, La, La, La, La, La, La)\n```\n\n----------------------------------------\n\nTITLE: Generated Secondary Constructors by @unroll for Class Compatibility in Scala\nDESCRIPTION: Shows the conceptual result of applying `@unroll` to a class constructor. The compiler generates synthetic secondary constructors (`this(...)`) that forward to the primary constructor using default values, maintaining binary compatibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/unroll-default-arguments.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nclass Unrolled(s: String, n: Int = 1, @unroll b: Boolean = true, @unroll l: Long = 0){\n   def foo = s + n + b + l\n\n   def this(s: String, n: Int, b: Boolean) = this(s, n, b, 0)\n   def this(s: String, n: Int) = this(s, n, true, 0)\n}\n```\n\n----------------------------------------\n\nTITLE: Confirming Default Numeric Types in REPL Scala\nDESCRIPTION: Shows the output from the Scala REPL when declaring variables without explicit types. It verifies that integer literals like `123` are inferred as `Int`, and floating-point literals like `1.0` are inferred as `Double`, demonstrating Scala's type inference behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/built-in-types.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> val i = 123\ni: Int = 123\n\nscala> val x = 1.0\nx: Double = 1.0\n```\n\n----------------------------------------\n\nTITLE: 实现TraversableLike中的map方法(Scala)\nDESCRIPTION: TraversableLike的map方法展示了如何使用CanBuildFrom机制实现类型灵活的转换操作。通过隐式参数bf，map方法可以根据函数返回类型动态确定结果集合类型，从而在保持类型安全的同时提供最佳的类型推断。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/architecture-of-scala-collections.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef map[B, That](p: Elem => B)\n    (implicit bf: CanBuildFrom[B, That, This]): That = {\n  val b = bf(this)\n  for (x <- this) b += f(x)\n  b.result\n}\n```\n\n----------------------------------------\n\nTITLE: Calling Named Function via Anonymous Function Syntax in Scala\nDESCRIPTION: Shows the equivalence of passing a named function directly and via an anonymous function wrapper by mapping over a list of strings, passing a lambda that calls toUpper. This demonstrates Scala’s flexibility in function passing conventions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/passing-functions-around.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nList(\"foo\", \"bar\").map(s => toUpper(s))\n```\n\n----------------------------------------\n\nTITLE: Illegal Colon Placement after Arrow Operator in Scala\nDESCRIPTION: This snippet demonstrates another illegal case: a colon follows a right-arrow operator ('-->'), resulting in invalid syntax. The code attempts to create a block via indentation, but the fewerBraces rules do not allow colons in this context. This kind of pattern must be avoided or replaced with valid grouping using parentheses.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nsource --> : x =>  // illegal\n val y = x * x\n println(y)\n```\n\n----------------------------------------\n\nTITLE: Applying Public Type Provider Macro Annotation\nDESCRIPTION: Shows how the public type provider macro annotation is applied to a target object. The macro annotation will process this object declaration and inject publicly visible code (e.g., database schema classes and objects) into its scope.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/typeproviders.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\n@H2Db(\"jdbc:h2:coffees.h2.db\") object Db\n```\n\n----------------------------------------\n\nTITLE: Defining a Numeric Abstraction with Dependent Types\nDESCRIPTION: This snippet introduces a 'Nums' trait with an abstract type 'Num' and basic numeric operations. It enables implementation of numerical modules where the specific numeric type can vary, facilitating flexible and type-safe numeric computations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-dependent-function.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Nums:\n  // тип Num оставлен абстрактным\n  type Num\n\n  // некоторые операции над числами\n  def lit(d: Double): Num\n  def add(l: Num, r: Num): Num\n  def mul(l: Num, r: Num): Num\n```\n\n----------------------------------------\n\nTITLE: Adding Toolkit Dependency with sbt - Scala\nDESCRIPTION: This snippet shows how to configure sbt to depend on the Scala toolkit by modifying your build.sbt file. The example defines a lazy val for a project, specifies the Scala version, and adds the toolkit dependency (version 0.7.0) using libraryDependencies. Ensure sbt is installed and that you are editing build.sbt.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-sttp.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nlazy val example = project.in(file(\".\"))\n  .settings(\n    scalaVersion := \"3.4.2\",\n    libraryDependencies += \"org.scala-lang\" %% \"toolkit\" % \"0.7.0\"\n  )\n```\n\n----------------------------------------\n\nTITLE: Defining Recursive Fix-Point Types with Opaque Types in Scala\nDESCRIPTION: This code demonstrates the use of an opaque type Fix to encode recursive data structures by hiding their internals, preventing infinite type expansion and supporting recursion schemes. It provides constructors (fix/unfix), defines a generic Tree type, enables catamorphic recursion over trees, and illustrates constructors for recursive trees. Required: Scala 3. Inputs are recursive data structures; outputs are recursive opaque types. Limitation: Type must be compatible with F[_] parameterization.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/opaque-types.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\npackage object fixed {\n  opaque type Fix[F[_]] = F[Fix[F]]\n\n  object Fix {\n    def fix[F[_]](unfixed: F[Fix[F]]): Fix[F] = unfixed\n    def unfix[F[_]](fixed: Fix[F]): F[Fix[F]] = fixed\n  }\n\n  sealed abstract class TreeU[R]\n\n  type Tree = Fix[TreeU]\n\n  object TreeU {\n    def cata[A](t: Tree)(f: TreeU[A] => A): A =\n      f(Fix.unfix(t) match {\n        case Branch(l, r) => Branch(cata(l)(f), cata(r)(f))\n        case Leaf(s) => Leaf(s)\n      })\n\n    case class Branch[R](left: R, right: R) extends TreeU[R]\n    case class Leaf[R](label: String) extends TreeU[R]\n  }\n\n  def leaf(s: String): Tree = Fix.fix(Leaf(s))\n  def branch(lhs: Tree, rhs: Tree): Tree = Fix.fix(Branch(lhs, rhs))\n\n  val tree: Tree = branch(branch(leaf(\"a\"), leaf(\"b\")), leaf(\"c\"))\n\n  println(tree)\n  // Branch(Branch(Leaf(a), Leaf(b)), Leaf(c))\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Scala Class with IOException Annotation\nDESCRIPTION: A Scala example demonstrating the use of the @throws annotation to properly indicate that a method may throw an IOException, allowing Java code to catch the exception.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/annotations.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\npackage examples\nimport java.io._\nclass Reader(fname: String) {\n  private val in = new BufferedReader(new FileReader(fname))\n  @throws(classOf[IOException])\n  def read() = in.read()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ParString Companion Object with CanBuildFrom Evidence in Scala\nDESCRIPTION: This Scala snippet provides the companion object implementation for the ParString class, including an implicit CanBuildFrom instance required by Scala's collections framework to enable operations like filter and partition. It defines combiners and builders to construct ParString instances efficiently during collection transformations. Dependencies include the parallel collections framework, particularly CanBuildFrom and Combiner types. This code supports building new ParString instances from sequences of characters and ensures integration with standard collection operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/overviews/parallel-collections/custom-parallel-collections.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nobject ParString {\n  implicit def canBuildFrom: CanCombineFrom[ParString, Char, ParString] =\n    new CanCombinerFrom[ParString, Char, ParString] {\n      def apply(from: ParString) = newCombiner\n      def apply() = newCombiner\n    }\n\n  def newBuilder: Combiner[Char, ParString] = newCombiner\n\n  def newCombiner: Combiner[Char, ParString] = new ParStringCombiner\n\n  def apply(elems: Char*): ParString = {\n    val cb = newCombiner\n    cb ++= elems\n    cb.result\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Définir une fonction qui retourne une fonction en Scala\nDESCRIPTION: Montre une méthode urlBuilder qui prend des paramètres ssl et domainName et retourne une fonction anonyme prenant deux Strings (endpoint et query) et retournant une URL formatée. Illustre la construction dynamique de fonctions basées sur des paramètres externes, un pattern courant en programmation fonctionnelle. La fonction retournée est ensuite utilisée pour générer des URL spécifiques. Entrée: paramètres ssl (Boolean), domainName (String), puis endpoint et query (String). Sortie: URL formattée (String).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tour/higher-order-functions.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef urlBuilder(ssl: Boolean, domainName: String): (String, String) => String = {\n  val schema = if (ssl) \"https://\" else \"http://\"\n  (endpoint: String, query: String) => s\"$schema$domainName/$endpoint?$query\"\n}\n\nval domainName = \"www.example.com\"\ndef getURL = urlBuilder(ssl=true, domainName)\nval endpoint = \"users\"\nval query = \"id=1\"\nval url = getURL(endpoint, query) // \"https://www.example.com/users?id=1\": String\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple Interfaces with Default Methods in Java\nDESCRIPTION: Java allows a class to implement multiple interfaces, even if those interfaces contain default methods. Conflicts are resolved by the implementing class providing its own implementation or explicitly calling a specific interface's default method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_26\n\nLANGUAGE: Java\nCODE:\n```\ninterface Adder {\n  default int add(int a, int b) {\n    return a + b;\n  }\n}\n\ninterface Multiplier {\n  default int multiply (\n    int a,\n    int b)\n  {\n    return a * b;\n  }\n}\n\npublic class JavaMath \nimplements Adder, Multiplier {}\n\nJavaMath jm = new JavaMath();\njm.add(1,1);\njm.multiply(2,2);\n```\n\n----------------------------------------\n\nTITLE: Defining case classes and abstract class for notifications - Scala\nDESCRIPTION: Declares an abstract superclass Notification and three case classes (Email, SMS, VoiceRecording) extending it. Each case class encapsulates specific fields representing data structures for different notification types. This snippet sets up the ADT (algebraic data type) foundation to be matched on in subsequent pattern matching examples.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/pattern-matching.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Notification\n\ncase class Email(sender: String, title: String, body: String) extends Notification\n\ncase class SMS(caller: String, message: String) extends Notification\n\ncase class VoiceRecording(contactName: String, link: String) extends Notification\n```\n\n----------------------------------------\n\nTITLE: Applying First Lazy Map to View - Scala REPL\nDESCRIPTION: Applying a map operation to a view doesn't immediately transform the elements. Instead, it returns a new view (`SeqViewM`) that encapsulates the original view and the pending map operation. The 'M' signifies a recorded map.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/views.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nvv map (_ + 1)\n```\n\nLANGUAGE: text\nCODE:\n```\nres13: scala.collection.SeqView[Int,Seq[_]] = SeqViewM(...)\n```\n\n----------------------------------------\n\nTITLE: Concrete DirectedGraph Specialization Defining Abstract Members in Scala\nDESCRIPTION: This snippet provides a concrete subclass `ConcreteDirectedGraph` of the abstract `DirectedGraph`. It defines the abstract type members `Edge` and `Node` as concrete aliases to `EdgeImpl` and `NodeImpl`, respectively. The factory methods `newNode` and `newEdge` are implemented to instantiate these concrete classes. This enables creating actual graph instances that satisfy the type constraints, making the node implementation instantiable and fully functional.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/self-types.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass ConcreteDirectedGraph extends DirectedGraph {\n  type Edge = EdgeImpl\n  type Node = NodeImpl\n  protected def newNode: Node = new NodeImpl\n  protected def newEdge(f: Node, t: Node): Edge =\n    new EdgeImpl(f, t)\n}\n```\n\n----------------------------------------\n\nTITLE: Recommended Function Type Formatting in Scala\nDESCRIPTION: The recommended way to format multi-line function types in Scala, with the arrow (=>) at the beginning of a new line to avoid confusion with indentation syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nval y = xs.map: ((x: Int)\n  => Int)\n```\n\n----------------------------------------\n\nTITLE: Defining a MUnit Test Suite in Scala 3\nDESCRIPTION: This snippet defines a similar test suite as the Scala 2 example but adapted for Scala 3 syntax, using significant indentation instead of braces. It extends munit.FunSuite to create a test class with a single test verifying that 2 plus 2 equals 4 using assertEquals. It requires the MUnit library and demonstrates the idiomatic Scala 3 style for defining test suites.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-suite.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\npackage example\n\nclass MyTests extends munit.FunSuite:\n  test(\"sum of two integers\") {\n    val obtained = 2 + 2\n    val expected = 4\n    assertEquals(obtained, expected)\n  }\n```\n\n----------------------------------------\n\nTITLE: Tagging and Publishing a Release with sbt - Bash\nDESCRIPTION: These Bash commands are used to tag a Git commit for a new release, publish the library to the Central repository using sbt and sign it with your PGP key, and finally to complete the release by instructing Sonatype to release the artifact. Dependencies include a correct sbt build, plugin setup (sbt-dynver, sbt-sonatype, sbt-pgp), and valid credentials for Sonatype and PGP key pair. Inputs are the desired version number; outputs are published artifacts available in the Central repository. The steps must be run from an environment where all required plugins and secrets are available.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ git tag v0.1.0\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt publishSigned\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt sonatypeRelease\n```\n\n----------------------------------------\n\nTITLE: Analyzing and Constructing Import Trees in Scala Macros\nDESCRIPTION: This code demonstrates extracting the reference and selectors from an import statement using quasiquotes, handling different kinds of selector patterns such as renamings and wildcards. It also shows how to construct import trees programmatically from these components, aiding in code transformation tasks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_54\n\nLANGUAGE: Scala\nCODE:\n```\nval q\"import $ref.{..$sels}\" = q\"import foo.{bar, baz => boo, poison => _, _}\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval ref = q\"a.b\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval sels = List(pq\"foo -> _\", pq\"_\")\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval imp = q\"import $ref.{..$sels}\"\n```\n\n----------------------------------------\n\nTITLE: Updating Immutable Set Using += and -= Operators - Scala\nDESCRIPTION: Shows usage of += and -= operators on a var holding an immutable Set of integers. The += operator is shorthand for reassigning the Set with a new Set including the added element, and similarly for -= removing an element. This demonstrates how immutable collections can be manipulated by reassignment rather than in-place mutations. No external dependencies needed beyond standard Scala collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/sets.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nvar s = Set(1, 2, 3)\ns += 4\ns -= 2\ns\n```\n\n----------------------------------------\n\nTITLE: Creating a Future with a long-running algorithm in Scala\nDESCRIPTION: Defines a long-running algorithm that returns 42 after a 10-second delay, wrapped into a Future to execute asynchronously. Demonstrates how to initiate the future and observe that it is not completed immediately.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/concurrency.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval eventualInt = Future(longRunningAlgorithm())\n```\n\n----------------------------------------\n\nTITLE: Implementing Enums and Extension Methods in Scala 3\nDESCRIPTION: This snippet demonstrates the syntax for creating enums and extension methods in Scala 3. The enum example shows how to define a Color enumeration with Red, Green, and Blue cases. The extension methods example shows how to add circumference, diameter, and area calculations to a Circle class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/why-scala-3.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// 枚举\nenum Color:\n  case Red, Green, Blue\n\n// 扩展方法\nextension (c: Circle)\n  def circumference: Double = c.radius * math.Pi * 2\n  def diameter: Double = c.radius * 2\n  def area: Double = math.Pi * c.radius * c.radius\n```\n\n----------------------------------------\n\nTITLE: Modifying Graph to Allow Connections Across Different Graph Nodes Using Type Projection in Scala 2\nDESCRIPTION: Updates the Graph class so that Node's list of connected nodes and the connectTo method accept nodes of type Graph#Node. This type projection allows nodes from any Graph instance to be connected, relaxing the previous path-dependent type restriction. The Graph maintains a list of its own Nodes, but connections can include nodes from other graphs. Requires familiarity with Scala's advanced type system features, particularly type projections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/inner-classes.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass Graph {\n  class Node {\n    var connectedNodes: List[Graph#Node] = Nil\n    def connectTo(node: Graph#Node): Unit = {\n      if (!connectedNodes.exists(node.equals)) {\n        connectedNodes = node :: connectedNodes\n      }\n    }\n  }\n  var nodes: List[Node] = Nil\n  def newNode: Node = {\n    val res = new Node\n    nodes = res :: nodes\n    res\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling Interactive Scala Program Using scalac\nDESCRIPTION: Shows the shell command to compile the interactive Scala program source file named 'helloInteractive.scala' using 'scalac'. Compilation generates JVM bytecode enabling subsequent program execution. This command applies to both Scala 2 and Scala 3 with prior source files matching respective language version syntax. Requires Scala compiler accessible from command line.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-hello-world.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ scalac helloInteractive.scala\n```\n\n----------------------------------------\n\nTITLE: Line Wrapping for Long Expressions - Scala\nDESCRIPTION: Illustrates the recommended method to wrap long Scala expressions over multiple lines, indenting each additional line by two spaces and ensuring the continuation via an unclosed parenthesis or infix operator. No external dependencies are required. Inputs are long, multi-part arithmetic expressions; output is the continued calculation. Maintains style correctness and avoids accidental compiler interpretation of semicolons.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/indentation.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval result = 1 + 2 + 3 + 4 + 5 + 6 +\n  7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 +\n  15 + 16 + 17 + 18 + 19 + 20\n```\n\n----------------------------------------\n\nTITLE: Using Protected Methods in Scala Classes\nDESCRIPTION: Demonstrates protected methods which are accessible within the class and its subclasses. The example shows a hierarchy with private, protected, and public methods and their access rules.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\nclass Animal {\n  private def breathe() = println(\"I'm breathing\")\n  def walk() = {\n    breathe()\n    println(\"I'm walking\")\n  }\n  protected def speak() = println(\"Hello?\")\n}\n\nclass Cat extends Animal {\n  override def speak() = println(\"Meow\")\n}\n\nval cat = new Cat\ncat.walk()\ncat.speak()\ncat.breathe()   // won't compile because it's private\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Animal:\n  private def breathe() = println(\"I'm breathing\")\n  def walk() =\n    breathe()\n    println(\"I'm walking\")\n  protected def speak() = println(\"Hello?\")\n\nclass Cat extends Animal:\n  override def speak() = println(\"Meow\")\n\nval cat = new Cat\ncat.walk()\ncat.speak()\ncat.breathe()   // won't compile because it's private\n```\n\n----------------------------------------\n\nTITLE: Defining implicit conversion from List to Ordered in Scala\nDESCRIPTION: This implicit method converts a List of type A to an Ordered[List[A]], given an implicit conversion from A to Ordered[A]. It enables comparison operations between lists by coerced ordering, relying on implicit resolution for element conversions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/implicit-conversions.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit def list2ordered[A](x: List[A])\n    (implicit elem2ordered: A => Ordered[A]): Ordered[List[A]] =\n  new Ordered[List[A]] { /* .. */ }\n```\n\n----------------------------------------\n\nTITLE: Matching Basic 'super' Quasiquotes - Scala\nDESCRIPTION: Demonstrates pattern matching on a basic `super` expression with a field access using quasiquotes. The pattern `q\"$name.super[$qual].$field\"` matches `q\"super.foo\"` and extracts the components, showing empty type/qualifier names when none are explicitly present.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"$name.super[$qual].$field\" = q\"super.foo\"\nname: universe.TypeName =\nqual: universe.TypeName =\nfield: universe.Name = foo\n```\n\n----------------------------------------\n\nTITLE: Object-Oriented Programming: Classes and Methods in Scala and Python\nDESCRIPTION: Compares defining classes with constructors and methods in Scala and Python. Shows instance creation, attribute modification, and method invocation, illustrating object-oriented concepts in both languages, including syntax for constructors, instance variables, and method definitions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Person(object):\n  def __init__(self, name):\n    self.name = name\n\n  def speak(self):\n    print(f'Hello, my name is {self.name}')\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass Person (var name: String):\n  def speak() = println(s\"Hello, my name is $name\")\n```\n\nLANGUAGE: python\nCODE:\n```\np = Person(\"John\")\n p.name  # John\n p.name = 'Fred'\n p.name  # Fred\n p.speak()\n```\n\nLANGUAGE: scala\nCODE:\n```\nval p = Person(\"John\")\n p.name  // John\n p.name = \"Fred\"\n p.name  // Fred\n p.speak()\n```\n\n----------------------------------------\n\nTITLE: Enabling Snippet Compiler in SBT (Scala)\nDESCRIPTION: Configures the Scala compiler options within an SBT build file to enable Scaladoc's snippet compiler for all `scala` snippets in the project documentation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/snippet-compiler.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nCompile / doc / scalacOptions ++= Seq(\"-snippet-compiler:compile\")\n```\n\n----------------------------------------\n\nTITLE: Implementing a Covariant, Immutable Stack with Variance Annotations in Scala\nDESCRIPTION: This code defines a covariant generic class 'Stack' with an overridden 'push' method that uses a lower type bound to enable adding elements of supertype 'S' to a stack of type 'T'. The class supports immutable operations by returning new stack instances, with inner classes managing the internal structure. The 'VariancesTest' object demonstrates creating and extending a stack with elements of various types, illustrating the use of covariance in practice.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/variances.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass Stack[+T] {\n  def push[S >: T](elem: S): Stack[S] = new Stack[S] {\n    override def top: S = elem\n    override def pop: Stack[S] = Stack.this\n    override def toString: String =\n      elem.toString + \" \" + Stack.this.toString\n  }\n  def top: T = sys.error(\"no element on stack\")\n  def pop: Stack[T] = sys.error(\"no element on stack\")\n  override def toString: String = \"\"\n}\n\nobject VariancesTest extends App {\n  var s: Stack[Any] = new Stack().push(\"hello\")\n  s = s.push(new Object())\n  s = s.push(7)\n  println(s)\n}\n```\n\n----------------------------------------\n\nTITLE: Invoking Anonymous Type Provider Macro\nDESCRIPTION: Demonstrates the invocation of the `h2db` macro. The result, despite the `Any` return type in the definition, will gain a structural type inferred by the compiler based on the macro's expansion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/typeproviders.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval db = h2db(\"jdbc:h2:coffees.h2.db\")\n```\n\n----------------------------------------\n\nTITLE: Updating elements in mutable lists/sequences in Python and Scala\nDESCRIPTION: Illustrates how to update elements by index in mutable lists/sequences. Python lists are mutable and allow direct modification using square brackets. Scala's mutable ArrayBuffer allows updates using parentheses. Highlights mutability considerations when working with collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_53\n\nLANGUAGE: python\nCODE:\n```\na[0] = 10\na[1] = 20\n```\n\nLANGUAGE: scala\nCODE:\n```\n// ArrayBuffer is mutable\na(0) = 10\na(1) = 20\n```\n\n----------------------------------------\n\nTITLE: Creating Specific Keys with Dependent Types\nDESCRIPTION: This snippet defines specific objects 'Name' and 'Age' extending 'Key' with concrete 'Value' types. It illustrates how different key objects have distinct associated value types, and how method calls like 'db.get(Name)' are typed accordingly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-dependent-function.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject Name extends Key { type Value = String }\nobject Age extends Key { type Value = Int }\n\nval db: DB = ...\nval res1: Option[String] = db.get(Name)\nval res2: Option[Int] = db.get(Age)\n```\n\n----------------------------------------\n\nTITLE: Creating and Decomposing While and Do-While Loops Using Quasiquotes\nDESCRIPTION: This snippet illustrates how to construct while and do-while loop trees with quasiquotes, capturing loop conditions and bodies, and how to decompose these trees back into their components. These constructs are useful for code generation where performance-critical loops are involved.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_51\n\nLANGUAGE: Scala\nCODE:\n```\nval `while` = q\"while(x > 0) x -= 1\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval q\"while($cond) $body\" = `while`\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval `do-while` = q\"do x -= 1 while (x > 0)\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval q\"do $body while($cond)\" = `do-while`\n```\n\n----------------------------------------\n\nTITLE: Updating Elements in an Immutable ArraySeq in Scala\nDESCRIPTION: This snippet shows how to create an updated version of an immutable ArraySeq using the `updated` method, which produces a new ArraySeq with a changed element at a specified index. It highlights the immutability property by showing the original ArraySeq remains unchanged after the update operation. This approach requires Scala 2.13 or later.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-immutable-collection-classes.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nscala> arr.updated(2, 4)\nres26: scala.collection.immutable.ArraySeq[Int] = ArraySeq(1, 2, 4)\nscala> arr\nres27: scala.collection.immutable.ArraySeq[Int] = ArraySeq(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Creating and Modifying Immutable ArraySeqs in Scala\nDESCRIPTION: This snippet illustrates how to create an immutable ArraySeq with initial elements, append an element using `:+`, and access an element by index. ArraySeq provides constant-time indexed access while maintaining immutability. It requires Scala 2.13 or later and the standard Scala immutable collections namespace.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-immutable-collection-classes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nscala> val arr = scala.collection.immutable.ArraySeq(1, 2, 3)\narr: scala.collection.immutable.ArraySeq[Int] = ArraySeq(1, 2, 3)\nscala> val arr2 = arr :+ 4\narr2: scala.collection.immutable.ArraySeq[Int] = ArraySeq(1, 2, 3, 4)\nscala> arr2(0)\nres22: Int = 1\n```\n\n----------------------------------------\n\nTITLE: Creating a Comparable Date Class in Scala\nDESCRIPTION: Implements a Date class that extends the Ord trait to make dates comparable. The class defines the required equality and less-than methods while inheriting the other comparison operators from the Ord trait.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tutorials/scala-for-java-programmers.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass Date(a: Int, m: Int, j: Int) extends Ord {\n  def annee = a\n  def mois = m\n  def jour = j\n  override def toString(): String = annee + \"-\" + mois + \"-\" + jour\n\n  override def equals(that: Any): Boolean =\n    that.isInstanceOf[Date] && {\n      val d = that.asInstanceOf[Date]\n      d.jour == jour && d.mois == mois && d.annee == annee\n    }\n\n  def <(that: Any): Boolean = {\n    if (!that.isInstanceOf[Date])\n      sys.error(\"on ne peut pas comparer \" + that + \" et une Date\")\n\n    val d = that.asInstanceOf[Date]\n    (annee < d.annee) ||\n    (annee == d.annee && (mois < d.mois ||\n                       (mois == d.mois && jour < d.jour)))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Custom '+' Operator for a Case Class in Scala\nDESCRIPTION: Defines a case class `Vec` representing a 2D vector and implements a custom '+' method to perform vector addition. It then demonstrates creating instances and using this method as an infix operator to add two vectors.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/operators.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncase class Vec(x: Double, y: Double) {\n  def +(that: Vec) = Vec(this.x + that.x, this.y + that.y)\n}\n\nval vector1 = Vec(1.0, 1.0)\nval vector2 = Vec(2.0, 2.0)\n\nval vector3 = vector1 + vector2\nvector3.x  // 3.0\nvector3.y  // 3.0\n```\n\n----------------------------------------\n\nTITLE: Using callback-based Futures for currency trading in Scala 3\nDESCRIPTION: Scala 3 syntax example showing nested Futures using callbacks with for-comprehensions to fetch USD exchange rate and conditionally buy currency. It highlights nested asynchronous blocks using the concise Scala 3 'for...do' syntax and inline conditional expressions. Similar limitations arise due to nested callbacks reducing composability and scope visibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nval rateQuote = Future {\n  connection.getCurrentValue(USD)\n}\n\nfor quote <- rateQuote do\n  val purchase = Future {\n    if isProfitable(quote) then connection.buy(amount, quote)\n    else throw Exception(\"not profitable\")\n  }\n\n  for amount <- purchase do\n    println(\"Purchased \" + amount + \" USD\")\n```\n\n----------------------------------------\n\nTITLE: Specifying Numeric Literal Types in Scala\nDESCRIPTION: Shows how to append suffixes like L, D, and F to numeric literals to explicitly specify their types as Long, Double, or Float.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-vars-data-types.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval x = 1_000L   // val x: Long = 1000\nval y = 2.2D     // val y: Double = 2.2\nval z = 3.3F     // val z: Float = 3.3\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Pattern Matching Duration in Scala\nDESCRIPTION: This snippet demonstrates the various ways to instantiate Duration objects and utilize them in pattern matching within concurrent Scala applications. Required dependencies include scala.concurrent.util.Duration, scala.concurrent.util.duration._ for implicit conversions, and java.util.concurrent.TimeUnit for working with time units. Key parameters include length (Long or Int) and unit (TimeUnit or String), with expected output as Duration instances representing a specific length of time. The snippet shows both explicit and implicit construction, as well as extraction of length and unit using unapply in pattern matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/futures-promises.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.concurrent.util.Duration\nimport scala.concurrent.util.duration._\nimport java.util.concurrent.TimeUnit._\n\n// instantiation\nval d1 = Duration(100, MILLISECONDS) // from Long and TimeUnit\nval d2 = Duration(100, \"millis\") // from Long and String\nval d3 = 100 millis // implicitly from Long, Int or Double\nval d4 = Duration(\"1.2 µs\") // from String\n\n// pattern matching\nval Duration(length, unit) = 5 millis\n\n```\n\n----------------------------------------\n\nTITLE: Migrating Method Invocations for Collections - Scala\nDESCRIPTION: This snippet demonstrates the migration of collection method calls to their modern equivalents in Scala 2.13. It highlights syntactic and behavioral differences, such as invoking \"to\" using parentheses instead of type parameters and adapting methods like \"mapValues\" for compatibility with the new API. Dependencies include the core scala.collection library. Inputs are typical Scala collections; outputs are the adapted collections. The focus is on reducing breakage when upgrading codebases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/collections-migration-213.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nxs.to(List) // instead of xs.to[List]\nkvs.mapValues(f).toMap // instead of kvs.mapValues(f)\nxs1.iterator.sameElements(xs2) // instead of xs1.sameElements(xs2)\nval xs = ys.iterator.map(f).to(List) // instead of val xs: List[Int] = ys.map(f)(collection.breakOut)\nmap.zip(iterable).toMap // instead of map.zip(iterable)\nArrayBuilder.make[Int] // instead of ArrayBuilder.make[Int]()\n```\n\n----------------------------------------\n\nTITLE: Creating Lists with Mixed Types\nDESCRIPTION: Demonstrates creating Lists that contain multiple types of elements using union types in Scala 3 and Any in both Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval things: List[String | Int | Double] = List(1, \"two\", 3.0) // with union types\nval thingsAny: List[Any] = List(1, \"two\", 3.0)                // with any\n```\n\n----------------------------------------\n\nTITLE: Defining Immutable Pizza Case Class with Functional Methods in Scala\nDESCRIPTION: This snippet defines a Pizza case class using immutable fields and incorporates behavior methods directly within the class. Each method (price, addTopping, removeAllToppings, updateCrustSize, updateCrustType) operates on the current Pizza instance, leveraging `this.copy` to return updated immutable instances rather than mutating state. The price method delegates to an external pizzaPrice function. This design illustrates a hybrid functional-object oriented approach common in Scala, emphasizing pure functions and immutability. Both Scala 2 and Scala 3 syntaxes are shown.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-fp.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Pizza(\n  crustSize: CrustSize,\n  crustType: CrustType,\n  toppings: Seq[Topping]\n) {\n\n  // the operations on the data model\n  def price: Double =\n    pizzaPrice(this) // implementation from above\n\n  def addTopping(t: Topping): Pizza =\n    this.copy(toppings = this.toppings :+ t)\n\n  def removeAllToppings: Pizza =\n    this.copy(toppings = Seq.empty)\n\n  def updateCrustSize(cs: CrustSize): Pizza =\n    this.copy(crustSize = cs)\n\n  def updateCrustType(ct: CrustType): Pizza =\n    this.copy(crustType = ct)\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Pizza(\n  crustSize: CrustSize,\n  crustType: CrustType,\n  toppings: Seq[Topping]\n):\n\n  // the operations on the data model\n  def price: Double =\n    pizzaPrice(this) // implementation from above\n\n  def addTopping(t: Topping): Pizza =\n    this.copy(toppings = this.toppings :+ t)\n\n  def removeAllToppings: Pizza =\n    this.copy(toppings = Seq.empty)\n\n  def updateCrustSize(cs: CrustSize): Pizza =\n    this.copy(crustSize = cs)\n\n  def updateCrustType(ct: CrustType): Pizza =\n    this.copy(crustType = ct)\n```\n\n----------------------------------------\n\nTITLE: Deriving Semigroup for Tuples via Implicits in Scala\nDESCRIPTION: Defines implicit methods for constructing Semigroup instances for tuples of two and three elements, given existing Semigroup instances for the tuple element types. Each tuple Semigroup delegates combine to the element-wise combination using the appropriate implicit Semigroup instances. Shows combinatorial construction and is extendable to all product types (case classes). Requires prior Semigroup instances for the contained element types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit def tuple2Semigroup[A, B]\n  (implicit\n    sa: Semigroup[A],\n    sb: Semigroup[B]):\n        Semigroup[(A, B)] =\n  new Semigroup[(A, B)] {\n    def combine(x: (A, B), y: (A, B)): (A, B) =\n      (sa.combine(x._1, y._1),\n       sb.combine(x._2, y._2))\n  }\n\nimplicit def tuple3Semigroup[A, B, C]\n  (implicit\n    sa: Semigroup[A],\n    sb: Semigroup[B],\n    sc: Semigroup[C]):\n        Semigroup[(A, B, C)] =\n  nee Semigroup[(A, B, C)] {\n    def combine(x: (A, B, C), y: (A, B, C)): (A, B, C) =\n      (sa.combine(x._1, y._1),\n       sb.combine(x._2, y._2),\n       sc.combine(x._3, y._3))\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Looping Over a List in Scala 2\nDESCRIPTION: Shows the Scala 2 syntax for iterating through a `List` using a `for` loop with parentheses and printing each element. Requires a pre-defined `List` named `names`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nfor (name <- names) println(name)\n```\n\n----------------------------------------\n\nTITLE: Scala Class and Trait Mixins for Class Composition\nDESCRIPTION: This snippet demonstrates how to use abstract classes and traits to compose classes in Scala. It shows a base class 'A', subclass 'B', a trait 'C', and a class 'D' that combines 'B' and 'C' via mixins, illustrating multiple traits inheritance and message transformation functionality.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/mixin-class-composition.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class A {\n  val message: String\n}\nclass B extends A {\n  val message = \"I'm an instance of class B\"\n}\ntrait C extends A {\n  def loudMessage = message.toUpperCase()\n}\nclass D extends B with C\n\nval d = new D\nd.message  // I'm an instance of class B\nd.loudMessage  // I'M AN INSTANCE OF CLASS B\n```\n\n----------------------------------------\n\nTITLE: Demonstrating RNA1 Limitation with map/++ (Scala)\nDESCRIPTION: Shows the actual behavior of the `RNA1` class when using `map` (even when mapping `Base` to `Base`) and `++` (concatenating `RNA1` with itself). Due to the way `RNA1` inherits from `IndexedSeqOps` (specifically specifying `IndexedSeq` as the target collection constructor `CC` for `map`), these operations return a generic `IndexedSeq` (specifically a `Vector`), not a new `RNA1` instance. This highlights a limitation of the initial `RNA1` implementation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nscala> val rna1 = RNA1(A, U, G, G, C)\nval rna1: RNA1 = RNA1(A, U, G, G, C)\n\nscala> rna1.map { case A => U case b => b }\nval res0: IndexedSeq[Base] = Vector(U, U, G, G, C)\n\nscala> rna1 ++ rna1\nval res1: IndexedSeq[Base] = Vector(A, U, G, G, C, A, U, G, G, C)\n```\n\n----------------------------------------\n\nTITLE: Evaluating Arithmetic Expression Trees Using Pattern Matching in Scala\nDESCRIPTION: Defines a recursive function eval that takes an arithmetic expression tree (an instance of Arbol) and a variable environment (Entorno), evaluating the expression to an integer. It uses Scala's pattern matching to handle different node types: Sum nodes recursively evaluate left and right subtrees and sum the results, Var nodes retrieve the variable's value from the environment, and Const nodes return their integer value directly. This implementation throws an exception if a node type is unrecognized, ensuring exhaustiveness if new subclasses are added.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tutorials/scala-for-java-programmers.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ndef eval(a: Arbol, ent: Entorno): Int = a match {\n  case Sum(i, d) => eval(i, ent) + eval(d, ent)\n  case Var(n)    => ent(n)\n  case Const(v)  => v\n}\n```\n\n----------------------------------------\n\nTITLE: Ambiguous Conversions in Scala 3\nDESCRIPTION: Example demonstrating how implicit conversions that were unambiguous in Scala 2.13 (where conversion on A wins over => A) become ambiguous in Scala 3, requiring explicit conversion specification.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-contextual-abstractions.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimplicit def boolFoo(bool: Boolean): Foo = ???\nimplicit def lazyBoolFoo(lazyBool:  => Boolean): Foo = ???\n\ntrue.foo()\n```\n\n----------------------------------------\n\nTITLE: Defining generic array creation with ClassTag context bound in Scala 2\nDESCRIPTION: This Scala 2 snippet defines a generic function 'evenElems' that extracts elements at even indices from a Vector of type T and returns them in a new Array of type T. It requires an implicit ClassTag for T to allow creation of an Array[T] at runtime, since arrays are represented by their runtime class. The function initializes a new array of appropriate length and fills it by iterating over even-indexed elements of the input vector. The key dependency is scala.reflect.ClassTag, ensuring correct type information at runtime for the array.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/arrays.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect.ClassTag\n// this works\ndef evenElems[T: ClassTag](xs: Vector[T]): Array[T] = {\n  val arr = new Array[T]((xs.length + 1) / 2)\n  for (i <- 0 until xs.length by 2)\n    arr(i / 2) = xs(i)\n  arr\n}\n```\n\n----------------------------------------\n\nTITLE: Using the SensorReader Observer Components in Scala 3\nDESCRIPTION: This code shows how to utilize SensorReader components in Scala 3 for event notification. It imports all SensorReader members, creates two sensors and two displays, links displays to sensors via subscription, and changes sensor values to trigger observer notifications. Dependencies: SensorReader, Sensor, and Display definitions available. Inputs are sensor labels as strings and value updates as numbers. Outputs include printed lines on observer updates. The code showcases Scala 3's concise import and instance creation syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-oop.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\nimport SensorReader.*\n\n// setting up a network\nval s1 = Sensor(\"sensor1\")\nval s2 = Sensor(\"sensor2\")\nval d1 = Display()\nval d2 = Display()\ns1.subscribe(d1)\ns1.subscribe(d2)\ns2.subscribe(d1)\n\n// propagating updates through the network\ns1.changeValue(2)\ns2.changeValue(3)\n\n// prints:\n// sensor1 has value 2.0\n// sensor1 has value 2.0\n// sensor2 has value 3.0\n```\n\n----------------------------------------\n\nTITLE: Перевірка встановлення Scala за допомогою bash\nDESCRIPTION: Цей bash-фрагмент призначений для перевірки коректності встановлення Scala на вашому комп'ютері. Виконання команди `scala -version` виводить інформацію про версію Scala code runner та встановлену версію Scala. Це допомагає впевнитися, що інсталяція виконалася успішно і командний інструмент доступний у середовищі користувача. Після встановлення інструменту може знадобитися перезапустити сесію терміналу або перезавантажити комп’ютер, щоб зміни застосувалися.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/getting-started/install-scala.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ scala -version\nScala code runner version: 1.4.3\nScala version (default): {{site.scala-3-version}}\n```\n\n----------------------------------------\n\nTITLE: Declaring Cask Dependency Using Scala CLI in Scala\nDESCRIPTION: This snippet demonstrates how to add the Cask web framework as a dependency using the Scala CLI's 'using dep' directive. No additional setup beyond Scala CLI is required. The dependency version must match the project's Scala version compatibility; the shown version targets Cask 0.10.2. The directive is typically placed at the top of your .scala source file to enable Cask features in your Scala scripting projects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-cask.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n//> using dep com.lihaoyi::cask::0.10.2\n```\n\n----------------------------------------\n\nTITLE: Nested package declaration in Scala 2\nDESCRIPTION: Shows how to declare nested packages within a single file using block syntax within Scala 2. This allows grouping related classes under sub-packages such as 'administrators' and 'normalusers' with access control over scope.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/packages-and-imports.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\npackage users {\n  package administrators {\n    class NormalUser\n  }\n  package normalusers {\n    class NormalUser\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Selectively Applying @unroll for Multiple Parameter Additions in Scala\nDESCRIPTION: Illustrates that when multiple default parameters are added at once (like `b` and `l`), only the first parameter (`b`) needs the `@unroll` annotation to generate the necessary forwarder for the previous version. This avoids generating redundant intermediate forwarders.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/unroll-default-arguments.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nobject Unrolled{\n   def foo(s: String, n: Int = 1, @unroll b: Boolean = true, l: Long = 0) = s + n + b + l\n\n   def foo(s: String, n: Int) = foo(s, n, true, 0)\n}\n```\n\n----------------------------------------\n\nTITLE: Optional Colon Syntax with Case Pattern Matching\nDESCRIPTION: A proposed extension where the colon could be omitted when followed by 'case' on the next line. This was left out of the initial implementation for simplicity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nval xs = List((1, \"hello\"), (true, \"bar\"), (false, \"foo\"))\nval ys = xs.collect // note: no ':' here\n  case (b: Boolean, s) if b => s\nprintln(ys)\n```\n\n----------------------------------------\n\nTITLE: Macro Expansion with Explicit Type Ascription for Consistency (Scala)\nDESCRIPTION: This macro implementation explicitly upcasts the expansion to 'Any', enforcing a unified type for the macro output across both Scala 2.10.x and 2.11.0. This approach discourages blackbox/whitebox-specific behavior but results in loss of structure for the expanded value, making member access like 'foo.x' fail in all cases. Dependencies include 'scala-reflect' and macro support.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/changelog211.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject Macros {\n  def impl(c: Context) = {\n    import c.universe._\n    q\"(new { val x = 2 }): Any\" // note the explicit type ascription\n  }\n\n  def foo: Any = macro impl\n}\n\nobject Test extends App {\n  // consistently doesn't work in Scala 2.10.x and Scala 2.11.0\n  // regardless of whether foo is whitebox or blackbox\n  println(Macros.foo.x)\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating a Custom Parallel Collection with the Scala Framework in Scala\nDESCRIPTION: Completes the `ParString` implementation by integrating it with the Scala collections framework. It mixes in `GenericParTemplate`, implements the `companion` method, and defines a companion object `ParString` providing implicit `CanCombineFrom`, `newBuilder`, `newCombiner`, and an `apply` factory method. This enables seamless use with standard collection operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/parallel-collections/custom-parallel-collections.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.parallel.immutable\nimport scala.collection.parallel.Combiner\nimport scala.collection.parallel.SeqSplitter\nimport scala.collection.mutable.ArrayBuffer\nimport scala.collection.parallel.ParSeqLike\nimport scala.collection.parallel.IterableSplitter\nimport scala.collection.generic.GenericParTemplate\nimport scala.collection.generic.CanCombineFrom\nimport scala.collection.parallel.ParIterable\n\nclass ParString(val str: String)\nextends immutable.ParSeq[Char]\n   with GenericParTemplate[Char, ParString]\n   with ParSeqLike[Char, ParString, collection.immutable.WrappedString] {\n\n  // Methods: apply, length, seq, splitter\n  def apply(i: Int) = str.charAt(i)\n  def length = str.length\n  def seq = new collection.immutable.WrappedString(str)\n  def splitter: ParStringSplitter = new ParStringSplitter(str, 0, str.length)\n\n  override def companion = ParString\n\n  protected[this] override def newCombiner: Combiner[Char, ParString] = ParString.newCombiner\n\n  // Inner ParStringSplitter class\n  class ParStringSplitter(private var s: String, private var i: Int, private val ntl: Int)\n  extends SeqSplitter[Char] {\n    // Methods: hasNext, next, remaining, dup, split, psplit\n    final def hasNext = i < ntl\n    final def next = { val r = s.charAt(i); i += 1; r }\n    def remaining = ntl - i\n    def dup = new ParStringSplitter(s, i, ntl)\n    def split = { val rem = remaining; if (rem >= 2) psplit(rem / 2, rem - rem / 2) else Seq(this) }\n    def psplit(sizes: Int*): Seq[ParStringSplitter] = {\n      val splitted = new ArrayBuffer[ParStringSplitter]\n      for (sz <- sizes) {\n        val next = (i + sz) min ntl\n        splitted += new ParStringSplitter(s, i, next)\n        i = next\n      }\n      if (remaining > 0) splitted += new ParStringSplitter(s, i, ntl)\n      splitted\n    }\n  }\n}\n\nobject ParString {\n  // Custom CanCombineFrom implementation\n  class ParStringCanCombineFrom extends CanCombineFrom[ParString, Char, ParString] {\n    def apply(from: ParString): Combiner[Char, ParString] = newCombiner\n    def apply(): Combiner[Char, ParString] = newCombiner\n  }\n\n  implicit def canBuildFrom: CanCombineFrom[ParString, Char, ParString] = new ParStringCanCombineFrom\n\n  def newBuilder: Combiner[Char, ParString] = newCombiner\n\n  def newCombiner: Combiner[Char, ParString] = new ParStringCombiner\n\n  def apply(elems: Char*): ParString = {\n    val cb = newCombiner\n    cb ++= elems\n    cb.result\n  }\n\n  // Private Combiner implementation moved inside companion object\n  private class ParStringCombiner extends Combiner[Char, ParString] {\n    var sz = 0\n    val chunks = new ArrayBuffer[StringBuilder] += new StringBuilder\n    var lastc = chunks.last\n\n    def size: Int = sz\n\n    def +=(elem: Char): this.type = {\n      lastc += elem\n      sz += 1\n      this\n    }\n\n    def clear = {\n      chunks.clear\n      chunks += new StringBuilder\n      lastc = chunks.last\n      sz = 0\n    }\n\n    def result: ParString = {\n      val rsb = new StringBuilder\n      for (sb <- chunks) rsb.append(sb)\n      new ParString(rsb.toString)\n    }\n\n    def combine[U <: Char, NewTo >: ParString](other: Combiner[U, NewTo]) = if (other eq this) this else {\n      val that = other.asInstanceOf[ParStringCombiner]\n      sz += that.sz\n      chunks ++= that.chunks\n      lastc = chunks.last\n      this\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Enqueuing a Single Element to an Immutable Queue in Scala\nDESCRIPTION: Shows using the `enqueue` method to add a single element (1) to an immutable Queue. This operation returns a *new* Queue instance (`has1`) containing the added element; the original queue (`empty`) remains unchanged.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/concrete-immutable-collection-classes.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval has1 = empty.enqueue(1)\n```\n\nLANGUAGE: output\nCODE:\n```\nhas1: scala.collection.immutable.Queue[Int] = Queue(1)\n```\n\n----------------------------------------\n\nTITLE: Creating Allocation-Free Extension Methods using Implicit Value Classes in Scala\nDESCRIPTION: Defines an implicit value class `RichInt` that extends `AnyVal`. This pattern allows adding extension methods (like `toHexString`) to an existing type (`Int`) without the runtime overhead of creating a wrapper object for each method call.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimplicit class RichInt(val self: Int) extends AnyVal {\n  def toHexString: String = java.lang.Integer.toHexString(self)\n}\n```\n\n----------------------------------------\n\nTITLE: 双向链表（DoubleLinkedList）\nDESCRIPTION: 说明双向链表在单向链表基础上增加prev指针，支持快速元素移除。支持类为DoubleLinkedList，允许双向遍历和高效删除，适合复杂操作场景。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/concrete-mutable-collection-classes.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\n// 具体代码示例未提供，仅为说明\n```\n\n----------------------------------------\n\nTITLE: Passing Arguments After Newline with an Open Brace - Scala\nDESCRIPTION: This code passes a block argument to the 'test' function by placing the opening brace on a new line. While compilable in Scala 2.13, Scala 3 rejects this as a syntax error (the brace starts a new statement). The snippet asserts equality within the block. There are no dependencies, and the main limitation is the changed newline brace handling in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-syntactic.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ntest(\"my test\")\n{ // In Scala 3, Error: This opening brace will start a new statement.\n  assert(1 == 1)\n}\n```\n\n----------------------------------------\n\nTITLE: 示例：函数类型的子类型关系（Scala 2/3）\nDESCRIPTION: 演示可用的子类型关系：Function[Buyable, Buyable] 兼容 Function[Buyable, Item] 和 Function[Book, Buyable]，体现逆变参数和协变返回值的语义。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-variance.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nval f: Function[Buyable, Buyable] = b => b\n\n// OK: Buyable可被用在期望Item的位置\nval g: Function[Buyable, Item] = f\n\n// OK: Book可以作为输入传递给需要Buyable的函数\nval h: Function[Book, Buyable] = f\n```\n\n----------------------------------------\n\nTITLE: Extending and Overriding Multiple Traits in a Scala Cat Class\nDESCRIPTION: Creates a Cat class that extends multiple traits, implements the required abstract method, and overrides some concrete methods with custom implementations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/traits-abstract-mixins.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nclass Cat extends Speaker with TailWagger with Runner {\n    def speak(): String = \"Meow\"\n    override def startRunning(): Unit = println(\"Yeah ... I don't run\")\n    override def stopRunning(): Unit = println(\"No need to stop\")\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing an Immutable List in Scala\nDESCRIPTION: Demonstrates how to create an immutable `List` of strings in both Scala 2 and 3 using the `List` companion object's `apply` method. This is the standard way to create a list with initial elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval names = List(\"Joel\", \"Chris\", \"Ed\")\n```\n\n----------------------------------------\n\nTITLE: Creating Immutable List (Java)\nDESCRIPTION: This Java snippet demonstrates how to create an immutable List instance using the `List.of()` factory method. This method provides a convenient way to create small, fixed-size immutable lists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_54\n\nLANGUAGE: Java\nCODE:\n```\nList strings = List.of(\"a\", \"b\", \"c\");\n```\n\n----------------------------------------\n\nTITLE: Scala Enum for Sum Types with Parameters in Scala 3\nDESCRIPTION: Defines a recursive sum type 'Nat' using enum with cases Zero and Succ, illustrating enum with parameters in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-modeling.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nenum Nat:\n  case Zero\n  case Succ(pred: Nat)\n```\n\n----------------------------------------\n\nTITLE: Example of Trait Parameter Initialization Order in Scala - Scala\nDESCRIPTION: This snippet demonstrates the evaluation and initialization order when a class `D` extends two parameterized traits `T` and `V` with arguments `e1` and `e2` respectively. It clarifies that arguments are evaluated immediately before their corresponding trait initializers run, enforcing the linearized order of initialization: evaluation of `e1`, initializer of `T`, evaluation of `e2`, followed by initializer of `V`. This example helps understand runtime behavior of constructor argument evaluation in traits.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/trait-parameters.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ntrait V(x2: B)\nclass D extends T(e1) with V(e2)\n```\n\n----------------------------------------\n\nTITLE: Defining an Abstract Base Class and Subclasses in Scala\nDESCRIPTION: This snippet defines a base class E with an abstract type member T and a value x of type Option[T] initialized to None. Subclasses C and D are then derived from E, with D extending C, establishing an inheritance hierarchy. No dependencies are required beyond standard Scala, and this forms the foundation for later runtime comparisons. Expected input is class instantiation, and output is the class structure; no specific limitations as this is standard Scala class structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/overview.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass E {\n  type T\n  val x: Option[T] = None\n}\nclass C extends E\nclass D extends C\n```\n\n----------------------------------------\n\nTITLE: Constructing Code Blocks with Scala Quasiquotes\nDESCRIPTION: Illustrates creating a `Block` AST using the `q` interpolator with multiple statements separated by semicolons or newlines. The example creates a block containing three identifiers `a`, `b`, and `c`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_37\n\nLANGUAGE: scala\nCODE:\n```\nscala> val t = q\"a; b; c\"\nt: universe.Tree =\n{\n  a;\n  b;\n  c\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Inspecting a LazyList Fibonacci Sequence in Scala\nDESCRIPTION: This snippet demonstrates creating a finite prefix of the infinite Fibonacci LazyList by using `take` to select the first seven elements. It then converts the lazy sequence to a strict List with `toList` to force evaluation and display the elements. Inputs are the initial two Fibonacci numbers and the number of elements to take; output is a strict list of Fibonacci numbers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-immutable-collection-classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> val fibs = fibFrom(1, 1).take(7)\nfibs: scala.collection.immutable.LazyList[Int] = LazyList(<not computed>)\nscala> fibs.toList\nres9: List[Int] = List(1, 1, 2, 3, 5, 8, 13)\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Tuples in List\nDESCRIPTION: Provides an example of pattern matching on tuples within a list to perform conditional logic based on tuple contents, such as matching specific planet names and their distances from the sun. Demonstrates pattern matching syntax with tuple deconstruction.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/tuples.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval planetDistanceFromSun = List(\n  (\"Mercury\", 57.9),\n  (\"Venus\", 108.2),\n  (\"Earth\", 149.6),\n  (\"Mars\", 227.9),\n  (\"Jupiter\", 778.3)\n)\n\nplanetDistanceFromSun.foreach {\n  case (\"Mercury\", distance)  => println(s\"Merkury jest $distance milionów km od Słońca\")\n  case p if p._1 == \"Venus\" => println(s\"Wenus jest ${p._2} milionów km od Słońca\")\n  case p if p._1 == \"Earth\" => println(s\"Niebieska Planeta jest ${p._2} milionów km od Słońca\")\n  case _                    => println(\"Zbyt daleko...\")\n}\n```\n\n----------------------------------------\n\nTITLE: Cross-building Custom Collections Configuration in Scala SBT Build Definition\nDESCRIPTION: Provides an sbt build setting snippet that configures separate source directories for different Scala versions to support cross-building of custom collections. This setup allows authors to maintain Scala 2.13+ and earlier 2.13 versions source compatibility by directing sbt to use 'scala-2.13+' for Scala 2.13 and newer and 'scala-2.13-' for older versions. It depends on sbt build tool and the CrossVersion utility. Input is the scalaVersion setting, and output is the unmanagedSourceDirectories setting extended accordingly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\n// Adds a `src/main/scala-2.13+` source directory for Scala 2.13 and newer\n// and a `src/main/scala-2.13-` source directory for Scala version older than 2.13\nunmanagedSourceDirectories in Compile += {\n  val sourceDir = (sourceDirectory in Compile).value\n  CrossVersion.partialVersion(scalaVersion.value) match {\n    case Some((2, n)) if n >= 13 => sourceDir / \"scala-2.13+\"\n    case _                       => sourceDir / \"scala-2.13-\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Refined Types Using Refined and Shapeless Witness in Scala\nDESCRIPTION: Shows declaration of refined types with value-level Witness singleton types to constrain integer values, such as enforcing that a value is greater than a constant. Dependencies include the refined and shapeless libraries. Demonstrates valid type ascriptions, as well as compile-time errors for invalid ascriptions using refined predicates Greater[w.T], where w is a Witness of an integer literal. The inputs are integer values and type-level predicates; outputs are values constrained by refined types and compile-time safety enforcement.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/42.type.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval w5 = Witness(5)\nval a: Int Refined Greater[w5.T] = 10\n\n// Since every value greater than 5 is also greater than 4,\n// `a` can be ascribed the type Int Refined Greater[w4.T]:\nval w4 = Witness(4)\nval b: Int Refined Greater[w4.T] = a\n\n// An unsound ascription leads to a compile error:\nval w6 = Witness(6)\nval c: Int Refined Greater[w6.T] = a\n\n//<console>:23: error: type mismatch (invalid inference):\n// Greater[Int(5)] does not imply\n// Greater[Int(6)]\n//       val c: Int Refined Greater[W.`6`.T] = a\n                                             ^\n```\n\n----------------------------------------\n\nTITLE: Accessing Singleton Object Instances via ModuleMirror - Scala\nDESCRIPTION: Shows how to use Scala's runtime reflection to access an instance of a singleton object 'C' by retrieving its ModuleSymbol and reflecting it to a ModuleMirror. The 'instance' property yields the actual object. Prerequisite: defined singleton object and the reflective runtime mirror.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/environment-universes-mirrors.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nobject C { def x = 2 }\nval m = ru.runtimeMirror(getClass.getClassLoader)\nval objectC = ru.typeOf[C.type].termSymbol.asModule\nval mm = m.reflectModule(objectC)\nval obj = mm.instance\n```\n\n----------------------------------------\n\nTITLE: Setting SBT Build Settings for Sonatype Publishing (Scala)\nDESCRIPTION: Defines essential sbt project settings for publishing to Sonatype, including artifactId, groupId, project licenses, and metadata description. Also configures Sonatype project hosting and directs sbt to publish using the Sonatype bundle method. Requires sbt and the sbt-sonatype plugin. Inputs: project metadata and Sonatype account information. Outputs: properly configured sbt project ready for Sonatype publication. Limitation: Must update placeholder values for project specifics and maintain plugin compatibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n// used as `artifactId`\nname := \"library-example\"\n\n// used as `groupId`\norganization := \"ch.epfl.scala\"\n\n// open source licenses that apply to the project\nlicenses := Seq(\"APL2\" -> url(\"https://www.apache.org/licenses/LICENSE-2.0.txt\"))\n\ndescription := \"A library that does nothing useful\"\n\nimport xerial.sbt.Sonatype._\nsonatypeProjectHosting := Some(GitHubHosting(\"scalacenter\", \"library-example\", \"julien.richard-foy@epfl.ch\"))\n\n// publish to the sonatype repository\npublishTo := sonatypePublishToBundle.value\n```\n\n----------------------------------------\n\nTITLE: Creating and Inspecting a SeqView from a Scala Vector - Scala\nDESCRIPTION: Shows assigning a SeqView to variable `vv` by calling `.view` on a Vector. The resulting SeqView is a lazy sequence proxy that carries type information about the underlying collection (`Vector[Int]`). This step demonstrates accessing and working with lazy views explicitly before applying transformations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/views.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval vv = v.view\n```\n\n----------------------------------------\n\nTITLE: Utility Functions for Precomputing Parameters in AST Form in Macros (Scala)\nDESCRIPTION: Defines a helper method `precompute` inside a macro implementation that takes a tree representing a value and its type, stores a val definition for that value with a fresh name to ensure evaluation order, and returns an identifier referring to the fresh val. This pattern avoids repeated computations and allows inserting intermediate definitions within the macro-generated code. This method uses mutable ListBuffer and mechanisms to generate fresh names within the macro expansion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/overview.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval evals = ListBuffer[ValDef]()\ndef precompute(value: Tree, tpe: Type): Ident = {\n  val freshName = TermName(c.fresh(\"eval$\"))\n  evals += ValDef(Modifiers(), freshName, TypeTree(tpe), value)\n  Ident(freshName)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Map in Scala\nDESCRIPTION: Initializes a Map with state abbreviations as keys and full state names as values. This demonstrates the basic syntax for Map creation in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval states = Map(\n  \"AK\" -> \"Alaska\",\n  \"AL\" -> \"Alabama\", \n  \"AR\" -> \"Arizona\"\n)\n```\n\n----------------------------------------\n\nTITLE: Sharing Liftable Definitions Across Universes - Scala Trait Pattern\nDESCRIPTION: This snippet illustrates how to encapsulate liftable definitions in a trait that can be mixed into separate objects or classes for macro or runtime universes. The trait requires a universe value of type scala.reflect.api.Universe, ensuring compatibility. When used in macros, the context's universe is provided to the trait. This aids code reuse but requires managing universe paths and cannot share liftables directly across universes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/lifting.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.api.Universe\nimport scala.reflect.macros.blackbox.Context\n\ntrait LiftableImpls {\n  val universe: Universe\n  import universe._\n\n  implicit val liftPoint = Liftable[points.Point] { p =>\n    q\"_root_.points.Point(${p.x}, ${p.y})\"\n  }\n}\n\nobject RuntimeLiftableImpls extends LiftableImpls {\n  val universe: universe.type = universe\n}\n\ntrait MacroLiftableImpls extends LiftableImpls {\n  val c: Context\n  val universe: c.universe.type = c.universe\n}\n\n// macro impls defined as a bundle\nclass MyMacro(val c: Context) extends MacroLiftableImpls {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Rich Iterator Trait in Scala 3\nDESCRIPTION: A trait in Scala 3 syntax that extends AbsIterator and adds a foreach method to apply a function to each element in the iterator, using the 'do' keyword for the while loop.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/mixin-class-composition.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ntrait RichIterator extends AbsIterator:\n  def foreach(f: T => Unit): Unit = while hasNext do f(next())\n```\n\n----------------------------------------\n\nTITLE: Explicit vs. Implicit Type Declaration in Scala\nDESCRIPTION: Shows how variables can be declared with explicit type annotations or use Scala's type inference system to determine types implicitly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-vars-data-types.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval x: Int = 1   // 显式\nval x = 1        // 隐式的；编译器推断类型\n```\n\n----------------------------------------\n\nTITLE: 式の評価を行う関数（パターンマッチ実装）\nDESCRIPTION: Tree型の式を評価する関数。環境に基づき変数の値を取得し、木のノードに応じて演算や値の返却を行う。`match`式を用いてSum、Var、Constのケース毎に処理を分岐している。これにより、構造をパターンマッチで分解しながら計算可能。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tutorials/scala-for-java-programmers.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef eval(t: Tree, env: Environment): Int = t match {\n  case Sum(l, r) => eval(l, env) + eval(r, env)\n  case Var(n) => env(n)\n  case Const(v) => v\n}\n```\n\n----------------------------------------\n\nTITLE: Composing Scala ASTs using `reify` and `Expr.splice`\nDESCRIPTION: Demonstrates how to use `reify` to create an `Expr` (a typed AST wrapper) and `Expr.splice` to insert one reified tree into another. This example builds the AST for `println(2)` by splicing a reified `2` into a reified `println` expression.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\nscala> val x = reify(2)\nx: scala.reflect.runtime.universe.Expr[Int(2)] = Expr[Int(2)](2)\n\nscala> reify(println(x.splice))\nres1: scala.reflect.runtime.universe.Expr[Unit] = Expr[Unit](scala.this.Predef.println(2))\n```\n\n----------------------------------------\n\nTITLE: Serving Static Files with @cask.staticFiles Annotation in Scala 2\nDESCRIPTION: Scala 2 implementation of a Cask server that serves static files from a resources directory. The endpoint function specifies the file location, and the @cask.staticFiles annotation defines the URL path.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/web-server-static.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject Example extends cask.MainRoutes {\n  @cask.staticFiles(\"/static\")\n  def staticEndpoint(): String = \"src/main/resources\" // or \"resources\" if not using SBT\n\n  initialize()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating List of Lists of Trees for Splicing (Scala)\nDESCRIPTION: Initializes a `List[List[universe.Tree]]` (`argss`) representing arguments for a curried function, prepared for demonstrating `...$` splicing. This shows how to structure data for higher-rank splicing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/intro.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val argss = List(ab, List(c))\narglists: List[List[universe.Ident]] = List(List(a, b), List(c))\n```\n\n----------------------------------------\n\nTITLE: Using Methods with Inferred Context Parameters\nDESCRIPTION: Shows how to call a method with context parameters without explicitly providing the arguments, relying on the compiler to infer them from the available given/implicit values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-context-parameters.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nrenderWebsite(\"/home\")\n//                   ^\n//   again no argument\n```\n\n----------------------------------------\n\nTITLE: Using an Extension Method defined via an Implicit Value Class in Scala\nDESCRIPTION: Shows the invocation of the `toHexString` extension method on an `Int` literal (3). Because `RichInt` is an implicit value class, this call is typically optimized by the compiler to a static method call, avoiding the instantiation of a `RichInt` object at runtime.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n3.toHexString\n```\n\n----------------------------------------\n\nTITLE: Listing Compiled Class Files After Scala 2 Compilation (Bash)\nDESCRIPTION: This bash snippet lists generated files in the current directory after compiling Scala 2 source code with `scalac`. The output includes the bytecode `.class` files that represent the compiled Scala singleton object and its class. These files are ready to be executed on the JVM.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-hello-world.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ ls -1\nhello$.class\nhello.class\nhello.scala\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Expression Evaluation and Derivation in Scala 3 Main Program\nDESCRIPTION: Presents a Scala 3 @main method Calc for constructing an arithmetic expression, defining an environment mapping variables to integers, evaluating the expression, and computing symbolic derivatives with respect to x and y. It relies on the existence of Environment, eval, and derive, with Tree.* imported. The code illustrates simplified main definition and matching styles in Scala 3, printing results of each operation. Proper Tree structure and function implementations are required for full operation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_25\n\nLANGUAGE: Scala\nCODE:\n```\nimport Tree.*\n\n@main def Calc: Unit =\n  val exp: Tree = Sum(Sum(Var(\"x\"),Var(\"x\")),Sum(Const(7),Var(\"y\")))\n  val env: Environment = { case \"x\" => 5 case \"y\" => 7 }\n  println(\"Expression: \" + exp)\n  println(\"Evaluation with x=5, y=7: \" + eval(exp, env))\n  println(\"Derivative relative to x:\\n \" + derive(exp, \"x\"))\n  println(\"Derivative relative to y:\\n \" + derive(exp, \"y\"))\n```\n\n----------------------------------------\n\nTITLE: Obtain Symbol for a Type Using TypeRepr in Scala\nDESCRIPTION: Provides a simpler way to get the symbol for the definition of a type `T` by using `TypeRepr.of[T].typeSymbol` instead of the longer `TypeTree.of[T].tpe.typeSymbol`. This avoids unsafe or complicated traversals and is the recommended idiomatic approach in Scala 3 macros. Requires Scala 3 reflection API.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/best-practices.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nTypeTree.of[T].tpe.typeSymbol\n```\n\nLANGUAGE: scala\nCODE:\n```\nTypeRepr.of[T].typeSymbol\n```\n\n----------------------------------------\n\nTITLE: Implementing a Graph with Inner Classes in Scala\nDESCRIPTION: Defines a Graph class with an inner Node class where each node maintains a list of connected nodes. The connectTo method adds a node to the connections only if it is not already connected. Nodes are collected in the outer Graph's nodes list. This illustrates how inner classes are linked to an instance of the outer class in Scala, enforcing instance-specific associations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/inner-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Graph {\n  class Node {\n    var connectedNodes: List[Node] = Nil\n    def connectTo(node: Node): Unit = {\n      if (!connectedNodes.exists(node.equals)) {\n        connectedNodes = node :: connectedNodes\n      }\n    }\n  }\n  var nodes: List[Node] = Nil\n  def newNode: Node = {\n    val res = new Node\n    nodes = res :: nodes\n    res\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Calling Aliased Scala Methods from Java\nDESCRIPTION: Demonstrates Java code calling a Scala method using the alternate name ('add') provided via the `@targetName` annotation, instead of the original symbolic name ('+').\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/interacting-with-java.md#_snippet_5\n\nLANGUAGE: Java\nCODE:\n```\nint x = Adder.add(1,1);\nSystem.out.printf(\"x = %d\\n\", x);\n```\n\n----------------------------------------\n\nTITLE: パラメーターなし関数の定義と呼び出し - Scala\nDESCRIPTION: パラメーターを一切受け取らず定数値を返す無名関数の例です。空のパラメーターリスト()を与え、呼び出し時も()を付けて使用します。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval getTheAnswer = () => 42\nprintln(getTheAnswer()) // 42\n```\n\n----------------------------------------\n\nTITLE: Creating Integer Sequence in Scala\nDESCRIPTION: Defines an immutable sequence named `nums` containing integers 1, 2, and 3. This sequence is used in subsequent examples to demonstrate iteration. It uses the `Seq` collection type, which is a common linear collection in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/for-loops.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval nums = Seq(1,2,3)\n```\n\n----------------------------------------\n\nTITLE: Helper Function to Precompute Parameter Values into ValDefs Using Scala Reflection\nDESCRIPTION: Defines a helper method `precompute` that creates a fresh local val definition with a unique name, storing a given `Tree` value annotated with its `Type`. The method collects these vals into a mutable list buffer and returns identifiers referencing them. This supports evaluation and reuse of parameters in the generated AST.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/overview.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval evals = ListBuffer[ValDef]()\ndef precompute(value: Tree, tpe: Type): Ident = {\n  val freshName = TermName(c.fresh(\"eval$\"))\n  evals += ValDef(Modifiers(), freshName, TypeTree(tpe), value)\n  Ident(freshName)\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Named Arguments Usage in Scala\nDESCRIPTION: Demonstrates how to call methods using named arguments, which allows parameters to be specified in any order by explicitly naming them. Arguments are evaluated in call-site order.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-and-default-arguments.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef f[T](a: Int, b: T)\nf(b = getT(), a = getInt())\n```\n\n----------------------------------------\n\nTITLE: Caching function results using Scala mutable Map and getOrElseUpdate\nDESCRIPTION: Defines a cached version of the computationally expensive function `f` that first attempts to retrieve a cached result from `cache` using `getOrElseUpdate`. If the key is absent, it computes and stores the result atomically. This leverages lazy evaluation of the second argument to avoid unnecessary computation. Requires mutable collection support and previously defined `f` and `cache`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/maps.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef cachedF(s: String) = cache.getOrElseUpdate(s, f(s))\n```\n\n----------------------------------------\n\nTITLE: Set data structure in Python and Scala\nDESCRIPTION: Illustrates creation of a set of elements in Python and Scala, showing syntax and semantics. In Scala, sets are instantiated using 'Set()'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nx = {1, 2, 3}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval x = Set(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Defining Semigroup Type Class in Scala\nDESCRIPTION: Defines a basic Semigroup type class in Scala representing an associative binary operation on a type A. The trait requires implementers to provide the combine method defining the binary operation. This is a foundational building block for instances and generic derivation throughout the examples and does not depend on any external libraries.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Semigroup[A] {\n  def combine(x: A, y: A): A\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Compiled Class Files in Scala 3\nDESCRIPTION: Displays typical output of Scala 3 compiler's generated bytecode and intermediate files. The output includes '.class' files and '.tasty' files representing rich metadata for tooling support. Files 'hello$package$.class' and 'hello$package.class' indicate package-level objects generated by the Scala 3 compiler. This listing helps understand the differences in compilation artifacts between Scala 2 and Scala 3. The user runs 'ls -1' to observe these files.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-hello-world.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ ls -1\nhello$package$.class\nhello$package.class\nhello$package.tasty\nhello.scala\nhello.class\nhello.tasty\n```\n\n----------------------------------------\n\nTITLE: Iterating Over List Elements Using for Loop in Python\nDESCRIPTION: Shows two equivalent forms of Python for loops iterating over a list named 'ints', printing each element. Demonstrates standard iteration over list elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_17\n\nLANGUAGE: Python\nCODE:\n```\nfor i in ints: print(i)\n\nfor i in ints:\n  print(i)\n```\n\n----------------------------------------\n\nTITLE: Using Match Expressions with Conditional Guards in Scala 2\nDESCRIPTION: Demonstrates a match expression against the variable `count` using conditional guards `if` on cases to handle multiple conditions. It prints messages based on the value of `count` with detailed conditions for values 1, 2 or 3, values greater than 3, and a fallback default case. This example requires `count` as an integer input to the match and has no dependencies other than standard Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_35\n\nLANGUAGE: scala\nCODE:\n```\ncount match {\n  case 1 =>\n    println(\"one, a lonely number\")\n  case x if x == 2 || x == 3 => \n    println(\"two's company, three's a crowd\")\n  case x if x > 3 =>\n    println(\"4+, that's a party\")\n  case _ => \n    println(\"i'm guessing your number is zero or less\")\n}\n```\n\n----------------------------------------\n\nTITLE: Omitting Context Parameter Names in Scala 3 Method Signatures\nDESCRIPTION: This Scala 3 snippet shows how to omit the name of a context parameter in the method signature by specifying only its type after the `using` keyword, making the declaration more concise. This is a Scala 3 feature that is not available in Scala 2. The method still requires a context value of type `Config` to be in implicit scope during calls. The input is the path argument, and the output is an HTML string. This approach simplifies method signatures when the parameter name is not needed within the method body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/ca-context-parameters.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n//                нет необходимости придумывать имя параметра\n//                             vvvvvvvvvvvvv\ndef renderWebsite(path: String)(using Config): String =\n    \"<html>\" + renderWidget(List(\"cart\")) + \"</html>\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Function Value in Scala - Scala\nDESCRIPTION: Defines an immutable value 'square' as a function from Int to Int using a lambda expression in Scala. This assigns a function value to 'square' that takes an integer parameter 'x' and returns its square. It demonstrates function values as first-class citizens in Scala, enabling functional programming styles.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/FAQ/index.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval square: Int => Int = x => x * x\n```\n\n----------------------------------------\n\nTITLE: Defining a Liftable in a Macro Bundle - Scala\nDESCRIPTION: Shows the practical pattern of defining a Liftable instance for a custom type within a macro bundle class. Here, the Liftable must be declared for the macro universe provided by the current macro context. This instance enables automatic lifting of user types within macro quasiquotes. All dependencies, such as points.Point, must be imported and available in the macro class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/lifting.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.macros.blackbox.Context\n\n// macro impls defined as a macro bundle\nclass MyMacros(c: Context) {\n  import c.universe._\n\n  implicit val liftPoint = Liftable[points.Point] { p =>\n    q\"_root_.points.Point(${p.x}, ${p.y})\"\n  }\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Definición de parámetros por defecto en Scala para HashMap\nDESCRIPTION: Muestra cómo Scala implementa los valores por defecto directamente en la definición de parámetros, eliminando la necesidad de sobrecarga de constructores y simplificando el código.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/default-parameter-values.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass HashMap[K,V](initialCapacity:Int = 16, loadFactor:Float = 0.75) {\n}\n```\n\n----------------------------------------\n\nTITLE: Successful future failed projection in Scala\nDESCRIPTION: Creates a successful future and attempts to match it with the `failed` projection, which results in a failed future (`NoSuchElementException`). Demonstrates handling of non-failure futures with `failed`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_29\n\nLANGUAGE: Scala\nCODE:\n```\nval g = Future {\n  4 / 2\n}\nfor exc <- g.failed) println(exc)\n```\n\n----------------------------------------\n\nTITLE: Real-world Example of a Multi-line Method\nDESCRIPTION: Provides a practical example of a multi-line method that converts a Throwable to a formatted string, showing how to perform a sequence of operations in a method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/methods-most.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// Scala 2\ndef getStackTraceAsString(t: Throwable): String = {\n  val sw = new StringWriter()\n  t.printStackTrace(new PrintWriter(sw))\n  sw.toString\n}\n\n// Scala 3\ndef getStackTraceAsString(t: Throwable): String =\n  val sw = StringWriter()\n  t.printStackTrace(PrintWriter(sw))\n  sw.toString\n```\n\n----------------------------------------\n\nTITLE: Defining an Alias for Variable Environments as Functions in Scala\nDESCRIPTION: Introduces a type alias Entorno to represent variable environments as functions mapping variable names (String) to integer values (Int). This allows treating environments as functions to retrieve variable values by name, simplifying the evaluation function's implementation and enhancing code readability and maintainability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tutorials/scala-for-java-programmers.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ntype Entorno = String => Int\n```\n\n----------------------------------------\n\nTITLE: Single-line for Loop Over Collection in Scala\nDESCRIPTION: Preferred and available Scala syntax for iterating over collection ints with for-generator, printing each element. Demonstrates multiple syntactic forms for loops.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_40\n\nLANGUAGE: scala\nCODE:\n```\n//preferred\nfor i <- ints do println(i)\n\n// also available\nfor (i <- ints) println(i)\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Intersection Types in Scala 3 with Scala\nDESCRIPTION: This snippet demonstrates how to define two traits, `Resettable` and `Growable[A]`, and use them together as an intersection type parameter `Resettable & Growable[String]` in method `f`. The parameter `x` must implement both traits, allowing calls to both `reset()` and `add(\"first\")`. This showcases the capability of the `&` operator to enforce multiple trait requirements without creating an intermediary trait. No external dependencies are required beyond Scala 3. The expected input is any instance implementing both traits, and the output is the successful invocation of both trait methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-intersection.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Resettable:\n  def reset(): Unit\n\ntrait Growable[A]:\n  def add(a: A): Unit\n\ndef f(x: Resettable & Growable[String]): Unit =\n  x.reset()\n  x.add(\"first\")\n```\n\n----------------------------------------\n\nTITLE: Environment-Specific Tests Using Assumptions in Scala\nDESCRIPTION: Demonstrates how to create tests that run only under specific conditions using assume(). This example creates a test that runs only on Linux systems by checking Properties.isLinux.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-what-else.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.util.Properties\n\ntest(\"home directory\") {\n  assume(Properties.isLinux, \"this test runs only on Linux\")\n  assert(os.home.toString.startsWith(\"/home/\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Equivalent Separate Branch Pattern Matching in Scala\nDESCRIPTION: This snippet presents an alternative to merging multiple patterns into a single pattern with an or-pattern by splitting them into separate branches. Each branch explicitly matches a single constructor (Bar or Baz), allowing individual handling or type ascription. This form provides clarity and can help reduce ambiguity in type inference for bound variables. No external dependencies. Input is the same context as Foo from the previous snippet; output is the value captured by id in each branch. Applicable when fine-grained control over variable typing is needed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/alternative-bind-variables.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\ndef test = this match\n  case Bar(id: Int) => id\n  case Baz(id) => id\n```\n\n----------------------------------------\n\nTITLE: Extending Package Objects With Traits in Scala\nDESCRIPTION: This snippet shows how a package object can inherit from multiple traits (`FruitAliases` and `FruitHelpers`), allowing encapsulation of helper methods, type aliases, or implicit conversions within the package object. This modular composition pattern enhances the package object’s capabilities while maintaining a centralized definition point.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/package-objects.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\npackage object fruits extends FruitAliases with FruitHelpers {\n  // 헬퍼와 변수가 이곳에 따라온다\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering iterator elements with dropWhile\nDESCRIPTION: Uses dropWhile to skip elements that do not meet a predicate, e.g., words shorter than two characters. Shows that dropWhile modifies the iterator's position and that the resulting iterator shares the internal state, advancing it affects the original iterator.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/iterators.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval it = Iterator(\"a\", \"number\", \"of\", \"words\")\nval res4 = it.dropWhile(_.length < 2)\nprintln(res4.next())\n```\n\n----------------------------------------\n\nTITLE: Defining Pizza Functional Methods Using Implicit Class in Scala 2\nDESCRIPTION: Implements Pizza functional methods as extension methods on the Pizza type using an implicit class `PizzaOps`. This allows adding methods like price, addTopping, removeAllToppings, updateCrustSize, and updateCrustType without modifying the original Pizza class. Each method accesses the underlying Pizza instance `p` and returns immutable updates or price calculation. This pattern requires importing the implicit class to use these extension methods and enables retroactive enrichment of the Pizza API.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-fp.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ncase class Pizza(\n  crustSize: CrustSize,\n  crustType: CrustType,\n  toppings: Seq[Topping]\n)\n\nimplicit class PizzaOps(p: Pizza) {\n  def price: Double =\n    pizzaPrice(p) // такая же имплементация, как и выше\n\n  def addTopping(t: Topping): Pizza =\n    p.copy(toppings = p.toppings :+ t)\n\n  def removeAllToppings: Pizza =\n    p.copy(toppings = Seq.empty)\n\n  def updateCrustSize(cs: CrustSize): Pizza =\n    p.copy(crustSize = cs)\n\n  def updateCrustType(ct: CrustType): Pizza =\n    p.copy(crustType = ct)\n}\n```\n\n----------------------------------------\n\nTITLE: Example Scala Optimizer Inliner Log Output - Text\nDESCRIPTION: This snippet shows example output from the Scala compiler when compiled with the `-Vinline` flag and the optimizer enabled. It details which methods were inlined into the target method (`my/project/C.f`), the reason for inlining (e.g., `@inline`, higher-order method), and the approximate instruction count change.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/compiler-options/optimizer.md#_snippet_7\n\nLANGUAGE: Text\nCODE:\n```\nInlining into my/project/C.f\n inlined scala/Predef$.intArrayOps (the callee is annotated `@inline`). Before: 15 ins, after: 30 ins.\n inlined scala/collection/ArrayOps$.map$extension (the callee is a higher-order method, the argument for parameter (evidence$6: Function1) is a function literal). Before: 30 ins, after: 94 ins.\n  inlined scala/runtime/ScalaRunTime$.array_length (the callee is annotated `@inline`). Before: 94 ins, after: 110 ins.\n  [...]\n  rewrote invocations of closure allocated in my/project/C.f with body $anonfun$f$1: INVOKEINTERFACE scala/Function1.apply (Ljava/lang/Object;)Ljava/lang/Object; (itf)\n inlined my/project/C.$anonfun$f$1 (the callee is a synthetic forwarder method). Before: 654 ins, after: 666 ins.\n inlined scala/runtime/BoxesRunTime.boxToInteger (the callee is a forwarder method with boxing adaptation). Before: 666 ins, after: 674 ins.\n```\n\n----------------------------------------\n\nTITLE: Single-Line while Loop in Scala 2\nDESCRIPTION: Shows Scala 2 single-line while loop syntax executing function f(x) while condition (x >= 0) is true. Demonstrates compact loop form with conditions and body in one line. Input is variable 'x'; output depends on function 'f'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_25\n\nLANGUAGE: Scala\nCODE:\n```\nwhile (x >= 0) { x = f(x) }\n```\n\n----------------------------------------\n\nTITLE: Instance Usage and State Change in Counter (Scala 2)\nDESCRIPTION: This code snippet demonstrates creating a Counter instance, retrieving its count, mutating its state using tick, and observing the updated count. It illustrates encapsulation and mutable state via private fields. No dependencies beyond the Counter definition are required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nval c1 = new Counter()\nc1.count // 0\nc1.tick()\nc1.tick()\nc1.count // 2\n```\n\n----------------------------------------\n\nTITLE: Creating a Tuple with Mixed Types in Scala 2 and 3\nDESCRIPTION: Shows how to create a tuple containing an integer, a string, and a custom Person instance. The tuple groups heterogeneous types in a single container supporting fixed length and positional access, useful for coordinated but distinct data elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-collections.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval t = (11, \"eleven\", Person(\"Eleven\"))\n```\n\n----------------------------------------\n\nTITLE: Adding Scala Toolkit Dependency in Mill Build File - Scala\nDESCRIPTION: This example demonstrates configuring the Scala Toolkit as a dependency in a Mill build file ('build.sc'). It defines a Scala module named 'example', sets the Scala version to '3.4.2', and adds the toolkit version '0.7.0' to the module's dependencies via 'ivyDeps'. The snippet requires Mill and uses the 'Agg' constructor to aggregate dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-os-lib.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nobject example extends ScalaModule {\n  def scalaVersion = \"3.4.2\"\n  def ivyDeps =\n    Agg(\n      ivy\"org.scala-lang::toolkit:0.7.0\"\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: String Interpolation in Scala\nDESCRIPTION: Shows how to use string interpolation with the 's' prefix to embed variables directly in strings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-vars-data-types.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval firstName = \"John\"\nval mi = 'C'\nval lastName = \"Doe\"\n\nprintln(s\"Name: $firstName $mi $lastName\")   // \"Name: John C Doe\"\n```\n\n----------------------------------------\n\nTITLE: Объявление отношений подтипов в Scala 2 и 3\nDESCRIPTION: Выражение подтиповых отношений между типами Book, Buyable и Item демонстрирует, что Book является подтипом Buyable, а Buyable — подтипом Item. Этот факт служит основой для объяснения ограничений и возможностей вариантности в параметризованных типах.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-variance.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nBook <: Buyable <: Item\n```\n\n----------------------------------------\n\nTITLE: Specifying Scala Version in Page Metadata - YAML\nDESCRIPTION: Shows how to mark documentation pages as version-specific in YAML front matter for Jekyll. The snippet can be used to indicate that a given Markdown file is specific to either Scala 2 or Scala 3 by setting 'scala2: true' or 'scala3: true', with 'versionSpecific: true' to flag the scope. No parameters are required; keys are boolean flags. This impacts how code blocks are presented and signals the version specificity of the page.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/add-guides.md#_snippet_5\n\nLANGUAGE: YAML\nCODE:\n```\nscala3: true\nversionSpecific: true\n```\n\nLANGUAGE: YAML\nCODE:\n```\nscala2: true\nversionSpecific: true\n```\n\n----------------------------------------\n\nTITLE: Creating Scala Literal AST Nodes Using scala.reflect.runtime.universe - Scala\nDESCRIPTION: Demonstrates constructing a Scala AST node representing a literal integer constant using scala.reflect.runtime.universe's Literal and Constant classes. Shows how the Scala compiler evaluates certain expressions as compile-time constants and represents them as reflection literals.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/annotations-names-scopes.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nscala> Literal(Constant(5))\nval res6: reflect.runtime.universe.Literal = 5\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Java Annotation Interface\nDESCRIPTION: This Java code snippet defines a custom annotation interface '@Source' with two elements: 'URL' and 'mail', both of type String. These elements represent name-value pairs required when applying the annotation. The interface uses the '@interface' syntax introduced in Java 1.5 to declare user-defined annotations. There are no default values specified, hence both elements must be provided upon annotation usage. This snippet can be used as a metadata descriptor for classes or other program elements and requires Java 1.5 or higher.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/annotations.md#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\n@interface Source {\n  public String URL();\n  public String mail();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Compiler Plugins in SBT Build Files - Scala\nDESCRIPTION: Shows how to add the 'kind-projector' compiler plugin using both libraryDependencies and addCompilerPlugin in an SBT build file. Requires SBT build system and access to build.sbt. Key parameters include the plugin coordinates, Scala version, and compatibility via CrossVersion.full. Inputs are the configuration lines; output is that the specified compiler plugin is available during compilation. Note: Plugin compatibility with Scala 3 must be verified since some plugins may not have a Scala 3 equivalent.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-prerequisites.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n// build.sbt\nlibraryDependencies +=\n  compilerPlugin(\"org.typelevel\" %% \"kind-projector\" % \"0.11.0\" cross CrossVersion.full)\n\naddCompilerPlugin(\"org.typelevel\" %% \"kind-projector\" % \"0.11.0\" cross CrossVersion.full)\n```\n\n----------------------------------------\n\nTITLE: Creating Scala Parallel Collections by Instantiation and Conversion\nDESCRIPTION: Explains two methods for creating parallel collections in Scala: directly instantiating a parallel collection type (e.g., ParVector) using the `new` keyword with an appropriate import, and converting an existing sequential collection into a parallel one by calling `.par` on it. Both methods produce parallel collection instances which support parallel operations transparently. This snippet requires importing the parallel collection class for instantiation or using `.par` conversion on standard collections. Inputs vary between empty initialization and sequential collection instances, outputs are parallel collection instances. It highlights the seamless interoperability and uniform API usage in parallel collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/overviews/parallel-collections/overview.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.parallel.immutable.ParVector\nval pv = new ParVector[Int]\n```\n\nLANGUAGE: scala\nCODE:\n```\nval pv = Vector(1,2,3,4,5,6,7,8,9).par\n```\n\n----------------------------------------\n\nTITLE: Implementing PrefixMap Companion Object in Scala\nDESCRIPTION: Companion object for the PrefixMap class that provides factory methods and a CanBuildFrom implicit to ensure proper type preservation for transformations like map.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-collections.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable.{Builder, MapBuilder}\nimport scala.collection.generic.CanBuildFrom\n\nobject PrefixMap extends {\n  def empty[T] = new PrefixMap[T]\n\n  def apply[T](kvs: (String, T)*): PrefixMap[T] = {\n    val m: PrefixMap[T] = empty\n    for (kv <- kvs) m += kv\n    m\n  }\n\n  def newBuilder[T]: Builder[(String, T), PrefixMap[T]] =\n    new MapBuilder[String, T, PrefixMap[T]](empty)\n\n  implicit def canBuildFrom[T]\n    : CanBuildFrom[PrefixMap[_], (String, T), PrefixMap[T]] =\n      new CanBuildFrom[PrefixMap[_], (String, T), PrefixMap[T]] {\n        def apply(from: PrefixMap[_]) = newBuilder[T]\n        def apply() = newBuilder[T]\n      }\n}\n```\n\n----------------------------------------\n\nTITLE: Cross-Building for Multiple Scala Versions - Scala\nDESCRIPTION: These Scala sbt settings configure cross-version compilation by specifying supported Scala versions in crossScalaVersions and setting the default scalaVersion. Require sbt and a compatible Scala project. crossScalaVersions should list all versions to be built; CI jobs will use this setting to build and test the library against all specified versions. Outputs are published artifacts for each Scala version listed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ncrossScalaVersions := Seq(\"3.3.0\", \"2.13.12\", \"2.12.18\")\nscalaVersion := crossScalaVersions.value.head\n```\n\n----------------------------------------\n\nTITLE: Filtering List Elements in Scala\nDESCRIPTION: Illustrates the `filter` method, which creates a new sequence consisting only of elements from the original sequence that satisfy a given predicate function (return true). Examples show filtering numbers based on value and parity, and filtering strings based on length.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/collections-methods.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval lessThanFive = nums.filter(_ < 5)\nval evens = nums.filter(_ % 2 == 0)\nval shortNames = names.filter(_.length <= 4)\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Class with Auxiliary Constructors\nDESCRIPTION: Defines a `Pizza` class in Scala demonstrating the use of a primary constructor and three auxiliary constructors (`def this`). Each auxiliary constructor calls another constructor (`this(...)`), showcasing the required chaining. Includes companion default values for crust size and type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/classes-aux-constructors.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval DefaultCrustSize = 12\nval DefaultCrustType = \"THIN\"\n\n// the primary constructor\nclass Pizza (var crustSize: Int, var crustType: String) {\n\n    // one-arg auxiliary constructor\n    def this(crustSize: Int) = {\n        this(crustSize, DefaultCrustType)\n    }\n\n    // one-arg auxiliary constructor\n    def this(crustType: String) = {\n        this(DefaultCrustSize, crustType)\n    }\n\n    // zero-arg auxiliary constructor\n    def this() = {\n        this(DefaultCrustSize, DefaultCrustType)\n    }\n\n    override def toString = s\"A $crustSize inch pizza with a $crustType crust\"\n\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Forwarders by @unroll for Secondary Constructors in Scala\nDESCRIPTION: Illustrates the generated secondary constructors resulting from applying `@unroll` to another secondary constructor. These new constructors maintain binary compatibility by calling the annotated secondary constructor with appropriate default values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/unroll-default-arguments.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nclass Unrolled() {\n   var foo = \"\"\n\n   def this(s: String, n: Int = 1, @unroll b: Boolean = true, @unroll l: Long = 0) = {\n      this()\n      foo = s + n + b + l\n   }\n\n   def this(s: String, n: Int, b: Boolean) = this(s, n, b, 0)\n   def this(s: String, n: Int) = this(s, n, true, 0)\n}\n```\n\n----------------------------------------\n\nTITLE: Representing Empty Parts with Quasiquotes - Scala\nDESCRIPTION: Explains the usage of the empty quasiquote `q\"\"` to signify unprovided parts in an AST, such as missing right-hand sides for `Val`, `Var`, `Def`, absent bounds in abstract types, missing `finally` clauses in `Try`, or guards in `Case` clauses. Its default string representation is `<empty>`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nq\"\"\n```\n\n----------------------------------------\n\nTITLE: Reporting warnings and errors within Scala Macros via reflect.macros.FrontEnds\nDESCRIPTION: This snippet explains how to use the macro context methods such as c.error, c.warning, and c.abort to report errors and warnings during macro expansion. It illustrates that errors terminate macro expansion, whereas warnings issue notices, and highlights current limitations like only one warning/error per position.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/overview.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nscala> def impl(c: Context) =\n  c.abort(c.enclosingPosition, \"macro has reported an error\")\nimpl: (c: scala.reflect.macros.Context)Nothing\n\nscala> def test = macro impl\ndefined term macro test: Any\n\nscala> test\n<console>:32: error: macro has reported an error\n              test\n              ^\n```\n\n----------------------------------------\n\nTITLE: Using the 'copy' Method in Scala Case Classes\nDESCRIPTION: Defines a 'BaseballTeam' case class and demonstrates how to use the automatically generated 'copy' method. It creates an initial instance ('cubs1908') and then creates a new instance ('cubs2016') by copying the first one while modifying the 'lastWorldSeriesWin' field. This is a common pattern in functional programming for \"updating\" immutable objects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/case-classes.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nscala> case class BaseballTeam(name: String, lastWorldSeriesWin: Int)\ndefined class BaseballTeam\n\nscala> val cubs1908 = BaseballTeam(\"Chicago Cubs\", 1908)\ncubs1908: BaseballTeam = BaseballTeam(Chicago Cubs,1908)\n\nscala> val cubs2016 = cubs1908.copy(lastWorldSeriesWin = 2016)\ncubs2016: BaseballTeam = BaseballTeam(Chicago Cubs,2016)\n```\n\n----------------------------------------\n\nTITLE: Defining a Module for Numerical Expressions with Abstract Number Type\nDESCRIPTION: Creates a trait that abstracts over the internal representation of numbers, providing operations like literal creation, addition, and multiplication.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-dependent-function.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ntrait Nums:\n  // the type of numbers is left abstract\n  type Num\n\n  // some operations on numbers\n  def lit(d: Double): Num\n  def add(l: Num, r: Num): Num\n  def mul(l: Num, r: Num): Num\n```\n\n----------------------------------------\n\nTITLE: Matching Quoted Types with Nested Type Variables (Old Syntax) - Scala\nDESCRIPTION: Presents the original syntax for matching quoted types in Scala. It shows how nested type variables (`t`) are introduced implicitly and used within the type pattern, noting the limitation that explicit definitions and bounds were not supported in the source syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/quote-pattern-type-variable-syntax.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ncase '[ t ] => f[t]\ncase '[ List[t] ] => g[t]\n```\n\n----------------------------------------\n\nTITLE: Accessing Private Methods Across Classes and Companion Objects in Scala\nDESCRIPTION: Demonstrates how Scala allows private method access in companion objects but compiles these accesses as public in bytecode by 'mangling' the method name. The 'm' method can be inlined more broadly as a result, but this introduces potential binary compatibility issues if used across library versions. The snippet requires no external dependencies and expects a 'C' instance to access the mangled method; outputs depend on usage context. This highlights limitations and bytecode realities underpinning inlining decisions in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/compiler-options/optimizer.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass C {\n  private def x = 0\n  @inline final def m: Int = x\n}\nobject C {\n  def t(c: C) = c.x\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Scala Compiler Options in sbt Build Tool - Scala\nDESCRIPTION: Shows a typical sbt build configuration snippet for setting Scala compiler options using the `scalacOptions` setting. It uses the `++=` operator to append options as a Scala sequence, each option supplied as a string. This snippet demonstrates options like setting encoding, enabling feature warnings, language imports, and treating warnings as errors. The example uses one option per line and ends the list with a trailing comma for easier maintenance and git diff clarity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/compiler-options/index.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nscalacOptions ++= Seq(          // use ++= to add to existing options\n  \"-encoding\", \"utf8\",          // if an option takes an arg, supply it on the same line\n  \"-feature\",                   // then put the next option on a new line for easy editing\n  \"-language:implicitConversions\",\n  \"-language:existentials\",\n  \"-unchecked\",\n  \"-Werror\",\n  \"-Xlint\",                     // exploit \"trailing comma\" syntax so you can add an option without editing this line\n)\n```\n\n----------------------------------------\n\nTITLE: Continuous Documentation Deployment Workflow - YAML\nDESCRIPTION: Defines a GitHub Actions workflow job for automated documentation publishing to GitHub Pages. It sets up checkout, installs Java, generates the site with sbt, and deploys with github-pages-deploy-action. Requires GitHub Actions, access permissions, and correct branches. Inputs: repository state, outputs: published site on gh-pages branch. Limitation: Must be integrated with repository secrets for deploy action.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_20\n\nLANGUAGE: yaml\nCODE:\n```\n# .github/workflows/publish.yml\nname: Continuous publication\n\njobs:\n  release: # The release job is not changed, you can find it above\n  publishSite:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n      - uses: actions/setup-java@v3\n        with:\n          distribution: temurin\n          java-version: 8\n          cache: sbt\n      - name: Generate site\n        run: sbt makeSite\n      - uses: JamesIves/github-pages-deploy-action@4.1.3\n        with:\n          branch: gh-pages\n          folder: target/site\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Macro Expansion in Scala Macros (Scala)\nDESCRIPTION: Defines a simple macro in Scala 2.10.x/2.11.0 that returns a new object with a 'val x = 2'. Requires 'scala-reflect' and an enabled macro paradise plugin for quasiquotes on Scala 2.10.x. No explicit whitebox or blackbox context is specified, making it whitebox by default in 2.10.x; in 2.11.0 it depends on the macro def. The expanded value is returned without type ascription, which affects compatibility for blackbox macros.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/changelog211.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject Macros {\n  def impl(c: Context) = {\n    import c.universe._\n    q\"new { val x = 2 }\"\n  }\n\n  def foo: Any = macro impl\n}\n\nobject Test extends App {\n  // works in Scala 2.10.x and Scala 2.11.0 if foo is whitebox\n  // doesn't work in Scala 2.11.0 if foo is blackbox\n  println(Macros.foo.x)\n}\n```\n\n----------------------------------------\n\nTITLE: Interactive Hello World Program in Scala 2 with User Input\nDESCRIPTION: Defines a singleton object `helloInteractive` with a `main` method that prompts the user to enter their name via the command line, reads the input using `readLine`, and then prints a personalized greeting. The program demonstrates reading from STDIN, string concatenation, and output to STDOUT. Requires importing `scala.io.StdIn.readLine`. The `args` parameter is unused. Input is a line of text entered by the user; output is a greeting message. This shows a typical command-line interaction in Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-hello-world.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.io.StdIn.readLine\n\nobject helloInteractive {\n\n  def main(args: Array[String]) = {\n    println(\"Please enter your name:\")\n    val name = readLine()\n\n    println(\"Hello, \" + name + \"!\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining filter and map in IterableOps Trait - Scala 2\nDESCRIPTION: This trait defines core operations for iterable collections, providing abstracted versions of filter and map using view-based (non-strict) evaluation. It delegates the actual collection construction to fromSpecific and from, which must be implemented in concrete collections. Key parameters include the predicate for filtering (pred: A => Boolean) and a transformation function for mapping (f: A => B). Dependencies: Requires View.Filter, View.Map, and the presence of fromSpecific and from.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\ntrait IterableOps[+A, +CC[_], +C] {\n\n  def filter(pred: A => Boolean): C =\n    fromSpecific(new View.Filter(this, pred))\n\n  def map[B](f: A => B): CC[B] = \n    from(new View.Map(this, f))\n\n  protected def fromSpecific(coll: IterableOnce[A]): C\n  protected def from[E](it: IterableOnce[E]): CC[E]\n}\n```\n\n----------------------------------------\n\nTITLE: Sending POST Request with Binary Body in Scala\nDESCRIPTION: This snippet shows how to send a POST request with binary data (byte array) as the body. The example works for both Scala 2 and 3, demonstrating how to convert a string to bytes and use it as the request body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/http-client-request-body.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval bytes: Array[Byte] = \"john\".getBytes\nval request = quickRequest.post(uri\"https://example.com/\").body(bytes)\n```\n\n----------------------------------------\n\nTITLE: Creating Lists in Scala\nDESCRIPTION: Demonstrates how to create Lists in Scala, including initialization with values and using the cons (::) operator with Nil.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval ints = List(1, 2, 3)\nval names = List(\"Joel\", \"Chris\", \"Ed\")\n\n// another way to construct a List\nval namesAgain = \"Joel\" :: \"Chris\" :: \"Ed\" :: Nil\n```\n\n----------------------------------------\n\nTITLE: Illustrating Explicit ArrayOps Conversion via intArrayOps (REPL)\nDESCRIPTION: Demonstrates the underlying mechanism for direct sequence method calls on arrays by explicitly using the 'intArrayOps' implicit conversion function (from Predef). This achieves the same result as the direct call 'a1.reverse', highlighting how ArrayOps is automatically applied.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/arrays.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nscala> intArrayOps(a1).reverse\nres5: Array[Int] = Array(3, 2, 1)\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Dependencies with Maven in XML\nDESCRIPTION: This example presents a pom.xml configuration for managing Scala dependencies in a Maven project. It defines project metadata, encodings, Java and Scala versions, explicit dependencies for Scala library and sttp modules, and configures the Scala Maven Plugin. The configuration requires Maven and the Scala Maven Plugin. The input is the XML build definition; output is a Maven-configured build capable of processing Scala code with defined dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/drop-stdlib-forwards-bin-compat.md#_snippet_6\n\nLANGUAGE: XML\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n   <modelVersion>4.0.0</modelVersion>\n   <groupId>a.b</groupId>\n   <artifactId>proj</artifactId>\n   <version>1.0.0-SNAPSHOT</version>\n   <properties>\n      <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n      <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n      <java.version>1.8</java.version>\n      <scala.version>2.13.8</scala.version>\n   </properties>\n   <dependencies>\n      <dependency>\n         <groupId>org.scala-lang</groupId>\n         <artifactId>scala-library</artifactId>\n         <version>${scala.version}</version>\n      </dependency>\n      <dependency>\n         <groupId>com.softwaremill.sttp.client3</groupId>\n         <artifactId>core_2.13</artifactId>\n         <version>3.8.3</version>\n      </dependency>\n      <dependency>\n         <groupId>com.softwaremill.sttp.shared</groupId>\n         <artifactId>ws_2.13</artifactId>\n         <version>1.2.7</version>\n      </dependency>\n   </dependencies>\n   <build>\n      <plugins>\n         <plugin>\n            <groupId>net.alchim31.maven</groupId>\n            <artifactId>scala-maven-plugin</artifactId>\n            <version>4.8.0</version>\n         </plugin>\n      </plugins>\n   </build>\n</project>\n```\n\n----------------------------------------\n\nTITLE: Marking a Snippet Expected to Fail Compilation (Markdown/Scala)\nDESCRIPTION: Shows how to use the `sc:fail` flag in a Markdown code block definition to indicate that the enclosed Scala snippet is intentionally written to cause a compilation error. Scaladoc will verify that compilation actually fails.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/snippet-compiler.md#_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n```scala sc:fail\nList(1,2,3).toMap\n```\n```\n\n----------------------------------------\n\nTITLE: Executing Scala-CLI General Command Syntax (Shell)\nDESCRIPTION: Illustrates the standard command-line syntax for the `scala-cli` tool. It shows the typical ordering of command, options, inputs (like file paths or snippets), and how program arguments are passed after a `--` separator. This syntax allows flexible mixing of options and inputs before the program arguments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/scala-cli.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nscala-cli [command] [scala_cli_options | input]... -- [program_arguments]...\n```\n\n----------------------------------------\n\nTITLE: Using Custom Boolean Operators to Define 'not' and 'xor' Functions in Scala 2 and 3\nDESCRIPTION: Defines a 'not' function that negates a MyBool instance and an 'xor' function implementing exclusive or logic using the custom defined 'and', 'or', and 'negate' methods. Utilizes infix notation for readability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/operators.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef not(x: MyBool) = x.negate\ndef xor(x: MyBool, y: MyBool) = (x or y) and not(x and y)\n```\n\n----------------------------------------\n\nTITLE: Adding elements to mutable Map in Scala\nDESCRIPTION: Shows different ways to add elements to a mutable Map: a single element using '+=' with a tuple, multiple elements using '+=' with multiple tuples, and multiple elements from another Map using '++='. The Map must be mutable for these operations. Input is new key-value pairs, output is the updated Map reflecting the insertions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/map-class.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nstates += (\"AL\" -> \"Alabama\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nstates += (\"AR\" -> \"Arkansas\", \"AZ\" -> \"Arizona\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nstates ++= Map(\"CA\" -> \"California\", \"CO\" -> \"Colorado\")\n```\n\n----------------------------------------\n\nTITLE: Using ConcreteDirectedGraph to Create and Connect Nodes in Scala\nDESCRIPTION: Defines a function graphTest that instantiates a ConcreteDirectedGraph, adds three nodes via addNode, and connects nodes via connectWith. This example demonstrates practical usage of the scalable graph implementation with explicit self-types, showcasing node creation and edge formation via the described classes and methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/self-types.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef graphTest: Unit = {\n  val g: Graph = new ConcreteDirectedGraph\n  val n1 = g.addNode\n  val n2 = g.addNode\n  val n3 = g.addNode\n  n1.connectWith(n2)\n  n2.connectWith(n3)\n  n1.connectWith(n3)\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring and Implementing TraversableLike Trait in Scala\nDESCRIPTION: Defines the TraversableLike trait, which abstracts common traversal and transformation logic for Scala collections. It contains two essential abstract methods, newBuilder and foreach, and provides a generic filter implementation that constructs a new collection of the same representation type using these methods. Dependencies include the existence of a Builder type, and the trait is designed to be inherited by concrete collection types. The filter method accepts a predicate and returns a new collection, preserving type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-collections.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\npackage scala.collection\n\ntrait TraversableLike[+Elem, +Repr] {\n  def newBuilder: Builder[Elem, Repr] // deferred\n  def foreach[U](f: Elem => U): Unit  // deferred\n          ...\n  def filter(p: Elem => Boolean): Repr = {\n    val b = newBuilder\n    foreach { elem => if (p(elem)) b += elem }\n    b.result\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Reflecting Instance Fields Using FieldMirror - Scala\nDESCRIPTION: Demonstrates how to reflectively access and set instance fields 'x' (val) and 'y' (var) using Scala's reflection FieldMirror functionality. Requires a defined class with fields, a runtime mirror, and an InstanceMirror. Allows getting and setting field values dynamically; setting is only possible on vars.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/environment-universes-mirrors.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass C { val x = 2; var y = 3 }\nval m = ru.runtimeMirror(getClass.getClassLoader)\nval im = m.reflect(new C)\nval fieldX = ru.typeOf[C].decl(ru.TermName(\"x\")).asTerm.accessed.asTerm\nval fmX = im.reflectField(fieldX)\nfmX.get\nfmX.set(3)\nval fieldY = ru.typeOf[C].decl(ru.TermName(\"y\")).asTerm.accessed.asTerm\nval fmY = im.reflectField(fieldY)\nfmY.get\nfmY.set(4)\nfmY.get\n```\n\n----------------------------------------\n\nTITLE: Triggering Implicit Resolution for `Foo` Type Class (Scala)\nDESCRIPTION: Demonstrates calls to `implicitly` to resolve instances of the `Foo` type class for `C`, `B`, and `A`. Under the divergence checking rules prior to this SIP, resolving `Foo[C]` succeeds, while attempts to resolve `Foo[B]` and `Foo[A]` result in divergence, motivating the proposed changes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nimplicitly[Foo[C]] // OK\nimplicitly[Foo[B]] // Diverges\nimplicitly[Foo[A]] // Diverges\n```\n\n----------------------------------------\n\nTITLE: Displaying sbt test output for ScalaTest BDD-style tests\nDESCRIPTION: This snippet shows example output from running sbt test which executes both previously defined tests and the new MathUtilsSpec BDD tests. It details test names, status indicators, counts of succeeded, failed, canceled, ignored, and pending tests, and summarizes total tests and suite results. This output confirms successful execution of tests and highlights the visibility of pending tests within the sbt reporting framework. No dependencies other than sbt and ScalaTest are applicable to interpreting this output. Input is the set of ScalaTest test classes; output is the formatted test results shown by sbt.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/sbt-scalatest-bdd.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n> sbt test\n\n[info] HelloTests:\n[info] - the name is set correctly in constructor\n[info] - a Person's name can be changed\n[info] MathUtilsSpec:\n[info] MathUtils::double\n[info] - should handle 0 as input\n[info] - should handle 1\n[info] - should handle really large integers (pending)\n[info] Total number of tests run: 4\n[info] Suites: completed 2, aborted 0\n[info] Tests: succeeded 4, failed 0, canceled 0, ignored 0, pending 1\n[info] All tests passed.\n[success] Total time: 4 s\n```\n\n----------------------------------------\n\nTITLE: Instantiating a Scala Case Class Without new Keyword\nDESCRIPTION: Demonstrates how to instantiate a case class object without using the 'new' keyword, highlighting Scala's convenience in concise object creation. The snippet creates an instance of Email case class with concrete string values to represent the source email, title, and body of a message.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/case-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval emailFromJohn = Email(\"john.doe@mail.com\", \"Greetings From John!\", \"Hello World!\")\n```\n\n----------------------------------------\n\nTITLE: Traversing Tree Nodes with Pattern Matching (Binding)\nDESCRIPTION: Illustrates basic tree traversal using pattern matching. It matches against the `Apply` node of a simple tree (`x.$plus(2)`) and binds the function part (`fn`) and argument list (`a`) to variables using a `case` clause, allowing extraction of these components.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/reflection/symbols-trees-types.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n\nval tree = Apply(Select(Ident(TermName(\"x\")), TermName(\"$plus\")), List(Literal(Constant(2))))\n\nval (fun, arg) = tree match {\n     case Apply(fn, a :: Nil) => (fn, a)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Observer Pattern Components in Scala 2\nDESCRIPTION: This code defines the SensorReader singleton object by extending the SubjectObserver trait, concretizing type members S to Sensor and O to Display. Sensor implements Subject and maintains a private state updated and published through changeValue, while Display implements Observer and prints notifications. Dependencies: SubjectObserver, Subject, and Observer traits must be defined elsewhere. Sensor instances represent observable data sources, and Display instances observe and handle updates. Inputs: label for Sensor; Display has none. Outputs are printed messages on updates. Constraints: Assumes functional SubjectObserver framework is present.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-oop.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nobject SensorReader extends SubjectObserver {\n  type S = Sensor\n  type O = Display\n\n  class Sensor(val label: String) extends Subject {\n    private var currentValue = 0.0\n    def value = currentValue\n    def changeValue(v: Double) = {\n      currentValue = v\n      publish()\n    }\n  }\n\n  class Display extends Observer {\n    def notify(sub: Sensor) =\n      println(s\"${sub.label} has value ${sub.value}\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Graph with Inner Nodes Using Path-Dependent Types in Scala 3\nDESCRIPTION: The Scala 3 counterpart of the Graph class that defines an inner Node class. This snippet uses Scala 3's significant indentation syntax and expression-oriented style. Nodes maintain connections only with nodes from the same Graph instance, preserving type safety by leveraging path-dependent types. The implementation includes a newNode method to instantiate nodes and manage the graph's node collection. It requires Scala 3 environment compatibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/inner-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass Graph:\n  class Node:\n    var connectedNodes: List[Node] = Nil\n    def connectTo(node: Node): Unit =\n      if !connectedNodes.exists(node.equals) then\n        connectedNodes = node :: connectedNodes\n\n  var nodes: List[Node] = Nil\n  def newNode: Node =\n    val res = Node()\n    nodes = res :: nodes\n    res\n```\n\n----------------------------------------\n\nTITLE: Extending Scala 3 Enum 'Color' from Java's 'java.lang.Enum'\nDESCRIPTION: Illustrates creating a Scala 3 enum 'Color' that extends Java's 'Enum' class for interoperability, allowing the Scala enum to be used in Java contexts as a Java enum.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\nenum Color extends Enum[Color] { case Red, Green, Blue }\n```\n\n----------------------------------------\n\nTITLE: 計算式の実行 - Scala\nDESCRIPTION: Scalaの式の基本的な計算例を示しています。簡単な算術計算と文字列連結の結果を標準出力に表示します。依存関係は特になく、Scala REPL等で即座に動作確認できます。結果は画面にプリントされる標準出力です。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n1 + 1\n```\n\n----------------------------------------\n\nTITLE: Verifying GraalVM Java Version\nDESCRIPTION: Executes the 'java -version' command to display the currently active Java Virtual Machine (JVM) version. This step verifies that the GraalVM environment has been correctly configured and is the active Java runtime. The example output confirms GraalVM CE is being used.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-on-android.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n> java -version\nopenjdk version \"11.0.10\" 2021-01-19\nOpenJDK Runtime Environment GraalVM CE 21.0.0 (build 11.0.10+8-jvmci-21.0-b06)\nOpenJDK 64-Bit Server VM GraalVM CE 21.0.0 (build 11.0.10+8-jvmci-21.0-b06, mixed mode, sharing)\n```\n\n----------------------------------------\n\nTITLE: Defining Class and Fruit Objects in Scala 2 and 3\nDESCRIPTION: Defines a case class `Fruit` and three Fruit objects representing different fruit types. This snippet serves as the base domain model used in subsequent package-level definitions. It includes a constructor with parameters `name` and `color` and singleton objects for specific fruit instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/package-objects.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\npackage gardening.fruits\n\ncase class Fruit(name: String, color: String)\nobject Apple extends Fruit(\"Apple\", \"green\")\nobject Plum extends Fruit(\"Plum\", \"blue\")\nobject Banana extends Fruit(\"Banana\", \"yellow\")\n```\n\n----------------------------------------\n\nTITLE: Explicitly Typed Graph Usage in Scala\nDESCRIPTION: Same graph example but with explicit type annotations, showing how node types are prefixed by their outer instance. This demonstrates how Scala's type system binds inner class instances to their specific outer object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/inner-classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef graphTest: Unit = {\n  val g: Graph = new Graph\n  val n1: g.Node = g.newNode\n  val n2: g.Node = g.newNode\n  val n3: g.Node = g.newNode\n  n1.connectTo(n2)\n  n3.connectTo(n1)\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Ambiguity Between Named Arguments and Assignments\nDESCRIPTION: Demonstrates how Scala treats expressions that could be either named arguments or variable assignments. When ambiguous, additional parentheses or braces can clarify that an expression is an assignment.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-and-default-arguments.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef twice(op: => Unit) = { op; op }\nvar x = 1\ntwice(x = x + 1)\n```\n\n----------------------------------------\n\nTITLE: Looping Over a Vector in Scala 3 REPL\nDESCRIPTION: Demonstrates initializing a `Vector` and iterating over it using the Scala 3 `for` loop syntax (`do` keyword, optional parentheses) within the REPL, printing each element.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nscala> val names = Vector(\"Joel\", \"Chris\", \"Ed\")\nval names: Vector[String] = Vector(Joel, Chris, Ed)\n\nscala> for name <- names do println(name)\nJoel\nChris\nEd\n```\n\n----------------------------------------\n\nTITLE: Using Right-Ignoring Sequence Patterns with '_*' Wildcard in Scala\nDESCRIPTION: This snippet demonstrates how to use sequence patterns with the '_*' wildcard to match a specific prefix ('scala') in a string and bind the remaining characters to a variable. The example implements a function that returns true if a string contains 'scala' as a prefix.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/regular-expression-patterns.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject RegExpTest1 extends App {\n  def containsScala(x: String): Boolean = {\n    val z: Seq[Char] = x\n    z match {\n      case Seq('s','c','a','l','a', rest @ _*) =>\n        println(\"rest is \"+rest)\n        true\n      case Seq(_*) =>\n        false\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Imports Locally Within a Function in Scala 2\nDESCRIPTION: This Scala 2 function defines 'sqrtplus1', showing that import statements in Scala can be declared within function bodies. It imports 'scala.math.sqrt' locally, applies it to an Int parameter 'x', and returns its square root plus 1.0. No external setup is necessary, and the function illustrates scope flexibility for imports. The input is an integer, and the output is a double.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/packages-and-imports.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ndef sqrtplus1(x: Int) = {\n  import scala.math.sqrt\n  sqrt(x) + 1.0\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmarking parallel reduce with Scala parallel collections\nDESCRIPTION: Defines a Scala benchmark object `Reduce` to measure the performance of parallel reduction (summation) over a ParVector collection. It sets up the parallelism level dynamically via JVM system properties and configures the ForkJoinPool for task execution. The `run` method performs a reduce operation summing all elements. This snippet depends on Scala's collection.parallel.immutable.ParVector and the scala.concurrent.forkjoin.ForkJoinPool classes. Inputs are collection length and parallelism degree; output is the result of the summation. It demonstrates how to configure and run parallel computations with ParVector using task support.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/parallel-collections/performance.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport collection.parallel.immutable.ParVector\n\nobject Reduce extends testing.Benchmark {\n  val length = sys.props(\"length\").toInt\n  val par = sys.props(\"par\").toInt\n  val parvector = ParVector((0 until length): _*)\n\n  parvector.tasksupport = new collection.parallel.ForkJoinTaskSupport(new scala.concurrent.forkjoin.ForkJoinPool(par))\n\n  def run = {\n    parvector reduce {\n      (a, b) => a + b\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Compile-Time Power Function with Macros in Scala 3\nDESCRIPTION: This snippet shows the structure of a macro that computes x^n at compile time when both x and n are statically known. It demonstrates the pattern for defining the inline entry point and its corresponding macro implementation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/macros.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ninline def power(inline x: Double, inline n: Int) =\n  ${ powerCode('x, 'n)  }\n\ndef powerCode(\n  x: Expr[Double],\n  n: Expr[Int]\n)(using Quotes): Expr[Double] = ...\n```\n\n----------------------------------------\n\nTITLE: Exception Handling with Try/Catch/Finally (Scala 2)\nDESCRIPTION: Illustrates the `try`/`catch`/`finally` structure in Scala 2 for handling exceptions. The `catch` block uses pattern matching on specific exception types (`IOException`, `NumberFormatException`), and the `finally` block ensures cleanup code runs regardless of whether an exception occurred. Requires definition of `writeTextToFile` and a `text` variable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_26\n\nLANGUAGE: Scala\nCODE:\n```\ntry {\n  writeTextToFile(text)\n} catch {\n  case ioe: IOException => println(\"Got an IOException.\")\n  case nfe: NumberFormatException => println(\"Got a NumberFormatException.\")\n} finally {\n  println(\"Clean up your resources here.\")\n}\n```\n\n----------------------------------------\n\nTITLE: Forcing Evaluation of Lazy View - Scala REPL\nDESCRIPTION: Calling `.force` on a view triggers the execution of all recorded lazy operations in the correct order and materializes the final result as a new collection. This avoids creating intermediate collections for each step.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/views.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nres14.force\n```\n\nLANGUAGE: text\nCODE:\n```\nres15: Seq[Int] = Vector(4, 6, 8, 10, 12, 14, 16, 18, 20, 22)\n```\n\n----------------------------------------\n\nTITLE: Clearing and Removing Elements from Scala mutable Set using clear and remove in Scala\nDESCRIPTION: Demonstrates how to clear all elements using clear(), resulting in an empty set, and how to remove a single element using remove, which returns a Boolean indicating success. The snippet highlights both successful and unsuccessful attempts to remove elements, showcasing expected return values and subsequent set states.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/set-class.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval set = scala.collection.mutable.Set(1, 2, 3, 4, 5)\nset.clear()\n\nval set2 = scala.collection.mutable.Set(1, 2, 3, 4, 5)\nset2.remove(2)\nset2.remove(40)\n```\n\n----------------------------------------\n\nTITLE: Deconstructing a Package Definition AST in Scala\nDESCRIPTION: Shows how to use a Scala quasiquote to pattern match on a package definition AST (created previously) and extract its reference (`ref`) and body content (`body`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/definition-details.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"package $ref { ..$body }\" = pack\nref: universe.RefTree = mycorp.myproj\nbody: List[universe.Tree] =\nList(class MyClass extends scala.AnyRef {\n  def <init>() = {\n    super.<init>();\n    ()\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Combining Alternative Patterns in Scala Quasiquotes\nDESCRIPTION: Shows how to create and decompose alternative patterns that represent pattern matches that succeed when any branch matches. The code illustrates pattern construction using OR (`|`) operators and pattern decomposition into the first pattern and remaining patterns using quasiquotes, supporting both head-tail and init-last extraction. Inputs are alternative pattern trees; outputs are lists and individual pattern trees.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/pattern-details.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval alt = pq\"Foo() | Bar() | Baz()\"\nalt: universe.Alternative = (Foo()| Bar()| Baz())\n\nval pq\"$first | ..$rest\" = alt\nhead: universe.Tree = Foo()\ntail: List[universe.Tree] = List(Bar(), Baz())\n\nval pq\"..$init | $last\" = alt\ninit: List[universe.Tree] = List(Foo(), Bar())\nlast: universe.Tree = Baz()\n```\n\n----------------------------------------\n\nTITLE: Using Guards in For Loops in Scala 3\nDESCRIPTION: Demonstrates Scala 3's syntax for filtering elements in ints within a for loop using indentation and an inline if guard. ints should be defined. Only values satisfying the guard are printed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nfor\n  i <- ints\n  if i > 2\ndo\n  println(i)\n\n```\n\n----------------------------------------\n\nTITLE: ScalaCheck Property-based Test Example - Scala\nDESCRIPTION: Demonstrates writing a ScalaCheck-based test for verifying properties of list concatenation. Requires the ScalaCheck library, and places the test under ./test/files/scalacheck. The test defines a property (prop_ConcatLists) that asserts the size of two concatenated lists equals the sum of their individual sizes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/partest-guide.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport org.scalacheck._\nimport Prop._\n\nobject Test {\n\tval prop_ConcatLists = property{ (l1: ListInt, l2: ListInt) =>\n\t\tl1.size + l2.size == (l1 ::: l2).size\n\t}\n\n\tval tests = List((\"prop_ConcatLists\", prop_ConcatLists))\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering a Collection in Python\nDESCRIPTION: Demonstrates filtering a collection (`numbers`) in Python using the built-in `filter` function and a lambda expression (`f`) to define the filtering condition (elements greater than 1).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_67\n\nLANGUAGE: Python\nCODE:\n```\nf = lambda x: x > 1\nx = filter(f, numbers)\n```\n\n----------------------------------------\n\nTITLE: Attempting to Mutate a Case Class Field and Resulting Error in Scala\nDESCRIPTION: Tries to assign a new value to 'emailDeJohn.title', resulting in a compile-time error because case class fields are immutable by default. Highlights the immutability characteristic of case classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/case-classes.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nemailDeJohn.title = \"Adeus do John!\" // Erro de compilação\n```\n\n----------------------------------------\n\nTITLE: Matching Integer Constants with Scala Match Expression (Scala 2)\nDESCRIPTION: Demonstrates how to perform pattern matching on an integer value using the Scala 2 syntax. The code imports the Random utility, generates a random integer between 0 and 9, and uses match with several case constants to map the integer to a corresponding string representation. The underscore case acts as a default to catch all other integer values. This snippet showcases Scala 2's curly braces enclosed match syntax and emphasizes the match expression's capability to return a value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/pattern-matching.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.util.Random\n\nval x: Int = Random.nextInt(10)\n\nx match {\n  case 0 => \"zero\"\n  case 1 => \"one\"\n  case 2 => \"two\"\n  case _ => \"other\"\n}\n```\n\n----------------------------------------\n\nTITLE: Funkcija cloneAndReset koja koristi složene tipove u Scalaj\nDESCRIPTION: Ova funkcija prima objekat koji mora biti i `Cloneable` i `Resetable`, klonira taj objekat i resetuje originalni objekat. Tip parametra je specificiran kao `Cloneable with Resetable`, što omogućava pristup metodama oba traita bez potrebe za kastovanjem. Funkcija vraća klonirani objekat.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/compound-types.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef cloneAndReset(obj: Cloneable with Resetable): Cloneable = {\n  val cloned = obj.clone()\n  obj.reset\n  cloned\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Value Class without Allocation in Scala\nDESCRIPTION: Demonstrates creating instances of the `Meter` value class and using its `+` operator. In this context, Scala optimizes the operations to work directly on the underlying primitive `Double` values, avoiding the allocation of `Meter` objects at runtime.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval x = new Meter(3.4)\nval y = new Meter(4.3)\nval z = x + y\n```\n\n----------------------------------------\n\nTITLE: Using Alternative Patterns for Command Synonyms in Scala\nDESCRIPTION: Shows how to use Scala's alternative pattern (`|`) to treat \"north\" and \"go north\" as synonyms within a `match` statement. Both `Command(North :: Nil)` and `Command(Go :: North :: Nil)` map to the same logic. This works currently as no variables are bound.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/alternative-bind-variables.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n  case Command(North :: Nil | Go :: North :: Nil) => // Code for going north\n```\n\n----------------------------------------\n\nTITLE: Calling `inline if` Function: Success and Error Cases in Scala\nDESCRIPTION: Shows the results of calling the `power` function defined with `inline if`. The call `power(2, 2)` succeeds because `n` is a constant, allowing compile-time evaluation. The call `power(2, unknownNumber)` results in a compile-time error because `n` is not constant, and `inline if` requires a statically known condition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\npower(2, 2) // Ok\npower(2, unknownNumber) // error\n```\n\n----------------------------------------\n\nTITLE: Applying Strict Transformations - Scala REPL\nDESCRIPTION: This example shows how multiple strict map operations are applied to a Vector in Scala. Each map operation creates a new intermediate Vector, which can be inefficient for large collections or many transformations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/views.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval v = Vector(1 to 10: _*)\n```\n\nLANGUAGE: text\nCODE:\n```\nv: scala.collection.immutable.Vector[Int] =\n   Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n```\n\nLANGUAGE: scala\nCODE:\n```\nv map (_ + 1) map (_ * 2)\n```\n\nLANGUAGE: text\nCODE:\n```\nres5: scala.collection.immutable.Vector[Int] =\n   Vector(4, 6, 8, 10, 12, 14, 16, 18, 20, 22)\n```\n\n----------------------------------------\n\nTITLE: Creating a Mutable View Slice - Scala REPL\nDESCRIPTION: Creates a view representing a slice of the original mutable array using `.view.slice`. This view (`IndexedSeqView`) provides a window into the original array's elements without copying them.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/views.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval subarr = arr.view.slice(3, 6)\n```\n\nLANGUAGE: text\nCODE:\n```\nsubarr: scala.collection.mutable.IndexedSeqView[\nInt,Array[Int]] = IndexedSeqViewS(...)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Scala Default Parameters Usage and Java Interoperability Limitations\nDESCRIPTION: This snippet contains a Scala class `Point` with default constructor parameter values and a Java class `Main` that attempts to instantiate `Point` with a single argument. It demonstrates that, although Scala allows default parameters to be omitted, calls from Java do not support this feature and require all parameters explicitly. Dependencies include cross-language usage of compiled Scala classes in Java. Input is Java constructor invocation with partial parameters; output is a compile-time error indicating missing argument. Highlights limitations for default parameters when interoperating with Java.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/default-parameter-values.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n// Point.scala\nclass Point(val x: Double = 0, val y: Double = 0)\n```\n\nLANGUAGE: java\nCODE:\n```\n// Main.java\npublic class Main {\n    public static void main(String[] args) {\n        Point point = new Point(1);  // does not compile\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Instance with Some Value for Optional Field in Scala 3\nDESCRIPTION: An example showing how to create an Address instance with Some(\"Apt. 2B\") for the optional street2 field in Scala 3, using the more concise syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fp-functional-error-handling.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nval santa = Address(\n  \"123 Main Street\",\n  Some(\"Apt. 2B\"),\n  \"Talkeetna\",\n  \"Alaska\",\n  \"99676\"\n)\n```\n\n----------------------------------------\n\nTITLE: Defining an Abstract Iterator Class in Scala\nDESCRIPTION: This snippet defines an abstract class `AbsIterator` with a type member `T` and abstract methods `hasNext` and `next` for iteration. It serves as a base for creating custom iterators.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/mixin-class-composition.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class AbsIterator {\n  type T\n  def hasNext: Boolean\n  def next(): T\n}\n```\n\n----------------------------------------\n\nTITLE: Using Covariant List in Scala to Print Animal Names\nDESCRIPTION: This snippet defines an object demonstrating covariance with a covariant List[+A]. It contains a method printAnimalNames that accepts a List[Animal] and prints each animal's name. Lists of Cats and Dogs can be passed to this method without compilation errors due to the covariance of List, illustrating subtype substitution.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/variances.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nobject CovarianceTest extends App {\n  def printAnimalNames(animals: List[Animal]): Unit = {\n    animals.foreach { animal =>\n      println(animal.name)\n    }\n  }\n\n  val cats: List[Cat] = List(Cat(\"Whiskers\"), Cat(\"Tom\"))\n  val dogs: List[Dog] = List(Dog(\"Fido\"), Dog(\"Rex\"))\n\n  printAnimalNames(cats)\n  // Whiskers\n  // Tom\n\n  printAnimalNames(dogs)\n  // Fido\n  // Rex\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating String Operations in Scala\nDESCRIPTION: This snippet shows various string operations like reverse, map, drop, and slice applied to a String in Scala, illustrating how strings can be manipulated similarly to collections. It also assigns a String to a Seq of Char, showing implicit conversions in action.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/strings.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val str = \"hello\"\nstr: java.lang.String = hello\nscala> str.reverse\nres6: String = olleh\nscala> str.map(_.toUpper)\nres7: String = HELLO\nscala> str drop 3\nres8: String = lo\nscala> str slice (1, 4)\nres9: String = ell\nscala> val s: Seq[Char] = str\ns: Seq[Char] = WrappedString(h, e, l, l, o)\n```\n\n----------------------------------------\n\nTITLE: Modifying Class Fields in Scala\nDESCRIPTION: Examples of how to modify mutable fields of a class instance in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-tools.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\np.name = \"Bob Dylan\"\np.vocation = \"Musician\"\n```\n\n----------------------------------------\n\nTITLE: Creating a sequence buffer with anonymous class implementing abstract members\nDESCRIPTION: This snippet defines 'IntSeqBuffer' as an extension of 'SeqBuffer' with 'U' fixed to 'Int'. It provides a factory method 'newIntSeqBuf' that creates an anonymous class implementing 'IntSeqBuffer', concretely defining 'T' as 'List[U]' and initializing 'element' with a list of integers. It demonstrates dynamic instantiation and usage with sample elements. Dependencies include 'SeqBuffer'. Inputs are integers; outputs include buffer length and content.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tour/abstract-type-members.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class IntSeqBuffer extends SeqBuffer {\n  type U = Int\n}\n\ndef newIntSeqBuf(elem1: Int, elem2: Int): IntSeqBuffer =\n  new IntSeqBuffer {\n\ttype T = List[U]\n\tval element = List(elem1, elem2)\n  }\nval buf = newIntSeqBuf(7, 8)\nprintln(\"length = \" + buf.length)\nprintln(\"content = \" + buf.element)\n```\n\n----------------------------------------\n\nTITLE: For loop with range iteration in Python and Scala\nDESCRIPTION: Shows looping over a numeric range with printing of the index. Inputs: loop indices from 0 to 2 inclusive or exclusive depending on language. Outputs: printed numbers. Scala has multiple syntaxes demonstrated including preferred forms and multiline options.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_32\n\nLANGUAGE: Scala\nCODE:\n```\n// preferred\nfor i <- 0 until 3 do println(i)\n\n// also available\nfor (i <- 0 until 3) println(i)\n\n// multiline syntax\nfor\n  i <- 0 until 3\ndo\n  println(i)\n```\n\n----------------------------------------\n\nTITLE: Basic match expression example in Scala 2\nDESCRIPTION: Demonstrates a match expression that converts integer values to day names. It shows how to provide cases for different values and a default case using the underscore pattern.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\n// `i` is an integer\nval day = i match {\n  case 0 => \"Sunday\"\n  case 1 => \"Monday\"\n  case 2 => \"Tuesday\"\n  case 3 => \"Wednesday\"\n  case 4 => \"Thursday\"\n  case 5 => \"Friday\"\n  case 6 => \"Saturday\"\n  case _ => \"invalid day\"   // the default, catch-all\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting and Padding Elements in a Mutable Buffer in Scala\nDESCRIPTION: Shows how to insert one or more elements at a specific index, or pad the buffer to a given size with a repeated value. Requires a mutable Buffer from scala.collection.mutable, and numeric indices to specify insertion or padding points. The insert and insertAll methods accept the target index and elements, while padToInPlace pads up to the required length. Inputs are indexes, buffers, and values; outputs are the modified buffer, potentially extended in size.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/seqs.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nbuf.insert(i, x)\nbuf.insertAll(i, xs)\nbuf.padToInPlace(n, x)\n```\n\n----------------------------------------\n\nTITLE: Calling drop on Some(42) via Implicit Conversion - Scala 2 and 3\nDESCRIPTION: Shows dropping the first element of a Some(42) through implicit conversion to Iterable, resulting in an empty List. Requires Scala's implicit conversion in scope. Input: Some(42); Output: Iterable[Int] = List(). Demonstrates standard collection method invocation on converted Option.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/conversion-between-option-and-the-collections.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nSome(42).drop(1)\n// : Iterable[Int] = List()\n```\n\n----------------------------------------\n\nTITLE: Using type parameters instead of abstract type members for Buffers in Scala\nDESCRIPTION: This snippet replaces abstract type members with generic type parameters in 'Buffer' and 'SeqBuffer' classes, adding variance annotations. A factory function 'newIntSeqBuf' creates a 'SeqBuffer' with specific type parameters, demonstrating an alternative way to achieve flexible buffer types with compile-time type safety.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/abstract-type-members.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Buffer[+T] {\n  val element: T\n}\nabstract class SeqBuffer[U, +T <: Seq[U]] extends Buffer[T] {\n  def length = element.length\n}\n\ndef newIntSeqBuf(e1: Int, e2: Int): SeqBuffer[Int, Seq[Int]] =\n  new SeqBuffer[Int, List[Int]] {\n    val element = List(e1, e2)\n  }\n\nval buf = newIntSeqBuf(7, 8)\nprintln(\"length = \" + buf.length)\nprintln(\"content = \" + buf.element)\n```\n\n----------------------------------------\n\nTITLE: 可变列表（MutableList）实例\nDESCRIPTION: 描述MutableList由单向链表和终端空节点指针构成，避免遍历整个列表找到终点，优化操作时间。它是Scala中mutable.LinearSeq的标准实现，支持高效的插入和删除操作。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/concrete-mutable-collection-classes.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\n// 具体代码示例未提供，仅为说明\n```\n\n----------------------------------------\n\nTITLE: Anti-pattern: Mutable Class Variables in Scala\nDESCRIPTION: Shows an example of how not to define classes in functional programming by using var for mutable fields in a Person class constructor.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-immutable-values.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// don't do this in FP\nclass Person(var firstName: String, var lastName: String)\n             ---                    ---\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mixin Equivalents in Java (N/A)\nDESCRIPTION: Java does not have a direct equivalent concept to Scala's mixins (traits mixed into an instance or anonymous class). While interfaces with default methods offer some similar capability, mixing traits into an instance is a distinct feature.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_28\n\nLANGUAGE: text\nCODE:\n```\nN/A\n```\n\n----------------------------------------\n\nTITLE: Using if as a Method Body in Scala\nDESCRIPTION: Demonstrates how to use an if/else expression as the entire body of a method. The example implements a function that determines if a value is truthy, similar to Perl's concept of true and false.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\ndef isTruthy(a: Any) = {\n  if (a == 0 || a == \"\" || a == false)\n    false\n  else\n    true\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef isTruthy(a: Any) =\n  if a == 0 || a == \"\" || a == false then\n    false\n  else\n    true\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Mixed Positional and Named Arguments\nDESCRIPTION: This snippet shows an incorrect method call where a positional argument follows a named argument, which results in a compilation error. It emphasizes that when using named arguments, all positional arguments should come before them.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/named-arguments.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nprintName(last = \"Smith\", \"john\") // error: positional after named argument\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Scala 2 Pattern Matching Types\nDESCRIPTION: Defines a Scala 2 function `pattern` that accepts a `Matchable` input and uses a `match` expression to demonstrate various pattern types: constant, sequence, tuple, constructor (assuming `Person` and `Dog` case classes are defined), and type test patterns. It returns a descriptive string based on the matched pattern or 'Unknown' if no pattern matches.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\ndef pattern(x: Matchable): String = x match {\n\n  // constant patterns\n  case 0 => \"zero\"\n  case true => \"true\"\n  case \"hello\" => \"you said 'hello'\"\n  case Nil => \"an empty List\"\n\n  // sequence patterns\n  case List(0, _, _) => \"a 3-element list with 0 as the first element\"\n  case List(1, _*) => \"list, starts with 1, has any number of elements\"\n  case Vector(1, _*) => \"vector, starts w/ 1, has any number of elements\"\n\n  // tuple patterns\n  case (a, b) => s\"got $a and $b\"\n  case (a, b, c) => s\"got $a, $b, and $c\"\n\n  // constructor patterns\n  case Person(first, \"Alexander\") => s\"Alexander, first name = $first\"\n  case Dog(\"Zeus\") => \"found a dog named Zeus\"\n\n  // type test patterns\n  case s: String => s\"got a string: $s\"\n  case i: Int => s\"got an int: $i\"\n  case f: Float => s\"got a float: $f\"\n  case a: Array[Int] => s\"array of int: ${a.mkString(\",\")}\"\n  case as: Array[String] => s\"string array: ${as.mkString(\",\")}\"\n  case d: Dog => s\"dog: ${d.name}\"\n  case list: List[?] => s\"got a List: $list\"\n  case m: Map[?, ?] => m.toString\n\n  // the default wildcard pattern\n  case _ => \"Unknown\"\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mutable BitSet Operations in Scala\nDESCRIPTION: This snippet demonstrates creating and modifying a mutable BitSet in Scala's collections library. It shows how elements can be added to the BitSet in-place, avoiding unnecessary copying compared to immutable sets. The snippet requires Scala 2 or 3 and uses the scala.collection.mutable.BitSet type. It outputs the BitSet contents after additions to verify the in-place updates.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-mutable-collection-classes.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val bits = scala.collection.mutable.BitSet.empty\nbits: scala.collection.mutable.BitSet = BitSet()\nscala> bits += 1\nres49: bits.type = BitSet(1)\nscala> bits += 3\nres50: bits.type = BitSet(1, 3)\nscala> bits\nres51: scala.collection.mutable.BitSet = BitSet(1, 3)\n```\n\n----------------------------------------\n\nTITLE: Looping Over a List in Scala 3\nDESCRIPTION: Shows the simplified Scala 3 syntax for iterating through a `List` using a `for` loop with the `do` keyword (parentheses are optional). Requires a pre-defined `List` named `names`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nfor name <- names do println(name)\n```\n\n----------------------------------------\n\nTITLE: Registering Completion Callback on Scala Future - Scala 2\nDESCRIPTION: Demonstrates how to register an onComplete callback on a Scala Future to process a list of recent posts when the asynchronous computation completes. Requires the scala.concurrent and scala.util.{Success, Failure} libraries. The callback differentiates between successful completion and failure, printing each post or an error message as appropriate. The Future expects session.getRecentPosts to return a List[String].\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.util.{Success, Failure}\nval f: Future[List[String]] = Future {\n  session.getRecentPosts\n}\n\nf.onComplete {\n  case Success(posts) => for (post <- posts) println(post)\n  case Failure(t) => println(\"An error has occured: \" + t.getMessage)\n}\n```\n\n----------------------------------------\n\nTITLE: Implicit conversion priority for array operations in Scala\nDESCRIPTION: This code explains how implicit conversions are prioritized, with ArrayOps having higher priority due to being defined in 'Predef'. The example demonstrates calling 'reverse' on an array with the implicit conversion selecting ArrayOps over WrappedArray.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/arrays.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nscala> a1.reverse\nres4: Array[Int] = Array(3, 2, 1)\n```\n\n----------------------------------------\n\nTITLE: Returning Option for Type-Safe Error Handling in Scala\nDESCRIPTION: This code defines a method, makeInt, which attempts to convert a string to an integer and returns the result wrapped in an Option[Int] instead of throwing an exception. It uses a try/catch block internally; if the conversion succeeds, Some[Int] is returned, otherwise None is returned on NumberFormatException. The function requires no dependencies and accepts a string input, returning either Some(Int) or None. This approach avoids unchecked exceptions and encourages safe, composable error handling. The limitation is that only NumberFormatException is caught and all failures result in None, potentially losing precise failure information.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_64\n\nLANGUAGE: Scala\nCODE:\n```\ndef makeInt(s: String): Option[Int] =\n  try\n    Some(s.toInt)\n  catch\n    case e: NumberFormatException => None\n```\n\n----------------------------------------\n\nTITLE: Scala 3: Functional approach using map\nDESCRIPTION: This Scala 3 code snippet illustrates a functional programming style using the map method to double each element in a list, resulting in more concise and readable code compared to imperative loops.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/scala-features.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval newNumbers = oldNumbers.map(_ * 2)\n```\n\n----------------------------------------\n\nTITLE: Примеры отношений подтипов для функций с вариантностью параметров в Scala 2 и 3\nDESCRIPTION: В этом примере показана переменная f с типом Function[Buyable, Buyable], а также переменные g и h с типами, соответствующими отношениям подтипов с учетом вариантности: g — возвращает более обобщённый тип, h — принимает более специализированный аргумент. На практике иллюстрируется, что функция с параметрами вариантности может безопасно использоваться в более широком диапазоне контекстов.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-variance.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nval f: Function[Buyable, Buyable] = b => b\n\n// OK - допустимо вернуть Buyable там, где ожидается Item\nval g: Function[Buyable, Item] = f\n\n// OK - допустимо передать аргумент Book туда, где ожидается Buyable\nval h: Function[Book, Buyable] = f\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Arithmetic and String Methods in Scala 2 and 3\nDESCRIPTION: Shows examples of methods performing arithmetic addition and string concatenation with explicit return types. Parameters include two integers or two strings, returning their sum or concatenated result respectively. No external dependencies required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-methods.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef sum(a: Int, b: Int): Int = a + b\ndef concatenate(s1: String, s2: String): String = s1 + s2\n```\n\n----------------------------------------\n\nTITLE: Exhaustive pattern matching with sealed trait 'Notification' (Scala 2)\nDESCRIPTION: Defines a function 'showNotification' that pattern matches on 'Notification' subtypes 'Email' and 'SMS'. The function generates descriptive strings based on notification type and content. Utilizes 'sealed trait' to ensure all cases are accounted for; missing patterns like 'VoiceRecording' trigger compile-time warnings. Dependencies include 'case class' definitions for 'Email' and 'SMS'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/pattern-matching.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\ndef showNotification(notification: Notification): String = {\n  notification match {\n    case Email(sender, title, _) =>\n      s\"You got an email from $sender with title: $title\"\n    case SMS(number, message) =>\n      s\"You got an SMS from $number! Message: $message\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using build.sbt to Enable New Syntax Control Structure Rewrite - Scala\nDESCRIPTION: Shows how to enable the new syntax control structure rewrites by specifying scalacOptions in an sbt build definition. The options `-new-syntax` and `-rewrite` automate source rewriting to Scala 3 style during compilation. This snippet is required to apply the compiler-driven source transformations demonstrated.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tooling-syntax-rewriting.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n// build.sbt, for Scala 3 project\nscalacOptions ++= Seq(\"-new-syntax\", \"-rewrite\")\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Reference Container Class in Scala 2\nDESCRIPTION: Defines a generic class Reference parametrized by a type T, representing a container that can hold a value of type T. It has a private mutable variable contents initialized to a default value (_) and provides set and get methods to mutate and access the stored value. The underscore (_) initializes contents to a default value of T (e.g., 0 for numeric types, null for objects) in Scala 2. This design ensures type safety and avoids the need for casting. Key parameters include the type parameter T and the value passed to set(). The class returns the contained value on get().\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\nclass Reference[T] {\n  private var contents: T = _\n  def set(value: T): Unit = { contents = value }\n  def get: T = contents\n}\n```\n\n----------------------------------------\n\nTITLE: Exception handling in Java vs Scala\nDESCRIPTION: Compares try-catch-finally blocks between Java and Scala. Scala handles exceptions using pattern matching syntax and doesn't require parentheses or curly braces.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_47\n\nLANGUAGE: Java\nCODE:\n```\ntry {\n  writeTextToFile(text);\n} catch (IOException ioe) {\n  println(ioe.getMessage())\n} catch (NumberFormatException nfe) {\n  println(nfe.getMessage())\n} finally {\n  println(\"Clean up resources here.\")\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntry\n  writeTextToFile(text)\ncatch\n  case ioe: IOException =>\n    println(ioe.getMessage)\n  case nfe: NumberFormatException =>\n    println(nfe.getMessage)\nfinally\n  println(\"Clean up resources here.\")\n```\n\n----------------------------------------\n\nTITLE: Escaping Dollar Signs in Scala `s`-Interpolated Strings\nDESCRIPTION: Shows how to include a literal dollar sign (`$`) within an `s`-interpolated string in Scala by escaping it with another dollar sign (`$$`). This prevents the interpolator from trying to interpret the following text as a variable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nprintln(s\"New offers starting at $$14.99\")   // \"New offers starting at $14.99\"\n```\n\n----------------------------------------\n\nTITLE: Defining Combined Traits for Intersection in Scala 2 and Scala 3\nDESCRIPTION: Illustrates how combined traits can be defined to mimic intersection types in both Scala 2 and Scala 3. The Scala 2 snippet uses trait inheritance with `extends Resettable with Growable[A]`, while Scala 3 uses `extends Resettable, Growable[A]`. Both define a trait `Both[A]` which is a subtype of both `Resettable` and `Growable[A]`. The method `f` accepts parameters of type `Both[String]`, showing how trait composition differs from direct intersection types. This example highlights that direct intersection types accept any value simultaneously subtype of the involved traits, whereas combined traits require explicit inheritance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-intersection.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntrait Both[A] extends Resettable with Growable[A]\ndef f(x: Both[String]): Unit\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait Both[A] extends Resettable, Growable[A]\ndef f(x: Both[String]): Unit\n```\n\n----------------------------------------\n\nTITLE: Defining URI Extension Method for '/' Operator in Scala\nDESCRIPTION: This snippet defines an extension method `/` for the `java.net.URI` class to resolve child URIs, similar to the `Path` example. It shows an example where extension methods for different types provide the same operation symbol but cannot be imported together without ambiguity before this SIP. The snippet requires Scala 3 compiler and the Java URI API. It accepts a `URI` instance and child string as input and returns a resolved `URI`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/multi-source-extension-overloads.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport java.net.URI\n\nobject URIExtensions:\n  extension (uri: URI)\n    def /(child: String): URI = uri.resolve(child)\n\ndef app2(): Unit =\n  import URIExtensions.*\n  val rootURI = new URI(\"https://www.example.com/\")\n  val projectURI = rootURI / \"project/\"\n```\n\n----------------------------------------\n\nTITLE: Defining Location Macro in Scala 2 - Location.scala\nDESCRIPTION: Implements a simple macro library in Scala 2.13 defining a 'Location' case class and a 'Macros' object. The macro method 'location' returns a 'Location' instance at the call site, extracting path and line using 'Context'. Requires 'scala-reflect' and experimental macros enabled. Inputs: macro invocation; Outputs: Location(path: String, line: Int). Must be compiled only in Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-macro-cross-building.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// example/src/main/scala/location/Location.scala\npackage location\n\nimport scala.reflect.macros.blackbox.Context\nimport scala.language.experimental.macros\n\ncase class Location(path: String, line: Int)\n\nobject Macros {\n  def location: Location = macro locationImpl\n\n  private def locationImpl(c: Context): c.Tree =  {\n    import c.universe._\n    val location = typeOf[Location]\n    val line = Literal(Constant(c.enclosingPosition.line))\n    val path = Literal(Constant(c.enclosingPosition.source.path))\n    q\"new $location($path, $line)\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing a Nested Apply Tree in Scala Reflection\nDESCRIPTION: This snippet constructs a nested Apply tree representing the expression x.$plus(2).$plus(3). It demonstrates building deeper tree structures by nesting Apply, Select, and Literal nodes. Inputs are the identifiers and numeric constants; the output is a Tree representing a compound apply node suitable for traversal or transformation with the Reflection API.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\nval tree = Apply(Select(Apply(Select(Ident(TermName(\"x\")), TermName(\"$plus\")), List(Literal(Constant(2)))), TermName(\"$plus\")), List(Literal(Constant(3))))\n```\n\n----------------------------------------\n\nTITLE: 拡張メソッドの例：`RichInt`による静的拡張\nDESCRIPTION: 値クラスとして定義されたimplicitクラス`RichInt`。`Int`型に対して拡張メソッド`toHexString`を追加し、`3.toHexString`のように呼び出せる。実行時には静的メソッド呼び出しに変換され、追加のインスタンス化が不要となる。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/value-classes.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit class RichInt(val self: Int) extends AnyVal {\n  def toHexString: String = java.lang.Integer.toHexString(self)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Anonymous Class with a Method Using Reflective Calls in Scala\nDESCRIPTION: This snippet shows the Scala 2 and 3 approach for creating an anonymous class with a method bar, using scala.language.reflectiveCalls to enable reflective access. It highlights that, while reflective calls were supported in Scala 2, Scala 3 programmatically handles structural types differently, requiring explicit type ascription for such access. Dependencies include the scala.language.reflectiveCalls import, and the code expects a context where structural member typing is used.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-type-inference.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.language.reflectiveCalls\n\nval foo = new {\n  def bar: Unit = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Resolving Implicit Arguments in Scala - Scala\nDESCRIPTION: This Scala snippet demonstrates how implicit argument resolution works by defining an implicit function requiring a tuple, another implicit that provides the tuple, and an implicit integer value. The code uses 'implicitly' to summon a List[Int] via these implicits, relying on the Scala compiler to resolve the chain safely without reporting divergence due to algorithmic 'striping'. Dependencies include standard Scala syntax and an understanding of implicits; no additional libraries are required. The main parameters are generic type T for the implicits, and the expected input is the presence of these implicit definitions, ultimately resulting in a List[Int] at runtime. This code showcases compiler behavior and will not trigger a divergence error in Scala's actual implementation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit def requiresPair[T](implicit tt: (T, T)): List[T] =\n  List(tt._1, tt._2)\n\nimplicit def providesPair[T](implicit t: T): (T, T) = (t, t)\n\nimplicit val singleInt: Int = 23\n\nimplicitly[List[Int]]\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Dependencies with Mill in Scala\nDESCRIPTION: This snippet demonstrates how to declare and manage Scala and third-party dependencies in a Mill build configuration using a Scala-based build.sc file. The 'scalaVersion' sets the Scala version, and 'ivyDeps' lists required Ivy dependencies for sttp and related libraries. Mill resolves these for compilation and runtime based on the specified versions. Inputs are build configuration details; output is used by Mill build scripts. Mill and the scalalib module are prerequisites.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/drop-stdlib-forwards-bin-compat.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport mill._, scalalib._\nobject proj extends ScalaModule {\n  def scalaVersion = \"2.13.8\"\n  def ivyDeps = Agg(\n    ivy\"com.softwaremill.sttp.client3::core:3.8.3\",\n    ivy\"com.softwaremill.sttp.shared::ws:1.2.7\",\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ThreadPoolTaskSupport for Scala Parallel Collections in Scala\nDESCRIPTION: This snippet shows how to assign a ThreadPoolTaskSupport to a parallel mutable array as a task support, providing a fallback task execution mechanism for concurrent environments that do not support fork-join pools or are JVM 1.5. After assignment, a map operation is executed on the ParArray. Dependencies include scala.collection.parallel.ThreadPoolTaskSupport. The input is a ParArray[Int], and the output is a ParArray[Int] with incremented elements computed in parallel.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/parallel-collections/configuration.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\npc.tasksupport = new ThreadPoolTaskSupport()\npc map { _ + 1 }\n```\n\n----------------------------------------\n\nTITLE: Getting Method Symbol via Type Reflection\nDESCRIPTION: Retrieves the symbol representation of the `test` method from the reflected type of `C[Int]`. It uses `typeOf` to get the type and `member` with `TermName` to find the specific member by name.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> val testMember = typeOf[C[Int]].member(TermName(\"test\"))\ntestMember: scala.reflect.runtime.universe.Symbol = method test\n```\n\n----------------------------------------\n\nTITLE: For-Comprehension Without Yield in Scala\nDESCRIPTION: This example demonstrates a for-comprehension without using yield, which results in Unit return type. It performs the same operation as the previous example but directly prints the results rather than collecting them.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/for-comprehensions.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef foo(n: Int, v: Int) =\n   for (i <- 0 until n;\n        j <- 0 until n if i + j == v)\n   println(s\"($i, $j)\")\n\nfoo(10, 10)\n```\n\n----------------------------------------\n\nTITLE: If-elseif-else control flow in Python and Scala\nDESCRIPTION: Shows branching logic using if, else if (elif), and else constructs to classify integer x as negative, zero, or positive with corresponding print outputs. Inputs: integer x; outputs: printed classification string. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_23\n\nLANGUAGE: Python\nCODE:\n```\nif x < 0:\n  print(\"negative\")\nelif x == 0:\n  print(\"zero\")\nelse:\n  print(\"positive\")\n```\n\n----------------------------------------\n\nTITLE: Representation of generic Array[T] in Scala\nDESCRIPTION: This snippet explains how Scala maps a generic type Array[T] at runtime to one of Java's primitive array types or Object arrays, using 'AnyRef' as a universal supertype. It discusses runtime type tests that influence access performance and implications for efficiency.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/arrays.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// Explanation only; no code snippet provided in text\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Case Classes\nDESCRIPTION: A function that pattern matches on different types of Notification objects, extracting and using their fields to generate appropriate message strings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/pattern-matching.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef showNotification(notification: Notification): String = {\n  notification match {\n    case Email(sender, title, _) =>\n      s\"You got an email from $sender with title: $title\"\n    case SMS(number, message) =>\n      s\"You got an SMS from $number! Message: $message\"\n    case VoiceRecording(name, link) =>\n      s\"You received a Voice Recording from $name! Click the link to hear it: $link\"\n  }\n}\nval someSms = SMS(\"12345\", \"Are you there?\")\nval someVoiceRecording = VoiceRecording(\"Tom\", \"voicerecording.org/id/123\")\n\nprintln(showNotification(someSms))  // prints You got an SMS from 12345! Message: Are you there?\n\nprintln(showNotification(someVoiceRecording))  // prints You received a Voice Recording from Tom! Click the link to hear it: voicerecording.org/id/123\n```\n\n----------------------------------------\n\nTITLE: Implicit Conversion from Scala.Int to Java.lang.Integer\nDESCRIPTION: Provides an implicit function that converts Scala's Int type to Java's Integer type to facilitate calling Java methods expecting Integer from Scala code. Necessary for interoperability between Scala and Java collections or APIs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/implicit-conversions.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.language.implicitConversions\n\nimplicit def int2Integer(x: Int): Integer =\n  Integer.valueOf(x)\n```\n\n----------------------------------------\n\nTITLE: Using Private Members and Custom Getters/Setters in Scala\nDESCRIPTION: Defines a class with private mutable variables and public getter and setter methods that enforce validation before modifying internal state. The setters include specific Scala syntax using the '_=' suffix. Also shows a private method used to print warnings when invalid assignments are attempted. Illustrates encapsulation patterns and access control in Scala classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/classes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass Point {\n  private var _x = 0\n  private var _y = 0\n  private val bound = 100\n\n  def x = _x\n  def x_= (newValue: Int): Unit = {\n    if (newValue < bound) _x = newValue else printWarning\n  }\n\n  def y = _y\n  def y_= (newValue: Int): Unit = {\n    if (newValue < bound) _y = newValue else printWarning\n  }\n\n  private def printWarning = println(\"UWAGA: wartość poza przedziałem\")\n}\n\nval point1 = new Point\npoint1.x = 99\npoint1.y = 101 // wyświetla ostrzeżenie\n```\n\n----------------------------------------\n\nTITLE: Adding Macro Paradise Plugin in sbt - Scala\nDESCRIPTION: This Scala build configuration snippet demonstrates how to add the Macro Paradise compiler plugin to an sbt project. It adds the Sonatype releases resolver and configures the compiler plugin dependency for macro support. The 'resolvers' line ensures access to published plugin artifacts, while 'addCompilerPlugin' specifies the group, artifact, version, and crossVersion of the plugin. No runtime dependencies on the plugin are introduced, and the expected input is a build.sbt file with these lines added. Limitations apply for Scala version compatibility and the specific plugin version.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/paradise.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nresolvers += Resolver.sonatypeRepo(\"releases\")\naddCompilerPlugin(\"org.scalamacros\" % \"paradise\" % \"2.1.0\" cross CrossVersion.full)\n```\n\n----------------------------------------\n\nTITLE: Initializing a Scala mutable Set in Scala\nDESCRIPTION: Initializes an empty mutable Set of integers by importing and instantiating scala.collection.mutable.Set. This is the prerequisite step before performing any additions or removals to the set.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/set-class.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval set = scala.collection.mutable.Set[Int]()\n```\n\n----------------------------------------\n\nTITLE: Defining Complex Number Class with Constructor and Accessor Methods in Scala\nDESCRIPTION: Defines a class Complex with two constructor parameters real and imaginary, both Doubles. The class provides two methods re() and im() that return the respective parts of the complex number. Scala demonstrates type inference of the method return types here. Instances require explicit construction with both parameters. This snippet introduces basic class construction, parameter passing, and defining simple methods accessing constructor parameters. Inputs are real and imaginary doubles; outputs are the values of these parts via methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tutorials/scala-for-java-programmers.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass Complex(real: Double, imaginary: Double) {\n  def re() = real\n  def im() = imaginary\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Filter Function with Partially Applied 'modN' in Scala\nDESCRIPTION: This snippet defines a 'filter' function that recursively filters a list of integers based on a predicate. The 'modN' function is partially applied with a specific divisor, returning a function of type 'Int => Boolean'. Two calls to 'filter' use 'modN' with different divisors to filter list elements divisible by 2 and 3, respectively. Dependencies include basic list operations and partial application. The input is a list and predicate functions; outputs are filtered lists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/multiple-parameter-lists.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef filter(xs: List[Int], p: Int => Boolean): List[Int] =\n  if (xs.isEmpty) xs\n  else if (p(xs.head)) xs.head :: filter(xs.tail, p)\n  else filter(xs.tail, p)\n\ndef modN(n: Int)(x: Int) = ((x % n) == 0)\n\nval nums = List(1, 2, 3, 4, 5, 6, 7, 8)\nprintln(filter(nums, modN(2)))\nprintln(filter(nums, modN(3)))\n```\n\n----------------------------------------\n\nTITLE: Using Dependency Injection and Contextual Functions to Extend Numeric DSL\nDESCRIPTION: This snippet extends 'Nums' with 'NumsDSL' trait to add extension methods for operations, and defines a 'const' function utilizing context parameters. It then defines a dependent function type 'Prog' as a context-dependent lambda, showcasing advanced composition of dependent types, contextual functions, and extension methods for intuitive DSL design.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-dependent-function.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ntrait NumsDSL extends Nums:\n  extension (x: Num)\n    def +(y: Num) = add(x, y)\n    def *(y: Num) = mul(x, y)\n\ndef const(d: Double)(using n: Nums): n.Num = n.lit(d)\n\ntype Prog = (n: NumsDSL) ?=> n.Num => n.Num\n//                       ^^^\n//     prog теперь - контекстная функция,\n//     которая неявно предполагает NumsDSL в контексте вызова\n\n def derivative(input: Prog): Double = ...\n\n// теперь нам не нужно упоминать Nums в приведенных ниже примерах\nderivative { x => const(1.0) + x }\n\nderivative { x => x * x + const(2.0) }\n```\n\n----------------------------------------\n\nTITLE: Defining Enums with Custom Fields/Methods in Scala 3\nDESCRIPTION: Demonstrates defining a complex enumeration (`Planet`) in Scala 3 where the enum itself takes parameters (`mass`, `radius`), and cases extend it with specific values. It also shows how to include custom fields (`G`) and methods (`surfaceGravity`, `surfaceWeight`) within the enum definition. This advanced feature is not directly available in standard Python enums.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_75\n\nLANGUAGE: Scala\nCODE:\n```\nenum Planet(\n    mass: Double,\n    radius: Double\n  ):\n  case Mercury extends\n      Planet(3.303e+23, 2.4397e6)\n  case Venus extends\n      Planet(4.869e+24, 6.0518e6)\n  case Earth extends\n      Planet(5.976e+24, 6.37814e6)\n  // more planets ...\n\n  // fields and methods\n  private final val G = 6.67300E-11\n  def surfaceGravity = G * mass /\n      (radius * radius)\n  def surfaceWeight(otherMass: Double)\n      = otherMass * surfaceGravity\n```\n\n----------------------------------------\n\nTITLE: Defining a MUnit Test Suite in Scala 2\nDESCRIPTION: This snippet defines a basic test suite in Scala 2 using MUnit by creating a class that extends munit.FunSuite. It contains a single test method named \"sum of two integers\" which asserts that the sum of 2 and 2 equals 4. The example demonstrates how to structure a test case and use the assertEquals assertion method to validate expected results. Required dependencies include the MUnit testing library. Inputs are static values within the test, and the output is the pass/fail status of the test.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-suite.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\npackage example\n\nclass MyTests extends munit.FunSuite {\n  test(\"sum of two integers\") {\n    val obtained = 2 + 2\n    val expected = 4\n    assertEquals(obtained, expected)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Running External Process with OS-Lib in Scala\nDESCRIPTION: This snippet demonstrates creating and executing an external process using OS-Lib's os.proc method and call() in Scala. It shows how to construct a file path, verify its existence, run the 'touch' command to create a file, and check the exit code of the command to verify success. Dependencies include the OS-Lib library. The key parameters include the command and arguments passed as strings or os.Path objects. The expected output is the file creation at the specified path and successful command exit code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/os-run-process.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval path: os.Path = os.pwd / \"output.txt\"\nprintln(os.exists(path))\n// prints: false\nval result: os.CommandResult = os.proc(\"touch\", path).call()\nprintln(result.exitCode)\n// prints: 0\nprintln(os.exists(path))\n// prints: true\n```\n\n----------------------------------------\n\nTITLE: Generated Project Structure for Scala Hello World\nDESCRIPTION: The directory structure that is generated when creating a new Scala project with sbt, showing the project organization with build files and source code folders.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/getting-started/install-scala.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n- hello-world\n    - project (sbt использует эту папку для собственных файлов)\n        - build.properties\n    - build.sbt (файл определения сборки sbt)\n    - src\n        - main\n            - scala (здесь весь Scala code)\n                - Main.scala (точка входа в программу) <-- это все, что сейчас нужно\n```\n\n----------------------------------------\n\nTITLE: Public Type Provider Using Macro Paradise and Annotations\nDESCRIPTION: This snippet shows defining a macro annotation `H2Db` that generates an external, publicly accessible class `H2Db`. The annotation allows external code to access static members and methods like `Coffees`, enabling type-safe database interactions with generated classes, without scope restrictions implied by local macros.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/typeproviders.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass H2Db(connString: String) extends StaticAnnotation {\n  def macroTransform(annottees: Any*) = macro ...\n}\n\n@H2Db(\"jdbc:h2:coffees.h2.db\") object Db\nprintln(Db.Coffees.all)\nDb.Coffees.insert(\"Brazilian\", 99, 0)\n```\n\n----------------------------------------\n\nTITLE: Displaying scalac Compiler Usage Information in Text\nDESCRIPTION: This snippet shows the basic usage message from the Scala 3 compiler executable 'scalac' when run without arguments. It lists common options such as '-explain' for detailed error explanations, '-rewrite' for source code automatic migration rewrites, and '-source' to specify the compilation source version including migration modes like '3.0-migration'. This output helps users understand available migration-related compiler flags and how to invoke them at the command line. It assumes access to the 'scalac' executable either installed manually or via Coursier.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tooling-migration-mode.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n$ scalac\nUsage: scalac <options> <source files>\nwhere possible standard options include:\n\n...\n-explain           Explain errors in more detail.\n...\n-rewrite           When used in conjunction with a `...-migration` source version, rewrites sources to migrate to new version.\n...\n-source            source version\n                   Default: 3.0.\n                   Choices: 3.0, future, 3.0-migration, future-migration.\n...\n```\n\n----------------------------------------\n\nTITLE: Scala Method with Original Parameters and @unroll Forwarders\nDESCRIPTION: This code snippet illustrates a Scala method annotated with @unroll, demonstrating how original method parameters are expanded into generated forwarders. These forwarders preserve binary compatibility when new parameters with defaults are added, by delegating calls to a primary method, adjusting parameters accordingly. It emphasizes the use of @unroll to enable backward-compatible evolution of APIs with default parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/unroll-default-arguments.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef foo(s: String, n: Int = 1, @unroll b: Boolean = true, @unroll l: Long = 0) = s + n + b + l\n\ndef foo(s: String, n: Int, b: Boolean) = foo(s, n, b, 0)\ndef foo(s: String, n: Int) = foo(s, n, true, 0)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Scaladoc's Context Wrapping Mechanism (Scala)\nDESCRIPTION: Shows the preprocessed Scala code generated internally by Scaladoc. It wraps the original snippet within a package and trait structure to provide the necessary context (e.g., `self: List[A]`) for compilation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/snippet-compiler.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\npackage scala.collection\ntrait Snippet[A] { self: List[A] =>\n  slice(2,5) == drop(2).take(3)\n}\n```\n\n----------------------------------------\n\nTITLE: Restrictions on Named Tuples - Mixed Named and Unnamed Elements\nDESCRIPTION: Demonstrates an illegal pattern where both named and unnamed elements are mixed in a tuple. All elements must either be named or unnamed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-tuples.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval illFormed1 = (\"Bob\", age = 33)  // error\n```\n\n----------------------------------------\n\nTITLE: Scala 2 Implementation of Capped2 Class Extending Iterable and IterableOps\nDESCRIPTION: This snippet defines the Capped2 class in Scala 2, which extends immutable.Iterable and IterableOps to create a custom collection with fixed capacity. It overrides methods for collection creation, transformation, and iteration, utilizing an associated factory class. The class design ensures that operations like map, filter, and take return Capped2 instances, maintaining collection integrity and performance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass Capped2[A] private (val capacity: Int, val length: Int, offset: Int, elems: Array[Any])\n  extends immutable.Iterable[A]\n    with IterableOps[A, Capped2, Capped2[A]] { self =>\n\n  def this(capacity: Int) = // as before\n\n  def appended[B >: A](elem: B): Capped2[B] = // as before\n  @`inline` def :+ [B >: A](elem: B): Capped2[B] = // as before\n  def apply(i: Int): A = // as before\n\n  def iterator: Iterator[A] = // as before\n\n  override def className = \"Capped2\"\n  override val iterableFactory: IterableFactory[Capped2] = new Capped2Factory(capacity)\n  override protected def fromSpecific(coll: IterableOnce[A]): Capped2[A] = iterableFactory.from(coll)\n  override protected def newSpecificBuilder: mutable.Builder[A, Capped2[A]] = iterableFactory.newBuilder\n  override def empty: Capped2[A] = iterableFactory.empty\n\n}\n\nclass Capped2Factory(capacity: Int) extends IterableFactory[Capped2] {\n\n  def from[A](source: IterableOnce[A]): Capped2[A] =\n    (newBuilder[A] ++= source).result()\n\n  def empty[A]: Capped2[A] = new Capped2[A](capacity)\n\n  def newBuilder[A]: mutable.Builder[A, Capped2[A]] =\n    new mutable.ImmutableBuilder[A, Capped2[A]](empty) {\n      def addOne(elem: A): this.type = { elems = elems :+ elem; this }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using add Method to Add Elements to Scala mutable Set with Boolean Result in Scala\nDESCRIPTION: Shows usage of the add method on mutable Set which attempts to add a single element, returning true if the element was successfully added and false if the element was already present. This provides a way to detect whether an insertion has mutated the set.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/set-class.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nset.add(6)\nset.add(5)\n```\n\n----------------------------------------\n\nTITLE: Handling Path Segments in Cask Endpoint (Scala)\nDESCRIPTION: Extends the Cask application to capture and use a dynamic segment from the URL path. The endpoint path is changed to `/time/:city`, where `:city` is a variable segment. The value of this segment is automatically passed as an argument (`city: String`) to the `dynamicWithCity` method. A helper function `getZoneIdForCity` attempts to find a timezone based on the provided city name using `java.time.ZoneId` and `scala.jdk.CollectionConverters`. The response includes the current time formatted for the found timezone or an error message.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/web-server-dynamic.md#_snippet_2\n\nLANGUAGE: Scala 2\nCODE:\n```\nimport java.time.{ZoneId, ZonedDateTime}\n\nobject Example extends cask.MainRoutes {\n\n  private def getZoneIdForCity(city: String): Option[ZoneId] = {\n    import scala.jdk.CollectionConverters._\n    ZoneId.getAvailableZoneIds.asScala.find(_.endsWith(\"/\" + city)).map(ZoneId.of)\n  }\n\n  @cask.get(\"/time/:city\")\n  def dynamicWithCity(city: String): String = {\n    getZoneIdForCity(city) match {\n      case Some(zoneId) => s\"Current date is: ${ZonedDateTime.now().withZoneSameInstant(zoneId)}\"\n      case None => s\"Couldn't find time zone for city $city\"\n    }\n  }\n\n  initialize()\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nimport java.time.{ZoneId, ZonedDateTime}\n\nobject Example extends cask.MainRoutes:\n\n  private def getZoneIdForCity(city: String): Option[ZoneId] =:\n    import scala.jdk.CollectionConverters.*\n    ZoneId.getAvailableZoneIds.asScala.find(_.endsWith(\"/\" + city)).map(ZoneId.of)\n  \n  @cask.get(\"/time/:city\")\n  def dynamicWithCity(city: String): String =:\n    getZoneIdForCity(city) match:\n      case Some(zoneId) => s\"Current date is: ${ZonedDateTime.now().withZoneSameInstant(zoneId)}\"\n      case None => s\"Couldn't find time zone for city $city\"\n\n  initialize()\n```\n\n----------------------------------------\n\nTITLE: Desired Behavior of `map` and `++` on RNA Sequences in Scala REPL\nDESCRIPTION: Illustrates the ideal, expected behavior when applying `map` and `++` to a properly implemented `RNA` sequence class in the Scala REPL. Mapping bases to bases (`map { case A => U case b => b }`) or appending another RNA strand (`rna ++ rna`) should yield an `RNA` instance. Mapping to a different type (`map Base.toInt`) or appending non-base elements (`rna ++ List(\"missing\", \"data\")`) should result in a more general sequence type like `IndexedSeq`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-collections.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val rna = RNA(A, U, G, G, C)\nrna: RNA = RNA(A, U, G, G, C)\n\nscala> rna map { case A => U case b => b }\nres7: RNA = RNA(U, U, G, G, C)\n\nscala> rna ++ rna\nres8: RNA = RNA(A, U, G, G, C, A, U, G, G, C)\n\nscala> rna map Base.toInt\nres2: IndexedSeq[Int] = Vector(0, 1, 2, 2, 3)\n\nscala> rna ++ List(\"missing\", \"data\")\nres3: IndexedSeq[java.lang.Object] =\n  Vector(A, U, G, G, C, missing, data)\n```\n\n----------------------------------------\n\nTITLE: Creating and populating a parallel trie map for iterative square root calculation\nDESCRIPTION: This code initializes a list of Entry objects with numbers from 1 to 49999 and adds them into a ParTrieMap for concurrent processing. The map enables thread-safe, parallel updates of the elements' square roots during the convergence process, facilitating efficient concurrent iteration and modification.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/parallel-collections/ctries.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval length = 50000\n\n// 准备链表\nval entries = (1 until length) map { num => Entry(num.toDouble) }\nval results = ParTrieMap()\nfor (e <- entries) results += ((e.num, e))\n```\n\n----------------------------------------\n\nTITLE: Completing a Promise with a Try and Using tryComplete Methods\nDESCRIPTION: This snippet discusses completing a Promise using `complete` with a `Try[T]`, handling failure with specific Throwable types, and using `tryComplete`, `trySuccess`, and `tryFailure` to attempt completion without exceptions. It highlights the deterministic nature of Promise-Future programs and use cases for first-success combinator.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_37\n\nLANGUAGE: Scala\nCODE:\n```\np.complete(/= Failure(new Throwable)) // where Throwable could be various subtypes\n// Methods like tryComplete, trySuccess, and tryFailure attempt to complete a Promise without throwing exceptions.\n\n// Example of a custom 'first' combinator:\ndef first[T](f: Future[T], g: Future[T]): Future[T] = {\n  val p = Promise[T]\n  f.foreach { x => p.trySuccess(x) }\n  g.foreach { x => p.trySuccess(x) }\n  p.future\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Boilerplate Code for Maintaining Binary Compatibility with Default Parameters\nDESCRIPTION: This snippet showcases a typical pattern in Scala where multiple method overloads are manually written to support binary compatibility amid evolution of API—particularly when adding default parameters. It highlights the verbosity and error-prone nature of such boilerplate, emphasizing the need for annotations like @unroll to simplify this pattern.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/unroll-default-arguments.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef constructEither(\n    args: Seq[String],\n    allowPositional: Boolean,\n    allowRepeats: Boolean,\n    totalWidth: Int,\n    printHelpOnExit: Boolean,\n    docsOnNewLine: Boolean,\n    autoPrintHelpAndExit: Option[(Int, PrintStream)],\n    customName: String,\n    customDoc: String,\n    sorted: Boolean,\n): Either[String, T] = constructEither(\n  args,\n  allowPositional,\n  allowRepeats,\n  totalWidth,\n  printHelpOnExit,\n  docsOnNewLine,\n  autoPrintHelpAndExit,\n  customName,\n  customDoc,\n  sorted,\n)\n```\n\n----------------------------------------\n\nTITLE: Assigning a New Value to a Boxed Content in Scala\nDESCRIPTION: This example assigns a Dog instance to the content field of an Animal box, illustrating that mutability allows replacing the value (if variance was permitted). Dependencies include an AnimalBox instance and the Dog class. The parameter myAnimalBox is a mutable container. This code highlights why mutable classes must be invariant to prevent type errors, as it allows changing the boxed type unpredictably.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/variances.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\n  myAnimalBox.content = Dog(\"Fido\")\n```\n\n----------------------------------------\n\nTITLE: Using Immutable BitSets in Scala for Fast Integer Set Operations\nDESCRIPTION: This snippet demonstrates the creation and usage of immutable BitSets in Scala, which store sets of small integers efficiently using bitwise representation within Long arrays. There are no additional dependencies beyond the Scala library. Examples show initialization, adding elements with '+', and testing membership with the function syntax (e.g., moreBits(3)). BitSets are optimal for sparse sets of small non-negative integers, offering constant-time membership checks; adding may be proportional to the size of the array.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/concrete-immutable-collection-classes.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nscala> val bits = scala.collection.immutable.BitSet.empty\nbits: scala.collection.immutable.BitSet = BitSet()\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> val moreBits = bits + 3 + 4 + 4\nmoreBits: scala.collection.immutable.BitSet = BitSet(3, 4)\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> moreBits(3)\nres26: Boolean = true\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> moreBits(0)\nres27: Boolean = false\n```\n\n----------------------------------------\n\nTITLE: Combining ..$ Splicing, $ Unquoting, and ..$ Splicing (Scala)\nDESCRIPTION: Demonstrates a more complex combination where a list of trees is spliced (`..$ab`), followed by a single tree unquoted (`$c`), followed by the same list of trees spliced again (`..$ab`) within a function application.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/intro.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val fabcab = q\"f(..$ab, $c, ..$ab)\"\nfabcab: universe.Tree = f(a, b, c, a, b)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating LazyList Behavior in Scala\nDESCRIPTION: Creates a potentially infinite `LazyList` using `LazyList.range` and demonstrates its non-strict (lazy) nature. Operations like `take` and `map` return new `LazyList` instances without computing elements until forced. This is valid for Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nval x = LazyList.range(1, Int.MaxValue)\nx.take(1)      // LazyList(<not computed>)\nx.take(5)      // LazyList(<not computed>)\nx.map(_ + 1)   // LazyList(<not computed>)\n```\n\n----------------------------------------\n\nTITLE: Using Overridden toString Method in Scala 2\nDESCRIPTION: This snippet demonstrates how to instantiate the `Complex` class and invoke the overridden `toString` method within a Scala 2 application, showcasing object string representation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\n```scala\nobject ComplexNumbers {\n  def main(args: Array[String]): Unit = {\n    val c = new Complex(1.2, 3.4)\n    println(\"Overridden toString(): \" + c.toString)\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Modifying Parallel String Collection to Use a Combiner (Scala)\nDESCRIPTION: Updates the `ParString` class definition to include the `ParSeqLike` trait. This trait helps ensure that transformer methods like `filter` return the specific `ParString` type instead of a more general `ParSeq[Char]`. A protected `newCombiner` method is added, responsible for creating instances of the custom `ParStringCombiner`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/overviews/parallel-collections/custom-parallel-collections.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass ParString(val str: String)\nextends immutable.ParSeq[Char]\n   with ParSeqLike[Char, ParString, collection.immutable.WrappedString]\n\n  // ... other methods remain the same ...\n\n  protected[this] override def newCombiner: Combiner[Char, ParString] = new ParStringCombiner\n```\n\n----------------------------------------\n\nTITLE: Accessing Fields of a Case Class in Scala\nDESCRIPTION: Accesses the 'title' field of 'emailDeJohn' directly, illustrating that case class parameters are public and accessible as fields. Also demonstrates printing the value to console.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/case-classes.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval titulo = emailDeJohn.title\nprintln(titulo) // prints \"Saudações do John!\"\n```\n\n----------------------------------------\n\nTITLE: Using MethodMirror to Invoke Instance Methods Reflectively in Scala\nDESCRIPTION: This snippet illustrates obtaining a MethodMirror to invoke an instance method reflectively. It retrieves the method symbol by name from the reflected type, then creates a method mirror bound to an instance. The method mirror can be invoked as a function call to execute the method. Prerequisites include a valid InstanceMirror and runtime mirror, as well as the correct method symbol. Input is a method symbol and instance mirror; output is the method invocation result.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/reflection/environment-universes-mirrors.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> val methodX = ru.typeOf[C].decl(ru.TermName(\"x\")).asMethod\nmethodX: scala.reflect.runtime.universe.MethodSymbol = method x\n\nscala> val mm = im.reflectMethod(methodX)\nmm: scala.reflect.runtime.universe.MethodMirror = method mirror for C.x: scala.Int (bound to C@3442299e)\n\nscala> mm()\nres0: Any = 2\n```\n\n----------------------------------------\n\nTITLE: Creating an Instance of a Case Class in Scala 2 and 3\nDESCRIPTION: Shows instantiation of the case class `Person` by passing concrete values to the constructor. The resulting instance holds immutable field values assigned at construction. This demonstrates the standard method for creating data objects in Scala using case classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_39\n\nLANGUAGE: scala\nCODE:\n```\nval christina = Person(\"Christina\", \"niece\")\n```\n\n----------------------------------------\n\nTITLE: Correctly Skipping Empty Words Using BufferedIterator in Scala\nDESCRIPTION: This snippet shows the proper way to skip initial empty strings in an iterator by using BufferedIterator's head method for lookahead without advancing the iterator. Inside the while loop, head is checked for emptiness and next() is called only if the condition is met. This preserves the first non-empty string during traversal.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/iterators.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef skipEmptyWords(it: BufferedIterator[String]) =\n  while (it.head.isEmpty) { it.next() }\n```\n\n----------------------------------------\n\nTITLE: Type Safety Violation when Reading from Variant Box in Scala\nDESCRIPTION: This snippet shows a failed downcast: extracting a Cat from a box after the content was assigned a Dog, leading to a logic error. Dependencies are myCatBox variable and prior assignments. If type system allowed this, the Cat variable would point to a Dog, which is unsafe. Highlights the importance of invariance for mutable containers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/variances.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\n  val myCat: Cat = myCatBox.content //myCat would be Fido the dog!\n```\n\n----------------------------------------\n\nTITLE: Declaring Mutable Variables (var) in Scala - Scala\nDESCRIPTION: Shows how to declare a mutable variable using the var keyword, allowing reassignment of values after initialization. The type of the variable can be declared explicitly or inferred. Variable reassignment is demonstrated.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/tour/basics.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nvar x = 1 + 1\nx = 3 // reassignment allowed\nprintln(x * x) // 9\n```\n\nLANGUAGE: Scala\nCODE:\n```\nvar x: Int = 1 + 1\n```\n\n----------------------------------------\n\nTITLE: Using '_root_' for Absolute Import in Scala\nDESCRIPTION: This snippet demonstrates importing with the '_root_' prefix to access top-level packages from nested packages, avoiding naming conflicts. It shows importing all members from 'users' package from within the 'accounts' package, ensuring unambiguous references.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/packages-and-imports.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\npackage accounts\n\nimport _root_.users._\n```\n\n----------------------------------------\n\nTITLE: Illustrating Non-deterministic Callback Execution in Scala\nDESCRIPTION: Demonstrates the potential for race conditions when multiple callbacks registered on the same `Future` modify shared mutable state (`@volatile var totalA`). Since the execution order and concurrency of callbacks are not guaranteed, the final value of `totalA` might be incorrect due to interleaved read/write operations from the concurrent `foreach` callbacks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\n@volatile var totalA = 0\n\nval text = Future {\n  \"na\" * 16 + \"BATMAN!!!\"\n}\n\ntext.foreach { txt =>\n  totalA += txt.count(_ == 'a')\n}\n\ntext.foreach { txt =>\n  totalA += txt.count(_ == 'A')\n}\n```\n\n----------------------------------------\n\nTITLE: Using Ternary Operator in a Method in Java\nDESCRIPTION: Java can use the ternary operator (`? :`) as a concise way to write a simple `if-else` expression, often used for returning a value directly from a method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_36\n\nLANGUAGE: Java\nCODE:\n```\npublic int min(int a, int b) {\n  return (a < b) ? a : b;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the first version of RNA sequence class in Scala\nDESCRIPTION: The initial implementation of RNA1 class that extends IndexedSeq[Base] with a private constructor and companion object for creation. This version provides basic functionality but doesn't properly handle return types for collection operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/architecture-of-scala-collections.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport collection.IndexedSeqLike\nimport collection.mutable.{Builder, ArrayBuffer}\nimport collection.generic.CanBuildFrom\n\nfinal class RNA1 private (val groups: Array[Int],\n    val length: Int) extends IndexedSeq[Base] {\n\n  import RNA1._\n\n  def apply(idx: Int): Base = {\n    if (idx < 0 || length <= idx)\n      throw new IndexOutOfBoundsException\n    Base.fromInt(groups(idx / N) >> (idx % N * S) & M)\n  }\n}\n\nobject RNA1 {\n\n  // 表示一组所需要的比特数\n  private val S = 2            \n\n  // 一个Int能够放入的组数\n  private val N = 32 / S       \n\n  // 分离组的位掩码(bitmask)\n  private val M = (1 << S) - 1\n\n  def fromSeq(buf: Seq[Base]): RNA1 = {\n    val groups = new Array[Int]((buf.length + N - 1) / N)\n    for (i <- 0 until buf.length)\n      groups(i / N) |= Base.toInt(buf(i)) << (i % N * S)\n    new RNA1(groups, buf.length)\n  }\n\n  def apply(bases: Base*) = fromSeq(bases)\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Referential Transparency via Unquoting Symbol - Scala\nDESCRIPTION: Offers another workaround for referential transparency. The macro implementation resolves the symbol for the intended `wrapper` method using the reflection API (`symbolOf`, `member`) and unquotes the symbol reference directly into the quasiquote (`q\"$wrapper($x)\"`). This guarantees that the correct definition is used, bypassing potential name resolution issues at the call site.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/hygiene.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ndef impl(c: Context)(x: c.Tree) = {\n  import c.universe._\n  val myMacro = symbolOf[MyMacro.type].asClass.module\n  val wrapper = myMacro.info.member(TermName(\"wrapper\"))\n  q\"$wrapper($x)\"\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Illegal Cross-Graph Node Connection in Scala\nDESCRIPTION: Shows an example where nodes from different graph instances are mistakenly mixed, leading to a type error in Scala. This snippet emphasizes Scala's strict enforcement of path-dependent types which disallow connecting nodes from separate Graph objects. The example contrasts Scala's behavior with Java, where such mixing is allowed due to different type resolution.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/inner-classes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nobject IllegalGraphTest extends App {\n  val g: Graph = new Graph\n  val n1: g.Node = g.newNode\n  val n2: g.Node = g.newNode\n  n1.connectTo(n2)      // legal\n  val h: Graph = new Graph\n  val n3: h.Node = h.newNode\n  n1.connectTo(n3)      // ilegal!\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Generic Reference Class to Store Integer Values in Scala 2\nDESCRIPTION: Provides an example of using the Reference class by creating an IntegerReference object with a main method. It instantiates Reference[Int] to hold an integer, sets its value to 13 using set(), and prints double the stored value. This demonstrates type-safe generic usage without casting and enforcing that only integers can be stored. Dependencies include the previously defined Reference class. Inputs are the integer passed to set(), and the output is the printed string using get().\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\nobject IntegerReference {\n  def main(args: Array[String]): Unit = {\n    val cell = new Reference[Int]\n    cell.set(13)\n    println(\"Reference contains the half of \" + (cell.get * 2))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Type Inference Challenges with 'foldLeft1' Method in Scala\nDESCRIPTION: This snippet illustrates issues with type inference when attempting to call a variadic 'foldLeft1' method with an inline lambda '_ + _'. It demonstrates that Scala cannot infer the types of '_ + _' without explicit type annotations, leading to compilation failure. Providing explicit type parameters allows successful invocation. Dependencies include Scala's type inference mechanics. The inputs are lists and lambdas; the output is the result of the fold operation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/multiple-parameter-lists.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef foldLeft1[A, B](as: List[A], b0: B, op: (B, A) => B) = ???\n\n// Failing invocation\n// def notPossible = foldLeft1(numbers, 0, _ + _)\n\n// Correct invocations with explicit types\nval firstWay = foldLeft1[Int, Int](numbers, 0, _ + _)\nval secondWay = foldLeft1(numbers, 0, (a: Int, b: Int) => a + b)\n```\n\n----------------------------------------\n\nTITLE: Importing Members from Packages with Renaming and Hiding - Scala\nDESCRIPTION: Demonstrates importing members from packages with varying granularity, including importing all members, specific members, renaming imports to avoid naming conflicts, and hiding members to exclude them from imports. Includes examples importing several members at once, aliasing members (e.g., Java classes renamed during import), and hiding one or more members using underscore aliases. These features enhance flexibility and control over namespace collisions and importing scope. Requires Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/packaging-imports.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport users.*                            // imports all from package 'users'\nimport users.User                         // imports only the 'User' class\nimport users.{User, UserPreferences}      // imports two specific package members\nimport users.{UserPreferences as UPrefs}  // rename imported member\n\nimport java.util.{List as JavaList}\n\nimport java.util.{Date as JDate, HashMap as JHashMap, *}\n\nimport java.util.{Random as _, *}\n\nscala> import java.util.{List as _, Map as _, Set as _, *}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Interpolator using Extension Method in Scala 3\nDESCRIPTION: Provides the Scala 3 implementation structure for a custom string interpolator (`p`). It uses an `extension` method on `StringContext` to define the `p` method. This method receives arguments (`Any*`) representing the interpolated expressions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nextension (sc: StringContext)\n  def p(args: Any*): Point = ???\n```\n\n----------------------------------------\n\nTITLE: Writing Hello World Program Using Scala 3\nDESCRIPTION: This Scala 3 snippet defines a Hello World program as a top-level method annotated with @main. The method HelloWorld takes a variable-length argument sequence representing the command-line arguments and prints \"Hello, World!\". Scala 3 introduces the @main macro annotation, which generates the necessary JVM-compatible static main method at compile time, removing the need for singleton objects to host static entry-points. The method’s return type Unit indicates no return value. This snippet demonstrates the concise and modern syntax improvements in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n@main def HelloWorld(args: String*): Unit =\n  println(\"Hello, World!\")\n```\n\n----------------------------------------\n\nTITLE: Generated Output Structure from Scaladoc\nDESCRIPTION: Demonstrates the resulting output files generated by Scaladoc from the basic directory structure example.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/static-site.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nindex.html\ngetting-started.html\n```\n\n----------------------------------------\n\nTITLE: Generated Output Structure in Scaladoc\nDESCRIPTION: Shows the structure of files in the generated documentation after Scaladoc processes the source files.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/static-site.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nindex.html\ngetting-started.html\n```\n\n----------------------------------------\n\nTITLE: 使用可变字段定义Person类(Scala 3)\nDESCRIPTION: 展示如何在Scala 3中创建带有可变字段的类。这个例子定义了Person类，其中firstName和lastName是可变的var参数，可以在对象创建后修改。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-modeling.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass Person(var firstName: String, var lastName: String):\n  def printFullName() = println(s\"$firstName $lastName\")\n\nval p = Person(\"John\", \"Stephens\")\nprintln(p.firstName)   // \"John\"\np.lastName = \"Legend\"\np.printFullName()      // \"John Legend\"\n```\n\n----------------------------------------\n\nTITLE: Defining a given Ordering Instance Using Legacy Scala 3 Syntax in Scala\nDESCRIPTION: Demonstrates the original Scala 3 syntax for defining an anonymous given Ordering instance for List[A], using the 'with' keyword and colon placement deemed awkward and inconsistent. The snippet shows how the existing syntax uses a colon before the implemented type and a trailing 'with' to start the body. This style is criticized for being unnatural and harder to learn.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\ngiven [A](using Ord[A]): Ord[List[A]] with\n  def compare(x: List[A], y: List[A]) = ...\n```\n\n----------------------------------------\n\nTITLE: Intuitive (Incorrect) Desugaring Expectation\nDESCRIPTION: Shows the simpler desugaring one might intuitively expect for the preceding example, involving a single `map` operation. This highlights the discrepancy between user expectation and the actual current desugaring.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndoSth(arg).map { a =>\n  val b = a\n  a + b\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Snippet Compiler for a Specific Path\nDESCRIPTION: This command-line argument example shows how to enable the snippet compiler (`compile` flag) specifically for documentation files located within the `docs` directory or its subdirectories. This provides finer-grained control over which parts of the project have snippet testing enabled.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/snippet-compiler.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n-snippet-compiler:docs=compile\n```\n\n----------------------------------------\n\nTITLE: Type-Level Arithmetic and Refinement with Singleton-Ops in Scala\nDESCRIPTION: Defines a generic class MyVec parameterized on a singleton type L representing a length. Methods demonstrate type-level arithmetic using singleton-ops, e.g., doubling size and scaling length by another type-level integer N. The getLength method retrieves the runtime Int value from the singleton type L via an implicit SafeInt[L]. The companion object uses an implicit Require[L > 0] to enforce that MyVec instances cannot be created with non-positive lengths, ensuring compile-time correctness. The example shows valid and invalid instantiations of MyVec with different length parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/42.type.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport singleton.ops._\n\nclass MyVec[L] {\n  def doubleSize = new MyVec[2 * L]\n  def nSize[N] = new MyVec[N * L]\n  def getLength(implicit length : SafeInt[L]) : Int = length\n}\nobject MyVec {\n  implicit def apply[L]\n    (implicit check : Require[L > 0]) : MyVec[L] =\n       new MyVec[L]()\n}\nval myVec : MyVec[10] = MyVec[4 + 1].doubleSize\nval myBadVec = MyVec[-1] //fails compilation, as required\n```\n\n----------------------------------------\n\nTITLE: Defining an Unapply Method (Extractor) in Companion Object in Scala\nDESCRIPTION: This snippet implements an unapply method within a companion object, enabling manual extraction of a Person instance's internal fields. The unapply receives a Person and returns a string combining its properties, thus facilitating pattern deconstruction. There are no external dependencies; the main parameter is p: Person, output is a formatted String. The core limitation is that the result is always a String, which may constrain downstream pattern-matching use cases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/companion-objects.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass Person(var name: String, var age: Int)\n\nobject Person {\n    def unapply(p: Person): String = s\"${p.name}, ${p.age}\"\n}\n```\n\n----------------------------------------\n\nTITLE: Structuring Package Documentation using package.scala in Scala\nDESCRIPTION: Illustrates the standard structure for providing package-level Scaladoc. Documentation is placed in a comment block preceding a package object definition within a `package.scala` file located in the corresponding package directory.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/scaladoc.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\npackage parent.package.name\n\n/** This is the Scaladoc for the package. */\npackage object mypackage {\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating Animal Class\nDESCRIPTION: Creates an instance of the `Animal` class. This instance is then passed to the `getType` helper function in a subsequent step to demonstrate type reflection on instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nscala> val a = new Animal\na: Animal = Animal@21c17f5a\n```\n\n----------------------------------------\n\nTITLE: Example of Optimized `for`-`yield` Desugaring Input in Scala\nDESCRIPTION: A simple Scala `for`-comprehension that iterates over a `List` and yields the iteration variable itself. This pattern triggers the optimized desugaring rule.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nfor\n  a <- List(1, 2, 3)\nyield a\n```\n\n----------------------------------------\n\nTITLE: Using the `Iso` Trait to Convert Case Class to Tuple (Scala)\nDESCRIPTION: Illustrates the use case for the `Iso` trait. A case class `Foo` and a generic conversion function `conv` are defined. `conv` takes an instance `c` of type `C` and implicitly requires an `Iso[C, L]` to convert `c` to type `L`. The example shows converting a `Foo` instance to a tuple `(Int, String, Boolean)`, highlighting the compiler's challenge in inferring the type `L` before macro expansion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/implicits.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ncase class Foo(i: Int, s: String, b: Boolean)\ndef conv[C, L](c: C)(implicit iso: Iso[C, L]): L = iso.to(c)\n\nval tp  = conv(Foo(23, \"foo\", true))\ntp: (Int, String, Boolean)\ntp == (23, \"foo\", true)\n```\n\n----------------------------------------\n\nTITLE: Multi-line for loops in Scala 2 and 3\nDESCRIPTION: Syntax for for loops with multi-line code blocks, demonstrating how to execute multiple statements for each iteration in both Scala versions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/control-structures.md#_snippet_8\n\nLANGUAGE: Scala 2\nCODE:\n```\nfor (i <- ints) {\n  val x = i * 2\n  println(s\"i = $i, x = $x\")\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nfor i <- ints\ndo\n  val x = i * 2\n  println(s\"i = $i, x = $x\")\n```\n\n----------------------------------------\n\nTITLE: Defining Combiner trait in Scala parallel collections\nDESCRIPTION: The Combiner trait extends Builder and adds a combine method that merges two combiners. Combiners are used to aggregate results from different partitions processed in parallel, combining them into a final collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/parallel-collections/architecture.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntrait Combiner[Elem, To] extends Builder[Elem, To] {\n    def combine(other: Combiner[Elem, To]): Combiner[Elem, To]\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Macro API Compatibility with Universe.internal and Context.internal (Scala)\nDESCRIPTION: Provides a cross-compatible macro implementation usable in both 2.10.x and 2.11.0 by using a private stub object to supply a missing 'compat' import on Scala 2.10.x. Demonstrates usage of 'Tree.setType', which was removed in 2.11, via 'compat._'. Depends on 'scala-reflect', 'scala.language.experimental.macros', and custom compatibility logic. Returns an Int by constructing a typed literal inside the macro.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/changelog211.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n// scala.reflect.macros.Context is available both in 2.10 and 2.11\n// in Scala 2.11.0 it is deprecated\n// and aliased to scala.reflect.macros.whitebox.Context\nimport scala.reflect.macros.Context\nimport scala.language.experimental.macros\n\n// provides a source compatibility stub\n// in Scala 2.10.x, it will make `import compat._` compile just fine,\n// even though `c.universe` doesn't have `compat`\n// in Scala 2.11.0, it will be ignored, because `import c.universe._`\n// brings its own `compat` in scope and that one takes precedence\nprivate object HasCompat { val compat = ??? }; import HasCompat._\n\nobject Macros {\n  def impl(c: Context): c.Expr[Int] = {\n    import c.universe._\n    // enables Tree.setType that's been removed in Scala 2.11.0\n    import compat._\n    c.Expr[Int](Literal(Constant(42)) setType definitions.IntTpe)\n  }\n\n  def ultimateAnswer: Int = macro impl\n}\n```\n\n----------------------------------------\n\nTITLE: Java Code Attempting to Instantiate Scala Class with Default Parameters\nDESCRIPTION: Java code tries to instantiate 'Point' with a single argument, which is invalid because Java does not support default parameters from Scala. Developers must specify all parameters explicitly when creating Scala classes from Java code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/default-parameter-values.md#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\n// Main.java\npublic class Main {\n    public static void main(String[] args) {\n        Point point = new Point(1);  // compile error\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Exploring Additional Expressions in the Scala REPL - Scala\nDESCRIPTION: Presents a sequence of sample expressions for users to try in the REPL, demonstrating variable assignment, string operations, arithmetic, and conditional expressions. No additional libraries are needed; the code showcases various features of the Scala standard library. Outputs will vary depending on the input and the state of the REPL session.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/scala-repl.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval name = \"John Doe\"\n\"hello\".head\n\"hello\".tail\n\"hello, world\".take(5)\nprintln(\"hi\")\n1 + 2 * 3\n(1 + 2) * 3\nif (2 > 1) println(\"greater\") else println(\"lesser\")\n```\n\n----------------------------------------\n\nTITLE: Declaring a simple trait in Scala\nDESCRIPTION: A minimal trait declaration using the 'trait' keyword with just a name. This example shows the simplest form of a trait without any methods or fields.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/traits.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait HairColor\n```\n\n----------------------------------------\n\nTITLE: Example Showing Ambiguity from Importing Multiple Extension Method Sources in Scala\nDESCRIPTION: This snippet demonstrates the ambiguity issue when importing two extension method sources (`PathExtensions` and `URIExtensions`) defining `/` methods for different receiver types into the same scope. Attempting to use `/` on both `Path` and `URI` instances results in a compiler error for ambiguous references due to overlapping extension methods. It exemplifies the problem solved by SIP-54. Requires prior definitions of `PathExtensions` and `URIExtensions` with appropriate extension methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/multi-source-extension-overloads.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef app(): Unit =\n  import PathExtensions.*\n  import URIExtensions.*\n\n  val projectDir = Paths.get(\".\") / \"project\"\n  val rootURI = new URI(\"https://www.example.com/\")\n  val projectURI = rootURI / \"project/\"\n  println(s\"$projectDir -> $projectURI\")\nend app\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Contravariant Serializer in Scala 2\nDESCRIPTION: Declares a Serializer abstract class contravariant in its type parameter (-A), with a single serialize method. Demonstrates assigning a Serializer[Animal] to a variable of type Serializer[Cat], due to contravariance, and serializing a Cat. Dependencies are minimal; Serializers must implement serialize(a: A): String. Purpose is to show contravariant subtyping in action, particularly for APIs that consume values such as serializers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/variances.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Serializer[-A] {\n  def serialize(a: A): String\n}\n\nval animalSerializer: Serializer[Animal] = new Serializer[Animal] {\n  def serialize(animal: Animal): String = s\"\"\"{ \\\"name\\\": \\\"${animal.name}\\\" }\"\"\"\n}\nval catSerializer: Serializer[Cat] = animalSerializer\ncatSerializer.serialize(Cat(\"Felix\"))\n```\n\n----------------------------------------\n\nTITLE: Extending Parameterized Traits with Arguments in Scala Classes - Scala\nDESCRIPTION: This code snippet highlights the restriction that only classes can pass arguments to parameterized traits and demonstrates the correct way to extend a parameterized trait `T` in classes. It shows that a class `C` extending trait `U` (which itself extends `T`) must directly extend `T` with parameters to ensure `T` receives arguments. Two syntactically different but semantically equivalent forms for class `C` are shown, illustrating the initialization linearization order where `T` is initialized before `U`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/trait-parameters.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass C extends T(e) with U\nclass C extends U with T(e)\n```\n\n----------------------------------------\n\nTITLE: Defining a Hello World Application in Scala 2\nDESCRIPTION: This Scala 2 snippet defines a singleton object named `hello` containing a `main` method that takes an array of strings as its argument and prints \"Hello, World!\" to the standard output. The `object` keyword indicates a singleton instance, and the main method serves as the program's entry point. The example requires a Scala 2 compiler (`scalac`) to compile and the Scala runtime (`scala`) to execute. The input parameter `args` is currently unused. The output of the program is the standard printed greeting string.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-hello-world.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject hello {\n  def main(args: Array[String]) = {\n    println(\"Hello, World!\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Behavior to Pizza Class (Scala)\nDESCRIPTION: Extends the `Pizza` class to include methods for managing its state, specifically adding and removing toppings (`addTopping`, `removeTopping`, `removeAllToppings`). It also includes a method signature `getPrice` using `???` as a placeholder, indicating that the method's body is not yet implemented but the signature is valid. The class requires `scala.collection.mutable.ArrayBuffer` for the `toppings` field.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/oop-pizza-example.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass Pizza (\n    var crustSize: CrustSize,\n    var crustType: CrustType,\n    val toppings: ArrayBuffer[Topping]\n) {\n\n    def addTopping(t: Topping): Unit = toppings += t\n    def removeTopping(t: Topping): Unit = toppings -= t\n    def removeAllToppings(): Unit = toppings.clear()\n\n}\n\ndef getPrice(\n    toppingsPrices: Map[Topping, Int],\n    crustSizePrices: Map[CrustSize, Int],\n    crustTypePrices: Map[CrustType, Int]\n): Int = ???\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invariance Type Error with Mutable Box in Scala 2\nDESCRIPTION: This snippet shows that assigning a Box[Cat] to a variable of type Box[Animal] results in a compilation error due to invariance. It uses the earlier defined Box, Cat, and Animal types. The code demonstrates a failed attempt to treat Box[Cat] as Box[Animal], followed by accessing the content. It is marked as a compile-time failure (e.g., with scala mdoc:fail). The limitation is that mutable containers cannot be safely made covariant.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/variances.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval myCatBox: Box[Cat] = new Box[Cat](Cat(\"Felix\"))\nval myAnimalBox: Box[Animal] = myCatBox // this doesn't compile\nval myAnimal: Animal = myAnimalBox.content\n```\n\n----------------------------------------\n\nTITLE: Defining Logarithm Class with Arithmetic in Scala\nDESCRIPTION: Defines a Logarithm class encapsulating a logarithmic representation of a Double value, offering methods to convert back to Double and to perform addition and multiplication operations. The companion object provides an apply method for convenient instantiation using Double values that are log-transformed. This implementation offers clear abstraction but introduces performance overhead due to instantiation and conversions during operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-opaque-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Logarithm(protected val underlying: Double):\n  def toDouble: Double = math.exp(underlying)\n  def + (that: Logarithm): Logarithm =\n    // here we use the apply method on the companion\n    Logarithm(this.toDouble + that.toDouble)\n  def * (that: Logarithm): Logarithm =\n    new Logarithm(this.underlying + that.underlying)\n\nobject Logarithm:\n  def apply(d: Double): Logarithm = new Logarithm(math.log(d))\n```\n\n----------------------------------------\n\nTITLE: Copying and Modifying Case Class Instances in Scala\nDESCRIPTION: Presents the use of the 'copy' method to create a shallow copy of a case class instance with optional parameter overrides. The example shows swapping sender and recipient while preserving the original message body. Dependencies include the implicit 'copy' method provided by the Scala compiler for case classes. Inputs consist of an original 'Message' instance; output is a new instance reflecting the changes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tour/case-classes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ncase class Message(sender: String, recipient: String, body: String)\nval message4 = Message(\"julien@bretagne.fr\", \"travis@washington.us\", \"Me zo o komz gant ma amezeg\")\nval message5 = message4.copy(sender = message4.recipient, recipient = \"claire@bourgogne.fr\")\nmessage5.sender  // travis@washington.us\nmessage5.recipient // claire@bourgogne.fr\nmessage5.body  // \"Me zo o komz gant ma amezeg\"\n```\n\n----------------------------------------\n\nTITLE: Using Scala 3 Match Expression as Value\nDESCRIPTION: This snippet demonstrates the Scala 3 syntax (using indentation instead of braces) for a `match` expression used to return a value. It matches an input `i` against various cases and assigns the result to `numAsString`, showcasing `match` as an expression in the newer syntax style.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/why-scala-3.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nval numAsString = i match\n  case 1 | 3 | 5 | 7 | 9 => \"odd\"\n  case 2 | 4 | 6 | 8 | 10 => \"even\"\n  case _ => \"too big\"\n```\n\n----------------------------------------\n\nTITLE: Checking Tuple Arity Support in Scala Reflection\nDESCRIPTION: Shows how to check if a specific tuple arity (e.g., 10 or 23) is supported by the current Scala reflection implementation using `definitions.TupleClass(arity) != NoSymbol`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\nscala> val `tuple 10 supported?` = definitions.TupleClass(10) != NoSymbol\ntuple 10 supported?: Boolean = true\n\nscala> val `tuple 23 supported?` = definitions.TupleClass(23) != NoSymbol\ntuple 23 supported?: Boolean = false\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom TaskSupport Trait in Scala Parallel Collections\nDESCRIPTION: This example outlines the key methods required to implement a custom task scheduling support by extending the TaskSupport trait in Scala. It requires implementing execute, executeAndWaitResult, and parallelismLevel methods. The execute method runs a task asynchronously and returns a function serving as a future for the result. The executeAndWaitResult method runs a task synchronously, blocking until completion and returning the result. The parallelismLevel method returns an integer indicating the preferred concurrency level. This allows flexible customization of task scheduling strategies beyond the provided defaults.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/parallel-collections/configuration.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef execute[R, Tp](task: Task[R, Tp]): () => R\n\ndef executeAndWaitResult[R, Tp](task: Task[R, Tp]): R\n\ndef parallelismLevel: Int\n```\n\n----------------------------------------\n\nTITLE: Defining Sealed Trait and Case Classes for Notifications (Scala 2 and 3)\nDESCRIPTION: Defines a sealed trait Notification and three case classes Email, SMS, and VoiceRecording that extend this trait. Each case class encapsulates different fields that describe the type of notification: Email has sender, title, and body; SMS has caller and message; VoiceRecording has contactName and link. The sealed trait ensures all implementations are known at compile-time enabling exhaustive pattern matching. This structuring sets up for advanced pattern matching with class extractors.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/pattern-matching.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait Notification\n\ncase class Email(sender: String, title: String, body: String) extends Notification\n\ncase class SMS(caller: String, message: String) extends Notification\n\ncase class VoiceRecording(contactName: String, link: String) extends Notification\n```\n\n----------------------------------------\n\nTITLE: 임포트 구문을 통한 멤버 참조 및 이름 변경 스칼라\nDESCRIPTION: 스칼라에서 원하는 패키지나 클래스 멤버를 다른 네임스페이스에서 접근하기 위해 사용하는 다양한 임포트 구문을 설명합니다. 전체 패키지 임포트(users._), 선택된 멤버 임포트, 멤버 이름 변경(import users.{UserPreferences => UPrefs}) 기법들을 소개합니다. 이로써 코드 간결성 및 네임스페이스 간 충돌 방지에 유용하며, 임포트 구문은 어디서든 활용할 수 있습니다.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/packages-and-imports.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport users._  // users 패키지 전부를 임포트한다\nimport users.User  // User 클래스를 임포트한다\nimport users.{User, UserPreferences}  // 선택된 멤버만 임포트한다\nimport users.{UserPreferences => UPrefs}  // 편의를 위해 이름을 바꾸고 임포트한다\n```\n\n----------------------------------------\n\nTITLE: Summoning Type Instances for All Types in a Tuple and Returning as Expression\nDESCRIPTION: A recursive function that summons type class instances for each type in a tuple type and combines them into a single expression representing the tuple. Returns None if any instance cannot be summoned.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/faq.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef summonAll[T](using Type[T])(using Quotes): Option[Expr[Tuple]]] = {\n  Type.of[T] match\n    case '[ head *: tail ] =>\n      for headExpr <- Expr.summon[head]\n          tailExpr <- summonAll[tail]\n      yield '{ headExpr *: tailExpr }\n    case '[ EmptyTuple ] => Some('{ EmptyTuple })\n    case _ => None\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Scaladoc Site Root in SBT\nDESCRIPTION: Shows how to configure the site root directory in SBT build settings using scalacOptions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/static-site.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nCompile / doc / scalacOptions ++= Seq(\"-siteroot\", \"docs\")\n```\n\n----------------------------------------\n\nTITLE: Proposed Context-Free Syntax for Scala 3 'given' Definitions\nDESCRIPTION: Presents a formal grammar defining the complete context-free syntax for Scala 3 'given' definitions. Specifies production rules covering identifiers, given signatures, implementations (including expressions and template bodies), conditional givens, and type bounds. This syntax underpins the new given construct forms, supporting typeclass implementations, parameterized givens, aliases, abstract and by-name givens, as well as optional naming conventions. It supports both the current and proposed syntax styles.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\nTmplDef           ::=  'given' GivenDef\nGivenDef          ::=  [id ':'] GivenSig\nGivenSig          ::=  GivenImpl\n                    |  '(' ')' '=>' GivenImpl\n                    |  GivenConditional '=>' GivenSig\nGivenImpl         ::=  GivenType ([‘=’ Expr] | TemplateBody)\n                    |  ConstrApps TemplateBody\nGivenConditional  ::=  DefTypeParamClause\n                    |  DefTermParamClause\n                    |  '(' FunArgTypes ')'\n                    |  GivenType\nGivenType         ::=  AnnotType1 {id [nl] AnnotType1}\n\nTypeDef           ::=  id [TypeParamClause] TypeAndCtxBounds\nTypeParamBounds   ::=  TypeAndCtxBounds\nTypeAndCtxBounds  ::=  TypeBounds [‘:’ ContextBounds]\nContextBounds     ::=  ContextBound | '{' ContextBound {',' ContextBound} '}'\nContextBound      ::=  Type ['as' id]\n\nFunType           ::=  FunTypeArgs (‘=>’ | ‘?=>’) Type\n                    |  DefTypeParamClause '=>' Type\nFunExpr           ::=  FunParams (‘=>’ | ‘?=>’) Expr\n                    |  DefTypeParamClause ‘=>’ Expr\n```\n\n----------------------------------------\n\nTITLE: Macro-Based AST Manipulation with Quasiquotes in Scala\nDESCRIPTION: Defines an experimental macro that prints the code of each expression before executing it, enabling AST rewriting through quasiquote patterns. Depends on Scala macros and the reflection API (`Context`, `c.universe._`). The macro expects any block of code as an argument and returns a rewritten block where each statement is logged; output includes debug prints and possible runtime exceptions from wrapped statements. Intended for use in development or debugging scenarios.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/usecases.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n// macro that prints the expression code before executing it\nobject debug {\n  def apply[T](x: => T): T = macro impl\n  def impl(c: Context)(x: c.Tree) = { import c.universe._\n    val q\"..$stats\" = x\n    val loggedStats = stats.flatMap { stat =>\n      val msg = \"executing \" + showCode(stat)\n      List(q\"println($msg)\", stat)\n    }\n    q\"..$loggedStats\"\n  }\n}\n\n// usage\nobject Test extends App {\n  def faulty: Int = throw new Exception\n  debug {\n    val x = 1\n    val y = x + faulty\n    x + y\n  }\n}\n\n// output\nexecuting val x: Int = 1\nexecuting val y: Int = x.+(Test.this.faulty)\njava.lang.Exception\n...\n```\n\n----------------------------------------\n\nTITLE: Simple Scala 'match' expression as a switch statement\nDESCRIPTION: Demonstrates a basic 'match' expression in Scala, similar to Java's 'switch', matching integer values 1 through 12 to month names, with a default case for invalid input.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/match-expressions.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n// i is an integer\ni match {\n    case 1  => println(\"January\")\n    case 2  => println(\"February\")\n    case 3  => println(\"March\")\n    case 4  => println(\"April\")\n    case 5  => println(\"May\")\n    case 6  => println(\"June\")\n    case 7  => println(\"July\")\n    case 8  => println(\"August\")\n    case 9  => println(\"September\")\n    case 10 => println(\"October\")\n    case 11 => println(\"November\")\n    case 12 => println(\"December\")\n    // catch the default with a variable so you can print it\n    case _  => println(\"Invalid month\")\n}\n```\n\n----------------------------------------\n\nTITLE: Объявление переменных `String` и `Char` в Scala\nDESCRIPTION: Демонстрирует базовое объявление переменных типа `String` (с использованием двойных кавычек) и `Char` (с использованием одинарных кавычек).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-vars-data-types.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval name = \"Bill\"   // String\nval c = 'a'         // Char\n```\n\n----------------------------------------\n\nTITLE: Defining Base Types for RNA Sequences in Scala\nDESCRIPTION: Defines the fundamental building blocks (A, U, G, C) for an RNA sequence collection using an abstract class `Base` and case objects. The companion object provides utility functions `fromInt` (Array-based) and `toInt` (Map-based) for conversion between `Base` objects and integers (0-3).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-collections.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Base\ncase object A extends Base\ncase object U extends Base\ncase object G extends Base\ncase object C extends Base\n\nobject Base {\n  val fromInt: Int => Base = Array(A, U, G, C)\n  val toInt: Base => Int = Map(A -> 0, U -> 1, G -> 2, C -> 3)\n}\n```\n\n----------------------------------------\n\nTITLE: Result of Optimized `for`-`yield` Desugaring in Scala\nDESCRIPTION: Shows the desugared form of the previous example (`for a <- List(1, 2, 3) yield a`). Due to the optimization rule, it simplifies directly to the original collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nList(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Defining Compile-Time Macros and Accessing Compile-Time Mirrors in Scala - scala\nDESCRIPTION: Illustrates how to use Scala macros to create compile-time mirrors via macro context, enabling symbolic reflection during compilation. It shows the use of `scala.reflect.macros.Context` to access compile-time mirror, look up static modules by name, and build expressions dynamically. Dependencies include macro support enabled in the Scala compiler and the macro paradise plugin if required. Inputs involve source code location data, and outputs are compile-time expressions that embed source position metadata. Limitations include reliance on macro-enabled compilation and context availability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/reflection/environment-universes-mirrors.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect.macros.Context\n\ncase class Location(filename: String, line: Int, column: Int)\n\nobject Macros {\n  def currentLocation: Location = macro impl\n\n  def impl(c: Context): c.Expr[Location] = {\n    import c.universe._\n    val pos = c.macroApplication.pos\n    val clsLocation = c.mirror.staticModule(\"Location\") // get symbol of \"Location\" object\n    c.Expr(Apply(Ident(clsLocation), List(Literal(Constant(pos.source.path)), Literal(Constant(pos.line)), Literal(Constant(pos.column)))))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Compile-Time Power Function in Scala 3\nDESCRIPTION: This implementation of powerCode extracts values from expressions, performs a calculation at compile time, and creates a new expression with the result. It demonstrates valueOrAbort for extracting primitive values from expressions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/macros.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef pow(x: Double, n: Int): Double =\n  if n == 0 then 1 else x * pow(x, n - 1)\n\ndef powerCode(\n  x: Expr[Double],\n  n: Expr[Int]\n)(using Quotes): Expr[Double] =\n  val value: Double = pow(x.valueOrAbort, n.valueOrAbort)\n  Expr(value)\n```\n\n----------------------------------------\n\nTITLE: Current Syntax Examples of Unnamed given Definitions in Scala\nDESCRIPTION: Lists existing Scala 3 syntax examples for unnamed given definitions. These use the colon before the implemented type and a trailing 'with' keyword to introduce the body. This style highlights the less intuitive aspects of the current syntax compared to the proposed form, such as usage of 'using' clauses for context and trailing 'with' blocks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\n  // Simple typeclass\n  given Ord[Int] with\n    def compare(x: Int, y: Int) = ...\n\n  // Parameterized typeclass with context bound\n  given [A: Ord]: Ord[List[A]] with\n    def compare(x: List[A], y: List[A]) = ...\n\n  // Parameterized typeclass with context parameter\n  given [A](using Ord[A]): Ord[List[A]] with\n    def compare(x: List[A], y: List[A]) = ...\n\n  // Parameterized typeclass with named context parameter\n  given [A](using ord: Ord[A]): Ord[List[A]] with\n    def compare(x: List[A], y: List[A]) = ...\n\n  // Simple alias\n  given Ord[Int] = IntOrd()\n```\n\n----------------------------------------\n\nTITLE: Adding a List Parameter to the `map` Signature in Scala\nDESCRIPTION: Extends the `map` method signature to accept a `List[Int]` named `xs` as the second parameter. This list contains the elements to be transformed by the function `f`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-write-map-function.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef map[A](f: (Int) => A, xs: List[Int])\n```\n\n----------------------------------------\n\nTITLE: Multiline Strings with Interpolation in JavaScript\nDESCRIPTION: This snippet shows how to create multiline strings with interpolation in JavaScript using backticks (`). Newlines and embedded expressions are preserved.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\nlet name = \"joe\";\nlet str = `\nHello, ${name}.\nThis is a multiline string.\n`;\n```\n\n----------------------------------------\n\nTITLE: Multiple Forms of Anonymous Functions with Map in Scala\nDESCRIPTION: Shows different syntax variations for writing anonymous functions with the map method, from most explicit to increasingly concise forms.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-anonymous-functions.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval doubledInts = ints.map((i: Int) => i * 2)\nval doubledInts = ints.map((i) => i * 2)\nval doubledInts = ints.map(i => i * 2)\n```\n\n----------------------------------------\n\nTITLE: Updating Elements in a Mutable ArrayBuffer in Scala\nDESCRIPTION: Shows how to update elements at specific indices in a mutable `ArrayBuffer`. This can be done using direct assignment syntax (`a(index) = value`) or the equivalent `update` method (`a.update(index, value)`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_28\n\nLANGUAGE: Scala\nCODE:\n```\nval a = ArrayBuffer.range(1,5)        // ArrayBuffer(1, 2, 3, 4)\na(2) = 50                             // ArrayBuffer(1, 2, 50, 4)\na.update(0, 10)                       // ArrayBuffer(10, 2, 50, 4)\n```\n\n----------------------------------------\n\nTITLE: 値クラスの継承制約例（暗黙的に`final`）\nDESCRIPTION: 値クラスは`final`修飾子暗黙的に付与されているため、継承はできない。例として`Value`クラスを継承しようとした場合のエラーが示される。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/value-classes.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nclass Value(val x: Int) extends AnyVal\nclass Extend(x: Int) extends Value(x)\n```\n\n----------------------------------------\n\nTITLE: Adding Specific OS-Lib Version in Mill Build File - Scala\nDESCRIPTION: This snippet shows how to directly include the OS-Lib dependency at a specified version in a Mill build file, using 'ivy\"com.lihaoyi::os-lib:0.11.3\"'. This can be placed within a module's 'ivyDeps' definition or used standalone in custom scripts. Mill and the required Scala version should be configured; this method supports fine-grained dependency control.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-os-lib.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nivy\"com.lihaoyi::os-lib:0.11.3\"\n```\n\n----------------------------------------\n\nTITLE: Legal Type Ascription with Indentation in Scala\nDESCRIPTION: This snippet shows a legal alternative to the previous type ascription edge case. The code puts the colon at the start of the new line for type ascription, preventing conflict with fewerBraces syntax. This can be used to adapt pre-existing code for compatibility with SIP-44 and Scala 3's indentation rules.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nval x = y\n  : Int\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Aggregation Wrappers with Opaque Types in Scala\nDESCRIPTION: This code presents a framework for defining custom aggregation wrappers (First, Last, Min, Max, Plus, Times, Reversed, Unordered) using opaque types and a common abstract Wrapper class. The design associates aggregation semantics to types in a zero-overhead way and provides implicit semigroup or ordering instances per wrapper. Inputs: values to aggregate; outputs: values with custom aggregation semantics. Dependencies: Scala 3, relevant Numeric/Ordering instances. Limitation: The wraps/unwrap methods are only accessible within the companion object, as required by Scala opaque types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/opaque-types.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\npackage object groups {\n  trait Semigroup[A] {\n    def combine(x: A, y: A): A\n  }\n\n  object Semigroup {\n    def instance[A](f: (A, A) => A): Semigroup[A] =\n      new Semigroup[A] {\n        def combine(x: A, y: A): A = f(x, y)\n      }\n  }\n\n  type Id[A] = A\n\n  trait Wrapping[F[_]] {\n    def wraps[G[_], A](ga: G[A]): G[F[A]]\n    def unwraps[G[_], A](ga: G[F[A]]): G[A]\n  }\n\n  abstract class Wrapper[F[_]] { self =>\n    def wraps[G[_], A](ga: G[A]): G[F[A]]\n    def unwraps[G[_], A](gfa: G[F[A]]): G[A]\n\n    final def apply[A](a: A): F[A] = wraps[Id, A](a)\n\n    implicit object WrapperWrapping extends Wrapping[F] {\n      def wraps[G[_], A](ga: G[A]): G[F[A]] = self.wraps(ga)\n      def unwraps[G[_], A](ga: G[F[A]]): G[A] = self.unwraps(ga)\n    }\n  }\n\n  opaque type First[A] = A\n  object First extends Wrapper[First] {\n    def wraps[G[_], A](ga: G[A]): G[First[A]] = ga\n    def unwrap[G[_], A](gfa: G[First[A]]): G[A] = gfa\n    implicit def firstSemigroup[A]: Semigroup[First[A]] =\n      Semigroup.instance((x, y) => x)\n  }\n\n  opaque type Last[A] = A\n  object Last extends Wrapper[Last] {\n    def wraps[G[_], A](ga: G[A]): G[Last[A]] = ga\n    def unwrap[G[_], A](gfa: G[Last[A]]): G[A] = gfa\n    implicit def lastSemigroup[A]: Semigroup[Last[A]] =\n      Semigroup.instance((x, y) => y)\n  }\n\n  opaque type Min[A] = A\n  object Min extends Wrapper[Min] {\n    def wraps[G[_], A](ga: G[A]): G[Min[A]] = ga\n    def unwrap[G[_], A](gfa: G[Min[A]]): G[A] = gfa\n    implicit def minSemigroup[A](implicit o: Ordering[A]): Semigroup[Min[A]] =\n      Semigroup.instance(o.min)\n  }\n\n  opaque type Max[A] = A\n  object Max extends Wrapper[Max] {\n    def wraps[G[_], A](ga: G[A]): G[Max[A]] = ga\n    def unwrap[G[_], A](gfa: G[Max[A]]): G[A] = gfa\n    implicit def maxSemigroup[A](implicit o: Ordering[A]): Semigroup[Max[A]] =\n      Semigroup.instance(o.max)\n  }\n\n  opaque type Plus[A] = A\n  object Plus extends Wrapper[Plus] {\n    def wraps[G[_], A](ga: G[A]): G[Plus[A]] = ga\n    def unwrap[G[_], A](gfa: G[Plus[A]]): G[A] = gfa\n    implicit def plusSemigroup[A](implicit n: Numeric[A]): Semigroup[Plus[A]] =\n      Semigroup.instance(n.plus)\n  }\n\n  opaque type Times[A] = A\n  object Times extends Wrapper[Times] {\n    def wraps[G[_], A](ga: G[A]): G[Times[A]] = ga\n    def unwrap[G[_], A](gfa: G[Times[A]]): G[A] = gfa\n    implicit def timesSemigroup[A](implicit n: Numeric[A]): Semigroup[Times[A]] =\n      Semigroup.instance(n.times)\n  }\n\n  opaque type Reversed[A] = A\n  object Reversed extends Wrapper[Reversed] {\n    def wraps[G[_], A](ga: G[A]): G[Reversed[A]] = ga\n    def unwrap[G[_], A](gfa: G[Reversed[A]]): G[A] = gfa\n    implicit def reversedOrdering[A](implicit o: Ordering[A]): Ordering[Reversed[A]] =\n      o.reverse\n  }\n\n  opaque type Unordered[A] = A\n  object Unordered extends Wrapper[Unordered] {\n    def wraps[G[_], A](ga: G[A]): G[Unordered[A]] = ga\n    def unwrap[G[_], A](gfa: G[Unordered[A]]): G[A] = gfa\n    implicit def unorderedOrdering[A]: Ordering[Unordered[A]] =\n      Ordering.by(_ => ())\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Private Class Constructor Parameters Are Not Accessible from Outside in Scala\nDESCRIPTION: Illustrates that constructor parameters not declared with 'val' or 'var' are private to the class and cannot be accessed externally, leading to compilation errors if attempted. Emphasizes the importance of declaring parameters with 'val' or 'var' to make them accessible as class fields.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/classes.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass Point(x: Int, y: Int)\nval point = new Point(1, 2)\npoint.x  // <-- nie kompiluje się\n```\n\n----------------------------------------\n\nTITLE: Defining Runner Trait Scala\nDESCRIPTION: Defines a simple Scala trait named `Runner` that specifies two abstract methods, `startRunning` and `stopRunning`. These methods have no parameters and return Unit, representing the ability to run.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/traits-interfaces.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Runner {\n    def startRunning(): Unit\n    def stopRunning(): Unit\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Nominal Helper Trait in Scala 2\nDESCRIPTION: Shows the Scala 2 approach of creating a nominal helper trait `Both[A]` that explicitly extends both `Resettable` and `Growable[A]` using the `with` keyword. A function `f` is then defined to accept instances of this specific `Both[String]` trait. This method requires explicitly defining the combined type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-intersection.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntrait Both[A] extends Resettable with Growable[A]\ndef f(x: Both[String]): Unit\n```\n\n----------------------------------------\n\nTITLE: Accessing Tuple Elements in Python\nDESCRIPTION: Demonstrates accessing elements of a Python tuple 't' by index using square brackets, returning the first and second elements: 11 and 11.0 respectively.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_22\n\nLANGUAGE: Python\nCODE:\n```\nt[0]  # 11\nt[1]  # 11.0\n```\n\n----------------------------------------\n\nTITLE: Instantiating Class with Default/Named Parameters in Scala 2\nDESCRIPTION: This snippet illustrates various ways to instantiate a class with default parameter values in Scala 2, including using positional arguments, providing all arguments, or using named parameters to specify arguments selectively.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nval s = new Socket()                  // timeout: 5000, linger: 5000\nval s = new Socket(2_500)             // timeout: 2500, linger: 5000\nval s = new Socket(10_000, 10_000)    // timeout: 10000, linger: 10000\nval s = new Socket(timeout = 10_000)  // timeout: 10000, linger: 5000\nval s = new Socket(linger = 10_000)   // timeout: 5000, linger: 10000\n```\n\n----------------------------------------\n\nTITLE: Testing Graph Node Connections in Scala Without Explicit Types\nDESCRIPTION: Shows a test method creating a Graph instance and adding nodes, then connecting nodes incrementally using connectTo. This snippet demonstrates usage of the Graph and Node classes, focusing on node construction and relationship modification without explicit type annotations for nodes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/inner-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef graphTest: Unit = {\n  val g = new Graph\n  val n1 = g.newNode\n  val n2 = g.newNode\n  val n3 = g.newNode\n  n1.connectTo(n2)\n  n3.connectTo(n1)\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating over dictionary/map entries in Python and Scala\nDESCRIPTION: Shows how to iterate over all key-value pairs. Python uses dict.items() and a for loop unpacking key and value. Scala uses for-comprehension syntax with tuple pattern matching to iterate keys and values. Both provide readable iteration idioms for associative containers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_58\n\nLANGUAGE: python\nCODE:\n```\nfor key, value in my_dict.items():\n    print(key)\n    print(value)\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor (key,value) <- myMap do\n    println(key)\n    println(value)\n```\n\n----------------------------------------\n\nTITLE: Calling Inline Function with Non-Constant Argument in Scala\nDESCRIPTION: Demonstrates calling the `power` function with a non-constant argument (`unknownNumber`). This sets up the context for explaining why standard `inline` might lead to issues without compile-time constants for conditions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\npower(2, unknownNumber)\n```\n\n----------------------------------------\n\nTITLE: Visualizing the Scala 3 compilation process in text diagram\nDESCRIPTION: This ASCII diagram illustrates the three-step compilation pipeline of Scala 3 code: source code compiled by scalac into a TASTy file containing complete information, which then produces the JVM 'class' file with incomplete type information. It clarifies the roles and contents of each intermediate artifact in the process.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/scala3/guides/tasty-overview.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n         +-------------+    +-------------+    +-------------+\n$ scalac | Hello.scala | -> | Hello.tasty | -> | Hello.class |\n         +-------------+    +-------------+    +-------------+\n                ^                  ^                  ^\n                |                  |                  |\n           Your source        TASTy file         Class file\n               code           for scalac        for the JVM\n                              (contains         (incomplete\n                               complete         information)\n                             information)\n```\n\n----------------------------------------\n\nTITLE: Using Traits for Subtyping and Polymorphism in Scala\nDESCRIPTION: Defines a trait `Pet` with an abstract field `name`, implemented by classes `Cat` and `Dog` which define the `name` parameter in their constructors. An `ArrayBuffer` of `Pet` objects accepts instances of both subtypes, enabling polymorphic storage and operations. The snippet illustrates trait-based interface inheritance and how trait subtypes can be used interchangeably while accessing shared members.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/tour/traits.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable.ArrayBuffer\n\ntrait Pet {\n  val name: String\n}\n\nclass Cat(val name: String) extends Pet\nclass Dog(val name: String) extends Pet\n\nval dog = new Dog(\"Harry\")\nval cat = new Cat(\"Sally\")\n\nval animals = ArrayBuffer.empty[Pet]\nanimals.append(dog)\nanimals.append(cat)\nanimals.foreach(pet => println(pet.name))  // แสดงค่า Harry Sally\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait with Parameters in Scala 3\nDESCRIPTION: Demonstrates Scala 3's ability to define traits that take constructor parameters, similar to abstract classes. The trait `Pet` accepts a `name` parameter and declares abstract members `greeting` and `age` with a custom `toString` method. The subclass `Dog` extends this trait and implements required members. This feature increases flexibility in trait composition and usage. Prerequisites include using Scala 3. Input is constructor arguments; output is a concrete class instance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\ntrait Pet(name: String):\n  def greeting: String\n  def age: Int\n  override def toString = s\"My name is $name, I say $greeting, and I’m $age\"\n\nclass Dog(name: String, var age: Int) extends Pet(name):\n  val greeting = \"Woof\"\n\nval d = Dog(\"Fido\", 1)\n```\n\n----------------------------------------\n\nTITLE: Использование map с Future в Scala\nDESCRIPTION: Пример применения метода map к Future для трансформации результата, показывающий как работает функциональная композиция с асинхронными вычислениями.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/concurrency.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval a = Future(longRunningAlgorithm()).map(_ * 2)\n// a: scala.concurrent.Future[Int] = Future(<not completed>)\n\n// Через 10 секунд:\n// a\n// res1: scala.concurrent.Future[Int] = Future(Success(84))\n```\n\n----------------------------------------\n\nTITLE: Generic and Curried Use of foldLeft and foldRight in Scala\nDESCRIPTION: This snippet compares both full and curried forms of foldLeft and foldRight for summing a list of numbers. The generic form provides complete function signatures, and the curried form leverages the simplest underscore shorthand. Demonstrates flexibility of multiple parameter lists and their impact on invoking higher-order methods. Inputs are the same list of integers; outputs are the respective sums for each operation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/multiple-parameter-lists.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\nnumbers.foldLeft(0)((sum, item) => sum + item) // Generic Form\nnumbers.foldRight(0)((sum, item) => sum + item) // Generic Form\n\nnumbers.foldLeft(0)(_+_) // Curried Form\nnumbers.foldRight(0)(_+_) // Curried Form\n```\n\n----------------------------------------\n\nTITLE: Running ScalaTest Suite with sbt - Shell\nDESCRIPTION: Demonstrates executing tests in a Scala project using the 'sbt test' command. This snippet shows the expected output during test execution including suite and test results, which helps users verify their test setup. Dependency: sbt must be installed. The project must be set up with ScalaTest as a dependency.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/getting-started/sbt-track/testing-scala-with-sbt-on-the-command-line.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nsbt test\n[info] Loading global plugins from /Users/username/.sbt/0.13/plugins\n[info] Loading project definition from /Users/username/workspace/sandbox/my-something-project/project\n[info] Set current project to scalatest-example (in build file:/Users/username/workspace/sandbox/my-something-project/)\n[info] CubeCalculatorTest:\n[info] - CubeCalculator.cube\n[info] Run completed in 267 milliseconds.\n[info] Total number of tests run: 1\n[info] Suites: completed 1, aborted 0\n[info] Tests: succeeded 1, failed 0, canceled 0, ignored 0, pending 0\n[info] All tests passed.\n[success] Total time: 1 s, completed Feb 2, 2017 7:37:31 PM\n```\n\n----------------------------------------\n\nTITLE: Fixing Self-Type Error in Scala DirectedGraph NodeImpl using Explicit Self-Type\nDESCRIPTION: Modifies DirectedGraph.NodeImpl by adding an explicit self-type annotation `self: Node =>`. This annotation declares that instances of NodeImpl must conform to the abstract Node type. As a result, the use of `this` in connectWith is now statically recognized as of type Node, allowing the call to newEdge(this, node) to compile correctly. This technique resolves the type compatibility issue with self references in inner classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/self-types.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nabstract class DirectedGraph extends Graph {\n  ...\n  class NodeImpl extends NodeIntf {\n    self: Node =>\n    def connectWith(node: Node): Edge = {\n      val edge = newEdge(this, node)  // now legal\n      edges = edge :: edges\n      edge\n    }\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Covariance Issues Using Lower Type Bounds in Scala\nDESCRIPTION: Redefines the Node trait and its implementations by introducing a method type parameter U with a lower bound 'U >: B' for the prepend method. This fixes the variance conflict by allowing the prepend method to accept elements that are supertypes of B, enabling safe method usage and maintaining covariance of Node. The prepend method returns a Node of type U, reflecting the potential broadening of the list element types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/lower-type-bounds.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntrait Node[+B] {\n  def prepend[U >: B](elem: U): Node[U]\n}\n\ncase class ListNode[+B](h: B, t: Node[B]) extends Node[B] {\n  def prepend[U >: B](elem: U): ListNode[U] = ListNode(elem, this)\n  def head: B = h\n  def tail: Node[B] = t\n}\n\ncase class Nil[+B]() extends Node[B] {\n  def prepend[U >: B](elem: U): ListNode[U] = ListNode(elem, this)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Anonymous Type Provider Macro\nDESCRIPTION: Defines a macro intended to act as an anonymous type provider. It takes a connection string and is expected to generate code that encapsulates database schema information, making it available via the macro's return type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/typeproviders.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef h2db(connString: String): Any = macro ...\n```\n\n----------------------------------------\n\nTITLE: Illustrating Desired map/++ Behavior for RNA Class (Scala)\nDESCRIPTION: Shows the ideal behavior for `map` (when mapping `Base` to `Base`) and `++` (when concatenating two `RNA` instances) on a hypothetical improved `RNA` class. The desired outcome is that these operations return an instance of `RNA`, preserving the specific collection type. This contrasts with the `RNA1` implementation's current behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nscala> val rna = RNA(A, U, G, G, C)\nval rna: RNA = RNA(A, U, G, G, C)\n\nscala> rna.map { case A => U case b => b }\nval res7: RNA = RNA(U, U, G, G, C)\n\nscala> rna ++ rna\nval res8: RNA = RNA(A, U, G, G, C, A, U, G, G, C)\n```\n\n----------------------------------------\n\nTITLE: Reading Line-Based Output of External Process Using OS-Lib in Scala\nDESCRIPTION: This snippet shows how to execute a command (such as 'cal') and process the resulting output line by line using OS-Lib in Scala. The CommandResult's output is accessed via out.lines(), which returns a Seq of strings representing each output line. The snippet assumes availability of the 'cal' utility on the system. It prints a formatted calendar for given month and year, demonstrating real-time line-wise output handling.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/os-run-process.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval res: os.CommandResult = os.proc(\"cal\", \"-h\", \"2\", \"2023\").call()\nres.out.lines().foreach(println)\n// prints:\n//   February 2023\n// Su Mo Tu We Th Fr Sa\n//          1  2  3  4\n// ...\n```\n\n----------------------------------------\n\nTITLE: Initializing Integer List Using List.range in Scala\nDESCRIPTION: Creates a new List of integers using the List.range method, specifying a start and end value. Depends only on the Scala standard library. Start is inclusive, end is exclusive. Input: starting value 1, ending value 10. Output: List[Int] from 1 to 9. Useful for generating sequences of integers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/anonymous-functions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval ints = List.range(1, 10)\n```\n\n----------------------------------------\n\nTITLE: Declaring Variables in Java\nDESCRIPTION: This snippet demonstrates typical Java variable declarations, where each variable must be declared with an explicit type preceding the variable name. It shows string, integer, and object instance declarations using the class Person. It assumes Java environment with standard type syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/two-types-variables.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nString s = \"hello\";\nint i = 42;\nPerson p = new Person(\"Joel Fleischman\");\n```\n\n----------------------------------------\n\nTITLE: Explicit Value Type Casting with Precision Loss in Scala\nDESCRIPTION: This snippet demonstrates type casting where precision loss can occur, requiring an explicit conversion method like `.toFloat`. It shows that casting a `Long` to a `Float` might result in a different value due to the floating-point representation. It also illustrates an illegal implicit cast from `Float` to `Long` because this conversion is not automatically supported and would result in potential data loss without an explicit method call.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/first-look-at-types.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nval x: Long = 987654321\nval y: Float = x.toFloat  // 9.8765434E8 (note that `.toFloat` is required because the cast results in precision loss)\nval z: Long = y  // Error\n```\n\n----------------------------------------\n\nTITLE: Basic Directory Structure for Scaladoc Static Site\nDESCRIPTION: Shows the minimal directory structure needed to create a 'hello world' static site with Scaladoc, containing an index and a getting-started page.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/static-site.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n.\n└── <site-root>/\n    └── _docs/\n        ├── index.html\n        └── getting-started.html\n```\n\n----------------------------------------\n\nTITLE: Matching Quoted Expressions with Explicit Type Variables (Old Syntax) - Scala\nDESCRIPTION: Demonstrates the previous syntax for defining explicit type variables within Scala quoted expression patterns. It highlights the requirement to use backticks (` `) around the type variable names (`t`, `u`, `tail`) when referencing them inside the quote pattern.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/quote-pattern-type-variable-syntax.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase '{ type t; $x: `t` } => f[t](x: Expr[t])\ncase '{ type u; ($ls: List[`u`]).map($f: `u` => Int) } => g[u](ls: Expr[List[u]], f: Expr[u => Int])\ncase '{ type tail <: Tuple; $x: *:[Int, `tail`] } => h[tail](x: Expr[*:[Int, tail])\n```\n\n----------------------------------------\n\nTITLE: Simple Hello World Program in Scala\nDESCRIPTION: Defines a singleton object 'HolaMundo' with a main method that prints '¡Hola, mundo!'. Demonstrates Scala's object declaration, singleton pattern, and main method structure akin to Java, but without static members. The snippet introduces Scala compilation with 'scalac' and execution with 'scala'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tutorials/scala-for-java-programmers.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject HolaMundo {\n  def main(args: Array[String]): Unit = {\n    println(\"¡Hola, mundo!\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a basic ScalaTest FunSuite test class\nDESCRIPTION: A simple Scala test class that extends FunSuite to test the CubeCalculator.cube function. The test asserts that calling cube(3) returns 27 using ScalaTest's triple equals (===) assertion for better error messages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/getting-started/sbt-track/testing-scala-with-sbt-on-the-command-line.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport org.scalatest.FunSuite\n\nclass CubeCalculatorTest extends FunSuite {\n    test(\"CubeCalculator.cube\") {\n        assert(CubeCalculator.cube(3) === 27)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Sequence Elements with elementWise and unlift in Scala\nDESCRIPTION: Illustrates how to use the `elementWise` method in conjunction with `unlift` on an optional function (`String => Option[Char]`) to create an extractor that applies the function to each element of a sequence (`Seq[String]`) and extracts the results. The example defines `firstChar` to get the head character of a string and uses `firstChar.unlift.elementWise` to pattern match on the first characters of a sequence of strings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/converters-among-optional-functions-partialfunctions-and-extractor-objects.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval firstChar: String => Option[Char] = _.headOption\n\nSeq(\"foo\", \"bar\", \"baz\") match {\n  case firstChar.unlift.elementWise(c0, c1, c2) =>\n    println(s\"$c0, $c1, $c2\") // Output: f, b, b\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Connected Android Devices (ADB)\nDESCRIPTION: Uses the Android Debug Bridge (ADB) command-line utility to list all Android devices and emulators currently connected to the computer and recognized by ADB. This is useful for verifying device connectivity before attempting installation or debugging. Requires ADB to be installed and in the system's PATH, and the Android device must have USB debugging enabled.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-on-android.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nadb devices\n```\n\n----------------------------------------\n\nTITLE: Inspecting Tree Structure with reify and showRaw\nDESCRIPTION: Shows how to obtain an AST from a Scala expression using the `reify` method, which returns an `Expr` wrapping the `Tree` and `TypeTag`. It then extracts the `Tree` from the `Expr` and uses the `showRaw` method to display the raw, untyped internal structure of the AST used by the compiler and type checker.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/reflection/symbols-trees-types.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n\nval expr = reify { class Flower { def name = \"Rose\" } }\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval tree = expr.tree\n```\n\nLANGUAGE: Scala\nCODE:\n```\nshowRaw(tree)\n```\n\n----------------------------------------\n\nTITLE: Scala Object Demonstrating Unified Types\nDESCRIPTION: This snippet defines a Scala singleton object 'UnifiedTypes' extending 'App', illustrating that various types of data (strings, numbers, characters, booleans, functions) are all objects. It creates a mutable LinkedHashSet of type 'Any', adds different elements to it, and iterates over the set to print each element's string representation. Dependencies include Scala's collection library. It showcases type inference with 'Any' and demonstrates a basic collection manipulation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/unified-types.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject UnifiedTypes extends App {\n  val set = new scala.collection.mutable.LinkedHashSet[Any]\n  set += \"This is a string\"  // suma un String\n  set += 732                 // suma un número\n  set += 'c'                 // suma un caracter\n  set += true                // suma un valor booleano\n  set += main _              // suma la función main\n  val iter: Iterator[Any] = set.iterator\n  while (iter.hasNext) {\n    println(iter.next.toString())\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Factoring Inner Function to Method in Generic Traverse Implementation (Scala)\nDESCRIPTION: Here, a context function is factored out as a named method (`def traverser`) and passed to `traverse`, showcasing reusability and improved readability. Requires appropriate types for `T`, `F` and a supporting `inst` implementation. Inputs are functors and element functions, output is lifted collection. Limitation: depends on eta-expansion for methods with multiple parameter lists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/polymorphic-eta-expansion.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n...  \n  final override def traverse[G[_], A, B](fa: F[A])(f: A => G[B])\n      (using G: Applicative[G]): G[F[B]] =\n    def traverser[F[_]](tf: T[F], fa: F[A]) = tf.traverse(fa)(f)\n    inst.traverse[A, G, B](fa)(G.map)(G.pure)(G.ap)(traverser)\n```\n\n----------------------------------------\n\nTITLE: Initial Method Definition Before Adding Default Parameters in Scala\nDESCRIPTION: Defines a simple method `foo` within an `Unrolled` object. This represents the initial state of a library method before adding new default parameters, serving as a starting point to illustrate binary compatibility issues.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/unroll-default-arguments.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nobject Unrolled{\n   def foo(s: String, n: Int = 1) = s + n + b + l\n}\n```\n\n----------------------------------------\n\nTITLE: Reporting Compile-time Error in Scala\nDESCRIPTION: This snippet illustrates using `scala.compiletime.error` within an `inline` method to report errors during the compilation process. The error message is emitted only if the call site, after inlining, is not removed as part of a dead branch, demonstrating how errors can be conditional based on compile-time evaluated logic.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/compiletime.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ninline def doSomething(inline mode: Boolean): Unit =\n  if mode then ...\n  else if !mode then ...\n  else error(\"Mode must be a known value\")\n\ndoSomething(true)\ndoSomething(false)\nval bool: Boolean = ...\ndoSomething(bool) // error: Mode must be a known value\n```\n\n----------------------------------------\n\nTITLE: Avoiding Synchronous ExecutionContext Running in Current Thread in Scala 2 and 3\nDESCRIPTION: Warns against creating an ExecutionContext that runs computations immediately in the invoking thread by implementing execute(runnable) to run runnable.run(). Such usage results in non-deterministic callback execution and breaks expected asynchronous semantics. The example shows how this can cause callbacks to execute either synchronously or asynchronously depending on the scheduling, which is considered a bad practice. It recommends refraining from this pattern to preserve execution guarantees.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval currentThreadExecutionContext = ExecutionContext.fromExecutor(\n  new Executor {\n    // Do not do this!\n    def execute(runnable: Runnable) = runnable.run()\n})\n```\n\nLANGUAGE: scala\nCODE:\n```\nFuture {\n  doSomething\n}(ExecutionContext.global).map {\n  doSomethingElse\n}(currentThreadExecutionContext)\n```\n\n----------------------------------------\n\nTITLE: Defining Complex Class with Parameterless Accessor Methods in Scala\nDESCRIPTION: Defines a revised Complex class where the re and im methods are declared without parentheses, making them parameterless functions. This allows invoking these methods without parentheses, giving them the appearance of fields when accessed. This snippet illustrates Scala's distinction between zero-argument methods with and without parentheses, enhancing readability and idiomatic usage. Inputs are real and imaginary doubles for construction; outputs are accessible fields via parameterless method calls.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tutorials/scala-for-java-programmers.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nclass Complex(real: Double, imaginary: Double) {\n  def re = real\n  def im = imaginary\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining Algebraic Expressions with Function Calls in Scala\nDESCRIPTION: This snippet demonstrates the assignment of results from multiple function calls into variables using algebraic expressions in Scala. Each function is called with the result of the previous, showcasing how to compose operations without introducing side effects or exceptions. There are no dependencies other than the functions f, g, and h, which are expected to be defined elsewhere. Inputs are variables x, z, y, and the outputs are the computed values a, b, c. There are no explicit error-handling mechanisms shown in this snippet.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_63\n\nLANGUAGE: Scala\nCODE:\n```\nval a = f(x)\nval b = g(a,z)\nval c = h(b,y)\n```\n\n----------------------------------------\n\nTITLE: Define SubjectObserver Trait with Abstract Types (Scala 2)\nDESCRIPTION: Defines a generic `SubjectObserver` trait in Scala 2 using abstract type members (`S` for Subject, `O` for Observer) with upper bounds, and nested traits (`Subject`, `Observer`). The `Subject` trait includes a self-type annotation (`self: S =>`) to ensure subtypes of `Subject` are also subtypes of `S`, enabling safe calls to the observer's `notify` method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\ntrait SubjectObserver {\n\n  type S <: Subject\n  type O <: Observer\n\n  trait Subject { self: S =>\n    private var observers: List[O] = List()\n    def subscribe(obs: O): Unit = {\n      observers = obs :: observers\n    }\n    def publish() = {\n      for ( obs <- observers ) obs.notify(this)\n    }\n  }\n\n  trait Observer {\n    def notify(sub: S): Unit\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Access Control Decorator in Cask (Scala 2)\nDESCRIPTION: This snippet defines and uses a custom endpoint decorator, 'loggedIn', to enforce authentication for a given Cask HTTP route using Scala 2. The decorator extends 'cask.RawDecorator' and checks the 'sessionId' cookie for a valid session before allowing access. If authentication passes, it injects the session ID as a parameter; otherwise, it returns a 403 response. Requires Cask framework and a session-tracking set (sessionIds) in scope. Use the decorator via the '@loggedIn()' annotation to protect endpoints from unauthenticated access. Limitations: only enforces cookie-based sessions with names matching 'sessionId'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/web-server-cookies-and-decorators.md#_snippet_2\n\nLANGUAGE: Scala 2\nCODE:\n```\nclass loggedIn extends cask.RawDecorator {\n  override def wrapFunction(ctx: cask.Request, delegate: Delegate): Result[Raw] = {\n    ctx.cookies.get(\"sessionId\") match {\n      case Some(cookie) if sessionIds.contains(cookie.value) => delegate(Map(\"sessionId\" -> cookie.value))\n      case _ => cask.router.Result.Success(cask.model.Response(\"You aren't logged in\", 403))\n    }\n  }\n}\n\n@loggedIn()\n@cask.get(\"/decorated\")\ndef decorated()(sessionId: String): String = {\n  s\"You are logged in with id: $sessionId\"\n}\n```\n\n----------------------------------------\n\nTITLE: Writing and Running a Failing MUnit Test - Scala 2\nDESCRIPTION: Defines an intentionally failing test case in Scala 2 syntax using MUnit. The test checks that the sum of 2 and 3 equals 4 using the 'assertEquals' assertion, which will fail because 2 + 3 is 5. The code demonstrates how assertion failures are reported, helping developers understand error traces and difference output provided by MUnit. Requires MUnit as a library dependency, and should be placed in a test source file recognized by the build tool.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-run.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ntest(\"failing test\") {\n  val obtained = 2 + 3\n  val expected = 4\n  assertEquals(obtained, expected)\n}\n```\n\n----------------------------------------\n\nTITLE: Collapsing Leading Zeros with Iterator span and ++ in Scala\nDESCRIPTION: This second version of the Scala function `collapse` provides a more idiomatic way to collapse leading zeros using `it.span(_ == 0)`. `span` splits the iterator into two: the longest prefix satisfying the predicate (zeros) and the rest. It then takes the first element of the 'zeros' part (if any) using `take(1)` and concatenates it with the 'rest' part using `++`. This version buffers the unconsumed zeros internally within the span operation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/iterators.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\ndef collapse(it: Iterator[Int]) = {\n     | val (zeros, rest) = it.span(_ == 0)\n     | zeros.take(1) ++ rest\n     | }\n```\n\n----------------------------------------\n\nTITLE: Defining GenericArray Class Structure in Scala\nDESCRIPTION: Provides a conceptual definition of the `GenericArray[T]` class in Scala, located in `scala.collection.mutable`. Unlike standard arrays, `GenericArray` uses a uniform representation (`Array[AnyRef]`, equivalent to Java's `Object[]`) to store elements, allowing instances to be created without a `ClassManifest`. It extends `Vector[T]` and implements vector operations based on the underlying `AnyRef` array. This is useful when providing a manifest is infeasible.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/scala-2-8-arrays.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass GenericArray[T](length: Int) extends Vector[T] {\n\tval array: Array[AnyRef] = new Array[AnyRef](length)\n\t...\n\t// all vector operations defined in terms of ‘array’\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Given Instances Separately in Scala 3 - Scala\nDESCRIPTION: Explains how Scala 3 distinguishes between importing non-given members and given instances (contextual abstractions). Demonstrates importing all non-given members separately from given instances using `import A.*` and `import A.given`. Also shows combining both into one statement for clear and explicit management of contextual information. Requires Scala 3 context abstractions support. Inputs include objects defining given instances and imports that bring these into scope accordingly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/packaging-imports.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nobject A:\n  class TC\n  given tc: TC\n  def f(using TC) = ???\n\nobject B:\n  import A.*       // Imports all non-given members\n  import A.given   // Imports given instances only\n\nobject B:\n  import A.{given, *}\n```\n\n----------------------------------------\n\nTITLE: Interactive Hello World Program in Scala 3 Using @main and User Input\nDESCRIPTION: Defines a main method 'helloInteractive' annotated with Scala 3's `@main` which interacts with the user by requesting a name input. It imports the 'readLine' method and stores input into a 'val name'. The program then outputs a greeting with string concatenation. The snippet demonstrates simplified main method syntax with multiple statements, interaction via standard input, and use of 'println' for output. Requires Scala 3 compiler and runtime.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-hello-world.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.io.StdIn.readLine\n\n@main def helloInteractive() =\n  println(\"Please enter your name:\")\n  val name = readLine()\n\n  println(\"Hello, \" + name + \"!\")\n```\n\n----------------------------------------\n\nTITLE: Performing Side-Effects after Future Completion using andThen Combinator in Scala\nDESCRIPTION: This snippet illustrates chaining side-effecting handlers after a Future completes regardless of success or failure using andThen. It asynchronously fetches recent posts, accumulates them in a mutable Set, then clears and renders all posts on the screen. andThen guarantees the order of these side-effects without affecting the Future's original result, enabling clean separation of pure asynchronous logic and side-effecting code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/futures.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nval allposts = mutable.Set[String]()\n\nFuture {\n  session.getRecentPosts\n} andThen {\n  case Success(posts) => allposts ++= posts\n} andThen {\n  case _ =>\n  clearAll()\n  for (post <- allposts) render(post)\n}\n```\n\n----------------------------------------\n\nTITLE: Proposed Handling of Implicit `given` Bindings in Alternatives in Scala\nDESCRIPTION: Proposes how implicit `given` bindings would work in alternative patterns under the SIP. If the same context type (`Context`) is implicitly available (`given Context`) in each branch, it can be used within the case body (e.g., to call `run`). The proposal focuses on ensuring the required *type* is present in the contextual scope for each alternative, regardless of anonymous binding.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/alternative-bind-variables.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\n  case class Context()\n\n  def run(using ctx: Context): Unit = ???\n\n  enum Foo:\n    case Bar(ctx: Context)\n    case Baz(i: Int, ctx: Context)\n\n    def fun = this match\n      case Bar(given Context) | Baz(_, given Context) => run // `Context` appears in both branches\n```\n\n----------------------------------------\n\nTITLE: Configuring Cross-Version Macro Library and Compatibility Submodule in build.sbt - Scala\nDESCRIPTION: This build.sbt configuration shows how to structure two modules: the main macro library in Scala 3, and a Scala 2.13 compatibility submodule (example-compat) providing Scala 2 macros (with possible quasiquotes). The configuration sets scalaVersion per module and adds Scala reflection as a dependency for the 2.13 module. The main module depends on the compat module. This is intended for multi-module SBT projects targeting cross-version macro usage.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-macro-mixing.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n// build.sbt\n\nlazy val example = project.in(file(\"example\"))\n  .settings(\n    scalaVersion := \"3.3.1\"\n  )\n  .dependsOn(`example-compat`)\n\nlazy val `example-compat` = project.in(file(\"example-compat\"))\n  .settings(\n    scalaVersion := \"2.13.12\",\n    libraryDependencies += \"org.scala-lang\" % \"scala-reflect\" % scalaVersion.value\n  )\n```\n\n----------------------------------------\n\nTITLE: Eliminating Manual Eta-Expansion for Uncurried Map and Ap in Scala (Kittens)\nDESCRIPTION: This snippet leverages the ability (as per SIP-49) to use existing polymorphic methods such as `G.pure`, `G.map`, and `G.ap` directly, eliminating manual eta-expansion and reducing boilerplate. Requires the proposal to be implemented and the methods to be properly uncurried. Inputs and outputs follow the generic functor traverse pattern. Limitation: only uncurried functions are supported for eta-expansion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/polymorphic-eta-expansion.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n...  \n  final override def traverse[G[_], A, B](fa: F[A])(f: A => G[B])\n      (using G: Applicative[G]): G[F[B]] =\n    inst.traverse[A, G, B](fa)(G.map)(G.pure)(G.ap)([f[_]] => (tf: T[f], fa: f[A]) => tf.traverse(fa)(f))\n```\n\n----------------------------------------\n\nTITLE: Using Lower Type Bounds to Fix Variance in Scala Covariant List Prepend Method\nDESCRIPTION: This code snippet corrects the previous issue by introducing a new type parameter U with a lower bound of B (U >: B) in the prepend method. This approach reverses the variance position of the method parameter elem from covariant to contravariant, enabling safe addition of elements to the covariant list structure. This change ensures successful compilation and proper variance handling in Scala collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/lower-type-bounds.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntrait Node[+B] {\n  def prepend[U >: B](elem: U): Node[U]\n}\n\ncase class ListNode[+B](h: B, t: Node[B]) extends Node[B] {\n  def prepend[U >: B](elem: U): ListNode[U] = ListNode(elem, this)\n  def head: B = h\n  def tail: Node[B] = t\n}\n\ncase class Nil[+B]() extends Node[B] {\n  def prepend[U >: B](elem: U): ListNode[U] = ListNode(elem, this)\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Field to a Case Class and Updating Constructors in Scala 3\nDESCRIPTION: This Scala 3 example shows how to add an optional address field and a corresponding withAddress method to a Person case class, updating the apply constructor to default the address to None. The method maintains binary compatibility with older users. Dependencies include prior case class implementation and sbt/MiMa when used for library distribution. Inputs are original and new fields; outputs are the augmented Person objects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/binary-compatibility-for-library-authors.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Person private (name: String, age: Int, address: Option[String]):\n  ...\n  def withAddress(address: Option[String]) = copy(address = address)\n\nobject Person:\n  // Update the public constructor to also initialize the address field\n  def apply(name: String, age: Int): Person = new Person(name, age, None)\n```\n\n----------------------------------------\n\nTITLE: Example Scala 2.13 sbt Build Configuration (Scala)\nDESCRIPTION: This snippet shows an example sbt build configuration (`build.sbt`) for a Scala 2.13 project. It defines dependencies, including standard libraries, test dependencies, a macro library, and compiler plugins. This configuration is used as the basis for demonstrating the `migrateDependencies` command.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/scala3-migrate.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n//build.sbt\nlazy val main = project\n  .in(file(\".\"))\n  .settings(\n    scalaVersion := \"2.13.11\",\n    libraryDependencies ++= Seq(\n      \"org.typelevel\" %% \"cats-core\" % \"2.4.0\",\n      \"io.github.java-diff-utils\" % \"java-diff-utils\" % \"4.12\",\n      \"org.scalameta\" %% \"parsers\" % \"4.8.9\",\n      \"org.scalameta\" %% \"munit\" % \"0.7.23\" % Test,\n      \"com.softwaremill.scalamacrodebug\" %% \"macros\" % \"0.4.1\" % Test\n    ),\n    addCompilerPlugin((\"org.typelevel\" %% \"kind-projector\" % \"0.13.2\").cross(CrossVersion.full)),\n    addCompilerPlugin(\"com.olegpy\" %% \"better-monadic-for\" % \"0.3.1\")\n  )\n```\n\n----------------------------------------\n\nTITLE: Defining Methods with Implicit Parameters in Scala\nDESCRIPTION: Example showing how to declare a method with an implicit parameter using multiple parameter lists, where the implicit parameter is placed in its own parameter list.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/multiple-parameter-lists.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef execute(arg: Int)(implicit ec: scala.concurrent.ExecutionContext) = ???\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef execute(arg: Int)(using ec: scala.concurrent.ExecutionContext) = ???\n```\n\n----------------------------------------\n\nTITLE: Assets Directory Structure Example\nDESCRIPTION: Shows how to organize assets like images in the _assets directory for use in the static site.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/static-site.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n├── _assets\n│   └── images\n│        └── myimage.png\n└── _docs\n    └── getting-started.md\n```\n\n----------------------------------------\n\nTITLE: Using Intersection Types with Traits in Scala 3\nDESCRIPTION: Demonstrates the definition and usage of intersection types in Scala 3 via the `&` operator. The traits `Resettable` and `Growable[A]` declare methods `reset` and `add` respectively. The function `f` accepts a parameter `x` of type `Resettable & Growable[String]`, allowing invocation of both `reset()` and `add(\"first\")` on `x`. This snippet requires Scala 3 and leverages the new intersection type syntax to represent values that fulfill multiple trait contracts simultaneously.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-intersection.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Resettable:\n  def reset(): Unit\n\ntrait Growable[A]:\n  def add(a: A): Unit\n\ndef f(x: Resettable & Growable[String]): Unit =\n  x.reset()\n  x.add(\"first\")\n```\n\n----------------------------------------\n\nTITLE: Inferring Value Type Using Scala Type Inference\nDESCRIPTION: Demonstrates that the Scala compiler can infer the type of a value from its assigned expression. In this example, the compiler infers that the val named \"businessName\" has the type String from the provided string literal. This requires no explicit type declaration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/type-inference.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval businessName = \"Montreux Jazz Café\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Class with Option Type for Optional Fields in Scala\nDESCRIPTION: An improved Address class definition that uses Option[String] for the optional street2 field, making the optionality explicit in the type system.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fp-functional-error-handling.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nclass Address(\n  var street1: String,\n  var street2: Option[String],   // необязательное значение\n  var city: String, \n  var state: String, \n  var zip: String\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Source Directory for Scala Code\nDESCRIPTION: Shell command to create a package directory under src/main/scala for the Scala source files.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/sbt-scalatest-tdd.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n$ mkdir src/main/scala/simpletest\n```\n\n----------------------------------------\n\nTITLE: Declaring Variables with Explicit Types\nDESCRIPTION: Highlights how to explicitly declare variable types for better code clarity, such as Person objects or primitive types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-vars-data-types.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval x: Int = 1\nval s: String = \"a string\"\nval p: Person = Person(\"Richard\")\n```\n\n----------------------------------------\n\nTITLE: Output of migrateDependencies Command (Sbt Console)\nDESCRIPTION: This snippet displays the full console output generated by running the `migrateDependencies main` command in the sbt shell for the example project. It categorizes the project's dependencies and compiler plugins based on their compatibility with Scala 3 and provides recommendations for migration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/scala3-migrate.md#_snippet_2\n\nLANGUAGE: Sbt Console\nCODE:\n```\nsbt:main> migrateDependencies main\n[info] \n[info] Starting migration of libraries and compiler plugins of project main\n[info] \n[info] <span style=\"color:green\">Valid dependencies:</span>\n[info] \"io.github.java-diff-utils\" % \"java-diff-utils\" % \"4.12\"\n\n[warn] \n[warn] <span style=\"color:orange\">Versions to update:</span>\n[warn] \"org.typelevel\" %% \"cats-core\" % \"<span style=\\\"color:orange\\\">2.6.1</span>\" <span style=\"color:orange\">(Other versions: 2.7.0, ..., 2.10.0)</span>\n[warn] \"org.scalameta\" %% \"munit\" % \"<span style=\\\"color:orange\\\">0.7.25</span>\" % Test <span style=\"color:orange\">(Other versions: 0.7.26, ..., 1.0.0-M8)</span>\n[warn] \n[warn] <span style=\"color:orange\">For Scala 3 use 2.13:</span>\n[warn] (\"org.scalameta\" %% \"parsers\" % \"4.8.9\")<span style=\"color:orange\">.cross(CrossVersion.for3Use2_13)</span>\n[warn] \n[warn] <span style=\"color:orange\">Integrated compiler plugins:</span>\n[warn] addCompilerPlugin((\"org.typelevel\" %% \"kind-projector\" % \"0.13.2\").cross(CrossVersion.full))\n[warn] replaced by <span style=\"color:orange\">scalacOptions += \"-Ykind-projector\"</span>\n[error] \n[error] <span style=\"color:red\">Incompatible Libraries:</span>\n[error] \"com.softwaremill.scalamacrodebug\" %% \"macros\" % \"0.4.1\" % Test <span style=\"color:red\">(Macro Library)</span>\n[error] addCompilerPlugin(\"com.olegpy\" %% \"better-monadic-for\" % \"0.3.1\") <span style=\"color:red\">(Compiler Plugin)</span>\n[info] \n[success] Total time: 0 s, completed Aug 28, 2023 9:18:04 AM\n```\n\n----------------------------------------\n\nTITLE: Matching Quoted Expressions with Explicit Type Variables (Proposed New Syntax) - Scala\nDESCRIPTION: Shows the final proposed syntax for explicit type variables (`t`, `u`, `tail`) in Scala quoted expression patterns, where references within the quote pattern do not require backticks. This syntax matches the simplified version previously shown.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/quote-pattern-type-variable-syntax.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ncase '{ type t; $x: t } => f[t](x: Expr[t])\ncase '{ type u; ($ls: List[u]).map($f: u => Int) } => g[u](ls: Expr[List[u]], f: Expr[u => Int])\ncase '{ type tail <: Tuple; $x: *:[Int, tail] } => h[tail](x: Expr[*:[Int, tail])\n```\n\n----------------------------------------\n\nTITLE: Enabling comparison with CanEqual given instance\nDESCRIPTION: Shows how to enable comparison between instances of the same class by providing a given instance of CanEqual in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-multiversal-equality.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// Option 2\ncase class Dog(name: String)\ngiven CanEqual[Dog, Dog] = CanEqual.derived\n```\n\n----------------------------------------\n\nTITLE: Definition Sketch of `Expr.apply` using `ToExpr`\nDESCRIPTION: Provides a conceptual definition of `Expr.apply`. It takes a value `x` of type `T` and uses an implicitly available `ToExpr[T]` instance to convert `x` into its corresponding `Expr[T]` representation (quoted code that constructs `x`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nobject Expr:\n  def apply[T](x: T)(using Quotes, ToExpr[T]): Expr[T] =\n    summon[ToExpr[T]].apply(x)\n```\n\n----------------------------------------\n\nTITLE: Executing a Multiline Method in Scala REPL (2 & 3)\nDESCRIPTION: Shows the invocation of the `addThenDouble` method with arguments `(1, 1)` in the Scala REPL and its expected output `res0: Int = 4`, demonstrating how the return value is inferred and displayed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nscala> addThenDouble(1, 1)\nres0: Int = 4\n```\n\n----------------------------------------\n\nTITLE: Type Signature of Collections Containing Function Variables in Scala\nDESCRIPTION: Describes the inferred Scala types of collections containing function variables: a List of functions with type `Int => Int` and a Map with String keys and function values of type `Int => Int`. This snippet clarifies type relationships in functional collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-function-variables.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\n// a List that contains functions of the type `Int => Int`\nfunctionList: List[Int => Int]\n\n// a Map whose keys have the type `String`, and whose\n// values have the type `Int => Int`\nfunctionMap: Map[String, Int => Int]\n```\n\n----------------------------------------\n\nTITLE: Accessing a Singleton Object's Method (IdFactory) in Scala\nDESCRIPTION: Shows how to use the previously defined `IdFactory` singleton object by calling its `create` method. The example demonstrates obtaining sequential integer IDs by invoking the method multiple times.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\nval newId: Int = IdFactory.create()\nprintln(newId) // 1\nval newerId: Int = IdFactory.create()\nprintln(newerId) // 2\n```\n\n----------------------------------------\n\nTITLE: Explicit Type Annotation for Variables in Scala\nDESCRIPTION: Provides an example of defining a mutable variable with an explicit type. Useful to ensure type consistency in evolving code and for documentation purposes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nvar x: Int = 1 + 1\n```\n\n----------------------------------------\n\nTITLE: Type Ascription Examples in Scala\nDESCRIPTION: Demonstrates various uses of type ascription in Scala, which is an up-cast performed at compile-time for the type checker. Includes examples with List, varargs, and AnyRef.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/types.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nNil: List[String]\nSet(values: _*)\n\"Daniel\": AnyRef\n```\n\n----------------------------------------\n\nTITLE: Compiler Expansion of Context Bounds and Deferred Givens in Scala\nDESCRIPTION: Illustrates the compiler's translation of the previous `Sorted` trait and `SortedSet` class example. The context bound `: Ord` on `Element` in the trait expands to a deferred given `given Ord[Element] = compiletime.deferred`. The implementing class `SortedSet` receives the `Ord[A]` instance via a `using` clause and provides it as an `override given` for `Ord[Element]`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ntrait Sorted:\n  type Element\n  given Ord[Element] = compiletime.deferred\n\nclass SortedSet[A](using evidence$0: Ord[A]) extends Sorted:\n  type Element = A\n  override given Ord[Element] = evidence$0\n```\n\n----------------------------------------\n\nTITLE: Использование обратного вызова onComplete с Future в Scala\nDESCRIPTION: Демонстрация использования метода onComplete для обработки результата Future с помощью паттерн-матчинга для Success и Failure случаев.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/concurrency.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nFuture(longRunningAlgorithm()).onComplete {\n  case Success(value) => println(s\"Got the callback, value = $value\")\n  case Failure(e) => e.printStackTrace\n}\n```\n\n----------------------------------------\n\nTITLE: Using Basic Collection Methods in Scala\nDESCRIPTION: Examples of common collection methods that don't use lambda expressions, including distinct, drop, head, init, intersect, last, slice, tail, and take variants.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/collections-methods.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval a = List(10, 20, 30, 40, 10)      // List(10, 20, 30, 40, 10)\n\na.distinct                            // List(10, 20, 30, 40)\na.drop(2)                             // List(30, 40, 10)\na.dropRight(2)                        // List(10, 20, 30)\na.head                                // 10\na.headOption                          // Some(10)\na.init                                // List(10, 20, 30, 40)\na.intersect(List(19,20,21))           // List(20)\na.last                                // 10\na.lastOption                          // Some(10)\na.slice(2,4)                          // List(30, 40)\na.tail                                // List(20, 30, 40, 10)\na.take(3)                             // List(10, 20, 30)\na.takeRight(2)                        // List(40, 10)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Trait with Context-Bounded Type Members in Scala\nDESCRIPTION: Provides an example of a trait `Sorted` defining a type member `Element` with a context bound `: Ord`, and a class `SortedSet` that implements this trait. The class satisfies the context bound requirement via its own type parameter `A : Ord`, linking it to the implemented `Element` type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ntrait Sorted:\n  type Element : Ord\n\nclass SortedSet[A : Ord] extends Sorted:\n  type Element = A\n```\n\n----------------------------------------\n\nTITLE: Handling Type Parameters in Scala 3 Macros\nDESCRIPTION: This example shows how to handle type parameters in a macro by using the Type[T] class. It demonstrates the pattern for both the inline entry point and the macro implementation method that requires the type information.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/macros.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ninline def logged[T](inline x: T): T = ${ loggedCode('x)  }\n\ndef loggedCode[T](x: Expr[T])(using Type[T], Quotes): Expr[T] = ...\n```\n\n----------------------------------------\n\nTITLE: Defining an Expensive Computation Function in Scala\nDESCRIPTION: Shows the definition of a Scala function 'f' that performs an expensive computation by printing a message, sleeping for 100 milliseconds, and returning the reversed input string. Demonstrates function definition syntax in Scala 2 and Scala 3. Requires no external dependencies. The input parameter 'x' is a string and the output is the reversed string. The function does not have side effects other than console output and sleep delay.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/maps.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: String): String = {\n  println(\"taking my time.\"); Thread.sleep(100)\n  x.reverse\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Type Subtyping Relationship in Scala\nDESCRIPTION: Shows the subtyping relationship derived from the initial trait definitions: `Book` is a subtype of `Buyable`, and `Buyable` is a subtype of `Item`. This relationship is fundamental to understanding how variance impacts parameterized types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-variance.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nBook <: Buyable <: Item\n```\n\n----------------------------------------\n\nTITLE: Using the New runtimeCheck Method with Pattern Matching in Scala\nDESCRIPTION: Demonstrates the proposed usage of the runtimeCheck extension method to assert that a pattern is checked at runtime, replacing the @unchecked annotation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/replace-nonsensical-unchecked-annotation.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef xs: List[Any] = ???\nval y :: ys = xs.runtimeCheck\n```\n\n----------------------------------------\n\nTITLE: Inspecting Type of Anonymous Type Provider Result\nDESCRIPTION: Illustrates the inferred structural type of the value produced by the anonymous type provider macro. The compiler captures publicly visible members from the macro's local definitions (like `Coffee` and `Coffees`) and exposes them via a structural type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/typeproviders.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val db = h2db(\"jdbc:h2:coffees.h2.db\")\ndb: AnyRef {\n  type Coffee { val name: String; val price: Int; ... }\n  val Coffees: Table[this.Coffee]\n} = $anon$1...\n```\n\n----------------------------------------\n\nTITLE: Extending Traits with Upper Type Bounds - Scala 3\nDESCRIPTION: Defines an abstract class 'SeqBuffer' extending 'Buffer', introducing an abstract type 'U' and restricting 'T' as a subtype of 'Seq[U]'. Implements a 'length' method for sequence length. Written in Scala 3 style and depends on core Scala collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/abstract-type-members.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class SeqBuffer extends Buffer:\n  type U\n  type T <: Seq[U]\n  def length = element.length\n```\n\n----------------------------------------\n\nTITLE: Explanation of initialization order for strict vals in Scala\nDESCRIPTION: This section explains the order in which strict (non-lazy) vals are initialized in Scala classes and subclasses, emphasizing superclass first, then declaration order within classes. It clarifies why overridden vals might be uninitialized during superclass construction.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/FAQ/initialization-order.md#_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Using a Generic Reference with Integer Type in Scala\nDESCRIPTION: Example of using the generic Reference class with an Integer type parameter, demonstrating how to create, set and access values from the type-safe container.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_de/tutorials/scala-for-java-programmers.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nobject IntegerReference {\n  def main(args: Array[String]): Unit = {\n    val cell = new Reference[Int]\n    cell.set(13)\n    println(\"Reference contains the half of \" + (cell.get * 2))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Package in Scala 3 Using Single Line Syntax - Scala\nDESCRIPTION: Demonstrates declaring a top-level package in Scala using the single-line package syntax before definitions. This style associates all definitions in the file with the declared package. The snippet shows declaring a package for a domain with nested package names as per conventional naming schemes. Requires Scala 3 support. Expected input is the package structure line and class declarations, output is the class belonging to the specified package.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/packaging-imports.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\npackage com.acme.myapp.model\n\nclass Person ...\n```\n\n----------------------------------------\n\nTITLE: Invoking a Higher-Order Function With Compatible Functions in Scala\nDESCRIPTION: Demonstrates usage of the higher-order method sayHello by passing compatible no-parameter functions helloJoe and bonjourJulien. When called, sayHello calls the passed function, which results in printing personalized greetings. This shows how functions matching the expected signature can be seamlessly passed and invoked in Scala HOFs. The snippet involves core Scala standard output and method invocation and requires no external dependencies. Inputs are the selected functions, output is Unit from their invoked effects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-hofs.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nsayHello(helloJoe)   // prints \"Hello, Joe\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\nsayHello(bonjourJulien)\n```\n\n----------------------------------------\n\nTITLE: Scala Value Class Inheritance Restrictions (Disallowed)\nDESCRIPTION: This snippet highlights two inheritance restrictions for Scala value classes. First, a value class (`Value`) cannot extend a non-universal trait (`NotUniversal`). Second, a value class cannot be extended by another class (`Extend`), as value classes are implicitly final. The compiler errors confirm both rules.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\ntrait NotUniversal\nclass Value(val x: Int) extends AnyVal with NotUniversal\nclass Extend(x: Int) extends Value(x)\n```\n\nLANGUAGE: text\nCODE:\n```\nExtend.scala:2: error: illegal inheritance; superclass AnyVal\n is not a subclass of the superclass Object\n of the mixin trait NotUniversal\nclass Value(val x: Int) extends AnyVal with NotUniversal\n                                            ^\nExtend.scala:3: error: illegal inheritance from final class Value\nclass Extend(x: Int) extends Value(x)\n                             ^\n```\n\n----------------------------------------\n\nTITLE: Illustrating Boilerplate in Manual Type Class Instances (Scala)\nDESCRIPTION: Highlights the boilerplate problem associated with manually defining type class instances. It shows two similar classes, `C` and `D`, each requiring a separate but structurally analogous `Showable` instance definition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/implicits.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass C(x: Int)\nimplicit def cShowable = new Showable[C] {\n  def show(c: C) = \"C(\" + c.x + \")\"\n}\n\nclass D(x: Int)\nimplicit def dShowable = new Showable[D] {\n  def show(d: D) = \"D(\" + d.x + \")\"\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing Expression Tree with q (Scala)\nDESCRIPTION: Demonstrates using the `q` interpolator to create a `universe.Tree` representing a simple Scala expression. Shows the resulting tree structure. This is the basic usage for creating expression or definition trees.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/intro.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val tree = q\"i am { a quasiquote }\"\ntree: universe.Tree = i.am(a.quasiquote)\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Unliftable Instance in Scala\nDESCRIPTION: Shows how to define a custom Unliftable instance for a user-defined Point case class. This example creates an implicit unliftPoint value using the Unliftable companion object’s apply method, specifying a partial function that matches the fully qualified tree representation of Point with integer arguments. This enables pattern matching on syntax trees representing Point instances with literal Int components.  Dependencies include scala.universe._ for Tree definitions, and the snippet highlights limitations such as requiring fully qualified references and literal Int arguments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/unlifting.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\npackage Points\n\nimport scala.universe._\n\ncase class Point(x: Int, y: Int)\nobject Point {\n  implicit val unliftPoint = Unliftable[points.Point] {\n    case q\"_root_.points.Point(${x: Int}, ${y: Int})\" => Point(x, y)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Inline Entry Point for a Scala 3 Macro\nDESCRIPTION: This snippet shows how to create the inline entry point for a macro. It demonstrates the structure where the inline method contains a single splice calling the macro implementation with quoted parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/macros.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ninline def inspect(inline x: Any): Any = ${ inspectCode('x) }\n```\n\n----------------------------------------\n\nTITLE: Adding Specific MUnit Version using Scala CLI\nDESCRIPTION: Adds a specific version of MUnit directly as a dependency using the Scala CLI `//> using dep` directive. This is an alternative to including the full Scala Toolkit and applies only to test files.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-munit.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n//> using dep org.scalameta::munit:1.1.0\n```\n\n----------------------------------------\n\nTITLE: Importing JavaConverters in Scala\nDESCRIPTION: This Scala code demonstrates importing all members of the `collection.JavaConverters` object using a wildcard import (`_`). This import brings the implicit conversions and extension methods (`asJava`, `asScala`) into scope, enabling easy conversion between Scala and Java collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/conversions-between-java-and-scala-collections.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nscala> import collection.JavaConverters._\nimport collection.JavaConverters._\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Pattern Matching with Duration in Scala 3\nDESCRIPTION: Demonstrates various ways to instantiate Duration objects and use pattern matching with Duration in Scala 3, showing the syntax differences from Scala 2, particularly in import statements and method invocation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_40\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.concurrent.duration.*\nimport java.util.concurrent.TimeUnit.*\n\n// instantiation\nval d1 = Duration(100, MILLISECONDS) // from Long and TimeUnit\nval d2 = Duration(100, \"millis\") // from Long and String\nval d3 = 100.millis // implicitly from Long, Int or Double\nval d4 = Duration(\"1.2 µs\") // from String\n\n// pattern matching\nval Duration(length, unit) = 5.millis\n```\n\n----------------------------------------\n\nTITLE: メソッドの定義と呼び出し - Scala\nDESCRIPTION: defキーワードを使い名前付きメソッドを定義する基本例です。引数リストと戻り値型を指定し、足し算の処理を記述しています。呼び出し時に引数値を渡し結果を出力します。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ndef add(x: Int, y: Int): Int = x + y\nprintln(add(1, 2)) // 3\n```\n\n----------------------------------------\n\nTITLE: Simulating Java Bean Getters and Setters in Scala\nDESCRIPTION: Demonstrates how to encapsulate private fields in Scala with bean-style getter and setter methods, using a backing variable prefixed with underscore. This enables Java-style property access semantics while conforming to Scala’s naming and method design.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/naming-conventions.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nclass Company {\n  private var _name: String = _\n\n  def name = _name\n\n  def name_=(name: String) {\n    _name = name\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating a Class with Traits in Scala 2\nDESCRIPTION: This snippet shows how to instantiate MyService in Scala 2 using the new keyword, assigning it to a typed value. It creates s1 as an instance with the name 'Service 1'. Standard Scala 2 syntax and type declarations are used.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval s1: MyService = new MyService(\"Service 1\")\n```\n\n----------------------------------------\n\nTITLE: Implicit conversion for sequence methods support via ArrayOps\nDESCRIPTION: This snippet shows how implicit conversions add sequence methods to arrays by wrapping them in an ArrayOps object, which supports operations like 'reverse'. It highlights the priority of implicit conversions in Scala, where ArrayOps has higher precedence than WrappedArray.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/arrays.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval seq: Seq[Int] = a1\nseq.reverse\nres2: Seq[Int] = WrappedArray(3, 2, 1)\nval ops: collection.mutable.ArrayOps[Int] = a1\nops.reverse\nres3: Array[Int] = Array(3, 2, 1)\n```\n\n----------------------------------------\n\nTITLE: Implementing Self Types with User and Tweeter Traits in Scala\nDESCRIPTION: This example demonstrates how self types work in Scala. The Tweeter trait requires the User trait using a self type annotation, allowing it to access the username member without directly extending User. The VerifiedTweeter class implements both traits to satisfy the self type requirement.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/self-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait User {\n  def username: String\n}\n\ntrait Tweeter {\n  this: User =>  // 重新赋予 this 的类型\n  def tweet(tweetText: String) = println(s\"$username: $tweetText\")\n}\n\nclass VerifiedTweeter(val username_ : String) extends Tweeter with User {  // 我们混入特质 User 因为 Tweeter 需要\n\tdef username = s\"real $username_\"\n}\n\nval realBeyoncé = new VerifiedTweeter(\"Beyoncé\")\nrealBeyoncé.tweet(\"Just spilled my glass of lemonade\")  // 打印出 \"real Beyoncé: Just spilled my glass of lemonade\"\n```\n\n----------------------------------------\n\nTITLE: Influencing code generation with @inline annotation in Scala\nDESCRIPTION: Describes how @inline suggests to the compiler to inline methods, potentially improving performance. The example notes that inlining is heuristic and not guaranteed, affecting the generated bytecode.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/annotations.md#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Demonstrating Immutability and Copying with Scala Case Classes\nDESCRIPTION: Illustrates that case class fields are immutable by default and cannot be reassigned, exemplified by a commented out assignment that would cause a compile error. Shows how to create modified copies of case class instances using the 'copy' method with selective field replacement, supporting functional programming immutability principles.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/case-classes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nemailFromJohn.title = \"Goodbye From John!\" // 이것은 컴파일시에 에러가 난다. 우리는 val인 필드에 다른 값을 할당할수 없으며, 모든 케이스 클래스 필드는 기본적으로 val이다.\n\nval editedEmail = emailFromJohn.copy(title = \"I am learning Scala!\", body = \"It's so cool!\")\nprintln(emailFromJohn) // prints \"Email(john.doe@mail.com,Greetings From John!,Hello World!)\"\nprintln(editedEmail) // prints \"Email(john.doe@mail.com,I am learning Scala,It's so cool!)\"\n```\n\n----------------------------------------\n\nTITLE: Running MUnit Tests with Scala CLI - shell\nDESCRIPTION: Executes all test suites within the 'example' directory using the Scala CLI command-line tool. Requires that MUnit is properly installed and test files are located under the specified folder. The command compiles the project and prints test results, including durations and individual statuses for each test suite. Output shows passed tests, denoted by a '+' before their names.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-run.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nscala-cli test example\n# Compiling project (test, Scala 3.2.1, JVM)\n# Compiled project (test, Scala 3.2.1, JVM)\n# MyTests:\n#  + sum of two integers 0.009s\n```\n\n----------------------------------------\n\nTITLE: Running sbt and Building Project in Interactive Shell - Bash and sbt Prompt\nDESCRIPTION: This snippet outlines starting the sbt interactive shell, where project settings are loaded and the sbt server is started. Within the sbt prompt, the 'run' command compiles and executes the 'helloWorld' main method, showing output and timings. This interactive mode speeds up iterative development by avoiding JVM startup overhead.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt\n\n[info] welcome to sbt\n[info] loading settings for project ...\n[info] loading project definition ...\n[info] loading settings for project root from build.sbt ...\n[info] sbt server started at\n       local:///${HOME}/.sbt/1.0/server/7d26bae822c36a31071c/sock\nsbt:hello-world> run\n\n[info] running helloWorld\nHello, world\n[success] Total time: 0 s\n```\n\n----------------------------------------\n\nTITLE: Команди компіляції та роботи з файлами TASTy та байткодом - Bash\nDESCRIPTION: Набір команд Bash для компіляції Scala файлу за допомогою scalac та перегляду створених файлів, зокрема файлів з розширенням .tasty. Команди також ілюструють перегляд вмісту файлу .tasty у текстовому форматі та в форматі, схожому на декомпільований Scala код. Ці команди вимагають встановленого Scala 3 компілятора та доступу до shell.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/scala3/guides/tasty-overview.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ scalac Hello.scala\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ ls -1\nHello$package$.class\nHello$package.class\nHello$package.tasty\nHello.scala\nhello.class\nhello.tasty\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ scalac -print-tasty hello.tasty\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ scalac -decompile hello.tasty\n```\n\n----------------------------------------\n\nTITLE: Using callback-based Futures for currency trading in Scala 2\nDESCRIPTION: Demonstrates how to use Scala Futures with nested callbacks (foreach) to perform a currency trading operation: fetching a USD rate and making a purchase if profitable. The snippet creates a Future to get the current value and then another Future for making a purchase inside the callback. It prints the purchased amount asynchronously. This approach leads to nested callbacks which can complicate code structure and reduce readability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nval rateQuote = Future {\n  connection.getCurrentValue(USD)\n}\n\nfor (quote <- rateQuote) {\n  val purchase = Future {\n    if (isProfitable(quote)) connection.buy(amount, quote)\n    else throw new Exception(\"not profitable\")\n  }\n\n  for (amount <- purchase)\n    println(\"Purchased \" + amount + \" USD\")\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Case Class Instances by Structural Equality in Scala\nDESCRIPTION: Demonstrates that instances of a case class are compared based on their structure (values) rather than reference identity. Two separate 'Message' instances with identical field values are compared using '==' and yield true. It relies on the automatically generated 'equals' method of case classes. Inputs are two 'Message' objects with identical content, output is a boolean indicating equality.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tour/case-classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncase class Message(sender: String, recipient: String, body: String)\n\nval message2 = Message(\"jorge@catalonia.es\", \"guillaume@quebec.ca\", \"Com va?\")\nval message3 = Message(\"jorge@catalonia.es\", \"guillaume@quebec.ca\", \"Com va?\")\nval messagesAreTheSame = message2 == message3  // true\n```\n\n----------------------------------------\n\nTITLE: Enhancing Custom Parallel Collection with Combiner Support (Scala)\nDESCRIPTION: Updates the `ParString` class definition to include `ParSeqLike`. This trait helps ensure that transformer methods like `filter` return the specific `ParString` type. It overrides the `newCombiner` method to provide an instance of the custom `ParStringCombiner`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/custom-parallel-collections.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass ParString(val str: String)\nextends immutable.ParSeq[Char]\n   with ParSeqLike[Char, ParString, collection.immutable.WrappedString] {\n\n  // apply, length, seq, splitter methods remain the same as before\n  def apply(i: Int) = str.charAt(i)\n  def length = str.length\n  def seq = new collection.immutable.WrappedString(str)\n  def splitter = new ParStringSplitter(str, 0, str.length)\n\n  // Inner ParStringSplitter class definition remains the same\n  class ParStringSplitter(private var s: String, private var i: Int, private val ntl: Int)\n  extends SeqSplitter[Char] { /* ... methods ... */ }\n\n  protected[this] override def newCombiner: Combiner[Char, ParString] = new ParStringCombiner\n\n  // ... ParStringCombiner class definition follows ...\n}\n```\n\n----------------------------------------\n\nTITLE: Utilizing createGreetingFunction to Generate Language-Specific Greeting Functions in Scala\nDESCRIPTION: Shows how to call `createGreetingFunction` with different language strings to produce greeting functions `greetInFrench` and `greetInEnglish`. Each returned function accepts a name string and prints the greeting in the respective language. This snippet highlights how to consume higher-order factory methods and invoke the returned functions with inputs to produce desired console output. Inputs are language strings and name strings; outputs are printed greetings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-write-method-returns-function.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval greetInFrench = createGreetingFunction(\"french\")\ngreetInFrench(\"Jonathan\")   // prints \"Bonjour, Jonathan\"\n\nval greetInEnglish = createGreetingFunction(\"english\")\ngreetInEnglish(\"Joe\")   // prints \"Hello, Joe\"\n```\n\n----------------------------------------\n\nTITLE: Dependencies Requiring CrossVersion.for3Use2_13 Output (Sbt Console)\nDESCRIPTION: This snippet shows the 'For Scala 3 use 2.13' section from the `migrateDependencies` command output. It lists dependencies that are not cross-published to Scala 3 but can be used by compiling against their 2.13 artifacts, requiring the addition of `.cross(CrossVersion.for3Use2_13)` in `build.sbt`. Note the disclaimer about potential transitive dependency conflicts.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/scala3-migrate.md#_snippet_5\n\nLANGUAGE: Sbt Console\nCODE:\n```\n[warn] <span style=\"color:orange\">For Scala 3 use 2.13:</span>\n[warn] (\"org.scalameta\" %% \"parsers\" % \"4.8.9\")<span style=\"color:orange\">.cross(CrossVersion.for3Use2_13)</span>\n```\n\n----------------------------------------\n\nTITLE: Unsafe synchronous ExecutionContext example\nDESCRIPTION: Demonstrates an example of creating an ExecutionContext that executes runnables immediately in the current thread, which is strongly discouraged due to potential deadlocks and unpredictable behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval currentThreadExecutionContext = ExecutionContext.fromExecutor(\n  new Executor {\n    // Do not do this!\n    def execute(runnable: Runnable) = runnable.run()\n  })\n```\n\n----------------------------------------\n\nTITLE: Defining Comments in Scala\nDESCRIPTION: Shows the syntax for single-line (`//`), multi-line (`/* ... */`), and Scaladoc (`/** ... */`) comments in Scala, which is identical to Java.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n//\n/* ... */\n/** ... */\n```\n\n----------------------------------------\n\nTITLE: Mapping Over Lists for Transformation in Scala\nDESCRIPTION: This group of snippets shows various uses of the map method, including mapping integers to doubles, capitalizing strings, creating Map from string-length tuples, and mapping to Boolean. Inputs are List[Int] or List[String], outputs vary by transformation. No dependencies are required. The examples highlight both concise and explicit anonymous function usage, demonstrating map's versatility for type-changing and data transformation tasks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-methods.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nscala> val doubles = oneToTen.map(_ * 2)\ndoubles: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> val doubles = oneToTen.map(i => i * 2)\ndoubles: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> val capNames = names.map(_.capitalize)\ncapNames: List[String] = List(Adam, Brandy, Chris, David)\n\nscala> val nameLengthsMap = names.map(s => (s, s.length)).toMap\nnameLengthsMap: Map[String, Int] = Map(adam -> 4, brandy -> 6, chris -> 5, david -> 5)\n\nscala> val isLessThanFive = oneToTen.map(_ < 5)\nisLessThanFive: List[Boolean] = List(true, true, true, true, false, false, false, false, false, false)\n```\n\n----------------------------------------\n\nTITLE: Working with data structures in Scala\nDESCRIPTION: Shows common data structures in Scala including tuples, lists, and ranges, along with operations to create and manipulate these structures.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n(1, 2, 3)\n```\n\nLANGUAGE: scala\nCODE:\n```\nvar (x, y, z) = (1, 2, 3)\n```\n\nLANGUAGE: scala\nCODE:\n```\nvar x, y, z = (1, 2, 3)\n```\n\nLANGUAGE: scala\nCODE:\n```\nvar xs = List(1, 2, 3)\n```\n\nLANGUAGE: scala\nCODE:\n```\nxs(2)\n```\n\nLANGUAGE: scala\nCODE:\n```\n1 :: List(2, 3)\n```\n\nLANGUAGE: scala\nCODE:\n```\n1 to 5\n```\n\nLANGUAGE: scala\nCODE:\n```\n1 until 6\n```\n\nLANGUAGE: scala\nCODE:\n```\n1 to 10 by 2\n```\n\nLANGUAGE: scala\nCODE:\n```\n()\n```\n\n----------------------------------------\n\nTITLE: Dependency resolution in Scala using sbt\nDESCRIPTION: This snippet demonstrates how Scala's sbt build tool handles project dependencies by specifying them in 'build.sbt' and running 'sbt compile', which automatically resolves and downloads all necessary dependencies. It emphasizes that users do not need to interact with downloaded dependencies directly and that the process is automatic and seamless.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_76\n\nLANGUAGE: Scala\nCODE:\n```\ncd myapp\nsbt compile\n```\n\n----------------------------------------\n\nTITLE: Defining and Calling a Function in Scala Worksheet\nDESCRIPTION: Demonstrates defining a simple function `square` within a Scala Worksheet in IntelliJ. The function takes an integer `x` and returns its square. It is then called with the value 2. Scala Worksheets provide an interactive environment where code is evaluated and results are displayed alongside the code, suitable for both Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/getting-started/intellij-track/getting-started-with-scala-in-intellij.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef square(x: Int): Int = x * x\n\nsquare(2)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Sensor System Extending SubjectObserver in Scala 2\nDESCRIPTION: This Scala 2 snippet provides a concrete implementation 'SensorReader' object extending 'SubjectObserver', with 'S' as 'Sensor' and 'O' as 'Display'. It defines classes 'Sensor' (with state and state change method) and 'Display' (implementing the 'notify' method). This pattern demonstrates practical use of abstract types and nested traits for creating sensor-monitoring components.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-oop.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nobject SensorReader extends SubjectObserver {\n  type S = Sensor\n  type O = Display\n\n  class Sensor(val label: String) extends Subject {\n    private var currentValue = 0.0\n    def value = currentValue\n    def changeValue(v: Double) = {\n      currentValue = v\n      publish()\n    }\n  }\n\n  class Display extends Observer {\n    def notify(sub: Sensor) =\n      println(s\"${sub.label} has value ${sub.value}\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Graph to Use Path-Independent Node Types in Scala\nDESCRIPTION: Redefines the Graph class's Node inner class so that connected nodes and connectTo method parameters use the type Graph#Node, allowing nodes from different Graph instances to be connected. This snippet relaxes the previous type restriction by utilizing a type projection to express a type independent of the specific outer instance, enabling more flexible node connections across graphs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/inner-classes.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass Graph {\n  class Node {\n    var connectedNodes: List[Graph#Node] = Nil\n    def connectTo(node: Graph#Node): Unit = {\n      if (!connectedNodes.exists(node.equals)) {\n        connectedNodes = node :: connectedNodes\n      }\n    }\n  }\n  var nodes: List[Node] = Nil\n  def newNode: Node = {\n    val res = new Node\n    nodes = res :: nodes\n    res\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Uniform Deconstruction of Anonymous Functions\nDESCRIPTION: Shows that different forms of function creation (placeholder, inferred type, explicit type) result in `Function` ASTs that can be deconstructed uniformly using the `q\"(..$params) => $body\"` pattern. The `$params` will be a list of `ValDef` trees representing the function parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_48\n\nLANGUAGE: scala\nCODE:\n```\nscala> List(f1, f2, f3).foreach {\n             case q\"(..$params) => $body\" =>\n               println(s\"params = $params, body = $body\")\n           }\nparams = List(<synthetic> val x$5 = _), body = x$5.$plus(1)\nparams = List(val a = _), body = a.$plus(1)\nparams = List(val a: Int = _), body = a.$plus(1)\n```\n\n----------------------------------------\n\nTITLE: Scala Quasiquote Pattern for Class Definition\nDESCRIPTION: Presents the general Scala quasiquote pattern for matching or constructing a class definition AST. It outlines the structure including modifiers, type name, type parameters, constructor modifiers/parameters, early definitions, parent types, self-type, and class body statements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/definition-details.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nq\"$mods class $tpname[..$tparams] $ctorMods(...$paramss) extends { ..$earlydefns } with ..$parents { $self => ..$stats }\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Pattern Matching to Return String (Scala 2)\nDESCRIPTION: Defines a function named matchTest that takes an integer parameter and uses pattern matching to return a corresponding string for specific integer cases (1 and 2) and a default \"other\" string for all other values. The match expression is encapsulated in braces following Scala 2 syntax. The function explicitly returns a string, demonstrating that the pattern matching result is also typed appropriately. Example calls show expected output for various integer inputs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/pattern-matching.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef matchTest(x: Int): String = x match {\n  case 1 => \"one\"\n  case 2 => \"two\"\n  case _ => \"other\"\n}\nmatchTest(3)  // выводит \"other\"\nmatchTest(1)  // выводит \"one\"\n```\n\n----------------------------------------\n\nTITLE: Using multi-line blocks with for-expressions in Scala 3\nDESCRIPTION: Demonstrates Scala 3's syntax for multi-line blocks in for-expressions, which doesn't require curly braces but uses indentation to denote the block structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval names = List(\"_olivia\", \"_walter\", \"_peter\")\n\nval capNames = for name <- names yield\n  val nameWithoutUnderscore = name.drop(1)\n  val capName = nameWithoutUnderscore.capitalize\n  capName\n\n// capNames: List[String] = List(Olivia, Walter, Peter)\n```\n\n----------------------------------------\n\nTITLE: Calling Java Methods with Named Parameters\nDESCRIPTION: This note clarifies that when invoking Java methods from Scala, named arguments cannot be used. The snippet emphasizes the restriction and suggests that only positional arguments are valid in Java method calls.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/named-arguments.md#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Illustrating Static Field Initialization Order - Scala\nDESCRIPTION: Compares the initialization behavior of a field in a Scala object extending a class, showing the difference when the field is standard versus annotated with `@static`. It highlights how static field initializers can run earlier than non-static ones in this specific scenario.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/static-members.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass C {\n  val x = {println(\"x\"); 1 }\n}\n\n\nobject O extends C {\n  val y = { println(\"y\"); 2 }\n  // prints:\n  // x\n  // y\n}\n\nobject Os extends C {\n  @static val y = { println(\"y\"); 2 }\n   // prints:\n   // y\n   // x\n}\n```\n\n----------------------------------------\n\nTITLE: Comparison with Verbose Scala 2 Implementation of Numerical Programs\nDESCRIPTION: Demonstrates how Scala 2 would require verbose anonymous classes to implement the same numerical programs that Scala 3 can express concisely.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-dependent-function.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nderivative(new Prog {\n  def apply(nums: Nums)(x: nums.Num): nums.Num = x\n})\nderivative(new Prog {\n  def apply(nums: Nums)(x: nums.Num): nums.Num = nums.add(nums.lit(0.8), x)\n})\n// ...\n```\n\n----------------------------------------\n\nTITLE: Handling Immutable Collection Conversion Limitations\nDESCRIPTION: Illustrates how converting immutable Scala collections to Java collections results in collections that throw UnsupportedOperationException when modification is attempted.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/conversions-between-java-and-scala-collections.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval jul = List(1, 2, 3).asJava\n\njul.add(7)\n// java.lang.UnsupportedOperationException\n//         at java.util.AbstractList.add(AbstractList.java:148)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Name Shadowing (Unhygienic Unquoting) - Scala\nDESCRIPTION: Illustrates 'hygiene in the narrow sense' issues. An existing tree fragment (`originalRef`) referencing a definition (`originalDefn`) is unquoted into a new generated tree (`generatedTree`). A local definition of `x` within the generated code shadows the original binding, causing the unquoted reference `$originalRef` to resolve to the new definition and change semantics.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/hygiene.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val originalTree = q\"val x = 1; x\"\noriginalTree: universe.Tree = ...\n\nscala> toolbox.eval(originalTree)\nres1: Any = 1\n\nscala> val q\"$originalDefn; $originalRef\" = originalTree\noriginalDefn: universe.Tree = val x = 1\noriginalRef: universe.Tree = x\n\nscala> val generatedTree = q\"$originalDefn; { val x = 2; println(x); $originalRef }\"\ngeneratedTree: universe.Tree = ...\n\nscala> toolbox.eval(generatedTree)\n2\nres2: Any = 2\n```\n\n----------------------------------------\n\nTITLE: Handling Future Failures Due to Bad State - Scala\nDESCRIPTION: Illustrates error handling when a Future is created with an invalid session object (null), causing it to fail with a NullPointerException. This demonstrates expected failure modes and how exceptions within the Future body are captured in the resulting Future. Dependencies include scala.concurrent.Future; input assumptions are that session may be null, and consumers must check for potential failures when working with Futures in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/futures-promises.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval session = null\nval f: Future[List[Friend]] = Future {\n  session.getFriends\n}\n```\n\n----------------------------------------\n\nTITLE: Using assert to Check Boolean Conditions in MUnit - Scala 2\nDESCRIPTION: This snippet shows how to write a test in Scala 2 using MUnit's assert method to verify that all elements in a transformed list are even. It defines a test named \"all even numbers\" which multiplies each element in an input list by 2 and asserts that all resulting values are even by checking the modulo condition. It illustrates using assert for boolean conditions and requires MUnit as a dependency.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-suite.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntest(\"all even numbers\") {\n  val input: List[Int] = List(1, 2, 3, 4)\n  val obtainedResults: List[Int] = input.map(_ * 2)\n  // check that obtained values are all even numbers\n  assert(obtainedResults.forall(x => x % 2 == 0))\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Package Object with Shared Variables and Methods in Scala\nDESCRIPTION: This snippet implements a package object `fruits` within the `gardening` package that encapsulates a shared variable `planted` as a list of predefined fruit objects and a method `showFruit` for printing formatted information about a fruit. This allows these members to be accessed throughout the `gardening.fruits` package as if they were defined in the package namespace. The package object is conventionally placed in a file named `package.scala`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/package-objects.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\npackage gardening\npackage object fruits {\n  val planted = List(Apple, Plum, Banana)\n  def showFruit(fruit: Fruit): Unit = {\n    println(s\"${fruit.name}s are ${fruit.color}\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Graph to Allow Connections Across Different Graph Nodes Using Type Projection in Scala 3\nDESCRIPTION: Scala 3 version of the Graph class modification to permit nodes from different graphs to connect by using type projection Graph#Node in the connectedNodes list and connectTo method parameter. The code uses Scala 3 syntax and indentation rules but preserves the intended type semantics that relax strict path-dependent types to enable cross-graph node connections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/inner-classes.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nclass Graph:\n  class Node:\n    var connectedNodes: List[Graph#Node] = Nil\n    def connectTo(node: Graph#Node): Unit =\n      if !connectedNodes.exists(node.equals) then\n        connectedNodes = node :: connectedNodes\n\n  var nodes: List[Node] = Nil\n  def newNode: Node =\n    val res = Node()\n    nodes = res :: nodes\n    res\n```\n\n----------------------------------------\n\nTITLE: Using Complex Class in a Scala Application Object\nDESCRIPTION: Defines a Scala object 'ComplexNumbers' with a 'main' method serving as the program entry point. This snippet demonstrates creating an instance of the 'Complex' class and calling its 'im' method to print the imaginary part. It shows how to instantiate classes and invoke methods, with an example output statement combining string concatenation. Requires Scala runtime and compiler support for application entry via main method with 'Array[String]' parameter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_it/tutorials/scala-for-java-programmers.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nobject ComplexNumbers {\n  def main(args: Array[String]): Unit = {\n    val c = new Complex(1.2, 3.4)\n    println(\"imaginary part: \" + c.im())\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a utility object with a doubling method in Scala\nDESCRIPTION: This Scala snippet defines a simple object named MathUtils containing a method double which takes an integer input and returns its double. It is placed in the package simpletest. This method is the target for subsequent BDD-style tests. No additional dependencies beyond standard Scala are required. The input is an integer i, and the output is the integer result of multiplying i by 2. This object serves as a straightforward example for demonstrating ScalaTest testing styles.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/sbt-scalatest-bdd.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\npackage simpletest\n\nobject MathUtils {\n\n    def double(i: Int) = i * 2\n\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Traits into a Singleton Module Object in Scala 2 and Scala 3\nDESCRIPTION: This snippet shows how to define two traits, AddService and MultiplyService, each providing a method for arithmetic operations. These traits are combined into a singleton object MathService which extends both. This design enables modular functionality aggregation and reuse via importing the object members directly for easy access to methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-objects.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ntrait AddService {\n  def add(a: Int, b: Int) = a + b\n}\n\ntrait MultiplyService {\n  def multiply(a: Int, b: Int) = a * b\n}\n\n// реализация трейтов выше в качестве конкретного объекта\nobject MathService extends AddService with MultiplyService\n\n// использование объекта\nimport MathService._\nprintln(add(1,1))        // 2\nprintln(multiply(2,2))   // 4\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntrait AddService:\n  def add(a: Int, b: Int) = a + b\n\ntrait MultiplyService:\n  def multiply(a: Int, b: Int) = a * b\n\n// реализация трейтов выше в качестве конкретного объекта\nobject MathService extends AddService, MultiplyService\n\n// использование объекта\nimport MathService.*\nprintln(add(1,1))        // 2\nprintln(multiply(2,2))   // 4\n```\n\n----------------------------------------\n\nTITLE: 並行トライを使用した幅優先探索アルゴリズムの実装\nDESCRIPTION: 二次元マップ上で複数の開始点から目標地点への経路を見つける幅優先探索の実装。ParTrieMapを使用して探索前線(open)と訪問済みノード(closed)を管理し、効率的に経路を探索する。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/parallel-collections/ctries.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval length = 1000\n\n// Node 型を定義する\ntype Node = (Int, Int);\ntype Parent = (Int, Int);\n\n// Node 型の演算\ndef up(n: Node) = (n._1, n._2 - 1);\ndef down(n: Node) = (n._1, n._2 + 1);\ndef left(n: Node) = (n._1 - 1, n._2);\ndef right(n: Node) = (n._1 + 1, n._2);\n\n// map と target を作る\nval target = (length / 2, length / 2);\nval map = Array.tabulate(length, length)((x, y) => (x % 3) != 0 || (y % 3) != 0 || (x, y) == target)\ndef onMap(n: Node) = n._1 >= 0 && n._1 < length && n._2 >= 0 && n._2 < length\n\n// open マップ - ノード前線\n// closed マップ - 滞在済みのノード\nval open = ParTrieMap[Node, Parent]()\nval closed = ParTrieMap[Node, Parent]()\n\n// 初期位置をいくつか追加する\nopen((0, 0)) = null\nopen((length - 1, length - 1)) = null\nopen((0, length - 1)) = null\nopen((length - 1, 0)) = null\n\n// 貪欲法による幅優先探索\nwhile (open.nonEmpty && !open.contains(target)) {\n  for ((node, parent) <- open) {\n    def expand(next: Node) {\n      if (onMap(next) && map(next._1)(next._2) && !closed.contains(next) && !open.contains(next)) {\n        open(next) = node\n      }\n    }\n    expand(up(node))\n    expand(down(node))\n    expand(left(node))\n    expand(right(node))\n    closed(node) = parent\n    open.remove(node)\n  }\n}\n\n// 経路の表示\nvar pathnode = open(target)\nwhile (closed.contains(pathnode)) {\n  print(pathnode + \"->\")\n  pathnode = closed(pathnode)\n}\nprintln()\n```\n\n----------------------------------------\n\nTITLE: 不可变集合的更新演示 - Scala\nDESCRIPTION: 展示不可变集合变量如何使用+=和-=操作符进行元素添加和删除。由于不可变集合的特性，这些操作会返回新的集合并赋值给变量s，从而实现集合元素的修改。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/sets.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nscala> var s = Set(1, 2, 3)\ns: scala.collection.immutable.Set[Int] = Set(1, 2, 3)\nscala> s += 4\nscala> s -= 2\nscala> s\nres2: scala.collection.immutable.Set[Int] = Set(1, 3, 4)\n```\n\n----------------------------------------\n\nTITLE: Creating a Mutable Map as a Cache in Scala\nDESCRIPTION: Illustrates how to create an empty mutable Map in Scala to be used as a cache for storing computed string results keyed by strings. Uses Scala's built-in mutable Map from the 'collection.mutable' package. This map supports efficient in-place additions and retrievals. The example shows initialization syntax compatible with both Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/maps.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval cache = collection.mutable.Map[String, String]()\n```\n\n----------------------------------------\n\nTITLE: Implement Smooth Scroll and Highlight for Anchors - JavaScript\nDESCRIPTION: Uses jQuery's `$(document).ready()` to ensure the DOM is loaded before attaching a click event handler to elements with the class 'scroll'. The handler prevents the default anchor link behavior, animates the page scroll to the target element's position (with an added offset), and applies a visual highlight effect to the target element.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/contributing-header.txt#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\njQuery(document).ready(function($) {\n\n            $(\".scroll\").click(function(event){\n              event.preventDefault();\n              $('html,body').animate({scrollTop:$(this.hash).offset().top}, 500);\n              $('html,body').animate({scrollTop:$(this.hash).offset().top-=50}, 500);\n              $(this.hash).effect(\"highlight\", {color: \"#FFCC85\"}, 3000);\n            });\n      });\n```\n\n----------------------------------------\n\nTITLE: Using WeakTypeTag to Handle Abstract or Parameterized Types (Scala)\nDESCRIPTION: Introduces a method weakParamInfo leveraging an implicit WeakTypeTag parameter that can describe types with abstract or unresolved type parameters more flexibly than a regular TypeTag. The method prints type arguments from the WeakTypeTag's type representation, showcasing how runtime type information can reflect generic or abstract types. Requires scala.reflect.runtime.universe._ and implicit WeakTypeTag evidence for T.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/typetags-manifests.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef weakParamInfo[T](x: T)(implicit tag: WeakTypeTag[T]): Unit = {\n  val targs = tag.tpe match { case TypeRef(_, _, args) => args }\n  println(s\"type of $x has type arguments $targs\")\n}\n\n// Example usage:\n// def foo[T] = weakParamInfo(List[T]())\n// foo[Int]\n```\n\n----------------------------------------\n\nTITLE: Defining map Operation on List and Vector Traits in Scala 2\nDESCRIPTION: This snippet demonstrates how the map transformation operation is implemented separately for both the List and Vector traits in Scala 2. Each trait defines a type parameter A and provides a map method, which takes a function from A to B and returns a new collection (List[B] or Vector[B]) of transformed elements. This example shows the need for abstraction over result collection type constructors, a theme central to the new architecture.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait List[A] {\n  def map[B](f: A => B): List[B]\n}\n\ntrait Vector[A] {\n  def map[B](f: A => B): Vector[B]\n}\n```\n\n----------------------------------------\n\nTITLE: Примеры использования makeInt с демонстрацией результатов\nDESCRIPTION: Примеры вызовов функции makeInt для строк \"1\" и \"one\", иллюстрирующие возвращение Some(1) и None. Эти примеры показывают, как можно использовать возвращаемое значение Option для обработки успешных и неуспешных преобразований.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fp-functional-error-handling.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval a = makeInt(\"1\")     // Some(1)\nval b = makeInt(\"one\")   // None\n```\n\n----------------------------------------\n\nTITLE: Using fallbackTo combinator to recover from failed Futures in Scala 2/3\nDESCRIPTION: Demonstrates how to use 'fallbackTo' combinator to attempt an alternative Future if the original Future fails. This snippet tries obtaining the USD quote first, mapping it to a string, but if that Future fails, it falls back to the CHF quote Future. The final Future completes with the first successful quote, or fails if both fail.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\nval usdQuote = Future {\n  connection.getCurrentValue(USD)\n}.map {\n  usd => \"Value: \" + usd + \"$\"\n}\nval chfQuote = Future {\n  connection.getCurrentValue(CHF)\n} map {\n  chf => \"Value: \" + chf + \"CHF\"\n}\n\nval anyQuote = usdQuote.fallbackTo(chfQuote)\n\nanyQuote.foreach { println(_) }\n```\n\n----------------------------------------\n\nTITLE: Method getClassAsString Using match with Multiple Type Cases in Scala 2\nDESCRIPTION: Defines method 'getClassAsString' in Scala 2 that takes any type 'Any' and uses match expression to detect the object's type among String, Int, Double, List, or fallback to Unknown. Demonstrates pattern matching with type casting and wildcard matching. Input is any value; output is descriptive string of type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\n// getClassAsString - метод, принимающий один параметр любого типа.\ndef getClassAsString(x: Any): String = x match {\n  case s: String => s\"'$s' is a String\"\n  case i: Int => \"Int\"\n  case d: Double => \"Double\"\n  case l: List[_] => \"List\"\n  case _ => \"Unknown\"\n}\n\n// примеры\ngetClassAsString(1)               // Int\ngetClassAsString(\"hello\")         // 'hello' is a String\ngetClassAsString(List(1, 2, 3))   // List\n```\n\n----------------------------------------\n\nTITLE: Running Scala Programs Using Scala CLI Bash Commands\nDESCRIPTION: Shows commands to compile and run the Scala source files (`hello.scala` and `helloInteractive.scala`) using the `scala run` command provided by Scala CLI. This snippet demonstrates the usage of the Scala CLI toolchain to build and execute Scala programs with minimal setup. It outputs the compilation progress and runs the main method defined in the source file. Assumes Scala CLI is installed and available in the environment.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-hello-world.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ scala run hello.scala\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ scala run helloInteractive.scala\n```\n\n----------------------------------------\n\nTITLE: Generated Java-compatible main class for @main methods in Scala 3\nDESCRIPTION: This snippet shows the Scala compiler's code generation for an '@main'-annotated method, creating a Java-compatible class with a static 'main' method. It demonstrates how input arguments are parsed and converted into method parameters using 'scala.util.CommandLineParser', enabling the method to run as a command-line program with proper argument handling and exception management.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/methods-main-methods.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nfinal class happyBirthday {\n  import scala.util.{CommandLineParser as CLP}\n  def main(args: Array[String]): Unit =\n    try\n      happyBirthday(\n          CLP.parseArgument[Int](args, 0),\n          CLP.parseArgument[String](args, 1),\n          CLP.parseRemainingArguments[String](args, 2))\n    catch {\n      case error: CLP.ParseError => CLP.showError(error)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Type Alias and Parameter Passing Styles - Scala\nDESCRIPTION: Introduces custom type aliasing and contrasts call-by-value with call-by-name parameters. Dependency: none. Parameters are of a defined alias type, with call-by-name indicated by '=>'. Inputs: any R type, outputs depend on passed function. Useful for functional programming idioms.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ntype R = Double\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: R)\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef f(x: => R)\n```\n\n----------------------------------------\n\nTITLE: Package Management in Scala\nDESCRIPTION: Shows various ways to import packages, rename imports, and declare packages in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/cheatsheets/index.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection._\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.Vector\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.{Vector, Sequence}\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.{Vector => Vec28}\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport java.util.{Date => _, _}\n```\n\nLANGUAGE: scala\nCODE:\n```\npackage pkg\n```\n\nLANGUAGE: scala\nCODE:\n```\npackage pkg {\n  ...\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\npackage object pkg {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Define Base Page Layout and Styles - CSS\nDESCRIPTION: Provides inline CSS rules to configure the basic layout and visual appearance of the web page. It sets styles for the html and body elements (padding, background, shadows), input fields, menu layout, various header styles (font, color, shadow), and specific list and anchor styling within the table of contents (div#toc).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/contributing-header.txt#_snippet_3\n\nLANGUAGE: css\nCODE:\n```\nhtml, body {\n\t     padding-top: 36px;\n\t     height: 100%;\n\t     background:url({{ site.baseurl }}/resources/images/bg-short.jpg) no-repeat top center #310808;\n\t\t  -webkit-box-shadow: inset 0 10px 50px rgba(0,0,0,.6);\n\t\t     -moz-box-shadow: inset 0 10px 50px rgba(0,0,0,.6);\n\t\t/*          box-shadow: inset 0 10px 30px rgba(0,0,0,.3);*/\n\t  }\n\n      input, textarea, select, .uneditable-input {\n\t       width: 165px;\n\t   }\n\n\t  .scrollingmenu {\n\t\t  width: 940px;\n\t\t  margin-left: auto;\n\t\t  margin-right: auto;\n\t\t  height: 70px;\n\t\t  zoom: 1;\n\t}\n\t.scrollingmenu h1 {\n      padding-bottom: 30px;\n\t  color: #ffffff;\n\t  font-size: 42px;\n\t  line-height: 1;\n\t  text-shadow: 0 1px 2px rgba(0,0,0,.5);\n\t}\n    .container {\n\t   min-height: 100%;\n    }\n    .bottom {\n\t   min-height: 100%;\n\t   background-color: #ffffff;\n\t   padding-top: 20px;\n\t   border-top: 1px solid #8e397d;\n\t}\n\t.bottom h1,h2,h3 {\n\t\ttext-shadow: 0 1px 2px rgba(255,255,255,.5);\n\t}\n\t.bottom h1,h2,h3 a {\n                color: #404040;\n\t\ttext-shadow: 0 1px 2px rgba(255,255,255,.5);\n\t}\n\n\t.bottom small {\n                color: #808080;\n\t\ttext-shadow: 0 1px 1px rgba(255,255,255,.5);\n\t}\n\n\t.bottom p.under {\n                color: #808080;\n\t\ttext-shadow: 0 1px 1px rgba(255,255,255,.5);\n\t\tfont-size: 18px;\n\t\tline-height: 36px;\n\t\tmargin-top: -25px;\n\t}\n\n        .bottom ul.thanks {\n                margin: 10px 0 4px 25px;\n                list-style: square;\n        }\n\n        .bottom ul.thanks li {\n                color: #404040;\n                font-size: 16px;\n                line-height: 22px;\n                margin: 0px;\n         }\n\n        .page-header-index{margin-bottom:17px;border-bottom:1px solid #808080;-webkit-box-shadow:0 1px 0 rgba(255, 255, 255, 0.5);-moz-box-shadow:0 1px 0 rgba(255, 255, 255, 0.5);box-shadow:0 1px 0 rgba(255, 255, 255, 0.5);}\n\n       p.contents {\n           font-weight: bold;\n           font-size: 16px;\n       }\n\n       div#toc ul {\n           list-style: none;\n       }\n\n       div#toc ul a {\n           display: block;\n           list-style: none;\n           line-height: 22px;\n           font-weight: bold;\n           width: 100%;\n       }\n\n      div#toc ul li ul {\n           list-style: disc;\n      }\n\n      div#toc ul li ul a {\n           line-height: 18px;\n           font-weight: normal;\n      }\n\n      div#toc ul li ul li ul {\n           list-style: square;\n      }\n       div#toc ul li ul li ul a {\n       }\n\n       div#scroller-anchor {\n           width: inherit;\n       }\n\n       div#scroller {\n           width: inherit;\n       }\n\n       p#about {\n      \t margin-top: -8px;\n         padding-left: 14px;\n       }\n\n       ul {\n\t     margin-left: 15px;\n       }\n```\n\n----------------------------------------\n\nTITLE: Incorrectly Using Single Parameter List Method in Scala (Type Inference)\nDESCRIPTION: Illustrates an attempt to call the `foldLeft1` method (defined without multiple parameter lists) using a placeholder syntax for the function argument (`_ + _`). This fails compilation because Scala cannot infer the types of the function's arguments (`A` and `B`) at the point where the function is defined.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/multiple-parameter-lists.md#_snippet_3\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\ndef notPossible = foldLeft1(numbers, 0, _ + _)\n```\n\n----------------------------------------\n\nTITLE: Matching Identifier Quasiquotes (Backquoted Difference) - Scala\nDESCRIPTION: Demonstrates that backquoted and non-backquoted identifiers, while potentially referring to the same entity, are syntactically distinct in pattern matching. Matching `q\"`Foo`\"` against `q\"Foo\"` results in a `MatchError`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"`Foo`\" = q\"Foo\"\nscala.MatchError: Foo (of class scala.reflect.internal.Trees$Ident)\n  ... 32 elided\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Singleton Object in Scala\nDESCRIPTION: Illustrates the fundamental syntax for defining a singleton object named 'Box' in Scala using the 'object' keyword. Singleton objects are lazily instantiated upon first reference.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/singleton-objects.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject Box\n```\n\n----------------------------------------\n\nTITLE: Class Definition and Instance Usage in Python and Scala\nDESCRIPTION: Provides examples of defining classes with constructors and methods, creating instances, and modifying object attributes in Python and Scala. Demonstrates idiomatic class syntax and method definitions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nclass Person(object):\n  def __init__(self, name):\n    self.name = name\n\n  def speak(self):\n    print(f'Hello, my name is {self.name}')\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass Person (var name: String):\n  def speak() = println(s\"Hello, my name is $name\")\n\nval p = new Person(\"John\")\np.name  // John\np.name = \"Fred\"\np.name  // Fred\np.speak()\n```\n\n----------------------------------------\n\nTITLE: Using a Single-Line if Statement in Scala\nDESCRIPTION: In Scala 3, a single-line `if` statement can use the `then` keyword without curly braces. The condition does not require parentheses.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_31\n\nLANGUAGE: Scala\nCODE:\n```\nif x == 1 then println(x)\n```\n\n----------------------------------------\n\nTITLE: Workaround Using Named Given Instances Wrapping Extension Methods in Scala\nDESCRIPTION: This snippet provides a workaround for the extension method ambiguity by defining extensions inside `given` instances with empty refinements. This technique isolates extension methods inside named `given` objects (`pathExtensions` and `uriExtensions`), preventing implicit scope pollution and enabling simultaneous use of methods named `/` for different types. The workaround requires naming the `given`s differently and Scala 3 compiler support. The input is an instance of `Path` or `URI` and a child string; the output is a resolved `Path` or `URI` accordingly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/multi-source-extension-overloads.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nobject PathExtensions:\n  given pathExtensions: {} with\n    extension (path: Path)\n      def /(child: String): Path = path.resolve(child).nn\n\nobject URIExtensions:\n  given uriExtensions: {} with\n    extension (uri: URI)\n      def /(child: String): URI = uri.resolve(child)\n```\n\n----------------------------------------\n\nTITLE: Variable Definition for Union Type Inference Example\nDESCRIPTION: Defines two simple variables, `name` of type `Username` and `password` of type `Password`. These variables are used in the subsequent example demonstrating type inference with union types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-union.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval name = Username(\"Eve\")     // name: Username = Username(Eve)\nval password = Password(123)   // password: Password = Password(123)\n```\n\n----------------------------------------\n\nTITLE: Configuring Scaladoc Versioning with JSON URL in SBT\nDESCRIPTION: This snippet illustrates how to specify the URL of the JSON file containing version information in an sbt build configuration for Scaladoc. It verifies setting the '-versions-dictionary-url' option to enable dynamic version linking across multiple documentation versions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/site-versioning.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndoc / scalacOptions ++= Seq(\"-versions-dictionary-url\", \"https://dotty.epfl.ch/versions.json\")\n```\n\n----------------------------------------\n\nTITLE: Пример создания и модификации ArraySeq в Scala\nDESCRIPTION: Объяснение использования ArraySeq для произвольного доступа к элементам за постоянное время, а также создание новых коллекций через операции `updated`, `appended` и `prepended`. Показывается, что ArraySeq является неизменяемым типом коллекции, реализованным на базе массива.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/concrete-immutable-collection-classes.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val arr = scala.collection.immutable.ArraySeq(1, 2, 3)\narr: scala.collection.immutable.ArraySeq[Int] = ArraySeq(1, 2, 3)\nscala> val arr2 = arr :+ 4\narr2: scala.collection.immutable.ArraySeq[Int] = ArraySeq(1, 2, 3, 4)\nscala> arr2(0)\nres22: Int = 1\nscala> arr.updated(2, 4)\nres26: scala.collection.immutable.ArraySeq[Int] = ArraySeq(1, 2, 4)\nscala> arr\nres27: scala.collection.immutable.ArraySeq[Int] = ArraySeq(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Using foldLeft to Sum Elements in Scala List\nDESCRIPTION: This code snippet creates a Scala list of integers and uses foldLeft to compute the sum by applying a binary addition operation. The initial value for accumulation is 0, and the operation combines the rolling sum with each element. No external dependencies are required. Input is a list of integers; output is printed as the total sum. Demonstrates idiomatic use of curried foldLeft.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/multiple-parameter-lists.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nval res = numbers.foldLeft(0)((m, n) => m + n)\nprint(res) // 55\n```\n\n----------------------------------------\n\nTITLE: Inspecting Mill Project Classpath in Shell\nDESCRIPTION: This shell command snippet illustrates how to retrieve and display the runtime classpath for a Mill project. It runs the 'mill show proj.runClasspath' command, which outputs all resolved dependency JARs for the defined project. Dependencies must be properly declared in build.sc, and Mill must be installed; outputs are paths to JAR files used during execution. No input parameters besides the project definition are required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/drop-stdlib-forwards-bin-compat.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n$> mill show proj.runClasspath\n[\n  \"qref:868554b6:/Users/luc/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/softwaremill/sttp/client3/core_2.13/3.8.3/core_2.13-3.8.3.jar\",\n  \"qref:f3ba6af6:/Users/luc/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/softwaremill/sttp/shared/ws_2.13/1.3.10/ws_2.13-1.3.10.jar\",\n  \"qref:438104da:/Users/luc/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.8/scala-library-2.13.8.jar\",\n  \"qref:0c9ef1ab:/Users/luc/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/softwaremill/sttp/model/core_2.13/1.5.2/core_2.13-1.5.2.jar\",\n  \"qref:9b3d3f7d:/Users/luc/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/softwaremill/sttp/shared/core_2.13/1.3.10/core_2.13-1.3.10.jar\"\n]\n```\n\n----------------------------------------\n\nTITLE: Using @unchecked to Silence Warnings in Scala 3\nDESCRIPTION: Shows how the @unchecked annotation in Scala 3 silences both exhaustivity and type test warnings in pattern matching expressions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/replace-nonsensical-unchecked-annotation.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\n(xs: @unchecked) match {\n  case is: ::[Int] => is.head\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Splitter trait in Scala parallel collections\nDESCRIPTION: The Splitter trait extends Iterator and adds a split method that divides a collection into non-overlapping partitions. Splitters allow parallel collections to be divided into smaller parts until they're small enough to process sequentially.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/parallel-collections/architecture.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Splitter[T] extends Iterator[T] {\n    def split: Seq[Splitter[T]]\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying sbt Version in build.properties - Text\nDESCRIPTION: A minimal build.properties file for specifying the sbt version (here, 1.10.11) in the Scala project's project/ folder. Required for sbt to launch the build with a consistent version across environments. Input: the desired sbt version; Output: sbt uses this version when managing the project.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_18\n\nLANGUAGE: Text\nCODE:\n```\nsbt.version=1.10.11\n\n```\n\n----------------------------------------\n\nTITLE: Auxiliary Constructors in Java Class\nDESCRIPTION: Shows a Java class Person with a primary constructor and multiple overloaded constructors providing zero-, one-, and two-argument initialization options. Uses constructor chaining via this() calls to simplify field initialization. Illustrates Java's approach to supporting multiple constructor signatures within a class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\npublic class Person {\n  public String firstName;\n  public String lastName;\n  public int age;\n\n  // primary constructor\n  public Person(\n    String firstName,\n    String lastName,\n    int age\n  ) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.age = age;\n  }\n\n  // zero-arg constructor\n  public Person() {\n    this(\"\", \"\", 0);\n  }\n\n  // one-arg constructor\n  public Person(String firstName) {\n    this(firstName, \"\", 0);\n  }\n\n  // two-arg constructor\n  public Person(\n    String firstName, \n    String lastName\n  ) {\n    this(firstName, lastName, 0);\n  }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Illustration of contravariance with Printer hierarchy\nDESCRIPTION: This snippet depicts contravariant type parameters in a Printer hierarchy, illustrating how Printer[Animal] can be substituted where Printer[Cat] is expected. It highlights the flexibility contravariance provides when dealing with type hierarchies and functionality like printing or processing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/variances.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Printer[-A] {\n  def print(value: A): Unit\n}\n\nclass AnimalPrinter extends Printer[Animal] {\n  def print(animal: Animal): Unit =\n    println(\"The animal's name is: \" + animal.name)\n}\n\nclass CatPrinter extends Printer[Cat] {\n  def print(cat: Cat): Unit =\n    println(\"The cat's name is: \" + cat.name)\n}\n\nobject ContravarianceTest extends App {\n  val myCat: Cat = Cat(\"Boots\")\n\n  def printMyCat(printer: Printer[Cat]): Unit = {\n    printer.print(myCat)\n  }\n\n  val catPrinter: Printer[Cat] = new CatPrinter\n  val animalPrinter: Printer[Animal] = new AnimalPrinter\n\n  printMyCat(catPrinter)\n  printMyCat(animalPrinter)\n}\n// Output:\n// The cat's name is: Boots\n// The animal's name is: Boots\n```\n\n----------------------------------------\n\nTITLE: Using Parameterized greet Method to Create Multiple Greeting Functions in Scala\nDESCRIPTION: Shows creating multiple greeting functions by passing different greeting strings to the parameterized `greet` method. Returned functions are assigned to variables such as `sayHello`, `sayCiao`, and `sayHola`. Each function takes a name string and prints the corresponding greeting. Demonstrates how passing different parameters customizes the behavior of returned functions, enabling reuse and modularity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-write-method-returns-function.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval sayHello = greet(\"Hello\")\nsayHello(\"Joe\")   // prints \"Hello, Joe\"\n\nval sayCiao = greet(\"Ciao\")\nval sayHola = greet(\"Hola\")\n\nsayCiao(\"Isabella\")   // prints \"Ciao, Isabella\"\nsayHola(\"Carlos\")     // prints \"Hola, Carlos\"\n```\n\n----------------------------------------\n\nTITLE: Computed Field Names via Selectable Trait with NamedTuple Fields in Scala 3\nDESCRIPTION: Defines how classes implementing the Selectable trait can expose statically known field names as a named tuple type alias `Fields`. Field selections on instances of such classes are expanded to calls to selectDynamic with string literals, which must conform to the declared field types. This enables dynamic selection with static type safety for computed fields, facilitating flexible APIs such as query representations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-tuples.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ntrait Selectable:\n  type Fields <: NamedTuple.AnyNamedTuple\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait Q[T] extends Selectable:\n  type Fields = NamedTuple.Map[NamedTuple.From[T], Q]\n  def selectDynamic(fieldName: String) = ...\n```\n\nLANGUAGE: scala\nCODE:\n```\ncase class City(zipCode: Int, name: String, population: Int)\nval city: Q[City]\n\ncity.zipCode // expands to city.selectDynamic(\"zipCode\").asInstanceOf[Q[Int]]\n```\n\n----------------------------------------\n\nTITLE: Creating an anonymous subclass of an abstract class with concrete type in Scala\nDESCRIPTION: This snippet defines an abstract class 'IntSeqBuffer' extending 'SeqBuffer' with a concrete 'U' as 'Int'. It then shows a factory method 'newIntSeqBuf' that creates an anonymous subclass instance, specifying 'T' as 'List[U]' and initializing 'element' with a list of integers. It demonstrates instantiating and using buffer objects with concrete types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/abstract-type-members.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class IntSeqBuffer extends SeqBuffer {\n  type U = Int\n}\n\n\ndef newIntSeqBuf(elem1: Int, elem2: Int): IntSeqBuffer =\n  new IntSeqBuffer {\n       type T = List[U]\n       val element = List(elem1, elem2)\n     }\nval buf = newIntSeqBuf(7, 8)\nprintln(\"length = \" + buf.length)\nprintln(\"content = \" + buf.element)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Map Method Overloads on Scala Map\nDESCRIPTION: Shows the two `map` method signatures available on the `Map` type: one inherited from `MapOps` that returns a `Map[K2, V2]` if the function returns a pair, and one inherited from `IterableOps` that returns an `Iterable[B]` otherwise. The Scala compiler uses overloading resolution rules based on the function type to select the appropriate `map` implementation, adhering to the \"same-result-type\" principle when possible.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_10\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\n// from MapOps\ndef map[K2, V2](f: ((K, V)) => (K2, V2)): Map[K2, V2]\n\n// from IterableOps\ndef map[B](f: ((K, V)) => B): Iterable[B]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Tree Evaluation and Differentiation in Scala\nDESCRIPTION: Provides a `main` method that constructs an example expression tree, defines an environment using a partial function literal, evaluates the expression, computes its derivatives with respect to 'x' and 'y', and prints the results. Shows practical usage of the `eval` and `derive` functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tutorials/scala-for-java-programmers.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\ndef main(args: Array[String]): Unit = {\n  val exp: Tree = Sum(Sum(Var(\"x\"),Var(\"x\")),Sum(Const(7),Var(\"y\")))\n  val env: Environment = { case \"x\" => 5 case \"y\" => 7 }\n  println(\"Expression: \" + exp)\n  println(\"Evaluation with x=5, y=7: \" + eval(exp, env))\n  println(\"Derivative relative to x:\\n \" + derive(exp, \"x\"))\n  println(\"Derivative relative to y:\\n \" + derive(exp, \"y\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Location Macro in Scala 3 with Quotes\nDESCRIPTION: Implements a metaprogramming-enabled 'location' macro for Scala 3 using the new quotes API. The macro provides the file path and line number at macro expansion, matching the contract of the Scala 2 macro. Dependencies: 'scala.quoted'. Inputs: none; Outputs: Location instance with reflective source info. Usage requires Scala 3.3+ and proper source layout.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-macro-cross-building.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n// example/src/main/scala-3/location/Macros.scala\npackage location\n\nimport scala.quoted.{Quotes, Expr}\n\nobject Macros:\n  inline def location: Location = ${locationImpl}\n\n  private def locationImpl(using quotes: Quotes): Expr[Location] =\n    import quotes.reflect.Position\n    val pos = Position.ofMacroExpansion\n    val file = Expr(pos.sourceFile.path.toString)\n    val line = Expr(pos.startLine + 1)\n    '{new Location($file, $line)}\n```\n\n----------------------------------------\n\nTITLE: Creating a Hygienic Tree with reify for Function Application in Scala Reflection\nDESCRIPTION: This snippet illustrates building a hygienic tree for println(2) using reify, and then displaying its raw representation via showRaw. The reify method captures the expression's AST, ensuring identifier bindings are preserved irrespective of context. Prerequisites: import scala.reflect.runtime.universe._; inputs: an expression (here, println(2)); outputs: a Tree suitable for safe macro and runtime metaprogramming.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\n{ val tree = reify(println(2)).tree; showRaw(tree) }\n```\n\n----------------------------------------\n\nTITLE: Importing Implicit Enrichments for Additional Scala Collection Operations - Scala\nDESCRIPTION: The snippet shows the import statement required to bring additional collection operations into scope via implicit enrichment. By importing strawman.collection.decorators._, developers gain access to extra methods such as intersperse for Seq, and various join and merge operations for Map. These methods are provided through an incubator module scala-collection-contrib and may eventually be integrated into the core library upon validation through usage.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/collections-migration-213.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport strawman.collection.decorators._\n```\n\n----------------------------------------\n\nTITLE: scalafmt Code Formatting Check Step in CI - YAML\nDESCRIPTION: Adds a step in a GitHub Actions workflow to check Scala code formatting using 'sbt scalafmtCheck'. Requires the 'sbt-scalafmt' plugin configured. This workflow step ensures code is properly formatted before CI passes. Input: project source code; Output: pass/fail on code style. Limit: Only works for sbt projects using sbt-scalafmt.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_22\n\nLANGUAGE: yaml\nCODE:\n```\n# .github/workflows/ci.yml\n# The three periods `...` indicate the parts of file that do not change\n# from the snippets above and they are omitted for brevity\njobs:\n  ci:\n    # ...\n    steps:\n      # ...\n      - name: Code style\n        run: sbt scalafmtCheck\n```\n\n----------------------------------------\n\nTITLE: Original Scala 2 Style Control Structures - Scala\nDESCRIPTION: This Scala snippet shows a typical Scala 2 style source code example illustrating control structures using parentheses and braces. It defines a `State` case class with methods `inc` and `printAll` that use classic `if` expressions with parentheses for conditions and `for` comprehensions enclosed in braces. This code acts as the starting point for syntax rewriting demonstrations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tooling-syntax-rewriting.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class State(n: Int, minValue: Int, maxValue: Int) {\n  \n  def inc: State =\n    if (n == maxValue)\n      this\n    else\n      this.copy(n = n + 1)\n  \n  def printAll: Unit = {\n    println(\"Printing all\")\n    for {\n      i <- minValue to maxValue\n      j <- 0 to n\n    } println(i + j)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Google Analytics Tracking (JavaScript)\nDESCRIPTION: Initializes Google Analytics tracking for the page. It pushes commands to the `_gaq` queue to set the account ID ('UA-574683-5') and track the current page view. It then asynchronously creates and appends a script element to load the Google Analytics tracking code (ga.js) from the appropriate protocol (HTTPS or HTTP).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/cheatsheet-header.txt#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nvar _gaq = _gaq || [];\n_gaq.push(['_setAccount', 'UA-574683-5']);\n_gaq.push(['_trackPageview']);\n\n(function() {\n  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;\n  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';\n  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);\n})();\n```\n\n----------------------------------------\n\nTITLE: Implementing ParString Class with Parallel Collection Traits in Scala\nDESCRIPTION: This Scala class defines the ParString parallel collection by extending immutable.ParSeq and mixing in essential traits like GenericParTemplate and ParSeqLike to enable parallel operations on character sequences. It declares the companion method to link with its companion object, ensuring implicit evidence availability. The class acts as a foundation for ParString instances compatible with Scala's parallel collections, supporting typical sequence transformations with parallel execution semantics.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/overviews/parallel-collections/custom-parallel-collections.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass ParString(val str: String)\nextends immutable.ParSeq[Char]\n   with GenericParTemplate[Char, ParString]\n   with ParSeqLike[Char, ParString, collection.immutable.WrappedString] {\n\n  def companion = ParString\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lower Type Bound Usage with Bird Subtypes in Scala\nDESCRIPTION: This snippet shows practical usage of the lower bound prepend method by defining a trait Bird and two case classes AfricanSwallow and EuropeanSwallow extending Bird. It demonstrates assigning a ListNode of AfricanSwallow to a Node of Bird, then invoking prepend with a EuropeanSwallow instance. This example validates that the corrected prepend method with lower type bounds allows flexible and type-safe insertion of supertype elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/lower-type-bounds.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait Bird\ncase class AfricanSwallow() extends Bird\ncase class EuropeanSwallow() extends Bird\n\n\nval africanSwallowList= ListNode[AfricanSwallow](AfricanSwallow(), Nil())\nval birdList: Node[Bird] = africanSwallowList\nbirdList.prepend(EuropeanSwallow())\n```\n\n----------------------------------------\n\nTITLE: Implementing `map` Logic using a `for` Expression in Scala\nDESCRIPTION: Shows the implementation of the `map` method's body using a `for` expression (also known as a for-comprehension). It iterates through each element `x` in the input list `xs`, applies the provided function `f` to `x`, and yields the result. The `yield` keyword collects these results into a new list, which becomes the return value of the `map` method. Includes versions for both Scala 2 and Scala 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-write-map-function.md#_snippet_4\n\nLANGUAGE: Scala 2\nCODE:\n```\nfor (x <- xs) yield f(x)\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nfor x <- xs yield f(x)\n```\n\n----------------------------------------\n\nTITLE: Creating and copying immutable FP style records in Python and Scala\nDESCRIPTION: Demonstrates creating immutable instances and updating fields using Python's replace function and Scala's copy method. Dependencies are same as previous snippet. Inputs are initial values and updated fields; outputs are new instances with updated values preserving immutability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\np = Person(\"Alice\", 42)\np.name  # Alice\np2 = replace(p, age=43)\n```\n\n----------------------------------------\n\nTITLE: Specifying the Return Type for the `map` Method in Scala\nDESCRIPTION: Completes the `map` method signature by specifying its return type as `List[A]`. This indicates that the method will return a new list containing elements of type `A`, which are the results of applying the function `f` to the input list `xs`. The method body is temporarily represented by `???`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-write-map-function.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef map[A](f: (Int) => A, xs: List[Int]): List[A] = ???\n```\n\n----------------------------------------\n\nTITLE: Example Directory Structure with Site Root\nDESCRIPTION: Shows the directory structure with a specific 'docs' folder set as the site root for Scaladoc documentation generation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/static-site.md#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n.\n└── docs/\n    └── _docs/\n        ├── index.html\n        └── getting-started.html\n```\n\n----------------------------------------\n\nTITLE: Defining a Map in Scala\nDESCRIPTION: Shows how to define an immutable Map in Scala, associating keys (state abbreviations) with values (full state names). This syntax is common to both Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_14\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\nval states = Map(\n  \"AK\" -> \"Alaska\",\n  \"AL\" -> \"Alabama\", \n  \"AR\" -> \"Arizona\"\n)\n```\n\n----------------------------------------\n\nTITLE: Combining Extension Methods, Context Functions, and Dependent Types in Scala 3\nDESCRIPTION: Shows an advanced pattern combining multiple Scala 3 features to create a DSL for numerical expressions with improved ergonomics and syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-dependent-function.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ntrait NumsDSL extends Nums:\n  extension (x: Num)\n    def +(y: Num) = add(x, y)\n    def *(y: Num) = mul(x, y)\n\ndef const(d: Double)(using n: Nums): n.Num = n.lit(d)\n\ntype Prog = (n: NumsDSL) ?=> n.Num => n.Num\n//                       ^^^\n//     prog is now a context function that implicitly\n//     assumes a NumsDSL in the calling context\n\ndef derivative(input: Prog): Double = ...\n\n// notice how we do not need to mention Nums in the examples below?\nderivative { x => const(1.0) + x }\nderivative { x => x * x + const(2.0) }\n// ...\n```\n\n----------------------------------------\n\nTITLE: Compiler-Generated Static main Method Equivalent for @main in Scala 3\nDESCRIPTION: Presents the conceptual Scala code generated by the compiler for an @main method named happyBirthday. The compiler creates a final class with a static main method accepting Java-style command-line arguments (Array[String]). Inside main, it parses arguments into typed parameters using scala.util.CommandLineParser methods, then calls the original method. It also includes error handling for parsing failures. Note that the represented <static> modifier is conceptual; Scala generates such static members differently as object methods. This snippet explains the underlying transformation and runtime behavior of @main methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/methods-main-methods.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nfinal class happyBirthday {\n  import scala.util.{CommandLineParser as CLP}\n  <static> def main(args: Array[String]): Unit =\n    try\n      happyBirthday(\n          CLP.parseArgument[Int](args, 0),\n          CLP.parseArgument[String](args, 1),\n          CLP.parseRemainingArguments[String](args, 2)*)\n    catch {\n      case error: CLP.ParseError => CLP.showError(error)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using @publicInBinary to expose private and protected definitions in bytecode (Scala)\nDESCRIPTION: This snippet shows how to annotate private and protected members with @publicInBinary to make them publicly available in the generated bytecode while maintaining their restricted visibility in source code. It includes three definitions demonstrating package-private, protected, and public usage, with compiler warnings when @publicInBinary is applied to already public members.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/binary-api.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass C {\n  @publicInBinary private[C] def packagePrivateAPI: Int = ...\n  @publicInBinary protected def protectedAPI: Int = ...\n  @publicInBinary def publicAPI: Int = ... // warn: `@publicInBinary` has no effect on public definitions\n}\n```\n\n----------------------------------------\n\nTITLE: List comprehension filtering with 'for' in Scala\nDESCRIPTION: Generates a list of the lengths of strings that are longer than 4 characters, using 'for' with a filter guard.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nval fruits = List(\"apple\", \"banana\", \"lime\", \"orange\")\n\nval fruitLengths =\n  for (f <- fruits if f.length > 4) yield f.length\n// fruitLengths: List[Int] = List(5, 6, 6)\n```\n\n----------------------------------------\n\nTITLE: Attempting to Lift Null Value (Error) - Scala\nDESCRIPTION: Demonstrates that lifting a `null` value directly into a quasiquote using `$` is not supported and results in a compilation error. To create a `null` literal tree, the explicit quasiquote `q\"null\"` must be used.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val x = null\nx: Null = null\nscala> q\"$x\"\n<console>:31: error: Can't unquote Null, bottom type values often indicate programmer mistake\n                  q\"$x\"\n                     ^\n```\n\n----------------------------------------\n\nTITLE: Incorrect Type Behavior of `map` and `++` on RNA2 in Scala REPL\nDESCRIPTION: Shows the actual, incorrect behavior of the `map` and `++` methods when applied to the intermediate `RNA2` class in the Scala REPL. Even when the resulting elements are of type `Base`, these methods return `IndexedSeq[Base]` (specifically, `Vector` instances) instead of `RNA2`. This occurs because `RNA2` lacks the necessary `CanBuildFrom` implicit instance to construct `RNA2` results for these operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-collections.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val rna2 = RNA2(A, U, G, G, C)\nrna2: RNA2 = RNA2(A, U, G, G, C)\n\nscala> rna2 map { case A => U case b => b }\nres0: IndexedSeq[Base] = Vector(U, U, G, G, C)\n\nscala> rna2 ++ rna2\nres1: IndexedSeq[Base] = Vector(A, U, G, G, C, A, U, G, G, C)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating strictEquality Compilation Error in Scala 3 REPL\nDESCRIPTION: Shows how the strictEquality language feature in Scala 3 prevents comparing values of the same type (Some[Int]) when enabled, displaying the compilation error that occurs. This demonstrates the strictness of equality checking in Dotty's implementation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/minutes/2020-03-13-sip-minutes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n$ dotr -language:strictEquality\nStarting dotty REPL...\nscala> Some(1) == Some(2)\n1 |Some(1) == Some(2)\n  |^^^^^^^^^^^^^^^^^^\n  |Values of types Some[Int] and Some[Int] cannot be compared with == or !=\n```\n\n----------------------------------------\n\nTITLE: Equivalent flatMap and withFilter Composition for Future in Scala\nDESCRIPTION: This snippet shows the desugared form of the previous for-comprehension using explicit flatMap and withFilter combinators. It maps usdQuote using flatMap on usd, then filters chfQuote with the profitability predicate via withFilter, followed by mapping to the buy operation. This provides a more verbose yet explicit view of Future composition, useful for understanding the mechanics behind for-comprehensions and Future monadic chaining.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/futures.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nval purchase = usdQuote flatMap {\n  usd =>\n  chfQuote\n    .withFilter(chf => isProfitable(usd, chf))\n    .map(chf => connection.buy(amount, chf))\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Current Precedence Issues with Singleton-ops Type-Level Operations\nDESCRIPTION: This code snippet demonstrates how the current infix type precedence rules cause unintuitive behavior with the singleton-ops library, where mathematical operations don't follow expected precedence rules at the type level.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/priority-based-infix-type-precedence.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval works : 1 + (2 * 3) + 4 = 11\nval fails : 1 + 2 * 3 + 4 = 11 //left associative:(((1+2)*3)+4))) = 13\n```\n\n----------------------------------------\n\nTITLE: Typing Rule for Dynamic Member Access (Scala Typing Rule Pseudocode)\nDESCRIPTION: This snippet depicts a formal specification for accessing a member a of an expression v whose type Q is a subtype of Dynamic. The rule checks the member and establishes a subtype constraint. Such rules are used in the compiler's type checker to drive desugaring and code generation for reflective calls. There are no runtime dependencies, but downstream code may assume a Dynamic base class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/minutes/2019-03-13-sip-minutes.md#_snippet_5\n\nLANGUAGE: scala (typing rules pseudocode)\nCODE:\n```\nG |- v ~> v': Q  - Member(Q, a, U)    G |- Q <: Dynamic\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Named Tuples in Scala 3\nDESCRIPTION: Defines a named tuple type Person and demonstrates creation of instances with named fields and pattern matching on named tuples. Named tuple elements are specified using the syntax 'name: Type' for types and 'name = value' for values. Pattern matching supports both named and unnamed patterns. Elements can be accessed by name, improving readability over positional tuples. Dependencies include Scala 3 compiler with SIP-58 support.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-tuples.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype Person = (name: String, age: Int)\nval Bob: Person = (name = \"Bob\", age = 33)\n\nBob match\n  case (name = n, age = 22) => ...\n```\n\n----------------------------------------\n\nTITLE: Implementing a Generic Standalone `map` Method in Scala\nDESCRIPTION: Generalizes the previously defined `map` method to work with lists of any type. It introduces a second type parameter `B` for the input list elements, replacing the specific `Int` type. The method now accepts a function `f` that transforms type `B` to type `A` and a `List[B]`, returning a `List[A]`. This makes the `map` function universally applicable to any list type. Includes versions for both Scala 2 and Scala 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-write-map-function.md#_snippet_6\n\nLANGUAGE: Scala 2\nCODE:\n```\ndef map[A, B](f: (B) => A, xs: List[B]): List[A] =\n  for (x <- xs) yield f(x)\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ndef map[A, B](f: (B) => A, xs: List[B]): List[A] =\n  for x <- xs yield f(x)\n```\n\n----------------------------------------\n\nTITLE: Using match expressions for conditional logic in Python 3.10+\nDESCRIPTION: Demonstrates Python's structural pattern matching introduced in version 3.10, using the match statement to perform multi-way branching on a variable. Shows basic usage to match integer values representing months and assign a string accordingly. Requires Python 3.10 or later for support. The underscore (_) acts as the default case matching any other value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_45\n\nLANGUAGE: python\nCODE:\n```\nmatch month:\n    case 1:\n        monthAsString = \"January\"\n    case 2:\n        monthAsString = \"February\"\n    case _:\n        monthAsString = \"Other\"\n```\n\n----------------------------------------\n\nTITLE: Using Pizza Functional Methods with Fluent API in Scala 2 and 3\nDESCRIPTION: Demonstrates usage of the Pizza case class and its methods to build a pizza instance, add toppings, update crust type, and then calculate the price fluently. This snippet is compatible with both Scala 2 and Scala 3, showing invocation of methods directly on the Pizza instance to create a transformed pizza and retrieve its price as a Double output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-fp.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nPizza(Small, Thin, Seq(Cheese))\n  .addTopping(Pepperoni)\n  .updateCrustType(Thick)\n  .price\n```\n\n----------------------------------------\n\nTITLE: Composición mixin de iteradores con impresión en Scala\nDESCRIPTION: Demuestra la composición de mixin en Scala al definir en un método `main` la clase `Iter` que hereda de la clase `StringIterator` y mezcla el trait `RichIterator`. Se crea una instancia del iterador compuesto y se invoca el método `foreach` pasando `println` para imprimir cada carácter de la cadena. Muestra cómo combinar múltiples definiciones que contienen implementaciones para ampliar funcionalidad reutilizable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/mixin-class-composition.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nobject StringIteratorTest {\n  def main(args: Array[String]): Unit = {\n    class Iter extends StringIterator(\"Scala\") with RichIterator\n    val iter = new Iter\n    iter foreach println\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the companion object for the final RNA class in Scala\nDESCRIPTION: The companion object for the final RNA implementation that provides factory methods and the crucial implicit CanBuildFrom to ensure that collection operations like map return RNA instances when appropriate.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/architecture-of-scala-collections.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nobject RNA {\n\n  private val S = 2 // group中的比特（bit）数\n  private val M = (1 << S) - 1 // 用于隔离group的比特掩码\n  private val N = 32 / S // 一个Int中的group数\n\n  def fromSeq(buf: Seq[Base]): RNA = {\n    val groups = new Array[Int]((buf.length + N - 1) / N)\n    for (i <- 0 until buf.length)\n      groups(i / N) |= Base.toInt(buf(i)) << (i % N * S)\n    new RNA(groups, buf.length)\n  }\n\n  def apply(bases: Base*) = fromSeq(bases)\n\n  def newBuilder: Builder[Base, RNA] =\n    new ArrayBuffer mapResult fromSeq\n\n  implicit def canBuildFrom: CanBuildFrom[RNA, Base, RNA] =\n    new CanBuildFrom[RNA, Base, RNA] {\n      def apply(): Builder[Base, RNA] = newBuilder\n      def apply(from: RNA): Builder[Base, RNA] = newBuilder\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced Trait Design with Abstract Types and Self-Types in Scala\nDESCRIPTION: Presents an advanced example defining a `SubjectObserver` trait using abstract type members (`S`, `O`) with upper bounds, nested traits (`Subject`, `Observer`), and a self-type annotation (`self: S =>`) on the nested `Subject` trait. This demonstrates building complex, reusable component abstractions. Shows Scala 2 and 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-oop.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ntrait SubjectObserver {\n\n  type S <: Subject\n  type O <: Observer\n\n  trait Subject { self: S =>\n    private var observers: List[O] = List()\n    def subscribe(obs: O): Unit = {\n      observers = obs :: observers\n    }\n    def publish() = {\n      for ( obs <- observers ) obs.notify(this)\n    }\n  }\n\n  trait Observer {\n    def notify(sub: S): Unit\n  }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait SubjectObserver:\n\n  type S <: Subject\n  type O <: Observer\n\n  trait Subject:\n    self: S =>\n      private var observers: List[O] = List()\n      def subscribe(obs: O): Unit =\n        observers = obs :: observers\n      def publish() =\n        for obs <- observers do obs.notify(this)\n\n  trait Observer:\n    def notify(sub: S): Unit\n```\n\n----------------------------------------\n\nTITLE: Partitioning a Scala Collection Based on a Predicate\nDESCRIPTION: This Scala code snippet demonstrates partitioning a collection named `people` into two separate collections, `minors` and `adults`, based on a predicate (`_.age < 18`). The `partition` method, available on `TraversableLike`, divides elements based on whether they satisfy the given condition. The resulting collections (`minors` and `adults`) will have the same type as the original `people` collection. This approach is concise, type-safe, and potentially parallelizable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/introduction.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval (minors, adults) = people partition (_.age < 18)\n```\n\n----------------------------------------\n\nTITLE: Enumerations in Scala 2 and Scala 3\nDESCRIPTION: Defines enumerated types representing pizza attributes, such as crust size, crust type, and toppings. Uses 'sealed abstract class' and 'case object' in Scala 2, while Scala 3 introduces the more concise 'enum' construct. These enums facilitate pattern matching and value comparisons.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-modeling.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 2\nsealed abstract class CrustSize\nobject CrustSize {\n  case object Small extends CrustSize\n  case object Medium extends CrustSize\n  case object Large extends CrustSize\n}\n\nsealed abstract class CrustType\nobject CrustType {\n  case object Thin extends CrustType\n  case object Thick extends CrustType\n  case object Regular extends CrustType\n}\n\nsealed abstract class Topping\nobject Topping {\n  case object Cheese extends Topping\n  case object Pepperoni extends Topping\n  case object BlackOlives extends Topping\n  case object GreenOlives extends Topping\n  case object Onions extends Topping\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 3\nenum CrustSize:\n  case Small, Medium, Large\n\nenum CrustType:\n  case Thin, Thick, Regular\n\nenum Topping:\n  case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions\n```\n\n----------------------------------------\n\nTITLE: Formatting Method Invocation with Numerous Arguments - Scala\nDESCRIPTION: Shows the preferred approach for calling a Scala method with many arguments by placing each argument on its own line, indented by two spaces from the invocation. No special dependencies or libraries are needed. Expects a method call with several parameters; produces a function call expression. Facilitates maintainability by aligning all parameters regardless of method name changes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/indentation.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nfoo(\n  someVeryLongFieldName,\n  andAnotherVeryLongFieldName,\n  \"this is a string\",\n  3.1415)\n```\n\n----------------------------------------\n\nTITLE: Chaining Match Expressions in Scala 3\nDESCRIPTION: Illustrates Scala 3's ability to chain multiple match expressions without intermediate variables. The first match determines if an integer `i` is odd or even returning corresponding strings; the second match operates on that result, returning a boolean indicating if the string was \"even\". This uses type pattern matching with guards and is specific to Scala 3 syntax without braces.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_37\n\nLANGUAGE: scala\nCODE:\n```\ni match\n  case odd: Int if odd % 2 == 1 => \"odd\"\n  case even: Int if even % 2 == 0 => \"even\"\n  case _ => \"not an integer\"\nmatch\n  case \"even\" => true\n  case _ => false\n```\n\n----------------------------------------\n\nTITLE: Implementing a Covariant ListNode with a Lower Bound `prepend` Method in Scala\nDESCRIPTION: This code defines a covariant `ListNode` class with a `prepend` method that accepts an element of a supertype of `T`. The method returns a `ListNode` with a broader type `U`, ensuring type safety while allowing adding objects of supertype elements to the list. The implementation showcases how lower type bounds resolve covariance issues in Scala, supporting flexible and safe list operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/lower-type-bounds.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase class ListNode[+T](h: T, t: ListNode[T]) {\n  def head: T = h\n  def tail: ListNode[T] = t\n  def prepend[U >: T](elem: U): ListNode[U] =\n    ListNode(elem, this)\n}\n```\n\n----------------------------------------\n\nTITLE: Updating build.sbt with Migrated scalacOptions for Scala 2/3\nDESCRIPTION: Demonstrates how to update `build.sbt` to handle different `scalacOptions` for Scala 2 and Scala 3. It defines shared options and separate sequences for Scala 2 (`scala2Options`) and Scala 3 (`scala3Options`), conditionally applying them based on the `scalaVersion` setting.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/scala3-migrate.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nlazy val main = project\n  .in(file(\".\"))\n  .settings(\n    scalaVersion := \"2.13.11\",\n    scalacOptions ++= {\n      if (scalaVersion.value.startsWith(\"3.\")) scala3Options\n      else scala2Options\n    }\n  )\n\nlazy val sharedScalacOptions =\n  Seq(\"-encoding\", \"UTF-8\", \"-Wunused:imports,privates,locals\")\n\nlazy val scala2Options = sharedScalacOptions ++\n  Seq(\"-target:jvm-1.8\", \"-Xsource:3\", \"-explaintypes\")\n\nlazy val scala3Options = sharedScalacOptions ++\n  Seq(\"-Xunchecked-java-output-version:8\", \"-explain\")\n```\n\n----------------------------------------\n\nTITLE: Obtaining Builders and Factory Methods in IterableOps and IterableFactory - Scala 2\nDESCRIPTION: This snippet gives the structure for accessing collection factories and builders in IterableOps and IterableFactory in Scala 2. It shows how to obtain a factory (iterableFactory), construct a collection from an iterable (fromSpecific), and create new builders for both specific and general collection types. Builders provide facilities for strict collection construction and depend on the Builder trait.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_25\n\nLANGUAGE: Scala\nCODE:\n```\ntrait IterableOps[+A, +CC[_], +C] {\n  def iterableFactory: IterableFactory[CC]\n  protected def fromSpecific(coll: IterableOnce[A]): C\n  protected def newSpecificBuilder: Builder[A, C]\n}\n\ntrait IterableFactory[+CC[_]] {\n  def from[A](source: IterableOnce[A]): CC[A]\n  def newBuilder[A]: Builder[A, CC[A]]\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Case Class Parameters in Scala\nDESCRIPTION: This example defines a `Message` case class and demonstrates that its constructor parameters (`sender`, `recipient`, `body`) are automatically exposed as public immutable fields (`val`s). It shows accessing a field (`message1.sender`) and includes a commented-out line illustrating that attempting to reassign a `val` results in a compile-time error. This reinforces the use of case classes for immutable data structures.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/case-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class Message(sender: String, recipient: String, body: String)\nval message1 = Message(\"guillaume@quebec.ca\", \"jorge@catalonia.es\", \"Ça va ?\")\n\nprintln(message1.sender)  // prints guillaume@quebec.ca\nmessage1.sender = \"travis@washington.us\"  // this line does not compile\n```\n\n----------------------------------------\n\nTITLE: Defining PizzaServiceInterface Trait in Scala\nDESCRIPTION: This snippet defines a trait named PizzaServiceInterface that acts as a contract for pizza service behaviors such as pricing and modifying pizza toppings and crusts. It includes method signatures that take a Pizza instance as an input along with other parameters, and return an updated Pizza or a price (Double). The trait must be extended by any concrete implementation to provide the actual service logic. Scala 2 and Scala 3 variants differ in syntax but provide identical API.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-fp.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\ntrait PizzaServiceInterface {\n\n  def price(p: Pizza): Double\n\n  def addTopping(p: Pizza, t: Topping): Pizza\n  def removeAllToppings(p: Pizza): Pizza\n\n  def updateCrustSize(p: Pizza, cs: CrustSize): Pizza\n  def updateCrustType(p: Pizza, ct: CrustType): Pizza\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntrait PizzaServiceInterface:\n\n  def price(p: Pizza): Double\n\n  def addTopping(p: Pizza, t: Topping): Pizza\n  def removeAllToppings(p: Pizza): Pizza\n\n  def updateCrustSize(p: Pizza, cs: CrustSize): Pizza\n  def updateCrustType(p: Pizza, ct: CrustType): Pizza\n```\n\n----------------------------------------\n\nTITLE: Creating a Map in Scala\nDESCRIPTION: Shows creation of an immutable Scala Map named 'myMap' with string keys mapped to integer values. Uses '->' syntax to pair keys and values within the Map constructor.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nval myMap = Map(\n  \"a\" -> 1,\n  \"b\" -> 2,\n  \"c\" -> 3\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Enum Macro with Untyped Parameters in Scala\nDESCRIPTION: This snippet illustrates how to define the same Enum macro by using untyped parameters to bypass the compiler's typechecker on macro arguments. By replacing parameter types in the macro definition with underscores and using c.Tree instead of typed expressions in the implementation, the macro receives raw syntax trees that can represent code without prior typechecking, enabling greater flexibility such as introducing new bindings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/untypedmacros.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntype Enum(symbol: _*) = macro Macros.enum\nobject Macros {\n  def enum(c: Context)(symbol: c.Tree*): c.Tree = ...\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing HashMap Constructors with Overloads in Java\nDESCRIPTION: This snippet shows how Java uses overloaded constructors in the HashMap class to simulate default parameter values for initial capacity and load factor. It demonstrates multiple constructors ranging from a no-argument constructor to one that accepts both parameters. The approach requires defining multiple methods to provide default values and has a drawback of duplicating default value documentation and code. Intended inputs are Map, int initialCapacity, and float loadFactor parameters, with outputs being constructed HashMap instances. No runtime logic is shown here, only constructor declarations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/default-parameter-values.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\npublic class HashMap<K,V> {\n  public HashMap(Map<? extends K,? extends V> m);\n  /** Cria um novo HashMap com a capacidade padrão (16)\n    * and loadFactor (0.75)\n    */\n  public HashMap();\n  /** Cria um novo HashMap com um fator de carga padrão (0.75) */\n  public HashMap(int initialCapacity);\n  public HashMap(int initialCapacity, float loadFactor);\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Site Root Structure\nDESCRIPTION: Shows the full directory structure for a comprehensive Scaladoc site with layouts, documentation, blog, and assets.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/static-site.md#_snippet_13\n\nLANGUAGE: plaintext\nCODE:\n```\n.\n└── <site-root>/\n    ├── _layouts/\n    │   └── ...\n    ├── _docs/\n    │   └── ...\n    ├── _blog/\n    │   ├── index.md\n    │   └── _posts/\n    │       └── ...\n    └── _assets/\n        ├── js/\n        │   └── ...\n        ├── img/\n        │   └── ...\n        └── ...\n```\n\n----------------------------------------\n\nTITLE: Matching Ranges with If Guards in Scala 2\nDESCRIPTION: Shows how to use `if` guards with the `contains` method on integer ranges (`0 to 9`, `10 to 19`, etc.) within Scala 2 match expressions to efficiently match an input value against different numeric ranges.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\ni match {\n  case a if 0 to 9 contains a => println(s\"0-9 range: $a\")\n  case b if 10 to 19 contains b => println(s\"10-19 range: $b\")\n  case c if 20 to 29 contains c => println(s\"20-29 range: $c\")\n  case _ => println(\"Hmmm...\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using Dependent Methods with Type-Safe Returns\nDESCRIPTION: Shows how dependent method types enable type-safe database access, where the return type varies based on the key parameter passed to the get method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-dependent-function.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval db: DB = ...\nval res1: Option[String] = db.get(Name)\nval res2: Option[Int] = db.get(Age)\n```\n\n----------------------------------------\n\nTITLE: Implementando funções de ordem superior com classes em Scala\nDESCRIPTION: Exemplo completo com uma classe Decorator que implementa um método layout polimórfico, e um objeto FunTest que demonstra como métodos são automaticamente convertidos em funções.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/higher-order-functions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass Decorator(left: String, right: String) {\n  def layout[A](x: A) = left + x.toString() + right\n}\n\nobject FunTest extends App {\n  def apply(f: Int => String, v: Int) = f(v)\n  val decorator = new Decorator(\"[\", \"]\")\n  println(apply(decorator.layout, 7))\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping with list comprehensions in Python and for-comprehensions in Scala\nDESCRIPTION: Illustrates how to create a new collection by applying a transformation to each element. Python uses list comprehensions to multiply each element by 10. Scala uses for-comprehensions with yield to create a new list applying the same operation. Shows idiomatic functional style collection transformations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_63\n\nLANGUAGE: python\nCODE:\n```\nx = [i * 10 for i in numbers]\n```\n\nLANGUAGE: scala\nCODE:\n```\nval x = for i <- numbers yield i * 10\n```\n\n----------------------------------------\n\nTITLE: Including Source Code in Compile-time Error in Scala\nDESCRIPTION: This code demonstrates how to use `scala.compiletime.codeOf` in conjunction with `error` within an `inline` method's error message. It allows embedding the source code string of an `inline` parameter directly into the compile-time error, providing more context about the problematic argument at the call site.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/compiletime.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ninline def doSomething(inline mode: Boolean): Unit =\n  if mode then ...\n  else if !mode then ...\n  else error(\"Mode must be a known value but got: \" + codeOf(mode))\n\nval bool: Boolean = ...\ndoSomething(bool) // error: Mode must be a known value but got: bool\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Custom Parallel String Collection (Scala)\nDESCRIPTION: Defines a custom parallel string collection `ParString` by extending `immutable.ParSeq[Char]`. It implements essential methods like `apply` and `length`, specifies its sequential counterpart (`seq`), and declares the need for a `splitter`. This version lacks a custom combiner, meaning transformer methods will default to returning standard collection types like `ParVector`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/custom-parallel-collections.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass ParString(val str: String)\nextends immutable.ParSeq[Char] {\n\n  def apply(i: Int) = str.charAt(i)\n\n  def length = str.length\n\n  def seq = new collection.immutable.WrappedString(str)\n\n  // Splitter definition needed here (see next snippet)\n  def splitter = new ParStringSplitter(str, 0, str.length)\n\n  // ... splitter class definition follows ...\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit Type Declaration Examples in Scala\nDESCRIPTION: Shows how to explicitly declare variable types even when type inference could handle it automatically.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-vars-data-types.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval x: Int = 1\nval s: String = \"a string\"\nval p: Person = Person(\"Richard\")\n```\n\n----------------------------------------\n\nTITLE: Explicit Type Declaration for Clarity in Scala\nDESCRIPTION: Shows when to explicitly specify data types, especially to clarify code or when precise data types are necessary, such as for specific numeric values. These snippets help avoid ambiguity and ensure the correct data type is used, particularly in complex scenarios.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/type-is-optional.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval p: Person = new Person(\"Candy\")\n```\n\n----------------------------------------\n\nTITLE: Using the `Lambda` keyword in Scala 2 (kind-projector)\nDESCRIPTION: Specifically highlights the `Lambda` keyword syntax from the Scala 2 `kind-projector` plugin. This keyword is not supported in Scala 3's kind-projector implementation and must be rewritten.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/plugin-kind-projector.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nLambda[(`+E`, `+A`) => Either[E, A]]\n```\n\n----------------------------------------\n\nTITLE: Mixing Traits into a Scala Class at Instance Creation\nDESCRIPTION: Demonstrates dynamically mixing in traits with concrete methods at the time of class instantiation, allowing an instance to gain additional behaviors on the fly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/traits-abstract-mixins.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval d = new Dog(\"Fido\") with TailWagger with Runner\n```\n\n----------------------------------------\n\nTITLE: REPL Behavior: Redefinition of val Variables Permitted\nDESCRIPTION: This snippet demonstrates that the Scala REPL allows redefining a val variable by declaring a new val with the same name, effectively shadowing the previous definition. In real-world source code this is disallowed. The example shows val age initially set to 18 then redefined to 19, both with inferred type Int.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/two-types-variables.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nscala> val age = 18\nage: Int = 18\n\nscala> val age = 19\nage: Int = 19\n```\n\n----------------------------------------\n\nTITLE: Single-line Parameter Lambdas with Indented Bodies in Scala\nDESCRIPTION: This example is a compressed form of an indented lambda, where the parameter 'x' and the arrow '=>' appear on the same line after a colon. The body remains indented. This feature is enabled under the fewerBraces variant in Scala 3 and requires that 'xs' is iterable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nxs.map: x =>\n  val y = x - 1\n  y * y\n```\n\n----------------------------------------\n\nTITLE: Running Simple Scala 3 Program Bash\nDESCRIPTION: Demonstrates how to compile and run a Scala 3 file containing a `@main` method using the `scala run` command. The command `scala run <filename>` finds and executes the annotated main method within the specified file.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-main-methods.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\n$ scala run Hello.scala\nHello, World\n```\n\n----------------------------------------\n\nTITLE: Iteratively Computing Square Roots Using Parallel ParTrieMap in Scala\nDESCRIPTION: This Scala snippet demonstrates the concurrent mutation and traversal capabilities of scala.collection.parallel.mutable.ParTrieMap. It initializes a ParTrieMap with pairs of numbers from 1 to 99 as both keys and values converted to Double. Inside a while loop, the map is traversed parallely using foreach, updating each value with a new approximate square root calculated by the Babylonian method. When the approximation converges within a tolerance (0.01), it prints the value and removes the key from the map. This shows how ParTrieMap supports safe concurrent modification during traversal, with updated values reflected in the next iteration. The snippet depends on importing scala.collection.parallel.mutable.ParTrieMap and requires the Scala parallel collections library.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/concrete-parallel-collections.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval numbers = scala.collection.parallel.mutable.ParTrieMap((1 until 100) zip (1 until 100): _*) map { case (k, v) => (k.toDouble, v.toDouble) }\nwhile (numbers.nonEmpty) {\n  numbers foreach { case (num, sqrt) =>\n    val nsqrt = 0.5 * (sqrt + num / sqrt)\n    numbers(num) = nsqrt\n    if (math.abs(nsqrt - sqrt) < 0.01) {\n      println(num, nsqrt)\n      numbers.remove(num)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Scala.js SBT Plugin for Scala 3 Support - Scala\nDESCRIPTION: Illustrates how to add the sbt-scalajs plugin in project/plugins.sbt to enable Scala.js compilation for Scala 3 projects. The code is meant to be used in the plugins.sbt file within the project's 'project' directory. The key parameter is the version of sbt-scalajs, which must be 1.5.0 or higher for Scala 3 support. Input is the addSbtPlugin line; output is plugin activation. Limitation: Only compatible with sbt builds targeting supported Scala and plugin versions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-prerequisites.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n// project/plugins.sbt\naddSbtPlugin(\"org.scala-js\" % \"sbt-scalajs\" % \"1.5.0\")\n```\n\n----------------------------------------\n\nTITLE: Defining a Binary-Compatible Case Class with Private Constructor in Scala 2\nDESCRIPTION: This snippet demonstrates how to evolve a Scala 2 case class in a binary-compatible manner by making the primary constructor and unapply function private, and providing with-methods for each field. The public constructor is exposed in the companion object's apply method. Required dependencies include the Scala standard library and sbt configuration for MiMa if used in a project. Parameters 'name' and 'age' are mandatory for person instances. This pattern facilitates later extension or modification of the class structure while minimizing binary incompatibilities.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/binary-compatibility-for-library-authors.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n// Mark the primary constructor as private\ncase class Person private (name: String, age: Int) {\n  // Create withXxx methods for every field, implemented by using the (private) copy method\n  def withName(name: String): Person = copy(name = name)\n  def withAge(age: Int): Person = copy(age = age)\n}\n\nobject Person {\n  // Create a public constructor (which uses the private primary constructor)\n  def apply(name: String, age: Int) = new Person(name, age)\n  // Make the extractor private\n  private def unapply(p: Person): Some[Person] = Some(p)\n}\n```\n\n----------------------------------------\n\nTITLE: Импорт необходимых зависимостей для работы с Future в Scala\nDESCRIPTION: Набор импортов, необходимых для работы с Future в Scala, включая ExecutionContext и утилиты для обработки результатов.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/concurrency.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.util.{Failure, Success}\n```\n\n----------------------------------------\n\nTITLE: Manual implementation of caching with Scala Map pattern matching\nDESCRIPTION: Implements caching logic manually by matching the result of a `get` operation on the Map. Returns cached result if found in Some, otherwise computes the result, adds it to the Map, and returns it. This snippet illustrates the underlying mechanics performed by `getOrElseUpdate` and requires mutable Map, pattern matching, and the function `f`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/maps.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef cachedF(arg: String) = cache get arg match {\n  case Some(result) => result\n  case None =>\n    val result = f(x)\n    cache(arg) = result\n    result\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Base Case Class in Scala\nDESCRIPTION: Defines a simple `Circle` case class with `x`, `y`, and `radius` parameters. This class serves as the target type for demonstrating extension methods in subsequent examples.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/ca-extension-methods.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Circle(x: Double, y: Double, radius: Double)\n```\n\n----------------------------------------\n\nTITLE: Creating String Double Map in Scala\nDESCRIPTION: Defines an immutable map named `ratings` where keys are movie titles (String) and values are ratings (Double). This map is used to demonstrate iteration over key-value pairs, which requires different handling compared to iterating over simple sequences or lists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/for-loops.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval ratings = Map(\n    \"Lady in the Water\"  -> 3.0, \n    \"Snakes on a Plane\"  -> 4.0, \n    \"You, Me and Dupree\" -> 3.5\n)\n```\n\n----------------------------------------\n\nTITLE: Compile error example due to missing ClassTag for type parameter in Scala 2\nDESCRIPTION: This snippet shows a Scala 2 REPL error that occurs when attempting to call 'evenElems' on a vector parameterized by an unconstrained type parameter U without a ClassTag. The compiler fails with 'No ClassTag available for U' because the generic parameter lacks an implicit class manifest, which is required to construct arrays of type U at runtime. This example highlights the necessity of requiring an implicit ClassTag for generic array creation when the type parameter itself is generic and unconstrained.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/arrays.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nscala> def wrap[U](xs: Vector[U]) = evenElems(xs)\n<console>:6: error: No ClassTag available for U.\n     def wrap[U](xs: Vector[U]) = evenElems(xs)\n                                           ^\n```\n\n----------------------------------------\n\nTITLE: Executing Compiled Scala Class from Command Line\nDESCRIPTION: This shell snippet illustrates running a compiled Scala class file from the command line using the `scala run` command with explicit main class and classpath options. The example specifies `--main-class HelloWorld` to identify the program entry-point class and `-classpath .` to include the current directory where class files reside. The command runs the compiled program, producing the expected Hello World output. This usage parallels Java's `java` command for executing bytecode.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n> scala run --main-class HelloWorld -classpath .\n```\n\n----------------------------------------\n\nTITLE: Implementing Companion Objects with Private Methods in Scala\nDESCRIPTION: Shows how to create a companion object with a private method that can be accessed by its companion class. The Circle class uses the private calculateArea method from the Circle object to compute the area.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-objects.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.math.*\n\nclass Circle(radius: Double):\n  import Circle.*\n  def area: Double = calculateArea(radius)\n\nobject Circle:\n  private def calculateArea(radius: Double): Double =\n    Pi * pow(radius, 2.0)\n\nval circle1 = Circle(5.0)\ncircle1.area   // Double = 78.53981633974483\n```\n\n----------------------------------------\n\nTITLE: Illustrating Non-Determinism with Side Effects in Scala Parallel Collections\nDESCRIPTION: Highlights the potential for non-deterministic behavior when performing side-effecting operations within parallel collection methods like `foreach`. Modifying an external `var` (`sum`) concurrently can lead to data races, resulting in different final values across multiple executions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/overview.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nscala> var sum = 0\nsum: Int = 0\n\nscala> val list = (1 to 1000).toList.par\nlist: scala.collection.parallel.immutable.ParSeq[Int] = ParVector(1, 2, 3,…\n\nscala> list.foreach(sum += _); sum\nres01: Int = 467766\n\nscala> var sum = 0\nsum: Int = 0\n\nscala> list.foreach(sum += _); sum\nres02: Int = 457073\n\nscala> var sum = 0\nsum: Int = 0\n\nscala> list.foreach(sum += _); sum\nres03: Int = 468520\n```\n\n----------------------------------------\n\nTITLE: Implementing while loops in Java vs Scala\nDESCRIPTION: Shows the syntax difference in while loops between Java and Scala. Scala uses 'do' keyword and doesn't require parentheses around the condition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_39\n\nLANGUAGE: Java\nCODE:\n```\nwhile (i < 3) {\n  System.out.println(i);\n  i++;\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nwhile i < 3 do\n  println(i)\n  i += 1\n```\n\n----------------------------------------\n\nTITLE: 定义RNA碱基类用于自定义集合示例(Scala)\nDESCRIPTION: 这段代码定义了RNA碱基的基本类型系统，作为展示如何集成新容器类的示例。它包含一个Base抽象类和四个表示不同碱基的case object，以及在碱基和整数之间转换的实用方法。这为后续实现自定义RNA序列类型作准备。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/architecture-of-scala-collections.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Base\ncase object A extends Base\ncase object T extends Base\ncase object G extends Base\ncase object U extends Base\n\nobject Base {\n  val fromInt: Int => Base = Array(A, T, G, U)\n  val toInt: Base => Int = Map(A -> 0, T -> 1, G -> 2, U -> 3)\n}\n```\n\n----------------------------------------\n\nTITLE: Result of Raw Multiline String Assignment in Scala\nDESCRIPTION: This code shows the output string obtained from assigning a multiline triple-quoted string, where subsequent lines remain indented. This demonstrates that direct assignment preserves formatting as written.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/first-look-at-types.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n\"The essence of Scala:\n               Fusion of functional and object-oriented\n               programming in a typed setting.\"\n```\n\n----------------------------------------\n\nTITLE: Using Compound Types (`with`) in Function Signatures (Scala 2)\nDESCRIPTION: Shows the updated function signature for `cloneAndReset` in Scala 2, specifying the parameter `obj` type as `Cloneable with Resetable`. This compound type ensures the object has both `clone` and `reset` capabilities. The function body is indicated as incomplete.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/compound-types.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef cloneAndReset(obj: Cloneable with Resetable): Cloneable = {\n  //...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Logic Functions with Dot Notation - Scala\nDESCRIPTION: This snippet shows the same `not` and `xor` functions as the previous example. However, it uses the traditional object-oriented dot notation (`x.or(y)`) to call the methods, providing a direct comparison to the infix operator syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/operators.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef not(x: MyBool) = x.negate\ndef xor(x: MyBool, y: MyBool) = x.or(y).and(x.and(y).negate)\n```\n\n----------------------------------------\n\nTITLE: Scala 2 Self Type Usage in Trait for Enforcing Mix-ins\nDESCRIPTION: This snippet demonstrates how to define a trait that uses self types in Scala 2. It shows how to declare a self type dependency within a trait, requiring that classes mixing it in also extend another trait (User). The example includes a class that mixes in both traits and utilizes the self type to access members directly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/self-types.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait User {\n  def username: String\n}\n\ntrait Tweeter {\n  this: User =>  // self-type annotation\n  def tweet(tweetText: String) = println(s\"$username: $tweetText\")\n}\n\nclass VerifiedTweeter(val username_ : String) extends Tweeter with User {  // Mixes in User as required by self type\n  def username = s\"real $username_\"\n}\n\nval realBeyoncé = new VerifiedTweeter(\"Beyoncé\")\nrealBeyoncé.tweet(\"Just spilled my glass of lemonade\")  // outputs: real Beyoncé: Just spilled my glass of lemonade\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Heterogeneous Collection with Any Type in Scala\nDESCRIPTION: This snippet shows how various types (string, integer, character, boolean, and function) can all be stored in a List[Any] and then iterated over using foreach. It demonstrates Scala's unified type system where everything is an object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/unified-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval list: List[Any] = List(\n  \"a string\",\n  732,  // an integer\n  'c',  // a character\n  true, // a boolean value\n  () => \"an anonymous function returning a string\"\n)\n\nlist.foreach(element => println(element))\n```\n\n----------------------------------------\n\nTITLE: Named Arguments with Functional Values in Scala\nDESCRIPTION: Demonstrates how named arguments can be used with functional values that have an apply method. For Function1-N types, the parameter names from the apply method can be used.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-and-default-arguments.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval f1 = new { def apply(x: Int) = x + 1 }\nval f2 = (x: Int) => x + 1 // instance of Function1[Int, Int]\nf1(x = 2)    // OK\n// f2(x = 2) // \"error: not found: value x\"\nf2(v1 = 2)   // OK, 'v1' is the parameter name in Function1\n```\n\n----------------------------------------\n\nTITLE: Using the SensorReader Observer Components in Scala 2\nDESCRIPTION: This snippet demonstrates how to use the SensorReader, creating sensor and display instances, subscribing displays to sensors, and triggering updates. It imports SensorReader.*, creates two Sensors and two Displays, subscribes the displays to sensors, and updates sensor values, resulting in printed notifications. Dependencies: SensorReader object and its classes must be accessible. Inputs include sensor labels and update values. Outputs are notification prints for each observer. No return values; illustrates runtime behavior and relationship wiring.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-oop.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nimport SensorReader._\n\n// setting up a network\nval s1 = new Sensor(\"sensor1\")\nval s2 = new Sensor(\"sensor2\")\nval d1 = new Display()\nval d2 = new Display()\ns1.subscribe(d1)\ns1.subscribe(d2)\ns2.subscribe(d1)\n\n// propagating updates through the network\ns1.changeValue(2)\ns2.changeValue(3)\n\n// prints:\n// sensor1 has value 2.0\n// sensor1 has value 2.0\n// sensor2 has value 3.0\n\n```\n\n----------------------------------------\n\nTITLE: Replacing Wildcard with Type Parameter in Scala 3\nDESCRIPTION: Provides a diff illustrating the fix for the simple wildcard type argument issue in Scala 3. It replaces the method signature `def f(foo: Foo[_]): Unit` with `def f[A](foo: Foo[A]): Unit`, introducing an explicit type parameter `A` to make the type application reducible by the Scala 3 compiler.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-other-changes.md#_snippet_12\n\nLANGUAGE: diff\nCODE:\n```\n-def f(foo: Foo[_]): Unit\n+def f[A](foo: Foo[A]): Unit\n```\n\n----------------------------------------\n\nTITLE: Creating a Set in Scala\nDESCRIPTION: Demonstrates creation of a Scala immutable Set named 'set' with integer elements 1, 2, and 3 using the Set factory method. Scala Sets guarantee unique elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\nval set = Set(1,2,3)\n```\n\n----------------------------------------\n\nTITLE: Defining Enum in Python\nDESCRIPTION: Shows how to define an enumeration 'Color' in Python using the 'enum' module with automatic value assignment using 'auto()' for members RED, GREEN, and BLUE.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_36\n\nLANGUAGE: Python\nCODE:\n```\nfrom enum import Enum, auto\nclass Color(Enum):\n   RED = auto()\n   GREEN = auto()\n   BLUE = auto()\n```\n\n----------------------------------------\n\nTITLE: Augmented String Implicit Conversion\nDESCRIPTION: This code snippet shows how Scala implicitly converts a string to an augmented string type to enable comparison operations that aren't directly available on String.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/implicit-conversions.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nPredef.augmentString(\"foo\") < \"bar\"\n```\n\n----------------------------------------\n\nTITLE: Using Immutable BitSets in Scala\nDESCRIPTION: Shows how to create an empty immutable `BitSet`, add integer elements (3, 4) using the `+` operator (duplicates are ignored), and check for the presence of an element using the `apply` method (e.g., `moreBits(3)` returns `true`). BitSets efficiently store sets of small non-negative integers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-immutable-collection-classes.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nscala> val bits = scala.collection.immutable.BitSet.empty\nbits: scala.collection.immutable.BitSet = BitSet()\nscala> val moreBits = bits + 3 + 4 + 4\nmoreBits: scala.collection.immutable.BitSet = BitSet(3, 4)\nscala> moreBits(3)\nres26: Boolean = true\nscala> moreBits(0)\nres27: Boolean = false\n```\n\n----------------------------------------\n\nTITLE: Traditional Method Call Syntax for Logical Functions in Scala\nDESCRIPTION: Provides an equivalent implementation of the 'not' and 'xor' functions using standard object-oriented syntax with dot notation and parentheses for method calls. This contrasts with the infix/postfix usage, illustrating the same logic expressed in a more explicit way. Each method call on MyBool includes the dot operator and parentheses, clarifying method invocation order and style. Serves as a reference for understanding the difference between syntactic sugar and conventional method calls in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/operators.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef not(x: MyBool) = x.negate; // punto y coma necesario aquí\ndef xor(x: MyBool, y: MyBool) = x.or(y).and(x.and(y).negate)\n```\n\n----------------------------------------\n\nTITLE: Using Mutable Queues in Scala 3\nDESCRIPTION: Demonstrates creating a mutable `Queue[String]` in Scala 3 using the companion object's `apply` method, adding single elements with `+=`, adding multiple elements from a list with `++=`, and removing/returning the head element using `dequeue` (which modifies the queue).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-mutable-collection-classes.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nscala> val queue = scala.collection.mutable.Queue[String]()\nqueue: scala.collection.mutable.Queue[String] = Queue()\nscala> queue += \"a\"\nres10: queue.type = Queue(a)\nscala> queue ++= List(\"b\", \"c\")\nres11: queue.type = Queue(a, b, c)\nscala> queue\nres12: scala.collection.mutable.Queue[String] = Queue(a, b, c)\nscala> queue.dequeue\nres13: String = a\nscala> queue\nres14: scala.collection.mutable.Queue[String] = Queue(b, c)\n```\n\n----------------------------------------\n\nTITLE: Reading File Content in Java Using Scala Reader Class\nDESCRIPTION: This Java snippet demonstrates usage of the Scala-defined Reader class to read characters from a file specified by the first argument to the main method. It imports the Scala Reader class and instantiates it with the filename argument. The program reads each character until end-of-file (-1) and prints it to standard output. It handles IOException in a try-catch block. This example illustrates how Java code interacts with Scala classes that declare exceptions via annotations, relying on the @throws annotation to make the IOException visible at compile-time. Without the annotation in the Scala class, this Java program results in a compilation error, as the checked exception is not declared.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/annotations.md#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\npackage test;\nimport examples.Reader;  // Klasa Scali !!\npublic class AnnotaTest {\n    public static void main(String[] args) {\n        try {\n            Reader in = new Reader(args[0]);\n            int c;\n            while ((c = in.read()) != -1) {\n                System.out.print((char) c);\n            }\n        } catch (java.io.IOException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: メイン関数例：式の評価と微分結果の出力\nDESCRIPTION: 複合式 `(x + x) + (7 + y)`に対し、環境値と微分を計算し出力する`main`メソッド。式の評価、`x`と`y`の微分計算結果を出力。プログラムの動作例とその結果例を示す。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tutorials/scala-for-java-programmers.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef main(args: Array[String]): Unit = {\n  val exp: Tree = Sum(Sum(Var(\"x\"),Var(\"x\")),Sum(Const(7),Var(\"y\")))\n  val env: Environment = { case \"x\" => 5 case \"y\" => 7 }\n  println(\"Expression: \" + exp)\n  println(\"Evaluation with x=5, y=7: \" + eval(exp, env))\n  println(\"Derivative relative to x:\\n \" + derive(exp, \"x\"))\n  println(\"Derivative relative to y:\\n \" + derive(exp, \"y\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Using Match Expressions with Conditional Guards in Scala 3\nDESCRIPTION: Shows a match expression on variable `count` using Scala 3 syntax with indentation instead of braces. Cases use guards with `if` to selectively print messages for `count` values 1, 2 or 3, greater than 3, and a default case for all others. This example requires `count` as an integer and uses only standard Scala features.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_36\n\nLANGUAGE: scala\nCODE:\n```\ncount match\n  case 1 => \n    println(\"one, a lonely number\")\n  case x if x == 2 || x == 3 => \n    println(\"two's company, three's a crowd\")\n  case x if x > 3 => \n    println(\"4+, that's a party\")\n  case _ => \n    println(\"i'm guessing your number is zero or less\")\n```\n\n----------------------------------------\n\nTITLE: Defining Case Classes and `Generic` Instances for Derivation Example (Scala)\nDESCRIPTION: Defines three nested, non-recursive case classes `A`, `B`, and `C`. For each case class, a corresponding `Generic.Aux` implicit instance (`genA`, `genB`, `genC`) is provided, mapping the case class to its representation type (a nested tuple structure). This code forms part of the motivating example for the revised divergence checking algorithm.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ncase class A(b: B, i: Int)\nobject A {\n  implicit val genA: Generic.Aux[A, (B, (Int, Unit))] = ???\n}\n\ncase class B(c: C, i: Int, b: Boolean)\nobject B {\n  implicit val genB:\n    Generic.Aux[B, (C, (Int, (Boolean, Unit)))] = ???\n}\n\ncase class C(i: Int, s: String, b: Boolean)\nobject C {\n  implicit val genC:\n    Generic.Aux[C, (Int, (String, (Boolean, Unit)))] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Using Postfix Operators and Defining Logical Functions in Scala\nDESCRIPTION: Shows usage of the previously defined 'and', 'or', and 'negate' methods as infix and postfix operators, respectively. Defines 'not' as a postfix operator applying 'negate' and 'xor' combining these operators for a logical exclusive or operation. The postfix operator syntax is used by invoking methods without dot or parentheses following the object (e.g., 'x negate'). Requires enabling postfix ops if compiler settings restrict them. The code improves readability by leveraging Scala's operator notation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/operators.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef not(x: MyBool) = x negate; // punto y coma necesario aquí\ndef xor(x: MyBool, y: MyBool) = (x or y) and not(x and y)\n```\n\n----------------------------------------\n\nTITLE: GitHub Actions Step for Binary Compatibility with MiMa - YAML\nDESCRIPTION: Adds a CI step for running 'sbt mimaReportBinaryIssues' in the GitHub Actions pipeline, ensuring that pull requests do not introduce binary incompatible changes. Requires sbt-mima-plugin and configuration in build.sbt. Input: current and previous artifacts; Output: pass/fail on binary compatibility check. Limit: Part of a larger workflow; omitted lines are context.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_25\n\nLANGUAGE: yaml\nCODE:\n```\n# .github/workflows/ci.yml\n# The three periods `...` indicate the parts of file that do not change\n# from the snippets above and they are omitted for brevity\n\n# ...\njobs:\n  ci:\n    # ...\n    steps:\n      # ...\n      - name: Binary compatibility\n        run: sbt mimaReportBinaryIssues\n```\n\n----------------------------------------\n\nTITLE: Using ClassTag to create runtime-typed generic arrays\nDESCRIPTION: This example demonstrates declaring a generic method with a ClassTag context bound, enabling the creation of type-specific arrays at runtime. It highlights the implicit resolution of ClassTag and its importance in generic array creation for type safety and compatibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/arrays.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n// No additional code snippet; explanation only\n```\n\n----------------------------------------\n\nTITLE: Grouping and Running Tests by Tags in MUnit\nDESCRIPTION: Mentions the use of tags to organize and run specific groups of tests across suites. Tagging facilitates selective test execution, with the exact implementation detailed in the linked MUnit documentation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-run-only.md#_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: Примеры вывода типов в Scala REPL\nDESCRIPTION: Демонстрирует возможности вывода типов Scala в среде REPL для переменных типа `Int`, `String` и `List[Int]`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-vars-data-types.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nscala> val x = 1\nval x: Int = 1\n\nscala> val s = \"a string\"\nval s: String = a string\n\nscala> val nums = List(1, 2, 3)\nval nums: List[Int] = List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Conceptual Desugaring of a Scala 3 `enum`\nDESCRIPTION: Illustrates the conceptual expansion of a Scala 3 `enum` (`Color`) into a `sealed abstract class`, case objects/classes for its variants, and a companion object with helper methods like `fromOrdinal`. Note: This is a simplified representation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-adts-gadts.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nsealed abstract class Color(val rgb: Int) extends scala.reflect.Enum\nobject Color:\n  case object Red extends Color(0xFF0000) { def ordinal = 0 }\n  case object Green extends Color(0x00FF00) { def ordinal = 1 }\n  case object Blue extends Color(0x0000FF) { def ordinal = 2 }\n  case class Mix(mix: Int) extends Color(mix) { def ordinal = 3 }\n\n  def fromOrdinal(ordinal: Int): Color = ordinal match\n    case 0 => Red\n    case 1 => Green\n    case 2 => Blue\n    case _ => throw new NoSuchElementException(ordinal.toString)\n```\n\n----------------------------------------\n\nTITLE: Printing Output in Scala Console Applications - Scala\nDESCRIPTION: Demonstrates basic console output in Scala using the println function. This snippet is intended for illustration as part of both Scala 2 and Scala 3 guides. The function prints the string 'hello' to the standard output, requiring only the standard Scala library. No external dependencies or parameters are involved. The expected output is the text 'hello' displayed in the console. Intended for basic introduction purposes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/add-guides.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nprintln(\"hello\")\n```\n\n----------------------------------------\n\nTITLE: Using PartialFunction and Optional Function as Extractors in Scala\nDESCRIPTION: Demonstrates the proposed feature of using a `PartialFunction` directly as an extractor in a `match` statement and converting an optional function (`A => Option[B]`) into an extractor using the `unlift` method. This allows pattern matching on the results of these function types. The example defines both function types (`pf` and `of`) and then uses them within `case` clauses to potentially match a random integer.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/converters-among-optional-functions-partialfunctions-and-extractor-objects.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// Define a PartialFunction\nval pf: PartialFunction[Int, String] = {\n  case 1 => \"matched by a PartialFunction\"\n}\n\n// Define an optional function\nval of: Int => Option[String] = { i =>\n  if (i == 2) {\n    Some(\"matched by an optional function\")\n  } else {\n    None\n  }\n}\n\nutil.Random.nextInt(4) match {\n  case pf(m) => // A PartialFunction itself is a pattern\n    println(m)\n  case of.unlift(m) => // Convert an optional function to a pattern\n    println(m)\n  case _ =>\n    println(\"Not matched\")\n}\n```\n\n----------------------------------------\n\nTITLE: Calling a Multiline Scala Method in the REPL\nDESCRIPTION: Demonstrates invoking the multiline `addThenDouble` method defined previously from the Scala REPL. It shows how to pass arguments and confirms the correct execution and return value for a method with a block body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/methods-first-look.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nscala> addThenDouble(1, 1)\nres0: Int = 4\n```\n\n----------------------------------------\n\nTITLE: Using Curly Braces with Control Structures in Scala\nDESCRIPTION: This snippet illustrates guidelines for omitting or including curly braces in control structures. It states that if expressions with an else clause can omit braces if both branches are single-line; otherwise, braces should surround contents. While loops must always include braces as they are imperative. For expressions with a yield clause can omit braces if single-line, but must include braces otherwise. Case clauses should never use braces. It includes code examples showing correct usage of if expressions with and without braces as well as pattern matching without braces.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/control-structures.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval news = if (foo)\n  goodNews()\nelse\n  badNews()\n\nif (foo) {\n  println(\"foo was true\")\n}\n\nnews match {\n  case \"good\" => println(\"Good news!\")\n  case \"bad\" => println(\"Bad news!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Documenting Methods (Javadoc Style) in Scala\nDESCRIPTION: Demonstrates the Javadoc comment style applied to a Scala method definition. This style uses aligned asterisks starting in column two and follows traditional Javadoc conventions for multi-line comments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/scaladoc.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n/**\n * Provides a service as described.\n *\n * This is further documentation of what we're documenting.\n * Here are more details about how it works and what it does.\n */\ndef member: Unit = ()\n```\n\n----------------------------------------\n\nTITLE: Implementing Monoids with Implicit Parameters in Scala\nDESCRIPTION: This example demonstrates how to use implicit parameters in Scala through a Monoid implementation. It defines a Monoid trait with add and unit operations, creates implicit Monoid instances for String and Int types, and implements a sum function that uses these implicit Monoids to add elements in a list. The code shows how Scala automatically resolves and passes the appropriate implicit Monoid based on the list's element type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/implicit-parameters.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Monoid[A] {\n  def add(x: A, y: A): A\n  def unit: A\n}\n\nobject ImplicitTest {\n  implicit val stringMonoid: Monoid[String] = new Monoid[String] {\n    def add(x: String, y: String): String = x concat y\n    def unit: String = \"\"\n  }\n  \n  implicit val intMonoid: Monoid[Int] = new Monoid[Int] {\n    def add(x: Int, y: Int): Int = x + y\n    def unit: Int = 0\n  }\n  \n  def sum[A](xs: List[A])(implicit m: Monoid[A]): A =\n    if (xs.isEmpty) m.unit\n    else m.add(xs.head, sum(xs.tail))\n    \n  def main(args: Array[String]): Unit = {\n    println(sum(List(1, 2, 3)))       // uses IntMonoid implicitly\n    println(sum(List(\"a\", \"b\", \"c\"))) // uses StringMonoid implicitly\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using `?` as a wildcard in Scala 3\nDESCRIPTION: Demonstrates the use of `?` as a wildcard type placeholder in Scala 3. This syntax is required instead of `_` when the `-Ykind-projector:underscores` flag is enabled or when cross-compiling with the necessary Scala 2 flags, freeing up `_` for type lambdas.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/plugin-kind-projector.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef getWidget(widgets: Set[? <: Widget], name: String): Option[Widget] =\n  widgets.find(_.name == name)\n```\n\n----------------------------------------\n\nTITLE: Defining a SubjectObserver Trait with Abstract Type Members in Scala 2\nDESCRIPTION: This Scala 2 snippet defines a trait 'SubjectObserver' with abstract type members 'S' and 'O' representing Subject and Observer types, respectively. It includes nested traits 'Subject' with a self-type annotation to enforce type constraints and maintain proper interactions. This design enables creating flexible, scalable components following the observer pattern.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-oop.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait SubjectObserver {\n\n  type S <: Subject\n  type O <: Observer\n\n  trait Subject { self: S =>\n    private var observers: List[O] = List()\n    def subscribe(obs: O): Unit = {\n      observers = obs :: observers\n    }\n    def publish() = {\n      for ( obs <- observers ) obs.notify(this)\n    }\n  }\n\n  trait Observer {\n    def notify(sub: S): Unit\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Typed Expression Tree with reify in Scala\nDESCRIPTION: This snippet demonstrates how to construct an Expr instance encapsulating both a Tree and a TypeTag using the reify method. The input is any Scala expression (here, a class definition for Flower), and reify produces an Expr of type Unit containing the given expression as its AST. Requires scala.reflect.runtime.universe and works in the REPL or within macros; the resulting expr can be deconstructed or inspected for advanced metaprogramming.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nval expr = reify { class Flower { def name = \"Rose\" } }\n```\n\n----------------------------------------\n\nTITLE: Defining Identity Macro Annotation Using Macro Paradise - Scala\nDESCRIPTION: Defines an identity macro annotation class named `identity` that inherits from StaticAnnotation and uses the `macroTransform` method to mark it as a macro annotation. It uses the `@compileTimeOnly` annotation to ensure that if the macro paradise plugin is not enabled, a compile-time warning or error is raised, preventing silent failures. This snippet sets up the basic structure required to use macro annotations in Scala with macro paradise.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/annotations.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.annotation.{StaticAnnotation, compileTimeOnly}\nimport scala.language.experimental.macros\nimport scala.reflect.macros.whitebox\n\n@compileTimeOnly(\"enable macro paradise to expand macro annotations\")\nclass identity extends StaticAnnotation {\n  def macroTransform(annottees: Any*): Any = macro ???\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Method With ClassTag Context Bound (Scala)\nDESCRIPTION: Defines a generic method `wrap` that takes a `Vector` of type parameter `U` and passes it to `evenElems`. The `[U: ClassTag]` syntax is a context bound that requires an implicit `ClassTag[U]` to be available at the call site, which is then implicitly passed to `evenElems`, resolving the compile error seen in the previous example and allowing the creation of a generic array.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/arrays.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nscala> def wrap[U: ClassTag](xs: Vector[U]) = evenElems(xs)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nwrap: [U](xs: Vector[U])(implicit evidence$1: scala.reflect.ClassTag[U])Array[U]\n```\n\n----------------------------------------\n\nTITLE: Illustrating Current Scala Pattern Matching vs Assignment Behavior in Scala\nDESCRIPTION: This Scala snippet shows existing semantics where pattern matching assignments using 'val' differ from assignments without 'val'. The first line matches the pattern 'a(x)' against 'true', binding locally if it matches, while the second line attempts an assignment that will follow the language rules for such expressions. It demonstrates how multiple assignment syntax resembles but differs from pattern matching in current Scala versions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/multiple-assignments.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval a(x) = true // 1\n\na(x) = true     // 2\n```\n\n----------------------------------------\n\nTITLE: Using withAddress and Public Constructor to Set New Fields in Case Class in Scala\nDESCRIPTION: This snippet illustrates instantiating a Person object and setting the optional address field using the withAddress method, after extending the case class. It demonstrates typical usage in both Scala 2 and 3. The input is a new Person instance; withAddress returns a cloned Person with updated address. Requirements are an extended Person definition as described previously.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/binary-compatibility-for-library-authors.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\n// The public constructor sets the address to None by default.\n// To set the address, we call withAddress:\nval bob = Person(\"Bob\", 21).withAddress(Some(\"Atlantic ocean\"))\nprintln(bob.address)\n```\n\n----------------------------------------\n\nTITLE: Basic Collection Methods in Scala\nDESCRIPTION: Examples of basic collection methods that don't use lambda expressions, including distinct, drop, head, init, intersect, and others. These methods demonstrate operations on a List that return new collections without modifying the original.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-methods.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval a = List(10, 20, 30, 40, 10)      // List(10, 20, 30, 40, 10)\n\na.distinct                            // List(10, 20, 30, 40)\na.drop(2)                             // List(30, 40, 10)\na.dropRight(2)                        // List(10, 20, 30)\na.head                                // 10\na.headOption                          // Some(10)\na.init                                // List(10, 20, 30, 40)\na.intersect(List(19,20,21))           // List(20)\na.last                                // 10\na.lastOption                          // Some(10)\na.slice(2,4)                          // List(30, 40)\na.tail                                // List(20, 30, 40, 10)\na.take(3)                             // List(10, 20, 30)\na.takeRight(2)                        // List(40, 10)\n```\n\n----------------------------------------\n\nTITLE: Trait mixin con funcionalidad foreach para iteradores en Scala\nDESCRIPTION: Define el trait `RichIterator` que extiende `AbsIterator` y añade un método `foreach` que recibe una función `f` para aplicar a cada elemento producido por el iterador. El trait reutiliza la abstracción base e implementa un patrón de iteración simple invocando `hasNext` y `next()`. Requiere que cualquier clase mezclada con este trait implemente `AbsIterator`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/mixin-class-composition.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntrait RichIterator extends AbsIterator {\n  def foreach(f: T => Unit): Unit = { while (hasNext) f(next()) }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Covariant Linked List Usage with Lower Type Bounds in Scala\nDESCRIPTION: Provides an example object extending App that tests the covariant linked list with lower type bounds. It creates an empty list of Null type, prepends String elements to create a ListNode[String], then prepends an Int element to create a ListNode[Any]. This demonstrates the flexible type widening enabled by the lower bound in prepend method. No dependencies beyond standard Scala library.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/lower-type-bounds.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nobject LowerBoundTest extends App {\n  val empty: ListNode[Null] = ListNode(null, null)\n  val strList: ListNode[String] = empty.prepend(\"hello\")\n                                       .prepend(\"world\")\n  val anyList: ListNode[Any] = strList.prepend(12345)\n}\n```\n\n----------------------------------------\n\nTITLE: Understanding ExecutionContext and Thread Management in Scala\nDESCRIPTION: Provides an overview of ExecutionContext's role, including global default mechanisms and in-depth control via ForkJoinPool. Explains how thread pools manage parallelism, blocking, and custom executors, with code examples demonstrating managed blocking and the use of Java Executors for custom execution contexts.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.concurrent.{ Future, ExecutionContext }\nimport scala.concurrent.forkjoin._\n\n// the following is equivalent to `implicit val ec = ExecutionContext.global`\nimport ExecutionContext.Implicits.global\n\nFuture {\n  ForkJoinPool.managedBlock(\n    new ManagedBlocker {\n      var done = false\n\n      def block(): Boolean = {\n        try {\n          myLock.lock()\n          // ...\n        } finally {\n          done = true\n        }\n        true\n      }\n\n      def isReleasable: Boolean = done\n    }\n  )\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.concurrent.Future\nimport scala.concurrent.blocking\n\nFuture {\n  blocking {\n    myLock.lock()\n    // ...\n  }\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit val ec = ExecutionContext.global\n\nfor (i <- 1 to 32000) {\n  Future {\n    blocking {\n      Thread.sleep(999999)\n    }\n  }\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\ngiven ExecutionContext = ExecutionContext.global\n\nfor i <- 1 to 32000 do\n  Future {\n    blocking {\n      Thread.sleep(999999)\n    }\n  }\n\n```\n\nLANGUAGE: Scala\nCODE:\n```\nExecutionContext.fromExecutor(new ThreadPoolExecutor( /* your configuration */ ))\n```\n\nLANGUAGE: Scala\nCODE:\n```\nExecutionContext.fromExecutor(ThreadPoolExecutor( /* your configuration */ ))\n```\n\n----------------------------------------\n\nTITLE: 定義されたスプリッタ (`Splitter` trait) の実装\nDESCRIPTION: `Splitter` は、Scalaの並列コレクションを要素ごとに分割するためのイテレータのサブタイプであり、並列処理において要素の分割を行う中心的役割を担う。`split` メソッドは、自身を複数に分割し、各部分に対して並列処理を可能にする。分割可能な`Splitter`は、一度`split`を呼び出すと無効になる仕様となっている。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/parallel-collections/architecture.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Splitter[T] extends Iterator[T] {\n  def split: Seq[Splitter[T]]\n}\n```\n\n----------------------------------------\n\nTITLE: Serving Basic Dynamic Content with Cask (Scala)\nDESCRIPTION: Defines a basic Cask web application with an endpoint that generates content dynamically. The `@cask.get(\"/time\")` annotation maps the `/time` GET request path to the `dynamic()` method. This method returns a `String` representing the current date and time. The `initialize()` method starts the Cask server. Returning a `String` results in a `text/plain` content type response by default.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/web-server-dynamic.md#_snippet_0\n\nLANGUAGE: Scala 2\nCODE:\n```\nimport java.time.ZonedDateTime\n\nobject Example extends cask.MainRoutes {\n  @cask.get(\"/time\")\n  def dynamic(): String = s\"Current date is: ${ZonedDateTime.now()}\"\n\n  initialize()\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nimport java.time.ZonedDateTime\n\nobject Example extends cask.MainRoutes:\n  @cask.get(\"/time\")\n  def dynamic(): String = s\"Current date is: ${ZonedDateTime.now()}\"\n\n  initialize()\n```\n\n----------------------------------------\n\nTITLE: Defining OOP Style Class with Primary Constructor in Java\nDESCRIPTION: Defines a Java class named Person with public fields for first name, last name, and age. It includes a primary constructor to initialize these fields and an overridden toString method to provide a string representation. This is a typical JavaBeans-style class, used to demonstrate equivalent Scala class construction. No external dependencies required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\nclass Person {\n  public String firstName;\n  public String lastName;\n  public int age;\n  public Person(\n    String firstName, \n    String lastName,\n    int age\n  ) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.age = age;\n  }\n  public String toString() {\n    return String.format(\"%s %s is %d years old.\", firstName, lastName, age);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SIP Meeting Results Page (YAML)\nDESCRIPTION: YAML front matter defining metadata for a specific SIP meeting results page. It sets the 'layout' to 'sip-meeting-results', defines the page 'title', marks it as 'partof' the 'results' section, and lists proposals discussed ('SIP-61') along with their outcome ('accepted') and a link. This data is typically processed by a static site generator.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/results/2024-05-24-meeting.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nlayout: sip-meeting-results\ntitle: SIP Meeting Results - 24th May 2024\npartof: results\nproposals:\n  - url: https://github.com/scala/improvement-proposals/pull/78\n    name: SIP-61 - Unroll default arguments for binary compatibility\n    result: accepted\n---\n```\n\n----------------------------------------\n\nTITLE: Basic Pattern Matching with match Expression in Scala\nDESCRIPTION: Demonstrates a basic `match` expression, similar to a Java `switch`, that evaluates an integer `i` and assigns a corresponding day string to the `day` variable based on the matched `case`. Includes a default `case _` to handle any values not explicitly matched. Shows syntax for Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_22\n\nLANGUAGE: Scala 2\nCODE:\n```\n// `i` is an integer\nval day = i match {\n  case 0 => \"Sunday\"\n  case 1 => \"Monday\"\n  case 2 => \"Tuesday\"\n  case 3 => \"Wednesday\"\n  case 4 => \"Thursday\"\n  case 5 => \"Friday\"\n  case 6 => \"Saturday\"\n  case _ => \"invalid day\"   // the default, catch-all\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nimport scala.annotation.switch\n\n// `i` is an integer\nval day = i match\n  case 0 => \"Sunday\"\n  case 1 => \"Monday\"\n  case 2 => \"Tuesday\"\n  case 3 => \"Wednesday\"\n  case 4 => \"Thursday\"\n  case 5 => \"Friday\"\n  case 6 => \"Saturday\"\n  case _ => \"invalid day\"   // the default, catch-all\n```\n\n----------------------------------------\n\nTITLE: Matching Different Types Using Scala Pattern Matching\nDESCRIPTION: This Scala code defines an application with a function that matches an input parameter of type Any against different patterns. It matches the exact integer 1, the string \"two\", and any other integer using a type pattern that binds the value to variable y. It demonstrates pattern matching on multiple types, type annotations in patterns, and variable binding. The function returns various output types based on the matched pattern.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/pattern-matching.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject MatchTest2 extends App {\\n  def matchTest(x: Any): Any = x match {\\n    case 1 => \"one\"\\n    case \"two\" => 2\\n    case y: Int => \"scala.Int\"\\n  }\\n  println(matchTest(\"two\"))\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Immutable Case Classes in Scala\nDESCRIPTION: Defines a basic case class with an immutable parameter and demonstrates instantiating an object without using the 'new' keyword. It highlights that case classes provide a default 'apply' method for object creation and that constructor parameters are public immutable vals by default. Dependencies include the Scala standard library. The input includes a single String parameter 'isbn' and output is an instance of the 'Book' case class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tour/case-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Book(isbn: String)\n\nval frankenstein = Book(\"978-0486282114\")\n```\n\n----------------------------------------\n\nTITLE: Defining and Initializing a Scala Class with Constructors\nDESCRIPTION: Demonstrates defining a Scala class with a primary constructor accepting a parameter of type R, includes an assertion to validate the parameter, declarations of a mutable public member, an immutable value, a private variable, and an alternative constructor that initializes the class with a default value. Key dependencies include the Scala type system and constructor overloading rules. Inputs are constructor arguments of type R; outputs are initialized class instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/cheatsheets/index.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass C(var x: R) {\nassert(x > 0, \"positive please\")\nvar y = x\nval readonly = 5\nprivate var secret = 1\ndef this = this(42)\n}\n```\n\n----------------------------------------\n\nTITLE: Use Case: Avoiding Leaks in Effectful Loops with ZIO (Proposal 3)\nDESCRIPTION: Presents a ZIO example of a recursive effectful loop (`Task[Unit]`) that commonly ends with `yield ()`. The proposed optimization (removing the redundant final `map(_ => ())`) prevents potential memory leaks by avoiding the retention of intermediate results solely for this final map operation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\n//> using scala 3.3.3\n//> using lib \"dev.zio::zio:2.1.5\"\n\nimport zio.*\n\ndef loop: Task[Unit] =\n  for\n    _ <- Console.print(\"loop\")\n    _ <- loop\n  yield ()\n\n@main\ndef run =\n  val runtime = Runtime.default\n  Unsafe.unsafe { implicit unsafe =>\n    runtime.unsafe.run(loop).getOrThrowFiberFailure()\n  }\n```\n\n----------------------------------------\n\nTITLE: Using Java Annotation with Single Element and Default Value in Java\nDESCRIPTION: This Java code shows usage of the '@SourceURL' annotation by providing a single positional argument for the required 'value' element. Because 'value' is a special element name, the argument can be given without explicitly naming it. The optional 'mail' element is omitted and thus defaults to an empty string. The snippet exemplifies concise annotation application when defaults and the special 'value' element are defined.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/annotations.md#_snippet_6\n\nLANGUAGE: Java\nCODE:\n```\n@SourceURL(\"https://coders.com/\")\npublic class MyClass extends HisClass ...\n```\n\n----------------------------------------\n\nTITLE: Recovering from Specific Exceptions in Future Computations with recover Combinator in Scala\nDESCRIPTION: This snippet shows error recovery in a Future computation where a buy operation might throw a QuoteChangedException. The recover combinator intercepts this specific exception, returning a successful Future with a value of 0 instead of failing. If the Future succeeds normally, the result passes unchanged. This pattern enables graceful error handling in asynchronous pipelines without propagating failures upstream.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/futures.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nval purchase: Future[Int] = rateQuote map {\n  quote => connection.buy(amount, quote)\n} recover {\n  case QuoteChangedException() => 0\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Project Metadata and Dependencies with build.sbt - Scala\nDESCRIPTION: Shows a sample build.sbt file providing the project name, version, Scala version (using a placeholder), and specifying a test dependency on ScalaTest. Requires sbt installed and compatible Scala/Java SDKs. The libraryDependencies block sets up ScalaTest for test scope. Inputs: metadata strings and dependency coordinates; Outputs: a properly configured build.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\nname := \"HelloScalaTest\"\nversion := \"0.1\"\nscalaVersion := \"{{site.scala-3-version}}\"\n\nlibraryDependencies ++= Seq(\n  \"org.scalatest\" %% \"scalatest\" % \"3.2.19\" % Test\n)\n\n```\n\n----------------------------------------\n\nTITLE: Using onComplete for File Processing Future in Scala\nDESCRIPTION: Shows how to use `onComplete` with a `Future` that performs file I/O and string searching. The asynchronous operation reads a file and finds the index of a keyword. The callback handles success by printing the found index and failure by reporting an error message, demonstrating `onComplete`'s utility for operations that might fail.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nval firstOccurrence: Future[Int] = Future {\n  val source = scala.io.Source.fromFile(\"myText.txt\")\n  source.toSeq.indexOfSlice(\"myKeyword\")\n}\n\nfirstOccurrence.onComplete {\n  case Success(idx) => println(\"The keyword first appears at position: \" + idx)\n  case Failure(t) => println(\"Could not process file: \" + t.getMessage)\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Enum Values in Python\nDESCRIPTION: Demonstrates comparing two different enum members (`Color.RED` and `Color.BLUE`) for equality in Python, which evaluates to `False`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_72\n\nLANGUAGE: Python\nCODE:\n```\nColor.RED == Color.BLUE  # False\n```\n\n----------------------------------------\n\nTITLE: Creating a Language-Specific Greeting Function Factory in Scala\nDESCRIPTION: Defines a Scala method 'createGreetingFunction' that takes a language identifier string and returns a greeting function. It constructs anonymous functions for English and French greetings and uses pattern matching to select the appropriate one based on the input parameter. This approach demonstrates conditional logic and function factory pattern for multilingual greetings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-write-method-returns-function.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef createGreetingFunction(desiredLanguage: String): String => Unit = {\n  val englishGreeting = (name: String) => println(s\"Hello, $name\")\n  val frenchGreeting = (name: String) => println(s\"Bonjour, $name\")\n  desiredLanguage match {\n    case \"english\"\" => englishGreeting\n    case \"french\"\" => frenchGreeting\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Eta-Expansion for Polymorphic Functions in Kittens (Scala)\nDESCRIPTION: This example shows the explicit construction of polymorphic functions (`pure`, `map`, `ap`) as inline values to pass into a generic `traverse` implementation. Dependencies are a typeclass instance `Applicative[G]` and the `inst` with its methods. Key parameters are the higher-kinded types and context bounds. Inputs are functors and functions, outputs are higher-kinded mapped structures. Limitation: eta-expansion is done by hand due to current compiler limitations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/polymorphic-eta-expansion.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n...  \n  final override def traverse[G[_], A, B](fa: F[A])(f: A => G[B])\n      (using G: Applicative[G]): G[F[B]] =\n    val pure = [a] => (x: a) => G.pure(x)                        //  eta-expansion\n    val map = [a, b] => (ga: G[a], f: a => b) => G.map(ga)(f)    // ~eta-expansion\n    val ap = [a, b] => (gf: G[a => b], ga: G[a]) => G.ap(gf)(ga) // ~eta-expansion\n    inst.traverse[A, G, B](fa)(map)(pure)(ap)([f[_]] => (tf: T[f], fa: f[A]) => tf.traverse(fa)(f))\n```\n\n----------------------------------------\n\nTITLE: Multiline While Loop (Scala 2)\nDESCRIPTION: Demonstrates the standard multiline syntax for a `while` loop in Scala 2, using curly braces for the loop body. The example initializes a mutable variable `x` and increments it within the loop body until the condition `x < 3` is false, printing the value each iteration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_30\n\nLANGUAGE: Scala\nCODE:\n```\nvar x = 1\n\nwhile (x < 3) {\n  println(x)\n  x += 1\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a CustomerID Extractor Object in Scala\nDESCRIPTION: This example demonstrates creating an extractor object with both apply and unapply methods. The apply method creates a customer ID from a name, while the unapply method extracts the name from a customer ID using pattern matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/extractor-objects.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.util.Random\n\nobject CustomerID {\n\n  def apply(name: String) = s\"$name--${Random.nextLong()}\"\n\n  def unapply(customerID: String): Option[String] = {\n    val name = customerID.split(\"--\").head\n    if (name.nonEmpty) Some(name) else None\n  }\n}\n\nval customer1ID = CustomerID(\"Sukyoung\")  // Sukyoung--23098234908\ncustomer1ID match {\n  case CustomerID(name) => println(name)  // prints Sukyoung\n  case _ => println(\"Could not extract a CustomerID\")\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Non-Deterministic Callback Execution Order in Scala Futures\nDESCRIPTION: Highlights the potential for race conditions when multiple callbacks modify shared state. This example uses two `foreach` callbacks modifying a `@volatile var totalA`. Since callbacks can run concurrently and `+=` isn't atomic, the final value of `totalA` is unpredictable, demonstrating that callback execution order is not guaranteed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/futures.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n@volatile var totalA = 0\n\nval text = Future {\n  \"na\" * 16 + \"BATMAN!!!\"\n}\n\ntext.foreach { txt =>\n  totalA += txt.count(_ == 'a')\n}\n\ntext.foreach { txt =>\n  totalA += txt.count(_ == 'A')\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Structural Type with Record Class in Scala 3\nDESCRIPTION: Definition of a Record class that extends Selectable and a structural Person type with name and age fields. The Record class stores field values in a map and provides dynamic access through the selectDynamic method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-structural.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Record(elems: (String, Any)*) extends Selectable:\n  private val fields = elems.toMap\n  def selectDynamic(name: String): Any = fields(name)\n\ntype Person = Record {\n  val name: String\n  val age: Int\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lower Type Bounds Usage in Scala Covariant Lists\nDESCRIPTION: This snippet demonstrates practical usage of the List and NonEmptyList implementations with lower type bounds. It defines a Bird trait and two case classes AfricanSwallow and EuropeanSwallow extending Bird. It shows assignment compatibility between covariant lists of different subtypes, usage of prepend with elements of different but related types, and how the type parameter B is inferred as the supertype. The code highlights how adding elements widens the list type appropriately and warns about potential type arg widening issues flagged by the Scala '-Xlint' compiler flag.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/lower-type-bounds.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait Bird\ncase class AfricanSwallow() extends Bird\ncase class EuropeanSwallow() extends Bird\n\nval africanSwallows: List[AfricanSwallow] = Nil.prepend(AfricanSwallow())\nval swallowsFromAntarctica: List[Bird] = Nil\nval someBird: Bird = EuropeanSwallow()\n\n// assign swallows to birds\nval birds: List[Bird] = africanSwallows\n\n// add some bird to swallows, `B` is `Bird`\nval someBirds = africanSwallows.prepend(someBird)\n\n// add a swallow to birds\nval moreBirds = birds.prepend(EuropeanSwallow())\n\n// add disparate swallows together, `B` is `Bird` because that is the supertype common to both swallows\nval allBirds = africanSwallows.prepend(EuropeanSwallow())\n\n// but this is a mistake! adding a list of birds widens the type arg too much. -Xlint will warn!\nval error = moreBirds.prepend(swallowsFromAntarctica)    // List[Object]\n```\n\n----------------------------------------\n\nTITLE: Match Type Definition with Recursive Cases in Scala\nDESCRIPTION: Defines a recursive match type `LeafElem` that extracts leaf element types from collections or returns the type itself if it matches `AnyVal`. It is used to perform compile-time type computations for generic data structures, illustrating advanced type system capabilities.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/minutes/2020-03-12-minutes.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntype LeafElem[X] = X match {\n  case String => Char\n  case Array[t] => LeafElem[t]\n  case Iterable[t] => LeafElem[t]\n  case AnyVal => X\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Public Type Provider Macro Annotation\nDESCRIPTION: Defines a macro annotation used for implementing public type providers. This annotation, when applied to a target, will have its `macroTransform` method executed at compile-time to generate publicly visible definitions (like classes or objects) based on its parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/typeproviders.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nclass H2Db(connString: String) extends StaticAnnotation {\n  def macroTransform(annottees: Any*) = macro ...\n}\n```\n\n----------------------------------------\n\nTITLE: Variable Declaration and Assignment in Python and Scala\nDESCRIPTION: Shows how to create integer and string variables, as well as collections like lists, dictionaries (maps), sets, and tuples in Python and Scala. Highlights the syntactic differences, such as `x =` versus `val x =` and constructors like `List()` versus `[elements]` in Python.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nx = 1\nx = \"Hi\"\n y = \"\"\"foo\n      bar\n      baz\"\"\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval x = 1\nval x = \"Hi\"\nval y = \"\"\"foo\n             bar\n             baz\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Address Class with Potential for Null Optional Field (Scala 2 and 3)\nDESCRIPTION: This class defines an Address with five mutable fields of type String, including street2 which is intended to be optional but typed as a non-optional String, allowing for null values. This design can introduce null pointer issues because street2 is not explicitly optional. It demonstrates a problematic pattern where nulls are used as placeholders for missing values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-functional-error-handling.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nclass Address(\n  var street1: String,\n  var street2: String,\n  var city: String,\n  var state: String,\n  var zip: String\n)\n```\n\n----------------------------------------\n\nTITLE: Clase concreta de iterador sobre cadena de caracteres en Scala\nDESCRIPTION: Implementa la clase `StringIterator` que extiende `AbsIterator` y define el tipo `T` como `Char`. Proporciona implementación para `hasNext`, que verifica si quedan caracteres por iterar, y `next()`, que devuelve el siguiente carácter de la cadena `s`. Esta clase concreta proporciona la funcionalidad necesaria para ser mezclada con otros traits.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/mixin-class-composition.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass StringIterator(s: String) extends AbsIterator {\n  type T = Char\n  private var i = 0\n  def hasNext = i < s.length()\n  def next() = { val ch = s charAt i; i += 1; ch }\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Integer Values Using Scala\nDESCRIPTION: This snippet defines a Scala application with a function that maps integer input values to corresponding string representations using pattern matching. The function matchTest takes an integer and uses match-case expressions to return \"one\" for 1, \"two\" for 2, and \"many\" for all other values. It demonstrates basic pattern matching syntax and value matching on integers without additional dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/pattern-matching.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject MatchTest1 extends App {\\n  def matchTest(x: Int): String = x match {\\n    case 1 => \"one\"\\n    case 2 => \"two\"\\n    case _ => \"many\"\\n  }\\n  println(matchTest(3))\\n}\n```\n\n----------------------------------------\n\nTITLE: Utilisation de l'opérateur _ pour fonctions anonymes simplifiées en Scala\nDESCRIPTION: Présente une syntaxe courte pour définir une fonction anonyme lorsque le compilateur peut inférer les types, en utilisant le placeholder _. Permet d'exprimer succinctement la même transformation qu'avec une fonction lambda nommée. Nécessite la bibliothèque standard Scala. Entrée: Seq[Int], sortie: Seq[Int] avec valeurs doublées.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tour/higher-order-functions.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval salaries = Seq(20000, 70000, 40000)\nval newSalaries = salaries.map(_ * 2)\n```\n\n----------------------------------------\n\nTITLE: Defining Mixed Macro Signatures in Scala Object - Scala\nDESCRIPTION: This snippet defines the Location case class and the Macros object with two macro method signatures: a Scala 2.13 macro and its Scala 3 inline + macro expansion variant. The macros share the same name and signature, allowing the compiler to select the appropriate version during macro expansion. No macro bodies are provided here; only the signatures and structure are given.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-macro-mixing.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n// example/src/main/scala/location/Location.scala\npackage location\n\ncase class Location(path: String, line: Int)\n\nobject Macros:\n  def location: Location = macro ???\n  inline def location: Location = ${ ??? }\n```\n\n----------------------------------------\n\nTITLE: Using map method as an alternative to for-expression\nDESCRIPTION: Demonstrates how a for-expression can be rewritten using the map method, which applies a function to each element in a collection to produce a new collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval list = (10 to 12).map(i => i * 2)\n```\n\n----------------------------------------\n\nTITLE: Example Command to Run a Scala Source File or Compiled Class\nDESCRIPTION: Shows shell commands for executing a Scala script file directly or running a compiled Scala class with command-line arguments. Useful for testing @main methods or explicit main methods. No dependencies other than the Scala runtime and appropriate source or compiled files. Demonstrates expected console output when passing parameters at runtime.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/methods-main-methods.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ scala Hello.scala\nHello, World\n\n$ scala happyBirthday 23 Lisa Peter\nHappy 23rd Birthday, Lisa and Peter!\n\n$ scalac happyBirthday.scala\n\n$ scala happyBirthday 23 Lisa Peter\nHappy 23rd Birthday, Lisa and Peter!\n```\n\n----------------------------------------\n\nTITLE: Traits as Interfaces in Scala 3\nDESCRIPTION: Scala 3 rendition of traits defining behaviors for animals, with syntax differences such as colon instead of braces. Used similarly as interfaces, facilitating behavior composition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-modeling.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntrait Speaker:\n  def speak(): String  // has no body, so it’s abstract\n\ntrait TailWagger:\n  def startTail(): Unit = println(\"tail is wagging\")\n  def stopTail(): Unit = println(\"tail is stopped\")\n\ntrait Runner:\n  def startRunning(): Unit = println(\"I’m running\")\n  def stopRunning(): Unit = println(\"Stopped running\")\n```\n\n----------------------------------------\n\nTITLE: Illegal Multiple Colon-Delimited Function Arguments for groupMapReduce in Scala\nDESCRIPTION: This snippet presents an illegal pattern with multiple consecutive colon-initiated function arguments in a 'groupMapReduce' call. Each step (key, value, reduction) attempts to use a colon, which is not allowed by the SIP-44 rules. The contributor should instead use `.apply`, parentheses, or other legal constructs for chaining arguments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nxs.groupMapReduce: item =>\n  key(item)\n: item =>  // illegal\n  value(item)\n: (value1, value2) =>  // illegal\n  reduce(value1, value2)\n```\n\n----------------------------------------\n\nTITLE: Using for-Loop with Cartesian Product in Scala\nDESCRIPTION: This snippet demonstrates iterating over two collections simultaneously by using a for-loop with multiple generators to produce a Cartesian product of elements from both collections. Inside the loop, it performs a floating-point division and prints a formatted string using the Java Formatter-style syntax. It requires collections xs and ys of numeric types. The output prints each division result formatted as a string 'x/y = result' with one decimal place.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/cheatsheets/index.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nfor (x <- xs; y <- ys) {\n  val div = x / y.toFloat\n  println(\"%d/%d = %.1f\".format(x, y, div))\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Immutable VectorMaps in Scala\nDESCRIPTION: Demonstrates initializing an empty immutable `VectorMap`, adding key-value pairs using the `+` operator which preserves the insertion order of elements. It also shows that `VectorMap` equality comparison with standard `Map` ignores element order.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-immutable-collection-classes.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nscala> val vm = scala.collection.immutable.VectorMap.empty[Int, String]\nvm: scala.collection.immutable.VectorMap[Int,String] =\n  VectorMap()\nscala> val vm1 = vm + (1 -> \"one\")\nvm1: scala.collection.immutable.VectorMap[Int,String] =\n  VectorMap(1 -> one)\nscala> val vm2 = vm1 + (2 -> \"two\")\nvm2: scala.collection.immutable.VectorMap[Int,String] =\n  VectorMap(1 -> one, 2 -> two)\nscala> vm2 == Map(2 -> \"two\", 1 -> \"one\")\nres29: Boolean = true\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Pattern Matching to Return String (Scala 3)\nDESCRIPTION: Defines a function matchTest that uses Scala 3 syntax to pattern match an integer input and return a string label for specific integer values (1 and 2) with a catch-all default. The new indentation-based syntax is used instead of braces. Example calls demonstrate the function's output with different inputs, showing usage of the matching expression as a return value within a function.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/pattern-matching.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef matchTest(x: Int): String = x match\n  case 1 => \"one\"\n  case 2 => \"two\"\n  case _ => \"other\"\n\nmatchTest(3)  // выводит \"other\"\nmatchTest(1)  // выводит \"one\"\n```\n\n----------------------------------------\n\nTITLE: Concrete Contravariant Printer Subclasses for Animal and Cat in Scala - scala\nDESCRIPTION: Implements two concrete subclasses of Printer: AnimalPrinter printing Animals, and CatPrinter printing Cats. These classes override print method with specific implementations. They illustrate contravariance by showing how Printer[Animal] can be used where Printer[Cat] is expected, as animalPrinter handles any Animal including Cats.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/variances.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass AnimalPrinter extends Printer[Animal] {\n  def print(animal: Animal): Unit =\n    println(\"The animal's name is: \" + animal.name)\n}\n\nclass CatPrinter extends Printer[Cat] {\n  def print(cat: Cat): Unit =\n    println(\"The cat's name is: \" + cat.name)\n}\n```\n\n----------------------------------------\n\nTITLE: 도메인 기반 패키지 네이밍 관례 스칼라\nDESCRIPTION: 웹사이트 도메인 기반으로 패키지 이름을 체계화하는 관례를 보여주는 예제입니다. 예를 들어, com.google.selfdrivingcar.camera와 같이 기업의 상위 도메인, 도메인 이름, 프로젝트 이름을 포함한 형식으로 패키지를 명명하며, Lens 클래스가 해당 패키지 안에 정의됩니다. 이는 의존성 관리와 코드 재사용에 유리한 표준화된 네임스페이스 패턴입니다.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/packages-and-imports.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\npackage com.google.selfdrivingcar.camera\n\nclass Lens\n```\n\n----------------------------------------\n\nTITLE: Using PizzaService Methods After Implementation in Scala\nDESCRIPTION: Demonstrates usage of the concrete PizzaService implementation by importing its methods and performing chained pizza modifications starting from a base Pizza instance. Finally, it prints the computed price of the final Pizza object. It highlights a clean and expressive usage pattern leveraging immutable data transformations. Both Scala 2 and Scala 3 import syntaxes are presented.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-fp.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nimport PizzaService._\n\nval p = Pizza(Small, Thin, Seq(Cheese))\n\n// use the PizzaService methods\nval p1 = addTopping(p, Pepperoni)\nval p2 = addTopping(p1, Onions)\nval p3 = updateCrustType(p2, Thick)\nval p4 = updateCrustSize(p3, Large)\n\nprintln(price(p4)) // prints 8.75\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport PizzaService.*\n\nval p = Pizza(Small, Thin, Seq(Cheese))\n\n// use the PizzaService methods\nval p1 = addTopping(p, Pepperoni)\nval p2 = addTopping(p1, Onions)\nval p3 = updateCrustType(p2, Thick)\nval p4 = updateCrustSize(p3, Large)\n\nprintln(price(p4)) // prints 8.75\n```\n\n----------------------------------------\n\nTITLE: Использование метода 'map' с именованной функцией в Scala 2 и 3\nDESCRIPTION: Этот пример показывает, как определить функцию 'double' для умножения на 2 и использовать её с методом 'map' для преобразования списка. Подчеркивает возможность передачи имени функции без вызова скобок, для улучшения читаемости и переиспользования кода.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-functions.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef double(i: Int): Int = i * 2\n\nval a = List(1, 2, 3).map(i => double(i))   // List(2,4,6)\nval b = List(1, 2, 3).map(double)           // List(2,4,6)\n```\n\n----------------------------------------\n\nTITLE: Using the Public Constructor and with-Methods for Case Class Instances in Scala\nDESCRIPTION: This code demonstrates instantiating and transforming a Person case class using its public constructor and with-methods, for both Scala 2 and 3. Dependencies include the Person definition as per the prior examples. It shows how to create a new person instance and update fields in an immutable manner using the with-methods. Inputs are constructor arguments. Outputs are new Person instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/binary-compatibility-for-library-authors.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n// Create a new instance\nval alice = Person(\"Alice\", 42)\n// Transform an instance\nprintln(alice.withAge(alice.age + 1)) // Person(Alice, 43)\n```\n\n----------------------------------------\n\nTITLE: Configuring Default and Specific Snippet Compiler Flags\nDESCRIPTION: This command-line argument shows setting a default flag (`compile`) for all paths, then overriding it for more specific paths. Compilation is enabled by default, but explicitly disabled (`nocompile`) for `library/src/scala/quoted` and set to expect failures (`fail`) for `library/src/scala/compiletime`. The longest matching path prefix determines the flag used for a given snippet.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/snippet-compiler.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n-snippet-compiler:compile,library/src/scala/quoted=nocompile,library/src/scala/compiletime=fail\n```\n\n----------------------------------------\n\nTITLE: Using lazy vals to avoid uninitialized field access in Scala\nDESCRIPTION: This snippet shows how to declare lazy vals that are initialized on first access, which helps address initialization order issues and prevents null values during subclass construction. It also discusses Scala 3 support for abstract lazy vals.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/FAQ/initialization-order.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class A {\n  lazy val x1: String\n  lazy val x2: String = \"mom\"\n\n  println(\"A: \" + x1 + \", \" + x2)\n}\nclass B extends A {\n  lazy val x1: String = \"hello\"\n\n  println(\"B: \" + x1 + \", \" + x2)\n}\nclass C extends B {\n  override lazy val x2: String = \"dad\"\n\n  println(\"C: \" + x1 + \", \" + x2)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing custom string interpolator for Point in Scala 3\nDESCRIPTION: Defines an extension method to add a 'p' interpolator to StringContext, enabling creation of Point objects from string literals with embedded expressions. Uses Scala 3 extension syntax, relying on 'sc.s' for string substitution and parsing, suitable for creating Point instances with flexible inputs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/string-interpolation.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nextension (sc: StringContext)\n  def p(args: Double*): Point = {\n    // переиспользование интерполятора `s` и затем разбиение по ','\n    val pts = sc.s(args: _*).split(\",\", 2).map { _.toDoubleOption.getOrElse(0.0) }\n    Point(pts(0), pts(1))\n  }\n\nval x=12.0\n\np\"1, -2\"        // Point(1.0, -2.0)\np\"${x/5}, $x\"   // Point(2.4, 12.0)\n```\n\n----------------------------------------\n\nTITLE: Matching Against Constants in a Scala match Expression\nDESCRIPTION: Illustrates how a `case` pattern starting with an uppercase letter (e.g., `N`) matches against a constant value (`val N = 42`) defined in the scope, rather than introducing a new variable. This contrasts with lowercase variable patterns (e.g., `n`) which bind the matched value. Shows syntax for Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_24\n\nLANGUAGE: Scala 2\nCODE:\n```\nval N = 42\ni match {\n  case 0 => println(\"1\")\n  case 1 => println(\"2\")\n  case N => println(\"42\")\n  case n => println(s\"You gave me: $n\" )\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nval N = 42\ni match\n  case 0 => println(\"1\")\n  case 1 => println(\"2\")\n  case N => println(\"42\")\n  case n => println(s\"You gave me: $n\" )\n```\n\n----------------------------------------\n\nTITLE: Reverting to Original Scala 2 Syntax - Scala\nDESCRIPTION: Shows transformation to the original Scala 2 style by applying `-old-syntax -rewrite`. This restores parentheses around `if` conditions and removes `then` and `do` keywords, along with classic braces around control blocks and `for` generators. The snippet represents the initial code before any Scala 3 syntax rewrites.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tooling-syntax-rewriting.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ncase class State(n: Int, minValue: Int, maxValue: Int) {\n  \n  def inc: State =\n    if (n == maxValue)\n      this\n    else\n      this.copy(n = n + 1)\n  \n  def printAll: Unit = {\n    println(\"Printing all\")\n    for {\n      i <- minValue to maxValue\n      j <- 0 to n\n    }\n    println(i + j)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Compiled Class Files in Scala 2\nDESCRIPTION: Displays typical output of listing compiled bytecode files generated by the Scala 2 compiler. Shows the presence of class files including 'hello$.class' and 'hello.class' representing the singleton object and its compiled code respectively. This output provides insight into compilation artifacts before running the program on the JVM. Users must run 'ls -1' in the shell to verify compiled files.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-hello-world.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ ls -1\nhello$.class\nhello.class\nhello.scala\n```\n\n----------------------------------------\n\nTITLE: Running Scala 3 Program with Arguments Bash\nDESCRIPTION: Shows how to execute a Scala 3 program defined with `@main` that expects arguments. Arguments are passed after `--`. The `scala run` command handles parsing and passing these arguments to the `@main` method, performing necessary type conversions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-main-methods.md#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\n$ scala run happyBirthday.scala -- 23 Lisa Peter\nHappy 23rd Birthday, Lisa and Peter!\n```\n\n----------------------------------------\n\nTITLE: Accessing tuple elements in Python and Scala\nDESCRIPTION: Shows how to read individual tuple elements by index. Python uses square brackets while Scala uses parentheses. This demonstrates consistent syntax differences with other collection types for element access in both languages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_62\n\nLANGUAGE: python\nCODE:\n```\nt[0]  # 11\nt[1]  # 11.0\n```\n\nLANGUAGE: scala\nCODE:\n```\nt(0)  // 11\nt(1)  // 11.0\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on GADTs for Type Refinement in Scala\nDESCRIPTION: Shows how pattern matching on a GADT (`Box`) in Scala 3 allows the compiler to refine the type parameter (`T`) within each case block, enabling type-safe operations (like `n + 1` for `IntBox`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-adts-gadts.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ndef extract[T](b: Box[T]): T = b match\n  case IntBox(n)  => n + 1\n  case BoolBox(b) => !b\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Case Class Instances with Typed Patterns in Scala 2\nDESCRIPTION: This Scala 2 snippet illustrates how to pattern match on a Person instance using a typed pattern, which is necessary because the unapply extractor is private in this compatibility-preserving design. It demonstrates extracting the 'name' field from a Person. The snippet assumes an existing instance 'alice' and the compatible Person definition. It accepts an instance of Person and returns the name string.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/binary-compatibility-for-library-authors.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nalice match {\n  case person: Person => person.name\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling Scala Source Files Using scalac (Bash)\nDESCRIPTION: This bash snippet shows the usage of the Scala compiler `scalac` to compile a Scala source file named `Hello.scala`. Running `$ scalac Hello.scala` generates JVM bytecode files (*.class) corresponding to the compiled Scala code. This command mimics the Java compilation process (`javac`). Compilation output differs between Scala 2 and Scala 3, with additional `.tasty` and package-related files appearing in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-hello-world.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ scalac Hello.scala\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mutable Collection Key Pitfall in Scala HashMap\nDESCRIPTION: This snippet illustrates how using a mutable collection, specifically an `ArrayBuffer`, as a key in a `mutable.HashMap` can lead to unexpected behavior. After adding the `ArrayBuffer` to the map, modifying the buffer's contents changes its hash code. Subsequent lookups using the modified buffer fail because the hash map cannot find the key in the expected location based on the new hash code, resulting in a `NoSuchElementException`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/equality.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nscala> import collection.mutable.{HashMap, ArrayBuffer}\nimport collection.mutable.{HashMap, ArrayBuffer}\nscala> val buf = ArrayBuffer(1, 2, 3)\nbuf: scala.collection.mutable.ArrayBuffer[Int] =\nArrayBuffer(1, 2, 3)\nscala> val map = HashMap(buf -> 3)\nmap: scala.collection.mutable.HashMap[scala.collection.\nmutable.ArrayBuffer[Int],Int] = Map((ArrayBuffer(1, 2, 3),3))\nscala> map(buf)\nres13: Int = 3\nscala> buf(0) += 1\nscala> map(buf)\njava.util.NoSuchElementException: key not found:\nArrayBuffer(2, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Configuring Scala Par Collection with ThreadPoolTaskSupport\nDESCRIPTION: Illustrates changing a parallel collection's task support to use the ThreadPoolTaskSupport implementation. This is a fallback option for JVMs that don't support Fork/Join pools. The example shows assigning a new ThreadPoolTaskSupport instance to the collection and performing a parallel map operation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/configuration.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nscala> pc.tasksupport = new ThreadPoolTaskSupport()\npc.tasksupport: scala.collection.parallel.TaskSupport = scala.collection.parallel.ThreadPoolTaskSupport@1d914a39\n\nscala> pc map { _ + 1 }\nres1: scala.collection.parallel.mutable.ParArray[Int] = ParArray(2, 3, 4)\n```\n\n----------------------------------------\n\nTITLE: Applying @unroll to Method Parameters in Scala\nDESCRIPTION: Example of using the `@unroll` annotation on default parameters (`sorted`, `nameMapper`) within a method definition (`constructEither`). This annotation signals the compiler to generate backward-compatible forwarder methods for callers expecting older versions of the method signature that did not include these parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/unroll-default-arguments.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n  def constructEither(\n      args: Seq[String],\n      allowPositional: Boolean = false,\n      allowRepeats: Boolean = false,\n      totalWidth: Int = 100,\n      printHelpOnExit: Boolean = true,\n      docsOnNewLine: Boolean = false,\n      autoPrintHelpAndExit: Option[(Int, PrintStream)] = Some((0, System.out)),\n      customName: String = null,\n      customDoc: String = null,\n      @unroll sorted: Boolean = true,\n      @unroll nameMapper: String => Option[String] = Util.kebabCaseNameMapper\n  ): Either[String, T] = ???\n```\n\n----------------------------------------\n\nTITLE: Creating and Modifying Immutable Sets in Scala\nDESCRIPTION: Shows how to create empty Sets with type parameters, initialize Sets with values, and add or remove elements to create new Set instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-classes.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\n// Creating empty Sets\nval nums = Set[Int]()\nval letters = Set[Char]()\n\n// Creating Sets with initial data\nval nums = Set(1, 2, 3, 3, 3)           // Set(1, 2, 3)\nval letters = Set('a', 'b', 'c', 'c')   // Set('a', 'b', 'c')\n\n// Adding elements to Sets\nval a = Set(1, 2)                // Set(1, 2)\nval b = a + 3                    // Set(1, 2, 3)\nval c = b ++ Seq(4, 1, 5, 5)     // HashSet(5, 1, 2, 3, 4)\n\n// Removing elements from Sets\nval a = Set(1, 2, 3, 4, 5)   // HashSet(5, 1, 2, 3, 4)\nval b = a - 5                // HashSet(1, 2, 3, 4)\nval c = b -- Seq(3, 4)       // HashSet(1, 2)\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Exact Quoted `Option[Boolean]` Expressions\nDESCRIPTION: Extends quoted pattern matching to handle nested structures. This example matches an `Expr[Option[Boolean]]` against specific patterns like `'{ Some(true) }`, `'{ Some(false) }`, and `'{ None }`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ndef valueOfBooleanOption(x: Expr[Option[Boolean]])(using Quotes): Option[Option[Boolean]] =\n  x match\n    case '{ Some(true) } => Some(Some(true))\n    case '{ Some(false) } => Some(Some(false))\n    case '{ None } => Some(None)\n    case _ => None\n```\n\n----------------------------------------\n\nTITLE: Unlifting Literal Quasiquotes - Scala\nDESCRIPTION: Shows how to use pattern matching with quasiquotes to 'unlift' a value from a literal AST node. The syntax `q\"${x: Int}\"` matches a literal tree and extracts the underlying value, provided the type ascription matches the literal type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"${x: Int}\" = q\"1\"\nx: Int = 1\n```\n\n----------------------------------------\n\nTITLE: Transforming and Sorting mutable.IndexedSeq in Scala\nDESCRIPTION: Describes in-place transformation and sorting operations on Scala's mutable IndexedSeq. Important methods include mapInPlace for applying a function to each element, sortInPlace for sorting elements, sortInPlaceWith to sort according to a custom comparator function, and sortInPlaceBy which sorts based on the result of applying a function to each element. These methods mutate the original collection and depend on the mutable.IndexedSeq trait. Expected inputs are collections implementing mutable.IndexedSeq and appropriate functions for transformation or comparison. Outputs are the same mutable collections modified in-place.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/seqs.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nxs.mapInPlace(f)\nxs.sortInPlace()\nxs.sortInPlaceWith(c)\nxs.sortInPlaceBy(f)\n```\n\n----------------------------------------\n\nTITLE: Exception with head Method on Empty Collections in Scala\nDESCRIPTION: Warning about exceptions when using head method on empty collections, showing how it can fail with NoSuchElementException.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/collections-methods.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nval emptyList = List[Int]()   // emptyList: List[Int] = List()\nemptyList.head                // java.util.NoSuchElementException: head of empty list\n```\n\n----------------------------------------\n\nTITLE: Arity-1 Function Type Syntax in Scala\nDESCRIPTION: Demonstrates the special syntax for declaring single-parameter function types in Scala, omitting unnecessary parentheses to improve readability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/types.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef map[B](f: A => B) = ...\n```\n\n----------------------------------------\n\nTITLE: Examples of Illegal Type Match Patterns - Scala\nDESCRIPTION: This snippet lists patterns that are not permitted in Scala match types due to incorrect type captures, use of bounds not covering all instantiations, or refinement errors. It demonstrates common mistakes developers might encounter, referencing the type/class definitions above. Patterns here illustrate compiler restrictions and are not executable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/match-types-spec.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n// Type capture nested two levels below a non-covariant type constructor\ncase Inv[Cov[t]] =>\ncase Inv[Inv[t]] =>\ncase Contra[Cov[t]] =>\n\n// Type constructor with bounds that do not contain all possible instantiations\ncase IsSeq[t] =>\n\n// Type refinement where the refined type member is not a member of the parent\ncase ZExtractor[t] =>\n```\n\n----------------------------------------\n\nTITLE: Iterating Sequence with For Loop in Scala\nDESCRIPTION: Demonstrates a basic Scala `for` loop iterating over the elements of the `nums` sequence. Each element is assigned to the variable `n` and printed to the console, illustrating the simple generator syntax `variable <- collection` for basic iteration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/for-loops.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nfor (n <- nums) println(n)\n```\n\n----------------------------------------\n\nTITLE: Importing and creating mutable Map in Scala\nDESCRIPTION: This snippet imports the mutable Map class from the Scala collection library and demonstrates instantiating a mutable Map with one key-value pair. Dependencies include the Scala standard mutable Map implementation. The created Map allows mutation such as adding, removing, or updating elements after creation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/map-class.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable.Map\n```\n\nLANGUAGE: scala\nCODE:\n```\nval states = collection.mutable.Map(\"AK\" -> \"Alaska\")\n```\n\n----------------------------------------\n\nTITLE: Obtaining ClassTag using classTag method in Scala\nDESCRIPTION: Example of obtaining a ClassTag for String type using the classTag method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/reflection/typetags-manifests.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect._\nval ct = classTag[String]\n```\n\n----------------------------------------\n\nTITLE: Matching Empty Multiple Argument Lists - Scala\nDESCRIPTION: Illustrates that the `...$` pattern for matching multiple argument lists in quasiquotes will match even when no argument lists are present, resulting in an empty list of lists being bound to `$argss`. This highlights the need for additional checks (like `if argss.nonEmpty`) if specific argument lists are required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"g(...$argss)\" = q\"g\"\nargss: List[List[universe.Tree]] = List()\n```\n\n----------------------------------------\n\nTITLE: Creating and Filtering Parallel Vectors in Scala\nDESCRIPTION: Demonstrates creating a parallel vector using tabulate and applying a filter operation. ParVector is an immutable collection that provides logarithmic time for reads and writes with low constant factors.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/parallel-collections/concrete-parallel-collections.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval pv = scala.collection.parallel.immutable.ParVector.tabulate(1000)(x => x)\npv: scala.collection.parallel.immutable.ParVector[Int] = ParVector(0, 1, 2, 3, 4, 5, 6, 7, 8, 9,...\n\npv filter (_ % 2 == 0)\nres0: scala.collection.parallel.immutable.ParVector[Int] = ParVector(0, 2, 4, 6, 8, 10, 12, 14, 16, 18,...\n```\n\n----------------------------------------\n\nTITLE: Redirect Example Using Front Matter\nDESCRIPTION: Demonstrates how to configure page redirects using the redirectFrom property in the YAML front matter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/static-site.md#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\n---\nredirectFrom: /absolute/path/to/old/url.html\n---\n```\n\n----------------------------------------\n\nTITLE: Defining SmallAnimal and Mouse Subclasses in Scala for Function Variance\nDESCRIPTION: This snippet adds a subclass SmallAnimal extending Animal and a case class Mouse extending SmallAnimal, used to demonstrate function type variance where Function1 is contravariant in parameter type and covariant in result type. This sets up a type hierarchy for illustrating variance in function parameters and return values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/variances.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nabstract class SmallAnimal extends Animal\ncase class Mouse(name: String) extends SmallAnimal\n```\n\n----------------------------------------\n\nTITLE: Basic iteration over Scala Iterator using while loop (Scala 2 and 3)\nDESCRIPTION: Demonstrates how to traverse all elements of an iterator using a while loop and hasNext/next methods. It shows different syntax for Scala 2 and Scala 3 to perform element printing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/iterators.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nwhile (it.hasNext)\n  println(it.next())\n```\n\nLANGUAGE: Scala\nCODE:\n```\nwhile it.hasNext do\n  println(it.next())\n```\n\n----------------------------------------\n\nTITLE: Transitioning Deprecated and Removed Collection APIs - Scala\nDESCRIPTION: This code snippet collection shows deprecated or removed APIs in Scala's collections and suggests their modern equivalents. It focuses on things like replacing JavaConversions, deprecated Stack/Proxy types, and mutable collection APIs with recommended alternatives. Prerequisites include understanding of Scala collection traits and their modern replacements. Input is legacy code using old APIs; output is updated, supported code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/collections-migration-213.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\n// Use scala.jdk.CollectionConverters instead of collection.JavaConversions\nimport scala.jdk.CollectionConverters._\n\n// Replace deprecated MutableList\nval buffer = scala.collection.mutable.ListBuffer[Int]()\n\n// Use List instead of Stack\nval stack = List(1, 2, 3)\n\n```\n\n----------------------------------------\n\nTITLE: Local Import in Scala Function\nDESCRIPTION: This snippet shows that import statements can be placed inside functions, enabling context-specific imports and improved code modularity. Here, 'scala.math.sqrt' is imported locally within a function to perform square root calculations, showcasing Scala's flexible import scope.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/packages-and-imports.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef sqrtplus1(x: Int) = {\n  import scala.math.sqrt\n  sqrt(x) + 1.0\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Classes in Scala 2 and Scala 3\nDESCRIPTION: Models a 'Person' with mutable name fields using class constructors. Both Scala 2 and Scala 3 snippets demonstrate how classes are declared with constructor parameters and how to access and modify fields. The syntax difference is highlighted with or without angular brackets.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-modeling.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass Person(var firstName: String, var lastName: String) {\n  def printFullName() = println(s\"$firstName $lastName\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using Infix Notation for Arity-1 Methods in Scala\nDESCRIPTION: Illustrates the optional infix notation (`target method argument`) for invoking methods with one argument (arity-1). This is generally discouraged but acceptable for purely functional symbolic methods (operators) or sometimes higher-order functions. Standard dot notation (`target.method(argument)`) is generally preferred. Infix notation must not be used for methods with side-effects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/method-invocation.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n// recommended\nnames.mkString(\",\")\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// also sometimes seen; controversial\nnames mkString \",\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// wrong - has side-effects\njavaList add item\n```\n\n----------------------------------------\n\nTITLE: Corrected DirectedGraph Implementation with Explicit Self-Type Annotation in Scala\nDESCRIPTION: This snippet refines the previous `DirectedGraph` implementation by introducing an explicit self-type annotation `self: Node =>` inside the `NodeImpl` class. This annotation informs the Scala compiler that `this` should be typed as `Node`, making the call to `newEdge(this, node)` type-correct. All previous abstract members and methods are retained. This pattern resolves the incompatibility of the self reference type and allows subclasses to correctly instantiate node objects that align with the abstract type `Node`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/self-types.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nabstract class DirectedGraph extends Graph {\n  type Edge <: EdgeImpl\n  class EdgeImpl(origin: Node, dest: Node) {\n    def from = origin\n    def to = dest\n  }\n  class NodeImpl extends NodeIntf {\n    self: Node =>                     // nova linha adicionada\n    def connectWith(node: Node): Edge = {\n      val edge = newEdge(this, node)  // agora válido\n      edges = edge :: edges\n      edge\n    }\n  }\n  protected def newNode: Node\n  protected def newEdge(from: Node, to: Node): Edge\n  var nodes: List[Node] = Nil\n  var edges: List[Edge] = Nil\n  def addNode: Node = {\n    val node = newNode\n    nodes = node :: nodes\n    node\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cask Dependency in Mill Build File in Scala\nDESCRIPTION: This snippet demonstrates adding the Cask web framework as a dependency in a Mill build configuration via the 'build.sc' file. It defines a module that extends RootModule and ScalaModule, sets the Scala version, and includes Cask as an Ivy dependency. Ensure Mill and the Mill plugin for Scala are installed, and verify compatibility of both Scala and Cask versions for successful build execution.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-cask.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nobject example extends RootModule with ScalaModule {\n  def scalaVersion = \"3.4.2\"\n  def ivyDeps = Agg(\n    ivy\"com.lihaoyi::cask::0.10.2\"\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Secondary Constructor for Backward Binary Compatibility in Scala 3\nDESCRIPTION: This Scala 3 example shows how to add a secondary constructor to a case class to restore backward binary compatibility after changing the primary constructor signature, as an alternative to using a MiMa filter. The secondary constructor is marked as private and delegates to the new primary constructor. Inputs are previous constructor parameters; outputs ensure legacy usages remain supported.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/binary-compatibility-for-library-authors.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Person private (name: String, age: Int, address: Option[String]):\n  ...\n  // Add back the former primary constructor signature\n  private[Person] def this(name: String, age: Int) = this(name, age, None)\n```\n\n----------------------------------------\n\nTITLE: Porównywanie instancji case class według struktury w Scali\nDESCRIPTION: Prezentuje, że dwie instancje klasy przypadku są porównywane pod kątem równości ich wartości, a nie referencji w pamięci. Przykład ilustruje, że dwa obiekty z identycznymi wartościami parametrów są równe przy operatorze ==.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/case-classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncase class Message(sender: String, recipient: String, body: String)\n\nval message2 = Message(\"jorge@catalonia.es\", \"guillaume@quebec.ca\", \"Com va?\")\nval message3 = Message(\"jorge@catalonia.es\", \"guillaume@catalonia.ca\", \"Com va?\")\nval messagesAreTheSame = message2 == message3  // true\n```\n\n----------------------------------------\n\nTITLE: Defining an Abstract Iterator Class in Scala with Abstract Type and Methods\nDESCRIPTION: Defines an abstract class `AbsIterator` with an abstract type member `T` and two abstract methods `hasNext` (Boolean) and `next()` returning an element of type `T`. This sets up a template for iterator implementations where the element type is left open, allowing subclasses to specify the type. No dependencies beyond Scala abstract class syntax. Inputs are implementation-dependent, outputs include the abstract interface for iteration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/mixin-class-composition.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class AbsIterator {\n  type T\n  def hasNext: Boolean\n  def next(): T\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit `extends` in ADT Definition (Scala)\nDESCRIPTION: Shows the more explicit form of defining an ADT (`Option`) using Scala 3 `enum`, where each case explicitly specifies the type it extends. `None` extends `Option[Nothing]`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-adts-gadts.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nenum Option[+T]:\n  case Some(x: T) extends Option[T]\n  case None       extends Option[Nothing]\n```\n\n----------------------------------------\n\nTITLE: Creating an Anonymous Class in Scala\nDESCRIPTION: Illustrates the syntax for creating an anonymous class instance in Scala using the 'new' keyword directly with a class body instead of a named class. This is useful for quick on-the-fly subclasses or custom implementations without declaring a separate class. No explicit dependencies exist beyond the Scala language itself. The code snippet shows the typical structure, but contents inside are ellipsed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/cheatsheets/index.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nnew { ... }\n```\n\n----------------------------------------\n\nTITLE: Matching Case Classes with Guards (Scala 2)\nDESCRIPTION: Demonstrates using a `match` expression in Scala 2 to match against `case` classes, extract values (e.g., `name`), and use pattern guards (`if condition`) for more specific matching criteria. Includes a default case. Requires a `Person` case class definition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\nval p = Person(\"Fred\")\n\n// later in the code\np match {\n  case Person(name) if name == \"Fred\" =>\n    println(s\"$name says, Yubba dubba doo\")\n\n  case Person(name) if name == \"Bam Bam\" =>\n    println(s\"$name says, Bam bam!\")\n\n  case _ => println(\"Watch the Flintstones!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using Option in a for-comprehension with Set - Scala 2\nDESCRIPTION: Demonstrates how an Option can participate in a for-comprehension with another collection (Set), leveraging Option's implementation of IterableOnce. Requires Scala 2.x and standard library imports for Option and Set. The snippet yields the sum of elements in both collections, producing a Set[Int]. Inputs: Set(1), Option(41). Output: Set(42). Illustrates Option as an IterableOnce in Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/conversion-between-option-and-the-collections.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nfor {\n  a <- Set(1)\n  b <- Option(41)\n} yield (a + b)\n// : Set[Int] = Set(42)\n```\n\n----------------------------------------\n\nTITLE: Formatting Control Structures in Scala\nDESCRIPTION: This snippet demonstrates the correct and incorrect formatting of basic control structures such as if, for, and while in Scala. Correct usage requires a space after the defining keyword (if, for, while) followed by the condition or generator expression in parentheses. Incorrect forms omit the space, which is discouraged for readability. No additional dependencies apply.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/control-structures.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n// right!\nif (foo) bar else baz\nfor (i <- 0 to 10) { ... }\nwhile (true) { println(\"Hello, World!\") }\n\n// wrong!\nif(foo) bar else baz\nfor(i <- 0 to 10) { ... }\nwhile(true) { println(\"Hello, World!\") }\n```\n\n----------------------------------------\n\nTITLE: Match Type Pattern Abstract Syntax Definition in Scala\nDESCRIPTION: Defines the abstract syntax for match type patterns, showing the structure of patterns including types without captures, applied patterns with captures, type constructors, and different forms of type captures.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/match-types-spec.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// Top-level pattern\nMatchTypePattern ::= TypeWithoutCapture\n                   | MatchTypeAppliedPattern\n\n// A type that does not contain any capture, such as `Int` or `List[String]`\nTypeWithoutCapture ::= Type // `Type` is from the \"Internal types\" section of the spec\n\n// Applied type pattern with at least one capture, such as `List[Seq[t]]` or `*:[Int, t]`\nMatchTypeAppliedPattern ::= TyconWithoutCapture '[' MatchTypeSubPattern { ',' MatchTypeSubPattern } ']'\n\n// The type constructor of a MatchTypeAppliedPattern never contains any captures\nTyconWithoutCapture ::= Type\n\n// Type arguments can be captures, types without captures, or nested applied patterns\nMatchTypeSubPattern ::= TypeCapture\n                      | TypeWithoutCapture\n                      | MatchTypeAppliedPattern\n\nTypeCapture ::= NamedTypeCapture    // e.g., `t`\n              | WildcardTypeCapture // `_` (with inferred bounds)\n```\n\n----------------------------------------\n\nTITLE: Try-catch-finally exception handling in Scala\nDESCRIPTION: Demonstrates Scala's try-catch-finally construct for handling exceptions. Calls a method that writes text to a file and catches two specific exceptions: IOException and FileNotFoundException. The catch block uses pattern matching on exception types. Finally block prints a message regardless of exceptions. Illustrates idiomatic way to structure exceptions in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_50\n\nLANGUAGE: scala\nCODE:\n```\ntry\n  writeTextToFile(text)\ncatch\n  case ioe: IOException =>\n    println(ioe.getMessage)\n  case fnf: FileNotFoundException =>\n    println(fnf.getMessage)\nfinally\n  println(\"Finally\")\n```\n\n----------------------------------------\n\nTITLE: Defining a Book Structural Type in Scala 3\nDESCRIPTION: Example of creating another structural type Book with multiple fields representing book properties. This demonstrates the pattern for defining domain-specific structural types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-structural.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntype Book = Record {\n  val title: String\n  val author: String\n  val year: Int\n  val rating: Double\n}\n```\n\n----------------------------------------\n\nTITLE: Calling a Returned Greeting Function from greet() Method in Scala\nDESCRIPTION: Demonstrates usage in the Scala REPL where calling `greet()` returns a function assigned to `greetFunction`. The type of the returned function is confirmed as `String => Unit`. Then, the returned function is invoked with a name string to print a greeting message. Inputs include no parameters to `greet()` and a string argument to the returned function; outputs are console print statements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-write-method-returns-function.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval greetFunction = greet()\ngreetFunction(\"Joe\")   // prints \"Hello, Joe\"\n```\n\n----------------------------------------\n\nTITLE: Writing Output to Standard Out in Scala\nDESCRIPTION: Demonstrates how to write output to standard out (STDOUT) using println and print functions. The println function adds a newline character after the string, while print does not add a newline.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/command-line-io.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nprintln(\"Hello, world\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nprint(\"Hello without newline\")\n```\n\n----------------------------------------\n\nTITLE: Creating Collections with Literal Syntax in Scala\nDESCRIPTION: This example illustrates how high-level collection classes like 'Iterable', 'Map', 'Set', 'SortedSet', 'Buffer', 'IndexedSeq', and 'LinearSeq' can be instantiated using their constructors with elements specified as arguments. These instantiate collections with default implementations corresponding to their abstract types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/overview.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nIterable(\"x\", \"y\", \"z\")\nMap(\"x\" -> 24, \"y\" -> 25, \"z\" -> 26)\nSet(Color.red, Color.green, Color.blue)\nSortedSet(\"hello\", \"world\")\nBuffer(x, y, z)\nIndexedSeq(1.0, 2.0)\nLinearSeq(a, b, c)\n```\n\n----------------------------------------\n\nTITLE: Initializing a List for Demonstration\nDESCRIPTION: Creates a simple List of integers to be used in subsequent examples.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval a = List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Scala-to-Java One-Way Collection Conversions\nDESCRIPTION: This section lists Scala collection types (Seq, mutable.Seq, Set, Map) that can be converted to their corresponding Java interfaces (`java.util.List`, `java.util.Set`, `java.util.Map`) using `asJava`. However, converting them back using `asScala` might result in a different, mutable Scala type, not the original immutable one if applicable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/conversions-between-java-and-scala-collections.md#_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nSeq           =>    java.util.List\nmutable.Seq   =>    java.util.List\nSet           =>    java.util.Set\nMap           =>    java.util.Map\n```\n\n----------------------------------------\n\nTITLE: Handling Exceptions with try/catch/finally in Scala 2\nDESCRIPTION: Demonstrates Scala 2 syntax for exception handling using a `try/catch/finally` block. It attempts to call `openAndReadAFile` (assumed to be defined elsewhere), assigning the result to `text`. The `catch` block uses pattern matching to handle potential `FileNotFoundException` and `IOException`. The `finally` block ensures resource cleanup code is executed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\nvar text = \"\"\ntry {\n  text = openAndReadAFile(filename)\n} catch {\n  case fnf: FileNotFoundException => fnf.printStackTrace()\n  case ioe: IOException => ioe.printStackTrace()\n} finally {\n  // close your resources here\n  println(\"Came to the 'finally' clause.\")\n}\n```\n\n----------------------------------------\n\nTITLE: Example Scaladoc Output for Unexpected Successful Compilation\nDESCRIPTION: Shows the error message generated by Scaladoc when a code snippet marked with `sc:fail` compiles successfully, indicating a mismatch between the expected and actual behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/snippet-compiler.md#_snippet_6\n\nLANGUAGE: nohighlight\nCODE:\n```\n\nIn static site (./docs/docs/index.md):\nError: Snippet should not compile but compiled succesfully\n\n```\n\n----------------------------------------\n\nTITLE: Macro Implementation Example in Scala\nDESCRIPTION: This snippet provides an example implementation of a macro in Scala, demonstrating how to define macro logic in a macro implementation method. It shows the use of the macro context, handling arguments as 'c.Expr[T]', and conditionally generating code with quasiquotes. The implementation encodes the compile-time assertion logic by expanding into code that throws an AssertionError if the condition fails.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/overview.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.macros.Context\nimport scala.language.experimental.macros\n\nobject Asserts {\n  def raise(msg: Any) = throw new AssertionError(msg)\n  def assertImpl(c: Context)\n    (cond: c.Expr[Boolean], msg: c.Expr[Any]) : c.Expr[Unit] =\n     if (assertionsEnabled)\n        <[ if (!cond) raise(msg) ]>\n        else\n        <[ () ]>\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Lists in Python\nDESCRIPTION: Shows two Python 'for' loop syntax variants to iterate over elements in the list 'ints', printing each element. Demonstrates basic iteration with and without an empty newline for readability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nfor i in ints: print(i)\n\nfor i in ints:\n  print(i)\n```\n\n----------------------------------------\n\nTITLE: Adding library dependencies for Scastie snippets in scaladoc - Scala\nDESCRIPTION: Shows the syntax for defining additional sbt configurations to supply external library dependencies needed for Scastie snippet compilation in scaladoc. The example adds the Apache Commons Lang3 library dependency string via the `-scastie-configuration` option to include necessary external libraries for snippet evaluation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/settings.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n\"-scastie-configuration\", \"\"\"libraryDependencies += \\\"org.apache.commons\\\" % \\\"commons-lang3\\\" % \\\"3.12.0\\\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Scala Macros: Accessing Universe and Preparing for AST Generation (Scala)\nDESCRIPTION: Shows how to import the universe API from the macro context to access reflection facilities, which is customary for convenient manipulations of Scala AST nodes and types inside macro implementations. Importing `c.universe._` allows usage of various classes and methods that simplify abstract syntax tree creation and type handling during macro expansion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/overview.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport c.universe._\n```\n\n----------------------------------------\n\nTITLE: Reading File Line-by-Line as Sequence of Strings with OS-Lib in Scala\nDESCRIPTION: Reads the file at the given path into a sequence of lines using os.read.lines, providing each line as a separate String element in a Seq. This allows line-based processing such as searching or transformations. Requires the path variable to be an os.Path pointing to the file. Outputs a Seq[String] with each line from the file. Enables operations like finding the longest string element.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/os-read-file.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval lines: Seq[String]  = os.read.lines(path)\nprintln(lines.maxBy(_.size))\n// prints: antidisestablishmentarianism\n```\n\n----------------------------------------\n\nTITLE: Layout Template Example with Content Placeholder\nDESCRIPTION: Example of a main layout template that uses Liquid templating to insert content from individual pages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/static-site.md#_snippet_9\n\nLANGUAGE: html\nCODE:\n```\n<html>\n    <head>\n        <title>Hello, world!</title>\n    </head>\n    <body>\n        {{ content }}\n    </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Processing Successful Future Results with for-comprehension in Scala 2/3\nDESCRIPTION: Illustrates using a for-comprehension (syntactic sugar for `flatMap`/`foreach`) to process the result of a successfully completed `Future`. This is a concise way to handle only the success case, iterating through the list of posts obtained from the `Future` and printing each one. Failures are implicitly ignored by this structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_10\n\nLANGUAGE: Scala 2\nCODE:\n```\nval f: Future[List[String]] = Future {\n  session.getRecentPosts()\n}\n\nfor {\n  posts <- f\n  post <- posts\n} println(post)\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nval f: Future[List[String]] = Future {\n  session.getRecentPosts()\n}\n\nfor\n  posts <- f\n  post <- posts\ndo println(post)\n```\n\n----------------------------------------\n\nTITLE: Configuring ThreadPoolTaskSupport for Scala Parallel Collections\nDESCRIPTION: This snippet shows how to switch the task support of a parallel collection to use ThreadPoolTaskSupport instead of the default. It involves assigning a new ThreadPoolTaskSupport instance to the tasksupport property of the parallel collection. This option is considered less efficient than ForkJoinTaskSupport and mainly kept for backward compatibility with older JVM versions. The output is the parallel collection executing tasks on a thread pool executor.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/parallel-collections/configuration.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\npc.tasksupport = new ThreadPoolTaskSupport()\npc map { _ + 1 }\n```\n\n----------------------------------------\n\nTITLE: Output of `migrateScalacOptions` sbt Command\nDESCRIPTION: Shows the console output generated by running the `migrateScalacOptions main` command in sbt. The output categorizes the original `scalacOptions` into valid, renamed, and removed options for Scala 3 compatibility, guiding the user on necessary build file updates.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/scala3-migrate.md#_snippet_11\n\nLANGUAGE: text\nCODE:\n```\nsbt:main> migrateScalacOptions main\n[info] \n[info] Starting migration of scalacOptions in main\n[info] \n[info] <span style=\"color:green\">Valid scalacOptions:</span>\n[info] -encoding UTF-8\n[info] -Wunused:imports,privates,locals\n[warn] \n[warn] <span style=\"color:orange\">Renamed scalacOptions:</span>\n[warn] -target:jvm-1.8 -> <span style=\"color:orange\">-Xunchecked-java-output-version:8</span>\n[warn] -explaintypes   -> <span style=\"color:orange\">-explain</span>\n[warn] \n[warn] <span style=\"color:orange\">Removed scalacOptions:</span>\n[warn] -Xsource:3\n[warn] -Yrangepos\n[success] Total time: 0 s, completed Aug 29, 2023 2:00:57 PM\n```\n\n----------------------------------------\n\nTITLE: Applying Java Annotation with Named Arguments in Scala Mixing Styles\nDESCRIPTION: This snippet presents a Scala annotation usage example applying the '@SourceURL' annotation with a positional argument for 'value' and a named argument for 'mail'. Unlike Java which does not support mixing positional and named elements in annotation parameters, Scala allows this flexibility. This illustrates Scala’s more expressive annotation usage allowing combination of positional and named arguments to enhance clarity and reduce verbosity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/annotations.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\n@SourceURL(\"https://coders.com/\",\n           mail = \"support@coders.com\")\n    class MyScalaClass ...\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Method Without ClassTag (Scala)\nDESCRIPTION: Defines a generic method `wrap` that attempts to pass a `Vector` of type parameter `U` to another method (`evenElems`) which requires a `ClassTag[U]`. This snippet demonstrates the compile error encountered when the required `ClassTag` is not explicitly provided or made implicitly available for `U` within the method's scope.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/arrays.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nscala> def wrap[U](xs: Vector[U]) = evenElems(xs)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n<console>:6: error: No ClassTag available for U.\n         def wrap[U](xs: Vector[U]) = evenElems(xs)\n                                               ^\n```\n\n----------------------------------------\n\nTITLE: Defining a Scala Abstract Class with Concrete and Abstract Methods\nDESCRIPTION: This Scala code defines an abstract class 'Pet' which takes a 'name' constructor parameter. It includes a concrete method 'speak' with a default implementation and an abstract method 'comeToMaster' that lacks an implementation and must be defined by any concrete subclass.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/abstract-classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Pet (name: String) {\n    def speak(): Unit = println(\"Yo\")   // concrete implementation\n    def comeToMaster(): Unit            // abstract method\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Elements in ArrayBuffer\nDESCRIPTION: Shows how to add, remove, and update elements in an ArrayBuffer using methods like +=, ++=, -=, --=, and the update method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-classes.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\n// Adding elements\nval nums = ArrayBuffer(1, 2, 3)   // ArrayBuffer(1, 2, 3)\nnums += 4                         // ArrayBuffer(1, 2, 3, 4)\nnums ++= List(5, 6)               // ArrayBuffer(1, 2, 3, 4, 5, 6)\n\n// Removing elements\nval a = ArrayBuffer.range('a', 'h')   // ArrayBuffer(a, b, c, d, e, f, g)\na -= 'a'                              // ArrayBuffer(b, c, d, e, f, g)\na --= Seq('b', 'c')                   // ArrayBuffer(d, e, f, g)\na --= Set('d', 'e')                   // ArrayBuffer(f, g)\n\n// Updating elements\nval a = ArrayBuffer.range(1,5)        // ArrayBuffer(1, 2, 3, 4)\na(2) = 50                             // ArrayBuffer(1, 2, 50, 4)\na.update(0, 10)                       // ArrayBuffer(10, 2, 50, 4)\n```\n\n----------------------------------------\n\nTITLE: Scala Class with Private Members and Getter/Setter Methods\nDESCRIPTION: Shows a class 'Point' with private mutable variables _x and _y, along with getter and setter methods for controlled access and validation. Includes a private method to print warnings when bounds are exceeded, illustrating encapsulation and data hiding.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/classes.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nclass Point {\n  private var _x = 0\n  private var _y = 0\n  private val bound = 100\n\n  def x = _x\n  def x_= (newValue: Int): Unit = {\n    if (newValue < bound) _x = newValue else printWarning\n  }\n\n  def y = _y\n  def y_= (newValue: Int): Unit = {\n    if (newValue < bound) _y = newValue else printWarning\n  }\n\n  private def printWarning = println(\"WARNING: Out of bounds\")\n}\n\nval point1 = new Point\npoint1.x = 99\npoint1.y = 101 // warning output\n```\n\n----------------------------------------\n\nTITLE: Running sbt test command for ScalaTest execution\nDESCRIPTION: Example output from running the 'sbt test' command that executes a test suite containing a single test for the CubeCalculator.cube function. Shows the successful test run with timing information.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/getting-started/sbt-track/testing-scala-with-sbt-on-the-command-line.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsbt test\n[info] Loading global plugins from /Users/username/.sbt/0.13/plugins\n[info] Loading project definition from /Users/username/workspace/sandbox/my-something-project/project\n[info] Set current project to scalatest-example (in build file:/Users/username/workspace/sandbox/my-something-project/)\n[info] CubeCalculatorTest:\n[info] - CubeCalculator.cube\n[info] Run completed in 267 milliseconds.\n[info] Total number of tests run: 1\n[info] Suites: completed 1, aborted 0\n[info] Tests: succeeded 1, failed 0, canceled 0, ignored 0, pending 0\n[info] All tests passed.\n[success] Total time: 1 s, completed Feb 2, 2017 7:37:31 PM\n```\n\n----------------------------------------\n\nTITLE: Displaying Internal Tree Structure with showRaw in Scala\nDESCRIPTION: This snippet uses showRaw to print the internal, fully expanded representation of a Tree. This output exposes the compiler-level details and nested tree nodes as understood by the Scala typechecker. The main input is a Tree; showRaw outputs a String with the raw tree structure, facilitating debugging or understanding complex ASTs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\nshowRaw(tree)\n```\n\n----------------------------------------\n\nTITLE: GADT example using enum in Scala 3\nDESCRIPTION: This snippet models a GADT 'Box' with type parameter 'T' and cases 'IntBox' and 'BoolBox' holding an 'Int' and 'Boolean', respectively. The 'extract' method performs pattern matching, returning an 'Int' or 'Boolean' based on the constructor, exemplifying advanced type-safe data modeling.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-adts-gadts.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nenum Box[T](contents: T):\n  case IntBox(n: Int) extends Box[Int](n)\n  case BoolBox(b: Boolean) extends Box[Boolean](b)\n\ndef extract[T](b: Box[T]): T = b match\n  case IntBox(n)  => n + 1\n  case BoolBox(b) => !b\n```\n\n----------------------------------------\n\nTITLE: Correctly Skipping Leading Empty Strings with BufferedIterator in Scala\nDESCRIPTION: This snippet demonstrates the correct way to skip leading empty strings using a `BufferedIterator[String]`. The `head` method allows checking if the next element is empty without advancing the iterator. The iterator is only advanced using `it.next()` when an empty string is found, ensuring the loop stops *before* consuming the first non-empty string.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/iterators.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ndef skipEmptyWords(it: BufferedIterator[String]) =\n  while (it.head.isEmpty) { it.next() }\n```\n\n----------------------------------------\n\nTITLE: Adding a Dependency to build.sbt in Scala using sbt\nDESCRIPTION: This snippet demonstrates how to include an external library dependency in the sbt build configuration for your Scala project. It uses the `libraryDependencies` setting and the `+=` operator to add the 'scala-parser-combinators' library version 1.1.2, enabling its use in Scala source files. This helps extend functionality by integrating third-party libraries.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/getting-started/intellij-track/building-a-scala-project-with-intellij-and-sbt.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nlibraryDependencies += \"org.scala-lang.modules\" %% \"scala-parser-combinators\" % \"1.1.2\"\n```\n\n----------------------------------------\n\nTITLE: Generic Signature of the `map` Method in Scala Collections\nDESCRIPTION: Presents the generic signature of the `map` method as defined in `scala.collection.TraversableLike`. It highlights the type parameters `A` (element type), `Repr` (collection type), `B` (result element type), and `That` (result collection type). The implicit `CanBuildFrom[Repr, B, That]` parameter (`cbf`) is crucial as it determines the type (`That`) of the collection returned by `map`, enabling type-preserving or type-changing transformations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-collections.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\ndef map[B, That](f: A => B)\n  (implicit cbf: CanBuildFrom[Repr, B, That]): That\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Scala Compile-Time Constants with scala.reflect.runtime.universe - Scala\nDESCRIPTION: Illustrates pattern matching on scala.reflect.runtime.universe.Constant objects wrapping various literal types (String, Boolean, others). Uses a match expression to handle different constant types and access their underlying values, verifying the equality of the value method output to the raw literal.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/annotations-names-scopes.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nConstant(true) match {\n  case Constant(s: String)  => println(\"A string: \" + s)\n  case Constant(b: Boolean) => println(\"A Boolean value: \" + b)\n  case Constant(x)          => println(\"Something else: \" + x)\n}\nassert(Constant(true).value == true)\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom String Interpolator using StringContext\nDESCRIPTION: Explains how to create user-defined string interpolators by extending 'StringContext' with implicit classes. In this example, a 'json' interpolator is implemented to parse embedded JSON literals and expressions, transforming the interpolated string into a JSON object. It demonstrates customizing string processing for domain-specific languages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/string-interpolation.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit class JsonHelper(val sc: StringContext) extends AnyVal {\n  def json(args: Any*): JSONObject = sys.error(\"TODO - IMPLEMENT\")\n}\n\ndef giveMeSomeJson(x: JSONObject): Unit = ...\n\ngiveMeSomeJson(json\"{ name: $name, id: $id }\")\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit class JsonHelper(val sc: StringContext) extends AnyVal {\n  def json(args: Any*): JSONObject = {\n    val strings = sc.parts.iterator\n    val expressions = args.iterator\n    var buf = new StringBuilder(strings.next())\n    while(strings.hasNext) {\n      buf.append(expressions.next())\n      buf.append(strings.next())\n    }\n    parseJson(buf)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Matched Patterns - Scala 3\nDESCRIPTION: Shows how to bind a matched pattern to a variable (`p @ Phone(model)`) using Scala 3 syntax while simultaneously extracting fields (`model`). This allows using the bound variable (`p`) to access type-specific members (`p.screenOff`) alongside extracted fields. Requires the input type and its subtypes to be defined (like `Device`, `Phone`, `Computer`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/pattern-matching.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ndef goIdleWithModel(device: Device): String = device match\n  case p @ Phone(model) => s\"$model: ${p.screenOff}\"\n  case c @ Computer(model) => s\"$model: ${c.screenSaverOn}\"\n```\n\n----------------------------------------\n\nTITLE: Creating Actors Explicitly Using a Lazy View in Scala\nDESCRIPTION: This Scala code snippet shows how to achieve lazy evaluation explicitly using the `view` method on a range within a `for` comprehension. The `actor { ... }` block will only be executed, and actors created, when the resulting `actors` view is forced or iterated over. This mimics the pre-Scala 2.8 behavior where ranges were implicitly lazy.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/views.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\nval actors = for (i <- (1 to 10).view) yield actor { ... }\n```\n\n----------------------------------------\n\nTITLE: Trivial If/Else Expressions Inline in Scala\nDESCRIPTION: This snippet shows the preferred style for brief if/else expressions that are used as short conditional expressions within larger expressions in Scala. Since Scala lacks a ternary operator, placing the then and else branches on the same line as if and else keywords is acceptable for conciseness and readability. This style should only be used for pure expressions and never with imperative if statements or braces.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/control-structures.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval res = if (foo) bar else baz\n```\n\n----------------------------------------\n\nTITLE: Complete Transformation of Value Class Usage in Scala\nDESCRIPTION: This code shows the final transformation of value class operations after all 4 steps of the erasure process. It demonstrates how variables, assignments, method calls, and type operations are converted to their optimized form.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/value-classes.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nvar m, n: Meter           var m, n: Double\nvar o: Any                var o: Any\nm = n                     m = n\no = m                     o = new Meter(m)\nm.print                   new Meter(m).print\nm less n                  Meter.extension$less(m, n)\nm.toString                Meter.extension$toString(m)\nm.isInstanceOf[Ordered]   new Meter(m).isInstanceOf[Ordered]\nm.asInstanceOf[Ordered]   new Meter(m).asInstanceOf[Ordered]\no.isInstanceOf[Meter]     o.isInstanceOf[Meter]\no.asInstanceOf[Meter]     o.asInstanceOf[Meter].underlying\nm.isInstanceOf[Meter]     new Meter(m).isInstanceOf[Meter]\nm.asInstanceOf[Meter]     m.asInstanceOf[Double]\n```\n\n----------------------------------------\n\nTITLE: Checking Membership in Scala Immutable Set - Scala\nDESCRIPTION: Demonstrates how to create an immutable Set of strings and test membership of elements using the apply method or contains method. The snippet shows that calling set(elem) returns a Boolean indicating presence of elem within the set, with true if present and false otherwise. There are no external dependencies beyond Scala's immutable collections framework.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/sets.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval fruit = Set(\"apple\", \"orange\", \"peach\", \"banana\")\nfruit(\"peach\")\nfruit(\"potato\")\n```\n\n----------------------------------------\n\nTITLE: Обзор и использование Vector в Scala\nDESCRIPTION: Описание структуры данных Vector — сбалансированного дерева, обеспечивающего эффективный доступ и обновление элементов в произвольных позициях. Включает примеры создания, добавления и обращения к элементам, а также техническое описание внутренней реализации.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/concrete-immutable-collection-classes.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val vec = scala.collection.immutable.Vector.empty\nvec: scala.collection.immutable.Vector[Nothing] = Vector()\nscala> val vec2 = vec :+ 1 :+ 2\nvec2: scala.collection.immutable.Vector[Int] = Vector(1, 2)\nscala> val vec3 = 100 +: vec2\nvec3: scala.collection.immutable.Vector[Int] = Vector(100, 1, 2)\nscala> vec3(0)\nres1: Int = 100\n```\n\n----------------------------------------\n\nTITLE: Creating and Connecting Nodes within a Graph in Scala\nDESCRIPTION: Demonstrates usage of the Graph and Node classes by instantiating a new Graph, creating nodes, and connecting them. This snippet builds a sample graph structure, highlighting the incremental addition and connection of nodes within the same graph instance. It requires the Graph and Node classes defined earlier, and it produces no output but modifies graph state accordingly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/inner-classes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef graphTest: Unit = {\n  val g = new Graph\n  val n1 = g.newNode\n  val n2 = g.newNode\n  val n3 = g.newNode\n  n1.connectTo(n2)\n  n3.connectTo(n1)\n}\n```\n\n----------------------------------------\n\nTITLE: Definicija traitova Cloneable i Resetable u Scalaj\nDESCRIPTION: Ovaj kod prikazuje definiciju dva traita, `Cloneable` koji proširuje Java interfejs i overrid-uje metodu `clone()`, i `Resetable` koji definiše metodu `reset`. Trait `Cloneable` omogućava kloniranje objekta, dok `Resetable` pruža funkcionalnost resetovanja stanja objekta.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/compound-types.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Cloneable extends java.lang.Cloneable {\n  override def clone(): Cloneable = {\n    super.clone().asInstanceOf[Cloneable]\n  }\n}\ntrait Resetable {\n  def reset: Unit\n}\n```\n\n----------------------------------------\n\nTITLE: Inheriting Scala MapOps Template Trait\nDESCRIPTION: Illustrates how the concrete `Map` trait extends `Iterable` and mixes in the `MapOps` trait. This mixin pattern allows `Map` to inherit and utilize the specialized transformation operations defined in `MapOps` by correctly instantiating its type parameters `CC[_, _]` and `C` with `Map` and `Map[K, V]`, respectively.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_9\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\ntrait Map[K, V] extends Iterable[(K, V)]\n  with MapOps[K, V, Map, Map[K, V]]\n```\n\n----------------------------------------\n\nTITLE: Updating and Filtering a Mutable Map in Scala\nDESCRIPTION: This snippet highlights two operations: updating an existing entry by assigning a new value to a key (replacing the state's value), and filtering the Map in-place using 'filterInPlace' to retain only pairs matching a condition. Inputs: mutable Map, new value, and filtering function. Operations mutate the original Map directly. Requires Scala 2.13 or later for filterInPlace.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/collections-maps.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nstates(\"AK\") = \"Alaska, The Big State\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\nstates.filterInPlace((k,v) => k == \"AK\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Companion Object for Opaque Type Logarithm in Scala\nDESCRIPTION: Implements the companion object for the opaque type Logarithm providing necessary API methods for lifting from Double (apply, safe), unlifting to Double (exponent), and defining extension methods (toDouble, +, *) for arithmetic operations. The companion is essential for making the opaque type useful by exposing and controlling conversions and operations internally while enforcing external opacity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/opaque-types.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\npackage object opaquetypes {\n  // The previous opaque type definition\n  opaque type Logarithm = Double\n\n  object Logarithm {\n    // These are the ways to lift to the logarithm type\n    def apply(d: Double): Logarithm = math.log(d)\n\n    def safe(d: Double): Option[Logarithm] =\n      if (d > 0.0) Some(math.log(d)) else None\n\n    // This is the first way to unlift the logarithm type\n    def exponent(l: Logarithm): Double = l\n\n    // Extension methods define opaque types' public APIs\n    implicit class LogarithmOps(val `this`: Logarithm) extends AnyVal {\n      // This is the second way to unlift the logarithm type\n      def toDouble: Double = math.exp(`this`)\n      def +(that: Logarithm): Logarithm = Logarithm(math.exp(`this`) + math.exp(that))\n      def *(that: Logarithm): Logarithm = Logarithm(`this` + that)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Opaque Type Logarithm with Arithmetic in Scala 3\nDESCRIPTION: Introduces an opaque type alias Logarithm to Double inside the Logarithms object. The opaque type is only equal to Double within the object scope, providing fully encapsulated implementation details outside this scope. This pattern enables defining arithmetic operations and conversion methods as extension methods for the Logarithm type. Users outside the object cannot access the underlying Double directly, enforcing abstraction while eliminating boxing overhead and runtime cost.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-opaque-types.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nobject Logarithms:\n//vvvvvv this is the important difference!\n  opaque type Logarithm = Double\n\n  object Logarithm:\n    def apply(d: Double): Logarithm = math.log(d)\n\n  extension (x: Logarithm)\n    def toDouble: Double = math.exp(x)\n    def + (y: Logarithm): Logarithm = Logarithm(math.exp(x) + math.exp(y))\n    def * (y: Logarithm): Logarithm = x + y\n```\n\n----------------------------------------\n\nTITLE: 정의 및 출력: 다양한 타입 포함 리스트 생성 - Scala\nDESCRIPTION: 다양한 스칼라 타입(문자열, 정수, 문자, 불리언, 함수)을 포함하는 List[Any] 값을 정의하고, 리스트 내 각 요소를 순회하며 출력하는 예제입니다. 이 코드는 스칼라에서 모든 값이 객체임을 보여줍니다. 의존성은 스칼라 표준 라이브러리이며, List 타입의 다형성 사용과 함수 리터럴 표현을 포함합니다. 입력은 리스트 내 다양한 타입의 값들이며 출력은 각 값의 문자열 표현입니다.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/unified-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval list: List[Any] = List(\n  \"a string\",\n  732,  // 정수 값\n  'c',  // 문자 값\n  true, // boolean 값\n  () => \"an anonymous function returning a string\"\n)\n\nlist.foreach(element => println(element))\n```\n\n----------------------------------------\n\nTITLE: Abstract Iterator Class in Scala 3\nDESCRIPTION: Defines an abstract class AbsIterator with an abstract type T and abstract methods for iteration in Scala 3 syntax, using indentation instead of braces.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/mixin-class-composition.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nabstract class AbsIterator:\n  type T\n  def hasNext: Boolean\n  def next(): T\n```\n\n----------------------------------------\n\nTITLE: Specifying output directory with scaladoc command\nDESCRIPTION: Use the scaladoc command with the -d flag to specify a custom output directory for the generated documentation. This helps organize the HTML files in a dedicated location.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scaladoc/generate.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ scaladoc -d build/ src/main/scala/App.scala\n```\n\n----------------------------------------\n\nTITLE: Removing Elements from Scala mutable Set using -= and --= Methods in Scala\nDESCRIPTION: Illustrates deleting elements from a mutable Set using -= for removing one or multiple variadic elements, and --= for removing multiple elements provided as another sequence. This snippet includes examples with single and bulk element removal, showing how the set updates accordingly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/set-class.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval set = scala.collection.mutable.Set(1, 2, 3, 4, 5)\nset -= 1\nset -= (2, 3)\nset --= Array(4,5)\n```\n\n----------------------------------------\n\nTITLE: Overloading the apply Method in the Companion Object to Support Additional Fields in Scala 3\nDESCRIPTION: This Scala 3 snippet implements overloaded apply methods in the Person companion object, supporting both the legacy and the new constructor signature which includes the address field. Parameters match the new and old field sets for compatibility. Dependencies are a suitably designed Person class. This enables users to initialize all values in one call and preserves source/binary compatibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/binary-compatibility-for-library-authors.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nobject Person:\n  // Original public constructor\n  def apply(name: String, age: Int): Person = new Person(name, age, None)\n  // Additional constructor that also sets the address\n  def apply(name: String, age: Int, address: String): Person =\n    new Person(name, age, Some(address))\n```\n\n----------------------------------------\n\nTITLE: Blocking on a Simple Future Value - Scala\nDESCRIPTION: Shows how to block on a Future containing a constant value using the blocking function with a specified timeout duration. This pattern synchronously retrieves the result (here, integer 1) of a future. Dependencies: scala.concurrent._ and a suitable execution context. Inputs: a Future to block on; outputs: the resolved value or error if unresolved. Use only when absolutely necessary, as blocking can degrade performance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/futures-promises.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nval f = Future { 1 }\nval one: Int = blocking(f, 0 ns)\n```\n\n----------------------------------------\n\nTITLE: External Mapping Configuration Example in Scala 3\nDESCRIPTION: Example of how to configure external documentation mappings in Scala 3. This syntax allows linking to external Scaladoc and Javadoc references using regular expressions to match fully qualified names.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/scaladoc-settings-compatibility.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n-external-mappings:.*scala.*::scaladoc3::https://scala-lang.org/api/3.x/,.*java.*::javadoc::https://docs.oracle.com/javase/8/docs/api/\n```\n\n----------------------------------------\n\nTITLE: Example Compilation Error Output\nDESCRIPTION: This text block shows the typical error message produced by the Scala compiler when attempting to call `toMap` on a `List[Int]`. It highlights the type mismatch, indicating that `Int` cannot be proven to be a subtype of `(K, V)` (a key-value tuple).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/snippet-compiler.md#_snippet_4\n\nLANGUAGE: nohighlight\nCODE:\n```\nAt 18:21:\n  List(1,2,3).toMap\nError: Cannot prove that Int <:< (K, V)\n\nwhere:    K is a type variable with constraint \n          V is a type variable with constraint \n.\n```\n\n----------------------------------------\n\nTITLE: BeanProperty Methods Visibility in Scala 2\nDESCRIPTION: Shows how @BeanProperty-generated getter and setter methods were accessible in Scala 2 code but are intentionally invisible in Scala 3 as they're meant for Java interoperability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-other-changes.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nclass Pojo() {\n  @BeanProperty var fooBar: String = \"\"\n}\n\nval pojo = new Pojo()\n\npojo.setFooBar(\"hello\") // [E008] In Scala 3, Not Found Error: value setFooBar is not a member of Pojo\n\nprintln(pojo.getFooBar()) // [E008] In Scala 3, Not Found Error: value getFooBar is not a member of Pojo\n```\n\n----------------------------------------\n\nTITLE: Benchmarking sequential reduce with Scala immutable Vector\nDESCRIPTION: Defines a Scala benchmark object `ReduceSeq` to measure the performance of sequential reduction (summation) over an immutable Vector collection. It uses JVM system property for the collection length. The `run` method carries out a reduce operation summing elements sequentially. This snippet serves as a baseline comparison to the parallel Reduce benchmark and depends on Scala's immutable Vector collection. Input is the vector length; output is the sum of all elements. It illustrates standard sequential reduce usage and performance measurement.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/parallel-collections/performance.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject ReduceSeq extends testing.Benchmark {\n  val length = sys.props(\"length\").toInt\n  val vector = collection.immutable.Vector((0 until length): _*)\n\n  def run = {\n    vector reduce {\n      (a, b) => a + b\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Parallel TrieMap with Concurrent Modifications in Scala\nDESCRIPTION: Demonstrates creating a ParTrieMap and modifying it during traversal to calculate square roots using Newton's method. ParTrieMap provides consistent traversal even when the data structure is modified during iteration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/parallel-collections/concrete-parallel-collections.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval numbers = scala.collection.parallel.mutable.ParTrieMap((1 until 100) zip (1 until 100): _*) map { case (k, v) => (k.toDouble, v.toDouble) }\nnumbers: scala.collection.parallel.mutable.ParTrieMap[Double,Double] = ParTrieMap(0.0 -> 0.0, 42.0 -> 42.0, 70.0 -> 70.0, 2.0 -> 2.0,...\n\nwhile (numbers.nonEmpty) {\n  numbers foreach { case (num, sqrt) =>\n    val nsqrt = 0.5 * (sqrt + num / sqrt)\n    numbers(num) = nsqrt\n    if (math.abs(nsqrt - sqrt) < 0.01) {\n      println(num, nsqrt)\n      numbers.remove(num)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Self Type Usage in Trait for Enforcing Mix-ins\nDESCRIPTION: This snippet illustrates the Scala 3 syntax for self types within traits. It defines similar functionality as the Scala 2 example, requiring that classes mixing in the `Tweeter` trait must also extend `User`. The syntax for self type annotations uses the `this: User =>` form, but within Scala 3's trait declaration style.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/self-types.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntrait User:\n  def username: String\n\ntrait Tweeter:\n  this: User =>  // self-type annotation\n  def tweet(tweetText: String) = println(s\"$username: $tweetText\")\n\nclass VerifiedTweeter(val username_ : String) extends Tweeter, User:  // Mixes in User as per self type requirement\n  def username = s\"real $username_\"\n\nval realBeyoncé = VerifiedTweeter(\"Beyoncé\")\nrealBeyoncé.tweet(\"Just spilled my glass of lemonade\")  // outputs: real Beyoncé: Just spilled my glass of lemonade\n```\n\n----------------------------------------\n\nTITLE: Computing Symbolic Derivatives of Expression Trees with Pattern Matching and Guards in Scala\nDESCRIPTION: Implements a function derivada that computes the symbolic derivative of an arithmetic expression tree with respect to a given variable name. It recursively applies differentiation rules using pattern matching: sums are differentiated term-wise, variables yield Const(1) if matching the differentiation variable or Const(0) otherwise (enforced via a pattern guard), and all other expressions default to Const(0). Pattern guards and wildcards enable precise matching and default cases respectively.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tutorials/scala-for-java-programmers.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\ndef derivada(a: Arbol, v: String): Arbol = a match {\n  case Sum(l, r) => Sum(derivada(l, v), derivada(r, v))\n  case Var(n) if (v == n) => Const(1)\n  case _ => Const(0)\n}\n```\n\n----------------------------------------\n\nTITLE: Interacting with a Synchronized Scala Map in REPL\nDESCRIPTION: Shows example usage of the synchronized map created by `MapMaker.makeMap` within the Scala REPL. It demonstrates initializing the map, adding multiple elements using `++`, retrieving values for existing and non-existent keys (triggering the overridden `default` method), adding a single element using `+=`, and retrieving the newly added element. Output from the REPL is included.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/maps.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nscala> val capital = MapMaker.makeMap  \ncapital: scala.collection.mutable.Map[String,String] = Map()\nscala> capital ++ List(\"US\" -> \"Washington\",\n        \"France\" -> \"Paris\", \"Japan\" -> \"Tokyo\")\nres0: scala.collection.mutable.Map[String,String] =\n  Map(France -> Paris, US -> Washington, Japan -> Tokyo)\nscala> capital(\"Japan\")\nres1: String = Tokyo\nscala> capital(\"New Zealand\")\nres2: String = Why do you want to know?\nscala> capital += (\"New Zealand\" -> \"Wellington\")\nscala> capital(\"New Zealand\")                    \nres3: String = Wellington\n```\n\n----------------------------------------\n\nTITLE: Using Pattern Type Variables in Quoted Code in Scala Macros\nDESCRIPTION: This snippet illustrates matching expressions with pattern type variables (`t`) inside quotes, capturing the runtime type of matched expressions. It shows how to construct expressions dynamically with the captured types, enabling more flexible macro code that reacts to code structure and type information without static constraints.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\ndef exprOptionToList(x: Expr[Option[Any]])(using Quotes): Option[Expr[List[Any]]] =\n  x match\n    case '{ Some($x: t) } =>\n      // ^^^ this binds the type `t` in the body of the case\n      Some('{ List[t]($x) }) // x: Expr[List[t]]\n    case '{ None } =>\n      Some('{ Nil })\n    case _ => None\n\n// Pattern to get precise type of an expression\nval expr: Expr[Option[Int]] = ...\nexpr match\n  case '{ $expr: tpe } =>\n    Type.show[tpe] // e.g., Option[Int]\n    '{ val x: tpe = $expr; x } // value with precise type\n```\n\n----------------------------------------\n\nTITLE: Using PizzaService Methods in Scala 2\nDESCRIPTION: Demonstrates importing and using the PizzaService implementation in Scala 2, showing the complete workflow of pizza creation and modification.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-fp.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport PizzaService._\n\nval p = Pizza(Small, Thin, Seq(Cheese))\n\n// использование методов PizzaService\nval p1 = addTopping(p, Pepperoni)\nval p2 = addTopping(p1, Onions)\nval p3 = updateCrustType(p2, Thick)\nval p4 = updateCrustSize(p3, Large)\n\nprintln(price(p4)) // печатает 8.75\n```\n\n----------------------------------------\n\nTITLE: Initializing File Path with OS-Lib in Scala\nDESCRIPTION: Defines a file path using OS-Lib's Path type by chaining directory names. The path points to a file typically found on UNIX-like systems, using the root directory and subdirectories to locate the target file. This snippet serves as the foundation for subsequent file reading operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/os-read-file.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval path: os.Path = os.root / \"usr\" / \"share\" / \"dict\" / \"words\"\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Case Class Instances with Typed Patterns in Scala 3\nDESCRIPTION: This Scala 3 snippet shows matching a Person instance using typed pattern syntax. It is suitable where the unapply extractor method is private for compatibility reasons. The code requires an existing Person object ('alice') and yields the 'name' attribute. Inputs are the Person instance, and outputs are the corresponding field values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/binary-compatibility-for-library-authors.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nalice match\n  case person: Person => person.name\n```\n\n----------------------------------------\n\nTITLE: Inlining Example with Abstract Inline Method Call in Scala\nDESCRIPTION: Shows the inlining process for `logged(new PrintLogger, \"🥧\")`. First, the `logged` function is inlined. This makes the concrete type `PrintLogger` known for `logger`, allowing the call `logger.log(x)` to be devirtualized and the `PrintLogger.log` implementation to be inlined.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nlogged(new PrintLogger, \"🥧\")\n// inlined as\nval logger = new PrintLogger\nval x = \"🥧\"\nlogger.log(x)\n```\n\n----------------------------------------\n\nTITLE: Importing Implied Instances in Scala\nDESCRIPTION: This Scala import statement demonstrates the syntax for importing implied instances, which is a proposed language feature under discussion. The 'import implied' keyword combination would bring only implied (implicit) definitions into scope, helping to make such imports more explicit and manageable in codebases. This helps address issues of import clarity and implicit instance visibility, but may require a compatible compiler supporting this syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/minutes/2019-03-13-sip-minutes.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nimport implied\n```\n\n----------------------------------------\n\nTITLE: Using Scala Package Object Members via Wildcard Import\nDESCRIPTION: Imports all members of the gardening.fruits package (including those defined in the package object) and uses them inside the PrintPlanted object. It iterates over the planted list and calls showFruit for each fruit, demonstrating how package object members behave like regular package members and can be imported and accessed seamlessly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/package-objects.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n// in file PrintPlanted.scala\nimport gardening.fruits._\nobject PrintPlanted {\n  def main(args: Array[String]): Unit = {\n    for (fruit <- planted) {\n      showFruit(fruit)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using `inline match` for Compile-Time Pattern Matching in Scala\nDESCRIPTION: Defines an inline function `half` that uses `inline match`. This construct performs pattern matching at compile time based on the *static type* of the scrutinee (`x`), which must be an inline parameter or value. Only the matching branch is kept in the generated code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\ninline def half(x: Any): Any =\n  inline x match\n    case x: Int => x / 2\n    case x: String => x.substring(0, x.length / 2)\n```\n\n----------------------------------------\n\nTITLE: Scala値クラスに汎用トレイトを拡張する例\nDESCRIPTION: 値クラスが`Printable`のような汎用トレイトを拡張した例。`Printable`は`Any`を拡張し、`print`メソッドを持つ。値クラスは`with`を用いてトレイトを実装できるが、インスタンス化時にオーバーヘッドが生じる可能性がある。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/value-classes.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Printable extends Any {\n  def print(): Unit = println(this)\n}\nclass Wrapper(val underlying: Int) extends AnyVal with Printable\n```\n\n----------------------------------------\n\nTITLE: Running an Interactive Scala Program Expecting User Input (Bash)\nDESCRIPTION: This bash snippet demonstrates running the `helloInteractive` Scala application, which pauses execution to prompt the user for their name. The shell input cursor `▌` indicates waiting for user input. After the user types the name and presses Enter, the program outputs a personalized greeting. This execution requires prior compilation with `scalac` and run via the `scala` launcher.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-hello-world.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ scala helloInteractive\nPlease enter your name:\n▌\n```\n\n----------------------------------------\n\nTITLE: Tuple Literals and Destructuring Assignment - Scala\nDESCRIPTION: Defines tuple creation and destructuring assignment via pattern matching. Inputs: tuples of values. Outputs: individual variable assignments. Warns against incorrect tuple unpacking which binds all variables to the whole tuple.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\n(1,2,3)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nvar (x,y,z) = (1,2,3)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nvar x,y,z = (1,2,3)\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Classes in Scala\nDESCRIPTION: Examples of basic class definitions in Scala with constructor parameters as mutable fields.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-tools.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Person(var name: String, var vocation: String)\nclass Book(var title: String, var author: String, var year: Int)\nclass Movie(var name: String, var director: String, var year: Int)\n```\n\n----------------------------------------\n\nTITLE: Non-Curried Syntax for foldLeft in Scala\nDESCRIPTION: This example shows how foldLeft can be invoked with a non-curried (single parameter list) syntax, where both the initial value and the binary operation are supplied in one go. While technically correct, this approach is less idiomatic in Scala and loses some type inference benefits compared to multiple parameter lists. Inputs are the list and an explicit anonymous function; output is the sum result. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/multiple-parameter-lists.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nnumbers.foldLeft(0, {(m: Int, n: Int) => m + n})\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Graph Structure in Scala\nDESCRIPTION: This Scala snippet defines an abstract class `Graph` representing a generic graph structure with abstract type members `Node` and `Edge`. The nested abstract class `NodeIntf` defines a contract for nodes with a `connectWith` method to connect nodes via edges. The class declares abstract members to access nodes and edges collections, and a method `addNode` to add new nodes. This structure allows concrete implementations to specify exact types for nodes and edges, facilitating extensibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/self-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Graph {\n  type Edge\n  type Node <: NodeIntf\n  abstract class NodeIntf {\n    def connectWith(node: Node): Edge\n  }\n  def nodes: List[Node]\n  def edges: List[Edge]\n  def addNode: Node\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Trait in Scala\nDESCRIPTION: A minimal trait definition in Scala, using just the keyword 'trait' followed by an identifier.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/traits.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait HairColor\n```\n\n----------------------------------------\n\nTITLE: Using 'raw' Interpolator to Ignore Escape Sequences in Scala\nDESCRIPTION: Introduces the `raw` interpolator, which is similar to `s` but does *not* process escape sequences like `\\n`. Escape sequences are treated as literal characters within the resulting string.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/string-interpolation.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nscala> raw\"a\\nb\"\nres1: String = a\\nb\n```\n\n----------------------------------------\n\nTITLE: Calling a Transparent Inline Function and Observing Type Refinement in Scala\nDESCRIPTION: Demonstrates calling the `transparent inline` function `default`. Although the function's declared return type is `Any`, the variables `n0` and `s0` are correctly typed as `Int` and `String`, respectively, because the `transparent` nature allows the compiler to use the more precise type determined after inlining.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\nval n0: Int = default(\"Int\")\nval s0: String = default(\"String\")\n```\n\n----------------------------------------\n\nTITLE: Restrictions on Named Tuples - Duplicate Element Names\nDESCRIPTION: Shows an illegal pattern where duplicate element names are used in a named tuple. Each element name in a named tuple must be unique.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-tuples.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval illFormed2 = (name = \"\", age = 0, name = true)  // error\n```\n\n----------------------------------------\n\nTITLE: Configuring scaladoc options in sbt build file - Scala\nDESCRIPTION: This snippet shows how to provide scaladoc generation settings such as output directory and project name within an sbt build definition. The settings adjust `Compile / doc / target` to specify the output folder for generated documentation and `Compile / doc / scalacOptions` to pass arguments like project name to scaladoc. These settings enable documenting the code with appropriate metadata from the sbt build process.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/settings.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nCompile / doc / target := file(\"output\"),\nCompile / doc / scalacOptions ++= Seq(\"-project\", \"my-project\")\n```\n\n----------------------------------------\n\nTITLE: Standard Macro Method Signature with Expr and Quotes in Scala\nDESCRIPTION: Provides the canonical macro method signature pattern where only Expr, Type, and Quotes are mentioned in the method signature, while reflection internals are used inside the method body after importing `quotes.reflect.*`. This pattern supports hiding internal reflection details from macro users and helps maintain a clean API.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/reflection.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: Expr[Int])(using Quotes): Expr[Int] =\n  import quotes.reflect.*\n  ...\n```\n\n----------------------------------------\n\nTITLE: Converting Mutable Collections between Scala and Java\nDESCRIPTION: This Scala REPL session shows practical examples of collection conversion. It imports `collection.mutable._`, converts a Scala `ArrayBuffer` to a `java.util.List` using `asJava`, converts it back to a Scala `Seq` using `asScala`, and converts a Scala `HashMap` to a `java.util.Map` using `asJava`. It relies on the prior import of `collection.JavaConverters._`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/conversions-between-java-and-scala-collections.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> import collection.mutable._\nimport collection.mutable._\n\nscala> val jul: java.util.List[Int] = ArrayBuffer(1, 2, 3).asJava\njul: java.util.List[Int] = [1, 2, 3]\n\nscala> val buf: Seq[Int] = jul.asScala\nbuf: scala.collection.mutable.Seq[Int] = ArrayBuffer(1, 2, 3)\n\nscala> val m: java.util.Map[String, Int] = HashMap(\"abc\" -> 1, \"hello\" -> 2).asJava\nm: java.util.Map[String,Int] = {abc=1, hello=2}\n```\n\n----------------------------------------\n\nTITLE: Creating a Sized Mutable ArrayBuffer in Scala\nDESCRIPTION: Shows how to initialize a mutable `ArrayBuffer` with a specific initial capacity (100,000 in this example) using `new ArrayBuffer[Type](initialSize)`. This can potentially improve performance when the approximate size is known.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\n// ready to hold 100,000 ints\nval buf = new ArrayBuffer[Int](100_000)\n```\n\n----------------------------------------\n\nTITLE: Building Strings with StringBuilder in Scala 2\nDESCRIPTION: Illustrates creating a `StringBuilder` in Scala 2 using `new StringBuilder`, appending a character with `+=`, appending a string with `++=`, and finally converting it to a `String` using `toString`. This is useful for efficient string construction.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-mutable-collection-classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> val buf = new StringBuilder\nbuf: StringBuilder = \nscala> buf += 'a'\nres38: buf.type = a\nscala> buf ++= \"bcdef\"\nres39: buf.type = abcdef\nscala> buf.toString\nres41: String = abcdef\n```\n\n----------------------------------------\n\nTITLE: Defining Scala SortedSetOps Template Trait\nDESCRIPTION: Defines the `SortedSetOps` trait, a template for sorted collections with one type parameter like `SortedSet[A]`. It extends `IterableOps` and provides a specialized `map` method that requires an implicit/using `Ordering` for the result type `B`. This trait allows sorted set types to inherit common sorted operations while extending basic iterable functionality.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_12\n\nLANGUAGE: Scala 2\nCODE:\n```\ntrait SortedSetOps[A, +CC[_], +C] extends IterableOps[A, Set, C] {\n  def map[B](f: A => B)(implicit ord: Ordering[B]): CC[B] = …\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ntrait SortedSetOps[A, +CC[_], +C] extends IterableOps[A, Set, C]:\n  def map[B](f: A => B)(using ord: Ordering[B]): CC[B] = …\n```\n\n----------------------------------------\n\nTITLE: Running Cask Server Example (Build Tools)\nDESCRIPTION: Provides command-line instructions for starting the Cask web server application defined in the previous example. The specific command depends on the build tool being used: Scala CLI, sbt, or Mill. These commands should be executed in the terminal within the project directory, assuming the standard project structure described in the static file tutorial.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/web-server-dynamic.md#_snippet_1\n\nLANGUAGE: Scala CLI\nCODE:\n```\nscala-cli run Example.scala\n```\n\nLANGUAGE: sbt\nCODE:\n```\nsbt example/run\n```\n\nLANGUAGE: Mill\nCODE:\n```\n./mill run\n```\n\n----------------------------------------\n\nTITLE: Deconstructing Method Parameters without Implicits in Scala\nDESCRIPTION: Confirms that the quasiquote pattern for separating implicit parameters works correctly even when the method has no implicit parameter list. In this case, `implparams` is extracted as an empty list from `def g(x: Int)(y: Int) = x + y`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/definition-details.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"def g(...$paramss)(implicit ..$implparams) = $rhs\" =\n           q\"def g(x: Int)(y: Int) = x + y\"\nparamss: List[List[universe.ValDef]] = List(List(val x: Int = _), List(val y: Int = _))\nimplparams: List[universe.ValDef] = List()\nbody: universe.Tree = x.$plus(y)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Standalone `map` Method for `List[Int]` in Scala\nDESCRIPTION: Combines the complete method signature and the `for` expression body to create a standalone `map` function specifically tailored for `List[Int]`. This function takes a transformation function `f` (which converts an `Int` to type `A`) and a `List[Int]`, returning a new `List[A]` containing the transformed elements. Includes versions for both Scala 2 and Scala 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-write-map-function.md#_snippet_5\n\nLANGUAGE: Scala 2\nCODE:\n```\ndef map[A](f: (Int) => A, xs: List[Int]): List[A] =\n  for (x <- xs) yield f(x)\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ndef map[A](f: (Int) => A, xs: List[Int]): List[A] =\n  for x <- xs yield f(x)\n```\n\n----------------------------------------\n\nTITLE: Creating an ExecutionContext from a Java Executor in Scala 2 and 3\nDESCRIPTION: Shows how to adapt a Java Executor or a Java ThreadPoolExecutor into a Scala ExecutionContext using ExecutionContext.fromExecutor. This enables configuring custom thread pools for futures, providing flexibility for blocking or specialized use cases. The snippet exhibits concise syntax differences between Scala 2 and Scala 3. No additional dependencies beyond the standard Scala and JDK concurrency libraries are required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nExecutionContext.fromExecutor(new ThreadPoolExecutor( /* your configuration */ ))\n```\n\nLANGUAGE: scala\nCODE:\n```\nExecutionContext.fromExecutor(ThreadPoolExecutor( /* your configuration */ ))\n```\n\n----------------------------------------\n\nTITLE: Initializing and Modifying an Immutable TreeSet in Scala\nDESCRIPTION: Illustrates creating an empty immutable `TreeSet` for `Int` elements using `TreeSet.empty[Int]` and adding elements (1, 3) using the `+` operator. `TreeSet` automatically maintains elements in sorted order and ensures uniqueness; adding '3' twice has no additional effect. It is based on Red-Black Trees.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-immutable-collection-classes.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nscala> scala.collection.immutable.TreeSet.empty[Int]\nres11: scala.collection.immutable.TreeSet[Int] = TreeSet()\nscala> res11 + 1 + 3 + 3\nres12: scala.collection.immutable.TreeSet[Int] = TreeSet(1, 3)\n```\n\n----------------------------------------\n\nTITLE: Creating a Comparable Date Class with Ord Trait in Scala\nDESCRIPTION: Implementation of a Date class that extends the Ord trait, providing comparison functionality between dates by overriding equals method and implementing the required less-than method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_de/tutorials/scala-for-java-programmers.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass Date(y: Int, m: Int, d: Int) extends Ord {\n  def year  = y\n  def month = m\n  def day   = d\n\n  override def toString = year + \"-\" + month + \"-\" + day\n\n  override def equals(that: Any): Boolean =\n    that.isInstanceOf[Date] && {\n      val o = that.asInstanceOf[Date]\n      o.day == day && o.month == month && o.year == year\n    }\n\n  def <(that: Any): Boolean = {\n    if (!that.isInstanceOf[Date])\n      sys.error(\"cannot compare \" + that + \" and a Date\")\n\n    val o = that.asInstanceOf[Date]\n    (year < o.year) ||\n    (year == o.year && (month < o.month ||\n                       (month == o.month && day < o.day)))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering List Elements Using Anonymous Functions in Scala\nDESCRIPTION: Demonstrates use of the List class's filter method with different anonymous function syntaxes to generate filtered lists. Inputs: List[Int] named ints. Examples show filtering all elements greater than 5, less than 5, and even values via the modulus operator. Output: List[Int] with elements satisfying the predicate. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/anonymous-functions.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval x = ints.filter(_ > 5)\nval x = ints.filter(_ < 5)\nval x = ints.filter(_ % 2 == 0)\n```\n\n----------------------------------------\n\nTITLE: Analysis of Scala Macro System Proposals in SIP-28 and SIP-29\nDESCRIPTION: This snippet discusses the development of inline methods and meta-programming features in Scala, including macro implementations, experimental tools integration, and API considerations. It references the macro system's evolution in Dotty and IntelliJ support, aiming to improve debugability and compile-time code expansion. Dependencies include Scala macro API and tooling support.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/minutes/2016-11-29-sip-minutes.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nN/A\n```\n\n----------------------------------------\n\nTITLE: Accessing Structural Member Without Explicit Type in Scala 3\nDESCRIPTION: Attempting to access bar on foo in Scala 3 triggers a compilation error because, without explicit structural typing, foo is inferred as type Object, which does not contain bar. This snippet illustrates a limitation of Scala 3's default type inference regarding reflective calls. No extra dependencies are required; inputs are variable usage; output is a compiler error.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-type-inference.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nfoo.bar // Error: value bar is not a member of Object\n```\n\n----------------------------------------\n\nTITLE: Expressing Compound and Structural Types Via Quasiquotes - Scala\nDESCRIPTION: Demonstrates creation and decomposition of compound (types with multiple parents) and structural (refinement-only) types. Uses pattern matching to extract parent types and definitions. Prerequisite: Scala macro universe imports. Inputs: compound or structural type quasiquotes; outputs: lists of parent trees or member definitions ('parents', 'defns').\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/type-details.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval compound = tq\"A with B with C\"\nval tq\"..$parents { ..$defns }\" = compound\nval structural = tq\"{ val x: Int; val y: Int }\"\nval tq\"{ ..$defns }\" = structural\n```\n\n----------------------------------------\n\nTITLE: Defining Lambda Functions Without Parenthesized Parameters - Scala\nDESCRIPTION: This snippet shows a lambda assigned to 'f' where the parameter is typed but not parenthesized, valid in Scala 2.13 but a syntax error in Scala 3. The function multiplies an integer by itself. No external dependencies are required, and this pattern is only invalid when a parameter is typed without parentheses in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-syntactic.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval f = { x: Int => x * x } // In Scala 3, Error: parentheses are required around the parameter of a lambda.\n```\n\n----------------------------------------\n\nTITLE: Constructing Literal Quasiquotes - Scala\nDESCRIPTION: Demonstrates how to create AST nodes for various Scala built-in literals using quasiquotes. This includes integer, floating point, boolean, character, string, symbol, null, and unit literals. Most literals result in a `Literal` AST node, except symbols.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nq\"1\", q\"1L\"              // integer literals\nq\"1.0f\", q\"1.0\", q\"1.0d\" // floating point literals\nq\"true\", q\"false\"        // boolean literals\nq\"'c'\"                   // character literal\nq\"\"\" \"string\" \"\"\"        // string literal\nq\"'symbol\"               // symbol literal\nq\"null\"                  // null literal\nq\"()\"                    // unit literal\n```\n\n----------------------------------------\n\nTITLE: Desugaring Rules for Simple `for`-`yield` Expressions in Scala\nDESCRIPTION: Defines two desugaring rules for `for`-`yield` expressions. The first rule optimizes `for (P <- G) yield P` directly to `G` if `P` is a variable or tuple of variables and `G` is not a `withFilter` result. The second rule is the standard desugaring `for (P <- G) yield E` to `G.map(P => E)` for all other cases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\n  for (P <- G) yield P  ==>  G\nIf P is a variable or a tuple of variables and G is not a withFilter.\n\n  for (P <- G) yield E  ==>  G.map (P => E)\nOtherwise\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Hello World Program in Scala\nDESCRIPTION: This snippet shows how to declare a singleton object with a main method in Scala to print 'Hello, world!'. It demonstrates the use of 'object' for singleton patterns, the 'main' method structure, and the 'println' function. Dependencies include Scala compiler. Inputs are command-line arguments; output is the greeting message.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tutorials/scala-for-java-programmers.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject HelloWorld {\n  def main(args: Array[String]): Unit = {\n    println(\"Hello, world!\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Scala Parallel Collections Combiner Trait\nDESCRIPTION: Shows the definition of the `Combiner` trait, analogous to `Builder` in sequential collections. It defines a `combine` method used to merge results from parallel computations, producing a single combined `Combiner`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/architecture.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Combiner[Elem, To] extends Builder[Elem, To] {\n\tdef combine(other: Combiner[Elem, To]): Combiner[Elem, To]\n}\n```\n\n----------------------------------------\n\nTITLE: Definiowanie klas przypadków w Scali\nDESCRIPTION: Pokazuje minimalną definicję klasy przypadku z pojedynczym parametrem, oraz tworzenie jej instancji bez potrzeby używania słowa kluczowego \"new\" dzięki metodzie apply. Używany parametr jest publiczny i niemutowalny (val).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/case-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Book(isbn: String)\n\nval frankenstein = Book(\"978-0486282114\")\n```\n\n----------------------------------------\n\nTITLE: Using Companion Object Methods in Scala\nDESCRIPTION: Example showing how to create a Pizza instance and calculate its price using the companion object's price method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-fp.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval pizza1 = Pizza(Small, Thin, Seq(Cheese, Onions))\nPizza.price(pizza1)\n```\n\n----------------------------------------\n\nTITLE: Matching Numerical Ranges with if Guards in Scala match Expressions\nDESCRIPTION: Provides an example of using `if` guards combined with the `contains` method on `Range` objects (`0 to 9`, `10 to 19`, etc.) to match integer values falling within specific numerical ranges within a `match` expression. Shows syntax for Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_27\n\nLANGUAGE: Scala 2\nCODE:\n```\ni match {\n  case a if 0 to 9 contains a => println(s\"0-9 range: $a\")\n  case b if 10 to 19 contains b => println(s\"10-19 range: $b\")\n  case c if 20 to 29 contains c => println(s\"20-29 range: $c\")\n  case _ => println(\"Hmmm...\")\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ni match\n  case a if 0 to 9 contains a => println(s\"0-9 range: $a\")\n  case b if 10 to 19 contains b => println(s\"10-19 range: $b\")\n  case c if 20 to 29 contains c => println(s\"20-29 range: $c\")\n  case _ => println(\"Hmmm...\")\n```\n\n----------------------------------------\n\nTITLE: Combining Named Parameters with Default Values in Scala\nDESCRIPTION: This example shows how named parameters can be combined with default parameter values. Using named parameters allows skipping parameters with default values, even if they appear first in the parameter list.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/named-arguments.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef imprimeNome(nome:String = \"John\", sobrenome:String = \"Smith\") = {\n  println(nome + \" \" + sobrenome)\n}\n\nimprimeNome(sobrenome = \"Forbeck\") // Imprime \"John Forbeck\"\n```\n\n----------------------------------------\n\nTITLE: Simplified Multiple Assignment Syntax Alternative in Scala\nDESCRIPTION: This snippet shows a simplified alternative syntax for multiple assignments in Scala, using flat sequences separated by commas without parentheses. It swaps values of 'a' and 'b'. Though easier to parse, this approach limits expressiveness compared to tuple-based multiple assignments and may impact potential use cases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/multiple-assignments.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\na, b = b, a\n```\n\n----------------------------------------\n\nTITLE: Anonymous Implementation and Factory with Abstract Types - Scala 3\nDESCRIPTION: Mirrors the Scala 2 version, implementing 'IntSeqBuffer' with 'U = Int' and 'newIntSeqBuf' as a factory producing an anonymous implementation with 'T = List[U]'. The example demonstrates usage via instantiation, length and content printing. Written with Scala 3 syntax and requires standard collection types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/abstract-type-members.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class IntSeqBuffer extends SeqBuffer:\n  type U = Int\n\ndef newIntSeqBuf(elem1: Int, elem2: Int): IntSeqBuffer =\n  new IntSeqBuffer:\n    type T = List[U]\n    val element = List(elem1, elem2)\n\nval buf = newIntSeqBuf(7, 8)\nprintln(\"length = \" + buf.length)\nprintln(\"content = \" + buf.element)\n```\n\n----------------------------------------\n\nTITLE: Defining the Unliftable Trait in Scala\nDESCRIPTION: Defines the Unliftable trait, which provides an unapply method to attempt to extract a value of type T from a syntax tree (Tree). The return type is an Option[T] to handle cases where the tree does not represent the desired value. This trait allows instances to act as extractors in pattern matching against Trees representing Scala code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/unlifting.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Unliftable[T] {\n  def unapply(tree: Tree): Option[T]\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Scala 3 Pattern Matching Types\nDESCRIPTION: Defines a Scala 3 function `pattern` using the newer concise syntax. It takes a `Matchable` input and employs a `match` expression to showcase different pattern types (constant, sequence, tuple, constructor - assuming `Person` and `Dog` case classes exist, and type test). It returns a string describing the match or 'Unknown' by default.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\ndef pattern(x: Matchable): String = x match\n\n  // constant patterns\n  case 0 => \"zero\"\n  case true => \"true\"\n  case \"hello\" => \"you said 'hello'\"\n  case Nil => \"an empty List\"\n\n  // sequence patterns\n  case List(0, _, _) => \"a 3-element list with 0 as the first element\"\n  case List(1, _*) => \"list, starts with 1, has any number of elements\"\n  case Vector(1, _*) => \"vector, starts w/ 1, has any number of elements\"\n\n  // tuple patterns\n  case (a, b) => s\"got $a and $b\"\n  case (a, b, c) => s\"got $a, $b, and $c\"\n\n  // constructor patterns\n  case Person(first, \"Alexander\") => s\"Alexander, first name = $first\"\n  case Dog(\"Zeus\") => \"found a dog named Zeus\"\n\n  // type test patterns\n  case s: String => s\"got a string: $s\"\n  case i: Int => s\"got an int: $i\"\n  case f: Float => s\"got a float: $f\"\n  case a: Array[Int] => s\"array of int: ${a.mkString(\",\")}\"\n  case as: Array[String] => s\"string array: ${as.mkString(\",\")}\"\n  case d: Dog => s\"dog: ${d.name}\"\n  case list: List[?] => s\"got a List: $list\"\n  case m: Map[?, ?] => m.toString\n\n  // the default wildcard pattern\n  case _ => \"Unknown\"\n```\n\n----------------------------------------\n\nTITLE: Resetting Scope with mdoc:reset in Scala\nDESCRIPTION: Shows the use of the `mdoc:reset` modifier in a Scala code block. This modifier clears the compilation context, effectively forgetting all definitions (like the `now` method and the initial `Foo` object) from preceding snippets. This allows redefinition (like `case class Foo(a: String)`) without conflict.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/add-guides.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:reset\ncase class Foo(a: String) // forget the previous Foo's and start fresh\n```\n```\n\n----------------------------------------\n\nTITLE: Reading Entire File Content as String with OS-Lib in Scala\nDESCRIPTION: Reads the entire content of the file specified by the given os.Path into a single String using OS-Lib's os.read method. Requires the path variable to be properly defined as an os.Path. The input is a valid file path, and the output is the complete file content as a string. This operation loads the whole file into memory, which may be inefficient for large files.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/os-read-file.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval content: String = os.read(path)\n```\n\n----------------------------------------\n\nTITLE: Importing Implicit Conversions ('given') in Scala 3\nDESCRIPTION: Shows various ways to import `given` implicit conversions defined in an object (`Conversions`) in Scala 3. Options include importing the specific given instance by name (`import Conversions.fromStringToUser`), importing all givens (`import Conversions.given`), or importing givens of a specific type (`import Conversions.{given Conversion[String, User]}`). Note that Scala 3's standard wildcard import (`*`) does not import `given` definitions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-implicit-conversions.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport Conversions.fromStringToUser\n// or\nimport Conversions.given\n// or\nimport Conversions.{given Conversion[String, User]}\n```\n\n----------------------------------------\n\nTITLE: Performing Range Queries on SortedSet in Scala\nDESCRIPTION: This snippet shows how to perform range-based operations on a Scala TreeSet, including retrieving elements within a specified range with the 'range' method and all elements from a starting point with 'rangeFrom'. These methods return new sorted sets that maintain the original ordering property.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/sets.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nres4: scala.collection.immutable.TreeSet[String] = TreeSet(one, three)\nres5: scala.collection.immutable.TreeSet[String] = TreeSet(three, two)\n```\n\n----------------------------------------\n\nTITLE: Defining filter Operation for List and Map Traits in Scala 3\nDESCRIPTION: This snippet brings the filter method definitions for List and Map to Scala 3 syntax, using parameterized type signatures and concise formatting. Both traits feature a filter function appropriate to their element structures: A for List and (K, V) for Map. The focus is on strengthening abstraction and code reuse.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ntrait List[A]:\n  def filter(p: A => Boolean): List[A]\n\ntrait Map[K, V]:\n  def filter(p: ((K, V)) => Boolean): Map[K, V]\n```\n\n----------------------------------------\n\nTITLE: Matching Return Quasiquotes - Scala\nDESCRIPTION: Demonstrates pattern matching on a `return` expression using quasiquotes. The pattern `q\"return $expr\"` matches a return statement and extracts the tree representing the value being returned into the `$expr` variable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"return $expr\" = ret\nexpr: universe.Tree = 2.$plus(2)\n```\n\n----------------------------------------\n\nTITLE: Filtering List Elements Using for/yield with Guards in a Scala Method\nDESCRIPTION: Defines a method `between3and10` that accepts a `List[Int]` and returns a new `List[Int]` containing only the elements between 3 and 10 (inclusive). It uses a `for` expression with `if` guards as the method body to filter the elements. Shows syntax for both Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_20\n\nLANGUAGE: Scala 2\nCODE:\n```\ndef between3and10(xs: List[Int]): List[Int] =\n  for {\n    x <- xs\n    if x >= 3\n    if x <= 10\n  } yield x\n\nbetween3and10(List(1, 3, 7, 11))   // : List[Int] = List(3, 7)\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ndef between3and10(xs: List[Int]): List[Int] =\n  for\n    x <- xs\n    if x >= 3\n    if x <= 10\n  yield x\n\nbetween3and10(List(1, 3, 7, 11))   // : List[Int] = List(3, 7)\n```\n\n----------------------------------------\n\nTITLE: Simplifying Explicit Type Variable References in Quoted Expressions - Scala Diff\nDESCRIPTION: Shows the proposed change to remove the requirement for backticks (` `) when referencing explicit type variables (`u`) within Scala quoted expression patterns, improving consistency with external references.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/quote-pattern-type-variable-syntax.md#_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/old_code b/new_code\nindex abcdef1..1234567 new mode 100644\n--- a/old_code\n+++ b/new_code\n@@ -1,1 +1,1 @@\n- case '{ type u; ($ls: List[`u`]).map($f: `u` => Int) } => g[u](ls: Expr[List[u]], f: Expr[u => Int])\n+ case '{ type u; ($ls: List[u]).map($f: u => Int) } => g[u](ls: Expr[List[u]], f: Expr[u => Int])\n```\n\n----------------------------------------\n\nTITLE: Adding sttp Core Dependency with Mill - Scala\nDESCRIPTION: This snippet demonstrates how to add a single sttp core dependency (version 4.0.0-RC1) in Mill using the Ivy notation. Add this line to the appropriate place in your build.sc file, typically within ivyDeps of a ScalaModule definition. This is useful for excluding the rest of the toolkit and only adding sttp.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-sttp.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nivy\"com.softwaremill.sttp.client4::core:4.0.0-RC1\"\n```\n\n----------------------------------------\n\nTITLE: Algebraic Data Type of Option in Scala 3\nDESCRIPTION: This snippet models the 'Option' type as an enum with two cases: 'Some' with a value and 'None' without. It showcases pattern matching and methods (e.g., 'isDefined') within the enum, illustrating how ADTs can encapsulate optional values with behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-adts-gadts.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nenum Option[+T]:\n  case Some(x: T)\n  case None\n\n  def isDefined: Boolean = this match\n    case None => false\n    case Some(_) => true\n\nobject Option:\n  def apply[T >: Null](x: T): Option[T] =\n    if (x == null) None else Some(x)\n```\n\n----------------------------------------\n\nTITLE: Head Method in Scala Collections\nDESCRIPTION: Examples of using the head method to access the first element of a collection, with special attention to handling empty collections using headOption for safer functional programming.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-methods.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\noneToTen.head   // 1\nnames.head      // adam\n```\n\nLANGUAGE: scala\nCODE:\n```\n\"foo\".head // 'f'\n\"bar\".head // 'b'\n```\n\nLANGUAGE: scala\nCODE:\n```\nval emptyList = List[Int]()   // emptyList: List[Int] = List()\nemptyList.head                // java.util.NoSuchElementException: head of empty list\n```\n\nLANGUAGE: scala\nCODE:\n```\nemptyList.headOption          // None\n```\n\n----------------------------------------\n\nTITLE: Definición de iterador abstracto en Scala\nDESCRIPTION: Define una clase abstracta `AbsIterator` que establece la interfaz básica para un iterador, declarando un tipo abstracto `T` y los métodos `hasNext` y `next()`. Esta clase sirve como base para la composición de iteradores concretos y es requerida para ser extendida por otros traits o clases que implementen su funcionalidad.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/mixin-class-composition.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class AbsIterator {\n  type T\n  def hasNext: Boolean\n  def next(): T\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Class and its Companion Object in Scala\nDESCRIPTION: Illustrates defining a class `IntPair` and its companion object `IntPair` within the same source file. The companion object provides an implicit `Ordering` instance for the `IntPair` class, which is a common pattern for typeclass instances in Scala. Companion objects and classes must be defined in the same file and can access each other's private members.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/singleton-objects.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass IntPair(val x: Int, val y: Int)\n\nobject IntPair {\n  import math.Ordering\n\n  implicit def ipord: Ordering[IntPair] =\n    Ordering.by(ip => (ip.x, ip.y))\n}\n```\n\n----------------------------------------\n\nTITLE: Adding sbt-ghpages Plugin for Publishing - Scala\nDESCRIPTION: Adds the sbt-ghpages plugin dependency to 'project/plugins.sbt', enabling GitHub Pages publishing for sbt sites. Requires 'sbt' and correct project folder structure. Input: plugin coordinates; Output: enhanced sbt with gh-pages tasks available. Limitation: Only supports sbt builds using the standard plugin system.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\naddSbtPlugin(\"com.github.sbt\" % \"sbt-ghpages\" % \"0.8.0\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Navigation Pager with HTML and Liquid in Scala Docs\nDESCRIPTION: This snippet creates a navigation pager with conditional Previous and Next buttons. It uses Liquid templating to check if previous-page or next-page variables exist before rendering the corresponding navigation links, complete with directional arrow indicators.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/pager.txt#_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<nav>\n  <div class=\"pager\">\n  {% if page.previous-page %}\n      <div class=\"previous\"><a href=\"{{ page.previous-page }}.html\"\"><span aria-hidden=\"true\">&larr;</span> Previous</a></div>\n   {% endif %}\n   {% if page.next-page %}\n      <div class=\"next\"><a href=\"{{ page.next-page }}.html\">Next <span aria-hidden=\"true\">&rarr;</span></a></div>\n   {% endif %}\n  </div>\n</nav>\n```\n\n----------------------------------------\n\nTITLE: Defining a complex Scala method with multiple interleaved type and term parameters\nDESCRIPTION: This snippet shows a complex Scala method 'foo' with multiple interleaved type parameters, 'using' clauses, and term parameters, illustrating the proposed syntax for generalizing method signatures. It highlights how various parameter lists can be combined in a single method signature for increased flexibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/clause-interleaving.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef foo[A](using a: A)(b: List[A])[C <: a.type, D](cd: (C, D))[E]: Foo[A, B, C, D, E]\n```\n\n----------------------------------------\n\nTITLE: Configuring sbt for kind-projector cross-compilation (Scala)\nDESCRIPTION: Sets up `scalacOptions` in an sbt build to conditionally apply the correct compiler flags for enabling underscore type lambdas and `?` wildcards when cross-compiling between Scala 2.12/2.13 and Scala 3. It uses pattern matching on the `scalaVersion` to apply version-specific flags.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/plugin-kind-projector.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nThisBuild / scalacOptions ++= {\n  CrossVersion.partialVersion(scalaVersion.value) match {\n    case Some((3, _)) => Seq(\"-Ykind-projector:underscores\")\n    case Some((2, 12 | 13)) => Seq(\"-Xsource:3\", \"-P:kind-projector:underscore-placeholders\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating deprecated method migration using diff syntax (Scala)\nDESCRIPTION: This diff snippet illustrates the recommended migration for a deprecated API method by changing its visibility from public deprecated to private within a package scope. It shows how to alter method visibility to avoid binary compatibility issues by removing the public annotation while keeping the method accessible for binary compatibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/binary-api.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n- @deprecated(...) def myOldAPI: T = ...\n+ private[C] def myOldAPI: T = ...\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Address Class with Optional Field Using Option[String] (Scala 2 and 3)\nDESCRIPTION: This class declaration improves the design by using Option[String] for the street2 field to explicitly express optionality. This eliminates nulls by requiring street2 to be Some(value) or None. It enables safer handling of missing data and clearer code semantics. The snippet depends on Scala's Option class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-functional-error-handling.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nclass Address(\n  var street1: String,\n  var street2: Option[String],   // an optional value\n  var city: String, \n  var state: String, \n  var zip: String\n)\n```\n\n----------------------------------------\n\nTITLE: Defining the BuildFrom Trait for Scala 2 and 3\nDESCRIPTION: Provides the definition of the `scala.collection.BuildFrom` trait (formerly `CanBuildFrom`), which is designed for creating new collections based on a source collection. It includes `fromSpecific` and `newBuilder` methods, both taking the source collection (`From`) as a parameter, enabling type preservation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collection-operations.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ntrait BuildFrom[-From, -A, +C] {\n  /** @return a collection of type `C` containing the same elements\n    * (of type `A`) as the source collection `it`.\n    */\n  def fromSpecific(from: From)(it: IterableOnce[A]): C\n\n  /** @return a Builder for the collection type `C`, containing\n    * elements of type `A`.\n    */\n  def newBuilder(from: From): Builder[A, C]\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntrait BuildFrom[-From, -A, +C]:\n  /** @return a collection of type `C` containing the same elements\n    * (of type `A`) as the source collection `it`.\n    */\n  def fromSpecific(from: From)(it: IterableOnce[A]): C\n\n  /** @return a Builder for the collection type `C`, containing\n    * elements of type `A`.\n    */\n  def newBuilder(from: From): Builder[A, C]\n```\n\n----------------------------------------\n\nTITLE: Creating Collections with for/yield in Scala\nDESCRIPTION: Demonstrates using a `for` expression with `yield` to iterate over a range (10 to 12) and produce a new `IndexedSeq` (specifically a `Vector`) containing each number multiplied by 2. This is distinct from `for` loops used solely for side effects. Shows syntax for both Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_17\n\nLANGUAGE: Scala 2\nCODE:\n```\nval list =\n  for (i <- 10 to 12)\n  yield i * 2\n\n// list: IndexedSeq[Int] = Vector(20, 22, 24)\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nval list =\n  for i <- 10 to 12\n  yield i * 2\n\n// list: IndexedSeq[Int] = Vector(20, 22, 24)\n```\n\n----------------------------------------\n\nTITLE: Implementing a custom while loop using by-name parameters in Scala\nDESCRIPTION: This snippet shows how to implement a recursive 'whileLoop' function that mimics the behavior of a traditional while loop, using by-name parameters 'condition' and 'body' to delay their evaluation until necessary. It highlights how by-name parameters facilitate defining control flow constructs in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/by-name-parameters.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef whileLoop(condition: => Boolean)(body: => Unit): Unit =\n  if (condition) {\n    body\n    whileLoop(condition)(body)\n  }\n\nvar i = 2\n\nwhileLoop(i > 0) {\n  println(i)\n  i -= 1\n}  // prints 2 1\n```\n\n----------------------------------------\n\nTITLE: Defining Fruit Classes and Objects in Scala\nDESCRIPTION: This snippet defines the `Fruit` case class with name and color properties, along with three singleton fruit objects (`Apple`, `Plum`, and `Banana`) extending the `Fruit` class. It is intended to establish fruit entities within the `gardening.fruits` package as the data model for further use.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/package-objects.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\npackage gardening.fruits\n\ncase class Fruit(name: String, color: String)\nobject Apple extends Fruit(\"Apple\", \"green\")\nobject Plum extends Fruit(\"Plum\", \"blue\")\nobject Banana extends Fruit(\"Banana\", \"yellow\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating @tailrec failure on non-tail-recursive method in Scala\nDESCRIPTION: Shows that applying the `@tailrec` annotation to a method that is not tail-recursive will cause a compilation error (e.g., \"Recursive call not in tail position\"). This demonstrates the compiler's strict enforcement of the annotation's condition. Requires importing `scala.annotation.tailrec`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/annotations.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.annotation.tailrec\n\ndef factorial(x: Int): Int = {\n  @tailrec\n  def factorialHelper(x: Int): Int = {\n    if (x == 1) 1 else x * factorialHelper(x - 1)\n  }\n  factorialHelper(x)\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.annotation.tailrec\n\ndef factorial(x: Int): Int =\n  @tailrec\n  def factorialHelper(x: Int): Int =\n    if x == 1 then 1 else x * factorialHelper(x - 1)\n  factorialHelper(x)\n```\n\n----------------------------------------\n\nTITLE: Abstract Contravariant Printer Class Definition in Scala - scala\nDESCRIPTION: Defines an abstract generic class Printer contravariant in type parameter A. It contains one abstract method print accepting a value of type A. This demonstrates the syntax and semantic of contravariance, where Printer[-A] can accept supertypes to print subtypes, forming the basis for contravariant relationships.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/variances.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Printer[-A] {\n  def print(value: A): Unit\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Collection View with view in Scala\nDESCRIPTION: Generates a view over the source collection, enabling lazy transformations without materializing intermediate results. Requires only Scala's standard library; input is a collection, output is a non-strict (view) wrapper over that collection. Useful for optimizing chains of collection operations by avoiding unnecessary evaluations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/trait-iterable.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nxs.view\n```\n\n----------------------------------------\n\nTITLE: Adding Scala Toolkit Dependency in sbt Build File - Scala\nDESCRIPTION: This snippet illustrates adding the Scala Toolkit dependency to an sbt project by editing the 'build.sbt' file. It sets up a sample project named 'example' with Scala version '3.4.2' and includes the toolkit as a library dependency. This requires sbt as a build tool and will obtain version '0.7.0' of the toolkit for the entire project.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-os-lib.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nlazy val example = project.in(file(\".\"))\n  .settings(\n    scalaVersion := \"3.4.2\",\n    libraryDependencies += \"org.scala-lang\" %% \"toolkit\" % \"0.7.0\"\n  )\n```\n\n----------------------------------------\n\nTITLE: Using recover combinator to handle exceptions in Futures in Scala 2/3\nDESCRIPTION: Illustrates using the 'recover' combinator on a Future to handle exceptions gracefully by mapping specific exceptions to a default value. Here, if the buy operation throws a QuoteChangedException, the Future recovers to return 0 instead of failing. This helps avoid propagating exceptions downstream and allows for defining fallback values for failed computations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\nval purchase: Future[Int] = rateQuote.map {\n  quote => connection.buy(amount, quote)\n} recover {\n  case QuoteChangedException() => 0\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Pizza Functional Methods with Case Class in Scala 2\nDESCRIPTION: Defines a Pizza case class that encapsulates pizza properties and includes functional methods as class members to adjust toppings, crust size, and crust type, and to calculate the pizza price. These methods use immutable updating via copy and refer to the current instance using `this`. It requires the definitions of `CrustSize`, `CrustType`, `Topping` types and a `pizzaPrice` function to compute price. The methods provide fluent interfaces to manipulate pizza instances immutably.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-fp.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ncase class Pizza(\n  crustSize: CrustSize,\n  crustType: CrustType,\n  toppings: Seq[Topping]\n) {\n\n  // операции этой модели данных\n  def price: Double =\n    pizzaPrice(this) // такая же имплементация, как и выше\n\n  def addTopping(t: Topping): Pizza =\n    this.copy(toppings = this.toppings :+ t)\n\n  def removeAllToppings: Pizza =\n    this.copy(toppings = Seq.empty)\n\n  def updateCrustSize(cs: CrustSize): Pizza =\n    this.copy(crustSize = cs)\n\n  def updateCrustType(ct: CrustType): Pizza =\n    this.copy(crustType = ct)\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Ascription Quasiquotes - Scala\nDESCRIPTION: Demonstrates pattern matching on a type ascription expression using quasiquotes. The pattern `q\"$expr: $tpt\"` matches an ascription and extracts the tree for the expression being ascribed (`$expr`) and the tree for the type annotation (`$tpt`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_28\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"$expr: $tpt\" = ascribed\nexpr: universe.Tree = 1.$plus(1)\ntpt: universe.Tree = Int\n```\n\n----------------------------------------\n\nTITLE: Compiled JVM Output for Static Scala Members - Java\nDESCRIPTION: Illustrates the resulting Java bytecode structure when Scala `@static` fields and methods are compiled for the JVM. The snippet shows how the static members of the Scala object are emitted as `public static` fields and methods directly on the companion Java class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/static-members.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nclass Foo {\n  public static int x = 5;\n  public static int bar(int y) {\n    return x + y;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Ejemplos de uso de parámetros por defecto en Scala\nDESCRIPTION: Demuestra las diferentes formas de invocar un constructor con parámetros por defecto en Scala, incluyendo el uso de parámetros nombrados para omitir parámetros específicos.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/default-parameter-values.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n// Usa los parametros por defecto\nval m1 = new HashMap[String,Int]\n\n// initialCapacity 20, default loadFactor\nval m2= new HashMap[String,Int](20)\n\n// sobreescribe ambos\nval m3 = new HashMap[String,Int](20,0.8)\n\n// sobreescribe solamente loadFactor\n// mediante parametros nombrados\nval m4 = new HashMap[String,Int](loadFactor = 0.8)\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Boolean Logic Methods in a Scala Case Class\nDESCRIPTION: Creates a custom boolean wrapper case class `MyBool` and defines methods `and`, `or`, and `negate` to implement logical operations. The `and` and `or` methods take another `MyBool` instance as a parameter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/operators.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ncase class MyBool(x: Boolean) {\n  def and(that: MyBool): MyBool = if (x) that else this\n  def or(that: MyBool): MyBool = if (x) this else that\n  def negate: MyBool = MyBool(!x)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Packages and Package Objects with Java Naming Conventions\nDESCRIPTION: Illustrates Scala package naming following Java conventions using dot notation. Multiple package declarations can appear in sequence in a file to scope code appropriately. Also demonstrates defining a package object with documentation, which is a Scala feature to hold package-level utilities or state.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/naming-conventions.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n// wrong!\npackage coolness\n\n// right! puts only coolness._ in scope\npackage com.novell.coolness\n\n// right! puts both novell._ and coolness._ in scope\npackage com.novell\npackage coolness\n\n// right, for package object com.novell.coolness\npackage com.novell\n/**\n * Provides classes related to coolness\n */\npackage object coolness {\n}\n```\n\n----------------------------------------\n\nTITLE: Data Structures in Scala\nDESCRIPTION: Common data structures in Scala including tuples, lists, ranges, and pattern matching techniques for data extraction.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/cheatsheets/index.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n(1,2,3)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nvar (x,y,z) = (1,2,3)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nvar x,y,z = (1,2,3)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nvar xs = List(1,2,3)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nxs(2)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n1 :: List(2,3)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n1 to 5\n```\n\nLANGUAGE: Scala\nCODE:\n```\n1 until 6\n```\n\nLANGUAGE: Scala\nCODE:\n```\n1 to 10 by 2\n```\n\nLANGUAGE: Scala\nCODE:\n```\n()\n```\n\n----------------------------------------\n\nTITLE: Escaping Percent Signs in Scala `f`-Interpolated Strings\nDESCRIPTION: Shows how to include a literal percent sign (`%`) within an `f`-interpolated string in Scala by escaping it with another percent sign (`%%`). This is necessary because `%` normally indicates the start of a format specifier.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nprintln(f\"3/19 is less than 20%%\")  // \"3/19 is less than 20%\"\n```\n\n----------------------------------------\n\nTITLE: Defining Java Annotation Interface\nDESCRIPTION: Example of defining a custom annotation interface in Java with two required string elements: URL and mail.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/annotations.md#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\n@interface Source {\n  public String URL();\n  public String mail();\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Anonymous Function Syntax\nDESCRIPTION: Shows the basic syntax of an anonymous function that multiplies a value by 2, using the underscore as a placeholder for the parameter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-anonymous-functions.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n_ * 2\n```\n\n----------------------------------------\n\nTITLE: Main Program to Demonstrate Expression Evaluation and Differentiation in Scala\nDESCRIPTION: Implements a `main` method to demonstrate constructing expression trees, defining evaluation environments, and invoking evaluation and differentiation functions. It builds the expression `(x + x) + (7 + y)`, defines an environment assigning concrete integer values to variables \"x\" and \"y\", evaluates the expression in this environment, and computes its derivatives relative to \"x\" and \"y\". The results are printed to the console illustrating the use of earlier defined constructs and functions in a realistic context.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_it/tutorials/scala-for-java-programmers.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ndef main(args: Array[String]): Unit = {\n  val exp: Tree = Sum(Sum(Var(\"x\"),Var(\"x\")),Sum(Const(7),Var(\"y\")))\n  val env: Environment = { case \"x\" => 5 case \"y\" => 7 }\n  println(\"Expression: \" + exp)\n  println(\"Evaluation with x=5, y=7: \" + eval(exp, env))\n  println(\"Derivative relative to x:\\n \" + derive(exp, \"x\"))\n  println(\"Derivative relative to y:\\n \" + derive(exp, \"y\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing a PetOwner in Scala 3 with automatic derivation\nDESCRIPTION: This example showcases the Scala 3 syntax for deriving a `ReadWriter[PetOwner]` instance directly within the case class definition, streamlining JSON serialization. The code serializes a `PetOwner` instance to JSON format, facilitating easy data exchange with minimal boilerplate.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-serialize.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nimport upickle.default.*\n\ncase class PetOwner(name: String, pets: List[String]) derives ReadWriter\n\nval petOwner = PetOwner(\"Peter\", List(\"Toolkitty\", \"Scaniel\"))\nval json: String = write(petOwner)\nprintln(json)\n// prints: {\"name\":\"Peter\",\"pets\":[\"Toolkitty\",\"Scaniel\"]}\n```\n\n----------------------------------------\n\nTITLE: Defining a Parameterized Enumeration in Scala\nDESCRIPTION: Illustrates how to define a Scala 3 enumeration where each case carries a parameter (an `rgb` integer value in this example). Cases extend the enum and provide the corresponding parameter value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-adts-gadts.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nenum Color(val rgb: Int):\n  case Red   extends Color(0xFF0000)\n  case Green extends Color(0x00FF00)\n  case Blue  extends Color(0x0000FF)\n```\n\n----------------------------------------\n\nTITLE: Enumerated Examples of Named given Definitions Using Proposed Scala 3 Syntax in Scala\nDESCRIPTION: Shows the variant of the previous examples where optional names are explicitly bound to given instances. The syntax preserves the same clarity and structure but now associates identifiers with each given, supporting both simple and parameterized typeclasses, aliases, abstract and by-name givens under the new clean syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\n  // Simple typeclass\n  given intOrd: Ord[Int]:\n    def compare(x: Int, y: Int) = ...\n\n  // Parameterized typeclass with context bound\n  given listOrd: [A: Ord] => Ord[List[A]]:\n    def compare(x: List[A], y: List[A]) = ...\n\n  // Parameterized typeclass with context parameter\n  given listOrd: [A] => Ord[A] => Ord[List[A]]:\n    def compare(x: List[A], y: List[A]) = ...\n\n  // Parameterized typeclass with named context parameter\n  given listOrd: [A] => (ord: Ord[A]) => Ord[List[A]]:\n    def compare(x: List[A], y: List[A]) = ...\n\n  // Simple alias\n  given intOrd: Ord[Int] = IntOrd()\n\n  // Parameterized alias with context bound\n  given listOrd: [A: Ord] => Ord[List[A]] =\n    ListOrd[A]\n\n  // Parameterized alias with context parameter\n  given listOrd: [A] => Ord[A] => Ord[List[A]] =\n    ListOrd[A]\n\n  // Abstract or deferred given\n  given context: Context = deferred\n\n  // By-name given\n  given context: () => Context = curCtx\n```\n\n----------------------------------------\n\nTITLE: REPL Output Showing Function Variable Type in Scala\nDESCRIPTION: Shows the REPL confirming the inferred type of the function variable `double` is `Int => Int`, indicating it accepts an Int and returns an Int. Useful for understanding Scala's type inference on function literals assigned to vals.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-function-variables.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nscala> val double = (i: Int) => i * 2\nval double: Int => Int = ...\n```\n\n----------------------------------------\n\nTITLE: 定义 Person 类的 Scala 2 和 Scala 3 代码\nDESCRIPTION: 声明了简单的样例类 Person，包含 firstName 和 lastName 两个字段。此类没有继承任何 trait，演示如何通过类型类为此类添加额外行为。无其他依赖，作为类型类实例的承载类型示例。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/ca-type-classes.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Person(firstName: String, lastName: String)\n```\n\n----------------------------------------\n\nTITLE: Correctly Using Single Parameter List Method in Scala (Type Hints)\nDESCRIPTION: Demonstrates two ways to correctly call the `foldLeft1` method (defined with a single parameter list) despite its type inference limitations. This is achieved either by explicitly providing type parameters or by writing out the full lambda expression with type annotations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/multiple-parameter-lists.md#_snippet_4\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\ndef firstWay = foldLeft1[Int, Int](numbers, 0, _ + _)\ndef secondWay = foldLeft1(numbers, 0, (a: Int, b: Int) => a + b)\n```\n\n----------------------------------------\n\nTITLE: Named Arguments with Anonymous Functions in Scala\nDESCRIPTION: Demonstrates how placeholder syntax for anonymous functions works with named arguments, allowing the creation of partially applied functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-and-default-arguments.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ndef f(x: Int, y: String)\nval g1: Int => Int = f(y = \"someString\", x = _)\nval g2 = f(y = \"someString\", x = _: Int)\n```\n\n----------------------------------------\n\nTITLE: Reflectively Accessing and Modifying a Member Field in Scala\nDESCRIPTION: Illustrates how to access and modify a specific field of an object at runtime using reflection: obtaining a class mirror, locating the field symbol, and using a `FieldMirror` to get and set the field's value dynamically.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/overview.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.runtime.{universe => ru}\n\ncase class Purchase(name: String, orderNumber: Int, var shipped: Boolean)\n\nval p = Purchase(\"Jeff Lebowski\", 23819, false)\nval m = ru.runtimeMirror(p.getClass.getClassLoader)\nval termSymb = ru.typeOf[Purchase].decl(ru.TermName(\"shipped\")).asTerm\nval instanceMirror = m.reflect(p)\nval fieldMirror = instanceMirror.reflectField(termSymb)\n\n// Get current value of 'shipped'\nprintln(fieldMirror.get)  // Outputs: false\n\n// Set 'shipped' to true\nfieldMirror.set(true)\nprintln(fieldMirror.get)  // Outputs: true\n```\n\n----------------------------------------\n\nTITLE: Inlining Attempt with Non-Constant Argument in Scala\nDESCRIPTION: Illustrates the compiler's attempt to inline the `power` function when the exponent (`unknownNumber`) is not a compile-time constant. Since the conditions cannot be evaluated statically, the compiler attempts to inline both branches recursively, leading to non-terminating expansion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\n// first inlines as\nval x = 2\nif (unknownNumber == 0) 1.0\nelse if (unknownNumber % 2 == 1) x * power(x, unknownNumber - 1)\nelse power(x * x, unknownNumber / 2)\n// then inlined as\nval x = 2\nif (unknownNumber == 0) 1.0\nelse if (unknownNumber % 2 == 1) x * {\n  if (unknownNumber - 1 == 0) 1.0\n  else if ((unknownNumber - 1) % 2 == 1) x2 * power(x2, unknownNumber - 1 - 1)\n  else power(x2 * x2, (unknownNumber - 1) / 2)\n}\nelse {\n  val x2 = x * x\n  if (unknownNumber / 2 == 0) 1.0\n  else if ((unknownNumber / 2) % 2 == 1) x2 * power(x2, unknownNumber / 2 - 1)\n  else power(x2 * x2, unknownNumber / 2 / 2)\n}\n// Oops this will never finish compiling\n...\n```\n\n----------------------------------------\n\nTITLE: Creating a database object extending a type macro in Scala\nDESCRIPTION: This snippet shows how to instantiate a singleton object `Db` that extends the `H2Db` type macro with a specific database URL `coffees`. The macro generates a type-safe wrapper for CRUD operations, which is equivalent to a class extending the generated class. This demonstrates macro-based static code generation at compile-time.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/typemacros.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject Db extends H2Db(\"coffees\")\n```\n\n----------------------------------------\n\nTITLE: Multiple generators in for comprehension with filters in Scala\nDESCRIPTION: Example showing how to use for comprehension with multiple generators and a filter condition. This function finds all pairs of numbers between 0 and n-1 whose sum equals a specified value v, demonstrating the power of chained generators with guard conditions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/for-comprehensions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef foo(n: Int, v: Int) =\n   for (i <- 0 until n;\n        j <- i until n if i + j == v)\n   yield (i, j)\n\nfoo(10, 10) foreach {\n  case (i, j) =>\n    print(s\"($i, $j) \")  // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5)\n}\n```\n\n----------------------------------------\n\nTITLE: Default Splitter Splitting Logic in Scala Parallel Collections\nDESCRIPTION: Shows the default implementation of the `shouldSplitFurther` method used by splitters in Scala parallel collections. This method determines whether a splitter should be further divided based on the remaining elements compared to a threshold calculated from the collection size and parallelism level. Note: `thresholdFromSize` is a helper not shown here.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/parallel-collections/custom-parallel-collections.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef shouldSplitFurther[S](coll: ParIterable[S], parallelismLevel: Int) =\n  remaining > thresholdFromSize(coll.size, parallelismLevel)\n```\n\n----------------------------------------\n\nTITLE: Use Parameterized `greet` Method (Scala REPL/Script)\nDESCRIPTION: Shows how to use the parameterized `greet` method to create different greeting functions. It calls `greet` with various greeting strings (\"Hello\", \"Ciao\", \"Hola\") to generate specific functions (`sayHello`, `sayCiao`, `sayHola`), verifies the type of the returned function in the REPL, and then executes these specialized functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-write-method-returns-function.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val sayHello = greet(\"Hello\")\nval sayHello: String => Unit = Lambda.....\n    ------------------------\n```\n\nLANGUAGE: Scala\nCODE:\n```\nsayHello(\"Joe\")   // prints \"Hello, Joe\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval sayCiao = greet(\"Ciao\")\nval sayHola = greet(\"Hola\")\n\nsayCiao(\"Isabella\")   // prints \"Ciao, Isabella\"\nsayHola(\"Carlos\")     // prints \"Hola, Carlos\"\n```\n\n----------------------------------------\n\nTITLE: Basic For Expression with Filter in Scala\nDESCRIPTION: This snippet demonstrates a simple for expression that filters a list of User objects based on age criteria and yields their names as a new collection. It shows how to use a generator to iterate through a list and a filter to select elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/for-comprehensions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class User(name: String, age: Int)\n\nval userBase = List(User(\"Travis\", 28),\n  User(\"Kelly\", 33),\n  User(\"Jennifer\", 44),\n  User(\"Dennis\", 23))\n\nval twentySomethings = for (user <- userBase if (user.age >=20 && user.age < 30))\n  yield user.name  // i.e. add this to a list\n\ntwentySomethings.foreach(name => println(name))  // prints Travis Dennis\n```\n\n----------------------------------------\n\nTITLE: Defining Classes with Constructor Parameters and Methods in Scala - Scala\nDESCRIPTION: Illustrates declaring a class with constructor parameters and member methods. The example shows a Greeter class that concatenates prefix, given name, and suffix to print greetings. It also explains the Unit return type as the equivalent of void. Instances are created with the new keyword.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/tour/basics.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nclass Greeter(prefix: String, suffix: String) {\n  def greet(name: String): Unit =\n    println(prefix + name + suffix)\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval greeter = new Greeter(\"Hello, \", \"!\")\ngreeter.greet(\"Scala developer\") // Hello, Scala developer!\n```\n\n----------------------------------------\n\nTITLE: Creating a Future for Asynchronous Operations in Scala\nDESCRIPTION: Demonstrates creating a `Future` in Scala to perform an asynchronous operation, such as fetching data from a social network API. It imports necessary concurrent packages and an implicit global ExecutionContext. The `Future` wraps the call to `session.getFriends()`, allowing the main thread to continue while the operation completes in the background.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/futures.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.concurrent._\nimport ExecutionContext.Implicits.global\n\nval session = socialNetwork.createSessionFor(\"user\", credentials)\nval f: Future[List[Friend]] = Future {\n  session.getFriends()\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying sbt Project Directory Structure - Bash Output\nDESCRIPTION: This output shows the directory structure of a simple sbt Scala project, listing key configuration and source folders including 'build.sbt', project directory, source directories, and target output. It demonstrates the expected organization that sbt relies on for locating sources, tests, and build metadata.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ tree\n.\n├── build.sbt\n├── Hello.scala\n└── project\n    └── build.properties\n```\n\n----------------------------------------\n\nTITLE: Observing Method Return Types on RNA1 in Scala REPL\nDESCRIPTION: Shows the results of calling `length`, `last`, and `take` on an `RNA1` instance in the Scala REPL. It highlights that methods like `take`, inherited from `IndexedSeq`, currently return the default `IndexedSeq` implementation (`Vector`) rather than the custom `RNA1` type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-collections.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nscala> rna1.length\nres2: Int = 5\n\nscala> rna1.last\nres3: Base = C\n\nscala> rna1.take(3)\nres4: IndexedSeq[Base] = Vector(A, U, G)\n```\n\n----------------------------------------\n\nTITLE: Widening Type with Subtyping for Trait References\nDESCRIPTION: This snippet shows subtyping in action by assigning the MyService instance s1 to variables with trait reference types: GreetingService, TranslationService, and Showable. This demonstrates Scala's support for substituting subclass instances wherever a trait or interface is expected. Requires previous definitions of s1 and the traits.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nval s2: GreetingService = s1\nval s3: TranslationService = s1\nval s4: Showable = s1\n// ... and so on ...\n```\n\n----------------------------------------\n\nTITLE: Defining Vector Addition Operator '+' with Custom Case Class in Scala 2\nDESCRIPTION: Defines a case class Vec with properties x and y and implements the '+' method to add two Vec instances component-wise. Demonstrates creating two vectors and adding them using the '+' operator, returning a new Vec instance with summed coordinates.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/operators.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncase class Vec(x: Double, y: Double) {\n  def +(that: Vec) = Vec(this.x + that.x, this.y + that.y)\n}\n\nval vector1 = Vec(1.0, 1.0)\nval vector2 = Vec(2.0, 2.0)\n\nval vector3 = vector1 + vector2\nvector3.x  // 3.0\nvector3.y  // 3.0\n```\n\n----------------------------------------\n\nTITLE: Defining a Config case class and passing it explicitly in Scala 2 and 3\nDESCRIPTION: Defines a Config data class to hold website configuration. Shows typical explicit passing of Config instances through method parameters in Scala 2 and 3, serving as a baseline for contextual abstraction. Requires no special dependencies but results in verbose code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/ca-context-parameters.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Config(port: Int, baseUrl: String)\n\ndef renderWebsite(path: String, c: Config): String =\n    \"<html>\" + renderWidget(List(\"cart\"), c) + \"</html>\"\n\ndef renderWidget(items: List[String], c: Config): String = ???\n\nval config = Config(8080, \"docs.scala-lang.org\")\nrenderWebsite(\"/home\", config)\n```\n\n----------------------------------------\n\nTITLE: Implementing functional dependency (fundep) materialization with Scala macros\nDESCRIPTION: This code provides an approach to derive implicit instances for complex type relations such as 'Iso' mappings, addressing type inference issues by leveraging macro expansion that delayed inference until after macro code generation, thus enabling sophisticated type-level programming.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/implicits.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Iso[T, U] {\n  def to(t: T): U\n  def from(u: U): T\n}\n\ncase class Foo(i: Int, s: String, b: Boolean)\n\ndef conv[C, L](c: C)(implicit iso: Iso[C, L]): L = iso.from(c)\n```\n\n----------------------------------------\n\nTITLE: Declaring Immutable and Mutable Variables in Scala with Type Inference\nDESCRIPTION: This Scala snippet declares immutable and mutable variables using val and var keywords respectively, utilizing compiler type inference to deduce the variable types. The immutable val string s and mutable var integer i illustrate fundamental Scala variable styles. It also shows object instantiation with val for an instance of Person. Requires Scala environment and a Person class definition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/two-types-variables.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval s = \"hello\"   // immutable\nvar i = 42        // mutable\n\nval p = new Person(\"Joel Fleischman\")\n```\n\n----------------------------------------\n\nTITLE: Querying Method Member by Name in Scala Reflection\nDESCRIPTION: Demonstrates how to use the `member` method on a `Type` to find a specific member by name. It queries for the `map` method on `List[_]`'s type using `typeOf[List[_]]` and passes the name \"map\" explicitly as a `TermName` to specify it's looking for a term-level member (like a method or field).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/reflection/symbols-trees-types.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n\ntypeOf[List[_]].member(\"map\": TermName)\n```\n\n----------------------------------------\n\nTITLE: Companion Object Declaration and Access in Scala\nDESCRIPTION: Explains the concept of companion objects sharing the same name as a class and their access privileges, including sharing private members. Provides examples for defining a 'Circle' class with a companion object that contains a private utility method to compute an area, illustrating encapsulation and shared access.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/singleton-objects.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.math.pow\n\ncase class Circle(radius: Double) {\n  import Circle._\n  def area: Double = calculateArea(radius)\n}\n\nobject Circle {\n  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)\n}\n\nval circle1 = Circle(5.0)\n\ncircle1.area\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.math.pow\n\ncase class Circle(radius: Double):\n  import Circle.*\n  def area: Double = calculateArea(radius)\n\nobject Circle:\n  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)\n\nval circle1 = Circle(5.0)\n\ncircle1.area\n```\n\n----------------------------------------\n\nTITLE: Creating a Nominal Helper Trait in Scala 3\nDESCRIPTION: Shows the Scala 3 approach of creating a nominal helper trait `Both[A]` that explicitly extends both `Resettable` and `Growable[A]` using commas instead of `with`. A function `f` is then defined to accept instances of this specific `Both[String]` trait. This contrasts with the structural approach using intersection types, as it requires an explicit nominal type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-intersection.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait Both[A] extends Resettable, Growable[A]\ndef f(x: Both[String]): Unit\n```\n\n----------------------------------------\n\nTITLE: Minimal Scala 3 \"Hello, world\" Main Method - Scala\nDESCRIPTION: A concise Scala 3 program using '@main' annotation to define an executable entry point named 'helloWorld' that prints 'Hello, world' to the console. For small projects or demos, source files can be located in the root directory or under the conventional 'src/main/scala'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\n@main def helloWorld = println(\"Hello, world\")\n```\n\n----------------------------------------\n\nTITLE: Defining Traits in Scala 2 and Scala 3\nDESCRIPTION: Defines modular behaviors using traits. Traits act as interfaces and can contain abstract and concrete methods, enabling flexible composition for classes representing animals. Demonstrates trait syntax for Scala 2 and Scala 3, emphasizing the syntax differences while maintaining functionality.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-modeling.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Speaker {\n  def speak(): String  // abstract method\n}\n\ntrait TailWagger {\n  def startTail(): Unit = println(\"tail is wagging\")\n  def stopTail(): Unit = println(\"tail is stopped\")\n}\n\ntrait Runner {\n  def startRunning(): Unit = println(\"I’m running\")\n  def stopRunning(): Unit = println(\"Stopped running\")\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling cross-type comparisons with CanEqual\nDESCRIPTION: Shows how to allow comparisons between different types (PrintedBook and AudioBook) by providing the appropriate CanEqual instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-multiversal-equality.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\n// allow `PrintedBook == AudioBook`, and `AudioBook == PrintedBook`\ngiven CanEqual[PrintedBook, AudioBook] = CanEqual.derived\ngiven CanEqual[AudioBook, PrintedBook] = CanEqual.derived\n\nprintln(pBook == aBook)   // false\nprintln(aBook == pBook)   // false\n```\n\n----------------------------------------\n\nTITLE: Creating Object Instances and Using Traits in Scala 2 and Scala 3\nDESCRIPTION: Demonstrates instantiation of 'Dog' and 'Cat' objects, calling their methods to illustrate behavior. Highlights syntax differences: Scala 2 uses 'new', while Scala 3 allows object creation without 'new'. Outputs are shown for method calls.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-modeling.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval d = new Dog(\"Rover\")\nprintln(d.speak())      // prints \"Woof!\"\n\nval c = new Cat(\"Morris\")\nprintln(c.speak())      // \"Meow\"\n c.startRunning()        // \"Yeah ... I don’t run\"\n c.stopRunning()         // \"No need to stop\"\n```\n\n----------------------------------------\n\nTITLE: Function Utilizing Composite Type 'Cloneable with Resetable' in Scala\nDESCRIPTION: This snippet shows a function 'cloneAndReset' that takes an object of type 'Cloneable with Resetable', clones the object, resets the original, and returns the cloned copy. It demonstrates how composite types enforce that the object supports both cloning and resetting, enabling type-safe operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/compound-types.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef cloneAndReset(obj: Cloneable with Resetable): Cloneable = {\n  // Clone the object\n  val cloned = obj.clone()\n  // Reset the original object\n  obj.reset\n  // Return the cloned object\n  cloned\n}\n```\n\n----------------------------------------\n\nTITLE: Generalizing filter and map Operations in IterableOps in Scala 3\nDESCRIPTION: This Scala 3 snippet generalizes filter and map in IterableOps using the newer syntax. Both functions utilize the trait's type parameters to abstract over the resulting collection and element types. The code showcases how Scala 3 streamlines collections API definitions for clarity and flexibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ntrait IterableOps[+A, +CC[_], +C]:\n  def filter(p: A => Boolean): C = …\n  def map[B](f: A => B): CC[B] = …\n```\n\n----------------------------------------\n\nTITLE: Adding Table Row Hover Effect with jQuery (JavaScript)\nDESCRIPTION: Applies a hover effect to table rows within elements matching the selector '.bottom table tr' once the DOM is ready. On mouseenter, the background color of the hovered row is changed to '#FFCC85'. On mouseleave, the background color is reset to '#ffffff'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/cheatsheet-header.txt#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\njQuery(document).ready(function($) {\n\n      $(\".bottom table tr\").hover(\n        function(){$(this).css(\"background-color\", \"#FFCC85\");},\n    function(){$(this).css(\"background-color\", \"#ffffff\");}\n      );\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Service Traits for Mixin Composition in Scala\nDESCRIPTION: Defines two separate traits, `GreetingService` and `TranslationService`. `GreetingService` has an abstract `translate` method used by its concrete `sayHello` method. `TranslationService` provides a concrete implementation for `translate`. These traits are designed to be combined using mixin composition. Shows Scala 2 and 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-oop.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntrait GreetingService {\n  def translate(text: String): String\n  def sayHello = translate(\"Hello\")\n}\n\ntrait TranslationService {\n  def translate(text: String): String = \"...\"\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait GreetingService:\n  def translate(text: String): String\n  def sayHello = translate(\"Hello\")\n\ntrait TranslationService:\n  def translate(text: String): String = \"...\"\n```\n\n----------------------------------------\n\nTITLE: Extending trait with abstract type and upper bound in Scala\nDESCRIPTION: This snippet extends 'Buffer' in an abstract class 'SeqBuffer', adding a new abstract type 'U', and defining 'T' with an upper bound 'Seq[U]'. It allows constraining 'element' to be a sequence of 'U', facilitating more specific implementations. Dependencies include 'Buffer' and 'Seq'. Inputs are types; output is class extension with type bounds.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tour/abstract-type-members.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class SeqBuffer extends Buffer {\n  type U\n  type T <: Seq[U]\n  def length = element.length\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Existing File Error with os-lib in Scala\nDESCRIPTION: This snippet illustrates the behavior of `os.write` when attempting to write to a file that already exists. It shows that a `java.nio.file.FileAlreadyExistsException` is thrown in this scenario. This highlights the need for explicit handling (like using `os.write.over` or `os.write.append`) when dealing with potentially existing files. Requires the `os-lib` dependency.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/os-write-file.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nos.write(path, \"this will fail\")\n// this exception is thrown:\n// java.nio.file.FileAlreadyExistsException\n```\n\n----------------------------------------\n\nTITLE: Attempting Alternative Patterns with Variable Binding (Current Limitation) in Scala\nDESCRIPTION: Illustrates the current Scala limitation where binding the same variable (`name`) within different branches of an alternative pattern (`|`) is disallowed by the compiler. This code attempts to handle \"pick up item\" and \"get item\" synonymously while binding `name`, which is not currently supported.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/alternative-bind-variables.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n  case Command(Pick :: Up :: Item(name) :: Nil | Get :: Item(name) :: Nil) => // Code for picking up items\n```\n\n----------------------------------------\n\nTITLE: Using _root_ prefix to avoid name conflicts in Scala 3\nDESCRIPTION: Similar to Scala 2, this demonstrates the use of '_root_' prefix to explicitly specify the root package, helping to resolve naming conflicts or ambiguities in nested package structures.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/packages-and-imports.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\npackage accounts\n\nimport _root_.users.*\n```\n\n----------------------------------------\n\nTITLE: Compiling with Scala Optimizer and Inliner Warnings - CLI\nDESCRIPTION: Shows how to compile a Scala file (`Test.scala`) with the optimizer and full inlining enabled (`-opt:inline:**`), while also activating detailed inliner warnings using the `-Wopt` flag. This command will output specific reasons why the inliner might fail for `@inline` annotated methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/compiler-options/optimizer.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n$> scalac Test.scala '-opt:inline:**' -Wopt\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple Constructors with Auxiliary Constructors in Scala 3\nDESCRIPTION: Example of a Scala 3 class with a primary constructor and multiple auxiliary constructors to support different initialization scenarios.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-tools.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport java.time.*\n\n// [1] the primary constructor\nclass Student(\n  var name: String,\n  var govtId: String\n):\n  private var _applicationDate: Option[LocalDate] = None\n  private var _studentId: Int = 0\n\n  // [2] a constructor for when the student has completed\n  // their application\n  def this(\n    name: String,\n    govtId: String,\n    applicationDate: LocalDate\n  ) =\n    this(name, govtId)\n    _applicationDate = Some(applicationDate)\n\n  // [3] a constructor for when the student is approved\n  // and now has a student id\n  def this(\n    name: String,\n    govtId: String,\n    studentId: Int\n  ) =\n    this(name, govtId)\n    _studentId = studentId\n```\n\n----------------------------------------\n\nTITLE: Implementing Lazy Evaluation and Generic Type Representations in Shapeless\nDESCRIPTION: This snippet defines core shapeless components for type-level programming. It includes the Lazy trait for lazy evaluation of type class instances and the Generic trait for converting between concrete types and their generic representations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Lazy[+T] extends Serializable {\n  val value: T\n}\n\nobject Lazy {\n  implicit def apply[T](t: => T): Lazy[T] =\n    new Lazy[T] {\n      lazy val value = t\n    }\n\n  implicit def mkLazy[I]: Lazy[I] = macro ...\n}\n\ntrait Generic[T] {\n  type Repr\n  def to(t: T): Repr\n  def from(r: Repr): T\n}\n```\n\n----------------------------------------\n\nTITLE: Lazy Mapping on a Scala SeqView - Scala\nDESCRIPTION: Applies a map transformation on the SeqView `vv` returning another SeqViewM representing a view with one map operation applied lazily. The operation is not executed immediately, only recorded within the view. This snippet highlights the internal markers (such as 'M') used to identify pending operations in views.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/views.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nvv map (_ + 1)\n```\n\n----------------------------------------\n\nTITLE: Defining a Palindrome Check and Finder Functions on String Sequences - Scala\nDESCRIPTION: Defines a function `isPalindrome` to check if a string is a palindrome by comparing it to its reversal, and a `findPalindrome` function that finds the first palindrome in a sequence of strings using a predicate with `find`. This snippet sets a context for demonstrating views improving efficiency in sequence filtering and searching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/views.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef isPalindrome(x: String) = x == x.reverse\ndef findPalidrome(s: Seq[String]) = s find isPalindrome\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running a Scala Program Using scalac and scala\nDESCRIPTION: This snippet explains how to compile a Scala source file using 'scalac', generating class files, and subsequently execute it with 'scala'. It clarifies the process of converting Scala code into JVM bytecode and executing it as a standalone program, similar to Java. Not applicable—it's command-line instructions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tutorials/scala-for-java-programmers.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n> scalac HelloWorld.scala\n```\n\nLANGUAGE: Shell\nCODE:\n```\n> scala -classpath . HelloWorld\n```\n\n----------------------------------------\n\nTITLE: Importing CollectionConverters for Java-Scala Collection Conversion in Scala\nDESCRIPTION: Shows how to import the CollectionConverters object which provides implicit conversions between Java and Scala collections. This import is necessary to enable the asJava and asScala extension methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/conversions-between-java-and-scala-collections.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.jdk.CollectionConverters._\n```\n\n----------------------------------------\n\nTITLE: Using match Expression for Pattern Matching in Scala 2\nDESCRIPTION: Demonstrates the basic usage of Scala 2's match expression, similar to Java's switch, which matches an integer variable against patterns and executes corresponding code blocks. Requires Scala 2 compiler. Input is an integer variable 'i'; output is printed text describing the matched case.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nval i = 1\n\n// позже в этом коде ...\ni match {\n  case 1 => println(\"one\")\n  case 2 => println(\"two\")\n  case _ => println(\"other\")\n}\n```\n\n----------------------------------------\n\nTITLE: Stripping Indentation from Multiline Strings in Scala\nDESCRIPTION: This snippet applies the stripMargin method to a multiline string with leading '|' markers. The result is a string where lines after the first are left-aligned, improving readability and formatting reliability. StripMargin is especially useful when whitespace is significant in the string's content.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/first-look-at-types.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval quote = \"\"\"The essence of Scala:\n               |Fusion of functional and object-oriented\n               |programming in a typed setting.\"\"\".stripMargin\n```\n\n----------------------------------------\n\nTITLE: Defining a Unit-returning Method in Scala\nDESCRIPTION: This snippet defines a method, printIt, that takes a parameter a of type Any and prints it to standard output. The method returns Unit, representing the absence of a meaningful value in Scala, analogous to void in other languages. No external dependencies are required; 'Any' allows any type of input.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/first-look-at-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef printIt(a: Any): Unit = println(a)\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Custom Operators in Scala 2 and 3\nDESCRIPTION: Defines a 'Vec' class with a '+' method to add vectors, demonstrating operator overloading. Also defines a 'MyBool' class with logical operators 'and', 'or', and 'negate', showing how to create custom infix operators in Scala 2 and 3 with syntax differences.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/operators.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Vec(x: Double, y: Double) {\n  def +(that: Vec) = Vec(this.x + that.x, this.y + that.y)\n}\n\nval vector1 = Vec(1.0, 1.0)\nval vector2 = Vec(2.0, 2.0)\n\nval vector3 = vector1 + vector2\nvector3.x  // 3.0\nvector3.y  // 3.0\n```\n\nLANGUAGE: Scala\nCODE:\n```\ncase class MyBool(x: Boolean) {\n  def and(that: MyBool): MyBool = if (x) that else this\n  def or(that: MyBool): MyBool = if (x) this else that\n  def negate: MyBool = MyBool(!x)\n}\n```\n\n----------------------------------------\n\nTITLE: Infix Notation for Multi-Parameter Symbolic Methods in Scala\nDESCRIPTION: Shows how infix notation can be used even for symbolic methods taking more than one parameter, although such methods are generally discouraged in API design. Parameters are enclosed in parentheses and separated by commas, following the operator, with spaces delimiting the target, operator, and parameter list.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/method-invocation.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nfoo ** (bar, baz)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Code Levels in Quoted Scala Expressions\nDESCRIPTION: Illustrates the concept of levels in quoted code. Code outside quotes is at level 0. Entering a quote (`'{`) increases the level by 1, representing runtime code. Splicing (`${`) decreases the level by 1, bringing execution back towards compile-time. Level consistency ensures variables are accessed only at the level they are defined.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n// level 0\n'{ // level 1\n  var x = 0\n  ${ // level 0\n    x += 1\n    'x // level 1\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Blog Directory Structure in Markdown\nDESCRIPTION: Illustrates the recommended directory layout for storing blog posts in Scaladoc. The `_blog` folder should contain an `_posts` subfolder where Markdown files representing individual blog posts are stored, using date-based file names. This structure enables Scaladoc to automatically detect and process blogs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/blog.md#_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n├── _blog\n│   ├── _posts\n│   │   └── 2016-12-05-implicit-function-types.md\n│   └── index.html\n```\n\n----------------------------------------\n\nTITLE: Constructing Actors with Explicit View for Correct Evaluation - Scala\nDESCRIPTION: Addresses a common pitfall where a for-comprehension over a Range creates a lazy view causing no actor objects to be instantiated. By converting the Range to a view explicitly with `.view`, the map operation produces the expected actors eagerly on forcing the collection, resolving lazy evaluation issues in earlier Scala versions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/views.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval actors = for (i <- (1 to 10).view) yield actor { ... }\n```\n\n----------------------------------------\n\nTITLE: Java-like pseudocode showing casting due to type erasure\nDESCRIPTION: This code represents the casting introduced by the JVM for accessing elements of a generic list subject to type erasure. It shows the explicit cast to integer from a generic Object type and the similar Scala casting syntax. This casting is inserted because the JVM does not retain original generic type information.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/scala3/guides/tasty-overview.md#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nint x = (Int) xs.get(0)               // Java-ish\nval x = xs.get(0).asInstanceOf[Int]   // more Scala-like\n```\n\n----------------------------------------\n\nTITLE: Main method demonstrating the implicit Monoid resolution for sum calculation in Scala\nDESCRIPTION: The main method calls the generic sum function twice: once with a list of integers and once with a list of strings. Scala's implicit resolution mechanism automatically supplies the correct Monoid instance (`intMonoid` and `stringMonoid`) based on the list element type, resulting in the sum of integers and concatenation of strings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/implicit-parameters.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef main(args: Array[String]): Unit = {\n  println(sum(List(1, 2, 3)))       // Uses implicit intMonoid\n  println(sum(List(\"a\", \"b\", \"c\"))) // Uses implicit stringMonoid\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Alias Handling in Type Search (Scala)\nDESCRIPTION: Shows a type alias definition (`Name = String`) and two function definitions, one using the alias and one using the base type. This snippet illustrates how Inkuire desugars type aliases during the search process, allowing queries using either the alias or the underlying type to successfully find matching declarations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/search-engine.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ntype Name = String\n\ndef fromName(name: Name): String\ndef fromString(str: String): Name\n```\n\n----------------------------------------\n\nTITLE: Triggering Traversal with Custom Traverser and Accessing Results in Scala\nDESCRIPTION: This snippet demonstrates how to invoke traversal of a Tree using a custom Traverser subclass and access the results. The first line initiates the traversal with traverser.traverse(tree); the second retrieves the collected List of Apply nodes through traverser.applies. These calls rely on the previous definition of a custom traverser and a constructed Tree.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_27\n\nLANGUAGE: scala\nCODE:\n```\ntraverser.traverse(tree)\n```\n\nLANGUAGE: scala\nCODE:\n```\ntraverser.applies\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Stack Class (Scala 3)\nDESCRIPTION: Defines a generic `Stack` class in Scala 3 using a type parameter `A` and the colon-based syntax. It maintains an internal `List[A]` for storage and offers `push(x: A)`, `peek: A`, and `pop(): A` methods for stack operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-generics.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// here we declare the type parameter A\n//          v\nclass Stack[A]:\n  private var elements: List[A] = Nil\n  //                         ^\n  //  Here we refer to the type parameter\n  //          v\n  def push(x: A): Unit =\n    elements = elements.prepended(x)\n  def peek: A = elements.head\n  def pop(): A =\n    val currentTop = peek\n    elements = elements.tail\n    currentTop\n```\n\n----------------------------------------\n\nTITLE: Zipping Two Collections with zip in Scala\nDESCRIPTION: Pairs corresponding elements from two collections, producing a new collection of tuples. No additional dependencies beyond Scala collections API are required. Inputs are two sequences, and output is a sequence of paired elements; length is determined by the shorter input. Both sequences must be iterable, and the operation is constrained by the length of the shortest collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/trait-iterable.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nxs.zip(ys)\n```\n\n----------------------------------------\n\nTITLE: Using nested objects to defer initialization in Scala\nDESCRIPTION: This code illustrates creating a nested object within a class to delay initialization of certain state or fields, avoiding early access issues during superclass construction. It shows wrapping state inside a local object and importing its members.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/FAQ/initialization-order.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass Adder {\n  var sum = 0\n  def add(x: Int): Unit = sum += x\n  add(1)\n}\nclass LogAdder extends Adder {\n  private object state {\n    var added: Set[Int] = Set.empty\n  }\n  import state._\n  override def add(x: Int): Unit = { added += x; super.add(x) }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Mutable Collections in Scala\nDESCRIPTION: Demonstrates importing the scala.collection.mutable package to access mutable collection types. This is essential when working with mutable collections like Set, Iterable, or Buffer. No inputs or outputs are involved; the statement merely brings mutable collection types into scope. This convention allows referencing immutable collections by their simple names and referring to mutable counterparts with the mutable prefix.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/overview.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.mutable\n```\n\n----------------------------------------\n\nTITLE: Extending trait with abstract type bounds in Scala\nDESCRIPTION: This snippet showcases an abstract class 'SeqBuffer' extending 'Buffer' with an additional abstract type 'U' and a bounded type 'T' that must be a subtype of 'Seq[U]'. It includes a 'length' method accessing 'element.length', enforcing that 'element' is a sequence, demonstrating abstract type bounds and multiple abstract type members.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/abstract-type-members.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class SeqBuffer extends Buffer {\n  type U\n  type T <: Seq[U]\n  def length = element.length\n}\n```\n\n----------------------------------------\n\nTITLE: Minimal sbt Source Directory Structure - Text\nDESCRIPTION: For projects without Java sources or additional resources, this minimal layout shows only the essential Scala source directories under 'src'. Both main and test source code are segregated into their own 'scala' directories for compilation and testing purposes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n.\n└── src/\n    ├── main/\n    │   └── scala/\n    └── test/\n        └── scala/\n```\n\n----------------------------------------\n\nTITLE: Using traits and multiple trait composition in Scala\nDESCRIPTION: Shows the usage of traits, which are like interfaces with implementations, to provide mixin-style composition. It includes defining a trait `T` and composing it with classes via `extends` and `with` keywords. Multiple trait mixing and combining traits with class inheritance are also demonstrated.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\ntrait T { ... }\nclass C extends T { ... }\nclass C extends D with T { ... }\ntrait T1; trait T2\nclass C extends T1 with T2\nclass C extends D with T1 with T2\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Trait with Abstract Methods in Scala\nDESCRIPTION: Defines a generic trait Iterator with a type parameter `A` that declares two abstract methods: `hasNext` returning a Boolean, and `next()` returning a value of type `A`. This snippet shows how traits can declare abstract methods and serve as generic types requiring concrete implementation by subclasses or extending classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/tour/traits.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntrait Iterator[A] {\n  def hasNext: Boolean\n  def next(): A\n}\n```\n\n----------------------------------------\n\nTITLE: Type Inference Limitation with Null Literal Assignment in Scala\nDESCRIPTION: Highlights a limitation where assigning null to a variable causes the inferred type to be Null, preventing later reassignment to other types. The example shows that a val initialized as \"var obj = null\" cannot be reassigned to an instance of AnyRef because its type is fixed as Null, which only permits the null value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/type-inference.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nvar obj = null\n```\n\nLANGUAGE: scala\nCODE:\n```\nobj = new AnyRef\n```\n\n----------------------------------------\n\nTITLE: Summoning Givens via Inline Method Parameters in Scala Macros\nDESCRIPTION: Shows how to make a given (implicit) value available to a macro implementation by requiring it as a `using` parameter in the `inline` method. The given value is quoted and passed explicitly to the macro implementation function as an `Expr[T]`, requiring the given to be resolvable before macro expansion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_30\n\nLANGUAGE: Scala\nCODE:\n```\ninline def setOf[T](using ord: Ordering[T]): Set[T] =\n  ${ setOfCode[T]('ord) }\n\ndef setOfCode[T: Type](ord: Expr[Ordering[T]])(using Quotes): Expr[Set[T]] =\n  '{ TreeSet.empty[T](using $ord) }\n```\n\n----------------------------------------\n\nTITLE: Matching Expressions Using Expr.matches in Scala 3\nDESCRIPTION: This snippet demonstrates using `Expr.matches` to compare expressions for structural equality within macros, allowing pattern-based extraction of values. The provided function returns an `Option[Boolean]` indicating whether an `Expr[Boolean]` corresponds to true, false, or an unknown expression, highlighting limited normalization capabilities.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/macros.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\ndef value(boolExpr: Expr[Boolean]): Option[Boolean] =\n  if boolExpr.matches(Expr(true)) then Some(true)\n  else if boolExpr.matches(Expr(false)) then Some(false)\n  else None\n```\n\n----------------------------------------\n\nTITLE: Correctly Propagating ClassTag in Nested Generic Calls (REPL)\nDESCRIPTION: Shows how to fix the nested generic call by adding a ClassTag requirement to the outer function 'wrap' using the context bound '[U: ClassTag]'. This ensures that 'wrap' receives a ClassTag for U, which can then be implicitly passed to 'evenElems'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/arrays.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nscala> def wrap[U: ClassTag](xs: Vector[U]) = evenElems(xs)\nwrap: [U](xs: Vector[U])(implicit evidence$1: scala.reflect.ClassTag[U])Array[U]\n```\n\n----------------------------------------\n\nTITLE: Declaring Macros Object for Scala 3 - Initial Placeholder\nDESCRIPTION: Provides an empty placeholder for the 'Macros' object in Scala 3-specific sources. Declares an inline method 'location' with the same name and return type as its Scala 2 counterpart for API compatibility. Implementation is left unimplemented (???). Placed in 'src/main/scala-3/location/Macros.scala'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-macro-cross-building.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n// example/src/main/scala-3/location/Macros.scala\npackage location\n\nobject Macros:\n  inline def location: Location = ???\n```\n\n----------------------------------------\n\nTITLE: Configuring gh-pages Site Publication in sbt - Scala\nDESCRIPTION: Enables the GhpagesPlugin and configures git remote for publishing documentation to GitHub Pages in build.sbt. Requires 'sbt-ghpages' plugin and a suitable git remote configuration. Inputs: repository SCM URL from sonatypeProjectHosting. Output: build.sbt with publish-ready settings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nenablePlugins(GhpagesPlugin)\ngit.remoteRepo := sonatypeProjectHosting.value.get.scmUrl\n```\n\n----------------------------------------\n\nTITLE: Zipping Collections with fill Values Using zipAll in Scala\nDESCRIPTION: Combines two sequences, extending the shorter sequence using fill values as needed, and returns a sequence of tuples. Requires Scala collections. Inputs are two sequences and the fill values x and y for xs and ys; output is a sequence matching the length of the longer input. For padding, value x fills xs and y fills ys, ensuring all positions are paired.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/trait-iterable.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nxs.zipAll(ys, x, y)\n```\n\n----------------------------------------\n\nTITLE: Erasure Technique with Type Members and Singleton Types\nDESCRIPTION: Illustrates a technique for achieving erased type providers using type aliases parameterized by singleton types. Each type alias (like `Title`, `Director`) points to an upper bound (`XmlEntity`) but carries unique identity via a singleton type derived from a String literal URL.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/typeproviders.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nobject Netflix {\n  type Title = XmlEntity[\"https://.../Title\".type]\n  def Titles: List[Title] = ...\n  type Director = XmlEntity[\"https://.../Director\".type]\n  def Directors: List[Director] = ...\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using 'using' clause to mark parameters as context in Scala 3\nDESCRIPTION: Demonstrates defining functions with 'using' parameters to specify context dependencies automatically supplied by Scala 3's compiler. Eliminates the need to pass configuration explicitly at call sites, resulting in cleaner code. Utilizes Scala 3 syntax for contextual parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/ca-context-parameters.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef renderWebsite(path: String)(using c: Config): String =\n    \"<html>\" + renderWidget(List(\"cart\")) + \"</html>\"\n\ndef renderWidget(items: List[String])(using c: Config): String = ???\n```\n\n----------------------------------------\n\nTITLE: Creating a Generic Class with Upper Type Bound in Scala\nDESCRIPTION: This snippet defines the `PetContainer` class with a type parameter `P` constrained to be a subtype of `Pet` using `<: Pet`. It demonstrates how to instantiate the class with `Dog` and `Cat`, which are valid subtypes, enforcing type safety in managing pets.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/upper-type-bounds.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass PetContainer[P <: Pet](p: P) {\n  def pet: P = p\n}\n\nval dogContainer = new PetContainer[Dog](new Dog)\nval catContainer = new PetContainer[Cat](new Cat)\n```\n\n----------------------------------------\n\nTITLE: Defining a Function to Mutate Sequence - Scala\nDESCRIPTION: A function designed to modify elements of a mutable sequence in-place. It will be used to demonstrate how modifications through a view affect the underlying collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/views.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ndef negate(xs: collection.mutable.Seq[Int]) =\n           for (i <- 0 until xs.length) xs(i) = -xs(i)\n```\n\n----------------------------------------\n\nTITLE: Adding Behavior to Order Class (Scala)\nDESCRIPTION: Extends the `Order` class to include methods for managing the list of pizzas within the order (`addPizza`, `removePizza`). It also includes method signatures (`getBasePrice`, `getTaxes`, `getTotalPrice`) using `???` as placeholders for price calculation methods that are not yet implemented. The class requires `scala.collection.mutable.ArrayBuffer` and depends on the `Pizza` and `Customer` classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/oop-pizza-example.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nclass Order (\n    val pizzas: ArrayBuffer[Pizza],\n    var customer: Customer\n) {\n\n    def addPizza(p: Pizza): Unit = pizzas += p\n    def removePizza(p: Pizza): Unit = pizzas -= p\n\n    // need to implement these\n    def getBasePrice(): Int = ???\n    def getTaxes(): Int = ???\n    def getTotalPrice(): Int = ???\n\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring build.sbt with ScalaTest Dependency\nDESCRIPTION: The build.sbt configuration file for a Scala project using ScalaTest. It defines the project name, version, Scala version, and adds the ScalaTest library dependency.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/sbt-scalatest-tdd.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nname := \"HelloScalaTest\"\nversion := \"1.0\"\nscalaVersion := \"{{site.scala-version}}\"\n\nlibraryDependencies +=\n    \"org.scalatest\" %% \"scalatest\" % \"3.2.19\" % Test\n```\n\n----------------------------------------\n\nTITLE: Defining a List of Various Types in Scala\nDESCRIPTION: This code creates a List of type List[Any], containing elements of different types such as String, Int, Char, Boolean, and a function. It demonstrates that all these elements are instances of scala.Any, showcasing Scala's unified object model for different types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/unified-types.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval list: List[Any] = List(\n  \"a string\",\n  732,  // integer\n  'c',  // character\n  true, // boolean value\n  () => \"文字列を返す無名関数\"\n)\n\nlist.foreach(element => println(element))\n```\n\n----------------------------------------\n\nTITLE: Using Generic Stack with Integer Type in Scala 3\nDESCRIPTION: Example of instantiating and using a generic Stack with Integer type in Scala 3, showing the new constructor syntax. The example demonstrates pushing and popping operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/generic-classes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval stack = Stack[Int]\nstack.push(1)\nstack.push(2)\nprintln(stack.pop())  // выведет 2\nprintln(stack.pop())  // выведет 1\n```\n\n----------------------------------------\n\nTITLE: Implementing Classes with Traits in Scala 2 and Scala 3\nDESCRIPTION: Shows how classes extend multiple traits to combine behaviors. The 'Dog' class implements the abstract 'speak' method and inherits other behaviors, illustrating trait extension syntax for Scala 2 (using 'extends' and 'with') and Scala 3 (using comma separation). Also demonstrates method overriding.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-modeling.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass Dog(name: String) extends Speaker with TailWagger with Runner {\n  def speak(): String = \"Woof!\"\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass Cat(name: String) extends Speaker with TailWagger with Runner {\n  def speak(): String = \"Meow\"\n  override def startRunning(): Unit = println(\"Yeah ... I don’t run\")\n  override def stopRunning(): Unit = println(\"No need to stop\")\n}\n```\n\n----------------------------------------\n\nTITLE: Manually Constructing Scala ASTs\nDESCRIPTION: Demonstrates the low-level, manual construction of an AST for `println(2)` using `Apply`, `Ident`, `TermName`, `Literal`, and `Constant` from the Scala reflection API (`scala.reflect.runtime.universe`). This approach offers maximum flexibility but is verbose and fragile, typically used when other methods like `reify` or `parse` are unsuitable, such as assembling trees from dynamically created parts that don't form valid Scala code in isolation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_34\n\nLANGUAGE: scala\nCODE:\n```\nscala> Apply(Ident(TermName(\"println\")), List(Literal(Constant(2))))\nres0: scala.reflect.runtime.universe.Apply = println(2)\n```\n\n----------------------------------------\n\nTITLE: Using Parallel Hash Sets in Scala\nDESCRIPTION: Example of creating a mutable parallel hash set and performing a map operation on it. Parallel hash tables store elements in internal arrays with positions determined by hash codes of elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/parallel-collections/concrete-parallel-collections.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval phs = scala.collection.parallel.mutable.ParHashSet(1 until 2000: _*)\nphs: scala.collection.parallel.mutable.ParHashSet[Int] = ParHashSet(18, 327, 736, 1045, 773, 1082,...\n\nphs map (x => x * x)\nres0: scala.collection.parallel.mutable.ParHashSet[Int] = ParHashSet(2181529, 2446096, 99225, 2585664,...\n```\n\n----------------------------------------\n\nTITLE: Enable and Configure Paradox Site in sbt - Scala\nDESCRIPTION: This Scala configuration snippet enables the ParadoxSitePlugin and SitePreviewPlugin in the build and sets the Paradox source directory. Place these lines in build.sbt to generate documentation with sbt-site using Paradox, with sources located in the 'documentation' directory. Prerequisites include having the plugin installed and a properly structured documentation folder. Outputs are generated HTML documentation and optional preview tasks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nenablePlugins(ParadoxSitePlugin, SitePreviewPlugin)\nParadox / sourceDirectory := sourceDirectory.value / \"documentation\"\n```\n\n----------------------------------------\n\nTITLE: Conceptual Override of `take` for RNA1 in Scala\nDESCRIPTION: Presents a conceptual example of overriding the `take` method within the `RNA1` class. This approach calls the superclass's `take` method and then converts the resulting sequence back into an `RNA1` instance using `RNA1.fromSeq` to ensure the method returns the desired custom type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-collections.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef take(count: Int): RNA1 = RNA1.fromSeq(super.take(count))\n```\n\n----------------------------------------\n\nTITLE: Correct and Incorrect Pattern Matching Syntax in Scala Anonymous Functions\nDESCRIPTION: This snippet demonstrates the use of pattern matching with anonymous functions inside higher-order functions such as map. The correct usage requires the 'case' keyword to destructure tuple arguments; omitting 'case' results in a compilation error. It highlights the importance of the 'case' keyword for pattern matching in anonymous functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/cheatsheets/index.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\n(xs zip ys) map {\n  case (x, y) => x * y\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(xs zip ys) map {\n  (x, y) => x * y\n}\n```\n\n----------------------------------------\n\nTITLE: Java interoperability annotations and their syntax differences in Scala\nDESCRIPTION: This snippet and explanation compare Java annotations, which require key-value pairs and default values, with Scala's more flexible annotation application. It highlights syntax differences, such as using named parameters and omitting key when 'value' element is used, facilitating Java annotation use in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/annotations.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n/* Applying Java annotation with parameters in Scala */\n@Source(URL = \"https://coders.com/\",\n        mail = \"support@coders.com\")\nclass MyScalaClass ...\n```\n\nLANGUAGE: Scala\nCODE:\n```\n/* Applying Java annotation with default 'value' element in Scala simplifying syntax */\n@SourceURL(\"https://coders.com/\")\nclass MyScalaClass ...\n```\n\nLANGUAGE: Scala\nCODE:\n```\n/* Combining multiple parameters including optional ones in Scala */\n@SourceURL(\"https://coders.com/\",\n           mail = \"support@coders.com\")\nclass MyScalaClass ...\n```\n\n----------------------------------------\n\nTITLE: Defining Auxiliary Constructors in Java\nDESCRIPTION: This Java code defines a `Person` class with a primary constructor and multiple auxiliary constructors. Auxiliary constructors delegate to the primary constructor or another auxiliary constructor using `this()`, providing different ways to instantiate the object with default values for missing parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_4\n\nLANGUAGE: Java\nCODE:\n```\npublic class Person {\n  public String firstName;\n  public String lastName;\n  public int age;\n\n  // primary constructor\n  public Person(\n    String firstName,\n    String lastName,\n    int age\n  ) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.age = age;\n  }\n\n  // zero-arg constructor\n  public Person() {\n    this(\"\", \"\", 0);\n  }\n\n  // one-arg constructor\n  public Person(String firstName) {\n    this(firstName, \"\", 0);\n  }\n\n  // two-arg constructor\n  public Person(\n    String firstName,\n    String lastName\n  ) {\n    this(firstName, lastName, 0);\n  }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Error Message when Using Scala 2 Macros in Scala 3\nDESCRIPTION: This snippet shows the compiler error that occurs when attempting to use a Scala 2.13 macro in a Scala 3 project. The error explains that Scala 2 macros cannot be used in Scala 3 and offers the option to use '-Xignore-scala2-macros' to turn the error into a warning.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/compatibility-metaprogramming.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n -- Error: /src/main/scala/example/Example.scala:10:45 \n 10 |  val documentFormat = Json.format[Document]\n    |                            ^\n    |Scala 2 macro cannot be used in Scala 3. See https://dotty.epfl.ch/docs/reference/dropped-features/macros.html\n    |To turn this error into a warning, pass -Xignore-scala2-macros to the compiler\n```\n\n----------------------------------------\n\nTITLE: Minimal Scala値クラスの定義例\nDESCRIPTION: Scalaで`AnyVal`を継承し、単一の`val`パラメータを持つ値クラスの定義例。値クラスはコンパイル時には`Wrapper`型だが、実行時には`Int`型のデータとして扱われる。これにより、オブジェクト割り当てを避けつつ型安全を維持できる。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/value-classes.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass Wrapper(val underlying: Int) extends AnyVal\n```\n\n----------------------------------------\n\nTITLE: Defining Traits with Concrete and Abstract Methods in Scala\nDESCRIPTION: Defines a Scala trait Adder with an abstract method add and a concrete method multiply with a default implementation. Traits in Scala can contain both abstract and concrete methods, allowing flexible code reuse. The syntax uses the colon (:) and indentation for method bodies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\ntrait Adder:\n  def add(a: Int, b: Int): Int\n  def multiply(a: Int, b: Int): Int =\n    a * b\n```\n\n----------------------------------------\n\nTITLE: Filtering for Subdirectories with os.isDir in Scala\nDESCRIPTION: This code filters the listed directory entries to include only subdirectories by applying the os.isDir predicate, which identifies directory paths from the list of all directory contents.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/os-read-directory.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval dirs: Seq[os.Path] = os.list(os.root / \"etc\").filter(os.isDir)\n```\n\n----------------------------------------\n\nTITLE: Basic URI interpolation with automatic character escaping in Scala\nDESCRIPTION: Demonstrates how to use the uri interpolator to create URIs with variables, showing automatic escaping of special characters like spaces.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/http-client-uris.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport sttp.client4.quick._\nimport sttp.model.Uri\n\nval book = \"programming in scala\"\nval bookUri: Uri = uri\"https://example.com/books/$book\"\n\nprintln(bookUri)\n// prints: https://example.com/books/programming%20in%20scala\n```\n\n----------------------------------------\n\nTITLE: Compiler Error for Missing ClassTag on Generic Array Creation\nDESCRIPTION: Shows the compiler error message produced when attempting to instantiate 'new Array[T]' without providing a ClassTag. The error indicates that the class manifest (specifically, ClassTag) for element type T cannot be found.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/arrays.md#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nerror: cannot find class manifest for element type T\n  val arr = new Array[T]((arr.length + 1) / 2)\n            ^\n```\n\n----------------------------------------\n\nTITLE: Defining a case class and objects in a package\nDESCRIPTION: This snippet shows how to define a case class 'Fruit' and three objects extending it within the package 'gardening.fruits'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/package-objects.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// in file gardening/fruits/Fruit.scala\npackage gardening.fruits\n\ncase class Fruit(name: String, color: String)\nobject Apple extends Fruit(\"Apple\", \"green\")\nobject Plum extends Fruit(\"Plum\", \"blue\")\nobject Banana extends Fruit(\"Banana\", \"yellow\")\n```\n\n----------------------------------------\n\nTITLE: Implicit Conversions Enable String Collection Methods\nDESCRIPTION: This snippet explains how Scala uses two implicit conversions: one from String to WrappedString for collection-like methods such as reverse, map, drop, and slice, and another from String to StringOps for extending all immutable collection methods. These conversions are automatically applied to allow string operations similar to collection functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/strings.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n // Implicit conversions are automatically applied in method calls\n // String to WrappedString for collection operations\n // String to StringOps for further collection methods\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Logarithm Class in Scala\nDESCRIPTION: A class-based approach to represent logarithmic values. This implementation wraps Double values with a Logarithm class, providing methods for arithmetic operations, but introduces boxing overhead.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-opaque-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Logarithm(protected val underlying: Double):\n  def toDouble: Double = math.exp(underlying)\n  def + (that: Logarithm): Logarithm =\n    // here we use the apply method on the companion\n    Logarithm(this.toDouble + that.toDouble)\n  def * (that: Logarithm): Logarithm =\n    new Logarithm(this.underlying + that.underlying)\n\nobject Logarithm:\n  def apply(d: Double): Logarithm = new Logarithm(math.log(d))\n```\n\n----------------------------------------\n\nTITLE: Defining a Graph with Inner Node Class in Scala\nDESCRIPTION: Defines a basic graph class containing an inner class Node that holds connections to other nodes of the same graph instance. The Graph class maintains a list of nodes, and the Node class allows connecting to other nodes with deduplication. This design ties each Node instance to its enclosing Graph instance, exemplifying Scala's inner class semantics. No external dependencies beyond the Scala standard library are required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/inner-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Graph {\n  class Node {\n    var connectedNodes: List[Node] = Nil\n    def connectTo(node: Node): Unit = {\n      if (!connectedNodes.exists(node.equals)) {\n        connectedNodes = node :: connectedNodes\n      }\n    }\n  }\n  var nodes: List[Node] = Nil\n  def newNode: Node = {\n    val res = new Node\n    nodes = res :: nodes\n    res\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Scala Set with Duplicate Elements\nDESCRIPTION: Demonstrates that duplicate elements in a Scala Set literal, such as Set(1,2,1), are automatically removed, resulting in Set(1,2), showing uniqueness enforcement.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\nval set = Set(1,2,1)\n// set: Set(1,2)\n```\n\n----------------------------------------\n\nTITLE: Converting Iterator to BufferedIterator and Demonstrating Lookahead in Scala\nDESCRIPTION: This snippet illustrates how to convert a standard Iterator[Int] to a BufferedIterator[Int] using the buffered method. It demonstrates accessing the head element without advancing the iterator, then advancing with next(), showing that head returns the next element without moving forward, while next() consumes the element.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/iterators.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval it = Iterator(1, 2, 3, 4)\nval bit = it.buffered\nbit.head\nbit.next()\nbit.next()\n```\n\n----------------------------------------\n\nTITLE: Implementing the final version of RNA sequence class with proper builder support\nDESCRIPTION: The complete implementation of RNA class that handles all collection operations correctly, including map and ++, by providing an implicit CanBuildFrom in the companion object and optimizing the foreach method for better performance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/architecture-of-scala-collections.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nfinal class RNA private (val groups: Array[Int], val length: Int)\n  extends IndexedSeq[Base] with IndexedSeqLike[Base, RNA] {\n\n  import RNA._\n\n  // 在IndexedSeq中必须重新实现newBuilder\n  override protected[this] def newBuilder: Builder[Base, RNA] =\n    RNA.newBuilder\n\n  // 在IndexedSeq中必须实现apply\n  def apply(idx: Int): Base = {\n    if (idx < 0 || length <= idx)\n      throw new IndexOutOfBoundsException\n    Base.fromInt(groups(idx / N) >> (idx % N * S) & M)\n  }\n\n  // （可选）重新实现foreach,\n  // 来提高效率\n  override def foreach[U](f: Base => U): Unit = {\n    var i = 0\n    var b = 0\n    while (i < length) {\n      b = if (i % N == 0) groups(i / N) else b >>> S\n      f(Base.fromInt(b & M))\n      i += 1\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Thrown Exceptions in Scala for Java Interoperability\nDESCRIPTION: Demonstrates using the `@throws` annotation in Scala (versions 2 and 3) to declare that a method throws an exception. This allows the Java compiler to recognize the checked exception, forcing Java callers to handle it using try-catch blocks or by declaring it further.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/interacting-with-java.md#_snippet_0\n\nLANGUAGE: Scala 2\nCODE:\n```\nobject SExceptionThrower {\n  @throws[Exception]\n  def exceptionThrower =\n    throw new Exception(\"Idiomatic Scala methods don’t throw exceptions\")\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nobject SExceptionThrower:\n  @throws[Exception]\n  def exceptionThrower =\n    throw Exception(\"Idiomatic Scala methods don’t throw exceptions\")\n```\n\n----------------------------------------\n\nTITLE: Proposed Signature for Overriding `take` in Scala Custom Collection\nDESCRIPTION: Illustrates the method signature required if attempting to override the `take` method within a custom Scala collection (like `Capped1`) to ensure it returns an instance of the custom type instead of a default collection type. This approach is generally discouraged due to the large number of methods needing similar overrides for consistency.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef take(count: Int): Capped1 = …\n```\n\n----------------------------------------\n\nTITLE: Variable assignment examples in Python and Scala\nDESCRIPTION: Shows how to declare and initialize variables in Python and Scala, including integers, strings, lists, dictionaries/maps, sets, and tuples. The examples demonstrate syntax differences and similarities, emphasizing immutability with 'val' and mutability with 'var' in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nx = 1\nx = \"Hi\"\nx = \"\"\"foo\n      bar\n      baz\"\"\"\n```\n\nLANGUAGE: scala\nCODE:\n```\nval x = 1\nval x = \"Hi\"\nval y = \"\"\"foo\n             bar\n             baz\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Matching Multiple Data Types and Using Type Patterns in Scala\nDESCRIPTION: This code defines an object demonstrating pattern matching over different types, including integers and strings. It shows how to match specific values and use type patterns to bind values of certain types to variables within match cases, highlighting Scala's flexible pattern matching capabilities.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/pattern-matching.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject MatchTest2 extends App {\n  def matchTest(x: Any): Any = x match {\n    case 1 => \"one\"\n    case \"two\" => 2\n    case y: Int => \"scala.Int\"\n  }\n  println(matchTest(\"two\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Module Abstraction for Logarithms in Scala\nDESCRIPTION: An abstract trait defining operations for logarithmic values using type abstraction. This approach defines a module interface with abstract types and operations, along with extension methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-opaque-types.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait Logarithms:\n\n  type Logarithm\n\n  // operations on Logarithm\n  def add(x: Logarithm, y: Logarithm): Logarithm\n  def mul(x: Logarithm, y: Logarithm): Logarithm\n\n  // functions to convert between Double and Logarithm\n  def make(d: Double): Logarithm\n  def extract(x: Logarithm): Double\n\n  // extension methods to use `add` and `mul` as \"methods\" on Logarithm\n  extension (x: Logarithm)\n    def toDouble: Double = extract(x)\n    def + (y: Logarithm): Logarithm = add(x, y)\n    def * (y: Logarithm): Logarithm = mul(x, y)\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Notification Types in Scala\nDESCRIPTION: Defines a function 'mostrarNotificacao' using pattern matching to generate different messages depending on the notification type ('Email', 'SMS', 'VoiceRecording'). Demonstrates pattern matching with case classes and extracting data from their fields.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/case-classes.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ndef mostrarNotificacao(notificacao: Notification): String = {\n  notificacao match {\n    case Email(email, title, _) =>\n      \"Você recebeu um email de \" + email + \" com o título: \" + title\n    case SMS(number, message) =>\n      \"Você recebeu um SMS de\" + number + \"! Mensagem: \" + message\n    case VoiceRecording(name, link) =>\n      \"Você recebeu uma Mensagem de Voz de \" + name + \"! Clique no link para ouvir: \" + link\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using foldLeft with explicit initial value and lambda function\nDESCRIPTION: This example demonstrates invoking foldLeft on a list of integers with an initial value of 0 and an anonymous function that sums two integers. It highlights the typical use of multiple parameter lists to pass a function separately from other parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/multiple-parameter-lists.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nval res = numbers.foldLeft(0)((m, n) => m + n)\nprintln(res) // 55\n```\n\n----------------------------------------\n\nTITLE: Importing Scala Reflection Universe in Scala\nDESCRIPTION: This snippet imports the scala.reflect.runtime.universe package, which is essential for any operation involving Scala's runtime reflection, including manipulating or inspecting types, symbols, and trees. No parameters are taken, and the import is required as a prerequisite for the subsequent reflective operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/annotations-names-scopes.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n```\n\n----------------------------------------\n\nTITLE: Creating Initial Pizza Data Class (Scala)\nDESCRIPTION: Defines the initial `Pizza` class focusing purely on its data structure. It holds mutable properties for `crustSize`, `crustType`, and a mutable `ArrayBuffer` of `toppings`. This class requires `scala.collection.mutable.ArrayBuffer` and depends on the previously defined `CrustSize`, `CrustType`, and `Topping` types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/oop-pizza-example.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable.ArrayBuffer\n\nclass Pizza (\n    var crustSize: CrustSize,\n    var crustType: CrustType,\n    var toppings: ArrayBuffer[Topping]\n)\n```\n\n----------------------------------------\n\nTITLE: Including Scala Toolkit Libraries with Dependency Management in Scala\nDESCRIPTION: This snippet shows how to include the Scala Toolkit libraries, including os-lib, by specifying the 'toolkit' dependency in Scala CLI directives. It allows access to multiple useful libraries beyond os-lib, enabling broader filesystem, testing, or JSON functionalities.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/getting-started/install-scala.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\n//> using scala {{site.scala-3-version}}\n//> using toolkit 0.5.0\n\n@main\ndef countFiles(): Unit =\n  val paths = os.list(os.pwd)\n  println(paths.length)\n```\n\n----------------------------------------\n\nTITLE: Using TypeTag to Inspect Runtime Types in Scala\nDESCRIPTION: Demonstrates how to obtain and use a TypeTag to inspect the complete type information of a generic object at runtime, including handling implicit parameters and context bounds. This allows access to detailed type details such as type arguments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/overview.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.runtime.{universe => ru}\n\ndef getTypeTag[T: ru.TypeTag](obj: T) = ru.typeTag[T]\n\nval l = List(1, 2, 3)\nval theType = getTypeTag(l).tpe\nprintln(theType)  // Outputs: List[Int]\n\nval decls = theType.decls.take(10)\nprintln(decls)  // Prints a few declarations of the type\n```\n\n----------------------------------------\n\nTITLE: Scala Concrete Iterator Class for String Characters\nDESCRIPTION: This snippet implements 'StringIterator', a concrete class extending 'AbsIterator' with type 'Char'. It iterates over a given string, providing implementations for 'hasNext' and 'next', enabling character-by-character traversal of the string.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/mixin-class-composition.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass StringIterator(s: String) extends AbsIterator {\n  type T = Char\n  private var i = 0\n  def hasNext = i < s.length\n  def next() = {\n    val ch = s charAt i\n    i += 1\n    ch\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Scala Hello World App Using val\nDESCRIPTION: This code illustrates a minimal Scala application that defines a val named hello to store the greeting string. The object extends App enabling it to run as a program. The code prints the immutable hello value to the console. Save as Hello3.scala and run with scala command. Requires standard Scala runtime.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/two-types-variables.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nobject Hello3 extends App {\n    val hello = \"Hello, world\"\n    println(hello)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Parallel Map Benchmark in Scala\nDESCRIPTION: A benchmark implementation that tests the performance of mapping operations on a ParTrieMap with configurable parallelism and collection size. Uses scala.testing.Benchmark trait to measure execution time across multiple runs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/parallel-collections/performance.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport collection.parallel.mutable.ParTrieMap\nimport collection.parallel.ForkJoinTaskSupport\n\nobject Map extends testing.Benchmark {\n  val length = sys.props(\"length\").toInt\n  val par = sys.props(\"par\").toInt\n  val partrie = ParTrieMap((0 until length) zip (0 until length): _*)\n\n  partrie.tasksupport = new ForkJoinTaskSupport(new scala.concurrent.forkjoin.ForkJoinPool(par))\n\n  def run = {\n    partrie map {\n      kv => kv\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a generic 'pair' method with multiple type parameters in Scala\nDESCRIPTION: This snippet exemplifies a simple Scala method 'pair' that accepts two type parameters, A and B, interleaved with term parameters, allowing flexible multiple type parameter lists. It demonstrates method signature extension to support such interleaving to enable more expressive API design.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/clause-interleaving.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef pair[A](a: A)[B](b: B): (A, B) = (a, b)\n```\n\n----------------------------------------\n\nTITLE: Define Initial `greet` Method Returning a Function (Scala)\nDESCRIPTION: Defines a simple Scala method named `greet` that takes no parameters and returns a function. The returned function accepts a `String` parameter (`name`) and prints a fixed greeting including the name. This demonstrates the basic syntax for declaring a method that returns a function of type `String => Unit`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-write-method-returns-function.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef greet()\n// Method signature stub\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef greet(): String => Unit = ???\n           ----------------\n// Method signature with return type `String => Unit`\n```\n\nLANGUAGE: Scala\nCODE:\n```\n(name: String) => println(s\"Hello, $name\")\n// Anonymous function definition\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// a method that returns a function\ndef greet(): String => Unit = \n  (name: String) => println(s\"Hello, $name\")\n```\n\n----------------------------------------\n\nTITLE: Example Usage of the isTruthy Method in Scala\nDESCRIPTION: Provides several example calls to the `isTruthy` method (defined previously), demonstrating its behavior with various input types and values (integers, booleans, strings, floats) and showing the resulting `Boolean` output. This snippet is compatible with both Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_30\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\nisTruthy(0)      // false\nisTruthy(false)  // false\nisTruthy(\"\")     // false\nisTruthy(1)      // true\nisTruthy(\" \")    // true\nisTruthy(2F)     // true\n```\n\n----------------------------------------\n\nTITLE: Adding Specific OS-Lib Version in sbt Build File - Scala\nDESCRIPTION: This code snippet shows how to add a specific OS-Lib version as a dependency in an sbt project by updating 'build.sbt'. It uses 'libraryDependencies' to include 'com.lihaoyi' version '0.11.3' of 'os-lib'. This pattern can be combined with other dependencies and requires the sbt build tool.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-os-lib.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"com.lihaoyi\" %% \"os-lib\" % \"0.11.3\"\n```\n\n----------------------------------------\n\nTITLE: Implementing a Normal Method with a Retained Inline Method in Scala\nDESCRIPTION: Illustrates a scenario where an `inline` method (`PrintLogger.log`) implements a non-inline method from a trait (`Logger.log`). This creates a 'retained inline' method: the inline implementation exists for direct calls, but bytecode is also generated for runtime dispatch via the trait.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Logger:\n  def log(x: Any): Unit\n\nclass PrintLogger extends Logger:\n  inline def log(x: Any): Unit = println(x)\n```\n\n----------------------------------------\n\nTITLE: Performing Basic Operations on Scala Arrays (REPL)\nDESCRIPTION: Demonstrates creating a Scala Array, mapping elements using a function, filtering elements based on a condition, and reversing the array. These examples show that Scala arrays support standard sequence operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/arrays.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nscala> val a1 = Array(1, 2, 3)\na1: Array[Int] = Array(1, 2, 3)\nscala> val a2 = a1 map (_ * 3)\na2: Array[Int] = Array(3, 6, 9)\nscala> val a3 = a2 filter (_ % 2 != 0)\na3: Array[Int] = Array(3, 9)\nscala> a3.reverse\nres0: Array[Int] = Array(9, 3)\n```\n\n----------------------------------------\n\nTITLE: Equating Literal Patterns Using Scala Quasiquotes\nDESCRIPTION: Shows how literal patterns represent literals at the AST level and how to check equivalence of two literal quasiquotes using the `equalsStructure` method. Requires knowledge of Scala's reflection API and AST structure. Input literals like `pq\"1\"` are compared for structural equality producing a Boolean output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/pattern-details.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval equivalent = pq\"1\" equalsStructure q\"1\"\nequivalent: Boolean = true\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Multiple Data Types in Scala\nDESCRIPTION: This snippet shows a function that performs pattern matching on a value of type 'Any', matching specific integer and string cases, as well as a type-based pattern for integers. It demonstrates handling different data types and extracting data using pattern matching, emphasizing Scala's type system flexibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/pattern-matching.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject MatchTest2 extends App {\n  def matchTest(x: Any): Any = x match {\n    case 1 => \"one\"\n    case \"two\" => 2\n    case y: Int => \"scala.Int\"\n  }\n  println(matchTest(\"two\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel and Sequential Reduce Benchmarks in Scala\nDESCRIPTION: Comparison benchmarks for parallel and sequential vector reduction operations. Demonstrates how to set up both parallel and sequential variants to compare performance at different collection sizes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/parallel-collections/performance.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport collection.parallel.immutable.ParVector\n\nobject Reduce extends testing.Benchmark {\n  val length = sys.props(\"length\").toInt\n  val par = sys.props(\"par\").toInt\n  val parvector = ParVector((0 until length): _*)\n\n  parvector.tasksupport = new collection.parallel.ForkJoinTaskSupport(new scala.concurrent.forkjoin.ForkJoinPool(par))\n\n  def run = {\n    parvector reduce {\n      (a, b) => a + b\n    }\n  }\n}\n\nobject ReduceSeq extends testing.Benchmark {\n  val length = sys.props(\"length\").toInt\n  val vector = collection.immutable.Vector((0 until length): _*)\n\n  def run = {\n    vector reduce {\n      (a, b) => a + b\n    }\n  }\n  \n}\n```\n\n----------------------------------------\n\nTITLE: Constructing a Tuple in Scala (Scala mdoc)\nDESCRIPTION: Demonstrates how to instantiate a tuple with two elements—a String and an Int—using Scala syntax. No additional dependencies are required. The variable 'ingredient' will have the inferred type (String, Int) and contains the elements 'Sugar' and 25.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/tuples.md#_snippet_0\n\nLANGUAGE: Scala mdoc\nCODE:\n```\nval ingredient = (\"Sugar\", 25)\n```\n\n----------------------------------------\n\nTITLE: Correct factory method usage vs direct abstract type instantiation in Scala\nDESCRIPTION: Demonstrates a bad practice of instantiating an abstract type directly (`new List[Int]`) which results in a type error, contrasted with the recommended approach of using a factory method call `List(1,2,3)` that implicitly applies the type parameters and creates a properly typed instance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_25\n\nLANGUAGE: Scala\nCODE:\n```\nnew List[Int]  // bad\nList(1,2,3)     // good\n```\n\n----------------------------------------\n\nTITLE: Defining a trait with an abstract type in Scala\nDESCRIPTION: This snippet defines a trait 'Buffer' with an abstract type member 'T' and a value 'element' of type 'T'. It demonstrates how to declare abstract types for flexible subtype implementations. Dependencies include standard Scala traits. Inputs are not provided; the output is the abstract type declaration, used in extending classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tour/abstract-type-members.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Buffer {\n  type T\n  val element: T\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Traits and Implementing Them\nDESCRIPTION: Shows trait declaration with abstract method and default implementation, inheritance with 'extends', method overriding with 'override', and creating classes implementing traits. Demonstrates trait composition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/basics.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Greeter {\n  def greet(name: String): Unit\n}\ntrait Greeter {\n  def greet(name: String): Unit =\n    println(\"Hello, \" + name + \"!\")\n}\nclass DefaultGreeter extends Greeter\n\nclass CustomizableGreeter(prefix: String, postfix: String) extends Greeter {\n  override def greet(name: String): Unit = {\n    println(prefix + name + postfix)\n  }\n}\nval greeter = new DefaultGreeter()\ngreeter.greet(\"Scala developer\") // Hello, Scala developer!\n\nval customGreeter = new CustomizableGreeter(\"How are you, \", \"?\")\ncustomGreeter.greet(\"Scala developer\") // How are you, Scala developer?\n```\n\n----------------------------------------\n\nTITLE: Defining Cross-Compatible Location Case Class\nDESCRIPTION: Defines the cross-version case class 'Location' shared by both Scala 2.13 and Scala 3 implementations. Placed in the common source directory, it represents a source code location with file path and line number. No special dependencies are required and it is used by both Scala 2 and 3 macros.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-macro-cross-building.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n// example/src/main/scala/location/Location.scala\npackage location\n\ncase class Location(path: String, line: Int)\n```\n\n----------------------------------------\n\nTITLE: Running GluonFX App Locally (Maven)\nDESCRIPTION: Executes the Scala application using the GluonFX Maven plugin for rapid local GUI testing and development without native compilation. This command should be run within the Maven project directory. Requires a Maven project configured with the GluonFX plugin.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-on-android.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nmvn gluonfx:run\n```\n\n----------------------------------------\n\nTITLE: Creating and Manipulating Mutable BitSets in Scala\nDESCRIPTION: This snippet demonstrates how to create an empty mutable BitSet and add elements to it. It shows the creation of an empty BitSet followed by adding integers 1 and 3 using the += operator, with the BitSet being modified in place rather than creating new instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/concrete-mutable-collection-classes.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval bits = scala.collection.mutable.BitSet.empty\nbits += 1\nbits += 3\nbits\n```\n\n----------------------------------------\n\nTITLE: Performing Arithmetic Operations with BigInt in Scala\nDESCRIPTION: Shows usage of familiar arithmetic operators (+, *) on BigInt instances to compute sums and products of arbitrarily large integers. Illustrates how these types behave like normal numeric types but without standard size limitations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/first-look-at-types.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nval b = BigInt(1234567890)   // scala.math.BigInt = 1234567890\nval c = b + b                // scala.math.BigInt = 2469135780\nval d = b * b                // scala.math.BigInt = 1524157875019052100\n```\n\n----------------------------------------\n\nTITLE: 値クラスの継承制約例\nDESCRIPTION: 値クラスは他のクラスやトレイトを継承できない例。`NotUniversal`トレイトと`Value`クラスでエラーになる。値クラスは`final`修飾子が暗黙的に設定されており、継承が制限されていることを示す例。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/value-classes.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ntrait NotUniversal\nclass Value(val x: Int) extends AnyVal with NotUniversal\nclass Extend(x: Int) extends Value(x)\n```\n\n----------------------------------------\n\nTITLE: Valid Dependencies Output from migrateDependencies (Sbt Console)\nDESCRIPTION: This snippet shows the 'Valid dependencies' section of the `migrateDependencies` command output. These dependencies are compatible with Scala 3 as they are, either because they are Java libraries or have been cross-published to Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/scala3-migrate.md#_snippet_3\n\nLANGUAGE: Sbt Console\nCODE:\n```\n[info] <span style=\"color:green\">Valid dependencies:</span>\n[info] \"io.github.java-diff-utils\" % \"java-diff-utils\" % \"4.12\"\n```\n\n----------------------------------------\n\nTITLE: Reflecting an Instance to Obtain an InstanceMirror - Scala\nDESCRIPTION: Defines a simple class 'C' with a method 'x', then reflects an instance of 'C' to obtain an InstanceMirror using a runtime mirror (from Scala reflection). Required: a defined class and a runtime mirror instance 'm'. Output is an InstanceMirror bound to a new 'C' object, enabling further reflective member access.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/environment-universes-mirrors.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass C { def x = 2 }\nval im = m.reflect(new C)\n```\n\n----------------------------------------\n\nTITLE: Processing Multiple Option Values with For Expressions in Scala\nDESCRIPTION: Example showing how to work with multiple Option values using for comprehensions. This technique only yields a value if all operations succeed (all options are Some), otherwise returns None, enabling concise composition of operations that might fail.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fp-functional-error-handling.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval y = for\n  a <- makeInt(stringA)\n  b <- makeInt(stringB)\n  c <- makeInt(stringC)\nyield\n  a + b + c\n```\n\n----------------------------------------\n\nTITLE: Disabling Compilation for a Specific Snippet\nDESCRIPTION: This Scala snippet shows how to prevent the snippet compiler from processing a specific code block. By adding the `sc:nocompile` flag after `scala` in the fenced code block declaration, the enclosed code (illustrating an internal transformation of `map`) will be ignored by the compiler during documentation generation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/snippet-compiler.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n```scala sc:nocompile\n// under the hood `map` is transformed into\nList(1).map( _  + 1)(<implicits>)\n```\n```\n\n----------------------------------------\n\nTITLE: Creating an IndexedSeq Resulting in a Vector in Scala\nDESCRIPTION: This snippet shows how to create an immutable IndexedSeq which defaults to using a Vector internally for efficient indexed access and updates. This demonstrates Scala's recommendation of Vector as the default immutable indexed sequence due to its balanced performance characteristics.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-immutable-collection-classes.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nscala> collection.immutable.IndexedSeq(1, 2, 3)\nres2: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Extending Traits in Scala Package Object\nDESCRIPTION: Shows a package object named fruits that extends multiple traits, FruitAliases and FruitHelpers. This example illustrates that package objects can inherit traits and classes, allowing the consolidation of helper methods, aliases, and shared utilities in one place accessible to the entire package.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/package-objects.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\npackage object fruits extends FruitAliases with FruitHelpers {\n  // tutaj znajdują się pomocniki (helpers) i zmienne\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Method with TypeTag Context\nDESCRIPTION: Defines a helper function `getType` that takes an object and uses an implicit `TypeTag` to capture its type. The `TypeTag` is provided by the compiler via the `T: TypeTag` context bound, allowing `typeOf[T]` to work at runtime.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nscala> def getType[T: TypeTag](obj: T) = typeOf[T]\ngetType: [T](obj: T)(implicit evidence$1: scala.reflect.runtime.universe.TypeTag[T])scala.reflect.runtime.universe.Type\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Method in Scala 3\nDESCRIPTION: Shows the basic syntax for defining a method in Scala 3 using the `def` keyword, specifying parameters with types, and an optional return type. The method body follows the `=` and uses indentation; curly braces are optional for single-expression bodies. An optional `end methodName` marker can be used.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef methodName(param1: Type1, param2: Type2): ReturnType =\n  // the method body\n  // goes here\nend methodName   // this is optional\n```\n\n----------------------------------------\n\nTITLE: flatMap Signature for Set Using IterableOnce - Scala 2 and 3\nDESCRIPTION: Shows the signature of the flatMap method on Set, which takes a function returning an IterableOnce. Applies to both Scala 2 and Scala 3. This method is foundational for using Option as an IterableOnce argument in higher-order functions like flatMap. Key parameter: f, a function from Int to an IterableOnce of type B; returns Set[B].\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/conversion-between-option-and-the-collections.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef flatMap[B](f: Int => IterableOnce[B]): Set[B]\n```\n\n----------------------------------------\n\nTITLE: Showing Potential Interaction Between Star Infix Type and Repeated Parameters\nDESCRIPTION: This example demonstrates a potential edge case in the interaction between the * infix type operator and Scala's repeated parameters syntax (also using *). This interaction already exists in the current specification but is unlikely to cause practical issues.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/priority-based-infix-type-precedence.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntrait +[N1, N2]\ntrait *[N1, N2]\ntrait N1\ntrait N2\ndef foo(a : N1*N1+N2*) : Unit = {} //repeated parameter of type +[*[N1, N1], N2]\n```\n\n----------------------------------------\n\nTITLE: View Bounds No Longer Supported in Scala 3\nDESCRIPTION: Example showing how view bounds (A <% Long) that were deprecated but supported in Scala 2.13 are no longer valid in Scala 3. This requires explicit conversion handling.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-contextual-abstractions.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef foo[A <% Long](a: A): Long = a\n```\n\n----------------------------------------\n\nTITLE: Class with Private Mutable State in Scala 2\nDESCRIPTION: This snippet defines a Counter class with a private mutable var currentCount. The class provides tick to increment the state and count to read the state, enforcing encapsulation. This pattern is used to demonstrate private state management in OOP; no other dependencies are required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nclass Counter {\n  // can only be observed by the method `count`\n  private var currentCount = 0\n\n  def tick(): Unit = currentCount += 1\n  def count: Int = currentCount\n}\n```\n\n----------------------------------------\n\nTITLE: Matching on Scala 3 Enumeration Values\nDESCRIPTION: Demonstrates two ways to branch on enumeration values in Scala 3: using an if/then conditional and a match expression. It compares an enum value against constants and executes corresponding code blocks. This pattern matching capability is frequently used for control flow based on enumerated cases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_35\n\nLANGUAGE: scala\nCODE:\n```\n// if/then\nif currentCrustSize == Large then\n  println(\"You get a prize!\")\n\n// match\ncurrentCrustSize match\n  case Small => println(\"small\")\n  case Medium => println(\"medium\")\n  case Large => println(\"large\")\n```\n\n----------------------------------------\n\nTITLE: Example Calls to isTruthy Method\nDESCRIPTION: Provides example calls to the `isTruthy` method, demonstrating its behavior with various input types (integer, boolean, string, float). Shows inputs that evaluate to `false` according to the method's logic and inputs that evaluate to `true`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_32\n\nLANGUAGE: Scala\nCODE:\n```\nisTruthy(0)      // false\nisTruthy(false)  // false\nisTruthy(\"\")     // false\nisTruthy(1)      // true\nisTruthy(\" \")    // true\nisTruthy(2F)     // true\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Reference Class in Scala\nDESCRIPTION: This snippet defines a generic class `Reference[T]` that can hold a value of any specified type `T`. It demonstrates setting and getting the value with type safety, and explains the use of `_` for default initialization.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tutorials/scala-for-java-programmers.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nclass Reference[T] {\n  private var contents: T = _\n  def set(value: T) { contents = value }\n  def get: T = contents\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an OOP Class with a Primary Constructor in Java\nDESCRIPTION: Illustrates a standard Java class definition for `Person` with public mutable fields, a constructor to initialize them, and a `toString` method. This serves as a comparison point for the more concise Scala version.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\nclass Person {\n  public String firstName;\n  public String lastName;\n  public int age;\n  public Person(\n    String firstName, \n    String lastName,\n    int age\n  ) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.age = age;\n  }\n  public String toString() {\n    return String.format(\"%s %s is %d years old.\", firstName, lastName, age);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating a Failed Scala Future\nDESCRIPTION: Shows how a `Future` becomes 'failed' when the asynchronous computation within `Future.apply` throws an exception. In this example, attempting to call `getFriends()` on a `null` session object causes a `NullPointerException`, resulting in the `Future` `f` being completed with a failure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/futures.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval session = null\nval f: Future[List[Friend]] = Future {\n  session.getFriends()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Collections in Scala\nDESCRIPTION: Examples of creating various Scala collections using the apply method from companion objects, including empty collections and collections with initial elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/creating-collections-from-scratch.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nIterable()                // Пустая коллекция\nList()                    // Пустой список\nList(1.0, 2.0)            // Список с элементами 1.0, 2.0\nVector(1.0, 2.0)          // Вектор с элементами 1.0, 2.0\nIterator(1, 2, 3)         // Итератор возвращающий три целых числа.\nSet(dog, cat, bird)       // Множество с тремя объектами\nHashSet(dog, cat, bird)   // Хэш-множество с темиже объектами\nMap('a' -> 7, 'b' -> 0)   // Мапа с привязкой цифр к буквам\n```\n\n----------------------------------------\n\nTITLE: Running a Scala Program Using the scala Command (Bash)\nDESCRIPTION: This bash snippet runs a compiled Scala program named `hello` using the Scala runtime launcher. When executed, the program outputs \"Hello, world!\" to the console. This mimics running Java classes with the `java` command and requires prior successful compilation of the source code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-hello-world.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ scala hello\nHello, world!\n```\n\n----------------------------------------\n\nTITLE: Illustrating the Need for Compound Types in Scala 2 (Incomplete)\nDESCRIPTION: Presents an incomplete function `cloneAndReset` using Scala 2 syntax. It highlights the problem of needing an input object (`obj`) that supports both `clone` and `reset` methods, indicated by the placeholder type `?`, thus motivating the use of compound types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/compound-types.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef cloneAndReset(obj: ?): Cloneable = {\n  val cloned = obj.clone()\n  obj.reset\n  cloned\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Java Method with Checked Exception - Java\nDESCRIPTION: This snippet defines a Java method makeInt accepting a string and declaring throws NumberFormatException. Typical for Java, it signals that callers must handle NumberFormatException checked exception. Input is string s; output is an int. Implementation not shown. No special dependencies are needed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_62\n\nLANGUAGE: Java\nCODE:\n```\npublic int makeInt(String s)\nthrows NumberFormatException {\n  // code here to convert a String to an int\n}\n```\n\n----------------------------------------\n\nTITLE: Refined Types Simplified by Using Literal Types in Scala\nDESCRIPTION: Illustrates how refinement types can be more succinctly expressed by directly using literal types as type-level predicates without explicit Witness values. This approach simplifies refining an Int as greater than a literal integer value, enabling concise and clear constraints at the type level.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/42.type.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval a: Int Refined Greater[5] = 10\n\nval b: Int Refined Greater[4] = a\n```\n\n----------------------------------------\n\nTITLE: Accessing Tuple Elements by Position in Scala\nDESCRIPTION: Shows how to access individual tuple elements using underscore notation followed by the element index (e.g., _1 for first element). This is a common method for retrieving tuple data, where indexing starts at 1. Inputs are tuple instances, and outputs are individual element values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/tuples.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nt._1\n// returns 3\n\nt._2\n// returns \"Three\"\n\nt._3\n// returns Person(David)\n```\n\n----------------------------------------\n\nTITLE: Defining function with conditional return in Python and Scala\nDESCRIPTION: Shows how to define a method returning the minimum of two integer parameters using inline if-else logic within function bodies. Inputs: integers a and b; outputs: minimum value. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_28\n\nLANGUAGE: Scala\nCODE:\n```\ndef min(a: Int, b: Int): Int =\n  if a < b then a else b\n```\n\n----------------------------------------\n\nTITLE: Declaring Singleton Objects as Single Instance Definitions in Scala - Scala\nDESCRIPTION: Defines singleton objects using the object keyword. This snippet includes an IdFactory object that encapsulates a private mutable counter and exposes a create method generating unique IDs. Demonstrates accessing object methods without instantiation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/tour/basics.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nobject IdFactory {\n  private var counter = 0\n  def create(): Int = {\n    counter += 1\n    counter\n  }\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval newId: Int = IdFactory.create()\nprintln(newId) // 1\nval newerId: Int = IdFactory.create()\nprintln(newerId) // 2\n```\n\n----------------------------------------\n\nTITLE: Hiding Code Sections in Snippets (Scala)\nDESCRIPTION: Demonstrates the `//{ ... //}` syntax used within Scala code snippets to hide boilerplate code (like imports or initializations) from the rendered documentation view, while still including it for compilation. Hidden code can typically be expanded by the user.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/snippet-compiler.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\n//{\nimport scala.collection.immutable.List\n//}\nval intList: List[Int] = List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Adding sbt-mima-plugin for Binary Compatibility - Scala\nDESCRIPTION: Declares the sbt-mima-plugin in project/plugins.sbt to enable MiMa binary compatibility checking for Scala projects. Requires sbt build tool. Input: plugin coordinates; Output: sbt configured with MiMa tasks. Limit: Must be compatible with project's Scala and sbt versions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\naddSbtPlugin(\"com.typesafe\" % \"sbt-mima-plugin\" % \"1.1.2\")\n```\n\n----------------------------------------\n\nTITLE: Scala 2: Automatic Eta-Expansion Condition and Error Example\nDESCRIPTION: Explains that in Scala 2, implicit eta-expansion occurs only when the expected type is a function. Demonstrates an error when attempting to assign an un-eta-expanded method to a variable expecting a function type, emphasizing the need for explicit eta-expansion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-eta-expansion.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef isLessThan(x: Int, y: Int): Boolean = x < y\n\nval methods = List(isLessThan)\n// error: missing argument list for method isLessThan\n// Unapplied methods are only converted to functions when a function type is expected.\n```\n\n----------------------------------------\n\nTITLE: Defining an Abstract Class in Scala\nDESCRIPTION: Shows declaration of an abstract class in Scala which cannot be instantiated directly. Abstract classes are used as base classes to define abstract or partial implementations to be extended by concrete subclasses. The snippet uses an ellipsis to indicate body definitions. Prerequisites include understanding abstract members and subclassing in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/cheatsheets/index.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class D { ... }\n```\n\n----------------------------------------\n\nTITLE: Matching Quoted Types with Explicit Type Variables (Proposed Old Syntax) - Scala\nDESCRIPTION: Illustrates the initial proposed syntax for introducing explicit type variables (`t`, `tail`) within Scala quoted type patterns, demonstrating the use of bounds (`<: Tuple`) but still requiring backticks for references within the quote.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/quote-pattern-type-variable-syntax.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ncase '[ type t; List[`t`] ] => f[t]\ncase '[ type tail <: Tuple; *:[Int, `tail`] ] => g[tail]\n```\n\n----------------------------------------\n\nTITLE: Creating ScalaTest suite for MathUtils\nDESCRIPTION: A ScalaTest `AnyFunSuite` class that tests the `double` method with various inputs, demonstrating how to write basic unit tests in Scala using ScalaTest framework.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/tools-sbt.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\npackage math\n \nimport org.scalatest.funsuite.AnyFunSuite\n\nclass MathUtilsTests extends AnyFunSuite:\n\n  // test 1\n  test(\"'double' should handle 0\") {\n    val result = MathUtils.double(0)\n    assert(result == 0)\n  }\n\n  // test 2\n  test(\"'double' should handle 1\") {\n    val result = MathUtils.double(1)\n    assert(result == 2)\n  }\n \n  test(\"test with Int.MaxValue\") (pending)\n\nend MathUtilsTests\n```\n\n----------------------------------------\n\nTITLE: Converting Abstract Type Members to Type Parameters in Scala\nDESCRIPTION: Shows an alternative implementation using type parameters instead of abstract type members. Demonstrates how variance annotations are needed to hide the concrete sequence implementation type of objects returned from the factory method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/abstract-type-members.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Buffer[+T] {\n  val element: T\n}\nabstract class SeqBuffer[U, +T <: Seq[U]] extends Buffer[T] {\n  def length = element.length\n}\n\ndef newIntSeqBuf(e1: Int, e2: Int): SeqBuffer[Int, Seq[Int]] =\n  new SeqBuffer[Int, List[Int]] {\n    val element = List(e1, e2)\n  }\n\nval buf = newIntSeqBuf(7, 8)\nprintln(\"length = \" + buf.length)\nprintln(\"content = \" + buf.element)\n```\n\n----------------------------------------\n\nTITLE: Motivation: Current Scala For Comprehension Verbosity\nDESCRIPTION: Shows the current Scala equivalent for the Haskell example. To reuse the intermediate value `a` within the `for` comprehension, it must be defined outside the `for` block using `val`, leading to slightly more verbose code compared to the proposed syntax or Haskell's `do`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval a = largeExpr(b)\nfor\n  b <- doSth(a)\n  x <- combineM(a, b)\nyield x\n```\n\n----------------------------------------\n\nTITLE: Generating SIP List with Liquid Templates in HTML\nDESCRIPTION: This snippet uses Liquid templating to iterate through SIP data and generate HTML lists categorized by status. It assigns variables for SIP data, iterates through collections, and renders formatted lists with conditional styling based on each SIP's metadata.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/all.md#_snippet_0\n\nLANGUAGE: liquid\nCODE:\n```\n{% assign sips = site.sips | sort: title %}\n{% assign sipData = site.data.sip-data %}\n```\n\nLANGUAGE: html+liquid\nCODE:\n```\n<div class=\"sip-list\">\n  <ul>\n  {% for sip in sips %}\n   {% if sip.stage == \"design\" or sip.stage == \"implementation\" %}\n     <li class=\"no-fragmentation\">\n      <strong>\n        <a href=\"{% if sip.pull-request-number %}https://github.com/scala/improvement-proposals/pull/{{ sip.pull-request-number }}{% else %}{{ sip.url }}{% endif %}\">\n          {{ sip.title }}\n        </a>\n      </strong>\n      <div class=\"tag\" style=\"background-color: {{ sipData[sip.stage].color }}\">Stage: {{ sipData[sip.stage].text }}</div>\n      <div class=\"tag\" style=\"background-color: {{ sipData[sip.status].color }}\">Status: {{ sipData[sip.status].text }}</div>\n      {% if sip.recommendation %}\n        <div class=\"tag\" style=\"background-color: {{ sipData[sip.recommendation].color }}\">Recommendation: {{ sipData[sip.recommendation].text }}</div>\n      {% endif %}\n     </li>\n   {% endif %}\n  {% endfor %}\n  </ul>\n</div>\n```\n\nLANGUAGE: html+liquid\nCODE:\n```\n<div class=\"sip-list\">\n  <ul>\n  {% for sip in sips %}\n   {% if sip.stage == \"completed\" %}\n     <li class=\"no-fragmentation\">\n      <strong><a href=\"{{ sip.url }}\">{{ sip.title }}</a></strong>\n      <div class=\"tag\" style=\"background-color: {{ sipData[sip.status].color }}\">{{ sipData[sip.status].text }}</div>\n     </li>\n   {% endif %}\n  {% endfor %}    \n  </ul>\n</div>\n```\n\nLANGUAGE: html+liquid\nCODE:\n```\n<div class=\"sip-list\">\n  <ul>\n  {% for sip in sips %}\n   {% if sip.status == \"rejected\" %}\n     <li>\n      <strong><a href=\"https://github.com/scala/improvement-proposals/pull/{{ sip.pull-request-number }}\">{{ sip.title }}</a></strong>\n     </li>\n   {% endif %}\n  {% endfor %}    \n  </ul>    \n</div>\n```\n\nLANGUAGE: html+liquid\nCODE:\n```\n<div class=\"sip-list\">\n  <ul>\n  {% for sip in sips %}\n   {% if sip.status == \"withdrawn\" %}\n     <li>\n      <strong><a href=\"https://github.com/scala/improvement-proposals/pull/{{ sip.pull-request-number }}\">{{ sip.title }}</a></strong>\n     </li>\n   {% endif %}\n  {% endfor %}\n  </ul>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Creating and Accessing Immutable Maps in Scala\nDESCRIPTION: Demonstrates how to create immutable Maps with key-value pairs, access elements by keys, and iterate over the Map entries using a for loop.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-classes.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\n// Creating a Map\nval states = Map(\n  \"AK\" -> \"Alaska\",\n  \"AL\" -> \"Alabama\",\n  \"AZ\" -> \"Arizona\"\n)\n\n// Iterating over a Map in Scala 2\nfor ((k, v) <- states) println(s\"key: $k, value: $v\")\n\n// Iterating over a Map in Scala 3\nfor (k, v) <- states do println(s\"key: $k, value: $v\")\n\n// Accessing Map elements\nval ak = states(\"AK\") // ak: String = Alaska\nval al = states(\"AL\") // al: String = Alabama\n```\n\n----------------------------------------\n\nTITLE: Parameterized enum with constructor in Scala 3\nDESCRIPTION: This snippet introduces a parameterized enum 'Color' with an 'rgb' value. Each case extends 'Color' with a specific RGB integer, allowing color representation with associated data. It includes a print statement to access the 'rgb' parameter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-adts-gadts.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nenum Color(val rgb: Int):\n  case Red   extends Color(0xFF0000)\n  case Green extends Color(0x00FF00)\n  case Blue  extends Color(0x0000FF)\n\nprintln(Color.Green.rgb) // выводит 65280\n```\n\n----------------------------------------\n\nTITLE: Scala 2 和 Scala 3 高阶函数应用示例\nDESCRIPTION: 示例演示了如何在 Scala 2 和 Scala 3 中使用高阶函数和 lambda 表达式进行集合操作，与命令式风格的代码进行对比，突出函数式编程的简洁性和表达力。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-features.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable.ListBuffer\n\ndef double(ints: List[Int]): List[Int] = {\n  val buffer = new ListBuffer[Int]()\n  for (i <- ints) {\n    buffer += i * 2\n  }\n  buffer.toList\n}\n\nval oldNumbers = List(1, 2, 3)\nval newNumbers = double(oldNumbers)\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable.ListBuffer\n\ndef double(ints: List[Int]): List[Int] =\n  val buffer = new ListBuffer[Int]()\n  for i <- ints do\n    buffer += i * 2\n  buffer.toList\n\nval oldNumbers = List(1, 2, 3)\nval newNumbers = double(oldNumbers)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval newNumbers = oldNumbers.map(_ * 2)\n```\n\n----------------------------------------\n\nTITLE: Incompatible `kind-projector` constructs in Scala 2\nDESCRIPTION: Lists examples of advanced `kind-projector` syntax features in Scala 2, such as higher-kinded placeholders (`*[_]`, `_[_]`), named parameters (`λ[(F[_], A) => ...]`), and the `Lambda` keyword. These specific patterns are not supported by Scala 3's built-in kind-projector implementation and require rewriting.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/plugin-kind-projector.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n// classic\nEitherT[*[_], Int, *]    // equivalent to: type R[F[_], B] = EitherT[F, Int, B]\n// underscores\nEitherT[_[_], Int, _]    // equivalent to: type R[F[_], B] = EitherT[F, Int, B]\n// named λ\nλ[(F[_], A) => EitherT[F, Int, A]]\n// named Lambda\nLambda[(F[_], A) => EitherT[F, Int, A]]\n```\n\n----------------------------------------\n\nTITLE: Implicit Type Casting in Scala\nDESCRIPTION: Demonstrates how Scala automatically casts types when there's no loss of information. Shows examples of casting from Byte to Int and Char to Int where the conversion is safe and implicit.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/first-look-at-types.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nval b: Byte = 127\nval i: Int = b  // 127\n\nval face: Char = '☺'\nval number: Int = face  // 9786\n```\n\n----------------------------------------\n\nTITLE: WeakHashMap（弱哈希映射）示例\nDESCRIPTION: 介绍WeakHashMap允许垃圾回收机制忽略存储在内部Key的引用。适合缓存场景，避免无限增长。Scala中的WeakHashMap封装Java的java.util.WeakHashMap，实现弱键映射。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/concrete-mutable-collection-classes.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\n// 具体代码示例未提供，仅为说明\n```\n\n----------------------------------------\n\nTITLE: List data structure in Python and Scala\nDESCRIPTION: Demonstrates how to create list-like collections in Python and Scala, showing syntax differences. Highlights how lists are instantiated in both languages, with Scala using 'List()' and Python using square brackets.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nx = [1, 2, 3]\n```\n\nLANGUAGE: scala\nCODE:\n```\nval x = List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Explicitly Passing Context Parameters in Scala 2 and Scala 3\nDESCRIPTION: These snippets illustrate how to explicitly specify context parameters during method calls, overriding the automatic inference mechanism. In Scala 2, the syntax uses parentheses with the implicit parameter; in Scala 3, the `using` keyword is used for explicit specification. This method is useful when multiple values of the context type exist in scope and the programmer needs to specify which one to use. Input includes the method argument and an explicit context parameter; output is the result of the method call.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/ca-context-parameters.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nrenderWebsite(\"/home\")(config)\n```\n\nLANGUAGE: scala\nCODE:\n```\nrenderWebsite(\"/home\")(using config)\n```\n\n----------------------------------------\n\nTITLE: Running Enhanced ScalaTest Suite with sbt - Shell\nDESCRIPTION: Shows the sbt command output after adding a second test case to the suite. The output details the execution of two tests and confirms all tests passed. This helps users recognize successful multi-test execution. Dependency: sbt and proper ScalaTest configuration must be in place.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/getting-started/sbt-track/testing-scala-with-sbt-on-the-command-line.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nsbt test\n[info] Loading project definition from C:\\projects\\scalaPlayground\\scalatestpractice\\project\n[info] Loading settings for project root from build.sbt ...\n[info] Set current project to scalatest-example (in build file:/C:/projects/scalaPlayground/scalatestpractice/)\n[info] Compiling 1 Scala source to C:\\projects\\scalaPlayground\\scalatestpractice\\target\\scala-2.13\\test-classes ...\n[info] CubeCalculatorTest:\n[info] - CubeCalculator.cube 3 should be 27\n[info] - CubeCalculator.cube 0 should be 0\n[info] Run completed in 257 milliseconds.\n[info] Total number of tests run: 2\n[info] Suites: completed 1, aborted 0\n[info] Tests: succeeded 2, failed 0, canceled 0, ignored 0, pending 0\n[info] All tests passed.\n[success] Total time: 3 s, completed Dec 4, 2019 10:34:04 PM\n```\n\n----------------------------------------\n\nTITLE: Equivalent Java Stream Mapping of Integer Lists\nDESCRIPTION: Provides the Java equivalent for mapping and doubling integer values in a List using Java Streams API. Requires java.util.List, java.util.ArrayList, java.util.Arrays, and java.util.stream.Collectors. Inputs: List<Integer> ints. Output: List<Integer> doubledInts where each element is multiplied by two. Useful for comparing Scala and Java idioms.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/anonymous-functions.md#_snippet_6\n\nLANGUAGE: java\nCODE:\n```\nList<Integer> ints = new ArrayList<>(Arrays.asList(1, 2, 3));\n\n// the `map` process\nList<Integer> doubledInts = ints.stream()\n                                .map(i -> i * 2)\n                                .collect(Collectors.toList());\n```\n\n----------------------------------------\n\nTITLE: Implementing an Embedded Query Language in Scala using NamedTuples\nDESCRIPTION: A comprehensive implementation of an embedded query language in Scala that maps for-expressions to query objects. It uses NamedTuples and type classes to create a type-safe DSL for database operations without requiring macros.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-tuples.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nimport language.experimental.namedTuples\nimport NamedTuple.{NamedTuple, AnyNamedTuple}\n\n/* This is a demonstrator that shows how to map regular for expressions to\n * internal data that can be optimized by a query engine. It needs NamedTuples\n * and type classes but no macros. It's so far very provisional and experimental,\n * intended as a basis for further exploration.\n */\n\n/** The type of expressions in the query language */\ntrait Expr[Result] extends Selectable:\n\n  /** This type is used to support selection with any of the field names\n   *  defined by Fields.\n   */\n  type Fields = NamedTuple.Map[NamedTuple.From[Result], Expr]\n\n  /** A selection of a field name defined by Fields is implemented by `selectDynamic`.\n   *  The implementation will add a cast to the right Expr type corresponding\n   *  to the field type.\n   */\n  def selectDynamic(fieldName: String) = Expr.Select(this, fieldName)\n\n  /** Member methods to implement universal equality on Expr level. */\n  def == (other: Expr[?]): Expr[Boolean] = Expr.Eq(this, other)\n  def != (other: Expr[?]): Expr[Boolean] = Expr.Ne(this, other)\n\nobject Expr:\n\n  /** Sample extension methods for individual types */\n  extension (x: Expr[Int])\n    def > (y: Expr[Int]): Expr[Boolean] = Gt(x, y)\n    def > (y: Int): Expr[Boolean] = Gt(x, IntLit(y))\n  extension (x: Expr[Boolean])\n    def &&(y: Expr[Boolean]): Expr[Boolean] = And(x, y)\n    def || (y: Expr[Boolean]): Expr[Boolean] = Or(x, y)\n\n  // Note: All field names of constructors in the query language are prefixed with `$`\n  // so that we don't accidentally pick a field name of a constructor class where we want\n  // a name in the domain model instead.\n\n  // Some sample constructors for Exprs\n  case class Gt($x: Expr[Int], $y: Expr[Int]) extends Expr[Boolean]\n  case class Plus(x: Expr[Int], y: Expr[Int]) extends Expr[Int]\n  case class And($x: Expr[Boolean], $y: Expr[Boolean]) extends Expr[Boolean]\n  case class Or($x: Expr[Boolean], $y: Expr[Boolean]) extends Expr[Boolean]\n\n  // So far Select is weakly typed, so `selectDynamic` is easy to implement.\n  // Todo: Make it strongly typed like the other cases\n  case class Select[A]($x: Expr[A], $name: String) extends Expr\n\n  case class Single[S <: String, A]($x: Expr[A])\n  extends Expr[NamedTuple[S *: EmptyTuple, A *: EmptyTuple]]\n\n  case class Concat[A <: AnyNamedTuple, B <: AnyNamedTuple]($x: Expr[A], $y: Expr[B])\n  extends Expr[NamedTuple.Concat[A, B]]\n\n  case class Join[A <: AnyNamedTuple](a: A)\n  extends Expr[NamedTuple.Map[A, StripExpr]]\n\n  type StripExpr[E] = E match\n    case Expr[b] => b\n\n  // Also weakly typed in the arguents since these two classes model universal equality */\n  case class Eq($x: Expr[?], $y: Expr[?]) extends Expr[Boolean]\n  case class Ne($x: Expr[?], $y: Expr[?]) extends Expr[Boolean]\n\n  /** References are placeholders for parameters */\n  private var refCount = 0\n\n  case class Ref[A]($name: String = \"\") extends Expr[A]:\n    val id = refCount\n    refCount += 1\n    override def toString = s\"ref$id(${$name})\"\n\n  /** Literals are type-specific, tailored to the types that the DB supports */\n  case class IntLit($value: Int) extends Expr[Int]\n\n  /** Scala values can be lifted into literals by conversions */\n  given Conversion[Int, IntLit] = IntLit(_)\n\n  /** The internal representation of a function `A => B`\n   *  Query languages are ususally first-order, so Fun is not an Expr\n   */\n  case class Fun[A, B](param: Ref[A], f: B)\n\n  type Pred[A] = Fun[A, Expr[Boolean]]\n\n  /** Explicit conversion from\n   *      (name_1: Expr[T_1], ..., name_n: Expr[T_n])\n   *  to\n   *      Expr[(name_1: T_1, ..., name_n: T_n)]\n   */\n  extension [A <: AnyNamedTuple](x: A) def toRow: Join[A] = Join(x)\n\n  /** Same as _.toRow, as an implicit conversion */\n  given [A <: AnyNamedTuple]: Conversion[A, Expr.Join[A]] = Expr.Join(_)\n\nend Expr\n\n/** The type of database queries. So far, we have queries\n *  that represent whole DB tables and queries that reify\n *  for-expressions as data.\n */\ntrait Query[A]\n\nobject Query:\n  import Expr.{Pred, Fun, Ref}\n\n  case class Filter[A]($q: Query[A], $p: Pred[A]) extends Query[A]\n  case class Map[A, B]($q: Query[A], $f: Fun[A, Expr[B]]) extends Query[B]\n  case class FlatMap[A, B]($q: Query[A], $f: Fun[A, Query[B]]) extends Query[B]\n\n  // Extension methods to support for-expression syntax for queries\n  extension [R](x: Query[R])\n\n    def withFilter(p: Ref[R] => Expr[Boolean]): Query[R] =\n      val ref = Ref[R]()\n      Filter(x, Fun(ref, p(ref)))\n\n    def map[B](f: Ref[R] => Expr[B]): Query[B] =\n      val ref = Ref[R]()\n      Map(x, Fun(ref, f(ref)))\n\n    def flatMap[B](f: Ref[R] => Query[B]): Query[B] =\n      val ref = Ref[R]()\n      FlatMap(x, Fun(ref, f(ref)))\nend Query\n\n/** The type of query references to database tables */\ncase class Table[R]($name: String) extends Query[R]\n\n// Everything below is code using the model -----------------------------\n\n// Some sample types\ncase class City(zipCode: Int, name: String, population: Int)\ntype Address = (city: City, street: String, number: Int)\ntype Person = (name: String, age: Int, addr: Address)\n\n@main def Test =\n\n  val cities = Table[City](\"cities\")\n\n  val q1 = cities.map: c =>\n    c.zipCode\n  val q2 = cities.withFilter: city =>\n      city.population > 10_000\n    .map: city =>\n      city.name\n\n  val q3 =\n    for\n      city <- cities\n      if city.population > 10_000\n    yield city.name\n\n  val q4 =\n    for\n      city <- cities\n      alt <- cities\n      if city.name == alt.name && city.zipCode != alt.zipCode\n    yield\n      city\n\n  val addresses = Table[Address](\"addresses\")\n  val q5 =\n    for\n      city <- cities\n      addr <- addresses\n      if addr.street == city.name\n    yield\n      (name = city.name, num = addr.number)\n\n  val q6 =\n    cities.map: city =>\n      (name = city.name, zipCode = city.zipCode)\n\n  def run[T](q: Query[T]): Iterator[T] = ???\n\n  def x1: Iterator[Int] = run(q1)\n  def x2: Iterator[String] = run(q2)\n  def x3: Iterator[String] = run(q3)\n  def x4: Iterator[City] = run(q4)\n  def x5: Iterator[(name: String, num: Int)] = run(q5)\n  def x6: Iterator[(name: String, zipCode: Int)] = run(q6)\n```\n\n----------------------------------------\n\nTITLE: Triggering Value Class Allocation via Type Parameters in Scala\nDESCRIPTION: Illustrates that using a value class (`Meter`) as a type argument (`T`) for a generic function (like `identity`) forces the runtime instantiation of the value class object. The generic nature prevents the compiler from knowing the specific underlying type at compile time.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ndef identity[T](t: T): T = t\nidentity(Meter(5.0))\n```\n\n----------------------------------------\n\nTITLE: Showing Factory-based Intersperse Result in Scala REPL\nDESCRIPTION: Displays the output from the Scala REPL when calling the `intersperse` method implemented using `Factory` on a `List`. The result shows that it produces an `Array` instead of the expected `List`, highlighting the limitation of `Factory` for preserving the source collection type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collection-operations.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nscala> List(1, 2, 3).intersperse(0)\nres0: Array[Int] = Array(1, 0, 2, 0, 3)\n```\n\n----------------------------------------\n\nTITLE: Defining Builder Trait for Strict Construction - Scala 3\nDESCRIPTION: The Scala 3 Builder trait in scala.collection.mutable offers a standardized way to assemble collections in a strict (eager) manner. The interface consists of addOne for accumulating elements and result for producing the final collection, supporting builder-based patterns essential for strict collection implementations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\npackage scala.collection.mutable\n\ntrait Builder[-A, +C]:\n  def addOne(elem: A): this.type\n  def result(): C\n```\n\n----------------------------------------\n\nTITLE: Running Scala Benchmark with JVM Parameters\nDESCRIPTION: Command line instruction to execute the Map benchmark with specific JVM settings. Uses the server JVM with configurable parallelism and collection size parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/parallel-collections/performance.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\njava -server -cp .:../../build/pack/lib/scala-library.jar -Dpar=1 -Dlength=300000 Map 10\n```\n\n----------------------------------------\n\nTITLE: Offline Code Generation with showCode and Quasiquotes in Scala\nDESCRIPTION: Implements an offline code generator that serializes ASTs into source files using `showCode` from the reflection API. Dependencies include `java.io.PrintWriter` for file I/O and quasiquotes for AST construction. The method generates a tree representing a package with a class, pretty-prints it to Scala source, and writes it to disk; suitable for tools generating Scala code programmatically.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/usecases.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nobject OfflineCodeGen extends App {\n  def generateCode() =\n    q\"package mypackage { class MyClass }\"\n  def saveToFile(path: String, code: Tree) = {\n    val writer = new java.io.PrintWriter(path)\n    try writer.write(showCode(code))\n    finally writer.close()\n  }\n  saveToFile(\"myfile.scala\", generateCode())\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Abstract Classes and Subclasses for Animals in Scala\nDESCRIPTION: Defines a hierarchy of animal classes with a common 'name' method, including abstract classes Animal and Pet, and concrete classes Dog, Cat, and Lion. These are dependencies for understanding type bounds in PetContainer.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/upper-type-bounds.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class Animal {\n def name: String\n}\n\nabstract class Pet extends Animal {}\n\nclass Cat extends Pet {\n  override def name: String = \"Cat\"\n}\n\nclass Dog extends Pet {\n  override def name: String = \"Dog\"\n}\n\nclass Lion extends Animal {\n  override def name: String = \"Lion\"\n}\n```\n\n----------------------------------------\n\nTITLE: Importing JavaConverters for Collection Conversion in Scala\nDESCRIPTION: Shows how to import the JavaConverters object which provides implicit conversion methods between Java and Scala collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/conversions-between-java-and-scala-collections.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport collection.JavaConverters._\n```\n\n----------------------------------------\n\nTITLE: Running Scala 3 Nightly Builds with scala-cli (Shell)\nDESCRIPTION: These shell commands demonstrate how to use scala-cli to run Scala 3 nightly builds. The command '-S 3.nightly' or '-S 3.3.nightly' selects the nightly version of Scala 3. Requires scala-cli installed and network access to Maven Central. All subcommands such as 'repl', 'compile', and 'run' are supported.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/nightlies.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nscala-cli -S 3.nightly\n```\n\nLANGUAGE: Shell\nCODE:\n```\nscala-cli -S 3.3.nightly\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Numbers as Objects in Scala\nDESCRIPTION: Shows how arithmetic operations in Scala are actually method calls on number objects. Illustrates that operators like +, *, and / are valid method identifiers in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n1 + 2 * 3 / x\n```\n\nLANGUAGE: scala\nCODE:\n```\n1.+(2.*(3)./(x))\n```\n\n----------------------------------------\n\nTITLE: Implementing a breadth-first search using concurrent maps in Scala\nDESCRIPTION: This code defines types for nodes and parent mapping, sets up a grid-based map, and initializes open and closed concurrent trie maps for BFS traversal. It expands nodes in parallel, updating parent references, until the target node is reached. The code concludes by reconstructing the path from target to start, illustrating a parallel BFS with thread-safe data structures.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/parallel-collections/ctries.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval length = 1000\n\n//定义节点类型\ntype Node = (Int, Int);\ntype Parent = (Int, Int);\n\n//定义节点类型上的操作\ndef up(n: Node) = (n._1, n._2 - 1);\ndef down(n: Node) = (n._1, n._2 + 1);\ndef left(n: Node) = (n._1 - 1, n._2);\ndef right(n: Node) = (n._1 + 1, n._2);\n\n// 创建一个map及一个target\nval target = (length / 2, length / 2);\nval map = Array.tabulate(length, length)((x, y) => (x % 3) != 0 || (y % 3) != 0 || (x, y) == target)\ndef onMap(n: Node) = n._1 >= 0 && n._1 < length && n._2 >= 0 && n._2 < length\n\n//open列表 - 前节点\n// closed 列表 - 已处理的节点\nval open = ParTrieMap[Node, Parent]()\nval closed = ParTrieMap[Node, Parent]()\n\n// 加入一对起始位置\nopen((0, 0)) = null\nopen((length - 1, length - 1)) = null\nopen((0, length - 1)) = null\nopen((length - 1, 0)) = null\n\n//  贪婪广度优先算法路径搜索\nwhile (open.nonEmpty && !open.contains(target)) {\n  for ((node, parent) <- open) {\n    def expand(next: Node) {\n      if (onMap(next) && map(next._1)(next._2) && !closed.contains(next) && !open.contains(next)) {\n        open(next) = node\n      }\n    }\n    expand(up(node))\n    expand(down(node))\n    expand(left(node))\n    expand(right(node))\n    closed(node) = parent\n    open.remove(node)\n  }\n}\n\n// 打印路径\nvar pathnode = open(target)\nwhile (closed.contains(pathnode)) {\n  print(pathnode + \"->\")\n  pathnode = closed(pathnode)\n}\nprintln()\n```\n\n----------------------------------------\n\nTITLE: Resolving Referential Transparency via Fully Qualified Name - Scala\nDESCRIPTION: Presents a workaround for the referential transparency issue in macros. The macro implementation is modified to use a fully qualified name `_root_.example.MyMacro.wrapper` within the quasiquote. This ensures that the reference always points to the correct `wrapper` method, regardless of any local definitions at the macro's call site.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/hygiene.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef impl(c: Context)(x: c.Tree) = {\n  import c.universe._\n  q\"_root_.example.MyMacro.wrapper($x)\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Sample Lists for Code Examples in Scala\nDESCRIPTION: This snippet creates two sample lists: one of integers using a range, and one of strings. These are used throughout subsequent examples. There are no dependencies. Inputs are implicit (literal expressions); outputs are named List[Int] and List[String] variables. Useful for setting consistent context for demonstration code and testing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-methods.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval oneToTen = (1 to 10).toList\nval names = List(\"adam\", \"brandy\", \"chris\", \"david\")\n```\n\n----------------------------------------\n\nTITLE: Illustrating Type Safety Enforcement by Scala's Path-Dependent Types Across Graph Instances\nDESCRIPTION: Shows an example where nodes from two different Graph instances are explicitly typed and attempts to connect nodes across these instances, which the Scala compiler disallows due to distinct path-dependent Node types. This snippet highlights the compile-time type safety that prevents mixing nodes across different graph objects. The purpose is to demonstrate the type system's constraints rather than functional correctness. The snippet is marked to indicate the expected compilation failure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/inner-classes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval graph1: Graph = new Graph\nval node1: graph1.Node = graph1.newNode\nval node2: graph1.Node = graph1.newNode\nnode1.connectTo(node2)      // legal\nval graph2: Graph = new Graph\nval node3: graph2.Node = graph2.newNode\nnode1.connectTo(node3)      // illegal!\n```\n\n----------------------------------------\n\nTITLE: Compiler Desugaring of Custom Interpolators (Scala 2 & 3)\nDESCRIPTION: Explains how the Scala compiler transforms a processed string literal (e.g., `p\"1, $someVar\"`) into a method call (`p`) on a `StringContext` instance. The `StringContext` holds the literal parts of the string, and the evaluated expressions (`someVar`) are passed as arguments to the method. Shows the desugared form for both Scala 2 (with implicit class resolution) and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/string-interpolation.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 2 Desugaring (Conceptual)\nnew StringContext(\"1, \", \"\").p(someVar)\n\n// Scala 2 After Implicit Conversion\nnew PointHelper(new StringContext(\"1, \", \"\")).p(someVar)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 3 Desugaring\nStringContext(\"1, \",\"\").p(someVar)\n```\n\n----------------------------------------\n\nTITLE: Creating Address Data Class (Scala)\nDESCRIPTION: Defines the `Address` class as a data structure to store address details. It includes mutable properties for two street lines (`street1`, `street2`), `city`, `state`, and `zipCode`. This class is designed to be used as a property within the `Customer` class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/oop-pizza-example.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass Address (\n    var street1: String,\n    var street2: String,\n    var city: String,\n    var state: String,\n    var zipCode: String\n)\n```\n\n----------------------------------------\n\nTITLE: Taking First N Elements from a Scala Map\nDESCRIPTION: This example uses the 'take' method to extract the first two elements from a Map. Intended for Maps with a defined iteration order (such as sorted Maps); when applied to unordered Maps, results may be non-deterministic. Input is a Map; output is a Map with at most the first N elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/collections-maps.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval firstTwoElements = m.take(2)\n```\n\n----------------------------------------\n\nTITLE: Defining a Goal for a Custom String Interpolator in Scala\nDESCRIPTION: Sets up the context for a custom interpolator example. It defines a `Point` case class and specifies the goal: creating a `p` interpolator to parse a string like `\"1,-2\"` into a `Point` object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/string-interpolation.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Point(x: Double, y: Double)\n\nval pt = p\"1,-2\"     // Point(1.0,-2.0)\n```\n\n----------------------------------------\n\nTITLE: Testing Graph Node Connections in Scala With Explicit Path-Dependent Types\nDESCRIPTION: Improves the previous test by explicitly declaring types, showing that node types are tied to their respective Graph instance. This snippet highlights Scala's path-dependent typing, where each node's type is prefixed by its Graph instance, preventing mixing node types from different graphs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/inner-classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef graphTest: Unit = {\n  val g: Graph = new Graph\n  val n1: g.Node = g.newNode\n  val n2: g.Node = g.newNode\n  val n3: g.Node = g.newNode\n  n1.connectTo(n2)\n  n3.connectTo(n1)\n}\n```\n\n----------------------------------------\n\nTITLE: Increment and Decrement Operations in JavaScript and Scala\nDESCRIPTION: Demonstrates how increment and decrement operations differ between JavaScript and Scala. In Scala, operators like '+' and '-' are actually methods rather than operators.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nvar a = 2\na *= 2      // 4\na /= 2      // 2\n```\n\n----------------------------------------\n\nTITLE: Defining multiline functions in Python and Scala\nDESCRIPTION: Shows how to define functions with multiple statements printed sequentially. No dependencies. No inputs or return values; side-effects are printing messages to stdout. Useful to show block-structured code examples.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\ndef walkThenRun() =\n  println(\"walk\")\n  println(\"run\")\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Value Class with By-Name Parameter (Disallowed)\nDESCRIPTION: This snippet shows an attempt to define a value class `NoByName` using a by-name parameter (`=> Int`) for its constructor. This is disallowed because the single constructor parameter must be a `val`, and `val` parameters cannot be call-by-name. The compiler error confirms this limitation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_15\n\nLANGUAGE: text\nCODE:\n```\nNoByName.scala:1: error: `val` parameters may not be call-by-name\n```\n\nLANGUAGE: Scala\nCODE:\n```\nclass NoByName(val x: => Int) extends AnyVal\n                      ^\n```\n\n----------------------------------------\n\nTITLE: Implementing the Logarithms Module in Scala\nDESCRIPTION: Implementation of the Logarithms trait using a type alias for Double. This concrete implementation equates Logarithm with Double and implements the required operations, but the abstraction is leaky.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-opaque-types.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nobject LogarithmsImpl extends Logarithms:\n\n  type Logarithm = Double\n\n  // operations on Logarithm\n  def add(x: Logarithm, y: Logarithm): Logarithm = make(x.toDouble + y.toDouble)\n  def mul(x: Logarithm, y: Logarithm): Logarithm = x + y\n\n  // functions to convert between Double and Logarithm\n  def make(d: Double): Logarithm = math.log(d)\n  def extract(x: Logarithm): Double = math.exp(x)\n```\n\n----------------------------------------\n\nTITLE: Using reduce with associative string concatenation in parallel collections\nDESCRIPTION: This snippet shows that concatenating strings in a parallel collection using `reduce(_++_)` yields a consistent, correctly ordered result despite the operation being performed in a non-sequential manner, because string concatenation is associative.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/overviews/parallel-collections/overview.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval strings = List(\"abc\",\"def\",\"ghi\",\"jk\",\"lmnop\",\"qrs\",\"tuv\",\"wx\",\"yz\").par\nval alfabeto = strings.reduce(_++_)\n```\n\n----------------------------------------\n\nTITLE: Inheritance Shadowing Rejected in Scala 3\nDESCRIPTION: Demonstrates code that compiles in Scala 2 but is rejected in Scala 3 due to ambiguous reference. The compiler requires disambiguating inherited members that shadow identifiers from outer scopes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-other-changes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass A {\n  val x = 2\n}\n\nobject B {\n  val x = 1\n  class C extends A {\n    println(x)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Method Storage in Lists (Scala 2 vs Scala 3)\nDESCRIPTION: Contrasts the behavior when attempting to store a method directly in a List. Scala 2 produces an error, requiring explicit conversion (`_`), as methods aren't directly first-class objects. Scala 3, with enhanced Eta Expansion, allows direct storage, automatically converting the method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-eta-expansion.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// this example shows the Scala 2 error message\nval methods = List(isEvenMethod)\n                   ^\nerror: missing argument list for method isEvenMethod\nUnapplied methods are only converted to functions when a function type is expected.\nYou can make this conversion explicit by writing `isEvenMethod _` or `isEvenMethod(_)` instead of `isEvenMethod`.\n```\n\nLANGUAGE: scala\nCODE:\n```\nval functions = List(isEvenFunction)   // works\nval methods = List(isEvenMethod)       // works\n```\n\n----------------------------------------\n\nTITLE: Implementing a custom Future combinator in Scala\nDESCRIPTION: Example of implementing a custom 'first' combinator that returns a Future completed by whichever of two given Futures completes successfully first.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_35\n\nLANGUAGE: scala\nCODE:\n```\ndef first[T](f: Future[T], g: Future[T]): Future[T] = {\n  val p = Promise[T]\n\n  f.foreach { x =>\n    p.trySuccess(x)\n  }\n\n  g.foreach { x =>\n    p.trySuccess(x)\n  }\n\n  p.future\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef first[T](f: Future[T], g: Future[T]): Future[T] =\n  val p = Promise[T]\n\n  f.foreach { x =>\n    p.trySuccess(x)\n  }\n\n  g.foreach { x =>\n    p.trySuccess(x)\n  }\n\n  p.future\n```\n\n----------------------------------------\n\nTITLE: Using Scala 3 Macros in Scala 2.13 Projects via Dependency Settings - Scala\nDESCRIPTION: This snippet shows the necessary settings for an SBT build to consume a macro library cross-published for Scala 3 in a Scala 2.13 project. It sets the Scala version, adds the dependency with 'cross' parameter for 2.13/3 compatibility, and enables '-Ytasty-reader' to allow Scala 2.13 to read TASTy-encoded Scala 3 artifacts. This is essential for users wishing to use Scala 3 macro artifacts in updated Scala 2 projects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-macro-mixing.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nscalaVersion := \"2.13.12\"\nlibraryDependencies += (\"org\" %% \"example\" % \"x.y.z\").cross(CrossVersion.for2_13Use3)\nscalacOptions += \"-Ytasty-reader\"\n```\n\n----------------------------------------\n\nTITLE: Matching Quoted Expressions with Nested Type Variable - Scala\nDESCRIPTION: Illustrates the syntax for nested type variables within Scala quoted expression patterns. A type variable (`t`) is introduced implicitly without an explicit `type` declaration and is referenced directly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/quote-pattern-type-variable-syntax.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ncase '{ $x: t } => f[t](x: Expr[t])\n```\n\n----------------------------------------\n\nTITLE: Function Type Declarations in Scala\nDESCRIPTION: Shows proper formatting for function type declarations with spaces between parameter types, arrows, and return types. Demonstrates both simple and multi-parameter function types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/types.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef foo(f: Int => String) = ...\n\ndef bar(f: (Boolean, Double) => List[String]) = ...\n```\n\n----------------------------------------\n\nTITLE: Defining Class with Auxiliary Constructors in Scala 2\nDESCRIPTION: This snippet demonstrates defining a class with a primary constructor and multiple auxiliary constructors in Scala 2 using the `this` keyword. Auxiliary constructors must call a previously defined constructor (either the primary or another auxiliary constructor).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nimport java.time._\n\n// [1] the primary constructor\nclass Student(\n  var name: String,\n  var govtId: String\n) {\n  private var _applicationDate: Option[LocalDate] = None\n  private var _studentId: Int = 0\n\n  // [2] a constructor for when the student has completed\n  // their application\n  def this(\n    name: String,\n    govtId: String,\n    applicationDate: LocalDate\n  ) = {\n    this(name, govtId)\n    _applicationDate = Some(applicationDate)\n  }\n\n  // [3] a constructor for when the student is approved\n  // and now has a student id\n  def this(\n    name: String,\n    govtId: String,\n    studentId: Int\n  ) = {\n    this(name, govtId)\n    _studentId = studentId\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Documenting Methods (Scaladoc Style, Column 2) in Scala\nDESCRIPTION: Illustrates the Scaladoc comment style where the initial summary starts on the first line after '/**'. Subsequent lines with asterisks are aligned in column two. This format saves vertical space compared to Javadoc.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/scaladoc.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n/** Provides a service as described.\n * \n *  This is further documentation of what we're documenting.\n *  Here are more details about how it works and what it does.\n */\ndef member: Unit = ()\n```\n\n----------------------------------------\n\nTITLE: Defining Base Trait Hierarchy in Scala\nDESCRIPTION: Defines a simple trait hierarchy used throughout the variance examples. `Item` is the base trait, `Buyable` extends `Item` adding a price, and `Book` extends `Buyable` adding an ISBN. This establishes the subtyping relationship `Book <: Buyable <: Item`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-variance.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Item { def productNumber: String }\ntrait Buyable extends Item { def price: Int }\ntrait Book extends Buyable { def isbn: String }\n```\n\n----------------------------------------\n\nTITLE: Variable Initialization with Null and Its Type Inference Limitations in Scala 2 and 3\nDESCRIPTION: Illustrates that inferring type from 'null' results in a variable of type Null, which restricts later assignments to non-null types and causes compilation errors. Dependencies: none. Input is a null assignment; output is a variable of type Null which cannot be reassigned to other object types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/type-inference.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nvar obj = null\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Named Arguments in Scala\nDESCRIPTION: This snippet demonstrates an error case when using named arguments in Scala. It shows that positional arguments must come before named arguments when mixing both styles in a method call.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/tour/named-arguments.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nprintName(last = \"Smith\", \"john\") // erreur: argument positionnel après un argument nommé\n```\n\n----------------------------------------\n\nTITLE: Defining IterableOps Template Trait Header in Scala 2 and 3\nDESCRIPTION: This code defines the header for the IterableOps trait, the core abstraction for generic iterable collections in both Scala 2 and 3. The trait takes three type parameters: A (element type), CC (collection type constructor), and C (specific collection type), providing a flexible foundation for implementing common operations across collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ntrait IterableOps[+A, +CC[_], +C] { … }\n```\n\n----------------------------------------\n\nTITLE: Composing Multiple Traits in a New Trait in Scala 3\nDESCRIPTION: This Scala 3 code creates a new trait ComposedService by extending GreetingService and TranslationService using the modern comma-separation syntax. It demonstrates how abstract members from one trait can be implemented in another, supporting modular OOP design in Scala 3 with no external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-oop.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ntrait ComposedService extends GreetingService, TranslationService\n```\n\n----------------------------------------\n\nTITLE: Defining Palindrome Helper Functions - Scala\nDESCRIPTION: These functions define what a palindrome is and how to find the first one in a sequence of strings. They serve as utility functions for demonstrating collection transformations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/views.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef isPalindrome(x: String) = x == x.reverse\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef findPalindrome(s: Seq[String]) = s find isPalindrome\n```\n\n----------------------------------------\n\nTITLE: Legal Use of Parentheses for Arrow Expressions in Scala\nDESCRIPTION: This snippet demonstrates the use of parentheses to group lambda expressions where colon-initiated argument blocks are not permitted under the SIP-44 rules. It defines an anonymous function for the 'source -->' operator in a legal and idiomatic manner in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nsource --> ( x =>\n  val y = x * x\n  println(y)\n)\n```\n\n----------------------------------------\n\nTITLE: Forcing LazyList Evaluation in Scala REPL\nDESCRIPTION: Shows how to force the evaluation of a `LazyList` element using a terminal operation like `foreach` in the Scala REPL. Taking one element from the previously defined lazy list `x` and printing it computes and outputs the first value (1).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nscala> x.take(1).foreach(println)\n1\n```\n\n----------------------------------------\n\nTITLE: Restrictions on Overloading Methods with Default Parameters in Scala\nDESCRIPTION: Attempts to define two methods 'func' with default parameters, one accepting an integer and another a string, are invalid in both Scala 2 and Scala 3. Overloading such methods with default parameters causes ambiguity when invoking 'A.func()', as the compiler cannot distinguish which method to call.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/default-parameter-values.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nobject A {\n  def func(x: Int = 34): Unit\n  def func(y: String = \"abc\"): Unit\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Runtime Types Using Scala Reflection\nDESCRIPTION: This snippet showcases using Scala's reflection API to compare runtime types instead of classes. After importing scala.reflect.runtime.{universe => ru}, it defines a generic method m that takes two parameters and uses TypeTag to examine their types at runtime. The method returns true if the runtime type of the first parameter is a subtype of the second. The main dependency is scala-reflect, and key parameters are x, y (the values to compare). Output is a Boolean reflecting type subtyping, and it does not suffer from the limitations of Java reflection. This is the recommended approach in Scala for accurate type information at runtime.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/overview.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.runtime.{universe => ru}\ndef m[T: ru.TypeTag, S: ru.TypeTag](x: T, y: S): Boolean = {\n  val leftTag = ru.typeTag[T]\n  val rightTag = ru.typeTag[S]\n  leftTag.tpe <:< rightTag.tpe\n}\nm(d, c)\n```\n\n----------------------------------------\n\nTITLE: Rewriting incompatible type lambdas using Scala 3 native syntax (Scala 3 Only)\nDESCRIPTION: Shows how to replace incompatible `kind-projector` syntax using Scala 3's native type lambda syntax (`[F[_], A] =>> ...`). This syntax is specific to Scala 3 and offers a concise alternative when cross-compilation with Scala 2 is not required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/plugin-kind-projector.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\n[F[_], A] =>> EitherT[F, Int, A]\n```\n\n----------------------------------------\n\nTITLE: Creating an implicit ReadWriter for PetOwner in Scala 2\nDESCRIPTION: This code imports uPickle's default package and defines an implicit `ReadWriter[PetOwner]` instance using `macroRW`, which automatically generates serialization logic. This instance is essential for translating `PetOwner` objects to and from JSON in Scala 2 projects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-serialize.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport upickle.default._\n\nimplicit val ownerRw: ReadWriter[PetOwner] = macroRW[PetOwner]\n```\n\n----------------------------------------\n\nTITLE: Instantiating Scala Class with Auxiliary Constructors\nDESCRIPTION: Demonstrates how to create instances of the `Pizza` class using the primary constructor and the defined auxiliary constructors. Shows the different ways the class can be instantiated based on the constructor definitions provided.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/classes-aux-constructors.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval p1 = new Pizza(DefaultCrustSize, DefaultCrustType)\nval p2 = new Pizza(DefaultCrustSize)\nval p3 = new Pizza(DefaultCrustType)\nval p4 = new Pizza\n```\n\n----------------------------------------\n\nTITLE: Using a Synchronized Map in Scala\nDESCRIPTION: This code shows how to use the thread-safe map created with SynchronizedMap. It demonstrates initialization, adding key-value pairs, retrieving values, and handling undefined keys with the custom default method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/maps.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval capital = MapMaker.makeMap  \ncapital ++ List(\"US\" -> \"Washington\",\n      \"France\" -> \"Paris\", \"Japan\" -> \"Tokyo\")\ncapital(\"Japan\")\ncapital(\"New Zealand\")\ncapital += (\"New Zealand\" -> \"Wellington\")\ncapital(\"New Zealand\")\n```\n\n----------------------------------------\n\nTITLE: Filtering Elements in Scala Parallel Collections\nDESCRIPTION: Shows how to filter elements of a parallel collection, selecting elements based on a predicate using the filter operation. The sequential list of strings is converted into a parallel collection using `.par`. The filter retains only those elements whose first character is alphabetically greater than or equal to 'J'. Input is a List[String], and output is a parallel immutable sequence containing filtered strings. Dependencies include Scala's parallel collections. This snippet demonstrates parallelized filtering transparently.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/overviews/parallel-collections/overview.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval apellidos = List(\"Smith\",\"Jones\",\"Frankenstein\",\"Bach\",\"Jackson\",\"Rodin\").par\napellidos.filter(_.head >= 'J')\n```\n\n----------------------------------------\n\nTITLE: Defining the RNA2 Custom Collection Class in Scala\nDESCRIPTION: Defines the `RNA2` class, an intermediate version of a custom RNA sequence collection. It extends `IndexedSeq[Base]` and `IndexedSeqLike[Base, RNA2]` to integrate with Scala's collection framework. Includes an implementation of `newBuilder` using `ArrayBuffer` and `mapResult` to ensure methods like `take` and `drop` return `RNA2` instances. The `apply` method is declared but its implementation is noted as 'as before'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-collections.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nfinal class RNA2 private (\n  val groups: Array[Int],\n  val length: Int\n) extends IndexedSeq[Base] with IndexedSeqLike[Base, RNA2] {\n\n  import RNA2._\n\n  override def newBuilder: Builder[Base, RNA2] =\n    new ArrayBuffer[Base] mapResult fromSeq\n\n  def apply(idx: Int): Base = // as before\n}\n```\n\n----------------------------------------\n\nTITLE: Using Enumerations and Pattern Matching in Scala 2 and Scala 3\nDESCRIPTION: Shows importing enum values and using pattern matching or if statements to handle different enum cases. Provides examples for Scala 2 ('import' and 'match') and Scala 3 ('import' and 'match' with 'then'). Facilitates controlled branching based on enum values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-modeling.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 2\nimport CrustSize._\nval currentCrustSize = Small\n\ncurrentCrustSize match {\n  case Small => println(\"Small crust size\")\n  case Medium => println(\"Medium crust size\")\n  case Large => println(\"Large crust size\")\n}\n\nif (currentCrustSize == Small) println(\"Small crust size\")\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 3\nimport CrustSize.*\nval currentCrustSize = Small\n\ncurrentCrustSize match\n  case Small => println(\"Small crust size\")\n  case Medium => println(\"Medium crust size\")\n  case Large => println(\"Large crust size\")\n\nif currentCrustSize == Small then println(\"Small crust size\")\n```\n\n----------------------------------------\n\nTITLE: Defining Algebraic Sum Types in Scala 2 and Scala 3\nDESCRIPTION: Models recursive sum types like natural numbers using 'sealed abstract class' with 'case object' and 'case class' in Scala 2, and the 'enum' syntax in Scala 3. These types can represent variants with associated data, enabling flexible and type-safe data modeling.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-modeling.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 2\nsealed abstract class Nat\nobject Nat {\n  case object Zero extends Nat\n  case class Succ(pred: Nat) extends Nat\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 3\nenum Nat:\n  case Zero\n  case Succ(pred: Nat)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Polymorphic List Duplication Method in Scala 3\nDESCRIPTION: This snippet shows the Scala 3 syntax for creating a polymorphic method that duplicates an element a specified number of times in a list, demonstrating both explicit type parameter usage and type inference.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/polymorphic-methods.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef listOfDuplicates[A](x: A, length: Int): List[A] =\n  if length < 1 then\n    Nil\n  else\n    x :: listOfDuplicates(x, length - 1)\n\nprintln(listOfDuplicates[Int](3, 4))  // List(3, 3, 3, 3)\nprintln(listOfDuplicates(\"La\", 8))  // List(La, La, La, La, La, La, La, La)\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Snippet Compiler Flags\nDESCRIPTION: This command-line argument demonstrates combining multiple path-based configurations for the snippet compiler. It enables compilation for `docs` and `library/src`, disables it (`nocompile`) for `library/src/scala/quoted`, and expects failures (`fail`) for `library/src/scala/compiletime`. Flags are separated by commas.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/snippet-compiler.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n-snippet-compiler:docs=compile,library/src=compile,library/src/scala/quoted=nocompile,library/src/scala/compiletime=fail\n```\n\n----------------------------------------\n\nTITLE: Using reduce with non-associative subtraction in parallel collections\nDESCRIPTION: This code demonstrates that using `reduce(_-_)` on a parallel list can produce different, non-deterministic results because subtraction is not an associative operation. Multiple parallel reductions may yield varying outputs due to the arbitrary order of execution.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/overviews/parallel-collections/overview.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval list = (1 to 1000).toList.par\nlist.reduce(_-_)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nlist.reduce(_-_)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nlist.reduce(_-_)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Trait Matching Issue (SI-8399) in Scala\nDESCRIPTION: Demonstrates a potential `MatchError` when using a simple quasiquote (`q\"trait $name { ..$stats }\"`) to match a trait AST, particularly one with abstract members. This issue (SI-8399) relates to the INTERFACE flag set for traits.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/definition-details.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"trait $name { ..$stats }\" = q\"trait X { def x: Int }\"\nscala.MatchError: ...\n```\n\n----------------------------------------\n\nTITLE: Defining a simple main method with @main annotation in Scala 3\nDESCRIPTION: This snippet demonstrates how to define an executable entry point in Scala 3 using the '@main' annotation. The method 'hello()' prints 'Hello, world' when the program is executed, highlighting the ease of creating command-line programs without matching file and method names.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/methods-main-methods.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n@main def hello() = println(\"Hello, world\")\n```\n\n----------------------------------------\n\nTITLE: Splicing List of Lists of Trees with ...$ (Scala)\nDESCRIPTION: Demonstrates using the `...$` syntax within a `q` quasiquote to flatten and insert the elements from a `List[List[universe.Tree]]` (`argss`) as multiple argument lists into a curried function application `f(...)(...)`. This is 'splicing rank' 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/intro.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val fargss = q\"f(...$argss)\"\nfargss: universe.Tree = f(a, b)(c)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Level Inconsistency (Compile-Time Variable in Runtime Code)\nDESCRIPTION: Shows an incorrect macro implementation `myBadCounter1`. It attempts to access and modify a compile-time variable `x` (level 0) inside a quoted block (level 1), which is disallowed due to level consistency rules, as `x` won't exist at runtime.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef myBadCounter1(using Quotes): Expr[Int] = {\n  var x = 0\n  '{ x += 1; x }\n}\n```\n\n----------------------------------------\n\nTITLE: Calling Scala Varargs Methods from Java\nDESCRIPTION: Provides a Java example demonstrating how to call a Scala method annotated with `@varargs`. The Java code can pass multiple arguments directly, which are then handled as a sequence by the Scala method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/interacting-with-java.md#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\npublic class JVarargs {\n  public static void main(String[] args) {\n    VarargsPrinter.printAll(\"Hello\", \"world\");\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Polymorphic Eta-Expansion with Context Functions in Scala\nDESCRIPTION: Demonstrates how polymorphic eta-expansion works with methods that have context parameters and how they expand into polymorphic context functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/polymorphic-eta-expansion.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ndef f[A](using Int)(x: A)(using String): A\ndef f[B](x: B, y: B): B\n\ngiven i: Int = ???\ngiven s: String = ???\nval v: [T] => T => T = f\n// f expands to: [T'] => (t: T') => f[T'](t)\n// and then to:  [T'] => (t: T') => f[T'](using i)(t)(using s)\n\ndef g[C](using C): C\nval vg: [T] => T ?=> T = g\n// g expands to: [T'] => (t: T') ?=> g[T']\n// and then to:  [T'] => (t: T') ?=> g[T'](using t)\n```\n\n----------------------------------------\n\nTITLE: Modified Graph Implementation with Type Projection in Scala\nDESCRIPTION: A modified graph implementation using type projection (Graph#Node) to allow connecting nodes from different graph instances. This demonstrates how to work with a more general node type when needed, enabling cross-graph connections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/inner-classes.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass Graph {\n  class Node {\n    var connectedNodes: List[Graph#Node] = Nil\n    def connectTo(node: Graph#Node): Unit = {\n      if (!connectedNodes.exists(node.equals)) {\n        connectedNodes = node :: connectedNodes\n      }\n    }\n  }\n  var nodes: List[Node] = Nil\n  def newNode: Node = {\n    val res = new Node\n    nodes = res :: nodes\n    res\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using `_` placeholders for type lambdas in Scala 3\nDESCRIPTION: Shows how to rewrite the `kind-projector` `*` placeholder syntax from Scala 2 into the new Scala 3 syntax using `_`. This syntax is enabled by the `-Ykind-projector:underscores` compiler flag or the corresponding cross-compilation flags.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/plugin-kind-projector.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nTuple2[_, Double]        // equivalent to: type R[A] = Tuple2[A, Double]\nEither[Int, +_]          // equivalent to: type R[+A] = Either[Int, A]\nFunction2[-_, Long, +_]  // equivalent to: type R[-A, +B] = Function2[A, Long, B]\n```\n\n----------------------------------------\n\nTITLE: Constructing JSON object with uJson in Scala\nDESCRIPTION: Creates a JSON object with library metadata, versions, and documentation URL using ujson in Scala 2 and Scala 3. It illustrates defining data structures with ujson.Value and ujson.Arr for JSON construction, serving as a foundational step for JSON handling in Scala applications.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/json-what-else.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval obj: ujson.Value = ujson.Obj(\n  \"library\" -> \"upickle\",\n  \"versions\" -> ujson.Arr(\"1.6.0\", \"2.0.0\", \"3.1.0\"),\n  \"documentation\" -> \"https://com-lihaoyi.github.io/upickle/\"\n)\n```\n\n----------------------------------------\n\nTITLE: If-elseif-else control flow in Python and Scala\nDESCRIPTION: Shows branching logic using if, else if (elif), and else constructs to classify integer x as negative, zero, or positive with corresponding print outputs. Inputs: integer x; outputs: printed classification string. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_24\n\nLANGUAGE: Scala\nCODE:\n```\nif x < 0 then\n  println(\"negative\")\nelse if x == 0 then\n  println(\"zero\")\nelse\n  println(\"positive\")\n```\n\n----------------------------------------\n\nTITLE: Instantiating a Class Using None for Optional Field (Scala)\nDESCRIPTION: Demonstrates creating an `Address` instance where the optional `street2` field (of type `Option[String]`) is explicitly set to `None`, correctly and safely representing the absence of a second street address line.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/no-null-values.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval santa = new Address(\n    \"1 Main Street\",\n    None,\n    \"North Pole\",\n    \"Alaska\",\n    \"99705\"\n)\n```\n\n----------------------------------------\n\nTITLE: Using the printf Macro in Scala Application Code\nDESCRIPTION: Demonstrates usage of the previously defined `printf` macro in a separate Scala object `Test`. The macro is used as a normal function call to print a formatted string. Macro usage does not require explicit importing of language experimental macros, and the example illustrates a simple call to the macro facade.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/overview.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nobject Test extends App {\n  import Macros._\n  printf(\"hello %s!\", \"world\")\n}\n```\n\n----------------------------------------\n\nTITLE: Decompiled JVM bytecode signature showing type erasure in Java\nDESCRIPTION: This output from the 'javap' tool demonstrates how the Scala generic List[Int] appears after JVM compilation with type parameters erased to List<Object>. It highlights the loss of precise type information due to JVM limitations, an important motivation for TASTy.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/scala3/guides/tasty-overview.md#_snippet_6\n\nLANGUAGE: java\nCODE:\n```\npublic scala.collection.immutable.List<java.lang.Object> xs();\n```\n\n----------------------------------------\n\nTITLE: Documenting Methods (Scaladoc Style, Column 3) in Scala\nDESCRIPTION: Shows an alternative Scaladoc comment style where the initial summary starts on the first line, and subsequent lines with asterisks are aligned in column three. The text content aligns starting from column five.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/scaladoc.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n/** Provides a service as described.\n  *\n  * This is further documentation of what we're documenting.\n  * Here are more details about how it works and what it does.\n  */\ndef member: Unit = ()\n```\n\n----------------------------------------\n\nTITLE: Creating a Sub-Array View in Scala - Scala\nDESCRIPTION: Creates a view `subarr` representing a slice of the original mutable array `arr` from index 3 to 6. The view does not copy elements but maps the slice lazily, enabling efficient access and modification of a subset of the array without overhead of copying.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/views.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval subarr = arr.view.slice(3, 6)\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Multiple Cases in Scala\nDESCRIPTION: Illustrates Scala's 'match' expression matching an integer 'i' against grouped alternatives, labeling values as \"odd\", \"even\", or \"too big\" strings. Highlights concise multi-case pattern matching with '|' syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_32\n\nLANGUAGE: Scala\nCODE:\n```\nval numAsString = i match\n  case 1 | 3 | 5 | 7 | 9 => \"odd\"\n  case 2 | 4 | 6 | 8 | 10 => \"even\"\n  case _ => \"too big\"\n```\n\n----------------------------------------\n\nTITLE: Listing compiled Scala output files in Bash\nDESCRIPTION: This snippet uses the 'ls -1' command to display a list of files in the current directory after compilation, showing '.class', '.tasty', and source files generated by scalac. It provides a view to identify the various Scala compilation artifacts on disk.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/scala3/guides/tasty-overview.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ ls -1\nHello$package$.class\nHello$package.class\nHello$package.tasty\nHello.scala\nhello.class\nhello.tasty\n```\n\n----------------------------------------\n\nTITLE: Specifying a Precise Union Return Type for Transparent Inline Function in Scala\nDESCRIPTION: Shows an alternative definition of the `default` function using a more precise union type (`0 | \"\"`) as its declared return type. While this is more descriptive, the `transparent` keyword still governs the call-site type refinement based on the actual inlined expression.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\ntransparent inline def default(inline name: String): 0 | \"\" = ...\n```\n\n----------------------------------------\n\nTITLE: Checking Seq Concatenation Property in Scala\nDESCRIPTION: Illustrates a fundamental property of Scala `Seq` collections where the size of the concatenated sequence equals the sum of the sizes of the original sequences. This property is used to determine the appropriate base type for a custom collection like `Capped1` which doesn't satisfy this.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n(xs ++ ys).size == xs.size + ys.size\n```\n\n----------------------------------------\n\nTITLE: Traits as Interfaces in Scala 2\nDESCRIPTION: Defines modular behaviors for animals using traits with abstract and concrete methods, demonstrating their use as interfaces in Scala 2. Dependencies include no external libraries; traits can be combined via inheritance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-modeling.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Speaker {\n  def speak(): String  // has no body, so it’s abstract\n}\n\ntrait TailWagger {\n  def startTail(): Unit = println(\"tail is wagging\")\n  def stopTail(): Unit = println(\"tail is stopped\")\n}\n\ntrait Runner {\n  def startRunning(): Unit = println(\"I’m running\")\n  def stopRunning(): Unit = println(\"Stopped running\")\n}\n```\n\n----------------------------------------\n\nTITLE: Deconstructing Tuple with Pattern Matching in Scala\nDESCRIPTION: Shows how to unpack tuple elements into separate variables using pattern matching syntax. Variables 'name' and 'quantity' receive the first and second elements of 'ingredient', allowing direct access without using positional selectors. Types are inferred as String and Int respectively.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/tuples.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval (name, quantity) = ingredient\nprintln(name) // Sugar\nprintln(quantity) // 25\n```\n\n----------------------------------------\n\nTITLE: Case Class Copy Method with Default Arguments in Scala\nDESCRIPTION: Illustrates how default arguments are automatically generated for the copy method in Scala case classes. The copy method takes the same parameters as the primary constructor, with each parameter defaulting to the corresponding constructor parameter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-and-default-arguments.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ncase class A[T](a: T, b: Int) {\n// def copy[T'](a': T' = a, b': Int = b): A[T'] =\n// new A[T'](a', b')\n}\nval a1: A[Int] = A(1, 2)\nval a2: A[String] = a1.copy(a = \"someString\")\n```\n\n----------------------------------------\n\nTITLE: Defining Interfaces with Default Methods in Java\nDESCRIPTION: Defines a Java interface named Adder with an abstract method add and a default method multiply that provides an implementation. This allows classes implementing Adder to inherit a default multiply method without overriding it. Requires Java 8 or newer for default method support.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_20\n\nLANGUAGE: java\nCODE:\n```\npublic interface Adder {\n  int add(int a, int b);\n  default int multiply(\n    int a, int b\n  ) {\n    return a * b;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running partest tests by regex (partest-ack, Shell)\nDESCRIPTION: Demonstrates using the `partest-ack` tool from the `tools` directory to execute `partest` tests whose names match a given regular expression pattern (e.g., \"dottype\"). Note: `partest-ack` was removed in Scala 2.12. Requires the `partest-ack` script.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/hacker-guide.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\n./tools/partest-ack \"dottype\"\n```\n\n----------------------------------------\n\nTITLE: Configuring sbt cross-building for Scala 2.13 and Scala 3\nDESCRIPTION: This snippet sets up cross-compilation in sbt to target both Scala 2.13 and Scala 3, facilitating seamless testing and migration. It defines the default Scala version and the supported cross-versions for the project, ensuring the build can switch between Scala versions via sbt commands.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-sbt.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nscalaVersion := \"3.3.1\"\ncrossScalaVersions ++= Seq(\"2.13.11\", \"3.3.1\")\n```\n\n----------------------------------------\n\nTITLE: Use Returned `greetFunction` (Scala REPL)\nDESCRIPTION: Demonstrates how to call the `greet` method in the Scala REPL to obtain the returned function. It shows assigning the function to a variable `greetFunction`, verifying its type (`String => Unit`), and then executing the function by passing a `String` argument.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-write-method-returns-function.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val greetFunction = greet()\nval greetFunction: String => Unit = Lambda....\n    -----------------------------\n```\n\nLANGUAGE: Scala\nCODE:\n```\ngreetFunction(\"Joe\")   // prints \"Hello, Joe\"\n```\n\n----------------------------------------\n\nTITLE: Composing Expressions with REPL Result Variables - Scala\nDESCRIPTION: Demonstrates how to assign a new variable based on values stored in previously auto-generated result variables 'res0' and 'res1'. This example shows the flexibility of the REPL environment for chaining calculations and using temporary results. Only a basic REPL session is required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/scala-repl.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val z = res0 + res1\nz: Int = 5\n```\n\n----------------------------------------\n\nTITLE: Adding upickle dependency in sbt build.sbt\nDESCRIPTION: This snippet shows how to declare the upickle library dependency in an sbt build.sbt file, either by defining the toolkit version or including only the specific upickle version. It reflects standard sbt dependency syntax for project setup.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-upickle.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nlazy val example = project.in(file(\".\"))\n  .settings(\n    scalaVersion := \"3.4.2\",\n    libraryDependencies += \"org.scala-lang\" %% \"toolkit\" % \"0.7.0\"\n  )\n```\n\nLANGUAGE: Scala\nCODE:\n```\nlibraryDependencies += \"com.lihaoyi\" %% \"upickle\" % \"4.1.0\"\n```\n\n----------------------------------------\n\nTITLE: Using a Multiline if Statement in Scala\nDESCRIPTION: In Scala 3, a multiline `if` statement uses the `then` keyword, and the block of code is defined by indentation. Parentheses around the condition are optional.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_33\n\nLANGUAGE: Scala\nCODE:\n```\nif x == 1 then\n  println(\"x is 1, as you can see:\")\n  println(x)\n```\n\n----------------------------------------\n\nTITLE: Filtering Elements in 'for' Loops Using Guards ('if') in Scala\nDESCRIPTION: Demonstrates adding `if` conditions (guards) within a `for` loop to filter elements during iteration. Only elements satisfying the guard condition (even numbers in this case) are processed. Compares Scala 2 and Scala 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_12\n\nLANGUAGE: Scala 2\nCODE:\n```\nfor {\n  i <- 1 to 5\n  if i % 2 == 0\n} {\n  println(i)\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nfor\n  i <- 1 to 5\n  if i % 2 == 0\ndo\n  println(i)\n```\n\n----------------------------------------\n\nTITLE: Defining Boolean Predicate Methods for Filtering in Scala\nDESCRIPTION: Defines methods that return a Boolean value indicating whether an integer is less than five. Used as predicates for filtering a List. No dependencies. Inputs: Int values. Outputs: Boolean values. Highlights both verbose and concise syntax alternatives.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/anonymous-functions.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ndef lessThanFive(i: Int): Boolean = if (i < 5) true else false\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef lessThanFive(i: Int): Boolean = (i < 5)\n```\n\n----------------------------------------\n\nTITLE: Resulting Directory Structure from sbt New Template - Bash Output\nDESCRIPTION: The output of the 'tree' command after running an sbt project template generation, showing a typical directory and file layout including 'build.sbt', 'project/build.properties', README.md, and source/test directories with example Scala files. This structure follows recommended sbt conventions for new projects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n$ tree scala-3-project-template\nscala-3-project-template\n├── build.sbt\n├── project\n│   └── build.properties\n├── README.md\n└── src\n    ├── main\n    │   └── scala\n    │       └── Main.scala\n    └── test\n        └── scala\n            └── Test1.scala\n```\n\n----------------------------------------\n\nTITLE: Variable Declaration in Scala\nDESCRIPTION: Examples of variable and constant declaration in Scala with type specifications and best practices.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/cheatsheets/index.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nvar x = 5\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval x = 5\n```\n\nLANGUAGE: Scala\nCODE:\n```\nx=6\n```\n\nLANGUAGE: Scala\nCODE:\n```\nvar x: Double = 5\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Class with Default Constructor Parameters\nDESCRIPTION: This snippet demonstrates how to assign default values to constructor parameters in a Scala class using the `=` syntax. This allows for more flexible instantiation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/constructors-default-values.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass Socket(var timeout: Int = 2000, var linger: Int = 3000) {\n    override def toString = s\"timeout: $timeout, linger: $linger\"\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Compiled Scala Application on JVM via scala Command\nDESCRIPTION: Demonstrates running the compiled Scala Hello application by invoking the scala command with the object name Hello. This loads the generated class files and executes the main method, resulting in console output. Requires JVM and Scala runtime environment installed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/hello-world-1.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n$ scala Hello\n```\n\n----------------------------------------\n\nTITLE: Defining a Contravariant Printer Class in Scala\nDESCRIPTION: This snippet defines an abstract class Printer with a contravariant type parameter (-A). It declares a single method print to output values of type A. This class serves as the base for contravariance examples, illustrating how printer types relate inversely to their type parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/variances.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Printer[-A] {\n  def print(value: A): Unit\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Thread-Safe Set in Scala\nDESCRIPTION: This snippet demonstrates how to create a thread-safe HashSet by mixing in the SynchronizedSet trait, following the same pattern used for synchronized maps.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/maps.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable\nval synchroSet =\n  new mutable.HashSet[Int] with\n      mutable.SynchronizedSet[Int]\n```\n\n----------------------------------------\n\nTITLE: Creating Empty Scala TreeSet with Default Ordering\nDESCRIPTION: This Scala snippet shows how to create an empty `immutable.TreeSet` without specifying an explicit `Ordering`. By providing the element type `[String]`, the set automatically uses the default `Ordering` for strings, which is ascending lexicographical order.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/sets.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nscala> TreeSet.empty[String]\nres2: scala.collection.immutable.TreeSet[String] = TreeSet()\n```\n\n----------------------------------------\n\nTITLE: Enqueuing a Single Element to an Immutable Queue in Scala\nDESCRIPTION: Shows how to add a single element (1) to an existing immutable `Queue` (`empty`) using the `enqueue` method. This operation returns a new queue instance containing the original elements plus the added one, preserving immutability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/concrete-immutable-collection-classes.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nscala> val has1 = empty.enqueue(1)\nhas1: scala.collection.immutable.Queue[Int] = Queue(1)\n```\n\n----------------------------------------\n\nTITLE: Returning Values from If/Else Expressions in Scala 2\nDESCRIPTION: Demonstrates using if/else as an expression that selects between variables a and b, assigning the result to x. No special imports; a and b must be defined. The output is the selected value, which can be any type shared by a and b.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval x = if (a < b) { a } else { b }\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract Types with Concrete Types in Scala\nDESCRIPTION: Demonstrates concrete implementation of abstract types by creating an IntSeqBuffer class that specifies U as Int, and using anonymous classes to set T as List[U]. Shows how to instantiate and use buffers with specific integer sequences.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/abstract-type-members.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nabstract class IntSeqBuffer extends SeqBuffer {\n  type U = Int\n}\n\n\ndef newIntSeqBuf(elem1: Int, elem2: Int): IntSeqBuffer =\n  new IntSeqBuffer {\n       type T = List[U]\n       val element = List(elem1, elem2)\n     }\nval buf = newIntSeqBuf(7, 8)\nprintln(\"length = \" + buf.length)\nprintln(\"content = \" + buf.element)\n```\n\n----------------------------------------\n\nTITLE: Installing @unroll Compiler Plugin and Annotation in Scala Projects\nDESCRIPTION: Instructions for adding the @unroll compiler plugin and annotation dependencies to a Scala project using Ivy coordinates. These artifacts allow developers to use the @unroll annotation to maintain binary compatibility without manual stubs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/unroll-default-arguments.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\nivy\"com.lihaoyi::unroll-plugin:0.1.12\"\nivy\"com.lihaoyi::unroll-annotation:0.1.12\"\n```\n\n----------------------------------------\n\nTITLE: Handling Expected Compile Errors with mdoc:fail in Scala\nDESCRIPTION: Illustrates using the `mdoc:fail` modifier for Scala code snippets that are expected to fail compilation. The mdoc tool will verify that the code (`val b: String = 3`) indeed results in a compile-time error.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/add-guides.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:fail\nval b: String = 3 // won't compile\n```\n```\n\n----------------------------------------\n\nTITLE: Scala/Java Bidirectional Collection Type Mappings\nDESCRIPTION: Lists the direct mappings for bidirectional conversions between core Scala mutable collections and their Java counterparts facilitated by `JavaConverters`. It includes Iterators, Iterables, Buffers, Sets, Maps, and ConcurrentMaps.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/conversions-between-java-and-scala-collections.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nIterator               <=>     java.util.Iterator\nIterator               <=>     java.util.Enumeration\nIterable               <=>     java.lang.Iterable\nIterable               <=>     java.util.Collection\nmutable.Buffer         <=>     java.util.List\nmutable.Set            <=>     java.util.Set\nmutable.Map            <=>     java.util.Map\nmutable.ConcurrentMap  <=>     java.util.concurrent.ConcurrentMap\n```\n\n----------------------------------------\n\nTITLE: Default Arguments Referencing Earlier Parameters in Scala\nDESCRIPTION: Shows how default arguments can reference parameters from preceding parameter lists but not from the same parameter list. The actual argument values are used when computing dependent defaults.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-and-default-arguments.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ndef f(a: Int = 0)(b: Int = a + 1) = b // OK\n// def f(a: Int = 0, b: Int = a + 1) // \"error: not found: value a\"\nf(10)() // returns 11 (not 1)\n```\n\n----------------------------------------\n\nTITLE: Processing Option with Pattern Matching (Scala)\nDESCRIPTION: This Scala snippet demonstrates how to consume a value wrapped in an `Option` using a pattern matching expression. It shows how to handle both the `Some(value)` case (when a value is present) and the `None` case (when no value is present) explicitly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_73\n\nLANGUAGE: Scala\nCODE:\n```\nmakeInt(aString) match\n  case Some(i) => println(s\"Int i = $i\")\n  case None => println(s\"Could not convert $aString to an Int.\")\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Quoted Expressions by Type\nDESCRIPTION: Illustrates using type-test patterns within quotes. `case '{ $x: Boolean } =>` matches an `Expr[Any]` if its underlying structure corresponds to an expression of type `Boolean`, binding it to `x: Expr[Boolean]`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\ndef valueOf(x: Expr[Any])(using Quotes): Option[Any] =\n  x match\n    case '{ $x: Boolean } => valueOfBoolean(x) // x: Expr[Boolean]\n    case '{ $x: Option[Boolean] }  => valueOfBooleanOption(x) // x: Expr[Option[Boolean]]\n    case _ => None\n```\n\n----------------------------------------\n\nTITLE: Using Named Parameters for Clarity with Booleans (Scala 2 & 3)\nDESCRIPTION: Demonstrates calling the same `engage` method but using named parameters for each boolean argument (`speedIsSet = true`, `directionIsSet = true`, etc.). This significantly improves code readability and makes the purpose of each argument explicit.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nengage(\n  speedIsSet = true,\n  directionIsSet = true,\n  picardSaidMakeItSo = true,\n  turnedOffParkingBrake = false\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Boolean Logic Operators 'and', 'or', and 'negate' in Custom MyBool Case Class Scala 3\nDESCRIPTION: Defines the MyBool class with logical operator methods 'and', 'or', and 'negate' using Scala 3 significant indentation syntax. The methods implement basic boolean algebra operations as instance methods to enable infix usage.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/operators.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ncase class MyBool(x: Boolean):\n  def and(that: MyBool): MyBool = if x then that else this\n  def or(that: MyBool): MyBool = if x then this else that\n  def negate: MyBool = MyBool(!x)\n```\n\n----------------------------------------\n\nTITLE: Yielding Collections Using for Comprehension in Scala\nDESCRIPTION: Creates a collection 'xs' by iterating from 1 to 3 and yielding each element multiplied by 10. The resulting collection is a Vector containing values 10, 20, and 30. Demonstrates use of for-comprehensions to generate collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_28\n\nLANGUAGE: Scala\nCODE:\n```\nval xs = for i <- 1 to 3 yield i * 10\n// xs: Vector(10, 20, 30)\n```\n\n----------------------------------------\n\nTITLE: Converting Symbol to MethodSymbol\nDESCRIPTION: Explicitly casts a general `Symbol` instance obtained from `member` into a more specific `MethodSymbol` using the `asMethod` conversion method. This is required to access methods specific to method symbols, such as checking for constructors or variable arguments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nscala> testMember.asMethod\nres: scala.reflect.runtime.universe.MethodSymbol = method test\n```\n\n----------------------------------------\n\nTITLE: Including Named Snippets in Another Snippet\nDESCRIPTION: This markdown shows how to include one or more previously named snippets into the current Scala code block using the `sc-compile-with` argument. The code from the named snippets (`<snippet-name>`) is effectively prepended to the code in this block during compilation, allowing reuse of definitions and setup.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/snippet-compiler.md#_snippet_12\n\nLANGUAGE: markdown\nCODE:\n```\n```scala sc-compile-with:<snippet-name>(,<snippet-name>)+ ```\n```\n\n----------------------------------------\n\nTITLE: Complete For Comprehension Example with Option Values in Scala\nDESCRIPTION: A complete example showing how for comprehensions work with Option values, including the input values. This demonstrates how all conversions must succeed for the final result to be a Some, otherwise it's None.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fp-functional-error-handling.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval stringA = \"1\"\nval stringB = \"2\"\nval stringC = \"3\"\n\nval y = for\n  a <- makeInt(stringA)\n  b <- makeInt(stringB)\n  c <- makeInt(stringC)\nyield\n  a + b + c\n```\n\n----------------------------------------\n\nTITLE: Declaring Open/Inheritable Class in Scala 3\nDESCRIPTION: Uses the 'open' modifier in Scala 3 to explicitly mark a class Person as inheritable (open for extension). This deviates from the default closed class and aligns with designs intended for subclassing, providing enhanced clarity and control over inheritance semantics.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nopen class Person\n```\n\n----------------------------------------\n\nTITLE: Example project tree after creating a template-based Scala 3 project\nDESCRIPTION: Outputs the directory structure generated by the sbt template, containing build files, source code, and test directories for a standard Scala 3 project.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/tools-sbt.md#_snippet_10\n\nLANGUAGE: text\nCODE:\n```\nscala-3-project-template\n├── build.sbt\n├── project\n│   └── build.properties\n├── README.md\n└── src\n    ├── main\n    │   └── scala\n    │       └── Main.scala\n    └── test\n        └── scala\n            └── Test1.scala\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Scala Parallel Collection TaskSupport Trait\nDESCRIPTION: Provides the Scala trait definition required for creating custom task support implementations for parallel collections. It outlines the necessary methods: execute for asynchronous task submission, executeAndWaitResult for synchronous execution, and parallelismLevel to indicate the target concurrency.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/configuration.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef execute[R, Tp](task: Task[R, Tp]): () => R\n\ndef executeAndWaitResult[R, Tp](task: Task[R, Tp]): R\n\ndef parallelismLevel: Int\n```\n\n----------------------------------------\n\nTITLE: Generating Verbose Scala Optimizer Inliner Log - CLI\nDESCRIPTION: Illustrates the command-line invocation of the `scalac` compiler with the optimizer enabled (`-opt:inline:**`) and the verbose inliner logging flag (`-Vinline`). The flag is followed by the specific method signature (`my/project/C.f`) for which the inlining trace is requested.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/compiler-options/optimizer.md#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\n$> scalac Test.scala '-opt:inline:**' -Vinline my/project/C.f\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Default Parameter Instantiation in Scala REPL\nDESCRIPTION: This snippet shows the output in the Scala REPL when instantiating a class defined with default parameters using different numbers of arguments. It confirms how default values are used or overridden.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/constructors-default-values.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nscala> new Socket()\nres0: Socket = timeout: 2000, linger: 3000\n\nscala> new Socket(1000)\nres1: Socket = timeout: 1000, linger: 3000\n\nscala> new Socket(4000, 6000)\nres2: Socket = timeout: 4000, linger: 6000\n```\n\n----------------------------------------\n\nTITLE: Implicitly Providing `Type[T]` using `Type.of`\nDESCRIPTION: Illustrates how the `Type[T]` context bound is typically satisfied implicitly. When calling a method like `evalAndUse` with a concrete type (e.g., `Int`), the compiler automatically provides the `Type[Int]` instance using `Type.of[Int]`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nevalAndUse(Expr(3))\n// is equivalent to\nevalAndUse[Int](Expr(3))(using Type.of[Int])\n```\n\n----------------------------------------\n\nTITLE: Defining and Implementing Abstract Inline Methods in Scala\nDESCRIPTION: Shows how to define an abstract `inline` method within a trait (`InlineLogger`). Implementations of this trait must provide an `inline` method with the same signature, including any `inline` parameters. Abstract inline methods cannot be called directly on the trait.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\ntrait InlineLogger:\n  inline def log(inline x: Any): Unit\n\nclass PrintLogger extends InlineLogger:\n  inline def log(inline x: Any): Unit = println(x)\n```\n\n----------------------------------------\n\nTITLE: Use `createGreetingFunction` (Scala REPL/Script)\nDESCRIPTION: Demonstrates how to use the `createGreetingFunction` factory method. It calls the method with \"french\" and \"english\" as arguments to create specific greeting functions (`greetInFrench`, `greetInEnglish`) and then executes these returned functions with sample names.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-write-method-returns-function.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval greetInFrench = createGreetingFunction(\"french\")\ngreetInFrench(\"Jonathan\")   // prints \"Bonjour, Jonathan\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval greetInEnglish = createGreetingFunction(\"english\")\ngreetInEnglish(\"Joe\")   // prints \"Hello, Joe\"\n```\n\n----------------------------------------\n\nTITLE: Class Inheritance and Trait Extension in Scala\nDESCRIPTION: Shows Scala's syntax for extending one class and multiple traits/interfaces using the extends keyword followed by a comma-separated list. The class Dog inherits from Animal and mixes in traits HasLegs and HasTail, illustrating Scala's trait composition mechanism.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\nclass Dog extends Animal, HasLegs, HasTail\n```\n\n----------------------------------------\n\nTITLE: Using Optional 'end if' Syntax in Scala 3\nDESCRIPTION: Introduces the optional `end if` marker in Scala 3, which can be used to explicitly denote the end of an `if` block, particularly useful for improving readability in nested or complex conditional structures. This syntax is not available in Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_4\n\nLANGUAGE: Scala 3 Only\nCODE:\n```\nif x == 1 then\n  println(\"x is 1, as you can see:\")\n  println(x)\nend if\n```\n\n----------------------------------------\n\nTITLE: Summary of other build tools for Scala\nDESCRIPTION: Mentions alternative build systems such as Ant, Gradle, Maven, and Mill, emphasizing sbt's popularity. Also elaborates on Coursier as a dependency resolver used by sbt for efficient artifact download and management.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/tools-sbt.md#_snippet_11\n\n\n\n----------------------------------------\n\nTITLE: Function returning string based on input integer using 'match' in Scala\nDESCRIPTION: Defines a function 'matchTest' that takes an integer and returns a string based on pattern matching. The function showcases how match expressions return values and can be used to implement control flow based on input parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/pattern-matching.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef matchTest(x: Int): String = x match {\n  case 1 => \"one\"\n  case 2 => \"two\"\n  case _ => \"other\"\n}\nmatchTest(3)  // other\nmatchTest(1)  // one\n```\n\n----------------------------------------\n\nTITLE: Scala 2 Manual Eta-Expansion Using Placeholder and Lambda\nDESCRIPTION: Provides examples of manual eta-expansion in Scala 2, including using the underscore `_` syntax for partial application (`isLessThan _`) and wildcard application (`isLessThan(_, _)`), as well as anonymous functions wrapping the method call.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-eta-expansion.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval methodsA = List(isLessThan _)               // expand all parameters\nval methodsB = List(isLessThan(_, _))           // wildcard application\nval methodsC = List((x, y) => isLessThan(x, y)) // anonymous function\n```\n\n----------------------------------------\n\nTITLE: Multi-line if statement in Python and Scala\nDESCRIPTION: Illustrates multiline if control structure syntax to execute multiple instructions when condition is true. Inputs: variable x; outputs: several print calls if x==1. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_21\n\nLANGUAGE: Python\nCODE:\n```\nif x == 1:\n  print(\"x is 1, as you can see:\")\n  print(x)\n```\n\n----------------------------------------\n\nTITLE: Processing Option Values with Match Expressions in Scala\nDESCRIPTION: Example showing how to handle Option return values using pattern matching. This approach allows different code paths for Some and None cases, providing a clean way to handle both success and failure scenarios.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fp-functional-error-handling.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nmakeInt(x) match\n  case Some(i) => println(i)\n  case None => println(\"That didn't work.\")\n```\n\n----------------------------------------\n\nTITLE: Implicit Conversion from Int to java.lang.Integer in Scala\nDESCRIPTION: This Scala snippet imports the language feature for implicit conversions and defines an implicit function int2Integer that converts a Scala Int to a java.lang.Integer. This conversion supports interoperability between Scala and Java code by allowing Scala Int values to be passed where a Java Integer is required without explicit wrapping. The function uses Integer.valueOf to perform the conversion, and importing scala.language.implicitConversions is necessary to enable this feature safely.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/implicit-conversions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.language.implicitConversions\n\nimplicit def int2Integer(x: Int): Integer =\n  Integer.valueOf(x)\n```\n\n----------------------------------------\n\nTITLE: Type Safety Error with `f` Interpolator in Scala 2\nDESCRIPTION: Shows a Scala 2 compiler error when an incorrect format specifier (`%d` for Int) is used with a variable of a different type (`Double`) in an `f`-interpolated string. This demonstrates the type safety feature of the `f` interpolator.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval height: Double = 1.9d\n\nscala> f\"$height%4d\"\n<console>:9: error: type mismatch;\n  found   : Double\n  required: Int\n            f\"$height%4d\"\n              ^\n```\n\n----------------------------------------\n\nTITLE: Running Scala 2/3 Compatible Program Bash\nDESCRIPTION: Demonstrates running the Scala 2/3 compatible program defined in an `object` with an explicit `main` method using `scala run`. Similar to `@main`, arguments passed after `--` are provided as an `Array[String]` to the `main` method, where manual parsing is performed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-main-methods.md#_snippet_9\n\nLANGUAGE: Bash\nCODE:\n```\n$ scala run happyBirthday.scala -- 23 Lisa Peter\nHappy 23rd Birthday, Lisa and Peter!\n```\n\n----------------------------------------\n\nTITLE: Closing Classes by Default in Scala\nDESCRIPTION: In Scala, classes are closed for extension by default, meaning they cannot be subclassed unless explicitly marked as `open`. This promotes 'plan for inheritance or else forbid it' design.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nclass Person\n```\n\n----------------------------------------\n\nTITLE: Demonstration of side-effects and non-determinism in Scala parallel collections\nDESCRIPTION: This code snippet shows how using an external mutable variable 'sum' with `foreach` on a parallel collection leads to non-deterministic results due to race conditions. It highlights the risks of side-effects during parallel processing when mutating shared state.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/overviews/parallel-collections/overview.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nvar sum = 0\nval list = (1 to 1000).toList.par\nlist.foreach(sum += _); println(sum)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nvar sum = 0\nlist.foreach(sum += _); println(sum)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nvar sum = 0\nlist.foreach(sum += _); println(sum)\n```\n\n----------------------------------------\n\nTITLE: Using Mutable BitSets in Scala\nDESCRIPTION: Demonstrates creating an empty mutable BitSet, adding elements (1 and 3) using the `+=` operator which modifies the set in place, and displaying the final state of the BitSet. Mutable BitSets offer efficient updates compared to immutable ones.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/concrete-mutable-collection-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nscala> val bits = scala.collection.mutable.BitSet.empty\nbits: scala.collection.mutable.BitSet = BitSet()\nscala> bits += 1\nres49: bits.type = BitSet(1)\nscala> bits += 3\nres50: bits.type = BitSet(1, 3)\nscala> bits\nres51: scala.collection.mutable.BitSet = BitSet(1, 3)\n```\n\n----------------------------------------\n\nTITLE: Extending Animal Hierarchy with SmallAnimal and Mouse in Scala - scala\nDESCRIPTION: Adds to the existing Animal hierarchy by defining an abstract subclass SmallAnimal and a case class Mouse extending SmallAnimal. This expands the inheritance structure used to explain variance with Scala's Function1 trait example, providing additional subtyping relations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/variances.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nabstract class SmallAnimal extends Animal\ncase class Mouse(name: String) extends SmallAnimal\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Immutability of Scala Case Class Fields\nDESCRIPTION: Attempts to reassign the 'name' field of a 'Person' case class instance, resulting in a compile-time error. This highlights that case class constructor parameters are immutable ('val') by default, aligning with functional programming principles.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/case-classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n// can't mutate the `name` field\nscala> christina.name = \"Fred\"\n<console>:10: error: reassignment to val\n       christina.name = \"Fred\"\n                  ^\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Parts of Quoted Expressions by Type\nDESCRIPTION: Combines splice patterns and type tests. `case '{ Some($x: Boolean) } =>` matches an `Expr[Option[Any]]` (or similar) if it's a `Some` containing an expression of type `Boolean`, binding the inner expression to `x: Expr[Boolean]`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\ncase '{ Some($x: Boolean) } => // x: Expr[Boolean]\n```\n\n----------------------------------------\n\nTITLE: Proposal 2: Simplified Desugaring Output\nDESCRIPTION: Shows the proposed simpler desugared code for the preceding example (alias not followed by a guard). The alias `b = a` is directly incorporated into the lambda of the `map` call, avoiding intermediate tuples and extra maps.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ndoSth(arg).map { a =>\n  val b = a\n  a + b\n}\n```\n\n----------------------------------------\n\nTITLE: Using map as an Alternative to for/yield in Scala\nDESCRIPTION: Illustrates how the `map` method called on a range (`10 to 12`) achieves the same result as the equivalent `for`/`yield` expression, transforming each element (`i => i * 2`). This snippet is compatible with both Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_18\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\nval list = (10 to 12).map(i => i * 2)\n```\n\n----------------------------------------\n\nTITLE: Filtered for Loop Using if Guards in Python\nDESCRIPTION: Illustrates nested 'if' conditions inside a for loop iterating from 1 to 10. The loop prints 'i' only if 'i' is even and less than 5. Demonstrates filtering loop iterations with conditional statements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_23\n\nLANGUAGE: Python\nCODE:\n```\nfor i in range(1,11):\n  if i % 2 == 0:\n    if i < 5:\n      print(i)\n```\n\n----------------------------------------\n\nTITLE: Handling Option Results with Match, Scala\nDESCRIPTION: Demonstrates how to consume the result of a function returning an `Option` using a pattern `match` expression. This allows distinct handling for the `Some` case (when a value is present) and the `None` case (when it's absent).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-functional-error-handling.md#_snippet_3\n\nLANGUAGE: Scala 2\nCODE:\n```\nmakeInt(x) match {\n  case Some(i) => println(i)\n  case None => println(\"That didn’t work.\")\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nmakeInt(x) match\n  case Some(i) => println(i)\n  case None => println(\"That didn’t work.\")\n```\n\n----------------------------------------\n\nTITLE: For Expression Without Yield in Scala\nDESCRIPTION: This snippet shows a for expression without the yield statement, which returns Unit instead of a collection. It demonstrates how to use for loops for their side effects (printing values) rather than for creating new collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/for-comprehensions.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef foo(n: Int, v: Int) =\n   for (i <- 0 until n;\n        j <- i until n if i + j == v)\n   println(s\"($i, $j)\")\n\nfoo(10, 10)\n```\n\n----------------------------------------\n\nTITLE: Defining a Minimal Value Function Using if-else in Scala\nDESCRIPTION: Defines a Scala function 'min' that takes two integer parameters and returns the smaller one using an inline if-then-else expression as the method body. Demonstrates concise conditional function definitions returning expressions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\ndef min(a: Int, b: Int): Int =\n  if a < b then a else b\n```\n\n----------------------------------------\n\nTITLE: Limitations of type inference with recursive methods\nDESCRIPTION: This snippet demonstrates a scenario where Scala's type inference fails due to recursion. The compiler cannot infer the return type for the recursive function 'fac' because it depends on a self-referencing call, which requires explicit type annotation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/type-inference.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject InferenceTest2 {\n  def fac(n: Int) = if (n == 0) 1 else n * fac(n - 1)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Scala Abstract Class\nDESCRIPTION: This Scala code defines a concrete class 'Dog' that extends the abstract class 'Pet'. It demonstrates passing the 'name' constructor parameter to the superclass constructor ('Pet(name)'), overriding the concrete 'speak' method, and providing an implementation for the abstract 'comeToMaster' method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/abstract-classes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass Dog(name: String) extends Pet(name) {\n    override def speak() = println(\"Woof\")\n    def comeToMaster() = println(\"Here I come!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing Code with Quasi-Quotation in Scala 3\nDESCRIPTION: Demonstrates using Scala 3's quasi-quotation feature (`'{ ... }`) to construct a code block representing the expression `1 + 1` at compile time. This is part of Scala 3's metaprogramming facilities, providing a high-level interface for code construction and analysis.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/scala3/new-in-scala3.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n'{ 1 + 1 }\n```\n\n----------------------------------------\n\nTITLE: Creating a Tuple2 with Scala Syntax\nDESCRIPTION: Demonstrates how to create a tuple containing a String and an Int using Scala syntax. The example shows creating a Tuple2 instance with specific type annotations, which is common when returning multiple values from functions or grouping heterogeneous data.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/tuples.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval ingredient = (\"Sugar\" , 25): Tuple2[String, Int]\n```\n\n----------------------------------------\n\nTITLE: Equivalent Java Lambda Expression using Stream API\nDESCRIPTION: Provides the equivalent Java code for doubling elements in a list using the Stream API's `map` method and a lambda expression (`i -> i * 2`). This serves as a comparison for developers familiar with Java.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-anonymous-functions.md#_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nList<Integer> ints = List.of(1, 2, 3);\nList<Integer> doubledInts = ints.stream()\n                                .map(i -> i * 2)\n                                .collect(Collectors.toList());\n```\n\n----------------------------------------\n\nTITLE: Linking to GitHub Repository for Data Visualization\nDESCRIPTION: Provides a link to the GitHub repository containing Scala code used to generate plots and analyze survey data from the course. This snippet emphasizes sharing code for reproducibility and further exploration by course participants.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/news/_posts/2012-12-12-functional-programming-principles-in-scala-impressions-and-statistics.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n/* No specific code snippet provided, only a descriptive link to a GitHub project */\n```\n\n----------------------------------------\n\nTITLE: Using Tuples in for Loops\nDESCRIPTION: Demonstrates iteration over a list of tuple pairs in a 'for' loop with tuple pattern matching, allowing operations on paired data, such as multiplying elements. Useful for concise iteration where tuple destructuring simplifies code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/tuples.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval numPairs = List((2, 5), (3, -7), (20, 56))\n\nfor ((a, b) <- numPairs) {\n  println(a * b)\n}\n```\n\n----------------------------------------\n\nTITLE: Aggregating Multiple Traits in Scala 2 Package Objects\nDESCRIPTION: Shows how to aggregate reusable definitions from multiple traits into a single package object in Scala 2 by using inheritance. The `fruits` package object extends helper traits like `FruitAliases` and `FruitHelpers`, making their members accessible as package members. This allows code reuse and composition of functionality at the package level.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/package-objects.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\npackage gardening\n\n// `fruits` instead inherits its members from its parents.\npackage object fruits extends FruitAliases with FruitHelpers\n```\n\n----------------------------------------\n\nTITLE: Performing Basic Operations on an Immutable Stack in Scala\nDESCRIPTION: Shows how to create an empty immutable Stack, `push` an element (creating a new stack `hasOne`), view the `top` element without removal, and `pop` an element (returning a new stack without the top element). The original stack remains unchanged throughout.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/concrete-immutable-collection-classes.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval stack = scala.collection.immutable.Stack.empty\n```\n\nLANGUAGE: output\nCODE:\n```\nstack: scala.collection.immutable.Stack[Nothing] = Stack()\n```\n\nLANGUAGE: scala\nCODE:\n```\nval hasOne = stack.push(1)\n```\n\nLANGUAGE: output\nCODE:\n```\nhasOne: scala.collection.immutable.Stack[Int] = Stack(1)\n```\n\nLANGUAGE: scala\nCODE:\n```\nstack\n```\n\nLANGUAGE: output\nCODE:\n```\nstack: scala.collection.immutable.Stack[Nothing] = Stack()\n```\n\nLANGUAGE: scala\nCODE:\n```\nhasOne.top\n```\n\nLANGUAGE: output\nCODE:\n```\nres20: Int = 1\n```\n\nLANGUAGE: scala\nCODE:\n```\nhasOne.pop\n```\n\nLANGUAGE: output\nCODE:\n```\nres19: scala.collection.immutable.Stack[Int] = Stack()\n```\n\n----------------------------------------\n\nTITLE: Scala REPL Behavior: Reassigning a var Variable\nDESCRIPTION: This interactive REPL snippet shows variable reassignment for a mutable var variable succeeds without error. It initializes a var character variable a to 'a', then reassigns to 'b'. Demonstrates the mutability allowed by var in Scala REPL.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/two-types-variables.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nscala> var a = 'a'\na: Char = a\n\nscala> a = 'b'\na: Char = b\n```\n\n----------------------------------------\n\nTITLE: Configuring sbt Plugins for CI Release - Diff\nDESCRIPTION: This Diff snippet shows the update in the sbt plugins configuration file to replace individual plugins for PGP signing and Sonatype publishing with the unified sbt-ci-release plugin. Remove sbt-pgp, sbt-sonatype, and sbt-dynver, and add sbt-ci-release instead. sbt-ci-release streamlines the CI-based release process. The Diff should be applied in project/plugins.sbt, and further configuration may be required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_8\n\nLANGUAGE: diff\nCODE:\n```\n- addSbtPlugin(\"com.github.sbt\" % \"sbt-pgp\" % \"2.2.1\")\n- addSbtPlugin(\"org.xerial.sbt\" % \"sbt-sonatype\" % \"3.9.21\")\n- addSbtPlugin(\"com.github.sbt\" % \"sbt-dynver\" % \"5.0.1\")\n+ addSbtPlugin(\"com.github.sbt\" % \"sbt-ci-release\" % \"1.5.12\")\n```\n\n----------------------------------------\n\nTITLE: Creating Immutable Map (Scala)\nDESCRIPTION: This Scala snippet shows how to create an immutable Map instance. It uses `val` for immutability and the `Map()` factory method, employing the `->` syntax to define key-value associations within the map.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_59\n\nLANGUAGE: Scala\nCODE:\n```\nval map = Map(\n  \"a\" -> 1,\n  \"b\" -> 2,\n  \"c\" -> 3\n)\n```\n\n----------------------------------------\n\nTITLE: Matching Tuple Concatenation in Quoted Types (Problem Example) - Scala\nDESCRIPTION: Provides an example of a type pattern (`head *: tail`) that was challenging or impossible to match effectively with the old syntax due to the inability to specify bounds for type variables in quoted type patterns.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/quote-pattern-type-variable-syntax.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ncase '[ head *: tail ] => h[tail]\n```\n\n----------------------------------------\n\nTITLE: Filtering Option Values with Predicate Pattern - Scala\nDESCRIPTION: This snippet details how Option.filter(f) works through pattern matching. It returns Some(x) if the Option contains a value satisfying the predicate f, otherwise None. Inputs are an Option and a predicate function f. Outputs Option. No dependencies required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\noption match {\n  case Some(x) if f(x) => Some(x)\n  case _               => None\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Beta Reduction on Scala Expr\nDESCRIPTION: Demonstrates using the `Expr.betaReduce` function to explicitly perform beta-reduction on a quoted Scala expression. This applies to cases where a lambda is directly applied to an argument within the quote, transforming it into a more reduced form.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_29\n\nLANGUAGE: Scala\nCODE:\n```\nExpr.betaReduce('{ ((x: Int) => x + x)(y) }) // returns '{ val x = y; x + x }\n```\n\n----------------------------------------\n\nTITLE: Creating String List in Scala\nDESCRIPTION: Defines an immutable list named `people` containing several string elements (names). This list is used to demonstrate iteration with both `for` loops and the `foreach` method on a `List[String]` collection, showcasing iteration over a different data type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/for-loops.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval people = List(\n    \"Bill\", \n    \"Candy\", \n    \"Karen\", \n    \"Leo\", \n    \"Regina\"\n)\n```\n\n----------------------------------------\n\nTITLE: Using synchronized Maps in Scala\nDESCRIPTION: Shows how to use a synchronized Map created with the SynchronizedMap trait, demonstrating operations like initialization, adding key-value pairs, retrieving values, and handling missing keys with the custom default method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/maps.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval capital = MapMaker.makeMap\ncapital ++ List(\"US\" -> \"Washington\", \"France\" -> \"Paris\", \"Japan\" -> \"Tokyo\")\ncapital(\"Japan\")\ncapital(\"New Zealand\")\ncapital += (\"New Zealand\" -> \"Wellington\")\ncapital(\"New Zealand\")\n```\n\n----------------------------------------\n\nTITLE: Risks of unsafe type inference leading to compilation errors\nDESCRIPTION: This example highlights a potential pitfall where relying on type inference results in a variable with an inferred type of Null, which cannot be reassigned to a different value. It demonstrates the importance of explicit type annotations to avoid such issues.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/type-inference.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nobject InferenceTest4 {\n  var obj = null\n  obj = new Object()\n}\n```\n\n----------------------------------------\n\nTITLE: Looking Up Symbols at Compile Time with Macros and Classloader Mirror - Scala\nDESCRIPTION: Defines a macro that retrieves symbol information for the 'Location' object using compile-time reflection. Shows manual symbol lookup via the mirror staticModule API for use in macro expansions. Embeds filename, line, and column into a Location instance; required: macro context and proper imports.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/environment-universes-mirrors.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect.macros.Context\n\ncase class Location(filename: String, line: Int, column: Int)\n\nobject Macros {\n  def currentLocation: Location = macro impl\n\n  def impl(c: Context): c.Expr[Location] = {\n    import c.universe._\n    val pos = c.macroApplication.pos\n    val clsLocation = c.mirror.staticModule(\"Location\")\n    c.Expr(Apply(Ident(clsLocation), List(Literal(Constant(pos.source.path)), Literal(Constant(pos.line)), Literal(Constant(pos.column)))))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Trait for Rich Iteration Functionality in Scala\nDESCRIPTION: This snippet defines a trait `RichIterator` that extends `AbsIterator` and adds a `foreach` method, allowing users to apply a function to each element of an iterator. It demonstrates trait declaration and method implementation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/mixin-class-composition.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntrait RichIterator extends AbsIterator {\n  def foreach(f: T => Unit): Unit = { while (hasNext) f(next()) }\n}\n```\n\n----------------------------------------\n\nTITLE: Anonymous Function Parameter Type Inference in Scala 2 and 3\nDESCRIPTION: Shows inference of anonymous function parameter types based on the expected function signature when passed as an argument. Dependencies: none. Input is a sequence of integers and a lambda function; output is a list of doubled integers, with inferred parameter types within the lambda.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/type-inference.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nSeq(1, 3, 4).map(x => x * 2)  // List(2, 6, 8)\n```\n\n----------------------------------------\n\nTITLE: Using `foreach` with Eta Expansion (Method Value) in Scala\nDESCRIPTION: Demonstrates the most concise way to pass a function to `foreach` when the anonymous function consists of a single method call taking a single argument matching the list element type. `println` itself is passed as a function value (eta expansion).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-anonymous-functions.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nints.foreach(println)\n```\n\n----------------------------------------\n\nTITLE: Deprecation of early definitions in Scala 2 and unsupported in Scala 3\nDESCRIPTION: This section explains the deprecation and removal of early initializers in Scala 2.13 and Scala 3, highlighting the shift towards constant values and inline definitions as alternatives to manage initialization dependencies. It references the migration guide and best practices.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/FAQ/initialization-order.md#_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: Iterating with For Loops (Multiple Lines) - JavaScript & Scala\nDESCRIPTION: Shows multiline syntax for iterating over collections using 'for' loops in JavaScript and Scala when the loop body contains multiple statements. Includes preferred and alternative syntaxes for both languages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_27\n\nLANGUAGE: JavaScript\nCODE:\n```\n// preferred\nfor (let i of nums) {\n  let j = i * 2;\n  console.log(j);\n}\n\n// also available\nfor (i=0; i<nums.length; i++) {\n  let j = nums[i] * 2;\n  console.log(j);\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// preferred\nfor i <- nums do\n  val j = i * 2\n  println(j)\n\n// also available\nfor (i <- nums) {\n  val j = i * 2\n  println(j)\n}\n```\n\n----------------------------------------\n\nTITLE: Using the -snippet-compiler setting for type checking snippet compilation - General syntax\nDESCRIPTION: Defines the format and flags for the -snippet-compiler scaladoc option to configure snippet type checking modes. Arguments are specified as a comma-separated list of optional path prefixes mapped to compilation flags. Flags include `compile` for ensuring snippet compiles, `nocompile` for disabling checks, and `fail` to assert compilation failure. This setting controls how code snippets embedded in documentation are validated during scaladoc processing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/settings.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nargs := arg{,args}\narg := [path=]flag\n\nExample usage:\n\n\"-snippet-compiler:my/path/nc=nocompile,my/path/f=fail,compile\"\n```\n\n----------------------------------------\n\nTITLE: Calling sequence methods directly on arrays in Scala\nDESCRIPTION: This snippet demonstrates calling sequence methods like 'reverse' directly on arrays, which under the hood uses implicit conversions to insert an ArrayOps wrapper. The method invocation results in an array with reversed elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/arrays.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\na1.reverse\nres4: Array[Int] = Array(3, 2, 1)\n```\n\n----------------------------------------\n\nTITLE: Traits and Multiple Inheritance in Scala\nDESCRIPTION: Demonstrates the use of Scala traits to define reusable behaviors such as addition and multiplication, and how to create a class that extends multiple traits to compose functionality.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Adder:\n  def add(a: Int, b: Int) = a + b\n\ntrait Multiplier:\n  def multiply(a: Int, b: Int) = a * b\n\n// create a class from the traits\nclass SimpleMath extends Adder, Multiplier\nval sm = new SimpleMath\nsm.add(1, 1)  // 2\nsm.multiply(2, 2)  // 4\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Library Dependencies in Scala SBT\nDESCRIPTION: An example SBT configuration showing how build tools automatically update dependencies to the latest patch version required by any dependency on the classpath.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/drop-stdlib-forwards-bin-compat.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies ++= List(\n  \"com.softwaremill.sttp.client3\" %% \"core\" % \"3.8.3\", // depends on ws 1.3.10\n  \"com.softwaremill.sttp.shared\"  %% \"ws\"   % \"1.2.7\", // for demonstration\n)\n```\n\n----------------------------------------\n\nTITLE: Equality and toString Methods for Case Classes in Scala\nDESCRIPTION: Creates two SMS instances with identical data and compares them for equality, showing structural comparison. Also prints one SMS instance, demonstrating automatic 'toString' formatting.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/case-classes.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval primeiroSMS = SMS(\"12345\", \"Hello!\")\nval segundoSMS = SMS(\"12345\", \"Hello!\")\n\nif (primeiroSMS == segundoSMS) {\n  println(\"Somos iguais!\")\n}\n\nprintln(\"SMS é: \" + primeiroSMS) // Outputs 'SMS(12345, Hello!)'\n```\n\n----------------------------------------\n\nTITLE: Using Futures for Blocking I/O Operations in Scala\nDESCRIPTION: Shows how to use a Scala `Future` to perform potentially blocking I/O operations asynchronously. This example reads a text file and searches for a keyword's first occurrence off the main thread, improving responsiveness.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/futures.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval firstOccurence: Future[Int] = Future {\n  val source = scala.io.Source.fromFile(\"myText.txt\")\n  source.toSeq.indexOfSlice(\"myKeyword\")\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Type Casting Example in Scala\nDESCRIPTION: This example illustrates an invalid type cast in Scala that won't compile. It shows that while a Long can be converted to a Float, the reverse operation is not automatically allowed due to Scala's unidirectional casting system.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/unified-types.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval x: Long = 987654321\nval y: Float = x.toFloat  // 9.8765434E8\nval z: Long = y  // Does not conform\n```\n\n----------------------------------------\n\nTITLE: Filter Method in Scala Collections\nDESCRIPTION: Examples of using the filter method to create a new collection containing only elements that satisfy a predicate, including filtering numbers and strings based on various conditions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-methods.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nscala> val lessThanFive = oneToTen.filter(_ < 5)\nlessThanFive: List[Int] = List(1, 2, 3, 4)\n\nscala> val evens = oneToTen.filter(_ % 2 == 0)\nevens: List[Int] = List(2, 4, 6, 8, 10)\n\nscala> val shortNames = names.filter(_.length <= 4)\nshortNames: List[String] = List(adam)\n```\n\nLANGUAGE: scala\nCODE:\n```\noneToTen.filter(_ < 4).map(_ * 10)\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> oneToTen.filter(_ < 4).map(_ * 10)\nval res1: List[Int] = List(10, 20, 30)\n```\n\n----------------------------------------\n\nTITLE: Defining a Multiline Method in Scala 2\nDESCRIPTION: Illustrates defining a method (`addThenDouble`) with a body spanning multiple lines in Scala 2, enclosed in curly braces `{}`. The method calculates a sum and then returns the doubled sum. The last expression in the block is the return value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef addThenDouble(a: Int, b: Int): Int = {\n  // imagine that this body requires multiple lines\n  val sum = a + b\n  sum * 2\n}\n```\n\n----------------------------------------\n\nTITLE: Compiler Error for Missing Propagated ClassTag\nDESCRIPTION: Displays the compiler error resulting from the failed nested generic call in the previous example. The error explicitly states 'No ClassTag available for U', because the 'wrap' function didn't request one.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/arrays.md#_snippet_11\n\nLANGUAGE: text\nCODE:\n```\n<console>:6: error: No ClassTag available for U.\n     def wrap[U](xs: Vector[U]) = evenElems(xs)\n                                           ^\n```\n\n----------------------------------------\n\nTITLE: Nested for loops with multiple ranges in Python and Scala\nDESCRIPTION: Shows how to nest for loops to iterate across multiple ranges and print combined values. Inputs: ranges for i, j, k; outputs: printed combinations with formatted strings. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_37\n\nLANGUAGE: Python\nCODE:\n```\nfor i in range(1,3):\n  for j in range(4,6):\n    for k in range(1,10,3):\n      print(f\"i = {i}, j = {j}, k = {k}\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Tuple in Scala\nDESCRIPTION: Creates a tuple with two elements, a String and an Int, using Scala's tuple syntax. The resulting value 'ingredient' has an inferred type of Tuple2[String, Int] or (String, Int). This snippet requires no external dependencies and demonstrates basic tuple construction.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/tuples.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval ingredient = (\"Sugar\" , 25)\n```\n\n----------------------------------------\n\nTITLE: Error Output for Incorrectly Compiling Failing Snippet\nDESCRIPTION: This text block shows the error message generated by the snippet compiler when a code block marked with `sc:fail` compiles successfully instead of failing as expected. It indicates the location of the snippet and the nature of the error.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/snippet-compiler.md#_snippet_7\n\nLANGUAGE: nohighlight\nCODE:\n```\nIn static site (./docs/docs/index.md):\nError: Snippet should not compile but compiled succesfully\n```\n\n----------------------------------------\n\nTITLE: Alternative to Union Types: Pre-Planned Class Hierarchy\nDESCRIPTION: Presents an alternative approach without union types, using a shared marker trait (`UsernameOrPassword`) extended by the relevant case classes (`Username`, `Password`). This requires foresight in designing the class hierarchy.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-union.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntrait UsernameOrPassword\ncase class Username(name: String) extends UsernameOrPassword\ncase class Password(hash: Hash) extends UsernameOrPassword\ndef help(id: UsernameOrPassword) = ...\n```\n\n----------------------------------------\n\nTITLE: Starting the Scala 3 REPL (Bash)\nDESCRIPTION: Shows the command (`scala` or potentially `scala3` depending on installation) used to launch the Scala 3 REPL from the operating system's command line. Includes the typical welcome message and prompt displayed upon successful startup.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-repl.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ scala\nWelcome to Scala {{site.scala-3-version}} (1.8.0_322, Java OpenJDK 64-Bit Server VM).\nType in expressions for evaluation. Or try :help.\n\nscala> _\n```\n\n----------------------------------------\n\nTITLE: Tagging Flaky Tests in Scala\nDESCRIPTION: Shows how to mark tests as flaky using the .flaky tag. These tests can be conditionally skipped by setting the MUNIT_FLAKY_OK environment variable to true, which is useful for tests that occasionally fail due to external factors.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-what-else.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntest(\"requests\".flaky) {\n  // I/O heavy tests that sometimes fail\n}\n```\n\n----------------------------------------\n\nTITLE: Evaluating Simple Expressions in Scala - Scala\nDESCRIPTION: Demonstrates basic arithmetic and expression evaluation in Scala by computing values such as addition or string concatenation. This snippet shows how expressions can be calculated and their results printed directly. No special dependencies are required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/tour/basics.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n1 + 1\n```\n\n----------------------------------------\n\nTITLE: Scala Abstract Class with Type Member for Iterators\nDESCRIPTION: This snippet defines an abstract class 'AbsIterator' with an abstract type member 'T' and core iterator methods 'hasNext' and 'next'. It serves as a generic iterator interface allowing different element types, facilitating flexible iterator implementations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/mixin-class-composition.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nabstract class AbsIterator {\n  type T\n  def hasNext: Boolean\n  def next(): T\n}\n```\n\n----------------------------------------\n\nTITLE: Dictionary/Map data structure in Python and Scala\nDESCRIPTION: Provides an example of creating key-value pair collections in Python and Scala. Explains syntax differences, with Python using braces and colons, while Scala uses 'Map()' with '-&gt;' for pairs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nx = {\n  \"Toy Story\": 8.3,\n  \"Forrest Gump\": 8.8,\n  \"Cloud Atlas\": 7.4\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval x = Map(\n  \"Toy Story\" -&gt; 8.3,\n  \"Forrest Gump\" -&gt; 8.8,\n  \"Cloud Atlas\" -&gt; 7.4\n)\n```\n\n----------------------------------------\n\nTITLE: Chaining Multiple Map Operations Lazily on Scala SeqView - Scala\nDESCRIPTION: Chains a second map operation on an existing SeqViewM resulting in SeqViewMM, which contains two lazily applied map transformations. This example further illustrates how views accumulate transformations without execution until forced.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/views.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nres13 map (_ * 2)\n```\n\n----------------------------------------\n\nTITLE: Multiline Strings with Interpolation in Scala\nDESCRIPTION: This snippet demonstrates how to create multiline strings with interpolation in Scala using triple quotes (\"\"\"). The example also shows using stripMargin to remove leading whitespace and standard string methods like replaceAll and trim.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nval name = \"Martin Odersky\"\n\nval quote = s\"\"\"\n  |$name says\n  |Scala is a fusion of\n  |OOP and FP.\n\"\"\".stripMargin.replaceAll(\"\\n\", \" \").trim\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Enums in Python\nDESCRIPTION: Illustrates how to define a simple enumeration (`Color`) in Python using the `Enum` base class and `auto()` for automatic value assignment. Requires importing `Enum` and `auto` from the `enum` module.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_70\n\nLANGUAGE: Python\nCODE:\n```\nfrom enum import Enum, auto\nclass Color(Enum):\n    RED = auto()\n    GREEN = auto()\n    BLUE = auto()\n```\n\n----------------------------------------\n\nTITLE: ケースクラスの値による比較 - Scala\nDESCRIPTION: ケースクラスの==演算子は値を比較することを示す例です。二つの同じ座標のPointオブジェクトは等しいと判定され異なる座標は異なると判定され、それに応じてメッセージを標準出力に表示します。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nif (point == anotherPoint) {\n  println(s\"$point と $anotherPoint は同じです。\")\n} else {\n  println(s\"$point と $anotherPoint は異なります。\")\n} // Point(1,2) と Point(1,2) は同じです。\n\nif (point == yetAnotherPoint) {\n  println(s\"$point と $yetAnotherPoint は同じです。\")\n} else {\n  println(s\"$point と $yetAnotherPoint は異なります。\")\n} // Point(1,2) と Point(2,2) は異なります。\n```\n\n----------------------------------------\n\nTITLE: Обработка Option с помощью match в Scala 2 и Scala 3\nDESCRIPTION: Пример использования конструкции match для работы с результатами makeInt. В случае Some(i) выводится число, в случае None – сообщение о неудаче, что позволяет управлять потоками логики в зависимости от результата.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fp-functional-error-handling.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nmakeInt(x) match {\n  case Some(i) => println(i)\n  case None => println(\"That didn’t work.\")\n}\n```\n\n----------------------------------------\n\nTITLE: Outputting Values with println in Scala\nDESCRIPTION: Shows how to display integer and string values and combine strings using the println function. This snippet highlights basic input types (integers, strings) and their printed output. No dependencies or configuration needed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nprintln(1) // 1\nprintln(1 + 1) // 2\nprintln(\"Hello!\") // Hello!\nprintln(\"Hello,\" + \" world!\") // Hello, world!\n```\n\n----------------------------------------\n\nTITLE: Defining Implicit Conversion within an Object in Scala 2\nDESCRIPTION: Shows how to define an implicit conversion (`fromStringToUser`) within a Scala object (`Conversions`) in Scala 2. The conversion is defined using `implicit def` and must be explicitly imported into the scope where it's needed. Requires `import scala.language.implicitConversions`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-implicit-conversions.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.language.implicitConversions\n\nobject Conversions {\n  implicit def fromStringToUser(name: String): User = User(name)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Main Program Entry Point in Scala\nDESCRIPTION: Explains how to define the main entry point for a Scala program, required by the JVM. It presents the Scala 2 approach using an object with a `main` method accepting `Array[String]`, and the simplified Scala 3 approach using the `@main` annotation on a method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\nobject Main {\n  def main(args: Array[String]): Unit =\n    println(\"Hello, Scala developer!\")\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\n@main def hello() = println(\"Hello, Scala developer!\")\n```\n\n----------------------------------------\n\nTITLE: List Concatenation and Range Syntax - Scala\nDESCRIPTION: Concatenates lists using the '::' operator and demonstrates range generation with 'to', 'until', and 'by'. Inputs: numeric ranges or lists. Outputs: constructed lists or sequences. Useful for building and traversing data structures.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\n1 :: List(2,3)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n1 to 5\n```\n\nLANGUAGE: Scala\nCODE:\n```\n1 until 6\n```\n\nLANGUAGE: Scala\nCODE:\n```\n1 to 10 by 2\n```\n\n----------------------------------------\n\nTITLE: For Loop with Multiple Generators in Scala\nDESCRIPTION: Uses multiple generators in a single for expression with ranges including steps. Prints formatted strings showing the current values for i, j, k. Illustrates expressive generator syntax with compact notation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_44\n\nLANGUAGE: scala\nCODE:\n```\nfor\n  i <- 1 to 2\n  j <- 'a' to 'b'\n  k <- 1 to 10 by 5\n do\n  println(s\"i = $i, j = $j, k = $k\")\n```\n\n----------------------------------------\n\nTITLE: Defining multiline functions in Python and Scala\nDESCRIPTION: Shows how to define functions with multiple statements printed sequentially. No dependencies. No inputs or return values; side-effects are printing messages to stdout. Useful to show block-structured code examples.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_16\n\nLANGUAGE: Python\nCODE:\n```\ndef walkThenRun():\n  print('walk')\n  print('run')\n```\n\n----------------------------------------\n\nTITLE: Defining a printf Macro Facade in Scala\nDESCRIPTION: Defines the macro facade function `printf` that acts as the macro entry point. It requires importing `scala.language.experimental.macros` to enable macro usage. The function takes a format string and a variable number of parameters, and it delegates the implementation to `printf_impl` macro method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/overview.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.language.experimental.macros\ndef printf(format: String, params: Any*): Unit = macro printf_impl\n```\n\n----------------------------------------\n\nTITLE: Flattening Blocks with Scala Quasiquotes Splice\nDESCRIPTION: Demonstrates using the splice operator `..$` within a `q` interpolator to flatten the statements of one block into another. `..$ab` inserts the statements from the `ab` block into the new block `abc`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_39\n\nLANGUAGE: scala\nCODE:\n```\nscala> val ab = q\"a; b\"\nab: universe.Tree =\n{\n  a;\n  b\n}\n\nscala> val abc = q\"..$ab; c\"\nabc: universe.Tree =\n{\n  a;\n  b;\n  c\n}\n```\n\n----------------------------------------\n\nTITLE: Attempting to Mutate a Field of an Immutable Case Class Instance\nDESCRIPTION: An example showing a compiler error when trying to reassign a value to a case class field. Because fields in case classes are immutable by default, attempts to mutate them result in a reassignment error. This enforces immutability constraints in case class instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_40\n\nLANGUAGE: scala\nCODE:\n```\nchristina.name = \"Fred\"   // error: reassignment to val\n```\n\n----------------------------------------\n\nTITLE: Filtering with Guards in For Loops - JavaScript & Scala\nDESCRIPTION: Demonstrates how to filter elements during iteration. JavaScript uses an inline 'if' statement inside the loop body, while Scala provides 'guard' clauses directly within the 'for' expression.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_29\n\nLANGUAGE: JavaScript\nCODE:\n```\nfor (let i = 0; i < 10; i++) {\n  if (i % 2 == 0 && i < 5) {\n    console.log(i);\n  }\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor\n  i <- 1 to 10\n  if i % 2 == 0\n  if i < 5\ndo\n  println(i)\n```\n\n----------------------------------------\n\nTITLE: Defining the Scala Parallel Collections Splitter Trait\nDESCRIPTION: Illustrates the definition of the `Splitter` trait, a core abstraction in Scala's parallel collections. It extends `Iterator` and includes a `split` method used to partition the collection into multiple disjoint `Splitter` instances for parallel processing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/architecture.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Splitter[T] extends Iterator[T] {\n\tdef split: Seq[Splitter[T]]\n}\n```\n\n----------------------------------------\n\nTITLE: Using Directives Syntax Example in Scala\nDESCRIPTION: Example of Using Directives in Scala, which are special comments starting with '//>'. These directives configure the Scala compiler, platform, and other options at the file level rather than on the command line.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/scala-cli.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n//> using scala 3\n//> using platform scala-js\n//> using options -Xasync\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Class with Parameters in Scala 2\nDESCRIPTION: This snippet illustrates how to declare a class with parameters in Scala 2, using a `Complex` class to model complex numbers with real and imaginary parts. The class includes methods `re` and `im` to access these parts.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\n```scala\nclass Complex(real: Double, imaginary: Double) {\n  def re() = real\n  def im() = imaginary\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Assigning Results of 'if/else' Expressions in Scala\nDESCRIPTION: Shows how `if/else` constructs in Scala are expressions that return a value, allowing direct assignment to a variable (like `minValue`). This eliminates the need for a separate ternary operator. Compares Scala 2 and Scala 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_5\n\nLANGUAGE: Scala 2\nCODE:\n```\nval minValue = if (a < b) a else b\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nval minValue = if a < b then a else b\n```\n\n----------------------------------------\n\nTITLE: Deconstructing Tree with $ Pattern (Scala)\nDESCRIPTION: Shows how to use the `$` syntax within a `q` pattern match to extract a sub-tree from the matched `universe.Tree` into a variable (`what`). This is the inverse operation of unquoting during construction.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/intro.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"i am $what\" = q\"i am { a quasiquote }\"\nwhat: universe.Tree = a.quasiquote\n```\n\n----------------------------------------\n\nTITLE: Functional Error Handling with Option in Scala\nDESCRIPTION: A revised version of the makeInt method that uses Option to handle errors functionally. It returns Some(value) when successful and None when the conversion fails, providing a clear indication of the outcome without using exceptions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fp-functional-error-handling.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef makeInt(s: String): Option[Int] =\n  try\n    Some(Integer.parseInt(s.trim))\n  catch\n    case e: Exception => None\n```\n\n----------------------------------------\n\nTITLE: Using Java annotations in Scala with named parameters\nDESCRIPTION: Explains how Scala interacts with Java annotations that have multiple members, showing syntax for applying Java annotations with named arguments, especially when annotations include elements without default values. Highlights how Scala's syntax is flexible compared to Java.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/annotations.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n@Source(URL = \"https://coders.com/\",\n        mail = \"support@coders.com\")\nclass MyScalaClass ...\n```\n\nLANGUAGE: Scala\nCODE:\n```\n@SourceURL(\"https://coders.com/\")\nclass MyScalaClass ...\n```\n\nLANGUAGE: Scala\nCODE:\n```\n@SourceURL(\"https://coders.com/\",\n           mail = \"support@coders.com\")\n    class MyScalaClass ...\n```\n\n----------------------------------------\n\nTITLE: Defining the Main Method as JVM Program Entry Point in Scala - Scala\nDESCRIPTION: Illustrates defining a main method inside an object as the program entry point recognized by JVM. The main method accepts an array of strings as arguments and executes code inside its body, typically printing to the console.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/tour/basics.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nobject Main {\n  def main(args: Array[String]): Unit =\n    println(\"Hello, Scala developer!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting Collection at Index in Buffer in Scala\nDESCRIPTION: Inserts all elements from a collection 'xs' at a specific index 'i' within the buffer 'buf'. The elements of 'xs' are inserted consecutively at the specified position.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/seqs.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nbuf insertAll (i, xs)\n```\n\n----------------------------------------\n\nTITLE: Creating Immutable ParRange in Scala\nDESCRIPTION: Shows how to create an immutable `ParRange` by calling the `.par` method on standard Scala `Range` objects. Examples include a simple ascending range and a descending range with a step.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/concrete-parallel-collections.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> (1 to 3).par\nres0: scala.collection.parallel.immutable.ParRange = ParRange(1, 2, 3)\n\nscala> (15 to 5 by -2).par\nres1: scala.collection.parallel.immutable.ParRange = ParRange(15, 13, 11, 9, 7, 5)\n```\n\n----------------------------------------\n\nTITLE: Attempting to Instantiate PetContainer with a Non-Subtype in Scala\nDESCRIPTION: Shows an invalid example (commented out) where attempting to create a PetContainer with Lion, which does not extend Pet, results in a compile-time error due to type constraint violation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/upper-type-bounds.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n// this would not compile\nval lionContainer = new PetContainer[Lion](new Lion)\n```\n\n----------------------------------------\n\nTITLE: Using Anonymous Functions (Lambda Expressions) in Scala\nDESCRIPTION: Shows how to use anonymous functions with a timer example. Demonstrates the syntax of lambda expressions in Scala using the => arrow notation to separate arguments from function body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nobject TimerAnonymous {\n  def oncePerSecond(callback: () => Unit): Unit = {\n    while (true) { callback(); Thread.sleep(1000) }\n  }\n  def main(args: Array[String]): Unit = {\n    oncePerSecond(() =>\n      println(\"time flies like an arrow...\"))\n  }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef oncePerSecond(callback: () => Unit): Unit =\n  while true do { callback(); Thread.sleep(1000) }\n\n@main def TimerAnonymous: Unit =\n  oncePerSecond(() =>\n    println(\"time flies like an arrow...\"))\n```\n\n----------------------------------------\n\nTITLE: Defining simple one-line functions in Python and Scala\nDESCRIPTION: Illustrates compact function definition syntax to add two parameters. No external dependencies required. Parameters a and b are integers, and the output is their sum returned directly. Useful for simple operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\ndef add(a, b): return a + b\n```\n\n----------------------------------------\n\nTITLE: Objects with Constants in Scala\nDESCRIPTION: Creating an object to hold mathematical constants that can be accessed statically.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nobject MathConstants {\n  val PI = 3.14159\n  val E = 2.71828\n}\n\nprintln(MathConstants.PI)   // 3.14159\n```\n\nLANGUAGE: scala\nCODE:\n```\nobject MathConstants:\n  val PI = 3.14159\n  val E = 2.71828\n\nprintln(MathConstants.PI)   // 3.14159\n```\n\n----------------------------------------\n\nTITLE: Handling edge cases with drop and dropRight in Scala\nDESCRIPTION: Examples of how drop and dropRight methods handle edge cases, such as dropping more elements than exist in the list or dropping zero elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-methods.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\noneToTen.drop(Int.MaxValue)        // List()\noneToTen.dropRight(Int.MaxValue)   // List()\noneToTen.drop(0)                   // List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\noneToTen.dropRight(0)              // List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Multiple Types in Scala - Scala\nDESCRIPTION: Illustrates a Scala application that performs pattern matching on an input of type Any, matching integer literals, string literals, and typed integer patterns. It shows example usage of typed pattern matching with variable binding in the case statement. The 'matchTest' function accepts any input and returns either a String or an Int, depending on the matched pattern. This example highlights Scala's flexible pattern matching capabilities beyond fixed types and literals.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/pattern-matching.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject MatchTest2 extends App {\n  def matchTest(x: Any): Any = x match {\n    case 1 => \"um\"\n    case \"dois\" => 2\n    case y: Int => \"scala.Int\"\n  }\n  println(matchTest(\"dois\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Specific MUnit Version using Mill\nDESCRIPTION: Adds a specific version of MUnit directly as an Ivy dependency in a Mill build file (`build.sc`) using the `ivy` string interpolator. This would typically be placed within the `ivyDeps` definition of a test module.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-munit.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nivy\"org.scalameta::munit:1.1.0\"\n```\n\n----------------------------------------\n\nTITLE: Invalid Reassignment of Variable Inferred as Null in Scala 2 and 3 (Compilation Failure)\nDESCRIPTION: Shows that attempting to assign a non-null object to a variable initially inferred as Null fails to compile due to incompatible types. Dependencies: none. Input is an assignment of an AnyRef instance; expected output is a compile error due to type mismatch.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/type-inference.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nobj = new AnyRef\n```\n\n----------------------------------------\n\nTITLE: Directory Structure with Layouts\nDESCRIPTION: Shows the directory structure including a _layouts folder for template files in addition to the _docs content.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/static-site.md#_snippet_10\n\nLANGUAGE: plaintext\nCODE:\n```\n├── _layouts\n│   └── main.html\n└── _docs\n    ├── getting-started.md\n    └── index.html\n```\n\n----------------------------------------\n\nTITLE: Return Type Inheritance Example\nDESCRIPTION: Illustrates how method return type inheritance differs between Scala 2 and Scala 3, which can lead to binary compatibility issues during cross-building.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tooling-scala2-xsource3.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ntrait A { def f: Object }\nclass B extends A { def f = \"hi\" }\n```\n\n----------------------------------------\n\nTITLE: Removing Parentheses for Single Parameter\nDESCRIPTION: Shows how parentheses can be omitted when an anonymous function has only one parameter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-anonymous-functions.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval doubledInts = ints.map(i => i * 2)\n```\n\n----------------------------------------\n\nTITLE: Proposal 2: Simplified Desugaring without Guard - Example\nDESCRIPTION: Illustrates the scenario where a pure alias (`b = a`) is *not* immediately followed by an `if` guard. Under the proposal, this case would use a simpler desugaring.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nfor\n  a <- doSth(arg)\n  b = a\nyield a + b\n```\n\n----------------------------------------\n\nTITLE: Scala: Defining a Cube Calculation Object\nDESCRIPTION: This snippet defines a simple Scala object 'CubeCalculator' with a method 'cube' that computes the cube of an integer input. It demonstrates creating a singleton object and a static method in Scala, which can be tested later.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/getting-started/intellij-track/testing-scala-in-intellij-with-scalatest.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject CubeCalculator:\n  def cube(x: Int) =\n    x * x * x\n```\n\n----------------------------------------\n\nTITLE: Handling successful Futures with failed projection in Scala 2\nDESCRIPTION: Example showing that if a Future succeeds, accessing its failed projection results in a failure with NoSuchElementException because no Throwable is available. The for-comprehension does not output anything since the failed Future does not complete successfully.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_26\n\nLANGUAGE: Scala\nCODE:\n```\nval f = Future {\n  4 / 2\n}\nfor (exc <- f.failed) println(exc)\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Custom `p` Interpolator in Scala\nDESCRIPTION: Shows the definition of a `Point` case class and the desired usage of a hypothetical custom `p` interpolator. The goal is to parse a string like `p\"1,-2\"` directly into a `Point(1.0, -2.0)` object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ncase class Point(x: Double, y: Double)\n\nval pt = p\"1,-2\"     // Point(1.0,-2.0)\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Class with Parameters in Scala 3\nDESCRIPTION: This snippet demonstrates the Scala 3 syntax for declaring a class with parameters, using the same `Complex` class. The constructor syntax uses colons, and method definitions omit parentheses, following Scala 3 conventions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\n```scala\nclass Complex(real: Double, imaginary: Double):\n  def re() = real\n  def im() = imaginary\n```\n```\n\n----------------------------------------\n\nTITLE: Basic Class Composition with Traits in Scala 2\nDESCRIPTION: Demonstrates how to combine a superclass B and a trait C in a new class D. The trait extends an abstract class and adds additional functionality that the derived class can use.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/mixin-class-composition.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nabstract class A {\n  val message: String\n}\nclass B extends A {\n  val message = \"I'm an instance of class B\"\n}\ntrait C extends A {\n  def loudMessage = message.toUpperCase()\n}\nclass D extends B with C\n\nval d = new D\nprintln(d.message)  // I'm an instance of class B\nprintln(d.loudMessage)  // I'M AN INSTANCE OF CLASS B\n```\n\n----------------------------------------\n\nTITLE: Defining a Person Trait in Scala\nDESCRIPTION: Defines a simple trait `Person` with a single abstract method `name`. This trait serves as a common supertype for the subsequent case classes and demonstrates a base type used in pattern matching examples. It shows the syntax for both Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_42\n\nLANGUAGE: Scala 2\nCODE:\n```\ntrait Person {\n  def name: String\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ntrait Person:\n  def name: String\n```\n\n----------------------------------------\n\nTITLE: Defining a Singleton Object (IdFactory) in Scala\nDESCRIPTION: Demonstrates the definition of a singleton object named `IdFactory` using the `object` keyword in both Scala 2 and Scala 3. This object acts as a factory for generating unique integer IDs, maintaining an internal private counter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\nobject IdFactory {\n  private var counter = 0\n  def create(): Int = {\n    counter += 1\n    counter\n  }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nobject IdFactory:\n  private var counter = 0\n  def create(): Int =\n    counter += 1\n    counter\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterized Enum (Java)\nDESCRIPTION: This Java snippet shows how to define an enum where each constant member has associated data. This requires a constructor to initialize the private fields for each enum constant.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_67\n\nLANGUAGE: Java\nCODE:\n```\nenum Color {\n  Red(0xFF0000),\n  Green(0x00FF00),\n  Blue(0x0000FF);\n\n  private int rgb;\n\n  Color(int rgb) {\n    this.rgb = rgb;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Understanding Arithmetic Operations as Method Calls in Scala\nDESCRIPTION: Illustrates that basic arithmetic operations in Scala are actually method calls on number objects, showing how `1 + 2 * 3 / x` is equivalent to `1.+(2.*(3)./(x))`. Emphasizes that operators like `+`, `*` are valid method names.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tutorials/scala-for-java-programmers.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n// Standard arithmetic expression\n1 + 2 * 3 / x\n\n// Equivalent method calls\n1.+(2.*(3)./(x))\n```\n\n----------------------------------------\n\nTITLE: Removing Elements from a Mutable ArrayBuffer in Scala\nDESCRIPTION: Demonstrates removing a single element (`-=`) or multiple elements specified in another sequence or set (`--=`) from a mutable `ArrayBuffer`. The buffer is modified in place.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_27\n\nLANGUAGE: Scala\nCODE:\n```\nval a = ArrayBuffer.range('a', 'h')   // ArrayBuffer(a, b, c, d, e, f, g)\na -= 'a'                              // ArrayBuffer(b, c, d, e, f, g)\na --= Seq('b', 'c')                   // ArrayBuffer(d, e, f, g)\na --= Set('d', 'e')                   // ArrayBuffer(f, g)\n```\n\n----------------------------------------\n\nTITLE: Defining a Case Class as a Value Class in Scala\nDESCRIPTION: Defines `P` as both a case class and a value class by extending `AnyVal`. This provides the benefits of case classes (e.g., default `equals`, `hashCode`, `copy`, pattern matching support) while potentially benefiting from value class optimizations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ncase class P(i: Int) extends AnyVal\n```\n\n----------------------------------------\n\nTITLE: Invalid Trait Definition with Constructor Parameters in Scala\nDESCRIPTION: This Scala code snippet illustrates that traits cannot have constructor parameters. Attempting to define a trait 'Animal' with a 'name' parameter as shown will result in a compilation error, highlighting a limitation compared to abstract classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/abstract-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// this won’t compile\ntrait Animal(name: String)\n```\n\n----------------------------------------\n\nTITLE: Handling multiple patterns in one case in Scala 3\nDESCRIPTION: Demonstrates Scala 3's syntax for handling multiple patterns in a single case statement using the alternation operator (|), allowing more concise match expressions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nval evenOrOdd = i match\n  case 1 | 3 | 5 | 7 | 9 => println(\"odd\")\n  case 2 | 4 | 6 | 8 | 10 => println(\"even\")\n  case _ => println(\"some other number\")\n```\n\n----------------------------------------\n\nTITLE: Defining a Method in Scala - Scala\nDESCRIPTION: Defines a Scala method named 'square' that takes an integer parameter 'x' and returns its square as an integer result. This is a method definition using the 'def' keyword typical to Scala. The method can be called with an integer argument and returns the computed value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/FAQ/index.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef square(x: Int): Int = x * x\n```\n\n----------------------------------------\n\nTITLE: Running Scaladoc Tests Only with Partest from sbt Console - Shell\nDESCRIPTION: Runs only Scaladoc-related tests by specifying the source path to those tests. Use the --srcpath option followed by the desired test directory. Requires sbt and presence of Scaladoc test files.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/partest-guide.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nsbt:root> partest --srcpath scaladoc\n```\n\n----------------------------------------\n\nTITLE: Using while Loop for Counting in Python\nDESCRIPTION: Illustrates usage of a while loop to iterate while variable 'i' is less than 3, printing the value of 'i' and incrementing it each iteration. Demonstrates basic loop-and-count control flow in Python.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\ni = 1\nwhile i < 3:\n  print(i)\n  i += 1\n```\n\n----------------------------------------\n\nTITLE: Using if Expressions as Method Bodies\nDESCRIPTION: Shows how to use if/else expressions as method bodies, taking advantage of the fact that all expressions in Scala return values, creating a method that determines truthiness.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/methods-most.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\n// Scala 2\ndef isTruthy(a: Any) = {\n  if (a == 0 || a == \"\" || a == false)\n    false\n  else\n    true\n}\n\n// Scala 3\ndef isTruthy(a: Any) =\n  if a == 0 || a == \"\" || a == false then\n    false\n  else\n    true\n```\n\n----------------------------------------\n\nTITLE: Collection Initialization in Python and Scala\nDESCRIPTION: Illustrates creating lists, dictionaries (maps), sets, and tuples in both languages. Emphasizes the use of `List()` and `Map()` in Scala versus list and dict literals in Python.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nx = [1, 2, 3]\n\nx = {\n  \"Toy Story\": 8.3,\n  \"Forrest Gump\": 8.8,\n  \"Cloud Atlas\": 7.4\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval x = List(1, 2, 3)\n\nval x = Map(\n  \"Toy Story\" -> 8.3,\n  \"Forrest Gump\" -> 8.8,\n  \"Cloud Atlas\" -> 7.4\n)\n\nval setX = Set(1, 2, 3)\n\nval tupleX = (11, \"Eleven\")\n```\n\n----------------------------------------\n\nTITLE: Using Pattern Matching with Sample Notifications in Scala\nDESCRIPTION: Creates instances of SMS and VoiceRecording and applies 'mostrarNotificacao' to each, printing context-specific messages. Demonstrates pattern matching with data extraction from case classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/case-classes.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval algumSMS = SMS(\"12345\", \"Você está aí?\")\nval algumaMsgVoz = VoiceRecording(\"Tom\", \"voicerecording.org/id/123\")\n\nprintln(mostrarNotificacao(algumSMS)) // Saída\nprintln(mostrarNotificacao(algumaMsgVoz)) // Saída\n```\n\n----------------------------------------\n\nTITLE: Assigning Results from match Expression in Scala 3\nDESCRIPTION: Demonstrates capturing results from the match expression into variable 'result' with Scala 3's indentation-based syntax, eliminating braces. Input is integer 'i', matching returns a string assigned to 'result'. Requires Scala 3 compiler.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\nval result = i match\n  case 1 => \"one\"\n  case 2 => \"two\"\n  case _ => \"other\"\n```\n\n----------------------------------------\n\nTITLE: Incorrectly Skipping Empty Strings from an Iterator in Scala\nDESCRIPTION: Demonstrates an incorrect attempt to skip leading empty strings from a String Iterator. This function advances the iterator using `it.next()` within the `while` condition, causing it to consume and discard the first non-empty string.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/iterators.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 2 Version\ndef skipEmptyWordsNOT(it: Iterator[String]) =\n  while (it.next().isEmpty) {}\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 3 Version\ndef skipEmptyWordsNOT(it: Iterator[String]) =\n  while it.next().isEmpty do ()\n```\n\n----------------------------------------\n\nTITLE: Proposed Syntax for Aggregate Context Bounds\nDESCRIPTION: Example of the proposed syntax for combining multiple context bounds inside curly braces, improving readability when multiple type class constraints are needed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n  trait A:\n    def showMax[X : {Ordering, Show}](x: X, y: X): String\n  class B extends A:\n    def showMax[X : {Ordering as ordering, Show as show}](x: X, y: X): String =\n      show.asString(ordering.max(x, y))\n```\n\n----------------------------------------\n\nTITLE: Passing a Method to Scala `map` via Eta Expansion\nDESCRIPTION: Demonstrates defining a simple method (`times10`) and passing it directly to the `List.map` method, which expects a function. This works seamlessly due to Scala's Eta Expansion automatically converting the method into a function.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-eta-expansion.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef times10(i: Int) = i * 10   // a method\nList(1, 2, 3).map(times10)     // List(10,20,30)\n```\n\n----------------------------------------\n\nTITLE: Importing packages in Scala 2\nDESCRIPTION: Shows various forms of import statements in Scala 2, including group import, specific class import, multiple specific imports, and import aliasing. This enables selective and organized access to external code components, including renaming when necessary.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/packages-and-imports.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport users._  // group import\nimport users.User  // import specific class\nimport users.{User, UserPreferences}  // multiple specific imports\nimport users.{UserPreferences => UPrefs}  // import with alias\n```\n\n----------------------------------------\n\nTITLE: Calling Methods on Scala Collections (2 & 3)\nDESCRIPTION: Shows examples of calling built-in methods on a Scala `List` instance. It demonstrates calling `size` (no arguments), `contains` (one value argument), and `map` (takes a function argument, here an anonymous function `_ * 10`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval x = List(1, 2, 3)\n\nx.size          // 3\nx.contains(1)   // true\nx.map(_ * 10)   // List(10, 20, 30)\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Conditions (if/else if/else) - JavaScript & Scala\nDESCRIPTION: Shows how to handle multiple conditional branches using the if, else if, and else constructs in both JavaScript and Scala. Highlights the syntax differences, including the lack of mandatory curly braces in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_20\n\nLANGUAGE: JavaScript\nCODE:\n```\nif (x < 0) {\n  console.log(\"negative\")\n} else if (x == 0) {\n  console.log(\"zero\")\n} else {\n  console.log(\"positive\")\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nif x < 0 then\n  println(\"negative\")\nelse if x == 0\n  println(\"zero\")\nelse\n  println(\"positive\")\n```\n\n----------------------------------------\n\nTITLE: Instantiating Class with Mixed-in Traits - Scala\nDESCRIPTION: Shows how to create an instance of a class that has mixed in traits. The instance will have access to both the members defined in the class itself and the concrete members inherited from the traits, plus the implemented abstract members.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_30\n\nLANGUAGE: Scala 2\nCODE:\n```\nval d = new IrishSetter(\"Big Red\")   // \"Big Red is a Dog\"\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nval d = IrishSetter(\"Big Red\")   // \"Big Red is a Dog\"\n```\n\n----------------------------------------\n\nTITLE: Defining IterableFactory with from Method - Scala 3\nDESCRIPTION: Scala 3 version of the IterableFactory trait providing the from method for constructing new collections from an IterableOnce source. This abstraction facilitates generic creation of collection instances by various concrete collection types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\ntrait IterableFactory[+CC[_]]:\n  def from[A](source: IterableOnce[A]): CC[A]\n```\n\n----------------------------------------\n\nTITLE: Implementing a Concrete String Iterator Class in Scala\nDESCRIPTION: This snippet defines a class `StringIterator` extending `AbsIterator`, specialized to iterate over characters in a string. It implements `hasNext` and `next` methods to traverse the string.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/mixin-class-composition.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nclass StringIterator(s: String) extends AbsIterator {\n  type T = Char\n  private var i = 0\n  def hasNext = i < s.length()\n  def next() = { val ch = s charAt i; i += 1; ch }\n}\n```\n\n----------------------------------------\n\nTITLE: Multi-Line while Loop in Scala 3\nDESCRIPTION: Shows Scala 3 multi-line while loop without braces, using indentation and 'do' keyword to structure loop condition and body clearly. Initializes variable 'x', prints, and increments while condition holds. Input/output same as Scala 2 version, syntax updated.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_28\n\nLANGUAGE: Scala\nCODE:\n```\nvar x = 1\n\nwhile\n  x < 3\n do\n  println(x)\n  x += 1\n```\n\n----------------------------------------\n\nTITLE: Sample Coursier launch command\nDESCRIPTION: Command to launch a specific version of a Scala tool (`scalafmt`) via Coursier, illustrating how Coursier manages dependencies and runs Scala-based applications or CLI tools.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/tools-sbt.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n$ cs launch org.scalameta::scalafmt-cli:2.4.2 -- --help\nscalafmt 2.4.2\nUsage: scalafmt [options] [<file>...]\n```\n\n----------------------------------------\n\nTITLE: Traversing Tree Nodes with Pattern Matching (Direct Assignment)\nDESCRIPTION: Shows a more concise way to use pattern matching for tree traversal: direct assignment in a `val` definition. It matches the `Apply` pattern directly against the tree and binds the function (`fun`) and argument (`arg`) components if the pattern matches.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/reflection/symbols-trees-types.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n\nval tree = Apply(Select(Ident(TermName(\"x\")), TermName(\"$plus\")), List(Literal(Constant(2))))\n\nval Apply(fun, arg :: Nil) = tree\n```\n\n----------------------------------------\n\nTITLE: Calling Arity-0 Methods with Parentheses in Scala (2 & 3)\nDESCRIPTION: Demonstrates that calling an arity-0 method defined with parentheses (`speak()`) requires the caller to also use parentheses (`speak()`). Attempting to call it without parentheses (`speak`) results in a compilation error, enforcing the side-effect convention.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nspeak     // error: \"method speak must be called with () argument\"\nspeak()   // prints \"hi\"\n```\n\n----------------------------------------\n\nTITLE: Custom Directory Mapping Configuration in YAML\nDESCRIPTION: Shows how to use YAML configuration to map source directory structure to a custom output directory structure, allowing flexible organization.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/static-site.md#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\n- title: Some other subsection\n  index: abc/index.html\n  directory: custom-directory\n  subsection:\n    - page: abc2/page1.md\n    - page: foo/page2.md\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Enum - Scala\nDESCRIPTION: This snippet defines a basic enumeration in Scala 3 named Color. It declares three cases: Red, Green, and Blue, using the enum construct. Requires Scala 3 or higher. The result is an enum with three cases, matching the Java example.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_57\n\nLANGUAGE: Scala\nCODE:\n```\nenum Color:\n  case Red, Green, Blue\n```\n\n----------------------------------------\n\nTITLE: Defining Tuples Inline - Scala\nDESCRIPTION: This snippet shows how to create tuples of varying arities (sizes) in Scala using parentheses. No extra imports or libraries are required. Variables a, b, c, and d are tuples with 1 to 4 elements; the last tuple includes an instance of a Person class. Inputs are the tuple elements, and output variables are tuple instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_55\n\nLANGUAGE: Scala\nCODE:\n```\nval a = (\"eleven\")\nval b = (\"eleven\", 11)\nval c = (\"eleven\", 11, 11.0)\nval d = (\"eleven\", 11, 11.0, Person(\"Eleven\"))\n```\n\n----------------------------------------\n\nTITLE: Illustrating Future.apply Mechanism in Scala\nDESCRIPTION: Explains how the syntactic sugar `Future { ... }` is internally translated by the Scala compiler into a call to the `apply` method of the `Future` companion object, explicitly showing the underlying mechanism for creating a Future.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/futures.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ndef getStockPrice ... = Future.apply { method body here }\n                               -----\n```\n\n----------------------------------------\n\nTITLE: Defining a Named Snippet for Inclusion\nDESCRIPTION: This markdown shows how to define a named Scala code snippet using the `sc-name` argument. The name (`<snippet-name>`) must be unique within the file. This allows the code within this block to be reused in other snippets later in the document.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/snippet-compiler.md#_snippet_11\n\nLANGUAGE: markdown\nCODE:\n```\n```scala sc-name:<snippet-name> ```\n```\n\n----------------------------------------\n\nTITLE: Using while Loop for Counting in Scala\nDESCRIPTION: Shows a Scala while loop that increments a variable 'i' from 1 up to but excluding 3, printing its value each iteration. Demonstrates idiomatic Scala looping with mutable variables.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nvar i = 1\nwhile i < 3 do\n  println(i)\n  i += 1\n```\n\n----------------------------------------\n\nTITLE: Basic Class Composition with Traits in Scala 3\nDESCRIPTION: Shows the Scala 3 syntax for combining a superclass B and a trait C in a new class D. Note the use of comma syntax instead of 'with' and the indentation-based code structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/mixin-class-composition.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nabstract class A:\n  val message: String\nclass B extends A:\n  val message = \"I'm an instance of class B\"\ntrait C extends A:\n  def loudMessage = message.toUpperCase()\nclass D extends B, C\n\nval d = D()\nprintln(d.message)  // I'm an instance of class B\nprintln(d.loudMessage)  // I'M AN INSTANCE OF CLASS B\n```\n\n----------------------------------------\n\nTITLE: Defining YAML Front Matter for Russian Scala Documentation\nDESCRIPTION: YAML front matter that specifies the layout, section categorization, page title, and language for a Russian Scala documentation page. This configuration is used by the static site generator to properly render the page within the documentation structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/index.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nlayout: overviews\npartof: overviews\ntitle: Документация\nlanguage: ru\n---\n```\n\n----------------------------------------\n\nTITLE: Applying Functional Methods to Array (Scala)\nDESCRIPTION: This Scala snippet demonstrates applying functional methods like `map` and `filter` to a Scala `Array`. Despite mapping to a Java array, the Scala `Array` provides rich functional programming capabilities.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_62\n\nLANGUAGE: Scala\nCODE:\n```\nval nums = Array(1, 2, 3, 4, 5)\nval doubledNums = nums.map(_ * 2)\nval 过滤Nums = nums.filter(_ > 2)\n```\n\n----------------------------------------\n\nTITLE: Lambda Syntax Variations in Scala\nDESCRIPTION: Different forms of lambda syntax in Scala, from the most verbose to the most concise form, using filter as an example.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/collections-methods.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// все эти функции одинаковые и возвращают\n// одно и тоже: List(10, 20, 10)\n\na.filter((i: Int) => i < 25)   // 1. наиболее расширенная форма\na.filter((i) => i < 25)        // 2. `Int` необязателен\na.filter(i => i < 25)          // 3. скобки можно опустить\na.filter(_ < 25)               // 4. `i` необязателен\n```\n\n----------------------------------------\n\nTITLE: Defining an Anonymous Function Literal in Scala\nDESCRIPTION: Shows the syntax for an anonymous function (function literal) that takes an Int parameter and returns its double. This snippet illustrates the core concept of a function literal before assignment to a variable. It requires no external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-function-variables.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n(i: Int) => i * 2\n```\n\n----------------------------------------\n\nTITLE: Configuring Scaladoc Versions Dictionary URL in sbt\nDESCRIPTION: This sbt configuration line demonstrates how to set the `-versions-dictionary-url` scalac option for documentation generation. It specifies the URL where Scaladoc should find the JSON file containing the dictionary of available documentation versions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/site-versioning.md#_snippet_1\n\nLANGUAGE: sbt\nCODE:\n```\ndoc / scalacOptions ++= Seq(\"-versions-dictionary-url\", \"https://dotty.epfl.ch/versions.json\")\n```\n\n----------------------------------------\n\nTITLE: Handling failed Futures with failed projection in Scala 3\nDESCRIPTION: Demonstrates the Scala 3 concise 'for...do' syntax to process the failed projection of a Future that fails by division by zero. The exception is asynchronously propagated and printed, enabling explicit failure handling paths in asynchronous computations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_25\n\nLANGUAGE: Scala\nCODE:\n```\nval f = Future {\n  2 / 0\n}\nfor exc <- f.failed do println(exc)\n```\n\n----------------------------------------\n\nTITLE: Left-Aligned Multiline String Result in Scala\nDESCRIPTION: This is the resulting string after applying stripMargin to a triple-quoted string: lines are left-aligned with no leading spaces. It is useful for content-sensitive text or cleanly formatted output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/first-look-at-types.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\n\"The essence of Scala:\nFusion of functional and object-oriented\nprogramming in a typed setting.\"\n```\n\n----------------------------------------\n\nTITLE: Simple Trait with Abstract Method in Scala 3\nDESCRIPTION: Defines a Scala trait Adder with one abstract method add that takes two Int parameters and returns an Int. This trait specifies a contract similarly to a Java interface but can include implementations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Adder:\n  def add(a: Int, b: Int): Int\n```\n\n----------------------------------------\n\nTITLE: Attempting to Reassign Immutable Field of Case Class Instance in Scala\nDESCRIPTION: Shows that trying to reassign a field of a case class instance results in a compilation error because case class constructor fields are implicitly val (immutable). This enforces data immutability at the compiler level.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-tools.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nchristina.name = \"Fred\"   // error: reassignment to val\n```\n\n----------------------------------------\n\nTITLE: Using map with Scala Future to transform results\nDESCRIPTION: Applies a transformation function to a Future's result using the map method, resulting in a new Future that completes with the transformed value. Shows that mapped futures are also wrapped in Success/Failure inside a Future.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/concurrency.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval a = Future(longRunningAlgorithm()).map(_ * 2)\n```\n\n----------------------------------------\n\nTITLE: Recursive enum for natural numbers in Scala 3\nDESCRIPTION: This demonstrates a recursive enum 'Nat' representing natural numbers with 'Zero' and 'Succ' (successor) cases. 'Succ(Succ(Zero))' encodes the number 2 in unary, illustrating recursive data structures for mathematical data.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-adts-gadts.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nenum Nat:\n  case Zero\n  case Succ(n: Nat)\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Using a Class with State in Scala\nDESCRIPTION: Demonstrates creating an instance of the `Counter` class and interacting with its methods (`tick`, `count`) to modify and observe its internal state. Shows the difference in instantiation syntax between Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-oop.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval c1 = new Counter()\nc1.count // 0\nc1.tick()\nc1.tick()\nc1.count // 2\n```\n\nLANGUAGE: scala\nCODE:\n```\nval c1 = Counter()\nc1.count // 0\nc1.tick()\nc1.tick()\nc1.count // 2\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Extension Methods in Scala 3\nDESCRIPTION: Illustrates defining multiple extension methods (`circumference`, `diameter`, `area`) for the `Circle` type within a single `extension` block in Scala 3. All methods defined within the block become available on instances of the specified type (`Circle`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-extension-methods.md#_snippet_6\n\nLANGUAGE: Scala 3\nCODE:\n```\nextension (c: Circle)\n  def circumference: Double = c.radius * math.Pi * 2\n  def diameter: Double = c.radius * 2\n  def area: Double = math.Pi * c.radius * c.radius\n```\n\n----------------------------------------\n\nTITLE: Extension Method Override Example in Scala (Compatibility Concern)\nDESCRIPTION: Shows a scenario where user-defined extension methods could conflict with the proposed runtimeCheck method, highlighting a potential source compatibility issue.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/replace-nonsensical-unchecked-annotation.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n// source A.scala\npackage example\n\nextension (predef: scala.Predef.type)\n  transparent inline def runtimeCheck[T](x: T): x.type =\n    println(\"fake runtimeCheck\")\n    x\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Lists in Scala\nDESCRIPTION: Examples demonstrating how to create Lists, add elements to them, and iterate over their contents. Lists in Scala are immutable, linear sequences implemented as linked lists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval ints = List(1, 2, 3)\nval names = List(\"Joel\", \"Chris\", \"Ed\")\n\n// another way to construct a List\nval namesAgain = \"Joel\" :: \"Chris\" :: \"Ed\" :: Nil\n```\n\nLANGUAGE: scala\nCODE:\n```\nval ints: List[Int] = List(1, 2, 3)\nval names: List[String] = List(\"Joel\", \"Chris\", \"Ed\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nval things: List[String | Int | Double] = List(1, \"two\", 3.0) // with union types\nval thingsAny: List[Any] = List(1, \"two\", 3.0)                // with any\n```\n\nLANGUAGE: scala\nCODE:\n```\nval a = List(1, 2, 3)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval b = 0 :: a // List(0, 1, 2, 3)\nval c = List(-1, 0) ::: a // List(-1, 0, 1, 2, 3)\n```\n\nLANGUAGE: scala\nCODE:\n```\n0 +： a\n```\n\nLANGUAGE: scala\nCODE:\n```\na ：+ 4\n```\n\nLANGUAGE: scala\nCODE:\n```\nval names = List(\"Joel\", \"Chris\", \"Ed\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor name <- names do println(name)\n```\n\n----------------------------------------\n\nTITLE: Defining Initial `map` Function Signature Fragment (Accepting Function)\nDESCRIPTION: Shows the initial part of a Scala function definition named `map` that accepts a function `f` as an argument. The function `f` is expected to take an `Int` and return a value of some generic type `A`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-write-map-function.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef map(f: (Int) => A)\n```\n\n----------------------------------------\n\nTITLE: Importing Implicit Conversions in Scala 2\nDESCRIPTION: Demonstrates how to bring an implicit conversion defined within an object (`Conversions`) into the current scope in Scala 2. This can be done either by importing the specific conversion method (`import Conversions.fromStringToUser`) or by using a wildcard import (`import Conversions._`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-implicit-conversions.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport Conversions.fromStringToUser\n// or\nimport Conversions._\n```\n\n----------------------------------------\n\nTITLE: Accessing Head Element of Sequence in Scala\nDESCRIPTION: Explains the `head` method, which returns the first element of a sequence. It also shows that `head` can be used on Strings (as sequences of characters) and notes that calling `head` on an empty sequence throws a `NoSuchElementException`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/collections-methods.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nnums.head\n```\n\nLANGUAGE: scala\nCODE:\n```\nnames.head\n```\n\nLANGUAGE: scala\nCODE:\n```\n\"foo\".head\n```\n\nLANGUAGE: scala\nCODE:\n```\n\"bar\".head\n```\n\nLANGUAGE: scala\nCODE:\n```\nval emptyList = List[Int]()\n```\n\nLANGUAGE: scala\nCODE:\n```\nemptyList.head\n```\n\n----------------------------------------\n\nTITLE: Multi-line Methods in Scala 2 and Scala 3\nDESCRIPTION: Shows how to define methods that span multiple lines in both Scala versions, demonstrating proper indentation and the implicit return of the last expression.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/methods-most.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n// Scala 2\ndef addThenDouble(a: Int, b: Int): Int = {\n  // imagine that this body requires multiple lines\n  val sum = a + b\n  sum * 2\n}\n\n// Scala 3\ndef addThenDouble(a: Int, b: Int): Int =\n  // imagine that this body requires multiple lines\n  val sum = a + b\n  sum * 2\n```\n\n----------------------------------------\n\nTITLE: Using 'if/else' Expressions as Method Bodies in Scala\nDESCRIPTION: Demonstrates using an `if/else if/else` expression directly as the body of a method (`compare`) to return a value based on conditions. Compares Scala 2 and Scala 3 syntax for defining the method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/control-structures.md#_snippet_6\n\nLANGUAGE: Scala 2\nCODE:\n```\ndef compare(a: Int, b: Int): Int =\n  if (a < b)\n    -1\n  else if (a == b)\n    0\n  else\n    1\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ndef compare(a: Int, b: Int): Int =\n  if a < b then\n    -1\n  else if a == b then\n    0\n  else\n    1\n```\n\n----------------------------------------\n\nTITLE: Example of Operator Precedence with Custom Operators in Scala\nDESCRIPTION: Presents a complex expression involving multiple standard and potentially custom operators (`+`, `^?`, `?^`, `less`, `==>`, `|`) to illustrate Scala's operator precedence rules, which depend on the operator's first character.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/operators.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\na + b ^? c ?^ d less a ==> b | c\n```\n\n----------------------------------------\n\nTITLE: Defining a Pure Function in Scala (Scala 2 and 3)\nDESCRIPTION: This snippet demonstrates defining a simple pure function that doubles an integer input, showing syntax suitable for both Scala 2 and 3. It emphasizes writing functions that depend solely on their input parameters and produce consistent outputs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fp-pure-functions.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef double(i: Int): Int = i * 2\n```\n\n----------------------------------------\n\nTITLE: Illustrating Mismatch Between Object and Package Object Patterns (1)\nDESCRIPTION: Demonstrates that attempting to match a package object AST (`q\"package object O\"`) using the regular object quasiquote pattern (`q\"$mods object $name\"`) results in a `MatchError`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/definition-details.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"$mods object $name\" = q\"package object O\"\nscala.MatchError: ...\n```\n\n----------------------------------------\n\nTITLE: Getting Precise Type of an Expr Using Pattern Matching\nDESCRIPTION: A pattern matching technique to extract the precise type information from an Expr[X] value. This provides access to the exact type of the expression beyond what's known at the declaration site.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/faq.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval x: Expr[X] = ...\nx match\n  case '{ $x: t } =>\n    // `x: Expr[X & t]` where `t` is the precise type of `x`\n```\n\n----------------------------------------\n\nTITLE: Single-Line while Loop in Scala 3\nDESCRIPTION: Illustrates Scala 3's concise single-line while loop syntax using 'while condition do action' without braces or parentheses, improving readability while maintaining backward compatibility with Scala 2. Input is 'x' variable; action applies function 'f'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_26\n\nLANGUAGE: Scala\nCODE:\n```\nwhile x >= 0 do x = f(x)\n```\n\n----------------------------------------\n\nTITLE: Accessing Tuple Elements by Position in Scala\nDESCRIPTION: Demonstrates accessing tuple elements via positional selectors '_1' and '_2'. It prints the first and second elements of the 'ingredient' tuple. This approach is common for tuples with known element positions and types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/tuples.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nprintln(ingredient._1) // Sugar\nprintln(ingredient._2) // 25\n```\n\n----------------------------------------\n\nTITLE: Recursive Method with Inferred Return Type in Scala 3\nDESCRIPTION: Illustrates that Scala 3 compilers can infer the return type of recursive methods using improved type inference syntax with 'then'. Dependencies: none. Input is an integer parameter; output is the factorial as an Int.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/type-inference.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef fac(n: Int) = if n == 0 then 1 else n * fac(n - 1)\n```\n\n----------------------------------------\n\nTITLE: Apply Code Highlighting with Prettify - JavaScript\nDESCRIPTION: Defines a JavaScript function `styleCode` that iterates through all `pre code` elements, adds the necessary CSS classes (`prettyprint lang-scala linenums`) for the prettify library if they are not already present, and then calls the `prettyPrint()` function to apply syntax highlighting. It includes a check to potentially disable the styling via a global variable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/contributing-header.txt#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction styleCode()\n        {\n          if (typeof disableStyleCode != \"undefined\")\n          {\n              return;\n          }\n          var a = false;\n          $(\"pre code\").parent().each(function()\n          {\n              if (!$(this).hasClass(\"prettyprint\"))\n              {\n                  $(this).addClass(\"prettyprint lang-scala linenums\");\n                  a = true\n              }\n          });\n          if (a) { prettyPrint() }\n      }\n```\n\n----------------------------------------\n\nTITLE: Conditional Expressions Returning Values in Python\nDESCRIPTION: Demonstrates an inline conditional expression that assigns the minimum of two variables 'a' and 'b' to 'min_val'. Uses Python's syntax 'a if a < b else b' to concisely return one of two values based on a condition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nmin_val = a if a < b else b\n```\n\n----------------------------------------\n\nTITLE: Implementing PizzaServiceInterface in Scala 2\nDESCRIPTION: Example of creating a concrete implementation of the PizzaServiceInterface in Scala 2, defining the actual behavior for Pizza operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-fp.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nobject PizzaService extends PizzaServiceInterface {\n\n  def price(p: Pizza): Double =\n    ... // реализация была дана выше\n\n  def addTopping(p: Pizza, t: Topping): Pizza =\n    p.copy(toppings = p.toppings :+ t)\n\n  def removeAllToppings(p: Pizza): Pizza =\n    p.copy(toppings = Seq.empty)\n\n  def updateCrustSize(p: Pizza, cs: CrustSize): Pizza =\n    p.copy(crustSize = cs)\n\n  def updateCrustType(p: Pizza, ct: CrustType): Pizza =\n    p.copy(crustType = ct)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Overloaded Methods in a Scala Class - Scala\nDESCRIPTION: This snippet demonstrates how to define a Scala class ('bar') that contains two overloaded methods named 'foo' with different argument lists and return types. It also shows the usage of 'scala.collection.mutable.ListBuffer' as an import and in a method signature. This is used to illustrate how ambiguous links can arise in Scaladoc documentation when referencing overloaded methods. Requires the Scala standard library and does not produce output unless method bodies are implemented.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scaladoc/for-library-authors.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.mutable.ListBuffer\nclass bar {\n    def foo(x: Int): Boolean = ???\n    def foo(x: ListBuffer[Int], y: String): Int = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Headers to HTTP Requests with sttp\nDESCRIPTION: Shows how to add custom headers to an HTTP request using the header method. The example displays how headers are added to the default headers that sttp includes automatically.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/http-client-request.md#_snippet_1\n\nLANGUAGE: scala 2\nCODE:\n```\nimport sttp.client4.quick._\n\nval request = quickRequest\n  .get(uri\"https://example.com\")\n  .header(\"Origin\", \"https://scala-lang.org\")\n\nprintln(request.headers)\n// prints: Vector(Accept-Encoding: gzip, deflate, Origin: https://scala-lang.org)\n```\n\nLANGUAGE: scala 3\nCODE:\n```\nimport sttp.client4.quick.*\n\nval request = quickRequest\n  .get(uri\"https://example.com\")\n  .header(\"Origin\", \"https://scala-lang.org\")\n\nprintln(request.headers)\n// prints: Vector(Accept-Encoding: gzip, deflate, Origin: https://scala-lang.org)\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Class without Default Parameters\nDESCRIPTION: This snippet shows a basic Scala class definition with constructor parameters but without any default values assigned.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/constructors-default-values.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Socket(var timeout: Int, var linger: Int) {\n    override def toString = s\"timeout: $timeout, linger: $linger\"\n}\n```\n\n----------------------------------------\n\nTITLE: Using head Method with Strings in Scala\nDESCRIPTION: Demonstrating how head method works with strings, treating them as collections of characters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/collections-methods.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\n\"foo\".head   // 'f'\n\"bar\".head   // 'b'\n```\n\n----------------------------------------\n\nTITLE: Defining Scala View Trait for Non-Strictness\nDESCRIPTION: Defines the `View` trait, which represents a non-strict collection in Scala. It extends `Iterable` and `IterableOps`, providing a single abstract method `iterator`. The elements of a `View` are evaluated lazily only when its `iterator` is traversed, making `View` a fundamental component for implementing non-strict operations within the collections framework.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_14\n\nLANGUAGE: Scala 2\nCODE:\n```\ntrait View[+A] extends Iterable[A] with IterableOps[A, View, View[A]] {\n  def iterator: Iterator[A]\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ntrait View[+A] extends Iterable[A], IterableOps[A, View, View[A]]:\n  def iterator: Iterator[A]\n```\n\n----------------------------------------\n\nTITLE: Instantiating a Class Using a Null Value (Scala)\nDESCRIPTION: Shows the creation of an `Address` object where the optional `street2` field is explicitly assigned `null`, illustrating a common but problematic practice when dealing with optional data without using `Option`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/no-null-values.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval santa = new Address(\n    \"1 Main Street\",\n    null,               // <-- D'oh! A null value!\n    \"North Pole\",\n    \"Alaska\",\n    \"99705\"\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing a Runtime Mirror Using Scala Reflection - Scala\nDESCRIPTION: This Scala snippet demonstrates how to initialize the runtime reflection universe as 'ru' and obtain a runtime mirror for the current classloader. Dependencies: scala.reflect.runtime.universe. Input is the current classloader, and the output is a Mirror instance that allows reflective operations on loaded classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/environment-universes-mirrors.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval ru = scala.reflect.runtime.universe\nval m = ru.runtimeMirror(getClass.getClassLoader)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a CustomerID Extractor Object in Scala\nDESCRIPTION: This snippet demonstrates how to define an extractor object with apply and unapply methods. The CustomerID object creates and deconstructs customer IDs, allowing for pattern matching on CustomerID strings to extract the original name.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/extractor-objects.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.util.Random\n\nobject CustomerID {\n\n  def apply(name: String) = s\"$name--${Random.nextLong()}\"\n\n  def unapply(customerID: String): Option[String] = {\n    val stringArray: Array[String] = customerID.split(\"--\")\n    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None\n  }\n}\n\nval customer1ID = CustomerID(\"Sukyoung\")  // Sukyoung--23098234908\ncustomer1ID match {\n  case CustomerID(name) => println(name)  // prints Sukyoung\n  case _ => println(\"Could not extract a CustomerID\")\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Trait Composition Syntax Between Scala 2 and Scala 3 with Scala\nDESCRIPTION: These snippets compare the ways to create a combined trait extending both `Resettable` and `Growable[A]` in Scala 2 and Scala 3. In Scala 2, the combined trait `Both[A]` extends both traits with `with`, while in Scala 3, composition uses a comma-separated list. Both versions define method `f` accepting `Both[String]`. The difference lies in that using intersection types allows more flexible parameter passing compared to a nominal combined trait. This illustrates syntax evolution between Scala versions and type composition trade-offs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-intersection.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntrait Both[A] extends Resettable with Growable[A]\ndef f(x: Both[String]): Unit\n```\n\nLANGUAGE: scala\nCODE:\n```\ntrait Both[A] extends Resettable, Growable[A]\ndef f(x: Both[String]): Unit\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom 'p' Point Interpolator (Scala 2 & 3)\nDESCRIPTION: Provides sample implementations for the custom `p` interpolator in both Scala 2 (implicit class) and Scala 3 (extension method). This naive implementation reuses the standard `s` interpolator to combine parts and arguments, splits the resulting string by a comma, parses the parts to doubles (defaulting to 0.0 on failure), and constructs a `Point` object. Usage examples are included.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/string-interpolation.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 2 Implementation\ncase class Point(x: Double, y: Double) // Assuming defined elsewhere\nimplicit class PointHelper(val sc: StringContext) extends AnyVal {\n  def p(args: Double*): Point = {\n    // reuse the `s`-interpolator and then split on ','\n    val pts = sc.s(args: _*).split(\",\", 2).map { _.toDoubleOption.getOrElse(0.0) }\n    Point(pts(0), pts(1))\n  }\n}\n\nval x=12.0\n\np\"1, -2\"        // Point(1.0, -2.0)\np\"${x/5}, $x\"   // Point(2.4, 12.0)\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 3 Implementation\ncase class Point(x: Double, y: Double) // Assuming defined elsewhere\nextension (sc: StringContext)\n  def p(args: Double*): Point = {\n    // reuse the `s`-interpolator and then split on ','\n    val pts = sc.s(args: _*).split(\",\", 2).map { _.toDoubleOption.getOrElse(0.0) }\n    Point(pts(0), pts(1))\n  }\n\nval x=12.0\n\np\"1, -2\"        // Point(1.0, -2.0)\np\"${x/5}, $x\"   // Point(2.4, 12.0)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Immutable ParHashSet in Scala\nDESCRIPTION: Illustrates creating an immutable `ParHashSet` from a range of integers and then performing a parallel `map` operation (squaring elements) followed by a parallel `sum` operation on the results. This showcases chained parallel operations on immutable hash sets.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/concrete-parallel-collections.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nscala> val phs = scala.collection.parallel.immutable.ParHashSet(1 until 1000: _*)\nphs: scala.collection.parallel.immutable.ParHashSet[Int] = ParSet(645, 892, 69, 809, 629, 365, 138, 760, 101, 479,...\n\nscala> phs.map(x => x * x).sum\nres0: Int = 332833500\n```\n\n----------------------------------------\n\nTITLE: Приклад структури створеного проекту Scala (псевдокод)\nDESCRIPTION: Цей фрагмент показує приклад ієрархії файлів і папок, які створюються після ініціалізації проекту Scala за допомогою sbt шаблонів. Він включає директорію 'project' з файлами конфігурації sbt, файл збірки 'build.sbt', та каталог для вихідного коду 'src/main/scala' з файлом 'Main.scala' як точкою входу програми.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/getting-started/install-scala.md#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n- hello-world\n    - project (sbt uses this for its own files)\n        - build.properties\n    - build.sbt (sbt's build definition file)\n    - src\n        - main\n            - scala (весь ваш код на Scala буде тут)\n                - Main.scala (Точка входу в програму)\n```\n\n----------------------------------------\n\nTITLE: Avoiding Value Class Allocation with Specific Typing in Scala\nDESCRIPTION: Presents an alternative signature for the `add` function where parameters are typed specifically as the `Meter` value class. With this signature, the compiler can avoid allocating `Meter` objects during the function call, operating directly on the underlying primitives.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ndef add(a: Meter, b: Meter): Meter = ...\n```\n\n----------------------------------------\n\nTITLE: Defining a Multiline Method Body in Scala\nDESCRIPTION: Defines a Scala method `addThenDouble` with two integer parameters and an explicit `Int` return type. The method body contains multiple expressions and is enclosed in curly braces `{}`. In multiline method bodies, the value of the last expression is implicitly returned.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/methods-first-look.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ndef addThenDouble(a: Int, b: Int): Int = {\n    val sum = a + b\n    val doubled = sum * 2\n    doubled\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Code That Fails Compilation\nDESCRIPTION: This Scala code snippet shows an example that will fail to compile because the `toMap` method cannot be applied directly to a `List[Int]`. It requires a `List` of tuples (e.g., `List[(K, V)]`). This snippet is often used in conjunction with the `sc:fail` flag in documentation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/snippet-compiler.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nList(1,2,3).toMap\n```\n\n----------------------------------------\n\nTITLE: Explicit unapply Call in Scala 2\nDESCRIPTION: Demonstrates code that explicitly calls the unapply method and uses the Option result, which works in Scala 2 but fails in Scala 3 due to signature changes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-other-changes.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ndef tuple(location: Location): (Int, Int) = {\n  Location.unapply(location).get // [E008] In Scala 3, Not Found Error: value get is not a member of Location\n}\n```\n\n----------------------------------------\n\nTITLE: Inspecting Scala Generated JVM Bytecode Using javap Command\nDESCRIPTION: Displays the output of the javap tool applied to the Hello.class bytecode file produced by scalac. This inspection confirms that the Scala compiled class contains a public static main method compatible with JVM expectations, verifying interoperability between Scala bytecode and Java tools. Requires the javap utility (part of the JDK).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/hello-world-1.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n$ javap Hello.class\nCompiled from \"Hello.scala\"\npublic final class Hello {\n  public static void main(java.lang.String[]);\n}\n```\n\n----------------------------------------\n\nTITLE: Extending package objects with traits\nDESCRIPTION: This snippet demonstrates how to create a package object that extends multiple traits, showing that package objects can inherit from classes and traits like regular objects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/package-objects.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\npackage object fruits extends FruitAliases with FruitHelpers {\n  // helpers and variables follows here\n}\n```\n\n----------------------------------------\n\nTITLE: Adding sbt-sonatype and sbt-pgp Plugins for Publishing (Scala)\nDESCRIPTION: Lists the required plugin dependencies in sbt to enable publishing a Scala library to Sonatype and Maven Central. Includes sbt-sonatype for interacting with Sonatype's infrastructure and sbt-pgp for signing artifacts with GPG/PGP keys. Should be included in project/plugins.sbt. Inputs: correct plugin coordinates. Outputs: sbt build enriched with publish and sign capabilities. Limitation: Requires compatible sbt and plugin versions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\naddSbtPlugin(\"org.xerial.sbt\" % \"sbt-sonatype\" % \"3.9.21\")\naddSbtPlugin(\"com.github.sbt\" % \"sbt-pgp\" % \"2.2.1\")\n```\n\n----------------------------------------\n\nTITLE: Compiling a Scala source file using scalac in Bash\nDESCRIPTION: This shell command compiles the Scala source file 'Hello.scala' to generate JVM bytecode and TASTy metadata files. It requires the 'scalac' compiler installed and accessible in the environment. Upon execution, several output files including '.class' and '.tasty' files are produced, representing different compilation artifacts.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/scala3/guides/tasty-overview.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ scalac Hello.scala\n```\n\n----------------------------------------\n\nTITLE: Concise While Loop (Scala 3)\nDESCRIPTION: Shows the single-line syntax for a `while` loop in Scala 3 using the `do` keyword and indentation/no braces. The loop continues as long as the condition `x >= 0` is true, executing the single statement `x = f(x)`. Requires `x` to be a mutable variable and `f` to be a defined function.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_29\n\nLANGUAGE: Scala\nCODE:\n```\nwhile x >= 0 do x = f(x)\n```\n\n----------------------------------------\n\nTITLE: Running specific ScalaCheck tests by name (sbt)\nDESCRIPTION: Allows running one or more specified ScalaCheck tests by their fully qualified class names. This is useful for focusing on individual tests during development and debugging. Requires sbt and the exact names of the test classes to run.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/hacker-guide.md#_snippet_7\n\nLANGUAGE: sbt\nCODE:\n```\nscalacheck/testOnly <test1> ... <testN>\n```\n\nLANGUAGE: sbt\nCODE:\n```\nscalacheck/testOnly scala.tools.nsc.scaladoc.HtmlFactoryTest\n```\n\n----------------------------------------\n\nTITLE: Implicit Conversion from Option to Iterable - Scala 2 and 3\nDESCRIPTION: Defines the implicit conversion that allows an Option[A] to be converted to an Iterable[A], enabling the use of collection methods not otherwise available on Option. Applies to both Scala 2 and 3. Dependency: standard implicit resolution in the Scala library. Key parameter: xo, an Option[A]; returns an Iterable[A]. This conversion enables, for example, calling drop on an Option.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/conversion-between-option-and-the-collections.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit def option2Iterable[A](xo: Option[A]): Iterable[A]\n```\n\n----------------------------------------\n\nTITLE: Output of `migrateSyntax` sbt Command\nDESCRIPTION: Example console output after running the `migrateSyntax main` command in sbt. It shows the progress and results of applying Scalafix rules to update Scala 2 syntax to be compatible with Scala 3, reporting the number of sources processed and patches applied.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/scala3-migrate.md#_snippet_13\n\nLANGUAGE: text\nCODE:\n```\nsbt:main> migrateSyntax main\n[info] Starting migration of syntax in main\n[info] Run syntactic rules in 7 Scala sources successfully\n[info] Applied 3 patches in src/main/scala/example/SyntaxRewrites.scala\n[info] Run syntactic rules in 8 Scala sources successfully\n[info] Applied 1 patch in src/test/scala/example/SyntaxRewritesTests.scala\n[info] Migration of syntax in main succeeded.\n[success] Total time: 2 s, completed Aug 31, 2023 11:23:51 AM\n```\n\n----------------------------------------\n\nTITLE: Using the SensorReader Sensor-Display System in Scala 2\nDESCRIPTION: This Scala 2 code demonstrates creating sensor and display instances, subscribing displays to sensors, and updating sensor values to trigger notifications. It shows how the component design enables reactive updates and data flow in a sensor network, illustrating practical usage of the object-oriented pattern.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-oop.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport SensorReader._\n\n// настройка сети\nval s1 = new Sensor(\"sensor1\")\nval s2 = new Sensor(\"sensor2\")\nval d1 = new Display()\nval d2 = new Display()\ns1.subscribe(d1)\ns1.subscribe(d2)\ns2.subscribe(d1)\n\n// распространение обновлений по сети\ns1.changeValue(2)\ns2.changeValue(3)\n\n// печатает:\n// sensor1 has value 2.0\n// sensor1 has value 2.0\n// sensor2 has value 3.0\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Using a Class in Scala 2\nDESCRIPTION: Shows class instantiation with the new keyword and calling a method on the instance. Demonstrates parameter passing and use of user-defined classes. Standard practice for object-oriented code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\nval greeter = new Greeter(\"Hello, \", \"!\")\ngreeter.greet(\"Scala developer\") // Hello, Scala developer!\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type-Based Search in Scaladoc (Scala)\nDESCRIPTION: This Scala code snippet presents the signature of an `extension` method. It serves as an example to showcase Scaladoc's new type-based search feature, allowing users to search for functions by their type signature rather than just their name.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/scala3/scaladoc.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nextension [T](arr: IArray[T]) def span(p: T => Boolean): (IArray[T], IArray[T]) = ...\n```\n\n----------------------------------------\n\nTITLE: Importing Extension Methods in Scala 3\nDESCRIPTION: Illustrates how to import an extension method (`circumference`, assumed to be defined within a package `lib`) using a standard `import` statement to make it available in the current scope for use on `Circle` instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/ca-extension-methods.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport lib.circumference\n\naCircle.circumference\n```\n\n----------------------------------------\n\nTITLE: Take, TakeRight, and TakeWhile Methods in Scala Collections\nDESCRIPTION: Examples of using take-related methods to extract elements from collections, including taking a specific number of elements from the beginning or end, and taking elements while a condition is true.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-methods.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\noneToTen.take(1)        // List(1)\noneToTen.take(2)        // List(1, 2)\n\noneToTen.takeRight(1)   // List(10)\noneToTen.takeRight(2)   // List(9, 10)\n```\n\nLANGUAGE: scala\nCODE:\n```\noneToTen.take(Int.MaxValue)        // List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\noneToTen.takeRight(Int.MaxValue)   // List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\noneToTen.take(0)                   // List()\noneToTen.takeRight(0)              // List()\n```\n\nLANGUAGE: scala\nCODE:\n```\noneToTen.takeWhile(_ < 5)       // List(1, 2, 3, 4)\nnames.takeWhile(_.length < 5)   // List(adam)\n```\n\n----------------------------------------\n\nTITLE: Defining Absolute Paths with OS-Lib in Scala\nDESCRIPTION: This snippet shows how to create an absolute path to the /etc directory using the os.root path combined with the / operator. It demonstrates constructing paths for filesystem operations, starting from the root directory.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/os-read-directory.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval etc: os.Path = os.root / \"etc\"\n```\n\n----------------------------------------\n\nTITLE: Using match Expression for Pattern Matching in Scala\nDESCRIPTION: Shows Scala's 'match' expression matching the value of 'month' to cases 1, 2, and default, returning corresponding month strings. Demonstrates Scala's powerful pattern matching syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_30\n\nLANGUAGE: Scala\nCODE:\n```\nval monthAsString = month match\n  case 1 => \"January\"\n  case 2 => \"February\"\n  _ => \"Other\"\n```\n\n----------------------------------------\n\nTITLE: Declaring Basic Object with Methods - Scala\nDESCRIPTION: Demonstrates the syntax for declaring a standalone object in Scala, defining several utility methods within it. Objects provide a namespace similar to static classes in other languages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_19\n\nLANGUAGE: Scala 2\nCODE:\n```\nobject StringUtils {\n  def truncate(s: String, length: Int): String = s.take(length)\n  def containsWhitespace(s: String): Boolean = s.matches(\".*\\\\s.*\")\n  def isNullOrEmpty(s: String): Boolean = s == null || s.trim.isEmpty\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nobject StringUtils:\n  def truncate(s: String, length: Int): String = s.take(length)\n  def containsWhitespace(s: String): Boolean = s.matches(\".*\\\\s.*\")\n  def isNullOrEmpty(s: String): Boolean = s == null || s.trim.isEmpty\n```\n\n----------------------------------------\n\nTITLE: Type Inference in Scala Variable Declaration\nDESCRIPTION: Shows how Scala can infer variable types based on the assigned values, reducing verbosity. These snippets serve as examples of concise variable declaration, depending on the context for clarity, with no explicit type annotations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/type-is-optional.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval count = 1\nval name = \"Alvin\"\n```\n\n----------------------------------------\n\nTITLE: Syntax of Processed String Literals for Custom Interpolators in Scala\nDESCRIPTION: Illustrates the general syntax `id\"string content\"` for processed string literals in Scala. The compiler transforms this syntax into a method call (`id`) on an instance of `StringContext`, passing the string parts and evaluated expressions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nid\"string content\"\n```\n\n----------------------------------------\n\nTITLE: Using filter Method with Collections in Scala\nDESCRIPTION: Examples of the filter method which creates a new list containing only elements that satisfy a predicate condition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/collections-methods.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nscala> val lessThanFive = oneToTen.filter(_ < 5)\nlessThanFive: List[Int] = List(1, 2, 3, 4)\n\nscala> val evens = oneToTen.filter(_ % 2 == 0)\nevens: List[Int] = List(2, 4, 6, 8, 10)\n\nscala> val shortNames = names.filter(_.length <= 4)\nshortNames: List[String] = List(adam)\n```\n\n----------------------------------------\n\nTITLE: Higher-Order Functions with Short Lambda Syntax in Scala\nDESCRIPTION: Examples of higher-order functions using the concise placeholder syntax for lambda expressions, including dropWhile, filter, filterNot, find, and takeWhile.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-methods.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\na.dropWhile(_ < 25)   // List(30, 40, 10)\na.filter(_ > 100)     // List()\na.filterNot(_ < 25)   // List(30, 40)\na.find(_ > 20)        // Some(30)\na.takeWhile(_ < 30)   // List(10, 20)\n```\n\n----------------------------------------\n\nTITLE: Creating sbt Project Directory Structure with Terminal Commands\nDESCRIPTION: Shell commands to create a standard sbt project directory structure for a HelloWorld project. Creates the main and test directories for java, resources, and scala files.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/scala-build-tool-sbt.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmkdir HelloWorld\ncd HelloWorld\nmkdir -p src/{main,test}/{java,resources,scala}\nmkdir project target\n```\n\n----------------------------------------\n\nTITLE: Helper Class for Erasure Technique\nDESCRIPTION: Defines the `XmlEntity` class used as the upper bound in the erasure technique. It's marked as `Dynamic` to allow flexible member access (via `selectDynamic`) which is then handled by a macro.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/typeproviders.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nclass XmlEntity[Url] extends Dynamic {\n  def selectDynamic(field: String) = macro XmlEntity.impl\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Wildcard Pattern in Scala Quasiquotes\nDESCRIPTION: Demonstrates the simplest pattern matching in Scala quasiquotes using a wildcard pattern (`pq\"_\"`) that matches any input generically without condition. No parameters or inputs are required; this pattern acts as a universal matcher within Scala AST manipulations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/pattern-details.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\npq\"_\"\n```\n\n----------------------------------------\n\nTITLE: Creating a basic sbt project directory structure\nDESCRIPTION: Commands to set up a minimal sbt project with the standard directory layout, including source directories and build files needed for a simple Scala project.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/tools-sbt.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ mkdir HelloWorld\n$ cd HelloWorld\n$ mkdir -p src/{main,test}/scala\n$ mkdir project target\n\n```\n\n----------------------------------------\n\nTITLE: バビロニア法を用いた平方根計算アルゴリズムの実装\nDESCRIPTION: ParTrieMapを使用して数値の集合の平方根を計算する例。値が収束した数値は集合から削除され、未収束の数値のみが次の反復で処理される効率的な実装。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/parallel-collections/ctries.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Entry(num: Double) {\n  var sqrt = num\n}\n\nval length = 50000\n\n// リストを準備する\nval entries = (1 until length) map { num => Entry(num.toDouble) }\nval results = ParTrieMap()\nfor (e <- entries) results += ((e.num, e))\n\n// 平方根を計算する\nwhile (results.nonEmpty) {\n  for ((num, e) <- results) {\n    val nsqrt = 0.5 * (e.sqrt + e.num / e.sqrt)\n    if (math.abs(nsqrt - e.sqrt) < 0.01) {\n      results.remove(num)\n    } else e.sqrt = nsqrt\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining two lists/sequences in Python and Scala\nDESCRIPTION: Shows how to concatenate two lists or sequences. Python uses the + operator to combine lists while Scala uses ++ operator to concatenate two sequences. Demonstrates concise idiomatic ways of combining collections in both languages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_54\n\nLANGUAGE: python\nCODE:\n```\nc = a + b\n```\n\nLANGUAGE: scala\nCODE:\n```\nval c = a ++ b\n```\n\n----------------------------------------\n\nTITLE: Instantiating Class with Auxiliary Constructors in Scala 3\nDESCRIPTION: This snippet shows how to instantiate the `Student` class using its different constructors in Scala 3. Instances can be created using the primary constructor or either auxiliary constructor, without needing `new`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\nval s1 = Student(\"Mary\", \"123\")\nval s2 = Student(\"Mary\", \"123\", LocalDate.now())\nval s3 = Student(\"Mary\", \"123\", 456)\n```\n\n----------------------------------------\n\nTITLE: 定義されたコンバイナ (`Combiner` trait) の実装\nDESCRIPTION: `Combiner`は、Scalaの並列コレクションのビルダに相当し、複数の要素を効率的に集約しながら並列処理を行うためのトレイト。`combine` メソッドは、2つの`Combiner`を統合して新しい`Combiner`を生成し、並列処理によるデータの融合を可能にする。`combine`を呼び出すと、両方の`Combiner`は無効化される。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/parallel-collections/architecture.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Combiner[Elem, To] extends Builder[Elem, To] {\n  def combine(other: Combiner[Elem, To]): Combiner[Elem, To]\n}\n```\n\n----------------------------------------\n\nTITLE: Workaround for Trait Matching Issue in Scala\nDESCRIPTION: Shows the workaround for the trait matching issue (SI-8399) by using a wildcard pattern (`$_`) to capture the modifiers. This allows successful matching of the trait name and body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/definition-details.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"$_ trait $name { ..$stats }\" = q\"trait X { def x: Int }\"\nname: universe.TypeName = X\nstats: List[universe.Tree] = List(def x: Int)\n```\n\n----------------------------------------\n\nTITLE: Instantiating PetContainer with Valid Subtypes in Scala\nDESCRIPTION: Creates instances of PetContainer with Dog and Cat, which are subclasses of Pet, demonstrating correct type parameter usage respecting the upper bound constraint.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/upper-type-bounds.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval dogContainer = new PetContainer[Dog](new Dog)\nval catContainer = new PetContainer[Cat](new Cat)\n```\n\n----------------------------------------\n\nTITLE: Multi-line for Loop with Block in Java\nDESCRIPTION: For-loop that iterates over ints, calculates x as i*2, then prints x, showing multi-line body syntax with braces and variable declaration inside loop.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_41\n\nLANGUAGE: java\nCODE:\n```\nfor (int i: ints) {\n  int x = i * 2;\n  System.out.println(x);\n}\n```\n\n----------------------------------------\n\nTITLE: Inheritance Shadowing Example in Scala 2 and 3\nDESCRIPTION: Shows a code pattern where an identifier from an outer scope might be shadowed by an inherited member. Both Scala 2 and 3 allow this pattern when no actual shadowing occurs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-other-changes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject B {\n  val x = 1\n  class C extends A {\n    println(x)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Tuples (Scala)\nDESCRIPTION: This Scala snippet demonstrates the concise syntax for creating tuples of various sizes. Tuples are created by simply enclosing comma-separated values within parentheses.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_64\n\nLANGUAGE: Scala\nCODE:\n```\nval a = (\"eleven\")\nval b = (\"eleven\", 11)\nval c = (\"eleven\", 11, 11.0)\nval d = (\"eleven\", 11, 11.0, Person(\"Eleven\"))\n```\n\n----------------------------------------\n\nTITLE: Implicit Views Not Supported in Scala 3\nDESCRIPTION: Example showing how implicit views (implicit val ev: A => B) are not supported in Scala 3. This demonstrates how the direct usage of the conversion's result no longer works in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-contextual-abstractions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Pretty {\n  val print: String\n}\n\ndef pretty[A](a: A)(implicit ev: A => Pretty): String =\n  a.print // In Scala 3, Error: value print is not a member of A\n```\n\n----------------------------------------\n\nTITLE: Using Match Expressions as Scala 3 Method Bodies\nDESCRIPTION: Demonstrates using a Scala 3 match expression as the entire body of a method (`isTruthy`), directly returning the result of the match. The method takes a `Matchable` value and uses pattern matching (indentation syntax), including multi-value matching (`0 | \"\" | false`), to determine a boolean return value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_31\n\nLANGUAGE: Scala\nCODE:\n```\ndef isTruthy(a: Matchable) = a match\n  case 0 | \"\" | false => false\n  case _              => true\n```\n\n----------------------------------------\n\nTITLE: Defining a Concise Implicit Conversion using 'given' and Alias in Scala 3\nDESCRIPTION: Presents a concise syntax for defining an implicit conversion in Scala 3. It uses a `given` alias for `scala.Conversion[Int, Long]` and directly provides the conversion logic as a lambda expression `(x: Int) => x.toLong`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-implicit-conversions.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ngiven Conversion[Int, Long] = (x: Int) => x.toLong\n```\n\n----------------------------------------\n\nTITLE: Selecting and Deconstructing Type Projections with Quasiquotes - Scala\nDESCRIPTION: Illustrates basic type projection syntax and extraction in macros, including type member selection and the shortcut of member selections from terms. Requires Scala macro and reflection support. Key parameters include 'foo' and 'bar' as projected types/names. Inputs are quasiquoted types; outputs are SelectFromTypeTree and extracted components.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/type-details.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval proj = tq\"Foo#Bar\"\nval tq\"$foo#$bar\" = proj\nval int = tq\"scala.Int\"\nval tq\"scala.$name\" = int\nval projected = tq\"scala.type#Int\"\n```\n\n----------------------------------------\n\nTITLE: Checking Type Equality in Scala Reflection\nDESCRIPTION: Demonstrates the =:= operator for testing type equality, showing how it works with different instances of the same type and lists with different type parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n\ndef getType[T: TypeTag](obj: T) = typeOf[T]\n\nclass A\nval a1 = new A; val a2 = new A\ngetType(a1) =:= getType(a2) // Returns true\n```\n\nLANGUAGE: scala\nCODE:\n```\ngetType(List(1,2,3)) =:= getType(List(1.0, 2.0, 3.0)) // Returns false\ngetType(List(1,2,3)) =:= getType(List(9,8,7)) // Returns true\n```\n\nLANGUAGE: scala\nCODE:\n```\ntype Histogram = List[Int]\ntypeOf[Histogram] =:= getType(List(4,5,6)) // Returns true\ntypeOf[Histogram] == getType(List(4,5,6)) // Returns false (Don't use == for type comparison)\n```\n\n----------------------------------------\n\nTITLE: Creating and Modifying Immutable Vectors in Scala\nDESCRIPTION: Shows how to create an empty Vector, append elements using `:+`, prepend elements using `+:` and access elements by index (`vec3(0)`). Vectors provide effectively constant-time random access and modification.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/concrete-immutable-collection-classes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval vec = scala.collection.immutable.Vector.empty\n```\n\nLANGUAGE: output\nCODE:\n```\nvec: scala.collection.immutable.Vector[Nothing] = Vector()\n```\n\nLANGUAGE: scala\nCODE:\n```\nval vec2 = vec :+ 1 :+ 2\n```\n\nLANGUAGE: output\nCODE:\n```\nvec2: scala.collection.immutable.Vector[Int] = Vector(1, 2)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval vec3 = 100 +: vec2\n```\n\nLANGUAGE: output\nCODE:\n```\nvec3: scala.collection.immutable.Vector[Int] = Vector(100, 1, 2)\n```\n\nLANGUAGE: scala\nCODE:\n```\nvec3(0)\n```\n\nLANGUAGE: output\nCODE:\n```\nres1: Int = 100\n```\n\n----------------------------------------\n\nTITLE: Renaming a member during import in Scala 2 and 3\nDESCRIPTION: Renames the Java 'List' class to 'JavaList' on import to avoid naming conflicts with Scala's List class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/packaging-imports.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport java.util.{List => JavaList}  // Scala 2\nimport java.util.{List as JavaList}  // Scala 3\n```\n\n----------------------------------------\n\nTITLE: Working with Subtypes in Generic Classes in Scala 2\nDESCRIPTION: Example demonstrating how generic classes handle subtypes in Scala 2. Shows a class hierarchy with Fruit, Apple, and Banana, and how a Stack of Fruit can accept instances of Apple and Banana.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/generic-classes.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass Fruit\nclass Apple extends Fruit\nclass Banana extends Fruit\n\nval stack = new Stack[Fruit]\nval apple = new Apple\nval banana = new Banana\n\nstack.push(apple)\nstack.push(banana)\n```\n\n----------------------------------------\n\nTITLE: Converting Scala List to Java List with asJava and handling unsupported mutation (Scala 2 & 3)\nDESCRIPTION: Illustrates converting a Scala List to a Java list using 'asJava'. Since Scala Lists are immutable, attempting to mutate the Java list results in an UnsupportedOperationException.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/conversions-between-java-and-scala-collections.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval jul = List(1, 2, 3).asJava\njul.add(7) // Throws UnsupportedOperationException\n```\n\n----------------------------------------\n\nTITLE: Comparing Positional vs. Named Parameters for Instantiation in Scala 3\nDESCRIPTION: This snippet compares instantiating a class using positional arguments versus using named parameters in Scala 3 without the `new` keyword. Named parameters enhance readability, particularly with multiple parameters of the same type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\n// option 1\nval s = Socket(10_000, 10_000)\n\n// option 2\nval s = Socket(\n  timeout = 10_000,\n  linger = 10_000\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing polymorphic method with upper type bounds in Scala\nDESCRIPTION: This code snippet demonstrates how to use upper type bounds in Scala with a trait called Similar, a case class MyInt that extends Similar, and an object that implements a polymorphic method findSimilar which uses an upper type bound T <: Similar to ensure the type parameter has an isSimilar method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/upper-type-bounds.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Similar {\n  def isSimilar(x: Any): Boolean\n}\ncase class MyInt(x: Int) extends Similar {\n  def isSimilar(m: Any): Boolean =\n    m.isInstanceOf[MyInt] &&\n    m.asInstanceOf[MyInt].x == x\n}\nobject UpperBoundTest extends App {\n  def findSimilar[T <: Similar](e: T, xs: List[T]): Boolean =\n    if (xs.isEmpty) false\n    else if (e.isSimilar(xs.head)) true\n    else findSimilar[T](e, xs.tail)\n  val list: List[MyInt] = List(MyInt(1), MyInt(2), MyInt(3))\n  println(findSimilar[MyInt](MyInt(4), list))\n  println(findSimilar[MyInt](MyInt(2), list))\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified Anonymous Function Syntax (Single Parameter) with `map` in Scala\nDESCRIPTION: Shows further simplification of the anonymous function syntax for a single parameter (`i`) by removing the parentheses around it. This is valid when the type is inferred.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-anonymous-functions.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval doubledInts = ints.map(i => i * 2)\n```\n\n----------------------------------------\n\nTITLE: Defining a function with a by-name parameter in Scala\nDESCRIPTION: This snippet demonstrates the declaration of a function 'calculate' that takes a by-name parameter 'input'. The parameter is evaluated only when accessed within the function, enabling lazy evaluation for performance benefits.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/by-name-parameters.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef calculate(input: => Int) = input * 37\n```\n\n----------------------------------------\n\nTITLE: パラメータ付きケースクラスのフィールドアクセス\nDESCRIPTION: この例はパラメータを持つケースクラス`Message`を定義し、そのプロパティにアクセスしているものです。属性は自動的に`val`になるため、読み取り専用で他のクラスや関数からアクセスできます。この例では`sender`の値を出力し、変更しようとした場合のコンパイルエラーも示しています。依存関係はなしです。出力は`guillaume@quebec.ca`です。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/case-classes.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Message(sender: String, recipient: String, body: String)\nval message1 = Message(\"guillaume@quebec.ca\", \"jorge@catalonia.es\", \"Ça va ?\")\n\nprintln(message1.sender)  // guillaume@quebec.ca\nmessage1.sender = \"travis@washington.us\"  // この行はコンパイルされません\n```\n\n----------------------------------------\n\nTITLE: Instantiating a Class with Default Parameters in Scala 3\nDESCRIPTION: Various ways to create instances of a class that has default parameter values in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-tools.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval s = Socket()                  // timeout: 5000, linger: 5000\nval s = Socket(2_500)             // timeout: 2500, linger: 5000\nval s = Socket(10_000, 10_000)    // timeout: 10000, linger: 10000\nval s = Socket(timeout = 10_000)  // timeout: 10000, linger: 5000\nval s = Socket(linger = 10_000)   // timeout: 5000, linger: 10000\n```\n\n----------------------------------------\n\nTITLE: Sample Usage of PizzaServiceInterface Methods\nDESCRIPTION: Demonstrates how the PizzaServiceInterface methods would be used from a consumer's perspective, which helps validate API design.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-fp.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval p = Pizza(Small, Thin, Seq(Cheese))\n\n// как вы хотите использовать методы в PizzaServiceInterface\nval p1 = addTopping(p, Pepperoni)\nval p2 = addTopping(p1, Onions)\nval p3 = updateCrustType(p2, Thick)\nval p4 = updateCrustSize(p3, Large)\n```\n\n----------------------------------------\n\nTITLE: Явное и неявное объявление типов в Scala\nDESCRIPTION: Сравнивает явное объявление типа переменной (`val x: Int = 1`) с использованием вывода типов Scala, где компилятор автоматически определяет тип (`val x = 1`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-vars-data-types.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval x: Int = 1   // явно\nval x = 1        // неявно; компилятор выводит тип\n```\n\n----------------------------------------\n\nTITLE: Executing a List Loop in Scala 3 REPL\nDESCRIPTION: Shows the execution and output of a `for` loop iterating over a `List` within the Scala 3 REPL, using the updated syntax. Demonstrates the immediate evaluation and printing of each element.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/collections-classes.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nscala> for name <- names do println(name)\nJoel\nChris\nEd\n```\n\n----------------------------------------\n\nTITLE: Implementing runtimeCheck Extension Method in Scala Predef Object\nDESCRIPTION: Adds a transparent inline extension method to Predef that applies the @RuntimeCheck annotation to any expression, improving ergonomics and readability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/replace-nonsensical-unchecked-annotation.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\npackage scala\n\nimport scala.annotation.internal.RuntimeCheck\n\nobject Predef:\n  extension [T](x: T)\n    transparent inline def runtimeCheck: x.type =\n      x: @RuntimeCheck\n```\n\n----------------------------------------\n\nTITLE: Updating List Elements in Python\nDESCRIPTION: Shows how to update elements in a Python list by assigning new values to specific indices in a mutable list. Expects variable 'a' to be a list. Updates the first two elements to new integer values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\na[0] = 10\na[1] = 20\n```\n\n----------------------------------------\n\nTITLE: Recursive Sum of List in Scala 2\nDESCRIPTION: This snippet illustrates a pure recursive function in Scala 2 that calculates the sum of a list of integers. It highlights pattern matching on the list and recursion for processing each element, adhering to pure function principles.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fp-pure-functions.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef sum(xs: List[Int]): Int = xs match {\n  case Nil => 0\n  case head :: tail => head + sum(tail)\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Map Entries in Scala\nDESCRIPTION: Illustrates how to iterate over key-value pairs in a Scala Map called 'myMap' using a 'for' loop with pattern matching syntax (key,value) to print each element.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nfor (key,value) <- myMap do\n  println(key)\n  println(value)\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Authentication with sttp\nDESCRIPTION: Demonstrates how to add basic authentication to an HTTP request using the auth.basic method. The example shows the syntax for providing username and password credentials.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/http-client-request.md#_snippet_2\n\nLANGUAGE: scala 2\nCODE:\n```\nimport sttp.client4.quick._\n\n// a request with a authentication\nval request = quickRequest\n  .get(uri\"https://example.com\")\n  .auth.basic(user = \"user\", password = \"***\")\n```\n\nLANGUAGE: scala 3\nCODE:\n```\nimport sttp.client4.quick.*\n\n// a request with a authentication\nval request = quickRequest\n  .get(uri\"https://example.com\")\n  .auth.basic(user = \"user\", password = \"***\")\n```\n\n----------------------------------------\n\nTITLE: Importing and Creating ArrayBuffer in Scala\nDESCRIPTION: Demonstrates how to import ArrayBuffer from scala.collection.mutable and create empty or initialized ArrayBuffer instances with different data types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-classes.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.mutable.ArrayBuffer\n\nvar strings = ArrayBuffer[String]()\nvar ints = ArrayBuffer[Int]()\nvar people = ArrayBuffer[Person]()\n\n// ready to hold 100,000 ints\nval buf = new ArrayBuffer[Int](100_000)\n\nval nums = ArrayBuffer(1, 2, 3)\nval people = ArrayBuffer(\n  Person(\"Bert\"),\n  Person(\"Ernie\"),\n  Person(\"Grover\")\n)\n```\n\n----------------------------------------\n\nTITLE: Alternative Implementation with Using Clause\nDESCRIPTION: Alternative implementation of reduce that avoids context bounds by explicitly declaring the Monoid parameter in a using clause, allowing direct access to the instance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef reduce[A](xs: List[A])(using m: Monoid[A]): A =\n  xs.foldLeft(m.unit)(_ `combine` _)\n```\n\n----------------------------------------\n\nTITLE: Using foldLeft to Sum a List in Scala\nDESCRIPTION: Example of using foldLeft to sum all elements in a list, starting with an initial value of 0 and applying an addition function to each element.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/multiple-parameter-lists.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nval res = numbers.foldLeft(0)((m, n) => m + n)\nprintln(res) // 55\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Non-Interpolated String Literals in Scala\nDESCRIPTION: Shows that standard string literals in Scala do not perform interpolation if the `s` prefix is omitted. Variable references like `$name` and `$age` are treated as literal text.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval name = \"James\"\nval age = 30\nprintln(\"$name is $age years old\")   // \"$name is $age years old\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Traits in Scala 2 Classes\nDESCRIPTION: Defines a Dog class that extends multiple traits, providing implementation for the abstract method. Demonstrates trait inheritance and behavior composition in Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-modeling.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass Dog(name: String) extends Speaker with TailWagger with Runner {\n  def speak(): String = \"Woof!\"\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating with for Loop Over Range in Python\nDESCRIPTION: Shows a Python for loop iterating over a range from 0 to 3 (exclusive), printing each number. Demonstrates simple ranged iteration using the built-in 'range' function.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_15\n\nLANGUAGE: Python\nCODE:\n```\nfor i in range(0,3):\n  print(i)\n```\n\n----------------------------------------\n\nTITLE: Defining a Function Parameter for `map` in Scala\nDESCRIPTION: Defines the initial part of the `map` method signature, accepting a function `f` as a parameter. This function `f` takes an `Int` as input and returns a value of a generic type `A`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-write-map-function.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef map(f: (Int) => A)\n```\n\n----------------------------------------\n\nTITLE: Creating a Scala source file with utility method\nDESCRIPTION: Defines a simple Scala object with a method that doubles an integer, placed inside the `math` package, to be tested with ScalaTest.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/tools-sbt.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\npackage math\n\nobject MathUtils:\n  def double(i: Int) = i * 2\n```\n\n----------------------------------------\n\nTITLE: Procedure Syntax vs. Explicit Unit Return Type in Scala\nDESCRIPTION: Comparison between procedure syntax (proposed for removal) and the explicit Unit return type syntax that would be required after removal.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/minutes/2018-08-30-sip-minutes.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// Current procedure syntax (to be removed)\ndef foo() { }\n\n// Explicit Unit return type syntax\ndef foo(): Unit = {}\n\n// Incorrect alternative that might be used by developers\ndef foo() = {}\n```\n\n----------------------------------------\n\nTITLE: Example of @main Method in Scala 3\nDESCRIPTION: An example of a main method annotated with @main showing a simple method printing an integer parameter. This snippet is unrelated to named tuples and demonstrates a basic entry point declaration in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-tuples.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n// This is an @main method\n@main def foo(x: Int): Unit =\n  println(x)\n```\n\n----------------------------------------\n\nTITLE: Антипаттерн последовательного выполнения Future в Scala\nDESCRIPTION: Пример неправильного использования Future в выражении for, который приводит к последовательному, а не параллельному выполнению задач.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/concurrency.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\n// последовательное выполнение (без параллелизма!)\nfor\n  r1 <- Future { sleep(800); 1 }\n  r2 <- Future { sleep(200); 2 }\n  r3 <- Future { sleep(400); 3 }\nyield\n  r1 + r2 + r3\n```\n\n----------------------------------------\n\nTITLE: Scala 2 and 3: Usage of higher-order functions and lambdas\nDESCRIPTION: Demonstrates the use of higher-order functions like map and filter with lambda expressions for functional data transformations, highlighting Scala's concise syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/scala-features.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nnums.map(i => i * 2)   // long form\nnums.map(_ * 2)        // short form\n\nnums.filter(i => i > 1)\nnums.filter(_ > 1)\n```\n\n----------------------------------------\n\nTITLE: Extending Abstract Types with Upper Type Bounds in Scala\nDESCRIPTION: Shows how to extend the Buffer trait with an abstract class that adds upper type bounds to make the abstract type more precise. It introduces a new abstract type U and constrains T to be a subtype of Seq[U].\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/abstract-type-members.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nabstract class SeqBuffer extends Buffer {\n  type U\n  type T <: Seq[U]\n  def length = element.length\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Basic Trait (Interface) - Scala\nDESCRIPTION: Demonstrates the simplest form of a trait, defining only abstract methods. This is similar to a traditional interface in other languages, outlining a contract that implementing classes must fulfill.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_26\n\nLANGUAGE: Scala 2\nCODE:\n```\ntrait Employee {\n  def id: Int\n  def firstName: String\n  def lastName: String\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ntrait Employee:\n  def id: Int\n  def firstName: String\n  def lastName: String\n```\n\n----------------------------------------\n\nTITLE: Accessing the default value in match expressions in Scala 3\nDESCRIPTION: Demonstrates Scala 3's syntax for binding a variable to the default value in a match expression, showing how to use that value in the result expression.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\ni match\n  case 0 => println(\"1\")\n  case 1 => println(\"2\")\n  case what => println(s\"You gave me: $what\")\n```\n\n----------------------------------------\n\nTITLE: Illustration of expression-oriented programming concept\nDESCRIPTION: Explains the difference between expressions and statements in Scala, illustrating how expressions return values and statements are used for side effects. Uses simple examples for clarity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/if-then-else-construct.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval minValue = if (a < b) a else b\n```\n\nLANGUAGE: Scala\nCODE:\n```\nif (a == b) doSomething()\nprintln(\"Hello\")\n```\n\n----------------------------------------\n\nTITLE: Creating an Immutable Stream in Scala\nDESCRIPTION: Demonstrates creating a finite immutable Stream using the `#::` operator and `Stream.empty`. The tail elements are computed lazily and not shown immediately in the output, indicated by the '?'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/concrete-immutable-collection-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval str = 1 #:: 2 #:: 3 #:: Stream.empty\n```\n\nLANGUAGE: output\nCODE:\n```\nstr: scala.collection.immutable.Stream[Int] = Stream(1, ?)\n```\n\n----------------------------------------\n\nTITLE: Basic Unsafe Universal Equality Example in Scala\nDESCRIPTION: This snippet demonstrates the universal equality problem where values of incompatible types (Cat and Dog) can be compared without compile-time warnings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/ca-multiversal-equality.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Cat(name: String)\ncase class Dog(name: String)\nval d = Dog(\"Fido\")\nval c = Cat(\"Morris\")\n\nd == c  // false, но он компилируется\n```\n\n----------------------------------------\n\nTITLE: Single-line if statement in Python and Scala\nDESCRIPTION: Shows the syntax for an inline if statement that executes a print when condition is true. Inputs: integer variable x; output: printing x if equals 1. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_19\n\nLANGUAGE: Python\nCODE:\n```\nif x == 1: print(x)\n```\n\n----------------------------------------\n\nTITLE: Starting Interactive sbt Shell\nDESCRIPTION: Shows how to start sbt in interactive mode, which provides faster execution for subsequent commands by keeping the JVM running.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/scala-build-tool-sbt.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n> sbt\n[info] Loading project definition from /Users/al/Projects/Scala/Hello/project\n[info] Set current project to Hello (in build file:/Users/al/Projects/Scala/Hello/)\n```\n\n----------------------------------------\n\nTITLE: Using PizzaService Methods in Scala 3\nDESCRIPTION: Demonstrates importing and using the PizzaService implementation in Scala 3, showing the complete workflow of pizza creation and modification.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-fp.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport PizzaService.*\n\nval p = Pizza(Small, Thin, Seq(Cheese))\n\n// использование методов PizzaService\nval p1 = addTopping(p, Pepperoni)\nval p2 = addTopping(p1, Onions)\nval p3 = updateCrustType(p2, Thick)\nval p4 = updateCrustSize(p3, Large)\n\nprintln(price(p4)) // печатает 8.75\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Classes in Scala\nDESCRIPTION: This snippet demonstrates the lightweight syntax for defining simple classes with constructor parameters in Scala 2 and 3. The parameters are defined as `var` fields, making them mutable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass Person(var name: String, var vocation: String)\nclass Book(var title: String, var author: String, var year: Int)\nclass Movie(var name: String, var director: String, var year: Int)\n```\n\n----------------------------------------\n\nTITLE: Transforming a Sequence with for-yield in Scala\nDESCRIPTION: Defines a sequence of integers (`nums`) and then uses a Scala `for` expression with `yield` to create a new sequence (`doubledNums`) where each element is doubled. The REPL output confirms the result `List(2, 4, 6)`. This demonstrates the basic principle of using for-yield to create a new collection based on an existing one.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/for-expressions.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval nums = Seq(1,2,3)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval doubledNums = for (n <- nums) yield n * 2\n```\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val doubledNums = for (n <- nums) yield n * 2\ndoubledNums: Seq[Int] = List(2, 4, 6)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nList(2,4,6)\n```\n\n----------------------------------------\n\nTITLE: Reordering Elements - Error Before Trailing Commas\nDESCRIPTION: Illustrates the difficulty of reordering elements in a multi-line sequence without trailing comma support. Moving an element to the last position leaves a misplaced comma, resulting in a syntax error.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/trailing-commas.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval xs = Seq(\n  foo,\n  baz\n  bar,\n)       // error: illegal start of simple expression\n```\n\n----------------------------------------\n\nTITLE: Using blocking within a Future with a fixed thread pool ExecutionContext\nDESCRIPTION: Shows how to use the blocking construct within a Future with a fixed thread pool ExecutionContext, which will not handle the blocking in any special way.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\nimplicit val ec =\n  ExecutionContext.fromExecutor(Executors.newFixedThreadPool(4))\n\nFuture {\n  blocking { blockingStuff() }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ngiven ExecutionContext =\n  ExecutionContext.fromExecutor(Executors.newFixedThreadPool(4))\n\nFuture {\n  blocking { blockingStuff() }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the printf Macro from the Macros Object (Scala)\nDESCRIPTION: Defines an `App` object `Test` that imports the `Macros` object and calls the `printf` macro with a literal format string and argument. This shows the usage pattern of invoking a macro exactly as a regular method, without additional syntax or imports related to macros at the call site. It demonstrates how macros are seamlessly used after definition and compilation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/overview.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nobject Test extends App {\n  import Macros._\n  printf(\"hello %s!\", \"world\")\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Value Class Inside Top-Level Object (Allowed)\nDESCRIPTION: Contrasting with nesting inside a class, this example shows that defining a value class (`Inner`) as a member of a top-level or statically accessible object (`Outer`) is permitted in Scala. This works because it doesn't require an implicit reference to an enclosing class instance, thus adhering to the value class constraints.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\nobject Outer {\n  class Inner(val x: Int) extends AnyVal\n}\n```\n\n----------------------------------------\n\nTITLE: Importing readLine Method from scala.io.StdIn in Scala 2 and 3\nDESCRIPTION: Imports the `readLine` method from the Scala standard library object `scala.io.StdIn` to enable reading user input from the command line. This import is required before using `readLine` to capture interactive input in both Scala 2 and Scala 3 applications. There are no additional dependencies beyond the standard Scala library.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-hello-world.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.io.StdIn.readLine\n```\n\n----------------------------------------\n\nTITLE: Scala 3 Enum 'Planet' with Methods and Data\nDESCRIPTION: This enum defines planets with properties 'mass' and 'radius', and methods to calculate surface gravity and weight on the planet, illustrating complex enum types with fields and behavior in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\nenum Planet(mass: Double, radius: Double):\n  private final val G = 6.67300E-11\n  def surfaceGravity = G * mass / (radius * radius)\n  def surfaceWeight(otherMass: Double) =\n    otherMass * surfaceGravity\n\n  case Mercury extends Planet(3.303e+23, 2.4397e6)\n  case Earth   extends Planet(5.976e+24, 6.37814e6)\n```\n\n----------------------------------------\n\nTITLE: Creating RNA1 Instances (Scala)\nDESCRIPTION: Demonstrates creating `RNA1` instances using the companion object factory methods. `RNA1.fromSeq` converts an existing `Seq[Base]` (like a `List`) into an `RNA1`. `RNA1.apply` provides a convenient way to create an `RNA1` directly from a variable number of `Base` arguments. This code is compatible with both Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nscala> val xs = List(A, G, U, A)\nval xs: List[Base] = List(A, G, U, A)\n\nscala> RNA1.fromSeq(xs)\nval res1: RNA1 = RNA1(A, G, U, A)\n\nscala> val rna1 = RNA1(A, U, G, G, C)\nval rna1: RNA1 = RNA1(A, U, G, G, C)\n```\n\n----------------------------------------\n\nTITLE: Constructing a Package Definition AST in Scala\nDESCRIPTION: Demonstrates how to use a Scala quasiquote (`q\"...\"`) to construct the AST for a package definition, including nested definitions like classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/definition-details.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val pack = q\"package mycorp.myproj { class MyClass }\"\npack: universe.PackageDef =\npackage mycorp.myproj {\n  class MyClass extends scala.AnyRef {\n    def <init>() = {\n      super.<init>();\n      ()\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using @deprecated annotation in Scala\nDESCRIPTION: This snippet demonstrates the application of the @deprecated annotation to a method, causing compile-time warnings when the method is used. It showcases how annotations relate to method metadata and compiler warnings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/annotations.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject DeprecationDemo extends App {\n  @deprecated(\"deprecation message\", \"release # which deprecates method\")\n  def hello = \"hola\"\n\n  hello  \n}\n```\n\n----------------------------------------\n\nTITLE: Scala 3: Method Reference as Function\nDESCRIPTION: Illustrates that Scala 3 allows method references to be used directly as values, automatically converting them into function objects with matching types, simplifying method-to-function conversion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-eta-expansion.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef isLessThan(x: Int, y: Int): Boolean = x < y\n\nval methods = List(isLessThan) // works in Scala 3\n```\n\n----------------------------------------\n\nTITLE: Using Companion Objects with Case Class and Private Methods - scala\nDESCRIPTION: Defines a case class 'Circle' with a member method 'area' that calculates area using a private method 'calculateArea' defined in the companion singleton object 'Circle'. The companion object shares the class name and provides class-level methods accessible by all instances. It demonstrates encapsulation of utility methods in the companion object and shows usage of Scala's import within a class to bring companion members into scope. Dependencies include Scala's math package for Pi and pow functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/singleton-objects.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.math._\n\ncase class Circle(radius: Double) {\n  import Circle._\n  def area: Double = calculateArea(radius)\n}\n\nobject Circle {\n  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)\n}\n\nval circle1 = Circle(5.0)\n\ncircle1.area\n```\n\n----------------------------------------\n\nTITLE: Disabling Compilation for a Specific Snippet (Markdown/Scala)\nDESCRIPTION: Demonstrates how to prevent Scaladoc from attempting to compile a specific Scala code snippet by adding the `sc:nocompile` flag directly to the Markdown code block definition. This is useful for migrating existing projects or for examples not meant to be compiled.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/snippet-compiler.md#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n```scala sc:nocompile\n// under the hood `map` is transformed into\nList(1).map( _  + 1)(<implicits>)\n```\n```\n\n----------------------------------------\n\nTITLE: Scala code demonstrating type erasure with generics\nDESCRIPTION: This Scala snippet declares a List of integers assigned to a variable 'xs'. It illustrates Scala's generic usage that, when compiled, undergoes JVM type erasure where type parameters like Int are not preserved in class files. No dependencies beyond standard Scala are necessary.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/scala3/guides/tasty-overview.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval xs: List[Int] = List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Map Operation Using For-Yield in Scala\nDESCRIPTION: Shows a Scala 'for-yield' comprehension that maps each element 'i' in 'numbers' to 'i * 10', producing a new collection 'x' with transformed elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_26\n\nLANGUAGE: Scala\nCODE:\n```\nval x = for i <- numbers yield i * 10\n```\n\n----------------------------------------\n\nTITLE: Демонстрация неизменяемости `val` в Scala\nDESCRIPTION: Показывает, что попытка переназначить значение переменной, объявленной с помощью `val`, приводит к ошибке компиляции \"reassignment to val\".\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-vars-data-types.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval msg = \"Hello, world\"\nmsg = \"Aloha\"   // ошибка \"reassignment to val\"; этот код не скомпилируется\n```\n\n----------------------------------------\n\nTITLE: Создание и проверка состояния Future в Scala REPL\nDESCRIPTION: Демонстрация создания Future и проверки его состояния в REPL, показывающая переход от незавершенного к успешному состоянию.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/concurrency.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval eventualInt = Future(longRunningAlgorithm())\n// eventualInt: scala.concurrent.Future[Int] = Future(<not completed>)\n\n// Через 10 секунд:\n// eventualInt\n// val res2: scala.concurrent.Future[Int] = Future(Success(42))\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Enums in Scala 3\nDESCRIPTION: Shows the concise syntax for defining a simple enumeration (`Color`) in Scala 3 using the `enum` keyword and `case` objects for the members (`Red`, `Green`, `Blue`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_71\n\nLANGUAGE: Scala\nCODE:\n```\nenum Color:\n  case Red, Green, Blue\n```\n\n----------------------------------------\n\nTITLE: Invoking Methods with Multiple Boolean Parameters in Scala 2 and 3\nDESCRIPTION: Shows a call to a method with multiple boolean parameters passed positionally. Highlights the difficulty of understanding parameter roles without named arguments when multiple parameters share the same type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-methods.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nengage(true, true, true, false)\n```\n\n----------------------------------------\n\nTITLE: Creating Mutable Array (Java)\nDESCRIPTION: This Java snippet shows the standard syntax for creating and initializing a mutable array of strings using an array literal. This is the underlying structure that a Scala `Array[String]` maps to.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_61\n\nLANGUAGE: Java\nCODE:\n```\nString[] a = {\"a\", \"b\"};\n```\n\n----------------------------------------\n\nTITLE: Scala Swap Values in ArrayBuffer\nDESCRIPTION: Illustrates in-place swapping of elements within a Scala mutable collection using inline multiple assignment syntax to improve code readability and brevity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/multiple-assignments.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval a = mutable.ArrayBuffer(1, 2, 3)\n(a(0), a(2)) = (a(2), a(0))\nprintln(a) // ArrayBuffer(3, 2, 1)\n```\n\n----------------------------------------\n\nTITLE: Correct Multi-line Type Ascription in Scala\nDESCRIPTION: The proper way to format a multi-line type ascription in Scala. The colon should be at the beginning of the second line rather than at the end of the first line.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nanExpr\n  : aType\n```\n\n----------------------------------------\n\nTITLE: Using an Extractor for Value Assignment in Scala\nDESCRIPTION: This snippet shows how to use an extractor object for direct value assignment. It demonstrates extracting a name from a customer ID without explicit pattern matching syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ba/tour/extractor-objects.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval customer2ID = CustomerID(\"Nico\")\nval CustomerID(name) = customer2ID\nprintln(name)  // prints Nico\n```\n\n----------------------------------------\n\nTITLE: Creating Identifier Quasiquotes - Scala\nDESCRIPTION: Explains how to create identifier AST nodes (`Ident`) using quasiquotes, both directly with the name and by interpolating a `TermName`. It also shows how to create backquoted identifiers using backticks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val name = TermName(\"Foo\")\nname: universe.TermName = Foo\n\nscala> val foo = q\"$name\"\nfoo: universe.Ident = Foo\n\nscala> val backquoted = q\"`$name`\"\nbackquoted: universe.Ident = `Foo`\n```\n\n----------------------------------------\n\nTITLE: Sidebar Configuration in YAML\nDESCRIPTION: Example of a sidebar.yml file that customizes the navigation structure of the static site, overriding the default directory-based structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/static-site.md#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\nindex: index.html\nsubsection:\n    - title: Usage\n      index: usage/index.html\n      directory: usage\n      subsection:\n        - title: Dottydoc\n          page: usage/dottydoc.html\n          hidden: false\n        - title: sbt-projects\n          page: usage/sbt-projects.html\n          hidden: false\n```\n\n----------------------------------------\n\nTITLE: Using if statements as expressions in Java vs Scala\nDESCRIPTION: Demonstrates how Scala treats if statements as expressions that return values, similar to Java's ternary operator. This allows for more concise variable assignment based on conditions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_38\n\nLANGUAGE: Java\nCODE:\n```\nint minVal = (a < b) ? a : b;\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval minValue = if a < b then a else b\n```\n\n----------------------------------------\n\nTITLE: 定义具有多个方法的类型类 HasLegs 在 Scala 2 和 Scala 3 中的写法\nDESCRIPTION: 展示了如何定义一个参数化的类型类 HasLegs，包含 walk 和 run 两个抽象方法。Scala 2 采用传统 trait 和普通方法参数方式定义，Scala 3 通过扩展方法语法在 trait 内定义这些行为，允许为任意类型添加多种行为。适用于多方法的类型类设计。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/ca-type-classes.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ntrait HasLegs[A] {\n  def walk(a: A): Unit\n  def run(a: A): Unit\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntrait HasLegs[A]:\n  extension (a: A)\n    def walk(): Unit\n    def run(): Unit\n```\n\n----------------------------------------\n\nTITLE: Simple Scala 'Hello, World' source code\nDESCRIPTION: A minimal Scala 3 program defining a main method that prints 'Hello, world' to the console, placed in the root directory for simplicity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/tools-sbt.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n@main def helloWorld = println(\"Hello, world\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Dictionary in Python\nDESCRIPTION: Illustrates initializing a Python dictionary 'my_dict' with string keys 'a', 'b', 'c' and integer values 1, 2, 3 respectively. Demonstrates Python's dictionary literal syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\nmy_dict = {\n  'a': 1,\n  'b': 2,\n  'c': 3\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Variables with Explicit and Inferred Types\nDESCRIPTION: Shows how to explicitly specify a variable's data type or let Scala infer it based on the assigned value, promoting concise code through type inference.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-vars-data-types.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval x: Int = 1   // explicit\nval x = 1        // implicit; the compiler infers the type\n```\n\n----------------------------------------\n\nTITLE: Nested package declaration in Scala 3\nDESCRIPTION: Demonstrates nested package declaration syntax compatible with Scala 3, using indentation and colons. This approach facilitates clear and hierarchical organization of nested packages and classes, similar to the Scala 2 structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/packages-and-imports.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\npackage users:\n  package administrators:\n    class NormalUser\n\n  package normalusers:\n    class NormalUser\n```\n\n----------------------------------------\n\nTITLE: Calling Methods in Scala\nDESCRIPTION: Demonstrates how to call methods in Scala, including both simple method calls and calls to collection methods that take different types of parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/methods-most.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval x = add(1, 2)   // 3\n\nval x = List(1, 2, 3)\n\nx.size          // 3\nx.contains(1)   // true\nx.map(_ * 10)   // List(10, 20, 30)\n```\n\n----------------------------------------\n\nTITLE: Using TypeTag with context bounds in Scala\nDESCRIPTION: The paramInfo method rewritten to use context bounds instead of an explicit implicit parameter, providing a more concise syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/reflection/typetags-manifests.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n\ndef paramInfo[T: TypeTag](x: T): Unit = {\n  val targs = typeOf[T] match { case TypeRef(_, _, args) => args }\n  println(s\"type of $x has type arguments $targs\")\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Methods in Scala 2 and Scala 3\nDESCRIPTION: Demonstrates the basic syntax for defining methods in both Scala 2 and Scala 3, showing the differences in syntax and formatting between the two versions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/methods-most.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// Scala 2\ndef methodName(param1: Type1, param2: Type2): ReturnType = {\n  // the method body\n  // goes here\n}\n\n// Scala 3\ndef methodName(param1: Type1, param2: Type2): ReturnType =\n  // the method body\n  // goes here\nend methodName   // this is optional\n```\n\n----------------------------------------\n\nTITLE: Benefits of Using Case Classes in Scala for Data Modeling\nDESCRIPTION: Summarizes advantages of pervasive use of case classes, including immutability, value-based equality, and pattern matching, leading to more expressive, maintainable, and less bug-prone code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/case-classes.md#_snippet_9\n\n\n\n----------------------------------------\n\nTITLE: Sample minimal sbt project creation commands\nDESCRIPTION: Shell commands to create a simple directory structure for an sbt project suitable for Scala development, including source and test directories.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/tools-sbt.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ mkdir HelloWorld\n$ cd HelloWorld\n$ mkdir -p src/{main,test}/scala\n$ mkdir project target\n```\n\n----------------------------------------\n\nTITLE: Usage of User-Defined runtimeCheck Method in Scala\nDESCRIPTION: Demonstrates how a custom runtimeCheck method might be used, which could be affected by the introduction of the official method in Predef.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/replace-nonsensical-unchecked-annotation.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n// source B.scala\npackage example\n\n@main def Test =\n  val xs = List[Any](1,2,3)\n  val y :: ys = Predef.runtimeCheck(xs)\n  assert(ys == List(2, 3))\n```\n\n----------------------------------------\n\nTITLE: Creating Common Scala Collection Types\nDESCRIPTION: Examples of creating common Scala collection types including List, Vector, ArrayBuffer, Set, and Map with initial values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\nval strings = List(\"a\", \"b\", \"c\")\nval strings = Vector(\"a\", \"b\", \"c\")\nval strings = ArrayBuffer(\"a\", \"b\", \"c\")\n\nval set = Set(\"a\", \"b\", \"a\") // result: Set(\"a\", \"b\")\nval map = Map(\n  \"a\" -> 1,\n  \"b\" -> 2,\n  \"c\" -> 3\n)\n```\n\n----------------------------------------\n\nTITLE: Updating ArrayBuffer Elements in Scala\nDESCRIPTION: Demonstrates updating elements of a mutable Scala ArrayBuffer named 'a' by assigning new values to specific indices using parentheses notation. Requires import of mutable collection for ArrayBuffer.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\n// ArrayBuffer is mutable\na(0) = 10\na(1) = 20\n```\n\n----------------------------------------\n\nTITLE: Using '+' as an Infix Operator in Scala 2 and 3\nDESCRIPTION: Illustrates the more readable infix notation for calling methods with one parameter. Instead of using dot notation and parentheses, the '+' method is called between two operands.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/operators.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n10 + 1\n```\n\n----------------------------------------\n\nTITLE: Defining Quasiquote Patterns for Scala AST - Scala\nDESCRIPTION: This snippet lists common quasiquote patterns used for Scala syntax tree construction and matching, including import statements, case clauses, and different enumerators within for-comprehensions. It references the associated Tree types for each pattern, highlighting their use cases in metaprogramming. Dependencies include Scala's quasiquote support and Tree types for expressions, patterns, and imports.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/syntax-summary.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n   | Quasiquote                  | Type\n------------------------------------|-----------------------------|--------\n [Import][501]                      | `q\"import $ref.{..$sels}\"`  | Import\n [Case Clause][502]                 | `cq\"$pat if $expr => $expr\"`| CaseDef\n [Generator Enumerator][503]        | `fq\"$pat <- $expr\"`         | Tree\n [Value Definition Enumerator][503] | `fq\"$pat = $expr\"`          | Tree\n [Guard Enumerator][503]            | `fq\"if $expr\"`              | Tree\n```\n\n----------------------------------------\n\nTITLE: Importing All Members from an Object in Scala\nDESCRIPTION: Showing how to import all members from an object to call them directly without qualification.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport StringUtils._\ntruncate(\"Chuck Bartowski\", 5)       // \"Chuck\"\ncontainsWhitespace(\"Sarah Walker\")   // true\nisNullOrEmpty(\"John Casey\")          // false\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport StringUtils.*\ntruncate(\"Chuck Bartowski\", 5)       // \"Chuck\"\ncontainsWhitespace(\"Sarah Walker\")   // true\nisNullOrEmpty(\"John Casey\")          // false\n```\n\n----------------------------------------\n\nTITLE: Operator Precedence Rules in Scala\nDESCRIPTION: Explains Scala's operator precedence based on the first character, affecting how complex expressions are evaluated. Includes an example expression demonstrating precedence rules in Scala 2 and 3 syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/operators.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\na + b ^? c ?^ d less a ==> b | c\n```\n\n----------------------------------------\n\nTITLE: Combining given and All Members Imports in Scala 3 Using Scala\nDESCRIPTION: This snippet demonstrates the shortened syntax for importing both all non-given members and all given instances from the same object in Scala 3. The combined import statement 'import A.{given, *}' replaces separate import lines, improving conciseness while preserving explicit control over given instance imports. This approach depends on Scala 3's explicit import selectors for given and wildcard and maintains clarity about the imported scopes. Inputs are the declarations from object 'A', and outputs are the combined imports available in the importing scope.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/ca-given-imports.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject B:\n  import A.{given, *}\n```\n\n----------------------------------------\n\nTITLE: Importing All Object Members - Scala\nDESCRIPTION: Illustrates importing all public members of an object using the wildcard `_` (Scala 2) or `*` (Scala 3), allowing direct access to its methods without prefixing the object name.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_21\n\nLANGUAGE: Scala 2\nCODE:\n```\nimport StringUtils._\ntruncate(\"Chuck Bartowski\", 5)       // \"Chuck\"\ncontainsWhitespace(\"Sarah Walker\")   // true\nisNullOrEmpty(\"John Casey\")          // false\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nimport StringUtils.*\ntruncate(\"Chuck Bartowski\", 5)       // \"Chuck\"\ncontainsWhitespace(\"Sarah Walker\")   // true\nisNullOrEmpty(\"John Casey\")          // false\n```\n\n----------------------------------------\n\nTITLE: Complete Site Root Structure for Advanced Configuration\nDESCRIPTION: Shows the full directory structure for a Scaladoc site with layouts, documentation, blog, and assets organized in their respective directories.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/static-site.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n.\n└── <site-root>/\n    ├── _layouts/\n    │   └── ...\n    ├── _docs/\n    │   └── ...\n    ├── _blog/\n    │   ├── index.md\n    │   └── _posts/\n    │       └── ...\n    └── _assets/\n        ├── js/\n        │   └── ...\n        ├── img/\n        │   └── ...\n        └── ...\n```\n\n----------------------------------------\n\nTITLE: Unit Type and Empty Tuple - Scala\nDESCRIPTION: Illustrates the use of '()' as a member of the Unit type, similar to 'void' in Java or C. No dependencies. Commonly used as a placeholder for procedures with no return value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\n()\n```\n\n----------------------------------------\n\nTITLE: Initializing a Scala List of Integers\nDESCRIPTION: Defines a simple Scala `List` named `ints` containing integers 1, 2, and 3. This list serves as the base data for subsequent examples demonstrating anonymous functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-anonymous-functions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval ints = List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Basic Scala Worksheet Example\nDESCRIPTION: A simple Scala worksheet that demonstrates printing a message and evaluating expressions. Worksheets evaluate each expression and display results either in a side panel or as comments, depending on the IDE.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/tools-worksheets.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nprintln(\"Hello, world!\")\n\nval x = 1\nx + x\n```\n\n----------------------------------------\n\nTITLE: Comment Syntax in Python and Scala\nDESCRIPTION: Demonstrates the syntax for comments in Python (`#`) and Scala (`//`, `/*...*/`, `/**...*/`). Illustrates how comments are written for documentation and inline notes in both languages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n# a comment\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// a comment\n/* ... */\n/** ... */\n```\n\n----------------------------------------\n\nTITLE: Performing Runtime Type Checking in Scala\nDESCRIPTION: Demonstrates using the `isInstanceOf[Type]` method in Scala to check if an object `x` is an instance of a specific type (e.g., `String`) at runtime. It returns `true` if the object is an instance of the type, `false` otherwise.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/cheatsheets/index.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nx.isInstanceOf[String]\n```\n\n----------------------------------------\n\nTITLE: Creating a Python Set with Duplicate Elements\nDESCRIPTION: Shows that duplicates in a Python set literal are removed automatically, e.g., {1, 2, 1} results in {1, 2}, demonstrating set uniqueness property.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_18\n\nLANGUAGE: Python\nCODE:\n```\nset = {1,2,1}\n# set: {1,2}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using ArrayBuffer in Scala\nDESCRIPTION: Demonstrates how to create an empty ArrayBuffer, add elements to it, and convert it to an Array. ArrayBuffer is useful for efficiently building collections by appending elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/concrete-mutable-collection-classes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval buf = scala.collection.mutable.ArrayBuffer.empty[Int]\nbuf += 1\nbuf += 10\nbuf.toArray\n```\n\n----------------------------------------\n\nTITLE: Sample build.sbt for small sbt project\nDESCRIPTION: Configuration specifying project name, version, and Scala version, allowing sbt to locate sources and dependencies in the standard directory layout.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/tools-sbt.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nname := \"HelloWorld\"\nversion := \"0.1\"\nscalaVersion := \"{{ site.scala-3-version }}\"\n```\n\n----------------------------------------\n\nTITLE: While Loop in Scala\nDESCRIPTION: Shows Scala's concise while loop using 'while condition do' and indented block without braces, printing i while incrementing it, demonstrating clean loop syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_38\n\nLANGUAGE: scala\nCODE:\n```\nwhile i < 3 do\n  println(i)\n  i += 1\n```\n\n----------------------------------------\n\nTITLE: Scala抽出子マクロの定義とパターンマッチング実装例\nDESCRIPTION: Scalaにおける抽出子マクロの実装例として、`unapply`メソッドをマクロ化し、型に応じてパターンマッチングを行うコードを示す。`impl`関数は抽出子の動的生成に用いられ、パターンマッチの柔軟性を高めるための具体的なマクロパターンを解説している。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/extractors.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef unapply(x: SomeType) = macro impl\n    def impl(c: Context)(x: c.Tree) = {\n      q\"\"\"\n        new {\n          class Match(x: SomeType) {\n            def isEmpty = false\n            def get = x\n          }\n          def unapply(x: SomeType) = new Match(x)\n        }.unapply($x)\n      \"\"\"\n    }\n```\n\n----------------------------------------\n\nTITLE: Storing a Scala Function in a List\nDESCRIPTION: Shows that a Scala function (`isEvenFunction`), being a first-class object, can be treated like any other variable and stored directly within a data structure like a `List`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-eta-expansion.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval functions = List(isEvenFunction)\n```\n\n----------------------------------------\n\nTITLE: Basic Scala if statement syntax\nDESCRIPTION: Illustrates the simplest form of an if statement in Scala, including single-line and block syntax. Demonstrates how conditions are tested and actions are executed based on the condition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/if-then-else-construct.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nif (a == b) doSomething()\n```\n\nLANGUAGE: Scala\nCODE:\n```\nif (a == b) {\n    doSomething()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Scala/sbt Project Directory Structure - Bash\nDESCRIPTION: Provides a sequence of Bash commands to initialize the standard directory structure for a new Scala project managed with sbt. No prerequisites beyond Bash shell access; outputs created directories for main source code and tests, enabling clear project organization. Input: none; Output: project folders suitable for sbt.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_17\n\nLANGUAGE: Bash\nCODE:\n```\n$ mkdir HelloScalaTest\n$ cd HelloScalaTest\n$ mkdir -p src/{main,test}/scala\n$ mkdir project\n\n```\n\n----------------------------------------\n\nTITLE: Combined Iterator Implementation in Scala 2\nDESCRIPTION: Creates a class that combines StringIterator's ability to iterate over a string with RichIterator's foreach method, demonstrating the power of trait composition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/mixin-class-composition.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nclass RichStringIter extends StringIterator(\"Scala\") with RichIterator\nval richStringIter = new RichStringIter\nrichStringIter.foreach(println)\n```\n\n----------------------------------------\n\nTITLE: Configuring Macro Paradise in Maven POM\nDESCRIPTION: This snippet demonstrates how to configure the Macro Paradise compiler plugin in a Maven project by adding it to the compiler plugins section of the POM file.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/paradise.md#_snippet_2\n\nLANGUAGE: xml\nCODE:\n```\n<compilerPlugins>\n  <compilerPlugin>\n    <groupId>org.scalamacros</groupId>\n    <artifactId>paradise_<YOUR.SCALA.VERSION></artifactId>\n    <version>2.1.0-M4</version>\n  </compilerPlugin>\n</compilerPlugins>\n```\n\n----------------------------------------\n\nTITLE: Scala if/else-if/else expression with multiple conditions\nDESCRIPTION: Provides a comprehensive example of nested conditional logic with else-if clauses, enabling multi-branch decision making within a single expression.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/if-then-else-construct.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nif (test1) {\n    doX()\n} else if (test2) {\n    doY()\n} else {\n    doZ()\n}\n```\n\n----------------------------------------\n\nTITLE: Single-line for loops in Java vs Scala\nDESCRIPTION: Illustrates the syntax for iterating through a collection in a simple for loop in both languages. Scala offers both a preferred syntax without parentheses and an alternative with parentheses.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_40\n\nLANGUAGE: Java\nCODE:\n```\nfor (int i: ints) {\n  System.out.println(i);\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\n//preferred\nfor i <- ints do println(i)\n\n// also available\nfor (i <- ints) println(i)\n```\n\n----------------------------------------\n\nTITLE: Working with Traits in Scala\nDESCRIPTION: Examples of defining and implementing traits, which are interfaces with implementation that can be mixed into classes. Shows single trait implementation and combining traits with class inheritance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/cheatsheets/index.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ntrait T { ... }\nclass C extends T { ... }\nclass C extends D with T { ... }\n```\n\n----------------------------------------\n\nTITLE: Using foreach on Scala Iterator for concise traversal\nDESCRIPTION: Shows how to use the foreach method to execute a procedure on each element in the iterator, providing a more idiomatic and concise syntax, compatible with both Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/iterators.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nit.foreach(println)\n```\n\n----------------------------------------\n\nTITLE: Scala 2 nested 'for' with multiple generators and guards\nDESCRIPTION: Executes nested 'for' loops with multiple generators and guards, printing variables only when conditions are met.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nfor {\n  i <- 1 to 3\n  j <- 'a' to 'c'\n  if i == 2\n  if j == 'b'\n} {\n  println(s\"i = $i, j = $j\")   // prints: \"i = 2, j = b\"\n}\n```\n\n----------------------------------------\n\nTITLE: Proposal 3: Optimized Desugaring Output\nDESCRIPTION: Shows the optimized desugared code for the preceding example. The final `.map(a => a)` call is entirely removed, resulting in just the original collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nList(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Unicode Escapes in Raw Interpolations Example\nDESCRIPTION: Shows the behavior difference in handling Unicode escapes in raw string interpolations between regular Scala 2, -Xsource:3, and with -Xsource-features:unicode-escapes-raw enabled.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tooling-scala2-xsource3.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nraw\"\\u0061\"\n```\n\n----------------------------------------\n\nTITLE: Nested for loops vs Scala's multiple generators\nDESCRIPTION: Shows how Scala simplifies nested loops using multiple generators in a single for expression, compared to Java's nested for loops.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_42\n\nLANGUAGE: Java\nCODE:\n```\nfor (int i: ints1) {\n  for (int j: chars) {\n    for (int k: ints2) {\n      System.out.printf(\"i = %d, j = %d, k = %d\\n\", i,j,k);\n    }\n  }\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor\n  i <- 1 to 2\n  j <- 'a' to 'b'\n  k <- 1 to 10 by 5\ndo\n  println(s\"i = $i, j = $j, k = $k\")\n```\n\n----------------------------------------\n\nTITLE: Working with Mutable Queues in Scala\nDESCRIPTION: Shows how to create a mutable Queue, add elements with += and ++= operators, and remove elements with dequeue. Mutable queues modify themselves directly upon operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/concrete-mutable-collection-classes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval queue = new scala.collection.mutable.Queue[String]\nqueue += \"a\"\nqueue ++= List(\"b\", \"c\")\nqueue\nqueue.dequeue\nqueue\n```\n\n----------------------------------------\n\nTITLE: Defining Enum in Scala 3\nDESCRIPTION: Illustrates Scala 3 syntax for defining an enumeration 'Color' with three cases: Red, Green, and Blue using the 'enum' keyword and case enumerators.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_37\n\nLANGUAGE: Scala\nCODE:\n```\nenum Color:\n  case Red, Green, Blue\n```\n\n----------------------------------------\n\nTITLE: Serving Resources with @cask.staticResources Annotation in Scala 2\nDESCRIPTION: Simplified Scala 2 implementation that uses @cask.staticResources annotation to serve files directly from the resources directory. The \".\" path indicates the root of the resources directory.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/web-server-static.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nobject Example extends cask.MainRoutes {\n  @cask.staticResources(\"/static\")\n  def staticEndpoint(): String = \".\"\n\n  initialize()\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Scala Runtime Reflection Universe in Japanese Documentation\nDESCRIPTION: This code demonstrates how to import all members of the scala.reflect.runtime.universe using a wildcard import, which is typically required when using runtime reflection in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/reflection/overview.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n```\n\n----------------------------------------\n\nTITLE: Extension method in Scala 3\nDESCRIPTION: Defines an extension method `makeInt` on String to parse the string into an integer with a specified radix, demonstrating Scala 3's extension syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-methods.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nextension (s: String)\n  def makeInt(radix: Int): Int = Integer.parseInt(s, radix)\n\n\"1\".makeInt(2)      // Int = 1\n\"10\".makeInt(2)     // Int = 2\n\"100\".makeInt(2)    // Int = 4\n```\n\n----------------------------------------\n\nTITLE: 基本的なScala配列操作の例 - Scala\nDESCRIPTION: Scalaの配列(Array)の基本的な使用例を示すコードスニペットです。配列の生成、mapとfilterによる要素変換、reverseによる配列反転が含まれています。これらの操作はScalaの配列が提供する関数型コレクションメソッドを活用しています。入力は明示的な整数配列で、出力は各操作後の新しい配列です。依存はScala標準ライブラリのみです。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/arrays.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval a1 = Array(1, 2, 3)\nval a2 = a1 map (_ * 3)\nval a3 = a2 filter (_ % 2 != 0)\na3.reverse\n```\n\n----------------------------------------\n\nTITLE: Type Erasure and @unchecked Annotation in Scala Pattern Matching\nDESCRIPTION: Shows how @unchecked is used with type parameters to bypass runtime type checking, which can lead to ClassCastExceptions if used incorrectly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/replace-nonsensical-unchecked-annotation.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nxs match\n  case ints: List[Int @unchecked] =>\n```\n\n----------------------------------------\n\nTITLE: Using Apply Method from Companion Objects in Scala\nDESCRIPTION: Demonstrates how collection creation is expanded to companion object apply method calls and shows different collection type instantiations with the same elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/creating-collections-from-scratch.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nList.apply(1.0, 2.0)\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> List(1, 2, 3)\nres17: List[Int] = List(1, 2, 3)\nscala> Iterable(1, 2, 3)\nres18: Iterable[Int] = List(1, 2, 3)\nscala> mutable.Iterable(1, 2, 3)\nres19: scala.collection.mutable.Iterable[Int] = ArrayBuffer(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Scala 'Hello World' Program\nDESCRIPTION: Demonstrates the minimal structure of a Scala program using a singleton `object` containing a `main` method. Explains that `main` doesn't return a value (`Unit`), takes command-line arguments (`Array[String]`), and how singleton objects replace Java's static members. Uses `println` for output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tutorials/scala-for-java-programmers.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject HelloWorld {\n  def main(args: Array[String]): Unit = {\n    println(\"Hello, world!\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Java annotation with 'value' and named argument in Java\nDESCRIPTION: Shows how to apply a Java annotation with a `value` element and another element when providing values for both in Java. Both `value` and the other element must be specified using named arguments in this case.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/annotations.md#_snippet_8\n\nLANGUAGE: Java\nCODE:\n```\n@SourceURL(value = \"https://coders.com/\",\n           mail = \"support@coders.com\")\npublic class MyJavaClass extends TheirClass ...\n```\n\n----------------------------------------\n\nTITLE: Using Scala for comprehensions\nDESCRIPTION: Demonstrates Scala's for comprehensions which allow transformation of collections. This has no direct equivalent in Java and shows Scala's functional programming capabilities.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_44\n\nLANGUAGE: Scala\nCODE:\n```\nval list = \n  for\n    i <- 1 to 3\n  yield\n    i * 10\n// list: Vector(10, 20, 30)\n```\n\n----------------------------------------\n\nTITLE: Using '+' Operator as Method Call in Scala\nDESCRIPTION: Demonstrates how the '+' operator is a method that can be called using dot notation or infixed. Showcases the equivalence between 10.+(1) and 10 + 1 in Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/operators.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n10.+(1)\n```\n\n----------------------------------------\n\nTITLE: Defining Parent and Child Classes Illustrating Type Inference in Scala\nDESCRIPTION: This snippet demonstrates how Scala 2.13 and Scala 3 differ in inferring the return type of an overridden method. It defines a base class and a subclass in which the method foo is overridden, but an explicit return type is not provided. In Scala 2.13, the return type is inferred from the right-hand side, resulting in a more specific type, while Scala 3 infers it from the base class signature, leading to a type mismatch in certain cases. No external dependencies are required apart from standard class definitions. Inputs are class definitions; the output is the way the method type is inferred.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-type-inference.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass Foo\n\nclass RichFoo(foo: Foo) extends Foo {\n  def show: String = \"\"\n}\n\nclass Parent {\n  def foo: Foo = new Foo\n}\n\nclass Child extends Parent {\n  override def foo = new RichFoo(super.foo)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Tuple in Python\nDESCRIPTION: Creates a Python tuple 't' containing three elements: an integer 11, a float 11.0, and a string \"Eleven\", demonstrating fixed-size heterogeneous immutable collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_20\n\nLANGUAGE: Python\nCODE:\n```\nt = (11, 11.0, \"Eleven\")\n```\n\n----------------------------------------\n\nTITLE: If-else expressions as method bodies in Scala 2 and 3\nDESCRIPTION: Example of using if-else expressions as the body of a method, showing how they return values that become the method's return value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/control-structures.md#_snippet_6\n\nLANGUAGE: Scala 2\nCODE:\n```\ndef compare(a: Int, b: Int): Int =\n  if (a < b)\n    -1\n  else if (a == b)\n    0\n  else\n    1\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ndef compare(a: Int, b: Int): Int =\n  if a < b then\n    -1\n  else if a == b then\n    0\n  else\n    1\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Value Class with Disallowed Members (Disallowed)\nDESCRIPTION: This snippet illustrates various member definitions that are not permitted within a Scala value class `NoLazyMember`. These restricted members include regular `val`s, `var`s, `lazy val`s, nested objects, and nested classes. The corresponding compiler errors confirm these limitations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\nclass NoLazyMember(val evaluate: () => Double) extends AnyVal {\n  val member: Int = 3\n  var y: Int = 4\n  lazy val x: Double = evaluate()\n  object NestedObject\n  class NestedClass\n}\n```\n\nLANGUAGE: text\nCODE:\n```\nInvalid.scala:2: error: this statement is not allowed in value class: val member: Int = 3\n  val member: Int = 3\n      ^\nInvalid.scala:3: error: this statement is not allowed in value class: var y: Int = 4\n  var y: Int = 4\n      ^\nInvalid.scala:4: error: this statement is not allowed in value class: lazy val x: Double = NoLazyMember.this.evaluate.apply()\n  lazy val x: Double = evaluate()\n           ^\nInvalid.scala:5: error: value class may not have nested module definitions\n  object NestedObject\n         ^\nInvalid.scala:6: error: value class may not have nested class definitions\n  class NestedClass\n        ^\n```\n\n----------------------------------------\n\nTITLE: Simple 'Hello, World' Scala program\nDESCRIPTION: A minimal Scala 3 program with a main method, which prints 'Hello, world' when run. It demonstrates defining entry point in Scala 3 with @main def.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/tools-sbt.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n@main def helloWorld = println(\"Hello, world\")\n```\n\n----------------------------------------\n\nTITLE: Different syntax styles for 'for' with 'yield'\nDESCRIPTION: Shows multiple stylistic variations of 'for'-'yield' syntax in Scala, with and without braces.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nval doubles = for (i <- ints) yield i * 2\n// or\nval doubles = for (i <- ints) yield (i * 2)\n// or\nval doubles = for { i <- ints } yield (i * 2)\n```\n\n----------------------------------------\n\nTITLE: Declaring Immutable and Mutable Variables in Scala\nDESCRIPTION: Shows how to declare immutable (val) and mutable (var) variables in Scala with examples. Emphasizes that val cannot be reassigned, whereas var can be.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-vars-data-types.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// immutable\nval a = 0\n\n// mutable\nvar b = 1\n```\n\n----------------------------------------\n\nTITLE: Running Scala Compiled Program\nDESCRIPTION: Shows the shell command used to run the compiled Scala program named 'hello' on the JVM. The command 'scala hello' invokes the Scala runtime which loads and executes the bytecode, printing 'Hello, World!' to the standard output. This step follows compilation and requires proper Scala runtime environment setup. It confirms successful build and execution of the simple Scala application.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-hello-world.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ scala hello\nHello, World!\n```\n\n----------------------------------------\n\nTITLE: Multiline for Loop with Computation in Python\nDESCRIPTION: Illustrates a Python for loop iterating over a list 'ints', computing a new variable 'x' as double the current element, then printing a formatted string demonstrating variable use inside the loop body.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_19\n\nLANGUAGE: Python\nCODE:\n```\nfor i in ints:\n  x = i * 2\n  print(f\"i = {i}, x = {x}\")\n```\n\n----------------------------------------\n\nTITLE: Rewriting incompatible type lambdas using `type` aliases (Scala 2/3)\nDESCRIPTION: Provides the standard Scala syntax for defining type aliases (e.g., `type MyLambda[F[_], A] = ...`). This long-form syntax is compatible with both Scala 2 and Scala 3 and serves as a direct replacement for incompatible `kind-projector` features like higher-kinded placeholders and named parameters when cross-compiling.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/plugin-kind-projector.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ntype MyLambda[F[_], A] = EitherT[F, Int, A]\nMyLambda\n```\n\n----------------------------------------\n\nTITLE: Using Scala Value Class in Structural Type Definition (Disallowed)\nDESCRIPTION: This example demonstrates a limitation where a user-defined value class `Value` cannot be used as a parameter or return type within a structural type definition (e.g., `v: { def value: Value }`). The compiler raises an error, indicating that value classes cannot be referred to in structural refinements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\nclass Value(val x: Int) extends AnyVal\nobject Usage {\n  def anyValue(v: { def value: Value }): Value =\n    v.value\n}\n```\n\nLANGUAGE: text\nCODE:\n```\nStruct.scala:3: error: Result type in structural refinement may not refer to a user-defined value class\n  def anyValue(v: { def value: Value }): Value =\n                               ^\n```\n\n----------------------------------------\n\nTITLE: Using TypeTag as implicit parameter in Scala\nDESCRIPTION: Method that accepts any object and uses an implicit TypeTag parameter to print information about the type parameters of that object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/reflection/typetags-manifests.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n\ndef paramInfo[T](x: T)(implicit tag: TypeTag[T]): Unit = {\n  val targs = tag.tpe match { case TypeRef(_, _, args) => args }\n  println(s\"type of $x has type arguments $targs\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using Guards in For Loops in Scala 2\nDESCRIPTION: Filters elements in ints using a guard (if i > 2) inside the for loop, printing only values greater than 2. Dependencies: ints must be a List or similar collection. Prints each matching element.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-control-structures.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nfor (i <- ints if i > 2)\n  println(i)\n\n```\n\n----------------------------------------\n\nTITLE: 함수 내에서 지역 임포트 적용한 예제 스칼라\nDESCRIPTION: 스칼라의 특징으로 함수나 코드 블록 내부에서도 임포트가 가능함을 보여주는 예제입니다. 함수 sqrtplus1 정의 안에 scala.math.sqrt를 임포트하여 함수 내에서만 사용할 수 있게 제한하며, 해당 함수는 정수 입력에 대해 제곱근에 1을 더한 값을 실수로 반환합니다. 이 방법은 불필요한 전역 임포트 없이 스코프를 한정하여 코드 가독성과 충돌 방지에 유리합니다.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/packages-and-imports.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef sqrtplus1(x: Int) = {\n  import scala.math.sqrt\n  sqrt(x) + 1.0\n}\n```\n\n----------------------------------------\n\nTITLE: Examples of Legal Type Match Patterns - Scala\nDESCRIPTION: This snippet demonstrates various legal pattern matches in Scala's type system, including patterns with simple types, parameterized types, type constructors, nested captures with covariance, and type aliases. Each case covers a specific aspect or rule for match type patterns as per Scala type system rules. The snippet assumes the prior type and class definitions and is purely illustrative with comments, not meant for direct execution.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/match-types-spec.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n// TypeWithoutCapture's\ncase Any => // also the desugaring of `case _ =>` when the _ is at the top-level\ncase Int =>\ncase List[Int] =>\ncase Array[String] =>\n\n// Class type constructors with direct captures\ncase scala.collection.immutable.List[t] => // not Predef.List; it is a type alias\ncase Array[t] =>\ncase Contra[t] =>\ncase Either[s, t] =>\ncase Either[s, Contra[Int]] =>\ncase h *: t =>\ncase Int *: t =>\n\n// The S type constructor\ncase S[n] =>\n\n// An abstract type constructor\n// given a [F[_]] or `type F[_] >: L <: H` in scope\ncase F[t] =>\n\n// Nested captures in covariant position\ncase Cov[Inv[t]] =>\ncase Cov[Cov[t]] =>\ncase Cov[Contra[t]] =>\ncase Array[h] *: t => // sugar for *:[Array[h], t]\ncase g *: h *: EmptyTuple =>\n\n// Type aliases\ncase List[t] => // which is Predef.List, itself defined as `type List[+A] = scala.collection.immutable.List[A]`\n\n// Refinements (through a type alias)\ncase YExtractor[t] =>\n```\n\n----------------------------------------\n\nTITLE: Example of Value Class Type Transformations in Scala\nDESCRIPTION: This code snippet shows how different Scala statements involving value classes are transformed through the erasure process (steps 1-3). It demonstrates variable declarations, assignments, method calls, and type checks/casts.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/value-classes.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nvar m, n: Meter           var m, n: Meter$unboxed\nvar o: AnyRef             var o: AnyRef\nm = n                     m = n\no = m                     o = new Meter(m.asInstanceOf[Double])\nm.print                   new Meter(m.asInstanceOf[Double]).print\nm less n                  Meter.extension$less(m, n)\nm.toString                Meter.extension$toString(m)\nm.isInstanceOf[Ordered]   new Meter(m.asInstanceOf[Double]).isInstanceOf[Ordered]\nm.asInstanceOf[Ordered]   new Meter(m.asInstanceOf[Double]).asInstanceOf[Ordered]\no.isInstanceOf[Meter]     o.isInstanceOf[Meter]\no.asInstanceOf[Meter]     o.asInstanceOf[Meter].underlying.asInstanceOf[Meter$unboxed]\nm.isInstanceOf[Meter]     new Meter(m.asInstanceOf[Double]).isInstanceOf[Meter]\nm.asInstanceOf[Meter]     m.asInstanceOf[Meter$unboxed]\n```\n\n----------------------------------------\n\nTITLE: Simple Scala Compiler Plugin to Detect Division by Zero\nDESCRIPTION: This code defines a Scala compiler plugin named 'DivByZero' that adds a new compilation phase to check for division by zero in source code. It extends `Plugin`, incorporates a component extending `PluginComponent`, and registers a custom phase implementing the check within the `apply` method. Dependencies include Scala's `nsc` compilation API classes. The plugin reports errors on detected division by zero expressions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/plugins/index.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\npackage localhost\n\nimport scala.tools.nsc\nimport nsc.Global\nimport nsc.Phase\nimport nsc.plugins.Plugin\nimport nsc.plugins.PluginComponent\n\nclass DivByZero(val global: Global) extends Plugin {\n  import global._\n\n  val name = \"divbyzero\"\n  val description = \"checks for division by zero\"\n  val components = List[PluginComponent](Component)\n\n  private object Component extends PluginComponent {\n    val global: DivByZero.this.global.type = DivByZero.this.global\n    val runsAfter = List[String](\"refchecks\")\n    val phaseName = DivByZero.this.name\n    def newPhase(_prev: Phase) = new DivByZeroPhase(_prev)\n    class DivByZeroPhase(prev: Phase) extends StdPhase(prev) {\n      override def name = DivByZero.this.name\n      def apply(unit: CompilationUnit): Unit = {\n        for ( tree @ Apply(Select(rcvr, nme.DIV), List(Literal(Constant(0)))) <- unit.body\n             if rcvr.tpe <:< definitions.IntClass.tpe)\n          {\n            global.reporter.error(tree.pos, \"definitely division by zero\")\n          }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Variance Issues with Method Overloads and Type Bounds\nDESCRIPTION: Solutions to fix the variance checking errors in Scala 3 by using method overloads for default parameters and adding type bounds to inner classes. This approach maintains type safety while preserving functionality.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-type-checker.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass Foo[-A](x: List[A]) {\n  def f[B](y: List[B]): Unit = ???\n  def f(): Unit = f(x)\n}\n\nclass Outer[+A](x: A) {\n  class Inner[B >: A](y: B)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ParString Companion Object with Implicit CanBuildFrom and Builders in Scala\nDESCRIPTION: This Scala companion object for ParString defines implicit CanBuildFrom evidence allowing parallel transformer methods to construct new ParString collections. It provides methods newBuilder and newCombiner to create combiners (ParStringCombiner) that efficiently aggregate characters in parallel. The apply method builds a new ParString from variable character arguments, using a combiner for collection. Dependencies include the ParStringCombiner implementation and Scala parallel collection framework.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/custom-parallel-collections.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nobject ParString {\n  implicit def canBuildFrom: CanCombineFrom[ParString, Char, ParString] =\n    new CanCombinerFrom[ParString, Char, ParString] {\n      def apply(from: ParString) = newCombiner\n      def apply() = newCombiner\n    }\n\n  def newBuilder: Combiner[Char, ParString] = newCombiner\n\n  def newCombiner: Combiner[Char, ParString] = new ParStringCombiner\n\n  def apply(elems: Char*): ParString = {\n    val cb = newCombiner\n    cb ++= elems\n    cb.result\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Single-Line Method Definition in Java\nDESCRIPTION: Defines a simple Java method add that returns the sum of two int parameters. This method exemplifies a conventional one-statement Java method with a defined return type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_8\n\nLANGUAGE: Java\nCODE:\n```\npublic int add(int a, int b) {\n  return a + b;\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Pattern Matching Function in Scala REPL\nDESCRIPTION: Displays the output when calling the `getPrintableString` function with instances of `Student` and `Teacher` in the Scala REPL. This demonstrates that the pattern matching correctly identifies the case class type and extracts the values to produce the formatted string output. The REPL output is the same for Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_47\n\nLANGUAGE: Scala 2 and 3\nCODE:\n```\nscala> getPrintableString(s)\nres0: String = Al is a student in Year 1.\n\nscala> getPrintableString(t)\nres1: String = Bob Donnan teaches Mathematics.\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Lambda Syntax in Scala 3\nDESCRIPTION: Shows the syntax for type lambdas in Scala 3, which changed from using a single arrow to a double arrow to avoid conflicts with function types. Also demonstrates polymorphic function type syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/minutes/2019-06-08-sip-minutes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype A = [T] =>> List[T]\ndef id: [T] => T => T\n```\n\n----------------------------------------\n\nTITLE: Executing Parallel Filter Operation in Scala\nDESCRIPTION: Shows how to use the `filter` operation on a parallel sequence (`ParSeq`) to select elements based on a predicate (last names starting with 'J' or later). The filtering is performed concurrently across partitions of the collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/overview.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nscala> val lastNames = List(\"Smith\",\"Jones\",\"Frankenstein\",\"Bach\",\"Jackson\",\"Rodin\").par\nlastNames: scala.collection.parallel.immutable.ParSeq[String] = ParVector(Smith, Jones, Frankenstein, Bach, Jackson, Rodin)\n\nscala> lastNames.filter(_.head >= 'J')\nres0: scala.collection.parallel.immutable.ParSeq[String] = ParVector(Smith, Jones, Jackson, Rodin)\n```\n\n----------------------------------------\n\nTITLE: Defining a Value Class Extending a Universal Trait in Scala\nDESCRIPTION: Defines a case class `Meter` which is also a value class (`extends AnyVal`) and mixes in a universal trait `Distance` (which must extend `Any`). This structure is used to demonstrate scenarios where value class allocation becomes necessary, specifically when treating the value class instance as the universal trait type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ntrait Distance extends Any\ncase class Meter(value: Double) extends AnyVal with Distance\n```\n\n----------------------------------------\n\nTITLE: Manual Construction of Recursive Type Class Instance for List Using Byname in Scala\nDESCRIPTION: Demonstrates how to manually construct a type class instance Show[List[Int]] for a recursive type using byname parameters, enabling recursive references. Nested showGeneric and showPair calls refer to showListInt within their construction. Highlights the need for laziness/byname implicit parameters to break recursive cycles. Depends on defined Show instances for Int, Unit, and tuples.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval showListInt: Show[List[Int]] =\n  showGeneric(\n    generic[List[Int]],\n    showEither(\n      showGeneric(\n        generic[Cons[Int]],\n        showPair(\n          showInt,\n          showPair(\n            showListInt,\n            showUnit\n          )\n        )\n      ),\n      showUnit\n    )\n  )\n```\n\n----------------------------------------\n\nTITLE: Equivalent Map Operation in Java\nDESCRIPTION: Shows the Java equivalent of the Scala map operation, using streams and lambda expressions to double each element in a list.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-anonymous-functions.md#_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nList<Integer> ints = List.of(1, 2, 3);\nList<Integer> doubledInts = ints.stream()\n                                .map(i -> i * 2)\n                                .collect(Collectors.toList());\n```\n\n----------------------------------------\n\nTITLE: Implementation of Default Arguments in Scala\nDESCRIPTION: Explains how default arguments are implemented in Scala through synthetic methods. When a default argument is used, the compiler transforms the call to include the generated default method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-and-default-arguments.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ndef f(a: Int = 1, b: String)\n// generates a method: def f$default$1 = 1\nf(b = \"3\")\n// transformed to: f(b = \"3\", a = f$default$1)\n```\n\n----------------------------------------\n\nTITLE: Запуск тестов Scala через sbt в командной строке (Shell)\nDESCRIPTION: Показывает пример вывода команды `sbt test` при запуске набора тестов в Scala проекте. Демонстрируется успешный запуск теста CubeCalculator.cube с полной статистикой выполнения. Команда sbt должна запускаться в корневой директории проекта, где настроен build.sbt с зависимостью ScalaTest.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/getting-started/sbt-track/testing-scala-with-sbt-on-the-command-line.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nsbt test\n[info] Loading global plugins from /Users/username/.sbt/0.13/plugins\n[info] Loading project definition from /Users/username/workspace/sandbox/my-something-project/project\n[info] Set current project to scalatest-example (in build file:/Users/username/workspace/sandbox/my-something-project/)\n[info] CubeCalculatorTest:\n[info] - CubeCalculator.cube\n[info] Run completed in 267 milliseconds.\n[info] Total number of tests run: 1\n[info] Suites: completed 1, aborted 0\n[info] Tests: succeeded 1, failed 0, canceled 0, ignored 0, pending 0\n[info] All tests passed.\n[success] Total time: 1 s, completed Feb 2, 2017 7:37:31 PM\n```\n\n----------------------------------------\n\nTITLE: Actor Class Handling Speech Messages in Scala\nDESCRIPTION: An example actor class `Speak` that handles messages for starting, stopping, pausing, and resuming speech. Uses pattern matching within `receive` to handle different singleton message objects and a message class. This setup is typical in Akka actor systems.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/case-objects.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nclass Speak extends Actor {\n  def receive = {\n    case StartSpeakingMessage(textToSpeak) =>\n        // code to speak the text\n    case StopSpeakingMessage =>\n        // code to stop speaking\n    case PauseSpeakingMessage =>\n        // code to pause speaking\n    case ResumeSpeakingMessage =>\n        // code to resume speaking\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Circle Class in Scala\nDESCRIPTION: A simple case class representing a circle with x, y coordinates and a radius. This class is used to demonstrate extension methods in subsequent examples.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\ncase class Circle(x: Double, y: Double, radius: Double)\n```\n\n----------------------------------------\n\nTITLE: パターンマッチにおける抽出子マクロの利用例\nDESCRIPTION: このコードは文字列補間やパターンマッチに対して、動的に`unapply`を生成し、型に基づく高度なマッチングを実現する例を示す。`doTypedApply`メソッド内で`ExtractorType`と`unapply`を確認し、必要に応じてマクロ展開を行う仕組みを解説している。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/extractors.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef doTypedApply(tree: Tree, fun0: Tree, args: List[Tree], ...) = {\n  ...\n  fun.tpe match {\n    case ExtractorType(unapply) if mode.inPatternMode =>\n      if (unapply == QuasiquoteClass_api_unapply) macroExpandUnapply(...)\n      else doTypedUnapply(tree, fun0, fun, args, mode, pt)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Snippet Compiler in sbt\nDESCRIPTION: This Scala snippet demonstrates how to enable the snippet compiler feature within an sbt build configuration. The `-snippet-compiler:compile` option is added to the `scalacOptions` for the `Compile / doc` scope, instructing Scaladoc to compile all Scala code snippets found in the project's documentation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/snippet-compiler.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nCompile / doc / scalacOptions ++= Seq(\"-snippet-compiler:compile\")\n```\n\n----------------------------------------\n\nTITLE: Setting Up Collections for For Loops - JavaScript & Scala\nDESCRIPTION: Provides examples of how to define simple list/array collections in JavaScript and Scala, which are used as examples for demonstrating 'for' loops.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_25\n\nLANGUAGE: JavaScript\nCODE:\n```\n// JavaScript\nlet nums = [1, 2, 3];\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala\nval nums = List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Creating Mutable Array (Scala)\nDESCRIPTION: This Scala snippet demonstrates creating a mutable `Array` instance. A Scala `Array[A]` is a wrapper around a Java `A[]` array, providing mutable indexed access and also supporting Scala collection methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_60\n\nLANGUAGE: Scala\nCODE:\n```\nval a = Array(\"a\", \"b\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Scala 3 Macro for Source Location - Scala\nDESCRIPTION: This snippet shows a Scala 3 macro implementation of the 'location' method that provides file path and line number info at call site. The macro uses Scala 3 quotes API and needs 'scala.quoted.Quotes' and 'scala.quoted.Expr'. Dependencies include the inline macro mechanism and reflection to access position info. It requires Scala 3 and outputs a new instance of Location with the current file and line as parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-macro-mixing.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\npackage location\n\nimport scala.quoted.{Quotes, Expr}\n\ncase class Location(path: String, line: Int)\n\nobject Macros:\n  def location: Location = macro ???\n  inline def location: Location = ${locationImpl}\n\n  private def locationImpl(using quotes: Quotes): Expr[Location] =\n    import quotes.reflect.Position\n    val file = Expr(Position.ofMacroExpansion.sourceFile.jpath.toString)\n    val line = Expr(Position.ofMacroExpansion.startLine + 1)\n    '{new Location($file, $line)}\n```\n\n----------------------------------------\n\nTITLE: Defining the Main Entry Point in a Scala 2 Application - Scala\nDESCRIPTION: Shows how to define an object with a main entry point in Scala 2 using inheritance from the App trait. This code declares an object 'hello' which extends App and prints 'Hello, World!' to the console. The use of inheritance from App allows the object to serve as the application's main entry point. No additional dependencies are needed beyond the Scala standard library. Key parameter is the string passed to println. Output is the specified message in the console.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/add-guides.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nobject hello extends App {\n  println(\"Hello, World!\")\n}\n```\n\n----------------------------------------\n\nTITLE: General Method Invocation Syntax in Scala\nDESCRIPTION: Demonstrates the standard Scala convention for method invocation. There should be no space between the invocation target and the dot, the dot and the method name, or the method name and argument delimiters (parentheses). Arguments are separated by a comma followed by a single space.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/method-invocation.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nfoo(42, bar)\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntarget.foo(42, bar)\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntarget.foo()\n```\n\n----------------------------------------\n\nTITLE: Dependencies Requiring Version Update Output (Sbt Console)\nDESCRIPTION: This snippet shows the 'Versions to update' section from the `migrateDependencies` command output. It lists dependencies that have Scala 3 compatible versions available, indicating the recommended version. These require updating the version string in the `build.sbt` file.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/scala3-migrate.md#_snippet_4\n\nLANGUAGE: Sbt Console\nCODE:\n```\n[warn] <span style=\"color:orange\">Versions to update:</span>\n[warn] \"org.typelevel\" %% \"cats-core\" % \"<span style=\\\"color:orange\\\">2.6.1</span>\" <span style=\"color:orange\">(Other versions: 2.7.0, ..., 2.10.0)</span>\n[warn] \"org.scalameta\" %% \"munit\" % \"<span style=\\\"color:orange\\\">0.7.25</span>\" % Test <span style=\"color:orange\">(Other versions: 0.7.26, ..., 1.0.0-M8)</span>\n```\n\n----------------------------------------\n\nTITLE: Using Right-Ignoring Sequence Patterns in Scala\nDESCRIPTION: This example demonstrates a pattern matching implementation that identifies if a string contains 'scala' as a prefix. It uses the _* wildcard to match any remaining characters after 's','c','a','l','a' and binds them to the 'rest' variable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/regular-expression-patterns.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject RegExpTest1 extends App {\n  def containsScala(x: String): Boolean = {\n    val z: Seq[Char] = x\n    z match {\n      case Seq('s','c','a','l','a', rest @ _*) =>\n        println(\"rest is \"+rest)\n        true\n      case Seq(_*) =>\n        false\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Pattern Matching with Type Bounds\nDESCRIPTION: Solution to the pattern matching unsoundness by using type bounds to relax constraints while maintaining type safety. This approach works in both Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-type-checker.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef combineFetch[A](x: Fetch[_ <: A], y: Fetch[_ <: A]): Fetch[A] = Fetch(x.ids ++ y.ids)\n```\n\n----------------------------------------\n\nTITLE: Using Backticks for Escaping Identifiers in Scaladoc References\nDESCRIPTION: Shows how to use backticks to escape identifiers with special characters in Scaladoc references, which replaces the backslash escaping required in Scala 2.x versions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/linking.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef `([.abusive.])` = ???\n/** TODO: Figure out what [[`([.abusive.])`]] is. */\ndef foo = `([.abusive.])`\n```\n\n----------------------------------------\n\nTITLE: Ілюстрація перетворення типів при використанні списку - текстовий фрагмент Scala/Java\nDESCRIPTION: Фрагмент коду демонструє, як у JVM виконується приведення типів для отримання елемента з типізованого списку після стирання типів у байткоді. Перший рядок показує Java-подібне приведення типів, другий - більш відповідний синтаксису Scala. Ці рядки підкреслюють, що інформація про типи зберігається та застосовується лише на рівні компіляції, а на рівні виконання JVM вона відсутня.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/scala3/guides/tasty-overview.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nint x = (Int) xs.get(0)               // Java-подібно\nval x = xs.get(0).asInstanceOf[Int]   // більш Scala-подібно\n```\n\n----------------------------------------\n\nTITLE: Basic Directory Structure Example for Scaladoc Static Site\nDESCRIPTION: Shows the basic file structure for a simple \"Hello World\" static site generated with Scaladoc, including the site root with documentation files.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/static-site.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n.\n└── <site-root>/\n    └── _docs/\n        ├── index.html\n        └── getting-started.html\n```\n\n----------------------------------------\n\nTITLE: Compatibility Issues with Named Tuples - Method Parameter vs. Tuple\nDESCRIPTION: Shows a compatibility issue where a named parameter in a method call could be misinterpreted as a named tuple when using infix notation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-tuples.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nclass C:\n  infix def f(age: Int)\nval c: C\n\nc f (age = 1)\n```\n\n----------------------------------------\n\nTITLE: Using import within function scope in Scala 3\nDESCRIPTION: Shows equivalent Scala 3 syntax for local import statements inside a function, allowing for cleaner namespace management and clearer, context-specific dependency inclusion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/packages-and-imports.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ndef sqrtplus1(x: Int) =\n  import scala.math.sqrt\n  sqrt(x) + 1.0\n```\n\n----------------------------------------\n\nTITLE: Multi-line if statement in Scala 2 and 3\nDESCRIPTION: Syntax for multi-line if statements in both Scala versions, showing how Scala 3 uses the 'then' keyword to introduce the code block instead of parentheses and braces.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/control-structures.md#_snippet_1\n\nLANGUAGE: Scala 2\nCODE:\n```\nif (x == 1) {\n  println(\"x is 1, as you can see:\")\n  println(x)\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nif x == 1 then\n  println(\"x is 1, as you can see:\")\n  println(x)\n```\n\n----------------------------------------\n\nTITLE: Multi-line method example in Scala 2 and Scala 3\nDESCRIPTION: Demonstrates defining a multi-line method to convert a Throwable's stack trace to a String, with syntax differences between Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-methods.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nScala 2:\ndef getStackTraceAsString(t: Throwable): String = {\n  val sw = new StringWriter\n  t.printStackTrace(new PrintWriter(sw))\n  sw.toString\n}\n\nScala 3:\ndef getStackTraceAsString(t: Throwable): String =\n  val sw = new StringWriter\n  t.printStackTrace(new PrintWriter(sw))\n  sw.toString\n```\n\n----------------------------------------\n\nTITLE: Subclassing Traverser to Collect Apply Nodes in Scala Reflection Trees\nDESCRIPTION: This code defines an object that extends the Traverser class and overrides the traverse method to collect all Apply nodes encountered in a tree. It maintains a mutable List[Apply] to store found nodes, pattern matches each node, and recursively traverses both function and argument subtrees by calling super.traverse and super.traverseTrees. Prerequisites: import scala.reflect.runtime.universe._ and availability of a target Tree; outputs are collected in traverser.applies, and traversal initiated by traverser.traverse(tree).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\nobject traverser extends Traverser {\n  var applies = List[Apply]()\n  override def traverse(tree: Tree): Unit = tree match {\n    case app @ Apply(fun, args) =>\n      applies = app :: applies\n      super.traverse(fun)\n      super.traverseTrees(args)\n    case _ => super.traverse(tree)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Immutable Scala Collections to Java Collections\nDESCRIPTION: Demonstrates converting an immutable Scala List to a java.util.List. When trying to modify the resulting Java collection, an UnsupportedOperationException is thrown because the underlying Scala collection is immutable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/conversions-between-java-and-scala-collections.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval jul = List(1, 2, 3).asJava\n\njul.add(7)\n// Throws java.lang.UnsupportedOperationException\n```\n\n----------------------------------------\n\nTITLE: Сигнатура асинхронного вызова с Future в Scala\nDESCRIPTION: Пример определения функции, возвращающей Future[Int], и её вызова. Значение x будет доступно только после завершения задачи.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/concurrency.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef aLongRunningTask(): Future[Int] = ???\nval x = aLongRunningTask()\n```\n\n----------------------------------------\n\nTITLE: If-else statement in Scala 2 and 3\nDESCRIPTION: Comparison of if-else statement syntax, demonstrating the cleaner structure in Scala 3 that uses 'then' and 'else' keywords without requiring parentheses or braces.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/control-structures.md#_snippet_2\n\nLANGUAGE: Scala 2\nCODE:\n```\nif (x == 1) {\n  println(\"x is 1, as you can see:\")\n  println(x)\n} else {\n  println(\"x was not 1\")\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nif x == 1 then\n  println(\"x is 1, as you can see:\")\n  println(x)\nelse\n  println(\"x was not 1\")\n```\n\n----------------------------------------\n\nTITLE: Concatenating Collections in Scala\nDESCRIPTION: Demonstrates concatenation of two Scala collections 'a' and 'b' using the '++' operator. Produces a new collection combining elements from both collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval c = a ++ b\n```\n\n----------------------------------------\n\nTITLE: Using Mutable Stacks in Scala\nDESCRIPTION: Demonstrates operations on a mutable Stack including push, top, and pop. The mutable Stack updates in place when elements are added or removed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/concrete-mutable-collection-classes.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval stack = new scala.collection.mutable.Stack[Int]           \nstack.push(1)\nstack\nstack.push(2)\nstack\nstack.top\nstack\nstack.pop    \nstack\n```\n\n----------------------------------------\n\nTITLE: Class Extending Multiple Traits in Scala\nDESCRIPTION: Creating a class that extends multiple traits, implementing all their abstract members and inheriting concrete implementations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nclass IrishSetter(name: String) extends HasLegs with HasTail {\n  val numLegs = 4\n  val tailColor = \"Red\"\n  def walk() = println(\"I'm walking\")\n  override def toString = s\"$name is a Dog\"\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nclass IrishSetter(name: String) extends HasLegs, HasTail:\n  val numLegs = 4\n  val tailColor = \"Red\"\n  def walk() = println(\"I'm walking\")\n  override def toString = s\"$name is a Dog\"\n```\n\n----------------------------------------\n\nTITLE: Scala 2 Generated unapply Method\nDESCRIPTION: Shows the Option-based unapply method signature that Scala 2 automatically generates for case classes, returning the components wrapped in Some.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-other-changes.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nobject Location {\n  def unapply(location: Location): Option[(Double, Double)] = Some((location.lat, location.long))\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Higher-Order Functions in Scala\nDESCRIPTION: Example of chaining multiple higher-order functions together to solve a problem, showing how filter, takeWhile, and map can be combined in a functional pipeline.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-methods.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// yields `List(100, 200)`\na.filter(_ < 40)\n .takeWhile(_ < 30)\n .map(_ * 10)\n```\n\n----------------------------------------\n\nTITLE: Embedding Expressions in String Interpolations\nDESCRIPTION: Shows how to include complex expressions within string literals using `${}` syntax for dynamic output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-vars-data-types.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nprintln(s\"2 + 2 = ${2 + 2}\")   // prints \"2 + 2 = 4\"\n\nval x = -1\nprintln(s\"x.abs = ${x.abs}\")   // prints \"x.abs = 1\"\n```\n\n----------------------------------------\n\nTITLE: Working with Tuples in Scala\nDESCRIPTION: Examples of creating and accessing elements in Scala tuples, which can contain different types of data in a single collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_35\n\nLANGUAGE: scala\nCODE:\n```\nval a = (\"eleven\")\nval b = (\"eleven\", 11)\nval c = (\"eleven\", 11, 11.0)\nval d = (\"eleven\", 11, 11.0, Person(\"Eleven\"))\n```\n\nLANGUAGE: scala\nCODE:\n```\nd(0)   // \"eleven\"\nd(1)   // 11\n```\n\n----------------------------------------\n\nTITLE: Map Operation Using List Comprehension in Python\nDESCRIPTION: Demonstrates a Python list comprehension that multiplies each element of 'numbers' by 10, producing a new list 'x' with scaled values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_25\n\nLANGUAGE: Python\nCODE:\n```\nx = [i * 10 for i in numbers]\n```\n\n----------------------------------------\n\nTITLE: Using reduce with a helper method in Scala\nDESCRIPTION: Demonstration of the reduce method with a helper function, showing how elements are processed in sequence to produce a single result.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-methods.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nscala> a.reduce(add)\nreceived 1 and 2, their sum is 3\nreceived 3 and 3, their sum is 6\nreceived 6 and 4, their sum is 10\nres0: Int = 10\n```\n\n----------------------------------------\n\nTITLE: Defining Unhygienic Macro - Scala\nDESCRIPTION: Defines a simple Scala macro `MyMacro.apply` and its implementation `impl`. The macro generates code `q\"wrapper($x)\"`. This setup is used to illustrate how an unqualified reference to `wrapper` within the generated code can be accidentally captured by a definition of `wrapper` at the macro's call site, breaking referential transparency.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/hygiene.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n// ---- MyMacro.scala ----\npackage example\n\nimport scala.reflect.macros.blackbox.Context\nimport scala.language.experimental.macros\n\nobject MyMacro {\n  def wrapper(x: Int) = { println(s\"wrapped x = $x\"); x }\n  def apply(x: Int): Int = macro impl\n  def impl(c: Context)(x: c.Tree) = {\n    import c.universe._\n    q\"wrapper($x)\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Singleton Object Methods in Scala\nDESCRIPTION: Shows how to call methods directly on a singleton object. The example demonstrates accessing the isNullOrEmpty method from the StringUtils object with different string inputs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-objects.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval x = StringUtils.isNullOrEmpty(\"\")    // true\nval x = StringUtils.isNullOrEmpty(\"a\")   // false\n```\n\n----------------------------------------\n\nTITLE: Deriving Semigroup Instances Generically Using Shapeless Generic in Scala\nDESCRIPTION: Provides an implicit method to derive a Semigroup instance for any type T if there exists a shapeless Generic mapping T to representation R, and a Semigroup instance for R. The combine method transforms Ts into their representations, combines them, and reconstructs T. Requires shapeless and its Generic type class, as well as Semigroup instances for the representation types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit def genericSemigroup[T, R]\n  (implicit\n    gen: Generic.Aux[T, R]\n    sr:  Semigroup[R]):\n         Semigroup[T] =\n  new Semigroup[T] {\n    def combine(x: T, y: T): T =\n      gen.from(sr.combine(gen.to(x), gen.to(y)))\n  }\n\n// A case class with a Generic instance\ncase class Foo(i: Int, s: String)\n\nimplicitly[Semigroup[Foo]]\n```\n\n----------------------------------------\n\nTITLE: Creating tuples in Python and Scala\nDESCRIPTION: Shows syntax for defining tuples containing heterogeneous elements. Python tuples use parentheses with comma-separated values. Scala tuples are similarly created with parentheses. Useful for grouping related values without defining classes or structures.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_61\n\nLANGUAGE: python\nCODE:\n```\nt = (11, 11.0, \"Eleven\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nval t = (11, 11.0, \"Eleven\")\n```\n\n----------------------------------------\n\nTITLE: Defining Entry class for iterative square root calculation in Scala\nDESCRIPTION: This Scala class defines an Entry data structure to hold a number and its current square root approximation for iterative computations. It initializes with a specific number and updates during the square root approximation process, supporting the Babylonian method with reachability to convergence and removal from a results map once the value stabilizes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/parallel-collections/ctries.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Entry(num: Double) {\n  var sqrt = num\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Class Inheritance in Scala\nDESCRIPTION: Demonstrates class inheritance in Scala using the `extends` keyword. Class `C` inherits from class `D`, gaining access to its non-private members.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/cheatsheets/index.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nclass C extends D { /* subclass members */ }\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Pattern Guard in Scala\nDESCRIPTION: Demonstrates using a pattern guard in a match expression to add additional conditions to a pattern case. In this example, the case will only match if x is an even number.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_glossary/index.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase x if x % 2 == 0 => x + 1\n```\n\n----------------------------------------\n\nTITLE: Removing Specific Element from Buffer in Scala\nDESCRIPTION: Removes the first occurrence of a specific element 'x' from the buffer 'buf'. If the element appears multiple times, only the first one found is removed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/seqs.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nbuf -= x\n```\n\n----------------------------------------\n\nTITLE: Using Generic Stack with Integer Type in Scala 2\nDESCRIPTION: Example of instantiating and using a generic Stack with Integer type in Scala 2. The example shows pushing values onto the stack and popping them off.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/tour/generic-classes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval stack = new Stack[Int]\nstack.push(1)\nstack.push(2)\nprintln(stack.pop())  // выведет 2\nprintln(stack.pop())  // выведет 1\n```\n\n----------------------------------------\n\nTITLE: Using `foreach` with an Explicit Anonymous Function in Scala\nDESCRIPTION: Demonstrates using the `foreach` method on a `List` with an explicit anonymous function `(i: Int) => println(i)` to perform an action (printing) for each element.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-anonymous-functions.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nints.foreach((i: Int) => println(i))\n```\n\n----------------------------------------\n\nTITLE: Compiling a Scala Source File using scalac\nDESCRIPTION: Shows the command-line instruction to compile a Scala source file (`HelloWorld.scala`) using the `scalac` compiler, which generates standard Java `.class` files.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tutorials/scala-for-java-programmers.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nscalac HelloWorld.scala\n```\n\n----------------------------------------\n\nTITLE: Using `foreach` with a Simplified Anonymous Function in Scala\nDESCRIPTION: Shows a simplified anonymous function `i => println(i)` used with `foreach`, omitting the explicit type and parentheses for the single parameter `i`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-anonymous-functions.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nints.foreach(i => println(i))\n```\n\n----------------------------------------\n\nTITLE: Creating an Anonymous Class Instance in Scala\nDESCRIPTION: Illustrates the syntax `new { ... }` for creating an instance of an anonymous class in Scala. This is useful for one-off implementations or simple overrides without defining a named class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/cheatsheets/index.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nnew { /* implementation details */ }\n```\n\n----------------------------------------\n\nTITLE: 微分演算のためのパターンマッチ関数（微分の定義）\nDESCRIPTION: 式を変数に関して微分する関数。SumとVarに対応し、定数の場合は0を返す。Varのガードを用いて、変数名と微分対象の変数名を比較し、条件に応じた微分結果を返す。パターンマッチとガードの利用例を示す。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tutorials/scala-for-java-programmers.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef derive(t: Tree, v: String): Tree = t match {\n  case Sum(l, r) => Sum(derive(l, v), derive(r, v))\n  case Var(n) if (v == n) => Const(1)\n  case _ => Const(0)\n}\n```\n\n----------------------------------------\n\nTITLE: Single-line for Loop Over Collection in Java\nDESCRIPTION: Loops over elements in collection ints using enhanced for-loop, printing each element, illustrating common Java iteration syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_39\n\nLANGUAGE: java\nCODE:\n```\nfor (int i: ints) {\n  System.out.println(i);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Instance of Scala 'Person' Case Class\nDESCRIPTION: Shows instantiating a 'Person' case class object, illustrating the simplified constructor syntax inherent to case classes, suitable for immutable data representation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-tools.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\nval christina = Person(\"Christina\", \"niece\")\n```\n\n----------------------------------------\n\nTITLE: Calling an Extension Method in Scala 3\nDESCRIPTION: Shows the concise syntax for calling the `circumference` extension method directly on an instance (`aCircle`) of the `Circle` class, as if it were a native method of the class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/ca-extension-methods.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\naCircle.circumference\n```\n\n----------------------------------------\n\nTITLE: Defining and Reassigning Variables with 'var'\nDESCRIPTION: Illustrates variable declarations with 'var' allowing reassignment, including explicit type annotation, and demonstrating mutable state.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/basics.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nvar x = 1 + 1\nx = 3\nprintln(x * x)\n// x: Int = 3\n```\n\n----------------------------------------\n\nTITLE: Showcasing Type Inference with Static Typing in Scala\nDESCRIPTION: This snippet provides examples demonstrating how Scala's powerful type inference allows code to feel dynamically typed while retaining the benefits of static typing. Variables and complex expressions, including collection operations and for-comprehensions, are typed by the compiler without explicit type annotations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-features.md#_snippet_5\n\nLANGUAGE: Scala 2\nCODE:\n```\nval s = \"Hello\"\nval p = Person(\"Al\", \"Pacino\")\nval sum = nums.reduceLeft(_ + _)\nval y = for (i <- nums) yield i * 2\nval z = nums\n  .filter(_ > 100)\n  .filter(_ < 10_000)\n  .map(_ * 2)\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nval s = \"Hello\"\nval p = Person(\"Al\", \"Pacino\")\nval sum = nums.reduceLeft(_ + _)\nval y = for i <- nums yield i * 2\nval z = nums\n  .filter(_ > 100)\n  .filter(_ < 10_000)\n  .map(_ * 2)\n```\n\n----------------------------------------\n\nTITLE: Control Structures in Scala\nDESCRIPTION: Control flow constructs in Scala including conditionals, loops, and comprehensive for comprehensions with filtering, mapping, and cross-product operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/cheatsheets/index.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nif (check) happy else sad\n```\n\nLANGUAGE: scala\nCODE:\n```\nwhile (x < 5) { println(x); x += 1}\n```\n\nLANGUAGE: scala\nCODE:\n```\ndo { println(x); x += 1} while (x < 5)\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.util.control.Breaks._\nbreakable {\n    for (x <- xs) {\n        if (Math.random < 0.1) break\n    }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor (x <- xs if x%2 == 0) yield x*10\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor ((x,y) <- xs zip ys) yield x*y\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor (x <- xs; y <- ys) yield x*y\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor (x <- xs; y <- ys) {\n    println(\"%d/%d = %.1f\".format(x, y, x/y.toFloat))\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor (i <- 1 to 5) {\n    println(i)\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor (i <- 1 until 5) {\n    println(i)\n}\n```\n\n----------------------------------------\n\nTITLE: If-else expressions returning values in Scala 2 and 3\nDESCRIPTION: Demonstration of how if-else can be used as an expression that returns a value, eliminating the need for a ternary operator in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/control-structures.md#_snippet_5\n\nLANGUAGE: Scala 2\nCODE:\n```\nval minValue = if (a < b) a else b\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nval minValue = if a < b then a else b\n```\n\n----------------------------------------\n\nTITLE: Match Expression with Selector in Scala\nDESCRIPTION: Shows the structure of a match expression in Scala where 's' is the selector (the value being matched) and the underscore is a wildcard pattern that matches anything.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_glossary/index.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ns match { case _ => }\n```\n\n----------------------------------------\n\nTITLE: Simple for loops in Scala 2 and 3\nDESCRIPTION: Basic for loop syntax comparison between Scala versions, showing how to iterate over a sequence of integers and print each value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/control-structures.md#_snippet_7\n\nLANGUAGE: Scala 2\nCODE:\n```\nval ints = Seq(1, 2, 3)\nfor (i <- ints) println(i)\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nval ints = Seq(1, 2, 3)\nfor i <- ints do println(i)\n```\n\n----------------------------------------\n\nTITLE: Multiple Forms of Anonymous Functions\nDESCRIPTION: Demonstrates various syntactic forms for writing the same anonymous function to double integers, from explicit to more concise.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-anonymous-functions.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval doubledInts = ints.map((i: Int) => i * 2)\nval doubledInts = ints.map((i) => i * 2)\nval doubledInts = ints.map(i => i * 2)\n```\n\n----------------------------------------\n\nTITLE: Using Type Inference for Private Fields in Scala\nDESCRIPTION: Demonstrates when to use type inference for private fields, where type information is evident from the assigned value. The type should be inferred in this case.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/types.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nprivate val name = \"Daniel\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Equality Comparisons with CanEqual in Scala 3\nDESCRIPTION: This snippet shows two ways to enable equality comparisons between instances of the same class using the CanEqual type class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/ca-multiversal-equality.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n// Способ 1\ncase class Dog(name: String) derives CanEqual\n```\n\nLANGUAGE: scala\nCODE:\n```\n// Способ 2\ncase class Dog(name: String)\ngiven CanEqual[Dog, Dog] = CanEqual.derived\n```\n\n----------------------------------------\n\nTITLE: Attempted Reassignment to Immutable Variable in Scala\nDESCRIPTION: Shows the compiler error that occurs when attempting to reassign a value to an immutable (val) variable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-vars-data-types.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval msg = \"Hello, world\"\nmsg = \"Aloha\"   // \"reassignment to val\" error; this won't compile\n```\n\n----------------------------------------\n\nTITLE: Creating Immutable Case Classes in Scala\nDESCRIPTION: Demonstrates how to define an immutable Person case class where constructor parameters are val by default, making them immutable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fp-immutable-values.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncase class Person(firstName: String, lastName: String)\n```\n\n----------------------------------------\n\nTITLE: Using Short Local Variable Names in Simple Scala Methods\nDESCRIPTION: Explains and exemplifies the Scala convention of using very short names (e.g., 'a', 'b') for parameters and local variables within short, simple methods. This practice enhances brevity and relies on the short scope and descriptive types for clarity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/naming-conventions.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\ndef add(a: Int, b: Int) = a + b\n```\n\n----------------------------------------\n\nTITLE: Illustrating Shapeless `Lazy` for Dependent Type Paths (Scala)\nDESCRIPTION: Shows a common pattern in shapeless using `Lazy[Foo]`. It defines a `Foo` trait with a dependent type `Out` and an implicit `bar` that accesses this type via `foo.value.Out`. `Lazy` ensures `foo.value` is a stable path, allowing access to the dependent type member.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\ntrait Foo {\n  type Out\n  def out: Out\n}\n\nobject Test {\n  implicit def bar(implicit foo: Lazy[Foo]): foo.value.Out =\n    foo.value.out\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Type of Animal Instance via Helper\nDESCRIPTION: Uses the `getType` helper function on the previously created `Animal` instance. It correctly returns the reflection `Type` corresponding to the `Animal` class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nscala> getType(a)\nres: scala.reflect.runtime.universe.Type = Animal\n```\n\n----------------------------------------\n\nTITLE: Defining Recursive Tuple Type Mapping Using Scala 3 Match Types and Type Constructors in Scala\nDESCRIPTION: This Scala type alias `InverseMap` recursively converts a tuple of types of the form `(F[T1], ..., F[Tn])` to a tuple `(T1, ..., Tn)` by pattern matching on the tuple structure and applying the inverse of a type constructor `F[_]`. It requires `X` to be a subtype of `Tuple` and `F` to be a unary type constructor. The first case matches a non-empty tuple beginning with `F[x]`, extracting `x` and reapplying `InverseMap` to the rest of the tuple `t`. The second case handles the empty tuple, terminating recursion. The placeholder type constructor `F[_]` must be a concrete kind where `F[x]` is valid; using abstract or illegal type constructors can cause type checking errors deep in the compiler's processing. This snippet demonstrates advanced dependent type programming and type-level recursion in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/match-types-spec.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\n/** Converts a tuple `(F[T1], ..., F[Tn])` to `(T1,  ... Tn)` */\ntype InverseMap[X <: Tuple, F[_]] <: Tuple = X match {\n  case F[x] *: t => x *: InverseMap[t, F]\n  case EmptyTuple => EmptyTuple\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait with an Abstract Type Member in Scala\nDESCRIPTION: This snippet defines a trait 'Buffer' with an abstract type 'T' and a value 'element' of that type. It demonstrates how to declare an abstract type that will be specified in subclasses or instances, laying the groundwork for flexible type definitions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/abstract-type-members.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Buffer {\n  type T\n  val element: T\n}\n```\n\n----------------------------------------\n\nTITLE: Using Callbacks for Currency Purchase with Scala Futures\nDESCRIPTION: Shows how to perform asynchronous currency rate fetching and conditional purchase using nested Futures and onSuccess callbacks. It demonstrates the callback-based approach to Futures where one future's success triggers creation and execution of another future. The snippet depends on a currency connection API and methods like getCurrentValue and buy. Inputs include the currency (USD) and the amount. The output is a Future representing the purchase process. The snippet illustrates the inconvenience of nested callbacks and scope limitations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/futures-promises.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval rateQuote = Future {\n  connection.getCurrentValue(USD)\n}\n\nrateQuote onSuccess { case quote =>\n  val purchase = Future {\n    if (isProfitable(quote)) connection.buy(amount, quote)\n    else throw new Exception(\"not profitable\")\n  }\n\n  purchase onSuccess {\n    case _ => println(\"Purchased \" + amount + \" USD\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Desugaring Scala 3 enum into sealed class and case objects\nDESCRIPTION: This code illustrates manual desugaring of a Scala 3 enum 'Color' into a sealed abstract class with case object and case class extensions, including an 'ordinal' method and 'fromOrdinal' factory. It demonstrates how enums are represented as sealed class hierarchies under the hood.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-adts-gadts.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nsealed abstract class Color(val rgb: Int) extends scala.reflect.Enum\nobject Color:\n  case object Red extends Color(0xFF0000) { def ordinal = 0 }\n  case object Green extends Color(0x00FF00) { def ordinal = 1 }\n  case object Blue extends Color(0x0000FF) { def ordinal = 2 }\n  case class Mix(mix: Int) extends Color(mix) { def ordinal = 3 }\n\n  def fromOrdinal(ordinal: Int): Color = ordinal match\n    case 0 => Red\n    case 1 => Green\n    case 2 => Blue\n    case _ => throw new NoSuchElementException(ordinal.toString)\n```\n\n----------------------------------------\n\nTITLE: Structural Type Definition in Scala\nDESCRIPTION: Shows a structural type in Scala that describes any object with a close() method returning Unit. This enables duck typing for closeable resources.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_glossary/index.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n{ def close(): Unit }\n```\n\n----------------------------------------\n\nTITLE: For loops with guards in Scala 2 and 3\nDESCRIPTION: Adding conditional guards to for loops to filter iterations, showing how to only process elements that meet specific criteria.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/control-structures.md#_snippet_10\n\nLANGUAGE: Scala 2\nCODE:\n```\nfor {\n  i <- 1 to 5\n  if i % 2 == 0\n} {\n  println(i)\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nfor\n  i <- 1 to 5\n  if i % 2 == 0\ndo\n  println(i)\n```\n\n----------------------------------------\n\nTITLE: Scala Class Instantiation with Constructor in Scala 3\nDESCRIPTION: Object instantiation in Scala 3 without 'new', utilizing the apply method generated by the case class or class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-modeling.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\n// this code uses that constructor\nval p = Person(\"John\", \"Stephens\")\n```\n\n----------------------------------------\n\nTITLE: Importing a specific 'given' type in Scala\nDESCRIPTION: Shows how to import a single 'given' type TC from object A, emphasizing precise import of specific 'given' types to clarify dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/packaging-imports.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nimport A.{given TC}\n```\n\n----------------------------------------\n\nTITLE: Control Constructs in Scala\nDESCRIPTION: Details conditional expressions, loops, and flow control statements, including if-else, while, do-while, break, and for comprehensions with filtering and pattern matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/cheatsheets/index.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nif (check) happy else sad\n```\n\nLANGUAGE: Scala\nCODE:\n```\nif (check) happy\n// same as\n// if (check) happy else ()\n```\n\nLANGUAGE: Scala\nCODE:\n```\nwhile (x < 5) {\n  println(x)\n  x += 1\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndo {\n  println(x)\n  x += 1\n} while (x < 5)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.util.control.Breaks._\nbreakable {\n  for (x <- xs) {\n    if (Math.random < 0.1)\n      break\n  }\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor (x <- xs if x % 2 == 0)\n  yield x * 10\n// same as\n// xs.filter(_ % 2 == 0).map(_ * 10)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor ((x, y) <- xs zip ys)\n  yield x * y\n// same as\n// (xs zip ys) map {\n//   case (x, y) => x * y\n// }\n```\n\nLANGUAGE: Scala\nCODE:\n```\nfor (x <- xs; y <- ys)\n  yield x * y\n// same as\n// xs.flatMap(x => ys.map(y => x * y))\n```\n\n----------------------------------------\n\nTITLE: 変数の定義と再代入 - Scala\nDESCRIPTION: varキーワードによる可変変数の宣言例です。初期化後に値を変更可能であることを示しており、再代入後の値を元に計算し出力しています。型推論や明示的な型指定が可能です。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nvar x = 1 + 1\nx = 3 // \"x\"は\"var\"キーワードで宣言されているので、これはコンパイルされます。\nprintln(x * x) // 9\n```\n\n----------------------------------------\n\nTITLE: Defining a Marker Interface in Java\nDESCRIPTION: In Java, a marker interface is an interface with no methods or constants. It is used to 'mark' classes that implement it, indicating a property or capability.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_18\n\nLANGUAGE: Java\nCODE:\n```\npublic interface Marker {};\n```\n\n----------------------------------------\n\nTITLE: 値クラスのインスタンスが必要となる状況（例）\nDESCRIPTION: `Meter`値クラスのインスタンスは、型として扱うときや配列に代入、パターンマッチング時に実体化される。例として`Meter(3.4)`や`Array[Meter](m)`、パターンマッチングの際にインスタンスが生成される例を示す。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/value-classes.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval m = Meter(5.0)\nval array = Array[Meter](m)\n\ncase class P(val i: Int) extends AnyVal\n\nval p = new P(3)\np match { \n  case P(3) => println(\"Matched 3\")\n  case P(x) => println(\"Not 3\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using '+' as an Infix Operator in Scala\nDESCRIPTION: Shows the more common and readable infix notation for the '+' operator when applied to integer literals. This is syntactic sugar for the method call.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/operators.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n10 + 1\n```\n\n----------------------------------------\n\nTITLE: Явное объявление типов в Scala\nDESCRIPTION: Пример того, как явно объявить типы переменных в Scala. Показывает объявление переменных с явным указанием их типов (Int и Double).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-inferred.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval x: Int = 1\nval y: Double = 1\n```\n\n----------------------------------------\n\nTITLE: Force Rebuilding Docker Image for Scala Documentation\nDESCRIPTION: Command to completely rebuild the Docker image from scratch by skipping the cache, useful when troubleshooting Docker-related issues.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nenv UID=\"$(id -u)\" GID=\"$(id -g)\" docker-compose build --no-cache\n```\n\n----------------------------------------\n\nTITLE: Example of Page Redirection with redirectFrom Property\nDESCRIPTION: Demonstrates how to set up page redirection using the redirectFrom property to maintain old URLs when content is moved.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/static-site.md#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n---\nredirectFrom: /absolute/path/to/old/url.html\n---\n```\n\n----------------------------------------\n\nTITLE: Accessing Tuple Elements by Position in Scala\nDESCRIPTION: Shows how to access individual elements of a tuple using the positional notation _1, _2, etc.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/tuples.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nprintln(ingrediente._1) // Açucar\nprintln(ingrediente._2) // 25\n```\n\n----------------------------------------\n\nTITLE: Assigning Variable Using Ternary Operator in Java\nDESCRIPTION: Assigns the smaller of two integers to a variable minVal using Java's ternary conditional operator for concise conditional assignment.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_35\n\nLANGUAGE: java\nCODE:\n```\nint minVal = (a < b) ? a : b;\n```\n\n----------------------------------------\n\nTITLE: Adding Generic Type Parameter to `map` Function Signature\nDESCRIPTION: Adds the generic type parameter `[A]` to the Scala `map` function definition. This declares the type `A` used in the function argument `f`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-write-map-function.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef map[A](f: (Int) => A)\n```\n\n----------------------------------------\n\nTITLE: XML Literals Syntax Example in Scala\nDESCRIPTION: Example of XML literals directly embedded in Scala code that might be removed in favor of string interpolators like xml\"\"\"...\"\"\".\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/minutes/2018-08-30-sip-minutes.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nxml\"\"\"<button ...></button>\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Immutable Field Declaration in Java\nDESCRIPTION: Declares a final integer field i initialized to 1. The final modifier ensures the field is immutable after initialization, enforcing constancy at the language level.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_12\n\nLANGUAGE: Java\nCODE:\n```\nfinal int i = 1;\n```\n\n----------------------------------------\n\nTITLE: Doubling List Elements Using Shorthand Anonymous Function\nDESCRIPTION: Uses map with a concise anonymous function to double each element in the list, showcasing the underscore shorthand notation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-anonymous-functions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval doubledInts = ints.map(_ * 2)    // List(2, 4, 6)\n```\n\n----------------------------------------\n\nTITLE: Error Handling with Partial Functions in Scala\nDESCRIPTION: Shows what happens when you apply a partial function to an argument outside its domain, resulting in a MatchError exception at runtime.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/fun-partial-functions.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndoubledOdds(4)  // Exception in thread \"main\" scala.MatchError: 4\n```\n\n----------------------------------------\n\nTITLE: Running a Scala application with and without arguments\nDESCRIPTION: Examples showing how to run a compiled Scala application, demonstrating both cases with and without command-line arguments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/hello-world-2.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n$ scala HelloYou\nHello, you\n\n$ scala HelloYou Al\nHello, Al\n```\n\n----------------------------------------\n\nTITLE: Leading Infix Operators Example\nDESCRIPTION: Demonstrates the difference in handling continuation of expressions with leading infix operators on separate lines between Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tooling-scala2-xsource3.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef f =\n  1\n  + 2\n```\n\n----------------------------------------\n\nTITLE: 案例：数字抽象表示模块定义\nDESCRIPTION: 定义一个`Nums` trait，抽象定义数字类型`Num`和操作`lit`、`add`、`mul`，支持实现不同的数值表达。其中`type Num`可以由具体实现确定，提供灵活的数值表示策略。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-dependent-function.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Nums:\n  // 数字类型的抽象\n  type Num\n\n  // 数字操作\n  def lit(d: Double): Num\n  def add(l: Num, r: Num): Num\n  def mul(l: Num, r: Num): Num\n\n```\n\n----------------------------------------\n\nTITLE: Equivalent Java Stream Operation\nDESCRIPTION: Shows how the Scala map operation with an anonymous function compares to Java's stream API with a lambda expression.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-anonymous-functions.md#_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nList<Integer> ints = List.of(1, 2, 3);\nList<Integer> doubledInts = ints.stream()\n                                .map(i -> i * 2)\n                                .collect(Collectors.toList());\n```\n\n----------------------------------------\n\nTITLE: Defining a Java annotation with multiple elements\nDESCRIPTION: Defines a standard Java annotation interface with multiple abstract methods, which represent the elements of the annotation. These elements must be initialized when the annotation is applied.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/annotations.md#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\n@interface Source {\n  public String url();\n  public String mail();\n}\n```\n\n----------------------------------------\n\nTITLE: Rebuilding Docker Image for Scala Documentation\nDESCRIPTION: Command to rebuild the Docker image when dependencies change, ensuring the container has the latest requirements specified in the Gemfile.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nenv UID=\"$(id -u)\" GID=\"$(id -g)\" docker-compose up --build\n```\n\n----------------------------------------\n\nTITLE: Type Information and Runtime Type Operations in Scala\nDESCRIPTION: Examples of accessing class information and performing runtime type checks and conversions. Shows methods for reflection, instance checking, type casting, and compile-time type ascription.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/cheatsheets/index.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nclassOf[String]\n```\n\nLANGUAGE: scala\nCODE:\n```\nx.isInstanceOf[String]\n```\n\nLANGUAGE: scala\nCODE:\n```\nx.asInstanceOf[String]\n```\n\nLANGUAGE: scala\nCODE:\n```\nx: String\n```\n\n----------------------------------------\n\nTITLE: Using Java Annotation in Java Class\nDESCRIPTION: Example of applying the Source annotation to a Java class, specifying values for the required URL and mail elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/annotations.md#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\n@Source(URL = \"https://coders.com/\",\n        mail = \"support@coders.com\")\npublic class MyClass extends HisClass ...\n```\n\n----------------------------------------\n\nTITLE: Comparing WrappedArray and ArrayOps Implicit Conversions (REPL)\nDESCRIPTION: Contrasts the two implicit conversion mechanisms for arrays. Assigning an array to a Seq type results in a WrappedArray, and operations return a WrappedArray. Directly using ArrayOps (or letting it be implicitly applied) allows sequence methods, but operations like reverse return an Array, not a Seq.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/arrays.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> val seq: Seq[Int] = a1\nseq: Seq[Int] = WrappedArray(1, 2, 3)\nscala> seq.reverse\nres2: Seq[Int] = WrappedArray(3, 2, 1)\nscala> val ops: collection.mutable.ArrayOps[Int] = a1\nops: scala.collection.mutable.ArrayOps[Int] = [I(1, 2, 3)\nscala> ops.reverse\nres3: Array[Int] = Array(3, 2, 1)\n```\n\n----------------------------------------\n\nTITLE: Declaring String and Char Explicitly Scala\nDESCRIPTION: Demonstrates how to explicitly declare variables of type `String` and `Char` by adding the type annotation `: String` or `: Char` after the variable name, even though Scala can typically infer these types from the literal values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/built-in-types.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval name: String = \"Bill\"\nval c: Char = 'a'\n```\n\n----------------------------------------\n\nTITLE: Defining Comments\nDESCRIPTION: This snippet shows the syntax for single-line, multi-line, and documentation comments in JavaScript and Scala. Both languages use similar syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n//\n/* ... */\n/** ... */\n```\n\nLANGUAGE: Scala\nCODE:\n```\n//\n/* ... */\n/** ... */\n```\n\n----------------------------------------\n\nTITLE: Using Circle Extension Methods in Scala\nDESCRIPTION: Demonstrates how to call the extension methods added to the Circle class. The methods can be called as if they were originally defined in the class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-most.md#_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\naCircle.circumference\naCircle.diameter\naCircle.area\n```\n\n----------------------------------------\n\nTITLE: Using dropWhile with predicate functions in Scala\nDESCRIPTION: Examples of using dropWhile method with predicate functions to drop elements from a list while a condition is true.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-methods.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\noneToTen.dropWhile(_ < 5)       // List(5, 6, 7, 8, 9, 10)\nnames.dropWhile(_ != \"chris\")   // List(chris, david)\n```\n\n----------------------------------------\n\nTITLE: Adding List Parameter to `map` Function Signature\nDESCRIPTION: Extends the Scala `map` function signature to include a second parameter `xs` of type `List[Int]`, representing the input list.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-write-map-function.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef map[A](f: (Int) => A, xs: List[Int])\n```\n\n----------------------------------------\n\nTITLE: Creating Singleton Objects in Scala\nDESCRIPTION: Shows how to define a singleton object that extends a class. Singleton objects in Scala are similar to modules and provide a way to group related functionality.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/cheatsheets/index.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nobject O extends D { ... }\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching for Tuple Deconstruction in Scala\nDESCRIPTION: Illustrates how to use pattern matching to deconstruct a tuple into individual variables, enabling more readable access to tuple data.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/tuples.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval (name, quantity) = ingredient\nprintln(name) // Sugar\nprintln(quantity) // 25\n```\n\n----------------------------------------\n\nTITLE: Simple methods with return expressions in Scala 2 and 3\nDESCRIPTION: Provides examples of methods performing sum and string concatenation, demonstrating typical method definitions in Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-methods.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef sum(a: Int, b: Int): Int = a + b\ndef concatenate(s1: String, s2: String): String = s1 + s2\n```\n\n----------------------------------------\n\nTITLE: シングルトンオブジェクトのメソッド呼び出しとID生成 - Scala\nDESCRIPTION: IdFactoryオブジェクトのcreateメソッドを呼び出して値を取得し、連続したIDを生成・表示する例です。オブジェクト名を通じてアクセスし、個別のインスタンス生成は不要であることを示します。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nval newId: Int = IdFactory.create()\nprintln(newId) // 1\nval newerId: Int = IdFactory.create()\nprintln(newerId) // 2\n```\n\n----------------------------------------\n\nTITLE: 使用枚举值进行模式匹配和条件判断(Scala 3)\nDESCRIPTION: 演示如何在Scala 3中使用枚举值进行模式匹配和条件判断。这个例子导入CrustSize枚举成员，并使用match表达式和if语句来处理不同的枚举值。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-modeling.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport CrustSize.*\nval currentCrustSize = Small\n\n// enums in a `match` expression\ncurrentCrustSize match\n  case Small => println(\"Small crust size\")\n  case Medium => println(\"Medium crust size\")\n  case Large => println(\"Large crust size\")\n\n// enums in an `if` statement\nif currentCrustSize == Small then println(\"Small crust size\")\n```\n\n----------------------------------------\n\nTITLE: Main Layout Template with Content Placeholder\nDESCRIPTION: Example of a basic HTML layout template that includes a content placeholder to be replaced by page content.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/static-site.md#_snippet_7\n\nLANGUAGE: html\nCODE:\n```\n<html>\n    <head>\n        <title>Hello, world!</title>\n    </head>\n    <body>\n        {{ content }}\n    </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Removing Last N Elements from Buffer in Scala\nDESCRIPTION: Removes the last 'n' elements from the end of the buffer 'buf'. This is useful for discarding elements from the end.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/seqs.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nbuf trimEnd n\n```\n\n----------------------------------------\n\nTITLE: Object Instantiation in Scala\nDESCRIPTION: Example of creating a new object instance in Scala, using Java's File class as an example. Shows the standard constructor syntax with parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/cheatsheets/index.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nnew java.io.File(\"f\")\n```\n\n----------------------------------------\n\nTITLE: Using Layout Templates in Scaladoc\nDESCRIPTION: Example of an HTML file that uses a layout template defined in the front matter to structure the page content.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/static-site.md#_snippet_8\n\nLANGUAGE: html\nCODE:\n```\n---\nlayout: main\n---\n\n<h1>Hello world!</h1>\n```\n\n----------------------------------------\n\nTITLE: トレイトの定義 - デフォルト実装を持つメソッド - Scala\nDESCRIPTION: Greeterトレイト内でgreetメソッドに標準実装を提供する例です。具体的な処理として標準的な挨拶メッセージをprintlnで出力します。トレイトが具象メソッドを持つ形態を示しています。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/basics.md#_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\ntrait Greeter {\n  def greet(name: String): Unit =\n    println(\"Hello, \" + name + \"!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Progressive Simplification of Anonymous Functions with ForEach in Scala\nDESCRIPTION: Demonstrates the step-by-step simplification of an anonymous function used with the forEach method, from explicit typing to method reference.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-anonymous-functions.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nints.foreach((i: Int) => println(i))\nints.foreach(i => println(i))\nints.foreach(println(_))\nints.foreach(println)\n```\n\n----------------------------------------\n\nTITLE: Definindo uma função de ordem superior em Scala\nDESCRIPTION: Exemplo de uma função 'apply' que recebe outra função 'f' e um valor 'v', aplicando a função recebida ao valor.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/higher-order-functions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef apply(f: Int => String, v: Int) = f(v)\n```\n\n----------------------------------------\n\nTITLE: Storing Functions in Collections in Scala\nDESCRIPTION: Shows how to create multiple function variables and store them in collections like List and Map, treating functions as first-class values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-function-variables.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval triple = (i: Int) => i * 3\n```\n\nLANGUAGE: scala\nCODE:\n```\nval functionList = List(double, triple)\n\nval functionMap = Map(\n  \"2x\" -> double,\n  \"3x\" -> triple\n)\n```\n\n----------------------------------------\n\nTITLE: Inline Structural Type Declaration in Scala\nDESCRIPTION: Demonstrates how to format a simple structural type inline when it's under 50 characters, showing proper spacing and punctuation conventions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/types.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ndef foo(a: { val bar: String }) = ...\n```\n\n----------------------------------------\n\nTITLE: Accessing List Elements by Index in Python\nDESCRIPTION: Demonstrates accessing list elements using zero-based indexing syntax to retrieve the first and second elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_37\n\nLANGUAGE: Python\nCODE:\n```\na[0]\na[1]\n```\n\n----------------------------------------\n\nTITLE: 可变集合的元素添加与删除 - Scala\nDESCRIPTION: 演示如何在Scala的可变集合中使用+=和-=操作符直接修改集合内容，体现了可变集合的副作用特征。代码通过调用add和remove方法来说明元素的添加和删除行为及其返回值含义。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/sets.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscala> val s = collection.mutable.Set(1, 2, 3)\ns: scala.collection.mutable.Set[Int] = Set(1, 2, 3)\nscala> s += 4\nres3: s.type = Set(1, 4, 2, 3)\nscala> s -= 2\nres4: s.type = Set(1, 4, 3)\n```\n\n----------------------------------------\n\nTITLE: Cloning a Buffer in Scala\nDESCRIPTION: Creates and returns a new buffer that contains the same elements as the original buffer 'buf'. The new buffer is independent of the original.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/seqs.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nbuf.clone\n```\n\n----------------------------------------\n\nTITLE: Case Class Companion Function Traits in Scala 2\nDESCRIPTION: Shows how case class companions in Scala 2 extended Function traits and provided methods like tupled and curried, which is no longer the case in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-other-changes.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ncase class Foo(x: Int, b: Boolean)\n\nFoo.curried(1)(true)\nFoo.tupled((2, false))\n```\n\n----------------------------------------\n\nTITLE: Creating Class Instances in Scala 3 Without 'new' Keyword\nDESCRIPTION: Demonstration of instantiating a class in Scala 3 using the universal apply method without requiring the 'new' keyword.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-tools.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval p = Person(\"Robert Allen Zimmerman\", \"Harmonica Player\")\n```\n\n----------------------------------------\n\nTITLE: Triggering Value Class Allocation via Universal Trait Typing in Scala\nDESCRIPTION: Shows a function `add` whose parameters are typed as the universal trait `Distance`. When instances of the `Meter` value class are passed to this function, they must be boxed into actual `Meter` objects at runtime because they are being treated as the supertype `Distance`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ndef add(a: Distance, b: Distance): Distance = ...\nadd(Meter(3.4), Meter(4.3))\n```\n\n----------------------------------------\n\nTITLE: Defining Multi-Line Sequence - Before Trailing Commas\nDESCRIPTION: Illustrates the standard syntax for defining a multi-line Scala sequence where the last element is *not* followed by a comma. This is the baseline syntax that the SIP aims to improve upon.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/trailing-commas.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nSeq(\n  foo,\n  bar,\n  baz\n)\n```\n\n----------------------------------------\n\nTITLE: Illustrating `inline match` Expansion for Different Static Types in Scala\nDESCRIPTION: Shows the results of calling the `half` function with arguments whose static types are known at compile time (`6` as `Int`, `\"hello world\"` as `String`). The `inline match` resolves the type, selects the corresponding branch, and inlines only that branch's code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\nhalf(6)\n// expands to:\n// val x = 6\n// x / 2\n\nhalf(\"hello world\")\n// expands to:\n// val x = \"hello world\"\n// x.substring(0, x.length / 2)\n```\n\n----------------------------------------\n\nTITLE: Defining Local Class Inside Scala Value Class Method (Disallowed)\nDESCRIPTION: This example shows that defining local classes, traits, or objects (like `Local` class here) inside a method (`aMethod`) of a Scala value class (`NoLocalTemplates`) is restricted by the compiler. The error message indicates this implementation restriction.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\nclass NoLocalTemplates(val x: Int) extends AnyVal {\n  def aMethod = {\n    class Local\n    ...\n  }\n}\n```\n\nLANGUAGE: text\nCODE:\n```\nLocal.scala:3: error: implementation restriction: nested class is not allowed in value class\n  class Local\n        ^\n```\n\n----------------------------------------\n\nTITLE: Handling Exceptions with try/catch/finally (Java)\nDESCRIPTION: This snippet demonstrates the standard Java syntax for handling exceptions using a try-catch-finally block. Code that might throw an exception is placed in the 'try' block, specific exceptions are caught and handled in 'catch' blocks, and cleanup code runs in the 'finally' block regardless of whether an exception occurred.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_52\n\nLANGUAGE: Java\nCODE:\n```\ntry {\n  writeTextToFile(text);\n} catch (IOException ioe) {\n  println(ioe.getMessage())\n} catch (NumberFormatException nfe) {\n  println(nfe.getMessage())\n} finally {\n  println(\"Clean up resources here.\")\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Method Calls with Explicit Receiver Type Annotation\nDESCRIPTION: Highlights the need for explicit type annotation on the receiver (`$ls: List[Int]`) when pattern matching method calls like `.sum`. This is crucial to disambiguate which `sum` method is intended, especially with potential overloading or extension methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\ncase '{ ($ls: List[Int]).sum } =>\n```\n\n----------------------------------------\n\nTITLE: Running JUnit tests (sbt)\nDESCRIPTION: Executes all JUnit tests configured within the project using sbt. This is a standard way to run the unit test suite as part of verifying changes before contributing. Requires sbt installed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/hacker-guide.md#_snippet_9\n\nLANGUAGE: sbt\nCODE:\n```\nsbt test\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Complex Function Expressions (Method Chain)\nDESCRIPTION: Illustrates matching a more complex lambda expression involving a chain of method calls. `case '{ (arg: String) => arg.toLowerCase.strip.trim } =>` specifically matches a function that applies `toLowerCase`, `strip`, and `trim` to its `String` argument.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\ndef matchMethodCallChain(func: Expr[String => String])(using Quotes) = \n  func match \n    case '{ (arg: String) => arg.toLowerCase.strip.trim } =>\n```\n\n----------------------------------------\n\nTITLE: 并发映射（ConcurrentMap）方法介绍\nDESCRIPTION: 列出ConcurrentMap支持的原子操作方法，如putIfAbsent、remove、replace，确保多线程环境下的安全操作。可以通过Java的实现类转换为Scala对象，用于高并发场景。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/concrete-mutable-collection-classes.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\n// 具体代码示例未提供，仅描述支持的方法\n```\n\n----------------------------------------\n\nTITLE: Traversing Tree Nodes with Traverser\nDESCRIPTION: Demonstrates traversing an entire AST to collect specific node types using a custom `Traverser`. It defines an anonymous `Traverser` subclass that overrides `traverse` to specifically find `Apply` nodes, add them to a list, and then continue traversal using the superclass's methods (`super.traverse`, `super.traverseTrees`) to ensure nested nodes are visited. Finally, it shows how to initiate the traversal and access the collected results.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/reflection/symbols-trees-types.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n\nval tree = Apply(Select(Apply(Select(Ident(TermName(\"x\")), TermName(\"$plus\")), List(Literal(Constant(2)))), TermName(\"$plus\")), List(Literal(Constant(3))))\n```\n\nLANGUAGE: Scala\nCODE:\n```\nobject traverser extends Traverser {\n  var applies = List[Apply]()\n  override def traverse(tree: Tree): Unit = tree match {\n    case app @ Apply(fun, args) =>\n      applies = app :: applies\n      super.traverse(fun)\n      super.traverseTrees(args)\n    case _ => super.traverse(tree)\n  }\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntraverser.traverse(tree)\n```\n\nLANGUAGE: Scala\nCODE:\n```\ntraverser.applies\n```\n\n----------------------------------------\n\nTITLE: Creating Project Directory Structure with Shell Commands\nDESCRIPTION: Shell commands to create the standard sbt project directory structure for a project named HelloScalaTest, following the conventional src/main/scala and src/test/scala organization.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/sbt-scalatest-tdd.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmkdir HelloScalaTest\ncd HelloScalaTest\nmkdir -p src/{main,test}/{java,resources,scala}\nmkdir lib project target\n```\n\n----------------------------------------\n\nTITLE: Proposed Type Inference (LUB) for Bindings in Alternatives in Scala\nDESCRIPTION: Explains the proposed type inference mechanism for variables bound in alternative patterns. When the types differ (`Int` in `Bar(x)`, `String` in `Baz(x)`), the resulting type of the bound variable `x` is the Least Upper Bound (LUB) of the types from each branch, represented here as the union type `Int | String`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/alternative-bind-variables.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nenum Foo:\n  case Bar(x: Int)\n  case Baz(y: String)\n\n  def fun = this match\n    case Bar(x) | Baz(x) => // x: Int | String\n```\n\n----------------------------------------\n\nTITLE: 链表（LinkedList）应用示例\nDESCRIPTION: 介绍Scala中的可变链表，即LinkedList的使用，包括空链表的表示和节点链接特性。链表支持顺序遍历、元素插入和链接操作，空链表的next指向自身，避免空指针异常。依赖Scala collection.mutable包。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/concrete-mutable-collection-classes.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n// 具体代码示例未提供，仅为说明\n```\n\n----------------------------------------\n\nTITLE: Compile-Time Error with `inline match` on Non-Static Type in Scala\nDESCRIPTION: Demonstrates that using `inline match` on a variable (`n`) whose static type is `Any` (and not known more precisely at compile time) results in a compile-time error. The compiler cannot statically determine which branch to take.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\nval n: Any = 3\nhalf(n) // error: n is not statically known to be an Int or a Double\n```\n\n----------------------------------------\n\nTITLE: Using Type Aliases with Annotations in Scala\nDESCRIPTION: Shows that the lower camel case convention for annotations persists even when using type aliases. The example aliases `javax.persistence.Id` (typically used as `@Id`) to `id` and uses it as `@id` on a field.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/naming-conventions.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\ntype id = javax.persistence.Id @annotation.target.field\n@id\nvar id: Int = 0\n```\n\n----------------------------------------\n\nTITLE: XmlEntity Macro Implementation for Type Safety\nDESCRIPTION: This code defines a type alias `XmlEntity[Url]` with a macro-backed dynamic select method, enabling type-safe schema-based data access. The macro implementation loads an XML schema from the provided URL at compile time, verifying requested fields against the schema to prevent runtime errors.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/typeproviders.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nobject XmlEntity {\n  def impl(c: Context)(field: c.Tree) = {\n    import c.universe._\n    val TypeRef(_, _, tUrl) = c.prefix.tpe\n    val ConstantType(Constant(sUrl: String)) = tUrl\n    val schema = loadSchema(sUrl)\n    val Literal(Constant(sField: String)) = field\n    if (schema.contains(sField)) q\"${c.prefix}($sField)\"\n    else c.abort(s\"value $sField is not a member of $sUrl\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: YAML Front Matter Example for Scaladoc\nDESCRIPTION: Shows how to use YAML front matter in Scaladoc template files to define metadata such as custom page titles.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/static-site.md#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n---\ntitle: My custom title\n---\n```\n\n----------------------------------------\n\nTITLE: Multi-line for loop processing elements in Python and Scala\nDESCRIPTION: Illustrates a loop that processes each element of a collection, calculating derived values and printing formatted strings. Inputs: iterable ints; outputs: printed strings showing each element and its transformation. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_36\n\nLANGUAGE: Scala\nCODE:\n```\nfor\n  i <- ints\n do\n  val x = i * 2\n  println(s\"i = $i, x = $x\")\n```\n\n----------------------------------------\n\nTITLE: Explaining the map Method Signature (Scala)\nDESCRIPTION: Presents the generic signature of the `map` method found in `scala.collection.IterableOps`. It highlights that the return type `CC[B]` depends on the type constructor `CC` passed as a parameter to `IterableOps`. For the `RNA1` class, `CC` was specified as `IndexedSeq`, explaining why `map` operations on `RNA1` result in `IndexedSeq` (typically `Vector`) instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\ndef map[B](f: A => B): CC[B]\n```\n\n----------------------------------------\n\nTITLE: Using Expr.unapply for Pattern Matching in Scala 3 Macros\nDESCRIPTION: This snippet demonstrates an alternative approach to extract values from expressions using the Expr.unapply extractor in pattern matching, which provides a more concise syntax compared to using the value method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/macros.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n  ...\n  (x, n) match\n    case (Expr(base), Expr(exponent)) =>\n      val value: Double = pow(base, exponent)\n      Expr(value)\n    case (Expr(_), _) => ...\n    case _ => ...\n```\n\n----------------------------------------\n\nTITLE: Creating a package object\nDESCRIPTION: This snippet demonstrates how to create a package object for the 'fruits' package, which contains a value 'planted' and a method 'showFruit' that will be available at the package level.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/package-objects.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// in file gardening/fruits/package.scala\npackage gardening\npackage object fruits {\n  val planted = List(Apple, Plum, Banana)\n  def showFruit(fruit: Fruit): Unit = {\n    println(s\"${fruit.name}s are ${fruit.color}\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Scala Class in Scala\nDESCRIPTION: Defines a simple Scala class named Person with a mutable string field 'name'. This class serves as an example to demonstrate how tuples can store heterogeneous objects without needing new ad-hoc classes. No external dependencies are required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/tuples.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Person(var name: String)\n```\n\n----------------------------------------\n\nTITLE: Creating Code Blocks with Expr.block in Scala 3\nDESCRIPTION: This snippet shows how to build a code block using `Expr.block`, which combines multiple statements and a final expression into a bounded code segment. The example macro `test` generates either a block with side effects or a simple boolean value based on a condition, demonstrating side-effect management in macro-generated code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/macros.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\ninline def test(inline ignore: Boolean, computation: => Unit): Boolean =\n  ${ testCode('ignore, 'computation) }\n\ndef testCode(ignore: Expr[Boolean], computation: Expr[Unit])(using Quotes) =\n  if ignore.valueOrAbort then Expr(false)\n  else Expr.block(List(computation), Expr(true))\n```\n\n----------------------------------------\n\nTITLE: Storing Function Variables in Collections in Scala\nDESCRIPTION: Demonstrates how function variables can be stored in collections like List and Map, showing how functions are first-class values in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-function-variables.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval triple = (i: Int) => i * 3\n```\n\nLANGUAGE: scala\nCODE:\n```\nval functionList = List(double, triple)\n\nval functionMap = Map(\n  \"2x\" -> double,\n  \"3x\" -> triple\n)\n```\n\n----------------------------------------\n\nTITLE: Calling method with positional boolean parameters in Scala 2 and 3\nDESCRIPTION: Example showing how to call a method with multiple boolean parameters, highlighting potential readability issues.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-methods.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nengage(true, true, true, false)\n```\n\n----------------------------------------\n\nTITLE: 'for' expression with 'yield' in Scala 3\nDESCRIPTION: Uses Scala 3 syntax for list comprehension with 'yield' to create a new list with doubled values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nval doubles = for i <- ints yield i * 2\n// doubles: List[Int] = List(2, 4, 6, 8, 10)\n```\n\n----------------------------------------\n\nTITLE: Example of External Redirection with redirectTo Property\nDESCRIPTION: Shows how to redirect a current page to an external URL using the redirectTo property.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/static-site.md#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n---\nredirectTo: https://docs.scala-lang.org/\n---\n```\n\n----------------------------------------\n\nTITLE: Generic functions and syntax sugar in Scala\nDESCRIPTION: Shows how to use generic type parameters, infix notation, and varargs in Scala function definitions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_cheatsheets/index.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef mapmake[T](g: T => T)(seq: List[T]) =\n  seq.map(g)\n```\n\nLANGUAGE: scala\nCODE:\n```\n5.+(3); 5 + 3\n```\n\nLANGUAGE: scala\nCODE:\n```\n(1 to 5) map (_ * 2)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef sum(args: Int*) =\n  args.reduceLeft(_+_)\n```\n\n----------------------------------------\n\nTITLE: Using Java Annotation in Scala Class\nDESCRIPTION: Example of applying a Java annotation to a Scala class, using named arguments syntax for the annotation's elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/annotations.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n@Source(URL = \"https://coders.com/\",\n        mail = \"support@coders.com\")\nclass MyScalaClass ...\n```\n\n----------------------------------------\n\nTITLE: Explicit Anonymous Function Syntax\nDESCRIPTION: Shows the most explicit form of an anonymous function that doubles an integer value, with full type annotation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-anonymous-functions.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval doubledInts = ints.map((i: Int) => i * 2)\n```\n\n----------------------------------------\n\nTITLE: Using Simplified Java Annotation in Java\nDESCRIPTION: Applying the SourceURL annotation to a Java class using the simplified syntax available when the primary parameter is named 'value'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/annotations.md#_snippet_6\n\nLANGUAGE: java\nCODE:\n```\n@SourceURL(\"https://coders.com/\")\npublic class MyClass extends HisClass ...\n```\n\n----------------------------------------\n\nTITLE: Basic method syntax in Scala 2 and 3\nDESCRIPTION: Shows the syntax for defining a simple method with explicit return type in Scala 2 and 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-methods.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef methodName(param1: Type1, param2: Type2): ReturnType =\n  // тело метода\n  // находится здесь\n```\n\n----------------------------------------\n\nTITLE: Declaring Variables in Scala\nDESCRIPTION: Examples of variable declaration in Scala, including mutable variables with 'var', immutable values with 'val', and explicit type annotations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/cheatsheets/index.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nvar x = 5\n```\n\nLANGUAGE: scala\nCODE:\n```\nval x = 5\n```\n\nLANGUAGE: scala\nCODE:\n```\nvar x: Double = 5\n```\n\n----------------------------------------\n\nTITLE: Method Name as Function\nDESCRIPTION: Demonstrates the most concise form where a method name alone can be used as a function when it takes a single parameter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-anonymous-functions.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nints.foreach(println)\n```\n\n----------------------------------------\n\nTITLE: Assigning Named Functions to Values in Scala - Scala\nDESCRIPTION: Illustrates naming an anonymous function by assigning it to a val. The function accepts input parameters and returns their processed result, demonstrated by adding one to the input argument.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/tour/basics.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval addOne = (x: Int) => x + 1\nprintln(addOne(1)) // 2\n```\n\n----------------------------------------\n\nTITLE: Calling Different Constructors of a Class in Scala 3\nDESCRIPTION: Examples of instantiating a class using its primary and auxiliary constructors in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-tools.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval s1 = Student(\"Mary\", \"123\")\nval s2 = Student(\"Mary\", \"123\", LocalDate.now)\nval s3 = Student(\"Mary\", \"123\", 456)\n```\n\n----------------------------------------\n\nTITLE: Scala 3中的依赖函数类型定义\nDESCRIPTION: 将`DB`定义为依赖函数类型`(k: Key) => Option[k.Value]`，简化实现依赖类型的方法，为`user`函数提供更高效的接口调用方式。无需手动创建匿名类，依赖路径类型在函数类型中得到简洁表达。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-dependent-function.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ntype DB = (k: Key) => Option[k.Value] // 依赖函数类型\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Dictionary Elements in Python\nDESCRIPTION: Demonstrates accessing the value associated with key 'a' in a Python dictionary 'my_dict'. Returns the value 1.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\nmy_dict['a']  # 1\n```\n\n----------------------------------------\n\nTITLE: Enabling strict equality in Scala 3\nDESCRIPTION: Shows how to enable strict equality in Scala 3 by importing scala.language.strictEquality, which prevents comparing values of different types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-multiversal-equality.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.language.strictEquality\n\nval rover = Dog(\"Rover\")\nval fido = Dog(\"Fido\")\nprintln(rover == fido)   // compiler error\n\n// compiler error message:\n// Values of types Dog and Dog cannot be compared with == or !=\n```\n\n----------------------------------------\n\nTITLE: Filtered for Loop with if Guards in Java\nDESCRIPTION: Loops through an ArrayList of integers (ints) and prints values only when the elements meet guard conditions (even and less than 5). Implements manual filtering inside loop with if-statements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_45\n\nLANGUAGE: java\nCODE:\n```\nList ints = \n  ArrayList(1,2,3,4,5,6,7,8,9,10);\n\nfor (int i: ints) {\n  if (i % 2 == 0 && i < 5) {\n    System.out.println(x);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Anonymous Functions in Scala\nDESCRIPTION: Shows various ways to create and use anonymous functions (lambdas) in Scala, including placeholder syntax and multi-line blocks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/cheatsheets/index.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n(x: R) => x * x\n```\n\nLANGUAGE: scala\nCODE:\n```\n(1 to 5).map(_ * 2)\n```\n\nLANGUAGE: scala\nCODE:\n```\n(1 to 5).reduceLeft(_ + _)\n```\n\nLANGUAGE: scala\nCODE:\n```\n(1 to 5).map(x => x * x)\n```\n\nLANGUAGE: scala\nCODE:\n```\n(1 to 5).map { x =>\n  val y = x * 2\n  println(y)\n  y\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\n(1 to 5) filter {\n  _ % 2 == 0\n} map {\n  _ * 2\n}\n```\n\n----------------------------------------\n\nTITLE: Calling methods in Scala 2 and 3\nDESCRIPTION: Illustrates how to invoke the previously defined methods with positional arguments, returning their results.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-methods.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval x = sum(1, 2)\nval y = concatenate(\"foo\", \"bar\")\n```\n\n----------------------------------------\n\nTITLE: Running all partest tests (sbt)\nDESCRIPTION: Executes all `partest` tests configured within the project using sbt. This command runs the comprehensive `partest` suite, which is crucial for verifying the impact of changes on the Scala compiler and standard library. Requires sbt and `partest` setup.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/hacker-guide.md#_snippet_10\n\nLANGUAGE: sbt\nCODE:\n```\nsbt partest\n```\n\n----------------------------------------\n\nTITLE: For Comprehensions in Scala\nDESCRIPTION: Demonstrates the versatility of for comprehensions in Scala for transforming collections, including filtering, mapping, and nested iterations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/cheatsheets/index.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nfor (x <- xs if x % 2 == 0)\n  yield x * 10\n```\n\nLANGUAGE: scala\nCODE:\n```\nxs.filter(_ % 2 == 0).map(_ * 10)\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor ((x, y) <- xs zip ys)\n  yield x * y\n```\n\nLANGUAGE: scala\nCODE:\n```\n(xs zip ys) map {\n  case (x, y) => x * y\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor (x <- xs; y <- ys)\n  yield x * y\n```\n\nLANGUAGE: scala\nCODE:\n```\nxs flatMap { x =>\n  ys map { y =>\n    x * y\n  }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor (x <- xs; y <- ys) {\n  val div = x / y.toFloat\n  println(\"%d/%d = %.1f\".format(x, y, div))\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor (i <- 1 to 5) {\n  println(i)\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor (i <- 1 until 5) {\n  println(i)\n}\n```\n\n----------------------------------------\n\nTITLE: 値クラスによる多重継承制約例\nDESCRIPTION: 値クラスは非汎用トレイトを拡張できず、また他の値クラスを継承もできない例。`Value`クラスと`NotUniversal`トレイトの組み合わせや、値クラスの継承に関する制約が示されている。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/value-classes.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\ntrait NotUniversal\nclass Value(val x: Int) extends AnyVal with NotUniversal\nclass Extend(x: Int) extends Value(x)\n```\n\n----------------------------------------\n\nTITLE: HTML Template with Layout Configuration\nDESCRIPTION: Example of a simple HTML template with layout configuration that uses the 'main' layout defined elsewhere.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/static-site.md#_snippet_6\n\nLANGUAGE: html\nCODE:\n```\n---\nlayout: main\n---\n\n<h1>Hello world!</h1>\n```\n\n----------------------------------------\n\nTITLE: Using foreach Method for Side Effects in Scala\nDESCRIPTION: Example of the foreach method used to iterate through collection elements for side effects like printing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/collections-methods.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nscala> names.foreach(println)\nadam\nbrandy\nchris\ndavid\n```\n\n----------------------------------------\n\nTITLE: Standard Object Structure with Inner Object - Scala\nDESCRIPTION: A basic Scala example showing a top-level object containing both a field and a nested inner object with its own field. This structure serves as a point of comparison to explain how `@static` would affect compilation compared to the existing static forwarder mechanism.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/static-members.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nobject O {\n  val d = 1\n  object I {\n    val f = 1\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: 値クラスのトップレベル制約例\nDESCRIPTION: 値クラスはトップレベルまたは静的アクセスのクラスに限定されており、入れ子のクラスはエラーとなる例。`Inner`クラスが他のクラス内にある場合にエラー。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/value-classes.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nclass Outer {\n  class Inner(val x: Int) extends AnyVal\n}\n\n// エラー例\n// class Outer {\n//  class Inner(val x: Int) extends AnyVal\n//}\n```\n\n----------------------------------------\n\nTITLE: Definition of the `ToExpr` Typeclass Trait\nDESCRIPTION: Defines the `ToExpr[T]` trait. Its `apply` method takes a value `x` of type `T` and returns an `Expr[T]`, which is quoted code capable of reconstructing the value `x` at runtime.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ntrait ToExpr[T]:\n  def apply(x: T)(using Quotes): Expr[T]\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching and Extracting Parts of Quoted Expressions\nDESCRIPTION: Demonstrates using splice patterns (`$name`) within quoted patterns. `case '{ Some($boolExpr) } =>` matches an `Expr[Option[Boolean]]` representing `Some(...)` and extracts the inner expression as `boolExpr: Expr[Boolean]`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ndef valueOfBooleanOption(x: Expr[Option[Boolean]])(using Quotes): Option[Option[Boolean]] =\n  x match\n    case '{ Some($boolExpr) } => Some(valueOfBoolean(boolExpr))\n    case '{ None } => Some(None)\n    case _ => None\n```\n\n----------------------------------------\n\nTITLE: Using foreach with Explicit Anonymous Function\nDESCRIPTION: Shows how to use the foreach method with an anonymous function to print each element in a list.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-anonymous-functions.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nints.foreach((i: Int) => println(i))\n```\n\n----------------------------------------\n\nTITLE: Control Constructs in Scala\nDESCRIPTION: Shows various control flow structures in Scala, including conditional expressions, loops, and break statements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/cheatsheets/index.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nif (check) happy else sad\n```\n\nLANGUAGE: scala\nCODE:\n```\nif (check) happy\n```\n\nLANGUAGE: scala\nCODE:\n```\nif (check) happy else ()\n```\n\nLANGUAGE: scala\nCODE:\n```\nwhile (x < 5) {\n  println(x)\n  x += 1\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ndo {\n  println(x)\n  x += 1\n} while (x < 5)\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.util.control.Breaks._\n\nbreakable {\n  for (x <- xs) {\n    if (Math.random < 0.1)\n      break\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: 有序集合范围查询操作示例 - Scala\nDESCRIPTION: 演示有序集合TreeSet中range和from方法的使用，分别用于获取指定范围内和从指定元素起始的子集，这些操作返回的依然是有序集合，保持元素的排序特性。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/sets.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nscala> res3 range (\"one\", \"two\")\nres4: scala.collection.immutable.TreeSet[String] = TreeSet(one, three)\n\nscala> res3 from \"three\"\nres5: scala.collection.immutable.TreeSet[String] = TreeSet(three, two)\n```\n\n----------------------------------------\n\nTITLE: Package Management in Scala\nDESCRIPTION: Techniques for importing packages, selective imports, renaming imports, and package declarations in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/cheatsheets/index.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection._\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.Vector\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.{Vector, Sequence}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.{Vector => Vec28}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport java.util.{Date => _, _}\n```\n\nLANGUAGE: Scala\nCODE:\n```\npackage pkg\n```\n\nLANGUAGE: Scala\nCODE:\n```\npackage pkg { ... }\n```\n\n----------------------------------------\n\nTITLE: Declaring String and Char Types in Scala\nDESCRIPTION: Provides examples of declaring string and character variables in Scala, highlighting string syntax and character literals.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-vars-data-types.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval name = \"Bill\"   // String\nval c = 'a'         // Char\n```\n\n----------------------------------------\n\nTITLE: Data Structures in Scala\nDESCRIPTION: Common data structures in Scala including tuples, lists, ranges, and unit type, with examples of declaration and access.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_th/cheatsheets/index.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n(1,2,3)\n```\n\nLANGUAGE: scala\nCODE:\n```\nvar (x,y,z) = (1,2,3)\n```\n\nLANGUAGE: scala\nCODE:\n```\nvar xs = List(1,2,3)\n```\n\nLANGUAGE: scala\nCODE:\n```\nxs(2)\n```\n\nLANGUAGE: scala\nCODE:\n```\n1 :: List(2,3)\n```\n\nLANGUAGE: scala\nCODE:\n```\n1 to 5\n```\n\nLANGUAGE: scala\nCODE:\n```\n1 until 6\n```\n\nLANGUAGE: scala\nCODE:\n```\n1 to 10 by 2\n```\n\nLANGUAGE: scala\nCODE:\n```\n()\n```\n\n----------------------------------------\n\nTITLE: Removing Elements from Index with Count in Buffer in Scala\nDESCRIPTION: Removes 'n' elements from the buffer 'buf', starting at the specified index 'i'. This is useful for removing a contiguous block of elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/seqs.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nbuf remove (i, n)\n```\n\n----------------------------------------\n\nTITLE: Scala 3中枚举的定义（CrustSize, CrustType, Topping）\nDESCRIPTION: 使用Scala 3中的enum语法定义CrustSize、CrustType和Topping，提供简洁的枚举结构表示不同选择。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-fp.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nenum CrustSize:\n  case Small, Medium, Large\n\nenum CrustType:\n  case Thin, Thick, Regular\n\nenum Topping:\n  case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions\n```\n\n----------------------------------------\n\nTITLE: Combining filter and map Methods in Scala\nDESCRIPTION: Demonstration of combining filter and map methods to process a collection, showing the power of method chaining.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/collections-methods.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\noneToTen.filter(_ < 4).map(_ * 10)\n```\n\n----------------------------------------\n\nTITLE: Removing Type Declaration\nDESCRIPTION: Demonstrates how Scala's type inference allows omitting the type annotation in an anonymous function.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-anonymous-functions.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval doubledInts = ints.map((i) => i * 2)\n```\n\n----------------------------------------\n\nTITLE: Example of String Comparison Using Implicit Conversion\nDESCRIPTION: This example shows how Scala enables string comparison with the < operator by implicitly converting the string to an augmented type that supports comparison operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/implicit-conversions.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n\"foo\" < \"bar\"\n```\n\n----------------------------------------\n\nTITLE: Importing strict equality in a real-world example\nDESCRIPTION: Demonstrates enabling strict equality mode for a bookstore example by importing scala.language.strictEquality.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-multiversal-equality.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n// [1] add this import, or this command line flag: -language:strictEquality\nimport scala.language.strictEquality\n```\n\n----------------------------------------\n\nTITLE: Simplified foreach with Anonymous Function\nDESCRIPTION: Demonstrates a simplified form of an anonymous function with foreach, removing type annotations and parentheses.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-anonymous-functions.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nints.foreach(i => println(i))\n```\n\n----------------------------------------\n\nTITLE: 可变队列（Mutable Queue）操作示例\nDESCRIPTION: 展示如何创建一个可变队列，添加元素，以及出队操作。支持+=和++=方法进行插入，出队操作用dequeue方法移除队列头元素。适用于需要就地修改的队列场景。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/concrete-mutable-collection-classes.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval queue = new scala.collection.mutable.Queue[String]\nqueue += \"a\"\nqueue ++= List(\"b\", \"c\")\nval head = queue.dequeue\n```\n\n----------------------------------------\n\nTITLE: Scala 2 和 Scala 3 变量定义与高阶函数示例\nDESCRIPTION: 演示在Scala 2和3中，如何使用简洁的语法定义变量及其类型，以及利用高阶函数和 lambda 实现集合的过滤和映射操作，显示语法的简明和表达力。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-features.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval nums = List(1,2,3)\nval p = Person(\"Martin\", \"Odersky\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nnums.map(i => i * 2)   // 长写法\nnums.map(_ * 2)        // 简写\n\nnums.filter(i => i > 1)\nnums.filter(_ > 1)\n```\n\n----------------------------------------\n\nTITLE: Printing Tree Structures Using quotes.reflect Printers in Scala\nDESCRIPTION: Demonstrates how to print a tree structure using the Printer.TreeStructure in the quotes.reflect package to obtain a readable representation for debugging. This snippet requires a Tree instance and uses the show method with an implicit Printer to output the tree structure. It improves upon the default toString by providing clearer insights into the tree's makeup.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/reflection.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval tree: Tree = ...\nprintln(tree.show(using Printer.TreeStructure))\n```\n\n----------------------------------------\n\nTITLE: Enforcing tail recursion with @tailrec annotation\nDESCRIPTION: Illustrates the use of @tailrec to ensure a recursive method is optimized as tail recursion. The example shows a factorial calculation with a helper method annotated with @tailrec. An incorrect implementation that causes a compile-time error is also provided.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/annotations.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.annotation.tailrec\n\ndef factorial(x: Int): Int = {\n\n  @tailrec\n  def factorialHelper(x: Int, accumulator: Int): Int = {\n    if (x == 1) accumulator else factorialHelper(x - 1, accumulator * x)\n  }\n  factorialHelper(x, 1)\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.annotation.tailrec\n\ndef factorial(x: Int): Int = {\n  @tailrec\n  def factorialHelper(x: Int): Int = {\n    if (x == 1) 1 else x * factorialHelper(x - 1)\n  }\n  factorialHelper(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Explicitly Handling Generic Types using `t.Underlying` in Quoted Code\nDESCRIPTION: Presents a more verbose but equivalent method for handling generics. An explicit `Type[T]` instance `t` is used, and the type is referred to via its `Underlying` type member (`t.Underlying`), which resolves to `T`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef evalAndUse[T](x: Expr[T])(using t: Type[T])(using Quotes) = '{\n  val x2: t.Underlying = $x\n  ... // use x2\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Nested Packages Using Scala 2 Syntax\nDESCRIPTION: This Scala 2 code demonstrates how to nest packages and define classes within each namespace. A \"users\" package contains sub-packages \"administrators\" and \"normalusers\", each with a \"NormalUser\" class. No parameters are required, but the nesting allows for a hierarchical structure and more precise scoping. It does not require external dependencies and is suitable for Scala 2 syntax. The structure facilitates encapsulation but may introduce verbosity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/packages-and-imports.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\npackage users {\n  package administrators {\n    class NormalUser\n  }\n  package normalusers {\n    class NormalUser\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: 可变BitSet（mutable.BitSet）操作示例\nDESCRIPTION: 演示如何创建可变BitSet，添加元素，BitSet用于存储整数集合，特点是更新操作比不可变版本更高效，适合需要频繁变更的布尔值集合。依赖Scala collection.mutable包。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/collections/concrete-mutable-collection-classes.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nval bits = scala.collection.mutable.BitSet.empty\nbits += 1\nbits += 3\n```\n\n----------------------------------------\n\nTITLE: Extracting Singleton Types Using Quasiquotes in Scala - Scala\nDESCRIPTION: Shows how to represent and extract singleton type expressions using Scala quasiquotes. Utilizes '.sr' for string representation and pattern matching for subtree extraction. Requires Scala reflection imports. The input is a singleton type syntax (e.g., 'foo.bar.type'), and outputs include structured representations and extracted components.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/type-details.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval singleton = tq\"foo.bar.type\".sr\nval tq\"$ref.type\" = tq\"foo.bar.type\"\n```\n\n----------------------------------------\n\nTITLE: Implementing a Parallel String Collection with a Combiner in Scala\nDESCRIPTION: Shows how to define a parallel string collection (`ParString`) using a custom combiner (`ParStringCombiner`) to ensure transformation methods return the custom type (`ParString`). It extends `ParSeqLike` and overrides `newCombiner`. The `ParStringCombiner` implements the `Combiner` trait using an `ArrayBuffer` of `StringBuilder`s for efficient combining and result generation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/parallel-collections/custom-parallel-collections.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass ParString(val str: String)\nextends immutable.ParSeq[Char]\n   with ParSeqLike[Char, ParString, collection.immutable.WrappedString] {\n\n  // previously defined methods: apply, length, seq, splitter\n\n  protected[this] override def newCombiner: Combiner[Char, ParString] = new ParStringCombiner\n\n  // Inner ParStringSplitter class remains the same\n  // ...\n\n  private class ParStringCombiner extends Combiner[Char, ParString] {\n    var sz = 0\n    val chunks = new ArrayBuffer[StringBuilder] += new StringBuilder\n    var lastc = chunks.last\n\n    def size: Int = sz\n\n    def +=(elem: Char): this.type = {\n      lastc += elem\n      sz += 1\n      this\n    }\n\n    def clear = {\n      chunks.clear\n      chunks += new StringBuilder\n      lastc = chunks.last\n      sz = 0\n    }\n\n    def result: ParString = {\n      val rsb = new StringBuilder\n      for (sb <- chunks) rsb.append(sb)\n      new ParString(rsb.toString)\n    }\n\n    def combine[U <: Char, NewTo >: ParString](other: Combiner[U, NewTo]) = if (other eq this) this else {\n      val that = other.asInstanceOf[ParStringCombiner]\n      sz += that.sz\n      chunks ++= that.chunks\n      lastc = chunks.last\n      this\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Scala 2 和 Scala 3中逆变的泛型类型示例\nDESCRIPTION: 定义一个逆变的trait Consumer[-T]，用于输入参数位置，允许父类型实例替代子类型。说明逆变在消费者场景（如药方）中的应用。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-variance.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ntrait Consumer[-T] {\n  def take(t: T): Unit\n}\n```\n\n----------------------------------------\n\nTITLE: 结合参数调用特定操作的高阶函数 executeAndPrint\nDESCRIPTION: 定义接收两整数和一个函数的 `executeAndPrint`，调用不同函数（如加法、乘法）实现对输入值的处理与输出。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-hofs.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ndef executeAndPrint(f: (Int, Int) => Int, i: Int, j: Int): Unit =\n  println(f(i, j))\n```\n\n----------------------------------------\n\nTITLE: Importing the Scala Reflection Universe\nDESCRIPTION: This snippet demonstrates how to import the scala.reflect.runtime.universe package, which provides access to all the principal concepts used in Scala reflection, including types, trees, and annotations. This import is a prerequisite for most Scala reflection operations, especially those working with runtime type information. The expected result is that all members of the runtime universe become available in the current scope.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/overview.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n```\n\n----------------------------------------\n\nTITLE: Using Object Methods in Scala\nDESCRIPTION: Example of calling methods from a singleton object in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-tools.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nStringUtils.truncate(\"Chuck Bartowski\", 5)  // \"Chuck\"\n```\n\n----------------------------------------\n\nTITLE: Scala函数定义配料价格（toppingPrice）\nDESCRIPTION: 纯函数，根据Topping枚举值返回对应的价格，使用模式匹配区分不同配料。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-fp.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef toppingPrice(t: Topping): Double = t match {\n  case Cheese | Onions => 0.5\n  case Pepperoni | BlackOlives | GreenOlives => 0.75\n}\n```\n\n----------------------------------------\n\nTITLE: 使用样例类创建披萨实例\nDESCRIPTION: 示例创建一个喜欢的披萨实例，并打印其`crustType`属性，展示数据模型的实例化与访问。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/domain-modeling-fp.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval myFavPizza = Pizza(Small, Regular, Seq(Cheese, Pepperoni))\nprintln(myFavPizza.crustType) // 输出: Regular\n```\n\n----------------------------------------\n\nTITLE: While loop example in Python and Scala\nDESCRIPTION: Illustrates looping constructs executing while a condition remains true, printing values of i from 1 to 2. Inputs: variable i initialized to 1; outputs: printed integers 1 and 2. No external dependencies.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_29\n\nLANGUAGE: Python\nCODE:\n```\ni = 1\nwhile i < 3:\n  print(i)\n  i += 1\n```\n\n----------------------------------------\n\nTITLE: Applying New Control Structure Syntax Rewrite - Scala\nDESCRIPTION: Demonstrates the `-new-syntax -rewrite` compiler options that transform Scala 2 style control structures into Scala 3 style without parentheses around conditions and braces in generators. The snippet shows changes such as dropping parentheses in `if` conditions, requiring `then` keyword, and removing braces around `for` generators and adding `do` keyword. The snippet assumes `scalac` invoked with these flags as shown in the build.sbt example.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tooling-syntax-rewriting.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncase class State(n: Int, minValue: Int, maxValue: Int) {\n  \n  def inc: State =\n    if n == maxValue then\n      this\n    else\n      this.copy(n = n + 1)\n  \n  def printAll: Unit = {\n    println(\"Printing all\")\n    for\n      i <- minValue to maxValue\n      j <- 0 to n\n    do println(i + j)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: ネストされた値クラスの定義例とエラー\nDESCRIPTION: 値クラスはトップレベルまたは静的アクセス可能なオブジェクトのメンバ内にある必要があるため、入れ子の値クラスはエラーになる例。`Outer`クラス内の`Inner`はエラーとなるが、`Outer`の静的オブジェクト内の`Inner`は許される。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/value-classes.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nclass Outer {\n  class Inner(val x: Int) extends AnyVal\n}\n\n// エラー例\n// class Outer {\n//  class Inner(val x: Int) extends AnyVal\n//}\n```\n\n----------------------------------------\n\nTITLE: Defining Scala 2 Method Body with Match Expression\nDESCRIPTION: This snippet shows how a `match` expression can serve as the entire body of a method in Scala 2 using block syntax. The `isTruthy` method takes a `Matchable` input `a` and returns a boolean based on the pattern match, leveraging the fact that `match` expressions return values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/why-scala-3.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ndef isTruthy(a: Matchable) = a match {\n  case 0 | \"\" => false\n  case _ => true\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Error Reporting in Scala 3 Macros\nDESCRIPTION: This snippet shows how to provide custom error messages in macro implementations. It demonstrates pattern matching on expression values and using quotes.reflect.report for reporting compile-time errors with meaningful messages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/macros.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef powerCode(\n  x: Expr[Double],\n  n: Expr[Int]\n)(using Quotes): Expr[Double] =\n  import quotes.reflect.report\n  (x.value, n.value) match\n    case (Some(base), Some(exponent)) =>\n      val value: Double = pow(base, exponent)\n      Expr(value)\n    case (Some(_), _) =>\n      report.errorAndAbort(\"Expected a known value for the exponent, but was \" + n.show, n)\n    case _ =>\n      report.errorAndAbort(\"Expected a known value for the base, but was \" + x.show, x)\n```\n\n----------------------------------------\n\nTITLE: Case Class with Private Constructor Example\nDESCRIPTION: Shows how constructor modifiers affect the synthetic methods of case classes, which can change with -Xsource-features:case-apply-copy-access.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tooling-scala2-xsource3.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ncase class C private[p] (x: Int)\n```\n\n----------------------------------------\n\nTITLE: Adding sttp Core Dependency with sbt - Scala\nDESCRIPTION: This code demonstrates how to add a dependency on a specific version of sttp core (4.0.0-RC1) in an sbt project. The dependency is added using the libraryDependencies += syntax in build.sbt. Only the sttp component will be available to your Scala project.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/_markdown/install-sttp.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nlibraryDependencies += \"com.softwaremill.sttp.client4\" %% \"core\" % \"4.0.0-RC1\"\n```\n\n----------------------------------------\n\nTITLE: Illustrating Object Field Initialization Issues in Scala\nDESCRIPTION: This Scala code snippet demonstrates a scenario involving class inheritance and object definition where a field `c` is overridden in an object extending a class, and a new field `d` is introduced. It is used in the document to illustrate potential issues with initialization order and side-effects if object fields like `c` or `d` were emitted as static bytecode fields, highlighting the complexity of maintaining correct semantics.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/static-members.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nclass Super {\n val c = {println(1); 1}\n}\nobject Object extends Super {\n override val c = {println(2); 2}\n val d = {println(3); 2}\n}\n```\n\n----------------------------------------\n\nTITLE: Map Function Using Map Method in Scala\nDESCRIPTION: Applies the 'map' method on Scala collection 'numbers' with anonymous function '_ * 10' to return a new collection with each value scaled by 10.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_32\n\nLANGUAGE: Scala\nCODE:\n```\nval x = numbers.map(_ * 10)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Level Inconsistency (Runtime Variable in Compile-Time Code)\nDESCRIPTION: Shows the dual incorrect macro implementation `myBadCounter2`. It defines a variable `x` inside a quote (level 1, runtime) and attempts to access it via a splice (level 0, compile-time), which fails because `x` doesn't exist at compile-time.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef myBadCounter2(using Quotes): Expr[Int] = '{\n  var x = 0\n  ${ x += 1; 'x }\n}\n```\n\n----------------------------------------\n\nTITLE: Blocking on a Scala Future Result - Scala\nDESCRIPTION: Demonstrates how to use the blocking primitive to synchronously wait for the result of a Future in Scala. The sample imports scala.concurrent._, creates a future for retrieving a currency value, then composes logic to buy or throw based on profitability. Dependencies: Scala’s concurrent library. Parameters: the target future, and a timeout duration (e.g., 0 ns). The blocking call waits until the result is available or the timeout is reached. Inputs: asynchronous computations; outputs: the result or an exception. Avoid using blocking except as a last resort due to performance and deadlock risks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/futures-promises.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.concurrent._\n\ndef main(args: Array[String]) {\n  val rateQuote = Future {\n    connection.getCurrentValue(USD)\n  }\n\n  val purchase = rateQuote map {\n    quote => if (isProfitable(quote)) connection.buy(amount, quote)\n             else throw new Exception(\"not profitable\")\n  }\n\n  blocking(purchase, 0 ns)\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing a Scala Array with Strings - Scala\nDESCRIPTION: This snippet demonstrates how to initialize a mutable Array in Scala using the Array constructor with a sequence of strings. The Scala Array provides Java array-like performance but also exposes collection methods like map and filter. No imports are needed for Array. The array contains two string elements and type inference determines the array type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_51\n\nLANGUAGE: Scala\nCODE:\n```\nval a = Array(\"a\", \"b\")\n```\n\n----------------------------------------\n\nTITLE: Declaration of the publicInBinary annotation class in Scala standard library\nDESCRIPTION: This Scala snippet defines the @publicInBinary annotation class within the scala.annotation package as a final class extending StaticAnnotation. This declaration enables usage of the annotation on supported definitions to control their public availability in binary bytecode. It is a prerequisite for migrating code using the binary API scheme.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/binary-api.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\npackage scala.annotation\n\nfinal class publicInBinary extends scala.annotation.StaticAnnotation\n```\n\n----------------------------------------\n\nTITLE: MatchError on Deconstructing Ascribed and Annotated Expressions\nDESCRIPTION: Illustrates that the simple annotation deconstruction pattern `q\"$expr: @$annot\"` fails with a `scala.MatchError` if the tree represents an expression that is both type-ascribed and annotated (`Typed` tree). Deconstructing this requires matching the ascription first, then the annotation on the type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\nscala> val q\"$expr: @$annot\" = q\"(1 + 1): Int @positive\"\nscala.MatchError: (1.$plus(1): Int @positive) (of class scala.reflect.internal.Trees$Typed)\n  ... 32 elided\n```\n\n----------------------------------------\n\nTITLE: Working with Immutable Parallel Hash Sets in Scala\nDESCRIPTION: Creates an immutable parallel hash set and maps each element to its square, then sums the results. Parallel hash tries are efficient parallel versions of immutable hash tries for sets and maps.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/parallel-collections/concrete-parallel-collections.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval phs = scala.collection.parallel.immutable.ParHashSet(1 until 1000: _*)\nphs: scala.collection.parallel.immutable.ParHashSet[Int] = ParSet(645, 892, 69, 809, 629, 365, 138, 760, 101, 479,...\n\nphs map { x => x * x } sum\nres0: Int = 332833500\n```\n\n----------------------------------------\n\nTITLE: Examples of Type-based Search Queries (Scala Syntax)\nDESCRIPTION: Provides various examples of type signatures used as queries in the Inkuire search bar. Each query is shown with its intended result (the method name) and demonstrates how to search for common functions (`map`, `contains`, `apply`, etc.) using only their input and output types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/search-engine.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nList[Int] => (Int => Long) => List[Long]\nSeq[A] => (A => B) => Seq[B]\n(A, B) => A\nSet[Long] => Long => Boolean\nInt => Long => Int\nString => Int => Char\n(Int & Float) => (String | Double)\nF[A] => Int\n```\n\n----------------------------------------\n\nTITLE: Applying @unroll to a Class Secondary Constructor in Scala\nDESCRIPTION: Example of applying the `@unroll` annotation to default parameters within a secondary constructor (`def this(...)`). Similar to primary constructors, this generates further secondary constructors for binary compatibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/unroll-default-arguments.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nclass Unrolled() {\n   var foo = \"\"\n\n   def this(s: String, n: Int = 1, @unroll b: Boolean = true, @unroll l: Long = 0) = {\n      this()\n      foo = s + n + b + l\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling successful Futures with failed projection in Scala 3\nDESCRIPTION: Scala 3 syntax illustrating that attempting to process the failed projection of a successful Future results in no output due to the failed Future failing with NoSuchElementException, demonstrating the behavior of failed projection on success cases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/futures.md#_snippet_27\n\nLANGUAGE: Scala\nCODE:\n```\nval g = Future {\n  4 / 2\n}\nfor exc <- g.failed do println(exc)\n```\n\n----------------------------------------\n\nTITLE: Implementing Intersperse with Factory for Scala 2 and 3\nDESCRIPTION: Presents an initial implementation of the 'intersperse' operation using `scala.collection.generic.IsSeq` to generalize over sequence types and `scala.collection.Factory` to produce the result collection. This version uses an `AbstractView` and `AbstractIterator` to generate the elements. It serves to demonstrate that `Factory` alone does not guarantee preservation of the source collection's specific type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collection-operations.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.{ AbstractIterator, AbstractView, Factory }\nimport scala.collection.generic.IsSeq\n\nclass IntersperseOperation[Repr](coll: Repr, seq: IsSeq[Repr]) {\n  def intersperse[B >: seq.A, That](sep: B)(implicit factory: Factory[B, That]): That = {\n    val seqOps = seq(coll)\n    factory.fromSpecific(new AbstractView[B] {\n      def iterator = new AbstractIterator[B] {\n        val it = seqOps.iterator\n        var intersperseNext = false\n        def hasNext = intersperseNext || it.hasNext\n        def next() = {\n          val elem = if (intersperseNext) sep else it.next()\n          intersperseNext = !intersperseNext && it.hasNext\n          elem\n        }\n      }\n    })\n  }\n}\n\nimplicit def IntersperseOperation[Repr](coll: Repr)(implicit seq: IsSeq[Repr]): IntersperseOperation[Repr] =\n  new IntersperseOperation(coll, seq)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.{ AbstractIterator, AbstractView, Factory }\nimport scala.collection.generic.IsSeq\n\nextension [Repr](coll: Repr)(using seq: IsSeq[Repr])\n  def intersperse[B >: seq.A, That](sep: B)(using factory: Factory[B, That]): That =\n    val seqOps = seq(coll)\n    factory.fromSpecific(new AbstractView[B]:\n      def iterator = new AbstractIterator[B]:\n        val it = seqOps.iterator\n        var intersperseNext = false\n        def hasNext = intersperseNext || it.hasNext\n        def next() =\n          val elem = if intersperseNext then sep else it.next()\n          intersperseNext = !intersperseNext && it.hasNext\n          elem\n    )\n```\n\n----------------------------------------\n\nTITLE: Compiling a Scala application using scalac\nDESCRIPTION: Command to compile a Scala source file into bytecode using the Scala compiler.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/hello-world-2.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nscalac HelloYou.scala\n```\n\n----------------------------------------\n\nTITLE: Defining a Point String Interpolator Using Implicit Class in Scala 2\nDESCRIPTION: This snippet defines an implicit class 'PointHelper' that extends StringContext to create a custom string interpolator 'p' in Scala 2. The interpolator processes a variable number of Double arguments, reuses the built-in 's' interpolator to produce a formatted string, splits it into two parts on the first comma, converts each part to Double with safe fallbacks, and constructs a Point case class instance with these coordinates. It requires the input string to contain exactly two numeric parts separated by a comma. Example usage demonstrates its creation and usage with literal and expression interpolations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/string-interpolation.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit class PointHelper(val sc: StringContext) extends AnyVal {\n  def p(args: Double*): Point = {\n    // reuse the `s`-interpolator and then split on ','\n    val pts = sc.s(args: _*).split(\",\", 2).map { _.toDoubleOption.getOrElse(0.0) }\n    Point(pts(0), pts(1))\n  }\n}\n\nval x=12.0\n\np\"1, -2\"        // Point(1.0, -2.0)\np\"${x/5}, $x\"   // Point(2.4, 12.0)\n```\n\n----------------------------------------\n\nTITLE: Restrictions on Pattern Matching - Regular Tuples with Named Patterns\nDESCRIPTION: Demonstrates an illegal pattern match where a regular tuple is matched with a named pattern. Regular tuples can only be matched with regular patterns.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-tuples.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\n(tuple: Tuple) match\n    case (age = x) => // error\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Difference Between Infix Expression Precedence and Infix Type Precedence in Scala\nDESCRIPTION: This code example illustrates the current inconsistency between how operator precedence works for expressions versus types in Scala. In expressions, operators follow standard precedence rules (e.g., / takes precedence over +), while in types, operations are simply left-associative regardless of the operator.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/priority-based-infix-type-precedence.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject InfixExpressionPrecedence {\n  case class Nummy(expand : String) {\n    def + (that : Nummy) : Nummy = Nummy(s\"Plus[$this,$that]\")\n    def / (that : Nummy) : Nummy = Nummy(s\"Div[$this,$that]\")\n  }\n  object N1 extends Nummy(\"N1\")\n  object N2 extends Nummy(\"N2\")\n  object N3 extends Nummy(\"N3\")\n  object N4 extends Nummy(\"N4\")\n  //Both expand to Plus[Plus[N1,Div[N2,N3]],N4]\n  assert((N1 + N2 / N3 + N4).expand == (N1 + (N2 / N3) + N4).expand)\n}\nobject InfixTypePrecedence {\n  trait Plus[N1, N2]\n  trait Div[N1, N2]\n  type +[N1, N2] = Plus[N1, N2]\n  type /[N1, N2] = Div[N1, N2]\n  trait N1\n  trait N2\n  trait N3\n  trait N4\n  //Error!\n  //Left  expands to Plus[Div[Plus[N1,N2],N3],N4] (Surprising)\n  //Right expands to Plus[Plus[N1,Div[N2,N3]],N4]\n  implicitly[(N1 + N2 / N3 + N4) =:= (N1 + (N2 / N3) + N4)]\n}\n```\n\n----------------------------------------\n\nTITLE: Matching 'super' with Type Qualifier Quasiquotes - Scala\nDESCRIPTION: Shows pattern matching on a `super` expression with a type qualifier and field access using quasiquotes. The pattern `q\"$name.super[$qual].$field\"` matches `q\"super[T].foo\"` and extracts the type qualifier `T` into `$qual`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"$name.super[$qual].$field\" = q\"super[T].foo\"\nname: universe.TypeName =\nqual: universe.TypeName = T\nfield: universe.Name = foo\n```\n\n----------------------------------------\n\nTITLE: Parsing Strings within Scala Macros using `Context.parse`\nDESCRIPTION: Demonstrates using `Context.parse` within a Scala macro implementation (`impl`) to parse a string into an AST. This is the recommended approach inside macros instead of `ToolBox.parse`. The example defines a macro `test` that parses and executes `println(2)`. Note the use of `-Yrepl-class-based:false` for the REPL example.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_32\n\nLANGUAGE: bash\nCODE:\n```\nbash$ scala -Yrepl-class-based:false\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> import scala.language.experimental.macros\nimport scala.language.experimental.macros\n\nscala> def impl(c: scala.reflect.macros.whitebox.Context) = c.Expr[Unit](c.parse(\"println(2)\"))\ndef impl(c: scala.reflect.macros.whitebox.Context): c.Expr[Unit]\n\nscala> def test: Unit = macro impl\ndef test: Unit\n\nscala> test\n2\n```\n\n----------------------------------------\n\nTITLE: Using package object members\nDESCRIPTION: This snippet shows how to import and use members defined in a package object by importing the entire package with a wildcard.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/package-objects.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n// in file PrintPlanted.scala\nimport gardening.fruits._\nobject PrintPlanted {\n  def main(args: Array[String]): Unit = {\n    for (fruit <- planted) {\n      showFruit(fruit)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Graph Node Connections with Type Projection in Scala\nDESCRIPTION: Modifies the initial Graph and Node definitions to allow nodes from different graph instances to connect by using Scala's type projection syntax (`Graph#Node`). This relaxes type constraints on connected nodes, enabling cross-instance node connections while retaining node management within each individual graph. The snippet highlights advanced type manipulation in Scala to control member type bindings for inner classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/inner-classes.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass Graph {\n  class Node {\n    var connectedNodes: List[Graph#Node] = Nil   // Graph#Node en lugar de Node\n    def connectTo(node: Graph#Node): Unit = {\n      if (!connectedNodes.exists(node.equals)) {\n        connectedNodes = node :: connectedNodes\n      }\n    }\n  }\n  var nodes: List[Node] = Nil\n  def newNode: Node = {\n    val res = new Node\n    nodes = res :: nodes\n    res\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Java Annotation with Single Element and Default Value in Scala\nDESCRIPTION: This Scala snippet demonstrates usage of the Java annotation '@SourceURL' using a positional argument for the required 'value' element. It shows that Scala accepts the same simplified syntax as Java. The default value for the optional 'mail' element is utilized by not specifying it explicitly. This highlights Scala's flexible annotation syntax when interoperating with Java annotation APIs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/annotations.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\n@SourceURL(\"https://coders.com/\")\nclass MyScalaClass ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Capped1 Immutable Iterable in Scala\nDESCRIPTION: Defines the `Capped1` class, an immutable iterable collection with a fixed capacity in Scala. It extends `immutable.Iterable` and implements core methods: a constructor to initialize capacity, `appended` to add elements (overwriting oldest when full), `apply` for indexed access, and `iterator` for traversal. Overrides `className` for string representation. Demonstrates basic custom collection structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection._\n\nclass Capped1[A] private (val capacity: Int, val length: Int, offset: Int, elems: Array[Any])\n  extends immutable.Iterable[A] { self =>\n\n  def this(capacity: Int) =\n    this(capacity, length = 0, offset = 0, elems = Array.ofDim(capacity))\n\n  def appended[B >: A](elem: B): Capped1[B] = {\n    val newElems = Array.ofDim[Any](capacity)\n    Array.copy(elems, 0, newElems, 0, capacity)\n    val (newOffset, newLength) =\n      if (length == capacity) {\n        newElems(offset) = elem\n        ((offset + 1) % capacity, length)\n      } else {\n        newElems(length) = elem\n        (offset, length + 1)\n      }\n    new Capped1[B](capacity, newLength, newOffset, newElems)\n  }\n\n  @`inline` def :+ [B >: A](elem: B): Capped1[B] = appended(elem)\n\n  def apply(i: Int): A = elems((i + offset) % capacity).asInstanceOf[A]\n\n  def iterator: Iterator[A] = new AbstractIterator[A] {\n    private var current = 0\n    def hasNext = current < self.length\n    def next(): A = {\n      val elem = self(current)\n      current += 1\n      elem\n    }\n  }\n\n  override def className = \"Capped1\"\n\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\nimport scala.collection.*\n\nclass Capped1[A] private (val capacity: Int, val length: Int, offset: Int, elems: Array[Any])\n  extends immutable.Iterable[A]:\n  self =>\n\n  def this(capacity: Int) =\n    this(capacity, length = 0, offset = 0, elems = Array.ofDim(capacity))\n\n  def appended[B >: A](elem: B): Capped1[B] =\n    val newElems = Array.ofDim[Any](capacity)\n    Array.copy(elems, 0, newElems, 0, capacity)\n    val (newOffset, newLength) =\n      if length == capacity then\n        newElems(offset) = elem\n        ((offset + 1) % capacity, length)\n      else\n        newElems(length) = elem\n        (offset, length + 1)\n    Capped1[B](capacity, newLength, newOffset, newElems)\n  end appended\n\n  inline def :+ [B >: A](elem: B): Capped1[B] = appended(elem)\n\n  def apply(i: Int): A = elems((i + offset) % capacity).asInstanceOf[A]\n\n  def iterator: Iterator[A] = new AbstractIterator[A]:\n    private var current = 0\n    def hasNext = current < self.length\n    def next(): A =\n      val elem = self(current)\n      current += 1\n      elem\n  end iterator\n\n  override def className = \"Capped1\"\nend Capped1\n```\n\n----------------------------------------\n\nTITLE: Summoning an Expression for a Statically Unknown Type Using TypeRepr\nDESCRIPTION: A technique to summon a type class instance for a type represented by TypeRepr at compile time, using the low-level implicits search API.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/faq.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval tpe: TypeRepr = ...\nImplicits.search(tpe) match\n  case result: ImplicitSearchSuccess => result.tree\n  case _ =>\n```\n\n----------------------------------------\n\nTITLE: Proposed Binding in Alternatives with Same Type in Scala\nDESCRIPTION: Illustrates the proposed feature allowing variable binding (`z`) in alternative patterns (`|`) when the bound variable has the same type (`Int`) in both branches (`Bar(z)` and `Baz(z)`). The variable `z` would be available in the case body with the type `Int`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/alternative-bind-variables.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nenum Foo:\n  case Bar(x: Int)\n  case Baz(y: Int)\n\n  def fun = this match\n    case Bar(z) | Baz(z) => ... // z: Int\n```\n\n----------------------------------------\n\nTITLE: Filtering MiMa Binary Compatibility Errors in sbt\nDESCRIPTION: This snippet demonstrates how to use the sbt MiMa plugin to filter out specific binary incompatibility reports when evolving a case class, in this case excluding constructor signature errors. Dependencies include sbt with the MiMa plugin and the Person case class. The filter avoids breaking the build when intentional, compatible changes are made to class constructors. The filter targets the 'Person.this' method signature mismatch reported by MiMa.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/binary-compatibility-for-library-authors.md#_snippet_7\n\nLANGUAGE: sbt\nCODE:\n```\nimport com.typesafe.tools.mima.core._\nmimaBinaryIssueFilters += ProblemFilters.exclude[DirectMissingMethodProblem](\"Person.this\")\n```\n\n----------------------------------------\n\nTITLE: Migrating varargs and collection types in Scala 2.13 - Scala\nDESCRIPTION: This snippet demonstrates a migration example where the method parameter and return types use scala.collection.Seq instead of scala.Seq to handle changes in Scala 2.13 where scala.Seq became an alias for immutable.Seq. It shows how to declare a method inside an object accepting and returning collection.Seq, addressing potential compatibility issues caused by stricter immutability requirements introduced in Scala 2.13. Dependencies include the Scala standard library collection package. The input is a sequence of Order, outputting a sequence of Food, both typed as collection.Seq to avoid varargs incompatibilities.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/collections-migration-213.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection\n\nobject FoodToGo {\n  def orderFood(order: collection.Seq[Order]): collection.Seq[Food]\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Field to a Case Class and Updating Constructors in Scala 2\nDESCRIPTION: This snippet extends the original Person case class by adding an optional address field and a withAddress method, and demonstrates updating the public apply constructor accordingly for binary compatibility in Scala 2. Prerequisites include the prior Person implementation and sbt/MiMa setup. Inputs are name, age, and optional address. Outputs are extended Person instances; legacy usages remain compatible.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/binary-compatibility-for-library-authors.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Person private (name: String, age: Int, address: Option[String]) {\n  ...\n  def withAddress(address: Option[String]) = copy(address = address)\n}\n\nobject Person {\n  // Update the public constructor to also initialize the address field\n  def apply(name: String, age: Int): Person = new Person(name, age, None)\n}\n```\n\n----------------------------------------\n\nTITLE: Scala if/else construct with code blocks\nDESCRIPTION: Shows the use of if/else to execute different code blocks depending on the condition. Demonstrates conditional branching with else clause to handle alternate cases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/if-then-else-construct.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nif (a == b) {\n    doSomething()\n} else {\n    doSomethingElse()\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Trait Implementation REPL\nDESCRIPTION: Shows how to interact with a class implementing a trait in the Scala REPL (Read-Eval-Print Loop). It demonstrates creating an instance of the `Dog` class and calling the implemented `startTail` and `stopTail` methods to verify their functionality.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/traits-interfaces.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val d = new Dog\nd: Dog = Dog@234e9716\n\nscala> d.startTail\ntail is wagging\n\nscala> d.stopTail\ntail is stopped\n```\n\n----------------------------------------\n\nTITLE: Defining Multi-Line Sequence - Trailing Comma Allowed\nDESCRIPTION: Illustrates the syntax introduced by SIP-27 for defining a multi-line Scala sequence. A comma is allowed after the last element when it is on its own line, simplifying modifications and reducing diff noise.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/trailing-commas.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval xs = Seq(\n  foo,\n  baz,\n  bar,\n)\n```\n\n----------------------------------------\n\nTITLE: Updating Mutable Sequence Elements in Scala\nDESCRIPTION: Shows that Scala's ArrayBuffer supports mutability by allowing element update via parentheses indexing and assignment syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_40\n\nLANGUAGE: Scala\nCODE:\n```\n// ArrayBuffer is mutable\na(0) = 10\na(1) = 20\n```\n\n----------------------------------------\n\nTITLE: Enum with user-defined methods and companion object in Scala 3\nDESCRIPTION: This snippet shows an enum 'Planet' with properties 'mass' and 'radius', along with methods to compute surface gravity and weight. The companion object defines a 'main' method calculating weight based on input. It demonstrates encapsulation of behavior within enum types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/types-adts-gadts.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nenum Planet(mass: Double, radius: Double):\n\n  private final val G = 6.67300E-11\n  def surfaceGravity = G * mass / (radius * radius)\n  def surfaceWeight(otherMass: Double) =  otherMass * surfaceGravity\n\n  case Mercury extends Planet(3.303e+23, 2.4397e6)\n  case Venus   extends Planet(4.869e+24, 6.0518e6)\n  case Earth   extends Planet(5.976e+24, 6.37814e6)\n\nobject Planet:\n  def main(args: Array[String]) =\n    val earthWeight = args(0).toDouble\n    val mass = earthWeight / Earth.surfaceGravity\n    for (p <- values)\n      println(s\"Your weight on $p is ${p.surfaceWeight(mass)}\")\n```\n\n----------------------------------------\n\nTITLE: Verifying Bug Fix by Recompiling and Running Scala Test in Sandbox - Shell and Scala\nDESCRIPTION: Shows the final steps to verify the correctness of the applied bug fix by recompiling the modified compiler using sbt and rerunning the sandbox test file. It demonstrates the successful transformation of `%n` into a newline in the output, confirming the fix. The inputs are the modified macro source and the test Scala file, with outputs indicating a successful compile and corrected program output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/hacker-guide.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n18:51 ~/Projects/scala (ticket/6725)$ sbt compile\n...\n[success] Total time: 18 s, completed Jun 6, 2016 9:03:02 PM\nTotal time: 18 seconds\n```\n\nLANGUAGE: Shell\nCODE:\n```\n18:51 ~/Projects/scala/sandbox (ticket/6725)$ ../build/pack/bin/scalac Test.scala\n18:51 ~/Projects/scala/sandbox (ticket/6725)$ ../build/pack/bin/scala Test\n1\n1 // no longer getting the %n here - it got transformed into a newline\n```\n\n----------------------------------------\n\nTITLE: Enforcing New Syntax with Compiler Options - text\nDESCRIPTION: An error message example emitted by the Scala 3 compiler when enforcing the `-new-syntax` option. It shows how the compiler disallows parentheses around an `if`-condition, instructing users to rewrite their code using `-new-syntax -rewrite -source 3.0-migration` for compliance. This snippet illustrates how syntax consistency enforcement works.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tooling-syntax-rewriting.md#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n-- Error: /home/piquerez/scalacenter/syntax/example.scala:6:7 ------------------\n6 |    if (n == maxValue)\n  |       ^^^^^^^^^^^^^^^\n  |This construct is not allowed under -new-syntax.\n  |This construct can be rewritten automatically under -new-syntax -rewrite -source 3.0-migration.\n```\n\n----------------------------------------\n\nTITLE: Using end if statement in Scala 3\nDESCRIPTION: A Scala 3 specific feature that allows explicitly marking the end of an if block with the 'end if' statement, which can improve readability in complex nested structures.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/control-structures.md#_snippet_4\n\nLANGUAGE: Scala 3\nCODE:\n```\nif x == 1 then\n  println(\"x is 1, as you can see:\")\n  println(x)\nend if\n```\n\n----------------------------------------\n\nTITLE: Defining Class with Default Parameter Values in Scala 2\nDESCRIPTION: This snippet shows how to define a class in Scala 2 where constructor parameters have default values, using the assignment operator (`=`). This provides flexibility in how instances can be created.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/domain-modeling-tools.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nclass Socket(val timeout: Int = 5_000, val linger: Int = 5_000) {\n  override def toString = s\"timeout: $timeout, linger: $linger\"\n}\n```\n\n----------------------------------------\n\nTITLE: Proposed Solution Using $\" Escape in Scala Interpolations\nDESCRIPTION: The new syntax proposed by SIP-37, using $\" to escape quote characters within string interpolations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/interpolation-quote-escape.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ns\"A common question for Scala programmers is $\"How can I represent a literal $\" character in Scala interpolations?$\"\"\n```\n\n----------------------------------------\n\nTITLE: Defining RNA2 class in Scala 2\nDESCRIPTION: This Scala 2 class implementation defines an immutable collection RNA2 for RNA sequences, extending IndexedSeq and IndexedSeqOps, with methods to manipulate and extend RNA sequences efficiently. It includes methods such as concat, appended, prepended, map, and flatMap, optimized for returning RNA2 instances where possible.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_18\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.{ View, mutable }\nimport scala.collection.immutable.{ IndexedSeq, IndexedSeqOps }\n\nfinal class RNA2 private (val groups: Array[Int], val length: Int)\n  extends IndexedSeq[Base] with IndexedSeqOps[Base, IndexedSeq, RNA2] {\n\n  import RNA2._\n\n  def apply(idx: Int): Base = // as before\n  override protected def fromSpecific(coll: IterableOnce[Base]): RNA2 = // as before\n  override protected def newSpecificBuilder: mutable.Builder[Base, RNA2] = // as before\n  override def empty: RNA2 = // as before\n  override def className = \"RNA2\"\n\n  // Overloading of `appended`, `prepended`, `appendedAll`,\n  // `prependedAll`, `map`, `flatMap` and `concat` to return an `RNA2`\n  // when possible\n  def concat(suffix: IterableOnce[Base]): RNA2 =\n    fromSpecific(iterator ++ suffix.iterator)\n  // symbolic alias for `concat`\n  @inline final def ++ (suffix: IterableOnce[Base]): RNA2 = concat(suffix)\n  def appended(base: Base): RNA2 =\n    fromSpecific(new View.Appended(this, base))\n  def appendedAll(suffix: IterableOnce[Base]): RNA2 =\n    concat(suffix)\n  def prepended(base: Base): RNA2 =\n    fromSpecific(new View.Prepended(base, this))\n  def prependedAll(prefix: IterableOnce[Base]): RNA2 =\n    fromSpecific(prefix.iterator ++ iterator)\n  def map(f: Base => Base): RNA2 =\n    fromSpecific(new View.Map(this, f))\n  def flatMap(f: Base => IterableOnce[Base]): RNA2 =\n    fromSpecific(new View.FlatMap(this, f))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Matching 'super' with Prefix and Type Qualifier Quasiquotes - Scala\nDESCRIPTION: Illustrates pattern matching on a `super` expression with both a prefix and a type qualifier, along with field access. The pattern `q\"$name.super[$qual].$field\"` matches `q\"other.super[T].foo\"` and extracts the prefix `other` into `$name`, the type qualifier `T` into `$qual`, and the field `foo` into `$field`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"$name.super[$qual].$field\" = q\"other.super[T].foo\"\nname: universe.TypeName = other\nqual: universe.TypeName = T\nfield: universe.Name = foo\n```\n\n----------------------------------------\n\nTITLE: Sorting a List by Multiple Fields Using sortBy in Scala\nDESCRIPTION: Illustrates the use of the sortBy method to sort a list of Address objects first by city and then by street, using a tuple as the comparison key. The key function is specified in the lambda, while ordering for the tuple is inferred implicitly by the compiler. No special dependencies are needed beyond a type called Address. The input is a list of Address objects and the result is a sorted list. This demonstrates basic usage without explicit context parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/taste-contextual-abstractions.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval addresses: List[Address] = ...\n\naddresses.sortBy(address => (address.city, address.street))\n```\n\n----------------------------------------\n\nTITLE: Defining Enum with Members (Java)\nDESCRIPTION: This Java snippet illustrates a more complex enum definition including private instance fields, a constructor, a static constant, and instance methods that operate on the data associated with each enum constant.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_69\n\nLANGUAGE: Java\nCODE:\n```\nenum Planet {\n  MERCURY (3.303e+23, 2.4397e6),\n  VENUS   (4.869e+24, 6.0518e6),\n  EARTH   (5.976e+24, 6.37814e6);\n  // more planets ...\n\n  private final double mass;\n  private final double radius;\n\n  Planet(double mass, double radius) {\n    this.mass = mass;\n    this.radius = radius;\n  }\n\n  public static final double G =\n    6.67300E-11;\n\n  private double mass() {\n    return mass;\n  }\n\n  private double radius() {\n    return radius;\n  }\n\n  double surfaceGravity() {\n    return G * mass /\n      (radius * radius);\n  }\n\n  double surfaceWeight(\n    double otherMass\n  ) {\n    return otherMass *\n      surfaceGravity();\n  }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PizzaServiceInterface in Scala 3\nDESCRIPTION: Example of creating a concrete implementation of the PizzaServiceInterface in Scala 3 syntax, defining the actual behavior for Pizza operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/domain-modeling-fp.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nobject PizzaService extends PizzaServiceInterface:\n\n  def price(p: Pizza): Double =\n    ... // реализация была дана выше\n\n  def addTopping(p: Pizza, t: Topping): Pizza =\n    p.copy(toppings = p.toppings :+ t)\n\n  def removeAllToppings(p: Pizza): Pizza =\n    p.copy(toppings = Seq.empty)\n\n  def updateCrustSize(p: Pizza, cs: CrustSize): Pizza =\n    p.copy(crustSize = cs)\n\n  def updateCrustType(p: Pizza, ct: CrustType): Pizza =\n    p.copy(crustType = ct)\n\nend PizzaService\n```\n\n----------------------------------------\n\nTITLE: Iterating with foreach in Scala\nDESCRIPTION: Shows the `foreach` method, which applies a procedure (a function with return type Unit) to each element of a sequence. It is typically used for side effects like printing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/collections-methods.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nnames.foreach(println)\n```\n\n----------------------------------------\n\nTITLE: Explanation of Scala's Types: Nothing and Null\nDESCRIPTION: This section explains that 'Nothing' is a subtype of all types used to indicate non-termination scenarios like exceptions or infinite loops. 'Null' is a subtype of all reference types and usually represents the null value, primarily for interoperation with Java. No code snippet is provided for this part.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/unified-types.md#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Proposal 2: Complex Desugaring Output with Guard\nDESCRIPTION: Shows the desugared code when an alias is followed by an `if` guard. The proposal retains the current complex desugaring strategy (using `map` to create a tuple, then `withFilter`, then `map`) to correctly handle the filtering condition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\ndoSth(arg).map { a =>\n  val b = a\n  (a, b)\n}.withFilter { case (a, b) =>\n  b > 1\n}.map { case (a, b) =>\n  a + b\n}\n```\n\n----------------------------------------\n\nTITLE: Proposed Recursive Alternative Patterns with Binding in Scala\nDESCRIPTION: Demonstrates how the proposed feature would handle recursive alternative patterns with variable binding. The variable `z` (type `Int`) is bound consistently within nested alternatives (`Bar(z) | Baz(z)`) inside another alternative pattern `Quux(z) | Corge(...)`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/alternative-bind-variables.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nenum Foo:\n  case Bar(x: Int)\n  case Baz(x: Int)\n\nenum Qux:\n  case Quux(y: Int)\n  case Corge(x: Foo)\n\n  def fun = this match\n    case Quux(z) |  Corge(Bar(z) | Baz(z)) => ... // z: Int\n```\n\n----------------------------------------\n\nTITLE: Defining Method with Return Type Inference in Scala\nDESCRIPTION: Shows a simple method definition where the explicit return type (`Int`) is omitted. Scala infers the return type from the body expression (`a + b`), demonstrating return type inference for methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/why-scala-3.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef add(a: Int, b: Int) = a + b\n```\n\n----------------------------------------\n\nTITLE: Implementing WebSocket Endpoint with Cask (Scala 2)\nDESCRIPTION: This Scala code defines a Cask web server with two endpoints using Scala 2 syntax. The `@cask.staticResources` endpoint serves files from the current directory under the `/static` path. The `@cask.websocket` endpoint handles WebSocket connections, processing incoming city names to return the current time in the corresponding timezone via `cask.Ws.Text` messages or closing the connection on an empty message.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/web-server-websockets.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n@cask.staticResources(\"/static\")\ndef static() = \".\"\n\nprivate def getZoneIdForCity(city: String): Option[ZoneId] = {\n  import scala.jdk.CollectionConverters._\n  ZoneId.getAvailableZoneIds.asScala.find(_.endsWith(\"/\" + city)).map(ZoneId.of)\n}\n\n@cask.websocket(\"/websocket\")\ndef websocket(): cask.WsHandler = {\n  cask.WsHandler { channel =>\n    cask.WsActor {\n      case cask.Ws.Text(\"\") => channel.send(cask.Ws.Close())\n      case cask.Ws.Text(city) =>\n        val text = getZoneIdForCity(city) match {\n          case Some(zoneId) => s\"Current date is: ${ZonedDateTime.now().withZoneSameInstant(zoneId)}\"\n          case None => s\"Couldn't find time zone for city $city\"\n        }\n        channel.send(cask.Ws.Text(text))\n    }\n  }\n}\n\ninitialize()\n```\n\n----------------------------------------\n\nTITLE: 定义Builder类基本结构(Scala)\nDESCRIPTION: Builder类是Scala集合框架的基础组件，用于构建新的集合。它提供了添加元素、获取结果、清空和映射结果等基本操作。Builder是参数化的，支持为不同元素类型和目标集合类型构建集合。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/architecture-of-scala-collections.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\npackage scala.collection.mutable\n\nclass Builder[-Elem, +To] {\n  def +=(elem: Elem): this.type\n  def result(): To\n  def clear(): Unit\n  def mapResult[NewTo](f: To => NewTo): Builder[Elem, NewTo] = ...\n}\n```\n\n----------------------------------------\n\nTITLE: Reverting to Classic Brace Syntax with New Control Structures - Scala\nDESCRIPTION: Illustrates the use of `-no-indent -rewrite` compiler options to revert significant indentation syntax back to classical brace-based syntax while preserving the new control structures syntax (e.g., without parentheses but with `then`/`do`). This snippet shows braces usage in method bodies and `for` comprehensions while retaining keywords.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tooling-syntax-rewriting.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ncase class State(n: Int, minValue: Int, maxValue: Int) {\n  \n  def inc: State =\n    if n == maxValue then\n      this\n    else\n      this.copy(n = n + 1)\n  \n  def printAll: Unit = {\n    println(\"Printing all\")\n    for {\n      i <- minValue to maxValue\n      j <- 0 to n\n    }\n    do println(i + j)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Scala 3 compiler options in sbt during migration\nDESCRIPTION: This code configures sbt's `scalacOptions` to include specific compiler flags depending on the Scala version, particularly adding `-source:3.0-migration` for Scala 3 to enable migration mode. It helps automate the handling of deprecations and compilation warnings during the porting process.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-sbt.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nscalacOptions ++= {\n  Seq(\n    \"-encoding\",\n    \"UTF-8\",\n    \"-feature\",\n    \"-language:implicitConversions\",\n    // disabled during the migration\n    // \"-Xfatal-warnings\"\n  ) ++ \n    (CrossVersion.partialVersion(scalaVersion.value) match {\n      case Some((3, _)) => Seq(\n        \"-unchecked\",\n        \"-source:3.0-migration\"\n      )\n      case _ => Seq(\n        \"-deprecation\",\n        \"-Xfatal-warnings\",\n        \"-Wunused:imports,privates,locals\",\n        \"-Wvalue-discard\"\n      )\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Recursive Polymorphic Eta-Expansion in Scala\nDESCRIPTION: Shows how recursive polymorphic eta-expansion works when the method returns another polymorphic method that needs further expansion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/polymorphic-eta-expansion.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nextension [A](x: A)\n  def foo[B](y: B) = (x, y)\n\nval voo: [T] => T => [U] => U => (T, U) = foo\n// foo expands to:\n// [T'] => (t: T') => ( foo[T'](t) with expected type [U] => U => (T', U) )\n// [T'] => (t: T') => [U'] => (u: U') => foo[T'](t)[U'](u)\n```\n\n----------------------------------------\n\nTITLE: Executing Scala-CLI Shebang Command Syntax (Shell)\nDESCRIPTION: Shows the specific command-line syntax required when using the `scala-cli shebang` command. Unlike the general syntax, this form strictly requires all `scala-cli` options to appear before the single input file, and all program arguments must follow the input file. This structure is designed for compatibility with Unix shebang scripts.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/scala-cli.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nscala-cli shebang [scala_cli_options]... input [program_arguments]...\n```\n\n----------------------------------------\n\nTITLE: Using Wildcard in Higher-Kinded Type as Argument (Scala 2)\nDESCRIPTION: Demonstrates a Scala 2 method signature `g` where a higher-kinded type applied to a wildcard (`Foo[_]`) is used as a type argument for another type constructor (`Seq`). This scenario complicates the simple type parameter fix.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-other-changes.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ndef g(foos: Seq[Foo[_]]): Unit\n```\n\n----------------------------------------\n\nTITLE: Running an sbt Project from Command Line\nDESCRIPTION: Output from running the HelloWorld project using the sbt run command, showing compilation and execution steps with their respective log messages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/scala-build-tool-sbt.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt run\n\nUpdated file /Users/al/Projects/Scala/Hello/project/build.properties setting sbt.version to: 0.13.15\n[warn] Executing in batch mode.\n[warn]   For better performance, hit [ENTER] to switch to interactive mode, or\n[warn]   consider launching sbt without any commands, or explicitly passing 'shell'\n[info] Loading project definition from /Users/al/Projects/Scala/Hello/project\n[info] Updating {file:/Users/al/Projects/Scala/Hello/project/}hello-build...\n[info] Resolving org.fusesource.jansi#jansi;1.4 ...\n[info] Done updating.\n[info] Set current project to Hello (in build file:/Users/al/Projects/Scala/Hello/)\n[info] Updating {file:/Users/al/Projects/Scala/Hello/}hello...\n[info] Resolving jline#jline;2.14.5 ...\n[info] Done updating.\n[info] Compiling 1 Scala source to /Users/al/Projects/Scala/Hello/target/scala-2.12/classes...\n[info] Running HelloWorld \nHello, world\n[success] Total time: 4 s\n```\n\n----------------------------------------\n\nTITLE: Configuring Continuous Integration Workflow with GitHub Actions (YAML)\nDESCRIPTION: Defines an automated workflow for a Scala library project using GitHub Actions. This YAML snippet sets up a job that runs on every push, checks out the repository, configures a Java development environment, installs and caches sbt dependencies, and executes unit tests. Dependencies include GitHub Actions runners, the setup-java GitHub Action, and an sbt-compatible project. Inputs: triggered events (pushes), no direct manual inputs. Output: test results and CI status for repository commits. Branch and trigger customization are possible by editing the workflow 'on' field.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nname: Continuous integration\non: push\n\njobs:\n  ci:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3 # Retrieve the content of the repository\n      - uses: actions/setup-java@v3 # Set up a jdk\n        with:\n          distribution: temurin\n          java-version: 8\n          cache: sbt # Cache the artifacts downloaded by sbt accross CI runs\n      - name: unit tests # Custom action consisting of a shell command\n        run: sbt +test\n\n```\n\n----------------------------------------\n\nTITLE: Using Single-Letter Higher-Kinded Type Parameters with Context Bounds in Scala\nDESCRIPTION: Demonstrates using single letters (e.g., 'M[_]') for well-known higher-kinded types like Monad or Functor, especially when a context bound (e.g., `: Monad`) provides necessary context about the type's nature.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/naming-conventions.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\ndef doSomething[M[_]: Monad](m: M[Int]) = ...\n```\n\n----------------------------------------\n\nTITLE: Implementing a Packed RNA Sequence Collection (RNA1) in Scala\nDESCRIPTION: Presents the initial implementation of `RNA1`, a custom `IndexedSeq[Base]` for RNA sequences, using a packed `Array[Int]` representation where each Int stores 16 bases (2 bits each). It implements the required `length` (via val) and `apply` methods. The companion object defines constants for bit manipulation (`S`, `N`, `M`) and provides factory methods (`fromSeq`, `apply`) to create instances, hiding the private constructor and internal representation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-collections.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport collection.IndexedSeqLike\nimport collection.mutable.{Builder, ArrayBuffer}\nimport collection.generic.CanBuildFrom\n\nfinal class RNA1 private (val groups: Array[Int],\n    val length: Int) extends IndexedSeq[Base] {\n\n  import RNA1._\n\n  // Implementation of apply method omitted in the snippet, but described in text\n  def apply(idx: Int): Base = {\n    if (idx < 0 || length <= idx)\n      throw new IndexOutOfBoundsException\n    Base.fromInt(groups(idx / N) >> (idx % N * S) & M)\n  }\n}\n\nobject RNA1 {\n\n  // Number of bits necessary to represent group\n  private val S = 2            \n\n  // Number of groups that fit in an Int\n  private val N = 32 / S       \n\n  // Bitmask to isolate a group\n  private val M = (1 << S) - 1\n\n  def fromSeq(buf: Seq[Base]): RNA1 = {\n    val groups = new Array[Int]((buf.length + N - 1) / N)\n    for (i <- 0 until buf.length)\n      groups(i / N) |= Base.toInt(buf(i)) << (i % N * S)\n    new RNA1(groups, buf.length)\n  }\n\n  def apply(bases: Base*) = fromSeq(bases)\n}\n```\n\n----------------------------------------\n\nTITLE: Correctly Skipping Empty Strings Using BufferedIterator in Scala\nDESCRIPTION: Shows the correct way to skip leading empty strings using a `BufferedIterator`. The `head` method allows inspection of the next element without advancing the iterator, preventing the loss of the first non-empty string. `it.next()` is called only when an empty string needs to be skipped.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/iterators.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 2 Version\ndef skipEmptyWords(it: BufferedIterator[String]) =\n  while (it.head.isEmpty) { it.next() }\n```\n\nLANGUAGE: Scala\nCODE:\n```\n// Scala 3 Version\ndef skipEmptyWords(it: BufferedIterator[String]) =\n  while it.head.isEmpty do it.next()\n```\n\n----------------------------------------\n\nTITLE: Using the Custom Generic `map` Function in Scala\nDESCRIPTION: Provides examples of how to use the custom generic `map` function with different input list types (Int, String) and transformation functions (`double`, `strlen`). Demonstrates its flexibility in handling various data types and returns the transformed lists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-write-map-function.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef double(i : Int) = i * 2\nmap(double, List(1, 2, 3))            // List(2, 4, 6)\n\ndef strlen(s: String) = s.length\nmap(strlen, List(\"a\", \"bb\", \"ccc\"))   // List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: 示例：定义具体的键对象\nDESCRIPTION: 定义两个`Key`对象`Name`和`Age`，分别绑定`String`和`Int`类型的值。通过这些键可以在调用`get`方法时，自动获得对应的类型推断，展示了依赖类型在实际中的应用场景。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-dependent-function.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject Name extends Key { type Value = String }\nobject Age extends Key { type Value = Int }\n```\n\n----------------------------------------\n\nTITLE: Getting Type Representation of List[Int]\nDESCRIPTION: Uses the `typeOf` macro/method to obtain the reflection `Type` object representing the specific type `List[Int]`. This demonstrates the basic syntax for getting a `Type` for a known, concrete type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nscala> typeOf[List[Int]]\nres: scala.reflect.runtime.universe.Type = scala.List[Int]\n```\n\n----------------------------------------\n\nTITLE: Generated Code for Main Method Scala 3\nDESCRIPTION: Illustrates the underlying code generated by the Scala 3 compiler for a `@main` annotated method (like `happyBirthday`). It creates a class with a static `main` method (like Java's) that uses `CommandLineParser` utilities to parse `Array[String]` arguments from the command line and pass them to the original method. Note that `<static>` is a representation of generated code and not valid user syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/methods-main-methods.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nfinal class happyBirthday {\n  import scala.util.{CommandLineParser as CLP}\n  <static> def main(args: Array[String]): Unit =\n    try\n      happyBirthday(\n          CLP.parseArgument[Int](args, 0),\n          CLP.parseArgument[String](args, 1),\n          CLP.parseRemainingArguments[String](args, 2)*)\n    catch {\n      case error: CLP.ParseError => CLP.showError(error)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Singleton Object in Scala - scala\nDESCRIPTION: Defines a basic singleton object named 'Box' using the Scala 'object' keyword to create an instance that is globally unique and lazily instantiated upon first use. This snippet has no dependencies and demonstrates the minimal syntax for creating a singleton object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/singleton-objects.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject Box\n```\n\n----------------------------------------\n\nTITLE: Defining Day of Week Enumeration in Scala\nDESCRIPTION: This snippet demonstrates creating an enumeration for days of the week by declaring a sealed trait 'DayOfWeek' and extending it with case objects for each day. The pattern shows how to group related constant values and enables pattern matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/enumerations-pizza-class.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nsealed trait DayOfWeek\ncase object Sunday extends DayOfWeek\ncase object Monday extends DayOfWeek\ncase object Tuesday extends DayOfWeek\ncase object Wednesday extends DayOfWeek\ncase object Thursday extends DayOfWeek\ncase object Friday extends DayOfWeek\ncase object Saturday extends DayOfWeek\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple Scala Program for Testing\nDESCRIPTION: A simple Scala program with a Person class that will be tested with ScalaTest. The program includes an App object that creates and uses a Person instance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/sbt-scalatest-tdd.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\npackage simpletest\n\nobject Hello extends App {\n    val p = new Person(\"Alvin Alexander\")\n    println(s\"Hello ${p.name}\")\n}\n\nclass Person(var name: String)\n```\n\n----------------------------------------\n\nTITLE: 配列とSeqの相互変換を示す暗黙の変換利用例 - Scala\nDESCRIPTION: このコード例は、Scalaの配列(Array[Int])とSeq[Int]の間で行われる暗黙の変換を示しています。配列からSeqへの変換はWrappedArrayでラッピングされ、SeqからArrayへの変換はtoArrayメソッドを用いて行います。最後のeqメソッドは配列オブジェクトの同一性を比較し、ラッピングとアンラッピングの整合性を示します。暗黙の変換はScala標準のコレクション変換機能に依存します。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/arrays.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval seq: Seq[Int] = a1\nval a4: Array[Int] = seq.toArray\na1 eq a4\n```\n\n----------------------------------------\n\nTITLE: Results of Combined filter and map in Scala REPL\nDESCRIPTION: Output from the Scala REPL showing the result of chaining filter and map methods on a collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/collections-methods.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nscala> oneToTen.filter(_ < 4).map(_ * 10)\nval res1: List[Int] = List(10, 20, 30)\n```\n\n----------------------------------------\n\nTITLE: 構造的部分型に値クラスを用いることの制約例\nDESCRIPTION: 構造的部分型の定義に値クラスを用いることは制約により許されず、エラーとなる。`v.value`のようなアクセスも不可能。例は`Value`値クラスを用いた構造的型定義のエラー例。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/value-classes.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nclass Value(val x: Int) extends AnyVal\n\nobject Usage {\n  def anyValue(v: { def value: Value }): Value =\n    v.value\n}\n\n// 構造的型に値クラスを用いるのはエラー\n```\n\n----------------------------------------\n\nTITLE: Non-Polymorphic Eta-Expansion in Scala\nDESCRIPTION: Demonstrates the existing behavior of non-polymorphic eta-expansion where type inference is used to determine the concrete type parameters.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/polymorphic-eta-expansion.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ndef ident[T](x: T): T = x\n\nval idInt: Int => Int = ident\n// ident becomes:\n// ident[X] with expected type Int => Int\n// (x: X) => ident[X](x) of type X => X with expected type Int => Int\n// therefore X := Int\n// (x: Int) => ident[Int](x)\n```\n\n----------------------------------------\n\nTITLE: Pretty Printing with Type Information Using Scala Reflection ToolBox (Scala)\nDESCRIPTION: Demonstrates usage of showRaw with printing detailed type information by combining scala.reflect.runtime and the ToolBox compiler API. The snippet type checks an AST and prints the tree with embedded type annotations and unique node identifiers, useful for advanced analysis or macro debugging. Requires scala-compiler.jar on classpath.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/reflection/annotations-names-scopes.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.tools.reflect.ToolBox // requires scala-compiler.jar\nimport scala.reflect.runtime.{currentMirror => cm}\n\nval tb = cm.mkToolBox()\nval typedTree = tb.typeCheck(tree)\nprintln(showRaw(typedTree, printTypes = true))\n```\n\n----------------------------------------\n\nTITLE: Declaring a Method Accepting Long in Scala\nDESCRIPTION: Defines a Scala method `findUserById` that takes a single parameter `id` of type `Long` and returns an `Option[User]`. This method signature serves as an example scenario where an implicit conversion might be applied if the method is called with an argument of a different numeric type like `Int`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/ca-implicit-conversions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef findUserById(id: Long): Option[User]\n```\n\n----------------------------------------\n\nTITLE: Using Context Bounds in Polymorphic Function Types and Literals (Scala)\nDESCRIPTION: Proposes extending context bounds syntax (`[X: Ord]`) to polymorphic function type aliases (`Comparer`) and polymorphic function literals (`less`). This allows specifying type class constraints directly within function type definitions, mirroring the capability already present in method definitions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ntype Comparer = [X: Ord] => (x: X, y: X) => Boolean\nval less: Comparer = [X: Ord as ord] => (x: X, y: X) =>\n  ord.compare(x, y) < 0\n```\n\n----------------------------------------\n\nTITLE: Example Snippet that Compiles Successfully (Scala)\nDESCRIPTION: Provides a valid Scala code snippet that successfully converts a `List` of tuples into a `Map`. This contrasts with intentionally failing examples.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/snippet-compiler.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nList((1,2), (2,3)).toMap\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Pattern Matching vs Multiple Assignment in Scala\nDESCRIPTION: This Scala snippet illustrates the semantic difference between pattern matching assignments introduced with 'val' and the proposed multiple assignment syntax without 'val'. The first line declares local bindings via pattern matching from a tuple, while the second line performs direct assignments without pattern matching semantics. It depends on the presence of extractors and tuple values. These examples show how identical-looking syntax can have distinct behaviors based on context in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/multiple-assignments.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval (a(x), b) = (true, \"!\") // 1\n\n(a(x), b) = (true, \"!\")     // 2\n```\n\n----------------------------------------\n\nTITLE: Initializing Runtime Reflection Mirrors in Scala\nDESCRIPTION: This snippet demonstrates initializing the runtime reflection environment in Scala by importing the runtime universe and creating a runtime mirror from a class loader. The mirror acts as an entry point to load symbols by name and create caller mirrors. No external dependencies besides standard Scala reflection libraries are required. The input is a class loader, and the output is a JavaMirror instance that provides access to reflection capabilities at runtime.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/reflection/environment-universes-mirrors.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nscala> val ru = scala.reflect.runtime.universe\nru: scala.reflect.api.JavaUniverse = ...\n\nscala> val m = ru.runtimeMirror(getClass.getClassLoader)\nm: scala.reflect.runtime.universe.Mirror = JavaMirror ...\n```\n\n----------------------------------------\n\nTITLE: Initializing Scala Reflection Universe and ToolBox - Scala\nDESCRIPTION: This snippet demonstrates how to set up the scala-reflect universe and initialize the ToolBox in Scala 2.11 using the REPL. The universe import is necessary for accessing quasiquotes, while the ToolBox API enables runtime evaluation and manipulation of Scala ASTs. Required dependencies include 'scala-reflect' and, for the ToolBox, 'scala.tools.reflect.ToolBox'. The main parameters are none; expected input is through entered Scala code, and the output is initialized reflection components. This setup is specific to environments where runtime reflection and quasiquote manipulation are needed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/setup.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval universe: scala.reflect.runtime.universe.type = scala.reflect.runtime.universe\nimport universe._\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.runtime.currentMirror\nimport scala.tools.reflect.ToolBox\nval toolbox = currentMirror.mkToolBox()\n```\n\n----------------------------------------\n\nTITLE: 示例：调用依赖路径类型的`get`方法\nDESCRIPTION: 演示如何使用定义的键`Name`和`Age`调用`db.get`方法，得到类型分别为`Option[String]`和`Option[Int]`的结果，体现依赖类型根据参数的不同而变化。需要已实现`DB`接口的实例。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/types-dependent-function.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval db: DB = ...\nval res1: Option[String] = db.get(Name)\nval res2: Option[Int] = db.get(Age)\n```\n\n----------------------------------------\n\nTITLE: Conditional Quasiquote Dependencies for Scala Cross-Compilation - sbt\nDESCRIPTION: This snippet provides an sbt build definition for managing dependencies required for using quasiquotes across Scala 2.10 and 2.11. It uses conditional logic based on the current Scala version to select either the built-in 'scala-reflect' dependency (for 2.11+) or additional compiler plugins and libraries (for 2.10). Required prerequisites include an sbt build environment and knowledge of 'CrossVersion'. Input is the current Scala version; output is a modified sequence of library dependencies suitable for cross-compiling. This pattern solves compatibility issues between different Scala versions for projects relying on macros or quasiquotes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/setup.md#_snippet_3\n\nLANGUAGE: sbt\nCODE:\n```\nlibraryDependencies := {\n  CrossVersion.partialVersion(scalaVersion.value) match {\n    // if scala 2.11+ is used, quasiquotes are merged into scala-reflect\n    case Some((2, scalaMajor)) if scalaMajor >= 11 =>\n      libraryDependencies.value\n    // in Scala 2.10, quasiquotes are provided by macro paradise\n    case Some((2, 10)) =>\n      libraryDependencies.value ++ Seq(\n        compilerPlugin(\"org.scalamacros\" % \"paradise\" % \"2.0.0\" cross CrossVersion.full),\n        \"org.scalamacros\" %% \"quasiquotes\" % \"2.0.0\" cross CrossVersion.binary)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Imperative Error Handling with Try-Catch in Scala\nDESCRIPTION: A simple example showing a traditional imperative approach to error handling. This method attempts to convert a string to an integer, returning 0 when the conversion fails. This approach lacks precision as it's impossible to tell whether 0 was an actual input or a fallback from an error.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fp-functional-error-handling.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef makeInt(s: String): Int =\n  try\n    Integer.parseInt(s.trim)\n  catch\n    case e: Exception => 0\n```\n\n----------------------------------------\n\nTITLE: Adding Another Default Parameter, Further Breaking Binary Compatibility in Scala\nDESCRIPTION: Evolves the `foo` method further by adding another default parameter `l: Long = 0`. This continues the pattern of source-compatible changes that break binary compatibility with earlier compiled code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/unroll-default-arguments.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nobject Unrolled{\n   def foo(s: String, n: Int = 1, b: Boolean = true, l: Long = 0) = s + n + b + l\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MiMa Previous Artifacts in sbt - Scala\nDESCRIPTION: Sets previous artifact versions for MiMa to check binary compatibility against in build.sbt. Requires 'sbt-mima-plugin' enabled. Input: previous stable version, organization, and project name; Output: mimaPreviousArtifacts set for MiMa checks. Limitation: Only meaningful when upgrading versions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\nmimaPreviousArtifacts := previousStableVersion.value.map(organization.value %% name.value % _).toSet\n```\n\n----------------------------------------\n\nTITLE: Performing Runtime Type Casting in Scala\nDESCRIPTION: Shows how to use the `asInstanceOf[Type]` method in Scala to cast an object `x` to a specific type (e.g., `String`) at runtime. This operation is unsafe and will throw a `ClassCastException` if `x` is not actually an instance of the target type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_fr/cheatsheets/index.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nx.asInstanceOf[String]\n```\n\n----------------------------------------\n\nTITLE: Named Arguments Implementation in Scala\nDESCRIPTION: Demonstrates how named arguments are transformed by the Scala compiler to preserve call-site order evaluation. The method application is transformed into a block that evaluates arguments in the order they appear in the call.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-and-default-arguments.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nclass A {\n  def f(a: Int, b: Int)(c: Int)\n}\n(new A).f(b = getB(), a = getA())(c = getC())\n// transformed to\n// {\n//   val qual$1 = new A()\n//   val x$1 = getB()\n//   val x$2 = getA()\n//   val x$3 = getC()\n//   qual$1.f(x$2, x$1)(x$3)\n// }\n```\n\n----------------------------------------\n\nTITLE: Implementing a Combiner for a Custom Parallel Collection (Scala)\nDESCRIPTION: Defines the `ParStringCombiner` class, which extends `Combiner[Char, ParString]`. It uses an `ArrayBuffer` of `StringBuilder` chunks to efficiently accumulate characters in parallel. The `+=` method adds elements, `result` constructs the final `ParString`, and `combine` merges results from different parallel tasks by concatenating chunk lists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/parallel-collections/custom-parallel-collections.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nprivate class ParStringCombiner extends Combiner[Char, ParString] {\n  var sz = 0\n  val chunks = new ArrayBuffer[StringBuilder] += new StringBuilder\n  var lastc = chunks.last\n\n  def size: Int = sz\n\n  def +=(elem: Char): this.type = {\n    lastc += elem\n    sz += 1\n    this\n  }\n\n  def clear = {\n    chunks.clear\n    chunks += new StringBuilder\n    lastc = chunks.last\n    sz = 0\n  }\n\n  def result: ParString = {\n    val rsb = new StringBuilder\n    for (sb <- chunks) rsb.append(sb)\n    new ParString(rsb.toString)\n  }\n\n  def combine[U <: Char, NewTo >: ParString](other: Combiner[U, NewTo]) = if (other eq this) this else {\n    val that = other.asInstanceOf[ParStringCombiner]\n    sz += that.sz\n    chunks ++= that.chunks\n    lastc = chunks.last\n    this\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Just-in-Time Compilation with ToolBox and Quasiquotes in Scala\nDESCRIPTION: Uses the `ToolBox` API to generate, compile, and execute Scala code at runtime through quasiquotes. Requires the ToolBox library from Scala reflection. The code builds a syntax tree that prints a message, compiles it on-the-fly, and runs it, producing both side effects (console output) and a result value. Useful for scenarios requiring dynamic code evaluation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/usecases.md#_snippet_3\n\nLANGUAGE: Scala REPL\nCODE:\n```\nscala> val code = q\"\"\"println(\"compiled and run at runtime!\")\"\"\"\nscala> val compiledCode = toolbox.compile(code)\nscala> val result = compiledCode()\ncompiled and run at runtime!\nresult: Any = ()\n```\n\n----------------------------------------\n\nTITLE: Formatting Multi-line Parenthetical Expressions in Scala (Lisp-style)\nDESCRIPTION: Illustrates the preferred Lisp-style formatting for parenthetical expressions that span multiple lines in Scala. The opening and closing parentheses should remain unspaced and generally stay on the same lines as the content they enclose.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/nested-blocks.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n(this + is a very ++ long *\n  expression)\n```\n\n----------------------------------------\n\nTITLE: Running Specific Scala Version with Coursier\nDESCRIPTION: Commands demonstrating how to launch specific versions of Scala or Scalac using Coursier's launch functionality, useful when working with projects requiring different Scala versions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/getting-started/install-scala.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ cs launch scala:{{ site.scala-version }}\n$ cs launch scalac:{{ site.scala-version }}\n```\n\n----------------------------------------\n\nTITLE: Integrated Compiler Plugins Output (Sbt Console)\nDESCRIPTION: This snippet shows the 'Integrated compiler plugins' section from the `migrateDependencies` command output. It lists Scala 2 compiler plugins that have equivalent functionality built into the Scala 3 compiler, indicating the corresponding `scalacOptions` flag to use instead of the plugin dependency.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/scala3-migrate.md#_snippet_6\n\nLANGUAGE: Sbt Console\nCODE:\n```\n[warn] <span style=\"color:orange\">Integrated compiler plugins:</span>\n[warn] addCompilerPlugin((\"org.typelevel\" %% \"kind-projector\" % \"0.13.2\").cross(CrossVersion.full))\n[warn] replaced by <span style=\"color:orange\">scalacOptions += \"-Ykind-projector\"</span>\n```\n\n----------------------------------------\n\nTITLE: Selecting Members Through super and this in Scala Type Quasiquotes - Scala\nDESCRIPTION: Demonstrates accessing type members via 'super' and 'this' selectors in quasiquotes. Shows decomposition into prefix, parent, and field components. Requirements: Scala macro context and reflection universe. Inputs are selections like 'super.Bar' or 'this.Foo'; outputs are TypeName or Name extractions from the type AST.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/type-details.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval superbar = tq\"super.Bar\"\nval tq\"$pre.super[$parent].$field\" = superbar\nval thisfoo = tq\"this.Foo\"\nval tq\"this.${tpname: TypeName}\" = thisfoo\n```\n\n----------------------------------------\n\nTITLE: Benchmarking parallel map with Scala mutable ParHashMap\nDESCRIPTION: Defines a Scala benchmark object `Map` to measure the performance of a parallel map operation on a mutable ParHashMap. The map is populated with key-value pairs from 0 to length-1, with parallelism level configured via JVM properties. Task support is set with a ForkJoinPool for concurrent execution. The `run` method applies the identity function mapping each key-value pair. Dependent on Scala's collection.parallel.mutable.ParHashMap and scala.concurrent.forkjoin.ForkJoinPool classes. Inputs are collection size and thread count; output is the transformed collection. Demonstrates parallel transformation over mutable hash maps with configurable parallelism.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/parallel-collections/performance.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport collection.parallel.mutable.ParHashMap\n\nobject Map extends testing.Benchmark {\n  val length = sys.props(\"length\").toInt\n  val par = sys.props(\"par\").toInt\n  val phm = ParHashMap((0 until length) zip (0 until length): _*)\n\n  phm.tasksupport = new collection.parallel.ForkJoinTaskSupport(new scala.concurrent.forkjoin.ForkJoinPool(par))\n\n  def run = {\n    phm map {\n      kv => kv\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Suppressing Unchecked Warnings with @unchecked in Scala\nDESCRIPTION: This snippet shows how to suppress unchecked warnings when using `runtimeChecked` in a pattern match. By applying the `@unchecked` annotation directly to the type argument (`Int @unchecked`), the compiler is instructed to ignore the potential runtime type safety issue for that specific type parameter, resulting in no warning.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/replace-nonsensical-unchecked-annotation.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nscala> xs.runtimeChecked match {\n     |   case is: ::[Int @unchecked] => is.head\n     | }\nval res14: Int = 1\n```\n\n----------------------------------------\n\nTITLE: Using Overridden toString Method in Scala 3\nDESCRIPTION: This snippet shows usage of the `Complex` class with an overridden `toString` in a Scala 3 main method, demonstrating access to custom object string representations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-for-java-programmers.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\n@main def ComplexNumbers: Unit =\n  val c = Complex(1.2, 3.4)\n  println(\"Overridden toString(): \" + c.toString)\n\n```\n\n----------------------------------------\n\nTITLE: Creating BitSet and Understanding Internal Representation in Scala\nDESCRIPTION: This snippet explains how Scala's BitSet uses a Long array internally, with each Long representing 64 bits corresponding to elements from 0 upwards. It describes the space optimization for small, dense sets and the efficiency of operations like 'contains', addition, and removal, due to bitwise implementation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/collections-2.13/sets.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nВнутреннее представление [BitSet](https://www.scala-lang.org/api/current/scala/collection/BitSet.html) использует массив `Long`ов. Первый `Long` охватывает элементы от 0 до 63, второй от 64 до 127 и так далее (Неизменяемые наборы элементов в диапазоне от 0 до 127 оптимизированны таким образом что хранят биты непосредственно в одном или двух полях типа `Long` без использования массива). Для каждого `Long` 64 бита каждого из них устанавливается значение 1, если соответствующий элемент содержится в наборе, и сбрасывается в 0 в противном случае.\n```\n\n----------------------------------------\n\nTITLE: Demo of TypeTag with context bounds in Scala\nDESCRIPTION: Examples showing the output of the paramInfo method with context bounds when called with different types of arguments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/reflection/typetags-manifests.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nscala> paramInfo(42)\ntype of 42 has type arguments List()\n\nscala> paramInfo(List(1, 2))\ntype of List(1, 2) has type arguments List(Int)\n```\n\n----------------------------------------\n\nTITLE: Incorrect Indentation in Scala Class Definition - Scala\nDESCRIPTION: Demonstrates a Scala class and method with improper indentation using four spaces and tab-like style, contrary to recommended practice. No external dependencies are required. Key parameters include a class definition, a method, and a local variable. Expected input is typical Scala class syntax; output is not applicable as this serves as a style anti-pattern. Limitation: Should not be followed in Scala projects.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/indentation.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n// wrong!\nclass Foo {\n    def fourspaces = {\n        val x = 4\n        ..\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Illegal Colon Placement after Infix Operators in Scala\nDESCRIPTION: This code snippet illustrates an illegal usage under the fewerBraces design, where a colon follows an infix operator ('||'), resulting in an ambiguous or syntactically invalid block. The code attempts to define a block after '||' using a colon, but this is not permitted by SIP-44. Such patterns trigger syntax errors and should be rewritten using parentheses or other legal constructs.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\na < b || :  // illegal\n  val x = f(c)\n  x > 0\n```\n\n----------------------------------------\n\nTITLE: Using `_` as a wildcard in Scala 2\nDESCRIPTION: Shows the standard Scala 2 syntax for using `_` as a wildcard type placeholder, specifically within a `Set`. This syntax must be replaced with `?` when enabling underscore type lambdas via `-Xsource:3` and kind-projector.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/plugin-kind-projector.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef getWidget(widgets: Set[_ <: Widget], name: String): Option[Widget] =\n  widgets.find(_.name == name)\n```\n\n----------------------------------------\n\nTITLE: Defining a Linked List Node with Invariant Type Parameter in Scala\nDESCRIPTION: Defines a simple linked list node class with an invariant type parameter T. It has head and tail members and a prepend method to add elements. The type T is used both in positive and negative positions, restricting subtyping relationships. This code does not support covariance and thus does not recognize ListNode[String] as a subtype of ListNode[Object]. No external dependencies are required.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ko/tour/lower-type-bounds.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ncase class ListNode[T](h: T, t: ListNode[T]) {\n  def head: T = h\n  def tail: ListNode[T] = t\n  def prepend(elem: T): ListNode[T] =\n    ListNode(elem, this)\n}\n```\n\n----------------------------------------\n\nTITLE: Inferring Method Return Type in Scala\nDESCRIPTION: Shows how the Scala compiler infers the return type of a method based on its body expression. The method \"squareOf\" takes an Int parameter and returns an Int result without explicitly declaring the return type. This relies on the expression 'x * x' being of type Int.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tour/type-inference.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef squareOf(x: Int) = x * x\n```\n\n----------------------------------------\n\nTITLE: Iterating Collections with for Loops in Scala 2 and Scala 3\nDESCRIPTION: Illustrates the usage of for loops to iterate over collections such as sequences in both Scala 2 and Scala 3. It explains single generator syntax, multiple generators, use of guards (conditional filters within loops), and multiline code blocks inside loops. The snippet also shows equivalent REPL outputs. Key concepts include generators's pattern <- expression form and guards filtering iterations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval ints = Seq(1, 2, 3)\nfor (i <- ints) println(i)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval ints = Seq(1, 2, 3)\nfor i <- ints do println(i)\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor (i <- ints) {\n  val x = i * 2\n  println(s\"i = $i, x = $x\")\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor i <- ints\n do\n  val x = i * 2\n  println(s\"i = $i, x = $x\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  i <- 1 to 2\n  j <- 'a' to 'b'\n  k <- 1 to 10 by 5\n} {\n  println(s\"i = $i, j = $j, k = $k\")\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor\n  i <- 1 to 2\n  j <- 'a' to 'b'\n  k <- 1 to 10 by 5\n do\n  println(s\"i = $i, j = $j, k = $k\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  i <- 1 to 5\n  if i % 2 == 0\n} {\n  println(i)\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor\n  i <- 1 to 5\n  if i % 2 == 0\n do\n  println(i)\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  i <- 1 to 10\n  if i > 3\n  if i < 6\n  if i % 2 == 0\n} {\n  println(i)\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor\n  i <- 1 to 10\n  if i > 3\n  if i < 6\n  if i % 2 == 0\n do\n  println(i)\n```\n\n----------------------------------------\n\nTITLE: Removing Element at Index in Buffer in Scala\nDESCRIPTION: Removes the element located at the specified index 'i' from the buffer 'buf'. Elements after index 'i' are shifted to the left.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/seqs.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nbuf remove i\n```\n\n----------------------------------------\n\nTITLE: Using Curly Braces and Expressions in String Interpolation in Scala\nDESCRIPTION: This snippet shows how to enclose variables within `${}` for clarity and to embed expressions within strings using string interpolation. It highlights the benefits of using `${expression}` syntax for readability and dynamic content generation within strings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/two-notes-about-strings.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nprintln(s\"Name: ${firstName} ${mi} ${lastName}\")\n```\n\nLANGUAGE: Scala\nCODE:\n```\nprintln(s\"1+1 = ${1+1}\")\n```\n\n----------------------------------------\n\nTITLE: Declaring Default Numeric Types Implicitly Scala\nDESCRIPTION: Illustrates how Scala can infer the data type for integer literals (defaulting to `Int`) and floating-point literals (defaulting to `Double`) when no explicit type annotation is provided. This is a common and concise way to declare these standard numeric variables.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/built-in-types.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval i = 123   // defaults to Int\nval x = 1.0   // defaults to Double\n```\n\n----------------------------------------\n\nTITLE: Setting sbt Version via Build Properties - Text File\nDESCRIPTION: This snippet shows the contents of the 'build.properties' file located inside the 'project' directory. It defines the sbt version (1.10.11) that the build should use. The build properties file is a required part of any sbt project to specify the sbt launcher version.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nsbt.version=1.10.11\n```\n\n----------------------------------------\n\nTITLE: Defining Scala Value Class with Secondary Constructor (Disallowed)\nDESCRIPTION: This example demonstrates that defining secondary constructors (using `this`) within a Scala value class `Secondary` is prohibited. Value classes are restricted to only having the primary constructor defined in the class signature. The compiler error enforces this rule.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\nclass Secondary(val x: Int) extends AnyVal {\n  def this(y: Double) = this(y.toInt)\n}\n```\n\nLANGUAGE: text\nCODE:\n```\nSecondary.scala:2: error: value class may not have secondary constructors\n  def this(y: Double) = this(y.toInt)\n      ^\n```\n\n----------------------------------------\n\nTITLE: Limitations on Converting Iterable to RNA2\nDESCRIPTION: Attempts to convert a generic Iterable[Base] into an RNA2 using the .to method fail because the method expects a Factory parameter, not a type or singleton object. This indicates that explicit conversion or factory methods are needed for such transformations to succeed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val bases: Iterable[Base] = List(A, U, C, C)\nval bases: Iterable[Base] = List(A, U, C, C)\n\nscala> bases.to(RNA2)\n                ^\n       error: type mismatch;\n        found   : RNA2.type\n        required: scala.collection.Factory[Base,?]\n```\n\n----------------------------------------\n\nTITLE: Adding sbt-dynver Plugin for Dynamic Versioning (Scala)\nDESCRIPTION: Demonstrates how to add the sbt-dynver plugin to an SBT project, enabling automatic version derivation from Git tags for release artifacts. Place this dependency in project/plugins.sbt and omit the version key from build.sbt. Inputs: the plugin dependency. Output: project version is auto-calculated, facilitating reproducible and automated releases. Limitation: Project must use Git for version control.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\naddSbtPlugin(\"com.github.sbt\" % \"sbt-dynver\" % \"5.0.1\")\n```\n\n----------------------------------------\n\nTITLE: Triggering Value Class Allocation via Array Assignment in Scala\nDESCRIPTION: Shows that assigning a value class instance (`m` of type `Meter`) to an `Array[Meter]` requires allocating actual `Meter` objects on the heap. Arrays in the JVM store objects, so the underlying primitive cannot be stored directly in this context.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/value-classes.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval m = Meter(5.0)\nval array = Array[Meter](m)\n```\n\n----------------------------------------\n\nTITLE: Implementing a ParString with Enhanced Collection Behavior and Parallel Splitting\nDESCRIPTION: This snippet adds a variant of `ParString` that mixes in `ParSeqLike` to allow defining a custom `filter` operation that returns a `ParString` instead of a default collection type. It introduces a custom `ParStringCombiner` class to efficiently accumulate characters during parallel transformations, maintaining a sequence of string builders. The combiner supports adding elements, merging, and final result construction, ensuring minimal copying and efficient parallel operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/parallel-collections/custom-parallel-collections.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass ParString(val str: String)\n  extends immutable.ParSeq[Char]\n     with ParSeqLike[Char, ParString, collection.immutable.WrappedString] {\n  protected[this] override def newCombiner: Combiner[Char, ParString] = new ParStringCombiner\n  private class ParStringCombiner extends Combiner[Char, ParString] {\n    var sz = 0\n    val chunks = new ArrayBuffer[StringBuilder] += new StringBuilder\n    var lastc = chunks.last\n    def size: Int = sz\n    def +=(elem: Char): this.type = {\n      lastc += elem\n      sz += 1\n      this\n    }\n    def clear = {\n      chunks.clear\n      chunks += new StringBuilder\n      lastc = chunks.last\n      sz = 0\n    }\n    def result: ParString = {\n      val rsb = new StringBuilder\n      for (sb <- chunks) rsb.append(sb)\n      new ParString(rsb.toString)\n    }\n    def combine[U <: Char, NewTo >: ParString](other: Combiner[U, NewTo]) = if (other eq this) this else {\n      val that = other.asInstanceOf[ParStringCombiner]\n      sz += that.sz\n      chunks ++= that.chunks\n      lastc = chunks.last\n      this\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Eta-Expansion for Extension and Interleaved Methods in Scala\nDESCRIPTION: This snippet demonstrates eta-expansion behavior for extension methods and interleaved clauses. Extension methods become polymorphic functions when partially applied, and interleaved methods get transformed to functions with matching generic constraints. Dependencies: key types and instantiations (e.g., Key), and understanding of extension syntax. Inputs are numbers and keys, outputs are function values. Limitation: advanced shape may require SIP-49 implementation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/polymorphic-eta-expansion.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nextension (x: Int)\n  def extf1[A](x: A): A = ???\n\nval extv1_1: [B] => B => B = extf1(4) // extf1(4) becomes [B'] => (y: B')  => extf1(4)[B'](y)\n\nval extv1_3: Int => [B] => B => B = extf1 // extf1 becomes (i: Int) => [B'] => (y: B')  => extf1(i)[B'](y)\n\n// See https://docs.scala-lang.org/sips/clause-interleaving.html\ndef interleaved(key: Key)[V >: key.Value](default: V): V = ???\nval someKey: Key = ???\nval interleaved_1: [A >: someKey.Value] => A => A = interleaved(someKey)\n// interleaved(someKey) becomes [A' >: someKey.Value] => (default: A') => interleaved(someKey)[A'](default)\n```\n\n----------------------------------------\n\nTITLE: Hiding Code Sections in Snippets\nDESCRIPTION: This Scala snippet demonstrates the syntax for hiding parts of a code example in Scaladoc. Code enclosed within `//{` and `//}` markers (like the import statement) is initially hidden in the rendered documentation but can be expanded by the user. This keeps examples concise while providing full context on demand.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/snippet-compiler.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\n//{\nimport scala.collection.immutable.List\n//}\nval intList: List[Int] = List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Using while loops in Scala 2\nDESCRIPTION: Demonstrates the syntax for while loops in Scala 2, which include a condition in parentheses and a block of code in curly braces to be executed repeatedly while the condition is true.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/control-structures.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nvar i = 0\n\nwhile (i < 3) {\n  println(i)\n  i += 1\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Over Lists and Tuples Illustrates Eta-Expansion Limitation in Scala\nDESCRIPTION: These examples show how eta-expansion currently works with standard collections like List, but fails for Tuple as it requires a polymorphic function. The first line passes a monomorphic function, while the second line expects a polymorphic function with an error shown. No dependencies are required except for foundational Scala collections. Inputs are a List or Tuple and a function (Some.apply), output is a mapped collection or a compile error. The limitation is that tuples cannot be mapped with a monomorphic function under the status quo.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/polymorphic-eta-expansion.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nList(1, 2, 3).map(Some.apply) // works\n\n(\"Hello\", 2, 'u').map(Some.apply) // error:\n// Found: Any => Some[Any], Required: [t] => (t) => Nothing\n```\n\n----------------------------------------\n\nTITLE: Updating build.sbt for Scala 3 Migration Dependencies\nDESCRIPTION: Example `build.sbt` configuration demonstrating how to add necessary dependencies for Scala 3 migration, including `cats-core`, `java-diff-utils`, `scalameta parsers`, and `munit` for testing. It also shows conditional inclusion of the `kind-projector` compiler plugin and Scala 3 specific `scalacOptions` based on the `scalaVersion`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/scala3-migrate.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\n//build.sbt\nlazy val main = project\n  .in(file(\".\"))\n  .settings(\n    scalaVersion := \"2.13.11\",\n    libraryDependencies ++= Seq(\n      \"org.typelevel\" %% \"cats-core\" % \"2.6.1\",\n      \"io.github.java-diff-utils\" % \"java-diff-utils\" % \"4.12\",\n      (\"org.scalameta\" %% \"parsers\" % \"4.8.9\").cross(CrossVersion.for3Use2_13),\n      \"org.scalameta\" %% \"munit\" % \"0.7.25\" % Test\n    ),\n    libraryDependencies ++= {\n      if (scalaVersion.value.startsWith(\"3.\")) Seq.empty\n      else Seq(\n        compilerPlugin((\"org.typelevel\" %% \"kind-projector\" % \"0.13.2\").cross(CrossVersion.full))\n      )\n    },\n    scalacOptions ++= {\n      if (scalaVersion.value.startsWith(\"3.\")) Seq(\"-Ykind-projector\")\n      else Seq.empty\n    }\n  )\n```\n\n----------------------------------------\n\nTITLE: Rerouting Scala Value Class Method Calls (Step 2 Example)\nDESCRIPTION: Demonstrates how calls to methods on value class instances are rewritten by the compiler. Instead of a virtual method call, the call is transformed into a static method call on the companion object, passing the instance (`x` or `y`) as the first argument. This step, following method extraction, ensures that value class operations are translated into efficient static calls.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/value-classes.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n    val x, y: Meter\n    x.plus(y)\n    x.toString\n```\n\nLANGUAGE: Scala\nCODE:\n```\n    Meter.extension$plus(x, y)\n    Meter.extension$toString(x)\n```\n\n----------------------------------------\n\nTITLE: Setup for Working with Quotes Reflection API in Scala\nDESCRIPTION: Defines a sealed trait hierarchy with `Box.Base` and `Box.Leaf` case class and declares several reflection-related bindings such as `TypeRepr` and `Symbol` for these types. These are used in subsequent examples to demonstrate Symbol usage, TypeRepr extraction, and reflection best practices. Requires importing or having access to Scala 3 reflection packages and appropriate macro context.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/best-practices.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nobject Box:\n  sealed trait Base\n  case class Leaf(x: Int) extends Base\n\n// Quotes in contextual scope\nval boxTpe : TypeRepr = TypeRepr.of[Box.type]\nval baseTpe: TypeRepr = TypeRepr.of[Box.Base]\nval baseSym: Symbol   = baseTpe.typeSymbol\nval leafTpe: TypeRepr = TypeRepr.of[Box.Leaf]\nval leafSym: Symbol   = leafTpe.typeSymbol\n```\n\n----------------------------------------\n\nTITLE: Defining immutable FP style records in Python and Scala\nDESCRIPTION: Shows how to define immutable data structures using Python frozen dataclasses and Scala case classes. Dependencies include Python's dataclasses module for frozen dataclasses. Key parameters are the fields defining the record. Input is field values during instantiation; output is an immutable object. This introduces fundamental FP style record creation in both languages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Person(name: String, age: Int)\n```\n\n----------------------------------------\n\nTITLE: Defining a Ring-Buffer Capped Collection - Scala 2\nDESCRIPTION: Implements a capped ring-buffer as an immutable collection by extending StrictOptimizedIterableOps, IterableFactoryDefaults, and other core Scala collection traits in Scala 2. The Capped class manages an internal fixed-size buffer, exposes constant-time append and indexed access, and overrides factory/iterator/view behaviors for optimized performance. Requires Scala collections, supports type parameterization, and customizes the builder/factory pattern for reusable creation. Inputs include element values and capacity; outputs are Capped collections supporting fast transform and append. Limitations: buffer size is fixed at construction, and appends overwrite when full.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_6\n\nLANGUAGE: Scala 2\nCODE:\n```\nimport scala.collection._\n\nfinal class Capped[A] private (val capacity: Int, val length: Int, offset: Int, elems: Array[Any])\n  extends immutable.Iterable[A]\n    with IterableOps[A, Capped, Capped[A]]\n    with IterableFactoryDefaults[A, Capped]\n    with StrictOptimizedIterableOps[A, Capped, Capped[A]] { self =>\n\n  def this(capacity: Int) =\n    this(capacity, length = 0, offset = 0, elems = Array.ofDim(capacity))\n\n  def appended[B >: A](elem: B): Capped[B] = {\n    val newElems = Array.ofDim[Any](capacity)\n    Array.copy(elems, 0, newElems, 0, capacity)\n    val (newOffset, newLength) =\n      if (length == capacity) {\n        newElems(offset) = elem\n        ((offset + 1) % capacity, length)\n      } else {\n        newElems(length) = elem\n        (offset, length + 1)\n      }\n    new Capped[B](capacity, newLength, newOffset, newElems)\n  }\n\n  @`inline` def :+ [B >: A](elem: B): Capped[B] = appended(elem)\n\n  def apply(i: Int): A = elems((i + offset) % capacity).asInstanceOf[A]\n\n  def iterator: Iterator[A] = view.iterator\n\n  override def view: IndexedSeqView[A] = new IndexedSeqView[A] {\n    def length: Int = self.length\n    def apply(i: Int): A = self(i)\n  }\n\n  override def knownSize: Int = length\n\n  override def className = \"Capped\"\n\n  override val iterableFactory: IterableFactory[Capped] = new CappedFactory(capacity)\n\n}\n\nclass CappedFactory(capacity: Int) extends IterableFactory[Capped] {\n\n  def from[A](source: IterableOnce[A]): Capped[A] =\n    source match {\n      case capped: Capped[A] if capped.capacity == capacity => capped\n      case _ => (newBuilder[A] ++= source).result()\n    }\n\n  def empty[A]: Capped[A] = new Capped[A](capacity)\n\n  def newBuilder[A]: mutable.Builder[A, Capped[A]] =\n    new mutable.ImmutableBuilder[A, Capped[A]](empty) {\n      def addOne(elem: A): this.type = { elems = elems :+ elem; this }\n    }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Single-Line Sequence - Trailing Comma Disallowed\nDESCRIPTION: Provides an example of a single-line Scala sequence definition with a trailing comma. The SIP restricts trailing comma support to multi-line sequences, making this style invalid.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/trailing-commas.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval xs = Seq(foo, baz, bar, )\n```\n\n----------------------------------------\n\nTITLE: Named Arguments with Overloaded Methods in Scala\nDESCRIPTION: Demonstrates how named arguments influence overloading resolution. Named arguments help select the applicable overloaded method based on parameter names.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-and-default-arguments.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef f() // #1\ndef f(a: Int, b: String) // #2\nf(b = \"someString\", a = 1) // using #2\n```\n\n----------------------------------------\n\nTITLE: Defining Classes and Enumerations in Scala\nDESCRIPTION: Demonstrates creating enumeration types and a class in Scala, showing how to define class members, methods, and use mutable collections within a class. Includes example of creating and using class instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\n// create some enumerations that the Pizza class will use\nenum CrustSize:\n  case Small, Medium, Large\n\nenum CrustType:\n  case Thin, Thick, Regular\n\nenum Topping:\n  case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions\n\n// import those enumerations and the ArrayBuffer,\n// so the Pizza class can use them\nimport CrustSize.*\nimport CrustType.*\nimport Topping.*\nimport scala.collection.mutable.ArrayBuffer\n\n// define an OOP style Pizza class\nclass Pizza(\n  var crustSize: CrustSize,\n  var crustType: CrustType\n):\n\n  private val toppings = ArrayBuffer[Topping]()\n\n  def addTopping(t: Topping): Unit =\n    toppings += t\n\n  def removeTopping(t: Topping): Unit =\n    toppings -= t\n\n  def removeAllToppings(): Unit =\n    toppings.clear()\n\n  override def toString(): String =\n    s\"\"\"\n      |Pizza:\n      |  Crust Size: ${crustSize}\n      |  Crust Type: ${crustType}\n      |  Toppings:   ${toppings}\n    \"\"\".stripMargin\n\nend Pizza\n\n// create a Pizza instance\nval p = Pizza(Small, Thin)\n\n// change the crust\np.crustSize = Large\np.crustType = Thick\n\n// add and remove toppings\np.addTopping(Cheese)\np.addTopping(Pepperoni)\np.addTopping(BlackOlives)\np.removeTopping(Pepperoni)\n\n// print the pizza, which uses its `toString` method\nprintln(p)\n```\n\n----------------------------------------\n\nTITLE: Creating a Book Domain Model with Strict Equality\nDESCRIPTION: This snippet shows a complete example of implementing multiversal equality for a book domain model with PrintedBook and AudioBook classes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/ca-multiversal-equality.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n// [1] добавить этот импорт или command line flag: -language:strictEquality\nimport scala.language.strictEquality\n```\n\nLANGUAGE: scala\nCODE:\n```\n// [2] создание иерархии классов\ntrait Book:\n    def author: String\n    def title: String\n    def year: Int\n\ncase class PrintedBook(\n    author: String,\n    title: String,\n    year: Int,\n    pages: Int\n) extends Book\n\ncase class AudioBook(\n    author: String,\n    title: String,\n    year: Int,\n    lengthInMinutes: Int\n) extends Book\n```\n\nLANGUAGE: scala\nCODE:\n```\n// [3] создайте экземпляры класса типов, чтобы определить разрешенные сравнения.\n//     разрешено `PrintedBook == PrintedBook`\n//     разрешено `AudioBook == AudioBook`\ngiven CanEqual[PrintedBook, PrintedBook] = CanEqual.derived\ngiven CanEqual[AudioBook, AudioBook] = CanEqual.derived\n\n// [4a] сравнение двух печатных книг разрешено\nval p1 = PrintedBook(\"1984\", \"George Orwell\", 1961, 328)\nval p2 = PrintedBook(\"1984\", \"George Orwell\", 1961, 328)\nprintln(p1 == p2)         // true\n\n// [4b] нельзя сравнивать печатную книгу и аудиокнигу\nval pBook = PrintedBook(\"1984\", \"George Orwell\", 1961, 328)\nval aBook = AudioBook(\"1984\", \"George Orwell\", 2006, 682)\nprintln(pBook == aBook)   // ошибка компиляции\n```\n\n----------------------------------------\n\nTITLE: Matching Tuple Patterns Using Scala Quasiquotes\nDESCRIPTION: Covers pattern matching for tuple structures which are syntactic sugar for `TupleN` extractor patterns in Scala. Demonstrates creating a tuple pattern and extracting its constituent patterns as a list. Inputs are tuple quasiquotes; outputs are a list of AST trees representing each tuple element with bindings using wildcard patterns.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/pattern-details.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval tup2pat = pq\"(a, b)\"\ntup2pat: universe.Tree = scala.Tuple2((a @ _), (b @ _))\n\nval pq\"(..$pats)\" = tup2pat\npats: List[universe.Tree] = List((a @ _), (b @ _))\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Method for Type Search Example (Scala)\nDESCRIPTION: Presents a Scala 3 extension method definition (`span` on `IArray`) to serve as an example of a declaration that can be searched for using its type signature. This snippet helps illustrate the concept of mapping code to a searchable type representation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/search-engine.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nextension [T](arr: IArray[T]) def span(p: T => Boolean): (IArray[T], IArray[T]) = ...\n```\n\n----------------------------------------\n\nTITLE: map Operation Using iterableFactory in IterableOps - Scala 2\nDESCRIPTION: This snippet demonstrates how the map operation leverages iterableFactory, which is expected to be implemented in the concrete subclass and provides a from method to build new collection instances. This allows for proper construction of mapped collections using the associated factory. The transformation function (f: A => B) is passed to View.Map for lazy evaluation. Dependencies include IterableFactory and View.Map.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\ntrait IterableOps[+A, +CC[_], +C] {\n\n  def iterableFactory: IterableFactory[CC]\n  \n  def map[B](f: A => B): CC[B] = \n    iterableFactory.from(new View.Map(this, f))  \n}\n```\n\n----------------------------------------\n\nTITLE: Using Ambiguous Extension Methods Imported From Multiple Sources in Scala\nDESCRIPTION: This snippet shows an example where importing extension methods with identical names from different sources (`A` and `B`) causes ambiguity. It demonstrates the problem where calling `foo.meth()` is disambiguated by this SIP, while direct calls to `meth(foo)()` or `normalMeth(foo)` remain ambiguous. This snippet illustrates the motivation for the proposal to relax overload resolution to correctly pick the extension method matching the receiver type when multiple imports exist. Requires prior definitions of `Foo`, `Bar`, and extension methods in `A` and `B`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/multi-source-extension-overloads.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport A.*\nimport B.*\n\nval foo: Foo = ???\nfoo.meth() // works with this SIP; \"ambiguous import\" without it\n\n// unchanged:\nmeth(foo)() // always ambiguous, just like\nnormalMeth(foo) // always ambiguous\n```\n\n----------------------------------------\n\nTITLE: Using @unroll in a Subsequent Parameter List of a Curried Method in Scala\nDESCRIPTION: Example demonstrating that `@unroll` can be applied to parameters in a parameter list other than the first one in a multi-parameter-list method. However, only a single parameter list within the method can be targeted for unrolling.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/unroll-default-arguments.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nobject Unrolled{\n   def foo(blah: Blah)\n          (s: String,\n           n: Int = 1,\n           @unroll b: Boolean = true,\n           @unroll l: Long = 0) = s + n + b + l\n}\n```\n\n----------------------------------------\n\nTITLE: Multi-line Strings in Scala\nDESCRIPTION: Shows how to create multi-line strings using triple quotes, which preserve line breaks and formatting.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-vars-data-types.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nval quote = \"\"\"The essence of Scala:\n               Fusion of functional and object-oriented\n               programming in a typed setting.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Определение долговременного алгоритма для Future в Scala\nDESCRIPTION: Функция, имитирующая долговременный алгоритм с задержкой в 10 секунд, используемая для демонстрации работы Future.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/concurrency.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef longRunningAlgorithm() =\n  Thread.sleep(10_000)\n  42\n```\n\n----------------------------------------\n\nTITLE: Detailed Inlining Steps for Recursive Power Function in Scala\nDESCRIPTION: Provides the subsequent inlining and partial evaluation steps for the `power(2, 2)` example. It shows the complete unrolling of the recursion at compile time, demonstrating how the compiler eliminates further dead branches and simplifies the expression down to `x2 * 1.0`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\n// then inlined as\nval x = 2\nval x2 = x * x\nif (1 == 0) 1.0 // dead branch\nelse if (1 % 2 == 1) x2 * power(x2, 1 - 1)\nelse power(x2 * x2, 1 / 2) // dead branch\n// partially evaluated to\nval x = 2\nval x2 = x * x\nx2 * power(x2, 0)\n// then inlined as\nval x = 2\nval x2 = x * x\nx2 * {\n  if (0 == 0) 1.0\n  else if (0 % 2 == 1) x2 * power(x2, 0 - 1) // dead branch\n  else power(x2 * x2, 0 / 2) // dead branch\n}\n// partially evaluated to\nval x = 2\nval x2 = x * x\nx2 * 1.0\n```\n\n----------------------------------------\n\nTITLE: Extracting Function and Argument via Pattern Matching on Apply Trees in Scala\nDESCRIPTION: This example shows two idiomatic ways to pattern match on an Apply tree node to extract its function and argument. The first uses a match expression; the alternative uses pattern matching directly in a value assignment. Both methods take advantage of Scala Pattern Matching to deconstruct AST nodes for analysis or transformation. These patterns require prior construction of an Apply tree.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\nval (fun, arg) = tree match {\n  case Apply(fn, a :: Nil) => (fn, a)\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval Apply(fun, arg :: Nil) = tree\n```\n\n----------------------------------------\n\nTITLE: Obtaining TypeTags via scala.reflect.runtime.universe.typeTag (Scala)\nDESCRIPTION: Demonstrates how to obtain a TypeTag instance for a specific type using the scala.reflect.runtime.universe.typeTag method, which is part of Scala reflection. Requires importing scala.reflect.runtime.universe._ to access the typeTag method. The snippet obtains a TypeTag for the Int type and a ClassTag for the String type, showcasing the difference between full type descriptors (TypeTag) and class-only descriptors (ClassTag). The output is stored in vals for further type introspection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/typetags-manifests.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\nval tt = typeTag[Int]\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect._\nval ct = classTag[String]\n```\n\n----------------------------------------\n\nTITLE: Importing the Scala ArrayBuffer Class\nDESCRIPTION: This snippet demonstrates importing the ArrayBuffer class from Scala's mutable collection package, which is necessary for creating and manipulating ArrayBuffer instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/arraybuffer-examples.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.mutable.ArrayBuffer\n```\n\n----------------------------------------\n\nTITLE: Pretty-Printing Scala Reflection Trees Using show and showRaw - Scala\nDESCRIPTION: Provides methods for displaying Scala reflection Trees in a 'prettified' human-readable form or as detailed raw abstract syntax trees (ASTs). The example imports runtime reflection, creates an AST for a final class with a method, and prints the desugared Java-like code using show, then inspects the detailed internal tree structure with showRaw. It highlights that showRaw is mainly suitable for inspection rather than macro construction due to partial symbol representation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/annotations-names-scopes.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nscala> import scala.reflect.runtime.universe._\nimport scala.reflect.runtime.universe._\n\nscala> def tree = reify { final class C { def x = 2 } }.tree\ntree: scala.reflect.runtime.universe.Tree\n\nscala> show(tree)\nres0: String =\n{\n  final class C extends AnyRef {\n    def <init>() = {\n      super.<init>();\n      ()\n    };\n    def x = 2\n  };\n  ()\n}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nscala> showRaw(tree)\nres1: String = Block(List(\n  ClassDef(Modifiers(FINAL), TypeName(\"C\"), List(), Template(\n    List(Ident(TypeName(\"AnyRef\"))),\n    emptyValDef,\n    List(\n      DefDef(Modifiers(), termNames.CONSTRUCTOR, List(), List(List()), TypeTree(),\n        Block(List(\n          Apply(Select(Super(This(typeNames.EMPTY), typeNames.EMPTY), termNames.CONSTRUCTOR), List())),\n          Literal(Constant(())))),\n      DefDef(Modifiers(), TermName(\"x\"), List(), List(), TypeTree(),\n        Literal(Constant(2))))))),\n  Literal(Constant(())))\n```\n\n----------------------------------------\n\nTITLE: Defining a list for reduce demonstration in Scala\nDESCRIPTION: Creating a list of integers that will be used to demonstrate the reduce method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/collections-methods.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nval a = List(1,2,3,4)\n```\n\n----------------------------------------\n\nTITLE: Using Automatic Result Variables in REPL - Scala\nDESCRIPTION: Illustrates how the REPL assigns unnamed results to automatically-named variables ('res0', 'res1', etc.) when the user does not provide an explicit variable name. These variables can be reused in subsequent expressions, enabling incremental and exploratory programming. No explicit dependencies are required beyond starting a REPL session.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/scala-repl.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nscala> 2 + 2\nres0: Int = 4\n\nscala> 3 / 3\nres1: Int = 1\n```\n\n----------------------------------------\n\nTITLE: Marking a Failing Snippet That Incorrectly Compiles\nDESCRIPTION: This Scala snippet demonstrates the use of the `sc:fail` flag on a code block that actually compiles successfully (converting a `List` of tuples to a `Map`). In this scenario, the snippet compiler will report an error because the code was expected to fail but didn't.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/snippet-compiler.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n```scala sc:fail\nList((1,2), (2,3)).toMap\n```\n```\n\n----------------------------------------\n\nTITLE: Declaring a printf Macro and Its Implementation Signature (Scala)\nDESCRIPTION: Declares a macro method `printf` with a standard function signature but with its body referring to a macro implementation `printf_impl`. The implementation method is declared with the compiler context parameter, followed by expression parameters representing the format string and variadic parameters. This establishes the correspondence between macro definitions and macro implementations, requiring `import scala.language.experimental.macros` to enable macro support.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/overview.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.language.experimental.macros\ndef printf(format: String, params: Any*): Unit = macro printf_impl\n\nimport scala.reflect.macros.Context\ndef printf_impl(c: Context)(format: c.Expr[String], params: c.Expr[Any]*): c.Expr[Unit] = ...\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Constant Literal Values Using Scala Reflection (Scala)\nDESCRIPTION: Shows how to use pattern matching on Constant objects in Scala reflection to determine the underlying literal type and value. The example matches on strings and booleans wrapped within Constant, printing corresponding messages. It also verifies the actual value held by a Constant instance. This snippet requires scala.reflect.runtime.universe.Constant for type-safe inspection of compile-time literals.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/reflection/annotations-names-scopes.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nConstant(true) match {\n  case Constant(s: String)  => println(\"A string: \" + s)\n  case Constant(b: Boolean) => println(\"A Boolean value: \" + b)\n  case Constant(x)          => println(\"Something else: \" + x)\n}\nassert(Constant(true).value == true)\n```\n\n----------------------------------------\n\nTITLE: Using Unliftable for Pattern Matching with Quasiquotes in Scala\nDESCRIPTION: Demonstrates how implicit Unliftable instances enable pattern matching on quasiquote syntax trees with ascribed variable types. This snippet shows extracting integer values from the tree representation of an addition expression using quasiquotes. It also illustrates combining unquote splicing with unlifting to extract lists of values from argument lists in function calls, enabling element-wise conversion and collection into lists.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/unlifting.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"${left: Int} + ${right: Int}\" = q\"2 + 2\"\nleft: Int = 2\nright: Int = 2\n\nscala> left + right\nres4: Int = 4\n\nscala> val q\"f(..${ints: List[Int]})\" = q\"f(1, 2, 3)\"\nints: List[Int] = List(1, 2, 3)\n\nscala> val q\"f(...${intss: List[List[Int]]})\" = q\"f(1, 2, 3)(4, 5)(6)\"\nintss: List[List[Int]] = List(List(1, 2, 3), List(4, 5), List(6))\n```\n\n----------------------------------------\n\nTITLE: Creating Single Tree for Splicing Combination (Scala)\nDESCRIPTION: Creates a single `universe.Tree` variable (`c`), used in subsequent examples to show how regular `$` unquoting can be combined with `..$` splicing when constructing trees.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/intro.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val c = q\"c\"\nc: universe.Ident = c\n```\n\n----------------------------------------\n\nTITLE: Defining Static Members in Scala.js Objects - Scala\nDESCRIPTION: Shows how to apply the `@static` annotation within a Scala object intended for Scala.js interoperability, where the object and its companion class extend `js.Object`. This demonstrates the Scala-side syntax for defining static members exposed to JavaScript.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/static-members.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n@ScalaJSDefined\nclass Foo extends js.Object\n\n@ScalaJSDefined\nobject Foo extends js.Object {\n  @static val x = 5\n  @static def bar(y: Int): Int = x + y\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring the printf Macro Implementation Using scala.reflect.macros.Context in Scala\nDESCRIPTION: Declares the macro implementation method `printf_impl` matching the signature requirements for macros. It takes a macro context `c: Context` as the first parameter list and typed expressions matching the macro signature in the second list. It returns an expression of type `Unit`. This method forms the core of macro expansion logic.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/overview.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.macros.Context\ndef printf_impl(c: Context)(format: c.Expr[String], params: c.Expr[Any]*): c.Expr[Unit] = ...\n```\n\n----------------------------------------\n\nTITLE: Creating a Book Instance with Structural Typing in Scala 3\nDESCRIPTION: Example showing how to instantiate a Book structural type by creating a Record with the appropriate fields and casting it to the Book type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/types-structural.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval book = Record(\n  \"title\" -> \"The Catcher in the Rye\",\n  \"author\" -> \"J. D. Salinger\",\n  \"year\" -> 1951,\n  \"rating\" -> 4.5\n).asInstanceOf[Book]\n```\n\n----------------------------------------\n\nTITLE: Invalid Method Overloading with Default Parameters in Scala 3\nDESCRIPTION: The Scala 3 version of the overloading limitation example, showing the same concept with Scala 3's optional braces syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/default-parameter-values.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nobject A:\n  def func(x: Int = 34): Unit\n  def func(y: String = \"abc\"): Unit\n```\n\n----------------------------------------\n\nTITLE: Completing `map` Function Signature with Return Type\nDESCRIPTION: Finalizes the Scala `map` function signature by specifying the return type `List[A]`. The function body is indicated as unimplemented with `???`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-write-map-function.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef map[A](f: (Int) => A, xs: List[Int]): List[A] = ???\n```\n\n----------------------------------------\n\nTITLE: Definition and Implementation of RNA Class in Scala 2\nDESCRIPTION: The Scala 2 implementation defines a final immutable class `RNA` that extends sequence traits for efficient sequence operations, using bit manipulation to store nucleotide bases. It provides methods for constructing, modifying, and iterating over RNA sequences, along with a companion object offering factory methods for creation from collections. The class is optimized for performance through overrides of essential methods like `iterator` and sequence concatenation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_21\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.{AbstractIterator, SpecificIterableFactory, StrictOptimizedSeqOps, View, mutable}\nimport scala.collection.immutable.{IndexedSeq, IndexedSeqOps}\n\nfinal class RNA private (\n  val groups: Array[Int],\n  val length: Int\n) extends IndexedSeq[Base]\n    with IndexedSeqOps[Base, IndexedSeq, RNA]\n    with StrictOptimizedSeqOps[Base, IndexedSeq, RNA] { rna =>\n\n  import RNA._\n\n  // Mandatory implementation of `apply` in `IndexedSeqOps`\n  def apply(idx: Int): Base = {\n    if (idx < 0 || length <= idx)\n      throw new IndexOutOfBoundsException\n    Base.fromInt(groups(idx / N) >> (idx % N * S) & M)\n  }\n\n  // Mandatory overrides of `fromSpecific`, `newSpecificBuilder`,\n  // and `empty`, from `IterableOps`\n  override protected def fromSpecific(coll: IterableOnce[Base]): RNA =\n    RNA.fromSpecific(coll)\n  override protected def newSpecificBuilder: mutable.Builder[Base, RNA] =\n    RNA.newBuilder\n  override def empty: RNA = RNA.empty\n\n  // Overloading of `appended`, `prepended`, `appendedAll`, `prependedAll`,\n  // `map`, `flatMap` and `concat` to return an `RNA` when possible\n  def concat(suffix: IterableOnce[Base]): RNA =\n    strictOptimizedConcat(suffix, newSpecificBuilder)\n  @inline final def ++ (suffix: IterableOnce[Base]): RNA = concat(suffix)\n  def appended(base: Base): RNA =\n    (newSpecificBuilder ++= this += base).result()\n  def appendedAll(suffix: Iterable[Base]): RNA =\n    strictOptimizedConcat(suffix, newSpecificBuilder)\n  def prepended(base: Base): RNA =\n    (newSpecificBuilder += base ++= this).result()\n  def prependedAll(prefix: Iterable[Base]): RNA =\n    (newSpecificBuilder ++= prefix ++= this).result()\n  def map(f: Base => Base): RNA =\n    strictOptimizedMap(newSpecificBuilder, f)\n  def flatMap(f: Base => IterableOnce[Base]): RNA =\n    strictOptimizedFlatMap(newSpecificBuilder, f)\n\n  // Optional re-implementation of iterator,\n  // to make it more efficient.\n  override def iterator: Iterator[Base] = new AbstractIterator[Base] {\n    private var i = 0\n    private var b = 0\n    def hasNext: Boolean = i < rna.length\n    def next(): Base = {\n      b = if (i % N == 0) groups(i / N) else b >>> S\n      i += 1\n      Base.fromInt(b & M)\n    }\n  }\n\n  override def className = \"RNA\"\n}\n\nobject RNA extends SpecificIterableFactory[Base, RNA] {\n\n  private val S = 2            // number of bits in group\n  private val M = (1 << S) - 1 // bitmask to isolate a group\n  private val N = 32 / S       // number of groups in an Int\n\n  def fromSeq(buf: collection.Seq[Base]): RNA = {\n    val groups = new Array[Int]((buf.length + N - 1) / N)\n    for (i <- 0 until buf.length)\n      groups(i / N) |= Base.toInt(buf(i)) << (i % N * S)\n    new RNA(groups, buf.length)\n  }\n\n  // Mandatory factory methods: `empty`, `newBuilder`\n  // and `fromSpecific`\n  def empty: RNA = fromSeq(Seq.empty)\n\n  def newBuilder: mutable.Builder[Base, RNA] =\n    mutable.ArrayBuffer.newBuilder[Base].mapResult(fromSeq)\n\n  def fromSpecific(it: IterableOnce[Base]): RNA = it match {\n    case seq: collection.Seq[Base] => fromSeq(seq)\n    case _ => fromSeq(mutable.ArrayBuffer.from(it))\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Workarounds for Named Tuple Compatibility Issues in Scala\nDESCRIPTION: Provides workarounds for the compatibility issues with assignments and method calls when using named tuples.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-tuples.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\n{age = 1}     // ok\nc.f(age = 1)  // ok\n```\n\n----------------------------------------\n\nTITLE: Abstract Override Behavior Change in Scala 2 vs 3\nDESCRIPTION: Demonstrates how overriding a concrete method with an abstract method affects subclasses differently in Scala 2 and 3. In Scala 3, such methods are considered abstract in subclasses.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-other-changes.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntrait A {\n  def bar(x: Int): Int = x + 3\n}\n\ntrait B extends A {\n  def bar(x: Int): Int\n}\n\nclass C extends B // In Scala 3, Error: class C needs to be abstract, since def bar(x: Int): Int is not defined\n```\n\n----------------------------------------\n\nTITLE: Implementing Witness and Type Tagging in Scala for Singleton Types\nDESCRIPTION: This snippet from shapeless library demonstrates how singleton types are implemented and used. It includes the Witness trait for representing singleton types, the labelled object for field type tagging, and SingletonOps for operating on singleton values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/42.type.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ntrait Witness {\n  type T           // the singleton type represented by this Witness\n  val value: T {}  // the unique inhabitant of that type\n}\n\nobject Witness extends Dynamic {\n  type Aux[T0] = Witness { type T = T0 }\n  type Lt[Lub] = Witness { type T <: Lub }\n\n  /**\n   * Materialize the Witness for singleton type T\n   */\n  implicit def apply[T]: Witness.Aux[T] = macro ...\n\n  /**\n   * Convert a literal value to its Witness\n   */\n  implicit def apply[T](t: T): Witness.Lt[T] = macro ...\n}\n\nobject labelled {\n  /**\n   * The type of fields with keys of singleton type `K` and value type `V`.\n   */\n  type FieldType[K, +V] = V with KeyTag[K, V]\n  trait KeyTag[K, +V]\n\n  /**\n   * Yields a result encoding the supplied value with the singleton type `K' as its key.\n   */\n  def field[K] = new FieldBuilder[K]\n\n  class FieldBuilder[K] {\n    def apply[V](v : V): FieldType[K, V] = v.asInstanceOf[FieldType[K, V]]\n  }\n}\n\nobject singleton {\n  implicit def mkSingletonOps(t: Any): SingletonOps = macro ...\n}\n\ntrait SingletonOps {\n  import labelled._\n\n  type T\n\n  /**\n   * Returns a Witness of the singleton type of this value.\n   */\n  val witness: Witness.Aux[T]\n\n  /**\n   * Narrows this value to its singleton type.\n   */\n  def narrow: T {} = witness.value\n\n  /**\n   * Returns the provided value tagged with the singleton type\n   * of this value as its key in a record-like structure.\n   */\n  def ->>[V](v: V): FieldType[T, V] = field[T](v)\n}\n```\n\n----------------------------------------\n\nTITLE: Double Definitions with Empty Parens Example\nDESCRIPTION: Shows a case where a method defined both with and without empty parentheses is allowed in Scala 2 but produces a double definition error in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tooling-scala2-xsource3.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass C(x: Int) {\n  def x(): Int = x // allowed in Scala 2, double definition error in Scala 3\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RNA Base Types and Integer Mapping - Scala 2\nDESCRIPTION: Presents an abstract Base class with four case objects for RNA nucleotides (A, U, G, C), plus a companion object with utility functions for mapping between the bases and integer representations. fromInt uses an array for constant-time lookup, and toInt uses a Map for reverse mapping; both leverage Scala's treating of collections as functions. No dependencies beyond Scala core. Inputs are ints or base instances; outputs are the mapped base or integer index. Suited for compact sequence encoding. Limitations: only four bases supported, indices must be 0..3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_8\n\nLANGUAGE: Scala 2\nCODE:\n```\nabstract class Base\ncase object A extends Base\ncase object U extends Base\ncase object G extends Base\ncase object C extends Base\n\nobject Base {\n  val fromInt: Int => Base = Array(A, U, G, C)\n  val toInt: Base => Int = Map(A -> 0, U -> 1, G -> 2, C -> 3)\n}\n```\n\n----------------------------------------\n\nTITLE: Example Snippet Requiring Context (Scala)\nDESCRIPTION: A Scala code snippet comparing `slice` with `drop` and `take`. This code relies on being executed within the context of a `List` instance to resolve the methods.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/snippet-compiler.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nslice(2, 5) == drop(2).take(3)\n```\n\n----------------------------------------\n\nTITLE: Constructing New Instances with Quasiquotes in Scala\nDESCRIPTION: This snippet shows how to generate a new object creation tree, including inherited types and additional body definitions. It leverages quasiquotes to represent 'new' expressions with optional refinements, useful for code generation and meta-programming in Scala macros.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_53\n\nLANGUAGE: Scala\nCODE:\n```\nval q\"new ..$parents { ..$body }\" = q\"new Foo(1) with Bar { def baz = 2 }\"\n```\n\n----------------------------------------\n\nTITLE: Preparing Tree for Unquoting (Scala)\nDESCRIPTION: Creates a `universe.Tree` variable using `q` that will be used later for unquoting (structural substitution) into another quasiquote. This shows how a piece of syntax can be captured as a tree.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/intro.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val aquasiquote = q\"a quasiquote\"\naquasiquote: universe.Select = a.quasiquote\n```\n\n----------------------------------------\n\nTITLE: Combining Macro and Manual Implicits for Type Classes (Scala)\nDESCRIPTION: Demonstrates the seamless integration of implicit macros with standard implicit definitions. An implicit `def` `listShowable` provides a `Showable` instance for `List[T]`, provided a `Showable[T]` instance exists (which could be materialized by the `materializeShowable` macro). The example shows calling `show` on a `List[Int]`, where `Showable[Int]` is generated by the macro and `Showable[List[Int]]` is provided by the manual implicit.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/implicits.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimplicit def listShowable[T](implicit s: Showable[T]) =\n  new Showable[List[T]] {\n    def show(x: List[T]) = { x.map(s.show).mkString(\"List(\", \", \", \")\")\n  }\n}\nshow(List(42)) // prints: List(42)\n```\n\n----------------------------------------\n\nTITLE: Using Classloader Mirror for Compile-Time Reflection in Scala Macros\nDESCRIPTION: This snippet exemplifies compile-time reflection in Scala macros using a classloader mirror accessed from the macro context. It defines a macro to capture the current source code location by accessing position information (filename, line, column) and creating an expression using the classloader mirror to locate the Location object symbol. This example requires a macro definition environment and the scala.reflect.macros.Context. Inputs include macro context and macro application position, while output is a tree-expression representing the Location instantiation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/reflection/environment-universes-mirrors.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect.macros.Context\n\ncase class Location(filename: String, line: Int, column: Int)\n\nobject Macros {\n  def currentLocation: Location = macro impl\n\n  def impl(c: Context): c.Expr[Location] = {\n    import c.universe._\n    val pos = c.macroApplication.pos\n    val clsLocation = c.mirror.staticModule(\"Location\") // get symbol of \"Location\" object\n    c.Expr(Apply(Ident(clsLocation), List(Literal(Constant(pos.source.path)), Literal(Constant(pos.line)), Literal(Constant(pos.column)))))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing and Deconstructing Pattern Matches with Scala Quasiquotes\nDESCRIPTION: Shows how to construct and deconstruct `Match` ASTs. The `q\"$expr match { case ..$cases }\"` pattern extracts the matched expression and a list of `CaseDef` trees. Individual cases can be further deconstructed using the `cq\"...\"` interpolator.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_43\n\nLANGUAGE: scala\nCODE:\n```\nscala> val q\"$expr match { case ..$cases }\" = \n               q\"foo match { case _: Foo => 'foo case _ => 'notfoo }\"\nexpr: universe.Tree = foo\ncases: List[universe.CaseDef] = List(case (_: Foo) => scala.Symbol(\"foo\"), case _ => scala.Symbol(\"notfoo\"))\n\nscala> val cq\"$pat1 => $body1\" :: cq\"$pat2 => $body2\" :: Nil = cases\npat1: universe.Tree = (_: Foo)\nbody1: universe.Tree = scala.Symbol(\"foo\")\npat2: universe.Tree = _\nbody2: universe.Tree = scala.Symbol(\"notfoo\")\n```\n\n----------------------------------------\n\nTITLE: Constructing Assign and Update Quasiquotes - Scala\nDESCRIPTION: Demonstrates creating AST nodes for variable assignment (`=`) and collection update syntax (`obj(args) = expr`) using quasiquotes. The update syntax `array(0) = 1` is shown to be syntactic sugar for an `update` method call (`array.update(0, 1)`) in the resulting AST.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val assign = q\"x = 2\"\nassign: universe.Tree = x = 2\n\nscala> val update = q\"array(0) = 1\"\nupdate: universe.Tree = array.update(0, 1)\n```\n\n----------------------------------------\n\nTITLE: Using FromExpr to Extract Values from Expressions in Scala\nDESCRIPTION: This code defines extension methods for `Expr[T]` to extract runtime values using `FromExpr` instances, providing `value` and `valueOrError` methods. It also shows how to implement `FromExpr` for specific types like `Boolean` and `StringContext`, enabling pattern matching on expressions to generate runtime values, essential for macro-based code generation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_27\n\nLANGUAGE: Scala\nCODE:\n```\nextension [T](expr: Expr[T]):\n  def value(using Quotes)(using fromExpr: FromExpr[T]): Option[T] =\n    fromExpr.unapply(expr)\n\n  def valueOrError(using Quotes)(using fromExpr: FromExpr[T]): T =\n    fromExpr.unapply(expr).getOrElse(report.throwError(\"...\", expr))\n\nobject Expr:\n  def unapply[T](expr: Expr[T])(using Quotes)(using fromExpr: FromExpr[T]): Option[T] =\n    fromExpr.unapply(expr)\n\n// Implementations of FromExpr\ngiven FromExpr[Boolean] with {\n  def unapply(x: Expr[Boolean])(using Quotes): Option[Boolean] =\n    x match\n      case '{ true } => Some(true)\n      case '{ false } => Some(false)\n      case _ => None\n}\n\ngiven FromExpr[StringContext] with {\n  def unapply(x: Expr[StringContext])(using Quotes): Option[StringContext] = x match {\n    case '{ new StringContext(${Varargs(Exprs(args))}*) } => Some(StringContext(args*))\n    case '{     StringContext(${Varargs(Exprs(args))}*) } => Some(StringContext(args*))\n    case _ => None\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Deconstructing a Secondary Constructor Definition in Scala\nDESCRIPTION: Illustrates the specific quasiquote pattern (`q\"def this(...$paramss) = this(...$argss)\"`) designed to match and deconstruct secondary constructor definitions in Scala. This example extracts parameter lists and constructor call arguments from `def this() = this(0)`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/definition-details.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"$mods def this(...$paramss) = this(...$argss)\" =\n           q\"def this() = this(0)\"\nmods: universe.Modifiers = Modifiers(, , Map())\nparamss: List[List[universe.ValDef]] = List(List())\nargss: List[List[universe.Tree]] = List(List(0))\n```\n\n----------------------------------------\n\nTITLE: Scala 2: Imperative loop for doubling numbers\nDESCRIPTION: This Scala 2 code snippet demonstrates a traditional imperative approach to process a list of integers by iterating with a for-loop and accumulating results in a mutable buffer before converting to an immutable list.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/scala-features.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable.ListBuffer\n\ndef double(ints: List[Int]): List[Int] = {\n  val buffer = new ListBuffer[Int]()\n  for (i <- ints) {\n    buffer += i * 2\n  }\n  buffer.toList\n}\n\nval oldNumbers = List(1, 2, 3)\nval newNumbers = double(oldNumbers)\n```\n\n----------------------------------------\n\nTITLE: Legal Parenthesized Type Ascription after Colon in Scala\nDESCRIPTION: This snippet provides another legal form for type ascription compatible with fewerBraces rules. The function type '(Int => Int) => Int' follows the colon on a new line, maintaining validity and avoiding the parsing ambiguity introduced by the previous example. This is relevant when upgrading code bases affected by SIP-44.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nval y = (xs.map: (Int => Int)\n  => Int)\n```\n\n----------------------------------------\n\nTITLE: Defining IterableFactory with from Method - Scala 2\nDESCRIPTION: This snippet outlines the IterableFactory trait, an abstraction for factories that produce collection instances. The from method takes an IterableOnce of elements and constructs a corresponding collection, supporting flexible creation patterns in the collections framework. It must be implemented by concrete companion objects of specific collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\ntrait IterableFactory[+CC[_]] {\n  def from[A](source: IterableOnce[A]): CC[A]\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Android App via ADB\nDESCRIPTION: Installs an Android application from a specified APK file onto a connected Android device or emulator using the Android Debug Bridge (ADB). Replace '<path to APK>' with the actual file path to the generated APK file (e.g., target/client/aarch64-android/gvm/yourapp.apk). Requires ADB, a connected device/emulator recognized by 'adb devices', and appropriate permissions enabled on the device (USB Debugging, Install via USB).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-on-android.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nadb install <path to APK>\n```\n\n----------------------------------------\n\nTITLE: Using @unroll in the First Parameter List of a Curried Method in Scala\nDESCRIPTION: Example showing the `@unroll` annotation applied to parameters within the first parameter list of a method with multiple parameter lists (curried method). Only one parameter list can be unrolled.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/unroll-default-arguments.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nobject Unrolled{\n   def foo(s: String,\n           n: Int = 1,\n           @unroll b: Boolean = true,\n           @unroll l: Long = 0)\n          (implicit blah: Blah) = s + n + b + l\n}\n```\n\n----------------------------------------\n\nTITLE: Lifting Values to Literal Quasiquotes - Scala\nDESCRIPTION: Illustrates the 'lifting' mechanism where Scala values of literal types can be directly interpolated into quasiquotes using `$` to create corresponding AST nodes. This works for most literal types but has limitations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val x = 1\nx: Int = 1\nscala> val one = q\"$x\"\none: universe.Tree = 1\n```\n\n----------------------------------------\n\nTITLE: Defining Scala MapOps Template Trait\nDESCRIPTION: Defines the `MapOps` trait, a template for collections with two type parameters like `Map[K, V]`. It inherits from `IterableOps` and provides a specialized `map` method signature designed to handle key-value pairs and potentially return a collection of the same type constructor `CC[_, _]`. This trait is necessary because `IterableOps` is designed for single-parameter collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_8\n\nLANGUAGE: Scala 2\nCODE:\n```\ntrait MapOps[K, +V, +CC[_, _], +C] extends IterableOps[(K, V), Iterable, C] {\n  def map[K2, V2](f: ((K, V)) => (K2, V2)): CC[K2, V2] = …\n}\n```\n\nLANGUAGE: Scala 3\nCODE:\n```\ntrait MapOps[K, +V, +CC[_, _], +C] extends IterableOps[(K, V), Iterable, C]:\n  def map[K2, V2](f: ((K, V)) => (K2, V2)): CC[K2, V2] = …\n```\n\n----------------------------------------\n\nTITLE: Matching Assign and Update Specifically - Scala\nDESCRIPTION: Demonstrates how to differentiate between direct assignment and update syntax during pattern matching by using more specific patterns for the left-hand side. A `q\"${ref: RefTree} = $expr\"` pattern matches direct assignments, while `q\"$obj(..$args) = $expr\"` matches the update syntax based on its underlying application structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_22\n\nLANGUAGE: Scala\nCODE:\n```\nscala> List(assign, update).foreach {\n             case q\"${ref: RefTree} = $expr\" =>\n               println(s\"assign $expr to $ref\")\n             case q\"$obj(..$args) = $expr\" =>\n               println(s\"update $obj at $args with $expr\")\n           }\nassign 2 to x\nupdate array at List(0) with 1\n```\n\n----------------------------------------\n\nTITLE: Scala Fibonacci Iterator Implementation\nDESCRIPTION: An iterator class generating Fibonacci numbers with traditional single-variable updates, illustrating the limitations of sequential assignment for defining the Fibonacci sequence.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/multiple-assignments.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass FibonacciIterator() extends Iterator[Int]:\n\n  private var a: Int = 0\n  private var b: Int = 1\n\n  def hasNext = true\n  def next() =\n    val r = a\n    val n = a + b\n    a = b\n    b = n\n    r\n```\n\n----------------------------------------\n\nTITLE: Viewing TASTy file contents using scalac in Bash\nDESCRIPTION: These shell commands invoke the Scala compiler with flags to display the internal TASTy representation of a compiled Scala file. The '-print-tasty' flag shows a human-readable format of the typed AST, and '-decompile' prints a decompiled Scala-like source code. These commands require the scalac compiler and a valid '.tasty' file as input.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/scala3/guides/tasty-overview.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ scalac -print-tasty hello.tasty\n$ scalac -decompile hello.tasty\n```\n\n----------------------------------------\n\nTITLE: If Expression with Indented Operator in Scala\nDESCRIPTION: This snippet illustrates the use of Scala 3's flexible parsing rules that allow operators after a line break within an `if` expression. The logical AND operator is placed on a separate indented line, showcasing how the parser accommodates operator precedence and whitespace sensitivity. This example highlights the new control syntax and its implications for readability and parsing behavior. No external dependencies are needed, and the snippet is primarily for explaining the parser's capabilities with the new syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/minutes/2020-03-13-sip-minutes.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nif (x || y)\n  && (a || b) then foo()\n```\n\n----------------------------------------\n\nTITLE: Comparing q and tq Tree Structure (Scala)\nDESCRIPTION: Demonstrates that the `q` (expression/definition) and `tq` (type) interpolators produce distinct `universe.Tree` structures, even for syntactically similar inputs like `List[Int]`. Choosing the correct interpolator is crucial.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/intro.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nscala> println(q\"List[Int]\" equalsStructure tq\"List[Int]\")\nfalse\n```\n\n----------------------------------------\n\nTITLE: Binding Multiple Type Variables with Pattern Variables in Scala Macros\nDESCRIPTION: This code demonstrates defining multiple type variables (`u`, `v`) within a pattern using `type` declarations, enabling the transformation of chained `map` calls into a single `map`. It shows how to bind and reuse type variables in macro patterns for more concise and efficient code generation, including handling type bounds.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_25\n\nLANGUAGE: Scala\nCODE:\n```\ndef fuseMap[T: Type](x: Expr[List[T]])(using Quotes): Expr[List[T]] = x match {\n  case '{\n    type u\n    type v\n    ($ls: List[`u`])\n      .map($f: `u` => `v`)\n      .map($g: `v` => T)\n    } =>\n    '{ $ls.map(y => $g($f(y))) }\n  case _ => x\n}\n```\n\n----------------------------------------\n\nTITLE: Deconstructing Case Clauses (`cq`) with Scala Quasiquotes\nDESCRIPTION: Demonstrates deconstructing individual `CaseDef` trees using the `cq\"$pat if $guard => $body\"` pattern. It extracts the pattern, the guard expression, and the body expression. An absent guard is represented by `EmptyTree` (`<empty>`), and an absent body is represented by a synthetic `Unit` literal `()`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_44\n\nLANGUAGE: scala\nCODE:\n```\nscala> val cq\"$pat if $expr1 => $expr2\" = cq\"_ =>\"\npat: universe.Tree = _\nexpr1: universe.Tree = <empty>\nexpr2: universe.Tree = ()\n```\n\n----------------------------------------\n\nTITLE: Defining and Deconstructing Type Identifiers in Scala Quasiquotes - Scala\nDESCRIPTION: Demonstrates constructing a type identifier using TypeName and quasiquotes, then deconstructing it via pattern matching. Requires the Scala reflection API via 'import scala.reflect.runtime.universe._'. Here, 'name' is constructed as a TypeName object, then interpolated into a quasiquote, and finally extracted back. Inputs include the type name string; outputs include the corresponding universe.TypeName or universe.Ident instances.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/type-details.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval name = TypeName(\"Foo\")\nval foo = tq\"$name\"\nval tq\"${name: TypeName}\" = tq\"Foo\"\n```\n\n----------------------------------------\n\nTITLE: Using match Expression for Pattern Matching in Python\nDESCRIPTION: Introduces Python's structural pattern matching feature (available from Python 3.10), matching the variable 'month' against cases for 1, 2, and the default. Assigns human-readable month names or 'Other' based on 'month' value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_29\n\nLANGUAGE: Python\nCODE:\n```\n# From 3.10, Python supports structural pattern matching\n# You can also use dictionaries for basic “switch” functionality\nmatch month:\n  case 1:\n    monthAsString = \"January\"\n  case 2:\n    monthAsString = \"February\"\n  case _:\n    monthAsString = \"Other\"\n```\n\n----------------------------------------\n\nTITLE: Scala Quasiquote Pattern for Trait Definition\nDESCRIPTION: Presents the general Scala quasiquote pattern for matching or constructing a trait definition AST. The structure is similar to a class but lacks constructor value parameters and constructor modifiers.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/definition-details.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\n q\"$mods trait $tpname[..$tparams] extends { ..$earlydefns } with ..$parents { $self => ..$stats }\"\n```\n\n----------------------------------------\n\nTITLE: Combining $ Unquoting and ..$ Splicing (Prefix) (Scala)\nDESCRIPTION: Shows inserting a single tree using `$` unquoting (`c`) followed by a list of trees using `..$` splicing (`ab`) within a function application in a `q` quasiquote. Demonstrates another order of combining unquoting and splicing.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/intro.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val fcab = q\"f($c, ..$ab)\"\nfcab: universe.Tree = f(c, a, b)\n```\n\n----------------------------------------\n\nTITLE: Querying Types for Members and Declarations\nDESCRIPTION: Shows how to query a Type for its members and declarations using methods like member, decl, members, and decls. Includes examples for looking up specific members by name.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n\ntypeOf[List[_]].member(TermName(\"map\")) // Returns the Symbol for the map method\ntypeOf[List[_]].member(TypeName(\"Self\")) // Returns the Symbol for the Self type\n```\n\nLANGUAGE: scala\nCODE:\n```\ntypeOf[List[Int]].members.filter(_.isPrivate).foreach(println _)\n// Outputs private members like super$sameElements, occCounts, etc.\n```\n\n----------------------------------------\n\nTITLE: Understanding Quote Contexts in Scala Macros\nDESCRIPTION: This section explains the role of `Quotes` as the main context object for constructing and managing quote scopes. It describes how each quote introduces a nested scope, how to explicitly pass and retrieve the current `Quotes`, and how nested quotes maintain linkage via `Quotes.Nested`. This knowledge is vital for advanced macro writing that involves complex quote and splice manipulations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_28\n\nLANGUAGE: Scala\nCODE:\n```\ndef $[T](x: Quotes ?=> Expr[T]): T = ...\n\n// Usage to get current Quotes\nimport scala.quoted.*\n\n// Using `quotes` as an alias\n${ (using q1) => body(using q1) }\n// or\n${ body(using quotes) }\n\n// Nested quotes example\ndef f(using q1: Quotes) = '{\n  ${ (using q2: q1.Nested) ?=>\n      ...\n  }\n}\n\n// Inner splice with nested quote context\n// This defines a method where `x` is a quote within the outer quote's scope\ndef $[T](using q: Quotes)(x: q.Nested ?=> Expr[T]): T = ...\n```\n\n----------------------------------------\n\nTITLE: Generated bytecode signatures for @publicInBinary annotated class (Java-like JVM signature)\nDESCRIPTION: This snippet presents the JVM bytecode signatures generated from the annotated Scala class. It shows that the package-private and protected APIs annotated with @publicInBinary are made public in the bytecode, as reflected by the public methods in the Java-style class signature.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/binary-api.md#_snippet_4\n\nLANGUAGE: java\nCODE:\n```\npublic class C {\n  public C();\n  public int packagePrivateAPI();\n  public int protectedAPI();\n  public int publicAPI();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Pattern Matching Partial Functions in Scala Macros\nDESCRIPTION: This snippet demonstrates how to define a partial function using pattern matching within quasiquotes, and how to extract cases from it. It highlights pattern matching syntax, case class representations, and the distinction between similar tree data structures for match expressions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_50\n\nLANGUAGE: Scala\nCODE:\n```\nval pf = q\"{ case i: Int if i > 0 => i * i }\"\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval q\"{ case ..$cases }\" = pf\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval q\"$expr match { case ..$cases }\" = pf\n```\n\n----------------------------------------\n\nTITLE: Scala Quasiquote Pattern for Package Object Definition\nDESCRIPTION: Presents the general Scala quasiquote pattern for matching or constructing a package object definition AST. Its structure is similar to an object but represents a package object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/definition-details.md#_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nq\"package object $tname extends { ..$earlydefns } with ..$parents { $self => ..$stats }\"\n```\n\n----------------------------------------\n\nTITLE: Constructing Return Quasiquotes - Scala\nDESCRIPTION: Shows how to create an AST node for a `return` expression using quasiquotes. The example `q\"return 2 + 2\"` demonstrates that the returned expression is captured.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val ret = q\"return 2 + 2\"\nret: universe.Return = return 2.$plus(2)\n```\n\n----------------------------------------\n\nTITLE: Numeric Type Suffixes in Scala\nDESCRIPTION: Demonstrates how to use literal suffixes (L, D, F) to specify Long, Double, and Float types for numeric values.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-vars-data-types.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval x = 1_000L   // val x: Long = 1000\nval y = 2.2D     // val y: Double = 2.2\nval z = 3.3F     // val z: Float = 3.3\n```\n\n----------------------------------------\n\nTITLE: Inspecting Created Directory Structure\nDESCRIPTION: Shows the output of the find command after creating the sbt project structure, confirming that all necessary directories have been created correctly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/scala-build-tool-sbt.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ find .\n.\n./project\n./src\n./src/main\n./src/main/java\n./src/main/resources\n./src/main/scala\n./src/test\n./src/test/java\n./src/test/resources\n./src/test/scala\n./target\n```\n\n----------------------------------------\n\nTITLE: Creating Actors with Strict Range Mapping in Scala 2.8\nDESCRIPTION: This Scala code snippet demonstrates the default strict behavior of collections introduced in Scala 2.8. It creates a range from 1 to 10 and immediately applies the `map` function, resulting in the creation and starting of 10 actors. This behavior is different from pre-2.8 versions where the range would have been lazy.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/views.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nval actors = (1 to 10) map (i => actor { ... })\n```\n\n----------------------------------------\n\nTITLE: Filtering Private Members of a Type in Scala Reflection\nDESCRIPTION: Illustrates how to use the `members` method to retrieve all members (including inherited ones) of a type as a `MemberScope` (which is `Traversable`). It then applies familiar collection methods like `filter` and `foreach` to process the `Symbol` objects, specifically filtering for private members and printing them.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/reflection/symbols-trees-types.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n\ntypeOf[List[Int]].members.filter(_.isPrivate).foreach(println _)\n```\n\n----------------------------------------\n\nTITLE: Testing Subtyping Relationships in Scala Reflection\nDESCRIPTION: Demonstrates how to test whether one type is a subtype of another using the <:< operator from Scala's reflection API. Shows examples with class inheritance.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n\nclass A; class B extends A\n\ntypeOf[A] <:< typeOf[B] // Returns false\ntypeOf[B] <:< typeOf[A] // Returns true\n```\n\n----------------------------------------\n\nTITLE: For Loop with Multiple Conditions in Python\nDESCRIPTION: Demonstrates a for loop iterating from 1 to 10 with a combined conditional filtering line. Prints 'i' only if 'i' is even and less than 5, showing abbreviated conditional expression in loop.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_25\n\nLANGUAGE: Python\nCODE:\n```\nfor i in range(1,11):\n  if i % 2 == 0 and i < 5:\n    print(i)\n```\n\n----------------------------------------\n\nTITLE: Assigning Results from match Expression in Scala 2\nDESCRIPTION: Illustrates capturing the result of a match expression into a variable 'result' using Scala 2 syntax. The integer variable 'i' is matched against cases returning string literals. Requires Scala 2 environment; input is integer 'i', output is a string assigned to 'result'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-control-structures.md#_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\nval result = i match {\n  case 1 => \"one\"\n  case 2 => \"two\"\n  case _ => \"other\"\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Experimental Modularity Feature in Scala\nDESCRIPTION: This snippet shows how to enable the experimental modularity language feature that includes the proposed syntax enhancements for context bounds and givens in Scala 3. This import is required to use the new syntax patterns described in the proposal.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\nimport language.experimental.modularity\n```\n\n----------------------------------------\n\nTITLE: Overloading the apply Method in the Companion Object to Support Additional Fields in Scala 2\nDESCRIPTION: This Scala 2 snippet demonstrates how to overload the apply method in the Person companion object to provide constructors that accept different numbers of parameters, accommodating newly added fields. Inputs can be name, age, or address; outputs are properly constructed Person instances. Compatibility is preserved for users relying on previous constructors. Dependencies include the prior Person case class implementation with optional fields.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/binary-compatibility-for-library-authors.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nobject Person {\n  // Original public constructor\n  def apply(name: String, age: Int): Person = new Person(name, age, None)\n  // Additional constructor that also sets the address\n  def apply(name: String, age: Int, address: String): Person =\n    new Person(name, age, Some(address))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Array - Scala REPL\nDESCRIPTION: Initializes a mutable Array of integers for demonstrating how views can be used with mutable collections to perform selective updates.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections/views.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval arr = (0 to 9).toArray\n```\n\nLANGUAGE: text\nCODE:\n```\narr: Array[Int] = Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n```\n\n----------------------------------------\n\nTITLE: Defining Type Constructors and Extractors - Scala\nDESCRIPTION: This snippet defines several type constructors—`Inv`, `Cov`, `Contra`—and a base trait, along with type extractors and a type alias for enforcing subtype constraints. These are prerequisites for experimenting with match type patterns. The main dependencies are standard Scala syntax; no external libraries are required. Key parameters are type parameters A, t, s, and bounds for IsSeq. Expected inputs/outputs are type-level constructs; no runtime logic is included.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/match-types-spec.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nclass Inv[A]\nclass Cov[+A]\nclass Contra[-A]\n\nclass Base {\n  type Y\n}\n\ntype YExtractor[t] = Base { type Y = t }\ntype ZExtractor[t] = Base { type Z = t }\n\ntype IsSeq[t <: Seq[Any]] = t\n```\n\n----------------------------------------\n\nTITLE: Querying Type Members and Declarations API Signatures\nDESCRIPTION: Defines the method signatures available on a `scala.reflect.runtime.universe.Type` for querying members and declarations. `member` and `decl` retrieve a single `Symbol` by name (or `OverloadedSymbol`/`NoSymbol`), while `members` and `decls` return a `MemberScope` (a `Traversable`) containing multiple symbols. Members include inherited elements, declarations only include elements defined directly on the type.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/reflection/symbols-trees-types.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n/** The member with given name, either directly declared or inherited, an\n  * OverloadedSymbol if several exist, NoSymbol if none exist. */\ndef member(name: Universe.Name): Universe.Symbol\n\n/** The defined or declared members with name name in this type; an\n  * OverloadedSymbol if several exist, NoSymbol if none exist. */\ndef decl(name: Universe.Name): Universe.Symbol\n\n/** A Scope containing all members of this type\n  * (directly declared or inherited). */\ndef members: Universe.MemberScope // MemberScope is a type of\n                                  // Traversable, use higher-order\n                                  // functions such as map,\n                                  // filter, foreach to query!\n\n/** A Scope containing the members declared directly on this type. */\ndef decls: Universe.MemberScope // MemberScope is a type of\n                                       // Traversable, use higher-order\n                                       // functions such as map,\n                                       // filter, foreach to query!\n```\n\n----------------------------------------\n\nTITLE: Defining a Macro Method in Scala\nDESCRIPTION: This snippet shows how to declare a macro method in Scala, illustrating the use of the 'macro' keyword to link a method to its macro implementation. It demonstrates the syntax for macro definitions, the role of the Context parameter, and how macro arguments are wrapped with 'c.Expr'. This pattern is fundamental for creating compile-time code transformations and requires importing 'scala.reflect.macros.Context' and enabling macros via language settings.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/overview.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef assert(cond: Boolean, msg: Any) = macro Asserts.assertImpl\n```\n\n----------------------------------------\n\nTITLE: Initial build.sbt Configuration with Scala 2 scalacOptions\nDESCRIPTION: Example `build.sbt` showing a project configuration before migrating compiler options. It defines the Scala version (2.13.11) and includes several common Scala 2 `scalacOptions` like encoding, JVM target, source compatibility, warnings, and explain types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/scala3-migrate.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nlazy val main = project\n  .in(file(\".\"))\n  .settings(\n    scalaVersion := \"2.13.11\",\n    scalacOptions ++= Seq(\n      \"-encoding\",\n      \"UTF-8\",\n      \"-target:jvm-1.8\",\n      \"-Xsource:3\",\n      \"-Wunused:imports,privates,locals\",\n      \"-explaintypes\"\n    )\n  )\n```\n\n----------------------------------------\n\nTITLE: Running subset of partest tests by wildcard (Shell)\nDESCRIPTION: Shows how to navigate to the `test` directory and execute `partest` directly (not via sbt) targeting a subset of tests using a wildcard pattern in the file path. The output shows the list of tests run and their results. Requires `partest` and access to the project's test directory.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/hacker-guide.md#_snippet_11\n\nLANGUAGE: Shell\nCODE:\n```\n18:52 ~/Projects/scala/sandbox (ticket/6725)$ cd ../test\n18:56 ~/Projects/scala/test (ticket/6725)$ partest files/run/*interpol*\nTesting individual files\ntesting: [...]/files/run/interpolationArgs.scala                      [  OK  ]\ntesting: [...]/files/run/interpolationMultiline1.scala                [  OK  ]\ntesting: [...]/files/run/interpolationMultiline2.scala                [  OK  ]\ntesting: [...]/files/run/sm-interpolator.scala                        [  OK  ]\ntesting: [...]/files/run/interpolation.scala                          [  OK  ]\ntesting: [...]/files/run/stringinterpolation_macro-run.scala          [  OK  ]\nAll of 6 tests were successful (elapsed time: 00:00:08)\n```\n\n----------------------------------------\n\nTITLE: Case Class Definition for unapply Examples\nDESCRIPTION: A simple case class definition used to demonstrate differences in unapply method generation between Scala 2 and 3 in subsequent examples.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-other-changes.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ncase class Location(lat: Double, long: Double)\n```\n\n----------------------------------------\n\nTITLE: Executing Scala Program with 'scala' Command\nDESCRIPTION: Shows how to run the compiled Scala program using the 'scala' command with classpath option. Demonstrates that running 'scala -classpath . HolaMundo' executes the program and outputs '¡Hola, mundo!'. Clarifies command-line usage analogous to Java runtime.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tutorials/scala-for-java-programmers.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n> scala -classpath . HolaMundo\n\n¡Hola, mundo!\n```\n\n----------------------------------------\n\nTITLE: Using withPrefix Method on PrefixMap in Scala\nDESCRIPTION: Example showing how to use the withPrefix method to obtain a submap containing only entries with keys starting with a specific prefix. Here it returns all entries with keys starting with \"a\".\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\nm.withPrefix(\"a\")\n```\n\n----------------------------------------\n\nTITLE: Extracting Literal Format String from Macro Parameter Tree in Scala\nDESCRIPTION: Uses pattern matching to extract the format string literal from the macro parameter tree `format.tree`. This relies on the format argument being a compile-time constant `String`. If the `format` is not a string literal, the macro expansion will fail because the tree pattern will not match.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/overview.md#_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval Literal(Constant(s_format: String)) = format.tree\n```\n\n----------------------------------------\n\nTITLE: Illustrating Inline Function Expansion with Constant Argument in Scala\nDESCRIPTION: Shows the initial steps of compile-time expansion when calling the inline `power` function with constant arguments (2, 2). The compiler substitutes the arguments, evaluates constant conditions, and eliminates dead branches (`if (2 == 0)` and `if (2 % 2 == 1)`), simplifying the call to `power(x * x, 1)`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\npower(2, 2)\n// first inlines as\nval x = 2\nif (2 == 0) 1.0 // dead branch\nelse if (2 % 2 == 1) x * power(x, 2 - 1) // dead branch\nelse power(x * x, 2 / 2)\n// partially evaluated to\nval x = 2\npower(x * x, 1)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Runtime Mirrors in Scala - scala\nDESCRIPTION: Demonstrates the creation of a runtime mirror using Scala reflection's runtime universe and a class loader. This mirror serves as a starting point for accessing symbols by name and creating invoker mirrors (InstanceMirror, MethodMirror, FieldMirror, ClassMirror, ModuleMirror) to perform reflective operations such as method invocation, field access, constructor invocation, and singleton object instance retrieval. Dependencies include scala.reflect.runtime.universe and a valid class loader. The expected input is Scala classes or objects whose members are accessed reflectively, with outputs being the results of reflective method calls or field manipulations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/reflection/environment-universes-mirrors.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nscala> val ru = scala.reflect.runtime.universe\nru: scala.reflect.api.JavaUniverse = ...\n\nscala> val m = ru.runtimeMirror(getClass.getClassLoader)\nm: scala.reflect.runtime.universe.Mirror = JavaMirror ...\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> class C { def x = 2 }\ndefined class C\n\nscala> val im = m.reflect(new C)\nim: scala.reflect.runtime.universe.InstanceMirror = instance mirror for C@3442299e\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> val methodX = ru.typeOf[C].decl(ru.TermName(\"x\")).asMethod\nmethodX: scala.reflect.runtime.universe.MethodSymbol = method x\n\nscala> val mm = im.reflectMethod(methodX)\nmm: scala.reflect.runtime.universe.MethodMirror = method mirror for C.x: scala.Int (bound to C@3442299e)\n\nscala> mm()\nres0: Any = 2\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> class C { val x = 2; var y = 3 }\ndefined class C\n\nscala> val m = ru.runtimeMirror(getClass.getClassLoader)\nm: scala.reflect.runtime.universe.Mirror = JavaMirror ...\n\nscala> val im = m.reflect(new C)\nim: scala.reflect.runtime.universe.InstanceMirror = instance mirror for C@5f0c8ac1\n\nscala> val fieldX = ru.typeOf[C].decl(ru.TermName(\"x\")).asTerm.accessed.asTerm\nfieldX: scala.reflect.runtime.universe.TermSymbol = value x\n\nscala> val fmX = im.reflectField(fieldX)\nfmX: scala.reflect.runtime.universe.FieldMirror = field mirror for C.x (bound to C@5f0c8ac1)\n\nscala> fmX.get\nres0: Any = 2\n\nscala> fmX.set(3)\n\nscala> val fieldY = ru.typeOf[C].decl(ru.TermName(\"y\")).asTerm.accessed.asTerm\nfieldY: scala.reflect.runtime.universe.TermSymbol = variable y\n\nscala> val fmY = im.reflectField(fieldY)\nfmY: scala.reflect.runtime.universe.FieldMirror = field mirror for C.y (bound to C@5f0c8ac1)\n\nscala> fmY.get\nres1: Any = 3\n\nscala> fmY.set(4)\n\nscala> fmY.get\nres2: Any = 4\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> case class C(x: Int)\ndefined class C\n\nscala> val m = ru.runtimeMirror(getClass.getClassLoader)\nm: scala.reflect.runtime.universe.Mirror = JavaMirror ...\n\nscala> val classC = ru.typeOf[C].typeSymbol.asClass\nclassC: scala.reflect.runtime.universe.Symbol = class C\n\nscala> val cm = m.reflectClass(classC)\ncm: scala.reflect.runtime.universe.ClassMirror = class mirror for C (bound to null)\n\nscala> val ctorC = ru.typeOf[C].decl(ru.termNames.CONSTRUCTOR).asMethod\nctorC: scala.reflect.runtime.universe.MethodSymbol = constructor C\n\nscala> val ctorm = cm.reflectConstructor(ctorC)\nctorm: scala.reflect.runtime.universe.MethodMirror = constructor mirror for C.<init>(x: scala.Int): C (bound to null)\n\nscala> ctorm(2)\nres0: Any = C(2)\n```\n\nLANGUAGE: scala\nCODE:\n```\nscala> object C { def x = 2 }\ndefined module C\n\nscala> val m = ru.runtimeMirror(getClass.getClassLoader)\nm: scala.reflect.runtime.universe.Mirror = JavaMirror ...\n\nscala> val objectC = ru.typeOf[C.type].termSymbol.asModule\nobjectC: scala.reflect.runtime.universe.ModuleSymbol = object C\n\nscala> val mm = m.reflectModule(objectC)\nmm: scala.reflect.runtime.universe.ModuleMirror = module mirror for C (bound to null)\n\nscala> val obj = mm.instance\nobj: Any = C$@1005ec04\n```\n\n----------------------------------------\n\nTITLE: Implementing a Covariant Singly Linked List with Incorrect Prepend Method in Scala\nDESCRIPTION: This code snippet implements a covariant singly linked list with a trait Node and two case classes ListNode and Nil. It attempts to define a prepend method taking an element of type B. However, this implementation fails to compile due to variance rules: because B is covariant (+B), it cannot appear in a contravariant position such as a method parameter. The snippet illustrates the problem scenario requiring variance fixes before usage.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/tour/lower-type-bounds.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Node[+B] {\n  def prepend(elem: B): Node[B]\n}\n\ncase class ListNode[+B](h: B, t: Node[B]) extends Node[B] {\n  def prepend(elem: B): ListNode[B] = ListNode(elem, this)\n  def head: B = h\n  def tail: Node[B] = t\n}\n\ncase class Nil[+B]() extends Node[B] {\n  def prepend(elem: B): ListNode[B] = ListNode(elem, this)\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling Scala Code Using scalac\nDESCRIPTION: Shows the shell command to compile Scala source code files using the 'scalac' compiler. The command 'scalac hello.scala' compiles the specified Scala source file, generating Java bytecode files (.class) suitable for execution on the JVM. This snippet applies to both Scala 2 and Scala 3 with subtle differences in generated files depending on Scala version. The prerequisite is having the Scala compiler installed and properly configured in the user's environment path.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/taste-hello-world.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ scalac hello.scala\n```\n\n----------------------------------------\n\nTITLE: Importing CollectionConverters in Scala 2\nDESCRIPTION: Shows how to import the CollectionConverters object in Scala 2 to enable collection conversions. Essential for setting up implicit conversions between Scala and Java collections.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/conversions-between-java-and-scala-collections.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.jdk.CollectionConverters._\n```\n\n----------------------------------------\n\nTITLE: Expanded Unhygienic Macro Usage - Scala\nDESCRIPTION: Shows the result of expanding the `MyMacro(2)` call in the `Test.scala` example. The macro expands to a simple call `wrapper(2)`. Due to the local definition of `wrapper` in `Test`, the expanded code calls `example.Test.wrapper` instead of the intended `example.MyMacro.wrapper`, confirming the name collision and lack of referential transparency.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/hygiene.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\n// Expanded Test.scala\npackage example\n\nobject Test extends App {\n  def wrapper(x: Int) = x\n  wrapper(2)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Named given Ordering Instance Using Legacy Scala 3 Syntax in Scala\nDESCRIPTION: Extends the previous example by adding an explicit name to the given definition, resembling an implicit method in Scala 2. The syntax still uses colon and trailing 'with', preserving the issues with inconsistency and verbosity despite introducing a name binding.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\ngiven listOrd[A](using Ord[A]): Ord[List[A]] with\n  def compare(x: List[A], y: List[A]) = ...\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Types with '[...]' in Scala Macros\nDESCRIPTION: This snippet uses pattern matching on type representations with `Type[T]` using the `'[...]` syntax inside macros, enabling compile-time inspection of tuple types and element types. It recursively processes known tuple types to extract their element type names as strings, providing detailed type analysis capabilities at compile time.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_26\n\nLANGUAGE: Scala\nCODE:\n```\ndef mirrorFieldsImpl[T: Type](using Quotes): Expr[List[String]] =\n  def rec[A : Type]: List[String] = Type.of[A] match\n    case '[field *: fields] =>\n      Type.show[field] :: rec[fields]\n    case '[EmptyTuple] =>\n      Nil\n    case _ =>\n      quotes.reflect.report.errorAndAbort(\"Expected known tuple but got: \" + Type.show[A])\n  Expr(rec)\n```\n\n----------------------------------------\n\nTITLE: Temporarily Switching Nightly Version in sbt Shell (sbt)\nDESCRIPTION: These commands temporarily change the Scala version for a running sbt session to a specified nightly version. The command syntax differs between sbt versions 0.13.x and 1.x. It is useful for testing nightly builds in multi-project configurations or ephemeral sessions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/nightlies.md#_snippet_5\n\nLANGUAGE: sbt\nCODE:\n```\n++2.13.1-bin-abcd123\n```\n\nLANGUAGE: sbt\nCODE:\n```\n++2.13.1-bin-abcd123!\n```\n\n----------------------------------------\n\nTITLE: Creating a TermName with Scala Reflection in Scala\nDESCRIPTION: This code demonstrates how to construct a TermName object ('map') in Scala's reflection API, associating it with the reflection universe. It requires the universe to be imported. The input string (\"map\") specifies the name to encapsulate, and the resulting TermName is used to look up terms (members or methods) reflectively.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/annotations-names-scopes.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval mapName = TermName(\"map\")\n```\n\n----------------------------------------\n\nTITLE: Class Definition with Implicitly Nullable Field (Scala)\nDESCRIPTION: Defines an `Address` class where `street2` is a `String`. In Scala (like Java), this allows `null` values, which can lead to `NullPointerException`s and represents an optional field poorly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/no-null-values.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nclass Address (\n    var street1: String,\n    var street2: String,\n    var city: String, \n    var state: String, \n    var zip: String\n)\n```\n\n----------------------------------------\n\nTITLE: Deconstructing Code Blocks with Scala Quasiquotes\nDESCRIPTION: Shows how to extract the list of statements (`stats`) from a `Block` AST using the `q\"..$stats\"` pattern. This works for multi-statement blocks, blocks containing definitions, and single expressions (which are treated as single-element blocks). It returns the user-defined contents.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_40\n\nLANGUAGE: scala\nCODE:\n```\nscala> val q\"..$stats\" = q\"a; b; c\"\nstats: List[universe.Tree] = List(a, b, c)\n\nscala> val q\"..$stats\" = q\"{ val x = 2 }\"\nstats: List[universe.Tree] = List(val x = 2)\n\nscala> val q\"..$stats\" = q\"foo\"\nstats: List[universe.Tree] = List(foo)\n```\n\n----------------------------------------\n\nTITLE: Using RNA1 Transformation Methods (take, filter)\nDESCRIPTION: Illustrates the usage of `take` and `filter` methods on an `RNA1` instance. Because these operations preserve the element type (`Base`), and due to the definition within `IndexedSeqOps` and potential overrides, they correctly return new `RNA1` instances in this implementation. This code is compatible with both Scala 2 and Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nscala> val rna1_2 = rna1.take(3)\nval rna1_2: RNA1 = RNA1(A, U, G)\n\nscala> val rna1_3 = rna1.filter(_ != U)\nval rna1_3: RNA1 = RNA1(A, G, G, C)\n```\n\n----------------------------------------\n\nTITLE: Matching Unqualified 'this' Quasiquotes - Scala\nDESCRIPTION: Demonstrates pattern matching on an unqualified `this` expression using quasiquotes. The pattern `q\"$name.this\"` matches `q\"this\"` and binds the type name to `name`, showing that unqualified `this` is equivalent to `q\"${tpnme.EMPTY}.this\"` in this pattern.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"$name.this\" = q\"this\"\nname: universe.TypeName =\n```\n\n----------------------------------------\n\nTITLE: Reflecting Constructors with ClassMirror for Case Classes - Scala\nDESCRIPTION: Illustrates constructing a case class instance using Scala reflection: retrieves the class symbol, creates a ClassMirror, finds its constructor MethodSymbol, and invokes the constructor via a MethodMirror. Inputs are the type information and parameters for the constructor; output is a new instance of the case class.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/environment-universes-mirrors.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ncase class C(x: Int)\nval m = ru.runtimeMirror(getClass.getClassLoader)\nval classC = ru.typeOf[C].typeSymbol.asClass\nval cm = m.reflectClass(classC)\nval ctorC = ru.typeOf[C].decl(ru.termNames.CONSTRUCTOR).asMethod\nval ctorm = cm.reflectConstructor(ctorC)\nctorm(2)\n```\n\n----------------------------------------\n\nTITLE: Matching Expression Tree with q Pattern (Scala)\nDESCRIPTION: Shows how to use the `q` interpolator in pattern matching to check the structural equality of a `universe.Tree` against a pattern. If the tree's structure matches the pattern, the corresponding case block is executed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/intro.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nscala> println(tree match { case q\"i am { a quasiquote }\" => \"it worked!\" })\nit worked!\n```\n\n----------------------------------------\n\nTITLE: Defining a Polymorphic Method Extension in Scala\nDESCRIPTION: Demonstrates the definition of a polymorphic method as an extension on Int type. Illustrates the difference between polymorphic and monomorphic method references.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/polymorphic-eta-expansion.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nextension (x: Int)\n  def poly[T](x: T): T = x\n// signature: (Int)[T](T): T\n\npoly(4) // polymorphic method: takes a  [T]\npoly    // monomorphic method: takes an (Int)\n```\n\n----------------------------------------\n\nTITLE: Defining a type macro with impl method in Scala\nDESCRIPTION: This code snippet demonstrates the definition of a type macro `H2Db` in Scala, which connects to a database at compile-time to generate static, type-safe database wrappers. The `impl` method processes the macro context and constructs a class or object definition as a syntax tree (`c.Tree`) which the compiler inserts or manipulates during compilation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/typemacros.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntype H2Db(url: String) = macro impl\n\ndef impl(c: Context)(url: c.Expr[String]): c.Tree = {\n  val name = c.freshName(c.enclosingImpl.name).toTypeName\n  val clazz = ClassDef(..., Template(..., generateCode()))\n  c.introduceTopLevel(c.enclosingPackage.pid.toString, clazz)\n  val classRef = Select(c.enclosingPackage.pid, name)\n  Apply(classRef, List(Literal(Constant(c.eval(url)))))\n}\n```\n\n----------------------------------------\n\nTITLE: Enhancing Pattern Matching on Tree with Debug Output in Scala\nDESCRIPTION: Shows how to integrate TreeStructure printing in exhaustive pattern matches on Tree to aid debugging by throwing a MatchError that includes the familiar tree structure when no cases match. This pattern helps developers identify missing cases by providing a copy-pasteable representation of the unexpected tree. It requires handling various Tree subtypes and leveraging the show method with Printer.TreeStructure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/reflection.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ntree match\n  case Ident(_) =>\n  case Select(_, _) =>\n  ...\n  case _ =>\n    throw new MatchError(tree.show(using Printer.TreeStructure))\n```\n\n----------------------------------------\n\nTITLE: Defining the Final RNA Custom Collection Class in Scala\nDESCRIPTION: Defines the final `RNA` class, a custom Scala collection for RNA sequences. It extends `IndexedSeq[Base]` and `IndexedSeqLike[Base, RNA]`. It overrides `newBuilder` (delegating to a companion object method), implements the mandatory `apply` method using bitwise operations for efficient storage, and optionally overrides `foreach` with a more efficient loop-based implementation. This structure aims to correctly integrate with Scala's collection framework.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-collections.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nfinal class RNA private (val groups: Array[Int], val length: Int)\n  extends IndexedSeq[Base] with IndexedSeqLike[Base, RNA] {\n\n  import RNA._\n\n  // Mandatory re-implementation of `newBuilder` in `IndexedSeq`\n  override protected[this] def newBuilder: Builder[Base, RNA] =\n    RNA.newBuilder\n\n  // Mandatory implementation of `apply` in `IndexedSeq`\n  def apply(idx: Int): Base = {\n    if (idx < 0 || length <= idx)\n      throw new IndexOutOfBoundsException\n    Base.fromInt(groups(idx / N) >> (idx % N * S) & M)\n  }\n\n  // Optional re-implementation of foreach,\n  // to make it more efficient.\n  override def foreach[U](f: Base => U): Unit = {\n    var i = 0\n    var b = 0\n    while (i < length) {\n      b = if (i % N == 0) groups(i / N) else b >>> S\n      f(Base.fromInt(b & M))\n      i += 1\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Showing Raw tq Tree Structure (Scala)\nDESCRIPTION: Uses `showRaw` to display the internal representation of the `universe.Tree` generated by the `tq` interpolator for type syntax. Contrasts with the tree generated by `q` for the same syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/intro.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nscala> println(showRaw(tq\"List[Int]\"))\nAppliedTypeTree(Ident(TypeName(\"List\")), List(Ident(TypeName(\"Int\"))))\n```\n\n----------------------------------------\n\nTITLE: Повторный запуск тестов Scala через sbt (Shell)\nDESCRIPTION: Пример вывода запуска команды `sbt test` после добавления второго теста в класс CubeCalculatorTest. Отображается успешное прохождение 2 тестов вместе со статистикой и временем выполнения. Предполагается, что проект настроен корректно и все тесты выполняются без ошибок.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/getting-started/sbt-track/testing-scala-with-sbt-on-the-command-line.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nsbt test\n[info] Loading project definition from C:\\projects\\scalaPlayground\\scalatestpractice\\project\n[info] Loading settings for project root from build.sbt ...\n[info] Set current project to scalatest-example (in build file:/C:/projects/scalaPlayground/scalatestpractice/)\n[info] Compiling 1 Scala source to C:\\projects\\scalaPlayground\\scalatestpractice\\target\\scala-2.13\\test-classes ...\n[info] CubeCalculatorTest:\n[info] - CubeCalculator.cube 3 should be 27\n[info] - CubeCalculator.cube 0 should be 0\n[info] Run completed in 257 milliseconds.\n[info] Total number of tests run: 2\n[info] Suites: completed 1, aborted 0\n[info] Tests: succeeded 2, failed 0, canceled 0, ignored 0, pending 0\n[info] All tests passed.\n[success] Total time: 3 s, completed Dec 4, 2019 10:34:04 PM\n```\n\n----------------------------------------\n\nTITLE: Defining Blackbox Macro Bundle Methods in Scala\nDESCRIPTION: This snippet demonstrates how to define macro implementations within a Scala class acting as a macro bundle. The class constructor takes a blackbox macro context, and methods within the class (`mono`, `poly`) contain the actual macro logic. A separate object (`Macros`) then defines the user-facing macro calls that delegate to the bundle methods using the `macro ClassName.methodName` syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/bundles.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.macros.blackbox.Context\n\nclass Impl(val c: Context) {\n  def mono = c.literalUnit\n  def poly[T: c.WeakTypeTag] = c.literal(c.weakTypeOf[T].toString)\n}\n\nobject Macros {\n  def mono = macro Impl.mono\n  def poly[T] = macro Impl.poly[T]\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Singleton Objects Using ModuleMirror in Scala\nDESCRIPTION: This snippet demonstrates how to use ModuleMirror to access singleton object instances via reflection. It reflects the module symbol of an object, creates a module mirror, and retrieves the instance behind the singleton module at runtime. This requires the runtime mirror and proper retrieval of module symbols. Inputs are the module symbolic reference, outputs are the instantiated singleton object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/reflection/environment-universes-mirrors.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nscala> object C { def x = 2 }\ndefined module C\n\nscala> val m = ru.runtimeMirror(getClass.getClassLoader)\nm: scala.reflect.runtime.universe.Mirror = JavaMirror ...\n\nscala> val objectC = ru.typeOf[C.type].termSymbol.asModule\nobjectC: scala.reflect.runtime.universe.ModuleSymbol = object C\n\nscala> val mm = m.reflectModule(objectC)\nmm: scala.reflect.runtime.universe.ModuleMirror = module mirror for C (bound to null)\n\nscala> val obj = mm.instance\nobj: Any = C$@1005ec04\n```\n\n----------------------------------------\n\nTITLE: 値クラスのパラメータに`call-by-name`や`lazy val`を許さない例\nDESCRIPTION: 値クラスのパラメータは`val`でなければならず、`call-by-name`パラメータや`lazy val`は許されない。例としてparameterに`=> Int`を指定したクラスや`lazy val`を持つクラスはエラーとなる。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/core/value-classes.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nclass NoByName(val x: => Int) extends AnyVal\n\nclass NoLazyMember(val evaluate: () => Double) extends AnyVal {\n  val member: Int = 3\n  lazy val x: Double = evaluate()\n  object NestedObject\n  class NestedClass\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling with Scala Optimizer Full Inlining - CLI\nDESCRIPTION: Demonstrates compiling a Scala file (`Test.scala`) using the `scalac` compiler with the optimizer enabled for full inlining. The `-opt:inline:**` flag instructs the compiler to attempt inlining from all classes, including the JDK, which is typical for application builds.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/compiler-options/optimizer.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n$> scalac Test.scala '-opt:inline:**'\n```\n\n----------------------------------------\n\nTITLE: Inspecting Internal Representation of Package Object AST in Scala\nDESCRIPTION: Constructs a package object AST (`q\"package object P\"`) and shows its internal representation. It reveals that a package object is represented as a regular object named `package` nested within a package definition.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/definition-details.md#_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val P = q\"package object P\"\nP: universe.PackageDef =\npackage P {\n  object `package` extends scala.AnyRef {\n    def <init>() = {\n      super.<init>();\n      ()\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using This Keyword in Scaladoc References\nDESCRIPTION: Demonstrates using the 'this' keyword as a prefix in Scaladoc references to reference the enclosing class-like entity, making references more familiar and resistant to class name changes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/linking.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass C {\n  def foo = \"foo\"\n  /** This is not [[this.foo]], this is bar. */\n  def bar = \"bar\"\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Compiled Scala Program using scala\nDESCRIPTION: Illustrates how to execute a compiled Scala program (`HelloWorld`) using the `scala` command, similar to the `java` command. Includes setting the classpath (`-classpath .`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tutorials/scala-for-java-programmers.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nscala -classpath . HelloWorld\n```\n\n----------------------------------------\n\nTITLE: Accessing Java Annotation Class and Enum References via Scala Reflection - Scala and Java\nDESCRIPTION: Shows interoperability between Java annotations and Scala reflection. Defines a Java enum and annotation referencing a class and enum values. In Scala, retrieves annotation arguments from Java code using scala.reflect.runtime.universe, pattern matches on LiteralArgument containing Constants, converts class references to Types and runtime classes, extracts enum symbols, enum values, and obtains underlying runtime enum value using reflection on the JVM.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/annotations-names-scopes.md#_snippet_10\n\nLANGUAGE: Java\nCODE:\n```\nenum JavaSimpleEnumeration { FOO, BAR }\n\nimport java.lang.annotation.*;\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE})\npublic @interface JavaSimpleAnnotation {\n  Class<?> classRef();\n  JavaSimpleEnumeration enumRef();\n}\n\n@JavaSimpleAnnotation(\n  classRef = JavaAnnottee.class,\n  enumRef = JavaSimpleEnumeration.BAR\n)\npublic class JavaAnnottee {}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\nimport scala.reflect.runtime.{currentMirror => cm}\n\nobject Test extends App {\n  val jann = typeOf[JavaAnnottee].typeSymbol.annotations(0).javaArgs\n\n  def jarg(name: String) = jann(TermName(name)) match {\n    case LiteralArgument(ct: Constant) => value\n    case _ => sys.error(\"Not a constant\")\n  }\n\n  val classRef = jarg(\"classRef\").value.asInstanceOf[Type]\n  println(showRaw(classRef))         // TypeRef(ThisType(), JavaAnnottee, List())\n  println(cm.runtimeClass(classRef)) // class JavaAnnottee\n\n  val enumRef = jarg(\"enumRef\").value.asInstanceOf[Symbol]\n  println(enumRef)                   // value BAR\n\n  val siblings = enumRef.owner.typeSignature.decls\n  val enumValues = siblings.filter(sym => sym.isVal && sym.isPublic)\n  println(enumValues)                // Scope {\n                                   //   final val FOO: JavaSimpleEnumeration;\n                                   //   final val BAR: JavaSimpleEnumeration\n                                   // }\n\n  val enumClass = cm.runtimeClass(enumRef.owner.asClass)\n  val enumValue = enumClass.getDeclaredField(enumRef.name.toString).get(null)\n  println(enumValue)                 // BAR\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Local Server for Viewing Documentation\nDESCRIPTION: Shell command for starting a Python HTTP server to view the generated documentation locally with full functionality including search and snippets.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/static-site.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ncd output\npython3 -m http.server 8080\n```\n\n----------------------------------------\n\nTITLE: Constructing Nullary Tuples (Unit) with Scala Quasiquotes\nDESCRIPTION: Demonstrates constructing a nullary tuple (representing `Unit`, often written as `()`) using the splice syntax `q\"(..$elems)\"` where `elems` is an empty list of trees.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_35\n\nLANGUAGE: scala\nCODE:\n```\nscala> val elems = List.empty[Tree]\nscala> val nullary = q\"(..$elems)\"\nnullary: universe.Tree = ()\n```\n\n----------------------------------------\n\nTITLE: Specifying Scala 2 Nightly Version in Script Directive (Scala)\nDESCRIPTION: This directive enables a Scala script to request the Scala 2 nightly version for execution via compatible tools like scala-cli. It eliminates the need for manual version management in the build configuration. Tooling must support '//>' syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/nightlies.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\n//> using scala 2.nightly\n```\n\n----------------------------------------\n\nTITLE: Практичний приклад стирання типів у JVM - Java\nDESCRIPTION: Показує результат компіляції Scala списку з типом List[Int] у JVM байткод, який через механізм стирання типів змінює цей тип на List<java.lang.Object>. Наведений приклад демонструє спрощене Java-подібне представлення методу, що повертає список, із стертою інформацією про типи. Код не призначений для компіляції сам по собі, а служить ілюстрацією концепції стирання типів у JVM.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_uk/scala3/guides/tasty-overview.md#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npublic scala.collection.immutable.List<java.lang.Object> xs();\n```\n\n----------------------------------------\n\nTITLE: Testing doNothing Function with Scalaprops - Scala 3\nDESCRIPTION: Defines a property-based test for Example.doNothing using Scalaprops in Scala 3, employing Scala 3's lambda and end marker syntax. Requires 'scalaprops' and 'library-example' dependencies. 'testDoNothing' property checks round-trip for any Int. Compatibility: Only for Scala 3 codebases.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contributors/index.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\npackage ch.epfl.scala\n\nimport scalaprops.{Property, Scalaprops}\n\nobject Usage extends Scalaprops:\n\n  val testDoNothing =\n// #do-nothing\n    Property.forAll: (x: Int) =>\n      Example.doNothing(x) == x\n// #do-nothing\n\nend Usage\n```\n\n----------------------------------------\n\nTITLE: Defining a Three-Parameter Method with Explicit Return Type in Scala\nDESCRIPTION: Provides another example of a multi-parameter method, defining an `add` method that accepts three integer parameters, `a`, `b`, and `c`, and explicitly returns their sum as an `Int`. This demonstrates extending the multi-parameter syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/methods-first-look.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ndef add(a: Int, b: Int, c: Int): Int = a + b + c\n```\n\n----------------------------------------\n\nTITLE: Basic mdoc Typechecking in Scala\nDESCRIPTION: Demonstrates the basic usage of the `mdoc` modifier in a Scala code block. This modifier instructs the mdoc tool to typecheck the enclosed Scala code (`val a = 1`) during the site build process, ensuring its validity.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/add-guides.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc\nval a = 1\n```\n```\n\n----------------------------------------\n\nTITLE: Illustrating Mismatch Between Object and Package Object Patterns (2)\nDESCRIPTION: Shows the inverse mismatch: attempting to match a regular object AST (`q\"object O\"`) using the package object quasiquote pattern (`q\"package object $name\"`) also results in a `MatchError`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/definition-details.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"package object $name\" = q\"object O\"\nscala.MatchError: ...\n```\n\n----------------------------------------\n\nTITLE: Generated fromProduct Implementation for @unroll'ed Case Class (Scala 3)\nDESCRIPTION: Illustrates the required `fromProduct` implementation generated in the companion object for an `@unroll`ed `case class` in Scala 3. This ensures semantic compatibility by correctly handling default field values when reconstructing the case class from a `Product` with fewer elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/unroll-default-arguments.md#_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\ndef fromProduct(p: Product): CaseClass = p.productArity match\n  case 2 =>\n    CaseClass(\n      p.productElement(0).asInstanceOf[...],\n      p.productElement(1).asInstanceOf[...],\n    )\n  case 3 =>\n    CaseClass(\n      p.productElement(0).asInstanceOf[...],\n      p.productElement(1).asInstanceOf[...],\n      p.productElement(2).asInstanceOf[...],\n    )\n  ...\n```\n\n----------------------------------------\n\nTITLE: Getting Type of List Instance via Helper\nDESCRIPTION: Invokes the previously defined `getType` helper function with an instance of `List(1,2,3)`. The `TypeTag` mechanism captures the runtime type `List[Int]`, and `getType` returns its reflection `Type` representation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nscala> getType(List(1,2,3))\nres: scala.reflect.runtime.universe.Type = List[Int]\n```\n\n----------------------------------------\n\nTITLE: Adding a Default Parameter, Breaking Binary Compatibility in Scala\nDESCRIPTION: Modifies the `foo` method by adding a new default parameter `b: Boolean = true`. This change is source-compatible but breaks binary compatibility with code compiled against the previous version of the method.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/unroll-default-arguments.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nobject Unrolled{\n   def foo(s: String, n: Int = 1, b: Boolean = true) = s + n + b + l\n}\n```\n\n----------------------------------------\n\nTITLE: Workaround for private constructors usage in inline methods using explicit accessor (Scala)\nDESCRIPTION: This Scala example provides a workaround for the limitation on inline references to private constructors by defining a private accessor method that instantiates the class, then an inline method that calls this accessor. This pattern avoids direct inline calls to private constructors and helps with binary compatibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/binary-api.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nclass C private()\nobject C:\n  private def newCInternal: C = new C()\n  inline def newC: C = newCInternal\n```\n\n----------------------------------------\n\nTITLE: Matching Infix Operations with Explicit Type Annotations\nDESCRIPTION: Demonstrates that when matching infix operations (like `+`), explicit type annotations on the operands (`($x: Int)`, `($y: Int)`) are necessary within the quoted pattern. This allows the compiler to resolve the correct overloaded operator.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\ncase '{ ($x: Int) + ($y: Int) } =>\ncase '{ ($x: Double) + ($y: Double) } =>\ncase ...\n```\n\n----------------------------------------\n\nTITLE: Proposed Grammar Changes for Quoted Type Patterns - Syntax Definition\nDESCRIPTION: Illustrates the proposed modifications to the Scala grammar for quoted type patterns (`'[...]`). It introduces `TypeBlock` and `TypeBlockStat` rules to allow explicit `type` declarations within the quoted type pattern syntax, enabling the proposed features.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/quote-pattern-type-variable-syntax.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nQuoted            ::=  ‘'’ ‘{’ Block ‘}’\n-                    |  ‘'’ ‘[’ Type ‘]’\n+                    |  ‘'’ ‘[’ TypeBlock ‘]’\n+TypeBlock         ::=  {TypeBlockStat semi} Type\n+TypeBlockStat     ::=  ‘type’ {nl} TypeDcl\n```\n\n----------------------------------------\n\nTITLE: Proposed Type Inference with GADTs in Alternatives in Scala\nDESCRIPTION: Illustrates proposed type inference behavior with Generalized Algebraic Data Types (GADTs) in alternative patterns. The type of `x` is inferred as the Least Upper Bound (LUB), `Int | A`, of the types from each branch (`Baz(x)` yielding `Int`, `Bar(x)` yielding the type parameter `A`). No type refinement based on matching one branch influences the other.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/alternative-bind-variables.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nenum Foo[A]:\n  case Bar(a: A)\n  case Baz(i: Int) extends Foo[Int]\n\n  def fun = this match\n    case Baz(x) | Bar(x) => // x: Int | A\n```\n\n----------------------------------------\n\nTITLE: Configuring Default and Specific Snippet Compiler Settings (Plain Text)\nDESCRIPTION: Illustrates setting a default flag (e.g., `compile`) for all snippets and then overriding it for more specific paths using the longest prefix match rule. This allows for fine-grained control over snippet validation behavior across a project.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/snippet-compiler.md#_snippet_13\n\nLANGUAGE: plaintext\nCODE:\n```\n-snippet-compiler:compile,library/src/scala/quoted=nocompile,library/src/scala/compiletime=fail\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Liftable Instance for a Case Class - Scala\nDESCRIPTION: This snippet provides an example of defining an implicit Liftable instance for a custom case class Point. It imports scala.reflect.runtime.universe for access to reflection primitives, then creates an implicit Liftable[Point] using a helper apply method that constructs a tree representing the Point constructor call using quasiquotes. All parameters must be themselves liftable. The implicit must be in scope to enable automatic transformation when unquoting Point values in quasiquotes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/lifting.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\npackage points\n\nimport scala.reflect.runtime.universe._\n\ncase class Point(x: Int, y: Int)\nobject Point {\n  implicit val lift = Liftable[Point] { p =>\n    q\"_root_.points.Point(${p.x}, ${p.y})\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Animal and Cat Classes\nDESCRIPTION: Defines two simple classes, `Animal` and `Cat`, where `Cat` extends `Animal`. These classes are used to illustrate how the `getType` helper correctly identifies the specific type of an instance, even in an inheritance hierarchy.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nscala> class Animal; class Cat extends Animal\ndefined class Animal\ndefined class Cat\n```\n\n----------------------------------------\n\nTITLE: Compiling `*` type lambdas in Scala 3 with `-Ykind-projector`\nDESCRIPTION: Demonstrates that existing `*` type lambda syntax from Scala 2 `kind-projector` can be compiled in Scala 3 by using the `-Ykind-projector` flag. This provides backward compatibility for some projects during migration without requiring immediate syntax changes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/plugin-kind-projector.md#_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nTuple2[*, Double]        // equivalent to: type R[A] = Tuple2[A, Double]\nEither[Int, +*]          // equivalent to: type R[+A] = Either[Int, A]\nFunction2[-*, Long, +*]  // equivalent to: type R[-A, +B] = Function2[A, Long, B]\n```\n\n----------------------------------------\n\nTITLE: Defining Configuration and Passing Explicit Parameters in Scala (Scala 2 and 3)\nDESCRIPTION: This snippet defines a case class `Config` representing configuration data and demonstrates methods that accept this configuration as a normal explicit parameter. It models passing configuration explicitly in method calls without using context parameters. Dependencies include the case class definition and standard Scala syntax. The inputs are a path string and a configuration object, and output is an HTML string representing a rendered website. This approach requires passing the configuration explicitly to every method call, which can be verbose and error-prone.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/ca-context-parameters.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Config(port: Int, baseUrl: String)\n\ndef renderWebsite(path: String, config: Config): String =\n  \"<html>\" + renderWidget(List(\"cart\"), config)  + \"</html>\"\n\ndef renderWidget(items: List[String], config: Config): String = ???\n\nval config = Config(8080, \"docs.scala-lang.org\")\nrenderWebsite(\"/home\", config)\n```\n\n----------------------------------------\n\nTITLE: Using Package Keyword in Scaladoc References\nDESCRIPTION: Shows how to use the 'package' keyword as a prefix in Scaladoc references to reference the enclosing package, making references shorter and more refactoring-resistant.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/linking.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\npackage utils\nclass C {\n  def foo = \"foo\".\n}\n/** See also [[package.C]]. */\nclass D {\n  def bar = \"bar\".\n}\n```\n\n----------------------------------------\n\nTITLE: Eta-Expansion on Methods with Explicit Parameters (Scala)\nDESCRIPTION: This section covers additional patterns of eta-expansion for methods with different signatures: with explicit parameters, type aliases, or failing shapes. The code covers positive and error cases and illustrates the result of eta-expansion under SIP-49, with dependencies being standard Scala. Key parameters and outputs mirror the method's input and output types, with compile-time errors explaining invalid forms.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/polymorphic-eta-expansion.md#_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ndef f1[A](x: A): A = ???\nval v1_1: [B] => B => B = f1 // f1 becomes [B'] => (y: B') => f1[B'](y)\n\ndef f2[A]: A => A = ???\nval v2_1: [B] => B => B = f2 // f2 becomes [B'] => (y: B') => f2[B'](y)\n\ntype F[C] = C => C\ndef f3[A]: F[A] = ???\nval v3_1: [B] => B => B = f3 // f3 becomes [B'] => (y: B') => f3[B'](y)\n\n//reminder:\nval vErr: [B] => B    = ??? // error: polymorphic function types must have a value parameter\n```\n\n----------------------------------------\n\nTITLE: Typechecking Type with Toolbox - Scala\nDESCRIPTION: Demonstrates how Scala's toolbox `typecheck` method, when used with a quasiquoted type reference (`tq\"Map[_, _]\"`), does not respect the current lexical context's imports and resolves to the default `collection.immutable.Map` instead of the intended `collection.mutable.Map`. This illustrates a lack of referential transparency.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/hygiene.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nscala> import collection.mutable.Map\n\nscala> def typecheckType(tree: Tree): Type =\n           toolbox.typecheck(tree, toolbox.TYPEmode).tpe\n\nscala> typecheckType(tq\"Map[_, _]\") =:= typeOf[Map[_, _]]\nfalse\n\nscala> typecheckType(tq\"Map[_, _]\") =:= typeOf[collection.immutable.Map[_, _]]\ntrue\n```\n\n----------------------------------------\n\nTITLE: Matching Quoted Types with Explicit Type Variables (Proposed New Syntax) - Scala\nDESCRIPTION: Presents the final proposed syntax for explicit type variables (`t`, `tail`) in Scala quoted type patterns, introducing the `type` keyword and supporting bounds (`<: Tuple`), while removing the requirement for backticks on references within the quote.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/quote-pattern-type-variable-syntax.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\ncase '[ type t; List[t] ] => f[t]\ncase '[ type tail <: Tuple; *:[Int, tail] ] => g[tail]\n```\n\n----------------------------------------\n\nTITLE: Pretty-Printing and Inspecting Scala Types Using show and showRaw - Scala\nDESCRIPTION: Shows how to produce readable and raw representations of Scala types using the show and showRaw methods from scala.reflect.runtime.universe. Demonstrates producing a refined type with members and visualizing its underlying AST representation, including options to print symbol IDs and kinds for detailed introspection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/annotations-names-scopes.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nscala> import scala.reflect.runtime.universe._\nimport scala.reflect.runtime.universe._\n\nscala> def tpe = typeOf[{ def x: Int; val y: List[Int] }]\ntpe: scala.reflect.runtime.universe.Type\n\nscala> show(tpe)\nres0: String = scala.AnyRef{def x: Int; val y: scala.List[Int]}\n```\n\nLANGUAGE: Scala\nCODE:\n```\nscala> showRaw(tpe)\nres1: String = RefinedType(\n  List(TypeRef(ThisType(scala), TypeName(\"AnyRef\"), List())),\n  Scope(\n    TermName(\"x\"),\n    TermName(\"y\")))\n```\n\nLANGUAGE: Scala\nCODE:\n```\nscala> showRaw(tpe, printIds = true, printKinds = true)\nres2: String = RefinedType(\n  List(TypeRef(ThisType(scala#2043#PK), TypeName(\"AnyRef\")#691#TPE, List())),\n  Scope(\n    TermName(\"x\")#2540#METH,\n    TermName(\"y\")#2541#GET))\n```\n\n----------------------------------------\n\nTITLE: Using Members of Anonymous Type Provider Result\nDESCRIPTION: Demonstrates accessing members exposed by the structural type of the anonymous type provider's result. This usage is statically typed based on the inferred structural type, despite the underlying types being defined locally within the macro expansion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/typeproviders.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nscala> db.Coffees.all\nres1: List[Db$1.this.Coffee] = List(Coffee(Brazilian,99,0))\n```\n\n----------------------------------------\n\nTITLE: Running Scala parallel collections benchmark with JVM parameters\nDESCRIPTION: Shows the command line invocation to run the compiled Scala benchmark for a parallel collection map operation using JVM server mode and system properties to configure parallelism and collection size. The 'java' command includes '-server' to enable server mode optimizations, '-cp' to set classpath including scala-library.jar, and '-Dpar' and '-Dlength' to specify the parallelism level and number of elements respectively. The final parameter is the number of benchmark repetitions to perform. This approach isolates the benchmark execution in a single JVM instance with configurable parameters ensuring consistent and optimized performance measurement.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/overviews/parallel-collections/performance.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\njava -server -cp .:../../build/pack/lib/scala-library.jar -Dpar=1 -Dlength=300000 Map 10\n```\n\n----------------------------------------\n\nTITLE: Defining Annotations with Lower Camel Case Names in Scala\nDESCRIPTION: Illustrates the Scala convention of defining annotations using lower camel case names (e.g., `@volatile`, `cloneable`). This differs from the Java convention (PascalCase). The example shows a custom annotation `cloneable`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_style/naming-conventions.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nclass cloneable extends StaticAnnotation\n```\n\n----------------------------------------\n\nTITLE: Applying @unroll to a Case Class Definition in Scala\nDESCRIPTION: Demonstrates applying `@unroll` to default parameters in a `case class` primary constructor. This requires special handling as it affects generated methods like `apply` and `copy` in the companion object, in addition to the constructor itself.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/unroll-default-arguments.md#_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ncase class Unrolled(s: String, n: Int = 1, @unroll b: Boolean = true){\n  def foo = s + n + b\n}\n```\n\n----------------------------------------\n\nTITLE: Running all ScalaCheck tests (sbt)\nDESCRIPTION: Executes all property-based tests located within the `scalacheck` sbt project module. This is typically run from within the sbt shell or as `sbt scalacheck/testOnly` from the command line. Requires sbt to be installed and the project configured.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/hacker-guide.md#_snippet_6\n\nLANGUAGE: sbt\nCODE:\n```\nscalacheck/testOnly\n```\n\n----------------------------------------\n\nTITLE: Defining Cross-Built Test Module with TASTy Reader and MUnit in build.sbt - Scala\nDESCRIPTION: This build.sbt snippet configures an SBT project for testing macro libraries across both Scala 2.13 and Scala 3. It sets crossScalaVersions, adds '-Ytasty-reader' as a scalac option for Scala 2.13 (to consume Scala 3 macros), and adds MUnit for testing. This setup ensures macro tests can be executed consistently in both environments. Requires SBT and cross-building knowledge.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-macro-mixing.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\n// build.sbt\nlazy val `example-test` = project.in(file(\"example-test\"))\n  .settings(\n    scalaVersion := \"3.3.1\",\n    crossScalaVersions := Seq(\"3.3.1\", \"2.13.12\"),\n    scalacOptions ++= {\n      CrossVersion.partialVersion(scalaVersion.value) match {\n        case Some((2, 13)) => Seq(\"-Ytasty-reader\")\n        case _ => Seq.empty\n      }\n    },\n    libraryDependencies += \"org.scalameta\" %% \"munit\" % \"0.7.26\" % Test\n  )\n  .dependsOn(example)\n```\n\n----------------------------------------\n\nTITLE: Example illustrating limitation on private constructors in inline methods (Scala)\nDESCRIPTION: This Scala snippet demonstrates the current restriction that prevents inline methods from directly instantiating classes using private constructors. It shows a class with a private constructor and an inline factory method attempting to instantiate it, which is disallowed by the compiler. This snippet motivates the need for explicit accessors to enable inlining of private constructors.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/binary-api.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass C private()\nobject C:\n  inline def newC: C = new C() // Implementation restriction: cannot use private constructors in inline methods\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Type Aliases in Scala\nDESCRIPTION: Defines three type aliases `A`, `B`, and `C` using `List` and `Tuple2` (represented by `(,)`) with `Int` and `String`. These types serve as examples to illustrate the concept of 'covering sets' within the context of the proposed divergence checking mechanism.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ntype A = List[(Int, Int)]\ntype B = List[(Int, (Int, Int))]\ntype C = List[(Int, String)]\n```\n\n----------------------------------------\n\nTITLE: Defining Scala 2 Method with Wildcard Type Argument\nDESCRIPTION: Shows a Scala 2 trait `Example` with a higher-kinded abstract type member `Foo` and a method `f` that accepts `Foo[_]`. This code compiles in Scala 2 but causes a type error (E043) in Scala 3 because Scala 3 cannot reduce the application of the higher-kinded type `Foo` to a wildcard argument.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-other-changes.md#_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ntrait Example {\n  type Foo[A]\n\n  def f(foo: Foo[_]): Unit // [E043] In Scala 3, Type Error: unreducible application of higher-kinded type Example.this.Foo to wildcard arguments \n}\n```\n\n----------------------------------------\n\nTITLE: Matching Typechecked Function Applications (Implicit Types) - Scala\nDESCRIPTION: Shows how typechecking adds implicit type arguments to function calls. Matching a typechecked tree using `q\"$_; f[..$ts](..$args)\"` (where `$_` matches preceding statements) reveals the compiler-inferred type arguments in the `$ts` list.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"$_; f[..$ts](..$args)\" = toolbox.typecheck(q\"\"\"\n             def f[T](xs: T*): List[T] = xs.toList\n             f(1, 2, 3)\n           \"\"\")\nts: List[universe.Tree] = List(Int)\nargs: List[universe.Tree] = List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Constructing Anonymous Functions with Scala Quasiquotes\nDESCRIPTION: Shows three ways to create `Function` ASTs using quasiquotes: placeholder syntax (`q\"_ + 1\"`), named parameter with inferred type (`q\"(a => a + 1)\"`), and named parameter with explicit type (`q\"(a: Int) => a + 1\"`). Note the implementation restriction requiring parentheses for the second form when used standalone.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_46\n\nLANGUAGE: scala\nCODE:\n```\nscala> val f1 = q\"_ + 1\"\nanon1: universe.Function = ((x$4) => x$4.$plus(1))\n\nscala> val f2 = q\"(a => a + 1)\"\nanon2: universe.Function = ((a) => a.$plus(1))\n\nscala> val f3 = q\"(a: Int) => a + 1\"\nanon3: universe.Function = ((a: Int) => a.$plus(1))\n```\n\n----------------------------------------\n\nTITLE: Obtaining TypeTag using typeTag method in Scala\nDESCRIPTION: Example of obtaining a TypeTag for Int type using the typeTag method provided by the Universe.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/reflection/typetags-manifests.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\nval tt = typeTag[Int]\n```\n\n----------------------------------------\n\nTITLE: Creating Enumerations in JavaScript\nDESCRIPTION: Example of creating a simple enumeration-like object in JavaScript with Object.freeze to prevent modifications.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_36\n\nLANGUAGE: javascript\nCODE:\n```\nlet Color = {\n  RED: 1,\n  GREEN: 2,\n  BLUE: 3\n};\nObject.freeze(Color);\n```\n\n----------------------------------------\n\nTITLE: Proposed Handling of Explicit `given` Bindings with Different Types in Scala\nDESCRIPTION: Discusses the proposed handling of explicit `given` bindings using `@` where the *same name* (`x`) is bound to *different types* (`String`, `Int`) in alternative branches. The proposal suggests this code should compile, adding a contextual variable `x` to the scope with the Least Upper Bound (LUB) type (`String | Int`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/alternative-bind-variables.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\n  enum Foo:\n    case Bar(s: String)\n    case Baz(i: Int)\n\n    def fun = this match\n      case Bar(x @ given String) | Baz(x @ given Int) => ???\n```\n\n----------------------------------------\n\nTITLE: Mutable Field Declaration in Java\nDESCRIPTION: Declares integer fields i using standard Java mutable variable syntax. The snippet shows both standard variable declaration and an invalid example 'var i = 1;' (which is invalid syntax in Java), indicating mutable field as default in Java.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_14\n\nLANGUAGE: Java\nCODE:\n```\nint i = 1;\nvar i = 1;\n```\n\n----------------------------------------\n\nTITLE: Updating partest check files (Shell)\nDESCRIPTION: Runs the `partest` tool with the `--update-check` flag for a specific test file. This command automatically updates the content of the corresponding `.check` file to match the current test output, useful when the output changes are intentional. Requires `partest` installed and available in the path or executed from the correct location, and the path to the test file.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/hacker-guide.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n./test/partest --update-check path/to/test.scala\n```\n\n----------------------------------------\n\nTITLE: Defining a Method with No Parameters in Scala\nDESCRIPTION: Presents a method without parameter lists, returning a String derived from a system property. Suitable for read-only operations that do not require input.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/basics.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\ndef name: String = System.getProperty(\"user.name\")\nprintln(\"Hello, \" + name + \"!\")\n```\n\n----------------------------------------\n\nTITLE: Java Code Handling Exceptions from Scala Class\nDESCRIPTION: A Java program that uses the Scala Reader class, catching the IOException that was properly annotated in the Scala code with @throws.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/annotations.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\npackage test;\nimport examples.Reader;  // Classe Scala acima declarada!!\npublic class AnnotaTest {\n    public static void main(String[] args) {\n        try {\n            Reader in = new Reader(args[0]);\n            int c;\n            while ((c = in.read()) != -1) {\n                System.out.print((char) c);\n            }\n        } catch (java.io.IOException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Deconstructing Existential Types in Scala Quasiquotes - Scala\nDESCRIPTION: Explains how to define and extract existential types, with both explicit ('forSome') and underscore notations. Requires Scala macro and reflection capabilities. Inputs: existential type trees (e.g., 'List[T] forSome { type T }', 'List[_]'); outputs: the quantified type ('tpt') and the list of type member definitions ('defns').\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/type-details.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval tq\"$tpt forSome { ..$defns }\" = tq\"List[T] forSome { type T }\"\nval tq\"$tpt forSome { ..$defns }\" = tq\"List[_]\"\n```\n\n----------------------------------------\n\nTITLE: Applying Java annotation using concise 'value' syntax in Java\nDESCRIPTION: Demonstrates the concise syntax in Java for applying an annotation that has an element named `value`. The value for the `value` element can be provided directly in parentheses without explicitly naming the parameter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/annotations.md#_snippet_7\n\nLANGUAGE: Java\nCODE:\n```\n@SourceURL(\"https://coders.com/\")\npublic class MyJavaClass extends TheirClass ...\n```\n\n----------------------------------------\n\nTITLE: Defining a Parameterized Enum - Java\nDESCRIPTION: This snippet demonstrates a Java enum with parameters. Each Color enum has an associated integer 'rgb' value, which is set using a private constructor. The enum defines a private field and includes the parameter as a constructor argument. This allows each enum case to have unique per-instance data.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_58\n\nLANGUAGE: Java\nCODE:\n```\nenum Color {\n  Red(0xFF0000),\n  Green(0x00FF00),\n  Blue(0x0000FF);\n\n  private int rgb;\n\n  Color(int rgb) {\n    this.rgb = rgb;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Isolating Snippets with mdoc:nest in Scala\nDESCRIPTION: Demonstrates the `mdoc:nest` modifier, which wraps the Scala code snippet (`case class Foo(a: Int)`) in a `scala.Predef.locally{...}` block. This isolates the snippet's scope, preventing naming conflicts with definitions in other snippets (like the `Foo` object defined previously) without affecting the overall compilation context for subsequent snippets.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/add-guides.md#_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:nest\ncase class Foo(a: Int) // conflicts with Foo above, but it's nested so it's fine\n```\n```\n\n----------------------------------------\n\nTITLE: Pretty Printing Reflection Trees Using show and showRaw (Scala)\nDESCRIPTION: Uses Scala reflection utilities to present syntax trees in readable formats. The `show` method formats a Tree as human-friendly Scala-like code, while `showRaw` displays the internal AST structure, similar to what the Scala compiler sees, aiding macro development and AST inspection. The example shows a simple class definition tree and its printed forms. The snippet assumes availability of scala.reflect.runtime.universe with runtime reflection enabled.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/reflection/annotations-names-scopes.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.reflect.runtime.universe._\n\ndef tree = reify { final class C { def x = 2 } }.tree\n\nprintln(show(tree))\nprintln(showRaw(tree))\n```\n\n----------------------------------------\n\nTITLE: Running the Scala Test Suite with Ant - Shell\nDESCRIPTION: Executes the test suite using the Ant build automation tool. This feature was removed on Scala 2.12 and later branches, but for earlier versions, invoke from the project root. Ant must be installed and configured for the Scala build system.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/partest-guide.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nant test.suite\n```\n\n----------------------------------------\n\nTITLE: Exception Handling Using try-except-finally in Python\nDESCRIPTION: Shows Python error handling with 'try' block executing code that may raise exceptions, catching 'NameError' and a generic catch-all 'except', followed by a 'finally' block that executes regardless of exceptions to print a final statement.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_33\n\nLANGUAGE: Python\nCODE:\n```\ntry:\n  print(a)\nexcept NameError:\n  print(\"NameError\")\nexcept:\n  print(\"Other\")\nfinally:\n  print(\"Finally\")\n```\n\n----------------------------------------\n\nTITLE: Using Abstract Inline Methods within Another Inline Function in Scala\nDESCRIPTION: Demonstrates calling an abstract `inline` method (`logger.log`) from within another `inline` function (`logged`). This is allowed because when `logged` is inlined, the concrete type of `logger` becomes known, enabling the specific `log` implementation to be inlined.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/inline.md#_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\ninline def logged(logger: InlineLogger, x: Any) =\n  logger.log(x)\n```\n\n----------------------------------------\n\nTITLE: Using Unhygienic Macro - Scala\nDESCRIPTION: Demonstrates the usage of the `MyMacro` defined previously. It includes its own definition of `wrapper` within the same scope. When the macro expands, the unqualified `wrapper` call generated by the macro resolves to this local `wrapper`, causing unexpected behavior and highlighting the referential transparency issue.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/hygiene.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n// ---- Test.scala ----\npackage example\n\nobject Test extends App {\n  def wrapper(x: Int) = x\n  MyMacro(2)\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Types in Scala Macros Using Pattern Matching\nDESCRIPTION: This code demonstrates pattern matching on types within quoted code, specifically matching `Option[T]` expressions where `T` is known or unknown. It shows how to pattern match on the structure of code involving types, including the use of type parameters in patterns, enabling extraction of type information at compile time for further code generation or analysis.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_23\n\nLANGUAGE: Scala\nCODE:\n```\ndef exprOfOption[T: Type](x: Expr[Option[T]])(using Quotes): Option[Expr[T]] =\n  x match\n    case '{ Some($x: T) } => Some(x) // x: Expr[T]\n                // ^^^ type ascription with type T\n    ...\n\ndef exprOfOptionOf[T: Type](x: Expr[Option[Any]])(using Quotes): Option[Expr[T]] =\n  x match\n    case '{ Some($x: T) } => Some(x) // x: Expr[T]\n    case _ => None\n\n// Usage examples:\nexprOfOptionOf[Int]('{ Some(3) })   // Some('{3})\nexprOfOptionOf[Int]('{ Some(\"a\") }) // None\n```\n\n----------------------------------------\n\nTITLE: Constructing Ascription Quasiquotes - Scala\nDESCRIPTION: Shows how to create an AST node for a type ascription expression using quasiquotes. The example `q\"(1 + 1): Int\"` demonstrates creating a tree that applies a type annotation (`Int`) to an expression (`1 + 1`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_27\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val ascribed = q\"(1 + 1): Int\"\nascribed: universe.Typed = (1.$plus(1): Int)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Type Mismatch with Previous `for`-`yield` Desugaring in Scala 3\nDESCRIPTION: Demonstrates a scenario in Scala 3 using an invariant `Container` type where the previous desugaring (always adding a `.map`) caused a type mismatch. The identity `map` introduced by `yield v` prevented the implicit upcast from `Container[Dog]` to `Container[Animal]`. Requires enabling `scala.language.experimental.betterFors`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\n//>  using scala 3.nightly\n\nimport scala.language.experimental.betterFors\n\ncase class Container[A](val value: A) {\n  def map[B](f: A => B): Container[B] = Container(f(value))\n}\n\nsealed trait Animal\ncase class Dog() extends Animal\n\ndef opOnDog(dog: Container[Dog]): Container[Animal] =\n  for\n    v <- dog\n  yield v\n```\n\n----------------------------------------\n\nTITLE: Running Scala 2 Nightly Builds with scala-cli (Shell)\nDESCRIPTION: These shell commands allow users to run Scala 2 nightly builds directly using scala-cli. The '-S 2.13.nightly', '-S 2.nightly', or '-S 2.12.nightly' options choose the nightly version for the specified Scala branch. This requires an installed version of scala-cli. All standard subcommands are supported.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/nightlies.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nscala-cli -S 2.13.nightly\n```\n\nLANGUAGE: Shell\nCODE:\n```\nscala-cli -S 2.nightly     # same as 2.13.nightly\n```\n\nLANGUAGE: Shell\nCODE:\n```\nscala-cli -S 2.12.nightly\n```\n\n----------------------------------------\n\nTITLE: Блокирующий однопоточный вызов в Scala\nDESCRIPTION: Пример блокирующего вызова, где println не выполнится до завершения aShortRunningTask, демонстрирующий особенности синхронного выполнения.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/concurrency.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef aShortRunningTask(): Int =\n  Thread.sleep(500)\n  42\nval x = aShortRunningTask()\nprintln(\"Here\")\n```\n\n----------------------------------------\n\nTITLE: Deconstructing Tuples with Scala Quasiquotes\nDESCRIPTION: Shows how to deconstruct tuples of arbitrary arity using the `q\"(..$elems)\"` pattern. This extracts the elements of the tuple into a `List[universe.Tree]`. It works for standard tuples, single expressions (treated as single-element tuples for this pattern), and `Unit` (treated as a nullary tuple).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_36\n\nLANGUAGE: scala\nCODE:\n```\nscala> val q\"(..$elems)\" = q\"(a, b)\"\nelems: List[universe.Tree] = List(a, b)\n\nscala> val q\"(..$elems)\" = q\"(a)\"\nelems: List[universe.Tree] = List(a)\n\nscala> val q\"(..$elems)\" = q\"()\"\nelems: List[universe.Tree] = List()\n```\n\n----------------------------------------\n\nTITLE: Creating a List Collection in Scala\nDESCRIPTION: Initializes a list of integers that will be used in subsequent examples to demonstrate anonymous functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/fun-anonymous-functions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval ints = List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Configuring Macro Paradise in SBT Build Definition\nDESCRIPTION: This snippet shows how to add the Macro Paradise compiler plugin to an SBT build. It adds the Sonatype repository and the compiler plugin dependency with the appropriate version.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/paradise.md#_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nresolvers += Resolver.sonatypeRepo(\"releases\")\n\naddCompilerPlugin(\"org.scalamacros\" % \"paradise\" % \"2.1.0-M4\" cross CrossVersion.full)\n```\n\n----------------------------------------\n\nTITLE: Overriding Splitter Methods for Load Balancing in Scala Parallel Collections\nDESCRIPTION: This Scala method snippet presents an override for the shouldSplitFurther method in splitters used by parallel collections. It uses the remaining element count compared to a threshold derived from collection size and parallelism level to decide if splitting should continue, optimizing workload distribution. This approach assumes the remaining method is inexpensive; for costly computations, it suggests alternative implementations like counters or overriding isRemainingCheap. This supports efficient parallel execution by controlling the granularity of data partitioning.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/overviews/parallel-collections/custom-parallel-collections.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ndef shouldSplitFurther[S](coll: ParIterable[S], parallelismLevel: Int) =\n  remaining > thresholdFromSize(coll.size, parallelismLevel)\n```\n\n----------------------------------------\n\nTITLE: Constructing and Extracting Applied Types with Quasiquotes - Scala\nDESCRIPTION: Shows how to build and destructure applied (parameterized) types using quasiquotes. Highlights pattern matching for type arguments, including empty application. Requires 'import scala.reflect.runtime.universe._'. Inputs are applied type constructions, outputs include lists of extracted type arguments ('targs').\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/type-details.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval applied = tq\"Foo[A, B]\"\nval tq\"Foo[..$targs]\" = applied\nval tq\"Foo[..$targs]\" = tq\"Foo\"\n```\n\n----------------------------------------\n\nTITLE: Unsound Variance Checking in Scala 2\nDESCRIPTION: Example of Scala 2 code that has unsound variance checking in default parameters and inner classes. This code compiles in Scala 2 but fails in Scala 3 due to stricter variance checking.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-type-checker.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Foo[-A](x: List[A]) {\n  def f[B](y: List[B] = x): Unit = ???\n}\n\nclass Outer[+A](x: A) {\n  class Inner(y: A)\n}\n```\n\n----------------------------------------\n\nTITLE: Scala Value Class Expansion Result (Step 1 Example)\nDESCRIPTION: Shows the result of the first step in the compiler expansion of the `Meter` value class. The original methods are transformed into simple calls to static 'extension' methods in the companion object. The companion object contains the actual implementation logic, taking the value class instance as the first parameter (`$this`). Synthetic `equals` and `hashCode` methods are also added and expanded.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/value-classes.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n    class Meter(val underlying: Double) extends AnyVal with Printable {\n        def plus (other: Meter): Meter =\n           Meter.extension$plus(this, other)\n        def divide (other: Meter): Double =\n           Meter.extension1$divide(this, other)\n        def divide (factor: Double): Meter =\n           Meter.extension2$divide(this, factor)\n        def less (other: Meter): Boolean =\n           Meter.extension$less(this, other)\n        override def toString: String =\n           Meter.extension$toString(this)\n        override def equals(other: Any) =\n           Meter.extension$equals(this, other)\n        override def hashCode =\n           Meter.extension$hashCode(this)\n    }\n```\n\nLANGUAGE: Scala\nCODE:\n```\n    object Meter {\n       def extension$plus($this: Meter, other: Meter) =\n         new Meter($this.underlying + other.underlying)\n       def extension1$divide($this: Meter, other: Meter): Double =\n         $this.underlying / other.underlying\n       def extension2$divide($this: Meter, factor: Double): Meter =\n         new Meter($this.underlying / factor)\n       def extension$less($this: Meter, other: Meter): Boolean =\n          $this.underlying < other.underlying\n       def extension$toString($this: Meter): String =\n          $this.underlying.toString + “m”\n       def extension$equals($this: Meter, other: Any) = other match {\n          case that: Meter => $this.underlying == that.underlying\n          case _ => false\n       }\n       def extension$hashCode($this: Meter) = $this.underlying\n    }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Intersperse Operation Examples\nDESCRIPTION: Provides examples of the desired behavior for a custom 'intersperse' collection operation, showing how it inserts a separator element between elements of a sequence, working on different collection types like `List` and `String`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collection-operations.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nList(1, 2, 3).intersperse(0) == List(1, 0, 2, 0, 3)\n\"foo\".intersperse(' ') == \"f o o\"\n```\n\n----------------------------------------\n\nTITLE: Importing Mutable Collections in Scala\nDESCRIPTION: This code snippet demonstrates how to import the mutable package from Scala's collection library. This import enables accessing mutable collection classes like 'mutable.Set' with the 'mutable' prefix, while unprefixed types like 'Set' remain immutable by default.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/collections-2.13/overview.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.collection.mutable\n```\n\n----------------------------------------\n\nTITLE: Programmatically Constructing Functions with Inferred Types\nDESCRIPTION: Demonstrates creating a function AST programmatically where the parameter type should be inferred. This involves creating an empty type tree using `tq\"\"`, using it in a `ValDef` quasiquote `q\"val x: $tpt\"`, and then using that parameter `ValDef` in the function quasiquote `q\"($param => x)\"`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_47\n\nLANGUAGE: scala\nCODE:\n```\nscala> val tpt = tq\"\"\ntpt: universe.TypeTree = <type ?>\n\nscala> val param = q\"val x: $tpt\"\nparam: universe.ValDef = val x\n\nscala> val fun = q\"($param => x)\"\nfun: universe.Function = ((x) => x)\n```\n\n----------------------------------------\n\nTITLE: Creating List of Trees for Splicing (Scala)\nDESCRIPTION: Initializes a `List[universe.Tree]` containing two simple identifier trees, prepared for demonstrating the unquote splicing (`..$`) feature. Splicing is used to insert a variable number of elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/intro.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val ab = List(q\"a\", q\"b\")\n```\n\n----------------------------------------\n\nTITLE: Using Procedure Syntax to Define Methods Without Explicit Return Types - Scala\nDESCRIPTION: This code demonstrates the deprecated (now invalid) Scala 2 procedure syntax for methods: omitting the explicit ': Unit =' return type. The method 'print' is defined without a return specification. In Scala 3, this results in a compilation error, requiring the explicit return type. No dependencies are needed. Only parameterless procedures using curly braces are affected.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-syntactic.md#_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nobject Bar {\n  def print() { // In Scala 3, Error: Procedure syntax no longer supported; `: Unit =` should be inserted here.\n    println(\"bar\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Reflection Utilities within the Macro Context in Scala\nDESCRIPTION: Imports the reflection API of the current macro context `c` by importing all members of `c.universe`. This grants access to common types, reflection utilities, and AST node types needed for macro implementation and code generation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/overview.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nimport c.universe._\n```\n\n----------------------------------------\n\nTITLE: Building Android APK with GluonFX (Maven)\nDESCRIPTION: Builds a native Android application package (APK) using the GluonFX Maven plugin, specifically activating the 'android' profile via '-Pandroid'. This command compiles the Scala code to a native Android executable packaged within an APK. Requires a Maven project configured for Android builds with GluonFX, GraalVM, Android SDK/NDK, and the necessary profiles set up. The resulting APK is typically located in the 'target/client/aarch64-android/gvm' directory.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-on-android.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nmvn -Pandroid gluonfx:build gluonfx:package\n```\n\n----------------------------------------\n\nTITLE: Defining and Extracting Annotated Types Using Quasiquotes - Scala\nDESCRIPTION: Shows how to add and extract annotations from types with quasiquotes. Requires access to Scala's macro reflection API. Inputs are annotated type trees (e.g., 'T @Fooable'); outputs are the type and annotation components ('tpt', 'annot') extracted via pattern matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/type-details.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval annotated = tq\"T @Fooable\"\nval tq\"$tpt @$annot\" = annotated\n```\n\n----------------------------------------\n\nTITLE: Syntax Issues with Abstract Givens in Scala\nDESCRIPTION: Highlights the problematic syntax of current abstract givens. While `given Tag[String]()` and `given Tag[String] with {}` create concrete instances, the seemingly natural `given Tag[String]` is misinterpreted as an abstract given definition, leading to a cryptic error. This motivates the proposal to remove abstract givens in favor of deferred givens.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/typeclasses-syntax.md#_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nclass Tag[T]\n\ngiven Tag[String]()\ngiven Tag[String] with {}\n\n// Fails with 'anonymous given cannot be abstract'\ngiven Tag[String]\n```\n\n----------------------------------------\n\nTITLE: Using Aux Pattern as Workaround for Byname Implicit Dependent Types (Scala)\nDESCRIPTION: Presents a workaround for the limitation of accessing dependent types via unstable byname implicit paths. By using the `Aux` pattern (`Foo.Aux[T]`), the dependent type `Out` is lifted into a type parameter `T`, allowing the implicit `bar` to be correctly defined using a byname parameter (`foo: => Foo.Aux[T]`) while still accessing the underlying value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\ntrait Foo {\n  type Out\n  def out: Out\n}\n\nobject Foo {\n  type Aux[Out0] = Foo { type Out = Out0 }\n}\n\nobject Test {\n  implicit def bar[T](implicit foo: => Foo.Aux[T]): T = foo.out\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Objects with New Scala 3 Keywords as Identifiers in Scala 2 - Scala\nDESCRIPTION: This snippet creates an object named 'given' and defines a value 'enum' inside it, both of which are legal identifiers in Scala 2.13 but invalid in Scala 3 due to newly reserved keywords. No imports or libraries are needed, but migrating to Scala 3 will result in syntax errors. Both the object and the value are referenced conventionally, demonstrating this incompatibility.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/incompat-syntactic.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject given { // In Scala 3, Error: given is now a keyword.\n  val enum = ??? // In Scala 3, Error: enum is now a keyword.\n\n  println(enum) // In Scala 3, Error: enum is now a keyword.\n}\n```\n\n----------------------------------------\n\nTITLE: Define Companion Object for PrefixMap in Scala\nDESCRIPTION: Provides factory methods and integration support for the `PrefixMap` class. It includes `empty` to create a new empty map, `apply` to create a map from key-value pairs, `newBuilder` for constructing maps incrementally, and an implicit `CanBuildFrom` instance. This `CanBuildFrom` allows higher-order methods like `map` applied to a `PrefixMap` to return a result of type `PrefixMap` when appropriate, ensuring seamless integration with the Scala collections framework. Requires imports for `Builder`, `MapBuilder`, and `CanBuildFrom`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/core/architecture-of-scala-collections.md#_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.collection.mutable.{Builder, MapBuilder}\nimport scala.collection.generic.CanBuildFrom\n\nobject PrefixMap extends {\n  def empty[T] = new PrefixMap[T]\n\n  def apply[T](kvs: (String, T)*): PrefixMap[T] = {\n    val m: PrefixMap[T] = empty\n    for (kv <- kvs) m += kv\n    m\n  }\n\n  def newBuilder[T]: Builder[(String, T), PrefixMap[T]] =\n    new MapBuilder[String, T, PrefixMap[T]](empty)\n\n  implicit def canBuildFrom[T]\n    : CanBuildFrom[PrefixMap[_], (String, T), PrefixMap[T]] =\n      new CanBuildFrom[PrefixMap[_], (String, T), PrefixMap[T]] {\n        def apply(from: PrefixMap[_]) = newBuilder[T]\n        def apply() = newBuilder[T]\n      }\n}\n```\n\n----------------------------------------\n\nTITLE: Example Scaladoc Output for Compilation Error Assertion\nDESCRIPTION: Illustrates the expected output format when using Scaladoc's snippet checking feature with the `sc:fail` flag. It shows the location and details of the expected compilation error.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/snippet-compiler.md#_snippet_4\n\nLANGUAGE: nohighlight\nCODE:\n```\n\nAt 18:21:\n  List(1,2,3).toMap\nError: Cannot prove that Int <:< (K, V)\n\nwhere:    K is a type variable with constraint \n          V is a type variable with constraint \n.\n```\n\n----------------------------------------\n\nTITLE: Defining the RNA1 Class (Scala 2)\nDESCRIPTION: Defines the initial `RNA1` class in Scala 2, representing an immutable sequence of `Base` objects. It utilizes an `Array[Int]` for compact storage via bit packing, storing multiple bases per integer. The class extends `IndexedSeq[Base]` and `IndexedSeqOps` to integrate with Scala's collection framework, implementing `apply` for element access and overriding `fromSpecific`, `newSpecificBuilder`, and `empty` for proper collection operations. The constructor is private, enforcing instantiation via the companion object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/custom-collections.md#_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport collection.mutable\nimport collection.immutable.{ IndexedSeq, IndexedSeqOps }\n\nfinal class RNA1 private (\n  val groups: Array[Int],\n  val length: Int\n) extends IndexedSeq[Base]\n  with IndexedSeqOps[Base, IndexedSeq, RNA1] {\n\n  import RNA1._\n\n  def apply(idx: Int): Base = {\n    if (idx < 0 || length <= idx)\n      throw new IndexOutOfBoundsException\n    Base.fromInt(groups(idx / N) >> (idx % N * S) & M)\n  }\n\n  override protected def fromSpecific(coll: IterableOnce[Base]): RNA1 =\n    fromSeq(coll.iterator.toSeq)\n  override protected def newSpecificBuilder: mutable.Builder[Base, RNA1] =\n    iterableFactory.newBuilder[Base].mapResult(fromSeq)\n  override def empty: RNA1 = fromSeq(Seq.empty)\n  override def className = \"RNA1\"\n}\n\nobject RNA1 {\n\n  // Number of bits necessary to represent group\n  private val S = 2\n\n  // Number of groups that fit in an Int\n  private val N = 32 / S\n\n  // Bitmask to isolate a group\n  private val M = (1 << S) - 1\n\n  def fromSeq(buf: collection.Seq[Base]): RNA1 = {\n    val groups = new Array[Int]((buf.length + N - 1) / N)\n    for (i <- 0 until buf.length)\n      groups(i / N) |= Base.toInt(buf(i)) << (i % N * S)\n    new RNA1(groups, buf.length)\n  }\n\n  def apply(bases: Base*) = fromSeq(bases)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Parallel String Collection in Scala by Extending immutable.ParSeq\nDESCRIPTION: This snippet implements a custom parallel collection class `ParString` by extending `immutable.ParSeq[Char]`. It provides core methods such as `apply`, `length`, and a method to obtain a sequential equivalent `WrappedString`. It also defines a splitter class `ParStringSplitter` for parallel processing, managing positions within the string, and providing methods like `next`, `hasNext`, `remaining`, `dup`, `split`, and `psplit` for dividing the collection into subparts for parallel execution.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/overviews/parallel-collections/custom-parallel-collections.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass ParString(val str: String) \nextends immutable.ParSeq[Char] {\n  def apply(i: Int) = str.charAt(i)\n  def length = str.length\n  def seq = new collection.immutable.WrappedString(str)\n  def splitter = new ParStringSplitter(str, 0, str.length)\n  class ParStringSplitter(private var s: String, private var i: Int, private val ntl: Int) \n  extends SeqSplitter[Char] {\n    final def hasNext = i < ntl\n    final def next = {\n      val r = s.charAt(i)\n      i += 1\n      r\n    }\n    def remaining = ntl - i\n    def dup = new ParStringSplitter(s, i, ntl)\n    def split = {\n      val rem = remaining\n      if (rem >= 2) psplit(rem / 2, rem - rem / 2)\n      else Seq(this)\n    }\n    def psplit(sizes: Int*): Seq[ParStringSplitter] = {\n      val splitted = new ArrayBuffer[ParStringSplitter]\n      for (sz <- sizes) {\n        val next = (i + sz) min ntl\n        splitted += new ParStringSplitter(s, i, next)\n        i = next\n      }\n      if (remaining > 0) splitted += new ParStringSplitter(s, i, ntl)\n      splitted\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Enum Macro with Typed Parameters in Scala\nDESCRIPTION: This snippet shows the traditional definition of an Enum macro in Scala using Macro Paradise, where the macro definition expects typed parameters (Symbol*), forcing the compiler to typecheck each argument passed to the macro. The implementation method takes a context and typed expressions corresponding to symbols, returning a transformed syntax tree.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/untypedmacros.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype Enum(symbol: Symbol*) = macro Macros.enum\nobject Macros {\n  def enum(c: Context)(symbol: c.Expr[Symbol]*): c.Tree = ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Immutable Map (Java)\nDESCRIPTION: This Java snippet demonstrates how to create an immutable Map instance using the `Map.of()` factory method. It shows how to specify key-value pairs to initialize the map.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_58\n\nLANGUAGE: Java\nCODE:\n```\nMap map = Map.of(\n  \"a\", 1,\n  \"b\", 2,\n  \"c\", 3\n);\n```\n\n----------------------------------------\n\nTITLE: Compiler Expansion of Recursive Show Instance Construction for List in Scala\nDESCRIPTION: Shows the expanded structure the compiler generates when resolving Show[List[Int]] with byname implicits. The definition creates a val holding the recursive Show[List[Int]] and connects it through recursive references in nested generic derivations using explicit val rec assignments. Demonstrates the full dependency graph as resolved by the compiler for recursive ADTs. Relies on Show and Generic machinery for List and Cons types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nval sl: Show[List[Int]] = Show.apply[List[Int]](\n  {\n    object LazyDefns$1 {\n      val rec$1: Show[List[Int]] =\n        showGeneric(\n          generic[List[Int]],\n          showEither(\n            showGeneric(\n              generic[Cons[Int]]\n              showCons(\n                showInt,\n                showCons(\n                  rec$1,\n                  showUnit\n                )\n              )\n            ),\n            showUnit\n          )\n        )\n    }\n    LazyDefns$1.rec$1\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Tuples in Java Using Helper Classes - Java\nDESCRIPTION: This snippet demonstrates tuple creation in Java using helper classes like Pair, Triplet, and Quartet. Each tuple is instantiated by passing each element to the constructor or static factory method. The code requires the presence of classes such as Pair, Triplet, and Quartet (often from third-party libraries), and demonstrates tuples of sizes 2 through 4 with different element types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_54\n\nLANGUAGE: Java\nCODE:\n```\nPair<String, Integer> pair =\n  new Pair<String, Integer>(\"Eleven\", 11);\n\nTriplet<String, Integer, Double> triplet =\n  Triplet.with(\"Eleven\", 11, 11.0);\nQuartet<String, Integer, Double, Person> quartet =\n  Quartet.with(\"Eleven\", 11, 11.0, new Person(\"Eleven\"));\n```\n\n----------------------------------------\n\nTITLE: Applying Java annotation with named arguments in Java\nDESCRIPTION: Demonstrates the syntax for applying a Java annotation with multiple elements in Java. Each element's value must be explicitly specified using named arguments (`elementName = value`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/annotations.md#_snippet_4\n\nLANGUAGE: Java\nCODE:\n```\n@Source(url = \"https://coders.com/\",\n        mail = \"support@coders.com\")\npublic class MyJavaClass extends TheirClass ...\n```\n\n----------------------------------------\n\nTITLE: Analyzing Complexity and Covering Sets During Implicit Expansion (Scala)\nDESCRIPTION: Presents the calculated complexity and covering set for each type generated during the `Foo[A]` implicit resolution trace. Steps generated via `fooGen` (marked with `*`) are subject to divergence checking. This analysis demonstrates that while type complexity increases, the covering sets also change, which prevents divergence under the proposed new algorithm.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/byname-implicits.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\n  Complexity      Covering set\n\n  2               Foo, A\n* 6               Foo, B, Int, Unit\n  2               Foo, B\n* 8               Foo, C, Int, Boolean, Unit\n  2               Foo, C\n* 8               Foo, Int, String, Boolean, Unit\n```\n\n----------------------------------------\n\nTITLE: Polymorphic Function as a Method (Eta-Expansion Limitation) in Scala\nDESCRIPTION: This variation makes the polymorphic function a method (`def unfolder[T](...)`). The intention is to pass it as a value, but eta-expansion does not handle polymorphic parameters without SIP-49. Inputs, outputs, and dependencies match previous examples; observed limitation is compile error due to monomorphic eta-expansion.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/polymorphic-eta-expansion.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n...  \n  def readElems(s: String): Option[(T, String)] = {\n    type Acc = (String, Seq[String], Boolean)\n    def unfolder[T](acc: Acc, rt: Read[T]): Acc = {\n      val (s, labels, first) = acc\n      (for {\n        (_, tl0) <- if(first) Some((\"\", s)) else head(s, \"(,)(.*)\".r)\n        (_, tl1) <- head(tl0, s\"(${labels.head}):(.*)\".r)\n        (t, tl2) <- rt.read(tl1)\n        } yield (t, tl2)) match {\n          case Some(t, tl2) => ((tl2, labels.tail, false), Some(t))\n          case None => ((s, labels, first), None)\n        }\n    }\n    inst.unfold[Acc]((s, labelling.elemLabels, true))(unfolder) match {\n      case (s, None) => None\n      case (acc, Some(t)) => Some((t, acc._1))\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Deconstructing Function Parameters (ValDefs)\nDESCRIPTION: Demonstrates further deconstruction of the function parameters extracted as a list of `ValDef`s. The example extracts the parameters list and then uses `q\"$_ val $name: $tpt\"` to extract the name and type tree from a parameter's `ValDef`. Using `$_` for modifiers is recommended to avoid match failures due to unexpected flags.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_49\n\nLANGUAGE: scala\nCODE:\n```\nscala> val q\"(..$params) => $_\" = f3\nparams: List[universe.ValDef] = List(val a: Int = _)\n\nscala> val List(q\"$_ val $name: $tpt\") = params\nname: universe.TermName = a\ntpt: universe.Tree = Int\n```\n\n----------------------------------------\n\nTITLE: Calling a Helper Method in Scala\nDESCRIPTION: Demonstrates how to invoke the `circumference` helper method defined within the `CircleHelpers` object, explicitly passing a `Circle` instance (`aCircle`) as an argument.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/ca-extension-methods.md#_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval aCircle = Circle(2, 3, 5)\n\n// без использования метода расширения\nCircleHelpers.circumference(aCircle)\n```\n\n----------------------------------------\n\nTITLE: Opaque Type Definition of NamedTuple with Type Parameters in Scala 3\nDESCRIPTION: Specifies the internal representation of named tuples as an opaque type alias parameterized by a tuple of string literal names and a tuple of element types. The alias erases names at runtime, meaning named tuples and regular tuples share runtime representation. This design enables named tuples to be syntactic sugar over standard tuples with the same element values but with compile-time names for type safety and pattern matching.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/named-tuples.md#_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nopaque type NamedTuple[N <: Tuple, +V <: Tuple] >: V = V\n```\n\n----------------------------------------\n\nTITLE: Generated Code for @unroll on Case Classes (Constructors, copy, apply) in Scala\nDESCRIPTION: Shows the conceptual code generated when `@unroll` is applied to a `case class`. This includes secondary constructors (`this`), overloaded `copy` methods, and overloaded `apply` methods in the companion object to maintain binary compatibility. Note that `.unapply` doesn't typically need duplication in Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/unroll-default-arguments.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\ncase class Unrolled(s: String, n: Int = 1, @unroll b: Boolean = true, @unroll l: Long = 0L){\n   def this(s: String, n: Int) = this(s, n, true, 0L)\n   def this(s: String, n: Int, b: Boolean) = this(s, n, b, 0L)\n\n   def copy(s: String, n: Int) = copy(s, n, this.b, this.l)\n   def copy(s: String, n: Int, b: Boolean) = copy(s, n, b, this.l)\n\n   def foo = s + n + b\n}\nobject Unrolled{\n   def apply(s: String, n: Int) = apply(s, n, true, 0L)\n   def apply(s: String, n: Int, b: Boolean) = apply(s, n, b, 0L)\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting a Raw Tree from an Expr in Scala Reflection\nDESCRIPTION: This snippet retrieves the underlying Tree from an Expr produced via reify. By accessing expr.tree, you obtain the full abstract syntax tree for the reified expression. This operation is vital for subsequent tree-based transformations, inspections, or code generation, and requires only the Expr object created by reify.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nval tree = expr.tree\n```\n\n----------------------------------------\n\nTITLE: Parsing Format String and Mapping Format Specifiers to Parameter ASTs in Scala Macro\nDESCRIPTION: Splits the format string into parts by format specifiers and maps each specifier to corresponding parameter expressions wrapped as `Ident` trees. The `paramsStack` holds macro parameter trees in reverse order. Special format specifiers (`%d`, `%s`, `%%`) are handled differently - numeric and string parameters are precomputed and `%` literal is inserted directly.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/macros/overview.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nval paramsStack = Stack[Tree]((params map (_.tree)): _*)\nval refs = s_format.split(\"(?<=%[\\\\w%])|(?=%[\\\\w%])\") map {\n  case \"%d\" => precompute(paramsStack.pop, typeOf[Int])\n  case \"%s\" => precompute(paramsStack.pop, typeOf[String])\n  case \"%%\" => Literal(Constant(\"%\"))\n  case part => Literal(Constant(part))\n}\n```\n\n----------------------------------------\n\nTITLE: Scala 2 Macro Implementation with Quasiquotes in Compatibility Module - Scala\nDESCRIPTION: This snippet demonstrates a Scala 2.13 macro implementation encapsulated in a separate compat object and package, meant for the example-compat submodule. It uses scala.reflect.macros.blackbox.Context and enables quasiquotes and macro language features. The macro constructs a new Location instance using quasiquoting and extracts file and line from the macro context. This implementation requires the scala-reflect dependency and is limited to Scala 2.13.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-macro-mixing.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\npackage location\n\nimport scala.reflect.macros.blackbox.Context\nimport scala.language.experimental.macros\n\ncase class Location(path: String, line: Int)\n\nobject Scala2MacrosCompat {\n  private[location] def locationImpl(c: Context): c.Tree =  {\n    import c.universe._\n    val location = typeOf[Location]\n    val line = Literal(Constant(c.enclosingPosition.line))\n    val path = Literal(Constant(c.enclosingPosition.source.path))\n    q\"new $location($path, $line)\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Motivation: Complex Desugaring of Pure Aliases Example\nDESCRIPTION: Presents a Scala `for` comprehension where a pure alias (`b = a`) follows a generator. This example is used to illustrate the complexity of the current desugaring mechanism.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nfor\n  a <- doSth(arg)\n  b = a\nyield a + b\n```\n\n----------------------------------------\n\nTITLE: Deconstructing Arguments with ..$ Pattern (Scala)\nDESCRIPTION: Shows how to use the `..$` syntax within a `q` pattern match on a function application tree (`q\"f(a, b)\"`) to extract the arguments as a `List[universe.Tree]` (`args`). This is the pattern matching counterpart to `..$` construction.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/intro.md#_snippet_19\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"f(..$args)\" = q\"f(a, b)\"\nargs: List[universe.Tree] = List(a, b)\n```\n\n----------------------------------------\n\nTITLE: Grammar Definition for Using Directives in Scala\nDESCRIPTION: Formal grammar definition for the Using Directives syntax. Defines the structure for how settings, identifiers, and values should be formatted within Using Directive special comments.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/scala-cli.md#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nUsingDirective ::= \"using\" Setting\nSetting ::= Ident ( Value | Values )\nIdent ::= ScalaIdent { \".\" ScalaIdent }\nValues ::= Value { \" \" [\",\"] Values }\nValue ::= Ident | stringLiteral | numericLiteral | true | false\n```\n\n----------------------------------------\n\nTITLE: Type Ascription with Parentheses Edge Case in Scala\nDESCRIPTION: This snippet displays another compatibility edge case with the fewerBraces proposal: a parenthesized type ascription that splits the type argument line, potentially causing parsing issues. The code maps over 'xs', indicating the function type '(Int => Int) => Int' in an indented fashion following the colon. Such code needs modification under the new rules but can be made legal by adjusting line breaks.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval y = (xs.map: (Int => Int) =>\n  Int)\n```\n\n----------------------------------------\n\nTITLE: Setting Git autocrlf to Avoid Windows Line Ending Issues - Shell\nDESCRIPTION: Provides git configuration commands to resolve line ending mismatches leading to test failures on Windows. Setting 'core.autocrlf' to false or input standardizes line endings in checked-in files and produced results.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/partest-guide.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\ngit config core.autocrlf false\n```\n\nLANGUAGE: shell\nCODE:\n```\ngit config core.autocrlf input\n```\n\n----------------------------------------\n\nTITLE: Creating a Set in Python\nDESCRIPTION: Shows how to create a Python set literal named 'set' containing the string elements \"a\", \"b\", and \"c\". Represents an unordered and unique collection.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_16\n\nLANGUAGE: Python\nCODE:\n```\nset = {\"a\", \"b\", \"c\"}\n```\n\n----------------------------------------\n\nTITLE: Defining Scaladoc Versions Dictionary (JSON)\nDESCRIPTION: This JSON structure defines the different versions of the documentation available. The 'versions' property contains a dictionary mapping version labels (e.g., \"3.0.x\", \"Nightly\") to the URLs of their respective index.html files.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/site-versioning.md#_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"versions\": {\n    \"3.0.x\": \"https://dotty.epfl.ch/3.0.x/docs/index.html\",\n    \"Nightly\": \"https://dotty.epfl.ch/docs/index.html\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Anonymous Type Provider Example Using Macro\nDESCRIPTION: This code snippet demonstrates defining a macro `h2db` which generates a local database module with a `Coffee` class and a `Coffees` table. The macro's expansion creates a trait with internal structure, providing a structural type that exposes database members, enabling static type checking despite hiding implementation details.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/macros/typeproviders.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef h2db(connString: String): Any = macro ...\n\n// invocation of the macro\nval db = h2db(\"jdbc:h2:coffees.h2.db\")\n\n// Macro expands into:\nval db = {\n  trait Db {\n    case class Coffee(...)\n    val Coffees: Table[Coffee] = ...\n  }\n  new Db {}\n}\n```\n\n----------------------------------------\n\nTITLE: Deconstructing If Expressions with Scala Quasiquotes\nDESCRIPTION: Demonstrates deconstructing `If` ASTs using the `q\"if ($cond) $thenp else $elsep\"` pattern. This extracts the condition, the 'then' part, and the 'else' part. If the original `if` expression lacks an `else` clause, the `$elsep` variable is bound to a synthetic `Unit` literal `()`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_42\n\nLANGUAGE: scala\nCODE:\n```\nscala> val q\"if ($cond) $thenp else $elsep\" = q\"if (true) a else b\"\ncond: universe.Tree = true\nthenp: universe.Tree = a\nelsep: universe.Tree = b\n\nscala> val q\"if ($cond) $thenp else $elsep\" = q\"if (true) a\"\ncond: universe.Tree = true\nthenp: universe.Tree = a\nelsep: universe.Tree = ()\n```\n\n----------------------------------------\n\nTITLE: Compiler Error Output for Type Mismatch Example\nDESCRIPTION: Displays the Scala 3 compiler error resulting from the previous code example when using the older desugaring rule. It highlights the type mismatch, showing that the `for`-comprehension resulted in `Container[Dog]` but `Container[Animal]` was expected, due to the invariance of `Container`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_22\n\nLANGUAGE: text\nCODE:\n```\n-- [E007] Type Mismatch Error: /home/kpi/bugs/better-fors-bug.scala:13:2 -------\n13 |  for\n   |  ^\n   |  Found:    (dog : Container[Dog])\n   |  Required: Container[Animal]\n14 |    v <- dog\n15 |  yield v\n   |\n   | longer explanation available when compiling with `-explain`\n```\n\n----------------------------------------\n\nTITLE: Updating List Elements in Python\nDESCRIPTION: Demonstrates assigning new values to existing list elements by index, modifying the list in place.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_39\n\nLANGUAGE: Python\nCODE:\n```\na[0] = 10\na[1] = 20\n```\n\n----------------------------------------\n\nTITLE: Multi-Line Void Method in Java\nDESCRIPTION: Defines a Java method walkThenRun that prints two statements sequentially. It uses multiple statements inside a void method body to demonstrate procedural style side effects with system output.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_10\n\nLANGUAGE: Java\nCODE:\n```\npublic void walkThenRun() {\n  System.out.println(\"walk\");\n  System.out.println(\"run\");\n}\n```\n\n----------------------------------------\n\nTITLE: Map Function Using Lambda in Python\nDESCRIPTION: Uses the 'map' function with a lambda expression to multiply each element of 'numbers' by 10, resulting in a map object converted to a list if needed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/scala3-book/scala-for-python-devs.md#_snippet_31\n\nLANGUAGE: Python\nCODE:\n```\nx = map(lambda x: x * 10, numbers)\n```\n\n----------------------------------------\n\nTITLE: Sample Program Output of Scala Interactive Application\nDESCRIPTION: Shows the expected output and interaction when running the HelloInteractive application. The example includes user input and the program's response.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/command-line-io.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n$ scala HelloInteractive\nEnter your first name: Alvin\nEnter your last name: Alexander\nYour name is Alvin Alexander\n```\n\n----------------------------------------\n\nTITLE: Базовый пример однопоточного вызова в Scala\nDESCRIPTION: Демонстрация синхронного вызова метода в Scala, где результат сразу доступен после выполнения функции.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/book/concurrency.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef aShortRunningTask(): Int = 42\nval x = aShortRunningTask()\n```\n\n----------------------------------------\n\nTITLE: Formal Desugaring Rule for Initial Aliases (Proposal 1)\nDESCRIPTION: Defines the new desugaring rule for `for` comprehensions starting with N pure aliases. It translates them into a block containing N `val` definitions, followed by the desugaring of the remaining part of the comprehension.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_14\n\nLANGUAGE: text\nCODE:\n```\nFor any N:\n  for (P_1 = E_1; ... P_N = E_N; ...) \n    ==> \n  { \n    val x_2 @ P_2 = E_2\n    ...\n    val x_N @ P_N = E_N\n    for (...)\n  }\n```\n\n----------------------------------------\n\nTITLE: Creating a List in Scala\nDESCRIPTION: Creates a simple list of integers which will be used in subsequent examples to demonstrate anonymous functions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/fun-anonymous-functions.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval ints = List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Using if-else-if Chains in Java\nDESCRIPTION: Java uses the `if`, `else if`, and `else` keywords to create conditional logic chains. The first condition that evaluates to true executes its corresponding block.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_34\n\nLANGUAGE: Java\nCODE:\n```\nif (x < 0) {\n  System.out.println(\"negative\")\n} else if (x == 0) {\n  System.out.println(\"zero\")\n} else {\n  System.out.println(\"positive\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Test Directory for ScalaTest - Bash\nDESCRIPTION: Bash command for generating the directory src/test/scala/math to contain test source files for the Scala project. Ensures tests mirror main code's package hierarchy, aiding organization and automatic test discovery by sbt. Input: none; Output: test source directory.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_23\n\nLANGUAGE: Bash\nCODE:\n```\n$ mkdir src/test/scala/math\n            ----\n\n```\n\n----------------------------------------\n\nTITLE: Defining Timing Helper Methods in Scala\nDESCRIPTION: Provides two utility methods, `currentTime` and `deltaTime`, based on `System.currentTimeMillis()`. These are simple helpers used within the example code to measure and display the duration of operations or the time elapsed since a starting point, aiding in understanding the asynchronous flow.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/futures.md#_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\ndef currentTime = System.currentTimeMillis()\ndef deltaTime(t0: Long) = System.currentTimeMillis() - t0\n```\n\n----------------------------------------\n\nTITLE: Binary Incompatible Direct .unapply Call on @unroll'ed Case Class (Scala 2)\nDESCRIPTION: Provides an example of code that can break binary compatibility in Scala 2 when dealing with `@unroll`ed case classes. Directly calling `.unapply` and using its result (e.g., via `.map`) can fail if fields were added, as the tuple structure returned by `.unapply` changes in Scala 2. Pattern matching is generally safe.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/unroll-default-arguments.md#_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\ndef foo(t: (String, Int)) = println(t)\nUnrolled.unapply(unrolled).map(foo)\n```\n\n----------------------------------------\n\nTITLE: Defining Macros Object for Scala 2 Only\nDESCRIPTION: Implements the 'Macros' object in a Scala 2-specific source directory. The 'location' macro is identical to the earlier version, relying on 'scala-reflect'. This file should only be present in 'src/main/scala-2'. Intended for invocation from user code under Scala 2.13. Requires Scala 2.13, 'scala-reflect', and macro annotations enabled.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-macro-cross-building.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// example/src/main/scala-2/location/Macros.scala\npackage location\n\nimport scala.reflect.macros.blackbox.Context\nimport scala.language.experimental.macros\n\nobject Macros {\n  def location: Location = macro locationImpl\n\n  private def locationImpl(c: Context): c.Tree =  {\n    import c.universe._\n    val location = typeOf[Location]\n    val line = Literal(Constant(c.enclosingPosition.line))\n    val path = Literal(Constant(c.enclosingPosition.source.path))\n    q\"new $location($path, $line)\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Traversable の foreach メソッド定義\nDESCRIPTION: Traversableトレイトで定義される唯一の抽象メソッドである`foreach`のシグネチャを示します。このメソッドは、コレクションの各要素に関数`f`を適用するために使用されますが、戻り値は破棄されます。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/trait-traversable.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef foreach[U](f: Elem => U)\n```\n\n----------------------------------------\n\nTITLE: Listing Compiled Class and Tasty Files After Scala 3 Compilation (Bash)\nDESCRIPTION: This bash snippet demonstrates the listing of files created after compiling a Scala 3 source file with `scalac`. Besides `.class` files, it includes `.tasty` files, which contain typed abstract syntax trees used by the Scala 3 compiler for tooling and enhanced JVM interoperability. These files indicate Scala 3's richer compilation metadata compared to Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/taste-hello-world.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ ls -1\nhello$package$.class\nhello$package.class\nhello$package.tasty\nhello.scala\nhello.class\nhello.tasty\n```\n\n----------------------------------------\n\nTITLE: Matching Qualified 'this' Quasiquotes - Scala\nDESCRIPTION: Shows pattern matching on a qualified `this` expression using quasiquotes. The pattern `q\"$name.this\"` matches `q\"foo.this\"` and successfully extracts the qualifier type name `foo` into the `$name` variable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"$name.this\" = q\"foo.this\"\nname: universe.TypeName = foo\n```\n\n----------------------------------------\n\nTITLE: Running MUnit Tests with Mill - shell\nDESCRIPTION: Invokes all tests in the 'example' module using the Mill build tool. Requires a configured Mill project with MUnit added as a test dependency. The command './mill example.test.test' executes all tests in the module, logs compilation steps, and displays individual test outcomes as well as performance timings in the console.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/testing-run.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n./mill example.test.test\n# [71/71] example.test.test\n# MyTests:\n#   + sum of two integers 0.008s\n```\n\n----------------------------------------\n\nTITLE: Binding Variables in Patterns with Scala Quasiquotes\nDESCRIPTION: Explains creating a binding pattern that associates a named identifier with a pattern portion, allowing capturing matched data under a local name. Includes pattern decomposition where components bound are extracted via quasiquote matching. The wildcard pattern is implied if no explicit pattern is provided. Inputs are patterns to bind; outputs are bindings with a name and the matched subtree.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/pattern-details.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval bindtup = pq\"foo @ (1, 2)\"\nbindtup: universe.Bind = (foo @ scala.Tuple2(1, 2))\n\nval pq\"$name @ $pat\" = bindtup\nname: universe.Name = foo\npat: universe.Tree = scala.Tuple2(1, 2)\n\nval pq\"$name @ $pat\" = pq\"foo\"\nname: universe.Name = foo\npat: universe.Tree = _\n```\n\n----------------------------------------\n\nTITLE: Applying Custom Java Annotation with Named Parameters\nDESCRIPTION: The snippet shows the usage of the previously defined '@Source' annotation on a Java class declaration. It applies the annotation with named parameters 'URL' and 'mail' set to corresponding string values. This is the standard Java syntax for applying annotations with multiple elements, ensuring that users explicitly specify values for each element unless defaults exist. The example illustrates adding metadata for documentation or tooling purposes on the class 'MyClass' that extends 'HisClass'.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pl/tour/annotations.md#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\n@Source(URL = \"https://coders.com/\",\n        mail = \"support@coders.com\")\npublic class MyClass extends HisClass ...\n```\n\n----------------------------------------\n\nTITLE: String Interpolation in JavaScript\nDESCRIPTION: This snippet shows how to perform string interpolation in JavaScript using backticks (`). Variables or expressions embedded within ${} are evaluated and inserted into the string.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\nlet name = 'Joe';\n\n// JavaScript uses backticks\nlet msg = `Hello, ${name}`;\n```\n\n----------------------------------------\n\nTITLE: Example Binary Compatibility Test Failure (Output)\nDESCRIPTION: Illustrates the output from the binary compatibility check (performed by `mima`, the Migration Manager) when a change introduces incompatibilities. It lists the specific problems found (e.g., `MissingMethodProblem`) and suggests a filter configuration to add to `project/MimaFilters.scala` to ignore these specific issues if they are deemed acceptable (e.g., for internal APIs). This is output, not executable code.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/hacker-guide.md#_snippet_8\n\nLANGUAGE: Output\nCODE:\n```\ntest.bc:\n   [echo] Checking backward binary compatibility for scala-library (against 2.11.0)\n   [mima] Found 2 binary incompatibiities\n   [mima] ================================\n   [mima]  * synthetic method\n   [mima]    scala$package$Class$method(java.lang.String)Unit in trait\n   [mima]    scala.package.Class does not have a correspondent in old version\n   [mima]  * synthetic method\n   [mima]    scala$package$AnotherClass$anotherMethod(java.lang.String)Unit in trait\n   [mima]    scala.package.AnotherClass does not have a correspondent in old version\n   [mima] Generated filter config definition\n   [mima] ==================================\n   [mima] \n   [mima]     filter {\n   [mima]         problems=[\n   [mima]             {\n   [mima]                 matchName=\"scala.package.Class$method\"\n   [mima]                 problemName=MissingMethodProblem\n   [mima]             },\n   [mima]             {\n   [mima]                 matchName=\"scala.package.AnotherClass$anotherMethod\"\n   [mima]                 problemName=MissingMethodProblem\n   [mima]             }\n   [mima]         ]\n   [mima]     }\n   [mima] \n\n ...\n Finished: FAILURE\n```\n\n----------------------------------------\n\nTITLE: Upgrading Macro Library Dependency in SBT for Scala Projects - Scala\nDESCRIPTION: Demonstrates how to update a ScalaTest dependency in the build definition for compatibility with Scala 3 by specifying a cross-published version. Requires SBT as the build tool, and expects the project to be using libraryDependencies in build.sbt. Input is the updated dependency line; output is proper version resolution for both Scala 2.13 and Scala 3. Limitations: The referenced version must already be published for your target Scala versions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-prerequisites.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nlibraryDependencies += \"org.scalatest\" %% \"scalatest\" % \"3.2.19\"\n```\n\n----------------------------------------\n\nTITLE: Symbol-Based Reference for Hygiene in Custom Liftable - Scala\nDESCRIPTION: To ensure reference correctness in all contexts (avoiding issues due to missing hygiene in macro expansions), this snippet shows how to use symbols instead of strings or direct references. The companion module symbol is obtained and used to reference the Point companion when creating the lifted tree, ensuring the right companion is found regardless of context. This pattern mitigates reference ambiguities.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/lifting.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval PointSym = symbolOf[Point].companionModule\nimplicit val lift = Liftable[Point] { p =>\n  q\"$PointSym(${p.x}, ${p.y})\"\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Specific Scala Version with Coursier\nDESCRIPTION: Command to force installation of Scala 2 as the default version using Coursier, overriding the default Scala 3 installation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/getting-started/install-scala.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ cs install scala:{{ site.scala-version }} scalac:{{ site.scala-version }}\n```\n\n----------------------------------------\n\nTITLE: Implementing Modular Arithmetic with Spire Using Literal Types in Scala\nDESCRIPTION: Defines a Residue class modeling modular arithmetic with a modulus specified as a type-level Int parameter. The plus operation enforces that operands have the same modulus via type parameterization and uses an implicit ValueOf[M] to access the modulus value at runtime, avoiding storing the modulus in each instance. This design prevents mixing modular numbers with different moduli at compile time. Demonstrates correct usage, addition of residues with the same modulus, and a compile-time error when adding residues with differing moduli.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/42.type.md#_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ncase class Residue[M <: Int](n: Int) extends AnyVal {\n  def +(rhs: Residue[M])(implicit m: ValueOf[M]): Residue[M] =\n    Residue((this.n + rhs.n) % valueOf[M])\n}\n\nval fiveModTen = Residue[10](5)\nval nineModTen = Residue[10](9)\n\nfiveModTen + nineModTen    // OK == Residue[10](4)\n\nval fourModEleven = Residue[11](4)\n\nfiveModTen + fourModEleven\n// compiler error: type mismatch;\n//   found   : Residue[11]\n//   required: Residue[10]\n```\n\n----------------------------------------\n\nTITLE: Deconstructing Annotated Expressions with Scala Quasiquotes\nDESCRIPTION: Shows how to extract the expression and annotation parts from an `Annotated` tree using pattern matching with quasiquotes. This pattern successfully matches trees created solely with annotation syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/expression-details.md#_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\nscala> val q\"$expr: @$annot\" = annotated\nexpr: universe.Tree = 1.$plus(1)\nannot: universe.Tree = positive\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Exact Quoted Boolean Expressions\nDESCRIPTION: Illustrates how to use quoted patterns (`case '{...} =>`) in a match expression to check if an `Expr[Boolean]` exactly matches the structure of `'{ true }` or `'{ false }`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-macros/tutorial/quotes.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ndef valueOfBoolean(x: Expr[Boolean])(using Quotes): Option[Boolean] =\n  x match\n    case '{ true } => Some(true)\n    case '{ false } => Some(false)\n    case _ => None\n```\n\n----------------------------------------\n\nTITLE: Breaking from Loops Using Breaks Utility - Scala\nDESCRIPTION: Uses scala.util.control.Breaks for breaking from for-loops, demonstrated with an import and breakable block. Required: Breaks facility. Useful for situations requiring early termination of iteration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/cheatsheets/index.md#_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.util.control.Breaks._\nbreakable {\n    for (x <- xs) {\n        if (Math.random < 0.1) break\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Kind Polymorphism and Quoting Types in Scala\nDESCRIPTION: This Scala snippet illustrates using type definitions and quoted types with kind polymorphism in the context of metaprogramming. The alias 'type T' is defined, and the expression ''T' demonstrates lifting a type into a quoted context, as is relevant when using staged metaprogramming features in Scala 3. At runtime, such quoting is transformed to a representation like 'the[quoted.Type[T]]', facilitating advanced macro and staging use-cases. Practical usage requires Scala 3's support for quoting and staging features, and considerations around kind polymorphism apply for higher-kinded types.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/minutes/2019-03-13-sip-minutes.md#_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\ntype T\n\n'T\n```\n\n----------------------------------------\n\nTITLE: Structural Method Invocation via applyDynamic (Scala Typing Rule Pseudocode)\nDESCRIPTION: This snippet shows the static rewriting, by the type system, of an invocation of a structural method to an applyDynamic call for types extending Selectable. It captures the logic that calls like v.m(a1, ..., an) are rewritten as v''.applyDynamic[(A1,...An), U](\"m\"), corresponding to the method name and argument types. It is meant solely as a specification for compiler authors and assumes infrastructure for dynamic dispatch and Selectable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/minutes/2019-03-13-sip-minutes.md#_snippet_3\n\nLANGUAGE: scala (typing rules pseudocode)\nCODE:\n```\nG |- v.m(ai...) : U ~> v''.applyDynamic[(A1,...An), U](\"m\")\n```\n\n----------------------------------------\n\nTITLE: Listing SIP Meeting Minutes with Liquid/Jekyll - HTML\nDESCRIPTION: This Liquid code block, used in an HTML template, lists SIP meeting minutes by fetching the 'site.sips' collection, sorting it in reverse chronological order, filtering entries where 'partof' is 'minutes', and creating HTML list items linking to each meeting's minutes by title. It requires Jekyll, the Liquid engine, and a SIP content collection. The expected input is a set of SIP entries with 'title', 'url', and 'partof'; output is a navigable HTML unordered list.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/meeting-results.md#_snippet_1\n\nLANGUAGE: Liquid\nCODE:\n```\n{% assign sips = site.sips | sort: 'date' | reverse %}\n{% for pg in sips %}\n  {% if pg.partof == 'minutes' %}\n    <li><a href=\"{{ site.baseurl }}{{ pg.url }}\">{{ pg.title }}</a></li>\n  {% endif %}\n{% endfor %}\n```\n\n----------------------------------------\n\nTITLE: Motivation: Haskell Do-Notation Example\nDESCRIPTION: Illustrates a common pattern in Haskell's `do` notation where an intermediate result (`a`) is bound and reused within the monadic context. This serves as a comparison point for Scala's `for` comprehension.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_1\n\nLANGUAGE: Haskell\nCODE:\n```\ndo\n  a = largeExpr(arg)\n  b <- doSth(a)\n  combineM(a, b)\n```\n\n----------------------------------------\n\nTITLE: Typechecking Scala ASTs using `ToolBox.typeCheck`\nDESCRIPTION: Shows how to use `ToolBox.typeCheck` to enrich an existing AST with type (`tpe`) and symbol (`symbol`) information. The example first creates a raw tree for `\"test\".length` using `reify { ... }.tree`, then initializes a `ToolBox`, and finally uses `typeCheck` to get a typechecked tree (`ttree`), verifying its type (`Int`) and symbol (`method length`).\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/reflection/symbols-trees-types.md#_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\nscala> import scala.reflect.runtime.universe._\nimport scala.reflect.runtime.universe._\n\nscala> val tree = reify { \"test\".length }.tree\ntree: scala.reflect.runtime.universe.Tree = \"test\".length()\n\nscala> import scala.tools.reflect.ToolBox\nimport scala.tools.reflect.ToolBox\n\nscala> val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()\ntb: scala.tools.reflect.ToolBox[scala.reflect.runtime.universe.type] = ...\n\nscala> val ttree = tb.typeCheck(tree)\nttree: tb.u.Tree = \"test\".length()\n\nscala> ttree.tpe\nres5: tb.u.Type = Int\n\nscala> ttree.symbol\nres6: tb.u.Symbol = method length\n```\n\n----------------------------------------\n\nTITLE: External Redirect Example Using Front Matter\nDESCRIPTION: Shows how to redirect to an external URL using the redirectTo property in the YAML front matter.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/static-site.md#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n---\nredirectTo: https://docs.scala-lang.org/\n---\n```\n\n----------------------------------------\n\nTITLE: Directory Structure with Assets\nDESCRIPTION: Shows how to organize static assets in the _assets directory within the site root structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/static-site.md#_snippet_11\n\nLANGUAGE: plaintext\nCODE:\n```\n├── _assets\n│   └── images\n│        └── myimage.png\n└── _docs\n    └── getting-started.md\n```\n\n----------------------------------------\n\nTITLE: Importing Experimental Fewer Braces in Scala\nDESCRIPTION: This snippet shows how to enable the experimental indentation-based function argument syntax in Scala 3 by importing the 'language.experimental.fewerBraces' module. This import allows writing function arguments without braces using only a colon and indentation, prior to the SIP-44 proposal making it default. No arguments or outputs are involved, but this feature requires Scala 3 and may only be available in certain compiler versions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport language.experimental.fewerBraces\n```\n\n----------------------------------------\n\nTITLE: Non-recommended Function Type Formatting in Scala\nDESCRIPTION: Example of a discouraged way to format multi-line function types in Scala, where the arrow (=>) is placed at the end of a line. This style might create ambiguity with the indentation syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nxs.map: ((x: Int) =>\n  Int)\n```\n\n----------------------------------------\n\nTITLE: Automated patching of migration warnings with sbt\nDESCRIPTION: This snippet demonstrates how to run sbt with the `-rewrite` option after setting `-source:3.0-migration`, allowing automatic rewriting of code to address migration warnings. This automates part of the code modernization process when porting to Scala 3.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/tutorial-sbt.md#_snippet_2\n\nLANGUAGE: sbt\nCODE:\n```\nset example / scalacOptions += \"-rewrite\"\nexample / compile\n```\n\n----------------------------------------\n\nTITLE: Switch Statement in Java\nDESCRIPTION: Shows a Java switch statement mapping day numbers to month names with case and default, using break statements to avoid fall-through. Illustrates classic multiple-branch control.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_48\n\nLANGUAGE: java\nCODE:\n```\nString monthAsString = \"\";\nswitch(day) {\n  case 1: monthAsString = \"January\";\n          break;\n  case 2: monthAsString = \"February\";\n          break;\n  default: monthAsString = \"Other\";\n           break;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Parallel String Collection Without a Combiner (Scala)\nDESCRIPTION: Defines a custom parallel string collection `ParString` by extending `immutable.ParSeq[Char]`. It implements essential methods like `apply`, `length`, and `seq` (returning `WrappedString`). Crucially, it defines a custom `splitter` named `ParStringSplitter` which extends `SeqSplitter[Char]` and implements methods like `hasNext`, `next`, `remaining`, `dup`, `split`, and `psplit` for parallel traversal. Without a custom combiner, transformer methods like `map` or `filter` will default to returning a standard collection like `ParVector`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/overviews/parallel-collections/custom-parallel-collections.md#_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nclass ParString(val str: String)\nextends immutable.ParSeq[Char] {\n\n  def apply(i: Int) = str.charAt(i)\n\n  def length = str.length\n\n  def seq = new collection.immutable.WrappedString(str)\n\n  def splitter = new ParStringSplitter(str, 0, str.length)\n\n  class ParStringSplitter(private var s: String, private var i: Int, private val ntl: Int)\n  extends SeqSplitter[Char] {\n\n    final def hasNext = i < ntl\n\n    final def next = {\n      val r = s.charAt(i)\n      i += 1\n      r\n    }\n\n    def remaining = ntl - i\n\n    def dup = new ParStringSplitter(s, i, ntl)\n\n   def split = {\n      val rem = remaining\n      if (rem >= 2) psplit(rem / 2, rem - rem / 2)\n      else Seq(this)\n    }\n\n    def psplit(sizes: Int*): Seq[ParStringSplitter] = {\n      val splitted = new ArrayBuffer[ParStringSplitter]\n      for (sz <- sizes) {\n        val next = (i + sz) min ntl\n        splitted += new ParStringSplitter(s, i, next)\n        i = next\n      }\n      if (remaining > 0) splitted += new ParStringSplitter(s, i, ntl)\n      splitted\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Patrón de constantes por defecto en Java para HashMap\nDESCRIPTION: Muestra el patrón común en Java de declarar constantes públicas para los valores por defecto, documentándolos en las constantes en lugar de duplicar la información en los comentarios de cada constructor.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/default-parameter-values.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\npublic class HashMap<K,V> {\n  public static final int DEFAULT_CAPACITY = 16;\n  public static final float DEFAULT_LOAD_FACTOR = 0.75;\n\n  public HashMap(Map<? extends K,? extends V> m);\n  /** Create a new HashMap with default capacity (16)\n    * and loadFactor (0.75)\n    */\n  public HashMap();\n  /** Create a new HashMap with default loadFactor (0.75) */\n  public HashMap(int initialCapacity);\n  public HashMap(int initialCapacity, float loadFactor);\n}\n```\n\n----------------------------------------\n\nTITLE: Deconstructing Argument Lists with ...$ Pattern (Scala)\nDESCRIPTION: Demonstrates using the `...$` syntax within a `q` pattern match on a curried function application tree (`q\"f(a, b)(c)\"`) to extract the argument lists as a `List[List[universe.Tree]]` (`argss`). This is the pattern matching counterpart to `...$` construction.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/intro.md#_snippet_20\n\nLANGUAGE: Scala\nCODE:\n```\nscala> val q\"f(...$argss)\" = q\"f(a, b)(c)\"\nargss: List[List[universe.Tree]] = List(List(a, b), List(c))\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Enum (Java)\nDESCRIPTION: This Java snippet shows the standard syntax for defining a simple enumeration with a list of constant members.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_65\n\nLANGUAGE: Java\nCODE:\n```\nenum Color {\n  RED, GREEN, BLUE\n}\n```\n\n----------------------------------------\n\nTITLE: Matching multiple cases with pattern matching in Python 3.10+\nDESCRIPTION: Demonstrates Python 3.10 pattern matching supporting matching multiple literal values in the same case separated by pipe (|) operators. It classifies integer values as 'odd', 'even', or 'too big'. This shows the extensibility of the match statement as a replacement for switch statements. Requires Python 3.10+.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_47\n\nLANGUAGE: python\nCODE:\n```\nmatch i:\n    case 1 | 3 | 5 | 7 | 9:\n        numAsString = \"odd\"\n    case 2 | 4 | 6 | 8 | 10:\n        numAsString = \"even\"\n    case _:\n        numAsString = \"too big\"\n```\n\n----------------------------------------\n\nTITLE: Equivalent Java Hello World Class with main Method\nDESCRIPTION: Provides a Java implementation of the Hello World program equivalent to the Scala example. It defines a public class Hello with a static main method receiving a String array and outputs \"Hello, world\". This snippet serves to highlight similarities and differences in program structure and entry point between Java and Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/hello-world-1.md#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\npublic class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, world\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Immutable Set (Java)\nDESCRIPTION: This Java snippet demonstrates how to create an immutable Set instance using the `Set.of()` factory method. This method creates a small, fixed-size immutable set containing the specified elements.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_56\n\nLANGUAGE: Java\nCODE:\n```\nSet set = Set.of(\"a\", \"b\", \"c\");\n```\n\n----------------------------------------\n\nTITLE: Declaring Mutable Fields in Java\nDESCRIPTION: In Java, a field declared without the `final` keyword is mutable, meaning its value can be reassigned. Modern Java (Java 10+) allows using the `var` keyword for local variable type inference, making it look similar to Scala's `var`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_16\n\nLANGUAGE: Java\nCODE:\n```\nint i = 1;\nvar i = 1;\n```\n\n----------------------------------------\n\nTITLE: Layout and Documentation Directory Structure\nDESCRIPTION: Shows the directory structure for organizing layout templates and documentation files in a Scaladoc project.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/static-site.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n├── _layouts\n│   └── main.html\n└── _docs\n    ├── getting-started.md\n    └── index.html\n```\n\n----------------------------------------\n\nTITLE: Implementación de constructor sobrecargado en Java para HashMap\nDESCRIPTION: Ejemplo de cómo Java implementa valores por defecto a través de sobrecarga de constructores para la clase HashMap. Muestra cuatro constructores diferentes que permiten crear un HashMap con diferentes combinaciones de parámetros.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_es/tour/default-parameter-values.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\npublic class HashMap<K,V> {\n  public HashMap(Map<? extends K,? extends V> m);\n  /** Create a new HashMap with default capacity (16)\n    * and loadFactor (0.75)\n    */\n  public HashMap();\n  /** Create a new HashMap with default loadFactor (0.75) */\n  public HashMap(int initialCapacity);\n  public HashMap(int initialCapacity, float loadFactor);\n}\n```\n\n----------------------------------------\n\nTITLE: Recursive Method without Explicit Return Type in Scala 2 (Compilation Failure)\nDESCRIPTION: Shows that the Scala 2 compiler cannot infer the return type of recursive methods, resulting in a compilation error. Dependencies: none. Input is an integer parameter; output is intended as an Int factorial. This example demonstrates the limitation requiring explicit return types for recursion in Scala 2.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/type-inference.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef fac(n: Int) = if (n == 0) 1 else n * fac(n - 1)\n```\n\n----------------------------------------\n\nTITLE: Basic HTML Structure for a Static Web Page\nDESCRIPTION: A minimal HTML file named 'hello.html' to be served as a static resource. This file includes a basic document structure with a title and a heading element.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/toolkit/web-server-static.md#_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<!doctype html>\n<html>\n    <head>\n        <title>Hello World</title>\n    </head>\n    <body>\n        <h1>Hello world</h1>\n    </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Allowing Inheritance by Default in Java\nDESCRIPTION: By default, a class definition in Java allows other classes to extend it (inherit from it). No specific keyword is needed to make a class extendable.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_8\n\nLANGUAGE: Java\nCODE:\n```\nclass Person\n```\n\n----------------------------------------\n\nTITLE: Performing Git add, commit, and push (Shell)\nDESCRIPTION: Illustrates the standard Git workflow for staging changes in a specific file (`git add`), committing the staged changes with a descriptive message (`git commit`), and pushing the local branch to a remote GitHub fork (`git push`). Includes prompts for credentials and confirmation output from the push operation. Requires Git and a remote repository set up.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/hacker-guide.md#_snippet_12\n\nLANGUAGE: Shell\nCODE:\n```\n19:22 ~/Projects/scala/test (ticket/6725)$ git add ../src/compiler/scala/tools/reflect/MacroImplementations.scala\n19:22 ~/Projects/scala/test (ticket/6725)$ git commit\n[ticket/6725 3c3098693b] SI-6725 `f` interpolator now supports %n tokens\n 1 file changed, 2 insertions(+), 1 deletion(-)\n19:34 ~/Projects/scala/test (ticket/6725)$ git push origin ticket/6725\nUsername for 'https://github.com': xeno-by\nPassword for 'https://xeno-by@github.com':\nCounting objects: 15, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (8/8), done.\nWriting objects: 100% (8/8), 1.00 KiB, done.\nTotal 8 (delta 5), reused 0 (delta 0)\nTo https://github.com/xeno-by/scala\n * [new branch]            ticket/6725 -> ticket/6725\n```\n\n----------------------------------------\n\nTITLE: Running Scala Documentation with Docker Compose\nDESCRIPTION: Commands to build and serve the Scala documentation site using Docker Compose. Environment variables are set to avoid permission issues by matching the container's user with the host user.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nenv UID=\"$(id -u)\" GID=\"$(id -g)\" docker-compose up\n```\n\n----------------------------------------\n\nTITLE: Creating a virtual environment in Python with venv\nDESCRIPTION: This snippet shows the manual process of creating an isolated Python environment using the 'venv' module, including activating the environment and installing dependencies from a requirements file. It highlights the differences between manual setup in Python and automatic dependency management in Scala.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-python-devs.md#_snippet_77\n\nLANGUAGE: Python\nCODE:\n```\ncd myapp\npython3 -m venv myapp-env\nsource myapp-env/bin/activate\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Formal Syntax Change for Initial Aliases (Proposal 1)\nDESCRIPTION: Specifies the proposed change to the Scala grammar (EBNF style) for `Enumerators` to allow zero or more pure alias definitions (`Pattern1 '=' Expr semi`) before the first generator.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/better-fors.md#_snippet_13\n\nLANGUAGE: text\nCODE:\n```\n// Current Syntax\nEnumerators ::= Generator {semi Enumerator | Guard}\n\n// Proposed Syntax\nEnumerators ::= {Pattern1 `=` Expr semi} Generator {semi Enumerator | Guard}\n```\n\n----------------------------------------\n\nTITLE: Adding Element to Sequence - Diff Noise Before Trailing Commas\nDESCRIPTION: Shows the version control `diff` output when adding a new element to the end of a multi-line sequence under the old syntax. It highlights how both the new line and the previously last line must be modified, creating unnecessary \"noise\" in the diff.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/trailing-commas.md#_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\n@@ -4,7 +4,8 @@\n Seq(\n   foo,\n   bar,\n-  baz\n+  baz,\n+  quux\n )\n\n```\n\n----------------------------------------\n\nTITLE: Using a Multiline if Statement in Java\nDESCRIPTION: A multiline `if` statement in Java requires the use of curly braces `{}` to group the statements that are conditionally executed. The condition is enclosed in parentheses `()`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_32\n\nLANGUAGE: Java\nCODE:\n```\nif (x == 1) {\n  System.out.println(\"x is 1, as you can see:\")\n  System.out.println(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Debug Location of Compiler/Library Classes with Partest - Shell\nDESCRIPTION: Adds the partest.debug=true system property when running Partest to display locations from which the Scala compiler and library classes are loaded. Useful for troubleshooting and reporting issues during test execution.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/partest-guide.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nscala -Dpartest.debug=true -cp <path to partest classes> scala.tools.partest.nest.NestRunner <options>\n```\n\n----------------------------------------\n\nTITLE: Setting up Jekyll for Scala Documentation\nDESCRIPTION: Commands to install dependencies and start a local Jekyll server for building and viewing the Scala documentation site. The -I flag enables incremental builds for faster development.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nbundle install\nbundle exec jekyll serve -I\n```\n\n----------------------------------------\n\nTITLE: Filtering ADB Logcat for GraalVM Output\nDESCRIPTION: Displays the Android device's log output in real-time using 'adb logcat' and filters it using 'grep' to show only lines containing the string \"GraalCompiled\". This is helpful for debugging and monitoring applications compiled with GraalVM Native Image running on Android. Requires ADB and a running application that produces relevant log messages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-on-android.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nadb logcat | grep GraalCompiled\n```\n\n----------------------------------------\n\nTITLE: Using Definitions After mdoc:reset in Scala\nDESCRIPTION: Demonstrates the effect of `mdoc:reset`. This Scala snippet can only access definitions made after the last `mdoc:reset` modifier was used. It successfully uses the `Foo` case class defined immediately prior, but would fail if it tried to access the `now` method or the original `Foo` object defined before the reset.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/contribute/add-guides.md#_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc\nval myFoo = Foo(\"hi\") // now we only have access to the last Foo\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Typing Rules for Selectable Method Invocation in Scala (Pseudocode)\nDESCRIPTION: This snippet provides the rule for invoking structural methods on types extending Selectable. It formally describes how the type checker rewrites a call to a method m with arguments ai to ensure correct typing and method presence. The rule asserts the presence of the method in some type refinement, then requires that Selectable be ascribed to the receiver to allow late binding. The notation is technical and is used for compiler implementation specifications, not for end-user programming.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/minutes/2019-03-13-sip-minutes.md#_snippet_2\n\nLANGUAGE: scala (typing rules pseudocode)\nCODE:\n```\nG |- v.m(ai...) : U ~> (v': Q).a   Q =:= C { ... m: (ai: Ai)U ... }  - Member(C, m, _)    G |- v' : Selectable ~> v''\n```\n\n----------------------------------------\n\nTITLE: Reflecting Classes and Invoking Constructors Using ClassMirror in Scala\nDESCRIPTION: This snippet shows how to reflect on a class symbol to create a ClassMirror used for invoking constructors reflectively. It obtains the runtime mirror, extracts the class symbol of a case class, reflects it to a ClassMirror, then obtains and reflects the constructor method to a MethodMirror. Calling this constructor mirror creates new instances dynamically. Inputs are the class symbol and constructor method symbol; output is the instantiated object.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/reflection/environment-universes-mirrors.md#_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nscala> case class C(x: Int)\ndefined class C\n\nscala> val m = ru.runtimeMirror(getClass.getClassLoader)\nm: scala.reflect.runtime.universe.Mirror = JavaMirror ...\n\nscala> val classC = ru.typeOf[C].typeSymbol.asClass\nclassC: scala.reflect.runtime.universe.Symbol = class C\n\nscala> val cm = m.reflectClass(classC)\ncm: scala.reflect.runtime.universe.ClassMirror = class mirror for C (bound to null)\n\nscala> val ctorC = ru.typeOf[C].decl(ru.termNames.CONSTRUCTOR).asMethod\nctorC: scala.reflect.runtime.universe.MethodSymbol = constructor C\n\nscala> val ctorm = cm.reflectConstructor(ctorC)\nctorm: scala.reflect.runtime.universe.MethodMirror = constructor mirror for C.<init>(x: scala.Int): C (bound to null)\n\nscala> ctorm(2)\nres0: Any = C(2)\n```\n\n----------------------------------------\n\nTITLE: Overview of concurrent dictionary tree features and snapshot operations in Scala\nDESCRIPTION: This section describes the capabilities of concurrent trie maps, including support for linearization, lock-free operations, and timed snapshots. It details how snapshots create partial, read-only views of the data structure at a specific time, using lazy updates and resource-efficient copying. It also covers size calculation optimizations and iteration based on snapshots, emphasizing thread-safe, efficient concurrency management.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/parallel-collections/ctries.md#_snippet_4\n\n\n\n----------------------------------------\n\nTITLE: Alternative Syntax for Lambda Parameters Without Colons\nDESCRIPTION: A considered (but rejected) alternative syntax that would allow lambda parameters without preceding colons. This was rejected because it looks too similar to a function call.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/fewer-braces.md#_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nxs.foldLeft(z)(a, b) =>\n  a + b\n```\n\n----------------------------------------\n\nTITLE: Listing Resolved Dependencies in Gradle via Shell\nDESCRIPTION: This shell command runs 'gradle dependencies --configuration runtimeClasspath' to analyze and output the full dependency tree and resolved versions for the project's runtime classpath. This helps inspect transitive updates, deduplication, and dependency conflicts. It requires a valid build.gradle file and Gradle environment; outputs are plain-text dependency trees. No direct input parameters are needed.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/drop-stdlib-forwards-bin-compat.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\n$> gradle dependencies --configuration runtimeClasspath\n\n> Task :dependencies\n\n------------------------------------------------------------\nRoot project 'proj'\n------------------------------------------------------------\n\nruntimeClasspath - Runtime classpath of source set 'main'.\n+--- org.scala-lang:scala-library:2.13.8 -> 2.13.10\n+--- com.softwaremill.sttp.client3:core_2.13:3.8.3\n|    +--- org.scala-lang:scala-library:2.13.10\n|    +--- com.softwaremill.sttp.model:core_2.13:1.5.2\n|    |    \\--- org.scala-lang:scala-library:2.13.8 -> 2.13.10\n|    +--- com.softwaremill.sttp.shared:core_2.13:1.3.10\n|    |    \\--- org.scala-lang:scala-library:2.13.9 -> 2.13.10\n|    \\--- com.softwaremill.sttp.shared:ws_2.13:1.3.10\n|         +--- org.scala-lang:scala-library:2.13.9 -> 2.13.10\n|         +--- com.softwaremill.sttp.shared:core_2.13:1.3.10 (*)\n|         \\--- com.softwaremill.sttp.model:core_2.13:1.5.2 (*)\n\\--- com.softwaremill.sttp.shared:ws_2.13:1.2.7 -> 1.3.10 (*)\n\n(*) - dependencies omitted (listed previously)\n```\n\n----------------------------------------\n\nTITLE: Simple Interface with Abstract Method in Java\nDESCRIPTION: Declares a Java interface Adder with a single abstract method add accepting two integers and returning an integer. This interface defines a contract for adding operations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_18\n\nLANGUAGE: Java\nCODE:\n```\npublic interface Adder {\n  public int add(int a, int b);\n}\n```\n\n----------------------------------------\n\nTITLE: Showing Raw q Tree Structure (Scala)\nDESCRIPTION: Uses `showRaw` to display the internal representation of the `universe.Tree` generated by the `q` interpolator for simple syntax. This requires access to the reflection universe and helps understand the tree's structure.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/quasiquotes/intro.md#_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nscala> println(showRaw(q\"List[Int]\"))\nTypeApply(Ident(TermName(\"List\")), List(Ident(TypeName(\"Int\"))))\n```\n\n----------------------------------------\n\nTITLE: Output of `migrateTypes` sbt Command\nDESCRIPTION: Illustrates the console output from the `migrateTypes main` command in sbt. This step compiles the code with Scala 2, then uses that information to identify and apply necessary type ascriptions for Scala 3 compatibility, recompiles with Scala 3 migration flags, and suggests setting the final Scala 3 version.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-migration/scala3-migrate.md#_snippet_14\n\nLANGUAGE: text\nCODE:\n```\nsbt:main> migrateTypes main\n[info] compiling 8 Scala sources to /home/piquerez/github/scalacenter/scala3-migration-example/target/scala-2.13/classes ...\n[warn] 1 deprecation; re-run with -deprecation for details\n[warn] one warning found\n[info] compiling 8 Scala sources to /home/piquerez/github/scalacenter/scala3-migration-example/target/scala-2.13/test-classes ...\n[warn] 2 deprecations; re-run with -deprecation for details\n[warn] one warning found\n[success] Total time: 7 s, completed Aug 31, 2023 11:26:25 AM\n[info] Defining scalaVersion\n[info] The new value will be used by Compile / bspBuildTarget, Compile / dependencyTreeCrossProjectId and 68 others.\n[info]  Run `last` for details.\n[info] Reapplying settings...\n[info] set current project to main (in build file:/home/piquerez/github/scalacenter/scala3-migration-example/)\n[info] \n[info] Migrating types in main / Compile\n[info] \n[info] Found 3 patches in 1 Scala source\n[info] Starting migration of src/main/scala/example/TypeIncompat.scala\n[info] 3 remaining candidates\n[info] 1 remaining candidate\n[info] Found 1 required patch in src/main/scala/example/TypeIncompat.scala\n[info] Compiling to Scala 3 with -source:3.0-migration -rewrite\n[info] compiling 1 Scala source to /home/piquerez/github/scalacenter/scala3-migration-example/target/scala-3.3.1/classes ...\n[info] \n[info] Migrating types in main / Test\n[info] \n[info] Found 4 patches in 1 Scala source\n[info] Starting migration of src/test/scala/example/TypeIncompatTests.scala.scala\n[info] 4 remaining candidates\n[info] 3 remaining candidates\n[info] 2 remaining candidates\n[info] Found 1 required patch in src/test/scala/example/TypeIncompatTests.scala.scala\n[info] Compiling to Scala 3 with -source:3.0-migration -rewrite\n[info] \n[info] You can safely upgrade main to Scala 3:\n[info] <span style=\"color:orange\">scalaVersion := \"3.3.1\"</span>\n[success] Total time: 18 s, completed Aug 31, 2023 11:26:45 AM\n[info] Defining scalaVersion\n[info] The new value will be used by Compile / bspBuildTarget, Compile / dependencyTreeCrossProjectId and 68 others.\n[info]  Run `last` for details.\n[info] Reapplying settings...\n[info] set current project to main (in build file:/home/piquerez/github/scalacenter/scala3-migration-example/)\nsbt:main>\n```\n\n----------------------------------------\n\nTITLE: Structural Member Access via selectDynamic (Scala Typing Rule Pseudocode)\nDESCRIPTION: This snippet illustrates the rewriting rule for structural member access using selectDynamic, as applied by Scala's type checker when Selectable is involved. The rule shows that a field access v.a can be rewritten to v''.selectDynamic[U](\"a\"), bridging static type checking and runtime method dispatch. These are specification rules, not runtime code; they assume the presence of Selectable and proper method signatures matching dynamic member names.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/minutes/2019-03-13-sip-minutes.md#_snippet_1\n\nLANGUAGE: scala (typing rules pseudocode)\nCODE:\n```\nG |- v.a : U ~> v''.selectDynamic[U](\"a\")\n```\n\n----------------------------------------\n\nTITLE: Analysis of Trailing Commas in Scala Syntax\nDESCRIPTION: This snippet covers the addition of trailing comma syntax for multi-line parameter lists, arguments, and possibly other constructs for consistency. It discusses implementation variants, potential confusion, and compiler error handling. Dependencies include parser and scanner modifications to support optional trailing commas.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/minutes/2016-11-29-sip-minutes.md#_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nN/A\n```\n\n----------------------------------------\n\nTITLE: Mixed-Style Annotation Usage in Java\nDESCRIPTION: Example showing how Java syntax requires consistent style when specifying both the primary 'value' parameter and additional parameters in an annotation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/annotations.md#_snippet_8\n\nLANGUAGE: java\nCODE:\n```\n@SourceURL(value = \"https://coders.com/\",\n           mail = \"support@coders.com\")\npublic class MyClass extends HisClass ...\n```\n\n----------------------------------------\n\nTITLE: Analysis of Static Members Proposal (SIP-NN)\nDESCRIPTION: This snippet addresses generating static fields and methods within Scala, considering use cases like Java interop and initialization order. It debates whether annotations should control static code generation and how static members affect bytecode and binary compatibility. Dependencies include compiler code generation mechanisms and platform-specific behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/minutes/2016-11-29-sip-minutes.md#_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nN/A\n```\n\n----------------------------------------\n\nTITLE: Sample Output for Nested Factorial Computation in Scala 2 and 3 - Output\nDESCRIPTION: This snippet displays the console output generated by running the factorial function examples provided for both Scala 2 and Scala 3. It shows that factorial(2) yields 2 and factorial(3) yields 6, confirming correct implementation. No dependencies or inputs are required; the snippet simply shows expected results for demonstration purposes.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_tour/nested-functions.md#_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\nFactorial of 2: 2\nFactorial of 3: 6\n```\n\n----------------------------------------\n\nTITLE: Swift Fibonacci Iterator Implementation Using Tuple Assignment\nDESCRIPTION: An example demonstrating concise multiple assignment via tuple unpacking to update multiple variables simultaneously, improving code clarity and correctness.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/sips/multiple-assignments.md#_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\nstruct FibonacciIterator: IteratorProtocol {\n\n  private var a: Int = 0\n  private var b: Int = 1\n  init() {}\n\n  mutating func next() -> Int? {\n    defer { (a, b) = (b, a + b) }\n    return a\n  }\n\n}\n```\n\n----------------------------------------\n\nTITLE: While Loop in Java\nDESCRIPTION: Demonstrates a standard Java while loop printing variable i while less than 3 and incrementing i each iteration. Illustrates imperative looping syntax.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_37\n\nLANGUAGE: java\nCODE:\n```\nwhile (i < 3) {\n  System.out.println(i);\n  i++;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Minimal Value Function Using if-else in Python\nDESCRIPTION: Shows a Python function 'min' that returns the smaller of two parameters 'a' and 'b' using a one-line inline conditional expression. Illustrates functional definition with conditional return value.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\ndef min(a, b):\n  return a if a < b else b\n```\n\n----------------------------------------\n\nTITLE: Generalizing filter and map Operations in IterableOps in Scala 2\nDESCRIPTION: Within IterableOps in Scala 2, this snippet adds generalized filter and map operations that leverage the trait's type parameters. The filter method returns C (the concrete collection type), while map returns CC[B] (the constructor applied to the new element type). This enables consistent, reusable definitions for a wide variety of collections, a pillar of the collections' architectural redesign.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/core/architecture-of-scala-213-collections.md#_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\ntrait IterableOps[+A, +CC[_], +C] {\n  def filter(p: A => Boolean): C = …\n  def map[B](f: A => B): CC[B] = …\n}\n```\n\n----------------------------------------\n\nTITLE: XML Plugin Descriptor for Scala Compiler Plugin\nDESCRIPTION: This XML snippet defines the plugin metadata, including the plugin's name and the class name of its main implementation. It is included in a file named 'scalac-plugin.xml' and packaged with the plugin's compiled classes to enable Scala to recognize and load the plugin during compilation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/plugins/index.md#_snippet_1\n\nLANGUAGE: XML\nCODE:\n```\n<plugin>\n  <name>divbyzero</name>\n  <classname>localhost.DivByZero</classname>\n</plugin>\n```\n\n----------------------------------------\n\nTITLE: Example Blog Post Metadata using YAML Frontmatter\nDESCRIPTION: Demonstrates the use of YAML frontmatter in blog Markdown files for specifying metadata such as layout, author, title, subtitle, date, and author image. This frontmatter allows Scaladoc to include additional information on blog pages and customize their appearance and behavior.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/blog.md#_snippet_1\n\nLANGUAGE: YAML\nCODE:\n```\n---\nlayout: <Ссылка на макет страницы для страницы блога>\nauthor: <Автор страницы>\ntitle: <Заголовок страницы>\nsubTitle: <Подзаголовок страницы>\ndate: <Дата создания страницы>, например, 2016-12-05\nauthorImg: <Ссылка на картинку автора>\n---\n<Содержимое страницы>\n```\n\n----------------------------------------\n\nTITLE: コンソールでの`-deprecation`と`-Xmigration`フラグを用いた警告例\nDESCRIPTION: Scala REPLに`-deprecation`と`-Xmigration`のフラグを渡して対象のコード実行時に警告を受ける方法。`List.unzip`や`Map.keys`の警告例を示し、API変更を理解するための具体的な使い方を説明している。\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ja/overviews/collections/migrating-from-scala-27.md#_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n>scala -deprecation -Xmigration\nWelcome to Scala version 2.8.0.final\nType in expressions to have them evaluated.\nType :help for more information.\nscala> val xs = List((1, 2), (3, 4))\nxs: List[(Int, Int)] = List((1,2), (3,4))\nscala> List.unzip(xs)\n<console>:7: warning: method unzip in object List is deprecated: use xs.unzip instead of List.unzip(xs)\n       List.unzip(xs)\n            ^\nres0: (List[Int], List[Int]) = (List(1, 3),List(2, 4))\nscala> xs.unzip\nres1: (List[Int], List[Int]) = (List(1, 3),List(2, 4))\nscala> val m = xs.toMap\nm: scala.collection.immutable.Map[Int,Int] = Map((1,2), (3,4))\nscala> m.keys\n<console>:8: warning: method keys in trait MapLike has changed semantics:\nAs of 2.8, keys returns Iterable[A] rather than Iterator[A].\n       m.keys\n         ^\nres2: Iterable[Int] = Set(1, 3)\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Directory Structure Mapping in YAML Configuration\nDESCRIPTION: This YAML configuration demonstrates how to map pages from different source directories to a single custom output directory. It defines a subsection with an index page and child pages, all of which will be rendered in 'custom-directory' regardless of their original locations.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-scaladoc/static-site.md#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\n- title: Some other subsection\n  index: abc/index.html\n  directory: custom-directory\n  subsection:\n    - page: abc2/page1.md\n    - page: foo/page2.md\n```\n\n----------------------------------------\n\nTITLE: Sidebar Configuration in YAML Format\nDESCRIPTION: Example of a sidebar.yml file that defines the navigation structure for the static site, including nested sections and pages.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_ru/scala3/guides/scaladoc/static-site.md#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\nindex: index.html\nsubsection:\n    - title: Usage\n      index: usage/index.html\n      directory: usage\n      subsection:\n        - title: Dottydoc\n          page: usage/dottydoc.html\n          hidden: false\n        - title: sbt-projects\n          page: usage/sbt-projects.html\n          hidden: false\n```\n\n----------------------------------------\n\nTITLE: Creating Test Directory for ScalaTest Files\nDESCRIPTION: Shell command to create a package directory under src/test/scala for the ScalaTest test files.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala-book/sbt-scalatest-tdd.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n$ mkdir src/test/scala/simpletest\n```\n\n----------------------------------------\n\nTITLE: Declaring Mutable Variables in JavaScript\nDESCRIPTION: This snippet shows the preferred (let) and older (var) keywords used to declare mutable variables in JavaScript. Mutable variables can have their values reassigned.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-javascript-devs.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nlet   // now preferred for mutable\nvar   // old mutable style\n```\n\n----------------------------------------\n\nTITLE: Sample Output of the Scala Expression Evaluator/Differentiator\nDESCRIPTION: Shows the console output produced by running the main function that evaluates and differentiates the example expression tree.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/tutorials/scala-for-java-programmers.md#_snippet_18\n\nLANGUAGE: text\nCODE:\n```\nExpression: Sum(Sum(Var(x),Var(x)),Sum(Const(7),Var(y)))\nEvaluation with x=5, y=7: 24\nDerivative relative to x:\n Sum(Sum(Const(1),Const(1)),Sum(Const(0),Const(0)))\nDerivative relative to y:\n Sum(Sum(Const(0),Const(0)),Sum(Const(0),Const(1)))\n```\n\n----------------------------------------\n\nTITLE: Listing SIP Meeting Results with Liquid/Jekyll - HTML\nDESCRIPTION: This Liquid snippet within an HTML page retrieves all SIP meeting entries from the 'site.sips' collection, sorts them by date in descending order, filters them where 'partof' equals 'results', and renders each as a list item linking to the meeting's detail page. Dependencies include Jekyll's build system, the Liquid template engine, and a properly structured SIP collection provided via site configuration. The snippet expects each SIP entry to have 'date', 'url', and 'partof' properties and outputs formatted HTML list items for navigation.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/meeting-results.md#_snippet_0\n\nLANGUAGE: Liquid\nCODE:\n```\n{% assign sips = site.sips | sort: 'date' | reverse %}\n{% for page in sips %}\n  {% if page.partof == 'results' %}\n    <li><a href=\"{{ site.baseurl }}{{ page.url }}\">{{ page.date  | date_to_long_string }}</a></li>\n  {% endif %}\n{% endfor %}\n```\n\n----------------------------------------\n\nTITLE: Listing Newly Created sbt Directory Structure - Bash Output\nDESCRIPTION: After creating the sbt project directory, this snippet shows the output of 'find .' command listing all directories present. It confirms correct creation of the 'project', 'src/main/scala', 'src/test/scala', and 'target' directories, which sbt expects for proper organization.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/tools-sbt.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ find .\n.\n./project\n./src\n./src/main\n./src/main/scala\n./src/test\n./src/test/scala\n./target\n```\n\n----------------------------------------\n\nTITLE: Building and Running Native Desktop App (Maven/GluonFX)\nDESCRIPTION: Builds a native executable image of the application specifically for the desktop platform using the GluonFX Maven plugin and then immediately runs it. This step allows testing the native build process and application functionality on the desktop before targeting Android. Requires Maven, GluonFX plugin, and GraalVM native-image tool setup.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-on-android.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nmvn gluonfx:build gluonfx:nativerun\n```\n\n----------------------------------------\n\nTITLE: Required C Development Libraries for Native Image Build (Linux Example)\nDESCRIPTION: Lists essential C development libraries (with package names typical for Debian/Ubuntu distributions) required for building a GraalVM native image of a JavaFX application. These libraries provide necessary headers and linkable components for native UI (GTK), audio (ALSA), video (libav), fonts (freetype), and other system interactions.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/tutorials/scala-on-android.md#_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\n  libasound2-dev (for pkgConfig alsa)\n  libavcodec-dev (for pkgConfig libavcodec)\n  libavformat-dev (for pkgConfig libavformat)\n  libavutil-dev (for pkgConfig libavutil)\n  libfreetype6-dev (for pkgConfig freetype2)\n  libgl-dev (for pkgConfig gl)\n  libglib2.0-dev (for pkgConfig gmodule-no-export-2.0)\n  libglib2.0-dev (for pkgConfig gthread-2.0)\n  libgtk-3-dev (for pkgConfig gtk+-x11-3.0)\n  libpango1.0-dev (for pkgConfig pangoft2)\n  libx11-dev (for pkgConfig x11)\n  libxtst-dev (for pkgConfig xtst)\n```\n\n----------------------------------------\n\nTITLE: Declaring Open/Inheritable Class in Java\nDESCRIPTION: Defines a normal Java class Person that can be subclassed since it is not marked final. This default openness enables classic inheritance used widely in Java OOP design.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_6\n\nLANGUAGE: Java\nCODE:\n```\nclass Person\n```\n\n----------------------------------------\n\nTITLE: Defining a One-Line Method in Java\nDESCRIPTION: In Java, even for a simple one-line method body, curly braces `{}` are typically used to enclose the method's statements. The return type is specified before the method name.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_10\n\nLANGUAGE: Java\nCODE:\n```\npublic int add(int a, int b) {\n  return a + b;\n}\n```\n\n----------------------------------------\n\nTITLE: Initialize Google Analytics Tracking - JavaScript\nDESCRIPTION: Sets up the Google Analytics tracking code by initializing the _gaq array, pushing the account ID and page view data, and dynamically creating and inserting the Google Analytics script tag into the document. This script is required for website traffic analysis.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_includes/contributing-header.txt#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nvar _gaq = _gaq || [];\n\t  _gaq.push(['_setAccount', 'UA-574683-5']);\n\t  _gaq.push(['_trackPageview']);\n\n\t  (function() {\n\t    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;\n\t    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '/ga.js';\n\t    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);\n\t  })();\n```\n\n----------------------------------------\n\nTITLE: Defining Default Values as Constants in Java HashMap\nDESCRIPTION: This snippet extends the previous Java example by introducing public static final constants DEFAULT_CAPACITY and DEFAULT_LOAD_FACTOR to represent default values for initial capacity and load factor. This approach avoids duplicating the literals in constructor implementations and Javadoc but still requires overloaded constructors. It improves maintainability by centralizing default values as constants, but is less expressive than Scala's default parameters. Inputs and outputs remain the same as the prior snippet.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_pt-br/tour/default-parameter-values.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\npublic class HashMap<K,V> {\n  public static final int DEFAULT_CAPACITY = 16;\n  public static final float DEFAULT_LOAD_FACTOR = 0.75;\n\n  public HashMap(Map<? extends K,? extends V> m);\n  /** Cria um novo HashMap com capacidade padrão (16)\n    * e fator de carga padrão (0.75)\n    */\n  public HashMap();\n  /** Cria um novo HashMap com um fator de carga padrão (0.75) */\n  public HashMap(int initialCapacity);\n  public HashMap(int initialCapacity, float loadFactor);\n}\n```\n\n----------------------------------------\n\nTITLE: SIP Meeting Results YAML Frontmatter in Markdown\nDESCRIPTION: YAML frontmatter defining the layout, title, and details of the SIP meeting results. It specifies that SIP-47 about clause interleaving was accepted.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_sips/results/2024-06-21-meeting.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nlayout: sip-meeting-results\ntitle: SIP Meeting Results - 21st June 2024\npartof: results\nproposals:\n  - url: https://github.com/scala/improvement-proposals/pull/47\n    name: SIP-47 - Clause interleaving\n    result: accepted\n---\n```\n\n----------------------------------------\n\nTITLE: Nested for Loops with Ranged Iterators in Python\nDESCRIPTION: Demonstrates nested for loops iterating over multiple ranges: 'i' from 1 to 2, 'j' from 4 to 5, and 'k' from 1 to 9 with step 3. Prints formatted strings combining all iterator values. Useful for multidimensional iteration.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_21\n\nLANGUAGE: Python\nCODE:\n```\nfor i in range(1,3):\n  for j in range(4,6):\n    for k in range(1,10,3):\n      print(f\"i = {i}, j = {j}, k = {k}\")\n```\n\n----------------------------------------\n\nTITLE: Declaring Checked Exception in Method (Java)\nDESCRIPTION: This Java snippet demonstrates the standard way to declare that a method might throw a checked exception using the `throws` keyword in the method signature. Callers of this method are required to either handle or re-declare the exception.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-java-devs.md#_snippet_71\n\nLANGUAGE: Java\nCODE:\n```\npublic int makeInt(String s)\nthrows NumberFormatException {\n  // code here to convert a String to an int\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple Interfaces and Extending a Class in Java\nDESCRIPTION: In Java, a class extends a single class using the `extends` keyword and implements one or more interfaces using the `implements` keyword. The `extends` clause must come before `implements`.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_overviews/scala3-book/scala-for-java-devs.md#_snippet_24\n\nLANGUAGE: Java\nCODE:\n```\nclass Dog extends Animal implements HasLegs, HasTail\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Python Virtual Environments via Shell\nDESCRIPTION: This shell snippet demonstrates how to create and activate a Python virtual environment using the 'venv' module and install dependencies from a requirements file. It shows the manual process required in Python to isolate project dependencies within a specific environment, including environment activation and package installation. This is presented as a contrast to Scala's automatic dependency management with sbt.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/_zh-cn/overviews/scala3-book/scala-for-python-devs.md#_snippet_45\n\nLANGUAGE: Shell\nCODE:\n```\ncd myapp\npython3 -m venv myapp-env\nsource myapp-env/bin/activate\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Rendering Tutorial Cards with Templating in HTML\nDESCRIPTION: This snippet iterates over a collection of tutorial objects using a Jinja-like templating syntax (e.g., Liquid for Jekyll) to dynamically generate white-card components for each tutorial. Each card displays an icon, title, description, author (if available), and a link that points to the tutorial's full page. Required dependencies include a compatible templating engine, the pre-defined 'page.tutorials' array, and Font Awesome for icon rendering. Expected input is a structured array of tutorial objects, and outputs are HTML elements for the tutorial cards. Limitations: Requires correct data structure and proper CSS classes to achieve the intended layout.\nSOURCE: https://github.com/scala/docs.scala-lang/blob/main/tutorials.md#_snippet_0\n\nLANGUAGE: HTML\nCODE:\n```\n{% for tutorial in page.tutorials %}\n<div class=\"white-card\">\n  <div class=\"card-wrap\">\n    <div class=\"card-header\">\n      {% if tutorial.icon %}\n      <div class=\"card-avatar\">\n        <div class=\"icon\"><i class=\"fa fa-{{ tutorial.icon }}\" aria-hidden=\"true\"></i></div>\n      </div>\n      {% endif %}\n      <a href=\"{{ tutorial.url }}\"><h3>{{ tutorial.title }}</h3></a>\n    </div>\n    <div class=\"card-content\">\n      {% if tutorial.by %}<div class=\"by\">By {{ tutorial.by }}</div>{% endif %}\n      {% if tutorial.description %}<p>{{ tutorial.description }}</p>{% endif %}\n    </div>\n  </div>\n  <div class=\"card-footer\">\n    <a class=\"go-btn\" href=\"{{ tutorial.url }}\"><i class=\"fa fa-arrow-right\" aria-hidden=\"true\"></i> Read</a>\n  </div>\n</div>\n{% endfor %}\n```"
  }
]