[
  {
    "owner": "unetworking",
    "repo": "uwebsockets",
    "content": "TITLE: Initializing SSL WebSocket Server with URL Routing in C++\nDESCRIPTION: Demonstrates setting up a secure WebSocket server with SSL configuration, URL routing for HTTP requests, and WebSocket event handling. Shows implementation of GET routes with parameters and WebSocket subscription handling.\nSOURCE: https://github.com/unetworking/uwebsockets/blob/master/README.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n/* One app per thread; spawn as many as you have CPU-cores and let uWS share the listening port */\nuWS::SSLApp({\n\n    /* These are the most common options, fullchain and key. See uSockets for more options. */\n    .cert_file_name = \"cert.pem\",\n    .key_file_name = \"key.pem\"\n    \n}).get(\"/hello/:name\", [](auto *res, auto *req) {\n\n    /* You can efficiently stream huge files too */\n    res->writeStatus(\"200 OK\")\n       ->writeHeader(\"Content-Type\", \"text/html; charset=utf-8\")\n       ->write(\"<h1>Hello \")\n       ->write(req->getParameter(\"name\"))\n       ->end(\"!</h1>\");\n    \n}).ws<UserData>(\"/*\", {\n\n    /* Just a few of the available handlers */\n    .open = [](auto *ws) {\n        ws->subscribe(\"oh_interesting_subject\");\n    },\n    .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {\n        ws->send(message, opCode);\n    }\n    \n}).listen(9001, [](auto *listenSocket) {\n\n    if (listenSocket) {\n        std::cout << \"Listening on port \" << 9001 << std::endl;\n    } else {\n        std::cout << \"Failed to load certs or to bind to port\" << std::endl;\n    }\n    \n}).run();\n```\n\n----------------------------------------\n\nTITLE: Configuring WebSocket Route Handlers in C++\nDESCRIPTION: Example showing complete WebSocket route setup including connection handling, message processing, and various event callbacks. Demonstrates proper configuration of WebSocket settings and handler implementation.\nSOURCE: https://github.com/unetworking/uwebsockets/blob/master/misc/READMORE.md#2025-04-22_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\nuWS::App().ws<PerSocketData>(\"/*\", {\n    /* Settings */\n    .compression = uWS::SHARED_COMPRESSOR,\n    .maxPayloadLength = 16 * 1024,\n    .idleTimeout = 10,\n    /* Handlers */\n    .upgrade = [](auto *res, auto *req, auto *context) {\n        /* You may read from req only here, and COPY whatever you need into your PerSocketData.\n         * See UpgradeSync and UpgradeAsync examples. */\n    },\n    .open = [](auto *ws) {\n\n    },\n    .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {\n        ws->send(message, opCode);\n    },\n    .drain = [](auto *ws) {\n        /* Check getBufferedAmount here */\n    },\n    .ping = [](auto *ws, std::string_view message) {\n\n    },\n    .pong = [](auto *ws, std::string_view message) {\n\n    },\n    .close = [](auto *ws, int code, std::string_view message) {\n\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic uWebSockets HTTP Server in C++\nDESCRIPTION: Creates a simple HTTP server using uWebSockets that listens on port 9001 and responds with 'Hello World!' to all requests. The example demonstrates basic route handling, server initialization, and graceful fallthrough behavior.\nSOURCE: https://github.com/unetworking/uwebsockets/blob/master/misc/READMORE.md#2025-04-22_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\nint main() {\n    uWS::App().get(\"/*\", [](auto *res, auto *req) {\n        res->end(\"Hello World!\");\n    }).listen(9001, [](auto *listenSocket) {\n        if (listenSocket) {\n            std::cout << \"Listening for connections...\" << std::endl;\n        }\n    }).run();\n\n    std::cout << \"Shoot! We failed to listen and the App fell through, exiting now!\" << std::endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling HTTP GET Request in C++ with µWebSockets\nDESCRIPTION: Demonstrates how to set up a simple HTTP GET route handler using µWebSockets. The example shows how to respond to a request at the '/hello' endpoint with a 'Hello World!' message.\nSOURCE: https://github.com/unetworking/uwebsockets/blob/master/misc/READMORE.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nuWS::App().get(\"/hello\", [](auto *res, auto *req) {\n    res->end(\"Hello World!\");\n});\n```\n\n----------------------------------------\n\nTITLE: Creating uWebSockets Cluster in C++\nDESCRIPTION: This snippet shows how to create a uWebSockets cluster in C++ using POSIX fork(). It creates child processes for each CPU core and initializes a uWS server in each process.\nSOURCE: https://github.com/unetworking/uwebsockets/blob/master/cluster/README.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <libusockets.h>\n#include <unistd.h>\n#include <thread>\n\n/* Create as many child processes as there are cores */\nfor (int i = 0; i < std::thread::hardware_concurrency(); i++) {\n    if (!fork()) {\n        /* Child process */\n        uWS::App().ws<int>(\"/*\", {\n            .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {\n                /* Echo the message back */\n                ws->send(message, opCode);\n            }\n        }).listen(9001, [](auto *listen_socket) {\n            if (listen_socket) {\n                std::cout << \"Listening to port 9001\" << std::endl;\n            }\n        }).run();\n        return 0;\n    }\n}\n\n/* Parent process */\nwhile (true) {\n    sleep(1);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Corked HTTP Response in C++\nDESCRIPTION: Demonstrates how to properly cork HTTP responses for efficient data sending. Corking ensures multiple send operations are bundled into a single syscall for better performance.\nSOURCE: https://github.com/unetworking/uwebsockets/blob/master/misc/READMORE.md#2025-04-22_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nres->cork([res]() {\n    res->end(\"This Http response will be properly corked and efficient in all cases\");\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Up WebSocket Server Listener in C++\nDESCRIPTION: Shows how to initialize and start a WebSocket server by listening on a specified port. Includes callback for handling the listen socket status.\nSOURCE: https://github.com/unetworking/uwebsockets/blob/master/misc/READMORE.md#2025-04-22_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\nApp.listen(port, [](auto *listenSocket) {\n    /* listenSocket is either nullptr or us_listen_socket */\n});\n```\n\n----------------------------------------\n\nTITLE: Creating uWebSockets.js Cluster in JavaScript\nDESCRIPTION: This snippet demonstrates how to set up a uWebSockets.js cluster using Node.js cluster module. It creates worker processes for each CPU core and initializes a uWS server in each worker.\nSOURCE: https://github.com/unetworking/uwebsockets/blob/master/cluster/README.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst uWS = require('uWebSockets.js');\nconst { Worker, isMainThread, parentPort } = require('worker_threads');\nconst os = require('os');\n\nif (isMainThread) {\n  for (let i = 0; i < os.cpus().length; i++) {\n    new Worker(__filename);\n  }\n} else {\n  const app = uWS.App().ws('/*', {\n    message: (ws, message, isBinary) => {\n      /* Echo the message back */\n      ws.send(message, isBinary);\n    }\n  }).listen(9001, (listenSocket) => {\n    if (listenSocket) {\n      console.log('Listening to port 9001');\n    }\n  });\n}\n```"
  }
]