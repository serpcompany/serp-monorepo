[
  {
    "owner": "dry-rb",
    "repo": "dry-monads",
    "content": "TITLE: Using Result Monad with Do Notation in Ruby\nDESCRIPTION: Example of using the Result monad with do notation in a ResultCalculator class, showcasing error handling and chaining of operations.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/getting-started.html.md#2025-04-12_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads'\n\nclass ResultCalculator\n  include Dry::Monads[:result, :do]\n\n  def calculate(input)\n    value = Integer(input)\n\n    value = yield add_3(value)\n    value = yield mult_2(value)\n\n    Success(value)\n  end\n\n  def add_3(value)\n    if value > 1\n      Success(value + 3)\n    else\n      Failure(\"value was less than 1\")\n    end\n  end\n\n  def mult_2(value)\n    if value % 2 == 0\n      Success(value * 2)\n    else\n      Failure(\"value was not even\")\n    end\n  end\nend\n\n\nc = ResultCalculator.new\nc.calculate(3) # => Success(12)\nc.calculate(0) # => Failure(\"value was less than 1\")\nc.calculate(2) # => Failure(\"value was not even\")\n```\n\n----------------------------------------\n\nTITLE: Result Monad Implementation\nDESCRIPTION: Example showing Result monad implementation with Success and Failure cases for better error handling.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/index.html.md#2025-04-12_snippet_7\n\nLANGUAGE: ruby\nCODE:\n```\ndef find_user(user_id)\n  user = User.find_by(id: user_id)\n\n  if user\n    Success(user)\n  else\n    Failure(:user_not_found)\n  end\nend\n\ndef find_address(address_id)\n  address = Address.find_by(id: address_id)\n\n  if address\n    Success(address)\n  else\n    Failure(:address_not_found)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Composing Operations with Result Monad in Ruby\nDESCRIPTION: Demonstrates how to use the bind method to compose multiple operations that might fail, using Success and Failure to handle the results.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/result.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads'\n\nclass AssociateUser\n  include Dry::Monads[:result]\n\n  def call(user_id:, address_id:)\n    find_user(user_id).bind do |user|\n      find_address(address_id).fmap do |address|\n        user.update(address_id: address.id)\n      end\n    end\n  end\n\n  private\n\n  def find_user(id)\n    user = User.find_by(id: id)\n\n    if user\n      Success(user)\n    else\n      Failure(:user_not_found)\n    end\n  end\n\n  def find_address(id)\n    address = Address.find_by(id: id)\n\n    if address\n      Success(address)\n    else\n      Failure(:address_not_found)\n    end\n  end\nend\n\nAssociateUser.new.(user_id: 1, address_id: 2)\n```\n\n----------------------------------------\n\nTITLE: Using fmap with Result Monad in Ruby\nDESCRIPTION: Shows how to use the fmap method with Success and Failure, including an example of passing a proc to fmap.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/result.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nextend Dry::Monads[:result]\n\nresult = if foo > bar\n  Success(10)\nelse\n  Failure(\"wrong\")\nend.fmap { |x| x * 2 }\n\n# If everything went success\nresult # => Success(20)\n# If it did not\nresult # => Failure(\"wrong\")\n\n# #fmap accepts a proc, just like #bind\n\nupcase = :upcase.to_proc\n\nSuccess('hello').fmap(upcase) # => Success(\"HELLO\")\n```\n\n----------------------------------------\n\nTITLE: Using fmap with Maybe monad in Ruby\nDESCRIPTION: Shows how to use the fmap method with Maybe monad to apply transformations to wrapped values.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/maybe.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nextend Dry::Monads[:maybe]\n\nMaybe(10).fmap { |x| x + 5 }.fmap { |y| y * 2 }\n# => Some(30)\n```\n\n----------------------------------------\n\nTITLE: Creating an account using bind and fmap in Ruby\nDESCRIPTION: This snippet demonstrates how to create an account using the traditional bind and fmap methods from dry-monads. It shows the complexity of nesting multiple monadic operations.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/do-notation.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads'\n\nclass CreateAccount\n  include Dry::Monads[:result]\n\n  def call(params)\n    validate(params).bind do |values|\n      create_account(values[:account]).bind do |account|\n        create_owner(account, values[:owner]).fmap do |owner|\n          [account, owner]\n        end\n      end\n    end\n  end\n\n  def validate(params)\n    # returns Success(values) or Failure(:invalid_data)\n  end\n\n  def create_account(account_values)\n    # returns Success(account) or Failure(:account_not_created)\n  end\n\n  def create_owner(account, owner_values)\n    # returns Success(owner) or Failure(:owner_not_created)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using bind with Maybe monad in Ruby\nDESCRIPTION: Demonstrates how to use the bind method with Maybe monad to handle potentially nil values in a chain of operations.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/maybe.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nextend Dry::Monads[:maybe]\n\nmaybe_street = Maybe(user).bind do |u|\n  Maybe(u.address).bind do |a|\n    Maybe(a.street)\n  end\nend\n\n# If user with address exists\n# => Some(\"Street Address\")\n# If user or address is nil\n# => None()\n\n# You also can pass a proc to #bind\n\nadd_two = -> (x) { Maybe(x + 2) }\n\nMaybe(5).bind(add_two).bind(add_two) # => Some(9)\nMaybe(nil).bind(add_two).bind(add_two) # => None()\n```\n\n----------------------------------------\n\nTITLE: Do Notation with Result Monad\nDESCRIPTION: Example showing cleaner implementation using do notation with Result monad.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/index.html.md#2025-04-12_snippet_10\n\nLANGUAGE: ruby\nCODE:\n```\nuser = yield find_user(params[:user_id])\naddress = yield find_address(params[:address_id])\n\nSuccess(user.update(address_id: address.id))\n```\n\n----------------------------------------\n\nTITLE: Transaction-safe account creation using Do notation in Ruby\nDESCRIPTION: This snippet demonstrates how to wrap account creation in a transaction block using Do notation. It ensures that the database remains in a consistent state if any part of the operation fails.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/do-notation.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nrepo.transaction do\n  account = yield create_account(values[:account])\n  owner = yield create_owner(account, values[:owner])\n\n  Success[account, owner]\nend\n```\n\n----------------------------------------\n\nTITLE: Basic Try Monad Usage in Ruby with dry-monads\nDESCRIPTION: Demonstrates how to use the Try monad to safely execute code that might raise exceptions. Shows successful execution, handling division by zero errors, and restricting exception types that are caught.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/try.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads'\n\nclass ExceptionalLand\n  include Dry::Monads[:try]\n\n  def call\n    res = Try { 10 / 2 }\n    res.value! if res.value?\n    # => 5\n\n    res = Try { 10 / 0 }\n    res.exception if res.error?\n    # => #<ZeroDivisionError: divided by 0>\n\n    # By default Try catches all exceptions inherited from StandardError.\n    # However you can catch only certain exceptions like this\n    Try[NoMethodError, NotImplementedError] { 10 / 0 }\n    # => raised ZeroDivisionError: divided by 0 exception\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using Maybe Monad in Ruby with dry-monads\nDESCRIPTION: Example of using the Maybe monad in a CreateUser class, demonstrating how to include the monad and use its constructors.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/getting-started.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads'\n\nclass CreateUser\n  # this line loads the Maybe monad and adds\n  # Some(...), None(), and Maybe(...) to CreateUser\n  include Dry::Monads[:maybe]\n\n  def call(params)\n    # ...\n    if valid?(params)\n      Some(create_user(params))\n    else\n      None()\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Maybe Monad Implementation\nDESCRIPTION: Example using Maybe monad for safe method chaining with nil handling and default value specification.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/index.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nstate_name = Maybe(\n  User.find_by(id: params[:id])\n).maybe(&:address).maybe(&:city).maybe(&:state).maybe(&:name)\n\nuser_state = state_name.value_or(\"No state\")\n```\n\n----------------------------------------\n\nTITLE: Form Validation Using Validated with List in Ruby\nDESCRIPTION: Enhanced implementation using Validated applicative functor with List to collect all validation errors at once, rather than stopping at the first failure.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/validated.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads'\n\nclass CreateAccount\n  include Dry::Monads[:list, :result, :validated, :do]\n\n  def call(form)\n    name, email, password = yield List::Validated[\n      validate_name(form),\n      validate_email(form),\n      validate_password(form)\n    ].traverse.to_result\n\n    user = repo.create_user(\n      name: name,\n      email: email,\n      password: password\n    )\n\n    Success(user)\n  end\n\n  def validate_name(form)\n    # Valid(name) or Invalid(:invalid_name)\n  end\n\n  def validate_email(form)\n    # Valid(email) or Invalid(:invalid_email)\n  end\n\n  def validate_password(form)\n    # Valid(password) or Invalid(:invalid_password)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Handling Monad Interactions in Ruby with dry-monads\nDESCRIPTION: Demonstrates how to properly load and use multiple monads to enable interactions between them, such as converting from Result to Maybe.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/getting-started.html.md#2025-04-12_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nextend Dry::Monads[:result, :maybe]\n\nSuccess(:foo).to_maybe # => Some(:foo)\n```\n\n----------------------------------------\n\nTITLE: Creating an account using Do notation in Ruby\nDESCRIPTION: This snippet shows how to use Do notation from dry-monads to simplify the process of creating an account. It demonstrates a more readable and maintainable approach to composing monadic operations.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/do-notation.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads'\nrequire 'dry/monads/do'\n\nclass CreateAccount\n  include Dry::Monads[:result]\n  include Dry::Monads::Do.for(:call)\n\n  def call(params)\n    values = yield validate(params)\n    account = yield create_account(values[:account])\n    owner = yield create_owner(account, values[:owner])\n\n    Success([account, owner])\n  end\n\n  def validate(params)\n    # returns Success(values) or Failure(:invalid_data)\n  end\n\n  def create_account(account_values)\n    # returns Success(account) or Failure(:account_not_created)\n  end\n\n  def create_owner(account, owner_values)\n    # returns Success(owner) or Failure(:owner_not_created)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Form Validation Using Result and Do Notation in Ruby\nDESCRIPTION: Implementation of form validation using Result monad with Do notation. This approach stops at the first validation failure and doesn't collect multiple errors.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/validated.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads'\n\nclass CreateAccount\n  include Dry::Monads[:result, :do]\n\n  def call(form)\n    name = yield validate_name(form)\n    email = yield validate_email(form)\n    password = yield validate_password(form)\n\n    user = repo.create_user(\n      name: name,\n      email: email,\n      password: password\n    )\n\n    Success(user)\n  end\n\n  def validate_name(form)\n    # Success(name) or Failure(:invalid_name)\n  end\n\n  def validate_email(form)\n    # Success(email) or Failure(:invalid_email)\n  end\n\n  def validate_password(form)\n    # Success(password) or Failure(:invalid_password)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Basic Task Usage with Concurrent Operations\nDESCRIPTION: Demonstrates how to use Task to run concurrent operations and combine their results. This example fetches users and posts concurrently and then combines the results.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/task.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads'\n\nclass PullUsersWithPosts\n  include Dry::Monads[:task]\n\n  def call\n    # Start two tasks running concurrently\n    users = Task { fetch_users }\n    posts = Task { fetch_posts }\n\n    # Combine two tasks\n    users.bind { |us| posts.fmap { |ps| [us, ps] } }\n  end\n\n  def fetch_users\n    sleep 3\n    [{ id: 1, name: 'John' }, { id: 2, name: 'Jane' }]\n  end\n\n  def fetch_posts\n    sleep 2\n    [\n      { id: 1, user_id: 1, name: 'Hello from John' },\n      { id: 2, user_id: 2, name: 'Hello from Jane' },\n    ]\n  end\nend\n\n# PullUsersWithPosts instance\npull = PullUsersWithPosts.new\n\n# Spin up two tasks\ntask = pull.call\n\ntask.fmap do |users, posts|\n  puts \"Users: #{ users.inspect }\"\n  puts \"Posts: #{ posts.inspect }\"\nend\n\nputs \"----\" # this will be printed before the lines above\n```\n\n----------------------------------------\n\nTITLE: Chaining Operations with Try Monad's bind Method\nDESCRIPTION: Shows how to use the bind method to chain multiple operations that might raise exceptions. The example demonstrates handling network and database errors in a sequence of operations.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/try.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nTry[NetworkError, DBError] { grap_user_by_making_request }.bind { |user| user_repo.save(user) }\n\n# Possible outcomes:\n# => Value(persisted_user)\n# => Error(NetworkError: request timeout)\n# => Error(DBError: unique constraint violated)\n```\n\n----------------------------------------\n\nTITLE: Tracing a Failure in Ruby using dry-monads\nDESCRIPTION: This code demonstrates how to access the trace information from a Failure object. It instantiates the CreateUser class, calls its method to get a Failure, and then accesses the trace property to see where the failure originated.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/tracing-failures.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'create_user'\n\ncreate_user = CreateUser.new\ncreate_user.()       # => Failure(:no_luck)\ncreate_user.().trace # => .../create_user.rb:8:in `call'\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Result Monad in Ruby\nDESCRIPTION: Examples of pattern matching against Success and Failure types from the Result monad. Shows various matching techniques including value binding, type constraints, guards, nested patterns, and array/tuple handling.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/pattern-matching.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\n# presumably you do it in a class with `include Dry::Monads[:result]`\n\ncase value\nin Success(Integer => x)\n  # x is bound to an integer\nin Success[:created, user]\n  # user is bound to the second member\nin Success(Date | Time)\n  # date or time object\nin Success[1, *]\n  # any array starting with 1\nin Success(String => s) if s.size < 100\n  # only if `s` is short enough\nin Success(counter: Integer)\n  # matches Success(counter: 50)\n  # doesn't match Success(counter: 50, extra: 50)\nin Success(user: User, account: Account => user_account)\n  # matches Success(user: User.new(...), account: Account.new(...), else: ...)\n  # user_account is bound to the value of the `:account` key\nin Success()\n  # corresponds to Success(Unit)\nin Success(user:, **rest)\n  # matches Success(user: User.new, other_key: \"value\")\nin Success(_)\n  # general success\nin Failure[:user_not_found]\n  # matches Failure([:user_not_found]) or Failure[:user_not_found]\nin Failure[error_code, *payload]\n  # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Result Monad with Fmap\nDESCRIPTION: Example showing Result monad composition using fmap for simpler inner block implementation.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/index.html.md#2025-04-12_snippet_9\n\nLANGUAGE: ruby\nCODE:\n```\nfind_user(params[:user_id]).bind do |user|\n  find_address(params[:address_id]).fmap |address|\n    user.update(address_id: address.id)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Result Monad with Bind\nDESCRIPTION: Example showing Result monad composition using bind method.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/index.html.md#2025-04-12_snippet_8\n\nLANGUAGE: ruby\nCODE:\n```\nfind_user(params[:user_id]).bind do |user|\n  find_address(params[:address_id]).bind |address|\n    Success(user.update(address_id: address.id))\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Maybe Monad with Bind\nDESCRIPTION: Example using Maybe monad's bind method for handling multiple potentially nil objects safely.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/index.html.md#2025-04-12_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nmaybe_user = Maybe(User.find_by(id: params[:user_id]))\n\nmaybe_user.bind do |user|\n  maybe_address = Maybe(Address.find_by(id: params[:address_id]))\n\n  maybe_address.bind do |address|\n    user.update(address_id: address.id)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Basic Pattern Matching with Some Monad in Ruby\nDESCRIPTION: This snippet demonstrates how to use Ruby's case operator to match on Some monad values, including matching against specific values and ranges.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/case-equality.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\ncase value\nwhen Some(1), Some(2) then :one_or_two\nwhen Some(3..5) then :three_to_five\nelse\n  :something_else\nend\n```\n\n----------------------------------------\n\nTITLE: Using bind with List Monad in Ruby\nDESCRIPTION: Demonstrates the bind method which lifts a block/proc and runs it against each member of the list. The block must return a value coercible to a list. Without a block, the first argument is treated as callable.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/list.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads/list'\n\nM = Dry::Monads\n\nM::List[1, 2].bind { |x| [x + 1] } # => List[2, 3]\nM::List[1, 2].bind(-> x { [x, x + 1] }) # => List[1, 2, 2, 3]\n\nM::List[1, nil].bind { |x| [x + 1] } # => error\n```\n\n----------------------------------------\n\nTITLE: Extracting values from Maybe monad in Ruby\nDESCRIPTION: Shows how to extract values from Maybe monad using value! and value_or methods, with error handling for None cases.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/maybe.html.md#2025-04-12_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nextend Dry::Monads[:maybe]\n\nSome(5).fmap(&:succ).value! # => 6\n\nNone().fmap(&:succ).value!\n# => Dry::Monads::UnwrapError: value! was called on None\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Success and Failure Monads in Ruby\nDESCRIPTION: This snippet shows how to match on Success and Failure monads, including matching against specific error types within Failure monads.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/case-equality.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\ncase value\nwhen Success then [:ok, value.value!]\nwhen Failure(TimeoutError) then [:timeout]\nwhen Failure(ConnectionClosed) then [:net_error]\nwhen Failure then [:generic_error]\nelse\n  raise \"Unhandled case\"\nend\n```\n\n----------------------------------------\n\nTITLE: Extracting Values from Result Monad in Ruby\nDESCRIPTION: Demonstrates the use of value_or for safely extracting values, and value! for extracting values when certain of Success.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/result.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nextend Dry::Monads[:result]\n\nSuccess(10).value_or(0) # => 10\nFailure('Error').value_or(0) # => 0\n\nSuccess(10).value! # => 10\nFailure('Error').value!\n# => Dry::Monads::UnwrapError: value! was called on Failure\n```\n\n----------------------------------------\n\nTITLE: Using or and failure Methods with Result Monad in Ruby\nDESCRIPTION: Shows how to use the or method with Success and Failure, and the failure method for unwrapping Failure values.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/result.html.md#2025-04-12_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nextend Dry::Monads[:result]\n\nSuccess(10).or(Success(99)) # => Success(10)\nFailure(\"error\").or(Failure(\"new error\")) # => Failure(\"new error\")\nFailure(\"error\").or { |err| Failure(\"new #{err}\") } # => Failure(\"new error\")\n\nFailure('Error').failure # => \"Error\"\n```\n\n----------------------------------------\n\nTITLE: Mapping Values in Try Monad with fmap Method\nDESCRIPTION: Demonstrates using the fmap method to transform values within a Try monad, similar to Result's fmap. Shows examples of mapping successful values and how errors are preserved.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/try.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads'\n\nclass ExceptionalLand\n  include Dry::Monads[:try]\n\n  def call\n    Try { 10 / 2 }.fmap { |x| x * 3 }\n    # => Try::Value(15)\n\n    Try[ZeroDivisionError] { 10 / 0 }.fmap { |x| x * 3 }\n    # => Try::Error(ZeroDivisionError: divided by 0)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Maybe Monad with Method Returns\nDESCRIPTION: Example showing Maybe monad usage with methods that return Maybe values.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/index.html.md#2025-04-12_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nfind_user(params[:user_id]).bind do |user|\n  find_address(params[:address_id]).bind do |address|\n    Some(user.update(address_id: address.id))\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing a Result Monad Failure in Ruby with dry-monads\nDESCRIPTION: This code creates a simple CreateUser class that includes the Result monad from dry-monads and returns a Failure with the symbol :no_luck. It demonstrates how failures can be created in a class method.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/tracing-failures.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\n# create_user.rb\nrequire 'dry/monads'\n\nclass CreateUser\n  include Dry::Monads[:result]\n\n  def call\n    Failure(:no_luck)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using maybe method with Maybe monad in Ruby\nDESCRIPTION: Demonstrates the maybe method, which is similar to fmap but maps nil to None, useful for method chaining.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/maybe.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nextend Dry::Monads[:maybe]\n\nMaybe(user).maybe(&:address).maybe(&:street)\n\n# If user with address exists\n# => Some(\"Street Address\")\n# If user or address is nil\n# => None()\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with List Monad in Ruby\nDESCRIPTION: Examples of pattern matching against List types. Shows matching against specific list contents, variable-length lists, and empty lists.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/pattern-matching.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\ncase value\nin List[Integer]\n  # any list of size 1 with an integer\nin List[1, 2, 3, *]\n  # list with size >= 3 starting with 1, 2, 3\nin List[]\n  # empty list\nend\n```\n\n----------------------------------------\n\nTITLE: Using Do::All for automatic method wrapping in Ruby\nDESCRIPTION: This snippet shows how to use Do::All to automatically wrap all new methods in a class with Do notation. It simplifies the process of applying Do notation to multiple methods within a class.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/do-notation.html.md#2025-04-12_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads'\n\nclass CreateAccount\n  # This will include Do::All by default\n  include Dry::Monads[:result, :do]\n\n  def call(account_params, owner_params)\n    repo.transaction do\n      account = yield create_account(account_params)\n      owner = yield create_owner(account, owner_params)\n\n      Success[account, owner]\n    end\n  end\n\n  def create_account(params)\n    values = yield validate_account(params)\n    account = repo.create_account(values)\n\n    Success(account)\n  end\n\n  def create_owner(account, params)\n    values = yield validate_owner(params)\n    owner = repo.create_owner(account, values)\n\n    Success(owner)\n  end\n\n  def validate_account(params)\n    # returns Success/Failure\n  end\n\n  def validate_owner(params)\n    # returns Success/Failure\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Converting Maybe to Result monad in Ruby\nDESCRIPTION: Demonstrates how to convert Maybe values to Result objects using the to_result method.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/maybe.html.md#2025-04-12_snippet_8\n\nLANGUAGE: ruby\nCODE:\n```\nextend Dry::Monads[:maybe, :result]\n\nSome(10).to_result # => Success(10)\nNone().to_result # => Failure()\nNone().to_result(:error) # => Failure(:error)\nNone().to_result { :block_value } # => Failure(:block_value)\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Maybe Monad in Ruby\nDESCRIPTION: Examples of pattern matching against Some and None types from the Maybe monad. Demonstrates matching with type constraints and conditional guards.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/pattern-matching.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\ncase value\nin Some(Integer => x) if x > 0\n  # x is a positive integer\nin Some(Float | String)\n  # ...\nin None\n  # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Using collect with List Monad in Ruby\nDESCRIPTION: Shows the collect method which works differently than Enumerable#collect. The block must return Maybe types where Some values are retained and None values are discarded. Without a block, the first argument is treated as callable.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/list.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads/list'\n\nM = Dry::Monads\n\nn = 20\nM::List[10, 5, 0].collect do |divisor|\n  if divisor.zero?\n    M::None()\n  else\n    M::Some(n / divisor)\n  end\nend\n# => List[2, 4]\n\nM::List[M::Some(1), M::None(), M::Some(2), M::None(), M::Some(3)].collect # => List[1, 2, 3]\n\nleap_year = proc do |year|\n  if year % 400 == 0\n    M::Some(year)\n  elsif year % 100 == 0\n    M::None()\n  elsif year % 4 == 0\n    M::Some(year)\n  else\n    M::None()\n  end\nend\n\nM::List[2020, 2021, 2022, 2023, 2024].collect(leap_year) # => List[2020, 2024]\n```\n\n----------------------------------------\n\nTITLE: Recovering from Errors in Try Monad\nDESCRIPTION: Shows how to use the recover method to handle specific exceptions and provide fallback values. Demonstrates recovery with explicit exception types and with default StandardError handling.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/try.html.md#2025-04-12_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nextend Dry::Monads[:try]\n\nTry { 10 / 0 }.recover(ZeroDivisionError) { 1 } # => Try::Value(1)\n```\n\nLANGUAGE: ruby\nCODE:\n```\nextend Dry::Monads[:try]\nTry { Hash.new.fetch(:missing) }.recover { :found } # => Try::Value(:found)\n```\n\nLANGUAGE: ruby\nCODE:\n```\nTry { 10 }.recover { 1 } # => Try::Value(10)\n```\n\nLANGUAGE: ruby\nCODE:\n```\nextend Dry::Monads[:try]\n\nTry { bang! }.recover(KeyError, ArgumentError) { :failsafe }\n```\n\n----------------------------------------\n\nTITLE: Flattening nested Maybe monads in Ruby\nDESCRIPTION: Shows how to use the flatten method to remove one level of nesting in Maybe monads.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/maybe.html.md#2025-04-12_snippet_7\n\nLANGUAGE: ruby\nCODE:\n```\nextend Dry::Monads[:maybe]\n\nSome(Some(10)).flatten # => Some(10)\nSome(None()).flatten   # => None()\nNone().flatten         # => None()\n```\n\n----------------------------------------\n\nTITLE: Unwrapping List Monad with value in Ruby\nDESCRIPTION: Shows how to unwrap a List monad to get the underlying array using the value method.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/list.html.md#2025-04-12_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads/list'\n\nM = Dry::Monads\n\nM::List[1, 2].value # => [1, 2]\n```\n\n----------------------------------------\n\nTITLE: Adding Constraints to Failure Values in Result Monad in Ruby\nDESCRIPTION: Demonstrates how to add type constraints to Failure values using dry-types, raising exceptions for invalid types.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/result.html.md#2025-04-12_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry-types'\n\nmodule Types\n  include Dry.Types()\nend\n\nclass Operation\n  Error = Types.Instance(RangeError)\n  include Dry::Monads::Result(Error)\n\n  def call(value)\n    case value\n    when 0..1\n      Success(:success)\n    when -Float::INFINITY..0, 1..Float::INFINITY\n      Failure(RangeError.new('Error'))\n    else\n      Failure(TypeError.new('Type error'))\n    end\n  end\nend\n\nOperation.new.call(0.5) # => Success(:success)\nOperation.new.call(5) # => Failure(#<RangeError: Error>)\nOperation.new.call(\"5\") # => Dry::Monads::InvalidFailureTypeError: Cannot create Failure from #<TypeError: Type error>, it doesn't meet the constraints\n```\n\n----------------------------------------\n\nTITLE: Using either and alt_map with Result Monad in Ruby\nDESCRIPTION: Shows how to use the either method to map Success and Failure cases, and alt_map for mapping Failure values.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/result.html.md#2025-04-12_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nSuccess(1).either(-> x { x + 1 }, -> x { x + 2 }) # => 2\nFailure(1).either(-> x { x + 1 }, -> x { x + 2 }) # => 3\n\nFailure(\"oops\").alt_map(&:upcase) # => Failure(\"OOPS\")\n```\n\n----------------------------------------\n\nTITLE: Extracting Results from Tasks\nDESCRIPTION: Shows how to extract values from Tasks using blocking operations like 'value!' and 'wait'. Includes warnings about blocking behavior.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/task.html.md#2025-04-12_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nTask { 0 }.value! # => 0\nTask { 1/0 }.value! # => ZeroDivisionError: divided by 0\n```\n\nLANGUAGE: ruby\nCODE:\n```\nTask[:io] { 2 }.wait(1) # => Task(value=2)\nTask[:io] { sleep 2; 2 }.wait(1) # => Task(?)\n\n# (?) denotes an unfinished computation\n```\n\n----------------------------------------\n\nTITLE: Including Multiple Monads in Ruby with dry-monads\nDESCRIPTION: Demonstrates how to include multiple monads (Maybe and Result) in a single class using dry-monads.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/getting-started.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads'\n\nclass CreateUser\n  # Adds Maybe and Result. The order doesn't matter\n  include Dry::Monads[:maybe, :result]\nend\n```\n\n----------------------------------------\n\nTITLE: Using fmap with List Monad in Ruby\nDESCRIPTION: Demonstrates the fmap method which maps a block over the list, similar to Array#map. Without a block, the first argument is treated as callable.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/list.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads/list'\n\nM = Dry::Monads\n\nM::List[1, 2].fmap { |x| x + 1 } # => List[2, 3]\n```\n\n----------------------------------------\n\nTITLE: Using value_or with Maybe monad in Ruby\nDESCRIPTION: Demonstrates the safe extraction of values from Maybe monad using value_or method, providing default values for None cases.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/maybe.html.md#2025-04-12_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nextend Dry::Monads[:maybe]\n\nadd_two = -> (x) { Maybe(x + 2) }\n\nMaybe(5).bind(add_two).value_or(0) # => 7\nMaybe(nil).bind(add_two).value_or(0) # => 0\n\nMaybe(nil).bind(add_two).value_or { 0 } # => 0\n```\n\n----------------------------------------\n\nTITLE: Using or and | operator with Maybe monad in Ruby\nDESCRIPTION: Shows how to use the or method and its alias | operator to provide alternative values for None cases.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/maybe.html.md#2025-04-12_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nextend Dry::Monads[:maybe]\n\nadd_two = -> (x) { Maybe(x + 2) }\n\nMaybe(5).bind(add_two).or(Some(0)) # => Some(7)\nMaybe(nil).bind(add_two).or(Some(0)) # => Some(0)\n\nMaybe(nil).bind(add_two).or { Some(0) } # => Some(0)\n\nNone() | Some(1) | Some(2) # => Some(1)\n```\n\n----------------------------------------\n\nTITLE: Handling Exceptions in Tasks\nDESCRIPTION: Demonstrates how exceptions are captured in Tasks and how to handle failure cases using the 'or' and 'or_fmap' methods.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/task.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nio_fail = Task[:io] { 1/0 }\nio_fail # => Task(error=#<ZeroDivisionError: divided by 0>)\n\nimmediate_fail = Task[:immediate] { 1/0 }\nimmediate_fail # => Task(error=#<ZeroDivisionError: divided by 0>)\n```\n\nLANGUAGE: ruby\nCODE:\n```\nTask[:immediate] { 1/0 }.or { M::Task[:immediate] { 0 } } # => Task(value=0)\nTask[:immediate] { 1/0 }.or_fmap { 0 } # => Task(value=0)\n```\n\n----------------------------------------\n\nTITLE: Example Result of Validated Form Validation in Ruby\nDESCRIPTION: Demonstrates the output format when multiple validation errors occur using the Validated approach with List.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/validated.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\ncreate_account.(form)\n# => Failure(List[:invalid_name, :invalid_email])\n```\n\n----------------------------------------\n\nTITLE: Do Notation with Maybe Monad\nDESCRIPTION: Example using do notation for cleaner Maybe monad implementation.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/index.html.md#2025-04-12_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nuser = yield find_user(params[:user_id])\naddress = yield find_address(params[:address_id])\n\nSome(user.update(address_id: address.id))\n```\n\n----------------------------------------\n\nTITLE: Configuring Task Executors\nDESCRIPTION: Shows how to specify different executors for Task operations. Includes examples for IO-bound, CPU-bound, and immediate execution patterns.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/task.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nTask[:io] { do_http_request }\n\nTask[:fast] { cpu_intensive_computation }\n\nTask[:immediate] { unsafe_io_operation }\n\n# You can pass an executor object\nTask[my_executor] { ... }\n```\n\n----------------------------------------\n\nTITLE: Using head and tail with List Monad in Ruby\nDESCRIPTION: Shows the head method which returns the first element wrapped in a Maybe monad, and the tail method which returns a new List with all but the first element.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/list.html.md#2025-04-12_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads/list'\n\nM = Dry::Monads\n\nM::List[1, 2, 3, 4].head # => Some(1)\nM::List[1, 2, 3, 4].tail # => List[2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Using Do::All with class methods in Ruby\nDESCRIPTION: This snippet demonstrates how to use Do::All with class methods. It shows how to extend a class with both Result and Do monads, and use them in a class method.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/do-notation.html.md#2025-04-12_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads'\n\nclass SomeClassLevelLogic\n  extend Dry::Monads[:result, :do]\n\n  def self.call\n    x = yield Success(5)\n    y = yield Success(20)\n\n    Success(x * y)\n  end\nend\n\nSomeClassLevelLogic.() # => Success(100)\n```\n\n----------------------------------------\n\nTITLE: Concatenating List Monads in Ruby\nDESCRIPTION: Demonstrates how to concatenate two List monads using the + operator, resulting in a new combined List.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/list.html.md#2025-04-12_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads/list'\n\nM = Dry::Monads\n\nM::List[1, 2] + M::List[3, 4] # => List[1, 2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Alternative Successful Array Pattern Matching in dry-monads\nDESCRIPTION: Another example of correct pattern matching for arrays in dry-monads using square bracket notation.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/pattern-matching.html.md#2025-04-12_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nSuccess([1, 2, 3]) in Success[1, 2 ,3]\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Nested Monad Structures in Ruby\nDESCRIPTION: This snippet demonstrates how to use pattern matching with nested monad structures, such as Success(None()) or Success(Some).\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/case-equality.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\ncase value\nwhen Success(None()) then :nothing\nwhen Success(Some { |x| x > 10 }) then :something\nwhen Success(Some) then :something_else\nwhen Failure then :error\nend\n```\n\n----------------------------------------\n\nTITLE: Using and method with Maybe monad in Ruby\nDESCRIPTION: Demonstrates how to chain two Maybe values using the and method, combining their results or propagating None.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/maybe.html.md#2025-04-12_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nextend Dry::Monads[:maybe]\n\nSome(5).and(Some(10)) { |x, y| x + y } # => Some(15)\nSome(5).and(None) { |x, y| x + y }     # => None()\nNone().and(Some(10)) { |x, y| x + y }  # => None()\n\nSome(5).and(Some(10)) # => Some([5, 10])\nSome(5).and(None())   # => None()\n```\n\n----------------------------------------\n\nTITLE: Traditional Nil Checking in Ruby\nDESCRIPTION: Example of traditional Ruby code showing verbose nil checking pattern when accessing nested object properties.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/index.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nuser = User.find_by(id: params[:id])\n\nif user\n  address = user.address\nend\n\nif address\n  city = address.city\nend\n\nif city\n  state = city.state\nend\n\nif state\n  state_name = state.name\nend\n\nuser_state = state_name || \"No state\"\n```\n\n----------------------------------------\n\nTITLE: Converting Result to Maybe Monad in Ruby\nDESCRIPTION: Demonstrates how to convert a Result monad to a Maybe monad using the to_maybe method.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/result.html.md#2025-04-12_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nextend Dry::Monads[:result, :maybe]\n\nresult = if foo > bar\n  Success(10)\nelse\n  Failure(\"wrong\")\nend.to_maybe\n\n# If everything went success\nresult # => Some(10)\n# If it did not\nresult # => None()\n```\n\n----------------------------------------\n\nTITLE: Using Do with class methods in Ruby\nDESCRIPTION: This snippet shows how to use Do notation with class methods. It demonstrates extending a class with Do::Mixin and using it in a class method.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/do-notation.html.md#2025-04-12_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads'\n\nclass VeryComplexAndUglyCode\n  extend Dry::Monads::Do::Mixin\n  extend Dry::Monads[:result]\n\n  def self.create_something(result_value)\n    call do\n      extracted = bind result_value\n      processed = bind process(extracted)\n\n      Success(processed)\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using traverse with Typed List Monad in Ruby\nDESCRIPTION: Demonstrates the traverse method which \"flips\" the List structure with the given monad type. Note that traversing requires the list to be typed with the typed method first.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/list.html.md#2025-04-12_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads/list'\n\nM = Dry::Monads\n\nM::List[M::Success(1), M::Success(2)].typed(M::Result).traverse # => Success(List[1, 2])\nM::List[M::Maybe(1), M::Maybe(nil), M::Maybe(3)].typed(M::Maybe).traverse # => None\n\n# also, you can use fmap with #traverse\n\nM::List[1, 2].fmap { |x| M::Success(x) }.typed(M::Result).traverse # => Success(List[1, 2])\nM::List[1, nil, 3].fmap { |x| M::Maybe(x) }.typed(M::Maybe).traverse # => None\n```\n\n----------------------------------------\n\nTITLE: Discarding values with the discard method\nDESCRIPTION: Explains how to use the .discard method to map a wrapped value to Unit when the outcome of an operation is not important. It maps Success with any value to Success(Unit) while leaving Failure unchanged.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/unit.html.md#2025-04-12_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nextend Dry::Monads[:result]\n\nresult = create_user # returns Success(#<User...>) or Failure(...)\n\nresult.discard # => Maps Success(#<User ...>) to Success() but lefts Failure(...) intact\n```\n\n----------------------------------------\n\nTITLE: Converting Tasks to Other Monads\nDESCRIPTION: Examples of converting Tasks to other monad types like Result and Maybe. These operations block the current thread until the task completes.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/task.html.md#2025-04-12_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nTask[:io] { 2 }.to_result # => Success(2)\nTask[:io] { 1/0 }.to_result # => Failure(#<ZeroDivisionError: divided by 0>)\n\nTask[:io] { 2 }.to_maybe # => Some(2)\nTask[:io] { 1/0 }.to_maybe # => None\n```\n\n----------------------------------------\n\nTITLE: Filtering Maybe values in Ruby\nDESCRIPTION: Shows how to use the filter method to apply predicates to Maybe values, returning None for false results.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/maybe.html.md#2025-04-12_snippet_9\n\nLANGUAGE: ruby\nCODE:\n```\nSome(3).filter(&:odd?)  # => Some(3)\nSome(3).filter(&:even?) # => None\n# no block given\nSome(3 == 5).filter     # => None\n```\n\n----------------------------------------\n\nTITLE: Successful Array Pattern Matching as Tuples in dry-monads\nDESCRIPTION: Examples of correct pattern matching approaches for arrays in dry-monads, treating them as tuples with individual elements.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/pattern-matching.html.md#2025-04-12_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nSuccess([1, 2, 3]) in Success(one, two, three)\n```\n\n----------------------------------------\n\nTITLE: Capturing Array Values in Pattern Matching with dry-monads\nDESCRIPTION: Demonstrating how to capture an entire array in pattern matching using the splat operator (*).\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/pattern-matching.html.md#2025-04-12_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nSuccess([1, 2, 3]) in Success(*numbers)\n```\n\n----------------------------------------\n\nTITLE: Using Unit as default value in dry-monads constructors\nDESCRIPTION: Shows how Unit is used as a default value when no value is passed to constructors like Success(). Unit is a singleton value that doesn't have special properties but differs from nil in that it passes conditional checks.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/unit.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nextend Dry::Monads[:result]\n\nSuccess().value! # => Unit\n```\n\n----------------------------------------\n\nTITLE: Traditional Nil Checking with Multiple Objects\nDESCRIPTION: Example showing traditional approach to handling multiple potentially nil objects before performing an operation.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/index.html.md#2025-04-12_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nuser = User.find_by(id: params[:user_id])\naddress = Address.find_by(id: params[:address_id])\n\nif user && address\n  user.update(address_id: address.id)\nend\n```\n\n----------------------------------------\n\nTITLE: Direct Method Chaining in Ruby\nDESCRIPTION: Example showing direct method chaining without nil checking, which could raise errors if any object in the chain is nil.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/index.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nstate_name = User.find_by(id: params[:id]).address.city.state.name\nuser_state = state_name || \"No state\"\n```\n\n----------------------------------------\n\nTITLE: Constructing Array Values with dry-monads in Ruby\nDESCRIPTION: Shows how to use shortcuts for wrapping arrays when constructing monad values, specifically for the Failure case of the Result monad.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/getting-started.html.md#2025-04-12_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads'\n\nclass CreateUser\n  include Dry::Monads[:result]\n\n  def call(params)\n    # ...\n    # Same as Failure([:user_exists, params: params])\n    Failure[:user_exists, params: params]\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Displaying Gem Version and CI Status Badges in Markdown\nDESCRIPTION: This snippet shows how to embed badges for the gem version from RubyGems and the CI status from GitHub Actions using Markdown syntax.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/README.md#2025-04-12_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[![Gem Version](https://badge.fury.io/rb/dry-monads.svg)][gem] [![CI Status](https://github.com/dry-rb/dry-monads/workflows/CI/badge.svg)][actions]\n```\n\n----------------------------------------\n\nTITLE: Installing dry-monads via Gemfile in Ruby\nDESCRIPTION: Add the dry-monads gem to your project's Gemfile and run bundle to install it.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/getting-started.html.md#2025-04-12_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\ngem 'dry-monads'\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ bundle\n```\n\n----------------------------------------\n\nTITLE: Unit exclusion from output formatting\nDESCRIPTION: Demonstrates how Unit is usually excluded from the output representation. When Success() is called without arguments, it's displayed as 'Success()' even though it technically contains the Unit value.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/unit.html.md#2025-04-12_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nextend Dry::Monads[:result]\n\n# Outputs as \"Success()\" but technically it's \"Success(Unit)\"\nSuccess()\n```\n\n----------------------------------------\n\nTITLE: Failed Array Pattern Matching Example in dry-monads\nDESCRIPTION: Example of a pattern matching approach that will not work with arrays in dry-monads because arrays are treated as tuples rather than lists.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/pattern-matching.html.md#2025-04-12_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nSuccess([1, 2, 3]) in Success(numbers) # => no match!\n```\n\n----------------------------------------\n\nTITLE: Using Do methods directly in Ruby\nDESCRIPTION: This snippet demonstrates how to use Do methods directly in your code without including them in a class. It shows how to use Do.() and Do.bind for ad-hoc monadic operations.\nSOURCE: https://github.com/dry-rb/dry-monads/blob/main/docsite/source/do-notation.html.md#2025-04-12_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nrequire 'dry/monads/do'\nrequire 'dry/monads/result'\n\n# some random place in your code\nDry::Monads::Do.() do\n  user = Dry::Monads::Do.bind create_user\n  account = Dry::Monads::Do.bind create_account(user)\n\n  Dry::Monads::Success[user, account]\nend\n```"
  }
]