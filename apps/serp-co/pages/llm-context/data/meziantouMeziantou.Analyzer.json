[
  {
    "owner": "meziantou",
    "repo": "meziantou.analyzer",
    "content": "TITLE: String Equality Comparison Using == in C#\nDESCRIPTION: This code snippet demonstrates the incorrect usage of the equality operator `==` for comparing strings.  It highlights that `string.Equals` should be used instead to explicitly define the string comparison rules. It suggests using `StringComparison.Ordinal` for ordinal comparison.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0006.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n\"\" == \"\";\n\n// Should be\nstring.Equals(\"\", \"\", StringComparison.Ordinal);\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Conversion: Replacing Blocking Calls with Await (C#)\nDESCRIPTION: This code snippet demonstrates the recommended transformation of a synchronous method to an asynchronous method by replacing blocking calls with `await`.  The method signature changes to `async Task Sample()`, and calls like `Task.Delay(1).Wait()` and `Task.Run(...).Result` are replaced with `await Task.Delay(1)` and `await Task.Run(...)` respectively.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0045.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic async Task Sample()\n{\n    await Task.Delay(1);\n    await Task.Delay(1);\n\n    var result = await Task.Run(() => 10);\n}\n```\n\n----------------------------------------\n\nTITLE: Replace Blocking Calls with Async Await - C#\nDESCRIPTION: This code demonstrates how to replace blocking calls (Thread.Sleep, Task.Delay.Wait, Task.Run(...).Result) with their asynchronous equivalents using the `await` keyword.  This ensures that the method remains asynchronous and avoids blocking the calling thread. The surrounding method must be declared as `async` for the `await` keyword to be used.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0042.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic async Task Sample()\n{\n    Thread.Sleep(1); // Non compliant\n    Task.Delay(1).Wait(); // non compliant\n    await Task.Delay(1); // compliant\n\n    var result = Task.Run(() => 10).Result; // non compliant\n    var result = await Task.Run(() => 10); // compliant\n}\n```\n\n----------------------------------------\n\nTITLE: String Comparison Missing - C#\nDESCRIPTION: This C# code snippet demonstrates the MA0001 analyzer rule. The `string.Equals` method is called without specifying a `StringComparison` type, which defaults to `StringComparison.Ordinal`. The analyzer recommends explicitly specifying the `StringComparison` value for clarity and correctness. The corrected version demonstrates how to provide the `StringComparison.Ordinal` explicitly.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0001.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstring.Equals(\"a\", \"b\"); // non-compliant as the default comparison of string.Equals is Ordinal\n\n// Should be\nstring.Equals(\"a\", \"b\", StringComparison.Ordinal);\n```\n\n----------------------------------------\n\nTITLE: Use System.Threading.Lock - Non-compliant C#\nDESCRIPTION: This code snippet demonstrates a non-compliant usage where a private `object` is used as a lock.  The MA0158 analyzer suggests using `System.Threading.Lock` instead. Requires `System.Threading` namespace.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0158.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nusing System.Threading;\n\nclass MyClass\n{\n    private object _lock = new(); // non-compliant\n\n    public void MyMethod()\n    {\n        lock (_lock)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Throwing ArgumentNullException with nameof (C#)\nDESCRIPTION: This code snippet shows the compliant way to throw an ArgumentNullException. The nameof operator ensures that the argument name is correctly referenced, preventing potential errors during refactoring.  It requires the System namespace.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0043.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Sample(string s)\n{\n    if (s == null)\n        throw new ArgumentNullException(nameof(s)); // compliant\n}\n```\n\n----------------------------------------\n\nTITLE: HashSet Initialization without StringComparer (C#)\nDESCRIPTION: This snippet demonstrates initializing a HashSet<string> without explicitly specifying a StringComparer.  This can lead to unexpected behavior based on the default comparer.  The corrected example shows how to specify StringComparer.Ordinal for explicit ordinal comparison.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0002.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnew HashSet<string>()\n\n// Should be\nnew HashSet<string>(StringComparer.Ordinal)\n```\n\n----------------------------------------\n\nTITLE: Catch and Throw Exception in C#\nDESCRIPTION: This code snippet demonstrates how to properly re-throw an exception from a catch block in C#. The first `throw` statement is non-compliant as it doesn't embed the original exception as inner exception. The second `throw` statement is compliant because it includes the original exception (`ex`) as the inner exception.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0054.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ntry\n{\n\n}\ncatch(Exception ex)\n{\n    throw new Exception(\"Sample\"); // Non compliant\n    throw new Exception(\"Sample\", ex); // compliant\n}\n```\n\n----------------------------------------\n\nTITLE: Regex Initialization without Timeout in C#\nDESCRIPTION: Demonstrates non-compliant Regex initialization without specifying a timeout.  It shows that creating a Regex object without a timeout parameter or using `RegexOptions.None` is considered a potential ReDoS vulnerability. The example highlights the need to explicitly set timeouts using `TimeSpan` to avoid denial-of-service attacks.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0009.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnew Regex(\"\"); // not compliant\nnew Regex(\"\", RegexOptions.None); // notcompliant\n```\n\n----------------------------------------\n\nTITLE: Suggest Regex Source Generator C#\nDESCRIPTION: This code snippet demonstrates the MA0110 analyzer suggesting the use of the Regex Source Generator instead of directly constructing a Regex object with a constant pattern. It highlights the diagnostic report generated for the standard Regex constructor and shows the correct usage of the [GeneratedRegex] attribute.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0110.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nnew Regex(\"constant pattern\"); // report diagnostic\n\n// ok\n[GeneratedRegex(\"constant pattern\")]\nprivate static partial Regex MyRegex();\n```\n\n----------------------------------------\n\nTITLE: ConfigureAwait Usage Example C#\nDESCRIPTION: This code snippet demonstrates how to use ConfigureAwait(false) or ConfigureAwait(true) when awaiting a Task. ConfigureAwait(false) is generally preferred when the SynchronizationContext is not needed, while ConfigureAwait(true) is useful for maintaining the context in UI applications.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0004.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nawait task;\n\n// Should be\nawait task.ConfigureAwait(false);\n// or\nawait task.ConfigureAwait(true);\n```\n\n----------------------------------------\n\nTITLE: Disable Certificate Validation Callback in C#\nDESCRIPTION: This C# code snippet demonstrates setting the `ServerCertificateValidationCallback` or `ServerCertificateCustomValidationCallback` to a custom method. This practice is flagged as non-compliant because custom validation can easily be used to bypass crucial security checks, making the application vulnerable to man-in-the-middle attacks.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0039.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.Net.ServicePointManager.ServerCertificateValidationCallback = ... // non compliant\n\nvar handler = new System.Net.Http.HttpClientHandler();\nhandler.ServerCertificateCustomValidationCallback = ... // non compliant\n```\n\n----------------------------------------\n\nTITLE: String Inequality Comparison Using != in C#\nDESCRIPTION: This code snippet demonstrates the incorrect usage of the inequality operator `!=` for comparing strings. It emphasizes that `string.Equals` should be used with a negation to explicitly define the string comparison rules. It suggests using `StringComparison.Ordinal` for ordinal comparison.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0006.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n\"\" != \"\";\n\n// Should be\n!string.Equals(\"\", \"\", StringComparison.Ordinal);\n```\n\n----------------------------------------\n\nTITLE: Optimize StringBuilder: String Interpolation/Concatenation\nDESCRIPTION: This snippet demonstrates how to optimize StringBuilder usage by avoiding string interpolation and concatenation. Instead, the Append method should be used to add individual components to the StringBuilder.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0028.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnew StringBuilder().Append($\"a{10}\");\nnew StringBuilder().Append(\"a\" + 10);\n\n// Should be\nnew StringBuilder().Append(\"a\").Append(10);\n```\n\n----------------------------------------\n\nTITLE: Forward TimeProvider to Task.Delay - C#\nDESCRIPTION: This C# code demonstrates the MA0166 analyzer rule. It highlights the importance of forwarding a System.TimeProvider to the Task.Delay method when an overload that accepts it is available. The non-compliant example shows a call to Task.Delay without a TimeProvider, while the compliant example passes the TimeProvider.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0166.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Test\n{\n    public void A(System.TimeProvider timeProvider)\n    {\n        Task.Delay(default(TimeSpan)); // non-compliant\n        Task.Delay(default(TimeSpan), timeProvider); // compliant\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: MA0142 - Correct Null Check - C#\nDESCRIPTION: This code snippet demonstrates the compliant null check using pattern matching (is null). This is the recommended way to check for null values.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0142.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvalue is null; // ok\n```\n\n----------------------------------------\n\nTITLE: Detecting missing await before disposing - C#\nDESCRIPTION: This C# code demonstrates the MA0100 analyzer rule. The `Demo1` method returns a `Task` without awaiting it within the `using` statement, triggering the MA0100 warning. The `Demo2` method correctly awaits the `Task` before the `using` block exits, avoiding the warning. The analyzer helps ensure that asynchronous operations complete before the disposable resource is released.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0100.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing System.Threading.Tasks;\n\nclass TestClass\n{\n    Task Demo1()\n    {\n        using var scope = new Disposable();\n        return Task.Delay(1); // MA0100, you must await the task before disposing the scope\n    }\n\n    async Task Demo2()\n    {\n        using var scope = new Disposable();\n        return await Task.Delay(1); // ok\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Locking on 'this' instance in C#\nDESCRIPTION: This code snippet demonstrates locking on the 'this' instance, which is considered non-compliant because 'this' is a publicly accessible instance and locking on it can lead to external interference. The analyzer flags this as a violation of the MA0064 rule.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0064.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nlock(this) { } // non compliant\n```\n\n----------------------------------------\n\nTITLE: Culture-sensitive ToString usage C#\nDESCRIPTION: This code demonstrates examples of culture-sensitive ToString usage. The rule flags cases where an implicit call to `obj.ToString()` may differ based on the current culture. Using `CultureInfo.CurrentCulture` or `CultureInfo.InvariantCulture` makes the code compliant.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0075.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n_ = \"abc\" + -1; // non-compliant as the result depends on the current culture\n_ = \"abc\" + 1; // compliant\n\n_ = \"abc\" + -1.ToString(CultureInfo.CurrentCulture);   // compliant\n_ = \"abc\" + -1.ToString(CultureInfo.InvariantCulture); // compliant\n```\n\n----------------------------------------\n\nTITLE: ConcurrentDictionary GetOrAdd: Detect Closure (C#)\nDESCRIPTION: This code snippet demonstrates the MA0106 analyzer flagging a ConcurrentDictionary.GetOrAdd call that uses a lambda expression without the 'factoryArgument' overload, potentially leading to unnecessary closure allocation. The analyzer suggests using the overload that passes the 'value' directly to avoid the closure.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0106.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing System.Collections.Concurrent;\n\nvar key = 1;\nvar value = 1;\nvar dict = new ConcurrentDictionary<int, int>();\ndict.GetOrAdd(key, _ => value); // report diagnostic\n\ndict.GetOrAdd(key, (_, v) => v, value); // ok\n```\n\n----------------------------------------\n\nTITLE: Return Task.FromResult(null) C#\nDESCRIPTION: This code snippet shows the correct way to return a null value from a method that returns Task<T>. Using Task.FromResult(null) ensures that the caller receives a completed task that yields a null result. This is the recommended practice for handling null returns in asynchronous methods.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0022.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nTask<object> Sample()\n{\n    return Task.FromResult(null);\n}\n```\n\n----------------------------------------\n\nTITLE: Locking on Typeof or GetType() in C#\nDESCRIPTION: This code demonstrates locking on a Type object obtained via typeof or GetType(). Locking on Type objects is discouraged because these objects are publicly accessible, making the lock vulnerable to external interference and potential deadlocks. The analyzer flags this as a violation of the MA0064 rule.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0064.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nlock(typeof(Console)) { } // non compliant\n\nvar type = obj.GetType();\nlock (type) { } // non compliant\n```\n\n----------------------------------------\n\nTITLE: Optimize String Method Usage with Character Literals (C#)\nDESCRIPTION: This code demonstrates instances where string methods (StartsWith, EndsWith, Replace, IndexOf) are used with string literals instead of character literals. The analyzer suggests using character literals for improved performance. The code highlights both non-compliant and compliant examples.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0089.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstring str;\nstr.StartsWith(\"a\"); // non-compliant\nstr.StartsWith('a'); // ok\n\nstr.EndsWith(\"a\"); // non-compliant\nstr.EndsWith('a'); // ok\n\nstr.Replace(\"a\", \"b\"); // non-compliant\nstr.Replace('a', 'b'); // ok\n\nstr.IndexOf(\"a\", StringComparison.Ordinal); // non-compliant\nstr.IndexOf('a'); // ok\n```\n\n----------------------------------------\n\nTITLE: Rethrowing Exception Implicitly (Correct) C#\nDESCRIPTION: This code snippet demonstrates the correct way of rethrowing an exception implicitly (without specifying the exception object). This approach preserves the original stack trace, providing more context for debugging.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0027.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ntry\n{\n}\ncatch (Exception ex)\n{\n    throw;\n}\n```\n\n----------------------------------------\n\nTITLE: Forward CancellationToken using .WithCancellation() in C#\nDESCRIPTION: This code snippet demonstrates the MA0079 rule, which identifies cases where a CancellationToken is not being forwarded when iterating over an asynchronous enumerable. The first `await foreach` loop is non-compliant as it doesn't use `.WithCancellation()`, while the second one is compliant because it does, ensuring that the operation can be cancelled.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0079.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nCancellationToken cancellationToken;\nIAsyncEnumeration<string> enumerable;\nawait foreach (var item in enumerable) // not compliant\n{\n}\n\nawait foreach (var item in enumerable.WithCancellation(cancellationToken)) // compliant\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Missing Await in Using Statement C#\nDESCRIPTION: This code snippet demonstrates the MA0129 analyzer's detection of a `Task` being used in a `using` statement without awaiting it first.  The analyzer flags the non-compliant code where the `Task` `t` is directly used in the `using` statement. It suggests awaiting the task before using it to ensure proper disposal of the underlying resource.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0129.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nTask<IDisposable> t = ...;\nusing(t) { } // non-compliant\n\nusing(await t) { } // ok\n```\n\n----------------------------------------\n\nTITLE: Return Null Task Anti-Pattern C#\nDESCRIPTION: This code snippet demonstrates the anti-pattern of directly returning null from a method that is expected to return Task<T>. Returning null directly can lead to unexpected behavior and exceptions when the caller attempts to await the task. The analyzer detects this and suggests a fix.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0022.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nTask<object> Sample()\n{\n    return null;\n}\n```\n\n----------------------------------------\n\nTITLE: Dictionary Initialization without StringComparer (C#)\nDESCRIPTION: This snippet demonstrates initializing a Dictionary<string, int> without explicitly specifying a StringComparer. It can lead to unexpected behavior based on the default comparer. The corrected example shows how to specify StringComparer.Ordinal for explicit ordinal comparison.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0002.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nnew Dictionary<string, int>()\n\n// Should be\nnew Dictionary<string, int>(StringComparer.Ordinal)\n```\n\n----------------------------------------\n\nTITLE: Use Unwrap instead of await twice in C#\nDESCRIPTION: This code snippet demonstrates the MA0152 analyzer suggestion. It shows a non-compliant example using `await await` and a compliant example using `Unwrap` to achieve the same result. The `Unwrap` method simplifies the code and potentially improves performance.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0152.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nTask<Task> t;\nawait await t; // non-compliant\n\nawait t.Unwrap(); // compliant\n```\n\n----------------------------------------\n\nTITLE: DateTime.TryParse Usage without IFormatProvider (C#)\nDESCRIPTION: This code snippet demonstrates the usage of `DateTime.TryParse` without providing an `IFormatProvider`. The analyzer flags this as non-compliant because it can lead to culture-specific parsing issues. The compliant version includes `CultureInfo.InvariantCulture` and `DateTimeStyles.None` to ensure consistent parsing.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0011.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nDateTime.TryParse(\"\", out var result);\n\n// Should be\nDateTime.TryParse(\"\", CultureInfo.InvariantCulture, DateTimeStyles.None, out var result);\n```\n\n----------------------------------------\n\nTITLE: ConcurrentDictionary Initialization without StringComparer (C#)\nDESCRIPTION: This snippet demonstrates initializing a ConcurrentDictionary<string, int> without explicitly specifying a StringComparer. This can lead to unexpected behavior based on the default comparer. The corrected example shows how to specify StringComparer.Ordinal for explicit ordinal comparison.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0002.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nnew ConcurrentDictionary<string, int>()\n\n// Should be\nnew ConcurrentDictionary<string, int>(StringComparer.Ordinal)\n```\n\n----------------------------------------\n\nTITLE: String StartsWith Method - Culture-Sensitive Example in C#\nDESCRIPTION: This code snippet demonstrates a non-compliant usage of the `StartsWith` method in C#, where the default culture-sensitive string comparison is used. It is recommended to use an explicit `StringComparison` overload for better clarity and predictability.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0074.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n\"a\".StartsWith(\"b\"); // non-compliant as the default comparison of StartsWith is CurrentCulture\n\n// Should be\n\"a\".StartsWith(\"b\", StringComparison.Ordinal);\n```\n\n----------------------------------------\n\nTITLE: Throwing Exception in Finally Block - C#\nDESCRIPTION: This C# code snippet demonstrates the anti-pattern of throwing an exception within a finally block.  The exception thrown in the finally block will prevent the original exception thrown in the try block from being caught by the calling method. This makes it harder to debug the code and can lead to unexpected behavior.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0072.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ntry\n{\n    // The parent method won't be able to catch this exception\n    throw new Exception(\"Original Exception\");\n}\nfinally\n{\n    // The parent method will only get this exception\n    throw new Exception(\"Finally Exception\");\n}\n```\n\n----------------------------------------\n\nTITLE: Stream.Read Return Value - Non-compliant C#\nDESCRIPTION: Illustrates a non-compliant usage of `Stream.Read` where the returned value (number of bytes read) is ignored. This can cause issues if fewer bytes than requested are read from the stream. The `stream` object is opened using `File.OpenRead` on \"file.txt\".\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0060.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Test\n{\n    void A()\n    {\n        var stream = File.OpenRead(\"file.txt\");\n        var bytes = new byte[10];\n        stream.Read(bytes, 0, bytes.Length); // Non-compliant\n\n        var read = stream.Read(bytes, 0, bytes.Length); // ok\n        var data = bytes.AsSpan(0, read);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Redundant Else Block - Non-compliant C#\nDESCRIPTION: This C# code snippet demonstrates a non-compliant case where an `else` block is redundant because the preceding `if` block contains a `return` statement. The `else` block adds unnecessary nesting.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0071.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nif (i < 0)\n{\n    return -1;\n}\nelse\n{\n    if (i == 0)\n    {\n        return 0;\n    }\n    else\n    {\n        return 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: LINQ Distinct without StringComparer (C#)\nDESCRIPTION: This snippet demonstrates using the LINQ Distinct method on an IEnumerable<string> without explicitly specifying a StringComparer. This can lead to unexpected behavior based on the default comparer. The corrected example shows how to specify StringComparer.Ordinal for explicit ordinal comparison.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0002.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nIEnumerable<string> list;\nlist.Distinct();\n\n// Should be\nlist.Distinct(StringComparer.Ordinal);\n```\n\n----------------------------------------\n\nTITLE: Null Check with Pattern Matching (Compliant) C#\nDESCRIPTION: This code snippet demonstrates the compliant way of checking for null values using pattern matching (is not null). This approach is preferred by the analyzer.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0141.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nvalue is not null; // ok\n```\n\n----------------------------------------\n\nTITLE: String Comparison with String.Equals in C#\nDESCRIPTION: This code snippet demonstrates the MA0127 analyzer rule by showing an example of using 'is' pattern matching for string comparison and the recommended alternative using `string.Equals` for explicit comparison. The `string.Equals` method allows specifying the comparison type, such as `StringComparison.Ordinal`, leading to more robust and predictable code.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0127.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n_ str = is \"foo\";\n\n// Should be\nstring.Equals(str, foo, StringComparison.Ordinal);\n```\n\n----------------------------------------\n\nTITLE: Combine LINQ methods in C#\nDESCRIPTION: This C# code snippet demonstrates a case where LINQ methods can be combined. The initial code uses `Where` followed by `Any`, which can be simplified to a single `Any` call with a predicate, improving readability and potentially performance. The rule MA0029 identifies and suggests this optimization.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0029.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnew int[0].Where(x => true).Any();\n\n// Should be\nnew int[0].Any(x => true);\n```\n\n----------------------------------------\n\nTITLE: Use Order instead of OrderBy - Non-compliant C#\nDESCRIPTION: This code snippet demonstrates the non-compliant usage of `OrderBy(n => n)` to order a collection of integers. The analyzer suggests using `Order()` instead for better readability and performance.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0159.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nIEnumerable<int> numbers = [1, 2];\nvar orderedNumbers = numbers.OrderBy(n => n); // non-compliant\n```\n\n----------------------------------------\n\nTITLE: Non-compliant code: Boolean comparison with constant in C#\nDESCRIPTION: This code snippet demonstrates a non-compliant example where a boolean variable is compared to a boolean constant. The analyzer suggests avoiding this direct comparison for better readability and conciseness. The code defines a boolean constant `MyConstant`, a boolean variable `value`, and then compares the variable to the constant in an `if` statement.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0073.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nconst bool MyConstant = false;\nbool value = GetSomeValue();\n\nif (value == MyConstant)\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Forward CancellationToken Parameter - C#\nDESCRIPTION: This code demonstrates the MA0040 rule. It shows a non-compliant case where a method accepting a CancellationToken is called without passing one, and a compliant case where the CancellationToken is correctly passed. The rule applies when a CancellationToken is already in scope.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0040.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Test\n{\n    public void A(CancellationToken cancellationToken)\n    {\n        MethodWithCancellationToken(); // non compliant\n        MethodWithCancellationToken(cancellationToken); // compliant\n    }\n\n    public void MethodWithCancellationToken() => throw null;\n    public void MethodWithCancellationToken(System.Threading.CancellationToken cancellationToken) => throw null;\n}\n```\n\n----------------------------------------\n\nTITLE: Regex Initialization with Timeout in C#\nDESCRIPTION: Illustrates compliant Regex initialization with an explicit timeout using `TimeSpan`. By providing a `TimeSpan` value, the Regex engine will halt execution after the specified duration, mitigating potential ReDoS attacks. This example showcases the recommended approach for Regex instantiation.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0009.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nnew Regex(\"\", RegexOptions.None, TimeSpan.FromSeconds(1)); // ok\n```\n\n----------------------------------------\n\nTITLE: ArgumentNullException.ThrowIfNull Usage Example in C#\nDESCRIPTION: This code demonstrates the correct and incorrect usage of `ArgumentNullException.ThrowIfNull` in C#. It highlights that the method should not be used with non-nullable value types like `int`, as they cannot be null, and shows its correct usage with reference types like `string`.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0131.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvoid Sample(int value, string str)\n{\n    ArgumentNullException.ThrowIfNull(value); // non-compliant as int is not nullable\n    ArgumentNullException.ThrowIfNull(str); // ok as string is a reference type\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting JSRuntime usage in OnInitialized methods in Blazor C#\nDESCRIPTION: This C# code snippet showcases a Blazor component with incorrect usage of IJSRuntime within the OnInitialized and OnInitializedAsync lifecycle methods, which triggers the MA0119 analyzer.  It demonstrates that JSRuntime operations are only valid in other methods, not the mentioned lifecycle hooks. The analyzer will raise errors in the non-compliant cases, while usage in `OtherMethod` is valid.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0119.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Components;\nusing Microsoft.JSInterop;\n\nclass MyComponent : ComponentBase\n{\n    public IJSRuntime JS { get; set; }\n    \n    protected override void OnInitialized()\n    {\n        _ = JS.InvokeVoidAsync(\"dummy\"); // non-compliant\n    }\n\n    protected override async Task OnInitializedAsync()\n    {\n        await JS.InvokeVoidAsync(\"dummy\");  // non-compliant\n    }\n\n    private async Task OtherMethod()\n    {\n        await JS.InvokeVoidAsync(\"dummy\");  // ok\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: MA0113 - Suggest DateTime.UnixEpoch (C#)\nDESCRIPTION: This code snippet demonstrates the MA0113 analyzer detecting the manual instantiation of a `DateTime` object with the Unix epoch value and suggesting the use of `DateTime.UnixEpoch` instead. The first line triggers the diagnostic, while the second line shows the corrected usage.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0113.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\n_ = new DateTime(1970, 1, 1); // report diagnostic\n\n_ = DateTime.UnixEpoch; // ok\n```\n\n----------------------------------------\n\nTITLE: Optimize Enumerable.Count() C#\nDESCRIPTION: This code snippet demonstrates the MA0031 analyzer's suggestion to replace `enumerable.Count() > 10` with `enumerable.Skip(10).Any()` for improved performance when checking if a collection contains more than a certain number of elements. The `Skip` and `Any` method avoids iterating the entire collection.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0031.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nenumerable.Count() > 10;\n\n// Should be\nenumerable.Skip(10).Any();\n```\n\n----------------------------------------\n\nTITLE: Throwing ArgumentException without Parameter Name (C#)\nDESCRIPTION: This code snippet demonstrates how to throw an ArgumentException without specifying the parameter name. This is considered non-compliant because it reduces code clarity.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0015.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvoid Sample(string str)\n{\n    if (str == \"\")\n        throw new ArgumentException(\"Error message\"); // non-compliant\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrate Culture-Sensitive ToString Usage in C#\nDESCRIPTION: This code snippet demonstrates the MA0107 analyzer rule by showing a non-compliant usage of `ToString()` and two compliant alternatives using `string.Format` and `FormattableString` with `CultureInfo.Invariant` to ensure culture-invariant formatting.  The variable `a` of type `object` is used to trigger the analyzer when its `ToString()` method is called directly.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0107.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nobject a = 10;\n_ = a.ToString(); // not-compliant\n_ = string.Format(CultureInfo.Invariant, \"{0}\", a); // compliant\n_ = FormattableString.Invariant($\"{a}\"); // compliant\n```\n\n----------------------------------------\n\nTITLE: Iterate IAsyncEnumeration without Cancellation Token (C#)\nDESCRIPTION: This code snippet demonstrates iterating through an IAsyncEnumeration without using a cancellation token.  This can lead to issues where the enumeration cannot be stopped gracefully. The `enumerable` variable represents an `IAsyncEnumeration<string>` object that is being iterated over. Using `.WithCancellation()` improves the code.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0080.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nIAsyncEnumeration<string> enumerable;\nawait foreach (var item in enumerable) // not compliant\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Optimize StringBuilder: String Formatting\nDESCRIPTION: This snippet demonstrates how to optimize StringBuilder usage when formatting numbers. Instead of using ToString with a specific format and culture, AppendFormat should be used for better performance and maintainability.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0028.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nnew StringBuilder().Append(10.ToString(\"n1\", CultureInfo.CurrentCulture));\n\n// Should be\nnew StringBuilder().AppendFormat(CultureInfo.CurrentCulture, \"{0:n1}\", 10);\n```\n\n----------------------------------------\n\nTITLE: MA0112 Diagnostic Report (C#)\nDESCRIPTION: This code snippet demonstrates the diagnostic reported by MA0112. It flags the use of `collection.Any()` and suggests using `collection.Count > 0` instead. No dependencies are required to understand the issue.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0112.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvar collection = new int[10];\nif(collection.Any()) { } // report diagnostic\n\nif(collection.Count > 0) { } // ok\n```\n\n----------------------------------------\n\nTITLE: Async Method Suffix: Non-Compliant Example (C#)\nDESCRIPTION: This C# code snippet demonstrates a non-compliant example where a method returning a Task does not have the 'Async' suffix. The MA0137 analyzer rule flags this as an issue, suggesting the addition of the 'Async' suffix for clarity.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0137.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\n// non-compliant\nTask Foo() => Task.CompletedTask;\n```\n\n----------------------------------------\n\nTITLE: DateTime.ToString Usage without IFormatProvider (C#)\nDESCRIPTION: This code snippet shows the usage of `DateTime.ToString` without specifying an `IFormatProvider`. This is flagged as non-compliant. Using a culture-invariant format like \"o\" resolves the issue.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0011.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nDateTime dt;\n\ndt.ToString();    // non-compliant\ndt.ToString(\"o\"); // ok as \"o\" is a culture invariant format\n```\n\n----------------------------------------\n\nTITLE: CancellationToken Usage Example C#\nDESCRIPTION: This example demonstrates the MA0032 analyzer's behavior when a method has a CancellationToken overload. The analyzer flags the call without a CancellationToken as non-compliant.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0032.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Test\n{\n    public void A(CancellationToken cancellationToken)\n    {\n        MethodWithCancellationToken(); // non compliant\n        MethodWithCancellationToken(cancellationToken); // compliant\n    }\n\n    public void MethodWithCancellationToken() => throw null;\n    public void MethodWithCancellationToken(System.Threading.CancellationToken cancellationToken) => throw null;\n}\n```\n\n----------------------------------------\n\nTITLE: Use Explicit StringComparer in C#\nDESCRIPTION: This C# code snippet demonstrates the MA0024 analyzer rule, highlighting the importance of using an explicit StringComparer when comparing strings. It shows an example of using EqualityComparer<string>.Default.Equals and suggests replacing it with StringComparer.Ordinal.Equals for better clarity and control over the comparison.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0024.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nEqualityComparer<string>.Default.Equals(\"a\", \"b\");\n\n// Should be\nStringComparer.Ordinal.Equals(\"a\", \"b\");\n```\n\n----------------------------------------\n\nTITLE: MA0056 - Detect Virtual Method Calls in Constructor (C#)\nDESCRIPTION: This code demonstrates the MA0056 analyzer rule.  It highlights a scenario where a virtual method, `VirtualMethod`, is called from the constructor of the `Sample` class. Because `Sample2` inherits from `Sample` and overrides `VirtualMethod`, when a `Sample2` object is created, the `VirtualMethod` called from `Sample`'s constructor will execute `Sample2`'s version before `Sample2`'s constructor has fully initialized, leading to potential issues.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0056.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Sample\n{\n    public Sample()\n    {\n        // What does it do?\n        // new Sample2() prints \"0\"\n        VirtualMethod(); // Non compliant\n    }\n\n    protected virtual void VirtualMethod()\n    {\n    }\n}\n\nclass Sample2 : Sample\n{\n    private int value;\n\n    public Sample2() => value = 42;\n\n    protected override void VirtualMethod()\n    {\n        Console.WriteLine(value);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: MA0005: Suggest Array.Empty<T>() in C#\nDESCRIPTION: This snippet demonstrates the MA0005 analyzer recommendation to replace `new T[0]` with `Array.Empty<T>()` in C# code to prevent unnecessary memory allocation. `Array.Empty<T>()` returns a cached empty array instance, while `new T[0]` always creates a new one. The analyzer helps improve performance by suggesting the more efficient alternative.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0005.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnew int[0];\n\n// Should be\nArray.Empty<int>();\n```\n\n----------------------------------------\n\nTITLE: Check OS using OperatingSystem vs RuntimeInformation in C#\nDESCRIPTION: This code snippet demonstrates the difference between using `RuntimeInformation.IsOSPlatform` and `OperatingSystem.IsWindows()` for checking if the current operating system is Windows. The latter is the preferred method according to analyzer MA0144.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0144.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nRuntimeInformation.IsOSPlatform(OSPlatform.Windows); // non-compliant\n\nOperatingSystem.IsWindows(); // ok\n```\n\n----------------------------------------\n\nTITLE: Use DateTimeOffset.UnixEpoch in C#\nDESCRIPTION: This C# code snippet demonstrates the diagnostic triggered by the MA0114 analyzer. It flags the explicit creation of a `DateTimeOffset` with Unix epoch values (1970, 1, 1) and suggests using `DateTimeOffset.UnixEpoch` instead. The second line shows the recommended approach.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0114.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\n_ = new DateTimeOffset(1970, 1, 1, 0, 0, 0, TimeSpan.Zero); // report diagnostic\n\n_ = DateTimeOffset.UnixEpoch; // ok\n```\n\n----------------------------------------\n\nTITLE: Illustrating `not` pattern with `or` without parentheses in C#\nDESCRIPTION: This snippet demonstrates the issue where the absence of parentheses with the `not` pattern and `or` operator can lead to ambiguity and potentially incorrect evaluation. The rule suggests using parentheses to make the evaluation order clear. It also provides an example using `and` which is acceptable without parens.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0164.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nDayOfWeek day = DayOfWeek.Tuesday;\n\nvar isWeekday = day is not DayOfWeek.Saturday or DayOfWeek.Sunday;      // wrong\nvar isWeekday = day is not (DayOfWeek.Saturday or DayOfWeek.Sunday);    // ok\nvar isWeekday = day is not DayOfWeek.Saturday and not DayOfWeek.Sunday; // ok\n```\n\n----------------------------------------\n\nTITLE: Detecting Blocking Calls in Synchronous Method (C#)\nDESCRIPTION: This code snippet demonstrates how blocking calls such as `Thread.Sleep`, `Task.Delay(...).Wait()`, and accessing `Task.Result` are flagged as non-compliant within a synchronous method. The analyzer suggests replacing these with asynchronous equivalents to avoid blocking the thread.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0045.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic void Sample()\n{\n    Thread.Sleep(1); // Non compliant\n    Task.Delay(1).Wait(); // non compliant\n\n    var result = Task.Run(() => 10).Result; // non compliant\n}\n```\n\n----------------------------------------\n\nTITLE: Use 'is' operator instead of SequenceEqual - C#\nDESCRIPTION: This C# code snippet demonstrates the MA0128 analyzer's suggestion to use the 'is' operator instead of `SequenceEqual` or `Equals` when comparing a `ReadOnlySpan<char>` to a constant string. It highlights cases where the analyzer reports a diagnostic and suggests the alternative.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0128.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nReadOnlySpan<char> span = \"foo\";\n\n_ = span.Equals(\"bar\", StringComparison.Ordinal); // report diagnostic\n_ = span is \"bar\";\n\n_ = span.SequenceEqual(\"bar\"); // report diagnostic\n_ = span is \"bar\";\n```\n\n----------------------------------------\n\nTITLE: MA0142 - Incorrect Null Check - C#\nDESCRIPTION: This code snippet demonstrates a non-compliant null check using the equality operator (==). The analyzer suggests using pattern matching instead.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0142.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvalue == null; // not compliant\n```\n\n----------------------------------------\n\nTITLE: MA0133 - Suggest DateTimeOffset (C#)\nDESCRIPTION: This code snippet demonstrates the MA0133 analyzer's suggestion to use DateTimeOffset.UtcNow or DateTimeOffset.Now instead of DateTime.UtcNow or DateTime.Now to prevent implicit conversions. The non-compliant code shows the implicit conversion, while the compliant code uses DateTimeOffset directly.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0133.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nSample(DateTime.UtcNow); // non-compliant\n\nSample(DateTimeOffset.UtcNow); // ok\n\nvoid Sample(DateTimeOffset datetime) { }\n```\n\n----------------------------------------\n\nTITLE: Rethrowing Exception Explicitly (Incorrect) C#\nDESCRIPTION: This code snippet demonstrates the incorrect way of rethrowing an exception by explicitly specifying the exception object. This approach replaces the original stack trace with a new one, making debugging more difficult.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0027.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ntry\n{\n}\ncatch (Exception ex)\n{\n    throw ex;\n}\n```\n\n----------------------------------------\n\nTITLE: Task.Delay without TimeProvider - C#\nDESCRIPTION: This code snippet demonstrates a non-compliant usage of Task.Delay. It lacks a TimeProvider argument, which makes it harder to test the time-dependent behavior. The analyzer suggests using an overload that accepts a TimeProvider to enable better testability.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0167.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Test\n{\n    public void A()\n    {\n        Task.Delay(default(TimeSpan)); // non-compliant\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: GeneratedRegex without Timeout in C#\nDESCRIPTION: Shows a non-compliant `GeneratedRegex` attribute without specifying a timeout. This indicates a potential ReDoS vulnerability as the generated Regex pattern lacks an execution time constraint. The analyzer flags these instances as needing an explicit timeout to improve security.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0009.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[GeneratedRegex(\"\"pattern\"\", RegexOptions.None)] // not compliant\nprivate static partial Regex Test();\n```\n\n----------------------------------------\n\nTITLE: Async Method Signature Considerations - C#\nDESCRIPTION: These code snippets illustrate how the analyzer rule applies based on the method signature. If `async` can be added without changing the return type (e.g., changing `Task` to `async Task`), the rule flags blocking calls.  If adding `async` would require changing the return type (e.g., `int` to `Task<int>`), the rule does not report a diagnostic.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0042.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic Task Sample()\n{\n    Thread.Sleep(1); // Non compliant, as you can add \"async\" to the signature without changing the return type\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic int Sample()\n{\n    Thread.Sleep(1); // compliant, as you cannot add \"async\" to the signature without changing the return type\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: MA0004 Configuration (.editorconfig)\nDESCRIPTION: This code snippet shows how to configure the MA0004 analyzer rule in an .editorconfig file. It allows you to control whether to report missing ConfigureAwait based on context detection or to always report it.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0004.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[.*cs]\nMA0004.report = DetectContext # (default) Try to detect the current context and report only if it considers ConfigureAwait is needed\nMA0004.report = Always        # Always report missing ConfigureAwait whatever the context\n```\n\n----------------------------------------\n\nTITLE: Configure MA0107 Analyzer - Exclude ToString Methods\nDESCRIPTION: This configuration snippet shows how to exclude `ToString` methods from the MA0107 analysis by setting the `MA0107.exclude_tostring_methods` option to `true`. This disables the rule for all `ToString` method calls within the project.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0107.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n# Exclude ToString methods from analysis\nMA0107.exclude_tostring_methods=true\n```\n\n----------------------------------------\n\nTITLE: Detecting public constructors in abstract classes in C#\nDESCRIPTION: This C# code snippet demonstrates an abstract class with a public constructor, which is flagged as non-compliant by the analyzer. Abstract classes should not have public constructors because they cannot be directly instantiated. The analyzer suggests using protected constructors instead.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0017.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nabstract class Sample\n{\n    public Sample() // non-compliant\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Use StringComparer.GetHashCode instead of string.GetHashCode - C#\nDESCRIPTION: This code snippet demonstrates the MA0021 analyzer suggestion. It shows the incorrect usage of `\"\".GetHashCode()` and the recommended alternative using `StringComparer.Ordinal.GetHashCode(\"\")`. The `StringComparer` approach ensures consistency and avoids potential culture-specific variations in hash code generation.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0021.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n\"\".GetHashCode();\n\n// Should be\nStringComparer.Ordinal.GetHashCode(\"\");\n```\n\n----------------------------------------\n\nTITLE: Casting with Select (Non-compliant) C#\nDESCRIPTION: This code snippet demonstrates the non-compliant way of casting elements using the 'Select' method in C#. It iterates through the 'strings' collection and casts each element to an object.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0078.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.Linq.Enumerable<string> strings = GetStrings();\nvar stringsAsObjects = strings.Select(str => (object)str);\n```\n\n----------------------------------------\n\nTITLE: MA0105 - Detect closure usage with ConcurrentDictionary (C#)\nDESCRIPTION: This code snippet demonstrates the MA0105 analyzer's detection of closure usage with ConcurrentDictionary. It highlights the case where a closure is used (accessing the 'key' variable directly in the lambda) and suggests using the lambda parameter instead.  The `ConcurrentDictionary` class is from the `System.Collections.Concurrent` namespace. The analyzer triggers on the first `GetOrAdd` call because it uses the external variable `key` within the lambda expression, creating a closure.  It approves the second `GetOrAdd` because the lambda parameter `k` is used instead of capturing the `key` variable.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0105.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvar key = 1;\nvar dict = new ConcurrentDictionary<int, string>();\ndict.GetOrAdd(key, _ => $\"{key}\"); // report diagnostic\n\ndict.GetOrAdd(key, k => $\"{k}\"); // ok\n```\n\n----------------------------------------\n\nTITLE: Defining Attribute with AttributeUsageAttribute C#\nDESCRIPTION: This code snippet demonstrates the correct usage of `AttributeUsageAttribute` when defining a custom attribute.  Here, `SampleAttribute` is decorated with `[System.AttributeUsage(System.AttributeTargets.Parameter)]`, indicating that it can only be applied to parameters. This provides clarity and prevents unintended usage.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0010.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\n// ok\n[System.AttributeUsage(System.AttributeTargets.Parameter)]\nclass SampleAttribute : System.Attribute { }\n```\n\n----------------------------------------\n\nTITLE: MA0103 - Non-compliant: Equality operator for Span<char>\nDESCRIPTION: This code snippet demonstrates a non-compliant usage of the equality operator (==) to compare two Span<char> instances. The analyzer suggests using SequenceEqual for value comparison.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0103.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing System;\n\n\"\".AsSpan() == \"\".AsSpan(); // non-compliant\n```\n\n----------------------------------------\n\nTITLE: Sealed Class Compliant and Non-Compliant Examples (C#)\nDESCRIPTION: Illustrates examples of compliant (implicitly sealed) and non-compliant (inheritable) classes according to the MA0053 analyzer.  The analyzer suggests adding the 'sealed' keyword to classes that are not inherited from.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0053.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Foo // compliant\n{\n}\n\npublic class Bar : Foo // Non compliant\n{\n}\n\n// Should be\npublic sealed class Bar : Foo\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Null Check with Inequality Operator (Non-compliant) C#\nDESCRIPTION: This code snippet demonstrates a non-compliant way of checking for null values using the inequality operator (!=). The analyzer suggests using pattern matching instead.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0141.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvalue != null; // not compliant\n```\n\n----------------------------------------\n\nTITLE: MA0103 - Compliant: SequenceEqual for Span<char>\nDESCRIPTION: This code snippet demonstrates the correct way to compare two Span<char> instances using SequenceEqual. This method performs a value comparison of the spans.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0103.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nusing System;\n\n\"\".AsSpan().SequenceEqual(\"\".AsSpan());\n```\n\n----------------------------------------\n\nTITLE: Observe Async Call Result in C#\nDESCRIPTION: This code snippet demonstrates the MA0134 analyzer's functionality. It flags the `Task.Delay(1)` call as non-compliant because its result is not observed. The `Task.Delay(1).Wait()` and `_ = Task.Delay(1)` lines are compliant because they explicitly observe the result of the async operation.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0134.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvoid Sample()\n{\n    Task.Delay(1); // non-compliant\n\n    Task.Delay(1).Wait(); // ok\n    _ = Task.Delay(1);    // ok\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Async Void Methods (C#)\nDESCRIPTION: This code snippet demonstrates the analyzer rule MA0155. The first example shows a non-compliant async void method. The second example demonstrates the correct usage of async Task instead of async void.  The analyzer is designed to flag the first example and encourage the use of the second.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0155.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\n// not-compliant\nasync void SomeMethod()\n{\n    await Task.Delay(1000);\n}\n\n// ok\nasync Task SomeMethod()\n{\n    await Task.Delay(1000);\n}\n```\n\n----------------------------------------\n\nTITLE: Use System.Threading.Lock - Compliant C#\nDESCRIPTION: This code snippet demonstrates a compliant usage where `System.Threading.Lock` is used as a lock instead of `object`.  This resolves the MA0158 analyzer warning. Requires `System.Threading` namespace and .NET 9 / C# 13 or later.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0158.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nusing System.Threading;\n\nclass MyClass\n{\n    private Lock _lock = new(); // ok\n\n    public void MyMethod()\n    {\n        lock (_lock)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: MA0019 - Use EventArgs.Empty in C#\nDESCRIPTION: This code snippet demonstrates the MA0019 analyzer rule that suggests using EventArgs.Empty instead of creating new EventArgs instances. The non-compliant example shows creating a new EventArgs object, while the compliant example uses EventArgs.Empty for better performance and memory usage. This rule aims to improve the efficiency of event handling in C# code.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0019.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMyEvent(this, new EventArgs()); // non-compliant\n\nMyEvent(this, EventArgs.Empty); // ok\n```\n\n----------------------------------------\n\nTITLE: Using EventHandler<T> for Event Declaration (C#)\nDESCRIPTION: This code snippet illustrates the MA0046 analyzer rule, showcasing both non-compliant and compliant event declarations using `EventHandler<T>`. The goal is to use `EventHandler<EventArgs>` or a derivative for proper event handling.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0046.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nevent Action<object, EventArgs> Foo; // non compliant\nevent EventHandler<EventArgs> Foo; // compliant\n```\n\n----------------------------------------\n\nTITLE: MA0099 - Detect implicit zero value enum assignments - C#\nDESCRIPTION: This C# code snippet demonstrates the MA0099 analyzer's functionality. It shows an enum `MyEnum` and a class `Test` with a method `A`. The analyzer identifies the line `MyEnum a = 0;` as a violation because it uses the implicit value 0 instead of the explicit enum member `MyEnum.A`. The other lines demonstrate correct usage by casting or using enum members.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0099.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nenum MyEnum { A = 0, B = 1 }\n\nclass Test\n{\n    void A()\n    {\n        MyEnum a = 0; // Report diagnostic\n        MyEnum b = (MyEnum)0;\n        MyEnum c = MyEnum.A;\n        MyEnum d = MyEnum.B;\n        long e = 0;\n        long f = (long)0;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Logger Parameter Types - C# Attribute\nDESCRIPTION: This C# code snippet demonstrates how to use the `StructuredLogField` attribute to define the allowed types for parameters in Serilog logging statements.  It requires the `Meziantou.Analyzer.Annotations` package. The attribute is applied at the assembly level and specifies the parameter name and its allowed types.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0139.md#_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\n// Requires the Meziantou.Analyzer.Annotations package\n[assembly: Meziantou.Analyzer.Annotations.StructuredLogField(\"Count\", typeof(int), typeof(long))]\n```\n\n----------------------------------------\n\nTITLE: GeneratedRegex with Timeout in C#\nDESCRIPTION: Demonstrates a compliant `GeneratedRegex` attribute with an explicit timeout specified using the `matchTimeoutMilliseconds` parameter. The `matchTimeoutMilliseconds` parameter ensures that the regex engine will halt execution after the specified milliseconds duration.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0009.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[GeneratedRegex(\"\"pattern\"\", RegexOptions.None, matchTimeoutMilliseconds: 1000)] // ok compliant\nprivate static partial Regex Test();\n```\n\n----------------------------------------\n\nTITLE: Collection Abstraction Usage - C#\nDESCRIPTION: This C# code demonstrates the MA0016 analyzer rule. The first property `Prop` uses a concrete implementation `List<string>` which is flagged as non-compliant. The second property `Prop` uses the `IList<string>` interface, which is considered compliant. Similarly, the `Method` parameter using `Dictionary<string, string>` is non-compliant.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0016.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npublic List<string> Prop { get; set; } // non-compliant\npublic IList<string> Prop { get; set; } // ok\n\npublic void Method(Dictionary<string, string> arg) {} // non-compliant\n```\n\n----------------------------------------\n\nTITLE: Finalizer Usage Example C#\nDESCRIPTION: This code snippet demonstrates a non-compliant usage of a finalizer in a C# class. Finalizers should be avoided in most cases and SafeHandle should be used instead to manage native resources. The class 'Sample' contains a destructor that is triggered by the garbage collector.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0055.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Sample\n{\n    ~Sample() // Non compliant\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Detect Culture-Sensitive ToString Usage C#\nDESCRIPTION: This code snippet demonstrates how implicit culture-sensitive `ToString` methods are used in interpolated strings, which can lead to unexpected behavior depending on the current culture. It also shows compliant alternatives using `FormattableString.Invariant` and `string.Create` with `CultureInfo.InvariantCulture`.  The code highlights cases that are compliant, as well as those that will generate warning MA0111.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0076.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n_ = $\"abc{-1}\"; // non-compliant as the result depends on the current culture\n\n_ = FormattableString.Invariant($\"abc{-1}\"); // compliant but will generate MA0111\n_ = string.Create(CultureInfo.InvariantCulture, $\"abc{-1}\"); // compliant\nFormattableString str = $\"abc{-1}\"; // compliant\n```\n\n----------------------------------------\n\nTITLE: C# Initializer With Trailing Comma\nDESCRIPTION: This code snippet shows the corrected version of the previous example, where a trailing comma is added after the last property assignment in the C# initializer. This satisfies the MA0007 rule.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0007.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nnew Sample\n{\n    A = 0,\n    B = 1,\n};\n```\n\n----------------------------------------\n\nTITLE: MA0081 - Method override missing params keyword in C#\nDESCRIPTION: This C# code demonstrates the MA0081 analyzer rule. The base class method uses the `params` keyword, but the derived class override omits it, which triggers the analyzer. The fix is to include the `params` keyword in the override.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0081.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Base\n{\n  public virtual void Method(params int[] numbers) => { };\n}\n\nclass Derived : Base\n{\n  public override void Method(int[] numbers) // non-compliant: \"params\" is missing\n  {\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrate non-compliant Obsolete attribute usage (C#)\nDESCRIPTION: This snippet shows a non-compliant usage of the `Obsolete` attribute, as it does not include an explanation string. The analyzer MA0070 will flag this as an issue.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0070.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[Obsolete] // non-compliant\nvoid A() {}\n```\n\n----------------------------------------\n\nTITLE: Flag Instance Fields with ThreadStaticAttribute (C#)\nDESCRIPTION: This code snippet demonstrates the MA0033 analyzer's functionality, flagging an instance field (``_field``) incorrectly tagged with the ``ThreadStaticAttribute``. The corrected code shows the proper usage of the attribute with a static field.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0033.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[ThreadStatic]\nprivate string _field;\n\n// Should be\n[ThreadStatic]\nprivate static string _field;\n```\n\n----------------------------------------\n\nTITLE: Using protected constructors in abstract classes in C#\nDESCRIPTION: This C# code snippet shows an abstract class with a protected constructor, which is considered compliant. Protected constructors are acceptable in abstract classes because they can be called by derived classes, allowing for proper initialization of the base class without enabling direct instantiation of the abstract class itself.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0017.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nabstract class Sample\n{\n    protected Sample() // ok\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: MA0092 - Sender should be 'null' for static events in C#\nDESCRIPTION: This C# code snippet demonstrates the MA0092 analyzer rule, which enforces that static events should be invoked with a 'null' sender. The example shows both a non-compliant invocation (using 'this' as the sender) and a compliant invocation (using 'null' as the sender).\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0092.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing System;\nclass Test\n{\n    public static event EventHandler MyEvent;\n\n    void OnEvent()\n    {\n        MyEvent.Invoke(this, EventArgs.Empty); // non-compliant\n        MyEvent.Invoke(null, EventArgs.Empty); // ok\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: MA0044: Non-compliant ToString() usage in C#\nDESCRIPTION: This code snippet demonstrates a non-compliant usage of `ToString()` on a string variable. The analyzer will flag this line and suggest removing the `.ToString()` call as it is redundant and has no effect.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0044.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar str = \"abc\";\nConsole.Write(str.ToString()); // non compliant\n```\n\n----------------------------------------\n\nTITLE: MA0093 - EventArgs should not be null in C#\nDESCRIPTION: This code snippet demonstrates the MA0093 analyzer rule. It shows an event being invoked with null EventArgs, which is flagged as non-compliant, and then correctly with EventArgs.Empty. The analyzer suggests replacing the null argument with EventArgs.Empty.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0093.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing System;\nclass Test\n{\n    public event EventHandler MyEvent;\n\n    void OnEvent()\n    {\n        MyEvent.Invoke(this, null); // non-compliant\n        MyEvent.Invoke(this, EventArgs.Empty); // ok\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Detect Implicit End-of-Line Characters in Verbatim Strings - C#\nDESCRIPTION: This code snippet demonstrates examples of C# verbatim strings and illustrates which ones will trigger the MA0101 analyzer due to implicit end-of-line characters. The analyzer will flag verbatim strings that contain implicit newlines (created by simply pressing enter within the string), as these can be affected by environment-specific line ending conventions.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0101.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n_ = @\"test\";              // valid\n_ = @\"line1\\n\" + \"line2\"; // valid\n_ = @\"line1\nline 2\";                  // not valid\n```\n\n----------------------------------------\n\nTITLE: Implicit DateTime to DateTimeOffset Conversion (C#)\nDESCRIPTION: This C# code demonstrates the MA0132 analyzer rule, which flags implicit conversions from DateTime to DateTimeOffset. The first line shows a non-compliant example where a DateTime is implicitly converted during subtraction. Subsequent lines show compliant alternatives using explicit DateTimeOffset constructors or casts. Dependencies: System.DateTime, System.DateTimeOffset.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0132.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nDateTime dt = ...;\n\ndt - DateTimeOffset.UtcNow; // non-compliant as there is an implicit conversion from DateTime to DateTimeOffset\n\nDateTimeOffset.UtcNow - DateTimeOffset.UtcNow;  // ok\nnew DateTimeOffset(dt) - DateTimeOffset.UtcNow; // ok\n(DateTimeOffset)dt - DateTimeOffset.UtcNow;     // ok\n```\n\n----------------------------------------\n\nTITLE: StructLayoutAttribute Suggestion - CSharp\nDESCRIPTION: This code shows an example of a struct that should have the `StructLayoutAttribute` and the suggested fix. It suggests adding `[StructLayout(LayoutKind.XXX)]` to the struct definition.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0008.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstruct Sample\n{\n    public int A;\n    public int B;\n}\n\n// Should be\n[StructLayout(LayoutKind.XXX)]\nstruct Sample\n{\n    public int A;\n    public int B;\n}\n```\n\n----------------------------------------\n\nTITLE: MA0111 Diagnostic Example C#\nDESCRIPTION: This code snippet demonstrates the MA0111 diagnostic. The analyzer reports a diagnostic when `FormattableString.Invariant` is used for string interpolation. The second line shows the recommended replacement using `string.Create` which resolves the diagnostic.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0111.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nFormattableString.Invariant($\"\"); // report diagnostic\n\nstring.Create(CultureInfo.Invariant, $\"\"); // ok\n```\n\n----------------------------------------\n\nTITLE: MA0160: Suggest ContainsKey over TryGetValue in C#\nDESCRIPTION: This C# code snippet demonstrates the MA0160 analyzer rule. It flags instances where Dictionary.TryGetValue is used and the output value is discarded (using `out _`), suggesting that Dictionary.ContainsKey should be used instead for better efficiency when only checking for key existence. The rule does not apply when the output value is assigned to a variable.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0160.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nDictionary<string, string> dict;\ndict.TryGetValue(\"dummy\", out _); // non-compliant\n\ndict.TryGetValue(\"dummy\", out var a); // ok\ndict.ContainsKey(\"dummy\"); // ok\n```\n\n----------------------------------------\n\nTITLE: DebuggerDisplay - Invalid Member C#\nDESCRIPTION: This C# code demonstrates the incorrect usage of the DebuggerDisplay attribute. The InvalidMember specified in the DebuggerDisplay attribute does not exist within the Dummy2 class, violating the analyzer rule. This will result in a diagnostic warning from the analyzer, indicating the missing member.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0151.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\n[DebuggerDisplay(\"{InvalidMember}\")] // non-compliant as InvalidMember doesn't exist\npublic class Dummy2\n{\n    public string Display { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Process.Start without explicit UseShellExecute (C#)\nDESCRIPTION: This code snippet demonstrates the violation of MA0161 rule. The `Process.Start` method is called without specifying the `UseShellExecute` property. This can lead to inconsistent behavior between .NET Framework and .NET Core due to different default values for the property. The analyzer flags these instances to enforce clarity and prevent potential issues during application migration or cross-platform development.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0161.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nusing System.Diasgnostics;\n\n// Non compliant\n\nProcess.Start(new ProcessStartInfo(\"cmd\")); // Intent is not clear if you want to use ShellExecute or not\n\nProcess.Start(new ProcessStartInfo(\"https://www.meziantou.net/\")); // Will fail on .NET Core apps\n\n// Compliant\n\nProcess.Start(new ProcessStartInfo(\"https://www.meziantou.net/\")\n{\n    UseShellExecute = true,\n});\n```\n\n----------------------------------------\n\nTITLE: Throwing ArgumentException with Parameter Name (C#)\nDESCRIPTION: This code snippet demonstrates how to throw an ArgumentException while properly specifying the parameter name using nameof. This is the recommended approach for better code readability and maintainability.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0015.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nvoid Sample(string str)\n{\n    if (str == \"\")\n        throw new ArgumentException(\"Error message\", paramName: nameof(str)); // ok\n}\n```\n\n----------------------------------------\n\nTITLE: MA0143 - Detect assignments to primary constructor parameters (C#)\nDESCRIPTION: This code snippet demonstrates the MA0143 analyzer rule. It defines a class with a primary constructor parameter 'p' and shows examples of assignments to 'p' within the class's method.  The analyzer will flag these assignments as violations of the rule, indicating that 'p' should be readonly.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0143.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nclass Sample(int p)\n{\n    void A()\n    {\n        p = 0; // non-compliant\n        (p, _) = (0, 1); // non-compliant\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Optimize StringBuilder: Direct Value Appending\nDESCRIPTION: This snippet demonstrates how to optimize StringBuilder usage by directly appending numerical values instead of converting them to strings using ToString(). This avoids unnecessary string conversions.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0028.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nnew StringBuilder().Append(10.ToString());\n\n// Should be\nnew StringBuilder().Append(10);\n```\n\n----------------------------------------\n\nTITLE: Remove Useless OrderBy - C#\nDESCRIPTION: This C# code snippet demonstrates the MA0030 analyzer rule which identifies and suggests removing duplicate `OrderBy` methods, or replacing the second `OrderBy` with `ThenBy`. The snippet provides examples of code that triggers the analyzer and the corresponding suggested replacements.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0030.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnew int[0].OrderBy(x => x).OrderBy(x => x);\n\n// Should be\nnew int[0].OrderBy(x => x);\nnew int[0].OrderBy(x => x).ThenBy(x => x);\n```\n\n----------------------------------------\n\nTITLE: Correct Iterator Method Argument Validation C#\nDESCRIPTION: This code snippet demonstrates the correct way to validate arguments in an iterator method. The validation is performed outside the iterator block, ensuring it happens immediately when the method is called. The iterator logic is encapsulated in a nested function.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0050.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nIEnumerable<int> Sample(string a)\n{\n    if (a == null)\n        throw new System.ArgumentNullException(nameof(a));\n\n    return Sample();\n\n    IEnumerable<int> Sample()\n    {\n        yield return 0;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Optimize StringBuilder: Character Appending\nDESCRIPTION: This snippet demonstrates how to optimize StringBuilder usage by appending characters directly using the Append('char') method instead of appending strings of length one. This improves performance.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0028.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nnew StringBuilder().Append(\"a\");\n\n// Should be\nnew StringBuilder().Append('a');\n```\n\n----------------------------------------\n\nTITLE: Implementing IEquatable<T> without overriding Equals(object) in C#\nDESCRIPTION: This code snippet demonstrates a non-compliant scenario where a class implements the IEquatable<T> interface but does not override the Equals(object) method. This violates the MA0095 rule.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0095.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nclass Test : IEquatable<T> // non-compliant\n{\n    public bool Equals(Test other) => throw null;\n}\n```\n\n----------------------------------------\n\nTITLE: Compliant Where-OrderBy Order - C#\nDESCRIPTION: This example shows the compliant usage of Where before OrderBy. It filters the enumerable before sorting, improving performance by sorting a smaller collection.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0063.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nenumerable.Where(...).OrderBy(...)\n```\n\n----------------------------------------\n\nTITLE: Incorrect Iterator Method Argument Validation C#\nDESCRIPTION: This code snippet demonstrates an incorrect implementation of argument validation in an iterator method. The validation occurs within the iterator block, which is only executed upon enumeration. This means the argument is not validated until the iterator is used, potentially leading to delayed exceptions.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0050.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nIEnumerable<int> Sample(string a)\n{\n    if (a == null)\n        throw new System.ArgumentNullException(nameof(a));\n\n    yield return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Type Name Matching Namespace in C#\nDESCRIPTION: This C# code snippet demonstrates a scenario where the type name 'Foo' matches the namespace 'Foo'. This makes it harder to distinguish the type from the namespace and requires fully qualifying the type when instantiating it.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0049.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace Foo\n{\n    class Foo // non compliant\n    {\n    }\n}\n\nvar foo = new Foo.Foo(); // You must fully qualify the type\n```\n\n----------------------------------------\n\nTITLE: MA0044: Compliant string usage in C#\nDESCRIPTION: This code snippet demonstrates the compliant usage of a string variable without calling `ToString()`. This is the recommended approach, as it is more concise and readable.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0044.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar str = \"abc\";\nConsole.Write(str); // compliant\n```\n\n----------------------------------------\n\nTITLE: Process.Start Usage with ProcessStartInfo - C#\nDESCRIPTION: This code snippet demonstrates the MA0162 analyzer rule, highlighting both non-compliant and compliant usages of `Process.Start`. It emphasizes the importance of using the `ProcessStartInfo` overload to explicitly set the `UseShellExecute` property, particularly when migrating applications between .NET Framework and .NET Core, as the default value differs between these platforms. The snippet includes examples of starting a process without `ProcessStartInfo` and then with `ProcessStartInfo` to illustrate the recommended approach.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0162.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nusing System.Diagnostics;\n\n// Non compliant\n\nProcess.Start(\"cmd\"); // Intent is not clear if you want to use ShellExecute or not\n\nProcess.Start(\"https://www.meziantou.net/\"); // Will fail on .NET Core apps\n\n// Compliant\n\nProcess.Start(new ProcessStartInfo(\"https://www.meziantou.net/\")\n{\n    UseShellExecute = true,\n});\n\n```\n\n----------------------------------------\n\nTITLE: StructLayoutAttribute Analyzer Example - C#\nDESCRIPTION: This code demonstrates scenarios where the analyzer will and will not report a diagnostic. It highlights structs that should have the StructLayoutAttribute based on the presence of multiple blittable fields.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0008.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nstruct A { }\nstruct A { public int A; }\nstruct A { public int A; public string B }\n\nstruct A { public int A; public int B; }\n```\n\n----------------------------------------\n\nTITLE: Redundant Else Block - Compliant C#\nDESCRIPTION: This C# code snippet demonstrates the compliant code where the redundant `else` block has been removed. This reduces nesting and improves code readability, while maintaining the same functionality.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0071.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nif (i < 0)\n{\n    return -1;\n}\n\nif (i == 0)\n{\n    return 0;\n}\n\nreturn 1;\n```\n\n----------------------------------------\n\nTITLE: Process.Start Usage with UseShellExecute\nDESCRIPTION: This C# code snippet demonstrates scenarios where the `UseShellExecute` property is not explicitly set when calling `Process.Start`, leading to potential issues, especially when redirecting standard input or output. It illustrates the difference in default behavior between .NET Framework and .NET Core and highlights cases that will result in runtime exceptions. The compliant examples show the correct way to set `UseShellExecute` based on the context.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0163.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nusing System.Diasgnostics;\n\n// Non compliant\n\nProcess.Start(\"cmd\"); // Intent is not clear if you want to use ShellExecute or not\n\nProcess.Start(\"https://www.meziantou.net/\"); // Will fail on .NET Core apps\n\nProcess.Start(new ProcessStartInfo(\"cmd\")\n{\n    RedirectStandardOutput = true,\n    UseShellExecute = true,\n});  // It will throw with error \"UseShellExecute must be set to false when redirecting I/O\"\n\nProcess.Start(new ProcessStartInfo(\"cmd\")\n{\n    RedirectStandardOutput = true,\n});  // It will throw with error \"UseShellExecute must be set to false when redirecting I/O\" on .NET Framework apps\n\n// Compliant\n\nProcess.Start(new ProcessStartInfo(\"https://www.meziantou.net/\")\n{\n    UseShellExecute = true,\n});\n\nProcess.Start(new ProcessStartInfo(\"cmd\")\n{\n    RedirectStandardOutput = true,\n    UseShellExecute = false,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuration Example C#\nDESCRIPTION: This example illustrates the configuration option `MA0032.allowOverloadsWithOptionalParameters`. When set to `true`, the analyzer will report usage even if the CancellationToken overload has optional parameters.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0032.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nFoo.Bar(); // report when MA0032.allowOverloadsWithOptionalParameters is true\n\nclass Foo\n{\n    public static void Bar() => throw null;\n    public static void Bar(CancellationToken cancellationToken, bool dummy = false) => throw null;\n}\n```\n\n----------------------------------------\n\nTITLE: Throwing ArgumentNullException without nameof (C#)\nDESCRIPTION: This code snippet demonstrates a non-compliant example where the argument name is passed as a string literal to the ArgumentNullException constructor. This is flagged by the MA0043 analyzer. It requires the System namespace.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0043.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Sample(string s)\n{\n    if (s == null)\n        throw new ArgumentNullException(\"s\"); // non compliant\n}\n```\n\n----------------------------------------\n\nTITLE: ToString() Usage with Analyzer MA0150 in C#\nDESCRIPTION: This code snippet demonstrates how the MA0150 analyzer rule identifies unnecessary calls to the default `ToString()` method. It shows a compliant example where the type might override `ToString()` and a non-compliant example where the type `Foo` is sealed and does not override `ToString()`. The analyzer highlights cases where the default `ToString()` is called without potential for customization.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0150.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nobject o = ...;\no.ToString(); // compliant as ToString may be overridden\n\nvar o = new Foo();\no.ToString(); // Non-compliant as Foo doesn't override ToString and is sealed\n\nsealed class Foo {}\n```\n\n----------------------------------------\n\nTITLE: Sample Razor Component Definition\nDESCRIPTION: Defines a simple Razor component named `SampleComponent` with a parameter `Text`.  This component displays the value of the `Text` parameter.  It serves as a baseline for demonstrating the MA0115 analyzer rule.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0115.md#_snippet_0\n\nLANGUAGE: razor\nCODE:\n```\n@* SampleComponent *@\n<p>@Text</p>\n\n@code {\n    [Parameter]\n    public string Text { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: IComparable Implementation with Operator Overloading in C#\nDESCRIPTION: This example shows a class `Test` that implements `IComparable<T>` and also includes the necessary overloaded comparison operators (<, <=, >, >=, ==, !=). This satisfies the MA0097 analyzer rule, ensuring consistency between comparison behavior defined by the interface and the operators. The `CompareTo` method and all relevant comparison operators are present.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0097.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nclass Test : IComparable<T> // ok\n{\n    public int CompareTo(Test other) => throw null;\n    public static bool operator <(Test a, Test b) => throw null;\n    public static bool operator <=(Test a, Test b) => throw null;\n    public static bool operator >(Test a, Test b) => throw null;\n    public static bool operator >=(Test a, Test b) => throw null;\n    public static bool operator ==(Test a, Test b) => throw null;\n    public static bool operator !=(Test a, Test b) => throw null;\n}\n```\n\n----------------------------------------\n\nTITLE: Casting with Cast (Compliant) C#\nDESCRIPTION: This code snippet shows the compliant way of casting elements using the 'Cast' method in C#. It directly casts the 'strings' collection to a collection of objects.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0078.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.Linq.Enumerable<string> strings = GetStrings();\nvar stringsAsObjects = strings.Cast<object>(str);\n```\n\n----------------------------------------\n\nTITLE: Valid SupplyParameterFromQuery usage in Blazor\nDESCRIPTION: This code snippet demonstrates the correct usage of the `[SupplyParameterFromQuery]` attribute. The component includes the `@page \"/\"` directive, making it a routable component. The `Value` parameter can now correctly receive values from the query string.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0122.md#_snippet_1\n\nLANGUAGE: razor\nCODE:\n```\n@page \"/\"\n@code {\n    // ok\n    [Parameter, SupplyParameterFromQuery]\n    public int Value { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Suppressing MA0048 C#\nDESCRIPTION: This snippet shows how to suppress the MA0048 analyzer rule locally using `#pragma warning disable MA0048` or `[SuppressMessage]`. This is useful when a file contains multiple types or when the rule doesn't apply in a specific case.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0048.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MatchFileName {}\n\n[System.Diagnostics.CodeAnalysis.SuppressMessage(\"Design\", \"MA0048:File name must match type name\", Justification = \"<Pending>\")]\npublic class DoNotMatchFileName1 { }\n\n#pragma warning disable MA0048\npublic class DoNotMatchFileName2 { }\npublic class DoNotMatchFileName3 { }\n```\n\n----------------------------------------\n\nTITLE: MA0091 - Sender should be 'this' for instance events in C#\nDESCRIPTION: This C# code snippet demonstrates the MA0091 analyzer rule, which requires the sender of an instance event to be 'this'. The example shows both a non-compliant case (passing null as sender) and a compliant case (passing 'this' as sender).\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0091.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing System;\nclass Test\n{\n    public event EventHandler MyEvent;\n\n    void OnEvent()\n    {\n        MyEvent.Invoke(null, EventArgs.Empty); // non-compliant\n        MyEvent.Invoke(this, EventArgs.Empty); // ok\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Replace Equality Operators with Pattern Matching in C#\nDESCRIPTION: This code snippet illustrates the MA0148 rule, highlighting the preference for pattern matching over equality operators when comparing a value against discrete values in C#. It demonstrates a non-compliant example using the == operator and a compliant example using the 'is' pattern matching.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0148.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvalue == 1; // not compliant\n\nvalue is 1; // ok\n```\n\n----------------------------------------\n\nTITLE: Invalid UnsafeAccessorAttribute Signature C#\nDESCRIPTION: This C# code snippet demonstrates an invalid usage of `[UnsafeAccessorAttribute]` where the first parameter of the `Demo` method is not passed by reference. This will trigger the MA0145 analyzer.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0145.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[UnsafeAccessor(UnsafeAccessorKind.Field, Name = \"dummy\")]\nextern static ref int Demo(MyStruct a); // Not compliant as the first parameter is not by ref\n```\n\n----------------------------------------\n\nTITLE: Correct EventArgs Class Naming C#\nDESCRIPTION: This code snippet demonstrates a compliant class name. The class `SampleEventArgs` inherits from `EventArgs` and its name ends with 'EventArgs', adhering to the MA0059 rule. The analyzer will not flag this as an issue.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0059.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass SampleEventArgs : EventArgs // compliant\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Async Void Delegates in C#\nDESCRIPTION: This C# code snippet demonstrates the analyzer MA0147 detecting an async void delegate being passed to a method that expects a synchronous Action delegate. The 'Foo' method accepts a System.Action delegate, which is synchronous. Passing 'async () => {}' is flagged as non-compliant. Passing '() => {}' is valid.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0147.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nFoo(() => {}); // ok\n\nFoo(async () => {}); // non-compliant as the delegate is not expecting an async method\n\nvoid Foo(System.Action action) => throw null;\n```\n\n----------------------------------------\n\nTITLE: Detect Logging of DataClassification Attributes in C#\nDESCRIPTION: This code snippet demonstrates a scenario where a property (`Prop`) decorated with a custom attribute (`PiiAttribute`) that inherits from `DataClassificationAttribute` is used directly as a log parameter. The analyzer rule MA0153 flags this as a violation, suggesting alternative approaches to avoid logging sensitive data directly.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0153.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nusing Microsoft.Extensions.Logging;\n\nILogger logger;\n\n// non-compliant as Prop is decorated with an attribute that inherits from DataClassificationAttribute\nlogger.LogInformation(\"{Prop}\", new Dummy().Prop);\n\nclass Dummy\n{\n    [PiiAttribute]\n    public string Prop { get; set; }\n}\n\nclass PiiAttribute : Microsoft.Extensions.Compliance.Classification.DataClassificationAttribute\n{\n    public TaxonomyAttribute() : base(default)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Serilog Logging Examples - C#\nDESCRIPTION: This C# code snippet provides examples of Serilog logging statements, demonstrating both compliant and non-compliant usage of parameters. The first `Log.Information` call is non-compliant because the `Name` parameter is configured to be a string, but an integer is passed. The second call is compliant as the `Name` parameter uses a string.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0139.md#_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nusing Serilog;\n\nLog.Information(\"{Name}\", 123); // non-compliant as the configuration file indicates Name should be of type string\nLog.Information(\"{Name}\", \"dummy\"); // ok\n```\n\n----------------------------------------\n\nTITLE: Enable rule for Exception classes (.editorconfig)\nDESCRIPTION: Configuration setting within a .editorconfig file to enable the MA0053 analyzer rule for classes that inherit from Exception. These classes are excluded from the analysis by default.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0053.md#_snippet_3\n\nLANGUAGE: editorconfig\nCODE:\n```\n# .editorconfig file\nMA0053.exceptions_should_be_sealed = true\n```\n\n----------------------------------------\n\nTITLE: Method Override Changing Default Value - C#\nDESCRIPTION: This C# code demonstrates a violation of the MA0061 analyzer rule. The `Bar` class overrides the `Write` method from the `Foo` class and changes the default value of the `i` parameter from 42 to 5. This can lead to different behavior depending on whether the method is called on a `Foo` or a `Bar` instance.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0061.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Foo\n{\n  public virtual void Write(int i = 42)\n  {\n    Console.WriteLine(i);\n  }\n}\n\npublic class Bar : Foo\n{\n  public override void Write(int i = 5) // Noncompliant\n  {\n    Console.WriteLine(i);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: MA0149 - Use pattern matching instead of inequality operators - C#\nDESCRIPTION: This code snippet demonstrates the MA0149 analyzer rule, which suggests replacing inequality operators with pattern matching. The first line shows a non-compliant example using the '!=' operator. The second line shows the recommended compliant example using 'is not' pattern matching.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0149.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvalue != 1; // not compliant\n\nvalue is not 1; // ok\n```\n\n----------------------------------------\n\nTITLE: Non-Compliant: Struct Member Without Readonly Modifier (C#)\nDESCRIPTION: This code snippet demonstrates a non-compliant struct member. The `A` property accesses the struct's internal state (`a`) but is not marked as `readonly`, even though it doesn't modify the state. This violates the MA0102 rule.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0102.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nstruct Sample\n{\n    int a;\n\n    public int A => a; // non-compliant\n}\n```\n\n----------------------------------------\n\nTITLE: MA0003 - Parameter Naming Example (C#)\nDESCRIPTION: This code snippet demonstrates the MA0003 analyzer rule. It shows a method call with a literal value that should be refactored to include the parameter name for better readability. The snippet also includes the suggested refactored code.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0003.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nobj.Test(null);\n\n// Should be\nobj.Test(name: null);\n```\n\n----------------------------------------\n\nTITLE: Enable rule for classes with virtual members (.editorconfig)\nDESCRIPTION: Configuration setting within a .editorconfig file to enable the MA0053 analyzer rule for classes containing virtual members. This is disabled by default.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0053.md#_snippet_2\n\nLANGUAGE: editorconfig\nCODE:\n```\n# .editorconfig file\nMA0053.class_with_virtual_member_should_be_sealed = true\n```\n\n----------------------------------------\n\nTITLE: IComparable Implementation without Operator Overloading in C#\nDESCRIPTION: This code snippet demonstrates a class `Test` implementing `IComparable<T>` but missing the overloaded comparison operators. This triggers the MA0097 analyzer rule because it's recommended to provide overloaded operators when implementing comparison interfaces. The `CompareTo` method is present, but the comparison operators are not.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0097.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nclass Test : IComparable<T> // non-compliant\n{\n    public int CompareTo(Test other) => throw null;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrate compliant Obsolete attribute usage (C#)\nDESCRIPTION: This snippet shows a compliant usage of the `Obsolete` attribute. The attribute includes a reason string, which satisfies the MA0070 analyzer rule.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0070.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[Obsolete(\"reason\")] // compliant\nvoid B() {}\n```\n\n----------------------------------------\n\nTITLE: IAsyncEnumerable method naming - Compliant C# example\nDESCRIPTION: This code snippet demonstrates the correct naming convention for a method that returns IAsyncEnumerable<T>. It shows that the 'Async' suffix should be omitted.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0157.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\n// compliant\nIAsyncEnumerable<string> Foo() => throw null;\n```\n\n----------------------------------------\n\nTITLE: Detecting Invalid Nullable Attribute Parameter in C#\nDESCRIPTION: This C# code demonstrates the MA0068 analyzer's detection of an invalid parameter name used with the `NotNullIfNotNullAttribute`. The first example shows a non-compliant case where \"unknown\" is not a valid parameter. The second example shows compliant use of \"a\" as the parameter name.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0068.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Test\n{\n    [return: System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute(\"unknown\")] // non-compliant, \"unknown\" is not a parameter of the method\n    public void A(string a) { }\n\n    [return: System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute(\"a\")] // compliant, \"a\" is not a parameter of the method\n    public void A(string a) { }\n}\n```\n\n----------------------------------------\n\nTITLE: MA0003 - RequireNamedArgument Attribute (C#)\nDESCRIPTION: This snippet shows how to use the `RequireNamedArgumentAttribute` from the `Meziantou.Analyzer.Annotations` NuGet package to enforce named arguments for specific parameters. It demonstrates that a diagnostic will be reported if the parameter is not named when calling the method. The package needs to be installed to use the attribute.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0003.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nTest(\"test\"); // report a diagnostic as the parameter is not named\n\n// Requires Meziantou.Analyzer.Annotations package\npublic void Test([RequireNamedArgument] string value) { }\n```\n\n----------------------------------------\n\nTITLE: MA0094: Compliant CompareTo(T) and IComparable implementation in C#\nDESCRIPTION: This code snippet shows a class `Test` that defines a `CompareTo(Test)` method and correctly implements the `IComparable<Test>` interface.  This resolves the MA0094 analyzer issue. The method throws a `null` exception as a placeholder.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0094.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nclass Test : IComparable<T> // ok\n{\n    public int CompareTo(Test other) => throw null;\n}\n```\n\n----------------------------------------\n\nTITLE: Logging Parameter Validation in C#\nDESCRIPTION: This C# code demonstrates the MA0135 analyzer rule in action. The code uses Microsoft.Extensions.Logging to log information. The first log statement is non-compliant because the parameter 'Prop' is not defined in the LoggerParameterTypes.txt configuration file. The second log statement is compliant because 'Name' is defined.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0135.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nusing Microsoft.Extensions.Logging;\n\nILogger logger = null;\nlogger.LogInformation(\"{Prop}\", 2); // non-compliant as \"Prop\" is not defined in the configuration file\nlogger.LogInformation(\"{Name}\", \"\"); // ok as Name is defined in the configuration file\n```\n\n----------------------------------------\n\nTITLE: IAsyncEnumerable method naming - Non-Compliant C# example\nDESCRIPTION: This code snippet illustrates an incorrect naming convention for a method that returns IAsyncEnumerable<T>.  It shows that the 'Async' suffix should not be present when returning IAsyncEnumerable<T>.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0157.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\n// non-compliant\nIAsyncEnumerable<string> FooAsync() => throw null;\n```\n\n----------------------------------------\n\nTITLE: DebuggerDisplay - Valid Member C#\nDESCRIPTION: This C# code demonstrates the correct usage of the DebuggerDisplay attribute.  The Display member is a valid property within the Dummy1 class, making this implementation compliant with the analyzer rule. The DebuggerDisplay attribute is used to customize how the class is displayed in the debugger.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0151.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\n[DebuggerDisplay(\"{Display}\")] // compliant\npublic class Dummy1\n{\n    public string Display { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuration MA0032.allowOverloadsWithOptionalParameters - C#\nDESCRIPTION: This configuration snippet demonstrates how `MA0032.allowOverloadsWithOptionalParameters` affects reporting. When set to `true`, it allows reporting of overloads with optional parameters. This example triggers a report if `MA0032.allowOverloadsWithOptionalParameters` is true.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0040.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nFoo.Bar(); // report when MA0032.allowOverloadsWithOptionalParameters is true\n\nclass Foo\n{\n    public static void Bar() => throw null;\n    public static void Bar(CancellationToken cancellationToken, bool dummy = false) => throw null;\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Incorrect NaN Comparisons in C#\nDESCRIPTION: This code demonstrates instances where direct comparison with NaN (Not a Number) is performed using `==`.  This is incorrect because comparing any number to NaN, including NaN itself, will always return `false`.  The analyzer suggests using the respective `IsNaN()` method of the `double`, `float`, or `Half` struct to correctly check if a number is NaN. No external dependencies are required.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0082.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nif (a == double.NaN) // non-compliant as it always returns false, should be double.IsNaN(a)\nif (a == float.NaN) // non-compliant as it always returns false, should be float.IsNaN(a)\nif (a == Half.NaN) // non-compliant as it always returns false, should be Half.IsNaN(a)\n```\n\n----------------------------------------\n\nTITLE: Raw String Implicit End-of-Line - Non-Compliant Example (C#)\nDESCRIPTION: This snippet shows a non-compliant example of using a raw string with implicit end-of-line characters that can cause issues with different line ending conventions. The analyzer flags this code because the raw string contains a newline followed by other content on the same line.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0136.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// non-compliant\n_ = \"\"\"\n    line1\n    line2\n    \"\"\";\n```\n\n----------------------------------------\n\nTITLE: Implementing IEquatable<T> with overriding Equals(object) in C#\nDESCRIPTION: This code snippet demonstrates a compliant scenario where a class implements the IEquatable<T> interface and also overrides the Equals(object) method. This satisfies the MA0095 rule.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0095.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nclass Test : IEquatable<T> // ok\n{\n    public override bool Equals(object other) => throw null;\n    public bool Equals(Test other) => throw null;\n}\n```\n\n----------------------------------------\n\nTITLE: Component with CaptureUnmatchedValues Attribute\nDESCRIPTION: Defines a component (`MyComponent`) that captures unmatched values using the `CaptureUnmatchedValues` attribute. This allows the component to accept arbitrary attributes. The analyzer can still be configured to detect PascalCase parameters when this attribute is present.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0115.md#_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nclass MyComponent : ComponentBase\n{\n    [Parameter(CaptureUnmatchedValues = true)]\n    public Dictionary<string, object> AdditionalAttributes { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Logger Usage Example (C#)\nDESCRIPTION: This snippet demonstrates the usage of the logger and highlights instances where the log parameters are non-compliant based on the configured types. It also includes an example of a compliant logging call.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0124.md#_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nusing Microsoft.Extensions.Logging;\n\nILogger logger = ...;\nlogger.LogInformation(\"{Name}\", 123); // non-compliant as the configuration file indicates Name should be of type string\nlogger.LogInformation(\"{Name}\", \"dummy\"); // ok\n```\n\n----------------------------------------\n\nTITLE: IJSRuntime InvokeVoidAsync Usage in C#\nDESCRIPTION: This C# code snippet demonstrates the usage of `InvokeVoidAsync` and `InvokeAsync` methods from `IJSRuntime` or `IJSInProcessRuntime` for JavaScript interop. It highlights the compliant and non-compliant scenarios according to the MA0120 analyzer rule, suggesting the use of `InvokeVoidAsync` when the returned value is not used. The rule aims to improve code readability and potentially performance by avoiding unnecessary result handling.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0120.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nIJSInProcessRuntime js = ...;\n\nawait js.InvokeVoidAsync(\"dummy\"); // compliant\nvar result = await js.InvokeAsync<object>(\"dummy\"); // compliant\nConsole.WriteLine(await js.InvokeAsync<object>(\"dummy\")); // compliant \n\nawait js.InvokeAsync<object>(\"dummy\"); // not-compliant => use InvokeVoidAsync\n```\n\n----------------------------------------\n\nTITLE: Include Logger Parameter Types File in Project\nDESCRIPTION: This snippet demonstrates how to include the `LoggerParameterTypes.txt` file in the project as an `AdditionalFile`. This allows the analyzer to use the type configurations defined in the file during the build process.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0124.md#_snippet_1\n\nLANGUAGE: xml\nCODE:\n```\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <ItemGroup>\n    <AdditionalFiles Include=\"$(MSBuildThisFileDirectory)\\LoggerParameterTypes.txt\" />\n  </ItemGroup>\n\n</Project>\n```\n\n----------------------------------------\n\nTITLE: MA0003 - Configuration (.editorconfig)\nDESCRIPTION: This snippet demonstrates how to configure the MA0003 analyzer rule using a .editorconfig file. It shows how to set the minimum number of method parameters to consider, the expression kinds to analyze, and exclude specific methods or methods matching a regex from the analysis.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0003.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[.*cs]\nMA0003.minimum_method_parameters = 1 # Only consider methods with 1 or more parameters\nMA0003.expression_kinds = Null, Boolean, Numeric, String  # Default: Null | Boolean\n\n# '|'-separated values of documentation comments https://github.com/dotnet/csharplang/blob/main/spec/documentation-comments.md#id-string-format\nMA0003.excluded_methods = M:A.B(System.Int32) | M:C.D()\n\n# The regex matches the documention comment of the method (https://github.com/dotnet/csharplang/blob/main/spec/documentation-comments.md#id-string-format)\nMA0003.excluded_methods_regex = Sample.*Test\n```\n\n----------------------------------------\n\nTITLE: MA0104 Violation: Class Name Matches BCL Type (C#)\nDESCRIPTION: This code snippet demonstrates a violation of the MA0104 analyzer rule. It defines a class named 'String', which conflicts with the System.String type in the Base Class Library. The analyzer will flag this code, indicating a potential naming conflict.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0104.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npublic class String // MA0104\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting missing Parameter attribute with EditorRequired\nDESCRIPTION: This code snippet demonstrates the scenario where the `[EditorRequired]` attribute is used without the `[Parameter]` attribute, which is flagged by the analyzer. It also shows the correct usage of both attributes. The `Microsoft.AspNetCore.Components` namespace is required.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0117.md#_snippet_0\n\nLANGUAGE: razor\nCODE:\n```\nusing Microsoft.AspNetCore.Components;\n\n@code {\n    [EditorRequired] // non-compliant\n    public int A { get; set; }\n\n    [Parameter]\n    [EditorRequired] // ok as the property has the Parameter attribute\n    public int B { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: MA0088: Replace DefaultValueAttribute with DefaultParameterValueAttribute (C#)\nDESCRIPTION: This C# code snippet demonstrates the MA0088 analyzer's suggestion to replace `DefaultValueAttribute` with `DefaultParameterValueAttribute`. The non-compliant code uses `DefaultValueAttribute`, while the compliant code examples use `DefaultParameterValueAttribute` or both. The `DefaultParameterValueAttribute` is more appropriate for specifying default parameter values.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0088.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System.ComponentModel;\nusing System.Runtime.InteropServices;\n\nclass Test\n{\n    void A([DefaultValue(10)]int a) { } // non-compliant\n    void A([DefaultParameterValue(10)]int a) { } // ok\n    void A([DefaultValue(10), DefaultParameterValue(10)]int a) { } // ok\n}\n```\n\n----------------------------------------\n\nTITLE: Regex Explicit Capture Suggestion in C#\nDESCRIPTION: This code snippet demonstrates the MA0023 analyzer's suggestion to add `RegexOptions.ExplicitCapture` to regular expressions for improved performance and the usage of named groups for enhanced clarity. The first line shows a non-compliant example, while the subsequent lines demonstrate compliant versions using `RegexOptions.ExplicitCapture` and named groups.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0023.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nnew Regex(\"a(b)\"); // non-compliant\nnew Regex(\"a(b)\", RegexOptions.ExplicitCapture); // ok\nnew Regex(\"a(?<name>b)\"); // ok\n```\n\n----------------------------------------\n\nTITLE: Configuration MA0032.allowOverloadsWithOptionalParameters\nDESCRIPTION: This snippet shows the configuration option for MA0032.allowOverloadsWithOptionalParameters. This allows the user to configure if the analyzer should report when a method with a CancellationToken parameter also has optional parameters. This provides finer-grained control over the analyzer's behavior.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0040.md#_snippet_2\n\nLANGUAGE: NA\nCODE:\n```\nMA0032.allowOverloadsWithOptionalParameters = false\n```\n\n----------------------------------------\n\nTITLE: MA0094: Non-compliant CompareTo(T) implementation in C#\nDESCRIPTION: This code snippet shows a class `Test` that defines a `CompareTo(Test)` method but does not implement the `IComparable<Test>` interface. This triggers the MA0094 analyzer, as providing a `CompareTo` method suggests the class is intended to be comparable but lacks the required interface implementation. The method throws a `null` exception as a placeholder.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0094.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nclass Test // non-compliant\n{\n    public int CompareTo(Test other) => throw null;\n}\n```\n\n----------------------------------------\n\nTITLE: MA0168 - Compliant example (C#)\nDESCRIPTION: This code snippet demonstrates a compliant example where the struct 'Foo' is declared as 'readonly' and passed as an 'in' parameter to method 'A'. This satisfies the MA0168 analyzer rule because the struct is immutable, preventing accidental modification and improving performance.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0168.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvoid A(in Foo p) { } // ok\n\nreadonly struct Foo { }\n```\n\n----------------------------------------\n\nTITLE: Nullable DateTime.ToString Usage with and without IFormatProvider (C#)\nDESCRIPTION: This code snippet demonstrates the usage of `Nullable<DateTime>.ToString` with and without `IFormatProvider`. Calling `ToString()` on the nullable DateTime without specifying the Culture is considered non-compliant. Using `CultureInfo.CurrentCulture` or a culture-invariant format resolves the issue.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0011.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nDateTime? dt;\n\ndt.ToString(); // non-compliant\ndt?.ToString(CultureInfo.CurrentCulture); // ok\ndt?.ToString(\"o\"); // ok as \"o\" is a culture invariant format\n```\n\n----------------------------------------\n\nTITLE: Detecting Empty Statement in C#\nDESCRIPTION: This C# code snippet demonstrates an empty statement within a `while` loop. The analyzer identifies the semicolon after the `while` condition as an empty statement and suggests its removal to improve code clarity and prevent potential errors.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0037.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nwhile (true); // empty statement here\n{\n    return;\n}\n```\n\n----------------------------------------\n\nTITLE: MA0096 Violation - IComparable without IEquatable C#\nDESCRIPTION: This code snippet demonstrates a violation of the MA0096 rule. The `Test` class implements `IComparable<T>` but does not implement `IEquatable<T>`. This can lead to inconsistencies between comparison and equality checks. The analyzer will flag this class as non-compliant.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0096.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nclass Test : IComparable<T> // non-compliant\n{\n    public bool Equals(Test other) => throw null;\n}\n```\n\n----------------------------------------\n\nTITLE: Compliant code: Negated boolean comparison in C#\nDESCRIPTION: This code snippet presents a compliant alternative to the previous example, showcasing how to avoid direct comparison with a boolean constant. Instead of comparing the variable to the constant, the code directly negates the variable. The code defines a boolean constant `MyConstant`, a boolean variable `value`, and then negates the variable in an `if` statement.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0073.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nconst bool MyConstant = false;\nbool value = GetSomeValue();\n\nif (!value)\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Configuration MA0032.allowOverloadsWithOptionalParameters\nDESCRIPTION: This configuration setting determines whether to report usage if CancellationToken overload has optional parameters.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0032.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nMA0032.allowOverloadsWithOptionalParameters = false\n```\n\n----------------------------------------\n\nTITLE: Including Additional Files in csproj - xml\nDESCRIPTION: This XML snippet demonstrates how to include the `LoggerParameterTypes.txt` file as an `AdditionalFiles` item in the `.csproj` file. This ensures that the analyzer can access the configuration file during the build process and validate the types of log parameters accordingly.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0139.md#_snippet_1\n\nLANGUAGE: xml\nCODE:\n```\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <ItemGroup>\n    <AdditionalFiles Include=\"$(MSBuildThisFileDirectory)\\LoggerParameterTypes.txt\" />\n  </ItemGroup>\n\n</Project>\n```\n\n----------------------------------------\n\nTITLE: MA0138 Non-Compliant Example (C#)\nDESCRIPTION: This code snippet demonstrates a non-compliant method that has the 'Async' suffix but does not return an awaitable type. This will trigger the MA0138 analyzer rule, suggesting the removal of the 'Async' suffix.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0138.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n// non-compliant\nvoid FooAsync() { }\n```\n\n----------------------------------------\n\nTITLE: MA0011 Analyzer Configuration\nDESCRIPTION: This snippet shows how to configure the MA0011 analyzer rule to exclude `ToString` methods from analysis or to consider nullable types when reporting issues.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0011.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n# Exclude ToString methods from analysis\nMA0011.exclude_tostring_methods=true\n\n# Report Nullable<T>.ToString when T is culture-sensitive\nMA0011.consider_nullable_types=true\n```\n\n----------------------------------------\n\nTITLE: Detecting missing [Parameter] attribute with [SupplyParameterFromQuery] in Razor\nDESCRIPTION: This code snippet demonstrates the MA0116 analyzer's functionality. It highlights a scenario where the `[SupplyParameterFromQuery]` attribute is used on a property `A` without the `[Parameter]` attribute, which is flagged as non-compliant. It also showcases a compliant case where both attributes are present on property `B`. This example is intended for Blazor development.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0116.md#_snippet_0\n\nLANGUAGE: razor\nCODE:\n```\nusing Microsoft.AspNetCore.Components;\n\n@code {\n    [SupplyParameterFromQuery] // non-compliant\n    public int A { get; set; }\n\n    [Parameter]\n    [SupplyParameterFromQuery] // ok as the property has the Parameter attribute\n    public int B { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Non-compliant: Equals(T) without IEquatable<T> - C#\nDESCRIPTION: This code snippet demonstrates a non-compliant case where a class `MyClass` provides an `Equals(MyClass)` method but does not implement the `IEquatable<MyClass>` interface. This violates the MA0077 rule and can lead to unexpected behavior during equality comparisons.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0077.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nclass MyClass\n{\n    public bool Equals(MyClass other)\n    {\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Use Order instead of OrderBy - Compliant C#\nDESCRIPTION: This code snippet demonstrates the compliant usage of `Order()` to order a collection of integers. This is the preferred way to order a collection when the sorting is based on the elements themselves.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0159.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nIEnumerable<int> numbers = [1, 2];\nvar orderedNumbers = numbers.Order(); // compliant\n```\n\n----------------------------------------\n\nTITLE: Enable rule for public classes (.editorconfig)\nDESCRIPTION: Configuration setting within a .editorconfig file to enable the MA0053 analyzer rule for public classes. This is disabled by default because the analyzer can only know the current project context, not the full solution.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0053.md#_snippet_1\n\nLANGUAGE: editorconfig\nCODE:\n```\n# .editorconfig file\nMA0053.public_class_should_be_sealed = true\n```\n\n----------------------------------------\n\nTITLE: EditorConfig Configuration for PascalCase Unmatched Parameters\nDESCRIPTION: Demonstrates how to configure the analyzer using an `.editorconfig` file to report PascalCase unmatched parameters, even when the component allows for unmatched parameters.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0115.md#_snippet_2\n\nLANGUAGE: .editorconfig\nCODE:\n```\nMA0115.ReportPascalCaseUnmatchedParameter\n```\n\n----------------------------------------\n\nTITLE: Identifying TODO Comments in C#\nDESCRIPTION: This C# code snippet demonstrates the structure of TODO comments that the MA0026 analyzer is designed to identify. The analyzer flags both single-line comments starting with `// TODO` and multi-line comments containing `TODO`.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0026.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// TODO Task 1\n\n/*\n * TODO task 2\n * TODO task 3\n */\n```\n\n----------------------------------------\n\nTITLE: Configure Logger Parameter Types via Text File\nDESCRIPTION: This snippet demonstrates the configuration of allowed types for logger parameters using a `LoggerParameterTypes.txt` file. Each line specifies a property name and a list of allowed types. Lines starting with `#` are treated as comments.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0124.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n# This is a comment\n\nName;System.String\nCount;System.Int32;System.Int64\nLength;System.Int32;System.Nullable{System.Int32}\nAccountId;System.Nullable{System.Guid}\n\n# Deny parameter\nInvalidParameter;\n```\n\n----------------------------------------\n\nTITLE: Iterate IAsyncEnumeration with Cancellation Token (C#)\nDESCRIPTION: This code snippet demonstrates iterating through an IAsyncEnumeration using a cancellation token via the `.WithCancellation()` extension method.  This allows the enumeration to be cancelled gracefully. The `cancellationToken` parameter is a `CancellationToken` instance, which is passed to the `WithCancellation` method.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0080.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nIAsyncEnumeration<string> enumerable;\nawait foreach (var item in enumerable.WithCancellation(cancellationToken)) // compliant\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Compliant: Struct Member With Readonly Modifier (C#)\nDESCRIPTION: This code snippet demonstrates a compliant struct member. The `A` property accesses the struct's internal state (`a`) and is correctly marked as `readonly`, indicating that it does not modify the struct's state. This satisfies the MA0102 rule.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0102.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nstruct Sample\n{\n    int a;\n\n    public readonly int A => a; // compliant\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Analyzer Rule Severity in .editorconfig\nDESCRIPTION: This code snippet demonstrates how to configure the severity of a specific diagnostic rule (MA0001) in an .editorconfig file. It sets the severity of the 'StringComparison is missing' rule to 'suggestion', indicating that violations of this rule should be reported as suggestions rather than warnings or errors. The general pattern is 'dotnet_diagnostic.[RuleId].severity = [SeverityLevel]'.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/README.md#_snippet_0\n\nLANGUAGE: editorconfig\nCODE:\n```\n# MA0001: StringComparison is missing\ndotnet_diagnostic.MA0001.severity = suggestion\n```\n\n----------------------------------------\n\nTITLE: Configuration Example with Duplicate Entry\nDESCRIPTION: This code snippet demonstrates a configuration file with a duplicate entry for 'PropName'. The analyzer will flag this as an error.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0126.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nPropName;type\nPropName;type # Report diagnostic\n```\n\n----------------------------------------\n\nTITLE: Configuring Analyzer Rule Severity in .editorconfig\nDESCRIPTION: This code snippet demonstrates configuring the severity of the MA0032 rule (Use an overload with a CancellationToken argument) to 'none', effectively disabling the rule.  The general pattern is 'dotnet_diagnostic.[RuleId].severity = [SeverityLevel]'.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/README.md#_snippet_2\n\nLANGUAGE: editorconfig\nCODE:\n```\n# MA0032: Use an overload with a CancellationToken argument\ndotnet_diagnostic.MA0032.severity = none\n```\n\n----------------------------------------\n\nTITLE: Detecting Incorrect Unsubscribe with Anonymous Delegates in C#\nDESCRIPTION: This code snippet showcases the incorrect usage of anonymous delegates to unsubscribe from a C# event. The analyzer MA0085 is triggered because the anonymous delegate created for unsubscribing is a new instance, and thus will not match the original subscription, leaving the event handler still attached. This can lead to memory leaks and unexpected behavior. It requires a pre-existing event 'MyEvent'.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0085.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nMyEvent += (sender, e) => { }\nMyEvent -= (sender, e) => { }; // Non-compliant as it doesn't actually remove the handler\n```\n\n----------------------------------------\n\nTITLE: C# Initializer Without Trailing Comma\nDESCRIPTION: This code snippet demonstrates a non-compliant C# initializer where the last property assignment is missing a trailing comma. The analyzer flags this as a violation of the MA0007 rule.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0007.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnew Sample\n{\n    A = 0,\n    B = 1  // non-compliant\n};\n```\n\n----------------------------------------\n\nTITLE: File Name Matching Examples C#\nDESCRIPTION: This snippet demonstrates examples of compliant and non-compliant C# code with respect to the MA0048 analyzer rule. It shows how the file name should match the class name, including generic types. It also demonstrates scenarios that are compliant.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0048.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// filename: Bar.cs\nclass Foo // non compliant\n{\n}\n\n// filename: Foo.cs\nclass Foo // compliant\n{\n}\n\n// filename: Foo.cs\nclass Foo<T> // compliant\n{\n}\n\n// filename: Foo`1.cs\nclass Foo<T> // compliant\n{\n}\n\n// filename: FooOfT.cs\nclass Foo<T> // compliant\n{\n}\n\n// filename: Foo{TKey,TResult}.cs\nclass Foo<TKey, TResult> // compliant\n{\n}\n\n// filename: Foo{T}.cs\nclass Foo<TKey, TResult> // non compliant\n{\n}\n```\n\n----------------------------------------\n\nTITLE: XML Comment - Compliant Example C#\nDESCRIPTION: This code snippet demonstrates a compliant example where the `<see langword=\"keyword\" />` tag is used to represent a keyword in an XML comment. This usage adheres to the MA0154 analyzer rule.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0154.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\n// ok\n/// <summary>Sample <see langword=\"class\" /> keyword</summary>\npublic class Sample { }\n```\n\n----------------------------------------\n\nTITLE: Incorrect EventArgs Class Naming C#\nDESCRIPTION: This code snippet demonstrates a non-compliant class name. The class `Sample` inherits from `EventArgs` but its name does not end with 'EventArgs', violating the MA0059 rule. The analyzer will flag this as an issue, suggesting to rename the class.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0059.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Sample : EventArgs // Non compliant\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Compliant Exception Class Name - C#\nDESCRIPTION: This code snippet demonstrates a compliant example where a class inheriting from `System.Exception` has a name ending with 'Exception'. This will not be flagged by the MA0058 analyzer rule.  No external dependencies are required other than the base class `System.Exception`.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0058.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass SampleException : Exception // compliant\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Missing Span Overload - C#\nDESCRIPTION: This code demonstrates a scenario where a method accepts a string array, but there's no corresponding overload that accepts a Span<string> or Memory<string>. This triggers the MA0109 diagnostic, suggesting the addition of such an overload for improved performance.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0109.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nvoid A(string[] a) { } // report diagnostic\n```\n\n----------------------------------------\n\nTITLE: Raw String Implicit End-of-Line - Compliant Examples (C#)\nDESCRIPTION: This snippet demonstrates compliant usage of raw strings where implicit end-of-line characters are handled correctly, avoiding potential issues with different line ending conventions. The examples show single-line raw strings and multiline raw strings without trailing newlines.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0136.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// ok\n_ = \"\"\"line1\"\"\"\n_ = \"\"\"\n    line1\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Replace Enum.ToString with nameof in C#\nDESCRIPTION: This code snippet demonstrates the MA0052 analyzer rule. It shows a non-compliant example using `ToString()` on a constant enumeration value and a compliant example using `nameof` to achieve the same result with better performance. The `Color` enum is defined, and the `Sample` method illustrates the usage.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0052.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum Color\n{\n    Blue,\n    Red,\n    Yellow,\n}\n\nvoid Sample()\n{\n    _ = Color.Blue.ToString(); // non compliant\n    _ = nameof(Color.Blue); // compliant\n}\n```\n\n----------------------------------------\n\nTITLE: Naming Convention Violation - C#\nDESCRIPTION: This code snippet demonstrates a violation of the MA0057 rule. The class 'Sample' derives from 'System.Attribute' but does not have the 'Attribute' suffix in its name. This violates the enforced naming convention.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0057.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Sample : Attribute // Non compliant\n{\n}\n```\n\n----------------------------------------\n\nTITLE: MA0096 Compliant - IComparable and IEquatable C#\nDESCRIPTION: This code snippet demonstrates a compliant implementation of the MA0096 rule. The `Test` class implements both `IComparable<T>` and `IEquatable<T>`. This ensures consistency between comparison and equality checks and avoids the analyzer warning.  It requires an override of `Equals(object other)` and implementation of `Equals(Test other)`.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0096.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nclass Test : IComparable<T>, IEquatable<T> // ok\n{\n    public override bool Equals(object other) => throw null;\n    public bool Equals(Test other) => throw null;\n}\n```\n\n----------------------------------------\n\nTITLE: Enforce Public Accessibility for JSInvokable Methods in C#\nDESCRIPTION: This code demonstrates the MA0118 analyzer rule. It shows examples of valid (public) and invalid (internal, static) `[JSInvokable]` method declarations. The analyzer will flag the non-compliant methods (B and C) as violations of the rule. The `Microsoft.JSInterop` namespace is required.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0118.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing Microsoft.JSInterop;\n\nclass Test\n{\n    [JSInvokable]\n    public void A() {}\n\n    [JSInvokable]\n    internal void B() {} // non-compliant, the method is internal\n\n    [JSInvokable]\n    static void C() {}  // non-compliant, the method is private\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Naming Convention - C#\nDESCRIPTION: This code snippet demonstrates the correct naming convention according to the MA0057 rule. The class 'SampleAttribute' derives from 'System.Attribute' and includes the 'Attribute' suffix in its name, complying with the rule.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0057.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass SampleAttribute : Attribute // compliant\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Identical If/Else Branches in C#\nDESCRIPTION: This C# code snippet demonstrates a non-compliant case where both the 'if' and 'else' branches contain the exact same code. The MA0140 analyzer flags this pattern as it indicates unnecessary duplication and potential for refactoring. The code writes 'true' to the console regardless of the condition's evaluation.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0140.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// non-compliant as both branches have the same code\nif (true)\n{\n    Console.WriteLine(true);    \n}\nelse\n{\n    Console.WriteLine(true);\n}\n```\n\n----------------------------------------\n\nTITLE: UnsafeAccessor with Explicit Name (C#)\nDESCRIPTION: This code snippet shows the correct usage of the `UnsafeAccessor` attribute on a local function by explicitly setting the `Name` parameter.  Specifying the name ensures that the correct member is accessed, even though the compiler may mangle the function's actual name. The `Name` parameter is essential for resolving the correct member.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0146.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n// Ok\nvoid Sample()\n{\n    [UnsafeAccessor(UnsafeAccessorKind.Field, Name = \"_Major\")]\n    extern static ref int _Major_(System.Version a);\n}\n```\n\n----------------------------------------\n\nTITLE: MA0087 Compliant and Non-Compliant Code Sample C#\nDESCRIPTION: This C# code snippet demonstrates the MA0087 analyzer rule.  It shows a compliant example where a parameter with the `[DefaultParameterValue]` attribute is also marked with `[Optional]`, and a non-compliant example where it is not. The analyzer will flag the second method `B` as non-compliant.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0087.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System.Runtime.InteropServices;\nclass Test\n{\n    void A([Optional, DefaultParameterValue(10)]int a)\n    {\n    }\n\n    void B([DefaultParameterValue(10)]int a) // Non-compliant\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Compliant: Equals(T) with IEquatable<T> - C#\nDESCRIPTION: This code snippet demonstrates a compliant case where a class `MyClass` provides an `Equals(MyClass)` method and implements the `IEquatable<MyClass>` interface. This satisfies the MA0077 rule and ensures consistent and type-safe equality comparisons.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0077.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nclass MyClass : IEquatable<MyClass>\n{\n    public bool Equals(MyClass other)\n    {\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Non-Compliant OrderBy-Where Order - C#\nDESCRIPTION: This example shows the non-compliant usage of OrderBy before Where.  It sorts the entire enumerable before filtering, which is less efficient than filtering first.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0063.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nenumerable.OrderBy(...).Where(...)\n```\n\n----------------------------------------\n\nTITLE: Acceptable Span Overload - C#\nDESCRIPTION: This code demonstrates an acceptable scenario where a method accepting a string array also has an overload that accepts a ReadOnlySpan<string>. This satisfies the MA0109 rule, as a Span overload is present.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0109.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvoid A(string[] a) { } // ok as there is an overload with Span\nvoid A(System.ReadOnlySpan<string> a) { }\n```\n\n----------------------------------------\n\nTITLE: Locking on Public Field in C#\nDESCRIPTION: This code snippet demonstrates locking on a public field within a class. Locking on a public field is considered non-compliant as it exposes the locking mechanism to external code, potentially leading to unexpected behavior or deadlocks. The analyzer flags this as a violation of the MA0064 rule.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0064.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Test\n{\n    public object PublicField;\n    public void A()\n    {\n        lock (PublicField) { } // non compliant\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: UnsafeAccessor without Explicit Name (C#)\nDESCRIPTION: This code snippet demonstrates a non-compliant usage of the `UnsafeAccessor` attribute on a local function without specifying the `Name` parameter. The compiler mangles local function names, making the `Name` parameter mandatory for correct access. This example highlights the issue that MA0146 aims to prevent.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0146.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// non compliant\nvoid Sample()\n{\n    [UnsafeAccessor(UnsafeAccessorKind.Field)]\n    extern static ref int _Major_(System.Version a);\n}\n```\n\n----------------------------------------\n\nTITLE: Async Method Suffix: Compliant Example (C#)\nDESCRIPTION: This C# code snippet demonstrates a compliant example where a method returning a Task has the 'Async' suffix. This adheres to the MA0137 analyzer rule, promoting code readability and consistency.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0137.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\n// compliant\nTask FooAsync() => Task.CompletedTask;\n```\n\n----------------------------------------\n\nTITLE: Initializing Guid using Guid.Empty - C#\nDESCRIPTION: This code snippet demonstrates the MA0067 analyzer rule. It shows examples of non-compliant code where a new Guid is initialized using `new Guid()` or `default(Guid)`, and a compliant example using `Guid.Empty`. The analyzer suggests replacing the non-compliant code with `Guid.Empty` for better readability and potential performance gains.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0067.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n_ = new Guid(); // non-compliant\n_ = default(Guid); // non-compliant\n\n_ = Guid.Empty; // compliant\n```\n\n----------------------------------------\n\nTITLE: Detecting Hidden Symbols in C#\nDESCRIPTION: This C# code snippet demonstrates how the MA0084 analyzer identifies local variables that hide class fields. The analyzer flags the local variable 'a' inside the 'A' method as non-compliant because it shadows the class-level field 'a'.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0084.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Test\n{\n    private string a;\n\n    void A()\n    {\n        string a; // not-compliant as it hides the field\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example of `not` pattern with `null` and `or` in C#\nDESCRIPTION: This snippet shows another example of the problem with the `not` pattern when combined with `or` and used with a null check.  It shows how parentheses can be used to resolve the ambiguity and make the code more readable and explicit.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0164.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\n_ = value is not null or \"\"; // not-compliant\n\n_ = value is (not null) or \"\"; // ok\n_ = value is not (null or \"\"); // ok\n```\n\n----------------------------------------\n\nTITLE: Analyzer Configuration Options\nDESCRIPTION: These configuration options allow customizing the behavior of the MA0076 analyzer.  `MA0076.exclude_tostring_methods=true` excludes ToString methods from analysis. `MA0076.consider_nullable_types=true` reports Nullable<T>.ToString when T is culture-sensitive.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0076.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n# Exclude ToString methods from analysis\nMA0076.exclude_tostring_methods=true\n\n# Report Nullable<T>.ToString when T is culture-sensitive\nMA0076.consider_nullable_types=true\n```\n\n----------------------------------------\n\nTITLE: Configuring MA0051 Analyzer\nDESCRIPTION: This snippet demonstrates how to configure the MA0051 analyzer using an `.editorconfig` file.  It sets the maximum number of lines and statements allowed per method and specifies whether to skip local functions during statement counting.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0051.md#_snippet_0\n\nLANGUAGE: editorconfig\nCODE:\n```\nMA0051.maximum_lines_per_method = 60\nMA0051.maximum_statements_per_method = 40\nMA0051.skip_local_functions = false # skip local functions when counting statements\n```\n\n----------------------------------------\n\nTITLE: MA0168 - Non-compliant example (C#)\nDESCRIPTION: This code snippet shows a non-compliant example where a struct 'Foo' is passed as an 'in' parameter to a method 'A', but the struct 'Foo' is not declared as 'readonly'. This triggers the MA0168 analyzer warning. The expected input is a struct declaration and a method using 'in' parameter.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0168.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvoid A(in Foo p) { } // not-compliant as Foo is not readonly\n\nstruct Foo { }\n```\n\n----------------------------------------\n\nTITLE: XML Comment - Non-compliant Example C#\nDESCRIPTION: This code snippet demonstrates a non-compliant example where the `<c>` tag is used to represent a keyword in an XML comment. The MA0154 analyzer will flag this usage.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0154.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\n// non-compliant\n/// <summary>Sample <c>class</c> keyword</summary>\npublic class Sample { }\n```\n\n----------------------------------------\n\nTITLE: Invalid SupplyParameterFromQuery usage in Blazor\nDESCRIPTION: This code snippet demonstrates an incorrect usage of the `[SupplyParameterFromQuery]` attribute. The attribute is applied to a parameter within a Blazor component, but the component lacks the `@page` directive, making it non-routable. As a result, the query parameter cannot be supplied to the `Value` parameter.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0122.md#_snippet_0\n\nLANGUAGE: razor\nCODE:\n```\n@code {\n    // non-compliant as there is no @page\n    [Parameter, SupplyParameterFromQuery]\n    public int Value { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Attribute without AttributeUsageAttribute C#\nDESCRIPTION: This code snippet demonstrates the non-compliant case where a custom attribute `SampleAttribute` is defined without the `AttributeUsageAttribute`. This means that the attribute can be applied to any code element, which might not be the intended behavior.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0010.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\n// non-compliant\nclass SampleAttribute : System.Attribute { }\n```\n\n----------------------------------------\n\nTITLE: EditorConfig Configuration for MA0002\nDESCRIPTION: This snippet shows how to configure the MA0002 analyzer rule using an .editorconfig file. Specifically, it demonstrates how to exclude the rule from code generated by query operators (e.g., from item in collection orderby item select item).\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0002.md#_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\n# Exclude the rules from code generated by query operators (e.g. from item in collection orderby item select item)\nMA0002.exclude_query_operator_syntaxes = false\n```\n\n----------------------------------------\n\nTITLE: FlagsAttribute Misuse on Enum (C#)\nDESCRIPTION: This code snippet demonstrates a non-compliant example where an enum marked with the FlagsAttribute contains a member ('Orange') that is not a power of two or a combination of other members. This violates the intended usage of FlagsAttribute.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0062.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[Flags] // Non-compliant, as 'Orange' is neither a power of two, nor a bitwise combination of existing \"power of two\" members\npublic enum Color\n{\n    None    = 0,\n    Red     = 1,\n    Orange  = 3,\n    Yellow  = 4,\n}\n```\n\n----------------------------------------\n\nTITLE: Configure Logger Parameter Types via Assembly Attribute (C#)\nDESCRIPTION: This snippet demonstrates the use of the `StructuredLogField` assembly attribute to configure allowed types for logger parameters. This method is applicable only for the current assembly. Requires the Meziantou.Analyzer.Annotations package.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0124.md#_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\n// Requires the Meziantou.Analyzer.Annotations package\n[assembly: Meziantou.Analyzer.Annotations.StructuredLogField(\"Count\", typeof(int), typeof(long))]\n```\n\n----------------------------------------\n\nTITLE: MA0083: ConstructorArgument Validation in C#\nDESCRIPTION: This code snippet demonstrates a violation of the MA0083 analyzer rule. The `ConstructorArgument` attribute is used on the `Value1` property, specifying \"value2\" as the constructor argument. However, no constructor of the `MyMarkupExtension` class accepts a parameter named \"value2\", resulting in a diagnostic message from the analyzer.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0083.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nusing System.Windows.Markup;\n\nnamespace Sample\n{\n    public class MyMarkupExtension : MarkupExtension\n    {\n        public MyMarkupExtension() { }\n\n        public MyMarkupExtension(object value1)\n        {\n            Value1 = value1;\n        }\n\n        [ConstructorArgument(\"value2\")] // non-compliant, \"value2\" is not a parameter of the constructor\n        public object Value1 { get; set; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: MA0075 Configuration\nDESCRIPTION: This snippet shows how to configure the MA0075 analyzer rule. The first option `MA0075.exclude_tostring_methods=true` excludes ToString methods from analysis. The second option `MA0075.consider_nullable_types=true` reports Nullable<T>.ToString when T is culture-sensitive.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0075.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n# Exclude ToString methods from analysis\nMA0075.exclude_tostring_methods=true\n\n# Report Nullable<T>.ToString when T is culture-sensitive\nMA0075.consider_nullable_types=true\n```\n\n----------------------------------------\n\nTITLE: Non-compliant Exception Class Name - C#\nDESCRIPTION: This code snippet demonstrates a non-compliant example where a class inheriting from `System.Exception` does not have a name ending with 'Exception'.  The analyzer will flag this as a violation of the MA0058 rule. No external dependencies are required other than the base class `System.Exception`.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0058.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Sample : Exception // Non compliant\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Razor Component Usage with CaptureUnmatchedValues and PascalCase Parameter\nDESCRIPTION: Demonstrates the usage of `MyComponent` with a valid attribute (`validAttribute`) and an invalid attribute (`InvalidParameter`). Even though `MyComponent` captures unmatched values, `InvalidParameter` will still be reported as an unmatched parameter due to its PascalCase naming, if the `.editorconfig` is configured to do so.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0115.md#_snippet_4\n\nLANGUAGE: razor\nCODE:\n```\n@*\nattribute1 is valid as it starts with a lowercase character\nInvalidParameter is not valid as it starts with an uppercase character\n*@\n<MyComponent validAttribute=\"value\" InvalidParameter=\"value\" />\n```\n\n----------------------------------------\n\nTITLE: MA0108 - Remove redundant argument value in C#\nDESCRIPTION: This C# code snippet demonstrates the MA0108 analyzer rule, which identifies redundant argument values in `ArgumentNullException.ThrowIfNull` calls.  The first call, `ArgumentNullException.ThrowIfNull(value, \"value\")`, is flagged as redundant because the parameter name is already available. The second call, `ArgumentNullException.ThrowIfNull(value)`, is the recommended way to call the method.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0108.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nusing System.Runtime.CompilerServices;\n\nvoid A(string value)\n{\n    ArgumentNullException.ThrowIfNull(value, \"value\"); // report diagnostic\n    ArgumentNullException.ThrowIfNull(value); // ok\n}\n```\n\n----------------------------------------\n\nTITLE: Logger Parameter Types Configuration\nDESCRIPTION: This configuration file (LoggerParameterTypes.txt) defines the valid parameter names that can be used in logging messages when using Microsoft.Extensions.Logging. Each line specifies a parameter name and its corresponding .NET type.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0135.md#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nName;System.String\n```\n\n----------------------------------------\n\nTITLE: Detecting GetType() calls on System.Type instances in C#\nDESCRIPTION: This code snippet demonstrates the scenario where `GetType()` is called on a `System.Type` instance, which is flagged as non-compliant by the analyzer. The analyzer aims to prevent this potentially incorrect usage.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0130.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nSystem.Type type = ...;\ntype.GetType(); // non-compliant\n\nint a = 123;\na.GetType(); // ok\n```\n\n----------------------------------------\n\nTITLE: MA0048 Configuration EditorConfig\nDESCRIPTION: This snippet demonstrates how to configure the MA0048 analyzer rule using a .editorconfig file. It shows how to exclude file-local types from analysis, validate only the first type in a file, and ignore certain symbols using wildcard patterns.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0048.md#_snippet_2\n\nLANGUAGE: editorconfig\nCODE:\n```\n# .editorconfig file\n# Exclude \"file class Sample\" from analysis. default: true\nMA0048.exclude_file_local_types = true\n\n# Only validate the first type in a file. default: false\nMA0048.only_validate_first_type = false\n\n# Ignore certain symbols. default: none\n# Pipe-separated list of wildcard patterns\ndotnet_diagnostic.MA0048.excluded_symbol_names = Foo*|T:MyNamespace.Bar\n```\n\n----------------------------------------\n\nTITLE: Detecting exceptions thrown from finalizers in C#\nDESCRIPTION: This code snippet demonstrates a C# class with a finalizer that throws an exception. The MA0086 analyzer rule flags this as a violation, as throwing exceptions from finalizers can lead to unpredictable behavior and application instability.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0086.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Test\n{\n    ~Test()\n    {\n        throw new Exception(); // non-compliant\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuration Example\nDESCRIPTION: This code snippet shows an example configuration for the MA0125 rule. It specifies a property name and an invalid type ('System.Unknown') which would trigger a diagnostic report. The separator is ';'.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0125.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nPropName;System.Unknown # Report diagnostic\n```\n\n----------------------------------------\n\nTITLE: MA0138 Compliant Example (C#)\nDESCRIPTION: This code snippet demonstrates a compliant method that does not have the 'Async' suffix because it does not return an awaitable type.  This avoids triggering the MA0138 analyzer rule.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0138.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// compliant\nvoid Foo() { }\n```\n\n----------------------------------------\n\nTITLE: FlagsAttribute with 'All' Bitmask (C#)\nDESCRIPTION: This code snippet shows a specific case where the 'All' member is defined as the inverse of 'None'.  This pattern, while technically not a power of two or a combination, is often used to represent all possible flags.  The MA0062 analyzer can be configured to allow this pattern.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0062.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[Flags]\npublic enum MyEnum\n{\n    None    = 0,\n    Option1 = 1,\n    All     = ~None,\n}\n```\n\n----------------------------------------\n\nTITLE: MA0020 Configuration\nDESCRIPTION: This snippet shows how to configure the MA0020 analyzer rule to always report diagnostics, even when arguments need conversion. This is achieved by setting the 'MA0020.report_when_conversion_needed' option to 'true' in the analyzer configuration file.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0020.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[*.cs]\nMA0020.report_when_conversion_needed=true\n```\n\n----------------------------------------\n\nTITLE: Analyzer Configuration (.editorconfig)\nDESCRIPTION: This snippet shows how to configure the MA0062 analyzer to allow the 'All' bitmask pattern using the `.editorconfig` file. Setting `MA0062.allow_all_bits_set_value` to `true` disables the rule for cases where an enum member is the inverse of `None`.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0062.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nMA0062.allow_all_bits_set_value = true\n```\n\n----------------------------------------\n\nTITLE: Apply MA0104 to all Types (.editorconfig)\nDESCRIPTION: This .editorconfig snippet configures the MA0104 analyzer to consider all types, not just public types.  By default, the rule only applies to public types. This setting expands the scope of the MA0104 rule to include internal and private types.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0104.md#_snippet_2\n\nLANGUAGE: .editorconfig\nCODE:\n```\nMA0104.only_consider_public_symbols = false\n```\n\n----------------------------------------\n\nTITLE: Configuring Analyzer Rule Severity in .editorconfig\nDESCRIPTION: This code snippet demonstrates configuring the severity of another diagnostic rule (MA0002) in an .editorconfig file. It sets the severity of the 'IEqualityComparer<string> or IComparer<string> is missing' rule to 'warning', indicating that violations of this rule should be reported as warnings. The general pattern is 'dotnet_diagnostic.[RuleId].severity = [SeverityLevel]'.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/README.md#_snippet_1\n\nLANGUAGE: editorconfig\nCODE:\n```\n# MA0002: IEqualityComparer<string> or IComparer<string> is missing\ndotnet_diagnostic.MA0002.severity = warning\n```\n\n----------------------------------------\n\nTITLE: Razor Component Usage with Invalid Parameter\nDESCRIPTION: Shows how to use the `SampleComponent` and includes an invalid parameter (`InvalidParameter`). The MA0115 analyzer will report a diagnostic on the `InvalidParameter` attribute because it is not a declared parameter of the `SampleComponent`.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0115.md#_snippet_1\n\nLANGUAGE: razor\nCODE:\n```\n<SampleComponent\n    Text=\"Dummy\"\n    InvalidParameter=\"Dummy\" />  // Report diagnostic as `InvalidParameter` does not exist in SampleComponent\n```\n\n----------------------------------------\n\nTITLE: Configure Namespaces Regex for MA0104 (.editorconfig)\nDESCRIPTION: This .editorconfig snippet configures the MA0104 analyzer to consider types within the System namespace (or its sub-namespaces). It also enables the use of types from preview versions of .NET.  This setting customizes the scope of the MA0104 rule.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0104.md#_snippet_1\n\nLANGUAGE: .editorconfig\nCODE:\n```\nMA0104.namespaces_regex = ^System($|\\.)\nMA0104.use_preview_types = true # use types from preview versions of .NET\n```\n\n----------------------------------------\n\nTITLE: Configuring Analyzer Rule Severity in .editorconfig\nDESCRIPTION: This code snippet shows configuring the severity of the MA0037 rule (Remove empty statement) to 'error'. This indicates that any violation of the rule will be reported as an error. The general pattern is 'dotnet_diagnostic.[RuleId].severity = [SeverityLevel]'.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/README.md#_snippet_3\n\nLANGUAGE: editorconfig\nCODE:\n```\n# MA0037: Remove empty statement\ndotnet_diagnostic.MA0037.severity = error\n```\n\n----------------------------------------\n\nTITLE: Configuring Logger Parameter Types - txt\nDESCRIPTION: This configuration file defines the expected types for parameters used in Serilog logging statements. Each line specifies a property name and a list of allowed types, represented by their CLR metadata name or XML comment ID. Lines starting with '#' are treated as comments and ignored.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0139.md#_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n# This is a comment\n\nName;System.String\nCount;System.Int32;System.Int64\nLength;System.Int32;System.Nullable{System.Int32}\nAccountId;System.Nullable{System.Guid}\n\n# Deny parameter\nInvalidParameter;\n```\n\n----------------------------------------\n\nTITLE: Setting MeziantouAnalysisMode in MSBuild\nDESCRIPTION: This snippet shows how to set the `<MeziantouAnalysisMode>` MSBuild property within a project file.  This allows configuration of the default severity of rules provided by the analyzer. Setting the value to `None` will disable all rules by default.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/README.md#_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<Project>\n  <PropertyGroup>\n    <MeziantouAnalysisMode>None</MeziantouAnalysisMode>\n  </PropertyGroup>\n</Project>\n```\n\n----------------------------------------\n\nTITLE: Valid UnsafeAccessorAttribute Signature C#\nDESCRIPTION: This C# code snippet demonstrates the correct usage of `[UnsafeAccessorAttribute]` where the first parameter of the `Demo` method is passed by reference. This will not trigger the MA0145 analyzer.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0145.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[UnsafeAccessor(UnsafeAccessorKind.Field, Name = \"dummy\")]\nextern static ref int Demo(ref MyStruct a); // ok\n```\n\n----------------------------------------\n\nTITLE: StringCreate vs FormattableString Benchmark C#\nDESCRIPTION: This C# code defines a benchmark to compare the performance of `string.Create` and `FormattableString.Invariant` for string interpolation.  It uses BenchmarkDotNet to measure the execution time and memory allocation of each method.  The benchmark includes memory diagnostics and return value validation.\nSOURCE: https://github.com/meziantou/meziantou.analyzer/blob/main/docs/Rules/MA0111.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nusing System.Globalization;\nusing BenchmarkDotNet.Attributes;\n\nnamespace Benchmark;\n\n[MemoryDiagnoser]\n[ReturnValueValidator]\npublic class StringCreateBenchmark\n{\n    int a = 1;\n    DateTime b = DateTime.UtcNow;\n\n    [Benchmark]\n    public string StringCreate()\n    {\n        return string.Create(CultureInfo.InvariantCulture, $\"text {a} test {b}\");\n    }\n\n    [Benchmark]\n    public string FormattableStringInvariant()\n    {\n        return FormattableString.Invariant($\"text {a} test {b}\");\n    }\n}\n```"
  }
]