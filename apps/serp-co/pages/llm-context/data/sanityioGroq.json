[
  {
    "owner": "sanity-io",
    "repo": "groq",
    "content": "TITLE: Basic GROQ Filter Query\nDESCRIPTION: GROQ query demonstrating filtering documents where id is greater than 2 and projecting only the name field.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/01-overview.md#2025-04-12_snippet_1\n\nLANGUAGE: example\nCODE:\n```\n*[id > 2]{name}\n```\n\n----------------------------------------\n\nTITLE: GROQ Query Result\nDESCRIPTION: JSON result showing filtered and projected output from the GROQ query.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/01-overview.md#2025-04-12_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n[\n  { \"name\": \"Drax\"},\n  { \"name\": \"Groot\"},\n  { \"name\": \"Rocket\"}\n]\n```\n\n----------------------------------------\n\nTITLE: GROQ Operator Precedence Table\nDESCRIPTION: Complete ordering of GROQ operators by precedence level (11 highest to 1 lowest) and their associativity rules. Includes compound expressions, arithmetic operators, ranges, comparisons, logical operators, and the arrow operator.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/10-precedence-associativity.md#2025-04-12_snippet_0\n\nLANGUAGE: groq\nCODE:\n```\nLevel 11: Compound expressions\nLevel 10: +, ! (prefix)\nLevel 9: ** (right-associative)\nLevel 8: - (prefix)\nLevel 7: *, /, % (left-associative)\nLevel 6: +, - (left-associative)\nLevel 5: .., ... (non-associative)\nLevel 4: ==, !=, >, >=, <, <=, in, match (non-associative)\nLevel 4: asc, desc (postfix)\nLevel 3: && (left-associative)\nLevel 2: || (left-associative)\nLevel 1: => (non-associative)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Pipe Function Call in GROQ\nDESCRIPTION: Shows how to use pipe functions in GROQ to process arrays. This example filters people documents, orders them by name, and projects the age field.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/07-compound-expressions.md#2025-04-12_snippet_2\n\nLANGUAGE: groq\nCODE:\n```\n*[_type == \"person\"] | order(name) | {age}\n```\n\n----------------------------------------\n\nTITLE: Querying Person Documents with Friends Filter in GROQ\nDESCRIPTION: This GROQ query fetches all documents of type 'person', returning their name and friends from Norway. It demonstrates the use of nested scopes and filters.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/03-execution.md#2025-04-12_snippet_0\n\nLANGUAGE: groq\nCODE:\n```\n*[_type == \"person\"]{name, friends[country == \"NO\"]}\n```\n\n----------------------------------------\n\nTITLE: Using Pipe Function in GROQ Query\nDESCRIPTION: Demonstrates the use of pipe functions in a GROQ query, specifically using the 'order' function to sort results.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/12-pipe-functions.md#2025-04-12_snippet_0\n\nLANGUAGE: groq\nCODE:\n```\n*[_type == \"person\"] | order(name) | {age}\n```\n\n----------------------------------------\n\nTITLE: Projection Traversal in GROQ\nDESCRIPTION: Demonstrates how to create new objects from existing ones by selecting specific fields and computing derived fields with expressions.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/08-traversal-operators.md#2025-04-12_snippet_4\n\nLANGUAGE: example\nCODE:\n```\n*[_type == \"person\"]{name, \"isLegal\": age >= 18}\n                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n```\n\n----------------------------------------\n\nTITLE: Comparing GROQ and JavaScript Equivalents for Data Filtering\nDESCRIPTION: Example demonstrating the equivalence between a GROQ query that filters users by type and returns their IDs, and the equivalent JavaScript code using filter and map functions.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/03-execution.md#2025-04-12_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// The following GROQ:\n*[_type == \"user\"]._id\n\n// is equivalent to the following JavaScript:\ndata.filter(u => u._type == \"user\").map(u => u._id)\n```\n\n----------------------------------------\n\nTITLE: GROQ Equality Algorithm\nDESCRIPTION: Algorithm for determining equality between two values in GROQ. Handles null values and uses partial comparison for other types. Note that unlike SQL, GROQ treats null comparison with non-null values as false.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/05-equality-comparison.md#2025-04-12_snippet_0\n\nLANGUAGE: pseudocode\nCODE:\n```\nEqual(a, b):\n- If both {a} and {b} is {null}:\n  - Return {true}.\n- Let {cmp} be the result of {PartialCompare(a, b)}.\n- If {cmp} is {Equal}:\n  - Return {true}.\n- Otherwise:\n  - Return {false}.\n```\n\n----------------------------------------\n\nTITLE: Querying Person Documents with Children Subquery in GROQ\nDESCRIPTION: This GROQ query fetches all documents of type 'person', returning their id, name, and a subquery for their children. It demonstrates the use of parent expressions for joins.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/03-execution.md#2025-04-12_snippet_1\n\nLANGUAGE: groq\nCODE:\n```\n*[_type == \"person\"]{\n  id,\n  name,\n  \"children\": *[_type == \"person\" && parentId == ^.id]\n}\n```\n\n----------------------------------------\n\nTITLE: Attribute Access Traversal in GROQ\nDESCRIPTION: Demonstrates how to access attributes of an object in GROQ using dot notation or square bracket notation with a string expression.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/08-traversal-operators.md#2025-04-12_snippet_0\n\nLANGUAGE: example\nCODE:\n```\nperson.name\n      ~~~~~\n\nperson[\"Full Name\"]\n      ~~~~~~~~~~~~~\n```\n\n----------------------------------------\n\nTITLE: Scoring Results in GROQ Query\nDESCRIPTION: Shows how to use the 'score' function to assign scores to query results based on a matching condition.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/12-pipe-functions.md#2025-04-12_snippet_1\n\nLANGUAGE: groq\nCODE:\n```\n*[_type == \"listing\"] | score(body match \"jacuzzi\")\n```\n\n----------------------------------------\n\nTITLE: Using GROQ Boost Function Example\nDESCRIPTION: Example showing how to use the boost() function within a score() context to increase relevance of matches in the title field compared to body field matches.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/11-functions.md#2025-04-12_snippet_0\n\nLANGUAGE: groq\nCODE:\n```\n* | score(boost(title matches \"milk\", 5.0), body matches \"milk\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Parenthesis Expression in GROQ\nDESCRIPTION: Shows how parentheses can be used to control operator precedence in GROQ expressions. In this example, the addition operation is performed before multiplication.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/07-compound-expressions.md#2025-04-12_snippet_0\n\nLANGUAGE: groq\nCODE:\n```\n(1 + 2) * 3\n```\n\n----------------------------------------\n\nTITLE: Query Execution Algorithm in GROQ\nDESCRIPTION: Algorithm for executing a GROQ query, which creates a root scope from the context and evaluates the query expression within that scope, returning the final result.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/03-execution.md#2025-04-12_snippet_8\n\nLANGUAGE: pseudocode\nCODE:\n```\nExecuteQuery(query, context):\n\n- Let {scope} be the result of {NewRootScope(context)}.\n- Let {expr} be the expression of {query}.\n- Let {result} be the result of {Evalute(expr, scope)}.\n- Return {result}.\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Traversal Expression in GROQ\nDESCRIPTION: Illustrates how to traverse through nested data structures in GROQ, accessing arrays and dereferencing objects using the arrow operator.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/07-compound-expressions.md#2025-04-12_snippet_1\n\nLANGUAGE: groq\nCODE:\n```\nusers.foo.bar[0].sources[]->name\n```\n\n----------------------------------------\n\nTITLE: Filter Traversal in GROQ\nDESCRIPTION: Shows how to filter an array using a conditional expression, returning only elements that match the specified condition.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/08-traversal-operators.md#2025-04-12_snippet_3\n\nLANGUAGE: example\nCODE:\n```\n*[_type == \"person\"]\n ~~~~~~~~~~~~~~~~~~~\n```\n\n----------------------------------------\n\nTITLE: Using This Expression in GROQ\nDESCRIPTION: A this expression uses the @ symbol to reference the current value in scope. This example filters numbers array elements that are greater than or equal to 10.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/06-simple-expressions.md#2025-04-12_snippet_0\n\nLANGUAGE: groq\nCODE:\n```\n*[_id == \"doc\"][0].numbers[@ >= 10]\n```\n\n----------------------------------------\n\nTITLE: Using Function Call Expressions in GROQ\nDESCRIPTION: Function call expressions invoke built-in GROQ functions. These examples show rounding a score to 2 decimal places and converting a description to lowercase using the global namespace.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/06-simple-expressions.md#2025-04-12_snippet_4\n\nLANGUAGE: groq\nCODE:\n```\n*{\"score\": round(score, 2)}\n```\n\nLANGUAGE: groq\nCODE:\n```\n*{\"description\": global::lower(description)}\n```\n\n----------------------------------------\n\nTITLE: Evaluating Equality Operators in GROQ\nDESCRIPTION: Defines the evaluation process for equality operators (== and !=) in GROQ. It compares two expressions and returns the result based on their equality.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/09-operators.md#2025-04-12_snippet_3\n\nLANGUAGE: GROQ\nCODE:\n```\nEvaluateEquality(scope):\n\n- Let {leftNode} be the first {Expression}.\n- Let {left} be the result of {Evaluate(leftNode, scope)}.\n- Let {rightNode} be the last {Expression}.\n- Let {right} be the result of {Evaluate(rightNode, scope)}.\n- Let {result} be the result of {Equal(left, right)}.\n- If the operator is `!=`:\n  - If {result} is {true}:\n    - Return {false}.\n  - If {result} is {false}:\n    - Return {true}.\n- Return {result}.\n```\n\n----------------------------------------\n\nTITLE: GROQ Total Comparison Algorithm\nDESCRIPTION: Algorithm for total comparison between two values, providing consistent ordering across different types. Uses type ordering and partial comparison to determine the final result.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/05-equality-comparison.md#2025-04-12_snippet_3\n\nLANGUAGE: pseudocode\nCODE:\n```\nTotalCompare(a, b):\n- Let {aTypeOrder} be the result of {TypeOrder(a)}.\n- Let {bTypeOrder} be the result of {TypeOrder(b)}.\n- If {aTypeOrder} != {bTypeOrder}:\n  - Return the result of {PartialCompare(aTypeOrder, bTypeOrder)}.\n- Let {result} be the result of {PartialCompare(a, b)}.\n- If {result} is {null}:\n  - Return {Equal}.\n- Otherwise:\n  - Return {result}.\n```\n\n----------------------------------------\n\nTITLE: Evaluating In Operator in GROQ\nDESCRIPTION: Defines the evaluation process for the IN operator in GROQ. It checks if a value is within a range or an array of values.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/09-operators.md#2025-04-12_snippet_5\n\nLANGUAGE: GROQ\nCODE:\n```\nEvaluateIn(scope):\n\n- Let {leftNode} be the first {Expression}.\n- Let {left} be the result of {Evaluate(leftNode, scope)}.\n- If the right-hand side is a {Range}:\n  - Let {lowerNode} be the start node of the range.\n  - Let {lower} be the result of {Evaluate(lowerNode, scope)}.\n  - Let {upperNode} be the end node of the range.\n  - Let {upper} be the result of {Evaluate(upperNode, scope)}.\n  - Let {leftCmp} be the result of {PartialCompare(left, lower)}.\n  - Let {rightCmp} be the result of {PartialCompare(left, upper)}.\n  - If {leftCmp} or {rightCmp} is {null}:\n    - Return {null}.\n  - If {leftCmp} is {Less}:\n    - Return {false}.\n  - If {rightCmp} is {Greater}:\n    - Return {false}.\n  - If the range is exclusive and {rightCmp} is {Equal}:\n    - Return {false}.\n  - Return {true}.\n- Let {rightNode} be the last {Expression}.\n- Let {right} be the result of {Evaluate(rightNode, scope)}.\n- If {right} is an array:\n  - For each {value} in {right}:\n    - If {Equal(left, value)} is {true}:\n      - Return {true}.\n  - Return {false}.\n- Return {null}.\n```\n\n----------------------------------------\n\nTITLE: Element Access Traversal in GROQ\nDESCRIPTION: Shows how to access elements within an array using square bracket notation with an index. Supports 0-based indexing and negative indices to access elements from the end of the array.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/08-traversal-operators.md#2025-04-12_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Evaluating Match Operator in GROQ\nDESCRIPTION: Defines the evaluation process for the MATCH operator in GROQ. It checks if a string or array of strings matches any of the given patterns.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/09-operators.md#2025-04-12_snippet_6\n\nLANGUAGE: GROQ\nCODE:\n```\nEvaluateMatch(scope):\n\n- Let {leftNode} be the first {Expression}.\n- Let {left} be the result of {Evaluate(leftNode, scope)}.\n- Let {rightNode} be the last {Expression}.\n- Let {right} be the result of {Evaluate(rightNode, scope)}.\n- Let {tokens} be an empty array.\n- If {left} is a string:\n  - Concatenate {MatchTokenize(left)} to {tokens}.\n- If {left} is an array:\n  - For each {value} in {left}:\n    - If {value} is a string:\n      - Concatenate {MatchTokenize(value)} to {tokens}.\n- Let {patterns} be an empty array.\n- If {right} is a string:\n  - Append {MatchAnalyzePattern(right)} to {patterns}.\n- If {right} is an array:\n  - For each {value} in {right}:\n    - If {value} is a string:\n      - Append {MatchAnalyzePattern(value)} to {patterns}.\n    - Otherwise: \\* Return {false}.\n- If {patterns} is empty:\n  - Return {false}.\n- For each {pattern} in {patterns}:\n  - If {pattern} does not matches {tokens}:\n    - Return {false}.\n- Return {true}.\n```\n\n----------------------------------------\n\nTITLE: Evaluating Comparison Operators in GROQ\nDESCRIPTION: Defines the evaluation process for comparison operators (<, <=, >, >=) in GROQ. It compares two expressions and returns the result based on their relative values.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/09-operators.md#2025-04-12_snippet_4\n\nLANGUAGE: GROQ\nCODE:\n```\nEvaluateComparison(scope):\n\n- Let {leftNode} be the first {Expression}.\n- Let {left} be the result of {Evaluate(leftNode, scope)}.\n- Let {rightNode} be the last {Expression}.\n- Let {right} be the result of {Evaluate(rightNode, scope)}.\n- Let {cmp} be the result of {PartialCompare(left, right)}.\n- If {cmp} is {null}:\n  - Return {null}.\n- If {cmp} is {Less} and the operator is {<} or {<=}:\n  - Return {true}.\n- If {cmp} is {Greater} and the operator is {>} or {>=}:\n  - Return {true}.\n- If {cmp} is {Equal} and the operator is {<=} or {>=}:\n  - Return {true}.\n- Return {false}.\n```\n\n----------------------------------------\n\nTITLE: Evaluating Binary Plus Operator in GROQ\nDESCRIPTION: Defines the evaluation process for the binary plus (+) operator in GROQ. It handles string concatenation, numeric addition, array concatenation, object merging, and datetime addition.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/09-operators.md#2025-04-12_snippet_9\n\nLANGUAGE: GROQ\nCODE:\n```\nEvaluatePlus(scope):\n\n- Let {leftNode} be the first {Expression}.\n- Let {left} be the result of {Evaluate(leftNode, scope)}.\n- Let {rightNode} be the last {Expression}.\n- Let {right} be the result of {Evaluate(rightNode, scope)}.\n- If both {left} and {right} are strings:\n  - Return the string concatenation of {left} and {right}.\n- If both {left} and {right} are numbers:\n  - Return the addition of {left} and {right}.\n- If both {left} and {right} are arrays:\n  - Return the concatenation of {left} and {right}.\n- If both {left} and {right} are objects:\n  - Return the merged object of {left} and {right}. For duplicate fields the value from {right} takes precedence.\n- If {left} is a datetime and {right} is a number:\n  - Return a new datetime that adds (or subtracts, if negative) {right} as a number of seconds to {left}.\n- Return {null}.\n```\n\n----------------------------------------\n\nTITLE: GROQ Type Order Algorithm\nDESCRIPTION: Algorithm for determining the ordering of different data types in GROQ, used in total comparison operations. Assigns numeric values to different types for consistent ordering.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/05-equality-comparison.md#2025-04-12_snippet_2\n\nLANGUAGE: pseudocode\nCODE:\n```\nTypeOrder(val):\n- If {val} is a datetime:\n  - Return 1.\n- If {val} is a number:\n  - Return 2.\n- If {val} is a string:\n  - Return 3.\n- If {val} is a boolean:\n  - Return 4.\n- Return 5.\n```\n\n----------------------------------------\n\nTITLE: Implementing array::unique() Function in GROQ\nDESCRIPTION: Filters duplicate values from an array, considering equality for comparable values. Takes one argument: the input array.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/11-functions.md#2025-04-12_snippet_9\n\nLANGUAGE: pseudocode\nCODE:\n```\narray_unique(args, scope):\n\n- Let {arrNode} be the first element of {args}.\n- Let {arr} be the result of {Evaluate(arrNode, scope)}.\n- If {arr} is not an array:\n  - Return {null}.\n- Let {output} be an empty array.\n- For each element in {arr}:\n  - Let {elem} be the element\n  - Let {found} be false.\n  - If {elem} is comparable (see above):\n    - For each element in {arr}:\n      - Let {b} be the element.\n      - Set {found} be the result of `Equal(elem, b)`\n      - If {found} is true:\n        - Break loop\n  - If {found} is false:\n    - Add {elem} to {output} at any position.\n- Return {output}.\n\narray_unique_validate(args):\n\n- If the length of {args} is not 1:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Using This Attribute Expression in GROQ\nDESCRIPTION: This attribute expressions reference a property on the current object scope. This example filters documents where the name attribute equals \"Michael Bluth\".\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/06-simple-expressions.md#2025-04-12_snippet_1\n\nLANGUAGE: groq\nCODE:\n```\n*[_id == \"document\"][name == \"Michael Bluth\"]\n```\n\n----------------------------------------\n\nTITLE: Implementing array::intersects() Function in GROQ\nDESCRIPTION: Compares two arrays and returns true if they have any elements in common. Takes two arguments: the two arrays to compare.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/11-functions.md#2025-04-12_snippet_10\n\nLANGUAGE: pseudocode\nCODE:\n```\narray_intersects(args, scope):\n\n- Let {firstNode} be the first element of {args}.\n- Let {first} be the result of {Evaluate(firstNode, scope)}.\n- If {first} is not an array:\n  - Return {null}.\n- Let {secondNode} be the first element of {args}.\n- Let {second} be the result of {Evaluate(secondNode, scope)}.\n- If {second} is not an array:\n  - Return {null}.\n- For each element in {first}:\n  - Let {a} be the element.\n  - For each element in {second}:\n    - Let {b} be the element.\n    - Set {equal} to be the result of `Equal(a, b)`.\n    - If {equal} is true:\n      - Return {true}.\n- Return {false}.\n\narray_intersects_validate(args):\n\n- If the length of {args} is not 2:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Implementing max() function in GROQ\nDESCRIPTION: Finds the largest numeric value in an array. Null values are ignored, non-numbers cause null return. Returns null if array contains no numeric values.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/11-functions.md#2025-04-12_snippet_19\n\nLANGUAGE: pseudocode\nCODE:\n```\nmath_max(args, scope):\n\n- Let {arrNode} be the first element of {args}.\n- Let {arr} be the result of {Evaluate(arrNode, scope)}.\n- If {arr} is not an array, return {null}.\n- Let {max} be {null}.\n- For each element {elem} in {arr}:\n  - If {elem} is null:\n    - Ignore it.\n  - If {elem} is not a number:\n    - Return {null}.\n  - Otherwise:\n    - If {max} is {null} or {PartialCompare(elem, max)} is {Greater}:\n      - Set {max} to {elem}.\n- Return {max}.\n```\n\n----------------------------------------\n\nTITLE: Implementing sum() function in GROQ\nDESCRIPTION: The sum function computes the sum of all numbers in an array. Null values are ignored, non-numbers cause null return. Returns 0 if array contains no numeric values.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/11-functions.md#2025-04-12_snippet_13\n\nLANGUAGE: pseudocode\nCODE:\n```\nmath_sum(args, scope):\n\n- Let {arrNode} be the first element of {args}.\n- Let {arr} be the result of {Evaluate(arrNode, scope)}.\n- If {arr} is not an array, return {null}.\n- Let {n} be zero.\n- For each element {elem} in {arr}:\n  - If {elem} is null:\n    - Ignore it.\n  - If {elem} is not a number:\n    - Return {null}.\n  - Otherwise:\n    - Add {elem} to {n}.\n- Return {n}.\n```\n\n----------------------------------------\n\nTITLE: Slice Traversal in GROQ\nDESCRIPTION: Demonstrates how to extract a subset of elements from an array using range notation, defining start and end indices.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/08-traversal-operators.md#2025-04-12_snippet_2\n\nLANGUAGE: example\nCODE:\n```\npeople[0..10]\n      ~~~~~~~\n```\n\n----------------------------------------\n\nTITLE: Implementing min() function in GROQ\nDESCRIPTION: Finds the smallest numeric value in an array. Null values are ignored, non-numbers cause null return. Returns null if array contains no numeric values.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/11-functions.md#2025-04-12_snippet_17\n\nLANGUAGE: pseudocode\nCODE:\n```\nmath_min(args, scope):\n\n- Let {arrNode} be the first element of {args}.\n- Let {arr} be the result of {Evaluate(arrNode, scope)}.\n- If {arr} is not an array, return {null}.\n- Let {min} be {null}.\n- For each element {elem} in {arr}:\n  - If {elem} is null:\n    - Ignore it.\n  - If {elem} is not a number:\n    - Return {null}.\n  - Otherwise:\n    - If {min} is {null} or {PartialCompare(elem, min)} is {Lower}:\n      - Set {min} to {elem}.\n- Return {min}.\n```\n\n----------------------------------------\n\nTITLE: Implementing avg() function in GROQ\nDESCRIPTION: Computes the arithmetic mean of all numbers in an array. Null values are ignored, non-numbers cause null return. Returns null if array contains no numeric values.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/11-functions.md#2025-04-12_snippet_15\n\nLANGUAGE: pseudocode\nCODE:\n```\nmath_avg(args, scope):\n\n- Let {arrNode} be the first element of {args}.\n- Let {arr} be the result of {Evaluate(arrNode, scope)}.\n- If {arr} is not an array, return {null}.\n- Let {n} be zero.\n- Let {count} be zero.\n- For each element {elem} in {arr}:\n  - If {elem} is null:\n    - Ignore it.\n  - If {elem} is not a number:\n    - Return {null}.\n  - Otherwise:\n    - Increment {count}.\n    - Add {elem} to {n}.\n- If {count} is zero:\n  - Return {null}.\n- Return {n} divided by the {count}.\n```\n\n----------------------------------------\n\nTITLE: Implementing global::pt() Function for Portable Text Validation\nDESCRIPTION: This function evaluates whether an input object or array of objects conforms to the Portable Text specification. It returns the original value if valid, or null if invalid.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/14-extensions.md#2025-04-12_snippet_0\n\nLANGUAGE: pseudocode\nCODE:\n```\nglobal_pt(args, scope):\n\n- Let {baseNode} be the first element of {args}.\n- Let {base} be the result of {Evaluate(baseNode, scope)}.\n- If {base} is an object:\n  - Try to parse it as Portable Text Block:\n  - If {base} is a valid Portable Text Block:\n    - Return {base}.\n- If {base} is an array of objects:\n  - Try to parse it as an array of Portable Text blocks:\n    - If all elements in {base} array are valid Portable Text blocks:\n      - Return {base}.\n- Otherwise:\n  - Return {null}.\n```\n\n----------------------------------------\n\nTITLE: Scoring Documents Based on a Condition in GROQ\nDESCRIPTION: This GROQ query scores all documents based on whether 'a' is greater than 1. It demonstrates the basic use of the score function.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/03-execution.md#2025-04-12_snippet_2\n\nLANGUAGE: groq\nCODE:\n```\n* | score(a > 1)\n```\n\n----------------------------------------\n\nTITLE: Implementing global::geo() Function for Geographic Data\nDESCRIPTION: This function constructs a geographic value from an object or another geo value. It attempts to parse the input as either a Geo Point or GeoJSON object.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/14-extensions.md#2025-04-12_snippet_4\n\nLANGUAGE: pseudocode\nCODE:\n```\nglobal_geo(args, scope):\n\n- Let {baseNode} be the first element of {args}.\n- Let {base} be the result of {Evaluate(baseNode, scope)}.\n- If {base} is an object:\n  - Try to parse it as Geo Point and GeoJSON:\n  - If {base} is a valid geo value:\n    - Return {base}.\n- If {base} is a geo value:\n  - Return {base}.\n- Otherwise:\n  - Return {null}.\n```\n\n----------------------------------------\n\nTITLE: Using Everything Expression in GROQ\nDESCRIPTION: The everything expression uses the * symbol to reference the entire dataset. This example selects all documents where _type equals \"person\".\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/06-simple-expressions.md#2025-04-12_snippet_2\n\nLANGUAGE: groq\nCODE:\n```\n*[_type == \"person\"]\n```\n\n----------------------------------------\n\nTITLE: Implementing geo::intersects() Function for Spatial Intersection\nDESCRIPTION: This function determines if two geo values intersect in planar space. It returns true if the geo values share any geometric points.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/14-extensions.md#2025-04-12_snippet_10\n\nLANGUAGE: pseudocode\nCODE:\n```\ngeo_intersects(args, scope):\n\n- Let {firstNode} be the first element of {args}.\n- Let {secondNode} be the second element of {args}.\n- Let {first} be the result of {Evaluate(firstNode, scope)}.\n- Let {second} be the result of {Evaluate(secondNode, scope)}.\n- If {first} or {second} is a not a geo value:\n  - Return {null}.\n- If {first} intersects {second}:\n  - Return {true}.\n- Otherwise:\n  - Return {false}.\n```\n\n----------------------------------------\n\nTITLE: Evaluating Binary Minus Operator in GROQ\nDESCRIPTION: Defines the evaluation process for the binary minus (-) operator in GROQ. It handles numeric subtraction, datetime difference, and datetime subtraction.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/09-operators.md#2025-04-12_snippet_10\n\nLANGUAGE: GROQ\nCODE:\n```\nEvaluateMinus(scope):\n\n- Let {leftNode} be the first {Expression}.\n- Let {left} be the result of {Evaluate(leftNode, scope)}.\n- Let {rightNode} be the last {Expression}.\n- Let {right} be the result of {Evaluate(rightNode, scope)}.\n- If both {left} and {right} are numbers:\n  - Return the subtraction of {left} from {right}.\n- If both {left} and {right} are datetimes:\n  - Return the difference, in seconds, between {left} from {right}.\n- If {left} is a datetime and {right} is a number:\n  - Return a new datetime being {left} minus {right} as seconds.\n- Return {null}.\n```\n\n----------------------------------------\n\nTITLE: GROQ Partial Comparison Algorithm\nDESCRIPTION: Detailed algorithm for partial comparison between two values, handling different types including datetime, numbers, strings, and booleans. Returns Greater, Equal, Less, or null for incomparable values.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/05-equality-comparison.md#2025-04-12_snippet_1\n\nLANGUAGE: pseudocode\nCODE:\n```\nPartialCompare(a, b):\n- If the type of {a} is different from the type of {b}:\n  - Return {null}.\n- If {a} is a datetime, consider the datetimes as absolute points in time in the UTC time zone:\n  - If a < b:\n    - Return {Less}.\n  - If a > b:\n    - Return {Greater}.\n  - If a = b:\n    - Return {Equal}.\n- If {a} is a number:\n  - If a < b:\n    - Return {Less}.\n  - If a > b:\n    - Return {Greater}.\n  - If a = b:\n    - Return {Equal}.\n- If {a} is a string:\n  - For each Unicode code point ({aCodePoint}, {bCodePoint}) in {a} and {b}:\n    - If {aCodePoint} < {bCodePoint}:\n      - Return {Less}.\n    - If {aCodePoint} > {bCodePoint}: \\* Return {Greater}.\n  - If {a} is shorter than {b}:\n    - Return {Less}.\n  - If {a} is longer than {b}:\n    - Return {Greater}.\n  - Return {Equal}.\n- If {a} is a boolean:\n  - Return the comparison between {a} and {b} with {false} < {true}.\n- Return {null}.\n```\n\n----------------------------------------\n\nTITLE: Multiple Scoring Expressions in GROQ Query\nDESCRIPTION: Illustrates the use of multiple scoring expressions in a single 'score' function call to evaluate and rank results based on multiple criteria.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/12-pipe-functions.md#2025-04-12_snippet_2\n\nLANGUAGE: groq\nCODE:\n```\n*[_type == \"listing\"] | score(body match \"jacuzzi\", bedrooms > 2, available && !inContract)\n```\n\n----------------------------------------\n\nTITLE: Evaluating And Operator in GROQ\nDESCRIPTION: Defines the evaluation process for the AND (&&) operator in GROQ. It checks both operands and returns true only if both are true, false if either is false, and null for non-boolean operands.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/09-operators.md#2025-04-12_snippet_0\n\nLANGUAGE: GROQ\nCODE:\n```\nEvaluateAnd(scope):\n\n- Let {leftNode} be the first {Expression}.\n- Let {left} be the result of {Evaluate(leftNode, scope)}.\n- Let {rightNode} be the last {Expression}.\n- Let {right} be the result of {Evaluate(rightNode, scope)}.\n- If {left} or {right} is {false}:\n  - Return {false}.\n- If {left} or {right} is not a boolean:\n  - Return {null}.\n- Return {true}.\n```\n\n----------------------------------------\n\nTITLE: Implementing array::join() Function in GROQ\nDESCRIPTION: Concatenates elements of an array into a single string using a specified separator. Takes two arguments: the array and the separator string.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/11-functions.md#2025-04-12_snippet_7\n\nLANGUAGE: pseudocode\nCODE:\n```\narray_join(args, scope):\n\n- Let {arrNode} be the first element of {args}.\n- Let {sepNode} be the second element of {args}.\n- Let {arr} be the result of {Evaluate(arrNode, scope)}.\n- Let {sep} be the result of {Evaluate(sepNode, scope)}.\n- If {arr} is not an array:\n  - Return {null}.\n- If {sep} is not a string:\n  - Return {null}.\n- Let {output} be an empty string.\n- For each element in {arr}:\n  - Let {elem} be the element.\n  - Let {index} be the index of the element.\n  - If {index} is greater than or equal to 1, append {sep} to {output}.\n  - Let {str} be the result of evaluating `global::string(elem)`.\n  - If {str} is {null}:\n    - Return {null}.\n  - Otherwise:\n    - Append {str} to {output}.\n- Return {output}.\n\narray_join_validate(args):\n\n- If the length of {args} is not 2:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Evaluating Or Operator in GROQ\nDESCRIPTION: Defines the evaluation process for the OR (||) operator in GROQ. It returns true if either operand is true, false if both are false, and null if any operand is non-boolean.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/09-operators.md#2025-04-12_snippet_1\n\nLANGUAGE: GROQ\nCODE:\n```\nEvaluateOr(scope):\n\n- Let {leftNode} be the first {Expression}.\n- Let {left} be the result of {Evaluate(leftNode, scope)}.\n- Let {rightNode} be the last {Expression}.\n- Let {right} be the result of {Evaluate(rightNode, scope)}.\n- If {left} or {right} is {true}:\n  - Return {true}.\n- If {left} or {right} is not a boolean:\n  - Return {null}.\n- Return {false}.\n```\n\n----------------------------------------\n\nTITLE: Using Parent Expression in GROQ\nDESCRIPTION: The parent expression (^) references a higher-level scope. This example finds people who have a reference to a friend document that has the isCool property.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/06-simple-expressions.md#2025-04-12_snippet_3\n\nLANGUAGE: groq\nCODE:\n```\n// Find all people who have a cool friend\n*[_type == \"person\" && *[_id == ^.friend._ref][0].isCool]\n```\n\n----------------------------------------\n\nTITLE: Evaluating Not Operator in GROQ\nDESCRIPTION: Defines the evaluation process for the NOT (!) operator in GROQ. It returns the opposite boolean value for true or false, and null for non-boolean values.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/09-operators.md#2025-04-12_snippet_2\n\nLANGUAGE: GROQ\nCODE:\n```\nEvaluateNot(scope):\n\n- Let {valueNode} be the {Expression}.\n- Let {value} be the result of {Evaluate(valueNode, scope)}.\n- If {value} is {false}:\n  - Return {true}.\n- If {value} is {true}:\n  - Return {false}.\n- Return {null}.\n```\n\n----------------------------------------\n\nTITLE: Implementing array::compact() Function in GROQ\nDESCRIPTION: Filters null values from an array. Takes one argument: the input array.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/11-functions.md#2025-04-12_snippet_8\n\nLANGUAGE: pseudocode\nCODE:\n```\narray_compact(args, scope):\n\n- Let {arrNode} be the first element of {args}.\n- Let {arr} be the result of {Evaluate(arrNode, scope)}.\n- If {arr} is not an array:\n  - Return null\n- Let {output} be an empty array.\n- For each element in {arr}:\n  - Let {elem} be the element\n  - If {elem} is not null:\n    - Append {elem} to {output}.\n- Return {output}.\n\narray_compact_validate(args):\n\n- If the length of {args} is not 1:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Implementing diff::changedAny() Function in GROQ\nDESCRIPTION: Compares two objects and returns true if any key paths matched by the selector are changed. Takes three arguments: left-hand side, right-hand side, and a selector.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/11-functions.md#2025-04-12_snippet_2\n\nLANGUAGE: pseudocode\nCODE:\n```\ndiff_changedAny(args, scope):\n\n- Let {lhs} be the first element of {args}.\n- Let {rhs} be the second element of {args}.\n- Let {selector} be the third element of {args}.\n- Let {before} be the result of {Evaluate(lhs, scope)}.\n- Let {after} be the result of {Evaluate(rhs, scope)}.\n- Let {selectedKeyPaths} be the result of {EvaluateSelector(selector, before, scope)}.\n- Let {diffKeyPaths} be the list of key paths that are different in {before} and {after}.\n- If {diffKeyPaths} overlaps with {selectedKeyPaths}:\n  - Return {true}.\n- Otherwise:\n  - Return {false}.\n\ndiff_changedAny_validate(args):\n\n- If the length of {args} is not 3:\n  - Report an error.\n- If the third element is not a {Selector}:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Implementing string::startsWith() Function in GROQ\nDESCRIPTION: Evaluates whether a string starts with a given prefix. Takes two arguments: the input string and the prefix string.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/11-functions.md#2025-04-12_snippet_12\n\nLANGUAGE: pseudocode\nCODE:\n```\nstring_startsWith(args, scope):\n\n- Let {strNode} be the first element of {args}.\n- Let {prefixNode} be the second element of {args}.\n- Let {str} be the result of {Evaluate(strNode, scope)}.\n- If {str} is not a string, return {null}.\n- Let {prefix} be the result of {Evaluate(sepNode, scope)}.\n- If {prefix} is not a string, return {null}.\n- Let {n} be the length of {prefix}.\n- If {n} is zero:\n  - Return true.\n- If the first {n} characters of {str} equal {prefix}:\n  - Return true.\n- Otherwise return false.\n\nstring_startsWith_validate(args):\n\n- If the length of {args} is not 2:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Implementing diff::changedOnly() Function in GROQ\nDESCRIPTION: Compares two objects and returns true if only the key paths matched by the selector are changed. Takes three arguments: left-hand side, right-hand side, and a selector.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/11-functions.md#2025-04-12_snippet_3\n\nLANGUAGE: pseudocode\nCODE:\n```\ndiff_changedOnly(args, scope):\n\n- Let {lhs} be the first element of {args}.\n- Let {rhs} be the second element of {args}.\n- Let {selector} be the third element of {args}.\n- Let {before} be the result of {Evaluate(lhs, scope)}.\n- Let {after} be the result of {Evaluate(rhs, scope)}.\n- Let {selectedKeyPaths} be the result of {EvaluateSelector(selector, before, scope)}.\n- Let {diffKeyPaths} be the list of key paths that are different in {before} and {after}.\n- If {diffKeyPaths} is a subset of {selectedKeyPaths}:\n  - Return {true}.\n- Otherwise:\n  - Return {false}.\n\ndiff_changedOnly_validate(args):\n\n- If the length of {args} is not 3:\n  - Report an error.\n- If the third element is not a {Selector}:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Evaluating Binary Star Operator in GROQ\nDESCRIPTION: Defines the evaluation process for the binary star (*) operator in GROQ. It performs multiplication for numeric operands.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/09-operators.md#2025-04-12_snippet_11\n\nLANGUAGE: GROQ\nCODE:\n```\nEvaluateStar(scope):\n\n- Let {leftNode} be the first {Expression}.\n- Let {left} be the result of {Evaluate(leftNode, scope)}.\n- Let {rightNode} be the last {Expression}.\n- Let {right} be the result of {Evaluate(rightNode, scope)}.\n- If both {left} and {right} are numbers:\n  - Return the multiplication of {left} and {right}.\n- Return {null}.\n```\n\n----------------------------------------\n\nTITLE: Implementing delta::changedAny Function in GROQ\nDESCRIPTION: A variant of diff::changedAny that works on before/after objects in delta mode. Takes a selector as an argument and compares the before and after states.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/11-functions.md#2025-04-12_snippet_4\n\nLANGUAGE: pseudocode\nCODE:\n```\ndelta_changedAny(args, scope):\n\n- Let {before} and {after} be the before/after objects of the query context to {scope}.\n- Let {selector} by the first element of {args}.\n- Let {result} be the result of {diff_changedAny(before, after, selector)}.\n- Return {result}.\n\ndelta_changedAny_validate(args, scope):\n\n- If the mode of the query context of {scope} is not \"delta\":\n  - Report an error.\n- If the first element is not a {Selector}:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Implementing string::split() Function in GROQ\nDESCRIPTION: Splits a string into multiple strings given a separator string. Takes two arguments: the input string and the separator string.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/11-functions.md#2025-04-12_snippet_11\n\nLANGUAGE: pseudocode\nCODE:\n```\nstring_split(args, scope):\n\n- Let {strNode} be the first element of {args}.\n- Let {sepNode} be the second element of {args}.\n- Let {str} be the result of {Evaluate(strNode, scope)}.\n- If {str} is not a string, return {null}.\n- Let {sep} be the result of {Evaluate(sepNode, scope)}.\n- If {sep} is not a string, return {null}.\n- Let {output} be an empty array.\n- If {sep} is an empty string:\n  - Let {output} be each character of {str}, according to Unicode character splitting rules.\n- Otherwise:\n  - Let {output} be each substring of {str} as separated by {sep}. An empty string is considered a substring, and will be included when {sep} is present at the beginning, the end, or consecutively of {str}. For example, the string `,a,b,` when split by `,` will result in four substrings `['', 'a', 'b', '']`.\n- Return {output}.\n\nstring_split_validate(args):\n\n- If the length of {args} is not 2:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Implementing delta::changedOnly Function in GROQ\nDESCRIPTION: A variant of diff::changedOnly that works on before/after objects in delta mode. Takes a selector as an argument and compares the before and after states.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/11-functions.md#2025-04-12_snippet_5\n\nLANGUAGE: pseudocode\nCODE:\n```\ndelta_changedOnly(args, scope):\n\n- Let {before} and {after} be the before/after objects of the query context to {scope}.\n- Let {selector} by the first element of {args}.\n- Let {result} be the result of {diff_changedOnly(before, after, selector)}.\n- Return {result}.\n\ndelta_changedOnly_validate(args, scope):\n\n- If the mode of the query context of {scope} is not \"delta\":\n  - Report an error.\n- If the first element is not a {Selector}:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Implementing geo::latLng() Function for Creating Geo Points\nDESCRIPTION: This function creates a GeoJSON Point from latitude and longitude coordinates. It validates that the coordinates are within valid ranges (-90 to 90 for latitude, -180 to 180 for longitude).\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/14-extensions.md#2025-04-12_snippet_6\n\nLANGUAGE: pseudocode\nCODE:\n```\ngeo_latLng(args, scope):\n\n- Let {latNode} be the first element of {args}.\n- Let {lngNode} be the second element of {args}.\n- Let {lat} be the result of {Evaluate(latNode, scope)}.\n- Let {lng} be the result of {Evaluate(lngNode, scope)}.\n- If {lat} or {lng} is not a number:\n  - Return {null}.\n- If {lat} is not in the range of -90 to 90:\n  - Return {null}.\n- If {lng} is not in the range of -180 to 180:\n  - Return {null}.\n- Otherwise:\n  - Return a GeoJSON Point with {lat} and {lng} as coordinates, in lng, lat order.\n```\n\n----------------------------------------\n\nTITLE: Traversal Join Evaluation Function in GROQ\nDESCRIPTION: Algorithm for evaluating joined traversals in GROQ, which applies traversals sequentially. This is used for operations like '.user.name' where traversals are chained directly.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/03-execution.md#2025-04-12_snippet_4\n\nLANGUAGE: pseudocode\nCODE:\n```\nEvaluateTraversalJoin(base, scope):\n\n- Let {traverse} be the traverse function of the first node.\n- Let {nextTraverse} be the traverse function of the last node.\n- Let {result} to be the result of {traverse(base, scope)}.\n- Set {result} to be the result of {nextTraverse(result, scope)}.\n- Return {result}.\n```\n\n----------------------------------------\n\nTITLE: Implementing geo::distance() Function for Geographic Distance Calculation\nDESCRIPTION: This function calculates the distance in meters between two geo points. It uses an implementation-defined algorithm (such as Haversine formula) to approximate Earth distance as accurately as possible.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/14-extensions.md#2025-04-12_snippet_12\n\nLANGUAGE: pseudocode\nCODE:\n```\ngeo_distance(args, scope):\n\n- Let {firstNode} be the first element of {args}.\n- Let {secondNode} be the second element of {args}.\n- Let {first} be the result of {Evaluate(firstNode, scope)}.\n- Let {second} be the result of {Evaluate(secondNode, scope)}.\n- If {first} or {second} is a not a geo value:\n  - Return {null}.\n- If {first} or {second} is a not a Geo Point or GeoJSON Point:\n  - Return {null}.\n- Let {distance} be the geographic distance between {first} and {second}:\n  - Return {distance}.\n- Otherwise:\n  - Return {null}.\n```\n\n----------------------------------------\n\nTITLE: Traversal Map Evaluation Function in GROQ\nDESCRIPTION: Algorithm for evaluating mapped traversals in GROQ, which applies a traversal to each element of an array. This is used for operations like '[_type == \"user\"].id' where the second traversal is applied to each result of the first.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/03-execution.md#2025-04-12_snippet_5\n\nLANGUAGE: pseudocode\nCODE:\n```\nEvaluateTraversalMap(base, scope):\n\n- Let {traverse} be the traverse function of the first node.\n- Let {nextTraverse} be the traverse function of the last node.\n- Set {base} to be the result of {traverse(base, scope)}.\n- If {base} is not an array:\n  - Return {null}.\n- Let {result} be an empty array.\n- For each {value} in {base}:\n  - Let {elem} be the result of {nextTraverse(value, scope)}.\n  - Append {elem} to {result}.\n- Return {result}.\n```\n\n----------------------------------------\n\nTITLE: Evaluating Binary Percent Operator in GROQ\nDESCRIPTION: Defines the evaluation process for the binary percent (%) operator in GROQ. It calculates the remainder of division for numeric operands.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/09-operators.md#2025-04-12_snippet_13\n\nLANGUAGE: GROQ\nCODE:\n```\nEvaluatePercent(scope):\n\n- Let {leftNode} be the first {Expression}.\n- Let {left} be the result of {Evaluate(leftNode, scope)}.\n- Let {rightNode} be the last {Expression}.\n- Let {right} be the result of {Evaluate(rightNode, scope)}.\n- If both {left} and {right} are numbers:\n  - Return the remainder of {left} after division by {right}.\n- Return {null}.\n```\n\n----------------------------------------\n\nTITLE: Traversal FlatMap Evaluation Function in GROQ\nDESCRIPTION: Algorithm for evaluating flat-mapped traversals in GROQ, which applies a traversal to each element of an array and flattens the result. Used for operations like '[_type == \"user\"].names[]' which return flattened arrays.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/03-execution.md#2025-04-12_snippet_6\n\nLANGUAGE: pseudocode\nCODE:\n```\nEvaluateTraversalFlatMap(base, scope):\n\n- Let {traverse} be the traverse function of the first node.\n- Let {nextTraverse} be the traverse function of the last node.\n- Set {base} to be the result of {traverse(base, scope)}.\n- If {base} is not an array:\n  - Return {null}.\n- Let {result} be an empty array.\n- For each {value} in {base}:\n  - Let {elem} be the result of {nextTraverse(value, scope)}.\n  - If {elem} is an array:\n    - Concatenate {elem} to {result}.\n- Return {result}.\n```\n\n----------------------------------------\n\nTITLE: Implementing pt::text() Function for Portable Text Conversion\nDESCRIPTION: This function extracts plain text from Portable Text blocks. When processing multiple blocks, it joins them with double newlines in the output string.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/14-extensions.md#2025-04-12_snippet_2\n\nLANGUAGE: pseudocode\nCODE:\n```\npt_text(args, scope):\n\n- Let {baseNode} be the first element of {args}.\n- Let {base} be the result of {Evaluate(baseNode, scope)}.\n- If {base} is an object:\n  - Try to parse it as Portable Text Block:\n  - If {base }is a valid Portable Text Block:\n    - Return string version of text in {base}.\n- If {base} is an array of objects:\n  - Try to parse it as an array of Portable Text blocks:\n  - If all elements in {base} array are valid Portable Text blocks:\n    - Return string version of text in {base}.\n- Otherwise:\n  - Return {null}.\n```\n\n----------------------------------------\n\nTITLE: Evaluating Object in GROQ\nDESCRIPTION: This function evaluates an object expression in GROQ, handling spread operators, nested expressions, and attribute naming.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/04-data-types.md#2025-04-12_snippet_1\n\nLANGUAGE: groq\nCODE:\n```\nEvaluateObject(scope):\n\n- Let {result} be a new empty object.\n- For each {ObjectAttribute}:\n  - If the {ObjectAttribute} contains `...`:\n    - If the {ObjectAttribute} contains an {Expression}:\n      - Let {baseNode} be the {Expression}.\n    - Let {base} be the result of {Evaluate(baseNode, scope)}.\n    - Otherwise:\n      - Let {base} be the this value of {scope}.\n    - For each {name} and {value} of {base}:\n      - Set the attribute {name} to {value} in {result}.\n  - Otherwise:\n    - Let {valueNode} be the {Expression} of the {ObjectAttribute}.\n    - Let {value} be the result of {Evaluate(valueNode, scope)}.\n    - If the {ObjectAttribute} contains a {String}:\n      - Let {name} be the string value of the {String}.\n    - Otherwise:\n      - Let {name} be the result of {DetermineName(valueNode)}.\n    - Set the attribute {name} to {value} in {result}.\n- Return {result}.\n```\n\n----------------------------------------\n\nTITLE: Evaluating Array in GROQ\nDESCRIPTION: This function evaluates an array expression in GROQ, handling spread operators and nested expressions.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/04-data-types.md#2025-04-12_snippet_0\n\nLANGUAGE: groq\nCODE:\n```\nEvaluateArray(scope):\n\n1. Let {result} be a new empty array.\n2. For each {ArrayElement}:\n3. Let {elementNode} be the {Expression} of the {ArrayElement}.\n4. Let {element} be the result of {Evaluate(elementNode, scope)}.\n5. If the {ArrayElement} contains {...}:\n   1. If {element} is an array:\n      1. Concatenate {element} to {result}.\n6. Otherwise:\n   1. Append {element} to {result}.\n7. Return {result}.\n```\n\n----------------------------------------\n\nTITLE: Evaluating Pair in GROQ\nDESCRIPTION: This function evaluates a pair expression in GROQ, creating a pair of two evaluated expressions.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/04-data-types.md#2025-04-12_snippet_2\n\nLANGUAGE: groq\nCODE:\n```\nEvaluatePair(scope):\n\n- Let {firstNode} be the first {Expression}.\n- Let {secondNode} be the second {Expression}.\n- Let {result} be a new pair.\n- Set the first value of {result} to the result of {Evaluate(firstNode, scope)}.\n- Set the second value of {result} to the result of {Evaluate(secondNode, scope)}.\n- Return {result}.\n```\n\n----------------------------------------\n\nTITLE: Traversal InnerMap Evaluation Function in GROQ\nDESCRIPTION: Algorithm for evaluating inner-mapped traversals in GROQ, which first applies a traversal to each element of an array, then applies another traversal to the entire result. Used for operations like '{name,type}[type == \"admin\"]'.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/03-execution.md#2025-04-12_snippet_7\n\nLANGUAGE: pseudocode\nCODE:\n```\nEvaluateTraversalInnerMap(base, scope):\n\n- Let {traverse} be the traverse function of the first node.\n- Let {nextTraverse} be the traverse function of the last node.\n- If {base} is not an array:\n  - Return {null}.\n- Let {result} be an empty array.\n- For each {value} in {base}:\n  - Let {elem} be the result of {traverse(value, scope)}.\n  - Append {elem} to {result}.\n- Set {result} to be the result of {nextResult(base, scope)}.\n- Return {result}.\n```\n\n----------------------------------------\n\nTITLE: Evaluating Range in GROQ\nDESCRIPTION: This function evaluates a range expression in GROQ, creating a range object with start and end values.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/04-data-types.md#2025-04-12_snippet_3\n\nLANGUAGE: groq\nCODE:\n```\nEvaluateRange(scope):\n\n- Let {startNode} be the first {Expression}.\n- Let {endNode} be the second {Expression}.\n- Let {start} be the result of {Evaluate(startNode, scope)}.\n- Let {end} be the result of {Evaluate(endNode, scope)}.\n- If {PartialCompare(start, end)} is {null}:\n  - Return {null}.\n- Let {result} be a new range.\n- Set the start value of {result} to {start}.\n- Set the end value of {result} to {end}.\n- Mark the range as inclusive or exclusive.\n- Return {result}.\n```\n\n----------------------------------------\n\nTITLE: Implementing geo::contains() Function for Spatial Containment\nDESCRIPTION: This function determines if one geo value completely contains another using planar coordinates. It returns true if all points of the second geo value are within the boundaries of the first.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/14-extensions.md#2025-04-12_snippet_8\n\nLANGUAGE: pseudocode\nCODE:\n```\ngeo_contains(args, scope):\n\n- Let {firstNode} be the first element of {args}.\n- Let {secondNode} be the second element of {args}.\n- Let {first} be the result of {Evaluate(firstNode, scope)}.\n- Let {second} be the result of {Evaluate(secondNode, scope)}.\n- If {first} or {second} is a not a geo value:\n  - Return {null}.\n- If {first} completely contains {second}:\n  - Return {true}.\n- Otherwise:\n  - Return {false}.\n```\n\n----------------------------------------\n\nTITLE: Evaluating Unary Plus Operator in GROQ\nDESCRIPTION: Defines the evaluation process for the unary plus (+) operator in GROQ. It returns the numeric value if the operand is a number, otherwise null.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/09-operators.md#2025-04-12_snippet_7\n\nLANGUAGE: GROQ\nCODE:\n```\nEvaluateUnaryPlus(scope):\n\n- Let {valueNode} be the {Expression}.\n- Let {value} be the result of {Evaluate(valueNode, scope)}.\n- If {value} is a number:\n  - Return {value}.\n- Return {null}.\n```\n\n----------------------------------------\n\nTITLE: Defining global::identity() Vendor Function in GROQ\nDESCRIPTION: The global::identity() function is an optional vendor function that returns a string representing the identity of the client executing the query. It accepts no arguments.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/13-vendor-functions.md#2025-04-12_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## global::identity()\n\nThe identity function should accept zero arguments and return a string which represents the identity of the client executing the query.\n```\n\n----------------------------------------\n\nTITLE: Evaluating Unary Minus Operator in GROQ\nDESCRIPTION: Defines the evaluation process for the unary minus (-) operator in GROQ. It returns the negated value if the operand is a number, otherwise null.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/09-operators.md#2025-04-12_snippet_8\n\nLANGUAGE: GROQ\nCODE:\n```\nEvaluateUnaryMinus(scope):\n\n- Let {valueNode} be the {Expression}.\n- Let {value} be the result of {Evaluate(valueNode, scope)}.\n- If {value} is a number:\n  - Return {value} with opposite sign.\n- Return {null}.\n```\n\n----------------------------------------\n\nTITLE: GROQ Comments Usage\nDESCRIPTION: Example showing how comments can be used in GROQ queries, either on separate lines or at the end of lines using the // syntax.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/02-syntax.md#2025-04-12_snippet_3\n\nLANGUAGE: example\nCODE:\n```\n{\n  // Comments can be on a separate line\n  \"key\": \"value\" // Or at the end of a line\n}\n```\n\n----------------------------------------\n\nTITLE: Evaluating Binary Slash Operator in GROQ\nDESCRIPTION: Defines the evaluation process for the binary slash (/) operator in GROQ. It performs division for numeric operands.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/09-operators.md#2025-04-12_snippet_12\n\nLANGUAGE: GROQ\nCODE:\n```\nEvaluateSlash(scope):\n\n- Let {leftNode} be the first {Expression}.\n- Let {left} be the result of {Evaluate(leftNode, scope)}.\n- Let {rightNode} be the last {Expression}.\n- Let {right} be the result of {Evaluate(rightNode, scope)}.\n- If both {left} and {right} are numbers:\n  - Return the division of {left} by {right}.\n- Return {null}.\n```\n\n----------------------------------------\n\nTITLE: Sample JSON Documents for GROQ Query\nDESCRIPTION: Example JSON documents representing a collection of records with id and name fields.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/01-overview.md#2025-04-12_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{ \"id\": 1, \"name\": \"Peter\"}\n{ \"id\": 2, \"name\": \"Gamora\"}\n{ \"id\": 3, \"name\": \"Drax\"}\n{ \"id\": 4, \"name\": \"Groot\"}\n{ \"id\": 5, \"name\": \"Rocket\"}\n```\n\n----------------------------------------\n\nTITLE: Evaluating Binary Double Star Operator in GROQ\nDESCRIPTION: Defines the evaluation process for the binary double star (**) operator in GROQ. It performs exponentiation for numeric operands.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/09-operators.md#2025-04-12_snippet_14\n\nLANGUAGE: GROQ\nCODE:\n```\nEvaluateStarStar(scope):\n\n- Let {leftNode} be the first {Expression}.\n- Let {left} be the result of {Evaluate(leftNode, scope)}.\n- Let {rightNode} be the last {Expression}.\n- Let {right} be the result of {Evaluate(rightNode, scope)}.\n- If both {left} and right are numbers:\n  - Return the exponentiation of {left} to the power of {right}.\n- Return {null}.\n```\n\n----------------------------------------\n\nTITLE: GROQ String Literals and Comments\nDESCRIPTION: Example demonstrating that comment-like syntax inside string literals is not interpreted as actual comments in GROQ.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/02-syntax.md#2025-04-12_snippet_4\n\nLANGUAGE: example\nCODE:\n```\n{\n  \"key // This isn't a comment\": \"value\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing dateTime::now() Function in GROQ\nDESCRIPTION: Returns the current point in time as a datetime. Takes no arguments and performs validation to ensure no arguments are provided.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/11-functions.md#2025-04-12_snippet_1\n\nLANGUAGE: pseudocode\nCODE:\n```\ndateTime_now(args, scope):\n\n- Let {result} be a datetime representing the current point in time.\n- Return {result}.\n\ndateTime_now_validate(args):\n\n- If the length of {args} is not 0:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Array JSON in GROQ\nDESCRIPTION: An array of strings as a valid JSON expression in GROQ.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/02-syntax.md#2025-04-12_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n[\"An\", \"array\", \"of\", \"strings\"]\n```\n\n----------------------------------------\n\nTITLE: Implementing delta::operation() Function in GROQ\nDESCRIPTION: Returns the current operation (create, update, delete) of a change in delta mode. Takes no arguments and works on the before/after objects of the query context.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/11-functions.md#2025-04-12_snippet_6\n\nLANGUAGE: pseudocode\nCODE:\n```\ndelta_operation(args, scope):\n\n- Let {before} and {after} be the before/after objects of the query context to {scope}.\n- If {before} is {null}:\n  - Return {\"create\"}.\n- If {after} is {null}:\n  - Return {\"delete\"}.\n- Return {\"update\"}.\n\ndelta_operation_validate(args):\n\n- If the length of {args} is not 0:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Validating sum() function arguments in GROQ\nDESCRIPTION: Validates that the sum function receives exactly one argument. Otherwise reports an error.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/11-functions.md#2025-04-12_snippet_14\n\nLANGUAGE: pseudocode\nCODE:\n```\nmath_sum_validate(args):\n\n- If the length of {args} is not 1:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Validating min() function arguments in GROQ\nDESCRIPTION: Validates that the min function receives exactly one argument. Otherwise reports an error.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/11-functions.md#2025-04-12_snippet_18\n\nLANGUAGE: pseudocode\nCODE:\n```\nmath_min_validate(args):\n\n- If the length of {args} is not 1:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Validating avg() function arguments in GROQ\nDESCRIPTION: Validates that the avg function receives exactly one argument. Otherwise reports an error.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/11-functions.md#2025-04-12_snippet_16\n\nLANGUAGE: pseudocode\nCODE:\n```\nmath_avg_validate(args):\n\n- If the length of {args} is not 1:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Defining global::path() Vendor Function in GROQ\nDESCRIPTION: The global::path() function is an optional vendor function that accepts a single argument and returns a path object. The specific implementation details are left to the vendor.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/13-vendor-functions.md#2025-04-12_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n## global::path()\n\nThe path function should accept a single argument and return a path object.\n```\n\n----------------------------------------\n\nTITLE: Validating max() function arguments in GROQ\nDESCRIPTION: Validates that the max function receives exactly one argument. Otherwise reports an error.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/11-functions.md#2025-04-12_snippet_20\n\nLANGUAGE: pseudocode\nCODE:\n```\nmath_max_validate(args):\n\n- If the length of {args} is not 1:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Validating Arguments for global::pt() Function\nDESCRIPTION: This function validates that the global::pt() function receives exactly one argument. If not, it reports an error.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/14-extensions.md#2025-04-12_snippet_1\n\nLANGUAGE: pseudocode\nCODE:\n```\nglobal_pt_validate(args):\n\n- If the length of {args} is not 1:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Validating Arguments for global::geo() Function\nDESCRIPTION: This function validates that the global::geo() function receives exactly one argument. If not, it reports an error.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/14-extensions.md#2025-04-12_snippet_5\n\nLANGUAGE: pseudocode\nCODE:\n```\nglobal_geo_validate(args):\n\n- If the length of {args} is not 1:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Validating Arguments for pt::text() Function\nDESCRIPTION: This function validates that the pt::text() function receives exactly one argument. If not, it reports an error.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/14-extensions.md#2025-04-12_snippet_3\n\nLANGUAGE: pseudocode\nCODE:\n```\npt_text_validate(args):\n\n- If the length of {args} is not 1:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Validating Arguments for geo::contains() Function\nDESCRIPTION: This function validates that the geo::contains() function receives exactly two arguments. If not, it reports an error.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/14-extensions.md#2025-04-12_snippet_9\n\nLANGUAGE: pseudocode\nCODE:\n```\ngeo_contains_validate(args):\n\n- If the length of {args} is not 2:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Validating Arguments for geo::latLng() Function\nDESCRIPTION: This function validates that the geo::latLng() function receives exactly two arguments. If not, it reports an error.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/14-extensions.md#2025-04-12_snippet_7\n\nLANGUAGE: pseudocode\nCODE:\n```\ngeo_latLng_validate(args):\n\n- If the length of {args} is not 2:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Validating Arguments for geo::intersects() Function\nDESCRIPTION: This function validates that the geo::intersects() function receives exactly two arguments. If not, it reports an error.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/14-extensions.md#2025-04-12_snippet_11\n\nLANGUAGE: pseudocode\nCODE:\n```\ngeo_intersects_validate(args):\n\n- If the length of {args} is not 2:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Validating Arguments for geo::distance() Function\nDESCRIPTION: This function validates that the geo::distance() function receives exactly two arguments. If not, it reports an error.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/14-extensions.md#2025-04-12_snippet_13\n\nLANGUAGE: pseudocode\nCODE:\n```\ngeo_distance_validate(args):\n\n- If the length of {args} is not 2:\n  - Report an error.\n```\n\n----------------------------------------\n\nTITLE: Basic String JSON in GROQ\nDESCRIPTION: A simple JSON string value that is valid in GROQ, demonstrating Unicode character support.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/02-syntax.md#2025-04-12_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n\"Hi! 👋\"\n```\n\n----------------------------------------\n\nTITLE: Complex Object JSON in GROQ\nDESCRIPTION: A comprehensive JSON object containing various data types including arrays, booleans, numbers, null values, nested objects, and strings, all valid as GROQ expressions.\nSOURCE: https://github.com/sanity-io/GROQ/blob/main/spec/02-syntax.md#2025-04-12_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"array\": [\"string\", 3.14, true, null],\n  \"boolean\": true,\n  \"number\": 3.14,\n  \"null\": null,\n  \"object\": {\"key\": \"value\"},\n  \"string\": \"Hi! 👋\"\n}\n```"
  }
]