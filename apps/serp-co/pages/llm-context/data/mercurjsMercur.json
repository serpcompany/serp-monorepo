[
  {
    "owner": "mercurjs",
    "repo": "mercur",
    "content": "TITLE: Defining a Basic GET API Route in Medusa (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a simple GET API route at `/store/hello-world` in Medusa. It involves creating a `route.ts` file, importing necessary types (`MedusaRequest`, `MedusaResponse`), and exporting an async function named `GET` that handles the request and sends a JSON response.\nSOURCE: https://github.com/mercurjs/mercur/blob/main/apps/backend/src/api/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { MedusaRequest, MedusaResponse } from '@medusajs/framework'\n\nexport async function GET(req: MedusaRequest, res: MedusaResponse) {\n  res.json({\n    message: 'Hello world!'\n  })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Medusa API Route with Path Parameters (TypeScript)\nDESCRIPTION: This snippet illustrates creating a dynamic API route in Medusa that accepts a path parameter. By naming a directory within the route path using bracket notation (e.g., `[productId]`), the value passed in that segment of the URL becomes available in the `req.params` object within the route handler.\nSOURCE: https://github.com/mercurjs/mercur/blob/main/apps/backend/src/api/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { MedusaRequest, MedusaResponse } from '@medusajs/framework'\n\nexport async function GET(req: MedusaRequest, res: MedusaResponse) {\n  const { productId } = req.params\n\n  res.json({\n    message: `You're looking for product ${productId}`\n  })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple HTTP Methods in a Medusa Route (TypeScript)\nDESCRIPTION: This snippet shows how to handle different HTTP methods (GET, POST, PUT) for the same API route path in Medusa. Within a single `route.ts` file, you export separate async functions named after the corresponding HTTP methods (e.g., `GET`, `POST`, `PUT`). Each function receives `MedusaRequest` and `MedusaResponse` objects.\nSOURCE: https://github.com/mercurjs/mercur/blob/main/apps/backend/src/api/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { MedusaRequest, MedusaResponse } from '@medusajs/framework'\n\nexport async function GET(req: MedusaRequest, res: MedusaResponse) {\n  // Handle GET requests\n}\n\nexport async function POST(req: MedusaRequest, res: MedusaResponse) {\n  // Handle POST requests\n}\n\nexport async function PUT(req: MedusaRequest, res: MedusaResponse) {\n  // Handle PUT requests\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Accessing the Medusa Container in an API Route (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the Medusa dependency injection container within an API route handler. The container is accessed via `req.scope`, and its `resolve` method is used to get instances of registered services, such as the `IProductModuleService`, identified by their registration keys (e.g., `Modules.PRODUCT`).\nSOURCE: https://github.com/mercurjs/mercur/blob/main/apps/backend/src/api/README.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { MedusaRequest, MedusaResponse } from '@medusajs/framework'\nimport { IProductModuleService } from '@medusajs/framework/types'\nimport { Modules } from '@medusajs/framework/utils'\n\nexport const GET = async (req: MedusaRequest, res: MedusaResponse) => {\n  const productModuleService: IProductModuleService = req.scope.resolve(\n    Modules.PRODUCT\n  )\n\n  const [, count] = await productModuleService.listAndCount()\n\n  res.json({\n    count\n  })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Applying Middleware to Medusa API Routes (TypeScript)\nDESCRIPTION: This snippet shows how to configure and apply middleware to specific API routes in Medusa. A `middlewares.ts` file is created in the `/src/api` directory, exporting a configuration object using `defineMiddlewares`. This object maps route matchers (strings or regex) to arrays of middleware functions to be executed for matching requests.\nSOURCE: https://github.com/mercurjs/mercur/blob/main/apps/backend/src/api/README.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type {\n  MedusaNextFunction,\n  MedusaRequest,\n  MedusaResponse\n} from '@medusajs/framework'\nimport { defineMiddlewares } from '@medusajs/medusa'\n\nasync function logger(\n  req: MedusaRequest,\n  res: MedusaResponse,\n  next: MedusaNextFunction\n) {\n  console.log('Request received')\n  next()\n}\n\nexport default defineMiddlewares({\n  routes: [\n    {\n      matcher: '/store/custom',\n      middlewares: [logger]\n    }\n  ]\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Module Service Class in TypeScript\nDESCRIPTION: Defines a minimal service class 'HelloModuleService' containing a single method 'getMessage' that returns a static greeting string. This service class forms the business logic component of a Medusa module and is written in TypeScript. No external dependencies are required besides Medusa's expected service contract. The class exposes a method for other code to retrieve a message; input parameters are not needed, and the output is a string.\nSOURCE: https://github.com/mercurjs/mercur/blob/main/apps/backend/src/modules/README.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default class HelloModuleService {\n  getMessage() {\n    return 'Hello, world!'\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Exporting a Medusa Module Definition in TypeScript\nDESCRIPTION: Exports a Medusa module from its root `index.ts` file by specifying the main service and a module identifier. This code imports the service class, defines a constant name for the module, and uses Medusa's 'Module' utility to declare the module interface. Dependencies include '@medusajs/framework/utils' for the Module helper and a correctly implemented service class. Parameters are the service and a string identifier; output is a Medusa-compliant module configuration export.\nSOURCE: https://github.com/mercurjs/mercur/blob/main/apps/backend/src/modules/README.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Module } from '@medusajs/framework/utils'\n\nimport HelloModuleService from './service'\n\nexport const HELLO_MODULE = 'helloModuleService'\n\nexport default Module(HELLO_MODULE, {\n  service: HelloModuleService\n})\n\n```\n\n----------------------------------------\n\nTITLE: Registering the Module in Medusa Configuration (JavaScript)\nDESCRIPTION: Demonstrates how to add the custom module to the Medusa application's configuration via the `modules` object. This JavaScript snippet imports the module identifier and specifies its resolution path using CommonJS conventions. The primary dependency is that the module must be defined and available at the given path, and the main Medusa configuration must support module registration. The key is the module constant; output is a properly structured configuration object.\nSOURCE: https://github.com/mercurjs/mercur/blob/main/apps/backend/src/modules/README.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { HELLO_MODULE } from './src/modules/hello'\n\nmodule.exports = defineConfig({\n  // ...\n  modules: {\n    [HELLO_MODULE]: {\n      resolve: './modules/hello'\n    }\n  }\n})\n\n```\n\n----------------------------------------\n\nTITLE: Resolving and Using a Module Service in a Medusa API Route (TypeScript)\nDESCRIPTION: Illustrates usage of the custom module's main service within an API route handler. The handler imports necessary types and the module, resolves the service from Medusa's request scope, and calls its business logic method to send an API response. It relies on Medusa's framework for request/response typing, dependency injection, and assumes prior module registration. Inputs are HTTP request/response objects; output is a JSON response containing the service's message.\nSOURCE: https://github.com/mercurjs/mercur/blob/main/apps/backend/src/modules/README.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MedusaRequest, MedusaResponse } from '@medusajs/framework'\n\nimport { HELLO_MODULE } from '../../../modules/hello'\nimport HelloModuleService from '../../../modules/hello/service'\n\nexport async function GET(\n  req: MedusaRequest,\n  res: MedusaResponse\n): Promise<void> {\n  const helloModuleService: HelloModuleService = req.scope.resolve(HELLO_MODULE)\n\n  res.json({\n    message: helloModuleService.getMessage()\n  })\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Parameterized Event Handling with Medusa and TypeScript\nDESCRIPTION: This snippet defines an advanced Medusa subscriber that consumes event payloads and utilizes Medusa's dependency injection container. The handler accesses event data (e.g., product id), resolves the appropriate module service, retrieves the product by id, and logs additional product details. Required dependencies include the MedusaJS framework and type definitions for SubscriberArgs and IProductModuleService. Key parameters are destructured from the event emission context. Outputs log dynamic product information and rely on proper Medusa container setup.\nSOURCE: https://github.com/mercurjs/mercur/blob/main/apps/backend/src/subscribers/README.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { SubscriberArgs, SubscriberConfig } from '@medusajs/framework'\nimport { IProductModuleService } from '@medusajs/framework/types'\nimport { Modules } from '@medusajs/framework/utils'\n\nexport default async function productCreateHandler({\n  event: { data },\n  container\n}: SubscriberArgs<{ id: string }>) {\n  const productId = data.id\n\n  const productModuleService: IProductModuleService = container.resolve(\n    Modules.PRODUCT\n  )\n\n  const product = await productModuleService.retrieveProduct(productId)\n\n  console.log(`The product ${product.title} was created`)\n}\n\nexport const config: SubscriberConfig = {\n  event: 'product.created'\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Subscriber with Medusa and TypeScript\nDESCRIPTION: This snippet demonstrates a minimal event subscriber for Medusa using TypeScript. It exports both an async event handler function and a configuration object that specifies the event to listen for. The subscriber logs a message every time a 'product.created' event is triggered. Requires MedusaJS and its framework types as dependencies. Inputs include event emissions via Medusa; output is side-effect logging. Limitations: only logs static messages without using event data.\nSOURCE: https://github.com/mercurjs/mercur/blob/main/apps/backend/src/subscribers/README.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { type SubscriberConfig } from '@medusajs/framework'\n\n// subscriber function\nexport default async function productCreateHandler() {\n  console.log('A product was created')\n}\n\n// subscriber config\nexport const config: SubscriberConfig = {\n  event: 'product.created'\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Scheduled Job in Medusa with TypeScript\nDESCRIPTION: This snippet defines a scheduled background job for a Medusa application using TypeScript. The exported async function receives a MedusaContainer instance for resolving services, retrieves product data from the Product module, and can be extended to operate on that data as needed. The configuration object specifies the job's unique name and a cron-based schedule (once nightly at midnight); an optional numberOfExecutions property can also restrict executions. Dependencies include @medusajs/framework/types and @medusajs/framework/utils, and this code must reside in the src/jobs directory to be recognized by Medusa.\nSOURCE: https://github.com/mercurjs/mercur/blob/main/apps/backend/src/jobs/README.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n  IProductModuleService,\n  MedusaContainer\n} from '@medusajs/framework/types'\nimport { Modules } from '@medusajs/framework/utils'\n\nexport default async function myCustomJob(container: MedusaContainer) {\n  const productService: IProductModuleService = container.resolve(\n    Modules.PRODUCT\n  )\n\n  const products = await productService.listAndCountProducts()\n\n  // Do something with the products\n}\n\nexport const config = {\n  name: 'daily-product-report',\n  schedule: '0 0 * * *' // Every day at midnight\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Medusa CLI Script in TypeScript to Count Products\nDESCRIPTION: This TypeScript snippet demonstrates how to define a custom Medusa CLI script in `src/scripts/my-script.ts`. It imports necessary types (`ExecArgs`, `IProductModuleService`) and utilities (`Modules`), defines an async function accepting `ExecArgs`, resolves the `IProductModuleService` from the Medusa container, fetches the product count using `listAndCountProducts`, and logs the count.\nSOURCE: https://github.com/mercurjs/mercur/blob/main/apps/backend/src/scripts/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title=\"src/scripts/my-script.ts\"\nimport { ExecArgs, IProductModuleService } from '@medusajs/framework/types'\nimport { Modules } from '@medusajs/framework/utils'\n\nexport default async function myScript({ container }: ExecArgs) {\n  const productModuleService: IProductModuleService = container.resolve(\n    Modules.PRODUCT\n  )\n\n  const [, count] = await productModuleService.listAndCountProducts()\n\n  console.log(`You have ${count} product(s)`)\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Accessing Command-Line Arguments in a Medusa CLI Script using TypeScript\nDESCRIPTION: This TypeScript snippet shows how a custom Medusa CLI script can receive and process command-line arguments. It imports the `ExecArgs` type, defines an async function that destructures the `args` array from the input parameter, and logs the received arguments. The `args` property contains an array of strings passed after the script path in the `exec` command.\nSOURCE: https://github.com/mercurjs/mercur/blob/main/apps/backend/src/scripts/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { ExecArgs } from '@medusajs/framework/types'\n\nexport default async function myScript({ args }: ExecArgs) {\n  console.log(`The arguments you passed: ${args}`)\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Passing Arguments to a Custom Medusa CLI Script using Bash\nDESCRIPTION: This Bash command demonstrates how to execute a custom Medusa CLI script (`./src/scripts/my-script.ts`) and pass command-line arguments (`arg1`, `arg2`) to it. The arguments are placed after the script file path when using the `npx medusa exec` command. These arguments will be available within the script via the `args` property of the function parameter.\nSOURCE: https://github.com/mercurjs/mercur/blob/main/apps/backend/src/scripts/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nnpx medusa exec ./src/scripts/my-script.ts arg1 arg2\n```\n```\n\n----------------------------------------\n\nTITLE: Running a Custom Medusa CLI Script using Bash\nDESCRIPTION: This Bash command demonstrates how to execute a custom Medusa CLI script located at `./src/scripts/my-script.ts`. It uses the Medusa CLI's `exec` command invoked via `npx`. Prerequisites include having Node.js, npm/npx, and Medusa installed, along with the script file existing at the specified path.\nSOURCE: https://github.com/mercurjs/mercur/blob/main/apps/backend/src/scripts/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nnpx medusa exec ./src/scripts/my-script.ts\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Workflows with MedusaJS in TypeScript\nDESCRIPTION: This snippet shows how to define a custom workflow in MedusaJS by composing multiple steps with distinct inputs and outputs. It leverages the framework's workflow SDK and TypeScript typings for type-safe config, demonstrating step creation, step invocation, and result aggregation. Dependencies include '@medusajs/framework/workflows-sdk' and TypeScript. 'WorkflowInput' and 'WorkflowOutput' interfaces are used to define the shape of input and output, while parameters such as 'name' (input) and the output 'message' are showcased.\nSOURCE: https://github.com/mercurjs/mercur/blob/main/apps/backend/src/workflows/README.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n  StepResponse,\n  createStep,\n  createWorkflow\n} from '@medusajs/framework/workflows-sdk'\n\nconst step1 = createStep('step-1', async () => {\n  return new StepResponse(`Hello from step one!`)\n})\n\ntype WorkflowInput = {\n  name: string\n}\n\nconst step2 = createStep('step-2', async ({ name }: WorkflowInput) => {\n  return new StepResponse(`Hello ${name} from step two!`)\n})\n\ntype WorkflowOutput = {\n  message: string\n}\n\nconst myWorkflow = createWorkflow<WorkflowInput, WorkflowOutput>(\n  'hello-world',\n  function (input) {\n    const str1 = step1()\n    // to pass input\n    step2(input)\n\n    return {\n      message: str1\n    }\n  }\n)\n\nexport default myWorkflow\n```\n\n----------------------------------------\n\nTITLE: Executing a MedusaJS Workflow from an API Endpoint in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to execute a MedusaJS workflow from within an HTTP API route. It imports a previously defined workflow, invokes it via an async 'GET' handler, and sends the workflow result as the HTTP response. Dependencies include '@medusajs/framework' for request/response types and the workflow module. Key parameters include the workflow input (with 'name' extracted from the query string), and the main output is the workflow execution result that is sent to the HTTP client.\nSOURCE: https://github.com/mercurjs/mercur/blob/main/apps/backend/src/workflows/README.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { MedusaRequest, MedusaResponse } from '@medusajs/framework'\n\nimport myWorkflow from '../../../workflows/hello-world'\n\nexport async function GET(req: MedusaRequest, res: MedusaResponse) {\n  const { result } = await myWorkflow(req.scope).run({\n    input: {\n      name: req.query.name as string\n    }\n  })\n\n  res.send(result)\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Mercur Development Environment using Bash\nDESCRIPTION: This Bash script outlines the sequence of commands to set up the Mercur development environment locally. It covers cloning the project repository, installing Node.js dependencies using Yarn, navigating directories, configuring the PostgreSQL database connection by copying and editing the environment file, initializing and migrating the database schema, seeding initial data, generating an OpenAPI client and http-client interfaces, creating an initial admin user via the Medusa CLI, and finally launching the development server. Prerequisites include Node.js v20+, PostgreSQL, and Git CLI.\nSOURCE: https://github.com/mercurjs/mercur/blob/main/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Clone the repository\ngit clone https://github.com/mercurjs/mercur.git\n\n# Change directory\ncd mercur\n\n# Install dependencies\nyarn install\n\n# Go to backend folder\ncd apps/backend\n\n# Clone .env.template\ncp .env.template .env\n\n# In the .env file replace user, password, address and port parameters in the DATABASE_URL variable with your values\nDATABASE_URL=postgres://[user]:[password]@[address]:[port]/$DB_NAME\n# For example:\nDATABASE_URL=postgres://postgres:postgres@localhost:5432/$DB_NAME\n\n# Setup database and run migrations\nyarn medusa db:create && yarn medusa db:migrate && yarn run seed\n\n# Generate OpenAPI client\nyarn generate:oas\n\n# Create admin user\nnpx medusa user --email <email> --password <password>\n\n# Go to root folder\ncd ../..\n\n# Generate http-client interfaces\nyarn codegen\n\n# Start Mercur\nyarn dev\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Admin Widget in Medusa Admin (TypeScript/TSX)\nDESCRIPTION: This snippet defines a new React component to function as a widget within the Medusa Admin dashboard. It uses the Medusa Admin SDK\\'s defineWidgetConfig utility to configure where the widget is injected (in this case, after the product details section). The ProductWidget displays a heading, and is exported as default, while the configuration is exported separately. Required dependencies are '@medusajs/admin-sdk' and React. Inputs involve no props; outputs are rendered DOM elements in the admin UI, with constraints based on available widget zones.\nSOURCE: https://github.com/mercurjs/mercur/blob/main/apps/backend/src/admin/README.md#_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nimport { defineWidgetConfig } from '@medusajs/admin-sdk'\\n\\n// The widget\\nconst ProductWidget = () => {\\n  return (\\n    <div>\\n      <h2>Product Widget</h2>\\n    </div>\\n  )\\n}\\n\\n// The widget's configurations\\nexport const config = defineWidgetConfig({\\n  zone: 'product.details.after'\\n})\\n\\nexport default ProductWidget\n```\n\n----------------------------------------\n\nTITLE: Defining a Module Link between Product and Custom Module in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to create a module link in a Mercurjs/MedusaJS application using the `defineLink` utility. It imports the standard `ProductModule`, a custom `HelloModule`, and `defineLink`, then defines a link between the `product` data model of the Product Module and the `myCustom` data model of the Hello Module by passing their respective `linkable` properties to `defineLink`. This establishes a relationship while maintaining module isolation.\nSOURCE: https://github.com/mercurjs/mercur/blob/main/apps/backend/src/links/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { defineLink } from '@medusajs/framework/utils'\nimport ProductModule from '@medusajs/medusa/product'\n\nimport HelloModule from '../modules/hello'\n\nexport default defineLink(\n  ProductModule.linkable.product,\n  HelloModule.linkable.myCustom\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a MedusaJS Integration Test Suite using medusaIntegrationTestRunner in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates setting up an integration test suite for a MedusaJS application using `medusaIntegrationTestRunner` from the `medusa-test-utils` package. It defines a test case for a custom GET endpoint `/store/custom`, making an API request using the provided `api` client and asserting the expected status code (200) and response body (`{ message: 'Hello, World!' }`). Requires the `medusa-test-utils` package and a compatible testing framework (like Jest, implied by `describe`, `it`, `expect`).\nSOURCE: https://github.com/mercurjs/mercur/blob/main/apps/backend/integration-tests/http/README.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\n```ts\nimport { medusaIntegrationTestRunner } from 'medusa-test-utils'\n\nmedusaIntegrationTestRunner({\n  testSuite: ({ api, getContainer }) => {\n    describe('Custom endpoints', () => {\n      describe('GET /store/custom', () => {\n        it('returns correct message', async () => {\n          const response = await api.get(`/store/custom`)\n\n          expect(response.status).toEqual(200)\n          expect(response.data).toHaveProperty('message')\n          expect(response.data.message).toEqual('Hello, World!')\n        })\n      })\n    })\n  }\n})\n```\n```"
  }
]