[
  {
    "owner": "slackapi",
    "repo": "bolt-js",
    "content": "TITLE: Listening and Responding to Messages in Socket Mode - Bolt.js - JavaScript\nDESCRIPTION: This code snippet shows how to initialize a Bolt App in Socket Mode using environment variables for authentication and port configuration. The app listens for messages containing the word \"hello\" and responds in the same channel, mentioning the user. Requires '@slack/bolt' and valid Slack OAuth and app-level tokens. Inputs include Slack event payloads containing messages, and the output is a message response from the bot.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/getting-started.mdx#2025-04-23_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst { App } = require('@slack/bolt');\n\nconst app = new App({\n  token: process.env.SLACK_BOT_TOKEN,\n  signingSecret: process.env.SLACK_SIGNING_SECRET,\n  socketMode: true,\n  appToken: process.env.SLACK_APP_TOKEN,\n  // Socket Mode doesn't listen on a port, but in case you want your app to respond to OAuth,\n  // you still need to listen on some port!\n  port: process.env.PORT || 3000\n});\n\n// Listens to incoming messages that contain \"hello\"\napp.message('hello', async ({ message, say }) => {\n  // say() sends a message to the channel where the event was triggered\n  await say(`Hey there <@${message.user}>!`);\n});\n\n(async () => {\n  // Start your app\n  await app.start();\n\n  app.logger.info('‚ö°Ô∏è Bolt app is running!');\n})();\n```\n\n----------------------------------------\n\nTITLE: Initializing Bolt App (Socket Mode) and Sending a Button\nDESCRIPTION: This snippet initializes a Slack Bolt app using Socket Mode. It requires environment variables for the bot token, signing secret, and app token. The app listens for messages containing 'hello' and responds with a message containing a section block with a button accessory. The button has an `action_id` of 'button_click'.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/getting-started.mdx#2025-04-23_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\nconst { App } = require('@slack/bolt');\n\nconst app = new App({\n  token: process.env.SLACK_BOT_TOKEN,\n  signingSecret: process.env.SLACK_SIGNING_SECRET,\n  socketMode: true,\n  appToken: process.env.SLACK_APP_TOKEN,\n  // Socket Mode doesn't listen on a port, but in case you want your app to respond to OAuth,\n  // you still need to listen on some port!\n  port: process.env.PORT || 3000\n});\n\n// Listens to incoming messages that contain \"hello\"\napp.message('hello', async ({ message, say }) => {\n  // say() sends a message to the channel where the event was triggered\n  await say({\n    blocks: [\n      {\n        \"type\": \"section\",\n        \"text\": {\n          \"type\": \"mrkdwn\",\n          \"text\": `Hey there <@${message.user}>!`\n        },\n        \"accessory\": {\n          \"type\": \"button\",\n          \"text\": {\n            \"type\": \"plain_text\",\n            \"text\": \"Click Me\"\n          },\n          \"action_id\": \"button_click\"\n        }\n      }\n    ],\n    text: `Hey there <@${message.user}>!`\n  });\n});\n\n(async () => {\n  // Start your app\n  await app.start();\n\n  app.logger.info('‚ö°Ô∏è Bolt app is running!');\n})();\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing Bolt App with Socket Mode\nDESCRIPTION: Sets up a basic Slack app using Socket Mode by configuring the App with socketMode enabled and providing the necessary tokens. This allows the app to connect to Slack via a WebSocket connection.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/socket-mode.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst { App } = require('@slack/bolt');\n\nconst app = new App({\n  token: process.env.BOT_TOKEN,\n  socketMode: true,\n  appToken: process.env.APP_TOKEN,\n});\n\n(async () => {\n  await app.start();\n  app.logger.info('‚ö°Ô∏è Bolt app started');\n})();\n```\n\n----------------------------------------\n\nTITLE: Responding to Actions with say() in Slack Bolt.js\nDESCRIPTION: Example of responding to an action using the say() function to send a message back to the conversation where the action occurred.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/actions.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\napp.action('approve_button', async ({ ack, say }) => {\n  // Acknowledge action request\n  await ack();\n  await say('Request approved üëç');\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Slack Bolt Application\nDESCRIPTION: JavaScript code to initialize and start a basic Slack Bolt application using environment variables for authentication\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/getting-started.mdx#2025-04-23_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst { App } = require('@slack/bolt');\n\n// Initializes your app with your bot token and signing secret\nconst app = new App({\n  token: process.env.SLACK_BOT_TOKEN,\n  signingSecret: process.env.SLACK_SIGNING_SECRET\n});\n\n(async () => {\n  // Start your app\n  await app.start(process.env.PORT || 3000);\n\n  app.logger.info('‚ö°Ô∏è Bolt app is running!');\n})();\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Bot Message Filter Middleware in Bolt.js\nDESCRIPTION: Example of a custom listener middleware that filters out bot messages and only processes messages from human users. Includes both the middleware function and its application in a message listener.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/listener-middleware.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Listener middleware that filters out messages with 'bot_message' subtype\nasync function noBotMessages({ message, next }) {\n  if (!message.subtype || message.subtype !== 'bot_message') {\n    await next();\n  }\n}\n\n// The listener only receives messages from humans\napp.message(noBotMessages, async ({ message, logger }) => logger.info(\n  // Handle only newly posted messages\n  if (message.subtype === undefined\n    // || message.subtype === 'bot_message'\n    || message.subtype === 'file_share'\n    || message.subtype === 'thread_broadcast') {\n    logger.info(`(MSG) User: ${message.user} Message: ${message.text}`)\n  }\n));\n```\n\n----------------------------------------\n\nTITLE: Implementing Timezone-Aware Message Scheduling in Slack Bolt.js\nDESCRIPTION: Demonstrates how to use context objects to store user timezone information and implement time-sensitive message scheduling. The code includes a middleware function to fetch user timezone and a command handler that schedules messages based on local time.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/context.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nasync function addTimezoneContext({ payload, client, context, next }) {\n  const user = await client.users.info({\n    user: payload.user_id,\n    include_locale: true\n  });\n\n  // Add user's timezone context\n  context.tz_offset = user.tz_offset;\n\n  // Pass control to the next middleware function\n  await next();\n}\n\napp.command('/request', addTimezoneContext, async ({ command, ack, client, context, logger }) => {\n  // Acknowledge command request\n  await ack();\n  // Get local hour of request\n  const localHour = (Date.UTC(2020, 3, 31) + context.tz_offset).getHours();\n\n  // Request channel ID\n  const requestChannel = 'C12345';\n\n  const requestText = `:large_blue_circle: *New request from <@${command.user_id}>*: ${command.text}`;\n\n  // If request not in between 9AM and 5PM, send request tomorrow\n  if (localHour > 17 || localHour < 9) {\n    // Assume function exists to get local tomorrow 9AM from offset\n    const localTomorrow = getLocalTomorrow(context.tz_offset);\n\n    try {\n      // Schedule message\n      const result = await client.chat.scheduleMessage({\n        channel: requestChannel,\n        text: requestText,\n        post_at: localTomorrow\n      });\n    }\n    catch (error) {\n      logger.error(error);\n    }\n  } else {\n    try {\n      // Post now\n      const result = await client.chat.postMessage({\n        channel: requestChannel,\n        text: requestText\n      });\n    } catch (error) {\n      logger.error(error);\n    }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Processing View Submission Data in Slack Bolt.js\nDESCRIPTION: Demonstrates handling a view_submission event, including accessing form input data, saving to a database, and sending a confirmation message to the user.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/view-submissions.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\napp.view('view_b', async ({ ack, body, view, client, logger }) => {\n  // Acknowledge the view_submission request\n  await ack();\n\n  // Do whatever you want with the input data - here we're saving it to a DB then sending the user a verification of their submission\n\n  // Assume there's an input block with `block_1` as the block_id and `input_a`\n  const val = view['state']['values']['block_1']['input_a'];\n  const user = body['user']['id'];\n\n  // Message to send user\n  let msg = '';\n  // Save to DB\n  const results = await db.set(user.input, val);\n\n  if (results) {\n    // DB save was successful\n    msg = 'Your submission was successful';\n  } else {\n    msg = 'There was an error with your submission';\n  }\n\n  // Message the user\n  try {\n    await client.chat.postMessage({\n      channel: user,\n      text: msg\n    });\n  }\n  catch (error) {\n    logger.error(error);\n  }\n\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Shortcut Handler in Slack Bolt.js\nDESCRIPTION: Demonstrates how to listen for a shortcut event and open a modal dialog in response. The code shows handling of the 'open_modal' shortcut including error handling and logging.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/shortcuts.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\napp.shortcut('open_modal', async ({ shortcut, ack, client, logger }) => {\n\n  try {\n    // Acknowledge shortcut request\n    await ack();\n\n    // Call the views.open method using one of the built-in WebClients\n    const result = await client.views.open({\n      trigger_id: shortcut.trigger_id,\n      view: {\n        type: \"modal\",\n        title: {\n          type: \"plain_text\",\n          text: \"My App\"\n        },\n        close: {\n          type: \"plain_text\",\n          text: \"Close\"\n        },\n        blocks: [\n          {\n            type: \"section\",\n            text: {\n              type: \"mrkdwn\",\n              text: \"About the simplest modal you could conceive of :smile:\\n\\nMaybe <https://docs.slack.dev/block-kit/#making-things-interactive|*make the modal interactive*> or <https://docs.slack.dev/surfaces/modals|*learn more advanced modal use cases*>.\"\n            }\n          },\n          {\n            type: \"context\",\n            elements: [\n              {\n                type: \"mrkdwn\",\n                text: \"Psssst this modal was designed using <https://api.slack.com/tools/block-kit-builder|*Block Kit Builder*>\"\n              }\n            ]\n          }\n        ]\n      }\n    });\n\n    logger.info(result);\n  }\n  catch (error) {\n    logger.error(error);\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Publishing Content to Slack App Home Tab with Bolt.js\nDESCRIPTION: Event listener implementation for app_home_opened that publishes a welcome message to a user's App Home tab. Uses the views.publish method to create a home view with markdown-formatted text blocks and user mentions.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/publishing-views.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Listen for users opening your App Home\napp.event('app_home_opened', async ({ event, client, logger }) => {\n  try {\n    // Call views.publish with the built-in client\n    const result = await client.views.publish({\n      // Use the user ID associated with the event\n      user_id: event.user,\n      view: {\n        // Home tabs must be enabled in your app configuration page under \"App Home\"\n        type: \"home\",\n        blocks: [\n          {\n            type: \"section\",\n            text: {\n              type: \"mrkdwn\",\n              text: \"*Welcome home, <@\" + event.user + \"> :house:*\"\n            }\n          },\n          {\n            type: \"section\",\n            text: {\n              type: \"mrkdwn\",\n              text: \"Learn how home tabs can be more useful and interactive <https://docs.slack.dev/surfaces/app-home|*in the documentation*>.\"\n            }\n          }\n        ]\n      }\n    });\n\n    logger.info(result);\n  }\n  catch (error) {\n    logger.error(error);\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Opening a Slack Modal with Form Input Using Bolt.js\nDESCRIPTION: This code demonstrates how to open a modal dialog in Slack in response to a slash command. The modal includes a welcome message with a button and a multi-line text input field. It uses the views.open API method and handles both success and error cases.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/creating-modals.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Listen for a slash command invocation\napp.command('/ticket', async ({ ack, body, client, logger }) => {\n  // Acknowledge the command request\n  await ack();\n\n  try {\n    // Call views.open with the built-in client\n    const result = await client.views.open({\n      // Pass a valid trigger_id within 3 seconds of receiving it\n      trigger_id: body.trigger_id,\n      // View payload\n      view: {\n        type: 'modal',\n        // View identifier\n        callback_id: 'view_1',\n        title: {\n          type: 'plain_text',\n          text: 'Modal title'\n        },\n        blocks: [\n          {\n            type: 'section',\n            text: {\n              type: 'mrkdwn',\n              text: 'Welcome to a modal with _blocks_'\n            },\n            accessory: {\n              type: 'button',\n              text: {\n                type: 'plain_text',\n                text: 'Click me!'\n              },\n              action_id: 'button_abc'\n            }\n          },\n          {\n            type: 'input',\n            block_id: 'input_c',\n            label: {\n              type: 'plain_text',\n              text: 'What are your hopes and dreams?'\n            },\n            element: {\n              type: 'plain_text_input',\n              action_id: 'dreamy_input',\n              multiline: true\n            }\n          }\n        ],\n        submit: {\n          type: 'plain_text',\n          text: 'Submit'\n        }\n      }\n    });\n    logger.info(result);\n  }\n  catch (error) {\n    logger.error(error);\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Authorization Function in Slack Bolt.js\nDESCRIPTION: Example implementation of an authorization function for handling multiple workspace installations in a Slack Bolt.js application. Demonstrates how to store and retrieve bot tokens, manage installation credentials, and handle enterprise and team-specific authorization.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/authorization.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst app = new App({ authorize: authorizeFn, signingSecret: process.env.SLACK_SIGNING_SECRET });\n\n// NOTE: This is for demonstration purposes only.\n// All sensitive data should be stored in a secure database\n// Assuming this app only uses bot tokens, the following object represents a model for storing the credentials as the app is installed into multiple workspaces.\n\nconst installations = [\n  {\n    enterpriseId: 'E1234A12AB',\n    teamId: 'T12345',\n    botToken: 'xoxb-123abc',\n    botId: 'B1251',\n    botUserId: 'U12385',\n  },\n  {\n    teamId: 'T77712',\n    botToken: 'xoxb-102anc',\n    botId: 'B5910',\n    botUserId: 'U1239',\n  },\n];\n\nconst authorizeFn = async ({ teamId, enterpriseId }) => {\n  // Fetch team info from database\n  for (const team of installations) {\n    // Check for matching teamId and enterpriseId in the installations array\n    if ((team.teamId === teamId) && (team.enterpriseId === enterpriseId)) {\n      // This is a match. Use these installation credentials.\n      return {\n        // You could also set userToken instead\n        botToken: team.botToken,\n        botId: team.botId,\n        botUserId: team.botUserId\n      };\n    }\n  }\n\n  throw new Error('No matching authorizations');\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Deferred Initialization in Slack Bolt.js\nDESCRIPTION: Demonstrates how to create a Bolt app instance with deferred initialization and properly initialize it before starting. The code shows the correct sequence of calling init() before start() within an async context, including error handling.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/deferring-initialization.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst { App } = require('@slack/bolt');\n\n// deferInitialization is one of the options you can set in the constructor\nconst app = new App({\n  token,\n  signingSecret,\n  deferInitialization: true,\n});\n\n(async () => {\n  try {\n    // Must call init() before start() within an async function\n    await app.init();\n    // Now safe to call start()\n    await app.start(process.env.PORT || 3000);\n  } catch (e) {\n    app.logger.error(e);\n    process.exit(1);\n  }\n})()\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Simple Receiver for Bolt.js\nDESCRIPTION: Complete implementation of a custom receiver class that meets the Bolt.js Receiver interface requirements. Includes server initialization, request handling, and lifecycle management methods.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/receiver.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createServer } from 'http';\nimport express from 'express';\n\nclass SimpleReceiver  {\n  constructor(signingSecret, endpoints) {\n    this.app = express();\n    this.server = createServer(this.app);\n\n    for (const endpoint of endpoints) {\n      this.app.post(endpoint, this.requestHandler.bind(this));\n    }\n  }\n\n  init(app) {\n    this.bolt = app;\n  }\n\n  start(port) {\n    return new Promise((resolve, reject) => {\n      try {\n        this.server.listen(port, () => {\n          resolve(this.server);\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  stop() {\n    return new Promise((resolve, reject) => {\n      this.server.close((error) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        resolve();\n      })\n    })\n  }\n\n  // This is a simple implementation. Look at the ExpressReceiver source for more detail\n  async requestHandler(req, res) {\n    let ackCalled = false;\n    // Assume parseBody function exists to parse incoming requests\n    const parsedReq = parseBody(req);\n    const event = {\n      body: parsedReq.body,\n      // Receivers are responsible for handling acknowledgements\n      // `ack` should be prepared to be called multiple times and\n      // possibly with `response` as an error\n      ack: (response) => {\n        if (ackCalled) {\n          return;\n        }\n\n        if (response instanceof Error) {\n          res.status(500).send();\n        } else if (!response) {\n          res.send('')\n        } else {\n          res.send(response);\n        }\n\n        ackCalled = true;\n      }\n    };\n    await this.bolt.processEvent(event);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Scheduling Messages using Slack Web API in Bolt.js\nDESCRIPTION: Demonstrates how to use the WebClient to schedule a message in Slack using the chat.scheduleMessage API method. The example shows error handling and uses the client provided to event listeners.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/web-api.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Unix Epoch time for September 30, 2019 11:59:59 PM\nconst whenSeptemberEnds = 1569887999;\n\napp.message('wake me up', async ({ message, client, logger }) => {\n  try {\n    // Call chat.scheduleMessage with the built-in client\n    const result = await client.chat.scheduleMessage({\n      channel: message.channel,\n      post_at: whenSeptemberEnds,\n      text: 'Summer has come and passed'\n    });\n  }\n  catch (error) {\n    logger.error(error);\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Validating Email in Modal Submission with ack() Function in Slack Bolt JS\nDESCRIPTION: This code demonstrates how to handle a modal submission by validating an email address and acknowledging the request appropriately. It uses a regex pattern to test email validity, accepting the submission if valid or returning an error message if invalid. This showcases proper implementation of the ack() function within the 3-second response window required by Slack.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/acknowledge.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Regex to determine if this is a valid email\nlet isEmail = /^[\\w\\-\\.]+@([\\w\\-]+\\.)+[\\w\\-]+$/;\n// This uses a constraint object to listen for modal submissions with a callback_id of ticket_submit \napp.view('ticket_submit', async ({ ack, view }) => {\n  // get the email value from the input block with `email_address` as the block_id\n  const email = view.state.values['email_address']['input_a'].value;\n\n  // if it's a valid email, accept the submission\n  if (email && isEmail.test(email)) {\n    await ack();\n  } else {\n    // if it isn't a valid email, acknowledge with an error\n    await ack({\n      \"response_action\": \"errors\",\n      errors: {\n        \"email_address\": \"Sorry, this isn't a valid email\"\n      }\n    });\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom SocketModeReceiver for Bolt\nDESCRIPTION: Creates a custom SocketModeReceiver instance that can be used with the Bolt App. This approach provides more flexibility and includes commented options for OAuth implementation if needed.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/socket-mode.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst { App, SocketModeReceiver } = require('@slack/bolt');\n\nconst socketModeReceiver = new SocketModeReceiver({\n  appToken: process.env.APP_TOKEN,\n\n  // enable the following if you want to use OAuth\n  // clientId: process.env.CLIENT_ID,\n  // clientSecret: process.env.CLIENT_SECRET,\n  // stateSecret: process.env.STATE_SECRET,\n  // scopes: ['channels:read', 'chat:write', 'app_mentions:read', 'channels:manage', 'commands'],\n});\n\nconst app = new App({\n  receiver: socketModeReceiver,\n  // disable token line below if using OAuth\n  token: process.env.BOT_TOKEN\n});\n\n(async () => {\n  await app.start();\n  app.logger.info('‚ö°Ô∏è Bolt app started');\n})();\n```\n\n----------------------------------------\n\nTITLE: Responding to External Select Options Requests in Bolt JS\nDESCRIPTION: This snippet demonstrates how to register a listener for options requests tied to a specific `action_id` ('external_action') using `app.options()`. It asynchronously fetches data (simulated via `db.get`) based on the team ID from the request payload, formats the results into Slack's required option object structure (text/value pairs), and sends these options back to Slack using the `ack()` function. If no results are found, it sends an empty acknowledgment.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/select-menu-options.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Example of responding to an external_select options request\napp.options('external_action', async ({ options, ack }) => {\n  // Get information specific to a team or channel\n  const results = await db.get(options.team.id);\n\n  if (results) {\n    let options = [];\n    // Collect information in options array to send in Slack ack response\n    for (const result of results) {\n      options.push({\n        text: {\n          type: \"plain_text\",\n          text: result.label\n        },\n        value: result.value\n      });\n    }\n\n    await ack({\n      options: options\n    });\n  } else {\n    await ack();\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Installation Store in Bolt.js\nDESCRIPTION: Implements a basic in-memory installation store with methods for storing, fetching, and deleting installations.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/authenticating-oauth.md#2025-04-23_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nconst app = new App({\n  signingSecret: process.env.SLACK_SIGNING_SECRET,\n  clientId: process.env.SLACK_CLIENT_ID,\n  clientSecret: process.env.SLACK_CLIENT_SECRET,\n  stateSecret: process.env.SLACK_STATE_SECRET,\n  scopes: [\"chat:write\", \"commands\"],\n  installationStore: {\n    storeInstallation: async (installation) => {\n      if (installation.team !== undefined) {\n        return await database.set(installation.team.id, installation);\n      }\n      throw new Error(\"Failed to save installation data to installationStore\");\n    },\n    fetchInstallation: async (installQuery) => {\n      if (installQuery.teamId !== undefined) {\n        return await database.get(installQuery.teamId);\n      }\n      throw new Error(\"Failed to fetch installation\");\n    },\n    deleteInstallation: async (installQuery) => {\n      if (installQuery.teamId !== undefined) {\n        return await database.delete(installQuery.teamId);\n      }\n      throw new Error(\"Failed to delete installation\");\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom HTTP Routes with ExpressReceiver\nDESCRIPTION: This example shows how to use the ExpressReceiver to add custom routes and middleware to a Bolt.js application. It demonstrates creating a receiver instance, adding Express middleware for logging, and defining a custom route handler. This approach offers more flexibility through the Express Router API.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/custom-routes.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst { App, ExpressReceiver } = require('@slack/bolt');\n\n// Create a Bolt Receiver\nconst receiver = new ExpressReceiver({ signingSecret: process.env.SLACK_SIGNING_SECRET });\n\n// Create the Bolt App, using the receiver\nconst app = new App({\n  token: process.env.SLACK_BOT_TOKEN,\n  receiver\n});\n\n// Slack interactions are methods on app\napp.event('message', async ({ event, client }) => {\n  // Do some slack-specific stuff here\n  await client.chat.postMessage(...);\n});\n\n// Middleware methods execute on every web request\nreceiver.router.use((req, res, next) => {\n  app.logger.info(`Request time: ${Date.now()}`);\n  next();\n});\n\n// Other web requests are methods on receiver.router\nreceiver.router.post('/secret-page', (req, res) => {\n  // You're working with an express req and res now.\n  res.send('yay!');\n});\n\n(async () => {\n  await app.start();\n  app.logger.info('‚ö°Ô∏è Bolt app started');\n})();\n```\n\n----------------------------------------\n\nTITLE: Fetching and Formatting Thread History for LLM Context in Bolt JS Assistant\nDESCRIPTION: This snippet presents an alternative approach within the `userMessage` handler, using thread history for context. It fetches replies to the current message thread using `client.conversations.replies`. The retrieved messages (`thread.messages`) are then mapped into an array (`threadHistory`) of objects, each containing a `role` ('user' or 'assistant', determined by the presence of `bot_id`) and the message `content` (`m.text`), formatted suitably for an LLM API.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/ai-assistant.md#2025-04-23_snippet_12\n\nLANGUAGE: js\nCODE:\n```\n      /**\n       * Scenario 2: Format and pass user messages directly to the LLM\n      */\n\n      // Retrieve the Assistant thread history for context of question being asked\n      const thread = await client.conversations.replies({\n        channel,\n        ts: thread_ts,\n        oldest: thread_ts,\n      });\n\n      // Prepare and tag each message for LLM processing\n      const userMessage = { role: 'user', content: message.text };\n      const threadHistory = thread.messages.map((m) => {\n        const role = m.bot_id ? 'assistant' : 'user';\n        return { role, content: m.text };\n      });\n```\n\n----------------------------------------\n\nTITLE: Creating Jira Issues from Slack Workflow in Bolt.js\nDESCRIPTION: Implements a workflow step that creates a Jira issue using external API calls. Handles API authentication, request formatting, and response processing.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/custom-steps.md#2025-04-23_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\napp.function('create_issue', async ({ inputs, complete, fail }) => {\n  try {\n    const { project, issuetype, summary, description } = inputs;\n\n    /** Prepare the URL to POST new issues to */\n    const jiraBaseURL = process.env.JIRA_BASE_URL;\n    const issueEndpoint = `https://${jiraBaseURL}/rest/api/latest/issue`;\n\n    /** Set custom headers for the request */\n    const headers = {\n      Accept: 'application/json',\n      Authorization: `Bearer ${process.env.JIRA_SERVICE_TOKEN}`,\n      'Content-Type': 'application/json',\n    };\n\n    /** Provide information about the issue in the body */\n    const body = JSON.stringify({\n      fields: {\n        project: Number.isInteger(project) ? { id: project } : { key: project },\n        issuetype: Number.isInteger(issuetype) ? { id: issuetype } : { name: issuetype },\n        description,\n        summary,\n      },\n    });\n\n    /** Create the issue on a project by POST request */\n    const issue = await fetch(issueEndpoint, {\n      method: 'POST',\n      headers,\n      body,\n    }).then(async (res) => {\n      if (res.status === 201) return res.json();\n      throw new Error(`${res.status}: ${res.statusText}`);\n    });\n\n    /** Return a prepared output for the step */\n    const outputs = {\n      issue_id: issue.id,\n      issue_key: issue.key,\n      issue_url: `https://${jiraBaseURL}/browse/${issue.key}`,\n    };\n    await complete({ outputs });\n  } catch (error) {\n    console.error(error);\n    await fail({ error });\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication Global Middleware in Bolt.js\nDESCRIPTION: Demonstrates how to create a global middleware function that authenticates users against an external identity provider (Acme). The middleware checks if the Slack user exists in the external system, adds user context if found, and handles error cases appropriately.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/global-middleware.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nasync function authWithAcme({ payload, client, context, next }) {\n  const slackUserId = payload.user;\n  const helpChannelId = 'C12345';\n\n  // Assume we have a function that accepts a Slack user ID to find user details from Acme\n  try {\n    // Assume we have a function that can take a Slack user ID as input to find user details from the provider\n    const user = await acme.lookupBySlackId(slackUserId);\n      \n    // When the user lookup is successful, add the user details to the context\n    context.user = user;\n  } catch (error) {\n    // This user wasn't found in Acme. Send them an error and don't continue processing request\n    if (error.message === 'Not Found') {\n        await client.chat.postEphemeral({\n          channel: payload.channel,\n          user: slackUserId,\n          text: `Sorry <@${slackUserId}>, you aren't registered in Acme. Please post in <#${helpChannelId}> for assistance.`\n        });\n        return;\n    }\n    \n    // Pass control to previous middleware (if any) or the global error handler\n    throw error;\n  }\n  \n  // Pass control to the next middleware (if there are any) and the listener functions\n  // Note: You probably don't want to call this inside a `try` block, or any middleware\n  //       after this one that throws will be caught by it. \n  await next();\n}\n```\n\n----------------------------------------\n\nTITLE: Using Message Matching Middleware in Bolt.js\nDESCRIPTION: Demonstrates how to use the built-in matchMessage middleware function to filter messages containing specific text. The middleware is imported from @slack/bolt and used as a parameter in the app.message() method.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/reference.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { matchMessage } from '@slack/bolt';\napp.message(matchMessage('hello'), async ({ message, logger }) => {\n  // this function will now only execute if \"hello\" is present in the message\n});\n```\n\n----------------------------------------\n\nTITLE: Handling team_join event in Slack Bolt.js\nDESCRIPTION: This code demonstrates how to listen for a team_join event in Slack and respond by sending a welcome message to a predefined channel. It uses the client.chat.postMessage method to send a message and includes error handling with logging.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/event-listening.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst welcomeChannelId = 'C12345';\n\n// When a user joins the team, send a message in a predefined channel asking them to introduce themselves\napp.event('team_join', async ({ event, client, logger }) => {\n  try {\n    // Call chat.postMessage with the built-in client\n    const result = await client.chat.postMessage({\n      channel: welcomeChannelId,\n      text: `Welcome to the team, <@${event.user.id}>! üéâ You can introduce yourself in this channel.`\n    });\n    logger.info(result);\n  }\n  catch (error) {\n    logger.error(error);\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Function Listener for Custom Step\nDESCRIPTION: JavaScript implementation of a Bolt.js function listener that handles the custom step execution. Posts a message with a button to the user when the step is triggered in a workflow.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/custom-steps-workflow-builder-new.md#2025-04-23_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\napp.function('sample_step', async ({ client, inputs, fail }) => {\n  try {\n    const { user_id } = inputs;\n\n    await client.chat.postMessage({\n      channel: user_id,\n      text: 'Click the button to signal the step has completed',\n      blocks: [\n        {\n          type: 'section',\n          text: {\n            type: 'mrkdwn',\n            text: 'Click the button to signal the step has completed',\n          },\n          accessory: {\n            type: 'button',\n            text: {\n              type: 'plain_text',\n              text: 'Complete step',\n            },\n            action_id: 'sample_button',\n          },\n        },\n      ],\n    });\n  } catch (error) {\n    console.error(error);\n    fail({ error: `Failed to handle a step request: ${error}` });\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Custom Step Function in Bolt.js\nDESCRIPTION: This code demonstrates how to create a basic custom step that formats an input message and outputs it. The function handles inputs, uses complete() to return successful outputs, and fail() to handle errors.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/custom-steps.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// This sample custom step formats an input and outputs it\napp.function('sample_custom_step', async ({ inputs, complete, fail, logger }) => {\n  try {\n    const { message } = inputs;\n\n    await complete({\n        outputs: { \n            message: `:wave: You submitted the following message: \\n\\n>${message}` \n        }\n    });\n  } catch (error) {\n    logger.error(error);\n    await fail({ error: `Failed to handle a function request: ${error}` });\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Updating Modal View on Submission in Slack Bolt.js\nDESCRIPTION: Demonstrates how to update a modal view in response to a view_submission event using the ack() method with a response_action of 'update'.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/view-submissions.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\napp.view('modal-callback-id', async ({ ack, body }) => {\n  await ack({\n    response_action: 'update',\n    view: buildNewModalView(body),\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Updating a Modal View in Response to Button Click using Slack Bolt.js\nDESCRIPTION: This code snippet demonstrates how to update an existing modal view when a user clicks a button with action_id 'button_abc'. It uses the client.views.update method to replace the current view with updated content including text and an image. The code includes error handling and acknowledges the interaction before processing.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/updating-pushing-views.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Listen for a button invocation with action_id `button_abc` (assume it's inside of a modal)\napp.action('button_abc', async ({ ack, body, client, logger }) => {\n  // Acknowledge the button request\n  await ack();\n\n  try {\n    if (body.type !== 'block_actions' || !body.view) {\n      return;\n    }\n    // Call views.update with the built-in client\n    const result = await client.views.update({\n      // Pass the view_id\n      view_id: body.view.id,\n      // Pass the current hash to avoid race conditions\n      hash: body.view.hash,\n      // View payload with updated blocks\n      view: {\n        type: 'modal',\n        // View identifier\n        callback_id: 'view_1',\n        title: {\n          type: 'plain_text',\n          text: 'Updated modal'\n        },\n        blocks: [\n          {\n            type: 'section',\n            text: {\n              type: 'plain_text',\n              text: 'You updated the modal!'\n            }\n          },\n          {\n            type: 'image',\n            image_url: 'https://media.giphy.com/media/SVZGEcYt7brkFUyU90/giphy.gif',\n            alt_text: 'Yay! The modal was updated'\n          }\n        ]\n      }\n    });\n    logger.info(result);\n  }\n  catch (error) {\n    logger.error(error);\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Interactive Custom Step with Button in Bolt.js\nDESCRIPTION: This code shows how to create a custom step that posts a message with an interactive button and waits for user interaction before completing. It demonstrates handling function-scoped interactivity events.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/custom-steps.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n/** This sample custom step posts a message with a button */\napp.function('custom_step_button', async ({ client, inputs, fail, logger }) => {\n  try {\n    const { user_id } = inputs;\n\n    await client.chat.postMessage({\n      channel: user_id,\n      text: 'Click the button to signal the function has completed',\n      blocks: [\n        {\n          type: 'section',\n          text: {\n            type: 'mrkdwn',\n            text: 'Click the button to signal the function has completed',\n          },\n          accessory: {\n            type: 'button',\n            text: {\n              type: 'plain_text',\n              text: 'Complete function',\n            },\n            action_id: 'sample_button',\n          },\n        },\n      ],\n    });\n  } catch (error) {\n    logger.error(error);\n    await fail({ error: `Failed to handle a function request: ${error}` });\n  }\n});\n\n/** Your listener will be called every time a block element with the action_id \"sample_button\" is triggered */\napp.action('sample_button', async ({ ack, body, client, complete, fail, logger }) => {\n  try {\n    await ack();\n\n    const { channel, message, user } = body;\n    // Functions should be marked as successfully completed using `complete` or\n    // as having failed using `fail`, else they'll remain in an 'In progress' state.\n    await complete({ outputs: { user_id: user.id } });\n\n    await client.chat.update({\n      channel: channel.id,\n      ts: message.ts,\n      text: 'Function completed successfully!',\n    });\n  } catch (error) {\n    logger.error(error);\n    await fail({ error: `Failed to handle a function request: ${error}` });\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Constraint Object Usage in Bolt.js\nDESCRIPTION: Examples of using constraint objects with different listener methods to narrow event handling or handle special cases. Shows constraint options for actions, shortcuts, views, and options handlers.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/reference.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\napp.action({ block_id, action_id, callback_id, type }, fn);\napp.shortcut({ type, callback_id }, fn);\napp.view({ type, callback_id }, fn);\napp.options({ block_id, action_id, callback_id }, fn);\n```\n\n----------------------------------------\n\nTITLE: Event Listener Method Signatures in Bolt.js\nDESCRIPTION: Core method signatures for handling different types of Slack events and interactions. Includes methods for handling events, messages, actions, shortcuts, views, workflow steps, commands, and options.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/reference.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\napp.event(eventType, fn);\napp.message([pattern ,] fn);\napp.action(actionId, fn);\napp.shortcut(callbackId, fn);\napp.view(callbackId, fn);\napp.step(workflowStep);\napp.command(commandName, fn);\napp.options(actionId, fn);\n```\n\n----------------------------------------\n\nTITLE: Responding to Actions with respond() in Slack Bolt.js\nDESCRIPTION: Example of using the respond() utility to handle user selection actions and send responses using the response_url.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/actions.md#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\napp.action('user_select', async ({ action, ack, respond }) => {\n  await ack();\n  if (action.type === 'users_select') {\n    await respond(`You selected <@${action.selected_user}>`);\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Responding to 'knock knock' Messages in Slack using Bolt.js\nDESCRIPTION: This snippet demonstrates how to listen for messages containing 'knock knock' and respond with an italicized 'Who's there?' using the Slack Bolt framework for JavaScript.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/message-sending.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Listens for messages containing \"knock knock\" and responds with an italicized \"who's there?\"\napp.message('knock knock', async ({ message, say }) => {\n  await say(`_Who's there?_`);\n});\n```\n\n----------------------------------------\n\nTITLE: Handling team_join Event with Slack Bolt.js\nDESCRIPTION: This snippet demonstrates how to listen for the team_join event when a new user joins a workspace. When triggered, it sends a welcome message to a specified channel encouraging the new user to introduce themselves. The code uses the built-in client to call chat.postMessage API and includes error handling with logging.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/event-listening.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst welcomeChannelId = 'C12345';\n\n// Êñ∞„Åó„ÅÑ„É¶„Éº„Ç∂„Éº„Åå„ÉØ„Éº„ÇØ„Çπ„Éö„Éº„Çπ„Å´Âä†ÂÖ•„Åó„Åü„Çø„Ç§„Éü„É≥„Ç∞„Åß„ÄÅÊåáÂÆö„ÅÆ„ÉÅ„É£„É≥„Éç„É´„Å´„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÈÄÅ‰ø°„Åó„Å¶Ëá™Â∑±Á¥π‰ªã„Çí‰øÉ„Åô\napp.event('team_join', async ({ event, client, logger }) => {\n  try {\n    // ÁµÑ„ÅøËæº„Åø„ÅÆ client „Åß chat.postMessage „ÇíÂëº„Å≥Âá∫„Åô\n    const result = await client.chat.postMessage({\n      channel: welcomeChannelId,\n      text: `Welcome to the team, <@${event.user.id}>! üéâ You can introduce yourself in this channel.`\n    });\n    logger.info(result);\n  }\n  catch (error) {\n    logger.error(error);\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Sending a Block Message with Datepicker in Slack using Bolt.js\nDESCRIPTION: This code snippet shows how to send a more complex message with a section block and datepicker when a user reacts with a calendar emoji. It uses the Slack Bolt framework for JavaScript and demonstrates the use of Block Kit elements.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/message-sending.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// Sends a section block with datepicker when someone reacts with a üìÖ emoji\napp.event('reaction_added', async ({ event, say }) => {\n  if (event.reaction === 'calendar') {\n    await say({\n      blocks: [{\n        \"type\": \"section\",\n        \"text\": {\n          \"type\": \"mrkdwn\",\n          \"text\": \"Pick a date for me to remind you\"\n        },\n        \"accessory\": {\n          \"type\": \"datepicker\",\n          \"action_id\": \"datepicker_remind\",\n          \"initial_date\": \"2019-04-28\",\n          \"placeholder\": {\n            \"type\": \"plain_text\",\n            \"text\": \"Select a date\"\n          }\n        }\n      }]\n    });\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handlers in Slack Bolt.js\nDESCRIPTION: This example demonstrates how to configure various error handlers in a Slack Bolt.js application. It shows setting up specific error handlers on the HTTPReceiver for different error paths and a global error handler using app.error(). The code includes handlers for dispatch errors, process event errors, and unhandled requests.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/error-handling.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { App, HTTPReceiver } from '@slack/bolt';\n\nconst app = new App({\n  receiver: new HTTPReceiver({\n    signingSecret: process.env.SLACK_SIGNING_SECRET,\n    // more specific, focussed error handlers\n    dispatchErrorHandler: async ({ error, logger, response }) => {\n      logger.error(`dispatch error: ${error}`);\n      response.writeHead(404);\n      response.write(\"Something is wrong!\");\n      response.end();\n    },\n    processEventErrorHandler: async ({ error, logger, response }) => {\n      logger.error(`processEvent error: ${error}`);\n      // acknowledge it anyway!\n      response.writeHead(200);\n      response.end();\n      return true;\n    },\n    unhandledRequestHandler: async ({ logger, response }) => {\n      logger.info('Acknowledging this incoming request because 2 seconds already passed...');\n      // acknowledge it anyway!\n      response.writeHead(200);\n      response.end();\n    },\n    unhandledRequestTimeoutMillis: 2000, // the default is 3001\n  }),\n});\n\n// A more generic, global error handler\napp.error(async (error) => {\n  // Check the details of the error to handle cases where you should retry sending a message or stop the app\n  app.logger.error(error);\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple Echo Command with Bolt.js in JavaScript\nDESCRIPTION: This snippet demonstrates how to create a basic /echo slash command that echoes back the text provided by the user. The example uses async/await to handle the command request, acknowledges receipt with ack(), and responds to the command with the respond() utility.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/commands.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// The echo command simply echoes on command\napp.command('/echo', async ({ command, ack, respond }) => {\n  // Acknowledge command request\n  await ack();\n\n  await respond(`${command.text}`);\n});\n```\n\n----------------------------------------\n\nTITLE: Event Listener Logging in Bolt.js\nDESCRIPTION: Example of using the logger within an event listener to log team join events and API responses. Shows error handling and different log levels in a practical context.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/logging.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\napp.event(\"team_join\", async ({ client, event, logger }) => {\n  logger.info(\"Someone new just joined the team.\");\n  try {\n    const result = await client.chat.postMessage({\n      channel: \"C0123456789\",\n      text: `Welcome to the team, <@${event.user.id}>!`,\n    });\n    logger.debug(result);\n  } catch (error) {\n    logger.error(error);\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Action Listener for Button Click\nDESCRIPTION: JavaScript implementation of a Bolt.js action listener that handles the button click event. Updates the message and marks the step as complete when the user clicks the button.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/custom-steps-workflow-builder-new.md#2025-04-23_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\napp.action('sample_button', async ({ body, client, complete, fail }) => {\n  const { channel, message, user } = body;\n\n  try {\n    await complete({ outputs: { user_id: user.id } });\n\n    await client.chat.update({\n      channel: channel.id,\n      ts: message.ts,\n      text: 'Step completed successfully!',\n    });\n  } catch (error) {\n    console.error(error);\n    fail({ error: `Failed to handle a step request: ${error}` });\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Fetching Channel History for LLM Context in Bolt JS Assistant\nDESCRIPTION: This snippet, part of the `userMessage` handler, demonstrates fetching channel history as context for an LLM. It checks if the user's message matches a specific prompt. If it does, it retrieves the thread context using `getThreadContext` and then attempts to fetch the last 50 messages from the associated channel using `client.conversations.history`. It includes error handling for the `not_in_channel` case, where the app joins the channel and retries the history fetch.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/ai-assistant.md#2025-04-23_snippet_10\n\nLANGUAGE: js\nCODE:\n```\n/** Scenario 1: Handle suggested prompt selection\n     * The example below uses a prompt that relies on the context (channel) in which\n     * the user has asked the question (in this case, to summarize that channel).\n    */\n      if (message.text === 'Assistant, please summarize the activity in this channel!') {\n        const threadContext = await getThreadContext();\n        let channelHistory;\n\n        try {\n          channelHistory = await client.conversations.history({\n            channel: threadContext.channel_id,\n            limit: 50,\n          });\n        } catch (e) {\n          // If the Assistant is not in the channel it's being asked about,\n          // have it join the channel and then retry the API call\n          if (e.data.error === 'not_in_channel') {\n            await client.conversations.join({ channel: threadContext.channel_id });\n            channelHistory = await client.conversations.history({\n              channel: threadContext.channel_id,\n              limit: 50,\n            });\n          } else {\n            logger.error(e);\n          }\n        }\n```\n\n----------------------------------------\n\nTITLE: Using Extended Error Handler in Slack Bolt.js\nDESCRIPTION: This code demonstrates how to use the extended error handler in Slack Bolt.js (available from version 3.8.0). The extended handler provides access to additional context information including the logger, request context, and request body, allowing for more comprehensive error handling and debugging.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/error-handling.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst { App } = require('@slack/bolt');\n\nconst app = new App({\n  signingSecret: process.env.SLACK_SIGNING_SECRET,\n  token: process.env.SLACK_BOT_TOKEN,\n  extendedErrorHandler: true,\n});\n\napp.error(async ({ error, logger, context, body }) => {\n  // Log the error using the logger passed into Bolt\n  logger.error(error);\n\n  if (context.teamId) {\n    // Do something with the team's ID for debugging purposes\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Bolt App Installation Store for Org-Wide Support in JavaScript\nDESCRIPTION: This JavaScript snippet shows how to initialize a Slack Bolt `App` with a custom `installationStore`. The store implementation includes functions (`storeInstallation`, `fetchInstallation`, `deleteInstallation`) that differentiate between enterprise-wide and team-specific installations, using the appropriate ID (`enterprise.id` or `team.id`) to interact with an external `database` object for persistence. This configuration is necessary for apps intended to support Slack Enterprise Grid org-wide installations.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/authenticating-oauth.md#2025-04-23_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\nconst app = new App({\n  signingSecret: process.env.SLACK_SIGNING_SECRET,\n  clientId: process.env.SLACK_CLIENT_ID,\n  clientSecret: process.env.SLACK_CLIENT_SECRET,\n  stateSecret: process.env.SLACK_STATE_SECRET,\n  scopes: [\"chat:write\", \"commands\"],\n  // highlight-start\n  installationStore: {\n    storeInstallation: async (installation) => {\n      if (\n        installation.isEnterpriseInstall &&\n        installation.enterprise !== undefined\n      ) {\n        return await database.set(installation.enterprise.id, installation);\n      }\n      if (installation.team !== undefined) {\n        return await database.set(installation.team.id, installation);\n      }\n      throw new Error(\"Failed to save installation data to installationStore\");\n    },\n    fetchInstallation: async (installQuery) => {\n      if (\n        installQuery.isEnterpriseInstall &&\n        installQuery.enterpriseId !== undefined\n      ) {\n        return await database.get(installQuery.enterpriseId);\n      }\n      if (installQuery.teamId !== undefined) {\n        return await database.get(installQuery.teamId);\n      }\n      throw new Error(\"Failed to fetch installation\");\n    },\n    deleteInstallation: async (installQuery) => {\n      if (\n        installQuery.isEnterpriseInstall &&\n        installQuery.enterpriseId !== undefined\n      ) {\n        return await database.delete(installQuery.enterpriseId);\n      }\n      if (installQuery.teamId !== undefined) {\n        return await database.delete(installQuery.teamId);\n      }\n      throw new Error(\"Failed to delete installation\");\n    },\n  },\n  // highlight-end\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Action Listener for Button Responses in Bolt.js\nDESCRIPTION: JavaScript code that implements an action listener for the approve/deny buttons. When a manager clicks a button, this listener completes the workflow step with the appropriate output values and updates the message.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/custom-steps-workflow-builder-existing.md#2025-04-23_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\napp.action(/^(approve_button|deny_button).*/, async ({ action, body, client, complete, fail }) => {\\n  const { channel, message, function_data: { inputs } } = body;\\n  const { manager_id, submitter_id } = inputs;\\n  const request_decision = action.value === 'approve';\\n\\n  try {\\n    await complete({ outputs: { manager_id, submitter_id, request_decision } });\\n    await client.chat.update({\\n      channel: channel.id,\\n      ts: message.ts,\\n      text: `Request ${request_decision ? 'approved' : 'denied'}!`,\\n    });\\n  } catch (error) {\\n    console.error(error);\\n    fail({ error: `Failed to handle a function request: ${error}` });\\n  }\\n});\n```\n\n----------------------------------------\n\nTITLE: Updating Custom Middleware for Bolt.js v2\nDESCRIPTION: Example demonstrating how to update custom middleware functions to use async/await syntax and perform post-processing after await next() instead of using callback functions.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/migration/migration-v2.md#2025-04-23_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nfunction noBotMessages({ message, next }) {\n  function doAfter() { \n    // Post processing goes here\n  }\n\nif (!message.subtype || message.subtype !== 'bot_message') {\n    next(doAfter);\n  }\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nasync function noBotMessages({ message, next }) {\n  if (!message.subtype || message.subtype !== 'bot_message') {\n    await next();\n    // Post processing goes here\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Function Listener for Workflow Step in Bolt.js\nDESCRIPTION: JavaScript code that implements a function listener for the 'request_time_off' workflow step. This listener sends a message to the manager with approve/deny buttons when the workflow step is executed.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/custom-steps-workflow-builder-existing.md#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\napp.function('request_time_off', async ({ client, inputs, fail }) => {\\n  try {\\n    const { manager_id, submitter_id } = inputs;\\n\\n    await client.chat.postMessage({\\n      channel: manager_id,\\n      text: `<@${submitter_id}> requested time off! What say you?`,\\n      blocks: [\\n        {\\n          type: 'section',\\n          text: {\\n            type: 'mrkdwn',\\n            text: `<@${submitter_id}> requested time off! What say you?`,\\n          },\\n        },\\n        {\\n          type: 'actions',\\n          elements: [\\n            {\\n              type: 'button',\\n              text: {\\n                type: 'plain_text',\\n                text: 'Approve',\\n                emoji: true,\\n              },\\n              value: 'approve',\\n              action_id: 'approve_button',\\n            },\\n            {\\n              type: 'button',\\n              text: {\\n                type: 'plain_text',\\n                text: 'Deny',\\n                emoji: true,\\n              },\\n              value: 'deny',\\n              action_id: 'deny_button',\\n            },\\n          ],\\n        },\\n      ],\\n    });\\n  } catch (error) {\\n    console.error(error);\\n    fail({ error: `Failed to handle a function request: ${error}` });\\n  }\\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Lambda Function Handler in Bolt.js\nDESCRIPTION: Code that exports the Lambda function handler, which processes incoming AWS Lambda events and routes them to the Bolt.js app.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/deployments/aws-lambda.md#2025-04-23_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n// Handle the Lambda function event\nmodule.exports.handler = async (event, context, callback) => {\n    const handler = await awsLambdaReceiver.start();\n    return handler(event, context, callback);\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Basic Message Events with Pattern Matching in Bolt.js\nDESCRIPTION: Demonstrates how to listen for messages containing specific emoji patterns and respond to them. Includes filtering for specific message subtypes to handle only newly posted messages.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/message-listening.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// This will match any message that contains üëã\napp.message(':wave:', async ({ message, say }) => {\n  // Handle only newly posted messages here\n  if (message.subtype === undefined\n    || message.subtype === 'bot_message'\n    || message.subtype === 'file_share'\n    || message.subtype === 'thread_broadcast') {\n    await say(`Hello, <@${message.user}>`);\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: RegExp Pattern Matching for Slack Messages in Bolt.js\nDESCRIPTION: Shows how to use regular expressions for more flexible message matching. Captures greeting patterns and responds with a contextual message using the matched text.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/message-listening.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\napp.message(/^(hi|hello|hey).*/, async ({ context, say }) => {\n  // RegExp matches are inside of context.matches\n  const greeting = context.matches[0];\n\n  await say(`${greeting}, how are you?`);\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Advanced OAuth Installer Options\nDESCRIPTION: Comprehensive example of configuring OAuth installer options including custom paths, user scopes, callback handlers, and state verification logic with database integration.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/authenticating-oauth.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst app = new App({\n  signingSecret: process.env.SLACK_SIGNING_SECRET,\n  clientId: process.env.SLACK_CLIENT_ID,\n  clientSecret: process.env.SLACK_CLIENT_SECRET,\n  scopes: [\n    \"channels:manage\",\n    \"channels:read\",\n    \"chat:write\",\n    \"groups:read\",\n    \"incoming-webhook\",\n  ],\n  installerOptions: {\n    authVersion: \"v2\",\n    directInstall: false,\n    installPath: \"/slack/install\",\n    metadata: \"\",\n    redirectUriPath: \"/slack/oauth_redirect\",\n    stateVerification: \"true\",\n    userScopes: [\"chat:write\"],\n    callbackOptions: {\n      success: (installation, installUrlOptions, req, res) => {\n        res.send(\"The installation succeeded!\");\n      },\n      failure: (error, installUrlOptions, req, res) => {\n        res.send(\"Something strange happened...\");\n      },\n    },\n    stateStore: {\n      generateStateParam: async (installUrlOptions, now) => {\n        const state = randomStringGenerator();\n        const value = { options: installUrlOptions, now: now.toJSON() };\n        await database.set(state, value);\n        return state;\n      },\n      verifyStateParam: async (now, state) => {\n        const value = await database.get(state);\n        const generated = new Date(value.now);\n        const seconds = Math.floor(\n          (now.getTime() - generated.getTime()) / 1000,\n        );\n        if (seconds > 600) {\n          throw new Error(\"The state expired after 10 minutes!\");\n        }\n        return value.options;\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Sending LLM Response as Markdown Block in Bolt JS `say`\nDESCRIPTION: This snippet shows how to send a response containing potentially complex formatting (like code blocks from an LLM) using Slack's Block Kit within the Bolt JS `say` function. By wrapping the LLM response text (`llmResponse.choices[0].message.content`) inside a `markdown` block within the `blocks` array, it ensures that Slack correctly renders any Markdown syntax present in the response.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/ai-assistant.md#2025-04-23_snippet_14\n\nLANGUAGE: js\nCODE:\n```\n...\n      await say(\n        {\n          blocks: [\n          {\n            \"type\": \"markdown\",\n            \"text\": llmResponse.choices[0].message.content,\n          }\n        ]\n      }\n    )\n...\n```\n\n----------------------------------------\n\nTITLE: Configuring Log Level in Bolt.js App Initialization\nDESCRIPTION: Demonstrates how to import and configure the logging level when initializing a Bolt for JavaScript application. Shows setting the log level to DEBUG using the LogLevel enum.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/logging.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Import LogLevel from the package\nconst { App, LogLevel } = require('@slack/bolt');\n\n// Log level is one of the options you can set in the constructor\nconst app = new App({\n  token,\n  signingSecret,\n  logLevel: LogLevel.DEBUG,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Title and Status on User Message in Bolt JS Assistant\nDESCRIPTION: This snippet shows the initial part of a `userMessage` handler in a Bolt JS Assistant app. Upon receiving a message, it extracts the `channel` and `thread_ts`. It then calls `setTitle` with the message text to update the Assistant thread's title using the `assistant.threads.setTitle` API method, aiding user reference. Subsequently, it calls `setStatus` to display a 'typing' indicator via the `assistant.threads.setStatus` API method, providing visual feedback during processing.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/ai-assistant.md#2025-04-23_snippet_8\n\nLANGUAGE: js\nCODE:\n```\n/**\n* Messages sent to the Assistant do not contain a subtype and must\n* be deduced based on their shape and metadata (if provided).\n* https://docs.slack.dev/reference/events/message\n*/\nuserMessage: async ({ client, message, getThreadContext, say, setTitle, setStatus }) => {\n  const { channel, thread_ts } = message;\n\n  try {\n    /**\n     * Set the title of the Assistant thread to capture the initial topic/question\n     * as a way to facilitate future reference by the user.\n     * https://docs.slack.dev/reference/methods/assistant.threads.setTitle\n     */\n    await setTitle(message.text);\n\n    /**\n     * Set the status of the Assistant to give the appearance of active processing.\n     * https://docs.slack.dev/reference/methods/assistant.threads.setStatus\n     */\n    await setStatus('is typing..');\n```\n\n----------------------------------------\n\nTITLE: Listening and Responding to Messages in HTTP Mode - Bolt.js - JavaScript\nDESCRIPTION: This JavaScript code initializes a Bolt App to listen for Slack events over HTTP, suitable for deployment environments where Bolt listens on a specific port. The app responds to messages containing \"hello\" by mentioning the user in the same channel. Requires '@slack/bolt' and the necessary bot tokens and signing secret as environment variables. The snippet outputs a running HTTP server that processes Slack Events API payloads.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/getting-started.mdx#2025-04-23_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nconst { App } = require('@slack/bolt');\n\nconst app = new App({\n  token: process.env.SLACK_BOT_TOKEN,\n  signingSecret: process.env.SLACK_SIGNING_SECRET,\n});\n\n// Listens to incoming messages that contain \"hello\"\napp.message('hello', async ({ message, say }) => {\n  // say() sends a message to the channel where the event was triggered\n  await say(`Hey there <@${message.user}>!`);\n});\n\n(async () => {\n  // Start your app\n  await app.start(process.env.PORT || 3000);\n\n  app.logger.info('‚ö°Ô∏è Bolt app is running!');\n})();\n```\n\n----------------------------------------\n\nTITLE: Basic Workflow Step Function Implementation in Bolt.js\nDESCRIPTION: Demonstrates a simple workflow step that sends a message to a user. Uses the client.chat.postMessage API and handles both success and error cases.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/custom-steps.md#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\napp.function('sample_step', async ({ client, inputs, complete, fail }) => {\n  try {\n    const { user_id } = inputs;\n\n    await client.chat.postMessage({ \n      channel: user_id, \n      text: `Greetings <@${user_id}>!` \n    });\n\n    await complete({ outputs: { user_id } });\n  } \n  catch (error) {\n    console.error(error);\n    fail({ error: `Failed to complete the step: ${error}` });\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom HTTP Routes with Bolt's Default HTTPReceiver\nDESCRIPTION: This example demonstrates how to add custom HTTP routes using the customRoutes parameter when initializing a Bolt app. It shows two route examples: a simple health check endpoint and a route with a dynamic parameter. The code also configures the port using installerOptions.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/custom-routes.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst { App } = require('@slack/bolt');\n\n// Initialize Bolt app, using the default HTTPReceiver\nconst app = new App({\n  token: process.env.SLACK_BOT_TOKEN,\n  signingSecret: process.env.SLACK_SIGNING_SECRET,\n  customRoutes: [\n    {\n      path: '/health-check',\n      method: ['GET'],\n      handler: (req, res) => {\n        res.writeHead(200);\n        res.end(`Things are going just fine at ${req.headers.host}!`);\n      },\n    },\n    {\n      path: '/music/:genre',\n      method: ['GET'],\n      handler: (req, res) => {\n        res.writeHead(200);\n        res.end(`Oh? ${req.params.genre}? That slaps!`);\n      },\n    },\n  ],\n  installerOptions: {\n    port: 3001,\n  },\n});\n\n(async () => {\n  await app.start();\n  app.logger.info('‚ö°Ô∏è Bolt app started');\n})();\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Logger in Bolt.js\nDESCRIPTION: Demonstrates implementing a custom logger that writes to a file instead of console. Shows implementation of all required logger interface methods with file stream output.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/logging.md#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst { App } = require('@slack/bolt');\nconst { createWriteStream } = require('fs');\nconst logWritable = createWriteStream('/var/my_log_file'); // Not shown: close this stream\n\nconst app = new App({\n  token,\n  signingSecret,\n  // Creating a logger as a literal object. It's more likely that you'd create a class.\n  logger: {\n    debug: (...msgs) => { logWritable.write('debug: ' + JSON.stringify(msgs)); },\n    info: (...msgs) => { logWritable.write('info: ' + JSON.stringify(msgs)); },\n    warn: (...msgs) => { logWritable.write('warn: ' + JSON.stringify(msgs)); },\n    error: (...msgs) => { logWritable.write('error: ' + JSON.stringify(msgs)); },\n    setLevel: (level) => { },\n    getLevel: () => { },\n    setName: (name) => { },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Serverless Framework Configuration for Bolt.js\nDESCRIPTION: YAML configuration for the Serverless Framework that defines how to deploy the Bolt.js app to AWS Lambda, including function definition and environment variables.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/deployments/aws-lambda.md#2025-04-23_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\nservice: serverless-bolt-js\nframeworkVersion: \"4\"\nprovider:\n  name: aws\n  runtime: nodejs22.x\n  environment:\n    SLACK_SIGNING_SECRET: ${env:SLACK_SIGNING_SECRET}\n    SLACK_BOT_TOKEN: ${env:SLACK_BOT_TOKEN}\nfunctions:\n  slack:\n    handler: app.handler\n    events:\n      - http:\n          path: slack/events\n          method: post\nplugins:\n  - serverless-offline\n```\n\n----------------------------------------\n\nTITLE: Updating Listeners to Async in Bolt.js v2\nDESCRIPTION: Example showing how to update action listeners to use async/await syntax in Bolt.js v2. The listener function needs to be marked as async, and ack() and say() methods must be prefaced with await.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/migration/migration-v2.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\napp.action('some-action-id', ({action, ack, say}) => { \n  ack();\n  say('hello world');\n})\n```\n\nLANGUAGE: javascript\nCODE:\n```\napp.action('some-action-id', async ({action, ack, say}) => { \n  await ack();\n  await say('hello world');\n})\n```\n\n----------------------------------------\n\nTITLE: Handling Interactive Button Actions in Workflow Steps\nDESCRIPTION: Shows how to handle interactive button clicks within a workflow step, demonstrating the use of complete and fail utilities in action handlers.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/custom-steps.md#2025-04-23_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\napp.action('approve_button', async ({ complete, fail }) => {\n  // Signal the step has completed once the button is clicked  \n  await complete({ outputs: { message: 'Request approved üëç' } });\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Receiver with Custom Properties in Bolt.js\nDESCRIPTION: Example showing how to initialize a Bolt.js app with HTTPReceiver and custom property extraction. Demonstrates header propagation and custom property handling through middleware.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/receiver.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst { App, HTTPReceiver } = require('@slack/bolt');\n\nconst app = new App({\n  token: process.env.SLACK_BOT_TOKEN,\n  receiver: new HTTPReceiver({\n    signingSecret: process.env.SLACK_SIGNING_SECRET,\n    customPropertiesExtractor: (req) => {\n      return {\n        \"headers\": req.headers,\n        \"foo\": \"bar\",\n      };\n    }\n  }),\n});\n\napp.use(async ({ logger, context, next }) => {\n  logger.info(context);\n  await next();\n});\n\n(async () => {\n  // Start your app\n  await app.start(process.env.PORT || 3000);\n\n  app.logger.info('‚ö°Ô∏è Bolt app is running!');\n})();\n```\n\n----------------------------------------\n\nTITLE: Importing the AWS Lambda Receiver in Bolt.js\nDESCRIPTION: Code modification to import the AWS Lambda Receiver module from Bolt.js, which allows the app to process AWS Lambda function events.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/deployments/aws-lambda.md#2025-04-23_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst { App, AwsLambdaReceiver } = require('@slack/bolt');\n```\n\n----------------------------------------\n\nTITLE: Initializing Slack Bolt App in Socket Mode - JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates initializing a Bolt.js App to operate in Socket Mode. It uses environment variables for authentication, enables socketMode and appToken, and illustrates that Bolt does not listen on a port in this mode (unless for OAuth). Dependencies include '@slack/bolt' and appropriate Slack tokens. Inputs are provided through environment variables, and the output is a configured App instance ready to receive and handle Slack events via WebSockets.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/getting-started.mdx#2025-04-23_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n// Initializes your app in socket mode with your app token and signing secret\nconst app = new App({\n  token: process.env.SLACK_BOT_TOKEN,\n  signingSecret: process.env.SLACK_SIGNING_SECRET,\n  socketMode: true, // add this\n  appToken: process.env.SLACK_APP_TOKEN // add this\n});\n```\n\n----------------------------------------\n\nTITLE: Removing SocketMode Configuration in Bolt.js App\nDESCRIPTION: Code modification to remove SocketMode configuration from the Bolt.js app to prepare it for HTTP-based Lambda deployment.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/deployments/aws-lambda.md#2025-04-23_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// Initializes your app with your bot token\nconst app = new App({\n  token: process.env.SLACK_BOT_TOKEN,\n  socketMode: true, // delete this line\n  appToken: process.env.SLACK_APP_TOKEN, // delete this line\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing App and Hugging Face Client - JavaScript\nDESCRIPTION: Setting up the Bolt app and Hugging Face client with environment variables.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/ai-assistant.md#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst app = new App({\n  token: process.env.SLACK_BOT_TOKEN,\n  appToken: process.env.SLACK_APP_TOKEN,\n  socketMode: true,\n  logLevel: LogLevel.DEBUG,\n});\n\n// HuggingFace configuration\nconst hfClient = new HfInference(process.env.HUGGINGFACE_API_KEY);\n```\n\n----------------------------------------\n\nTITLE: Implementing Constrained Shortcut Handler in Slack Bolt.js\nDESCRIPTION: Shows how to use a constraints object to listen for specific shortcut types and callback IDs. This example listens for message shortcuts with a specific callback_id.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/shortcuts.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\napp.shortcut({ callback_id: 'open_modal', type: 'message_action' }, async ({ shortcut, ack, client, logger }) => {\n  try {\n    // Acknowledge shortcut request\n    await ack();\n\n    // Call the views.open method using one of the built-in WebClients\n    const result = await client.views.open({\n      trigger_id: shortcut.trigger_id,\n      view: {\n        type: \"modal\",\n        title: {\n          type: \"plain_text\",\n          text: \"My App\"\n        },\n        close: {\n          type: \"plain_text\",\n          text: \"Close\"\n        },\n        blocks: [\n          {\n            type: \"section\",\n            text: {\n              type: \"mrkdwn\",\n              text: \"About the simplest modal you could conceive of :smile:\\n\\nMaybe <https://docs.slack.dev/block-kit/#making-things-interactive|*make the modal interactive*> or <https://docs.slack.dev/surfaces/modals|*learn more advanced modal use cases*>.\"\n            }\n          },\n          {\n            type: \"context\",\n            elements: [\n              {\n                type: \"mrkdwn\",\n                text: \"Psssst this modal was designed using <https://api.slack.com/tools/block-kit-builder|*Block Kit Builder*>\"\n              }\n            ]\n          }\n        ]\n      }\n    });\n\n    logger.info(result);\n  }\n  catch (error) {\n    logger.error(error);\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Listening to Actions with Constraint Object in Slack Bolt.js\nDESCRIPTION: Advanced example of listening to actions using a constraints object that combines action_id and block_id. Includes error handling and adding reactions to messages.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/actions.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\napp.action({ action_id: 'select_user', block_id: 'assign_ticket' },\n  async ({ body, client, ack, logger }) => {\n    await ack();\n    try {\n      // Make sure the action isn't from a view (modal or app home)\n      if (body.message) {\n        const result = await client.reactions.add({\n          name: 'white_check_mark',\n          timestamp: body.message.ts,\n          channel: body.channel.id\n        });\n\n        logger.info(result);\n      }\n    }\n    catch (error) {\n      logger.error(error);\n    }\n  });\n```\n\n----------------------------------------\n\nTITLE: Configuring Slack App Token in Environment - Shell\nDESCRIPTION: This shell command sets the SLACK_APP_TOKEN environment variable with the generated xapp token from the Slack app settings. It is a prerequisite step for initializing the Bolt.js app in Socket Mode, allowing authenticated event handling. No direct input or output; it expects the presence of a valid app token, and will be accessed by the application via process.env.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/getting-started.mdx#2025-04-23_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nexport SLACK_APP_TOKEN=xapp-<your-app-token>\n```\n\n----------------------------------------\n\nTITLE: Clearing Assistant Status in Bolt JS\nDESCRIPTION: This snippet demonstrates how to clear the status indicator (e.g., 'is typing..') for a Slack Assistant thread using the `setStatus` utility function provided by Bolt JS. Passing an empty string to `setStatus` achieves this, typically used after processing is complete or before sending a final response if the default clearing behavior (on reply) is not desired.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/ai-assistant.md#2025-04-23_snippet_9\n\nLANGUAGE: js\nCODE:\n```\nawait setStatus('');\n```\n\n----------------------------------------\n\nTITLE: Deploying Update with Serverless - Shell\nDESCRIPTION: This snippet shows how to redeploy the Slack Bolt app using the Serverless Framework after modifying its code, for example adding new handlers. The `serverless deploy` command re-packages and redeploys the project to AWS Lambda; prior AWS and Serverless configuration is required. Suitable for updating functions and deploying incremental changes; outputs status and endpoint information.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/deployments/aws-lambda.md#2025-04-23_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\nserverless deploy\n```\n\n----------------------------------------\n\nTITLE: Handling `assistant_thread_context_changed` Event in Bolt JS\nDESCRIPTION: This snippet defines an asynchronous function within a Bolt app configuration to handle the `assistant_thread_context_changed` event. This event fires when a user switches channels while the Assistant container is open. The function uses the injected `saveThreadContext` utility to persist the new context (channel, thread) and includes basic error logging using the `logger`. This ensures the app has the latest context for user interactions.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/ai-assistant.md#2025-04-23_snippet_7\n\nLANGUAGE: js\nCODE:\n```\n/**\n* `assistant_thread_context_changed` is sent when a user switches channels\n* while the Assistant container is open. If `threadContextChanged` is not\n* provided, context will be saved using the AssistantContextStore's `save`\n* method (either the DefaultAssistantContextStore or custom, if provided).\n* https://docs.slack.dev/reference/events/assistant_thread_context_changed\n*/\nthreadContextChanged: async ({ logger, saveThreadContext }) => {\n  // const { channel_id, thread_ts, context: assistantContext } = event.assistant_thread;\n  try {\n    await saveThreadContext();\n  } catch (e) {\n    logger.error(e);\n  }\n},\n```\n\n----------------------------------------\n\nTITLE: Initializing Bolt App with FileInstallationStore for Development\nDESCRIPTION: Example of configuring a Bolt app with basic OAuth settings using FileInstallationStore for development purposes. Includes essential configuration like signing secret, client credentials, and required scopes.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/authenticating-oauth.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst { App } = require(\"@slack/bolt\");\nconst { FileInstallationStore } = require(\"@slack/oauth\");\nconst app = new App({\n  signingSecret: process.env.SLACK_SIGNING_SECRET,\n  clientId: process.env.SLACK_CLIENT_ID,\n  clientSecret: process.env.SLACK_CLIENT_SECRET,\n  stateSecret: process.env.SLACK_STATE_SECRET,\n  scopes: [\"channels:history\", \"chat:write\", \"commands\"],\n  installationStore: new FileInstallationStore(),\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing a Message Reversal Bot in Bolt\nDESCRIPTION: Example of a simple Bolt app that listens for messages and replies with the reversed text. The function filters out messages with subtypes except for bot messages, then reverses the message text and sends it back.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/README.md#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// Reverse all messages the app can hear\napp.message(async ({ message, say }) => {\n  // Filter out message events with subtypes (see https://api.slack.com/events/message)\n  if (message.subtype === undefined || message.subtype === 'bot_message') {\n    const reversedText = [...message.text].reverse().join(\"\");\n    await say(reversedText);\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Deploying App with Serverless - Shell\nDESCRIPTION: This snippet demonstrates how to deploy a Slack Bolt app to AWS Lambda using the Serverless Framework. The command packages and deploys the current service, outputting endpoint URLs for event handling. Serverless must be installed and configured with valid AWS credentials, and the service should be correctly defined (e.g., in `serverless.yml`).\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/deployments/aws-lambda.md#2025-04-23_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\nserverless deploy\n# Serverless: Packaging service...\n# ...\n# endpoints:\n#   POST - https://atuzelnkvd.execute-api.us-east-1.amazonaws.com/dev/slack/events\n# ...\n```\n\n----------------------------------------\n\nTITLE: Initializing and Configuring a Slack Bolt Coding Assistant App in JavaScript\nDESCRIPTION: This JavaScript snippet sets up a Slack Bolt application designed as an AI coding assistant. It imports necessary libraries (`@slack/bolt`, `@huggingface/inference`, `dotenv`, `isomorphic-fetch`), initializes the Bolt app with socket mode enabled, configures a Hugging Face Inference client using an API key from environment variables, and defines default system instructions for the AI model. It includes a helper function (`convertMarkdownToSlack`) to format model responses for Slack, creates an Assistant instance with handlers for thread initiation (`threadStarted`) and user messages (`userMessage`), implements a custom Slack function (`code_assist`) for workflow integration, registers the assistant, and contains the logic to start the app.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/code-assistant.md#2025-04-23_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nrequire(\"isomorphic-fetch\");\nconst { App, LogLevel, Assistant } = require(\"@slack/bolt\");\nconst { config } = require(\"dotenv\");\nconst { HfInference } = require(\"@huggingface/inference\");\n\nconfig();\n\n/** Initialization */\nconst app = new App({\n  token: process.env.SLACK_BOT_TOKEN,\n  appToken: process.env.SLACK_APP_TOKEN,\n  socketMode: true,\n  logLevel: LogLevel.DEBUG,\n});\n\n// HuggingFace configuration\nconst hfClient = new HfInference(process.env.HUGGINGFACE_API_KEY);\n\n// Model instructions\nconst DEFAULT_SYSTEM_CONTENT = `You're an AI assistant specialized in answering questions about code.\nYou'll analyze code-related questions and provide clear, accurate responses.\nWhen you include markdown text, convert them to Slack compatible ones.\nWhen you include code examles, convert them to Slack compatible ones. (There must be an empty line before a code block.)\nWhen a prompt has Slack's special syntax like <@USER_ID> or <#CHANNEL_ID>, you must keep them as-is in your response.`;\n\nfunction convertMarkdownToSlack(markdown) {\n  let text = markdown;\n\n  // Add newlines around code blocks first\n  text = text.replace(/```([\\s\\S]*?)```/g, (match, code) => {\n    code = code.trim();\n    return \"\\n\\n```\\n\" + code + \"\\n```\\n\\n\";\n  });\n\n  // Fix up any triple+ newlines to be double newlines\n  text = text.replace(/\\n{3,}/g, \"\\n\\n\");\n\n  // Remaining markdown conversions\n  text = text.replace(/`([^`]+)`/g, \"`$1`\");\n  text = text.replace(/\\*\\*([^*]+)\\*\\*/g, \"*$1*\");\n  text = text.replace(/__([^_]+)__/g, \"*$1*\");\n  text = text.replace(/\\*([^*]+)\\*/g, \"_$1_\");\n  text = text.replace(/_([^_]+)_/g, \"_$1_\");\n  text = text.replace(/~~([^~]+)~~/g, \"~$1~\");\n  text = text.replace(/^>\\s(.+)/gm, \">>>\\n$1\");\n  text = text.replace(/^#{1,6}\\s(.+)$/gm, \"*$1*\");\n  text = text.replace(/^[\\*\\-\\+]\\s(.+)/gm, \"‚Ä¢ $1\");\n  text = text.replace(/^\\d+\\.\\s(.+)/gm, \"$1\");\n  text = text.replace(/\\[([^\\]]+)\\]\\(([^)]+)\\)/g, \"<$2|$1>\");\n\n  return text;\n}\n\n// Create the assistant\nconst assistant = new Assistant({\n  threadStarted: async ({ say, setSuggestedPrompts }) => {\n    try {\n      await say(\n        \"Hi! I'm your coding assistant. Ask me any questions about code!\",\n      );\n\n      const prompts = [\n        {\n          title: \"Code Example\",\n          message:\n            \"Show me an example of implementing a binary search tree in JavaScript.\",\n        },\n        {\n          title: \"Code Review\",\n          message:\n            \"What are best practices for writing clean, maintainable code?\",\n        },\n        {\n          title: \"Debug Help\",\n          message: \"How do I debug memory leaks in Node.js applications?\",\n        },\n      ];\n\n      await setSuggestedPrompts({\n        prompts,\n        title: \"Here are some questions you can ask:\",\n      });\n    } catch (error) {\n      console.error(\"Error in threadStarted:\", error);\n    }\n  },\n\n  userMessage: async ({ message, client, say, setTitle, setStatus }) => {\n    const { channel, thread_ts } = message;\n\n    try {\n      await setTitle(message.text);\n      await setStatus(\"is thinking...\");\n\n      // Retrieve the Assistant thread history for context of question being asked\n      const thread = await client.conversations.replies({\n        channel,\n        ts: thread_ts,\n        oldest: thread_ts,\n      });\n\n      // Prepare and tag each message for LLM processing\n      const userMessage = { role: \"user\", content: message.text };\n      const threadHistory = thread.messages.map((m) => {\n        const role = m.bot_id ? \"assistant\" : \"user\";\n        return { role, content: m.text };\n      });\n\n      const messages = [\n        { role: \"system\", content: DEFAULT_SYSTEM_CONTENT },\n        ...threadHistory,\n        userMessage,\n      ];\n\n      const modelResponse = await hfClient.chatCompletion({\n        model: \"Qwen/Qwen2.5-Coder-32B-Instruct\",\n        messages,\n        max_tokens: 2000,\n      });\n\n      await setStatus(\"is typing...\");\n      await say(\n        convertMarkdownToSlack(modelResponse.choices[0].message.content),\n      );\n    } catch (error) {\n      console.error(\"Error in userMessage:\", error);\n      await say(\n        \"I'm sorry, I ran into an error processing your request. Please try again.\",\n      );\n    }\n  },\n});\n\n// Register the assistant with the app\napp.assistant(assistant);\n\n// Set up custom function for assistant\napp.function(\"code_assist\", async ({ client, inputs, complete, fail }) => {\n  try {\n    const { channel_id, message_id } = inputs;\n    let messages;\n\n    try {\n      const result = await client.conversations.history({\n        channel: channel_id,\n        oldest: message_id,\n        limit: 1,\n        inclusive: true,\n      });\n\n      messages = [\n        { role: \"system\", content: DEFAULT_SYSTEM_CONTENT },\n        { role: \"user\", content: result.messages[0].text },\n      ];\n    } catch (e) {\n      // If the Assistant is not in the channel it's being asked about,\n      // have it join the channel and then retry the API call\n      if (e.data.error === \"not_in_channel\") {\n        await client.conversations.join({ channel: channel_id });\n        const result = await client.conversations.history({\n          channel: channel_id,\n          oldest: message_id,\n          limit: 1,\n          inclusive: true,\n        });\n\n        messages = [\n          { role: \"system\", content: DEFAULT_SYSTEM_CONTENT },\n          { role: \"user\", content: result.messages[0].text },\n        ];\n      } else {\n        console.error(e);\n      }\n    }\n\n    const modelResponse = await hfClient.chatCompletion({\n      model: \"Qwen/Qwen2.5-Coder-32B-Instruct\",\n      messages,\n      max_tokens: 2000,\n    });\n\n    await complete({\n      outputs: {\n        message: convertMarkdownToSlack(\n          modelResponse.choices[0].message.content,\n        ),\n      },\n    });\n  } catch (error) {\n    console.error(error);\n    fail({ error: `Failed to complete the step: ${error}` });\n  }\n});\n\n// Start the app\n(async () => {\n  try {\n    await app.start();\n    console.log(\"‚ö°Ô∏è Code Assistant app is running!\");\n  } catch (error) {\n    console.error(\"Failed to start app:\", error);\n  }\n})();\n```\n\n----------------------------------------\n\nTITLE: Function Configuration in App Manifest\nDESCRIPTION: JSON configuration defining the custom 'Request Time Off' workflow step in the app manifest, including its input and output parameters for manager ID, submitter ID, and request decision.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/custom-steps-workflow-builder-existing.md#2025-04-23_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n\"functions\": {\\n        \"request_time_off\": {\\n            \"title\": \"Request time off\",\\n            \"description\": \"Submit a request to take time off\",\\n            \"input_parameters\": {\\n                \"manager_id\": {\\n                    \"type\": \"slack#/types/user_id\",\\n                    \"title\": \"Manager\",\\n                    \"description\": \"Approving manager\",\\n                    \"is_required\": true,\\n                    \"hint\": \"Select a user in the workspace\",\\n                    \"name\": \"manager_id\"\\n                },\\n                \"submitter_id\": {\\n                    \"type\": \"slack#/types/user_id\",\\n                    \"title\": \"Submitting user\",\\n                    \"description\": \"User that submitted the request\",\\n                    \"is_required\": true,\\n                    \"name\": \"submitter_id\"\\n                }\\n            },\\n            \"output_parameters\": {\\n                \"manager_id\": {\\n                    \"type\": \"slack#/types/user_id\",\\n                    \"title\": \"Manager\",\\n                    \"description\": \"Approving manager\",\\n                    \"is_required\": true,\\n                    \"name\": \"manager_id\"\\n                },\\n                \"request_decision\": {\\n                    \"type\": \"boolean\",\\n                    \"title\": \"Request decision\",\\n                    \"description\": \"Decision to the request for time off\",\\n                    \"is_required\": true,\\n                    \"name\": \"request_decision\"\\n                },\\n                \"submitter_id\": {\\n                    \"type\": \"slack#/types/user_id\",\\n                    \"title\": \"Submitting user\",\\n                    \"description\": \"User that submitted the request\",\\n                    \"is_required\": true,\\n                    \"name\": \"submitter_id\"\\n                }\\n            }\\n        }\\n    }\n```\n\n----------------------------------------\n\nTITLE: Adding Goodbye Message Handler - Bolt for JavaScript - JavaScript\nDESCRIPTION: This snippet adds a message event handler to a Bolt for JavaScript Slack app which listens for the keyword 'goodbye'. When the app receives a message containing 'goodbye', it sends a farewell to the channel where the message originated. The app depends on the Bolt for JavaScript framework, and `app` must be an initialized Bolt App instance; the event handler parameters include the incoming message and the `say` function for replying. Expects valid Slack event objects; outputs a formatted farewell string mentioning the user.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/deployments/aws-lambda.md#2025-04-23_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\n// Listens to incoming messages that contain \"goodbye\"\napp.message('goodbye', async ({ message, say }) => {\n  // say() sends a message to the channel where the event was triggered\n  await say(`See ya later, <@${message.user}> :wave:`);\n});\n```\n\n----------------------------------------\n\nTITLE: Handling View Closed Events in Slack Bolt.js\nDESCRIPTION: Shows how to handle a view_closed event by specifying both the callback_id and type in the view method options.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/view-submissions.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\napp.view({ callback_id: 'view_b', type: 'view_closed' }, async ({ ack, body, view, client }) => {\n  // Acknowledge the view_closed request\n  await ack();\n  // react on close request\n});\n```\n\n----------------------------------------\n\nTITLE: Filtering Message Events by Subtype in Bolt.js\nDESCRIPTION: Demonstrates how to use the subtype middleware to filter for specific message event subtypes. Example shows tracking message edits by users.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/message-listening.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// Import subtype from the package\nconst { App, subtype } = require('@slack/bolt');\n\n// Matches all message changes from users\napp.message(subtype('message_changed'), ({ event, logger }) => {\n  // This if statement is required in TypeScript code\n  if (event.subtype === 'message_changed'\n    && !event.message.subtype\n    && !event.previous_message.subtype) {\n    logger.info(`The user ${event.message.user} changed their message from ${event.previous_message.text} to ${event.message.text}`);\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Installation Object Structure Example\nDESCRIPTION: Shows the structure of an installation object received after successful OAuth installation for a single workspace.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/authenticating-oauth.md#2025-04-23_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  team: { id: \"T012345678\", name: \"example-team-name\" },\n  enterprise: undefined,\n  user: { token: undefined, scopes: undefined, id: \"U012345678\" },\n  tokenType: \"bot\",\n  isEnterpriseInstall: false,\n  appId: \"A01234567\",\n  authVersion: \"v2\",\n  bot: {\n    scopes: [\n      \"chat:write\",\n    ],\n    token: \"xoxb-244493-28*********-********************\",\n    userId: \"U001111000\",\n    id: \"B01234567\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Redirect URL in Bolt.js\nDESCRIPTION: Sets up a custom redirect URL for OAuth flow by configuring redirectUri and redirectUriPath in the App initialization options. Requires environment variables for Slack credentials.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/authenticating-oauth.md#2025-04-23_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst app = new App({\n  signingSecret: process.env.SLACK_SIGNING_SECRET,\n  clientId: process.env.SLACK_CLIENT_ID,\n  clientSecret: process.env.SLACK_CLIENT_SECRET,\n  stateSecret: process.env.SLACK_STATE_SECRET,\n  scopes: [\"chat:write\"],\n  redirectUri: \"https://example.com/slack/redirect\",\n  installerOptions: {\n    redirectUriPath: \"/slack/redirect\",\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Install Query Object Structure\nDESCRIPTION: Demonstrates the structure of an installQuery object used for fetching and deleting installations.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/authenticating-oauth.md#2025-04-23_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  userId: \"U012345678\",\n  isEnterpriseInstall: false,\n  teamId: \"T012345678\",\n  enterpriseId: undefined,\n  conversationId: \"D02345678\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom OAuth Callbacks in Bolt.js\nDESCRIPTION: Defines custom success and failure callback handlers for the OAuth installation process using installerOptions.callbackOptions.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/authenticating-oauth.md#2025-04-23_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst app = new App({\n  signingSecret: process.env.SLACK_SIGNING_SECRET,\n  installerOptions: {\n    callbackOptions: {\n      success: (installation, installOptions, req, res) => {\n        res.send(\"The installation succeeded!\");\n      },\n      failure: (error, installOptions, req, res) => {\n        res.send(\"Something strange happened...\");\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Assistant Thread Started Event Handler - JavaScript\nDESCRIPTION: Handling the assistant_thread_started event to initialize conversation and set suggested prompts.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/ai-assistant.md#2025-04-23_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nthreadStarted: async ({ event, logger, say, setSuggestedPrompts, saveThreadContext }) => {\n  const { context } = event.assistant_thread;\n\n  try {\n    await say('Hi, how can I help?');\n    await saveThreadContext();\n\n    const prompts = [{\n      title: 'This is a suggested prompt',\n      message: 'When a user clicks a prompt, the resulting prompt message text can be passed '\n      + 'directly to your LLM for processing.\\n\\nAssistant, please create some helpful prompts '\n      + 'I can provide to my users.',\n    }];\n\n    if (context.channel_id) {\n      prompts.push({\n        title: 'Summarize channel',\n        message: 'Assistant, please summarize the activity in this channel!',\n      });\n    }\n\n    await setSuggestedPrompts({ prompts, title: 'Here are some suggested options:' });\n  } catch (e) {\n    logger.error(e);\n  }\n},\n```\n\n----------------------------------------\n\nTITLE: Importing webApi from Slack Bolt-JS Using TypeScript\nDESCRIPTION: This snippet demonstrates how to import the re-exported webApi module from the @slack/bolt package in TypeScript. By doing so, application developers can use the WebClient and other utilities provided by @slack/web-api without managing that dependency directly, unless specific version requirements exist. This import assumes that @slack/bolt is installed and peer dependencies are satisfied.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/migration/migration-v4.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { webApi } from '@slack/bolt';\n// now can use e.g. webApi.WebClient, etc.\n```\n\n----------------------------------------\n\nTITLE: Using Built-In Middleware Directly Without Invocation - TypeScript\nDESCRIPTION: This example shows the migration from calling built-in middleware as functions to using them directly as values. Previously, directMention would be called as a function to return middleware, but is now used as a directly-exported reference. This affects app.message handler signatures and simplifies usage. Prerequisite: slack/bolt-js v4.x.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/migration/migration-v4.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\napp.message(directMention(), async (args) => {\n  // my handler here\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\napp.message(directMention, async (args) => {\n  // my handler here\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring User Token Scopes in Bolt.js\nDESCRIPTION: Sets up user token scopes in addition to bot scopes for taking actions on behalf of users.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/authenticating-oauth.md#2025-04-23_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nconst app = new App({\n  signingSecret: process.env.SLACK_SIGNING_SECRET,\n  clientId: process.env.SLACK_CLIENT_ID,\n  clientSecret: process.env.SLACK_CLIENT_SECRET,\n  scopes: [\"chat:write\", \"channels:history\"],\n  installerOptions: {\n    userScopes: [\"chat:write\"],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using Built-in Logger in Bolt.js Application\nDESCRIPTION: Shows how to use the built-in logger to write logs during application startup. Demonstrates using different log levels like debug and info.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/logging.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n(async () => {\n  app.logger.debug(\"Starting the app now!\");\n  await app.start();\n  app.logger.info(\"‚ö°Ô∏è Bolt app started\");\n})();\n```\n\n----------------------------------------\n\nTITLE: Listening to Basic Actions in Slack Bolt.js\nDESCRIPTION: Basic example of listening to an action with a specific action_id in Slack. Shows how to acknowledge the action using the ack() function.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/actions.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\napp.action('approve_button', async ({ ack }) => {\n  await ack();\n  // Update the message to reflect the action\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Conditional Middleware Argument Types in TypeScript\nDESCRIPTION: This TypeScript type definition demonstrates how middleware argument types are now constructed using conditional intersections, allowing for context-dependent type extensions. If the event type is 'message', a message property of the appropriate type is included; otherwise, the addition is a no-op (unknown). This avoids issues with undefined properties in generic middleware, improving compilation and type inference. No external dependencies are required beyond TypeScript.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/migration/migration-v4.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype SomeMiddlewareArgs<EventType extends string = string> = {\n  // some type in here\n} & (EventType extends 'message'\n  // If this is a message event, add a `message` property\n  ? { message: EventFromType<EventType> }\n  : unknown\n)\n```\n\n----------------------------------------\n\nTITLE: Installation Store Implementation - Before Migration\nDESCRIPTION: Shows the previous v2.x implementation of installation store with separate methods for org-wide and team installations.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/migration/migration-v3.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\ninstallationStore: {\n    storeInstallation: async (installation) => {\n      // change the line below so it saves to your database\n      return await database.set(installation.team.id, installation);\n    },\n    fetchInstallation: async (installQuery) => {\n      // change the line below so it fetches from your database\n      return await database.get(installQuery.teamId);\n    },\n    storeOrgInstallation: async (installation) => {\n      // include this method if you want your app to support org wide installations\n      // change the line below so it saves to your database\n      return await database.set(installation.enterprise.id, installation);\n    },\n    fetchOrgInstallation: async (installQuery) => {\n      // include this method if you want your app to support org wide installations\n      // change the line below so it fetches from your database\n      return await database.get(installQuery.enterpriseId);\n    },\n  }\n```\n\n----------------------------------------\n\nTITLE: Configuring Org-wide Installation Settings\nDESCRIPTION: Demonstrates how to configure Bolt.js for org-wide installations by disabling state verification.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/authenticating-oauth.md#2025-04-23_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nconst app = new App({\n  signingSecret: process.env.SLACK_SIGNING_SECRET,\n  clientId: process.env.SLACK_CLIENT_ID,\n  clientSecret: process.env.SLACK_CLIENT_SECRET,\n  scopes: [\"chat:write\"],\n  installerOptions: {\n    stateVerification: false,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Message Metadata Event Subscriptions\nDESCRIPTION: YAML configuration for setting up message metadata event subscriptions in the Slack App Manifest, including bot events and metadata subscriptions with app_id.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/message-metadata/README.md#2025-04-23_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nsettings:\n  event_subscriptions:\n    bot_events:\n      - message_metadata_deleted\n      - message_metadata_posted\n      - message_metadata_updated\n    metadata_subscriptions:\n      - app_id: YOUR_APP_ID\n        event_type: my_event\n```\n\n----------------------------------------\n\nTITLE: Sending Thread History Context to LLM and Handling Errors in Bolt JS Assistant\nDESCRIPTION: This snippet completes the `userMessage` handling logic using thread history. It constructs the final `messages` array for the LLM, including a system prompt, the formatted `threadHistory`, and the current `userMessage`. This payload is sent to the LLM via `hfClient.chatCompletion`. The LLM's response is then sent back to the Slack user using `say`. The entire operation is enclosed in a try-catch block to log errors via `logger` and notify the user with a generic error message using `say` if any part of the process fails.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/ai-assistant.md#2025-04-23_snippet_13\n\nLANGUAGE: js\nCODE:\n```\n\n      const messages = [\n        { role: 'system', content: DEFAULT_SYSTEM_CONTENT },\n        ...threadHistory,\n        userMessage,\n      ];\n\n      // Send message history and newest question to LLM\n      const llmResponse = await hfClient.chatCompletion({\n        model: 'Qwen/QwQ-32B',\n        messages,\n        max_tokens: 2000,\n      });\n\n      // Provide a response to the user\n      await say({ text: llmResponse.choices[0].message.content });\n    } catch (e) {\n      logger.error(e);\n\n      // Send message to advise user and clear processing status if a failure occurs\n      await say({ text: 'Sorry, something went wrong!' });\n    }\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Socket Mode Procfile Configuration\nDESCRIPTION: Heroku Procfile configuration for running Bolt.js app in Socket Mode as a worker.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/deployments/heroku.md#2025-04-23_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nworker: node app.js\n```\n\n----------------------------------------\n\nTITLE: Web Server Procfile Configuration\nDESCRIPTION: Heroku Procfile configuration for running Bolt.js app as a web server with public address.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/deployments/heroku.md#2025-04-23_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nweb: node app.js\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple In-Memory Database for Bolt Installation Store Testing in JavaScript\nDESCRIPTION: This JavaScript code defines a basic `database` object for demonstration or testing purposes. It uses a simple JavaScript object (`store`) for in-memory storage and provides asynchronous `get`, `delete`, and `set` methods to interact with this store, simulating the interface required by the Bolt `installationStore` example. This implementation is volatile and not suitable for production environments.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/authenticating-oauth.md#2025-04-23_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\nconst database = {\n  store: {},\n  async get(key) {\n    return this.store[key];\n  },\n  async delete(key) {\n    delete this.store[key];\n  },\n  async set(key, value) {\n    this.store[key] = value;\n  },\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Custom HTTP Routes with ExpressReceiver in JavaScript\nDESCRIPTION: This code shows how to add custom HTTP routes using the ExpressReceiver approach in Bolt.js. It demonstrates creating an explicit receiver instance, defining Slack event handlers on the app, and adding custom middleware and routes using the receiver's router property.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/custom-routes.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst { App, ExpressReceiver } = require('@slack/bolt');\n\n// Bolt „ÅÆ Receiver „ÇíÊòé„Å´ÁîüÊàê\nconst receiver = new ExpressReceiver({ signingSecret: process.env.SLACK_SIGNING_SECRET });\n\n// App „Çí„Åì„ÅÆ„É¨„Ç∑„Éº„Éê„Éº„ÇíÊåáÂÆö„Åó„Å¶ÁîüÊàê\nconst app = new App({\n  token: process.env.SLACK_BOT_TOKEN,\n  receiver\n});\n\n// Slack „Å®„ÅÆ„ÇÑ„Çä„Å®„Çä„ÅØ App „ÅÆ„É°„ÇΩ„ÉÉ„Éâ„ÅßÂÆöÁæ©\napp.event('message', async ({ event, client }) => {\n  // Do some slack-specific stuff here\n  await client.chat.postMessage(...);\n});\n\nreceiver.router.use((req, res, next) => {\n  app.logger.info(`Request time: ${Date.now()}`);\n  next();\n});\n\n// „Åù„Çå‰ª•Â§ñ„ÅÆ Web „É™„ÇØ„Ç®„Çπ„Éà„ÅÆÂá¶ÁêÜ„ÅØ receiver.router „ÅÆ„É°„ÇΩ„ÉÉ„Éâ„ÅßÂÆöÁæ©\nreceiver.router.post('/secret-page', (req, res) => {\n  // „Åì„Åì„Åß„ÅØ Express „ÅÆ„É™„ÇØ„Ç®„Çπ„Éà„ÇÑ„É¨„Çπ„Éù„É≥„Çπ„Çí„Åù„ÅÆ„Åæ„ÅæÊâ±„ÅÜ\n  res.send('yay!');\n});\n\n(async () => {\n  await app.start();\n  app.logger.info('‚ö°Ô∏è Bolt app started');\n})();\n```\n\n----------------------------------------\n\nTITLE: Handling Button Click (HTTP) in Bolt App\nDESCRIPTION: This snippet shows a complete Bolt app configured for HTTP. It includes the 'hello' message listener from the previous HTTP example, which sends a button. Additionally, it adds an `app.action()` listener specifically for the 'button_click' `action_id`. When the button is clicked, the app acknowledges the action (`ack()`) and sends a follow-up message indicating which user clicked the button.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/getting-started.mdx#2025-04-23_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\nconst { App } = require('@slack/bolt');\n\nconst app = new App({\n  token: process.env.SLACK_BOT_TOKEN,\n  signingSecret: process.env.SLACK_SIGNING_SECRET\n});\n\n// Listens to incoming messages that contain \"hello\"\napp.message('hello', async ({ message, say }) => {\n  // say() sends a message to the channel where the event was triggered\n  await say({\n    blocks: [\n      {\n        \"type\": \"section\",\n        \"text\": {\n          \"type\": \"mrkdwn\",\n          \"text\": `Hey there <@${message.user}>!`\n        },\n        \"accessory\": {\n          \"type\": \"button\",\n          \"text\": {\n            \"type\": \"plain_text\",\n            \"text\": \"Click Me\"\n          },\n          \"action_id\": \"button_click\"\n        }\n      }\n    ],\n    text: `Hey there <@${message.user}>!`\n  });\n});\n\napp.action('button_click', async ({ body, ack, say }) => {\n  // Acknowledge the action\n  await ack();\n  await say(`<@${body.user.id}> clicked the button`);\n});\n\n(async () => {\n  // Start your app\n  await app.start(process.env.PORT || 3000);\n\n  app.logger.info('‚ö°Ô∏è Bolt app is running!');\n})();\n```\n```\n\n----------------------------------------\n\nTITLE: Starting the Local Development Server\nDESCRIPTION: NPM command to start the local development server. This launches the Bolt application, which connects to Slack using Socket Mode to listen for and respond to workflow step events.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/custom-steps-workflow-builder-new.md#2025-04-23_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies\nDESCRIPTION: NPM command to install all the dependencies required for the Bolt application to run. These dependencies include the Bolt for JavaScript framework and other packages needed for the custom step functionality.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/custom-steps-workflow-builder-new.md#2025-04-23_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Example Database Implementation\nDESCRIPTION: Provides a simple in-memory database implementation for testing purposes with basic CRUD operations.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/authenticating-oauth.md#2025-04-23_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nconst database = {\n  store: {},\n  async delete(key) {\n    delete this.store[key];\n  },\n  async get(key) {\n    return this.store[key];\n  },\n  async set(key, value) {\n    this.store[key] = value;\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Bolt„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆÈÅÖÂª∂ÂàùÊúüÂåñ„ÅÆÂÆüË£Ö (JavaScript)\nDESCRIPTION: „Åì„ÅÆ„Ç≥„Éº„Éâ„Çπ„Éã„Éö„ÉÉ„Éà„ÅØ„ÄÅBolt„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Åß`deferInitialization`„Ç™„Éó„Ç∑„Éß„É≥„Çí‰ΩøÁî®„Åó„Å¶ÂàùÊúüÂåñ„ÇíÈÅÖÂª∂„Åï„Åõ„ÄÅ`init()`„É°„ÇΩ„ÉÉ„Éâ„Çí‰ΩøÁî®„Åó„Å¶ÈùûÂêåÊúü„ÅßÂàùÊúüÂåñ„ÇíË°å„ÅÜÊñπÊ≥ï„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ`start()`„É°„ÇΩ„ÉÉ„Éâ„ÇíÂëº„Å≥Âá∫„ÅôÂâç„Å´`init()`„É°„ÇΩ„ÉÉ„Éâ„ÇíÂëº„Å≥Âá∫„ÅôÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/deferring-initialization.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst { App } = require('@slack/bolt');\n\n// deferInitialization „ÅØ„Ç≥„É≥„Çπ„Éà„É©„ÇØ„Çø„Éº„ÅßÊåáÂÆö„Åß„Åç„Çã„Ç™„Éó„Ç∑„Éß„É≥\nconst app = new App({\n  token,\n  signingSecret,\n  deferInitialization: true,\n});\n\n(async () => {\n  try {\n    // ÈùûÂêåÊúüÈñ¢Êï∞„ÅÆ‰∏≠„Åß start() „É°„ÇΩ„ÉÉ„Éâ„ÇíÂëº„Å≥Âá∫„ÅôÂâç„Å´ init() „É°„ÇΩ„ÉÉ„Éâ„ÇíÂëº„Å≥Âá∫„Åô„Åì„Å®\n    await app.init();\n    // init() „É°„ÇΩ„ÉÉ„Éâ„ÇíÂëº„Å≥Âá∫„Åó„Åü„ÅÆ„Åß„ÄÅ`start()` „É°„ÇΩ„ÉÉ„Éâ„ÇíÂÆâÂÖ®„Å´Âëº„Å≥Âá∫„Åô„Åì„Å®„Åå„Åß„Åç„Çã\n    await app.start(process.env.PORT || 3000);\n  } catch (e) {\n    app.logger.error(e);\n    process.exit(1);\n  }\n})()\n```\n\n----------------------------------------\n\nTITLE: Formatting Channel History Prompt for LLM in Bolt JS Assistant\nDESCRIPTION: This snippet continues the process of using channel history for context. It constructs a prompt string (`llmPrompt`) for an LLM by prepending a specific request to the formatted channel messages. It then assembles the `messages` array, including a system message (defined elsewhere as `DEFAULT_SYSTEM_CONTENT`) and the user prompt containing the channel history. This payload is sent to a Hugging Face client (`hfClient`) for chat completion, and the LLM's response is sent back to the user via the `say` function.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/ai-assistant.md#2025-04-23_snippet_11\n\nLANGUAGE: js\nCODE:\n```\n\n        // Prepare and tag the prompt and messages for LLM processing\n        let llmPrompt = `Please generate a brief summary of the following messages from Slack channel <#${threadContext.channel_id}:`;\n        channelHistory.messages.reverse().forEach((m) => {\n          if (m.user) llmPrompt += `\\n<@${m.user}> says: ${m.text}`;\n        });\n\n        const messages = [\n          { role: 'system', content: DEFAULT_SYSTEM_CONTENT },\n          { role: 'user', content: llmPrompt },\n        ];\n\n        // Send channel history and prepared request to LLM\n        const llmResponse = await hfClient.chatCompletion({\n          model: 'Qwen/QwQ-32B',\n          messages,\n          max_tokens: 2000,\n        });\n\n        // Provide a response to the user\n        await say({ text: llmResponse.choices[0].message.content });\n\n        return;\n      }\n```\n\n----------------------------------------\n\nTITLE: Navigating to the Project Directory\nDESCRIPTION: Command to change the current directory to the newly cloned project folder. This step is necessary before installing dependencies or running the application.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/custom-steps-workflow-builder-new.md#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncd boltstep\n```\n\n----------------------------------------\n\nTITLE: Setting Up Slack Environment Variables\nDESCRIPTION: Configuration of required Slack environment variables including client ID, client secret, and signing secret obtained from the Slack app configuration.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/custom-receiver/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport SLACK_CLIENT_ID=YOUR_SLACK_CLIENT_ID\nexport SLACK_CLIENT_SECRET=YOUR_SLACK_CLIENT_SECRET\nexport SLACK_SIGNING_SECRET=YOUR_SLACK_SIGNING_SECRET\n```\n\n----------------------------------------\n\nTITLE: Importing Required Modules - JavaScript\nDESCRIPTION: Importing necessary modules including Bolt, dotenv, and Hugging Face inference.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/ai-assistant.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst { App, LogLevel, Assistant } = require('@slack/bolt');\nconst { config } = require('dotenv');\nconst { HfInference } = require('@huggingface/inference');\n```\n\n----------------------------------------\n\nTITLE: Implementing Global Error Handler in Bolt.js v2\nDESCRIPTION: Example showing how to set up the global error handler in Bolt.js v2. This handler captures errors that aren't caught in individual listeners.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/migration/migration-v2.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\napp.error(async (error) => {\n  // Check the details of the error to handle cases where you should retry sending a message or stop the app\n  console.error(error);\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing a Bolt App in JavaScript\nDESCRIPTION: Creates and starts a Bolt app by importing the App constructor, configuring it with Slack credentials, and starting the server. Requires environment variables for the signing secret and bot token.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/README.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst { App } = require('@slack/bolt');\n\nconst app = new App({\n  signingSecret: process.env.SLACK_SIGNING_SECRET,\n  token: process.env.SLACK_BOT_TOKEN,\n});\n\n/* Add functionality here */\n\n(async () => {\n  // Start the app\n  await app.start(process.env.PORT || 3000);\n\n  console.log('‚ö°Ô∏è Bolt app is running!');\n})();\n```\n\n----------------------------------------\n\nTITLE: Starting the Koa Application\nDESCRIPTION: Command to start the application using npm run script.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/custom-receiver/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run koa\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies using Link Script\nDESCRIPTION: Shell script command to link to the latest source code of the project.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/custom-receiver/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./link.sh\n```\n\n----------------------------------------\n\nTITLE: Setting Heroku Environment Variables\nDESCRIPTION: Commands to configure essential Slack credentials as Heroku environment variables, including the signing secret and bot token.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/deploy-heroku/README.md#2025-04-23_snippet_2\n\nLANGUAGE: zsh\nCODE:\n```\nheroku config:set SLACK_SIGNING_SECRET=<your-signing-secret>\nheroku config:set SLACK_BOT_TOKEN=xoxb-<your-bot-token>\n```\n\n----------------------------------------\n\nTITLE: Handling Errors in Listeners with try/catch in Bolt.js v2\nDESCRIPTION: Example demonstrating how to handle errors within listeners using try/catch blocks. This approach is recommended over letting errors propagate to the global error handler.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/migration/migration-v2.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\napp.action('some-action-id', async ({action, ack, say, logger}) => { \n  try {\n    await ack();\n    await say('hello world');\n  } catch (error) {\n    logger.error(error);\n    // handle error\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: App Manifest Definition for Interactive Custom Step\nDESCRIPTION: JSON configuration for defining an interactive custom step with a button in a Slack app manifest. It specifies the input parameter for the user ID and the output parameter returned after button interaction.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/custom-steps.md#2025-04-23_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n...\n\"functions\": {\n    \"custom_step_button\": {\n        \"title\": \"Custom step with a button\",\n        \"description\": \"Custom step that waits for a button click\",\n        \"input_parameters\": {\n            \"user_id\": {\n                \"type\": \"slack#/types/user_id\",\n                \"title\": \"User\",\n                \"description\": \"The recipient of a message with a button\",\n                \"is_required\": true,\n            }\n        },\n        \"output_parameters\": {\n            \"user_id\": {\n                \"type\": \"slack#/types/user_id\",\n                \"title\": \"User\",\n                \"description\": \"The user that completed the function\",\n                \"is_required\": true\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies\nDESCRIPTION: Command to install local development dependencies using npm\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/deploy-aws-lambda/README.md#2025-04-23_snippet_1\n\nLANGUAGE: zsh\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Starting the Slack Bolt Application\nDESCRIPTION: Command to start the Slack Bolt application.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/socket-mode/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Installing Bolt for JavaScript using npm\nDESCRIPTION: Command to install the Bolt package from npm. This is the first step to start developing a Slack app with Bolt.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @slack/bolt\n```\n\n----------------------------------------\n\nTITLE: Setting Slack Environment Variables\nDESCRIPTION: Commands to export required Slack app credentials as environment variables\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/deploy-aws-lambda/README.md#2025-04-23_snippet_2\n\nLANGUAGE: zsh\nCODE:\n```\nexport SLACK_SIGNING_SECRET=<your-signing-secret>\nexport SLACK_BOT_TOKEN=<your-xoxb-bot-token>\n```\n\n----------------------------------------\n\nTITLE: Authorization Function Implementation - After Migration\nDESCRIPTION: Shows the new v3.x implementation with a single consolidated authorize function handling both scenarios.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/migration/migration-v3.md#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst app = new App({ authorize: authorizeFn, signingSecret: process.env.SLACK_SIGNING_SECRET });\n\nconst authorizeFn = async ({ teamId, enterpriseId, isEnterpriseInstall}) => { \n  // if isEnterpriseInstall is true, use enterpriseId to fetch installation details from database\n  // else, use teamId to fetch installation details from database\n}\n```\n\n----------------------------------------\n\nTITLE: App Manifest Definition for Custom Step\nDESCRIPTION: JSON configuration for defining a custom step in a Slack app manifest. It includes the step's title, description, required input parameters, and output parameters.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/custom-steps.md#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n...\n\"functions\": {\n    \"sample_custom_step\": {\n        \"title\": \"Sample custom step\",\n        \"description\": \"Run a sample custom step\",\n        \"input_parameters\": {\n            \"message\": {\n                \"type\": \"string\",\n                \"title\": \"Message\",\n                \"description\": \"A message to be formatted by a custom step\",\n                \"is_required\": true,\n            }\n        },\n        \"output_parameters\": {\n            \"message\": {\n                \"type\": \"string\",\n                \"title\": \"Messge\",\n                \"description\": \"A formatted message\",\n                \"is_required\": true,\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: OAuth Redirect URL Format\nDESCRIPTION: Example format for the OAuth redirect URL configuration.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/socket-mode/README.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nhttps://3cb89939.ngrok.io/slack/oauth_redirect\n```\n\n----------------------------------------\n\nTITLE: Example Ngrok Forwarding Output\nDESCRIPTION: Sample output showing the Ngrok forwarding address for the application.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/socket-mode/README.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nForwarding   https://3cb89939.ngrok.io -> http://localhost:3000\n```\n\n----------------------------------------\n\nTITLE: Configuring Org-Ready Settings in Slack App Manifest\nDESCRIPTION: JSON configuration to enable organization-wide deployment for Slack apps, required for custom workflow steps.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/custom-steps.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n    \"settings\": {\n        \"org_deploy_enabled\": true,\n        ...\n    }\n```\n\n----------------------------------------\n\nTITLE: Installation Store Implementation - After Migration\nDESCRIPTION: Shows the new v3.x implementation of installation store with consolidated methods handling both org-wide and team installations.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/migration/migration-v3.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\ninstallationStore: {\n    storeInstallation: async (installation) => {\n      if (installation.isEnterpriseInstall && installation.enterprise !== undefined) {\n        // support for org wide app installation\n        return await database.set(installation.enterprise.id, installation);\n      }\n      if (installation.team !== undefined) {\n        // single team app installation\n        return await database.set(installation.team.id, installation);\n      }\n      throw new Error('Failed saving installation data to installationStore');\n    },\n    fetchInstallation: async (installQuery) => {\n      // replace database.get so it fetches from your database\n      if (installQuery.isEnterpriseInstall && installQuery.enterpriseId !== undefined) {\n        // org wide app installation lookup\n        return await database.get(installQuery.enterpriseId);\n      }\n      if (installQuery.teamId !== undefined) {\n        // single team app installation lookup\n        return await database.get(installQuery.teamId);\n      }\n      throw new Error('Failed fetching installation');\n    },\n  }\n```\n\n----------------------------------------\n\nTITLE: Message Handler Implementation\nDESCRIPTION: JavaScript code implementing a Slack message handler that responds to 'goodbye' messages with a farewell message.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/deployments/heroku.md#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\napp.message('goodbye', async ({ message, say }) => {\n  await say(`See ya later, <@${message.user}> :wave:`);\n});\n```\n\n----------------------------------------\n\nTITLE: Cloning Starter Template\nDESCRIPTION: Command to clone the Bolt.js starter template repository.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/code-assistant.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/slack-samples/bolt-js-starter-template.git\n```\n\n----------------------------------------\n\nTITLE: Default System Content Configuration - JavaScript\nDESCRIPTION: Defining default system content for assistant responses with Slack-specific formatting instructions.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/ai-assistant.md#2025-04-23_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst DEFAULT_SYSTEM_CONTENT = `You're an assistant in a Slack workspace.\nUsers in the workspace will ask you to help them write something or to think better about a specific topic.\nYou'll respond to those questions in a professional way.\nWhen you include markdown text, convert them to Slack compatible ones.\nWhen a prompt has Slack's special syntax like <@USER_ID> or <#CHANNEL_ID>, you must keep them as-is in your response.`;\n```\n\n----------------------------------------\n\nTITLE: „Ç´„Çπ„Çø„É†„É™„Çπ„Éä„Éº„Éü„Éâ„É´„Ç¶„Çß„Ç¢„ÅÆÂÆüË£Ö„Å®„Éú„ÉÉ„Éà„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Éï„Ç£„É´„Çø„É™„É≥„Ç∞ÔºàJavaScriptÔºâ\nDESCRIPTION: „Åì„ÅÆ„Ç≥„Éº„Éâ„Çπ„Éã„Éö„ÉÉ„Éà„ÅØ„ÄÅ„Éú„ÉÉ„Éà„É°„ÉÉ„Çª„Éº„Ç∏„Çí„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„Åô„Çã„Ç´„Çπ„Çø„É†„É™„Çπ„Éä„Éº„Éü„Éâ„É´„Ç¶„Çß„Ç¢ 'noBotMessages' „ÅÆÂÆüË£Ö„Å®„ÄÅ„Åù„ÅÆ„Éü„Éâ„É´„Ç¶„Çß„Ç¢„Çí‰ΩøÁî®„Åó„Å¶„Éú„ÉÉ„Éà„Åß„ÅØ„Å™„Åè‰∫∫Èñì„Åã„Çâ„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Åø„ÇíÂá¶ÁêÜ„Åô„Çã„É™„Çπ„Éä„Éº„ÅÆ‰æã„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/listener-middleware.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// 'bot_message' „Çµ„Éñ„Çø„Ç§„Éó„ÇíÊåÅ„Å§„É°„ÉÉ„Çª„Éº„Ç∏„Çí„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„Åô„Çã„É™„Çπ„Éä„Éº„Éü„Éâ„É´„Ç¶„Çß„Ç¢\nasync function noBotMessages({ message, next }) {\n  if (!message.subtype || message.subtype !== 'bot_message') {\n    await next();\n  }\n}\n\n// „Éú„ÉÉ„Éà„Åß„ÅØ„Å™„Åè‰∫∫Èñì„Åã„Çâ„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Åø„ÇíÂèó‰ø°„Åô„Çã„É™„Çπ„Éä„Éº\napp.message(noBotMessages, async ({ message, logger }) => logger.info(\n  // Êñ∞Ë¶è„ÅßÊäïÁ®ø„Åï„Çå„Åü„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Åø„ÇíÂá¶ÁêÜ\n  if (message.subtype === undefined\n    // || message.subtype === 'bot_message'\n    || message.subtype === 'file_share'\n    || message.subtype === 'thread_broadcast') {\n    logger.info(`(MSG) User: ${message.user} Message: ${message.text}`)\n  }\n));\n```\n\n----------------------------------------\n\nTITLE: Type-Narrowing for AwsEvent Interfaces in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to distinguish between v1 and v2 AWS API Gateway payloads using property checks, reflecting the new AwsEvent union type in bolt-js v4.x. By checking for the 'path' property, the appropriate request path is extracted depending on the payload version. This is essential for logging and routing logic when handling AWS Lambda events within Bolt-JS. Prerequisite: TypeScript setup; used in AWS Lambda context.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/migration/migration-v4.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// the variable `awsEvent` is of type `AwsEvent`\nlet path: string;\nif ('path' in awsEvent) {\n  // This is a v1 payload, so `awsEvent.path` exists and points to the request URL path.\n  path = awsEvent.path;\n} else {\n  // This is a v2 payload, so `awsEvent.rawPath` exists and points to the request URL path.\n  path = awsEvent.rawPath;\n}\nthis.logger.info(`No request handler matched the request: ${path}`);\n```\n\n----------------------------------------\n\nTITLE: Configuring Slack App Manifest in JSON\nDESCRIPTION: App manifest configuration that sets up a Code Assistant bot with necessary scopes, events, and function definitions. Includes settings for assistant view, OAuth configuration, and a custom workflow step.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/code-assistant.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"display_information\": {\n    \"name\": \"Code Assistant\"\n  },\n  \"features\": {\n    \"app_home\": {\n      \"home_tab_enabled\": false,\n      \"messages_tab_enabled\": true,\n      \"messages_tab_read_only_enabled\": false\n    },\n    \"bot_user\": {\n      \"display_name\": \"Code Assistant\",\n      \"always_online\": false\n    },\n    \"assistant_view\": {\n      \"assistant_description\": \"An Assistant to help you with coding questions and challenges!\",\n      \"suggested_prompts\": []\n    }\n  },\n  \"oauth_config\": {\n    \"scopes\": {\n      \"bot\": [\n        \"assistant:write\",\n        \"channels:join\",\n        \"im:history\",\n        \"channels:history\",\n        \"groups:history\",\n        \"chat:write\"\n      ]\n    }\n  },\n  \"settings\": {\n    \"event_subscriptions\": {\n      \"bot_events\": [\n        \"assistant_thread_context_changed\",\n        \"assistant_thread_started\",\n        \"message.im\",\n        \"function_executed\"\n      ]\n    },\n    \"interactivity\": {\n      \"is_enabled\": true\n    },\n    \"org_deploy_enabled\": true,\n    \"socket_mode_enabled\": true,\n    \"function_runtime\": \"remote\",\n    \"token_rotation_enabled\": false\n  },\n  \"functions\": {\n    \"code_assist\": {\n      \"title\": \"Code Assist\",\n      \"description\": \"Get an answer about a code related question\",\n      \"input_parameters\": {\n        \"message_id\": {\n          \"type\": \"string\",\n          \"title\": \"Message ID\",\n          \"description\": \"The message the question was asked in.\",\n          \"is_required\": true\n        },\n        \"channel_id\": {\n          \"type\": \"slack#/types/channel_id\",\n          \"title\": \"Channel ID\",\n          \"description\": \"The channel the question was asked in\",\n          \"is_required\": true\n        }\n      },\n      \"output_parameters\": {\n        \"message\": {\n          \"type\": \"string\",\n          \"title\": \"Answer\",\n          \"description\": \"The response from the Code Assistant LLM\",\n          \"is_required\": true\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running the Bolt Application\nDESCRIPTION: Command to start the Slack Bolt application using Node.js\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/getting-started.mdx#2025-04-23_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nnode app.js\n```\n\n----------------------------------------\n\nTITLE: Configuring the AWS Lambda Receiver in Bolt.js\nDESCRIPTION: Code to initialize the AWS Lambda Receiver and configure the Bolt app to use it for handling Lambda function events.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/deployments/aws-lambda.md#2025-04-23_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// Initialize your custom receiver\nconst awsLambdaReceiver = new AwsLambdaReceiver({\n    signingSecret: process.env.SLACK_SIGNING_SECRET,\n});\n\n// Initializes your app with your bot token and the AWS Lambda ready receiver\nconst app = new App({\n    token: process.env.SLACK_BOT_TOKEN,\n    receiver: awsLambdaReceiver,\n\n    // When using the AwsLambdaReceiver, processBeforeResponse can be omitted.\n    // If you use other Receivers, such as ExpressReceiver for OAuth flow support\n    // then processBeforeResponse: true is required. This option will defer sending back\n    // the acknowledgement until after your handler has run to ensure your handler\n    // isn't terminated early by responding to the HTTP request that triggered it.\n\n    // receiver.processBeforeResponse: true\n\n});\n```\n\n----------------------------------------\n\nTITLE: Adding function_executed Event Subscription in App Manifest\nDESCRIPTION: JSON configuration to add the function_executed event subscription in the app manifest, which is required for the app to receive notifications when workflow steps are executed.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/custom-steps-workflow-builder-existing.md#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n...\\n    \"settings\": {\\n        \"event_subscriptions\": {\\n            \"bot_events\": [\\n\\t\\t\\t\\t...\\n                \"function_executed\"\\n            ]\\n        },\\n\\t}\n```\n\n----------------------------------------\n\nTITLE: Creating Public URL with ngrok for Slack Events\nDESCRIPTION: Command to start ngrok HTTP tunnel on port 3000, creating a public URL that forwards to your local development server for receiving Slack events.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/deployments/aws-lambda.md#2025-04-23_snippet_11\n\nLANGUAGE: zsh\nCODE:\n```\nngrok http 3000\n```\n\n----------------------------------------\n\nTITLE: Initializing Bolt App (HTTP) and Sending a Button\nDESCRIPTION: This snippet initializes a Slack Bolt app configured for HTTP requests. It requires environment variables for the bot token and signing secret. The app listens for messages containing 'hello' and responds with a message containing a section block with a button accessory (`action_id`: 'button_click'). The app starts listening on a specified port.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/getting-started.mdx#2025-04-23_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\n```javascript\nconst { App } = require('@slack/bolt');\n\nconst app = new App({\n  token: process.env.SLACK_BOT_TOKEN,\n  signingSecret: process.env.SLACK_SIGNING_SECRET\n});\n\n// Listens to incoming messages that contain \"hello\"\napp.message('hello', async ({ message, say }) => {\n  // say() sends a message to the channel where the event was triggered\n  await say({\n    blocks: [\n      {\n        \"type\": \"section\",\n        \"text\": {\n          \"type\": \"mrkdwn\",\n          \"text\": `Hey there <@${message.user}>!`\n        },\n        \"accessory\": {\n          \"type\": \"button\",\n          \"text\": {\n            \"type\": \"plain_text\",\n            \"text\": \"Click Me\"\n          },\n          \"action_id\": \"button_click\"\n        }\n      }\n    ],\n    text: `Hey there <@${message.user}>!`\n  });\n});\n\n(async () => {\n  // Start your app\n  await app.start(process.env.PORT || 3000);\n\n  app.logger.info('‚ö°Ô∏è Bolt app is running!');\n})();\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Step Configuration in manifest.json\nDESCRIPTION: JSON configuration that defines a custom step's properties, input parameters, and output parameters in the app manifest. Specifies user input requirements and expected outputs for the workflow step.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/custom-steps-workflow-builder-new.md#2025-04-23_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"functions\": {\n        \"sample_step\": {\n            \"title\": \"Sample step\",\n            \"description\": \"Runs sample step\",\n            \"input_parameters\": {\n                \"user_id\": {\n                    \"type\": \"slack#/types/user_id\",\n                    \"title\": \"User\",\n                    \"description\": \"Message recipient\",\n                    \"is_required\": true,\n                    \"hint\": \"Select a user in the workspace\",\n                    \"name\": \"user_id\"\n                }\n            },\n            \"output_parameters\": {\n                \"user_id\": {\n                    \"type\": \"slack#/types/user_id\",\n                    \"title\": \"User\",\n                    \"description\": \"User that completed the step\",\n                    \"is_required\": true,\n                    \"name\": \"user_id\"\n                }\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting the Slack Bolt App using npm in Bash\nDESCRIPTION: This Bash command starts the Node.js application. It assumes that a `start` script is defined in the `package.json` file (typically `node app.js`). Running this command executes the application code, connects to Slack via Socket Mode, and makes the AI assistant available.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/code-assistant.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Workflow Step in Slack App Manifest\nDESCRIPTION: Sample manifest configuration defining a custom workflow step with input and output parameters, including user selection functionality.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/custom-steps.md#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"functions\": {\n    \"sample_step\": {\n        \"title\": \"Sample step\",\n        \"description\": \"Runs sample step\",\n        \"input_parameters\": {\n          \"properties\": {\n            \"user_id\": {\n                \"type\": \"slack#/types/user_id\",\n                \"title\": \"User\",\n                \"description\": \"Message recipient\",\n                \"hint\": \"Select a user in the workspace\",\n                \"name\": \"user_id\"\n            }\n          },\n          \"required\": {\n            \"user_id\"\n          }\n        },\n        \"output_parameters\": {\n          \"properties\": {\n            \"user_id\": {\n                \"type\": \"slack#/types/user_id\",\n                \"title\": \"User\",\n                \"description\": \"User that received the message\",\n                \"name\": \"user_id\"\n            }\n          },\n          \"required\": {\n            \"user_id\"\n          }\n        },\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing OAuth Installation Page HTML\nDESCRIPTION: Example of customizing the HTML rendering for the OAuth installation page with a custom Add to Slack button.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/authenticating-oauth.md#2025-04-23_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst app = new App({\n  signingSecret: process.env.SLACK_SIGNING_SECRET,\n  installerOptions: {\n    renderHtmlForInstallPath: (addToSlackUrl) => {\n      return `<a href=\"${addToSlackUrl}\">Add to Slack</a>`;\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Slack Bolt.js App\nDESCRIPTION: Command to install the required npm dependencies for the Slack Bolt.js application.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/oauth/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Migrating Message Actions to Shortcuts in Bolt.js v2\nDESCRIPTION: Example showing how to migrate from the action() method to the shortcut() method for handling message shortcuts (previously called message actions).\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/migration/migration-v2.md#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\napp.action({ callback_id: 'message-action-callback' }, ({action, ack, context}) => {\n  ack();\n  // Do stuff\n})\n```\n\nLANGUAGE: javascript\nCODE:\n```\napp.shortcut('message-action-callback', async ({shortcut, ack, context}) => {\n  await ack();\n  // Do stuff\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Direct Install Path\nDESCRIPTION: Example of configuring a custom installation path and enabling direct installation without the intermediate page.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/authenticating-oauth.md#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst app = new App({\n  signingSecret: process.env.SLACK_SIGNING_SECRET,\n  installerOptions: {\n    directInstall: true,\n    installPath: \"/slack/installations\",\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with NPM\nDESCRIPTION: Command to install the required Node.js dependencies for the Slack Bolt application.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/socket-mode/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Importing Types as a Named Export from Bolt-JS - TypeScript\nDESCRIPTION: This TypeScript snippet illustrates the new way to import Slack domain types from '@slack/bolt', following the change to a named export for types. By using 'type types', developers can reference strongly-typed domain objects such as BotMessageEvent, ensuring accurate type checking and alignment with Slack's latest API model. Prerequisite: bolt-js v4.x installed.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/migration/migration-v4.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { App, type types } from '@slack/bolt';\n\n// Now you can get references to e.g. `types.BotMessageEvent`\n```\n\n----------------------------------------\n\nTITLE: Authorization Function Implementation - Before Migration\nDESCRIPTION: Shows the previous v2.x implementation with separate authorize and orgAuthorize functions.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/migration/migration-v3.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst app = new App({ authorize: authorizeFn, orgAuthorize: orgAuthorizeFn, signingSecret: process.env.SLACK_SIGNING_SECRET });\n\nconst authorizeFn = async ({ teamId, enterpriseId}) => { \n  // Use teamId to fetch installation details from database\n}\n\nconst orgAuthorizeFn = async ({ teamId, enterpriseId }) => { \n  // Use enterpriseId to fetch installation details from database\n}\n```\n\n----------------------------------------\n\nTITLE: Starting the Slack Bolt.js App\nDESCRIPTION: Command to start the Slack application using npm.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/oauth/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Registering Event Listeners in Bolt\nDESCRIPTION: Shows different methods to listen for various Slack events including actions, commands, events, functions, messages, options, shortcuts, and views. Each method takes an identifier and a callback function.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/README.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// Listen for an action from a Block Kit element (buttons, select menus, date pickers, etc)\napp.action(actionId, fn);\n\n// Listen for dialog submissions\napp.action({ callback_id: callbackId }, fn);\n\n// Listen for slash commands\napp.command(commandName, fn);\n\n// Listen for an event from the Events API\napp.event(eventType, fn);\n\n// Listen for a custom step execution from a workflow\napp.function(callbackId, fn)\n\n// Convenience method to listen to only `message` events using a string or RegExp\napp.message([pattern ,] fn);\n\n// Listen for options requests (from select menus with an external data source)\napp.options(actionId, fn);\n\n// Listen for a global or message shortcuts\napp.shortcut(callbackId, fn);\n\n// Listen for view_submission modal events\napp.view(callbackId, fn);\n```\n\n----------------------------------------\n\nTITLE: Updating SocketModeFunctions Static Method Import - TypeScript\nDESCRIPTION: This code demonstrates the change in importing the SocketModeFunctions's static method in Bolt-JS v4.x. Previously, developers would import the class and access the method. Now, the static method is exposed directly, simplifying imports and usage. The second import line (from '@slack/bolt') is the recommended approach. Ensure bolt-js v4.x is installed.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/migration/migration-v4.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// before:\nimport { SocketModeFunctions } from '@slack/bolt';\n// you probably did something with:\nSocketModeFunctions.defaultProcessEventErrorHandler\n\n// now:\nimport { defaultProcessEventHandler } from '@slack/bolt';\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for Slack App\nDESCRIPTION: Configuration of required environment variables including bot token, app token, and OAuth credentials for the Slack application.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/socket-mode/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n// can get this from OAuth & Permission page in app configuration\nexport BOT_TOKEN=YOUR_SLACK_BOT_TOKEN\n// can generate the app level token from basic information page in app configuration\nexport APP_TOKEN=YOUR_SLACK_APP_TOKEN \n\n// if using OAuth, also export the following\nexport CLIENT_ID=YOUR_SLACK_CLIENT_ID\nexport CLIENT_SECRET=YOUR_SLACK_CLIENT_SECRET\nexport STATE_SECRET=YOUR_STATE_SECRET\n```\n\n----------------------------------------\n\nTITLE: Simple Database Implementation for Testing\nDESCRIPTION: Basic in-memory database implementation for testing OAuth state storage and verification.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/concepts/authenticating-oauth.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst database = {\n  store: {},\n  async get(key) {\n    return this.store[key];\n  },\n  async set(key, value) {\n    this.store[key] = value;\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Starting the Application\nDESCRIPTION: Command to start the Node.js application\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/oauth-express-receiver/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for Slack OAuth\nDESCRIPTION: Commands to set required environment variables including Slack client ID, client secret, signing secret, and state secret. These values can be found in the Slack app configuration.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/oauth-express-receiver/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport SLACK_CLIENT_ID=YOUR_SLACK_CLIENT_ID\nexport SLACK_CLIENT_SECRET=YOUR_SLACK_CLIENT_SECRET\nexport SLACK_SIGNING_SECRET=YOUR_SLACK_SIGNING_SECRET\nexport SLACK_STATE_SECRET=YOUR_SLACK_STATE_SECRET\n```\n\n----------------------------------------\n\nTITLE: Deploying to AWS Lambda\nDESCRIPTION: Command to deploy the Slack app to AWS Lambda using Serverless Framework\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/deploy-aws-lambda/README.md#2025-04-23_snippet_3\n\nLANGUAGE: zsh\nCODE:\n```\nserverless deploy\n```\n\n----------------------------------------\n\nTITLE: Starting ngrok Tunnel\nDESCRIPTION: Command to start ngrok tunnel on port 3000 for creating a public URL required for OAuth redirect.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/oauth/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nngrok http 3000\n```\n\n----------------------------------------\n\nTITLE: Setting Up Environment Variables in .env File\nDESCRIPTION: Sample environment variables configuration showing how to store Slack app and bot tokens. These tokens are required for authentication when the app connects to the Slack API.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/custom-steps-workflow-builder-new.md#2025-04-23_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nSLACK_APP_TOKEN=<your_app_token>\nSLACK_BOT_TOKEN=<your_bot_token>\n```\n\n----------------------------------------\n\nTITLE: Starting Local Development Server\nDESCRIPTION: Command to start Serverless offline for local development\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/deploy-aws-lambda/README.md#2025-04-23_snippet_4\n\nLANGUAGE: zsh\nCODE:\n```\nserverless offline --noPrependStageInUrl\n```\n\n----------------------------------------\n\nTITLE: Installing and Running the App - NPM Commands\nDESCRIPTION: Commands to install dependencies and start the application.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/ai-assistant.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm run\n```\n\n----------------------------------------\n\nTITLE: Handling Button Click (Socket Mode) - Reference\nDESCRIPTION: This block indicates where the action handling code for a Socket Mode Bolt app would be placed. It provides a reference link to the complete example application on GitHub, which includes the `app.action()` handler for the 'button_click' action ID.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/getting-started.mdx#2025-04-23_snippet_12\n\nLANGUAGE: js\nCODE:\n```\n```js reference\nhttps://github.com/slackapi/bolt-js-getting-started-app/blob/main/app.js\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Slack Bot Token Environment Variable\nDESCRIPTION: Command to set the Slack bot token as an environment variable for API access\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/getting-started.mdx#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nexport SLACK_BOT_TOKEN=xoxb-<your-bot-token>\n```\n\n----------------------------------------\n\nTITLE: Configuring AWS Profile with AWS CLI\nDESCRIPTION: Command for setting up an AWS profile using the CLI, which stores your access key pair on your local machine for accessing AWS services. This profile is used for deploying to Lambda.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/deployments/aws-lambda.md#2025-04-23_snippet_0\n\nLANGUAGE: zsh\nCODE:\n```\naws configure\n# AWS Access Key ID [None]: <your-aws-access-key>\n# AWS Secret Access Key [None]: <your-aws-secret>\n# Default region name [None]: us-east-1\n# Default output format [None]: json\n```\n\n----------------------------------------\n\nTITLE: Starting the Bolt JavaScript App\nDESCRIPTION: Command to start the Bolt JavaScript application using npm.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/message-metadata/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Running Serverless Offline for Local Testing\nDESCRIPTION: Command to start the Serverless Offline server, which emulates AWS Lambda locally for testing the Bolt.js app.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/deployments/aws-lambda.md#2025-04-23_snippet_10\n\nLANGUAGE: zsh\nCODE:\n```\nserverless offline --noPrependStageInUrl\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for Slack Tokens\nDESCRIPTION: Bash commands to set required environment variables for Slack bot token and app-level token authentication.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/message-metadata/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nexport SLACK_BOT_TOKEN=YOUR_SLACK_BOT_TOKEN\nexport SLACK_APP_TOKEN=YOUR_SLACK_APP_TOKEN\n```\n\n----------------------------------------\n\nTITLE: Cloning Project Repository - Bash Commands\nDESCRIPTION: Commands to clone the project repository and set up the development environment.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/ai-assistant.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/slack-samples/bolt-js-assistant-template.git\n```\n\nLANGUAGE: bash\nCODE:\n```\ncd bolt-js-assistant-template\n```\n\nLANGUAGE: bash\nCODE:\n```\ncode .\n```\n\n----------------------------------------\n\nTITLE: Installing Serverless Offline Plugin\nDESCRIPTION: NPM command to install the serverless-offline plugin as a development dependency, which enables local testing of Lambda functions.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/deployments/aws-lambda.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save-dev serverless-offline\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for Slack App\nDESCRIPTION: Required environment variables setup including Slack client credentials, signing secret, and state secret. These values can be found in the Slack app configuration panel.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/oauth/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport SLACK_CLIENT_ID=YOUR_SLACK_CLIENT_ID\nexport SLACK_CLIENT_SECRET=YOUR_SLACK_CLIENT_SECRET\nexport SLACK_SIGNING_SECRET=YOUR_SLACK_SIGNING_SECRET\nexport SLACK_STATE_SECRET=YOUR_SLACK_STATE_SECRET\n```\n\n----------------------------------------\n\nTITLE: Opening Project in VS Code\nDESCRIPTION: Command to open the project in Visual Studio Code editor.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/code-assistant.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncode .\n```\n\n----------------------------------------\n\nTITLE: Deploying Application to Heroku\nDESCRIPTION: Commands to deploy the application to Heroku and scale the web process to ensure the application is running.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/deploy-heroku/README.md#2025-04-23_snippet_3\n\nLANGUAGE: zsh\nCODE:\n```\n# Deploy to Heroku\ngit push heroku main\n\n# Start web server on Heroku\nheroku ps:scale web=1\n```\n\n----------------------------------------\n\nTITLE: Cloning the Bolt.js Getting Started Template\nDESCRIPTION: Git command to clone the Bolt.js starter template, which provides a foundation for building a Slack app with Bolt.js.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/deployments/aws-lambda.md#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/slackapi/bolt-js-getting-started-app.git\n```\n\n----------------------------------------\n\nTITLE: Navigating to Project Directory\nDESCRIPTION: Command to change into the project directory after cloning.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/code-assistant.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd bolt-js-starter-template\n```\n\n----------------------------------------\n\nTITLE: Configuring AWS CLI\nDESCRIPTION: Command to configure AWS credentials on local machine after installing AWS CLI\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/deploy-aws-lambda/README.md#2025-04-23_snippet_0\n\nLANGUAGE: zsh\nCODE:\n```\naws configure\n```\n\n----------------------------------------\n\nTITLE: Testing Serverless Framework Installation\nDESCRIPTION: Command to verify that the Serverless Framework CLI is installed correctly by displaying available commands.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/deployments/aws-lambda.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nserverless help\n```\n\n----------------------------------------\n\nTITLE: OAuth Redirect URL Format\nDESCRIPTION: Example format for the OAuth redirect URL that needs to be configured in the Slack app settings.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/oauth/README.md#2025-04-23_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\nhttps://3cb89939.ngrok.io/slack/oauth_redirect\n```\n\n----------------------------------------\n\nTITLE: Setting Function Runtime in Slack App Manifest\nDESCRIPTION: Configuration for adding the function runtime setting required for custom steps in existing apps.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/custom-steps.md#2025-04-23_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n\"settings\": {\n\t...\n\t\"function_runtime\": \"remote\"\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning Bolt.js Template App\nDESCRIPTION: Command to clone the starter Bolt.js application template from GitHub repository.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/deployments/heroku.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/slackapi/bolt-js-getting-started-app.git\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies\nDESCRIPTION: Command to install all required npm packages for the Bolt-js project. This needs to be run before starting the local development server for the first time.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/README.md#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Installing Slack Bolt Package\nDESCRIPTION: NPM command to install the @slack/bolt package as a project dependency\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/getting-started.mdx#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nnpm install @slack/bolt\n```\n\n----------------------------------------\n\nTITLE: Setting up Project Directory with NPM\nDESCRIPTION: Commands to create a new directory for the Bolt project and initialize it with npm\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/getting-started.mdx#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nmkdir first-bolt-app\ncd first-bolt-app\nnpm init\n```\n\n----------------------------------------\n\nTITLE: Building Static Documentation Site\nDESCRIPTION: Command to generate the static content for the Bolt-js documentation into the 'build' directory, preparing it for deployment.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/README.md#2025-04-23_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ npm run build\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with NPM\nDESCRIPTION: Command to install the required npm dependencies for the application\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/oauth-express-receiver/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Creating Heroku Application\nDESCRIPTION: Command to create a new Heroku application for the Slack bot deployment.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/deploy-heroku/README.md#2025-04-23_snippet_1\n\nLANGUAGE: zsh\nCODE:\n```\nheroku create\n```\n\n----------------------------------------\n\nTITLE: Ngrok Forwarding Output\nDESCRIPTION: Example output showing the ngrok forwarding address for HTTPS access.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/custom-receiver/README.md#2025-04-23_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\nForwarding   https://3cb89939.ngrok.io -> http://localhost:3000\n```\n\n----------------------------------------\n\nTITLE: Starting ngrok Tunnel\nDESCRIPTION: Command to start ngrok tunnel for local development and testing\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/deploy-aws-lambda/README.md#2025-04-23_snippet_5\n\nLANGUAGE: zsh\nCODE:\n```\nngrok http 3000 -subdomain=my-unique-name\n```\n\n----------------------------------------\n\nTITLE: Installing NVM for Node Version Management\nDESCRIPTION: This command installs NVM (Node Version Manager) which allows easy management of Node.js versions. NVM is recommended for running the Bolt-js project locally.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash\n```\n\n----------------------------------------\n\nTITLE: Displaying Bolt-js Project Directory Structure\nDESCRIPTION: This snippet shows the directory structure of the Bolt-js project, including documentation content organization, translations, static assets, and configuration files.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/README.md#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\ndocs/\n‚îú‚îÄ‚îÄ content/ (the good stuff. md and mdx files supported)\n‚îÇ   ‚îú‚îÄ‚îÄ getting-started.md\n‚îÇ   ‚îî‚îÄ‚îÄ concepts\n‚îÇ       ‚îî‚îÄ‚îÄ sending-message.md\n‚îú‚îÄ‚îÄ i18n/ja-jp/ (the japanese translations)\n‚îÇ   ‚îú‚îÄ‚îÄ docusaurus-theme-classic/ (footer/navbar translations)\n‚îÇ   ‚îî‚îÄ‚îÄ docusaurus-plugin-content-docs/\n‚îÇ       ‚îî‚îÄ‚îÄ current/ (this folder's file names need to match **/content/)\n‚îÇ           ‚îú‚îÄ‚îÄ getting-started.md\n‚îÇ           ‚îî‚îÄ‚îÄ concepts\n‚îÇ               ‚îî‚îÄ‚îÄ sending-message.md\n‚îú‚îÄ‚îÄ static/\n‚îÇ   ‚îú‚îÄ‚îÄ css/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ custom.css (the css for everything!)\n‚îÇ   ‚îî‚îÄ‚îÄ img/ (the pictures for the site)\n‚îÇ       ‚îú‚îÄ‚îÄ rory.png \n‚îÇ       ‚îî‚îÄ‚îÄ oslo.svg \n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ pages/ (stuff that isn't docs content. This is empty for this repo!)\n‚îÇ   ‚îî‚îÄ‚îÄ theme (only contains the 404 page)\n‚îú‚îÄ‚îÄ docusaurus.config.js (main config file)\n‚îú‚îÄ‚îÄ footerConfig.js (footer. go to main repo to change)\n‚îú‚îÄ‚îÄ navbarConfig.js (navbar. go to main repo to change)\n‚îî‚îÄ‚îÄ sidebar.js (manually set where the content docs are in the sidebar.)\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with npm for Bolt.js\nDESCRIPTION: Command to install the required dependencies after updating the package.json file to Bolt version 1.20.0 or higher, which is necessary for custom workflow steps.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/custom-steps-workflow-builder-existing.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Creating Project Directory\nDESCRIPTION: Command to create and navigate to the project directory for the code assistant app.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/code-assistant.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmkdir code-assistant\ncd code-assistant\n```\n\n----------------------------------------\n\nTITLE: Docusaurus Theme Translation Configuration\nDESCRIPTION: Example of Japanese translation configuration for site components in JSON format.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/i18n/ja-jp/README.md#2025-04-23_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"item.label.Hello\": {\n    \"message\": \"„Åì„Çì„Å´„Å°„ÅØ\",\n    \"description\": \"The title of the page\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies\nDESCRIPTION: Command to install required npm packages including Axios, Hugging Face Inference, and isomorphic-fetch.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/code-assistant.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm install axios @huggingface/inference isomorphic-fetch\n```\n\n----------------------------------------\n\nTITLE: Thread Context Store Template - JavaScript\nDESCRIPTION: Template for implementing custom thread context storage functionality.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/ai-assistant.md#2025-04-23_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nthreadContextStore: {\n  get: async ({ context, client, payload }) => {},\n  save: async ({ context, client, payload }) => {},\n},\n```\n\n----------------------------------------\n\nTITLE: Starting Docusaurus in Japanese Locale\nDESCRIPTION: Command to run the documentation site in Japanese locale for testing purposes.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/i18n/ja-jp/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run start -- --locale ja-jp\n```\n\n----------------------------------------\n\nTITLE: Setting Slack Signing Secret Environment Variable\nDESCRIPTION: Command to set the Slack signing secret as an environment variable for authentication\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/getting-started.mdx#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nexport SLACK_SIGNING_SECRET=<your-signing-secret>\n```\n\n----------------------------------------\n\nTITLE: OAuth Redirect URL Format\nDESCRIPTION: Example format for the OAuth redirect URL to be configured in Slack app settings.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/custom-receiver/README.md#2025-04-23_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\nhttps://3cb89939.ngrok.io/slack/oauth_redirect\n```\n\n----------------------------------------\n\nTITLE: Starting Ngrok Tunnel for OAuth\nDESCRIPTION: Command to start an Ngrok tunnel for OAuth implementation, exposing local server to external network.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/socket-mode/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nngrok http 3000\n```\n\n----------------------------------------\n\nTITLE: Starting Ngrok Tunnel\nDESCRIPTION: Command to start ngrok tunnel for external access on port 3000.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/custom-receiver/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nngrok http 3000\n```\n\n----------------------------------------\n\nTITLE: Cloning the Bolt JS Custom Step Template Repository\nDESCRIPTION: Git command to clone the starter template repository for creating a custom workflow step. The template provides the base code needed to implement a custom step in Workflow Builder.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/tutorials/custom-steps-workflow-builder-new.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngit clone https://github.com/slack-samples/bolt-js-custom-step-template.git boltstep\n```\n\n----------------------------------------\n\nTITLE: Starting ngrok Tunnel\nDESCRIPTION: Command to start ngrok tunnel for exposing local server to the internet on port 3000\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/oauth-express-receiver/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nngrok http 3000\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Bolt JS App\nDESCRIPTION: Command to install the required npm dependencies for the Bolt JavaScript application.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/message-metadata/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Example ngrok Forwarding Output\nDESCRIPTION: Sample output showing the forwarding address provided by ngrok\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/oauth-express-receiver/README.md#2025-04-23_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\nForwarding   https://3cb89939.ngrok.io -> http://localhost:3000\n```\n\n----------------------------------------\n\nTITLE: Navigating to the App Directory\nDESCRIPTION: Command to change directory to the cloned Bolt.js app directory for further modification.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/deployments/aws-lambda.md#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncd bolt-js-getting-started-app/\n```\n\n----------------------------------------\n\nTITLE: Running Local Server with Japanese Localization\nDESCRIPTION: Command to start the local development server specifically for the Japanese version of the documentation. Docusaurus treats each language as a different instance of the website.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/README.md#2025-04-23_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nnpm run start -- --locale ja-jp\n```\n\n----------------------------------------\n\nTITLE: Starting Local Development Server\nDESCRIPTION: Commands to start the local development server and open a browser to view the Bolt-js documentation. Changes to pages are reflected live without server restart.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/README.md#2025-04-23_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nnpm run start\nopen http://localhost:3000/bolt-python/getting-started # visit a page\n```\n\n----------------------------------------\n\nTITLE: Example ngrok Forwarding URL\nDESCRIPTION: Example output showing the HTTPS forwarding address provided by ngrok.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/oauth/README.md#2025-04-23_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\nForwarding   https://3cb89939.ngrok.io -> http://localhost:3000\n```\n\n----------------------------------------\n\nTITLE: Serving Built Documentation Locally\nDESCRIPTION: Command to serve the built static documentation site locally for testing before creating a pull request for deployment.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/README.md#2025-04-23_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nnpm run serve\n```\n\n----------------------------------------\n\nTITLE: Email Contact Code in Markdown\nDESCRIPTION: Markdown code for displaying the support email contact information using mailto link.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/content/index.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[Email](mailto:support@slack.com)\n```\n\n----------------------------------------\n\nTITLE: Docusaurus Code Block Translation\nDESCRIPTION: Example of translating code block UI elements to Japanese in the code.json file.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/i18n/ja-jp/README.md#2025-04-23_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n  \"theme.CodeBlock.copy\": {\n    \"message\": \"„Ç≥„Éî„Éº\",\n    \"description\": \"The copy button label on code blocks\"\n  }\n```\n\n----------------------------------------\n\nTITLE: Adding Custom HTTP Routes Using customRoutes Property in JavaScript\nDESCRIPTION: This code demonstrates how to add custom HTTP routes when initializing a Bolt app using the customRoutes array property. It includes examples of a simple health check endpoint and a route with dynamic parameters. The code also shows how to specify a custom port using installerOptions.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/i18n/ja-jp/docusaurus-plugin-content-docs/current/concepts/custom-routes.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst { App } = require('@slack/bolt');\n\n// „Éá„Éï„Ç©„É´„Éà„ÅÆ HTTPReceiver „Çí‰Ωø„Å£„Å¶ Bolt „Ç¢„Éó„É™„ÇíÂàùÊúüÂåñ„Åó„Åæ„Åô\nconst app = new App({\n  token: process.env.SLACK_BOT_TOKEN,\n  signingSecret: process.env.SLACK_SIGNING_SECRET,\n  customRoutes: [\n    {\n      path: '/health-check',\n      method: ['GET'],\n      handler: (req, res) => {\n        res.writeHead(200);\n        res.end(`Things are going just fine at ${req.headers.host}!`);\n      },\n    },\n    {\n      path: '/music/:genre',\n      method: ['GET'],\n      handler: (req, res) => {\n        res.writeHead(200);\n        res.end(`Oh? ${req.params.genre}? That slaps!`);\n      },\n    },\n  ],\n  installerOptions: {\n    port: 3001,\n  },\n});\n\n(async () => {\n  await app.start();\n  app.logger.info('‚ö°Ô∏è Bolt app started');\n})();\n```\n\n----------------------------------------\n\nTITLE: Initializing Git Repository for Heroku Deployment\nDESCRIPTION: Commands to initialize a Git repository, make the initial commit, and optionally rename the master branch to main for Heroku deployment.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/examples/deploy-heroku/README.md#2025-04-23_snippet_0\n\nLANGUAGE: zsh\nCODE:\n```\n# Initialize Git repository\ngit init\n\n# Commit this project\ngit add .\ngit commit -am \"Initial commit\"\n\n# Rename master to main (optional)\ngit branch -m main\n```\n\n----------------------------------------\n\nTITLE: Installing Latest Node Version with NVM\nDESCRIPTION: Command to install the latest version of Node.js using NVM. At least Node 20 is required for running the Bolt-js project.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/README.md#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnvm install node\n```\n\n----------------------------------------\n\nTITLE: Japanese Page Title Configuration\nDESCRIPTION: Example showing how to set up a Japanese title in a documentation page's frontmatter.\nSOURCE: https://github.com/slackapi/bolt-js/blob/main/docs/i18n/ja-jp/README.md#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n---\ntitle: „Åì„Çì„Å´„Å°„ÅØ\n---\n\n# „Åì„Çì„Å´„Å°„ÅØ\n\n```"
  }
]