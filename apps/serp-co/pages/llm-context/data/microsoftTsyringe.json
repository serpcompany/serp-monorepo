[
  {
    "owner": "microsoft",
    "repo": "tsyringe",
    "content": "TITLE: Using Injectable Decorator\nDESCRIPTION: Example demonstrating how to use the @injectable decorator for constructor injection.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport {injectable} from \"tsyringe\";\n\n@injectable()\nclass Foo {\n  constructor(private database: Database) {}\n}\n\n// some other file\nimport \"reflect-metadata\";\nimport {container} from \"tsyringe\";\nimport {Foo} from \"./foo\";\n\nconst instance = container.resolve(Foo);\n```\n\n----------------------------------------\n\nTITLE: Using Singleton Decorator\nDESCRIPTION: Example showing how to create a singleton class using the @singleton decorator.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {singleton} from \"tsyringe\";\n\n@singleton()\nclass Foo {\n  constructor() {}\n}\n\n// some other file\nimport \"reflect-metadata\";\nimport {container} from \"tsyringe\";\nimport {Foo} from \"./foo\";\n\nconst instance = container.resolve(Foo);\n```\n\n----------------------------------------\n\nTITLE: Basic Class Injection Example in TypeScript\nDESCRIPTION: A simple example demonstrating class injection without interfaces. Classes have runtime type information, allowing TSyringe to resolve dependencies automatically with the @injectable decorator.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\n// Foo.ts\nexport class Foo {}\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// Bar.ts\nimport {Foo} from \"./Foo\";\nimport {injectable} from \"tsyringe\";\n\n@injectable()\nexport class Bar {\n  constructor(public myFoo: Foo) {}\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// main.ts\nimport \"reflect-metadata\";\nimport {container} from \"tsyringe\";\nimport {Bar} from \"./Bar\";\n\nconst myBar = container.resolve(Bar);\n// myBar.myFoo => An instance of Foo\n```\n\n----------------------------------------\n\nTITLE: Using Inject Decorator with Interfaces\nDESCRIPTION: Example of using @inject decorator for injecting interfaces and non-class dependencies.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport {injectable, inject} from \"tsyringe\";\n\ninterface Database {\n  // ...\n}\n\n@injectable()\nclass Foo {\n  constructor(@inject(\"Database\") private database?: Database) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Using AutoInjectable Decorator\nDESCRIPTION: Example of using @autoInjectable decorator for automatic dependency resolution with optional parameters.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport {autoInjectable} from \"tsyringe\";\n\n@autoInjectable()\nclass Foo {\n  constructor(private database?: Database) {}\n}\n\n// some other file\nimport {Foo} from \"./foo\";\n\nconst instance = new Foo();\n```\n\n----------------------------------------\n\nTITLE: Resolving Dependencies in TSyringe\nDESCRIPTION: This snippet demonstrates how to resolve dependencies using the container.resolve() method in TSyringe. It shows examples of resolving both class and string tokens.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myFoo = container.resolve(Foo);\nconst myBar = container.resolve<Bar>(\"Bar\");\n```\n\n----------------------------------------\n\nTITLE: Registering Dependencies in TSyringe\nDESCRIPTION: This snippet demonstrates how to register dependencies using the DependencyContainer.register() method in TSyringe. It shows examples of registering classes, values, and tokens.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\ncontainer.register<Foo>(Foo, {useClass: Foo});\ncontainer.register<Bar>(Bar, {useValue: new Bar()});\ncontainer.register<Baz>(\"MyBaz\", {useValue: new Baz()});\n```\n\n----------------------------------------\n\nTITLE: Interface Injection Example in TypeScript\nDESCRIPTION: Demonstrates how to use TSyringe with interfaces. Since interfaces don't have runtime type information, they must be registered with the container using string tokens and the @inject decorator.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\n// SuperService.ts\nexport interface SuperService {\n  // ...\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// TestService.ts\nimport {SuperService} from \"./SuperService\";\nexport class TestService implements SuperService {\n  //...\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// Client.ts\nimport {injectable, inject} from \"tsyringe\";\n\n@injectable()\nexport class Client {\n  constructor(@inject(\"SuperService\") private service: SuperService) {}\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// main.ts\nimport \"reflect-metadata\";\nimport {Client} from \"./Client\";\nimport {TestService} from \"./TestService\";\nimport {container} from \"tsyringe\";\n\ncontainer.register(\"SuperService\", {\n  useClass: TestService\n});\n\nconst client = container.resolve(Client);\n// client's dependencies will have been resolved\n```\n\n----------------------------------------\n\nTITLE: Using @injectable Decorator with Tokens in TSyringe\nDESCRIPTION: This snippet demonstrates how to use the @injectable decorator with tokens in TSyringe. It shows how to register a class with one or more tokens directly in the decorator.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface Bar {}\n\n@injectable({token: \"Bar\"})\nclass Foo implements Bar {}\n@injectable({token: [\"Bar\", \"Bar2\"]})\nclass Baz implements Bar {}\n\nclass MyRegistry {}\n\nconst myBars = container.resolveAll<Bar>(\"Bar\"); // myBars type is Bar[], contains 2 instances\nconst myBars2 = container.resolveAll<Bar>(\"Bar2\"); // myBars2 type is Bar[], contains 1 instance\n```\n\n----------------------------------------\n\nTITLE: Using @registry Decorator in TSyringe\nDESCRIPTION: This snippet shows how to use the @registry decorator in TSyringe to register providers upon importing the marked-up class. It's useful for registering multiple classes for the same token or registering 3rd party instances.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\n@registry([\n  { token: Foobar, useClass: Foobar },\n  { token: \"theirClass\", useFactory: (c) => {\n       return new TheirClass( \"arg\" )\n    },\n  }\n])\nclass MyClass {}\n```\n\n----------------------------------------\n\nTITLE: Resolving Multiple Instances in TSyringe\nDESCRIPTION: This snippet shows how to resolve all instances registered against a given token using the container.resolveAll() method in TSyringe. It demonstrates registering multiple implementations of an interface.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface Bar {}\n\n@injectable()\nclass Foo implements Bar {}\n@injectable()\nclass Baz implements Bar {}\n\n@registry([\n  // registry is optional, all you need is to use the same token when registering\n  {token: \"Bar\", useToken: Foo}, // can be any provider\n  {token: \"Bar\", useToken: Baz}\n])\nclass MyRegistry {}\n\nconst myBars = container.resolveAll<Bar>(\"Bar\"); // myBars type is Bar[]\n```\n\n----------------------------------------\n\nTITLE: Defining Factory Provider in TSyringe\nDESCRIPTION: This snippet shows how to define a factory provider in TSyringe. It's used to resolve a token using a given factory function, which has access to the dependency container.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  token: InjectionToken<T>;\n  useFactory: FactoryFunction<T>;\n}\n```\n\n----------------------------------------\n\nTITLE: Using instanceCachingFactory in TSyringe\nDESCRIPTION: This snippet demonstrates how to use the instanceCachingFactory in TSyringe. It lazily constructs an object, caches the result, and returns the single instance for subsequent resolutions, similar to @singleton().\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {instanceCachingFactory} from \"tsyringe\";\n\n{\n  token: \"SingletonFoo\";\n  useFactory: instanceCachingFactory<Foo>(c => c.resolve(Foo));\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Value Provider in TSyringe\nDESCRIPTION: This snippet demonstrates how to define a value provider in TSyringe. It's used to resolve a token to a given value, useful for registering constants or pre-instantiated objects.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  token: InjectionToken<T>;\n  useValue: T\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Token Provider in TSyringe\nDESCRIPTION: This snippet shows how to define a token provider in TSyringe. It acts as a redirect or alias, stating that given token x, resolve using token y.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  token: InjectionToken<T>;\n  useToken: InjectionToken<T>;\n}\n```\n\n----------------------------------------\n\nTITLE: Using instancePerContainerCachingFactory in TSyringe\nDESCRIPTION: This snippet shows how to use the instancePerContainerCachingFactory in TSyringe. It lazily constructs an object and caches the result per DependencyContainer, similar to @scoped(Lifecycle.ContainerScoped).\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {instancePerContainerCachingFactory} from \"tsyringe\";\n\n{\n  token: \"ContainerScopedFoo\";\n  useFactory: instancePerContainerCachingFactory<Foo>(c => c.resolve(Foo));\n}\n```\n\n----------------------------------------\n\nTITLE: Using predicateAwareClassFactory in TSyringe\nDESCRIPTION: This snippet demonstrates the use of predicateAwareClassFactory in TSyringe. It provides conditional behavior upon resolution, caching the result by default with an option to resolve fresh each time.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {predicateAwareClassFactory} from \"tsyringe\";\n\n{\n  token: \"FooHttp\",\n  useFactory: predicateAwareClassFactory<Foo>(\n    c => c.resolve(Bar).useHttps, // Predicate for evaluation\n    FooHttps, // A FooHttps will be resolved from the container if predicate is true\n    FooHttp // A FooHttp will be resolved if predicate is false\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting Primitive Values with Named Injection in TypeScript\nDESCRIPTION: Shows how to inject primitive values using named injection in TSyringe. This technique uses string tokens with the @inject decorator to register and inject values like strings or numbers.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nimport {singleton, inject} from \"tsyringe\";\n\n@singleton()\nclass Foo {\n  private str: string;\n  constructor(@inject(\"SpecialString\") value: string) {\n    this.str = value;\n  }\n}\n\n// some other file\nimport \"reflect-metadata\";\nimport {container} from \"tsyringe\";\nimport {Foo} from \"./foo\";\n\nconst str = \"test\";\ncontainer.register(\"SpecialString\", {useValue: str});\n\nconst instance = container.resolve(Foo);\n```\n\n----------------------------------------\n\nTITLE: Checking Registration in TSyringe\nDESCRIPTION: This snippet shows how to check if a token is registered in the container using the isRegistered() method in TSyringe. It also demonstrates how to check registration in parent containers.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst isRegistered = container.isRegistered(\"Bar\"); // true\n\nclass Bar {}\n\ncontainer.register(Bar, {useClass: Bar});\n\nconst childContainer = container.createChildContainer();\nchildContainer.isRegistered(Bar); // false\nchildContainer.isRegistered(Bar, true); // true\n```\n\n----------------------------------------\n\nTITLE: Creating Child Containers in TSyringe\nDESCRIPTION: This snippet shows how to create child containers in TSyringe. Child containers have independent registrations but can fall back to parent containers for resolution.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_21\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst childContainer1 = container.createChildContainer();\nconst childContainer2 = container.createChildContainer();\nconst grandChildContainer = childContainer1.createChildContainer();\n```\n\n----------------------------------------\n\nTITLE: Handling Circular Dependencies in TSyringe\nDESCRIPTION: This snippet demonstrates a circular dependency problem in TSyringe. It shows an example of two classes with cyclic dependencies that will result in an error when trying to resolve one of the services.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_23\n\nLANGUAGE: TypeScript\nCODE:\n```\n@injectable()\nexport class Foo {\n  constructor(public bar: Bar) {}\n}\n\n@injectable()\nexport class Bar {\n  constructor(public foo: Foo) {}\n}\n\ncontainer.resolve(Foo);\n```\n\n----------------------------------------\n\nTITLE: Using the delay Helper Function for Circular Dependencies in TypeScript\nDESCRIPTION: Demonstrates how to use the delay function to resolve circular dependencies between classes. It creates proxy objects that defer construction until first use, allowing mutually dependent classes to reference each other.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\n@injectable()\nexport class Foo {\n  constructor(@inject(delay(() => Bar)) public bar: Bar) {}\n}\n\n@injectable()\nexport class Bar {\n  constructor(@inject(delay(() => Foo)) public foo: Foo) {}\n}\n\n// construction of foo is possible\nconst foo = container.resolve(Foo);\n\n// property bar will hold a proxy that looks and acts as a real Bar instance.\nfoo.bar instanceof Bar; // true\n```\n\n----------------------------------------\n\nTITLE: Resolving Circular Dependencies with Interfaces in TypeScript\nDESCRIPTION: Shows how to handle circular dependencies with interfaces by using the delay function in combination with registry decorators. This technique allows interface implementations to reference each other without creating dependency cycles.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface IFoo {}\n\n@injectable()\n@registry([\n  {\n    token: \"IBar\",\n    // `DelayedConstructor` of Bar will be the token\n    useToken: delay(() => Bar)\n  }\n])\nexport class Foo implements IFoo {\n  constructor(@inject(\"IBar\") public bar: IBar) {}\n}\nexport interface IBar {}\n\n@injectable()\n@registry([\n  {\n    token: \"IFoo\",\n    useToken: delay(() => Foo)\n  }\n])\nexport class Bar implements IBar {\n  constructor(@inject(\"IFoo\") public foo: IFoo) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Using Interception in TSyringe\nDESCRIPTION: This snippet demonstrates how to use interception in TSyringe. It shows examples of using beforeResolution and afterResolution to execute callbacks before or after token resolution.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\nclass Bar {}\n\ncontainer.beforeResolution(\n  Bar,\n  // Callback signature is (token: InjectionToken<T>, resolutionType: ResolutionType) => void\n  () => {\n    console.log(\"Bar is about to be resolved!\");\n  },\n  {frequency: \"Always\"}\n);\n\nclass Bar {\n  public init(): void {\n    // ...\n  }\n}\n\ncontainer.afterResolution(\n  Bar,\n  // Callback signature is (token: InjectionToken<T>, result: T | T[], resolutionType: ResolutionType)\n  (_t, result) => {\n    result.init();\n  },\n  {frequency: \"Once\"}\n);\n```\n\n----------------------------------------\n\nTITLE: Disposing Container Instances in TSyringe\nDESCRIPTION: Shows how to properly dispose of instances created by the TSyringe container. Instances implementing the Disposable interface will be automatically disposed when the container is disposed, with support for both synchronous and asynchronous disposal.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\ncontainer.dispose();\n```\n\nLANGUAGE: typescript\nCODE:\n```\nawait container.dispose();\n```\n\n----------------------------------------\n\nTITLE: Clearing Instances in TSyringe\nDESCRIPTION: This snippet demonstrates how to clear all previously created and registered instances using the container.clearInstances() method in TSyringe. It's useful for resetting the container state, especially in testing scenarios.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_22\n\nLANGUAGE: TypeScript\nCODE:\n```\nclass Foo {}\n@singleton()\nclass Bar {}\n\nconst myFoo = new Foo();\ncontainer.registerInstance(\"Test\", myFoo);\nconst myBar = container.resolve(Bar);\n\ncontainer.clearInstances();\n\ncontainer.resolve(\"Test\"); // throws error\nconst myBar2 = container.resolve(Bar); // myBar !== myBar2\nconst myBar3 = container.resolve(Bar); // myBar2 === myBar3\n\n@singleton()\nclass Foo {}\n\nbeforeEach(() => {\n  container.clearInstances();\n});\n\ntest(\"something\", () => {\n  container.resolve(Foo); // will be a new singleton instance in every test\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript for TSyringe\nDESCRIPTION: Required TypeScript configuration settings in tsconfig.json to enable decorators and metadata emission.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Reflect Metadata\nDESCRIPTION: Example of importing the required Reflect API polyfill before using dependency injection.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// main.ts\nimport \"reflect-metadata\";\n\n// Your code here...\n```\n\n----------------------------------------\n\nTITLE: Defining FactoryFunction Type in TSyringe\nDESCRIPTION: This snippet defines the FactoryFunction type used in factory providers. It represents a function that takes a DependencyContainer and returns an instance of type T.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype FactoryFunction<T> = (dependencyContainer: DependencyContainer) => T;\n```\n\n----------------------------------------\n\nTITLE: Installing TSyringe with Package Managers\nDESCRIPTION: Commands for installing TSyringe using npm or yarn package managers.\nSOURCE: https://github.com/microsoft/tsyringe/blob/master/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install --save tsyringe\n\nyarn add tsyringe\n```"
  }
]