[
  {
    "owner": "elysiajs",
    "repo": "documentation",
    "content": "TITLE: Creating a Basic Handler in ElysiaJS\nDESCRIPTION: Demonstrates how to create a simple GET route handler in ElysiaJS that returns a 'hello world' response.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    // the function `() => 'hello world'` is a handler\n    .get('/', () => 'hello world')\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Routes in ElysiaJS\nDESCRIPTION: This snippet demonstrates how to define basic routes in ElysiaJS using HTTP verb methods. It shows how to create GET routes for the root path and '/hi' path.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/route.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/', 'hello')\n    .get('/hi', 'hi')\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Basic Hello World Server in Elysia\nDESCRIPTION: Creates a simple HTTP server that responds with 'Hello World' on the root path\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/cheat-sheet.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/', () => 'Hello World')\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Creating Public and Protected Post Routes Using Elysia (TypeScript)\nDESCRIPTION: This code snippet defines both public (read) and protected (write) endpoints for a 'post' resource in an Elysia server. The public GET endpoint retrieves a post by its ID without requiring authentication, providing a success status and data. The protected PUT endpoint (after .use(authen)) allows authenticated users to create posts, validating the input and associating ownership via userId. Required dependencies: Elysia, t (type-safety and validation), Supabase, and the authen plugin. Inputs: GET - post ID via params; PUT - body with 'detail' property. Outputs: GET - {success, data}; PUT - new post ID or throws error on failure. Demonstrates selective scoping of middleware.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-supabase.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nimport { authen, supabase } from '../../libs'\n\nexport const post = (app: Elysia) =>\n    app.group('/post', (app) =>\n        app\n            .get('/:id', async ({ params: { id } }) => { // [!code ++]\n                const { data, error } = await supabase // [!code ++]\n                    .from('post') // [!code ++]\n                    .select() // [!code ++]\n                    .eq('id', id) // [!code ++]\n // [!code ++]\n                if (error) return error // [!code ++]\n // [!code ++]\n                return { // [!code ++]\n                    success: !!data[0], // [!code ++]\n                    data: data[0] ?? null // [!code ++]\n                } // [!code ++]\n            }) // [!code ++]\n            .use(authen)\n            .put(\n                '/create',\n                async ({ body, userId }) => {\n                    const { data, error } = await supabase\n                        .from('post')\n                        .insert({\n                            // Add user_id somehow\n                            // user_id: userId,\n                            ...body\n                        })\n                        .select('id')\n\n                    if (error) throw error\n\n                    return data[0]\n                },\n                {\n                    schema: {\n                        body: t.Object({\n                            detail: t.String()\n                        })\n                    }\n                }\n            )\n    )\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic String Validation in ElysiaJS\nDESCRIPTION: Demonstrates how to create a basic POST endpoint that validates the request body as a string. If validation passes, the handler responds with a greeting that includes the body content.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/type.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n\t.post('/', ({ body }) => `Hello ${body}`, {\n\t\tbody: t.String()\n\t})\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Registering Standard GET and POST Endpoints in Elysia (TypeScript)\nDESCRIPTION: This snippet shows how to register multiple HTTP verb routes, such as GET and POST, in Elysia. It registers a GET endpoint at '/' that returns 'hello' and a POST at '/hi' returning 'hi', then starts the server. Requires Elysia imported with TypeScript enabled. Key parameters: path, response function, and optional hooks. Outputs plain string responses for GET and POST methods.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/route.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/', 'hello')\n    .post('/hi', 'hi')\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Adding Swagger Documentation with Elysia Plugin\nDESCRIPTION: Demonstrates how to integrate OpenAPI documentation using the Swagger plugin with minimal configuration.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/at-glance.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { swagger } from '@elysiajs/swagger'\n\nnew Elysia()\n    .use(swagger())\n    .get('/user/:id', ({ params: { id } }) => id, {\n        params: t.Object({\n            id: t.Number()\n        })\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Applying Authorization Plugin to Scoped Route Groups in Elysia (TypeScript)\nDESCRIPTION: This snippet showcases how to use the previously defined authen plugin to protect a group of Elysia routes in TypeScript. Within the '/post' route group, it uses .put to define an authenticated post creation endpoint, relying on userId injected by the plugin. The handler validates the input body, ensures proper authorization using supabase, and inserts a new post associated with the user. Dependencies: authen plugin, Elysia, Supabase client, t for schema validation. Inputs: body with a 'detail' string. Outputs: Returns the created post's ID. The scope pattern ensures all subsequent routes are protected.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-supabase.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nimport { authen, supabase } from '../../libs' // [!code ++]\n\nexport const post = (app: Elysia) =>\n    app.group('/post', (app) =>\n        app\n            .use(authen) // [!code ++]\n            .put(\n                '/create',\n                async ({ body, userId }) => { // [!code ++]\n                    let userId: string // [!code --]\n    // [!code --]\n                    const { data, error } = await supabase.auth.getUser( // [!code --]\n                        access_token // [!code --]\n                    ) // [!code --]\n    // [!code --]\n                    if(error) { // [!code --]\n                        const { data, error } = await supabase.auth.refreshSession({ // [!code --]\n                            refresh_token // [!code --]\n                        }) // [!code --]\n    // [!code --]\n                        if (error) throw error // [!code --]\n    // [!code --]\n                        userId = data.user!.id // [!code --]\n                    } // [!code --]\n\n                    const { data, error } = await supabase\n                        .from('post')\n                        .insert({\n                            user_id: userId, // [!code ++]\n                            ...body\n                        })\n                        .select('id')\n\n                    if (error) throw error\n\n                    return data[0]\n                },\n                {\n                    schema: {\n                        body: t.Object({\n                            detail: t.String()\n                        })\n                    }\n                }\n            )\n    )\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Context in ElysiaJS Handlers\nDESCRIPTION: Illustrates how to access the context object in an ElysiaJS route handler, which contains request-specific information.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.get('/', (context) => context.path)\n            // ^ This is a context\n```\n\n----------------------------------------\n\nTITLE: Implementing Note Management API with Elysia (TypeScript)\nDESCRIPTION: This snippet shows the implementation of a Note management API using Elysia. It includes CRUD operations for notes, with authentication and error handling.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { getUserId, userService } from './user'\n\nconst memo = t.Object({\n    data: t.String(),\n    author: t.String()\n})\n\ntype Memo = typeof memo.static\n\nclass Note {\n    constructor(\n        public data: Memo[] = [\n            {\n                data: 'Moonhalo',\n                author: 'saltyaom'\n            }\n        ]\n    ) {}\n\n    add(note: Memo) {\n        this.data.push(note)\n\n        return this.data\n    }\n\n    remove(index: number) {\n        return this.data.splice(index, 1)\n    }\n\n    update(index: number, note: Partial<Memo>) {\n        return (this.data[index] = { ...this.data[index], ...note })\n    }\n}\n\nexport const note = new Elysia({ prefix: '/note' })\n    .use(userService)\n    .decorate('note', new Note())\n    .model({\n        memo: t.Omit(memo, ['author'])\n    })\n    .onTransform(function log({ body, params, path, request: { method } }) {\n        console.log(`${method} ${path}`, {\n            body,\n            params\n        })\n    })\n    .get('/', ({ note }) => note.data)\n    .use(getUserId)\n    .put(\n        '/',\n        ({ note, body: { data }, username }) =>\n            note.add({ data, author: username }),\n        {\n            body: 'memo'\n        }\n    )\n    .get(\n        '/:index',\n        ({ note, params: { index }, error }) => {\n            return note.data[index] ?? error(404, 'Not Found :(')\n        },\n        {\n            params: t.Object({\n                index: t.Number()\n            })\n        }\n    )\n    .guard({\n        params: t.Object({\n            index: t.Number()\n        })\n    })\n    .delete('/:index', ({ note, params: { index }, error }) => {\n        if (index in note.data) return note.remove(index)\n\n        return error(422)\n    })\n    .patch(\n        '/:index',\n        ({ note, params: { index }, body: { data }, error, username }) => {\n            if (index in note.data)\n                return note.update(index, { data, author: username })\n\n            return error(422)\n        },\n        {\n            isSignIn: true,\n            body: 'memo'\n        }\n    )\n```\n\n----------------------------------------\n\nTITLE: Basic ElysiaJS Server Setup\nDESCRIPTION: Minimal TypeScript code to create an Elysia server with a single GET route.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/quick-start.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst app = new Elysia()\n\t.get('/', () => 'Hello Elysia')\n\t.listen(3000)\n\nconsole.log(\n\t`ðŸ¦Š Elysia is running at ${app.server?.hostname}:${app.server?.port}`\n)\n```\n\n----------------------------------------\n\nTITLE: Basic Mounting Example with ElysiaJS\nDESCRIPTION: Demonstrates basic usage of the .mount method to integrate a Hono fetch handler with an Elysia application.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/mount.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst app = new Elysia()\n    .get('/', () => 'Hello from Elysia')\n    .mount('/hono', hono.fetch)\n```\n\n----------------------------------------\n\nTITLE: Handling Scoped/Local Errors in Route Lifecycle with Elysia (TypeScript)\nDESCRIPTION: Shows how to provide local error handling within the route lifecycle using Elysiaâ€™s hook system. Demonstrates implementing a route with a local middleware (`beforeHandle`) that checks authentication and throws an error if it fails, plus a local error handler for the same route, enabling scoped error responses. Dependency: `elysia` and an external utility function `isSignIn`. Input: request headers; output: unauthorized error or handled response.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/', () => 'Hello', {\n        beforeHandle({ set, request: { headers }, error }) {\n            if (!isSignIn(headers)) throw error(401)\n        },\n        error({ error }) {\n            return 'Handled'\n        }\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Using ElysiaJS Validation System for Models (TypeScript)\nDESCRIPTION: Demonstrates the recommended approach for defining models in ElysiaJS using its built-in validation system. This approach provides both runtime validation and type inference.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/best-practice.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// âœ… Do\nimport { Elysia, t } from 'elysia'\n\nconst customBody = t.Object({\n\tusername: t.String(),\n\tpassword: t.String()\n})\n\n// Optional if you want to get the type of the model\n// Usually if we didn't use the type, as it's already inferred by Elysia\ntype CustomBody = typeof customBody.static\n    // ^?\n\n\n\nexport { customBody }\n```\n\n----------------------------------------\n\nTITLE: Implementing User Authentication in Elysia.js with Password Hashing and Cookie Sessions\nDESCRIPTION: This code sets up a user authentication system with sign-up and sign-in functionality. It uses Bun's password hashing, in-memory storage for user credentials and sessions, and secure cookies for maintaining user sessions. The implementation includes validation for username and password, error handling for existing users, and secure session token generation.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport const user = new Elysia({ prefix: '/user' })\n    .state({\n        user: {} as Record<string, string>,\n        session: {} as Record<number, string>\n    })\n    .put(\n        '/sign-up',\n        async ({ body: { username, password }, store, error }) => {\n            if (store.user[username])\n                return error(400, {\n                    success: false,\n                    message: 'User already exists'\n                })\n\n            store.user[username] = await Bun.password.hash(password)\n\n            return {\n                success: true,\n                message: 'User created'\n            }\n        },\n        {\n            body: t.Object({\n                username: t.String({ minLength: 1 }),\n                password: t.String({ minLength: 8 })\n            })\n        }\n    )\n    .post(\n        '/sign-in',\n        async ({\n            store: { user, session },\n            error,\n            body: { username, password },\n            cookie: { token }\n        }) => {\n            if (\n                !user[username] ||\n                !(await Bun.password.verify(password, user[username]))\n            )\n                return error(400, {\n                    success: false,\n                    message: 'Invalid username or password'\n                })\n\n            const key = crypto.getRandomValues(new Uint32Array(1))[0]\n            session[key] = username\n            token.value = key\n\n            return {\n                success: true,\n                message: `Signed in as ${username}`\n            }\n        },\n        {\n            body: t.Object({\n                username: t.String({ minLength: 1 }),\n                password: t.String({ minLength: 8 })\n            }),\n            cookie: t.Cookie(\n                {\n                    token: t.Number()\n                },\n                {\n                    secrets: 'seia'\n                }\n            )\n        }\n    )\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Routes with Elysia in TypeScript\nDESCRIPTION: This snippet demonstrates how to create basic routes using Elysia. It includes examples of GET routes with different response types and parameter handling.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/midori.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/', 'Hello World')\n    .get('/json', {\n        hello: 'world'\n    })\n    .get('/id/:id', ({ params: { id } }) => id)\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Path Parameter Handling\nDESCRIPTION: Shows how to use dynamic path parameters and rest parameters in routes\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/cheat-sheet.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/id/:id', ({ params: { id } }) => id)\n    .get('/rest/*', () => 'Rest')\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Defining Authorization Plugin with Elysia and Supabase in TypeScript\nDESCRIPTION: This snippet demonstrates how to encapsulate authorization and user identification logic as an Elysia plugin in TypeScript. It uses the @elysiajs/cookie plugin to access cookies, calls Supabase's getUser or refreshSession to retrieve the userId, and throws on failure, ensuring only authenticated requests are processed. The plugin injects userId into the request context for downstream handlers. Prerequisites: Elysia, Supabase client, @elysiajs/cookie installed and properly configured. Inputs: access_token and refresh_token cookies. Outputs: augments context with userId or prevents handler execution if authentication fails.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-supabase.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { cookie } from '@elysiajs/cookie'\n\nimport { supabase } from './supabase'\n\nexport const authen = (app: Elysia) =>\n    app\n        .use(cookie())\n        .derive(\n            async ({ setCookie, cookie: { access_token, refresh_token } }) => {\n                const { data, error } = await supabase.auth.getUser(\n                    access_token\n                )\n\n                if (data.user)\n                    return {\n                        userId: data.user.id\n                    }\n\n                const { data: refreshed, error: refreshError } =\n                    await supabase.auth.refreshSession({\n                        refresh_token\n                    })\n\n                if (refreshError) throw error\n\n                return {\n                    userId: refreshed.user!.id\n                }\n            }\n        )\n```\n\n----------------------------------------\n\nTITLE: Using ElysiaJS Models in Routes (TypeScript)\nDESCRIPTION: Shows how to use Elysia models in route handlers to leverage both validation and type inference. This approach ensures type safety while providing runtime validation.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/best-practice.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// âœ… Do\nnew Elysia()\n\t.post('/login', ({ body }) => {\n\t                 // ^?\n\t\treturn body\n\t}, {\n\t\tbody: customBody\n\t})\n```\n\n----------------------------------------\n\nTITLE: Implementing Note Storage Class\nDESCRIPTION: Creating a singleton class for storing notes and decorating the Elysia instance with it.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { swagger } from '@elysiajs/swagger'\n\nclass Note {\n    constructor(public data: string[] = ['Moonhalo']) {}\n}\n\nconst app = new Elysia()\n    .use(swagger())\n    .decorate('note', new Note())\n    .get('/note', ({ note }) => note.data)\n    .get('/note/:index', ({ note, params: { index }, error }) => {\n        return note.data[index] ?? error(404, 'oh no :(')\n    },\n    {\n        params: t.Object({\n            index: t.Number()\n        })\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Request Schema Validation\nDESCRIPTION: Shows how to implement request body validation using schema definitions\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/cheat-sheet.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n    .post('/mirror', ({ body: { username } }) => username, {\n        body: t.Object({\n            username: t.String(),\n            password: t.String()\n        })\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Using Elysia.error for Throwing vs. Returning Errors (TypeScript)\nDESCRIPTION: Illustrates Elysia's convention for returning versus throwing errors using the built-in `error` helper. An `onError` handler is configured to catch thrown errors, while returned errors bypass `onError`. Demonstrates both approaches via two GET endpoints (`/throw` and `/return`). Dependencies: `elysia` package. Inputs are requests to the two different endpoints; outputs are either caught or uncaught error handling.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, file } from 'elysia'\n\nnew Elysia()\n    .onError(({ code, error, path }) => {\n        if (code === 418) return 'caught'\n    })\n    .get('/throw', ({ error }) => {\n        // This will be caught by onError\n        throw error(418)\n    })\n    .get('/return', () => {\n        // This will NOT be caught by onError\n        return error(418)\n    })\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Elysia Server\nDESCRIPTION: A simple hello world example in Elysia that sets up three routes - a root GET route, a parameterized user route, and a POST route for form submissions.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/at-glance.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/', 'Hello Elysia')\n    .get('/user/:id', ({ params: { id }}) => id)\n    .post('/form', ({ body }) => body)\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Using Eden Treaty for Type-Safe Client-Server Communication in ElysiaJS\nDESCRIPTION: This snippet demonstrates how to set up an Elysia server with various endpoints and then use Eden Treaty to create a type-safe client. The example shows defining routes with parameters and body validation, then accessing those endpoints with full type support.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/overview.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @filename: server.ts\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n    .get('/', 'hi')\n    .get('/users', () => 'Skadi')\n    .put('/nendoroid/:id', ({ body }) => body, {\n        body: t.Object({\n            name: t.String(),\n            from: t.String()\n        })\n    })\n    .get('/nendoroid/:id/name', () => 'Skadi')\n    .listen(3000)\n\nexport type App = typeof app\n\n// @filename: index.ts\n// ---cut---\nimport { treaty } from '@elysiajs/eden'\nimport type { App } from './server'\n\nconst app = treaty<App>('localhost:3000')\n\n// @noErrors\napp.\n//  ^|\n\n\n\n\n// Call [GET] at '/'\nconst { data } = await app.index.get()\n\n// Call [PUT] at '/nendoroid/:id'\nconst { data: nendoroid, error } = await app.nendoroid({ id: 1895 }).put({\n    name: 'Skadi',\n    from: 'Arknights'\n})\n```\n\n----------------------------------------\n\nTITLE: Installing Bun Runtime\nDESCRIPTION: Commands for installing Bun runtime on different operating systems.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/quick-start.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -fsSL https://bun.sh/install | bash\n```\n\nLANGUAGE: bash\nCODE:\n```\npowershell -c \"irm bun.sh/install.ps1 | iex\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Type-Safe POST Requests in Elysia\nDESCRIPTION: This example shows how to create a type-safe POST endpoint using Elysia. It defines a schema for the request body using the 't' object for runtime type checking.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/midori.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n    .post(\n        '/profile',\n        // â†“ hover me â†“\n        ({ body }) => body,\n        {\n            body: t.Object({\n                username: t.String()\n            })\n        }\n    )\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Reusing Named ElysiaJS Plugins with Automatic Deduplication (TypeScript)\nDESCRIPTION: Illustrates how to create a named ElysiaJS plugin (`new Elysia({ name: 'my-plugin' })`) and apply it multiple times to an Elysia application using `.use()`. Elysia automatically handles deduplication of plugins based on their name (or an optional seed), preventing redundant processing and improving performance. Requires the 'elysia' package.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/best-practice.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst plugin = new Elysia({ name: 'my-plugin' })\n\t.decorate(\"type\", \"plugin\")\n\nconst app = new Elysia()\n    .use(plugin)\n    .use(plugin)\n    .use(plugin)\n    .use(plugin)\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Using Method Chaining in ElysiaJS (TypeScript)\nDESCRIPTION: Demonstrates the proper way to use method chaining in ElysiaJS to maintain type integrity. This pattern ensures type inference works correctly by preserving type references through the chain of method calls.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/best-practice.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .state('build', 1)\n    // Store is strictly typed // [!code ++]\n    .get('/', ({ store: { build } }) => build)\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Authenticating Users with Supabase in TypeScript\nDESCRIPTION: Demonstrates how to use Supabase for user authentication, including sign up and sign in functionality.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-supabase.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nsupabase.auth.signUp(body)\n\nsupabase.auth.signInWithPassword(body)\n```\n\n----------------------------------------\n\nTITLE: Initializing Elysia with Basic Configuration in TypeScript\nDESCRIPTION: Demonstrates how to create a new Elysia instance with prefix and normalize options. This is the basic way to configure Elysia's behavior by passing an object to the constructor.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/configuration.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia({\n\tprefix: '/v1',\n\tnormalize: true\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing User Authentication Service in ElysiaJS\nDESCRIPTION: Defines a user service with authentication functionality including state management, data models, and authentication macros. The service includes session management via cookies and defines a custom isSignIn macro for authorization checking.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nexport const userService = new Elysia({ name: 'user/service' })\n    .state({\n        user: {} as Record<string, string>,\n        session: {} as Record<number, string>\n    })\n    .model({\n        signIn: t.Object({\n            username: t.String({ minLength: 1 }),\n            password: t.String({ minLength: 8 })\n        }),\n        session: t.Cookie(\n            {\n                token: t.Number()\n            },\n            {\n                secrets: 'seia'\n            }\n        ),\n        optionalSession: t.Optional(t.Ref('session'))\n    })\n    .macro({\n        isSignIn(enabled: boolean) {\n            if (!enabled) return\n\n            return {\n            \tbeforeHandle({ error, cookie: { token }, store: { session } }) {\n                    if (!token.value)\n                        return error(401, {\n                            success: false,\n                            message: 'Unauthorized'\n                        })\n\n                    const username = session[token.value as unknown as number]\n\n                    if (!username)\n                        return error(401, {\n                            success: false,\n                            message: 'Unauthorized'\n                        })\n                }\n            }\n        }\n    })\n\nexport const getUserId = new Elysia()\n    .use(userService)\n    .guard({\n       \tisSignIn: true,\n        cookie: 'session'\n    })\n    .resolve(({ store: { session }, cookie: { token } }) => ({\n        username: session[token.value]\n    }))\n\nexport const user = new Elysia({ prefix: '/user' })\n\t.use(getUserId)\n\t.get('/profile', ({ username }) => ({\n        success: true,\n        username\n    }))\n```\n\n----------------------------------------\n\nTITLE: Implementing CRUD Operations in a Note Plugin with Elysia (TypeScript)\nDESCRIPTION: This enhanced plugin code adds create (PUT), read (GET), update (PATCH), and delete (DELETE) endpoints to the note functionality. The Note class now supports add, remove, and update methods. Each route uses typed request validation, and CRUD input/output structures are enforced via 'elysia' types. This modular plugin can be imported by other Elysia apps for full CRUD support.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nclass Note {\n    constructor(public data: string[] = ['Moonhalo']) {}\n\n    add(note: string) { // [!code ++]\n        this.data.push(note) // [!code ++]\n\n        return this.data // [!code ++]\n    } // [!code ++]\n\n    remove(index: number) { // [!code ++]\n        return this.data.splice(index, 1) // [!code ++]\n    } // [!code ++]\n\n    update(index: number, note: string) { // [!code ++]\n        return (this.data[index] = note) // [!code ++]\n    } // [!code ++]\n}\n\nexport const note = new Elysia()\n    .decorate('note', new Note())\n    .get('/note', ({ note }) => note.data)\n    .put('/note', ({ note, body: { data } }) => note.add(data), { // [!code ++]\n        body: t.Object({ // [!code ++]\n            data: t.String() // [!code ++]\n        }) // [!code ++]\n    }) // [!code ++]\n    .get(\n        '/note/:index',\n        ({ note, params: { index }, error }) => {\n            return note.data[index] ?? error(404, 'Not Found :(')\n        },\n        {\n            params: t.Object({\n                index: t.Number()\n            })\n        }\n    )\n    .delete( // [!code ++]\n        '/note/:index', // [!code ++]\n        ({ note, params: { index }, error }) => { // [!code ++]\n            if (index in note.data) return note.remove(index) // [!code ++]\n\n            return error(422) // [!code ++]\n        }, // [!code ++]\n        { // [!code ++]\n            params: t.Object({ // [!code ++]\n                index: t.Number() // [!code ++]\n            }) // [!code ++]\n        } // [!code ++]\n    ) // [!code ++]\n    .patch( // [!code ++]\n        '/note/:index', // [!code ++]\n        ({ note, params: { index }, body: { data }, error }) => { // [!code ++]\n            if (index in note.data) return note.update(index, data) // [!code ++]\n\n            return error(422) // [!code ++]\n        }, // [!code ++]\n        { // [!code ++]\n            params: t.Object({ // [!code ++]\n                index: t.Number() // [!code ++]\n            }), // [!code ++]\n            body: t.Object({ // [!code ++]\n                data: t.String() // [!code ++]\n            }) // [!code ++]\n        } // [!code ++]\n    ) // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Processing Stream Responses with Eden Treaty in TypeScript\nDESCRIPTION: This snippet shows how to handle stream responses from an Elysia server using Eden Treaty. The example demonstrates that stream responses are interpreted as AsyncGenerators, allowing the use of 'for await' loops to process each chunk of the streamed data.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/response.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { treaty } from '@elysiajs/eden'\n\nconst app = new Elysia()\n\t.get('/ok', function* () {\n\t\tyield 1\n\t\tyield 2\n\t\tyield 3\n\t})\n\nconst { data, error } = await treaty(app).ok.get()\nif (error) throw error\n\nfor await (const chunk of data)\n\tconsole.log(chunk)\n               // ^?\n```\n\n----------------------------------------\n\nTITLE: Defining and Handling Custom Errors in Elysia (TypeScript)\nDESCRIPTION: Demonstrates how to create and handle a custom error class with Elysia's type-safe error classification system. Defines `MyError` extending `Error`, registers it in the Elysia instance via `.error({ MyError })`, and provides an `onError` switch for handling custom error codes. Inputs: requests that throw `MyError`; outputs: error handling based on custom types. Dependencies: `elysia` package.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nclass MyError extends Error {\n    constructor(public message: string) {\n        super(message)\n    }\n}\n\nnew Elysia()\n    .error({\n        MyError\n    })\n    .onError(({ code, error }) => {\n        switch (code) {\n            // With auto-completion\n            case 'MyError':\n                // With type narrowing\n                // Hover to see error is typed as `CustomError`\n                return error\n        }\n    })\n    .get('/', () => {\n        throw new MyError('Hello Error')\n    })\n```\n\n----------------------------------------\n\nTITLE: Using Eden Fetch for Type-Safe API Requests in ElysiaJS\nDESCRIPTION: This example shows how to use Eden Fetch, an alternative to Eden Treaty that follows fetch-like syntax while maintaining type safety. It demonstrates making a POST request with route parameters and a request body.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/overview.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { edenFetch } from '@elysiajs/eden'\nimport type { App } from './server'\n\nconst fetch = edenFetch<App>('http://localhost:3000')\n\nconst { data } = await fetch('/name/:name', {\n    method: 'POST',\n    params: {\n        name: 'Saori'\n    },\n    body: {\n        branch: 'Arius',\n        type: 'Striker'\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Docker Configuration for Elysia.js\nDESCRIPTION: Dockerfile for deploying an Elysia.js application using a two-stage build process. It compiles the application to a binary in the build stage and uses a minimal distroless base image for runtime.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/deployment.md#2025-04-23_snippet_6\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM oven/bun AS build\n\nWORKDIR /app\n\n# Cache packages installation\nCOPY package.json package.json\nCOPY bun.lock bun.lock\n\nRUN bun install\n\nCOPY ./src ./src\n\nENV NODE_ENV=production\n\nRUN bun build \\\n\t--compile \\\n\t--minify-whitespace \\\n\t--minify-syntax \\\n\t--target bun \\\n\t--outfile server \\\n\t./src/index.ts\n\nFROM gcr.io/distroless/base\n\nWORKDIR /app\n\nCOPY --from=build /app/server server\n\nENV NODE_ENV=production\n\nCMD [\"./server\"]\n\nEXPOSE 3000\n```\n\n----------------------------------------\n\nTITLE: Method Chaining Pattern in ElysiaJS\nDESCRIPTION: Demonstrates the correct way to use method chaining in ElysiaJS to maintain type inference. Shows how to properly chain state and route definitions.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/structure.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .state('build', 1)\n    .get('/', ({ store: { build } }) => build)\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Configuring User Authentication in Elysia (TypeScript)\nDESCRIPTION: This snippet demonstrates how to set up user authentication using Elysia. It includes session handling, cookie management, and a macro for sign-in functionality.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\n        }),\n        session: t.Cookie(\n            {\n                token: t.Number()\n            },\n            {\n                secrets: 'seia'\n            }\n        ),\n        optionalSession: t.Optional(t.Ref('session'))\n    })\n    .macro({\n        isSignIn(enabled: boolean) {\n            if (!enabled) return\n\n            return {\n            \tbeforeHandle({ error, cookie: { token }, store: { session } }) {\n                    if (!token.value)\n                        return error(401, {\n                            success: false,\n                            message: 'Unauthorized'\n                        })\n\n                    const username = session[token.value as unknown as number]\n\n                    if (!username)\n                        return error(401, {\n                            success: false,\n                            message: 'Unauthorized'\n                        })\n                }\n            }\n        }\n    })\n\nexport const getUserId = new Elysia()\n    .use(userService)\n    .guard({\n    \tisSignIn: true,\n        cookie: 'session'\n    })\n    .resolve(({ store: { session }, cookie: { token } }) => ({\n        username: session[token.value]\n    }))\n    .as('plugin')\n\nexport const user = new Elysia({ prefix: '/user' })\n    .use(getUserId)\n    .get('/profile', ({ username }) => ({\n        success: true,\n        username\n    }))\n```\n\n----------------------------------------\n\nTITLE: Enabling Automatic OpenAPI Documentation with Swagger in Elysia (TypeScript)\nDESCRIPTION: This code enables automatic API documentation using the @elysiajs/swagger plugin in an Elysia TypeScript application. The swagger() plugin is registered before the usual auth and post modules, allowing the app to generate OpenAPI documentation conforming to Schema 3.0. Required dependencies: Elysia, @elysiajs/swagger, project modules. Inputs: None. Outputs: Running API server with Swagger UI available for documentation and testing. Useful for front-end integrations and API consumers.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-supabase.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { swagger } from '@elysiajs/swagger' // [!code ++]\n\nimport { auth, post } from './modules'\n\nconst app = new Elysia()\n    .use(swagger()) // [!code ++]\n    .use(auth)\n    .use(post)\n    .listen(3000)\n\nconsole.log(\n    `ðŸ¦Š Elysia is running at ${app.server?.hostname}:${app.server?.port}`\n)\n```\n\n----------------------------------------\n\nTITLE: Creating an Authentication Macro in ElysiaJS v1\nDESCRIPTION: Demonstrates creating an authentication macro in a separate file that defines isAuth and role properties. This shows how macros can be used for complex authorization layers.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/macro.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// @filename: auth.ts\nimport { Elysia } from 'elysia'\n\nexport const auth = new Elysia()\n    .macro(() => {\n        return {\n            isAuth(isAuth: boolean) {},\n            role(role: 'user' | 'admin') {},\n        }\n    })\n\n// @filename: index.ts\n// ---cut---\nimport { Elysia } from 'elysia'\nimport { auth } from './auth'\n\nconst app = new Elysia()\n    .use(auth)\n    .get('/', () => 'hi', {\n        isAuth: true,\n        role: 'admin'\n    })\n```\n\n----------------------------------------\n\nTITLE: Authentication Guard Implementation in Elysia.js\nDESCRIPTION: Shows how to implement authentication checks using beforeHandle and guard patterns\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { validateSession } from './user'\n\nnew Elysia()\n    .get('/', () => 'hi', {\n        beforeHandle({ set, cookie: { session }, error }) {\n            if (!validateSession(session.value)) return error(401)\n        }\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Handling Route Parameters in Elysia with TypeScript\nDESCRIPTION: Demonstrates how to define routes with parameters in Elysia, including optional parameters. Shows type inference for route parameters and response headers.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/index.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.get('/id/:id', ({ params, set }) => {\n\t                   // ^?\n\n\n\n\n\t\tset.headers.a\n\t\t//           ^|\n\n\n\t\treturn 'Su'\n\t})\n\n\t.get('/optional/:name?', ({ params: { name } }) => {\n\t                                   // ^?\n        return name ?? 'Pardofelis'\n\t})\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Returning Errors from ElysiaJS Derive Function in TypeScript\nDESCRIPTION: Demonstrates how to return an error early from the `derive` lifecycle hook in ElysiaJS. If the 'authorization' header is missing, it returns a 400 Bad Request error; otherwise, it derives a 'bearer' token property for the context.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .derive(({ headers, error }) => {\n        const auth = headers['authorization']\n\n        if(!auth) return error(400)\n\n        return {\n            bearer: auth?.startsWith('Bearer ') ? auth.slice(7) : null\n        }\n    })\n    .get('/', ({ bearer }) => bearer)\n```\n\n----------------------------------------\n\nTITLE: Consuming ElysiaJS Streamed Responses with Eden Treaty\nDESCRIPTION: Shows how a client using `@elysiajs/eden`'s `treaty` can consume a streamed response originating from an Elysia generator function. The `treaty` client correctly infers the response (`data`) as an `AsyncGenerator`, allowing the client to iterate through the streamed chunks using a `for await...of` loop.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-11.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { treaty } from '@elysiajs/eden'\n\nconst app = new Elysia()\n\t.get('/ok', function* () {\n\t\tyield 1\n\t\tyield 2\n\t\tyield 3\n\t})\n\nconst { data, error } = await treaty(app).ok.get()\nif (error) throw error\n\nfor await (const chunk of data)\n\tconsole.log(chunk)\n```\n\n----------------------------------------\n\nTITLE: Using Plugins and Prefixes to Modularize Route Groups in Elysia (TypeScript)\nDESCRIPTION: Showcases how to modularize groups of related routes by creating a plugin instance with a set prefix and then composing it into another Elysia instance. The 'users' plugin handles all endpoints under '/user', which is then integrated with an app that also serves a root endpoint. Prerequisites: Elysia imported, understanding of plugin/use pattern. Result is the same as manual grouping, but structure is more maintainable and reusable.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/route.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst users = new Elysia({ prefix: '/user' })\n    .post('/sign-in', 'Sign in')\n    .post('/sign-up', 'Sign up')\n    .post('/profile', 'Profile')\n\nnew Elysia()\n    .use(users)\n    .get('/', 'hello world')\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Grouping Note Plugin Endpoints with Prefix Option in Elysia (TypeScript)\nDESCRIPTION: This code reorganizes all note-related endpoints under a common '/note' prefix by providing the 'prefix' option during Elysia instantiation. The Note class's CRUD methods remain, but routes are now declared relative to the prefix (e.g., '/' and '/:index'). This pattern improves code readability and route maintainability, especially for larger plugins.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nclass Note {\n    constructor(public data: string[] = ['Moonhalo']) {}\n\n    add(note: string) {\n        this.data.push(note)\n\n        return this.data\n    }\n\n    remove(index: number) {\n        return this.data.splice(index, 1)\n    }\n\n    update(index: number, note: string) {\n        return (this.data[index] = note)\n    }\n}\n\n// ---cut---\nexport const note = new Elysia({ prefix: '/note' }) // [!code ++]\n    .decorate('note', new Note())\n    .get('/', ({ note }) => note.data) // [!code ++]\n    .put('/', ({ note, body: { data } }) => note.add(data), {\n        body: t.Object({\n            data: t.String()\n        })\n    })\n    .get(\n        '/:index',\n        ({ note, params: { index }, error }) => {\n            return note.data[index] ?? error(404, 'Not Found :(')\n        },\n        {\n            params: t.Object({\n                index: t.Number()\n            })\n        }\n    )\n    .delete(\n        '/:index',\n        ({ note, params: { index }, error }) => {\n            if (index in note.data) return note.remove(index)\n\n            return error(422)\n        },\n        {\n            params: t.Object({\n                index: t.Number()\n            })\n        }\n    )\n    .patch(\n        '/:index',\n        ({ note, params: { index }, body: { data }, error }) => {\n            if (index in note.data) return note.update(index, data)\n\n            return error(422)\n        },\n        {\n            params: t.Object({\n                index: t.Number()\n            }),\n            body: t.Object({\n                data: t.String()\n            })\n        }\n    )\n```\n\n----------------------------------------\n\nTITLE: Integrating User Authentication with Note Service in Elysia.js\nDESCRIPTION: Implementation of the note service with imported user authentication. This code shows how to use the user service and getUserId plugin to add authorization to different endpoints in the note controller.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { getUserId, userService } from './user' // [!code ++]\n\nconst memo = t.Object({\n\tdata: t.String(),\n\tauthor: t.String()\n})\n\ntype Memo = typeof memo.static\n\nclass Note {\n    constructor(\n\t\tpublic data: Memo[] = [\n\t\t\t{\n\t\t\t\tdata: 'Moonhalo',\n\t\t\t\tauthor: 'saltyaom'\n\t\t\t}\n\t\t]\n\t) {}\n\n    add(note: Memo) {\n        this.data.push(note)\n\n        return this.data\n    }\n\n    remove(index: number) {\n        return this.data.splice(index, 1)\n    }\n\n    update(index: number, note: Partial<Memo>) {\n        return (this.data[index] = { ...this.data[index], ...note })\n    }\n}\n\nexport const note = new Elysia({ prefix: '/note' })\n\t.use(userService) // [!code ++]\n    .decorate('note', new Note())\n    .model({\n        memo: t.Omit(memo, ['author'])\n    })\n    .onTransform(function log({ body, params, path, request: { method } }) {\n        console.log(`${method} ${path}`, {\n            body,\n            params\n        })\n    })\n    .get('/', ({ note }) => note.data)\n    .use(getUserId) // [!code ++]\n    .put(\n        '/',\n        ({ note, body: { data }, username }) =>\n            note.add({ data, author: username }),\n        {\n            body: 'memo'\n        }\n    )\n    .get(\n        '/:index',\n        ({ note, params: { index }, error }) => {\n            return note.data[index] ?? error(404, 'Not Found :(')\n        },\n        {\n            params: t.Object({\n                index: t.Number()\n            })\n        }\n    )\n    .guard({\n        params: t.Object({\n            index: t.Number()\n        })\n    })\n    .delete('/:index', ({ note, params: { index }, error }) => {\n        if (index in note.data) return note.remove(index)\n\n        return error(422)\n    })\n    .patch(\n        '/:index',\n        ({ note, params: { index }, body: { data }, error, username }) => {\n            if (index in note.data)\n                return note.update(index, { data, author: username })\n\n            return error(422)\n        },\n        {\n            isSignIn: true,\n            body: 'memo'\n        }\n    )\n```\n\n----------------------------------------\n\nTITLE: Initializing ElysiaJS with the Static Plugin\nDESCRIPTION: This TypeScript snippet demonstrates the basic integration of the `@elysiajs/static` plugin into an ElysiaJS application. It imports `Elysia` and `staticPlugin`, creates a new Elysia instance, registers the plugin using `.use(staticPlugin())`, and starts the server on port 3000. By default, this serves files from the 'public' directory under the '/public' URL prefix.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/static.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { staticPlugin } from '@elysiajs/static'\n\nnew Elysia()\n    .use(staticPlugin())\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Request Handling with Elysia.handle\nDESCRIPTION: Demonstrates programmatic request handling using Elysia.handle for testing and simulation.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst app = new Elysia()\n    .get('/', () => 'hello')\n    .post('/hi', () => 'hi')\n    .listen(3000)\n\napp.handle(new Request('http://localhost/')).then(console.log)\n```\n\n----------------------------------------\n\nTITLE: Custom 404 Error Handling with Elysia (TypeScript)\nDESCRIPTION: Shows how to provide a custom 404 (Not Found) message using the `onError` middleware in Elysia. Imports `NotFoundError` from `elysia`, assigns an error handler that checks if the error code is 'NOT_FOUND', and returns a custom response. Demonstrates POST request behavior that throws a not found error. Dependencies: `elysia` package. Output: Custom 404 message on error.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, NotFoundError } from 'elysia'\n\nnew Elysia()\n    .onError(({ code, error, set }) => {\n        if (code === 'NOT_FOUND') return error(404, 'Not Found :(')\n    })\n    .post('/', () => {\n        throw new NotFoundError()\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Schema Validation with Elysia.t\nDESCRIPTION: Shows how to use Elysia's schema builder to validate that a path parameter is numeric at both runtime and compile-time.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/at-glance.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n    .get('/user/:id', ({ params: { id } }) => id, {\n                                // ^?\n        params: t.Object({\n            id: t.Numeric()\n        })\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Implementing ElysiaJS Server in SvelteKit Route\nDESCRIPTION: This snippet demonstrates how to create an Elysia server instance within a SvelteKit server route file. It sets up GET and POST handlers and exports them for SvelteKit to use. The code includes type definitions and request handling.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/sveltekit.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// src/routes/[...slugs]/+server.ts\nimport { Elysia, t } from 'elysia';\n\nconst app = new Elysia()\n    .get('/', () => 'hello SvelteKit')\n    .post('/', ({ body }) => body, {\n        body: t.Object({\n            name: t.String()\n        })\n    })\n\ntype RequestHandler = (v: { request: Request }) => Response | Promise<Response>\n\nexport const GET: RequestHandler = ({ request }) => app.handle(request)\nexport const POST: RequestHandler = ({ request }) => app.handle(request)\n```\n\n----------------------------------------\n\nTITLE: Implementing User Authentication Services in Elysia.js\nDESCRIPTION: User authentication module that defines state management for users and sessions, validation models, authentication macros, and endpoints for sign-up, sign-in, sign-out, and profile viewing.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nexport const userService = new Elysia({ name: 'user/service' })\n    .state({\n        user: {} as Record<string, string>,\n        session: {} as Record<number, string>\n    })\n    .model({\n        signIn: t.Object({\n            username: t.String({ minLength: 1 }),\n            password: t.String({ minLength: 8 })\n        }),\n        session: t.Cookie(\n            {\n                token: t.Number()\n            },\n            {\n                secrets: 'seia'\n            }\n        ),\n        optionalSession: t.Optional(t.Ref('session'))\n    })\n    .macro({\n        isSignIn(enabled: boolean) {\n            if (!enabled) return\n\n            return {\n            \tbeforeHandle({ error, cookie: { token }, store: { session } }) {\n                    if (!token.value)\n                        return error(401, {\n                            success: false,\n                            message: 'Unauthorized'\n                        })\n\n                    const username = session[token.value as unknown as number]\n\n                    if (!username)\n                        return error(401, {\n                            success: false,\n                            message: 'Unauthorized'\n                        })\n                }\n            }\n        }\n    })\n\nexport const getUserId = new Elysia()\n    .use(userService)\n    .guard({\n    \tisSignIn: true,\n        cookie: 'session'\n    })\n    .resolve(({ store: { session }, cookie: { token } }) => ({\n        username: session[token.value]\n    }))\n    .as('plugin')\n\nexport const user = new Elysia({ prefix: '/user' })\n    .use(userService)\n    .put(\n        '/sign-up',\n        async ({ body: { username, password }, store, error }) => {\n            if (store.user[username])\n                return error(400, {\n                    success: false,\n                    message: 'User already exists'\n                })\n\n            store.user[username] = await Bun.password.hash(password)\n\n            return {\n                success: true,\n                message: 'User created'\n            }\n        },\n        {\n            body: 'signIn'\n        }\n    )\n    .post(\n        '/sign-in',\n        async ({\n            store: { user, session },\n            error,\n            body: { username, password },\n            cookie: { token }\n        }) => {\n            if (\n                !user[username] ||\n                !(await Bun.password.verify(password, user[username]))\n            )\n                return error(400, {\n                    success: false,\n                    message: 'Invalid username or password'\n                })\n\n            const key = crypto.getRandomValues(new Uint32Array(1))[0]\n            session[key] = username\n            token.value = key\n\n            return {\n                success: true,\n                message: `Signed in as ${username}`\n            }\n        },\n        {\n            body: 'signIn',\n            cookie: 'optionalSession'\n        }\n    )\n    .get(\n        '/sign-out',\n        ({ cookie: { token } }) => {\n            token.remove()\n\n            return {\n                success: true,\n                message: 'Signed out'\n            }\n        },\n        {\n            cookie: 'optionalSession'\n        }\n    )\n    .use(getUserId)\n    .get('/profile', ({ username }) => ({\n        success: true,\n        username\n    }))\n```\n\n----------------------------------------\n\nTITLE: Scoped Plugin Implementation in Elysia\nDESCRIPTION: Shows how to create truly encapsulated plugin instances using the new scoped functionality\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-07.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst plugin = new Elysia({ scoped: true, prefix: '/hello' })\n    .onRequest(() => {\n        console.log('In Scoped')\n    })\n    .get('/', () => 'hello')\n\nconst app = new Elysia()\n    .use(plugin)\n    // 'In Scoped' will not log\n    .get('/', () => 'Hello World')\n```\n\n----------------------------------------\n\nTITLE: Handling File Uploads in Elysia with TypeScript\nDESCRIPTION: Shows how to handle file uploads in Elysia using the PATCH method. Demonstrates type inference for request body and file validation.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/index.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n\t.patch('/profile', ({ body }) => body.profile, {\n\t                    // ^?\n\n\n\n\n\t\tbody: t.Object({\n\t\t\tid: t.Number(),\n\t\t\tprofile: t.File({ type: 'image' })\n\t\t})\n\t})\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Rate Limiter Implementation with onRequest\nDESCRIPTION: Example showing how to implement rate limiting using the onRequest lifecycle event.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .use(rateLimiter)\n    .onRequest(({ rateLimiter, ip, set, error }) => {\n        if (rateLimiter.check(ip)) return error(420, 'Enhance your calm')\n    })\n    .get('/', () => 'hi')\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Handling API Responses with Error Checking in TypeScript using Eden Treaty\nDESCRIPTION: This example demonstrates how to use Eden Treaty to make API calls to an Elysia server with proper error handling. It shows how the error() helper function works with type narrowing, allowing for more specific error handling based on HTTP status codes.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/response.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { treaty } from '@elysiajs/eden'\n\nconst app = new Elysia()\n    .post('/user', ({ body: { name }, error }) => {\n        if(name === 'Otto')\n            return error(400, 'Bad Request')\n\n        return name\n    }, {\n        body: t.Object({\n            name: t.String()\n        })\n    })\n    .listen(3000)\n\nconst api = treaty<typeof app>('localhost:3000')\n\nconst submit = async (name: string) => {\n    const { data, error } = await api.user.post({\n        name\n    })\n\n    // type: string | null\n    console.log(data)\n\n    if (error)\n        switch(error.status) {\n            case 400:\n                // Error type will be narrow down\n                throw error.value\n\n            default:\n                throw error.value\n        }\n\n    // Once the error is handled, type will be unwrapped\n    // type: string\n    return data\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming Elysia API with Eden Treaty Client\nDESCRIPTION: This snippet shows how to import the server type and use Eden Treaty to create a type-safe client. It demonstrates making GET and POST requests with proper type inference for both request parameters and response data.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/legacy.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// client.ts\nimport { edenTreaty } from '@elysiajs/eden'\nimport type { App } from './server' // [!code ++]\n\nconst app = edenTreaty<App>('http://localhost:')\n\n// response type: 'Hi Elysia'\nconst { data: pong, error } = app.get()\n\n// response type: 1895\nconst { data: id, error } = app.id['1895'].get()\n\n// response type: { id: 1895, name: 'Skadi' }\nconst { data: nendoroid, error } = app.mirror.post({\n    id: 1895,\n    name: 'Skadi'\n})\n```\n\n----------------------------------------\n\nTITLE: JWT Implementation with Cookie Authentication\nDESCRIPTION: Example of implementing JWT authentication using cookies in ElysiaJS, including sign-in and profile verification endpoints\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/jwt.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { jwt } from '@elysiajs/jwt'\n\nconst app = new Elysia()\n    .use(\n        jwt({\n            name: 'jwt',\n            secret: 'Fischl von Luftschloss Narfidort'\n        })\n    )\n    .get('/sign/:name', async ({ jwt, params: { name }, cookie: { auth } }) => {\n    \tconst value = await jwt.sign({ name })\n\n        auth.set({\n            value,\n            httpOnly: true,\n            maxAge: 7 * 86400,\n            path: '/profile',\n        })\n\n        return `Sign in as ${value}`\n    })\n    .get('/profile', async ({ jwt, error, cookie: { auth } }) => {\n        const profile = await jwt.verify(auth.value)\n\n        if (!profile)\n            return error(401, 'Unauthorized')\n\n        return `Hello ${profile.name}`\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Implementing Local Hook for HTML Content Type\nDESCRIPTION: Example showing how to use a local hook to set Content-Type headers for HTML responses on specific routes.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { isHtml } from '@elysiajs/html'\n\nnew Elysia()\n    .get('/', () => '<h1>Hello World</h1>', {\n        afterHandle({ response, set }) {\n            if (isHtml(response))\n                set.headers['Content-Type'] = 'text/html; charset=utf8'\n        }\n    })\n    .get('/hi', () => '<h1>Hello World</h1>')\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Applying Parameter Validation Globally with Guard in Elysia Plugin (TypeScript)\nDESCRIPTION: This snippet introduces the use of the '.guard()' method to globally specify parameter validation for subsequent routes within the plugin. The guard enforces that any route defined after its declaration automatically validates 'index' parameter as a number, removing the need for redundant per-route type definitions. This pattern increases maintainability and reduces code repetition for plugins with many similar routes.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nclass Note {\n    constructor(public data: string[] = ['Moonhalo']) {}\n\n    add(note: string) {\n        this.data.push(note)\n\n        return this.data\n    }\n\n    remove(index: number) {\n        return this.data.splice(index, 1)\n    }\n\n    update(index: number, note: string) {\n        return (this.data[index] = note)\n    }\n}\n\n// ---cut---\nexport const note = new Elysia({ prefix: '/note' })\n    .decorate('note', new Note())\n    .get('/', ({ note }) => note.data)\n    .put('/', ({ note, body: { data } }) => note.add(data), {\n        body: t.Object({\n            data: t.String()\n        })\n    })\n    .guard({ // [!code ++]\n        params: t.Object({ // [!code ++]\n            index: t.Number() // [!code ++]\n        }) // [!code ++]\n    }) // [!code ++]\n    .get(\n        '/:index',\n        ({ note, params: { index }, error }) => {\n            return note.data[index] ?? error(404, 'Not Found :(')\n        },\n        { // [!code --]\n            params: t.Object({ // [!code --]\n                index: t.Number() // [!code --]\n            }) // [!code --]\n        } // [!code --]\n    )\n    .delete(\n        '/:index',\n        ({ note, params: { index }, error }) => {\n            if (index in note.data) return note.remove(index)\n\n            return error(422)\n        },\n        { // [!code --]\n            params: t.Object({ // [!code --]\n                index: t.Number() // [!code --]\n            }) // [!code --]\n        } // [!code --]\n    )\n    .patch(\n        '/:index',\n        ({ note, params: { index }, body: { data }, error }) => {\n            if (index in note.data) return note.update(index, data)\n\n            return error(422)\n        },\n        {\n            params: t.Object({ // [!code --]\n                index: t.Number() // [!code --]\n            }), // [!code --]\n            body: t.Object({\n                data: t.String()\n            })\n        }\n    )\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Error Handling in Elysia.js\nDESCRIPTION: Demonstrates how to create and handle custom errors with type support in Elysia.js. The code shows error class definition and error handling with type narrowing and auto-completion.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-06.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nclass CustomError extends Error {\n    constructor(public message: string) {\n        super(message)\n    }\n}\n\nnew Elysia()\n    .addError({\n        MyError: CustomError\n    })\n    .onError(({ code, error }) => {\n        switch(code) {\n            // With auto-completion\n            case 'MyError':\n                // With type narrowing\n                // Error is typed as CustomError\n                return error\n        }\n    })\n```\n\n----------------------------------------\n\nTITLE: Basic Response Handling in Elysia\nDESCRIPTION: Demonstrates basic response handling in Elysia using both implicit and explicit Response objects.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    // Equivalent to \"new Response('hi')\"\n    .get('/', () => 'hi')\n    .listen(3000)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/', () => new Response('hi'))\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Injecting and Referencing ElysiaJS Models in Routes (TypeScript)\nDESCRIPTION: Shows how to define named models using `Elysia().model()` (e.g., mapping 'auth.sign' to `customBody`) and then reference these models by their string key within route definitions (`.post()`). This pattern leverages Elysia's reference model system for validation, providing benefits like autocompletion, schema modification, OpenAPI compatibility, and improved type inference speed. Requires the 'elysia' package.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/best-practice.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nconst customBody = t.Object({\n\tusername: t.String(),\n\tpassword: t.String()\n})\n\nconst AuthModel = new Elysia()\n    .model({\n        'auth.sign': customBody\n    })\n\nconst models = AuthModel.models\n\nconst UserController = new Elysia({ prefix: '/auth' })\n    .use(AuthModel)\n    .post('/sign-in', async ({ body, cookie: { session } }) => {\n                             // ^?\n\n        return true\n    }, {\n        body: 'auth.sign'\n    })\n```\n\n----------------------------------------\n\nTITLE: Creating a Note Management System with Elysia.js\nDESCRIPTION: Note management module implementing a CRUD system for notes with authentication integration. It defines a Note class, validation models, and endpoints for retrieving, creating, updating, and deleting notes.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { getUserId, userService } from './user'\n\nconst memo = t.Object({\n    data: t.String(),\n    author: t.String()\n})\n\ntype Memo = typeof memo.static\n\nclass Note {\n    constructor(\n        public data: Memo[] = [\n            {\n                data: 'Moonhalo',\n                author: 'saltyaom'\n            }\n        ]\n    ) {}\n\n    add(note: Memo) {\n        this.data.push(note)\n\n        return this.data\n    }\n\n    remove(index: number) {\n        return this.data.splice(index, 1)\n    }\n\n    update(index: number, note: Partial<Memo>) {\n        return (this.data[index] = { ...this.data[index], ...note })\n    }\n}\n\nexport const note = new Elysia({ prefix: '/note' })\n    .use(userService)\n    .decorate('note', new Note())\n    .model({\n        memo: t.Omit(memo, ['author'])\n    })\n    .onTransform(function log({ body, params, path, request: { method } }) {\n        console.log(`${method} ${path}`, {\n            body,\n            params\n        })\n    })\n    .get('/', ({ note }) => note.data)\n    .use(getUserId)\n    .put(\n        '/',\n        ({ note, body: { data }, username }) =>\n            note.add({ data, author: username }),\n        {\n            body: 'memo'\n        }\n    )\n    .get(\n        '/:index',\n        ({ note, params: { index }, error }) => {\n            return note.data[index] ?? error(404, 'Not Found :(')\n        },\n        {\n            params: t.Object({\n                index: t.Number()\n            })\n        }\n    )\n    .guard({\n        params: t.Object({\n            index: t.Number()\n        })\n    })\n    .delete('/:index', ({ note, params: { index }, error }) => {\n        if (index in note.data) return note.remove(index)\n\n        return error(422)\n    })\n    .patch(\n        '/:index',\n        ({ note, params: { index }, body: { data }, error, username }) => {\n            if (index in note.data)\n                return note.update(index, { data, author: username })\n\n            return error(422)\n        },\n        {\n            isSignIn: true,\n            body: 'memo'\n        }\n    )\n```\n\n----------------------------------------\n\nTITLE: Model Definition Using Elysia Validation\nDESCRIPTION: Demonstrates the correct way to define models using Elysia's built-in validation system.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/structure.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nconst customBody = t.Object({\n\tusername: t.String(),\n\tpassword: t.String()\n})\n\ntype CustomBody = typeof customBody.static\n\nexport { customBody }\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Post Endpoint with Elysia and Supabase - TypeScript\nDESCRIPTION: Implements a '/post/create' endpoint for inserting new blog posts into a Postgres 'post' table, using Supabase for database access. The endpoint expects a 'detail' string in the request body and inserts it into the table, returning the created row's ID. Dependencies include Elysia, type definitions ('t'), and the Supabase client. Inputs are properly shaped bodies matching the schema; outputs are the new post's database identifier or an error. Limitation: user_id association is noted as a TODO and not yet implemented.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-supabase.md#2025-04-23_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\n// src/modules/post/index.ts\nimport { Elysia, t } from 'elysia'\n\nimport { supabase } from '../../libs'\n\nexport const post = (app: Elysia) =>\n    app.group('/post', (app) =>\n        app.put(\n            '/create',\n            async ({ body }) => {\n                const { data, error } = await supabase\n                    .from('post')\n                    .insert({\n                        // Add user_id somehow\n                        // user_id: userId,\n                        ...body\n                    })\n                    .select('id')\n\n                if (error) throw error\n\n                return data[0]\n            },\n            {\n                schema: {\n                    body: t.Object({\n                        detail: t.String()\n                    })\n                }\n            }\n        )\n    )\n```\n\n----------------------------------------\n\nTITLE: Error Handling with Eden Treaty\nDESCRIPTION: This code shows how to handle errors with Eden Treaty, which returns both data and error properties. It demonstrates error status code checking and type narrowing with appropriate error handling based on different HTTP status codes.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/legacy.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// response type: { id: 1895, name: 'Skadi' }\nconst { data: nendoroid, error } = app.mirror.post({\n    id: 1895,\n    name: 'Skadi'\n})\n\nif(error) {\n    switch(error.status) {\n        case 400:\n        case 401:\n            warnUser(error.value)\n            break\n\n        case 500:\n        case 502:\n            emergencyCallDev(error.value)\n            break\n\n        default:\n            reportError(error.value)\n            break\n    }\n\n    throw error\n}\n\nconst { id, name } = nendoroid\n```\n\n----------------------------------------\n\nTITLE: Implementing Swagger Documentation in ElysiaJS\nDESCRIPTION: Shows how to integrate Swagger documentation with ElysiaJS using the @elysiajs/swagger plugin. Includes response type definitions and field selection.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/with-prisma.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { PrismaClient } from '@prisma/client'\nimport { swagger } from '@elysiajs/swagger'\n\nconst db = new PrismaClient()\n\nconst app = new Elysia()\n    .use(swagger())\n    .post(\n        '/',\n        async ({ body }) =>\n            db.user.create({\n                data: body,\n                select: {\n                    id: true,\n                    username: true\n                }\n            }),\n        {\n            error({ code }) {\n                switch (code) {\n                    case 'P2002':\n                        return {\n                            error: 'Username must be unique'\n                        }\n                }\n            },\n            body: t.Object({\n                username: t.String(),\n                password: t.String({\n                    minLength: 8\n                })\n            }),\n            response: t.Object({\n                id: t.Number(),\n                username: t.String()\n            })\n        }\n    )\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Error Handling in Elysia.js\nDESCRIPTION: This snippet shows how to add an error listener to an Elysia.js application. It catches all errors except 404 Not Found and logs them to the console. The error handler is applied before the routes to ensure it covers all child instances.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { swagger } from '@elysiajs/swagger'\n\nimport { note } from './note'\nimport { user } from './user'\n\nconst app = new Elysia()\n    .use(swagger())\n    .onError(({ error, code }) => {\n        if (code === 'NOT_FOUND') return\n\n        console.error(error)\n    })\n    .use(user)\n    .use(note)\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTPS/TLS in Elysia\nDESCRIPTION: Shows how to enable HTTPS by configuring TLS with certificate and key files. This example demonstrates enabling secure connections using Elysia's file utility to load the certificate files.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/configuration.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, file } from 'elysia'\n\nnew Elysia({\n\tserve: {\n\t\ttls: {\n\t\t\tcert: file('cert.pem'),\n\t\t\tkey: file('key.pem')\n\t\t}\n\t}\n})\n```\n\n----------------------------------------\n\nTITLE: Using Scoped Lifecycles for Authentication in ElysiaJS\nDESCRIPTION: Demonstrates how to properly scope lifecycles in ElysiaJS to allow parent modules to access authentication data from child modules. Uses the 'as: scoped' property to make authentication data available to parent routes.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nexport const userService = new Elysia({ name: 'user/service' })\n    .state({\n        user: {} as Record<string, string>,\n        session: {} as Record<number, string>\n    })\n    .model({\n        signIn: t.Object({\n            username: t.String({ minLength: 1 }),\n            password: t.String({ minLength: 8 })\n        }),\n        session: t.Cookie(\n            {\n                token: t.Number()\n            },\n            {\n                secrets: 'seia'\n            }\n        ),\n        optionalSession: t.Optional(t.Ref('session'))\n    })\n    .macro({\n        isSignIn(enabled: boolean) {\n            if (!enabled) return\n\n            return {\n            \tbeforeHandle({ error, cookie: { token }, store: { session } }) {\n                    if (!token.value)\n                        return error(401, {\n                            success: false,\n                            message: 'Unauthorized'\n                        })\n\n                    const username = session[token.value as unknown as number]\n\n                    if (!username)\n                        return error(401, {\n                            success: false,\n                            message: 'Unauthorized'\n                        })\n                }\n            }\n        }\n    })\n\nexport const getUserId = new Elysia()\n    .use(userService)\n    .guard({\n    \tas: 'scoped', // [!code ++]\n    \tisSignIn: true,\n        cookie: 'session'\n    })\n    .resolve(\n    \t{ as: 'scoped' }, // [!code ++]\n     \t({ store: { session }, cookie: { token } }) => ({\n        \tusername: session[token.value]\n      \t})\n    )\n\nexport const user = new Elysia({ prefix: '/user' })\n\t.use(getUserId)\n\t.get('/profile', ({ username }) => ({\n\t\t                 // ^?\n        success: true,\n        username\n    }))\n```\n\n----------------------------------------\n\nTITLE: Creating Unit Tests for ElysiaJS using Bun Test Runner\nDESCRIPTION: This code snippet demonstrates how to create a basic unit test for an ElysiaJS application using Bun's built-in test runner. It tests a simple GET request to the root endpoint.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/unit-test.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// test/index.test.ts\nimport { describe, expect, it } from 'bun:test'\nimport { Elysia } from 'elysia'\n\ndescribe('Elysia', () => {\n    it('return a response', async () => {\n        const app = new Elysia().get('/', () => 'hi')\n\n        const response = await app\n            .handle(new Request('http://localhost/'))\n            .then((res) => res.text())\n\n        expect(response).toBe('hi')\n    })\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Parser in Elysia.js\nDESCRIPTION: Shows how to register and use a custom parser for handling specific content types\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .parser('custom', ({ request, contentType }) => {\n        if (contentType === 'application/elysia') return request.text()\n    })\n    .post('/', ({ body }) => body, {\n        parse: ['custom', 'json']\n    })\n```\n\n----------------------------------------\n\nTITLE: Integrating Swagger Documentation with Elysia\nDESCRIPTION: Shows how to integrate Swagger documentation into an Elysia application. Demonstrates the use of plugins for extending functionality.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/index.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport swagger from '@elysiajs/swagger'\n\nnew Elysia()\n\t.use(swagger())\n\t.use(character)\n\t.use(auth)\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Handling Empty Body with Required Query Parameters in Eden Treaty\nDESCRIPTION: This snippet shows how to handle cases where the body is optional or not needed, but query parameters are required in Eden Treaty.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/parameters.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { treaty } from '@elysiajs/eden'\n\nconst app = new Elysia()\n    .post('/user', () => 'hi', {\n        query: t.Object({\n            name: t.String()\n        })\n    })\n    .listen(3000)\n\nconst api = treaty<typeof app>('localhost:3000')\n\napi.user.post(null, {\n    query: {\n        name: 'Ely'\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Exporting Elysia Server Type for Eden Treaty in TypeScript\nDESCRIPTION: This snippet demonstrates how to set up an Elysia server with various routes and export its type for use with Eden Treaty. It includes GET and POST routes with parameter and body validation.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/overview.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n    .get('/hi', () => 'Hi Elysia')\n    .get('/id/:id', ({ params: { id } }) => id)\n    .post('/mirror', ({ body }) => body, {\n        body: t.Object({\n            id: t.Number(),\n            name: t.String()\n        })\n    })\n    .listen(3000)\n\nexport type App = typeof app\n```\n\n----------------------------------------\n\nTITLE: Setting up Eden Treaty Test with ElysiaJS\nDESCRIPTION: Example of creating a basic integration test using Eden Treaty and Bun test runner. This setup demonstrates testing a simple GET endpoint with type safety and auto-completion support.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/test.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// test/index.test.ts\nimport { describe, expect, it } from 'bun:test'\n\nimport { edenTreaty } from '@elysiajs/eden'\n\nconst app = new Elysia()\n    .get('/', () => 'hi')\n    .listen(3000)\n\nconst api = edenTreaty<typeof app>('http://localhost:3000')\n\ndescribe('Elysia', () => {\n    it('return a response', async () => {\n        const { data } = await api.get()\n\n        expect(data).toBe('hi')\n    })\n})\n```\n\n----------------------------------------\n\nTITLE: WebSocket Message Validation in ElysiaJS\nDESCRIPTION: Shows how to implement message validation for WebSocket connections using schemas, including query parameters and message body validation.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/websocket.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n    .ws('/ws', {\n        // validate incoming message\n        body: t.Object({\n            message: t.String()\n        }),\n        query: t.Object({\n            id: t.String()\n        }),\n        message(ws, { message }) {\n            // Get schema from `ws.data`\n            const { id } = ws.data.query\n            ws.send({\n                id,\n                message,\n                time: Date.now()\n            })\n        }\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Cookie Type for Cookie Validation in ElysiaJS\nDESCRIPTION: Demonstrates how to create a validator for cookies, which extends the Object type and can include properties specific to cookies.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/type.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nt.Cookie({\n    name: t.String()\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Headers with Trace in Elysia\nDESCRIPTION: This snippet demonstrates how to use the trace API to add a custom header that shows the elapsed time for the beforeHandle lifecycle event. It uses the onStop callback to capture the timing information and add it to the response headers.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/trace.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst app = new Elysia()\n\t.trace(({ onBeforeHandle, set }) => {\n\t\tonBeforeHandle(({ onStop }) => {\n\t\t\tonStop(({ elapsed }) => {\n\t\t\t\tset.headers['X-Elapsed'] = elapsed.toString()\n\t\t\t})\n\t\t})\n\t})\n\t.get('/', () => 'Hi')\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Basic Swagger Integration in ElysiaJS\nDESCRIPTION: Basic setup to integrate Swagger documentation with an Elysia server, demonstrating route definition and server initialization\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/swagger.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { swagger } from '@elysiajs/swagger'\n\nnew Elysia()\n    .use(swagger())\n    .get('/', () => 'hi')\n    .post('/hello', () => 'world')\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Inferring ElysiaJS Handler Type using InferHandler Utility (TypeScript)\nDESCRIPTION: Demonstrates using the `InferHandler` utility type to infer the complete type signature for an ElysiaJS route handler. It takes the Elysia instance, the route path, and the route's schema (body, response, etc.) to provide strong typing for the handler's context, parameters, and expected return type.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, type InferHandler } from 'elysia'\n\nconst setup = new Elysia()\n\t.state('a', 'a')\n\t.decorate('b', 'b')\n\ntype Handler = InferHandler<\n\t// Elysia instance to based on\n\ttypeof setup,\n\t// path\n\t'/path',\n\t// schema\n\t{\n\t\tbody: string\n\t\tresponse: {\n\t\t\t200: string\n\t\t}\n\t}\n>\n\nconst handler: Handler = ({ body }) => body\n\nconst app = new Elysia()\n\t.get('/', handler)\n```\n\n----------------------------------------\n\nTITLE: Basic CORS Plugin Usage in ElysiaJS\nDESCRIPTION: Basic implementation of the CORS plugin in an Elysia application that accepts requests from any origin\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/cors.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { cors } from '@elysiajs/cors'\n\nnew Elysia().use(cors()).listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Handling Note Retrieval with Error Handling in Elysia.js\nDESCRIPTION: Code snippet that retrieves a note by index from the data store, returning a 404 error if the note doesn't exist. It includes validation for the index parameter using Elysia's type system.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n({ note, params: { index }, error }) => {\n            return note.data[index] ?? error(404, 'oh no :(')\n        },\n        {\n            params: t.Object({\n                index: t.Number()\n            })\n        }\n```\n\n----------------------------------------\n\nTITLE: Setting Up Elysia Routes in Astro\nDESCRIPTION: Creates an Elysia server instance in an Astro catch-all route file, defining API endpoints and exporting request handlers for different HTTP methods. This allows Elysia to handle API requests within the Astro application.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/astro.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// pages/[...slugs].ts\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n    .get('/api', () => 'hi')\n    .post('/api', ({ body }) => body, {\n        body: t.Object({\n            name: t.String()\n        })\n    })\n\nconst handle = ({ request }: { request: Request }) => app.handle(request) // [!code ++]\n\nexport const GET = handle // [!code ++]\nexport const POST = handle // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Monitoring Child Events in Elysia's Lifecycle\nDESCRIPTION: This example shows how to track the performance of child events within a lifecycle phase. It uses onBeforeHandle to count the total number of child events and captures timing information for each one using the onEvent and onStop callbacks.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/trace.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst sleep = (time = 1000) =>\n    new Promise((resolve) => setTimeout(resolve, time))\n\nconst app = new Elysia()\n    .trace(async ({ onBeforeHandle }) => {\n        onBeforeHandle(({ total, onEvent }) => {\n            console.log('total children:', total)\n\n            onEvent(({ onStop }) => {\n                onStop(({ elapsed }) => {\n                    console.log('child took', elapsed, 'ms')\n                })\n            })\n        })\n    })\n    .get('/', () => 'Hi', {\n        beforeHandle: [\n            function setup() {},\n            async function delay() {\n                await sleep()\n            }\n        ]\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Grouping Routes by Prefix with Elysia.group (TypeScript)\nDESCRIPTION: Demonstrates usage of Elysia.group to bundle related API endpoints under a common prefix, reducing duplication. The example puts all user-related POST endpoints within a '/user' group. Requires Elysia imported. The callback receives an app router instance for defining grouped routes. All outputs and behavior match the ungrouped version but are organized for maintainability.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/route.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .group('/user', (app) =>\n        app\n            .post('/sign-in', 'Sign in')\n            .post('/sign-up', 'Sign up')\n            .post('/profile', 'Profile')\n    )\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Basic ElysiaJS Route Setup\nDESCRIPTION: Example of setting up basic routes in ElysiaJS with different HTTP methods.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst app = new Elysia()\n    .get('/', () => 'Hello Elysia')\n    .get('/hello', 'Do you miss me?')\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Creating a Unit Test with Eden Treaty in TypeScript\nDESCRIPTION: This snippet demonstrates how to set up a unit test for an Elysia application using Eden Treaty. It creates a simple Elysia server with a GET endpoint, initializes the Eden Treaty client with the server instance, and tests that the endpoint returns the expected response. This approach provides end-to-end type safety without sending actual network requests.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/unit-test.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// test/index.test.ts\nimport { describe, expect, it } from 'bun:test'\nimport { Elysia } from 'elysia'\nimport { treaty } from '@elysiajs/eden'\n\nconst app = new Elysia().get('/hello', 'hi')\nconst api = treaty(app)\n\ndescribe('Elysia', () => {\n    it('return a response', async () => {\n        const { data } = await api.hello.get()\n\n        expect(data).toBe('hi')\n              // ^?\n\n    })\n})\n```\n\n----------------------------------------\n\nTITLE: Request Parameter Transformation in Elysia.js\nDESCRIPTION: Example of using transform to convert URL parameters to numeric values before validation\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n    .get('/id/:id', ({ params: { id } }) => id, {\n        params: t.Object({\n            id: t.Number()\n        }),\n        transform({ params }) {\n            const id = +params.id\n\n            if (!Number.isNaN(id)) params.id = id\n        }\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Mutating ElysiaJS State Using References vs. Values (TypeScript)\nDESCRIPTION: Highlights the importance of using references when mutating state managed by ElysiaJS. Accessing `store.counter++` directly modifies the shared state correctly. In contrast, destructuring the primitive `counter` from `store` (`{ store: { counter } }`) creates a local copy, and modifying it does not affect the global state.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .state('counter', 0)\n    // âœ… Using reference, value is shared\n    .get('/', ({ store }) => store.counter++)\n    // âŒ Creating a new variable on primitive value, the link is lost\n    .get('/error', ({ store: { counter } }) => counter)\n```\n\n----------------------------------------\n\nTITLE: Implementing Swagger Documentation\nDESCRIPTION: Adding Swagger documentation to ElysiaJS application using @elysiajs/swagger plugin.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { swagger } from '@elysiajs/swagger'\n\nconst app = new Elysia()\n    .use(swagger())\n    .get('/', ({ path }) => path)\n    .post('/hello', 'Do you miss me?')\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Implementing Role-Based Access Control with Macro API in Elysia\nDESCRIPTION: This snippet demonstrates how to use the new Macro API in Elysia 0.8 to implement role-based access control. It shows the usage of a custom 'role' field in route configuration.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-08.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { auth } from '@services/auth'\n\nconst app = new Elysia()\n    .use(auth)\n    .get('/', ({ user }) => user.profile, {\n        role: 'admin'\n    })\n```\n\n----------------------------------------\n\nTITLE: Streaming Responses in Elysia\nDESCRIPTION: Shows how to implement streaming responses using generator functions and handle headers in streams.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst app = new Elysia()\n\t.get('/ok', function* () {\n\t\tyield 1\n\t\tyield 2\n\t\tyield 3\n\t})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst app = new Elysia()\n\t.get('/ok', function* ({ set }) {\n\t\t// This will set headers\n\t\tset.headers['x-name'] = 'Elysia'\n\t\tyield 1\n\t\tyield 2\n\n\t\t// This will do nothing\n\t\tset.headers['x-id'] = '1'\n\t\tyield 3\n\t})\n```\n\n----------------------------------------\n\nTITLE: Implementing Note Service with Author Authentication in Elysia.js\nDESCRIPTION: Complete implementation of the note service with authorization. Defines a memo schema for notes with author field, updates the Note class to track authorship, and integrates with user authentication for protected operations.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nconst memo = t.Object({ // [!code ++]\n\tdata: t.String(), // [!code ++]\n\tauthor: t.String() // [!code ++]\n}) // [!code ++]\n\ntype Memo = typeof memo.static // [!code ++]\n\nclass Note {\n    constructor(public data: string[] = ['Moonhalo']) {} // [!code --]\n    constructor( // [!code ++]\n\t\tpublic data: Memo[] = [ // [!code ++]\n\t\t\t{ // [!code ++]\n\t\t\t\tdata: 'Moonhalo', // [!code ++]\n\t\t\t\tauthor: 'saltyaom' // [!code ++]\n\t\t\t} // [!code ++]\n\t\t] // [!code ++]\n\t) {} // [!code ++]\n\n    add(note: string) { // [!code --]\n    add(note: Memo) { // [!code ++]\n        this.data.push(note)\n\n        return this.data\n    }\n\n    remove(index: number) {\n        return this.data.splice(index, 1)\n    }\n\n    update(index: number, note: string) { // [!code --]\n        return (this.data[index] = note) // [!code --]\n    } // [!code --]\n    update(index: number, note: Partial<Memo>) { // [!code ++]\n        return (this.data[index] = { ...this.data[index], ...note }) // [!code ++]\n    } // [!code ++]\n}\n\nexport const note = new Elysia({ prefix: '/note' })\n    .decorate('note', new Note())\n    .model({ // [!code ++]\n    \tmemo: t.Omit(memo, ['author']) // [!code ++]\n    }) // [!code ++]\n    .onTransform(function log({ body, params, path, request: { method } }) {\n        console.log(`${method} ${path}`, {\n            body,\n            params\n        })\n    })\n    .get('/', ({ note }) => note.data)\n    .put('/', ({ note, body: { data } }) => note.add(data), { // [!code --]\n        body: t.Object({ // [!code --]\n            data: t.String() // [!code --]\n        }), // [!code --]\n    }) // [!code --]\n    .put('/', ({ note, body: { data }, username }) =>\n    \tnote.add({ data, author: username }),\n     \t{ // [!code ++]\n     \t\tbody: 'memo' // [!code ++]\n      \t}\n    ) // [!code ++]\n    .guard({\n        params: t.Object({\n            index: t.Number()\n        })\n    })\n    .get(\n        '/:index',\n        ({ note, params: { index }, error }) => {\n            return note.data[index] ?? error(404, 'Not Found :(')\n        }\n    )\n    .delete(\n        '/:index',\n        ({ note, params: { index }, error }) => {\n            if (index in note.data) return note.remove(index)\n\n            return error(422)\n        }\n    )\n    .patch(\n        '/:index',\n        ({ note, params: { index }, body: { data }, error }) => { // [!code --]\n            if (index in note.data) return note.update(index, data) // [!code --]\n        ({ note, params: { index }, body: { data }, error, username }) => { // [!code ++]\n        \tif (index in note.data) // [!code ++]\n         \t\treturn note.update(index, { data, author: username })) // [!code ++]\n\n            return error(422)\n        },\n        {\n            body: t.Object({ // [!code --]\n                data: t.String() // [!code --]\n            }), // [!code --]\n            body: 'memo'\n        }\n    )\n```\n\n----------------------------------------\n\nTITLE: Custom 404 Error Handling in Elysia Using .onError (TypeScript)\nDESCRIPTION: This code shows how to override Elysia's default 404 NOT_FOUND response using the .onError lifecycle hook. If a route isn't found, 'Route not found :(' is returned instead of the standard 404 text. Requires Elysia imported and proper initialization. The error hook inspects the 'code' parameter for 'NOT_FOUND'. Limitation: Only overrides NOT_FOUND cases unless expanded.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/route.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/', 'hi')\n    .onError(({ code }) => {\n        if (code === 'NOT_FOUND') {\n            return 'Route not found :('\n        }\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Implementing Trace v2 in Elysia\nDESCRIPTION: Shows how to use the new Trace v2 API in Elysia, which provides synchronous tracing capabilities and allows for more precise timing of events and lifecycle hooks.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-11.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.trace(({ onBeforeHandle, set }) => {\n\t\t// Listen to before handle event\n\t\tonBeforeHandle(({ onEvent }) => {\n\t\t\t// Listen to all child event in order\n\t\t\tonEvent(({ onStop, name }) => {\n\t\t\t\t// Execute something after a child event is finished\n\t\t\t\tonStop(({ elapsed }) => {\n\t\t\t\t\tconsole.log(name, 'took', elapsed, 'ms')\n\n\t\t\t\t\t// callback is executed synchronously before next event\n\t\t\t\t\tset.headers['x-trace'] = 'true'\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t})\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Macro for Role Validation in Elysia\nDESCRIPTION: This code snippet shows how to create a custom macro for role validation in Elysia 0.8. It demonstrates accessing the lifecycle stack and adding a beforeHandle event for role validation.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-08.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst plugin = new Elysia({ name: 'plugin' }).macro(({ beforeHandle }) => {\n    return {\n        role(type: 'admin' | 'user') {\n            beforeHandle(\n                { insert: 'before' },\n                async ({ cookie: { session } }) => {\n                  const user = await validateSession(session.value)\n                  await validateRole('admin', user)\n}\n            )\n        }\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Plugin System Usage\nDESCRIPTION: Shows how to create and use plugins in Elysia\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/cheat-sheet.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst plugin = new Elysia()\n    .state('plugin-version', 1)\n    .get('/hi', () => 'hi')\n\nnew Elysia()\n    .use(plugin)\n    .get('/version', ({ store }) => store['plugin-version'])\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Implementing Interceptor Hook for HTML Content Type\nDESCRIPTION: Demonstrates how to use an interceptor hook to automatically set Content-Type headers for HTML responses across multiple routes.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { isHtml } from '@elysiajs/html'\n\nnew Elysia()\n    .get('/none', () => '<h1>Hello World</h1>')\n    .onAfterHandle(({ response, set }) => {\n        if (isHtml(response))\n            set.headers['Content-Type'] = 'text/html; charset=utf8'\n    })\n    .get('/', () => '<h1>Hello World</h1>')\n    .get('/hi', () => '<h1>Hello World</h1>')\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Using Dynamic Paths with Path Parameters in ElysiaJS\nDESCRIPTION: This snippet illustrates how to use dynamic paths with path parameters in ElysiaJS. It shows how to extract and use the 'id' parameter from the URL.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/route.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/id/:id', ({ params: { id } }) => id)\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Implementing Security with Bearer Authentication\nDESCRIPTION: Configuration example for implementing JWT-based Bearer Authentication in Swagger documentation\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/swagger.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\napp.use(\n    swagger({\n        documentation: {\n            components: {\n                securitySchemes: {\n                    bearerAuth: {\n                        type: 'http',\n                        scheme: 'bearer',\n                        bearerFormat: 'JWT'\n                    }\n                }\n            }\n        }\n    })\n)\n\nexport const addressController = new Elysia({\n    prefix: '/address',\n    detail: {\n        tags: ['Address'],\n        security: [\n            {\n                bearerAuth: []\n            }\n        ]\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Enforcing Scoped Response Schema with ElysiaJS Guard\nDESCRIPTION: Illustrates using `guard` with `as: 'scoped'` to apply a shared response schema (`t.String()`) to all routes within the guarded instance (`plugin`) and its direct parent (`instance`). This ensures type safety across these routes. Routes returning non-string types (`/not-ok`, `/no-ok-parent`) will result in type errors, while routes outside the scope (`/ok` in `parent`) are unaffected. Requires `elysia` and `t` (presumably from Elysia's type system) imports.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-11.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// @errors: 2304 2345\nimport { Elysia, t } from 'elysia'\n\nconst plugin = new Elysia()\n\t.guard({\n\t\tas: 'scoped',\n\t\tresponse: t.String()\n\t})\n\t.get('/ok', () => 'ok')\n\t.get('/not-ok', () => 1)\n\nconst instance = new Elysia()\n\t.use(plugin)\n\t.get('/no-ok-parent', () => 2)\n\nconst parent = new Elysia()\n\t.use(instance)\n\t// This is fine because response is defined as scoped\n\t.get('/ok', () => 3)\n```\n\n----------------------------------------\n\nTITLE: Composing Multiple Elysia Projects\nDESCRIPTION: Shows how to combine multiple existing Elysia projects into a single application using the mount method, allowing for modular application composition.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-06.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport A from 'project-a/elysia'\nimport B from 'project-b/elysia'\nimport C from 'project-c/elysia'\n\nnew Elysia()\n    .mount(A)\n    .mount(B)\n    .mount(C)\n```\n\n----------------------------------------\n\nTITLE: Method Chaining in ElysiaJS\nDESCRIPTION: This snippet demonstrates the importance of method chaining in ElysiaJS for maintaining type inference. It shows how to properly chain methods to ensure type integrity.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/key-concept.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .state('build', 1)\n    .get('/', ({ store: { build } }) => build)\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Implementing Model Injection with Elysia Reference Models\nDESCRIPTION: Demonstrates how to create and inject a custom authentication model using Elysia's reference model pattern. The example shows the creation of a validation schema for authentication data and its integration into a controller route. This approach enables model naming, auto-completion, schema modification capabilities, and OpenAPI compliance.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/structure.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nconst customBody = t.Object({\n\tusername: t.String(),\n\tpassword: t.String()\n})\n\nconst AuthModel = new Elysia()\n    .model({\n        'auth.sign': customBody\n    })\n\nconst UserController = new Elysia({ prefix: '/auth' })\n    .use(AuthModel)\n    .post('/sign-in', async ({ body, cookie: { session } }) => {\n                             // ^?\n\n        return true\n    }, {\n        body: 'auth.sign'\n    })\n```\n\n----------------------------------------\n\nTITLE: WebSocket Implementation\nDESCRIPTION: Demonstrates setting up WebSocket functionality\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/cheat-sheet.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .ws('/ping', {\n        message(ws, message) {\n            ws.send('hello ' + message)\n        }\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Using Macro Options in ElysiaJS v1\nDESCRIPTION: Shows how to use the options parameter in a macro to control where the function is added in the lifecycle stack. The insert option specifies whether to add the function before or after existing functions.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/macro.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst plugin = new Elysia({ name: 'plugin' })\n    .macro(({ onBeforeHandle }) => {\n        return {\n            hi(word: string) {\n                onBeforeHandle(\n                    { insert: 'before' }, // [!code ++]\n                    () => {\n                        console.log(word)\n                    }\n                )\n            }\n        }\n    })\n```\n\n----------------------------------------\n\nTITLE: Configuring ElysiaJS Route Handler in Next.js\nDESCRIPTION: Sets up a basic ElysiaJS server within Next.js API route handler with GET and POST endpoints. Demonstrates route handling with path prefix '/api' and request body validation.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/nextjs.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// app/api/[[...slugs]]/route.ts\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia({ prefix: '/api' })\n    .get('/', () => 'hello Next')\n    .post('/', ({ body }) => body, {\n        body: t.Object({\n            name: t.String()\n        })\n    })\n\nexport const GET = app.handle\nexport const POST = app.handle\n```\n\n----------------------------------------\n\nTITLE: Lifecycle Event Order Demonstration\nDESCRIPTION: Shows the execution order of different lifecycle events in Elysia, demonstrating how hooks are processed in sequence.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .onBeforeHandle(() => {\n        console.log('1')\n    })\n    .onAfterHandle(() => {\n        console.log('3')\n    })\n    .get('/', () => 'hi', {\n        beforeHandle() {\n            console.log('2')\n        }\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Data Normalization in Elysia 1.1\nDESCRIPTION: Demonstrates how Elysia 1.1 normalizes data according to the defined schema, removing additional fields and ensuring consistent data formats for both request and response.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-11.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { treaty } from '@elysiajs/eden'\n\nconst app = new Elysia()\n\t.post('/', ({ body }) => body, {\n\t\tbody: t.Object({\n\t\t\tname: t.String(),\n\t\t\tpoint: t.Number()\n\t\t}),\n\t\tresponse: t.Object({\n\t\t\tname: t.String()\n\t\t})\n\t})\n\nconst { data } = await treaty(app).index.post({\n\tname: 'SaltyAom',\n\tpoint: 9001,\n\t// âš ï¸ additional field\n\ttitle: 'maintainer'\n})\n\n// 'point' is removed as defined in response\nconsole.log(data) // { name: 'SaltyAom' }\n```\n\n----------------------------------------\n\nTITLE: Nesting Multiple Frameworks with Mount\nDESCRIPTION: Demonstrates how to create deeply nested framework integration by mounting Elysia inside Hono inside Elysia, showcasing the interoperability between WinterCG-compliant frameworks.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-06.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst elysia = new Elysia()\n    .get('/Hello from Elysia inside Hono inside Elysia')\n\nconst hono = new Hono()\n    .get('/', (c) => c.text('Hello from Hono!'))\n    .mount('/elysia', elysia.fetch)\n\nconst main = new Elysia()\n    .get('/', () => 'Hello from Elysia')\n    .mount('/hono', hono.fetch)\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Error Handling and Response Validation in Elysia\nDESCRIPTION: Demonstrates error handling and response validation in Elysia. Shows how to define expected response types and handle custom error responses.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/index.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n\t.get('/profile', ({ error }) => {\n\t\tif(Math.random() > .5)\n\t\t\treturn error(418, 'Mika')\n\n\t\treturn 'ok'\n\t}, {\n\t\tresponse: {\n\t\t\t200: t.Literal('ok'),\n\t\t\t418: t.Literal('Nagisa')\n\t\t}\n\t})\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Initializing ElysiaJS with Basic Apollo GraphQL Setup\nDESCRIPTION: Demonstrates the basic setup of an ElysiaJS application using the `@elysiajs/apollo` plugin. It defines a simple GraphQL schema (`typeDefs`) with a `Book` type and a `books` query, along with corresponding resolvers (`resolvers`). The plugin is added via `.use()` and the server listens on port 3000.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/graphql-apollo.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { apollo, gql } from '@elysiajs/apollo'\n\nconst app = new Elysia()\n\t.use(\n\t\tapollo({\n\t\t\ttypeDefs: gql`\n\t\t\t\ttype Book {\n\t\t\t\t\ttitle: String\n\t\t\t\t\tauthor: String\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tbooks: [Book]\n\t\t\t\t}\n\t\t\t`,\n\t\t\tresolvers: {\n\t\t\t\tQuery: {\n\t\t\t\t\tbooks: () => {\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttitle: 'Elysia',\n\t\t\t\t\t\t\t\tauthor: 'saltyAom'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t)\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Components in ElysiaJS\nDESCRIPTION: This snippet shows how to create and use components in ElysiaJS. It demonstrates creating a store, a router, and an app, each as separate Elysia instances that can be combined.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/key-concept.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst store = new Elysia()\n\t.state({ visitor: 0 })\n\nconst router = new Elysia()\n\t.use(store)\n\t.get('/increase', ({ store }) => store.visitor++)\n\nconst app = new Elysia()\n\t.use(router)\n\t.get('/', ({ store }) => store)\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: WebSocket Configuration in ElysiaJS\nDESCRIPTION: Example of configuring WebSocket settings when initializing Elysia instance.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/websocket.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia({\n    websocket: {\n        idleTimeout: 30\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Basic GraphQL Server Setup\nDESCRIPTION: Example of setting up a basic GraphQL server with Elysia and GraphQL Yoga plugin, including type definitions and resolvers.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/graphql-yoga.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { yoga } from '@elysiajs/graphql-yoga'\n\nconst app = new Elysia()\n\t.use(\n\t\tyoga({\n\t\t\ttypeDefs: /* GraphQL */ `\n\t\t\t\ttype Query {\n\t\t\t\t\thi: String\n\t\t\t\t}\n\t\t\t`,\n\t\t\tresolvers: {\n\t\t\t\tQuery: {\n\t\t\t\t\thi: () => 'Hello from Elysia'\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t)\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Integrating OpenAI Chat Completion with ElysiaJS Stream - TypeScript\nDESCRIPTION: This snippet illustrates how to stream OpenAI ChatGPT responses directly to clients using ElysiaJS. It defines an endpoint '/ai' that wraps OpenAI's chat stream (an AsyncIterable) in the Stream class, automatically handling data flow. Assumes the OpenAI library is installed and initialized, and the Stream plugin is available.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/stream.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nnew Elysia()\n    .get(\n        '/ai',\n        ({ query: { prompt } }) =>\n            new Stream(\n                openai.chat.completions.create({\n                    model: 'gpt-3.5-turbo',\n                    stream: true,\n                    messages: [{\n                        role: 'user',\n                        content: prompt\n                    }]\n                })\n            )\n    )\n```\n\n----------------------------------------\n\nTITLE: Using Property Shorthand in Macro v2\nDESCRIPTION: Shows how to use property shorthand in Macro v2, where an object property is automatically converted to a function that accepts a boolean parameter. Both forms are functionally equivalent.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/macro.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nexport const auth = new Elysia()\n    .macro({\n    \t// This property shorthand\n    \tisAuth: {\n      \t\tresolve() {\n     \t\t\treturn {\n         \t\t\tuser: 'saltyaom'\n          \t\t}\n      \t\t}\n        },\n        // is equivalent to\n        isAuth(enabled: boolean) {\n        \tif(!enabled) return\n\n        \treturn {\n\t\t\t\tresolve() {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tuser\n\t\t\t\t\t}\n\t\t\t\t}\n         \t}\n        }\n    })\n```\n\n----------------------------------------\n\nTITLE: Adding Type Validation to User Sign-up Endpoint\nDESCRIPTION: Enhances the user sign-up endpoint with Elysia's type system for input validation. This ensures that the incoming request body matches the expected shape and updates TypeScript types accordingly.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/with-prisma.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { PrismaClient } from '@prisma/client'\n\nconst db = new PrismaClient()\n\nconst app = new Elysia()\n    .post(\n        '/sign-up', \n        async ({ body }) => db.user.create({\n            data: body\n        }),\n        {\n            body: t.Object({\n                username: t.String(),\n                password: t.String({\n                    minLength: 8\n                })\n            })\n        }\n    )\n    .listen(3000)\n\nconsole.log(\n    `ðŸ¦Š Elysia is running at ${app.server?.hostname}:${app.server?.port}`\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Apollo Context in ElysiaJS\nDESCRIPTION: Illustrates how to customize the Apollo GraphQL context within an ElysiaJS application. It defines an asynchronous `context` function that receives the Elysia context object (containing the standard `request`). This example extracts the 'Authorization' header from the incoming request and makes it available within the GraphQL resolver context.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/graphql-apollo.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new Elysia()\n\t.use(\n\t\tapollo({\n\t\t\ttypeDefs,\n\t\t\tresolvers,\n\t\t\tcontext: async ({ request }) => {\n\t\t\t\tconst authorization = request.headers.get('Authorization')\n\n\t\t\t\treturn {\n\t\t\t\t\tauthorization\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t)\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Scoping in ElysiaJS\nDESCRIPTION: This example illustrates the concept of scoping in ElysiaJS. It shows how to create a global scope for sharing properties between instances.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/key-concept.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst ip = new Elysia()\n\t.derive(\n\t\t{ as: 'global' },\n\t\t({ server, request }) => ({\n\t\t\tip: server?.requestIP(request)\n\t\t})\n\t)\n\t.get('/ip', ({ ip }) => ip)\n\nconst server = new Elysia()\n\t.use(ip)\n\t.get('/ip', ({ ip }) => ip)\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Using Better Auth Client in Frontend Applications\nDESCRIPTION: Example of implementing the Better Auth client in a frontend application. This demonstrates how to create an auth client and implement social login functionality with Google.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/better-auth.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAuthClient } from \"better-auth/client\"\nexport const authClient = createAuthClient({\n    baseURL: process.env.BETTER_AUTH_URL! \n})\n\nexport const signinGoogle = async () => {\n  const data = await authClient.signIn.social({\n    provider: \"google\",\n  });\n  \n  return data;\n};\n```\n\n----------------------------------------\n\nTITLE: Grouping ElysiaJS Models for Organization (TypeScript)\nDESCRIPTION: Illustrates how to group multiple ElysiaJS model definitions (e.g., `t.Object` for request/response schemas) into a single JavaScript object literal. This improves code organization and allows accessing models through a common namespace (e.g., `AuthModel.sign`). Requires the 'elysia' package and its 't' type builder.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/best-practice.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nexport const AuthModel = {\n\tsign: t.Object({\n\t\tusername: t.String(),\n\t\tpassword: t.String()\n\t})\n}\n\nconst models = AuthModel.models\n```\n\n----------------------------------------\n\nTITLE: JWT with Expiration Configuration\nDESCRIPTION: Example demonstrating how to set JWT expiration time in the configuration\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/jwt.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new Elysia()\n    .use(\n        jwt({\n            name: 'jwt',\n            secret: 'kunikuzushi',\n            exp: '7d'\n        })\n    )\n    .get('/sign/:name', async ({ jwt, params }) => jwt.sign(params))\n```\n\n----------------------------------------\n\nTITLE: Creating Configurable Plugins with Seed Values\nDESCRIPTION: Demonstrates how to create configurable plugins using the seed property to generate unique checksums based on configuration, allowing deduplication while preserving configuration options.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-06.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst plugin = (config) = new Elysia({\n    name: 'plugin',\n    seed: config\n})\n```\n\n----------------------------------------\n\nTITLE: Route Grouping\nDESCRIPTION: Demonstrates how to group routes under a common prefix\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/cheat-sheet.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get(\"/\", () => \"Hi\")\n    .group(\"/auth\", app => {\n        return app\n            .get(\"/\", () => \"Hi\")\n            .post(\"/sign-in\", ({ body }) => body)\n            .put(\"/sign-up\", ({ body }) => body)\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Implementing Request Logging with onTransform Lifecycle Hook in Elysia.js\nDESCRIPTION: This code implements a REST API for note management with request logging using the onTransform lifecycle hook. The hook captures and logs request method, path, body, and parameters before the request is validated, allowing for effective request tracking without triggering 404 errors for undefined routes.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport const note = new Elysia({ prefix: '/note' })\n    .decorate('note', new Note())\n    .onTransform(function log({ body, params, path, request: { method } }) { \n        console.log(`${method} ${path}`, { \n            body, \n            params \n        }) \n    }) \n    .get('/', ({ note }) => note.data)\n    .put('/', ({ note, body: { data } }) => note.add(data), {\n        body: t.Object({\n            data: t.String()\n        })\n    })\n    .guard({\n        params: t.Object({\n            index: t.Number()\n        })\n    })\n    .get('/:index', ({ note, params: { index }, error }) => {\n        return note.data[index] ?? error(404, 'Not Found :(')\n    })\n    .delete('/:index', ({ note, params: { index }, error }) => {\n        if (index in note.data) return note.remove(index)\n\n        return error(422)\n    })\n    .patch(\n        '/:index',\n        ({ note, params: { index }, body: { data }, error }) => {\n            if (index in note.data) return note.update(index, data)\n\n            return error(422)\n        },\n        {\n            body: t.Object({\n                data: t.String()\n            })\n        }\n    )\n```\n\n----------------------------------------\n\nTITLE: Using Trace to Monitor Handle Performance in Elysia\nDESCRIPTION: This snippet demonstrates how to use the trace API to measure the duration of the handle lifecycle event. It captures the execution time by registering listeners at the start and end of the event, then outputs the elapsed time in milliseconds.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/trace.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst app = new Elysia()\n    .trace(async ({ onHandle }) => {\n\t    onHandle(({ begin, onStop }) => {\n\t\t\tonStop(({ end }) => {\n        \t\tconsole.log('handle took', end - begin, 'ms')\n\t\t\t})\n\t    })\n    })\n    .get('/', () => 'Hi')\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Using Trace Listener in Elysia for Lifecycle Events\nDESCRIPTION: This example shows the structure of a trace listener for a specific lifecycle event (onBeforeHandle). The listener provides access to timing information and callbacks that execute when the lifecycle phase completes.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/trace.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst app = new Elysia()\n\t.trace(({ onBeforeHandle }) => {\n\t\t// This is trace listener\n\t\t// hover to view the type\n\t\tonBeforeHandle((parameter) => {\n\n\t\t})\n\t})\n\t.get('/', () => 'Hi')\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Implementing Different Path Types in ElysiaJS\nDESCRIPTION: This example shows how to implement static, dynamic, and wildcard paths in ElysiaJS. It demonstrates the priority order of these path types when resolving routes.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/route.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/id/1', 'static path')\n    .get('/id/:id', 'dynamic path')\n    .get('/id/*', 'wildcard path')\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Conditionally Enabling Server Timing in ElysiaJS (TypeScript)\nDESCRIPTION: Shows how to configure the Server Timing plugin to conditionally add timing headers based on the request. The 'allow' property takes a function that receives the request context (including the Request object) and returns true if timing should be enabled. In this example, timing is disabled for requests targeting the '/no-trace' path.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/server-timing.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { serverTiming } from '@elysiajs/server-timing'\n\nnew Elysia()\n    .use(\n        serverTiming({\n            allow: ({ request }) => {\n                return new URL(request.url).pathname !== '/no-trace'\n            }\n        })\n    )\n```\n\n----------------------------------------\n\nTITLE: File Upload with Eden Treaty in TypeScript using ElysiaJS\nDESCRIPTION: This snippet demonstrates how to handle file uploads using Eden Treaty, including setting up the server and client-side code for file submission.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/parameters.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { treaty } from '@elysiajs/eden'\n\nconst app = new Elysia()\n    .post('/image', ({ body: { image, title } }) => title, {\n        body: t.Object({\n            title: t.String(),\n            image: t.Files()\n        })\n    })\n    .listen(3000)\n\nexport const api = treaty<typeof app>('localhost:3000')\n\nconst images = document.getElementById('images') as HTMLInputElement\n\nconst { data } = await api.image.post({\n    title: \"Misono Mika\",\n    image: images.files!,\n})\n```\n\n----------------------------------------\n\nTITLE: Using Reactive Cookie API in Elysia\nDESCRIPTION: Example of using the new reactive cookie API in Elysia 0.7, where cookies are handled as reactive objects with automatic synchronization with headers.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-07.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\napp.get('/', ({ cookie: { name } }) => {\n    // Get\n    name.value\n\n    // Set\n    name.value = \"New Value\"\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Query Parameters and Fetch Options in Eden Treaty\nDESCRIPTION: This code demonstrates how to add query parameters and customize fetch options when making requests with Eden Treaty. The $query parameter is used for URL query strings, while $fetch allows setting any standard fetch API options.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/legacy.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\napp.get({\n    $query: {\n        name: 'Eden',\n        code: 'Gold'\n    }\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\napp.post({\n    $fetch: {\n        headers: {\n            'x-organization': 'MANTIS'\n        }\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Macros in Elysia for Authorization\nDESCRIPTION: Shows how to create custom macros in Elysia for handling authorization. Demonstrates the use of onBeforeHandle for role-based access control.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/index.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nconst role = new Elysia({ name: 'macro' })\n\t.macro(({ onBeforeHandle }) => ({\n\t\trole(type: 'user' | 'staff' | 'admin') {\n\t\t\tonBeforeHandle(({ headers, error }) => {\n\t\t\t\tif(headers.authorization !== type)\n\t\t\t\t\treturn error(401)\n\t\t\t})\n\t\t}\n\t}))\n\nnew Elysia()\n\t.use(role)\n\t.get('/admin/check', 'ok', {\n        r\n      // ^|\n\t})\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Proxying an External AI Stream Using Fetch in ElysiaJS - TypeScript\nDESCRIPTION: This code creates an '/ai' route in ElysiaJS that proxies a streaming response from an external service (e.g., Cloudflare AI). It constructs an API endpoint using environment variables, performs an authenticated POST request with streamed JSON, and passes the fetch result directlyâ€”leveraging the plugin's support for Response/ReadableStream inputs. Assumes all dependencies and required environment variables are properly set.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/stream.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst model = '@cf/meta/llama-2-7b-chat-int8'\nconst endpoint = `https://api.cloudflare.com/client/v4/accounts/${process.env.ACCOUNT_ID}/ai/run/${model}`\n\nnew Elysia()\n    .get('/ai', ({ query: { prompt } }) =>\n        fetch(endpoint, {\n            method: 'POST',\n            headers: {\n                authorization: `Bearer ${API_TOKEN}`,\n                'content-type': 'application/json'\n            },\n            body: JSON.stringify({\n                messages: [\n                    { role: 'system', content: 'You are a friendly assistant' },\n                    { role: 'user', content: prompt }\n                ]\n            })\n        })\n    )\n```\n\n----------------------------------------\n\nTITLE: Lifecycle Hooks Implementation\nDESCRIPTION: Shows how to use lifecycle hooks for request handling\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/cheat-sheet.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n    .onRequest(() => {\n        console.log('On request')\n    })\n    .on('beforeHandle', () => {\n        console.log('Before handle')\n    })\n    .post('/mirror', ({ body }) => body, {\n        body: t.Object({\n            username: t.String(),\n            password: t.String()\n        }),\n        afterHandle: () => {\n            console.log(\"After handle\")\n        }\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Defining Optional Path Parameters in ElysiaJS Routes\nDESCRIPTION: Shows how to define optional path parameters in ElysiaJS route paths by appending a question mark `?` to the parameter name (e.g., `/:id?`, `/:name?`). If the optional parameter is not provided in the request URL, its value will be `undefined` within the route handler's `params` object.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-11.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.get('/ok/:id?', ({ params: { id } }) => id)\n\t.get('/ok/:id/:name?', ({ params: { id, name } }) => name)\n```\n\n----------------------------------------\n\nTITLE: Managing Cookie Secret Rotation in Elysia\nDESCRIPTION: Example of handling cookie secret rotation in Elysia 0.7, where multiple secrets can be provided to safely transition between them while maintaining cookie validity.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-07.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nnew Elysia({\n    cookie: {\n        secrets: ['Vengeance will be mine', 'Fischl von Luftschloss Narfidort']\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Cookie Schema Validation in Elysia\nDESCRIPTION: Demonstrates how to use Cookie Schema in Elysia 0.7 to validate cookie values, providing type safety and automatic encoding/decoding of structured data.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-07.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\napp.get('/', ({ cookie: { name } }) => {\n    // Set\n    name.value = {\n        id: 617,\n        name: 'Summoning 101'\n    }\n}, {\n    cookie: t.Cookie({\n        value: t.Object({\n            id: t.Numeric(),\n            name: t.String()\n        })\n    })\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Redirects in ElysiaJS Handlers\nDESCRIPTION: Demonstrates how to use the redirect function to redirect requests to another resource, with optional custom status codes.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/', ({ redirect }) => {\n        return redirect('https://youtu.be/whpVWVWBW4U?&t=8')\n    })\n    .get('/custom-status', ({ redirect }) => {\n        // You can also set custom status to redirect\n        return redirect('https://youtu.be/whpVWVWBW4U?&t=8', 302)\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Nested Framework Integration Example\nDESCRIPTION: Advanced example showing how to nest multiple frameworks (Elysia and Hono) using their respective mount and fetch capabilities.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/mount.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { Hono } from 'hono'\n\nconst elysia = new Elysia()\n    .get('/', () => 'Hello from Elysia inside Hono inside Elysia')\n\nconst hono = new Hono()\n    .get('/', (c) => c.text('Hello from Hono!'))\n    .mount('/elysia', elysia.fetch)\n\nconst main = new Elysia()\n    .get('/', () => 'Hello from Elysia')\n    .mount('/hono', hono.fetch)\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Grouping Routes with Scoped Guards in Elysia.group (TypeScript)\nDESCRIPTION: This code introduces request body validation (a guard) for all routes combined under a group in Elysia. Uses t.Literal to specify that the request body must exactly match 'Rikuhachima Aru' for any grouped '/user' routes. Prerequisites include the 't' utility from Elysia. Each route inside the group inherits the guard constraint. Limitation: Only requests with the literal body value will succeed.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/route.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n    .group(\n        '/user',\n        {\n            body: t.Literal('Rikuhachima Aru')\n        },\n        (app) => app\n            .post('/sign-in', 'Sign in')\n            .post('/sign-up', 'Sign up')\n            .post('/profile', 'Profile')\n    )\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Configuring Elysia Server with tRPC Integration\nDESCRIPTION: Sets up an Elysia server with CORS and WebSocket support, integrating tRPC functionality. Exports the app type for client-side type inference.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/integrate-trpc-with-elysia.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, ws } from 'elysia'\nimport { cors } from '@elysiajs/cors'\nimport { trpc } from '@elysiajs/trpc'\n\nimport { router, createContext } from './trpc'\n\nconst app = new Elysia()\n    .use(cors())\n    .use(ws())\n    .get('/', () => 'Hello Elysia')\n    .use(\n        trpc(router, {\n            createContext\n        })\n    )\n    .listen(3000)\n\nexport type App = typeof app\n\nconsole.log(`ðŸ¦Š Elysia is running at ${app.server?.hostname}:${app.server?.port}`)\n```\n\n----------------------------------------\n\nTITLE: Integrating OpenAPI with Elysia in TypeScript\nDESCRIPTION: This snippet demonstrates how to integrate OpenAPI (Swagger) with Elysia. It shows the setup of multiple route modules and their combination with the Swagger middleware.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/midori.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { swagger } from '@elysiajs/swagger'\nimport { users, feed } from './controllers'\n\nnew Elysia()\n    .use(swagger())\n    .use(users)\n    .use(feed)\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Using Eden Fetch Client\nDESCRIPTION: Demonstrates how to use Eden Fetch to make type-safe API requests to the Elysia server. Shows examples of GET and POST requests with proper typing.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/fetch.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { edenFetch } from '@elysiajs/eden'\nimport type { App } from './server'\n\nconst fetch = edenFetch<App>('http://localhost:3000')\n\n// response type: 'Hi Elysia'\nconst pong = await fetch('/hi', {})\n\n// response type: 1895\nconst id = await fetch('/id/:id', {\n    params: {\n        id: '1895'\n    }\n})\n\n// response type: { id: 1895, name: 'Skadi' }\nconst nendoroid = await fetch('/mirror', {\n    method: 'POST',\n    body: {\n        id: 1895,\n        name: 'Skadi'\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Sending Emails with Nodemailer in ElysiaJS\nDESCRIPTION: Implementation for sending the OTP email using Nodemailer as the email provider. It renders the React component to HTML and sends it via SMTP.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/react-email.md#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nimport * as React from 'react'\nimport { renderToStaticMarkup } from 'react-dom/server'\n\nimport OTPEmail from './emails/otp'\n\nimport nodemailer from 'nodemailer'\n\nconst transporter = nodemailer.createTransport({\n  \thost: 'smtp.gehenna.sh',\n  \tport: 465,\n  \tauth: {\n  \t\tuser: 'makoto',\n  \t\tpass: '12345678'\n  \t}\n})\n\nnew Elysia()\n\t.get('/otp', ({ body }) => {\n\t\t// Random between 100,000 and 999,999\n  \t\tconst otp = ~~(Math.random() * (900_000 - 1)) + 100_000\n\n\t\tconst html = renderToStaticMarkup(<OTPEmail otp={otp} />)\n\n        await transporter.sendMail({\n        \tfrom: 'ibuki@gehenna.sh',\n           \tto: body,\n           \tsubject: 'Verify your email address',\n            html,\n        })\n\n        return { success: true }\n\t}, {\n\t\tbody: t.String({ format: 'email' })\n\t})\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Appending Response Headers in ElysiaJS\nDESCRIPTION: Shows how to append custom headers to the response using the set.headers property in an ElysiaJS handler.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/', ({ set }) => {\n        set.headers['x-powered-by'] = 'Elysia'\n\n        return 'a mimir'\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Using Predefined Patterns for Cron Scheduling - ElysiaJS in TypeScript\nDESCRIPTION: Illustrates advanced scheduling by importing time interval patterns from '@elysiajs/cron/schedule' via the 'Patterns' export. Instead of using raw cron syntax, the job schedule is defined by 'Patterns.everySecond()', providing increased readability and maintenance. The code also shows how to combine this with manual job management via the '/stop' endpoint. Requires both 'elysia' and '@elysiajs/cron', plus '@elysiajs/cron/schedule' for pattern constants and functions.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/cron.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { cron, Patterns } from '@elysiajs/cron'\n\nconst app = new Elysia()\n\t.use(\n\t\tcron({\n\t\t\tname: 'heartbeat',\n\t\t\tpattern: Patterns.everySecond(),\n\t\t\trun() {\n\t\t\t\tconsole.log('Heartbeat')\n\t\t\t}\n\t\t})\n\t)\n\t.get(\n\t\t'/stop',\n\t\t({\n\t\t\tstore: {\n\t\t\t\tcron: { heartbeat }\n\t\t\t}\n\t\t}) => {\n\t\t\theartbeat.stop()\n\n\t\t\treturn 'Stop heartbeat'\n\t\t}\n\t)\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Implementing Guards for Route Groups in ElysiaJS\nDESCRIPTION: Shows how to use guards to add additional information to a group of routes in the API documentation.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/openapi.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n\t.guard({\n\t\tdetail: {\n\t\t\tdescription: 'Require user to be logged in'\n\t\t}\n\t})\n\t.get('/user', 'user')\n\t.get('/admin', 'admin')\n```\n\n----------------------------------------\n\nTITLE: Defining an Optional Query Schema with t.Optional - Elysia/TypeBox - TypeScript\nDESCRIPTION: Creates an Elysia route that accepts an optional query parameter defined via t.Optional, specifically an object with a single 'name' property of type string. This pattern enables clients to omit the 'name' query parameter in their requests. To use this, import 'Elysia' and 't' from 'elysia'. The snippet expects HTTP GET requests to '/optional' and returns the query object if present; otherwise, returns undefined.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/type.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript twoslash\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n\t.get('/optional', ({ query }) => query, {\n                       // ^?\n\n\t\tquery: t.Optional(\n\t\t\tt.Object({\n\t\t\t\tname: t.String()\n\t\t\t})\n\t\t)\n\t})\n```\n\n----------------------------------------\n\nTITLE: Defining Custom HTTP Methods with Elysia.route (TypeScript)\nDESCRIPTION: Illustrates the use of Elysia.route to define a route with a non-standard custom HTTP verb. The app exposes '/get' for GET, '/post' for POST, and '/m-search' for the custom 'M-SEARCH' method, each returning specific string responses. Useful for supporting custom protocols or services beyond REST. Prerequisite: Elysia installed, case-sensitive method names per RFC. Outputs appropriate string for each method and route.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/route.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst app = new Elysia()\n    .get('/get', 'hello')\n    .post('/post', 'hi')\n    .route('M-SEARCH', '/m-search', 'connect') // [!code ++]\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Macro in ElysiaJS v1\nDESCRIPTION: Demonstrates creating a basic macro that logs a word using the onBeforeHandle lifecycle event. When the route is accessed, it logs \"Elysia\" to the console.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/macro.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst plugin = new Elysia({ name: 'plugin' })\n    .macro(({ onBeforeHandle }) => ({\n        hi(word: string) {\n            onBeforeHandle(() => {\n                console.log(word)\n            })\n        }\n    }))\n\nconst app = new Elysia()\n    .use(plugin)\n    .get('/', () => 'hi', {\n        hi: 'Elysia'\n    })\n```\n\n----------------------------------------\n\nTITLE: Basic Cookie Usage in ElysiaJS\nDESCRIPTION: Demonstrates basic get and set operations for cookies using ElysiaJS's reactive cookie system.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/cookie.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/', ({ cookie: { name } }) => {\n        // Get\n        name.value\n\n        // Set\n        name.value = \"New Value\"\n    })\n```\n\n----------------------------------------\n\nTITLE: Testing Elysia Applications with Bun\nDESCRIPTION: Shows how to write and run tests for Elysia applications using Bun's test runner. Demonstrates testing API endpoints and error handling.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/index.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// @filename: index.ts\nimport { Elysia, t } from 'elysia'\n\nexport const app = new Elysia()\n    .put(\n        '/user',\n        ({ body, error }) => {\n        \tif(body.username === 'mika')\n\t\t\t\treturn error(400, {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: 'Username already taken'\n\t\t\t\t} as const)\n\n            return {\n            \tsuccess: true,\n             \tmessage: 'User created'\n            } as const\n        },\n        {\n            body: t.Object({\n            \tusername: t.String(),\n             \tpassword: t.String()\n            })\n        }\n    )\n\n// @filename: client.ts\n// ---cut---\nimport { treaty } from '@elysiajs/eden'\nimport { app } from './index'\nimport { test, expect } from 'bun:test'\n\nconst server = treaty(app)\n\ntest('should handle duplicated user', async () => {\n\tconst { error } = await server.user.put({\n\t    username: 'mika',\n\t})\n\n\texpect(error?.value).toEqual({\n\t\tsuccess: false,\n\t\tmessage: 'Username already taken'\n\t})\n})\n```\n\n----------------------------------------\n\nTITLE: CORS Domain Pattern Matching Example\nDESCRIPTION: Example showing how to configure CORS to allow requests only from specific domain patterns using regex\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/cors.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { cors } from '@elysiajs/cors'\n\nconst app = new Elysia()\n\t.use(\n\t\tcors({\n\t\t\torigin: /.*\\.saltyaom\\.com$/\n\t\t})\n\t)\n\t.get('/', () => 'Hi')\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Data Type Coercion in Elysia 1.1\nDESCRIPTION: Illustrates the new automatic data type coercion feature in Elysia 1.1, allowing for simpler schema definitions without explicit coercion types like t.Numeric.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-11.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n\t.get('/', ({ query }) => query, {\n\t\tquery: t.Object({\n\t\t\t// âœ… page will be coerced into a number automatically\n\t\t\tpage: t.Number()\n\t\t})\n\t})\n```\n\n----------------------------------------\n\nTITLE: Creating Named Plugins with Checksum Support\nDESCRIPTION: Shows how to create a plugin with a name property to enable plugin checksum functionality, which prevents duplicate plugin registrations when the same plugin is used multiple times.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-06.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst plugin = new Elysia({\n    name: 'plugin'\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Request Interception in Eden Treaty\nDESCRIPTION: Shows how to intercept and modify fetch requests before they are sent. This can be used to add custom headers or modify the request based on certain conditions.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/config.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ntreaty<App>('localhost:3000', {\n    onRequest(path, options) {\n        if(path.startsWith('user'))\n            return {\n                headers: {\n                    authorization: 'Bearer 12345'\n                }\n            }\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Response Streaming using Generator Functions in ElysiaJS\nDESCRIPTION: Introduces native response streaming in ElysiaJS using JavaScript generator functions (`function*`). Returning a generator function from a route handler allows streaming data piece by piece using the `yield` keyword. This method provides better type inference compared to the older `@elysiajs/stream` package.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-11.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst app = new Elysia()\n\t.get('/ok', function* () {\n\t\tyield 1\n\t\tyield 2\n\t\tyield 3\n\t})\n```\n\n----------------------------------------\n\nTITLE: Implementing Hook Types in ElysiaJS\nDESCRIPTION: Demonstrates the new hook type implementation using the 'as' property to specify hook inheritance behavior.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-10.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst plugin = new Elysia()\n    .onBeforeHandle({ as: 'global' }, () => {\n        console.log('hi')\n    })\n    .get('/child', () => 'log hi')\n\nconst main = new Elysia()\n    .use(plugin)\n    .get('/parent', () => 'log hi')\n```\n\n----------------------------------------\n\nTITLE: Consuming Elysia API on client side using Eden\nDESCRIPTION: This snippet shows how to use Eden to consume the Elysia API on the client side, demonstrating type inference and API calls.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/installation.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// client.ts\nimport { treaty } from '@elysiajs/eden'\nimport type { App } from './server' // [!code ++]\n\nconst client = treaty<App>('localhost:3000') // [!code ++]\n\n// response: Hi Elysia\nconst { data: index } = await client.index.get()\n\n// response: 1895\nconst { data: id } = await client.id({ id: 1895 }).get()\n\n// response: { id: 1895, name: 'Skadi' }\nconst { data: nendoroid } = await client.mirror.post({\n    id: 1895,\n    name: 'Skadi'\n})\n\n// @noErrors\nclient.\n//     ^|\n```\n\n----------------------------------------\n\nTITLE: Overriding WebSocket Configuration in Elysia (TypeScript)\nDESCRIPTION: This snippet demonstrates how to customize the WebSocket configuration when initializing an Elysia server instance. It shows enabling per-message deflation for compression, using the extension of Bun's WebSocket API provided by Elysia. No additional dependencies are required beyond Elysia and Bun. The configuration object is passed on instantiation; parameters such as 'perMessageDeflate' control WebSocket behavior. This impacts how messages are handled over WebSocket connections, but Elysia manages most details automatically.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/configuration.md#2025-04-23_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia({\n\twebsocket: {\n\t\t// enable compression and decompression\n    \tperMessageDeflate: true\n\t}\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing User Authentication with Macros in Elysia.js\nDESCRIPTION: This snippet shows how to use a custom 'isSignIn' macro in a user management API. It implements user sign-up, sign-in, and profile endpoints, with the profile endpoint using the custom macro to handle authentication.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nexport const userService = new Elysia({ name: 'user/service' })\n    .state({\n        user: {} as Record<string, string>,\n        session: {} as Record<number, string>\n    })\n    .model({\n        signIn: t.Object({\n            username: t.String({ minLength: 1 }),\n            password: t.String({ minLength: 8 })\n        }),\n        session: t.Cookie(\n            {\n                token: t.Number()\n            },\n            {\n                secrets: 'seia'\n            }\n        ),\n        optionalSession: t.Optional(t.Ref('session'))\n    })\n    .macro({\n        isSignIn(enabled: boolean) {\n            if (!enabled) return\n\n            return {\n            \tbeforeHandle({ error, cookie: { token }, store: { session } }) {\n                    if (!token.value)\n                        return error(401, {\n                            success: false,\n                            message: 'Unauthorized'\n                        })\n\n                    const username = session[token.value as unknown as number]\n\n                    if (!username)\n                        return error(401, {\n                            success: false,\n                            message: 'Unauthorized'\n                        })\n                }\n            }\n        }\n    })\n\nexport const user = new Elysia({ prefix: '/user' })\n    .use(userService)\n    .put(\n        '/sign-up',\n        async ({ body: { username, password }, store, error }) => {\n            if (store.user[username])\n                return error(400, {\n                    success: false,\n                    message: 'User already exists'\n                })\n\n            store.user[username] = await Bun.password.hash(password)\n\n            return {\n                success: true,\n                message: 'User created'\n            }\n        },\n        {\n            body: 'signIn'\n        }\n    )\n    .post(\n        '/sign-in',\n        async ({\n            store: { user, session },\n            error,\n            body: { username, password },\n            cookie: { token }\n        }) => {\n            if (\n                !user[username] ||\n                !(await Bun.password.verify(password, user[username]))\n            )\n                return error(400, {\n                    success: false,\n                    message: 'Invalid username or password'\n                })\n\n            const key = crypto.getRandomValues(new Uint32Array(1))[0]\n            session[key] = username\n            token.value = key\n\n            return {\n                success: true,\n                message: `Signed in as ${username}`\n            }\n        },\n        {\n            body: 'signIn',\n            cookie: 'optionalSession'\n        }\n    )\n    .get(\n        '/profile',\n        ({ cookie: { token }, store: { session }, error }) => {\n            const username = session[token.value]\n\n            return {\n                success: true,\n                username\n            }\n        },\n        {\n            isSignIn: true, \n            cookie: 'session'\n        }\n    )\n```\n\n----------------------------------------\n\nTITLE: Cookie Removal Methods\nDESCRIPTION: Demonstrates two methods for removing cookies in ElysiaJS.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/cookie.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/', ({ cookie, cookie: { name } }) => {\n        name.remove()\n\n        delete cookie.name\n    })\n```\n\n----------------------------------------\n\nTITLE: Cookie Signature Implementation\nDESCRIPTION: Shows how to implement cookie signing for secure cookie handling.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/cookie.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n    .get('/', ({ cookie: { profile } }) => {\n        profile.value = {\n            id: 617,\n            name: 'Summoning 101'\n        }\n    }, {\n        cookie: t.Cookie({\n            profile: t.Object({\n                id: t.Numeric(),\n                name: t.String()\n            })\n        }, {\n            secrets: 'Fischl von Luftschloss Narfidort',\n            sign: ['profile']\n        })\n    })\n```\n\n----------------------------------------\n\nTITLE: Loose Path Handling in Elysia.js\nDESCRIPTION: Demonstrates the new loose path matching feature that automatically handles paths with and without trailing slashes.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-06.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nnew Elysia()\n    .group('/v1', (app) => app\n        // Handle /v1 and /v1/\n        .get('/', handle)\n    )\n```\n\n----------------------------------------\n\nTITLE: JWT Implementation with Header Authentication\nDESCRIPTION: Example of implementing JWT authentication using authorization headers in ElysiaJS\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/jwt.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { jwt } from '@elysiajs/jwt'\n\nconst app = new Elysia()\n    .use(\n        jwt({\n            name: 'jwt',\n            secret: 'Fischl von Luftschloss Narfidort'\n        })\n    )\n    .get('/sign/:name', ({ jwt, params: { name } }) => {\n    \treturn jwt.sign({ name })\n    })\n    .get('/profile', async ({ jwt, error, headers: { authorization } }) => {\n        const profile = await jwt.verify(authorization)\n\n        if (!profile)\n            return error(401, 'Unauthorized')\n\n        return `Hello ${profile.name}`\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Implementing Elysia Server in Expo API Route\nDESCRIPTION: Example of creating an Elysia server in an Expo API route file, defining GET and POST handlers.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/expo.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// app/[...slugs]+api.ts\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n    .get('/', () => 'hello Next')\n    .post('/', ({ body }) => body, {\n        body: t.Object({\n            name: t.String()\n        })\n    })\n\nexport const GET = app.handle // [!code ++]\nexport const POST = app.handle // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Server-side Setup for End-to-end Type Safety\nDESCRIPTION: Shows how to export your Elysia app type to enable end-to-end type safety with frontend clients.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/at-glance.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { swagger } from '@elysiajs/swagger'\n\nconst app = new Elysia()\n    .use(swagger())\n    .get('/user/:id', ({ params: { id } }) => id, {\n        params: t.Object({\n            id: t.Number()\n        })\n    })\n    .listen(3000)\n\nexport type App = typeof app\n```\n\n----------------------------------------\n\nTITLE: Automatic Numeric Transformation for Route Params - Elysia - TypeScript\nDESCRIPTION: Illustrates Elysia's automatic type transformation where t.Number used in route parameters (params) is converted to t.Numeric, but retains t.Number in nested object or body schemas. For this to function, import 'Elysia' and 't' from 'elysia'. The snippet demonstrates both converted and not converted scenarios. Only applies for parameters in the route schema, not nested objects.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/type.md#2025-04-23_snippet_16\n\nLANGUAGE: ts\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n\t.get('/:id', ({ id }) => id, {\n\t\tparams: t.Object({\n\t\t\t// Converted to t.Numeric()\n\t\t\tid: t.Number()\n\t\t}),\n\t\tbody: t.Object({\n\t\t\t// NOT converted to t.Numeric()\n\t\t\tid: t.Number()\n\t\t})\n\t})\n\n// NOT converted to t.Numeric()\nt.Number()\n```\n\n----------------------------------------\n\nTITLE: Testing Routes Programmatically with Elysia.handle (TypeScript)\nDESCRIPTION: Shows how to perform programmatic requests against an Elysia server using the .handle method. Initializes the server with GET and POST endpoints, then sends a Request object to '/' and logs the result. Requires Elysia and a compatible environment (Node.js or browser with fetch API). Useful for integration/unit tests that simulate actual HTTP requests without external clients.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/route.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst app = new Elysia()\n    .get('/', 'hello')\n    .post('/hi', 'hi')\n    .listen(3000)\n\napp.handle(new Request('http://localhost/')).then(console.log)\n```\n\n----------------------------------------\n\nTITLE: Initializing OpenTelemetry Plugin in ElysiaJS Application\nDESCRIPTION: Basic setup for integrating OpenTelemetry with an Elysia application using batch span processing and OTLP trace exporting. This configuration enables automatic trace collection and span management.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/opentelemetry.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { opentelemetry } from '@elysiajs/opentelemetry'\n\nimport { BatchSpanProcessor } from '@opentelemetry/sdk-trace-node'\nimport { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-proto'\n\nnew Elysia()\n\t.use(\n\t\topentelemetry({\n\t\t\tspanProcessors: [\n\t\t\t\tnew BatchSpanProcessor(\n\t\t\t\t\tnew OTLPTraceExporter()\n\t\t\t\t)\n\t\t\t]\n\t\t})\n\t)\n```\n\n----------------------------------------\n\nTITLE: Adding Tags to Route Groups in ElysiaJS\nDESCRIPTION: Demonstrates how to add tags to a group of routes for better organization in the API documentation.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/openapi.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia({\n\ttags: ['user']\n})\n\t.get('/user', 'user')\n\t.get('/admin', 'admin')\n```\n\n----------------------------------------\n\nTITLE: Defining Authentication Routes with Elysia and Supabase - TypeScript\nDESCRIPTION: Defines an Elysia group for authentication routes, implementing '/sign-up', '/sign-in', and '/refresh' endpoints using Supabase's authentication APIs. The code sets up models for request validation and manages cookies for session handling. Dependencies include Elysia, Supabase client, and type definitions from the 't' module. Inputs include request bodies matching schema definitions for email and password; outputs are either user objects or error responses. Limitations: requires correct Supabase configuration and secure handling of cookies.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-supabase.md#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\n// src/modules/authen.ts\nimport { Elysia, t } from 'elysia'\nimport { supabase } from '../../libs'\n\nconst authen = (app: Elysia) =>\n    app.group('/auth', (app) =>\n        app\n            .setModel({\n                sign: t.Object({\n                    email: t.String({\n                        format: 'email'\n                    }),\n                    password: t.String({\n                        minLength: 8\n                    })\n                })\n            })\n            .post(\n                '/sign-up',\n                async ({ body }) => {\n                    const { data, error } = await supabase.auth.signUp(body)\n\n                    if (error) return error\n                    return data.user\n                },\n                {\n                    schema: {\n                        body: 'sign'\n                    }\n                }\n            )\n            .post(\n                '/sign-in',\n                async ({ body }) => {\n                    const { data, error } =\n                        await supabase.auth.signInWithPassword(body)\n\n                    if (error) return error\n\n                    return data.user\n                },\n                {\n                    schema: {\n                        body: 'sign'\n                    }\n                }\n            )\n            .get( // [!code ++]\n                '/refresh', // [!code ++]\n                async ({ setCookie, cookie: { refresh_token } }) => { // [!code ++]\n                    const { data, error } = await supabase.auth.refreshSession({ // [!code ++]\n                        refresh_token // [!code ++]\n                    }) // [!code ++]\n // [!code ++]\n                    if (error) return error // [!code ++]\n // [!code ++]\n                    setCookie('refresh_token', data.session!.refresh_token) // [!code ++]\n // [!code ++]\n                    return data.user // [!code ++]\n                } // [!code ++]\n            ) // [!code ++]\n    )\n```\n\n----------------------------------------\n\nTITLE: Non-Request Dependent Service Implementation\nDESCRIPTION: Example of implementing a service that doesn't depend on request context using static methods.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/structure.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nabstract class Service {\n    static fibo(number: number): number {\n        if(number < 2)\n            return number\n\n        return Service.fibo(number - 1) + Service.fibo(number - 2)\n    }\n}\n\nnew Elysia()\n    .get('/fibo', ({ body }) => {\n        return Service.fibo(body)\n    }, {\n        body: t.Numeric()\n    })\n```\n\n----------------------------------------\n\nTITLE: Cookie Attribute Management\nDESCRIPTION: Shows how to get and set cookie attributes like domain and httpOnly flags directly.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/cookie.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/', ({ cookie: { name } }) => {\n        // get\n        name.domain\n\n        // set\n        name.domain = 'millennium.sh'\n        name.httpOnly = true\n    })\n```\n\n----------------------------------------\n\nTITLE: Basic JSX Implementation\nDESCRIPTION: Example of using JSX as a template engine in ElysiaJS\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/html.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { html, Html } from '@elysiajs/html'\n\nnew Elysia()\n\t.use(html())\n\t.get('/', () => (\n\t\t<html lang=\"en\">\n\t\t\t<head>\n\t\t\t\t<title>Hello World</title>\n\t\t\t</head>\n\t\t\t<body>\n\t\t\t\t<h1>Hello World</h1>\n\t\t\t</body>\n\t\t</html>\n\t))\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Integrating Better Auth with ElysiaJS Application\nDESCRIPTION: Code to attach the Better Auth view handler to specific routes in an ElysiaJS application. This sets up the authentication endpoint at '/api/auth/*' that will handle all auth-related requests.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/better-auth.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new Elysia()\n.use(cors()).use(swagger()).all(\"/api/auth/*\", betterAuthView);\n\napp.listen(process.env.BACKEND_PORT || 8000);\n\nconsole.log(\n  `ðŸ¦Š Elysia is running at ${app.server?.hostname}:${app.server?.port}`\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Bearer Token Retrieval in ElysiaJS\nDESCRIPTION: Example of using the Bearer plugin in an ElysiaJS application. It demonstrates how to set up a route that requires a Bearer token and handles unauthorized requests.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/bearer.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { bearer } from '@elysiajs/bearer'\n\nconst app = new Elysia()\n    .use(bearer())\n    .get('/sign', ({ bearer }) => bearer, {\n        beforeHandle({ bearer, set, error }) {\n            if (!bearer) {\n                set.headers[\n                    'WWW-Authenticate'\n                ] = `Bearer realm='sign', error=\"invalid_request\"`\n\n                return error(400, 'Unauthorized')\n            }\n        }\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Supabase Integration for Authentication\nDESCRIPTION: Implementation of Supabase authentication methods for sign-up and sign-in functionality with error handling.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-supabase.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { supabase } from '../../libs'\n\nconst authen = (app: Elysia) =>\n    app.group('/auth', (app) =>\n        app\n            .post('/sign-up', async ({ body }) => {\n                const { data, error } = await supabase.auth.signUp(body)\n\n                if (error) return error\n\n                return data.user\n            })\n            .post('/sign-in', async ({ body }) => {\n                const { data, error } = await supabase.auth.signInWithPassword(\n                    body\n                )\n\n                if (error) return error\n\n                return data.user\n            })\n    )\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Swagger Endpoint\nDESCRIPTION: Example showing how to customize the Swagger documentation endpoint path\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/swagger.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { swagger } from '@elysiajs/swagger'\n\nnew Elysia()\n    .use(\n        swagger({\n            path: '/v2/swagger'\n        })\n    )\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: End-to-End Type Safety with Elysia and Eden\nDESCRIPTION: Demonstrates end-to-end type safety between Elysia server and client using @elysiajs/eden. Shows type inference for API calls and response data.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/index.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// @filename: server.ts\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n    .patch(\n        '/profile',\n        ({ body, error }) => {\n            if(body.age < 18)\n                return error(400, \"Oh no\")\n\n            return body\n        },\n        {\n            body: t.Object({\n                age: t.Number()\n            })\n        }\n    )\n    .listen(80)\n\nexport type App = typeof app\n\n// @filename: client.ts\n// ---cut---\nimport { treaty } from '@elysiajs/eden'\nimport type { App } from './server'\n\nconst api = treaty<App>('api.elysiajs.com')\n\nconst { data } = await api.profile.patch({\n      // ^?\n    age: 21\n})\n```\n\n----------------------------------------\n\nTITLE: Using Eden for Validation Error Handling\nDESCRIPTION: Shows how to use Eden in Elysia 1.2 to automatically infer 422 status code for validation errors and handle them.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-12.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { treaty } from '@elysiajs/eden'\nimport type { App } from './app'\n\nconst api = treaty<App>('localhost:3000')\n\nconst { data, error } = await api.user.put({\n\tname: 'saltyaom'\n})\n\nif(error)\n\tswitch(error.status) {\n\t\tcase 422:\n\t\t\tconsole.log(error.summary)\n\t\t\tbreak\n\n\t\tdefault:\n\t\t\tconsole.error(error)\n\t}\n```\n\n----------------------------------------\n\nTITLE: Integrating Swagger Documentation with Elysia\nDESCRIPTION: Shows how to add Swagger documentation to an Elysia application using the Swagger plugin, including model definitions and typed endpoints.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/integrate-trpc-with-elysia.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { swagger } from '@elysiajs/swagger'\n\nconst app = new Elysia()\n    .use(swagger())\n    .setModel({\n        sign: t.Object({\n            username: t.String(),\n            password: t.String()\n        })\n    })\n    .get('/', () => 'Hello Elysia')\n    .post('/typed-body', ({ body }) => body, {\n        schema: {\n            body: 'sign',\n            response: 'sign'\n        }\n    })\n    .listen(3000)\n\nexport type App = typeof app\n\nconsole.log(`ðŸ¦Š Elysia is running at ${app.server?.hostname}:${app.server?.port}`)\n```\n\n----------------------------------------\n\nTITLE: Executing After-Response Hooks with Elysia (TypeScript)\nDESCRIPTION: Utilizes Elysia's `onAfterResponse` hook to perform actions (e.g., logging or analytics) after the HTTP response is sent. Contains a handler that logs the response completion time using the `performance.now()` API. Dependencies: `elysia` package, Bun's performance timer. Output: Console logs per request.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .onAfterResponse(() => {\n        console.log('Response', performance.now())\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Implementing Server-Sent Events with Callback-based Stream - TypeScript\nDESCRIPTION: This snippet defines a '/source' endpoint that uses the Stream constructor callback to send periodic messages using setInterval and closes the stream after 3 seconds. It's a template for creating SSE endpoints with full manual control over streaming behavior. Requires the Elysia and @elysiajs/stream modules to be installed.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/stream.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nnew Elysia()\n    .get('/source', () =>\n        new Stream((stream) => {\n            const interval = setInterval(() => {\n                stream.send('hello world')\n            }, 500)\n\n            setTimeout(() => {\n                clearInterval(interval)\n                stream.close()\n            }, 3000)\n        })\n    )\n```\n\n----------------------------------------\n\nTITLE: Setting Up File Upload Server in Elysia\nDESCRIPTION: This code demonstrates how to create a file upload endpoint in an Elysia server. It defines a route that accepts a file and title, using t.Files() to type the file upload field.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/legacy.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// server.ts\nimport { Elysia } from 'elysia'\n\nconst app = new Elysia()\n    .post('/image', ({ body: { image, title } }) => title, {\n        body: t.Object({\n            title: t.String(),\n            image: t.Files(),\n        })\n    })\n    .listen(3000)\n\nexport type App = typeof app\n```\n\n----------------------------------------\n\nTITLE: Custom JWT Namespace Configuration\nDESCRIPTION: Example showing how to configure JWT with a custom namespace name for multiple JWT configurations\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/jwt.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\napp\n    .use(\n        jwt({\n            name: 'myJWTNamespace',\n            secret: process.env.JWT_SECRETS!\n        })\n    )\n    .get('/sign/:name', ({ myJWTNamespace, params }) => {\n        return myJWTNamespace.sign(params)\n    })\n```\n\n----------------------------------------\n\nTITLE: Prefix-based Property Remapping in Elysia\nDESCRIPTION: Demonstrates using prefix functionality to bulk rename plugin properties and prevent naming conflicts\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-07.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst setup = new Elysia({ name: 'setup' })\n    .decorate({\n        argon: 'a',\n        boron: 'b',\n        carbon: 'c'\n    })\n\nconst app = new Elysia()\n    .use(\n        setup\n            .prefix('decorator', 'setup')\n    )\n    .get('/', ({ setupCarbon }) => setupCarbon)\n```\n\n----------------------------------------\n\nTITLE: Registering Swagger Plugin in ElysiaJS\nDESCRIPTION: Example of importing and using the Swagger plugin in an ElysiaJS application.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/openapi.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { swagger } from '@elysiajs/swagger'\n\nconst app = new Elysia()\n    .use(swagger())\n```\n\n----------------------------------------\n\nTITLE: Composing Elysia App with Swagger and External Note Plugin (TypeScript)\nDESCRIPTION: This snippet shows how to integrate the previously defined note plugin into the main Elysia application instance. It demonstrates the use of the Swagger plugin for API documentation and highlights the composition and extensibility of Elysia apps. Requires 'elysia', '@elysiajs/swagger', and the custom plugin module. Example endpoints are registered on /note and /note/:index.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// @filename: note.ts\nimport { Elysia, t } from 'elysia'\n\nclass Note {\n    constructor(public data: string[] = ['Moonhalo']) {}\n}\n\nexport const note = new Elysia()\n    .decorate('note', new Note())\n    .get('/note', ({ note }) => note.data)\n    .get(\n        '/note/:index',\n        ({ note, params: { index }, error }) => {\n            return note.data[index] ?? error(404, 'oh no :(')\n        },\n        {\n            params: t.Object({\n                index: t.Number()\n            })\n        }\n    )\n\n// @filename: index.ts\n// ---cut---\nimport { Elysia, t } from 'elysia'\nimport { swagger } from '@elysiajs/swagger'\n\nimport { note } from './note' // [!code ++]\n\nclass Note { // [!code --]\n    constructor(public data: string[] = ['Moonhalo']) {} // [!code --]\n} // [!code --]\n\nconst app = new Elysia()\n    .use(swagger())\n    .use(note) // [!code ++]\n    .decorate('note', new Note()) // [!code --]\n    .get('/note', ({ note }) => note.data) // [!code --]\n    .get( // [!code --]\n        '/note/:index', // [!code --]\n        ({ note, params: { index }, error }) => { // [!code --]\n            return note.data[index] ?? error(404, 'oh no :(') // [!code --]\n        }, // [!code --]\n        { // [!code --]\n            params: t.Object({ // [!code --]\n                index: t.Number() // [!code --]\n            }) // [!code --]\n        } // [!code --]\n    ) // [!code --]\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Configuring Elysia Server with TypeScript\nDESCRIPTION: Sets up an Elysia server with various endpoints including GET and POST routes with type validation. Exports the app type for client-side usage.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/fetch.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n    .get('/hi', () => 'Hi Elysia')\n    .get('/id/:id', ({ params: { id } }) => id)\n    .post('/mirror', ({ body }) => body, {\n        body: t.Object({\n            id: t.Number(),\n            name: t.String()\n        })\n    })\n    .listen(3000)\n\nexport type App = typeof app\n```\n\n----------------------------------------\n\nTITLE: State, Decorate, and Model Configuration in Elysia\nDESCRIPTION: Example demonstrating the new unified API for setting state, decorators, and models with both single and multiple value support\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-05.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n\t// ? set model using label\n\t.model('string', t.String())\n\t.model({\n\t\tnumber: t.Number()\n\t})\n\t.state('visitor', 1)\n\t// ? set model using object\n\t.state({\n\t\tmultiple: 'value',\n\t\tare: 'now supported!'\n\t})\n\t.decorate('visitor', 1)\n\t// ? set model using object\n\t.decorate({\n\t\tname: 'world',\n\t\tnumber: 2\n\t})\n```\n\n----------------------------------------\n\nTITLE: Using Optional Path Parameters in ElysiaJS\nDESCRIPTION: This snippet shows how to implement optional path parameters in ElysiaJS. It demonstrates how to make the 'id' parameter optional by adding a question mark after the parameter name.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/route.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/id/:id?', ({ params: { id } }) => `id ${id}`)\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Request IP in ElysiaJS Handlers\nDESCRIPTION: Demonstrates how to get the request IP address using the server.requestIP method in an ElysiaJS handler.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.get('/ip', ({ server, request }) => {\n\t\treturn server?.requestIP(request)\n\t})\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Basic HTML and JSX Usage in ElysiaJS\nDESCRIPTION: Example showing how to use both HTML strings and JSX components in ElysiaJS routes with the HTML plugin\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/html.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { html, Html } from '@elysiajs/html'\n\nnew Elysia()\n\t.use(html())\n\t.get(\n\t\t'/html',\n\t\t() => `\n            <html lang='en'>\n                <head>\n                    <title>Hello World</title>\n                </head>\n                <body>\n                    <h1>Hello World</h1>\n                </body>\n            </html>`\n\t)\n\t.get('/jsx', () => (\n\t\t<html lang=\"en\">\n\t\t\t<head>\n\t\t\t\t<title>Hello World</title>\n\t\t\t</head>\n\t\t\t<body>\n\t\t\t\t<h1>Hello World</h1>\n\t\t\t</body>\n\t\t</html>\n\t))\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Using Universal File API in Elysia\nDESCRIPTION: Shows how to use the new universal 'file' API in Elysia 1.2 for cross-runtime compatibility when returning file responses.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-12.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, file } from 'elysia'\n\nnew Elysia()\n\t.get('/', () => file('./public/index.html'))\n```\n\n----------------------------------------\n\nTITLE: Using Plugin Casting for Authentication Scope in ElysiaJS\nDESCRIPTION: Demonstrates an alternative approach to scope authentication data in ElysiaJS. Instead of specifying 'as: scoped' on individual lifecycle methods, it uses the global '.as('plugin')' method to make all authentication data available to parent modules.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nexport const userService = new Elysia({ name: 'user/service' })\n    .state({\n        user: {} as Record<string, string>,\n        session: {} as Record<number, string>\n    })\n    .model({\n        signIn: t.Object({\n            username: t.String({ minLength: 1 }),\n            password: t.String({ minLength: 8 })\n        }),\n        session: t.Cookie(\n            {\n                token: t.Number()\n            },\n            {\n                secrets: 'seia'\n            }\n        ),\n        optionalSession: t.Optional(t.Ref('session'))\n    })\n    .macro({\n        isSignIn(enabled: boolean) {\n            if (!enabled) return\n\n            return {\n            \tbeforeHandle({ error, cookie: { token }, store: { session } }) {\n                    if (!token.value)\n                        return error(401, {\n                            success: false,\n                            message: 'Unauthorized'\n                        })\n\n                    const username = session[token.value as unknown as number]\n\n                    if (!username)\n                        return error(401, {\n                            success: false,\n                            message: 'Unauthorized'\n                        })\n                }\n            }\n        }\n    })\n\nexport const getUserId = new Elysia()\n    .use(userService)\n    .guard({\n    \tas: 'scoped', // [!code --]\n    \tisSignIn: true,\n        cookie: 'session'\n    })\n    .resolve(\n   \t\t{ as: 'scoped' }, // [!code --]\n    \t({ store: { session }, cookie: { token } }) => ({\n    \t   \tusername: session[token.value]\n    \t})\n    )\n    .as('plugin') // [!code ++]\n\nexport const user = new Elysia({ prefix: '/user' })\n\t.use(getUserId)\n\t.get('/profile', ({ username }) => ({\n        success: true,\n        username\n    }))\n```\n\n----------------------------------------\n\nTITLE: Route Response Type Guarding\nDESCRIPTION: Demonstrates type enforcement for route responses using guards\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/cheat-sheet.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n    .guard({\n        response: t.String()\n    }, (app) => app\n        .get('/', () => 'Hi')\n        // Invalid: will throws error, and TypeScript will report error\n        .get('/invalid', () => 1)\n    )\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Plugin Decoration Remapping in Elysia\nDESCRIPTION: Shows how to remap plugin decorators to prevent naming conflicts using the decorator transformation function\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-07.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nnew Elysia()\n    .use(\n        plugin\n            .decorate(({ logger, ...rest }) => ({\n                pluginLogger: logger,\n                ...rest\n            }))\n    )\n```\n\n----------------------------------------\n\nTITLE: Integrating OpenTelemetry with Elysia Server\nDESCRIPTION: TypeScript code showing how to integrate OpenTelemetry plugin into an Elysia.js application with Swagger documentation and error handling. Includes complete server setup with note and user modules.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { opentelemetry } from '@elysiajs/opentelemetry'\nimport { swagger } from '@elysiajs/swagger'\n\nimport { note } from './note'\nimport { user } from './user'\n\nconst app = new Elysia()\n    .use(opentelemetry())\n    .use(swagger())\n    .onError(({ error, code }) => {\n        if (code === 'NOT_FOUND') return 'Not Found :('\n\n        console.error(error)\n    })\n    .use(note)\n    .use(user)\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Implementing WebSocket with Eden Treaty in ElysiaJS\nDESCRIPTION: Demonstrates how to set up a WebSocket server endpoint using ElysiaJS and connect to it using Eden Treaty. The example shows a chat implementation with type-safe messaging and event handling. It includes server setup with Elysia and client-side connection using Eden Treaty's subscribe method.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/websocket.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from \"elysia\";\nimport { treaty } from \"@elysiajs/eden\";\n\nconst app = new Elysia()\n  .ws(\"/chat\", {\n    body: t.String(),\n    response: t.String(),\n    message(ws, message) {\n      ws.send(message);\n    },\n  })\n  .listen(3000);\n\nconst api = treaty<typeof app>(\"localhost:3000\");\n\nconst chat = api.chat.subscribe();\n\nchat.subscribe((message) => {\n  console.log(\"got\", message);\n});\n\nchat.on(\"open\", () => {\n  chat.send(\"hello from client\");\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication Middleware for ElysiaJS\nDESCRIPTION: Middleware functions for handling authentication in ElysiaJS routes. The middleware retrieves session information from request headers and provides user authentication status for protected routes.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/better-auth.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Session, User } from \"better-auth/types\";\nimport { auth } from \"../../utils/auth/auth\";\nimport { Context } from \"elysia\";\n \nexport const userMiddleware = async (c: Context) => {\n  const session = await auth.api.getSession({ headers: c.request.headers });\n \n  if (!session) {\n    c.set.status = 401;\n    return { success: 'error', message: \"Unauthorized Access: Token is missing\" };\n  }\n \n  return {\n    user: session.user,\n    session: session.session\n  }\n}\n\nexport const userInfo = (user: User | null, session: Session | null) => {\n  return {\n    user: user,\n    session: session\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic User Sign-up with Elysia and Prisma\nDESCRIPTION: Creates a simple Elysia server with a POST endpoint for user sign-up, using Prisma to interact with the database. This version doesn't include input validation.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/with-prisma.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { PrismaClient } from '@prisma/client'\n\nconst db = new PrismaClient()\n\nconst app = new Elysia()\n    .post(\n        '/sign-up',\n        async ({ body }) => db.user.create({\n            data: body\n        })\n    )\n    .listen(3000)\n\nconsole.log(\n    `ðŸ¦Š Elysia is running at ${app.server?.hostname}:${app.server?.port}`\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Route Groups with Prefixed Elysia Instances (New Approach)\nDESCRIPTION: Demonstrates the simplified route group creation in Elysia 0.6 using the prefix option with an Elysia instance, reducing nesting and improving readability.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-06.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// >= 0.6\nconst group = new Elysia({ prefix: '/v1' })\n    .get('/hello', () => 'Hello World')\n```\n\n----------------------------------------\n\nTITLE: Setting Default Values for Optional Path Parameters in ElysiaJS\nDESCRIPTION: Demonstrates providing a default value for an optional path parameter using Elysia's schema validation. By defining a `params` schema with `t.Object` and setting a `default` value within the type definition (e.g., `t.Number({ default: 1 })`), the parameter (`id`) will receive the default value if it's omitted in the request URL.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-11.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n\t.get('/ok/:id?', ({ params: { id } }) => id, {\n\t\tparams: t.Object({\n\t\t\tid: t.Number({\n\t\t\t\tdefault: 1\n\t\t\t})\n\t\t})\n\t})\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Parsers in Elysia\nDESCRIPTION: Demonstrates how to use multiple parsers, including custom and built-in ones, in a specific order in Elysia 1.2.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-12.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.parser('custom', ({ contentType }) => {\n\t\tif(contentType === \"application/kivotos\")\n\t\t\treturn 'nagisa'\n\t})\n\t.post('/', ({ body }) => body, {\n\t\tparse: ['custom', 'json']\n\t})\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Headers and Status Code in ElysiaJS\nDESCRIPTION: Demonstrates how to set custom headers and return a custom status code using the context.set and context.error methods.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.get('/', ({ set, error }) => {\n\t\tset.headers = { 'X-Teapot': 'true' }\n\n\t\treturn error(418, 'I am a teapot')\n\t})\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Custom HTTP Methods Implementation\nDESCRIPTION: Demonstrates defining routes with different HTTP methods including custom verbs\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/cheat-sheet.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/hi', () => 'Hi')\n    .post('/hi', () => 'From Post')\n    .put('/hi', () => 'From Put')\n    .route('M-SEARCH', '/hi', () => 'Custom Method')\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Basic Routing and WebSocket Handling in Elysia\nDESCRIPTION: Demonstrates basic routing, file serving, streaming responses, and WebSocket handling in Elysia. Shows the simplicity of setting up various types of endpoints.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/index.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, file } from 'elysia'\n\nnew Elysia()\n\t.get('/', 'Hello World')\n\t.get('/image', file('mika.webp'))\n\t.get('/stream', function* () {\n\t\tyield 'Hello'\n\t\tyield 'World'\n\t})\n\t.ws('/realtime', {\n\t\tmessage(ws, message) {\n\t\t\tws.send('got:' + message)\n\t\t}\n\t})\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: File Upload Handling\nDESCRIPTION: Demonstrates how to handle file uploads with validation\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/cheat-sheet.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n\t.post('/body', ({ body }) => body, {\n\t\tbody: t.Object({\n\t\t\tfile: t.File({ format: 'image/*' }),\n\t\t\tmultipleFiles: t.Files()\n\t\t})\n\t})\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Using ObjectString Type with Multipart Form Data\nDESCRIPTION: Shows how to handle JSON objects in multipart/form-data using the new ObjectString type for file uploads with structured data\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-07.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nnew Elysia({\n    cookie: {\n        secret: 'Fischl von Luftschloss Narfidort'\n    }\n})\n    .post('/', ({ body: { data: { name } } }) => name, {\n        body: t.Object({\n            image: t.File(),\n            data: t.ObjectString({\n                name: t.String()\n            })\n        })\n    })\n```\n\n----------------------------------------\n\nTITLE: Setting up an Elysia.js Application with Swagger and OpenTelemetry\nDESCRIPTION: Main entry point that initializes the Elysia application with middleware for OpenTelemetry, Swagger documentation, error handling, and imports user and note modules.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { swagger } from '@elysiajs/swagger'\nimport { opentelemetry } from '@elysiajs/opentelemetry'\n\nimport { note } from './note'\nimport { user } from './user'\n\nconst app = new Elysia()\n    .use(opentelemetry())\n    .use(swagger())\n    .onError(({ error, code }) => {\n        if (code === 'NOT_FOUND') return 'Not Found :('\n\n        console.error(error)\n    })\n    .use(user)\n    .use(note)\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Registering Authentication Middleware in Elysia Root Server - TypeScript\nDESCRIPTION: Demonstrates how to attach the authentication module as middleware to the Elysia server and start listening on port 3000. It shows server initialization flow, registration order, and outputs the live server address. Dependencies are Elysia and the custom 'auth' module from './modules'. Input is programmatic use only; no explicit parameters are provided. Limitation: 'auth' must be implemented and imported correctly.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-supabase.md#2025-04-23_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nimport { auth } from './modules' // [!code ++]\n\nconst app = new Elysia()\n    .use(auth) // [!code ++]\n    .listen(3000)\n\nconsole.log(\n    `ðŸ¦Š Elysia is running at ${app.server?.hostname}:${app.server?.port}`\n)\n```\n\n----------------------------------------\n\nTITLE: Exporting Elysia server type in TypeScript\nDESCRIPTION: This code demonstrates how to create an Elysia server instance and export its type for use with Eden.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/installation.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// server.ts\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n    .get('/', () => 'Hi Elysia')\n    .get('/id/:id', ({ params: { id } }) => id)\n    .post('/mirror', ({ body }) => body, {\n        body: t.Object({\n            id: t.Number(),\n            name: t.String()\n        })\n    })\n    .listen(3000)\n\nexport type App = typeof app // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: tRPC Router Configuration Type Definition\nDESCRIPTION: Type definition for the tRPC router configuration showing the available options including endpoint customization.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/trpc.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ntrpc(\n\trouter: Router,\n\toption?: {\n\t    endpoint?: string\n\t}\n): this\n```\n\n----------------------------------------\n\nTITLE: Configuring Better Auth Instance with Drizzle Adapter\nDESCRIPTION: Setup code for initializing a Better Auth instance with Drizzle ORM as the database adapter. This configuration includes database schema mapping and social provider authentication options for GitHub and Google.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/better-auth.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { betterAuth } from \"better-auth\";\nimport { drizzleAdapter } from \"better-auth/adapters/drizzle\";\nimport db from \"../../database\";\nimport { account, session, user, verification } from \"../../database/schema\";\nexport const auth = betterAuth({\n  database: drizzleAdapter(db, { // We're using Drizzle as our database\n    provider: \"pg\",\n    /*\n    * Map your schema into a better-auth schema\n    */\n    schema: {\n      user,\n      session,\n      verification,\n      account,\n    },\n  }),\n  emailAndPassword: {  \n    enabled: true // If you want to use email and password auth\n  },\n  socialProviders: {\n    /*\n    * We're using Google and Github as our social provider, \n    * make sure you have set your environment variables\n    */\n    github: {\n      clientId: process.env.GITHUB_CLIENT_ID!,\n      clientSecret: process.env.GITHUB_CLIENT_SECRET!,\n    },\n    google: {\n      clientId: process.env.GOOGLE_CLIENT_ID!,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple User-Related POST Endpoints in Elysia (TypeScript)\nDESCRIPTION: Illustrates standard grouping of REST-style endpoints by manually writing out each route for user authentication and information. Each POST endpoint under '/user/<action>' returns its corresponding response. Prerequisite: Elysia installed; can be improved using grouping (see later snippet). Outputs static text for each endpoint.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/route.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .post('/user/sign-in', 'Sign in')\n    .post('/user/sign-up', 'Sign up')\n    .post('/user/profile', 'Profile')\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Cookie Schema Validation\nDESCRIPTION: Shows how to implement type-safe cookie validation using t.Cookie schema.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/cookie.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n    .get('/', ({ cookie: { name } }) => {\n        // Set\n        name.value = {\n            id: 617,\n            name: 'Summoning 101'\n        }\n    }, {\n        cookie: t.Cookie({\n            name: t.Object({\n                id: t.Numeric(),\n                name: t.String()\n            })\n        })\n    })\n```\n\n----------------------------------------\n\nTITLE: Using Error Function for Explicit Status Code Return in Elysia\nDESCRIPTION: This snippet demonstrates the usage of the new 'error' function in Elysia 0.8, which allows for explicit return of status codes alongside values, improving type inference for Eden.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-08.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, error } from 'elysia'\n\nnew Elysia()\n    .get('/', () => error(418, \"I'm a teapot\"))\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Unit Testing Setup\nDESCRIPTION: Demonstrates how to write unit tests for Elysia applications\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/cheat-sheet.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { describe, expect, it } from 'bun:test'\nimport { Elysia } from 'elysia'\n\ndescribe('Elysia', () => {\n    it('return a response', async () => {\n        const app = new Elysia().get('/', () => 'hi')\n\n        const response = await app\n            .handle(new Request('http://localhost/'))\n            .then((res) => res.text())\n\n        expect(response).toBe('hi')\n    })\n})\n```\n\n----------------------------------------\n\nTITLE: Customizing Validation Error Handling in Elysia\nDESCRIPTION: Illustrates how to implement custom error handling for validation errors in Elysia. This example shows how to return different responses for 'NOT_FOUND' and 'VALIDATION' error codes, including detailed field errors for validation failures.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-04.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nnew Elysia()\n    .onError(({ code, error, set }) => {\n        if (code === 'NOT_FOUND') {\n            set.status = 404\n\n            return 'Not Found :('\n        }\n\n        if (code === 'VALIDATION') {\n            set.status = 400\n\n            return {\n                fields: error.all()\n            }\n        }\n    })\n    .post('/sign-in', () => 'hi', {\n        schema: {\n            body: t.Object({\n                username: t.String(),\n                password: t.String()\n            })\n        }\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Using ElysiaJS Instance as a Controller (TypeScript)\nDESCRIPTION: Shows the recommended approach of using the Elysia instance itself as a controller. This maintains type integrity and aligns with the framework's design philosophy.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/best-practice.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { Service } from './service'\n\nnew Elysia()\n    .get('/', ({ stuff }) => {\n        Service.doStuff(stuff)\n    })\n```\n\n----------------------------------------\n\nTITLE: Elysia Server with tRPC Integration\nDESCRIPTION: Integration of tRPC router with Elysia server including CORS support\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/integrate-trpc-with-elysia.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { cors } from '@elysiajs/cors'\nimport { trpc } from '@elysiajs/trpc'\n\nimport { router } from './trpc'\n\nconst app = new Elysia()\n    .use(cors())\n    .get('/', () => 'Hello Elysia')\n    .use(\n        trpc(router)\n    )\n    .listen(3000)\n\nconsole.log(`ðŸ¦Š Elysia is running at ${app.server?.hostname}:${app.server?.port}`)\n```\n\n----------------------------------------\n\nTITLE: Using Drizzle Schema Singleton in Elysia Route Handlers\nDESCRIPTION: TypeScript example demonstrating how to use the Drizzle schema singleton pattern in Elysia route handlers for API validation, accessing schema properties directly from the singleton.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/drizzle.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { db } from './database/model'\n\nconst { user } = db.insert\n\nnew Elysia()\n\t.post('/sign-up', ({ body }) => {\n\t\t// Create a new user\n\t}, {\n\t\tbody: t.Object({\n\t\t\tid: user.username,\n\t\t\tusername: user.username,\n\t\t\tpassword: user.password\n\t\t})\n\t})\n```\n\n----------------------------------------\n\nTITLE: Prefixing Decorator Properties from an ElysiaJS Plugin (TypeScript)\nDESCRIPTION: Illustrates using the `prefix` function to remap specific properties ('decorator' type) from a used ElysiaJS plugin ('setup'). This helps prevent naming collisions by adding a prefix ('setup') to the selected properties ('argon', 'boron', 'carbon'), making them accessible as 'setupArgon', 'setupBoron', 'setupCarbon'.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst setup = new Elysia({ name: 'setup' })\n    .decorate({\n        argon: 'a',\n        boron: 'b',\n        carbon: 'c'\n    })\n\nconst app = new Elysia()\n    .use(\n        setup\n            .prefix('decorator', 'setup')\n    )\n    .get('/', ({ setupCarbon, ...rest }) => setupCarbon)\n```\n\n----------------------------------------\n\nTITLE: Handling Type Instantiation with Drizzle-TypeBox and Elysia\nDESCRIPTION: TypeScript examples demonstrating the correct and incorrect ways to handle type instantiation when using drizzle-typebox with Elysia to prevent infinite type instantiation errors.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/drizzle.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { t } from 'elysia'\nimport { createInsertSchema } from 'drizzle-typebox'\n\nimport { table } from './database/schema'\n\nconst _createUser = createInsertSchema(table.user, {\n\temail: t.String({ format: 'email' })\n})\n\n// âœ… This works, by referencing the type from `drizzle-typebox`\nconst createUser = t.Omit(\n\t_createUser,\n\t['id', 'salt', 'createdAt']\n)\n\n// âŒ This will cause an infinite loop of type instantiation\nconst createUser = t.Omit(\n\tcreateInsertSchema(table.user, {\n\t\temail: t.String({ format: 'email' })\n\t}),\n\t['id', 'salt', 'createdAt']\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing OpenTelemetry with ElysiaJS\nDESCRIPTION: Basic setup for OpenTelemetry in an Elysia application, using a batch span processor and OTLP trace exporter.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/opentelemetry.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { opentelemetry } from '@elysiajs/opentelemetry'\n\nimport { BatchSpanProcessor } from '@opentelemetry/sdk-trace-node'\nimport { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-proto'\n\nnew Elysia().use(\n\topentelemetry({\n\t\tspanProcessors: [new BatchSpanProcessor(new OTLPTraceExporter())]\n\t})\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a Note Plugin with Basic GET Routes in Elysia (TypeScript)\nDESCRIPTION: This code defines a reusable note plugin as an Elysia instance with basic routes for listing notes and fetching a note by index. It includes a Note class for data storage, uses decorators for extending request context, and applies route-level parameter validation. Required dependencies are 'elysia'. The plugin is intended to be imported and used within a main application instance.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nclass Note {\n    constructor(public data: string[] = ['Moonhalo']) {}\n}\n\nexport const note = new Elysia()\n    .decorate('note', new Note())\n    .get('/note', ({ note }) => note.data)\n    .get(\n        '/note/:index',\n        ({ note, params: { index }, error }) => {\n            return note.data[index] ?? error(404, 'oh no :(')\n        },\n        {\n            params: t.Object({\n                index: t.Number()\n            })\n        }\n    )\n```\n\n----------------------------------------\n\nTITLE: Array Type with Length Constraints in ElysiaJS\nDESCRIPTION: Shows how to validate an array of numbers with constraints on the minimum and maximum number of items. This example requires between 1 and 5 items.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/type.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nt.Array(\n    t.Number(),\n    {\n        /**\n         * Minimum number of items\n         */\n        minItems: 1,\n        /**\n         * Maximum number of items\n         */\n        maxItems: 5\n    }\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling in Elysia Server\nDESCRIPTION: This example demonstrates error handling in Elysia. It shows how to handle different error scenarios in a PATCH route, including custom error responses and type-safe body validation.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/midori.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// server.ts\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n    .patch(\n        '/user/profile',\n        ({ body, error }) => {\n            if(body.age < 18) \n                return error(400, \"Oh no\")\n\n            if(body.name === 'Nagisa')\n                return error(418)\n\n            return body\n        },\n        {\n            body: t.Object({\n                name: t.String(),\n                age: t.Number()\n            })\n        }\n    )\n    .listen(80)\n    \nexport type App = typeof app\n```\n\n----------------------------------------\n\nTITLE: Defining Route Schema with Details in ElysiaJS\nDESCRIPTION: Demonstrates how to define a route with schema and additional details for OpenAPI documentation.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/openapi.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { swagger } from '@elysiajs/swagger'\n\nnew Elysia()\n    .use(swagger())\n    .post('/sign-in', ({ body }) => body, {\n        body: t.Object(\n            {\n                username: t.String(),\n                password: t.String({\n                \tminLength: 8,\n                \tdescription: 'User password (at least 8 characters)'\n                })\n            },\n            {\n                description: 'Expected an username and password'\n            }\n        ),\n        detail: {\n            summary: 'Sign in the user',\n            tags: ['authentication']\n        }\n    })\n```\n\n----------------------------------------\n\nTITLE: Using Error and Set.Status in ElysiaJS Handlers\nDESCRIPTION: Shows two methods for returning custom status codes in ElysiaJS: using the error function and set.status property.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.get('/error', ({ error }) => error(418, 'I am a teapot'))\n\t.get('/set.status', ({ set }) => {\n\t\tset.status = 418\n\t\treturn 'I am a teapot'\n\t})\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Context Derivation in Elysia.js\nDESCRIPTION: Demonstrates how to derive new context values from request headers before validation\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .derive(({ headers }) => {\n        const auth = headers['Authorization']\n\n        return {\n            bearer: auth?.startsWith('Bearer ') ? auth.slice(7) : null\n        }\n    })\n    .get('/', ({ bearer }) => bearer)\n```\n\n----------------------------------------\n\nTITLE: Using ElysiaJS Instance as a Service (TypeScript)\nDESCRIPTION: Shows the recommended approach of using an Elysia instance as a service. This maintains type integrity and allows for proper dependency injection while providing scoped functionality.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/best-practice.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\n// âœ… Do\nconst AuthService = new Elysia({ name: 'Service.Auth' })\n    .derive({ as: 'scoped' }, ({ cookie: { session } }) => ({\n    \t// This is equivalent to dependency injection\n        Auth: {\n            user: session.value\n        }\n    }))\n    .macro(({ onBeforeHandle }) => ({\n     \t// This is declaring a service method\n        isSignIn(value: boolean) {\n            onBeforeHandle(({ Auth, error }) => {\n                if (!Auth?.user || !Auth.user) return error(401)\n            })\n        }\n    }))\n\nconst UserController = new Elysia()\n    .use(AuthService)\n    .get('/profile', ({ Auth: { user } }) => user, {\n    \tisSignIn: true\n    })\n```\n\n----------------------------------------\n\nTITLE: Implementing Complete User Authentication with Reference Models\nDESCRIPTION: Extended implementation that adds profile and sign-out functionality to the user authentication system using reference models for schema validation.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nexport const user = new Elysia({ prefix: '/user' })\n    .state({\n        user: {} as Record<string, string>,\n        session: {} as Record<number, string>\n    })\n    .model({\n        signIn: t.Object({\n            username: t.String({ minLength: 1 }),\n            password: t.String({ minLength: 8 })\n        }),\n        session: t.Cookie(\n            {\n                token: t.Number()\n            },\n            {\n                secrets: 'seia'\n            }\n        ),\n        optionalSession: t.Optional(t.Ref('session'))\n    })\n    .put(\n        '/sign-up',\n        async ({ body: { username, password }, store, error }) => {\n            if (store.user[username])\n                return error(400, {\n                    success: false,\n                    message: 'User already exists'\n                })\n\n            store.user[username] = await Bun.password.hash(password)\n\n            return {\n                success: true,\n                message: 'User created'\n            }\n        },\n        {\n            body: 'signIn'\n        }\n    )\n    .post(\n        '/sign-in',\n        async ({\n            store: { user, session },\n            error,\n            body: { username, password },\n            cookie: { token }\n        }) => {\n            if (\n                !user[username] ||\n                !(await Bun.password.verify(password, user[username]))\n            )\n                return error(400, {\n                    success: false,\n                    message: 'Invalid username or password'\n                })\n\n            const key = crypto.getRandomValues(new Uint32Array(1))[0]\n            session[key] = username\n            token.value = key\n\n            return {\n                success: true,\n                message: `Signed in as ${username}`\n            }\n        },\n        {\n            body: 'signIn',\n            cookie: 'optionalSession'\n        }\n    )\n    .get( // \n        '/sign-out', // \n        ({ cookie: { token } }) => { // \n            token.remove() // \n // \n            return { // \n                success: true, // \n                message: 'Signed out' // \n            } // \n        }, // \n        { // \n            cookie: 'optionalSession' // \n        } // \n    ) // \n    .get( // \n        '/profile', // \n        ({ cookie: { token }, store: { session }, error }) => { // \n            const username = session[token.value] // \n // \n            if (!username) // \n                return error(401, { // \n                    success: false, // \n                    message: 'Unauthorized' // \n                }) // \n // \n            return { // \n                success: true, // \n                username // \n            } // \n        }, // \n        { // \n            cookie: 'session' // \n        } // \n    ) // \n```\n\n----------------------------------------\n\nTITLE: Setting up GraphQL Apollo with Elysia\nDESCRIPTION: Demonstrates integration of GraphQL Apollo with Elysia, including type definitions and resolvers for a basic book query.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/integrate-trpc-with-elysia.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { apollo, gql } from '@elysiajs/apollo'\n\nconst app = new Elysia()\n    .use(\n        apollo({\n            typeDefs: gql`\n                type Book {\n                    title: String\n                    author: String\n                }\n\n                type Query {\n                    books: [Book]\n                }\n            `,\n            resolvers: {\n                Query: {\n                    books: () => {\n                        return [\n                            {\n                                title: 'Elysia',\n                                author: 'saltyAom'\n                            }\n                        ]\n                    }\n                }\n            }\n        })\n    )\n    .get('/', () => 'Hello Elysia')\n    .listen(3000)\n\nexport type App = typeof app\n\nconsole.log(`ðŸ¦Š Elysia is running at ${app.server?.hostname}:${app.server?.port}`)\n```\n\n----------------------------------------\n\nTITLE: Sending Emails with Sendgrid in ElysiaJS\nDESCRIPTION: Implementation for sending the OTP email using Sendgrid as the email provider. It renders the React component to HTML and sends it via the Sendgrid API.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/react-email.md#2025-04-23_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nimport OTPEmail from './emails/otp'\n\nimport sendgrid from \"@sendgrid/mail\"\n\nsendgrid.setApiKey(process.env.SENDGRID_API_KEY)\n\nnew Elysia()\n\t.get('/otp', ({ body }) => {\n\t\t// Random between 100,000 and 999,999\n  \t\tconst otp = ~~(Math.random() * (900_000 - 1)) + 100_000\n\n    \tconst html = renderToStaticMarkup(<OTPEmail otp={otp} />)\n\n        await sendgrid.send({\n        \tfrom: 'ibuki@gehenna.sh',\n           \tto: body,\n           \tsubject: 'Verify your email address',\n            html\n        })\n\n        return { success: true }\n\t}, {\n\t\tbody: t.String({ format: 'email' })\n\t})\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Testing ElysiaJS Controllers (TypeScript)\nDESCRIPTION: Demonstrates how to test ElysiaJS controllers using the handle method to directly call a function and its lifecycle. This approach allows for proper unit testing of controller functionality.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/best-practice.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { Service } from './service'\n\nimport { describe, it, should } from 'bun:test'\n\nconst app = new Elysia()\n    .get('/', ({ stuff }) => {\n        Service.doStuff(stuff)\n\n        return 'ok'\n    })\n\ndescribe('Controller', () => {\n\tit('should work', async () => {\n\t\tconst response = await app\n\t\t\t.handle(new Request('http://localhost/'))\n\t\t\t.then((x) => x.text())\n\n\t\texpect(response).toBe('ok')\n\t})\n})\n```\n\n----------------------------------------\n\nTITLE: Custom Content Type Parser\nDESCRIPTION: Shows how to implement a custom content type parser using onParse lifecycle event.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia().onParse(({ request, contentType }) => {\n    if (contentType === 'application/custom-type') return request.text()\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Swagger Tags Configuration\nDESCRIPTION: Example demonstrating how to configure and use Swagger tags for grouping API endpoints\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/swagger.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\napp.use(\n    swagger({\n        documentation: {\n            tags: [\n                { name: 'App', description: 'General endpoints' },\n                { name: 'Auth', description: 'Authentication endpoints' }\n            ]\n        }\n    })\n)\n```\n\n----------------------------------------\n\nTITLE: Explicit Content Type Setting in Elysia - TypeScript\nDESCRIPTION: Shows how to explicitly specify the content type for body parsing in Elysia using the 'type' property. This allows developers to override the default content type detection and force a specific parsing method for request bodies.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-05.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\napp.post('/', ({ body }) => body, {\n    type: 'json'\n})\n```\n\n----------------------------------------\n\nTITLE: Basic WebSocket Setup in ElysiaJS\nDESCRIPTION: Demonstrates the basic setup of a WebSocket endpoint that echoes back received messages.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/websocket.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .ws('/ws', {\n        message(ws, message) {\n            ws.send(message)\n        }\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Correct Controller Implementation\nDESCRIPTION: Shows the recommended way of using Elysia instance as a controller.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/structure.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { Service } from './service'\n\nnew Elysia()\n    .get('/', ({ stuff }) => {\n        Service.doStuff(stuff)\n    })\n```\n\n----------------------------------------\n\nTITLE: Files Type for Multiple File Uploads in ElysiaJS\nDESCRIPTION: Shows how to validate multiple files in a single field, extending the File type to support arrays of files for multiple file uploads.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/type.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nt.Files()\n```\n\n----------------------------------------\n\nTITLE: End-to-End Type Safety Testing with Eden Treaty\nDESCRIPTION: This code snippet demonstrates how to use Eden Treaty to create an end-to-end type safety test for an ElysiaJS server. It sets up a simple GET endpoint and tests it using the treaty function.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/unit-test.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// test/index.test.ts\nimport { describe, expect, it } from 'bun:test'\nimport { Elysia } from 'elysia'\nimport { treaty } from '@elysiajs/eden'\n\nconst app = new Elysia().get('/hello', 'hi')\n\nconst api = treaty(app)\n\ndescribe('Elysia', () => {\n    it('return a response', async () => {\n        const { data, error } = await api.hello.get()\n\n        expect(data).toBe('hi')\n              // ^?\n    })\n})\n```\n\n----------------------------------------\n\nTITLE: Error Handling with Eden Fetch\nDESCRIPTION: Shows how to handle errors when making requests with Eden Fetch, including status code checking and error value handling.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/fetch.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { edenFetch } from '@elysiajs/eden'\nimport type { App } from './server'\n\nconst fetch = edenFetch<App>('http://localhost:3000')\n\n// response type: { id: 1895, name: 'Skadi' }\nconst { data: nendoroid, error } = await fetch('/mirror', {\n    method: 'POST',\n    body: {\n        id: 1895,\n        name: 'Skadi'\n    }\n})\n\nif(error) {\n    switch(error.status) {\n        case 400:\n        case 401:\n            throw error.value\n            break\n\n        case 500:\n        case 502:\n            throw error.value\n            break\n\n        default:\n            throw error.value\n            break\n    }\n}\n\nconst { id, name } = nendoroid\n```\n\n----------------------------------------\n\nTITLE: Defining Wildcard Routes with Elysia (TypeScript)\nDESCRIPTION: This code demonstrates how to use a wildcard ('*') in Elysia route definitions to capture the remainder of a URL path segment. It imports Elysia, defines a server that handles any path matching '/id/*', and responds with the captured value. Prerequisites include Elysia installed and running in a TypeScript environment. The 'params' object provides access to the dynamic segments, with the wildcard stored as the '*' key. Limitations: Does not match '/id' itself; only responds to URLs with at least one additional segment.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/route.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/id/*', ({ params }) => params['*'])\n                    // ^?\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Defining Strict Response Schema in Elysia\nDESCRIPTION: Demonstrates how to define a strict response schema for different HTTP status codes using Elysia's schema validation. This example shows a POST route with specific response types for 200 and 400 status codes.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-04.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\napp.post('/strict-status', process, {\n    schema: {\n        response: {\n            200: t.String(),\n            400: t.Number()\n        }\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Using Node Adapter in Elysia\nDESCRIPTION: Demonstrates how to use the new Node adapter in Elysia 1.2 to run the framework on Node.js runtime.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-12.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { node } from '@elysiajs/node'\n\nnew Elysia({ adapter: node() })\n\t.get('/', 'Hello Node')\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Global Cookie Configuration\nDESCRIPTION: Demonstrates setting up global cookie configuration in the Elysia constructor.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/cookie.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia({\n    cookie: {\n        secrets: 'Fischl von Luftschloss Narfidort',\n        sign: ['profile']\n    }\n})\n    .get('/', ({ cookie: { profile } }) => {\n        profile.value = {\n            id: 617,\n            name: 'Summoning 101'\n        }\n    }, {\n        cookie: t.Cookie({\n            profile: t.Object({\n                id: t.Numeric(),\n                name: t.String()\n            })\n        })\n    })\n```\n\n----------------------------------------\n\nTITLE: Configuring Streaming Endpoint in ElysiaJS - TypeScript\nDESCRIPTION: This example demonstrates initializing an ElysiaJS server and enabling a streaming endpoint using the Stream plugin in manual/callback mode. It imports the necessary dependencies, creates a route that streams two messages (with artificial delay) to the client, and listens on port 3000. To use this snippet, the @elysiajs/stream plugin must be installed and imported.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/stream.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { Stream } from '@elysiajs/stream'\n\nnew Elysia()\n    .get('/', () => new Stream(async (stream) => {\n        stream.send('hello')\n\n        await stream.wait(1000)\n        stream.send('world')\n\n        stream.close()\n    }))\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Setting SameSite Cookie Attribute Elysia.js JavaScript\nDESCRIPTION: This code snippet demonstrates how to set the SameSite attribute of a cookie, accepting either a boolean or a string in Elysia.js. Supported values: true (Strict), false (not set), 'lax', 'none', or 'strict'. No external dependencies are needed. Input: boolean or string; output: cookie with proper SameSite enforcement for cross-site requests. Some clients may not support all options.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/cookie.md#2025-04-23_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\n/*\nSpecifies the boolean or string to be the value for the [SameSite Set-Cookie attribute](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-09#section-5.4.7).\n`true` will set the SameSite attribute to Strict for strict same-site enforcement.\n`false` will not set the SameSite attribute.\n`'lax'` will set the SameSite attribute to Lax for lax same-site enforcement.\n`'none'` will set the SameSite attribute to None for an explicit cross-site cookie.\n`'strict'` will set the SameSite attribute to Strict for strict same-site enforcement.\n*/\n```\n\n----------------------------------------\n\nTITLE: Hiding Routes from Swagger Documentation in ElysiaJS\nDESCRIPTION: Shows how to hide specific routes from appearing in the Swagger documentation.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/openapi.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { swagger } from '@elysiajs/swagger'\n\nnew Elysia()\n    .use(swagger())\n    .post('/sign-in', ({ body }) => body, {\n        body: t.Object(\n            {\n                username: t.String(),\n                password: t.String()\n            },\n            {\n                description: 'Expected an username and password'\n            }\n        ),\n        detail: {\n        \thide: true\n        }\n    })\n```\n\n----------------------------------------\n\nTITLE: Client-side Implementation with Eden for Type-safe API Calls\nDESCRIPTION: Demonstrates how to use the Eden client library to make type-safe API calls to an Elysia server without code generation.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/at-glance.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// client.ts\nimport { treaty } from '@elysiajs/eden'\nimport type { App } from './server'\n\nconst app = treaty<App>('localhost:3000')\n\n// Get data from /user/617\nconst { data } = await app.user({ id: 617 }).get()\n      // ^?\n\nconsole.log(data)\n```\n\n----------------------------------------\n\nTITLE: Implementing Server-Sent Events with Value-based Stream - TypeScript\nDESCRIPTION: This alternative SSE implementation uses a value-based Stream instance. After creating and returning a Stream object, it uses setInterval to periodically send messages and setTimeout to close after 3 seconds. This snippet demonstrates decoupling stream control from route handler instantiation. Requires Elysia, @elysiajs/stream, and clear/close intervals as in the callback-based approach.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/stream.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nnew Elysia()\n    .get('/source', () => {\n        const stream = new Stream()\n\n        const interval = setInterval(() => {\n            stream.send('hello world')\n        }, 500)\n\n        setTimeout(() => {\n            clearInterval(interval)\n            stream.close()\n        }, 3000)\n\n        return stream\n    })\n```\n\n----------------------------------------\n\nTITLE: Creating OpenTelemetry Instrumentation Setup in ElysiaJS\nDESCRIPTION: Example of creating a separate file for OpenTelemetry instrumentation setup, which is required to be loaded before importing instrumented modules.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/opentelemetry.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { opentelemetry } from '@elysiajs/opentelemetry'\nimport { PgInstrumentation } from '@opentelemetry/instrumentation-pg'\n\nexport const instrumentation = opentelemetry({\n\tinstrumentations: [new PgInstrumentation()]\n})\n```\n\n----------------------------------------\n\nTITLE: Using WebSocket with Eden Treaty Client\nDESCRIPTION: This snippet demonstrates how to use WebSockets with Eden Treaty. It shows how to establish a WebSocket connection, subscribe to messages, and send data from the client to the server with full type safety.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/legacy.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// Client\nimport { edenTreaty } from '@elysiajs/eden'\nconst app = edenTreaty<App>('http://localhost:')\n\nconst chat = app.chat.subscribe()\n\nchat.subscribe((message) => {\n    console.log('got', message)\n})\n\nchat.send('hello from client')\n```\n\n----------------------------------------\n\nTITLE: Simplified Numeric Type in Elysia 0.5 - TypeScript\nDESCRIPTION: Demonstrates the new Numeric type in Elysia 0.5 that automatically parses numeric strings into numbers. This approach eliminates the need for manual transformation, making the code more concise and declarative.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-05.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\napp.get('/id/:id', ({ params: { id } }) => id, {\n    params: t.Object({\n        id: t.Numeric()\n    })\n})\n```\n\n----------------------------------------\n\nTITLE: Using Elysia Client with Type Safety\nDESCRIPTION: This snippet shows how to use the Elysia client with full type safety. It demonstrates making API calls, handling errors, and leveraging TypeScript's type inference for response data.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/midori.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// client.ts\nimport { treaty } from '@elysiajs/eden'\nimport type { App } from './server'\n\nconst api = treaty<App>('localhost')\n\nconst { data, error } = await api.user.profile.patch({\n    name: 'saltyaom',\n    age: '21'\n})\n\nif(error)\n    switch(error.status) {\n        case 400:\n            throw error.value\n//                         ^?\n\n        case 418:\n            throw error.value\n//                         ^?\n}\n\ndata\n// ^?\n```\n\n----------------------------------------\n\nTITLE: Setting Up Reference Models in Elysia\nDESCRIPTION: Demonstrates how to use setModel to create reusable schema definitions with type inference and validation\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-02.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new Elysia()\n    .setModel({\n        sign: t.Object({\n            username: t.String(),\n            password: t.String()\n        })\n    })\n    .post('/sign', ({ body }) => body, {\n        schema: {\n            body: 'sign',\n            response: 'sign'\n        }\n    })\n```\n\n----------------------------------------\n\nTITLE: Using Controllers with Type Inference in ElysiaJS\nDESCRIPTION: This example demonstrates how to use controllers while maintaining type inference in ElysiaJS. It shows a recommended approach for applying separate functions like MVC controllers.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/key-concept.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nabstract class Controller {\n\tstatic greet({ name }: { name: string }) {\n\t\treturn 'hello ' + name\n\t}\n}\n\nconst app = new Elysia()\n\t.post('/', ({ body }) => Controller.greet(body), {\n\t\tbody: t.Object({\n\t\t\tname: t.String()\n\t\t})\n\t})\n```\n\n----------------------------------------\n\nTITLE: Registering and Running Cron Job in ElysiaJS - TypeScript\nDESCRIPTION: Demonstrates how to set up a recurring cron job within an ElysiaJS server using the @elysiajs/cron plugin. This snippet imports necessary modules, configures a job named 'heartbeat' that logs a message every 10 seconds using standard cron pattern syntax, and starts the server. It requires that you have previously installed both 'elysia' and '@elysiajs/cron'. Parameters include 'name' (for job identification), 'pattern' (cron schedule), and 'run' (callback function invoked each time the job fires). The server listens on port 3000 by default.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/cron.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { cron } from '@elysiajs/cron'\n\nnew Elysia()\n\t.use(\n\t\tcron({\n\t\t\tname: 'heartbeat',\n\t\t\tpattern: '*/10 * * * * *',\n\t\t\trun() {\n\t\t\t\tconsole.log('Heartbeat')\n\t\t\t}\n\t\t})\n\t)\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Response Redirection\nDESCRIPTION: Demonstrates how to implement response redirection\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/cheat-sheet.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/', () => 'hi')\n    .get('/redirect', ({ redirect }) => {\n        return redirect('/')\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Inferring ElysiaJS Context Type using InferContext Utility (TypeScript)\nDESCRIPTION: Shows how to use the `InferContext` utility type from ElysiaJS to automatically infer the type of the context object based on an Elysia instance's state and decorators. This avoids manual type definition and ensures type safety.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, type InferContext } from 'elysia'\n\nconst setup = new Elysia()\n\t.state('a', 'a')\n\t.decorate('b', 'b')\n\ntype Context = InferContext<typeof setup>\n\nconst handler = ({ store }: Context) => store.a\n```\n\n----------------------------------------\n\nTITLE: Type Inference in ElysiaJS\nDESCRIPTION: This snippet illustrates type inference in ElysiaJS. It shows how to use inline functions and schema validation to achieve accurate type inference for request bodies.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/key-concept.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n\t.post('/', ({ body }) => body, {\n\t\tbody: t.Object({\n\t\t\tname: t.String()\n\t\t})\n\t})\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Fetcher in Eden Treaty\nDESCRIPTION: Demonstrates how to provide a custom fetcher function instead of using the default fetch. This is useful when integrating with other HTTP clients like Axios or unfetch.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/config.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ntreaty<App>('localhost:3000', {\n    fetcher(url, options) {\n        return fetch(url, options)\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Using Record Utility with ElysiaJS OpenTelemetry\nDESCRIPTION: Example of using the 'record' utility to capture and trace a database query operation with OpenTelemetry in ElysiaJS.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/opentelemetry.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { record } from '@elysiajs/opentelemetry'\n\nexport const plugin = new Elysia().get('', () => {\n\treturn record('database.query', () => {\n\t\treturn db.query('SELECT * FROM users')\n\t})\n})\n```\n\n----------------------------------------\n\nTITLE: JSON Body Schema with Static Code Analysis in Elysia - TypeScript\nDESCRIPTION: Demonstrates how Static Code Analysis allows Elysia to optimize performance by detecting that a route expects a JSON body. The schema defines an object with username and password fields, enabling Elysia to parse the body as JSON instead of relying on dynamic Content-Type header checking.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-05.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\napp.post('/sign-in', ({ body }) => signIn(body), {\n    schema: {\n        body: t.Object({\n            username: t.String(),\n            password: t.String()\n        })\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Using URL Prefix with Route Definition in Elysia\nDESCRIPTION: Demonstrates how the prefix option affects route paths. This example shows that with a '/v1' prefix, a route defined as '/name' will actually be accessible at '/v1/name'.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/configuration.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia({ prefix: '/v1' }).get('/name', 'elysia') // Path is /v1/name\n```\n\n----------------------------------------\n\nTITLE: Decorating ElysiaJS Context with Multiple Properties using Object Pattern (TypeScript)\nDESCRIPTION: Shows how to use the `decorate` method with an object literal to add multiple properties (logger, trace, telemetry instances) to the ElysiaJS context simultaneously. This offers a less repetitive API compared to multiple key-value assignments.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\n// Assuming Logger, Trace, and Telemetry classes are defined elsewhere\nclass Logger {}\nclass Trace {}\nclass Telemetry {}\n\nnew Elysia()\n    .decorate({\n        logger: new Logger(),\n        trace: new Trace(),\n        telemetry: new Telemetry()\n    })\n```\n\n----------------------------------------\n\nTITLE: Enabling Native Static Response Optimization in Elysia\nDESCRIPTION: Shows how to enable runtime-specific optimizations for static responses. When enabled, Elysia will use optimized functions for handling static values based on the current runtime.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/configuration.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia({\n\tnativeStaticResponse: true\n})\n```\n\n----------------------------------------\n\nTITLE: Non-request Dependent Service in ElysiaJS (TypeScript)\nDESCRIPTION: Shows how to implement a service that doesn't depend on request properties in ElysiaJS. This pattern uses a static class for functionality that doesn't need to access Context properties.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/best-practice.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nabstract class Service {\n    static fibo(number: number): number {\n        if(number < 2)\n            return number\n\n        return Service.fibo(number - 1) + Service.fibo(number - 2)\n    }\n}\n\nnew Elysia()\n    .get('/fibo', ({ body }) => {\n        return Service.fibo(body)\n    }, {\n        body: t.Numeric()\n    })\n```\n\n----------------------------------------\n\nTITLE: Mapping and Compressing HTTP Responses with Elysia (TypeScript)\nDESCRIPTION: Implements the `mapResponse` lifecycle hook in Elysia to compress outgoing responses using gzip. The provided function serializes and encodes responses conditionally (JSON or string), applies gzip compression with Bun, and returns them with appropriate headers. Dependencies: `elysia` and Bun runtime; expects an Elysia context and utilizes the `TextEncoder` API. Routes \"/text\" and \"/json\" are demonstrated. Output is compressed HTTP responses with accurate `Content-Encoding` and `Content-Type` headers.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst encoder = new TextEncoder()\n\nnew Elysia()\n    .mapResponse(({ response, set }) => {\n        const isJson = typeof response === 'object'\n\n        const text = isJson\n            ? JSON.stringify(response)\n            : (response?.toString() ?? '')\n\n        set.headers['Content-Encoding'] = 'gzip'\n\n        return new Response(Bun.gzipSync(encoder.encode(text)), {\n            headers: {\n                'Content-Type': `${\n                    isJson ? 'application/json' : 'text/plain'\n                }; charset=utf-8`\n            }\n        })\n    })\n    .get('/text', () => 'mapResponse')\n    .get('/json', () => ({ map: 'response' }))\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Hook Type Inheritance Example\nDESCRIPTION: Comprehensive example showing how different hook types affect inheritance across multiple Elysia instances.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-10.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst type = 'local'\n\nconst child = new Elysia()\n    .get('/child', () => 'hello')\n\nconst current = new Elysia()\n    .onBeforeHandle({ as: type }, () => {\n        console.log('hi')\n    })\n    .use(child)\n    .get('/current', () => 'hello')\n\nconst parent = new Elysia()\n    .use(current)\n    .get('/parent', () => 'hello')\n\nconst main = new Elysia()\n    .use(parent)\n    .get('/main', () => 'hello')\n```\n\n----------------------------------------\n\nTITLE: Using Fetch Parameters with Eden Treaty in TypeScript\nDESCRIPTION: This example demonstrates how to use Fetch API parameters, such as AbortController, with Eden Treaty requests.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/parameters.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { treaty } from '@elysiajs/eden'\n\nconst app = new Elysia()\n    .get('/hello', () => 'hi')\n    .listen(3000)\n\nconst api = treaty<typeof app>('localhost:3000')\n\nconst controller = new AbortController()\n\nconst cancelRequest = setTimeout(() => {\n    controller.abort()\n}, 5000)\n\nawait api.hello.get({\n    fetch: {\n        signal: controller.signal\n    }\n})\n\nclearTimeout(cancelRequest)\n```\n\n----------------------------------------\n\nTITLE: Using Resolve in Macro v2\nDESCRIPTION: Demonstrates how to add properties to the context using the resolve function in a macro. This example adds a user property to the context.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/macro.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.macro({\n\t\tuser: (enabled: true) => ({\n\t\t\tresolve: () => ({\n\t\t\t\tuser: 'Pardofelis'\n\t\t\t})\n\t\t})\n\t})\n\t.get('/', ({ user }) => user, {\n                          // ^?\n\t\tuser: true\n\t})\n```\n\n----------------------------------------\n\nTITLE: Setting Up Status-Based Error Types in Elysia Server\nDESCRIPTION: This snippet shows how to define specific error types for different HTTP status codes in an Elysia server. It uses the model and response properties to map status codes to specific schema definitions for better type safety.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/legacy.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// server.ts\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n    .model({\n        nendoroid: t.Object({\n            id: t.Number(),\n            name: t.String()\n        }),\n        error: t.Object({\n            message: t.String()\n        })\n    })\n    .get('/', () => 'Hi Elysia')\n    .get('/id/:id', ({ params: { id } }) => id)\n    .post('/mirror', ({ body }) => body, {\n        body: 'nendoroid',\n        response: {\n            200: 'nendoroid', // [!code ++]\n            400: 'error', // [!code ++]\n            401: 'error' // [!code ++]\n        }\n    })\n    .listen(3000)\n\nexport type App = typeof app\n```\n\n----------------------------------------\n\nTITLE: Implementing Eden Client with Type Safety\nDESCRIPTION: Demonstrates how to set up an Eden client with full type inference from the server, enabling type-safe API calls.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/integrate-trpc-with-elysia.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { edenTreaty } from '@elysiajs/eden'\nimport type { App } from '../server'\n\n// This now has all type inference from the server\nconst app = edenTreaty<App>('http://localhost:3000')\n\n// data will have a value of 'Hello Elysia' and has a type of 'string'\nconst data = await app.index.get()\n```\n\n----------------------------------------\n\nTITLE: Handling All HTTP Methods for a Path with Elysia.all (TypeScript)\nDESCRIPTION: This example demonstrates the use of Elysia.all to handle any HTTP verb on a specific path. The route '/' will respond to all incoming methods (GET, POST, DELETE, etc.) with 'hi'. No method-specific logic is present. Requires Elysia set up, and is useful for catch-all or multipurpose endpoints. Limitation: not for fine-grained per-method logic.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/route.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .all('/', 'hi')\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Automatic Boolean Transformation for Route Params - Elysia - TypeScript\nDESCRIPTION: Shows how Elysia converts t.Boolean to t.BooleanString for route parameters, but does not perform this transformation in nested object or body schemas. Requires Elysia and TypeBox (t) imports. The code contrasts automatic conversion for route parameter schemas with the non-conversion in nested or body schemas. Used for simplifying Boolean handling in routes; only parameters at the route schema level are affected.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/type.md#2025-04-23_snippet_17\n\nLANGUAGE: ts\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n\t.get('/:id', ({ id }) => id, {\n\t\tparams: t.Object({\n\t\t\t// Converted to t.Boolean()\n\t\t\tid: t.Boolean()\n\t\t}),\n\t\tbody: t.Object({\n\t\t\t// NOT converted to t.Boolean()\n\t\t\tid: t.Boolean()\n\t\t})\n\t})\n\n// NOT converted to t.BooleanString()\nt.Boolean()\n```\n\n----------------------------------------\n\nTITLE: Cookie Setup for Session Management\nDESCRIPTION: Implementation of secure cookie handling for managing user sessions with configurable security options.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-supabase.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { cookie } from '@elysiajs/cookie'\n\nimport { supabase } from '../../libs'\n\nconst authen = (app: Elysia) =>\n    app.group('/auth', (app) =>\n        app\n            .use(\n                cookie({\n                    httpOnly: true,\n                    // If you need cookie to deliver via https only\n                    // secure: true,\n                    //\n                    // If you need a cookie to be available for same-site only\n                    // sameSite: \"strict\",\n                    //\n                    // If you want to encrypt a cookie\n                    // signed: true,\n                    // secret: process.env.COOKIE_SECRET,\n                })\n            )\n            .setModel({\n                sign: t.Object({\n                    email: t.String({\n                        format: 'email'\n                    }),\n                    password: t.String({\n                        minLength: 8\n                    })\n                })\n            })\n    )\n```\n\n----------------------------------------\n\nTITLE: Installing Swagger Plugin for ElysiaJS\nDESCRIPTION: Command to install the Swagger plugin using Bun package manager\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/swagger.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun add @elysiajs/swagger\n```\n\n----------------------------------------\n\nTITLE: Response Header Modification in Elysia.js\nDESCRIPTION: Demonstrates how to modify response headers using afterHandle hook\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { isHtml } from '@elysiajs/html'\n\nnew Elysia()\n    .get('/', () => '<h1>Hello World</h1>', {\n        afterHandle({ response, set }) {\n            if (isHtml(response))\n                set.headers['content-type'] = 'text/html; charset=utf8'\n        }\n    })\n    .get('/hi', () => '<h1>Hello World</h1>')\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Creating Plugins with Elysia Instances (New Approach)\nDESCRIPTION: Demonstrates the new plugin model in Elysia 0.6 that allows turning any Elysia instance into a plugin directly, eliminating the need for callback functions and improving code organization.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-06.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst plugin = new Elysia()\n    .get('/', () => 'hello')\n```\n\n----------------------------------------\n\nTITLE: XSS Protection Example\nDESCRIPTION: Implementation of XSS protection using the safe attribute in JSX components\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/html.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { html, Html } from '@elysiajs/html'\n\nnew Elysia()\n\t.use(html())\n\t.post(\n\t\t'/',\n\t\t({ body }) => (\n\t\t\t<html lang=\"en\">\n\t\t\t\t<head>\n\t\t\t\t\t<title>Hello World</title>\n\t\t\t\t</head>\n\t\t\t\t<body>\n\t\t\t\t\t<h1 safe>{body}</h1>\n\t\t\t\t</body>\n\t\t\t</html>\n\t\t),\n\t\t{\n\t\t\tbody: t.String()\n\t\t}\n\t)\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Implementing Default Query Parameters in Elysia\nDESCRIPTION: Demonstrates how to set default values for query parameters using TypeBox's new default field support. The example shows setting a default value 'Elysia' for the name query parameter.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-08.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/', ({ query: { name } }) => name, {\n        query: t.Object({\n            name: t.String({\n                default: 'Elysia'\n            })\n        })\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Inline Error Implementation\nDESCRIPTION: Demonstrates the new inline error handling with type-safe status codes and responses.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-10.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/hello', ({ error }) => {\n        if(Math.random() > 0.5) return error(418, 'Nagisa')\n\n        return 'Azusa'\n    }, {\n        response: t.Object({\n            200: t.Literal('Azusa'),\n            418: t.Literal('Nagisa')\n        })\n    })\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Authentication Macro in Elysia.js\nDESCRIPTION: This snippet demonstrates how to create a custom 'isSignIn' macro that implements authentication logic. The macro checks if a user is signed in by validating their token and session before allowing access to a route.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nexport const userService = new Elysia({ name: 'user/service' })\n    .state({\n        user: {} as Record<string, string>,\n        session: {} as Record<number, string>\n    })\n    .model({\n        signIn: t.Object({\n            username: t.String({ minLength: 1 }),\n            password: t.String({ minLength: 8 })\n        }),\n        session: t.Cookie(\n            {\n                token: t.Number()\n            },\n            {\n                secrets: 'seia'\n            }\n        ),\n        optionalSession: t.Optional(t.Ref('session'))\n    })\n    .macro({\n        isSignIn(enabled: boolean) { \n            if (!enabled) return \n\n\t\t\treturn {\n\t            beforeHandle({ error, cookie: { token }, store: { session } }) { \n                    if (!token.value) \n                        return error(401, { \n                            success: false, \n                            message: 'Unauthorized' \n                        }) \n\n                    const username = session[token.value as unknown as number] \n\n                    if (!username) \n                        return error(401, { \n                            success: false, \n                            message: 'Unauthorized' \n                        }) \n                } \n\t\t\t} \n        } \n    })\n```\n\n----------------------------------------\n\nTITLE: Installing Drizzle with TypeBox for Elysia Integration\nDESCRIPTION: Commands for installing drizzle-orm and drizzle-typebox packages, and instructions for pinning the @sinclair/typebox version to avoid conflicts.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/drizzle.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun add drizzle-orm drizzle-typebox\n```\n\nLANGUAGE: bash\nCODE:\n```\ngrep \"@sinclair/typebox\" node_modules/elysia/package.json\n```\n\n----------------------------------------\n\nTITLE: GraphQL Context Configuration\nDESCRIPTION: Example showing how to add custom context to GraphQL resolvers and use it within resolver functions.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/graphql-yoga.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { yoga } from '@elysiajs/graphql-yoga'\n\nconst app = new Elysia()\n\t.use(\n\t\tyoga({\n\t\t\ttypeDefs: /* GraphQL */ `\n\t\t\t\ttype Query {\n\t\t\t\t\thi: String\n\t\t\t\t}\n\t\t\t`,\n\t\t\tcontext: {\n\t\t\t\tname: 'Mobius'\n\t\t\t},\n\t\t\tuseContext(_) {},\n\t\t\tresolvers: {\n\t\t\t\tQuery: {\n\t\t\t\t\thi: async (parent, args, context) => context.name\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t)\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Mounting Scoped and Unscoped Elysia Instances - TypeScript\nDESCRIPTION: Shows the deprecation of the `scoped` option in Elysia's constructor as of version 1.2, previously used to denote scoped/global distinction. The snippet demonstrates removing the `scoped` configuration, constructing instances normally, and mounting them for modular route composition. Relies on the `elysia` package. Instantiates Elysia servers and composes them using `.mount()`, with old and new approaches annotated. This clarifies instance scoping for future code and modular design patterns.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-12.md#2025-04-23_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia({ scoped: false }) // [!code --]\n\nconst scoped = new Elysia() // [!code ++]\n\nconst main = new Elysia() // [!code ++]\n\t.mount(scoped) // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Integrating OpenTelemetry with Elysia in TypeScript\nDESCRIPTION: Demonstrates how to add OpenTelemetry support to an Elysia application using the @elysiajs/opentelemetry plugin. It sets up span processors and exporters for collecting telemetry data.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-11.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { opentelemetry } from '@elysiajs/opentelemetry'\n\nimport { BatchSpanProcessor } from '@opentelemetry/sdk-trace-node'\nimport { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-proto'\n\nnew Elysia()\n\t.use(\n\t\topentelemetry({\n\t\t\tspanProcessors: [\n\t\t\t\tnew BatchSpanProcessor(\n\t\t\t\t\tnew OTLPTraceExporter()\n\t\t\t\t)\n\t\t\t]\n\t\t})\n\t)\n```\n\n----------------------------------------\n\nTITLE: Workaround for Route Limit in Elysia 0.x\nDESCRIPTION: Demonstrates the previous workaround for overcoming the route limit by separating routes into controllers and using them as plugins.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-10.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst controller1 = new Elysia()\n    .get('/42', () => '42')\n    .get('/43', () => '43')\n\nconst main = new Elysia()\n    .get('/1', () => '1')\n    .get('/2', () => '2')\n    // repeat for 40 times\n    .use(controller1)\n```\n\n----------------------------------------\n\nTITLE: Body Schema Type Detection\nDESCRIPTION: Demonstrates how Elysia automatically determines the appropriate body parser based on schema definition.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia().post('/', ({ body }) => body, {\n    body: t.Object({\n        username: t.String(),\n        password: t.String()\n    })\n})\n```\n\n----------------------------------------\n\nTITLE: Schema Validation for Authentication Routes\nDESCRIPTION: Adding schema validation to ensure proper data structure for authentication requests using Elysia's built-in type system.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-supabase.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { supabase } from '../../libs'\n\nconst authen = (app: Elysia) =>\n    app.group('/auth', (app) =>\n        app\n            .setModel({\n                sign: t.Object({\n                    email: t.String({\n                        format: 'email'\n                    }),\n                    password: t.String({\n                        minLength: 8\n                    })\n                })\n            })\n            .post('/sign-up', async ({ body }) => {\n                const { data, error } = await supabase.auth.signUp(body)\n                if (error) return error\n                return data.user\n            },\n            {\n                schema: {\n                    body: 'sign'\n                }\n            })\n            .post('/sign-in', async ({ body }) => {\n                const { data, error } = await supabase.auth.signInWithPassword(body)\n                if (error) return error\n                return data.user\n            },\n            {\n                schema: {\n                    body: 'sign'\n                }\n            })\n    )\n```\n\n----------------------------------------\n\nTITLE: Handling File Upload with Eden Treaty Client\nDESCRIPTION: This snippet shows how to upload files using Eden Treaty. It demonstrates getting files from an HTML input element and sending them with a multipart/form-data request to the server.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/legacy.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// client.ts\nimport { edenTreaty } from '@elysia/eden'\nimport type { Server } from './server'\n\nexport const client = edenTreaty<Server>('http://localhost:3000')\n\nconst id = <T extends HTMLElement = HTMLElement>(id: string) =>\n    document.getElementById(id)! as T\n\nconst { data } = await client.image.post({\n    title: \"Misono Mika\",\n    image: id<HTMLInputElement>('picture').files!,\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Up WebSocket Server in Elysia\nDESCRIPTION: This code shows how to create a WebSocket endpoint in an Elysia server. It defines a chat endpoint with message handling and type definitions for both request and response bodies.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/legacy.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// Server\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n    .ws('/chat', {\n        message(ws, message) {\n            ws.send(message)\n        },\n        body: t.String(),\n        response: t.String()\n    })\n    .listen(3000)\n\ntype App = typeof app\n```\n\n----------------------------------------\n\nTITLE: Multiple Elysia Projects Integration\nDESCRIPTION: Example showing how to mount multiple existing Elysia projects into a single application instance.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/mount.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nimport A from 'project-a/elysia'\nimport B from 'project-b/elysia'\nimport C from 'project-c/elysia'\n\nnew Elysia()\n    .mount(A)\n    .mount(B)\n    .mount(C)\n```\n\n----------------------------------------\n\nTITLE: Implementing Drizzle Table Schema Singleton Pattern\nDESCRIPTION: TypeScript implementation of a singleton pattern for storing and accessing Drizzle table schemas throughout an application, using the spreads utility function.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/drizzle.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { table } from './schema'\nimport { spreads } from './utils'\n\nexport const db = {\n\tinsert: spreads({\n\t\tuser: table.user,\n\t}, 'insert'),\n\tselect: spreads({\n\t\tuser: table.user,\n\t}, 'select')\n} as const\n```\n\n----------------------------------------\n\nTITLE: Configuring Elysia with Prefix in Astro Subdirectory\nDESCRIPTION: Sets up an Elysia server in a subdirectory of Astro pages with a prefix configuration to ensure proper routing. This is necessary when the Elysia server is not placed at the root of the app router.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/astro.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// pages/api/[...slugs].ts\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia({ prefix: '/api' }) // [!code ++]\n    .get('/', () => 'hi')\n    .post('/', ({ body }) => body, {\n        body: t.Object({\n            name: t.String()\n        })\n    })\n\nconst handle = ({ request }: { request: Request }) => app.handle(request) // [!code ++]\n\nexport const GET = handle // [!code ++]\nexport const POST = handle // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Using Resolve to Create Computed Properties in Elysia.js\nDESCRIPTION: This snippet demonstrates using the 'resolve' hook to define computed properties based on request data. It creates a 'username' property derived from session data, available after validation and before route handlers.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nexport const userService = new Elysia({ name: 'user/service' })\n    .state({\n        user: {} as Record<string, string>,\n        session: {} as Record<number, string>\n    })\n    .model({\n        signIn: t.Object({\n            username: t.String({ minLength: 1 }),\n            password: t.String({ minLength: 8 })\n        }),\n        session: t.Cookie(\n            {\n                token: t.Number()\n            },\n            {\n                secrets: 'seia'\n            }\n        ),\n        optionalSession: t.Optional(t.Ref('session'))\n    })\n    .macro({\n        isSignIn(enabled: boolean) {\n            if (!enabled) return\n\n            return {\n            \tbeforeHandle({ error, cookie: { token }, store: { session } }) {\n                    if (!token.value)\n                        return error(401, {\n                            success: false,\n                            message: 'Unauthorized'\n                        })\n\n                    const username = session[token.value as unknown as number]\n\n                    if (!username)\n                        return error(401, {\n                            success: false,\n                            message: 'Unauthorized'\n                        })\n                }\n            }\n        }\n    })\n\nexport const getUserId = new Elysia() \n    .use(userService) \n    .guard({ \n        cookie: 'session' \n    }) \n    .resolve(({ store: { session }, cookie: { token } }) => ({ \n        username: session[token.value] \n    }))\n```\n\n----------------------------------------\n\nTITLE: Using Spread Utility vs. t.Pick for Schema Manipulation\nDESCRIPTION: TypeScript examples comparing the use of the spread utility function versus t.Pick for manipulating Drizzle schema properties when creating Elysia validation models.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/drizzle.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// âœ… Using spread utility function\nconst user = spread(table.user, 'insert')\n\nconst createUser = t.Object({\n\tid: user.id, // { type: 'string' }\n\tusername: user.username, // { type: 'string' }\n\tpassword: user.password // { type: 'string' }\n})\n\n// âš ï¸ Using t.Pick\nconst _createUser = createInsertSchema(table.user)\n\nconst createUser = t.Pick(\n\t_createUser,\n\t['id', 'username', 'password']\n)\n```\n\n----------------------------------------\n\nTITLE: Template Literal Type Validation with TypeBox in Elysia - TypeScript\nDESCRIPTION: Demonstrates TypeBox 0.28's template literal validation capabilities in Elysia. This example validates string patterns by defining a model with a TemplateLiteral type that matches specific string patterns, allowing for strict type checking of string values.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-05.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nnew Elysia()\n    .decorate('version', 'Elysia Radiant')\n    .model(\n        'name',\n        Type.TemplateLiteral([\n            Type.Literal('Elysia '),\n            Type.Union([\n                Type.Literal('The Blessing'),\n                Type.Literal('Radiant')\n            ])\n        ])\n    )\n    // Strictly check for template literal\n    .get('/', ({ version }) => version)\n```\n\n----------------------------------------\n\nTITLE: Configuring Strict Path Behavior in Elysia.js\nDESCRIPTION: Shows how to configure strict path handling behavior by setting the strictPath option in Elysia configuration.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-06.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nnew Elysia({\n    strictPath: false\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Elysia.js for Railway Deployment\nDESCRIPTION: Code snippet demonstrating how to modify an Elysia.js server to use the PORT environment variable provided by Railway, with a fallback for development environments.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/deployment.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nnew Elysia()\n\t.listen(3000) // [!code --]\n\t.listen(process.env.PORT ?? 3000) // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: FormData Handling in Elysia\nDESCRIPTION: Shows how to return FormData and files using Elysia's form and file utilities.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, form, file } from 'elysia'\n\nnew Elysia()\n\t.get('/', () => form({\n\t\tname: 'Tea Party',\n\t\timages: [file('nagi.web'), file('mika.webp')]\n\t}))\n\t.listen(3000)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, file } from 'elysia'\n\nnew Elysia()\n\t.get('/', file('nagi.web'))\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Group and Guard Pattern in Elysia\nDESCRIPTION: Examples showing both old and new syntax for combining group and guard functionality\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-05.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// âœ… previously, you need to nest guard inside a group\napp.group('/v1', (app) =>\n    app.guard(\n        {\n            body: t.Literal()\n        },\n        (app) => app.get('/student', () => 'Rikuhachima Aru')\n    )\n)\n\n// âœ… new, compatible with old syntax\napp.group(\n    '/v1', {\n        body: t.Literal('Rikuhachima Aru')\n    },\n    app => app.get('/student', () => 'Rikuhachima Aru')\n)\n\n// âœ… compatible with function overload\napp.group('/v1', app => app.get('/student', () => 'Rikuhachima Aru'))\n```\n\n----------------------------------------\n\nTITLE: Creating an Authentication Macro in ElysiaJS v2\nDESCRIPTION: Shows how to create an authentication macro in v2 that adds user data to the context. This example demonstrates using resolve to add properties to the context.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/macro.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// @filename: auth.ts\nimport { Elysia } from 'elysia'\n\nexport const auth = new Elysia()\n    .macro({\n    \tisAuth: {\n      \t\tresolve() {\n     \t\t\treturn {\n         \t\t\tuser: 'saltyaom'\n          \t\t}\n      \t\t}\n        },\n        role(role: 'admin' | 'user') {\n        \treturn {}\n        }\n    })\n\n// @filename: index.ts\n// ---cut---\nimport { Elysia } from 'elysia'\nimport { auth } from './auth'\n\nconst app = new Elysia()\n    .use(auth)\n    .get('/', ({ user }) => user, {\n                          // ^?\n        isAuth: true,\n        role: 'admin'\n    })\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Routes in Elysia\nDESCRIPTION: Shows how to use the new .if method to create conditional routes or apply plugins based on specific conditions. This example demonstrates excluding Swagger documentation in a production environment.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-04.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst isProduction = process.env.NODE_ENV === 'production'\n\nconst app = new Elysia().if(!isProduction, (app) =>\n    app.use(swagger())\n)\n```\n\n----------------------------------------\n\nTITLE: Lifting ElysiaJS Plugin Scope using 'as(\\'plugin\\')'\nDESCRIPTION: Demonstrates the use of `.as('plugin')` on an Elysia instance (`instance`) to 'lift' the scope of its contained plugins and their associated hooks/schemas (like the `guard` from `plugin`) up to the parent instance (`parent`). This makes the 'scoped' guard effectively apply to the `parent` instance as well, potentially causing type errors on routes in `parent` (like `/ok`) that previously didn't fall under the guard's schema. Requires `elysia` and `t` imports.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-11.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// @errors: 2304 2345\nimport { Elysia, t } from 'elysia'\n\nconst plugin = new Elysia()\n\t.guard({\n\t\tas: 'scoped',\n\t\tresponse: t.String()\n\t})\n\t.get('/ok', () => 'ok')\n\t.get('/not-ok', () => 1)\n\nconst instance = new Elysia()\n\t.use(plugin)\n\t.as('plugin') // [!code ++]\n\t.get('/no-ok-parent', () => 2)\n\nconst parent = new Elysia()\n\t.use(instance)\n\t// This now error because `scoped` is lifted up to parent\n\t.get('/ok', () => 3)\n```\n\n----------------------------------------\n\nTITLE: Stopping Named Cron Jobs Dynamically - ElysiaJS in TypeScript\nDESCRIPTION: Shows how to manually stop a running cron job by referencing it from the ElysiaJS store API. After registering a job named 'heartbeat', a GET endpoint '/stop' is defined. When '/stop' is requested, it stops the 'heartbeat' job using its name from the store and returns a confirmation message. Requires both 'elysia' and '@elysiajs/cron'. Key parameters are the cron configuration for registration and the endpoint handler for dynamic job management.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/cron.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { cron } from '@elysiajs/cron'\n\nconst app = new Elysia()\n\t.use(\n\t\tcron({\n\t\t\tname: 'heartbeat',\n\t\t\tpattern: '*/1 * * * * *',\n\t\t\trun() {\n\t\t\t\tconsole.log('Heartbeat')\n\t\t\t}\n\t\t})\n\t)\n\t.get(\n\t\t'/stop',\n\t\t({\n\t\t\tstore: {\n\t\t\t\tcron: { heartbeat }\n\t\t\t}\n\t\t}) => {\n\t\t\theartbeat.stop()\n\n\t\t\treturn 'Stop heartbeat'\n\t\t}\n\t)\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Inferring Context Type from ElysiaJS Instance (TypeScript)\nDESCRIPTION: Shows how to infer the Context type from an Elysia instance when necessary. This approach should be used sparingly, with the recommendation to use Elysia as a service instead.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/best-practice.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, type InferContext } from 'elysia'\n\nconst setup = new Elysia()\n\t.state('a', 'a')\n\t.decorate('b', 'b')\n\nclass AuthService {\n\tconstructor() {}\n\n\t// âœ… Do\n\tisSignIn({ cookie: { session } }: InferContext<typeof setup>) {\n\t\tif (session.value)\n\t\t\treturn error(401)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: UnionEnum Type for Enumeration Values in ElysiaJS\nDESCRIPTION: Shows how to create a validator that only accepts one of the specified values, supporting mixed types including strings, numbers, and booleans.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/type.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nt.UnionEnum(['rapi', 'anis', 1, true, false])\n```\n\n----------------------------------------\n\nTITLE: Catching and Transforming Errors with Elysia Middleware (TypeScript)\nDESCRIPTION: Demonstrates Elysia's `onError` middleware to catch and transform runtime errors into custom responses. Dependencies: `elysia` package. Defines an error handler that returns a plain text response of the error. Instantiates a GET route that throws an error, illustrating error catching behavior. Input: thrown error in request; output: custom response with error string.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .onError(({ code, error }) => {\n        return new Response(error.toString())\n    })\n    .get('/', () => {\n        throw new Error('Server is during maintenance')\n\n        return 'unreachable'\n    })\n```\n\n----------------------------------------\n\nTITLE: Custom Context Implementation\nDESCRIPTION: Shows how to add custom variables and methods to the route context\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/cheat-sheet.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .state('version', 1)\n    .decorate('getDate', () => Date.now())\n    .get('/version', ({\n        getDate,\n        store: { version }\n    }) => `${version} ${getDate()}`)\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Cron Function Type Signature - TypeScript\nDESCRIPTION: Specifies the function signature for the 'cron' utility as used within Elysia. It defines input types, expected arguments (the configuration object and instance-specific callback), and the returned server instance context for chaining. Useful for understanding type constraints and integration points when composing advanced ElysiaJS middleware. Requires familiarity with TypeScript and ElysiaJS server internals.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/cron.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ncron(config: CronConfig, callback: (Instance['store']) => void): this\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Eden Treaty Parameters in TypeScript with ElysiaJS\nDESCRIPTION: This snippet shows how to use Eden Treaty parameters for a POST request, including both body and additional parameters like headers and query.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/parameters.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { treaty } from '@elysiajs/eden'\n\nconst app = new Elysia()\n    .post('/user', ({ body }) => body, {\n        body: t.Object({\n            name: t.String()\n        })\n    })\n    .listen(3000)\n\nconst api = treaty<typeof app>('localhost:3000')\n\n// âœ… works\napi.user.post({\n    name: 'Elysia'\n})\n\n// âœ… also works\napi.user.post({\n    name: 'Elysia'\n}, {\n    // This is optional as not specified in schema\n    headers: {\n        authorization: 'Bearer 12345'\n    },\n    query: {\n        id: 2\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Enabling Ahead of Time Compilation in Elysia\nDESCRIPTION: Demonstrates enabling Elysia's built-in JIT compiler to optimize performance. When set to true, Elysia will precompile routes before starting the server for better runtime performance.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/configuration.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia({\n\taot: true\n})\n```\n\n----------------------------------------\n\nTITLE: Mounting WinterCG-Compliant Frameworks in Elysia\nDESCRIPTION: Shows how to use the new mount method to integrate other WinterCG-compliant frameworks (like Hono) within an Elysia application using their fetch handlers.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-06.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = new Elysia()\n    .get('/', () => 'Hello from Elysia')\n    .mount('/hono', hono.fetch)\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple Path Parameters in ElysiaJS\nDESCRIPTION: This example demonstrates how to use multiple path parameters in a single route. It shows how to extract both 'id' and 'name' parameters from the URL.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/route.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/id/:id', ({ params: { id } }) => id)\n    .get('/id/:id/:name', ({ params: { id, name } }) => id + ' ' + name)\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Request Dependent Service Implementation\nDESCRIPTION: Shows the recommended way of implementing a service that depends on request context using Elysia instance.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/structure.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst AuthService = new Elysia({ name: 'Service.Auth' })\n    .derive({ as: 'scoped' }, ({ cookie: { session } }) => ({\n        Auth: {\n            user: session.value\n        }\n    }))\n    .macro(({ onBeforeHandle }) => ({\n        isSignIn(value: boolean) {\n            onBeforeHandle(({ Auth, error }) => {\n                if (!Auth?.user || !Auth.user) return error(401)\n            })\n        }\n    }))\n\nconst UserController = new Elysia()\n    .use(AuthService)\n    .get('/profile', ({ Auth: { user } }) => user, {\n    \tisSignIn: true\n    })\n```\n\n----------------------------------------\n\nTITLE: Sending Emails with Resend in ElysiaJS\nDESCRIPTION: Implementation for sending the OTP email using Resend as the email provider. It passes the React component directly to Resend's API.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/react-email.md#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nimport OTPEmail from './emails/otp'\n\nimport Resend from 'resend'\n\nconst resend = new Resend('re_123456789')\n\nnew Elysia()\n\t.get('/otp', ({ body }) => {\n\t\t// Random between 100,000 and 999,999\n  \t\tconst otp = ~~(Math.random() * (900_000 - 1)) + 100_000\n\n        await resend.emails.send({\n        \tfrom: 'ibuki@gehenna.sh',\n           \tto: body,\n           \tsubject: 'Verify your email address',\n            html: <OTPEmail otp={otp} />,\n        })\n\n        return { success: true }\n\t}, {\n\t\tbody: t.String({ format: 'email' })\n\t})\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: File Type for File Upload Validation in ElysiaJS\nDESCRIPTION: Demonstrates how to create a validator for file uploads, which can include constraints for file type, minimum size, and maximum size.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/type.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nt.File()\n```\n\n----------------------------------------\n\nTITLE: MaybeEmpty Type for Allowing Null and Undefined Values in ElysiaJS\nDESCRIPTION: Demonstrates how to create a validator that accepts null and undefined values, useful for optional fields that might be omitted entirely.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/type.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nt.MaybeEmpty(t.String())\n```\n\n----------------------------------------\n\nTITLE: Number Type with Range Constraints in ElysiaJS\nDESCRIPTION: Demonstrates how to create a number validator with minimum and maximum value constraints, allowing values only between 10 and 100.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/type.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nt.Number({\n    minimum: 10,\n    maximum: 100\n})\n```\n\n----------------------------------------\n\nTITLE: Using Native Static Response with Bun Runtime in Elysia\nDESCRIPTION: Demonstrates the result of enabling nativeStaticResponse with Bun runtime. This optimization allows Elysia to use Bun's built-in static response handling for better performance with static values.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/configuration.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\n// This\nnew Elysia({\n\tnativeStaticResponse: true\n}).get('/version', 1)\n\n// is an equivalent to\nBun.serve({\n\tstatic: {\n\t\t'/version': new Response(1)\n\t}\n})\n```\n\n----------------------------------------\n\nTITLE: Setting OpenAPI Documentation Details in Elysia\nDESCRIPTION: Shows how to configure OpenAPI schema details for all routes in an Elysia instance. This configuration will be used when generating OpenAPI documentation, including tags and visibility settings.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/configuration.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia({\n\tdetail: {\n\t\thide: true,\n\t\ttags: ['elysia']\n\t}\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Explicit Body Parser in Elysia.js\nDESCRIPTION: Demonstrates how to explicitly specify the body parser type for handling different content types in POST requests\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia().post('/', ({ body }) => body, {\n    // Short form of application/json\n    parse: 'json'\n})\n```\n\n----------------------------------------\n\nTITLE: Applying OpenTelemetry Instrumentation in Main ElysiaJS Instance\nDESCRIPTION: Code sample showing how to apply the previously defined instrumentation to the main Elysia application instance.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/opentelemetry.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { instrumentation } from './instrumentation.ts'\n\nnew Elysia().use(instrumentation).listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Using Reference Schema in ElysiaJS\nDESCRIPTION: Demonstrates how to use reference schemas to reduce code duplication and improve type management. Shows defining reusable validation schemas using the model method.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/with-prisma.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { PrismaClient } from '@prisma/client'\n\nconst db = new PrismaClient()\n\nconst app = new Elysia()\n    .model({\n        'user.sign': t.Object({\n            username: t.String(),\n            password: t.String({\n                minLength: 8\n            })\n        })\n    })\n    .post(\n        '/',\n        async ({ body }) => db.user.create({\n            data: body\n        }),\n        {\n            error({ code }) {\n                switch (code) {\n                    case 'P2002':\n                        return {\n                            error: 'Username must be unique'\n                        }\n                }\n            },\n            body: 'user.sign'\n        }\n    )\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Implementing Union Response Types\nDESCRIPTION: Shows how to handle multiple response status codes using schema.response with different types for each status\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-02.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\napp\n    .post(\n        '/json/:id',\n        ({ body, params: { id } }) => ({\n            ...body,\n            id\n        }),\n        {\n            schema: {\n                body: 'sign',\n                response: {\n                    200: t.Object({\n                        username: t.String(),\n                        password: t.String(),\n                        id: t.String()\n                    }),\n                    400: t.Object({\n                        error: t.String()\n                    })\n                }\n            }\n        }\n    )\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Server in Elysia with TLS\nDESCRIPTION: Shows how to customize the underlying HTTP server, including hostname and TLS configuration. This extends Bun's serve API to configure aspects like SSL certificates for HTTPS connections.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/configuration.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia({\n\tserve: {\n\t\thostname: 'elysiajs.com',\n\t\ttls: {\n\t\t\tcert: Bun.file('cert.pem'),\n\t\t\tkey: Bun.file('key.pem')\n\t\t}\n\t},\n})\n```\n\n----------------------------------------\n\nTITLE: Authorizing Post Creation by Extracting User ID via Supabase in Elysia - TypeScript\nDESCRIPTION: Enhances the '/post/create' endpoint to extract the user ID from cookies using Supabase authentication. It first attempts to get the user from the access_token, and if it fails, refreshes the session using refresh_token. The user ID is then intended to be associated with the post creation. Dependencies: Elysia, Supabase client, '@elysiajs/cookie' middleware. Inputs include 'access_token' and 'refresh_token' cookies as well as a post detail in the body; outputs are the created row's ID or an error. Limitation: the complete wiring of userId to the database operation is indicated but not finalized in the sample.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-supabase.md#2025-04-23_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { cookie } from '@elysiajs/cookie' // [!code ++]\n\nimport { supabase } from '../../libs'\n\nexport const post = (app: Elysia) =>\n    app.group('/post', (app) =>\n        app.put(\n            '/create',\n            async ({ body }) => {\n                let userId: string // [!code ++]\n   // [!code ++]\n                const { data, error } = await supabase.auth.getUser( // [!code ++]\n                    access_token // [!code ++]\n                ) // [!code ++]\n   // [!code ++]\n                if(error) { // [!code ++]\n                    const { data, error } = await supabase.auth.refreshSession({ // [!code ++]\n                        refresh_token // [!code ++]\n                    }) // [!code ++]\n   // [!code ++]\n                    if (error) throw error // [!code ++]\n   // [!code ++]\n                    userId = data.user!.id // [!code ++]\n                } // [!code ++]\n\n                const { data, error } = await supabase\n                    .from('post')\n                    .insert({\n                        // Add user_id somehow\n                        // user_id: userId,\n                        ...body\n                    })\n                    .select('id')\n\n                if (error) throw error\n\n                return data[0]\n            },\n            {\n                schema: {\n                    body: t.Object({\n                        detail: t.String()\n                    })\n                }\n            }\n        )\n    )\n```\n\n----------------------------------------\n\nTITLE: Alternative Minification for Elysia.js Binary\nDESCRIPTION: Command to compile Elysia.js with the --minify flag instead of separate minification flags. Not recommended when using OpenTelemetry as it reduces function names to single characters.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/deployment.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbun build \\\n\t--compile \\\n\t--minify \\\n\t--target bun \\\n\t--outfile server \\\n\t./src/index.ts\n```\n\n----------------------------------------\n\nTITLE: Object Type with Additional Properties Option in ElysiaJS\nDESCRIPTION: Shows how to create an object validator that allows additional properties not specified in the schema by setting additionalProperties to true.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/type.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nt.Object(\n    {\n        x: t.Number()\n    },\n    {\n        /**\n         * @default false\n         * Accept additional properties\n         * that not specified in schema\n         * but still match the type\n         */\n        additionalProperties: true\n    }\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing Eden Treaty with Elysia Instance in TypeScript\nDESCRIPTION: Creates an Eden Treaty instance using an Elysia instance directly. This approach allows interaction with the Elysia server without network requests, useful for testing or creating type-safe reverse proxies.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/config.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { treaty } from '@elysiajs/eden'\n\nconst app = new Elysia()\n    .get('/hi', 'Hi Elysia')\n    .listen(3000)\n\nconst api = treaty(app)\n```\n\n----------------------------------------\n\nTITLE: Setting Plugin Deduplication Seed in Elysia\nDESCRIPTION: Shows how to define a seed value for generating checksums used in plugin deduplication. This seed can be any type, including strings, numbers, or objects.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/configuration.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia({\n\tseed: {\n\t\tvalue: 'service.thing'\n\t}\n})\n```\n\n----------------------------------------\n\nTITLE: Transforming String or Number Inputs with t.Numeric - TypeBox - TypeScript\nDESCRIPTION: Demonstrates the use of t.Numeric() to define a schema that validates both numeric strings and numbers, automatically transforming the value into a number. This function is useful for handling path or query parameters that may arrive as strings from HTTP requests. No external dependencies are required apart from TypeBox or the respective schema validation library, and no parameters are given. Outputs a schema object that accepts numeric values.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/type.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nt.Numeric()\n```\n\n----------------------------------------\n\nTITLE: Path Parameters with Type Inference in Elysia\nDESCRIPTION: An example showing how Elysia automatically infers types for path parameters without explicit type declarations.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/at-glance.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/user/:id', ({ params: { id } }) => id)\n                        // ^?\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Error Handling in ElysiaJS with Prisma\nDESCRIPTION: Example of handling Prisma's unique constraint violation errors using ElysiaJS's onError hook. Shows how to return custom error messages when username duplication occurs.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/with-prisma.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { PrismaClient } from '@prisma/client'\n\nconst db = new PrismaClient()\n\nconst app = new Elysia()\n    .post(\n        '/',\n        async ({ body }) => db.user.create({\n            data: body\n        }),\n        {\n            error({ code }) {\n                switch (code) {\n                    case 'P2002':\n                        return {\n                            error: 'Username must be unique'\n                        }\n                }\n            },\n            body: t.Object({\n                username: t.String(),\n                password: t.String({\n                    minLength: 8\n                })\n            })\n        }\n    )\n    .listen(3000)\n\nconsole.log(\n    `ðŸ¦Š Elysia is running at ${app.server?.hostname}:${app.server?.port}`\n)\n```\n\n----------------------------------------\n\nTITLE: Inspecting Response Objects After Handling in Elysia (TypeScript)\nDESCRIPTION: Demonstrates use of `onAfterResponse` in Elysia to inspect the value returned by a request handler. Logs the response value to the console after the route handler finishes processing. Particularly useful for debugging or analytics. Dependencies: `elysia` package.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.onAfterResponse(({ response }) => {\n\t\tconsole.log(response)\n\t})\n\t.get('/', () => 'Hello')\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: WebSocket Subscription Implementation\nDESCRIPTION: Setting up tRPC subscriptions using WebSocket with event emitter pattern\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/integrate-trpc-with-elysia.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server'\nimport { observable } from '@trpc/server/observable'\nimport type { FetchCreateContextFnOptions } from '@trpc/server/adapters/fetch'\nimport { EventEmitter } from 'stream'\nimport { zod } from 'zod'\n\nexport const createContext = async (opts: FetchCreateContextFnOptions) => {\n    return {\n        name: 'elysia'\n    }\n}\n\nconst t = initTRPC.context<Awaited<ReturnType<typeof createContext>>>().create()\nconst ee = new EventEmitter()\n\nexport const router = t.router({\n    mirror: t.procedure.input(z.string()).query(({ input }) => {\n        ee.emit('listen', input)\n        return input\n    }),\n    listen: t.procedure.subscription(() =>\n        observable<string>((emit) => {\n            ee.on('listen', (input) => {\n                emit.next(input)\n            })\n        })\n    )\n})\n\nexport type Router = typeof router\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Payload Length in Elysia\nDESCRIPTION: Shows how to set a limit on the maximum message size in bytes. This configures how large incoming payloads can be before being rejected by the server.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/configuration.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia({\n\tserve: {\n\t\t// Maximum message size (in bytes)\n\t    maxPayloadLength: 64 * 1024,\n\t}\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Authentication Routes Setup in ElysiaJS\nDESCRIPTION: Initial setup of authentication routes with basic sign-up and sign-in endpoints using ElysiaJS group routing.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-supabase.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst authen = (app: Elysia) =>\n    app.group('/auth', (app) =>\n        app\n            .post('/sign-up', () => {\n                return 'This route is expected to sign up a user'\n            })\n            .post('/sign-in', () => {\n                return 'This route is expected to sign in a user'\n            })\n    )\n```\n\n----------------------------------------\n\nTITLE: Object with Optional Property in ElysiaJS\nDESCRIPTION: Demonstrates how to create an object validator where one field is required and another is optional, similar to TypeScript's optional property syntax.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/type.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nt.Object({\n    x: t.Number(),\n    y: t.Optional(t.Number())\n})\n```\n\n----------------------------------------\n\nTITLE: Using Inline Values as Handlers in ElysiaJS\nDESCRIPTION: Shows how to use literal values and file responses as inline handlers for improved performance with static resources.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, file } from 'elysia'\n\nnew Elysia()\n    .get('/', 'Hello Elysia')\n    .get('/video', file('kyuukurarin.mp4'))\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Installing CORS Plugin with Bun\nDESCRIPTION: Command to install the @elysiajs/cors plugin using Bun package manager\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/cors.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun add @elysiajs/cors\n```\n\n----------------------------------------\n\nTITLE: Configuring Strict Path Handling in Elysia\nDESCRIPTION: Demonstrates how to enable strict path handling according to RFC 3986. When enabled, paths must exactly match the defined route without trailing slashes; when disabled, Elysia is more lenient with path matching.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/configuration.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia({ strictPath: true })\n```\n\n----------------------------------------\n\nTITLE: Accessing Server Instance in ElysiaJS Handlers\nDESCRIPTION: Shows how to access the server instance within an ElysiaJS handler to retrieve server-related information like the port number.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.get('/port', ({ server }) => {\n\t\treturn server?.port\n\t})\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Configuring Bun Preload for OpenTelemetry in bunfig.toml\nDESCRIPTION: Configuration for Bun to preload the OpenTelemetry instrumentation before the main application, which is necessary for many instrumentation libraries.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/opentelemetry.md#2025-04-23_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\npreload = [\"./src/instrumentation.ts\"]\n```\n\n----------------------------------------\n\nTITLE: Refining Insert and Select Schemas with Drizzle TypeBox in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates defining and refining database schemas using Drizzle TypeBox within an Elysia framework project. It imports schema creation functions and utility helpers to construct strongly-typed insert and select schemas for a 'user' table. The 'email' field schema is refined to enforce a specific format constraint. Dependencies include 'elysia', 'drizzle-typebox', and local 'schema' and 'utils' modules. The 'db' object exposes refined schemas for both insert and select operations, and uses a 'spreads' utility to assemble the full schema set while respecting refined definitions.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/drizzle.md#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { t } from 'elysia'\nimport { createInsertSchema, createSelectSchema } from 'drizzle-typebox'\n\nimport { table } from './schema'\nimport { spreads } from './utils'\n\nexport const db = {\n\tinsert: spreads({\n\t\tuser: createInsertSchema(table.user, {\n\t\t\temail: t.String({ format: 'email' })\n\t\t}),\n\t}, 'insert')),\n\tselect: spreads({\n\t\tuser: createSelectSchema(table.user, {\n\t\t\temail: t.String({ format: 'email' })\n\t\t})\n\t}, 'select')\n} as const\n```\n\n----------------------------------------\n\nTITLE: Dependency Management in ElysiaJS\nDESCRIPTION: This example shows how to manage dependencies in ElysiaJS using unique identifiers. It demonstrates how to prevent duplication of methods when applying instances multiple times.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/key-concept.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst ip = new Elysia({ name: 'ip' })\n\t.derive(\n\t\t{ as: 'global' },\n\t\t({ server, request }) => ({\n\t\t\tip: server?.requestIP(request)\n\t\t})\n\t)\n\t.get('/ip', ({ ip }) => ip)\n\nconst router1 = new Elysia()\n\t.use(ip)\n\t.get('/ip-1', ({ ip }) => ip)\n\nconst router2 = new Elysia()\n\t.use(ip)\n\t.get('/ip-2', ({ ip }) => ip)\n\nconst server = new Elysia()\n\t.use(router1)\n\t.use(router2)\n```\n\n----------------------------------------\n\nTITLE: Initializing Elysia.js Application with User and Note Services\nDESCRIPTION: Main application setup in Elysia.js, importing and using the swagger, user, and note plugins. This shows how to compose multiple services in an Elysia application.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { swagger } from '@elysiajs/swagger'\n\nimport { note } from './note'\nimport { user } from './user' // [!code ++]\n\nconst app = new Elysia()\n    .use(swagger())\n    .use(user) // [!code ++]\n    .use(note)\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Enabling Route Precompilation in Elysia\nDESCRIPTION: Demonstrates how to enable precompilation of all routes before starting the server. This option determines whether Elysia should compile routes ahead of time or dynamically on demand.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/configuration.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia({\n\tprecompile: true\n})\n```\n\n----------------------------------------\n\nTITLE: Setting OpenAPI Tags for Documentation in Elysia\nDESCRIPTION: Shows how to define OpenAPI tags for all routes in an Elysia instance. These tags are used to categorize endpoints in the generated OpenAPI documentation.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/configuration.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia({\n\ttags: ['elysia']\n})\n```\n\n----------------------------------------\n\nTITLE: Using String Type with Format Attribute in ElysiaJS\nDESCRIPTION: Shows how to define a string with the email format constraint using the format attribute according to JSON Schema 7 specification.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/type.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nt.String({\n    format: 'email'\n})\n```\n\n----------------------------------------\n\nTITLE: Installing JWT Plugin with Bun\nDESCRIPTION: Command to install the ElysiaJS JWT plugin using Bun package manager\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/jwt.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun add @elysiajs/jwt\n```\n\n----------------------------------------\n\nTITLE: OpenAPI Documentation Setup\nDESCRIPTION: Shows how to integrate Swagger documentation\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/cheat-sheet.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { swagger } from '@elysiajs/swagger'\n\nconst app = new Elysia()\n    .use(swagger())\n    .listen(3000)\n\nconsole.log(`View documentation at \"${app.server!.url}swagger\" in your browser`);\n```\n\n----------------------------------------\n\nTITLE: Union Type for Multiple Possible Types in ElysiaJS\nDESCRIPTION: Shows how to create a union type validator that accepts either a string or a number value, similar to TypeScript's union type.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/type.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nt.Union([\n    t.String(),\n    t.Number()\n])\n```\n\n----------------------------------------\n\nTITLE: Installing the ElysiaJS Static Plugin using Bun\nDESCRIPTION: This command uses the Bun package manager to add the `@elysiajs/static` plugin package as a dependency to the project. This is the first step required to use the static file serving functionality.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/static.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun add @elysiajs/static\n```\n\n----------------------------------------\n\nTITLE: Unit Testing with Eden Treaty 2\nDESCRIPTION: Demonstrates how to use Eden Treaty 2 for end-to-end type-safe unit testing of Elysia applications without starting a mock server.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-10.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// test/index.test.ts\nimport { describe, expect, it } from 'bun:test'\nimport { Elysia } from 'elysia'\nimport { treaty } from '@elysiajs/eden'\n\nconst app = new Elysia().get('/hello', () => 'hi')\nconst api = treaty(app)\n\ndescribe('Elysia', () => {\n    it('return a response', async () => {\n        const { data } = await api.hello.get()\n\n        expect(data).toBe('hi')\n    })\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Response Interception in Eden Treaty\nDESCRIPTION: Demonstrates how to intercept and modify fetch responses. This can be used to transform the response data or handle specific response conditions.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/config.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ntreaty<App>('localhost:3000', {\n    onResponse(response) {\n        if(response.ok)\n            return response.json()\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Cookie Secret Rotation\nDESCRIPTION: Shows how to implement cookie secret rotation for enhanced security.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/cookie.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia({\n    cookie: {\n        secrets: ['Vengeance will be mine', 'Fischl von Luftschloss Narfidort']\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Route Groups with Nested Callbacks (Previous Approach)\nDESCRIPTION: Shows how route groups were created before Elysia 0.6 using nested callback functions, which required additional indentation and verbosity.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-06.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// < 0.6\nconst group = (app: Elysia) => app\n    .group('/v1', (app) => app\n        .get('/hello', () => 'Hello World')\n    )\n```\n\n----------------------------------------\n\nTITLE: Installing Server Timing Plugin via Bun (Bash)\nDESCRIPTION: Installs the necessary '@elysiajs/server-timing' package using the Bun package manager. This command downloads and adds the plugin to the project's dependencies.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/server-timing.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun add @elysiajs/server-timing\n```\n\n----------------------------------------\n\nTITLE: Applying Scoped Guard Behavior in ElysiaJS using 'as'\nDESCRIPTION: Introduces the `as: 'scoped'` property within `guard` options in ElysiaJS 1.1. This explicitly sets the guard's hooks (like `beforeHandle`) to follow the 'scoped' lifecycle, meaning they affect the current instance and its immediate parent. The example shows this achieves the same scoping as individually setting `{ as: 'scoped' }` on an event listener like `onBeforeHandle`.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-11.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst plugin1 = new Elysia()\n\t.guard({\n\t\tas: 'scoped', // [!code ++]\n\t\tbeforeHandle() {\n\t\t\tconsole.log('called')\n\t\t}\n\t})\n\t.get('/plugin', () => 'ok')\n\n// Same as\nconst plugin2 = new Elysia()\n\t.onBeforeHandle({ as: 'scoped' }, () => {\n\t\tconsole.log('called')\n\t})\n\t.get('/plugin', () => 'ok')\n```\n\n----------------------------------------\n\nTITLE: Exporting OpenTelemetry Data to Axiom in Elysia\nDESCRIPTION: Shows how to configure Elysia with OpenTelemetry to export telemetry data to Axiom. It sets up the OTLPTraceExporter with Axiom-specific URL and headers.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-11.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { opentelemetry } from '@elysiajs/opentelemetry'\n\nimport { BatchSpanProcessor } from '@opentelemetry/sdk-trace-node'\nimport { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-proto'\n\nnew Elysia()\n\t.use(\n\t\topentelemetry({\n\t\t\tspanProcessors: [\n\t\t\t\tnew BatchSpanProcessor(\n\t\t\t\t\tnew OTLPTraceExporter({\n\t\t\t\t\t\turl: 'https://api.axiom.co/v1/traces',\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t    Authorization: `Bearer ${Bun.env.AXIOM_TOKEN}`,\n\t\t\t\t\t\t    'X-Axiom-Dataset': Bun.env.AXIOM_DATASET\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t]\n\t\t})\n\t)\n```\n\n----------------------------------------\n\nTITLE: Configuring Runtime Adapter for Elysia in TypeScript\nDESCRIPTION: Shows how to set a specific adapter for Elysia to work in different environments. This example uses the BunAdapter explicitly, though Elysia will select an appropriate adapter by default.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/configuration.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { BunAdapter } from 'elysia/adapter/bun'\n\nnew Elysia({\n\tadapter: BunAdapter\n})\n```\n\n----------------------------------------\n\nTITLE: Reconciling and Merging Response Schemas Across Scopes in ElysiaJS\nDESCRIPTION: Demonstrates ElysiaJS 1.1's response schema reconciliation feature. Schemas defined at different scopes (global via `plugin.guard`, local via `instance.guard`) for the same status code (e.g., 418) are merged or overridden based on specificity. The local schema in `instance` overrides the global one for its route `/ok`, while the `parent` route `/not-ok` still adheres to the global schema due to scoping rules. Requires `elysia` and `t` imports.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-11.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n// @errors: 2304 2345\nimport { Elysia, t } from 'elysia'\n\nconst plugin = new Elysia()\n\t.guard({\n\t\tas: 'global',\n\t\tresponse: {\n\t\t\t200: t.Literal('ok'),\n\t\t\t418: t.Literal('Teapot')\n\t\t}\n\t})\n\t.get('/ok', ({ error }) => error(418, 'Teapot'))\n\nconst instance = new Elysia()\n\t.use(plugin)\n\t.guard({\n\t\tresponse: {\n\t\t\t418: t.String()\n\t\t}\n\t})\n\t// This is fine because local response override\n\t.get('/ok', ({ error }) => error(418, 'ok'))\n\nconst parent = new Elysia()\n\t.use(instance)\n\t// Error because global response\n\t.get('/not-ok', ({ error }) => error(418, 'ok'))\n```\n\n----------------------------------------\n\nTITLE: Accessing Headers in Elysia - Old Syntax\nDESCRIPTION: Example showing the previous method of accessing request headers using request.headers.get\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-05.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\napp.post('/headers', ({ request: { headers } }) => {\n    return headers.get('content-type')\n})\n```\n\n----------------------------------------\n\nTITLE: Elysia Main Server Entry Point with Modules (TypeScript)\nDESCRIPTION: This snippet shows how to compose a main Elysia server instance in TypeScript by importing modular route groups (auth and post modules). The app sets up these modules using .use(), then starts the HTTP server on port 3000 and logs the status. Dependencies: Elysia, imported auth and post modules. Inputs: None directly. Outputs: Server running on specified hostname and port, with specified routes attached. Useful as a project entry-point.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-supabase.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nimport { auth, post } from './modules' // [!code ++]\n\nconst app = new Elysia()\n    .use(auth)\n    .use(post) // [!code ++]\n    .listen(3000)\n\nconsole.log(\n    `ðŸ¦Š Elysia is running at ${app.server?.hostname}:${app.server?.port}`\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Reference Models in Elysia.js (TypeScript)\nDESCRIPTION: This snippet demonstrates how to define reference models using the .model() method to create reusable schema definitions for authentication routes.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nexport const user = new Elysia({ prefix: '/user' })\n    .state({\n        user: {} as Record<string, string>,\n        session: {} as Record<number, string>\n    })\n    .model({ // \n    \tsignIn: t.Object({ // \n    \t\tusername: t.String({ minLength: 1 }), // \n    \t\tpassword: t.String({ minLength: 8 }) // \n    \t}), // \n     \tsession: t.Cookie( // \n\t     \t{ // \n\t     \t\ttoken: t.Number() // \n\t     \t}, // \n\t     \t{ // \n\t\t     \tsecrets: 'seia' // \n\t     \t} // \n\t    ), // \n      \toptionalSession: t.Optional(t.Ref('session')) // \n    }) // \n    .put(\n        '/sign-up',\n        async ({ body: { username, password }, store, error }) => {\n            if (store.user[username])\n                return error(400, {\n                    success: false,\n                    message: 'User already exists'\n                })\n            store.user[username] = await Bun.password.hash(password)\n\n            return {\n                success: true,\n                message: 'User created'\n            }\n        },\n        {\n           \tbody: 'signIn' // \n        }\n    )\n    .post(\n        '/sign-in',\n        async ({\n            store: { user, session },\n            error,\n            body: { username, password },\n            cookie: { token }\n        }) => {\n            if (\n                !user[username] ||\n                !(await Bun.password.verify(password, user[username]))\n            )\n                return error(400, {\n                    success: false,\n                    message: 'Invalid username or password'\n                })\n\n            const key = crypto.getRandomValues(new Uint32Array(1))[0]\n            session[key] = username\n            token.value = key\n\n            return {\n                success: true,\n                message: `Signed in as ${username}`\n            }\n        },\n        {\n           \tbody: 'signIn', // \n           \tcookie: 'session', // \n        }\n    )\n```\n\n----------------------------------------\n\nTITLE: Mutating Object Property Directly (Reference Example)\nDESCRIPTION: Demonstrates the correct way to mutate a property within an object in standard JavaScript. Accessing and incrementing `store.counter` modifies the original object's property because the reference is maintained.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nconst store = {\n    counter: 0\n}\n\nstore.counter++\nconsole.log(store.counter) // âœ… 1\n```\n\n----------------------------------------\n\nTITLE: Using Macro with Resolve in Elysia\nDESCRIPTION: Demonstrates the new macro object syntax in Elysia 1.2 that allows using 'resolve' within macros for more concise code.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-12.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.macro({\n\t\tuser: (enabled: true) => ({\n\t\t\tresolve: ({ cookie: { session } }) => ({\n\t\t\t\tuser: session.value!\n\t\t\t})\n\t\t})\n\t})\n\t.get('/', ({ user }) => user, {\n\t\tuser: true\n\t})\n```\n\n----------------------------------------\n\nTITLE: Initializing State and Decorators using Key-Value Pattern in ElysiaJS (TypeScript)\nDESCRIPTION: Illustrates the key-value pattern for adding properties to the ElysiaJS context using `state` to initialize a primitive value ('counter') and `decorate` to add an instance of a class ('Logger'). This pattern enhances readability for single property assignments.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nclass Logger {\n    log(value: string) {\n        console.log(value)\n    }\n}\n\nnew Elysia()\n    .state('counter', 0)\n    .decorate('logger', new Logger())\n```\n\n----------------------------------------\n\nTITLE: Applying Global Scope to ElysiaJS Hooks and Schemas with 'as(\\'global\\')'\nDESCRIPTION: Illustrates using `.as('global')` on an Elysia instance (`plugin`) to cast all its locally defined hooks (`onBeforeHandle`) and schemas (`guard`'s response schema) to the 'global' scope. This makes them apply to all routes defined subsequently in any parent instance (`instance`, `parent`). Requires `elysia` and `t` imports.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-11.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n// @errors: 2304 2345\nimport { Elysia, t } from 'elysia'\n\nconst plugin = new Elysia()\n\t.guard({\n\t\tresponse: t.String()\n\t})\n\t.onBeforeHandle(() => { console.log('called') })\n\t.get('/ok', () => 'ok')\n\t.get('/not-ok', () => 1)\n\t.as('global') // [!code ++]\n\nconst instance = new Elysia()\n\t.use(plugin)\n\t.get('/no-ok-parent', () => 2)\n\nconst parent = new Elysia()\n\t.use(instance)\n\t// This now error because `scoped` is lifted up to parent\n\t.get('/ok', () => 3)\n```\n\n----------------------------------------\n\nTITLE: Comparing Strict vs Lenient Path Handling in Elysia\nDESCRIPTION: Shows examples of how strictPath affects URL matching. With strictPath disabled, both '/name' and '/name/' match the same route; with strictPath enabled, only the exact path '/name' would match.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/configuration.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\n// Path can be either /name or /name/\nnew Elysia({ strictPath: false }).get('/name', 'elysia')\n\n// Path can be only /name\nnew Elysia({ strictPath: true }).get('/name', 'elysia')\n```\n\n----------------------------------------\n\nTITLE: Configuring OpenTelemetry Resource Detectors via Environment Variables\nDESCRIPTION: Example showing how to enable specific resource detectors for OpenTelemetry using environment variables. This configuration enables only the env and host detectors.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/opentelemetry.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport OTEL_NODE_RESOURCE_DETECTORS=\"env,host\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Experimental encodeSchema Feature in Elysia (TypeScript)\nDESCRIPTION: This snippet illustrates activating the experimental 'encodeSchema' feature in an Elysia server instance. By setting 'experimental.encodeSchema' to true, Elysia applies a custom encode function (if defined via t.Transform) before sending the response to clients. This requires the Elysia framework and its 't' module for schema definitions. The key parameter is 'encodeSchema', which accepts a boolean and defaults to false. This mechanism is useful for advanced response handling but may not be stable in all versions.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/configuration.md#2025-04-23_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia({ experimental: { encodeSchema: true } })\n```\n\n----------------------------------------\n\nTITLE: Using Eden Treaty for GET Requests in TypeScript with ElysiaJS\nDESCRIPTION: This example demonstrates how to use Eden Treaty for GET requests, which only accept additional parameters like headers.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/parameters.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { treaty } from '@elysiajs/eden'\n\nconst app = new Elysia()\n    .get('/hello', () => 'hi')\n    .listen(3000)\n\nconst api = treaty<typeof app>('localhost:3000')\n\n// âœ… works\napi.hello.get({\n    // This is optional as not specified in schema\n    headers: {\n        hello: 'world'\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: TSConfig for XSS Protection\nDESCRIPTION: TypeScript configuration for enabling XSS protection with the Kita HTML plugin\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/html.md#2025-04-23_snippet_6\n\nLANGUAGE: jsonc\nCODE:\n```\n{\n\t\"compilerOptions\": {\n\t\t\"jsx\": \"react\",\n\t\t\"jsxFactory\": \"Html.createElement\",\n\t\t\"jsxFragmentFactory\": \"Html.Fragment\",\n\t\t\"plugins\": [{ \"name\": \"@kitajs/ts-html-plugin\" }]\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC with ElysiaJS\nDESCRIPTION: Example showing how to set up a tRPC router with ElysiaJS, including procedure definition and input validation using either Zod or Elysia's built-in validator.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/trpc.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t as T } from 'elysia'\n\nimport { initTRPC } from '@trpc/server'\nimport { compile as c, trpc } from '@elysiajs/trpc'\n\nconst t = initTRPC.create()\nconst p = t.procedure\n\nconst router = t.router({\n\tgreet: p\n\t\t// ðŸ’¡ Using Zod\n\t\t//.input(z.string())\n\t\t// ðŸ’¡ Using Elysia's T\n\t\t.input(c(T.String()))\n\t\t.query(({ input }) => input)\n})\n\nexport type Router = typeof router\n\nconst app = new Elysia().use(trpc(router)).listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Exporting Elysia Server Type for Client Consumption\nDESCRIPTION: This snippet demonstrates how to set up an Elysia server and export its type for client-side consumption with Eden Treaty. It includes route definitions with various HTTP methods and parameter types.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/legacy.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// server.ts\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n    .get('/', () => 'Hi Elysia')\n    .get('/id/:id', ({ params: { id } }) => id)\n    .post('/mirror', ({ body }) => body, {\n        body: t.Object({\n            id: t.Number(),\n            name: t.String()\n        })\n    })\n    .listen(3000)\n\nexport type App = typeof app // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Logging Response Status and Headers After Handling with Elysia (TypeScript)\nDESCRIPTION: Shows how to access and log response status and headers using the `set` property from the context given to `onAfterResponse`. Implements a GET endpoint that logs the HTTP status and headers for each response. Dependency: `elysia` package. Input: any request; output: console log.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.onAfterResponse(({ set }) => {\n\t\tconsole.log(set.status, set.headers)\n\t})\n\t.get('/', () => 'Hello')\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Extracting Service Components with Plugin Deduplication\nDESCRIPTION: Shows how to extract shared components into a service plugin with proper naming to prevent duplicate instances when used in multiple modules.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n// @errors: 2538\nimport { Elysia, t } from 'elysia'\n\nexport const userService = new Elysia({ name: 'user/service' }) // \n\t.state({ // \n        user: {} as Record<string, string>, // \n        session: {} as Record<number, string> // \n    }) // \n    .model({ // \n        signIn: t.Object({ // \n            username: t.String({ minLength: 1 }), // \n            password: t.String({ minLength: 8 }) // \n        }), // \n        session: t.Cookie( // \n            { // \n                token: t.Number() // \n            }, // \n            { // \n                secrets: 'seia' // \n            } // \n        ), // \n        optionalSession: t.Optional(t.Ref('session')) // \n    }) // \n\nexport const user = new Elysia({ prefix: '/user' })\n\t.use(userService) // \n\t.state({ // \n        user: {} as Record<string, string>, // \n        session: {} as Record<number, string> // \n    }) // \n    .model({ // \n        signIn: t.Object({ // \n            username: t.String({ minLength: 1 }), // \n            password: t.String({ minLength: 8 }) // \n        }), // \n        session: t.Cookie( // \n            { // \n                token: t.Number() // \n            }, // \n            { // \n                secrets: 'seia' // \n            } // \n        ), // \n  \t\toptionalSession: t.Optional(t.Ref('session')) // \n    }) // \n```\n\n----------------------------------------\n\nTITLE: Utility Functions for Drizzle Schema Manipulation\nDESCRIPTION: Utility TypeScript functions for simplifying the conversion of Drizzle schemas to plain objects, enabling easier property selection and manipulation when integrating with Elysia validation.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/drizzle.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * @lastModified 2025-02-04\n * @see https://elysiajs.com/recipe/drizzle.html#utility\n */\n\nimport { Kind, type TObject } from '@sinclair/typebox'\nimport {\n    createInsertSchema,\n    createSelectSchema,\n    BuildSchema,\n} from 'drizzle-typebox'\n\nimport { table } from './schema'\nimport type { Table } from 'drizzle-orm'\n\ntype Spread<\n    T extends TObject | Table,\n    Mode extends 'select' | 'insert' | undefined,\n> =\n    T extends TObject<infer Fields>\n        ? {\n              [K in keyof Fields]: Fields[K]\n          }\n        : T extends Table\n          ? Mode extends 'select'\n              ? BuildSchema<\n                    'select',\n                    T['_']['columns'],\n                    undefined\n                >['properties']\n              : Mode extends 'insert'\n                ? BuildSchema<\n                      'insert',\n                      T['_']['columns'],\n                      undefined\n                  >['properties']\n                : {}\n          : {}\n\n/**\n * Spread a Drizzle schema into a plain object\n */\nexport const spread = <\n    T extends TObject | Table,\n    Mode extends 'select' | 'insert' | undefined,\n>(\n    schema: T,\n    mode?: Mode,\n): Spread<T, Mode> => {\n    const newSchema: Record<string, unknown> = {}\n    let table\n\n    switch (mode) {\n        case 'insert':\n        case 'select':\n            if (Kind in schema) {\n                table = schema\n                break\n            }\n\n            table =\n                mode === 'insert'\n                    ? createInsertSchema(schema)\n                    : createSelectSchema(schema)\n\n            break\n\n        default:\n            if (!(Kind in schema)) throw new Error('Expect a schema')\n            table = schema\n    }\n\n    for (const key of Object.keys(table.properties))\n        newSchema[key] = table.properties[key]\n\n    return newSchema as any\n}\n\nconst a = spread(table.user, 'insert')\n\n/**\n * Spread a Drizzle Table into a plain object\n *\n * If `mode` is 'insert', the schema will be refined for insert\n * If `mode` is 'select', the schema will be refined for select\n * If `mode` is undefined, the schema will be spread as is, models will need to be refined manually\n */\nexport const spreads = <\n    T extends Record<string, TObject | Table>,\n    Mode extends 'select' | 'insert' | undefined,\n>(\n    models: T,\n    mode?: Mode,\n): {\n    [K in keyof T]: Spread<T[K], Mode>\n} => {\n    const newSchema: Record<string, unknown> = {}\n    const keys = Object.keys(models)\n\n    for (const key of keys) newSchema[key] = spread(models[key], mode)\n\n    return newSchema as any\n}\n```\n\n----------------------------------------\n\nTITLE: Bulk Lifting Multiple ElysiaJS Hooks and Schemas Scope with 'as(\\'plugin\\')'\nDESCRIPTION: Shows how `.as('plugin')` provides a way to lift the scope of *all* locally defined hooks (like `onBeforeHandle`) and schemas (like the `guard`'s response schema) within an instance up to its parent. If applied to nested instances, the scope is lifted recursively. This allows applying 'scoped' behavior to multiple items at once without specifying `as: 'scoped'` on each. Requires `elysia` and `t` imports.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-11.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// @errors: 2304 2345\nimport { Elysia, t } from 'elysia'\n\nconst plugin = new Elysia()\n\t.guard({\n\t\tresponse: t.String()\n\t})\n\t.onBeforeHandle(() => { console.log('called') })\n\t.get('/ok', () => 'ok')\n\t.get('/not-ok', () => 1)\n\t.as('plugin') // [!code ++]\n\nconst instance = new Elysia()\n\t.use(plugin)\n\t.get('/no-ok-parent', () => 2)\n\t.as('plugin') // [!code ++]\n\nconst parent = new Elysia()\n\t.use(instance)\n\t// This now error because `scoped` is lifted up to parent\n\t.get('/ok', () => 3)\n```\n\n----------------------------------------\n\nTITLE: Partial Object Type in ElysiaJS\nDESCRIPTION: Shows how to make all properties of an object optional using Partial, which makes every field in the object schema optional.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/type.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nt.Partial(\n    t.Object({\n        x: t.Number(),\n        y: t.Number()\n    })\n)\n```\n\n----------------------------------------\n\nTITLE: Installing Bun Runtime\nDESCRIPTION: Commands for installing Bun runtime on different operating systems. Bun is a prerequisite for running ElysiaJS applications.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -fsSL https://bun.sh/install | bash\n```\n\nLANGUAGE: bash\nCODE:\n```\npowershell -c \"irm bun.sh/install.ps1 | iex\"\n```\n\n----------------------------------------\n\nTITLE: Custom Headers and Status Codes\nDESCRIPTION: Shows how to set custom headers and status codes in responses\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/cheat-sheet.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/', ({ set, error }) => {\n        set.headers['x-powered-by'] = 'Elysia'\n\n        return error(418, \"I'm a teapot\")\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Using TypeBox 0.34 for Recursive Types in Elysia\nDESCRIPTION: Demonstrates how to use TypeBox 0.34 in Elysia 1.2 to define and use recursive types with t.Module and t.Ref.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-12.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n\t.model({\n\t\ta: t.Object({\n\t\t\ta: t.Optional(t.Ref('a'))\n\t\t})\n\t})\n\t.post('/recursive', ({ body }) => body, {\n\t\tbody: 'a'\n\t})\n```\n\n----------------------------------------\n\nTITLE: Improving Function Naming for Better Trace Visibility in Elysia\nDESCRIPTION: Illustrates the importance of using named functions instead of anonymous arrow functions for better visibility in OpenTelemetry traces within Elysia applications.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-11.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst bad = new Elysia()\n\t// âš ï¸ span name will be anonymous\n\t.derive(async ({ cookie: { session } }) => {\n\t\treturn {\n\t\t\tuser: await getProfile(session)\n\t\t}\n\t})\n\nconst good = new Elysia()\n\t// âœ… span name will be getProfile\n\t.derive(async function getProfile({ cookie: { session } }) {\n\t\treturn {\n\t\t\tuser: await getProfile(session)\n\t\t}\n\t})\n```\n\n----------------------------------------\n\nTITLE: Initializing Server Timing Plugin in ElysiaJS (TypeScript)\nDESCRIPTION: Demonstrates the basic setup of the Server Timing plugin within an ElysiaJS application. It imports the necessary modules, applies the plugin middleware using '.use()' with default settings, defines a simple route, and starts the server. Server timing headers will be added automatically to responses.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/server-timing.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { serverTiming } from '@elysiajs/server-timing'\n\nnew Elysia()\n    .use(serverTiming())\n    .get('/', () => 'hello')\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Prefixing All Properties from an ElysiaJS Plugin (TypeScript)\nDESCRIPTION: Shows how to use `prefix('all', 'prefixName')` to apply a prefix to all properties (state, decorators, derived values) provided by an ElysiaJS plugin. This allows bulk remapping to avoid naming conflicts when integrating plugins.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst setup = new Elysia({ name: 'setup' })\n    .decorate({\n        argon: 'a',\n        boron: 'b',\n        carbon: 'c'\n    })\n\nconst app = new Elysia()\n    .use(setup.prefix('all', 'setup')) // [!code ++]\n    .get('/', ({ setupCarbon, ...rest }) => setupCarbon)\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage Without Method Chaining in ElysiaJS (TypeScript)\nDESCRIPTION: Shows the incorrect approach of using ElysiaJS without method chaining, resulting in loss of type inference. This anti-pattern breaks type references between method calls.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/best-practice.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// @errors: 2339\nimport { Elysia } from 'elysia'\n\nconst app = new Elysia()\n\napp.state('build', 1)\n\napp.get('/', ({ store: { build } }) => build)\n\napp.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Nullable Cookie Implementation\nDESCRIPTION: Demonstrates how to handle nullable cookie values using t.Optional.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/cookie.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia()\n    .get('/', ({ cookie: { name } }) => {\n        // Set\n        name.value = {\n            id: 617,\n            name: 'Summoning 101'\n        }\n    }, {\n        cookie: t.Cookie({\n            name: t.Optional(\n                t.Object({\n                    id: t.Numeric(),\n                    name: t.String()\n                })\n            )\n        })\n    })\n```\n\n----------------------------------------\n\nTITLE: Returning Form Data Explicitly with Elysia Middleware - TypeScript\nDESCRIPTION: Demonstrates how Elysia 1.2 requires you to explicitly use and return the `form` utility when your response should be a FormData, instead of previously detecting file returns automatically. The snippet shows importing the necessary helpers, usage in a POST route, and passing a file as a FormData attachment. Dependencies include the `elysia` package and access to the referenced file path. Expects file input via the route handler and outputs a FormData-compliant response built with `form`. Ensures explicit intent and removes auto-detection of files from 1-level objects.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-12.md#2025-04-23_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Elysia, form, file } from 'elysia'\n\nnew Elysia()\n\t.post('/', ({ file }) => ({ // [!code --]\n\t.post('/', ({ file }) => form({ // [!code ++]\n\t\ta: file('./public/kyuukurarin.mp4')\n\t}))\n```\n\n----------------------------------------\n\nTITLE: Literal Type Support in Elysia\nDESCRIPTION: Example showing literal type support in state and decorate methods using TypeScript 5.0 features\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-05.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n\t// ? state, decorate, now support literal\napp.get('/', ({ body }) => number, {\n\t\tbody: t.Literal(1),\n\t\tresponse: t.Literal(2)\n\t})\n```\n\n----------------------------------------\n\nTITLE: Installing XSS Protection Plugin\nDESCRIPTION: Command to install the Kita HTML plugin for XSS protection\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/html.md#2025-04-23_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nbun add @kitajs/ts-html-plugin\n```\n\n----------------------------------------\n\nTITLE: Enabling Dynamic Mode in Elysia\nDESCRIPTION: Shows how to enable dynamic mode in Elysia by setting the aot (Ahead of Time) option to false, which switches to JIT compilation for environments that don't support function composition.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-06.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nnew Elysia({\n    aot: false\n})\n```\n\n----------------------------------------\n\nTITLE: Using OpenTelemetry Record Function in Elysia Plugin\nDESCRIPTION: Demonstrates the use of the 'record' utility from @elysiajs/opentelemetry to collect spans from specific parts of an Elysia application, such as database queries.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-11.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { record } from '@elysiajs/opentelemetry'\n\nexport const plugin = new Elysia()\n\t.get('', () => {\n\t\treturn record('database.query', () => {\n\t\t\treturn db.query('SELECT * FROM users')\n\t\t})\n\t})\n```\n\n----------------------------------------\n\nTITLE: Configuring path aliases in TypeScript for monorepo\nDESCRIPTION: This JSON snippet demonstrates how to set up path aliases in tsconfig.json for a monorepo structure, ensuring proper module resolution for both frontend and backend.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/installation.md#2025-04-23_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n  \t\"baseUrl\": \".\",\n\t\"paths\": {\n\t  \"@/*\": [\"../apps/backend/src/*\"]\n\t}\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Drizzle Database Schema for User Table\nDESCRIPTION: TypeScript code defining a PostgreSQL user table schema using Drizzle ORM with fields for id, username, password, email, salt, and creation timestamp.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/drizzle.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { relations } from 'drizzle-orm'\nimport {\n    pgTable,\n    varchar,\n    timestamp\n} from 'drizzle-orm/pg-core'\n\nimport { createId } from '@paralleldrive/cuid2'\n\nexport const user = pgTable(\n    'user',\n    {\n        id: varchar('id')\n            .$defaultFn(() => createId())\n            .primaryKey(),\n        username: varchar('username').notNull().unique(),\n        password: varchar('password').notNull(),\n        email: varchar('email').notNull().unique(),\n        salt: varchar('salt', { length: 64 }).notNull(),\n        createdAt: timestamp('created_at').defaultNow().notNull(),\n    }\n)\n\nexport const table = {\n\tuser\n} as const\n\nexport type Table = typeof table\n```\n\n----------------------------------------\n\nTITLE: Accessing Headers in Elysia - New Syntax\nDESCRIPTION: Example showing the new simplified method of accessing headers directly from the context object\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-05.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\napp.post('/headers', ({ headers }) => headers['content-type'])\n```\n\n----------------------------------------\n\nTITLE: Implementing Named Functions for Better OpenTelemetry Tracing\nDESCRIPTION: Examples showing the difference between using anonymous functions and named functions in ElysiaJS for better span naming in OpenTelemetry traces.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/opentelemetry.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst bad = new Elysia()\n\t// âš ï¸ span name will be anonymous\n\t.derive(async ({ cookie: { session } }) => {\n\t\treturn {\n\t\t\tuser: await getProfile(session)\n\t\t}\n\t})\n\nconst good = new Elysia()\n\t// âœ… span name will be getProfile\n\t.derive(async function getProfile({ cookie: { session } }) {\n\t\treturn {\n\t\t\tuser: await getProfile(session)\n\t\t}\n\t})\n```\n\n----------------------------------------\n\nTITLE: Incorrect Model Declaration in ElysiaJS (TypeScript)\nDESCRIPTION: Shows anti-patterns for model declarations in ElysiaJS using class instances or interfaces. These approaches don't leverage Elysia's built-in validation and type inference capabilities.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/best-practice.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// âŒ Don't\nclass CustomBody {\n\tusername: string\n\tpassword: string\n\n\tconstructor(username: string, password: string) {\n\t\tthis.username = username\n\t\tthis.password = password\n\t}\n}\n\n// âŒ Don't\ninterface ICustomBody {\n\tusername: string\n\tpassword: string\n}\n```\n\n----------------------------------------\n\nTITLE: CORS Function Type Definition\nDESCRIPTION: Type definition for the CORS function that can be used as a custom handler for origin validation\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/cors.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ncors(context: Context) => boolean | void\n```\n\n----------------------------------------\n\nTITLE: Setting Default Headers in Elysia\nDESCRIPTION: Shows how to set default headers in Elysia using the new headers API, which improves performance by setting headers directly instead of using onRequest handlers.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-08.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nnew Elysia()\n    .headers({\n        'X-Powered-By': 'Elysia'\n    })\n```\n\n----------------------------------------\n\nTITLE: TSConfig for JSX Support\nDESCRIPTION: Required TypeScript configuration to enable JSX support in ElysiaJS\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/html.md#2025-04-23_snippet_2\n\nLANGUAGE: jsonc\nCODE:\n```\n{\n\t\"compilerOptions\": {\n\t\t\"jsx\": \"react\",\n\t\t\"jsxFactory\": \"Html.createElement\",\n\t\t\"jsxFragmentFactory\": \"Html.Fragment\"\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Elysia and Supabase Dependencies\nDESCRIPTION: Lists the commands to install necessary dependencies for the Elysia and Supabase integration.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-supabase.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbun add elysia@rc @elysiajs/cookie@rc @supabase/supabase-js\n```\n\n----------------------------------------\n\nTITLE: Compiling Elysia.js to Binary\nDESCRIPTION: Command to compile an Elysia.js application into a single portable binary. This reduces memory usage and file size by 2-3x compared to development environments.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/deployment.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun build \\\n\t--compile \\\n\t--minify-whitespace \\\n\t--minify-syntax \\\n\t--target bun \\\n\t--outfile server \\\n\t./src/index.ts\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Macro in ElysiaJS v2\nDESCRIPTION: Demonstrates the new object syntax in Macro v2, which returns lifecycle methods like inline hooks. This example creates a hi macro that adds a beforeHandle function.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/macro.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst plugin = new Elysia({ name: 'plugin' })\n    .macro({\n        hi(word: string) {\n            return {\n\t            beforeHandle() {\n\t                console.log(word)\n\t            }\n            }\n        }\n    })\n\nconst app = new Elysia()\n    .use(plugin)\n    .get('/', () => 'hi', {\n        hi: 'Elysia'\n    })\n```\n\n----------------------------------------\n\nTITLE: Authentication Check Using Guard Pattern\nDESCRIPTION: Shows the previous implementation of authentication check using nested guards.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-10.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst plugin = new Elysia()\n    .guard((app) =>\n        app\n            .onBeforeHandle(checkAuthSomehow)\n            .get('/profile', () => 'log hi')\n    )\n```\n\n----------------------------------------\n\nTITLE: Schema Migration from Nested to Inline in Elysia 0.5 - TypeScript\nDESCRIPTION: Illustrates the breaking change in Elysia 0.5 that moves schema definitions from a nested schema property to inline properties in the hook statement. This change makes route definitions more concise by eliminating the schema nesting level.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-05.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// ? From\napp.get('/id/:id', ({ params: { id } }) => id, {\n    schema: {\n        params: t.Object({\n            id: t.Number()\n        })\n    },\n})\n\n// ? To\napp.get('/id/:id', ({ params: { id } }) => id, {\n    params: t.Object({\n        id: t.Number()\n    })\n})\n```\n\n----------------------------------------\n\nTITLE: Using setAttribute with ElysiaJS OpenTelemetry\nDESCRIPTION: Example of setting attributes on the current OpenTelemetry span using the setAttribute utility function.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/opentelemetry.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { setAttribute } from '@elysiajs/opentelemetry'\n\nfunction utility() {\n\tsetAttribute('custom.attribute', 'value')\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Numeric String Parsing in Elysia 0.4 - TypeScript\nDESCRIPTION: Illustrates the old approach in Elysia 0.4 for parsing numeric string parameters. This example uses the transform hook to manually convert string parameters to numbers, showing the verbose approach that was required before the Numeric type was introduced.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-05.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\napp.get('/id/:id', ({ params: { id } }) => id, {\n    schema: {\n        params: t.Object({\n            id: t.Number()\n        })\n    },\n    transform({ params }) {\n        const id = +params.id\n\n        if(!Number.isNaN(id))\n            params.id = id\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Incorrect Controller Pattern for ElysiaJS (TypeScript)\nDESCRIPTION: Demonstrates an anti-pattern for ElysiaJS controllers by creating a separate controller class and passing its methods to Elysia routes. This approach reduces type integrity and doesn't align with the framework's design.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/best-practice.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t, type Context } from 'elysia'\n\nabstract class Controller {\n    static root(context: Context) {\n        return Service.doStuff(context.stuff)\n    }\n}\n\n// âŒ Don't\nnew Elysia()\n    .get('/', Controller.hi)\n```\n\n----------------------------------------\n\nTITLE: Context Extension in Elysia\nDESCRIPTION: Demonstrates various methods for extending Elysia's context including state, decorate, derive, and resolve.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .state('version', 1)\n    .get('/a', ({ store: { version } }) => version)\n    .get('/b', ({ store }) => store)\n    .get('/c', () => 'still ok')\n    .listen(3000)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nclass Logger {\n    log(value: string) {\n        console.log(value)\n    }\n}\n\nnew Elysia()\n    .decorate('logger', new Logger())\n    .get('/', ({ logger }) => {\n        logger.log('hi')\n\n        return 'hi'\n    })\n```\n\n----------------------------------------\n\nTITLE: Configuring ElysiaJS with Prefix for Non-Root SvelteKit Routes\nDESCRIPTION: This code snippet shows how to set up an Elysia server with a prefix for use in non-root SvelteKit routes. It demonstrates adding a '/api' prefix to the Elysia instance, which is necessary when the server is placed in a subdirectory of the app router.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/sveltekit.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// src/routes/api/[...slugs]/+server.ts\nimport { Elysia, t } from 'elysia';\n\nconst app = new Elysia({ prefix: '/api' })\n    .get('/', () => 'hi')\n    .post('/', ({ body }) => body, {\n        body: t.Object({\n            name: t.String()\n        })\n    })\n\ntype RequestHandler = (v: { request: Request }) => Response | Promise<Response>\n\nexport const GET: RequestHandler = ({ request }) => app.handle(request)\nexport const POST: RequestHandler = ({ request }) => app.handle(request)\n```\n\n----------------------------------------\n\nTITLE: Sending Emails with AWS SES in ElysiaJS\nDESCRIPTION: Implementation for sending the OTP email using AWS SES as the email provider. It renders the React component to HTML and formats it according to the AWS SES API requirements.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/react-email.md#2025-04-23_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nimport * as React from 'react'\nimport { renderToStaticMarkup } from 'react-dom/server'\n\nimport OTPEmail from './emails/otp'\n\nimport { type SendEmailCommandInput, SES } from '@aws-sdk/client-ses'\nimport { fromEnv } from '@aws-sdk/credential-providers'\n\nconst ses = new SES({\n    credentials:\n        process.env.NODE_ENV === 'production' ? fromEnv() : undefined\n})\n\nnew Elysia()\n\t.get('/otp', ({ body }) => {\n\t\t// Random between 100,000 and 999,999\n  \t\tconst otp = ~~(Math.random() * (900_000 - 1)) + 100_000\n\n\t\tconst html = renderToStaticMarkup(<OTPEmail otp={otp} />)\n\n        await ses.sendEmail({\n            Source: 'ibuki@gehenna.sh',\n            Destination: {\n                ToAddresses: [body]\n            },\n            Message: {\n                Body: {\n                    Html: {\n                        Charset: 'UTF-8',\n                        Data: html\n                    }\n                },\n                Subject: {\n                    Charset: 'UTF-8',\n                    Data: 'Verify your email address'\n                }\n            }\n        } satisfies SendEmailCommandInput)\n\n        return { success: true }\n\t}, {\n\t\tbody: t.String({ format: 'email' })\n\t})\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Generating Auth Schema with Better Auth CLI\nDESCRIPTION: Command to generate authentication schema using Better Auth CLI, pointing to the configuration file. This generates the necessary database schema for authentication functionality.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/better-auth.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbunx @better-auth/cli generate --config ./src/libs/auth/auth.ts\n```\n\n----------------------------------------\n\nTITLE: Running ElysiaJS Tests with Bun\nDESCRIPTION: This command shows how to run the ElysiaJS tests using Bun's test runner.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/unit-test.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbun test\n```\n\n----------------------------------------\n\nTITLE: Initializing Supabase Client in TypeScript\nDESCRIPTION: Demonstrates how to create and export a Supabase client instance using environment variables.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-supabase.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// src/libs/supabase.ts\nimport { createClient } from '@supabase/supabase-js'\n\nconst { supabase_url, supabase_service_role } = process.env\n\nexport const supabase = createClient(supabase_url!, supabase_service_role!)\n```\n\n----------------------------------------\n\nTITLE: Setting Cookie Priority Attribute Elysia.js JavaScript\nDESCRIPTION: This code snippet outlines the options for setting the Priority attribute of a cookie via a string value in Elysia.js. The attribute controls the priority sent with the Set-Cookie header ('low', 'medium', or 'high'). No special dependencies are required. Parameters: accepted values are 'low', 'medium' (default), or 'high'. The input is a string, and the output is the cookie with the appropriate Priority attribute; unsupported by some clients. Refer to the relevant specification for browser support.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/cookie.md#2025-04-23_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\n/*\nSpecifies the string to be the value for the [Priority Set-Cookie attribute](https://tools.ietf.org/html/draft-west-cookie-priority-00#section-4.1).\n`low` will set the Priority attribute to Low.\n`medium` will set the Priority attribute to Medium, the default priority when not set.\n`high` will set the Priority attribute to High.\n*/\n```\n\n----------------------------------------\n\nTITLE: Using Resolve Lifecycle Method for Bearer Token Extraction in Elysia\nDESCRIPTION: This snippet demonstrates the usage of the new 'resolve' lifecycle method in Elysia 0.8. It shows how to extract a bearer token from the Authorization header after validation.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-08.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .guard(\n        {\n            headers: t.Object({\n                authorization: t.TemplateLiteral('Bearer ${string}')\n            })\n        },\n        (app) =>\n            app\n                .resolve(({ headers: { authorization } }) => {\n                    return {\n                        bearer: authorization.split(' ')[1]\n                    }\n                })\n                .get('/', ({ bearer }) => bearer)\n    )\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Running Compiled Elysia.js Binary\nDESCRIPTION: Command to execute the compiled Elysia.js binary. Once compiled, the binary is portable and doesn't require Bun to be installed on the deployment machine.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/deployment.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./server\n```\n\n----------------------------------------\n\nTITLE: Setting URL Prefix for All Routes in Elysia\nDESCRIPTION: Shows how to define a URL prefix for all routes in an Elysia instance. When set, all defined routes will automatically be prefixed with the specified value.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/configuration.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia({\n\tprefix: '/v1'\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Request Body Size in Elysia\nDESCRIPTION: Demonstrates how to configure the maximum size allowed for request bodies. This example sets the limit to 256MB, overriding the default 128MB limit.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/configuration.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia({\n\tserve: {\n\t\tmaxRequestBodySize: 1024 * 1024 * 256 // 256MB\n\t}\n})\n```\n\n----------------------------------------\n\nTITLE: Custom Body Parser Implementation\nDESCRIPTION: Shows how to implement custom body parsing logic\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/cheat-sheet.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .onParse(({ request, contentType }) => {\n        if (contentType === 'application/custom-type')\n            return request.text()\n    })\n```\n\n----------------------------------------\n\nTITLE: Basic Trace Parameter Example in Elysia\nDESCRIPTION: This snippet demonstrates the basic structure of using the trace method with a parameter. It shows how to access the trace parameter object which contains various properties and methods for monitoring lifecycle events.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/trace.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst app = new Elysia()\n\t// This is trace parameter\n\t// hover to view the type\n\t.trace((parameter) => {\n\t})\n\t.get('/', () => 'Hi')\n\t.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Creating New ElysiaJS Project\nDESCRIPTION: Commands to create and initialize a new ElysiaJS project using Bun.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Create a new project\nbun create elysia hi-elysia\n\n# cd into the project\ncd hi-elysia\n\n# Install dependencies\nbun install\n```\n\n----------------------------------------\n\nTITLE: Configuring Cookie Signatures with Secret Keys in Elysia\nDESCRIPTION: Shows how to implement cookie signatures in Elysia 0.7 to verify cookie authenticity using a secret key, with automatic signing and verification.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-07.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nnew Elysia({\n    cookie: {\n        secret: 'Fischl von Luftschloss Narfidort'\n    }\n})\n    .get('/', ({ cookie: { profile } }) => {\n        profile.value = {\n            id: 617,\n            name: 'Summoning 101'\n        }\n    }, {\n        cookie: t.Cookie({\n            profile: t.Object({\n                id: t.Numeric(),\n                name: t.String()\n            })\n        }, {\n            sign: ['profile']\n        })\n    })\n```\n\n----------------------------------------\n\nTITLE: Using Custom Parser in Elysia\nDESCRIPTION: Shows how to define and use a custom parser with a specific name in Elysia 1.2 for decoding request bodies.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-12.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.parser('custom', ({ contentType }) => {\n\t\tif(contentType === \"application/kivotos\")\n\t\t\treturn 'nagisa'\n\t})\n\t.post('/', ({ body }) => body, {\n\t\tparse: 'custom'\n\t})\n```\n\n----------------------------------------\n\nTITLE: Setting Execute Permissions for Elysia.js Binary\nDESCRIPTION: Command to set executable permissions for the compiled binary on Linux systems, which may be required for execution.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/deployment.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nchmod +x ./server\n\n./server\n```\n\n----------------------------------------\n\nTITLE: Basic tRPC Router Configuration\nDESCRIPTION: Example of a basic tRPC router setup with a mirror procedure using Zod validation\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/integrate-trpc-with-elysia.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server'\nimport { observable } from '@trpc/server/observable'\n\nimport { z } from 'zod'\n\nconst t = initTRPC.create()\n\nexport const router = t.router({\n    mirror: t.procedure.input(z.string()).query(({ input }) => input),\n})\n\nexport type Router = typeof router\n```\n\n----------------------------------------\n\nTITLE: State Remapping Example in Elysia\nDESCRIPTION: Demonstrates how to remap state properties to prevent name collisions using state transformation function\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-07.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nnew Elysia()\n    .state({\n        a: \"a\",\n        b: \"b\"\n    })\n    // Exclude b state\n    .state(({ b, ...rest }) => rest)\n```\n\n----------------------------------------\n\nTITLE: Creating an OTP Email Template with React Email\nDESCRIPTION: A React component that creates an OTP verification email template using React Email components. It includes styling with Tailwind and preview props for development.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/react-email.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport * as React from 'react'\nimport { Tailwind, Section, Text } from '@react-email/components'\n\nexport default function OTPEmail({ otp }: { otp: number }) {\n    return (\n        <Tailwind>\n            <Section className=\"flex justify-center items-center w-full min-h-screen font-sans\">\n                <Section className=\"flex flex-col items-center w-76 rounded-2xl px-6 py-1 bg-gray-50\">\n                    <Text className=\"text-xs font-medium text-violet-500\">\n                        Verify your Email Address\n                    </Text>\n                    <Text className=\"text-gray-500 my-0\">\n                        Use the following code to verify your email address\n                    </Text>\n                    <Text className=\"text-5xl font-bold pt-2\">{otp}</Text>\n                    <Text className=\"text-gray-400 font-light text-xs pb-4\">\n                        This code is valid for 10 minutes\n                    </Text>\n                    <Text className=\"text-gray-600 text-xs\">\n                        Thank you joining us\n                    </Text>\n                </Section>\n            </Section>\n        </Tailwind>\n    )\n}\n\nOTPEmail.PreviewProps = {\n    otp: 123456\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript for React JSX\nDESCRIPTION: TypeScript configuration needed to support React JSX syntax in the project by setting the jsx compiler option to 'react'.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/react-email.md#2025-04-23_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n\t\"jsx\": \"react\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Prisma Migration\nDESCRIPTION: Executes a Prisma migration to sync the database schema with the defined Prisma schema, creating necessary tables and columns.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/with-prisma.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nbunx prisma migrate dev --name init\n```\n\n----------------------------------------\n\nTITLE: Example Bash Output for After-Response Logging (Bash)\nDESCRIPTION: Displays sample output from the console, showing log entries for each HTTP response received when using the `onAfterResponse` logging hook in Elysia. Demonstrates expected timestamps in bash output format. No dependencies or direct execution required; output for documentation purposes only.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/life-cycle.md#2025-04-23_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\nResponse 0.0000\nResponse 0.0001\nResponse 0.0002\n```\n\n----------------------------------------\n\nTITLE: tRPC Context Configuration\nDESCRIPTION: Implementation of tRPC context creation and configuration with Elysia\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/integrate-trpc-with-elysia.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server'\nimport { observable } from '@trpc/server/observable'\nimport type { FetchCreateContextFnOptions } from '@trpc/server/adapters/fetch'\nimport { z } from 'zod'\n\nexport const createContext = async (opts: FetchCreateContextFnOptions) => {\n    return {\n        name: 'elysia'\n    }\n}\n\nconst t = initTRPC.context<Awaited<ReturnType<typeof createContext>>>().create()\n\nexport const router = t.router({\n    mirror: t.procedure.input(z.string()).query(({ input }) => input),\n})\n\nexport type Router = typeof router\n```\n\n----------------------------------------\n\nTITLE: Setting Default Headers in Eden Treaty Configuration\nDESCRIPTION: Shows how to set default headers when initializing Eden Treaty. This can be done using an object or a function that returns headers based on conditions.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/config.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ntreaty<App>('localhost:3000', {\n    headers: {\n        'X-Custom': 'Griseo'\n    }\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\ntreaty<App>('localhost:3000', {\n    headers(path, options) {\n        if(path.startsWith('user'))\n            return {\n                authorization: 'Bearer 12345'\n            }\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Using WebSocket in Elysia\nDESCRIPTION: Shows the updated WebSocket API in Elysia 1.2 with ping and pong handlers.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-12.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nnew Elysia()\n\t.ws('/ws', {\n\t\tping: (message) => message,\n\t\tpong: (message) => message\n\t})\n```\n\n----------------------------------------\n\nTITLE: Running Elysia Server in Production (Bash)\nDESCRIPTION: This snippet shows how to run the compiled Elysia server binary in production.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_36\n\nLANGUAGE: bash\nCODE:\n```\n./server\n```\n\n----------------------------------------\n\nTITLE: Type-Safe Error Handling with Status-Based Error Types\nDESCRIPTION: This code demonstrates how to use status-based error types on the client side. It shows how TypeScript can narrow down error types based on the status code, providing better type safety when handling specific errors.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/legacy.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst { data: nendoroid, error } = app.mirror.post({\n    id: 1895,\n    name: 'Skadi'\n})\n\nif(error) {\n    switch(error.status) {\n        case 400:\n        case 401:\n            // narrow down to type 'error' described in the server\n            warnUser(error.value)\n            break\n\n        default:\n            // typed as unknown\n            reportError(error.value)\n            break\n    }\n\n    throw error\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Secure Cookie Attribute Elysia.js JavaScript\nDESCRIPTION: This snippet describes enabling or disabling the Secure cookie attribute using a boolean in Elysia.js. When true, cookies are transmitted only over HTTPS. There are no external dependencies. Input: boolean; output: cookie with the Secure attribute if true. Setting improperly may prevent cookies from being sent over HTTP.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/cookie.md#2025-04-23_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\n/*\nSpecifies the boolean value for the [Secure Set-Cookie attribute](https://tools.ietf.org/html/rfc6265#section-5.2.5). When truthy, the Secure attribute is set, otherwise, it is not. By default, the Secure attribute is not set.\n*/\n```\n\n----------------------------------------\n\nTITLE: Automatic JSON Response Handling\nDESCRIPTION: Example of Elysia's automatic JSON response conversion\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/cheat-sheet.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .get('/json', () => {\n        return {\n            hello: 'Elysia'\n        }\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Installing Optional Dependencies\nDESCRIPTION: Command to install optional peer dependencies for GraphQL Yoga plugin.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/graphql-yoga.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbun add graphql graphql-yoga\n```\n\n----------------------------------------\n\nTITLE: Installing Cron Plugin with Bun - Bash\nDESCRIPTION: Installs the @elysiajs/cron package into your project using the Bun package manager. Required as a prerequisite for all cron-related usage within ElysiaJS. No parameters are needed; simply execute the command in your project root. This will update your package manifest and install dependencies accordingly.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/cron.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun add @elysiajs/cron\n```\n\n----------------------------------------\n\nTITLE: Converting Drizzle Schema to Elysia Validation Models\nDESCRIPTION: TypeScript example showing how to convert a Drizzle user table schema into Elysia validation models using drizzle-typebox, enabling reuse of database schema for API validation.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/drizzle.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createInsertSchema } from 'drizzle-typebox'\nimport { table } from './database/schema'\n\nconst _createUser = createInsertSchema(table.user, {\n\t// Replace email with Elysia's email type\n\temail: t.String({ format: 'email' })\n})\n\nnew Elysia()\n\t.post('/sign-up', ({ body }) => {\n\t\t// Create a new user\n\t}, {\n\t\tbody: t.Omit(\n\t\t\t_createUser,\n\t\t\t['id', 'salt', 'createdAt']\n\t\t)\n\t})\n```\n\n----------------------------------------\n\nTITLE: Customizing Swagger Documentation Info\nDESCRIPTION: Configuration example for customizing Swagger documentation metadata including title and version\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/swagger.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { swagger } from '@elysiajs/swagger'\n\nnew Elysia()\n    .use(\n        swagger({\n            documentation: {\n                info: {\n                    title: 'Elysia Documentation',\n                    version: '1.0.0'\n                }\n            }\n        })\n    )\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Implementing TypeBox Numeric Transform in TypeScript\nDESCRIPTION: Demonstrates the new TypeBox 0.31 Transform feature for handling numeric type conversion with decode and encode functions\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-07.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nNumeric: (property?: NumericOptions<number>) =>\n    Type.Transform(Type.Union([Type.String(), Type.Number(property)]))\n        .Decode((value) => {\n            const number = +value\n            if (isNaN(number)) return value\n\n            return number\n        })\n        .Encode((value) => value) as any as TNumber,\n```\n\n----------------------------------------\n\nTITLE: Sending Messages with Updated Elysia WebSocket API - TypeScript\nDESCRIPTION: Explains the migration in Elysia 1.2 where WebSocket methods now return their respective values rather than allowing method chaining, in line with compatibility goals with Bun's API. The snippet displays old versus new usage for the `send` method inside a WebSocket endpoint. Requires the `elysia` package. The `ws` handler accepts a client connection, with key changes highlighted between chained and unchained invocations. Outputs direct message sends to the client socket without chained calls. Users should migrate off chaining for future compatibility.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-12.md#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n\t.ws('/', {\n\t\tmessage(ws) {\n\t\t\tws // [!code --]\n\t\t\t\t.send('hello') // [!code --]\n\t\t\t\t.send('world') // [!code --]\n\n\t\t\tws.send('hello') // [!code ++]\n\t\t\tws.send('world') // [!code ++]\n\t\t}\n\t})\n```\n\n----------------------------------------\n\nTITLE: Using scoped path aliases in TypeScript configuration\nDESCRIPTION: This JSON snippet shows a recommended approach for setting up scoped path aliases in a monorepo to avoid conflicts and improve module resolution.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/installation.md#2025-04-23_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n  \t\"baseUrl\": \".\",\n\t\"paths\": {\n\t  \"@frontend/*\": [\"./apps/frontend/src/*\"],\n\t  \"@backend/*\": [\"./apps/backend/src/*\"]\n\t}\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Instance Name for Plugin Deduplication in Elysia\nDESCRIPTION: Demonstrates how to define a name for an Elysia instance, which is useful for debugging and plugin deduplication. The name helps identify specific instances when using multiple plugins.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/configuration.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia({\n\tname: 'service.thing'\n})\n```\n\n----------------------------------------\n\nTITLE: Equivalent Inline Hook in ElysiaJS\nDESCRIPTION: Shows the equivalent code without using macro, directly pushing a function to the beforeHandle lifecycle. This example demonstrates the simplification macro provides.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/macro.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst app = new Elysia()\n    .get('/', () => 'hi', {\n        beforeHandle() {\n            console.log('Elysia')\n        }\n    })\n```\n\n----------------------------------------\n\nTITLE: Setting Default Status Code in ElysiaJS Lifecycle\nDESCRIPTION: Demonstrates how to set a default status code using onBeforeHandle lifecycle hook in ElysiaJS.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .onBeforeHandle(({ set }) => {\n        set.status = 418\n\n        return 'Kirifuji Nagisa'\n    })\n    .get('/', () => 'hi')\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: File Response Handling\nDESCRIPTION: Demonstrates returning files as part of the response using formdata\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/cheat-sheet.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, file } from 'elysia'\n\nnew Elysia()\n    .get('/json', () => {\n        return {\n            hello: 'Elysia',\n            image: file('public/cat.jpg')\n        }\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Comparing ElysiaJS 1.0 vs 1.1 for Applying Multiple Scoped Hooks\nDESCRIPTION: Contrasts the ElysiaJS 1.0 approach of applying 'scoped' behavior individually to multiple hooks (`onBeforeHandle`, `onAfterHandle`, etc.) with the more concise ElysiaJS 1.1 method using `.as('plugin')`. The 1.1 approach allows defining hooks with default local scope and then lifting them collectively to 'scoped', while also applying guard schemas scope-wise, which wasn't straightforward in 1.0. Requires `elysia` and `t` imports.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-11.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\n// On 1.0\nconst from = new Elysia()\n\t// Not possible to apply guard to parent on 1.0\n\t.guard({\n\t\tresponse: t.String()\n\t})\n\t.onBeforeHandle({ as: 'scoped' }, () => { console.log('called') })\n\t.onAfterHandle({ as: 'scoped' }, () => { console.log('called') })\n\t.onParse({ as: 'scoped' }, () => { console.log('called') })\n\n// On 1.1\nconst to = new Elysia()\n\t.guard({\n\t\tresponse: t.String()\n\t})\n\t.onBeforeHandle(() => { console.log('called') })\n\t.onAfterHandle(() => { console.log('called') })\n\t.onParse(() => { console.log('called') })\n\t.as('plugin')\n```\n\n----------------------------------------\n\nTITLE: Demonstrating TypeScript Route Limit in Elysia 0.x\nDESCRIPTION: Shows the previous limitation in Elysia where adding more than ~40 routes would cause a TypeScript error due to excessive type instantiation depth.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-10.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst main = new Elysia()\n    .get('/1', () => '1')\n    .get('/2', () => '2')\n    .get('/3', () => '3')\n    // repeat for 40 times\n    .get('/42', () => '42')\n    // Type instantiation is excessively deep and possibly infinite\n```\n\n----------------------------------------\n\nTITLE: Nullable Type for Allowing Null Values in ElysiaJS\nDESCRIPTION: Shows how to create a validator that allows a value to be null but not undefined, useful for optional fields that should be explicitly set or null.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/type.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nt.Nullable(t.String())\n```\n\n----------------------------------------\n\nTITLE: Configuring ElysiaJS with Custom User Route Prefix\nDESCRIPTION: Demonstrates how to configure ElysiaJS with a custom prefix for nested routes within Next.js app directory structure. Shows setup for '/user' prefix with GET and POST handlers.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/nextjs.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// app/user/[[...slugs]]/route.ts\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia({ prefix: '/user' })\n    .get('/', () => 'hi')\n    .post('/', ({ body }) => body, {\n        body: t.Object({\n            name: t.String()\n        })\n    })\n\nexport const GET = app.handle\nexport const POST = app.handle\n```\n\n----------------------------------------\n\nTITLE: Docker Configuration for Elysia.js in Monorepo\nDESCRIPTION: Dockerfile for deploying an Elysia.js application from a monorepo structure. It handles dependencies between packages in the monorepo architecture.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/deployment.md#2025-04-23_snippet_7\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM oven/bun:1 AS build\n\nWORKDIR /app\n\n# Cache packages\nCOPY package.json package.json\nCOPY bun.lock bun.lock\n\nCOPY /apps/server/package.json ./apps/server/package.json\nCOPY /packages/config/package.json ./packages/config/package.json\n\nRUN bun install\n\nCOPY /apps/server ./apps/server\nCOPY /packages/config ./packages/config\n\nENV NODE_ENV=production\n\nRUN bun build \\\n\t--compile \\\n\t--minify-whitespace \\\n\t--minify-syntax \\\n\t--target bun \\\n\t--outfile server \\\n\t./src/index.ts\n\nFROM gcr.io/distroless/base\n\nWORKDIR /app\n\nCOPY --from=build /app/server server\n\nENV NODE_ENV=production\n\nCMD [\"./server\"]\n\nEXPOSE 3000\n```\n\n----------------------------------------\n\nTITLE: Creating an Elysia Project with Bun\nDESCRIPTION: Shows the command to create a new Elysia project using Bun's project creation tool.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-supabase.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbun create elysia elysia-supabase\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Global Hook Behavior in TypeScript\nDESCRIPTION: Shows the previous behavior of hooks being global by default, which could cause unintended side effects across plugin usage.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-10.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst plugin = new Elysia()\n    .onBeforeHandle(() => {\n        console.log('Hi')\n    })\n    // log Hi\n    .get('/hi', () => 'in plugin')\n\nconst app = new Elysia()\n    .use(plugin)\n    // will also log hi\n    .get('/no-hi-please', () => 'oh no')\n```\n\n----------------------------------------\n\nTITLE: Strict Path Handling in Elysia.js\nDESCRIPTION: Shows the traditional strict path handling approach where routes need to be defined separately for paths with and without trailing slashes.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-06.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nnew Elysia()\n    .group('/v1', (app) => app\n        // Handle /v1\n        .get('', handle)\n        // Handle /v1/\n        .get('/', handle)\n    )\n```\n\n----------------------------------------\n\nTITLE: Skipping Body Parsing with Static Code Analysis in Elysia - TypeScript\nDESCRIPTION: Shows how Static Code Analysis can detect unused properties like body to skip parsing entirely, improving performance. Although a body schema is defined, Elysia determines that only the params.id is actually used in the handler function.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-05.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Body is not used, skip body parsing\napp.post('/id/:id', ({ params: { id } }) => id, {\n    schema: {\n        body: t.Object({\n            username: t.String(),\n            password: t.String()\n        })\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Migration Example for Hook Types\nDESCRIPTION: Shows how to migrate from Elysia 0.8 to 1.0 by explicitly declaring global hooks.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-10.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// From Elysia 0.8\nnew Elysia()\n    .onBeforeHandle(() => \"A\")\n    .derive(() => {})\n\n// Into Elysia 1.0\nnew Elysia()\n    .onBeforeHandle({ as: 'global' }, () => \"A\")\n    .derive({ as: 'global' }, () => {})\n```\n\n----------------------------------------\n\nTITLE: TypeScript Configuration\nDESCRIPTION: Basic TypeScript configuration for an Elysia project with strict mode enabled.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/quick-start.md#2025-04-23_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n   \t\"compilerOptions\": {\n  \t\t\"strict\": true\n   \t}\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Prisma CLI as Dev Dependency\nDESCRIPTION: Adds Prisma CLI to the project as a development dependency using Bun's package manager.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/with-prisma.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbun add -d prisma\n```\n\n----------------------------------------\n\nTITLE: Building Elysia Server for Production (Bash)\nDESCRIPTION: This snippet provides the command to build the Elysia server for production using Bun. It includes options for compilation, minification, and output configuration.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_35\n\nLANGUAGE: bash\nCODE:\n```\nbun build \\\n\t--compile \\\n\t--minify-whitespace \\\n\t--minify-syntax \\\n\t--target bun \\\n\t--outfile server \\\n\t./src/index.ts\n```\n\n----------------------------------------\n\nTITLE: Consuming Elysia API with Eden Treaty on Client Side in TypeScript\nDESCRIPTION: This snippet shows how to use Eden Treaty to interact with an Elysia server from the client side. It imports the server type, creates a treaty instance, and demonstrates making a type-safe API call.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/overview.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { treaty } from '@elysiajs/eden'\nimport type { App } from './server'\n\nconst app = treaty<App>('localhost:3000')\n\n// response type: 'Hi Elysia'\nconst { data, error } = await app.hi.get()\n```\n\n----------------------------------------\n\nTITLE: Creating New Elysia Project with Bun\nDESCRIPTION: Command to scaffold a new Elysia project using Bun's project creation tool\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/integrate-trpc-with-elysia.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun create elysia elysia-trpc && cd elysia-trpc && bun add elysia\n```\n\n----------------------------------------\n\nTITLE: Remapping State Properties in ElysiaJS using Function Pattern (TypeScript)\nDESCRIPTION: Demonstrates the remap pattern using `state` with a function. This function receives the current store and returns a new object, effectively reassigning the state. In this example, it renames 'version' to 'elysiaVersion' and excludes the original 'version' property.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n// @errors: 2339\nimport { Elysia } from 'elysia'\n\nnew Elysia()\n    .state('counter', 0)\n    .state('version', 1)\n    .state(({ version, ...store }) => ({\n        ...store,\n        elysiaVersion: 1\n    }))\n    // âœ… Create from state remap\n    .get('/elysia-version', ({ store }) => store.elysiaVersion)\n    // âŒ Excluded from state remap\n    .get('/version', ({ store }) => store.version)\n```\n\n----------------------------------------\n\nTITLE: Incorrect Request-Dependent Service Pattern in ElysiaJS (TypeScript)\nDESCRIPTION: Demonstrates an anti-pattern for implementing request-dependent services in ElysiaJS by passing the entire Context object. This approach reduces type integrity and makes code harder to maintain.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/best-practice.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Context } from 'elysia'\n\nclass AuthService {\n\tconstructor() {}\n\n\t// âŒ Don't do this\n\tisSignIn({ cookie: { session } }: Context) {\n\t\tif (session.value)\n\t\t\treturn error(401)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Default Local Scope of ElysiaJS Guard (Pre-1.1)\nDESCRIPTION: Demonstrates the historical behavior of `guard` in ElysiaJS before version 1.1. Hooks defined within a guard, such as `beforeHandle`, only applied to routes defined within the same Elysia instance (`plugin`), not affecting routes in the parent instance (`main`) where the plugin is used.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-11.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst plugin = new Elysia()\n\t.guard({\n\t\tbeforeHandle() {\n\t\t\tconsole.log('called')\n\t\t}\n\t})\n\t.get('/plugin', () => 'ok')\n\nconst main = new Elysia()\n\t.use(plugin)\n\t.get('/', () => 'ok')\n```\n\n----------------------------------------\n\nTITLE: Fetch Function Type Definition\nDESCRIPTION: Type definition for a WinterCG-compliant fetch function that accepts a RequestLike object and returns a Response.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/mount.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Web Standard Request-like object\n// Web Standard Response\ntype fetch = (request: RequestLike) => Response\n```\n\n----------------------------------------\n\nTITLE: Running Compiled Elysia.js JavaScript Bundle\nDESCRIPTION: Command to run the compiled JavaScript bundle in production mode using Bun.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/deployment.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nNODE_ENV=production bun ./dist/index.js\n```\n\n----------------------------------------\n\nTITLE: GraphQL Integration\nDESCRIPTION: Demonstrates integration with GraphQL Yoga for GraphQL server functionality\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/cheat-sheet.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { yoga } from '@elysiajs/graphql-yoga'\n\nconst app = new Elysia()\n    .use(\n        yoga({\n            typeDefs: /* GraphQL */`\n                type Query {\n                    hi: String\n                }\n            `,\n            resolvers: {\n                Query: {\n                    hi: () => 'Hello from Elysia'\n                }\n            }\n        })\n    )\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Running Jaeger Docker Container\nDESCRIPTION: Docker command to run Jaeger all-in-one container with necessary port mappings and environment configurations for collecting telemetry data.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --name jaeger \\\n  -e COLLECTOR_ZIPKIN_HOST_PORT=:9411 \\\n  -e COLLECTOR_OTLP_ENABLED=true \\\n  -p 6831:6831/udp \\\n  -p 6832:6832/udp \\\n  -p 5778:5778 \\\n  -p 16686:16686 \\\n  -p 4317:4317 \\\n  -p 4318:4318 \\\n  -p 14250:14250 \\\n  -p 14268:14268 \\\n  -p 14269:14269 \\\n  -p 9411:9411 \\\n  jaegertracing/all-in-one:latest\n```\n\n----------------------------------------\n\nTITLE: Deriving Types from ElysiaJS Models using typeof .static (TypeScript)\nDESCRIPTION: Demonstrates the recommended method for obtaining a static TypeScript type from an ElysiaJS model schema defined using `t.Object`. Instead of manually declaring a separate type, use `typeof model.static` to ensure type consistency and reduce redundancy. Requires the 'elysia' package.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/best-practice.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n// âŒ Don't\nimport { Elysia, t } from 'elysia'\n\nconst customBody = t.Object({\n\tusername: t.String(),\n\tpassword: t.String()\n})\n\ntype CustomBody = {\n\tusername: string\n\tpassword: string\n}\n\n// âœ… Do\nconst customBody = t.Object({\n\tusername: t.String(),\n\tpassword: t.String()\n})\n\ntype CustomBody = typeof customBody.static\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC Dependencies\nDESCRIPTION: Command to install required dependencies for tRPC integration with Elysia\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/integrate-trpc-with-elysia.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbun add @trpc/server zod @elysiajs/trpc @elysiajs/cors\n```\n\n----------------------------------------\n\nTITLE: Compiling Elysia.js to JavaScript\nDESCRIPTION: Command to bundle an Elysia.js server to a JavaScript file instead of a binary. Useful for environments where binary compilation isn't possible or for Windows servers.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/deployment.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nbun build \\\n\t--compile \\ // [!code --]\n\t--minify-whitespace \\\n\t--minify-syntax \\\n\t--target bun \\\n\t--outfile ./dist/index.js \\\n\t./src/index.ts\n```\n\n----------------------------------------\n\nTITLE: Configuring Eden Treaty with Custom Fetch Options in TypeScript\nDESCRIPTION: Demonstrates how to add custom fetch options when initializing Eden Treaty. This example sets the credentials option to 'include'.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/config.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport type App = typeof app // [!code ++]\nimport { treaty } from '@elysiajs/eden'\n// ---cut---\ntreaty<App>('localhost:3000', {\n    fetch: {\n        credentials: 'include'\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Elysia Server with Prefix for Nested Routes\nDESCRIPTION: Example of setting up an Elysia server with a prefix for use in nested Expo API routes.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/expo.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// app/api/[...slugs]+api.ts\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia({ prefix: '/api' })\n    .get('/', () => 'hi')\n    .post('/', ({ body }) => body, {\n        body: t.Object({\n            name: t.String()\n        })\n    })\n\nexport const GET = app.handle\nexport const POST = app.handle\n```\n\n----------------------------------------\n\nTITLE: Losing Reference When Assigning Primitive Property to New Variable\nDESCRIPTION: Illustrates a common JavaScript pitfall where assigning a primitive property (like a number) from an object to a new variable creates a copy, not a reference. Modifying the new variable (`counter`) does not affect the original object's property (`store.counter`).\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/handler.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nconst store = {\n    counter: 0\n}\n\nlet counter = store.counter\n\ncounter++\nconsole.log(store.counter) // âŒ 0\nconsole.log(counter) // âœ… 1\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Increased Route Limit in Elysia 1.0\nDESCRIPTION: Shows how Elysia 1.0 has overcome the previous route limit, allowing for theoretically unlimited routes until TypeScript breaks (around 558 routes).\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-10.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst main = new Elysia()\n    .get('/1', () => '1')\n    .get('/2', () => '2')\n    .get('/3', () => '42')\n    // repeat for n times\n    .get('/550', () => '550')\n```\n\n----------------------------------------\n\nTITLE: Installing ElysiaJS HTML Plugin\nDESCRIPTION: Command to install the HTML plugin using Bun package manager\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/html.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun add @elysiajs/html\n```\n\n----------------------------------------\n\nTITLE: Custom Error Response in Elysia.js\nDESCRIPTION: This example demonstrates how to return a custom error response for specific error types. In this case, it returns a custom message for 404 Not Found errors while still logging other errors to the console.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\nimport { swagger } from '@elysiajs/swagger'\n\nimport { note } from './note'\n\nconst app = new Elysia()\n    .use(swagger())\n    .onError(({ error, code }) => {\n        if (code === 'NOT_FOUND') return 'Not Found :('\n\n        console.error(error)\n    })\n    .use(note)\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Installing Swagger Plugin for ElysiaJS\nDESCRIPTION: Command to install the Swagger plugin for API documentation generation.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/with-prisma.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nbun add @elysiajs/swagger\n```\n\n----------------------------------------\n\nTITLE: Configuring Schema Normalization in Elysia\nDESCRIPTION: Shows how to configure schema normalization behavior. When enabled, Elysia will coerce fields into their specified schema types; when disabled, it will raise errors for fields not explicitly allowed in the schema.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/patterns/configuration.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t } from 'elysia'\n\nnew Elysia({\n\tnormalize: true\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing Eden Treaty with URL Endpoint in TypeScript\nDESCRIPTION: Creates an Eden Treaty instance using a URL endpoint. This approach uses fetch or a custom fetcher to make network requests to an Elysia instance.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/config.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { treaty } from '@elysiajs/eden'\nimport type { App } from './server'\n\nconst api = treaty<App>('localhost:3000')\n```\n\n----------------------------------------\n\nTITLE: Installing ElysiaJS Stream Plugin - Bash\nDESCRIPTION: This snippet provides the Bash command to install the ElysiaJS Stream plugin using Bun's package manager. Developers must run this command in their project root before using any of the plugin's features.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/stream.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun add @elysiajs/stream\n```\n\n----------------------------------------\n\nTITLE: Defining Prisma Schema for User Model\nDESCRIPTION: Creates a Prisma schema file defining a User model with id, username, and password fields. This schema will be used to generate the database structure.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/with-prisma.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id        Int     @id @default(autoincrement())\n  username  String  @unique\n  password  String\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Supabase Environment Variables\nDESCRIPTION: Shows the structure of the .env file for storing Supabase configuration variables.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-supabase.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# .env\nsupabase_url=https://********************.supabase.co\nsupabase_service_role=**** **** **** ****\n```\n\n----------------------------------------\n\nTITLE: Installing GraphQL Yoga Plugin\nDESCRIPTION: Command to install the GraphQL Yoga plugin for Elysia using Bun package manager.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/graphql-yoga.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun add @elysiajs/graphql-yoga\n```\n\n----------------------------------------\n\nTITLE: Serving a Single Static File using ElysiaJS file function\nDESCRIPTION: This TypeScript snippet shows an alternative method to serve a specific static file without using the full static plugin. It uses the built-in `file` function from ElysiaJS within a GET route handler to directly serve the 'public/takodachi.png' file when the '/file' endpoint is requested. This is useful for serving individual files without configuring the entire static directory.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/static.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, file } from 'elysia'\n\nnew Elysia()\n    .get('/file', file('public/takodachi.png'))\n```\n\n----------------------------------------\n\nTITLE: Running Eden Tests with Bun\nDESCRIPTION: Command to execute the Eden integration tests using the Bun test runner\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/test.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbun test\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Plugin in Elysia\nDESCRIPTION: Demonstrates how to create a deferred/lazy loading module using async plugin pattern in Elysia 0.2\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-02.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst plugin = async (app: Elysia) => {\n    const stuff = await doSomeHeavyWork()\n\n    return app.get('/heavy', stuff)\n}\n\napp.use(plugin)\n```\n\n----------------------------------------\n\nTITLE: Configuring Astro for Server Output\nDESCRIPTION: Sets up Astro configuration to enable server-side rendering by modifying the astro.config.mjs file to use 'server' as the output mode, which is required for running Elysia.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/astro.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// astro.config.mjs\nimport { defineConfig } from 'astro/config'\n\n// https://astro.build/config\nexport default defineConfig({\n    output: 'server' // [!code ++]\n})\n```\n\n----------------------------------------\n\nTITLE: Enabling strict mode in TypeScript configuration\nDESCRIPTION: This JSON snippet shows how to enable strict mode in tsconfig.json to improve type inference for Eden.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/installation.md#2025-04-23_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"strict\": true // [!code ++]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing OpenTelemetry Plugin\nDESCRIPTION: Command to install the OpenTelemetry plugin for Elysia.js using Bun package manager.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/tutorial.md#2025-04-23_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\nbun add @elysiajs/opentelemetry\n```\n\n----------------------------------------\n\nTITLE: Optimizing Static Content Serving in Elysia\nDESCRIPTION: This code snippet shows how to use the new static content optimization feature in Elysia 0.8, which improves performance for serving static files by determining the Response Ahead of Time.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-08.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nnew Elysia()\n    .get('/', Bun.file('video/kyuukurarin.mp4'))\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Creating Elysia Project with Bun\nDESCRIPTION: Initializes a new Elysia project using Bun's create command. This sets up the basic structure for an Elysia server.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/with-prisma.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun create elysia elysia-prisma\n```\n\n----------------------------------------\n\nTITLE: Installing Swagger Plugin for Elysia using Bun (Bash)\nDESCRIPTION: This bash command installs the Swagger plugin for Elysia, enabling OpenAPI spec generation and interactive documentation. Prerequisite: Bun package manager environment. Inputs: None. Outputs: Installs '@elysiajs/swagger@rc' as a dependency.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-supabase.md#2025-04-23_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nbun add @elysiajs/swagger@rc\n```\n\n----------------------------------------\n\nTITLE: Configuring Vue Components Import in ElysiaJS Docs\nDESCRIPTION: Vue script setup block importing Card and Deck components for documentation page layout.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/table-of-content.md#2025-04-23_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\n    import Card from './components/nearl/card.vue'\n    import Deck from './components/nearl/card-deck.vue'\n</script>\n```\n\n----------------------------------------\n\nTITLE: Running Type Safety Tests with TypeScript Compiler\nDESCRIPTION: This command uses the TypeScript compiler to perform type safety tests on all test files without emitting JavaScript output. This approach helps ensure type integrity between client and server, especially during migrations.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/treaty/unit-test.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntsc --noEmit test/**/*.ts\n```\n\n----------------------------------------\n\nTITLE: Creating a Better Auth View Handler for ElysiaJS\nDESCRIPTION: Implementation of a view handler function for Better Auth that processes authentication requests in an ElysiaJS context. It checks the request method and routes the request to the appropriate auth handler.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/better-auth.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Context } from \"elysia\";\nimport { auth } from \"./auth\";\n\nconst betterAuthView = (context: Context) => {\n    const BETTER_AUTH_ACCEPT_METHODS = [\"POST\", \"GET\"]\n    if(BETTER_AUTH_ACCEPT_METHODS.includes(context.request.method)) {\n      console.log(context.request)\n      return auth.handler(context.request);\n    }\n    else {\n      context.error(405)\n    }\n  }\n\nexport default betterAuthView;\n```\n\n----------------------------------------\n\nTITLE: Installing Eden and dependencies using Bun\nDESCRIPTION: This snippet shows how to install Eden, Elysia, and necessary type definitions using Bun package manager.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/eden/installation.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun add @elysiajs/eden\nbun add -d elysia\n\n# `@types/bun` must be installed even if you aren't using bun in the client\nbun add -d @types/bun\n```\n\n----------------------------------------\n\nTITLE: Node.js ElysiaJS Setup\nDESCRIPTION: Setup code for running Elysia with Node.js adapter.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/quick-start.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { node } from '@elysiajs/node'\n\nconst app = new Elysia({ adapter: node() })\n\t.get('/', () => 'Hello Elysia')\n\t.listen(3000, ({ hostname, port }) => {\n\t\tconsole.log(\n\t\t\t`ðŸ¦Š Elysia is running at ${hostname}:${port}`\n\t\t)\n\t})\n```\n\n----------------------------------------\n\nTITLE: Incorrect Method Usage in ElysiaJS\nDESCRIPTION: Shows the incorrect approach of not using method chaining, which breaks type inference in ElysiaJS.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/structure.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\n\nconst app = new Elysia()\n\napp.state('build', 1)\n\napp.get('/', ({ store: { build } }) => build)\n\napp.listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Lazy Loading Module Implementation\nDESCRIPTION: Shows how to implement lazy loading of modules using dynamic imports in Elysia 0.2\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-02.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\napp.use(import('./some-heavy-module'))\n```\n\n----------------------------------------\n\nTITLE: Configuring Vue Component for Elysia Blog Landing Page\nDESCRIPTION: Sets up a Vue component named 'Blogs' and passes an array of blog post data as a prop. Each blog post object contains a title, href (link), and detail (description).\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog.md#2025-04-23_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\n    import Blogs from './components/blog/Landing.vue'\n</script>\n\n<Blogs\n  :blogs=\"[\n      {\n        title: 'Elysia 1.2 - You and Me',\n        href: '/blog/elysia-12',\n        detail: 'Introducing Adapter for universal runtime suppport, Object macro with resolve, Parser with custom name, WebSocket with lifecycle, TypeBox 0.34 with recursive type, and Eden validation inference.'\n      },\n\t  {\n\t    title: 'Elysia 1.1 - Grown-up\\'s Paradise',\n\t    href: '/blog/elysia-11',\n\t    detail: 'Introducing OpenTelemetry, and Trace v2. Data coercion and normalization. Guard plugin and bulk cast. Optional path parameter. Decorator and Response status reconcilation. Generator response stream.'\n\t  },\n      {\n        title: 'Elysia 1.0 - Lament of the Fallen',\n        href: '/blog/elysia-10',\n        detail: 'Introducing Sucrose, a better static code analysis engine, improved starts up time up to 14x, remove 40 routes/instance limitation, faster type inference up to ~3.8x, Eden Treaty 2, Hook type (breaking change), and inline error for strict type check.'\n      },\n      {\n        title: 'Introducing Elysia 0.8 - Gate of Steiner',\n        href: '/blog/elysia-08',\n        detail: 'Introducing Macro API, a new way to interact with Elysia. New Lifecycle, resolve, and mapResponse to interact with Elysia even more. Static Content to compile static resource ahead of time. Default Property, Default Header and several improvement.'\n      },\n      {\n        title: 'Introducing Elysia 0.7 - Stellar Stellar',\n        href: '/blog/elysia-07',\n        detail: 'Introducing up to 13x faster type inference. Declarative telemetry with trace. Reactive cookie model, and cookie validation. TypeBox 0.31 and custom decoder support. Rewritten Web Socket. Definitions remapping and custom affix. Leading more solid foundation for Elysia for a brighter future.'\n      },\n      {\n        title: 'Introducing Elysia 0.6 - This Game',\n        href: '/blog/elysia-06',\n        detail: 'Introducing re-imagined plugin model, dynamic mode, better developer experience with declarative custom error, customizable loose and strict path mapping, TypeBox 0.30 and WinterCG framework interlop. Pushing the boundary of what is possible once again'\n      },\n      {\n        title: 'Accelerate your next Prisma server with Elysia',\n        href: '/blog/with-prisma',\n        detail: 'With the support of Prisma with Bun and Elysia, we are entering a new era of a new level of developer experience. For Prisma we can accelerate our interaction with database, Elysia accelerate our creation of backend web server in term of both developer experience and performance.'\n      },\n      {\n          title: 'Introducing Elysia 0.5 - Radiant',\n          href: '/blog/elysia-05',\n          detail: 'Introducing Static Code Analysis, New router Memoirist, TypeBox 0.28, Numeric type, inline schema, state/decorate/model/group rework, and type stability.'\n      },\n      {\n          title: 'Introducing Elysia 0.4 - æœˆå¤œã®éŸ³æ¥½ä¼š (Moonlit Night Concert)',\n          href: '/blog/elysia-04',\n          detail: 'Introducing Ahead of Time Compilation, TypeBox 0.26, Response validation per status, and Separation of Elysia Fn.'\n      },\n      {\n          title: 'Elysia with Supabase. Your next backend at sonic speed',\n          href: '/blog/elysia-supabase',\n          detail: 'Elysia, and Supabase are a great match for rapidly developing prototype in less than a hour, let\\'s take a look of how we can take advantage of both.'\n      },\n      {\n          title: 'Introducing Elysia 0.3 - å¤§åœ°ã®é–¾ã‚’æŽ¢ã—ã¦ [Looking for Edge of Ground]',\n          href: '/blog/elysia-03',\n          detail: 'Introducing Elysia Fn, Type Rework for highly scalable TypeScript performance, File Upload support and validation, Reworked Eden Treaty.'\n      },\n      {\n          title: 'Integrate existing tRPC server to Bun with Elysia',\n          href: '/blog/integrate-trpc-with-elysia',\n          detail: 'Learn how to integrate existing tRPC to Elysia and Bun with Elysia tRPC plugin and more about Eden end-to-end type-safety for Elysia.'\n      },\n      {\n          title: 'Introducing Elysia 0.2 - The Blessing',\n          href: '/blog/elysia-02',\n          detail: 'Introducing Elysia 0.2, bringing more improvement, mainly on TypeScript performance, type-inference, and better auto-completion and some new features to reduce boilerplate.'\n      }\n  ]\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Installing Swagger Plugin for ElysiaJS\nDESCRIPTION: Command to install the @elysiajs/swagger plugin using Bun package manager.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/openapi.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun add @elysiajs/swagger\n```\n\n----------------------------------------\n\nTITLE: Installing React Email Dependencies\nDESCRIPTION: Commands for installing React Email and its dependencies. This includes the development dependency react-email and the runtime dependencies for React components.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/react-email.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun add -d react-email\nbun add @react-email/components react react-dom\n```\n\n----------------------------------------\n\nTITLE: Package.json Scripts Configuration\nDESCRIPTION: Essential npm scripts for development, building, and running an Elysia application.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/quick-start.md#2025-04-23_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n   \t\"scripts\": {\n  \t\t\"dev\": \"bun --watch src/index.ts\",\n  \t\t\"build\": \"bun build src/index.ts --target bun --outdir ./dist\",\n  \t\t\"start\": \"NODE_ENV=production bun dist/index.js\",\n  \t\t\"test\": \"bun test\"\n   \t}\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up PostgreSQL Database with Docker\nDESCRIPTION: Runs a PostgreSQL database instance using Docker, exposing it on port 5432 with a specified password.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/with-prisma.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -p 5432:5432 -e POSTGRES_PASSWORD=12345678 -d postgres\n```\n\n----------------------------------------\n\nTITLE: Validation Error Response Format in Elysia\nDESCRIPTION: Example of the new JSON validation error format that includes detailed error information, expected values, and found values to help identify validation issues.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-08.md#2025-04-23_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"query\",\n  \"at\": \"password\",\n  \"message\": \"Required property\",\n  \"expected\": {\n    \"email\": \"eden@elysiajs.com\",\n    \"password\": \"\"\n  },\n  \"found\": {\n    \"email\": \"eden@elysiajs.com\"\n  },\n  \"errors\": [\n    {\n      \"type\": 45,\n      \"schema\": {\n        \"type\": \"string\"\n      },\n      \"path\": \"/password\",\n      \"message\": \"Required property\"\n    },\n    {\n      \"type\": 54,\n      \"schema\": {\n        \"type\": \"string\"\n      },\n      \"path\": \"/password\",\n      \"message\": \"Expected string\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Using Callback Function for Plugin Registration (Previous Approach)\nDESCRIPTION: Shows how to register an Elysia plugin using the callback function approach that was standard before version 0.6. This method passes an Elysia instance to a function that configures and returns it.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-06.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst plugin = (app: Elysia) => app.get('/', () => 'hello')\n```\n\n----------------------------------------\n\nTITLE: Adding React Email Script to Package.json\nDESCRIPTION: Configuration for package.json to add the email development script that enables previewing emails from the src/emails directory.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/react-email.md#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"email\": \"email dev --dir src/emails\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Apollo GraphQL Plugin Dependencies with Bun\nDESCRIPTION: Shows how to install the required packages (`graphql`, `@elysiajs/apollo`, `@apollo/server`) using the Bun package manager. These dependencies are necessary to use the Apollo GraphQL plugin within an ElysiaJS project.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/graphql-apollo.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun add graphql @elysiajs/apollo @apollo/server\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC Plugin Dependencies\nDESCRIPTION: Command to install the required dependencies for using tRPC with ElysiaJS including the core package, server package, and websocket support.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/trpc.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun add @elysiajs/trpc @trpc/server @elysiajs/websocket\n```\n\n----------------------------------------\n\nTITLE: Installing Better Auth with Bun Package Manager\nDESCRIPTION: Command to install the Better Auth package using Bun package manager. This is the initial step for integrating Better Auth into an ElysiaJS project.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/better-auth.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun add better-auth\n```\n\n----------------------------------------\n\nTITLE: Package.json TypeBox Version Override Configuration\nDESCRIPTION: JSON configuration for overriding the @sinclair/typebox version to ensure compatibility between Elysia and drizzle-typebox.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/drizzle.md#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"overrides\": {\n  \t\"@sinclair/typebox\": \"0.32.4\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Expo App with Tabs Template\nDESCRIPTION: Command to create a new Expo app using the tabs template.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/expo.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun create expo-app --template tabs\n```\n\n----------------------------------------\n\nTITLE: Configuring OpenTelemetry with Axiom in ElysiaJS\nDESCRIPTION: Example of exporting telemetry data to Axiom service by configuring the OTLP exporter with custom headers and URL.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/opentelemetry.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { opentelemetry } from '@elysiajs/opentelemetry'\n\nimport { BatchSpanProcessor } from '@opentelemetry/sdk-trace-node'\nimport { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-proto'\n\nnew Elysia().use(\n\topentelemetry({\n\t\tspanProcessors: [\n\t\t\tnew BatchSpanProcessor(\n\t\t\t\tnew OTLPTraceExporter({\n\t\t\t\t\turl: 'https://api.axiom.co/v1/traces', // [!code ++]\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t// [!code ++]\n\t\t\t\t\t\tAuthorization: `Bearer ${Bun.env.AXIOM_TOKEN}`, // [!code ++]\n\t\t\t\t\t\t'X-Axiom-Dataset': Bun.env.AXIOM_DATASET // [!code ++]\n\t\t\t\t\t} // [!code ++]\n\t\t\t\t})\n\t\t\t)\n\t\t]\n\t})\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Response Compression with MapResponse in Elysia\nDESCRIPTION: This code snippet shows how to use the new 'mapResponse' lifecycle method in Elysia 0.8 to implement response compression using gzip.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/elysia-08.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, mapResponse } from 'elysia'\nimport { gzipSync } from 'bun'\n\nnew Elysia()\n    .mapResponse(({ response }) => {\n        return new Response(\n            gzipSync(\n                typeof response === 'object'\n                    ? JSON.stringify(response)\n                    : response.toString()\n            )\n        )\n    })\n    .listen(3000)\n```\n\n----------------------------------------\n\nTITLE: Using getCurrentSpan with ElysiaJS OpenTelemetry\nDESCRIPTION: Example of getting the current OpenTelemetry span outside of a request handler to set custom attributes.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/opentelemetry.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getCurrentSpan } from '@elysiajs/opentelemetry'\n\nfunction utility() {\n\tconst span = getCurrentSpan()\n\tspan.setAttributes({\n\t\t'custom.attribute': 'value'\n\t})\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Controller Implementation\nDESCRIPTION: Demonstrates the wrong way of implementing controllers by creating separate controller classes.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/essential/structure.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia, t, type Context } from 'elysia'\n\nabstract class Controller {\n    static root(context: Context) {\n        return Service.doStuff(context.stuff)\n    }\n}\n\n// âŒ Don't\nnew Elysia()\n    .get('/', Controller.hi)\n```\n\n----------------------------------------\n\nTITLE: Initializing Prisma Project\nDESCRIPTION: Runs the Prisma init command using Bun's execution command 'bunx' to set up the initial Prisma configuration.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/with-prisma.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbunx prisma init\n```\n\n----------------------------------------\n\nTITLE: Previewing Email Templates\nDESCRIPTION: Command to start the React Email preview server, which opens a browser window showing the rendered email templates.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/integrations/react-email.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nbun email\n```\n\n----------------------------------------\n\nTITLE: Running Tests for Elysia Applications with Bun\nDESCRIPTION: Shows the command to run tests for Elysia applications using Bun's test runner.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/index.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ bun test\n```\n\n----------------------------------------\n\nTITLE: Installing Eden Dependencies\nDESCRIPTION: Command to install Eden and Elysia dependencies for client-side type-safe API consumption.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/blog/integrate-trpc-with-elysia.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nbun add @elysia/eden && bun add -d elysia\n```\n\n----------------------------------------\n\nTITLE: Installing Bearer Plugin for ElysiaJS\nDESCRIPTION: Command to install the Bearer plugin for ElysiaJS using Bun package manager.\nSOURCE: https://github.com/elysiajs/documentation/blob/main/docs/plugins/bearer.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun add @elysiajs/bearer\n```"
  }
]