[
  {
    "owner": "henauxg",
    "repo": "bevy_quinnet",
    "content": "TITLE: Adding QuinnetServerPlugin to Bevy App\nDESCRIPTION: Shows how to add the QuinnetServerPlugin to a Bevy application. This is the first step to enable server networking capabilities in a Bevy project.\nSOURCE: https://github.com/henauxg/bevy_quinnet/blob/main/README.md#2025-04-19_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nApp::new()\n        /*...*/\n        .add_plugins(QuinnetServerPlugin::default())\n        /*...*/\n        .run();\n```\n\n----------------------------------------\n\nTITLE: Adding QuinnetClientPlugin to Bevy App\nDESCRIPTION: Shows how to add the QuinnetClientPlugin to a Bevy application. This is the first step to enable client networking capabilities in a Bevy project.\nSOURCE: https://github.com/henauxg/bevy_quinnet/blob/main/README.md#2025-04-19_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nApp::new()\n        // ...\n        .add_plugins(QuinnetClientPlugin::default())\n        // ...\n        .run();\n```\n\n----------------------------------------\n\nTITLE: Starting a Server Listener\nDESCRIPTION: Demonstrates how to use the QuinnetServer resource to start a server endpoint that listens for client connections. The example binds to all available network interfaces on port 6000 and generates a self-signed certificate.\nSOURCE: https://github.com/henauxg/bevy_quinnet/blob/main/README.md#2025-04-19_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn start_listening(mut server: ResMut<QuinnetServer>) {\n    server\n        .start_endpoint(\n            ServerEndpointConfiguration::from_ip(Ipv6Addr::UNSPECIFIED, 6000),\n            CertificateRetrievalMode::GenerateSelfSigned {\n                server_hostname: Ipv6Addr::LOCALHOST.to_string(),\n            },\n            ChannelsConfiguration::default(),\n        )\n        .unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Opening a Client Connection\nDESCRIPTION: Demonstrates how to use the QuinnetClient resource to establish a connection to a server. The example uses localhost as the server address with port 6000 and skips certificate verification.\nSOURCE: https://github.com/henauxg/bevy_quinnet/blob/main/README.md#2025-04-19_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn start_connection(client: ResMut<QuinnetClient>) {\n    client\n        .open_connection(\n            ClientEndpointConfiguration::from_ips(\n                Ipv6Addr::LOCALHOST,\n                6000,\n                Ipv6Addr::UNSPECIFIED,\n                0,\n            ),\n            CertificateVerificationMode::SkipVerification,\n            ChannelsConfiguration::default(),\n        );\n    \n    // When trully connected, you will receive a ConnectionEvent\n```\n\n----------------------------------------\n\nTITLE: Handling Server Messages in a Client\nDESCRIPTION: Shows how to implement a Bevy system that processes messages from the server. It uses a generic receive_message method with a custom ServerMessage enum that must derive Serialize and Deserialize.\nSOURCE: https://github.com/henauxg/bevy_quinnet/blob/main/README.md#2025-04-19_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn handle_server_messages(\n    mut client: ResMut<QuinnetClient>,\n    /*...*/\n) {\n    while let Ok(Some((channel_id, message))) = client.connection_mut().receive_message::<ServerMessage>() {\n        match message {\n            // Match on your own message types ...\n            ServerMessage::ClientConnected { client_id, username} => {/*...*/}\n            ServerMessage::ClientDisconnected { client_id } => {/*...*/}\n            ServerMessage::ChatMessage { client_id, message } => {/*...*/}\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Client Messages in a Server\nDESCRIPTION: Shows how to implement a Bevy system that processes messages from clients and sends responses. It iterates through all connected clients and processes any pending messages using a custom ClientMessage enum.\nSOURCE: https://github.com/henauxg/bevy_quinnet/blob/main/README.md#2025-04-19_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn handle_client_messages(\n    mut server: ResMut<QuinnetServer>,\n    /*...*/\n) {\n    let mut endpoint = server.endpoint_mut();\n    for client_id in endpoint.clients() {\n        while let Some((channel_id, message)) = endpoint.try_receive_message_from::<ClientMessage>(client_id) {\n            match message {\n                // Match on your own message types ...\n                ClientMessage::Join { username} => {\n                    // Send a messsage to 1 client\n                    endpoint.send_message(client_id, ServerMessage::InitClient {/*...*/}).unwrap();\n                    /*...*/\n                }\n                ClientMessage::Disconnect { } => {\n                    // Disconnect a client\n                    endpoint.disconnect_client(client_id);\n                    /*...*/\n                }\n                ClientMessage::ChatMessage { message } => {\n                    // Send a message to a group of clients\n                    endpoint.send_group_message(\n                            client_group, // Iterator of ClientId\n                            ServerMessage::ChatMessage {/*...*/}\n                        )\n                        .unwrap();\n                    /*...*/\n                }           \n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Channel Types\nDESCRIPTION: Shows how to create a custom ChannelsConfiguration with multiple channel types. This example creates two OrderedReliable channels and one Unreliable channel, with channel IDs 0, 1, and 2 respectively.\nSOURCE: https://github.com/henauxg/bevy_quinnet/blob/main/README.md#2025-04-19_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n// Default channels configuration contains only 1 channel of the OrderedReliable type,\n// akin to a TCP connection.\nlet channels_config = ChannelsConfiguration::default();\n// Creates 2 OrderedReliable channels, and 1 unreliable channel,\n// with channel ids being respectively 0, 1 and 2.\nlet channels_config = ChannelsConfiguration::from_types(vec![\n    ChannelKind::default(),\n    ChannelKind::default(),\n    ChannelKind::Unreliable]);\n```\n\n----------------------------------------\n\nTITLE: Using Channels for Message Sending\nDESCRIPTION: Demonstrates different ways to send messages on channels, including using the default channel, specifying a channel ID, and changing the default channel for future messages.\nSOURCE: https://github.com/henauxg/bevy_quinnet/blob/main/README.md#2025-04-19_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet connection = client.connection();\n// No channel specified, default channel is used\nconnection.send_message(message);\n// Specifying the channel id\nconnection.send_message_on(channel_id, message);\n// Changing the default channel\nconnection.set_default_channel(channel_id);\n```\n\n----------------------------------------\n\nTITLE: Creating Additional Channels on Client\nDESCRIPTION: Shows how to create additional channels on a client connection after it's established. This example creates a new OrderedReliable channel specifically for chat messages.\nSOURCE: https://github.com/henauxg/bevy_quinnet/blob/main/README.md#2025-04-19_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n// If you want to create more channels\nlet chat_channel = client.connection().open_channel(ChannelKind::default()).unwrap();\nclient.connection().send_message_on(chat_channel, chat_message);\n```\n\n----------------------------------------\n\nTITLE: Creating Additional Channels on Server\nDESCRIPTION: Shows how to create additional channels on a server endpoint, which will be available for all current and future client connections. This example creates a new OrderedReliable channel for chat messages.\nSOURCE: https://github.com/henauxg/bevy_quinnet/blob/main/README.md#2025-04-19_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nlet chat_channel = server.endpoint().open_channel(ChannelKind::default()).unwrap();\nserver.endpoint().send_message_on(client_id, chat_channel, chat_message);\n```\n\n----------------------------------------\n\nTITLE: Configuring Server Certificate Management in Rust\nDESCRIPTION: Shows different server certificate configuration options including generating self-signed certificates, loading existing certificates, and hybrid approaches.\nSOURCE: https://github.com/henauxg/bevy_quinnet/blob/main/README.md#2025-04-19_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n    // To generate a new self-signed certificate on each startup \n    server.start_endpoint(/*...*/, CertificateRetrievalMode::GenerateSelfSigned { \n        server_hostname: Ipv6Addr::LOCALHOST.to_string(),\n    });\n    // To load a pre-existing one from files\n    server.start_endpoint(/*...*/, CertificateRetrievalMode::LoadFromFile {\n        cert_file: \"./certificates.pem\".into(),\n        key_file: \"./privkey.pem\".into(),\n    });\n    // To load one from files, or to generate a new self-signed one if the files do not exist.\n    server.start_endpoint(/*...*/, CertificateRetrievalMode::LoadFromFileOrGenerateSelfSigned {\n        cert_file: \"./certificates.pem\".into(),\n        key_file: \"./privkey.pem\".into(),\n        save_on_disk: true, // To persist on disk if generated\n        server_hostname: Ipv6Addr::LOCALHOST.to_string(),\n    });\n```\n\n----------------------------------------\n\nTITLE: Configuring Client Certificate Verification in Rust\nDESCRIPTION: Demonstrates different certificate verification modes for client connections including skip verification, CA verification, and trust on first use authentication.\nSOURCE: https://github.com/henauxg/bevy_quinnet/blob/main/README.md#2025-04-19_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n    // To accept any certificate\n    client.open_connection(/*...*/, CertificateVerificationMode::SkipVerification);\n    // To only accept certificates issued by a Certificate Authority\n    client.open_connection(/*...*/, CertificateVerificationMode::SignedByCertificateAuthority);\n    // To use the default configuration of the Trust on first use authentication scheme\n    client.open_connection(/*...*/, CertificateVerificationMode::TrustOnFirstUse(TrustOnFirstUseConfig {\n            // You can configure TrustOnFirstUse through the TrustOnFirstUseConfig:\n            // Provide your own fingerprint store variable/file,\n            // or configure the actions to apply for each possible certificate verification status.\n            ..Default::default()\n        }),\n    );\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Trust on First Use in Rust for Bevy Quinnet\nDESCRIPTION: Demonstrates how to use the default Trust on First Use (TOFU) configuration when opening a client connection in Bevy Quinnet. This setup uses the default known hosts file and verifier behaviors.\nSOURCE: https://github.com/henauxg/bevy_quinnet/blob/main/docs/Certificates.md#2025-04-19_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nclient.open_connection(/*...*/, CertificateVerificationMode::TrustOnFirstUse(TrustOnFirstUseConfig {\n        ..Default::default()\n    }),\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Known Hosts File in Rust for Bevy Quinnet TOFU\nDESCRIPTION: Shows how to configure Trust on First Use with a custom known hosts file while keeping default verifier behaviors in Bevy Quinnet.\nSOURCE: https://github.com/henauxg/bevy_quinnet/blob/main/docs/Certificates.md#2025-04-19_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nclient.open_connection(/*...*/, CertificateVerificationMode::TrustOnFirstUse(TrustOnFirstUseConfig {\n        known_hosts: KnownHosts::HostsFile(\"MyCustomFile\".to_string()),\n        ..Default::default()\n    }),\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Verifier Behaviors in Rust for Bevy Quinnet TOFU\nDESCRIPTION: Demonstrates how to set up custom verifier behaviors and a custom certificate store for Trust on First Use in Bevy Quinnet. This configuration defines specific actions for different certificate verification statuses.\nSOURCE: https://github.com/henauxg/bevy_quinnet/blob/main/docs/Certificates.md#2025-04-19_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nclient.open_connection(/*...*/, CertificateVerificationMode::TrustOnFirstUse(TrustOnFirstUseConfig {\n        known_hosts: KnownHosts::Store(my_cert_store),\n        verifier_behaviour: HashMap::from([\n                (\n                    CertVerificationStatus::UnknownCertificate,\n                    CertVerifierBehaviour::ImmediateAction(CertVerifierAction::TrustAndStore),\n                ),\n                (\n                    CertVerificationStatus::UntrustedCertificate,\n                    CertVerifierBehaviour::ImmediateAction(CertVerifierAction::AbortConnection),\n                ),\n                (\n                    CertVerificationStatus::TrustedCertificate,\n                    CertVerifierBehaviour::ImmediateAction(CertVerifierAction::TrustOnce),\n                ),\n            ]),\n    }),\n);\n```\n\n----------------------------------------\n\nTITLE: Handling Certificate Verification Events in Rust for Bevy Quinnet\nDESCRIPTION: Illustrates how to create a custom handler for CertInteractionEvent in Bevy Quinnet. This function decides whether to abort the connection or trust the certificate based on its verification status.\nSOURCE: https://github.com/henauxg/bevy_quinnet/blob/main/docs/Certificates.md#2025-04-19_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn handle_cert_events(mut cert_action_events: EventReader<CertInteractionEvent>) {\n    // We may receive a CertInteractionEvent during the connection\n    for cert_event in cert_action_events.iter() {\n        match cert_event.status {\n            // We want to abort the connection if the certificate is untrusted, else we continue\n            CertVerificationStatus::UntrustedCertificate => cert_event\n                .apply_cert_verifier_action(CertVerifierAction::AbortConnection)\n                .unwrap(),\n            _ => cert_event\n                .apply_cert_verifier_action(CertVerifierAction::TrustOnce)\n                .unwrap(),\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Known Hosts File Format in Bevy Quinnet\nDESCRIPTION: Shows the format of the known hosts file used in Bevy Quinnet for storing server fingerprints. Each line contains a server name (DNS or IP) followed by its fingerprint in base64 encoding.\nSOURCE: https://github.com/henauxg/bevy_quinnet/blob/main/docs/Certificates.md#2025-04-19_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\n::1 o1cpTe602uTq4pVwT+km8QtEPQE/xCAgk+3AicW/i9g=\n1234::1234 kzXIwhvMSbWCQOimT3btnFlmc/Lq0UN0JhSeQadaGbg=\n```"
  }
]