[
  {
    "owner": "supermacro",
    "repo": "neverthrow",
    "content": "TITLE: Using Result.asyncAndThrough for Chaining Async Operations\nDESCRIPTION: Demonstrates chaining multiple async operations using asyncAndThrough and andThen methods. Shows how to handle user input parsing, database insertion, and notification sending in a type-safe way.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { parseUserInput } from 'imaginary-parser'\nimport { insertUser } from 'imaginary-database'\nimport { sendNotification } from 'imaginary-service'\n\nconst resAsync = parseUserInput(userInput)\n               .asyncAndThrough(insertUser)\n               .andThen(sendNotification)\n\nresAsync.then((res: Result<void, ParseError | InsertError | NotificationError>) => {\n  if(res.isErr()){\n    console.log(\"Oops, at least one step failed\", res.error)\n  }\n  else{\n    console.log(\"User has been parsed, inserted and notified successfully.\")\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Using Result.combine for List Operations\nDESCRIPTION: Shows how to combine multiple Results into a single Result containing a list or tuple of values. Includes examples for both homogeneous and heterogeneous Result lists.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst resultList: Result<number, never>[] =\n  [ok(1), ok(2)]\n\nconst combinedList: Result<number[], unknown> =\n  Result.combine(resultList)\n\nconst tuple = <T extends any[]>(...args: T): T => args\n\nconst resultTuple: [Result<string, never>, Result<string, never>] =\n  tuple(ok('a'), ok('b'))\n\nconst combinedTuple: Result<[string, string], unknown> =\n  Result.combine(resultTuple)\n```\n\n----------------------------------------\n\nTITLE: Chaining Operations with ResultAsync.andThen\nDESCRIPTION: Method for chaining operations that may fail, flattening nested ResultAsync instances. Supports returning both Result and ResultAsync from the callback.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nclass ResultAsync<T, E> {\n  andThen<U, F>(\n    callback: (value: T) => Result<U, F> | ResultAsync<U, F>\n  ): ResultAsync<U, E | F> { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining Results with andThen Method\nDESCRIPTION: Examples showing how to chain Result operations using andThen, including success and error cases.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { err, ok } from 'neverthrow'\n\nconst sq = (n: number): Result<number, number> => ok(n ** 2)\n\nok(2)\n  .andThen(sq)\n  .andThen(sq) // Ok(16)\n\nok(2)\n  .andThen(sq)\n  .andThen(err) // Err(4)\n\nok(2)\n  .andThen(err)\n  .andThen(sq) // Err(2)\n\nerr(3)\n  .andThen(sq)\n  .andThen(sq) // Err(3)\n```\n\n----------------------------------------\n\nTITLE: Using Result.fromThrowable for Safe Error Handling\nDESCRIPTION: Shows how to wrap potentially throwing functions to return Result types instead. Useful for handling JSON parsing and other operations that may throw exceptions.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Result } from 'neverthrow'\n\ntype ParseError = { message: string }\nconst toParseError = (): ParseError => ({ message: \"Parse Error\" })\n\nconst safeJsonParse = Result.fromThrowable(JSON.parse, toParseError)\n\nconst res = safeJsonParse(\"{\")\n```\n\n----------------------------------------\n\nTITLE: Using ResultAsync.fromThrowable and fromPromise\nDESCRIPTION: Demonstrates how to safely wrap async functions that may throw errors or return promises into ResultAsync types.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ResultAsync } from 'neverthrow'\nimport { insertIntoDb } from 'imaginary-database'\n\nconst insertUser = ResultAsync.fromThrowable(insertIntoDb, () => new Error('Database error'))\n\nconst res = ResultAsync.fromPromise(insertIntoDb(myUser), () => new Error('Database error'))\n```\n\n----------------------------------------\n\nTITLE: Using safeTry for Simplified Result Handling\nDESCRIPTION: Shows how to use the safeTry utility with generator functions to handle Result types more concisely, reducing boilerplate code while maintaining error handling capabilities.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare function mayFail1(): Result<number, string>;\ndeclare function mayFail2(): Result<number, string>;\n\nfunction myFunc(): Result<number, string> {\n    return safeTry<number, string>(function*() {\n        return ok(\n            (yield* mayFail1()\n                .mapErr(e => `aborted by an error from 1st function, ${e}`))\n            +\n            (yield* mayFail2()\n                .mapErr(e => `aborted by an error from 2nd function, ${e}`))\n        )\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Using Result.combineWithAllErrors for Comprehensive Error Collection\nDESCRIPTION: Demonstrates how to combine multiple Results while collecting all errors instead of short-circuiting on the first error encountered.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst resultList: Result<number, string>[] = [\n  ok(123),\n  err('boooom!'),\n  ok(456),\n  err('ahhhhh!')\n]\n\nconst result = Result.combineWithAllErrors(resultList)\n\n// result is Err(['boooom!', 'ahhhhh!'])\n```\n\n----------------------------------------\n\nTITLE: Implementing ResultAsync.combineWithAllErrors Static Method in TypeScript\nDESCRIPTION: The combineWithAllErrors method aggregates multiple ResultAsync instances without short-circuiting on the first error. It collects all errors from failed operations into an array.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\n// homogeneous lists\nfunction combineWithAllErrors<T, E>(resultList: ResultAsync<T, E>[]): ResultAsync<T[], E[]>\n\n// heterogeneous lists\nfunction combineWithAllErrors<T1, T2, E1, E2>(resultList: [ ResultAsync<T1, E1>, ResultAsync<T2, E2> ]): ResultAsync<[ T1, T2 ], (E1 | E2)[]>\nfunction combineWithAllErrors<T1, T2, T3, E1, E2, E3> => ResultAsync<[ T1, T2, T3 ], (E1 | E2 | E3)[]>\nfunction combineWithAllErrors<T1, T2, T3, T4, E1, E2, E3, E4> => ResultAsync<[ T1, T2, T3, T4 ], (E1 | E2 | E3 | E4)[]>\n// ... etc etc ad infinitum\n```\n\n----------------------------------------\n\nTITLE: Implementing ResultAsync.combine Static Method in TypeScript\nDESCRIPTION: The combine method aggregates multiple ResultAsync instances into a single ResultAsync. It works similarly to Promise.all, supporting both homogeneous and heterogeneous lists of ResultAsync instances.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\n// homogeneous lists\nfunction combine<T, E>(resultList: ResultAsync<T, E>[]): ResultAsync<T[], E>\n\n// heterogeneous lists\nfunction combine<T1, T2, E1, E2>(resultList: [ ResultAsync<T1, E1>, ResultAsync<T2, E2> ]): ResultAsync<[ T1, T2 ], E1 | E2>\nfunction combine<T1, T2, T3, E1, E2, E3> => ResultAsync<[ T1, T2, T3 ], E1 | E2 | E3>\nfunction combine<T1, T2, T3, T4, E1, E2, E3, E4> => ResultAsync<[ T1, T2, T3, T4 ], E1 | E2 | E3 | E4>\n// ... etc etc ad infinitum\n```\n\n----------------------------------------\n\nTITLE: Using ResultAsync.andThrough Method for User Registration Flow\nDESCRIPTION: Example of using andThrough in a user registration flow. This method allows passing the original value through while still capturing potential errors from the intermediate operation.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildUser } from 'imaginary-builder'\nimport { insertUser } from 'imaginary-database'\nimport { sendNotification } from 'imaginary-service'\n\n// ^ assume buildUser, insertUser and sendNotification have the following signatures:\n// buildUser(userRaw: UserRaw): ResultAsync<User, BuildError>\n// insertUser(user: User): ResultAsync<void, InsertError>\n// sendNotification(user: User): ResultAsync<void, NotificationError>\n// Note insertUser returns void upon success but sendNotification takes User type. \n\nconst resAsync = buildUser(userRaw)\n                .andThrough(insertUser)\n                .andThen(sendNotification)\n\nresAsync.then((res: Result<void, BuildError | InsertError | NotificationError>) => {\n  if(res.isErr()){\n    console.log(\"Oops, at least one step failed\", res.error)\n  }\n  else{\n    console.log(\"User data has been built, inserted and notified successfully.\")\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Error Recovery with orElse Method\nDESCRIPTION: Example showing how to use orElse for database error recovery scenarios.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nenum DatabaseError {\n  PoolExhausted = 'PoolExhausted',\n  NotFound = 'NotFound',\n}\n\nconst dbQueryResult: Result<string, DatabaseError> = err(DatabaseError.NotFound)\n\nconst updatedQueryResult = dbQueryResult.orElse((dbError) =>\n  dbError === DatabaseError.NotFound\n    ? ok('User does not exist')\n    : err(500) \n)\n```\n\n----------------------------------------\n\nTITLE: Error Recovery with ResultAsync.orElse\nDESCRIPTION: Method for handling errors by potentially recovering with a new ResultAsync. Allows error transformation and recovery.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nclass ResultAsync<T, E> {\n  orElse<U, A>(\n    callback: (error: E) => Result<U, A> | ResultAsync<U, A>\n  ): ResultAsync<U | T, A> { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Async safeTry Implementation\nDESCRIPTION: Demonstrates using safeTry with async generator functions to handle asynchronous Results, supporting both Promise<Result> and ResultAsync types.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare function mayFail1(): Promise<Result<number, string>>;\ndeclare function mayFail2(): ResultAsync<number, string>;\n\nfunction myFunc(): Promise<Result<number, string>> {\n    return safeTry<number, string>(async function*() {\n        return ok(\n            (yield* (await mayFail1())\n                .mapErr(e => `aborted by an error from 1st function, ${e}`))\n            +\n            (yield* mayFail2()\n                .mapErr(e => `aborted by an error from 2nd function, ${e}`))\n        )\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with ResultAsync.match\nDESCRIPTION: Method for handling both success and error cases with separate callbacks. Returns a Promise of the callback result.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nclass ResultAsync<T, E> {\n  match<A, B = A>(\n    okCallback: (value: T) =>  A,\n    errorCallback: (error: E) =>  B\n  ): Promise<A | B> => { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming ResultAsync Values with map Method\nDESCRIPTION: Method that transforms the success value of a ResultAsync while preserving the error type. Can handle both synchronous and asynchronous transformations.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nclass ResultAsync<T, E> {\n  map<U>(\n    callback: (value: T) => U | Promise<U>\n  ): ResultAsync<U, E> { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Error Mapping with ResultAsync.mapErr\nDESCRIPTION: Method for transforming the error value of a ResultAsync while leaving success values unchanged. Supports both synchronous and asynchronous error transformations.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nclass ResultAsync<T, E> {\n  mapErr<F>(\n    callback: (error: E) => F | Promise<F>\n  ): ResultAsync<T, F> { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ResultAsync.combine with Homogeneous Lists\nDESCRIPTION: Example of using combine with a list of ResultAsync instances of the same type. The method returns a new ResultAsync with an array of values if all operations succeed.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nconst resultList: ResultAsync<number, never>[] =\n  [okAsync(1), okAsync(2)]\n\nconst combinedList: ResultAsync<number[], unknown> =\n  ResultAsync.combine(resultList)\n```\n\n----------------------------------------\n\nTITLE: Using ResultAsync.combine with Tuples\nDESCRIPTION: Example of using combine with heterogeneous tuples of ResultAsync instances. The method preserves the tuple structure in the successful result.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\n/** @example tuple(1, 2, 3) === [1, 2, 3] // with type [number, number, number] */\nconst tuple = <T extends any[]>(...args: T): T => args\n\nconst resultTuple: [ResultAsync<string, never>, ResultAsync<string, never>] =\n  tuple(okAsync('a'), okAsync('b'))\n\nconst combinedTuple: ResultAsync<[string, string], unknown> =\n  ResultAsync.combine(resultTuple)\n```\n\n----------------------------------------\n\nTITLE: Using ResultAsync.combineWithAllErrors with Mixed Results\nDESCRIPTION: Example of using combineWithAllErrors with a list containing both successful and failed ResultAsync instances. The method collects all errors into an array.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nconst resultList: ResultAsync<number, string>[] = [\n  okAsync(123),\n  errAsync('boooom!'),\n  okAsync(456),\n  errAsync('ahhhhh!'),\n]\n\nconst result = ResultAsync.combineWithAllErrors(resultList)\n\n// result is Err(['boooom!', 'ahhhhh!'])\n```\n\n----------------------------------------\n\nTITLE: Implementing ResultAsync.orTee Method in TypeScript\nDESCRIPTION: The orTee method for ResultAsync allows error value pass-through while executing a side effect. It's useful for operations like logging errors without affecting the main logic flow.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nclass ResultAsync<T, E> {\n  orTee(\n    callback: (value: E) => unknown\n  ): ResultAsync<T, E>  => { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ResultAsync.orTee Method with Database Operations\nDESCRIPTION: Example of using orTee to log errors during a user insertion process without affecting the main error flow. The method allows side effects to occur on the error track without changing the error type.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nimport { insertUser } from 'imaginary-database'\nimport { logInsertError } from 'imaginary-logger'\nimport { sendNotification } from 'imaginary-service'\n\n// ^ assume insertUser, logInsertError and sendNotification have the following signatures:\n// insertUser(user: User): ResultAsync<User, InsertError>\n// logInsertError(insertError: InsertError): Result<void, LogError>\n// sendNotification(user: User): ResultAsync<void, NotificationError>\n// Note logInsertError returns void on success but sendNotification takes User type. \n\nconst resAsync = insertUser(user)\n                .orTee(logUser)\n                .andThen(sendNotification)\n\n// Note there is no LogError in the types below \nresAsync.then((res: Result<void, InsertError | NotificationError>) => {\n  if(res.isErr()){\n    console.log(\"Oops, at least one step failed\", res.error)\n  }\n  else{\n    console.log(\"User has been inserted and notified successfully.\")\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Side Effect Handling with ResultAsync.andTee\nDESCRIPTION: Method for executing side effects while passing through the original ResultAsync. Useful for operations like logging that shouldn't affect the main flow.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nclass ResultAsync<T, E> {\n  andTee(\n    callback: (value: T) => unknown\n  ): ResultAsync<T, E>  => { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ResultAsync.andThrough Method in TypeScript\nDESCRIPTION: The andThrough method is similar to andTee but passes along errors from the callback function. This allows for side effects with error handling in the success track.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nclass ResultAsync<T, E> {\n  andThrough<F>(\n    callback: (value: T) => Result<unknown, F> | ResultAsync<unknown, F>,\n  ): ResultAsync<T, E | F> => { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Flattening Nested Results with andThen\nDESCRIPTION: Example demonstrating how to flatten nested Results using andThen method.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst nested = ok(ok(1234))\n\nconst notNested = nested.andThen((innerResult) => innerResult)\n```\n\n----------------------------------------\n\nTITLE: Implementing Result.andThen Method in TypeScript\nDESCRIPTION: Method signature for Result.andThen that allows chaining Result operations with distinct error types. Used for subsequent computations that might fail.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nclass Result<T, E> {\n  andThen<U, F>(\n    callback: (value: T) => Result<U, F>\n  ): Result<U, E | F> { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Result.asyncAndThen Method Implementation\nDESCRIPTION: Method signature for Result.asyncAndThen that handles asynchronous Result operations.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nclass Result<T, E> {\n  asyncAndThen<U, F>(\n    callback: (value: T) => ResultAsync<U, F>\n  ): ResultAsync<U, E | F> { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Result.orElse Method Implementation\nDESCRIPTION: Method signature and example for Result.orElse that handles error recovery by mapping error values.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nclass Result<T, E> {\n  orElse<U, A>(\n    callback: (error: E) => Result<U, A>\n  ): Result<U | T, A> { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Result.map Method\nDESCRIPTION: Example of using the map method to transform the value inside an Ok Result.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getLines } from 'imaginary-parser'\n// ^ assume getLines has the following signature:\n// getLines(str: string): Result<Array<string>, Error>\n\n// since the formatting is deemed correct by `getLines`\n// then it means that `linesResult` is an Ok\n// containing an Array of strings for each line of code\nconst linesResult = getLines('1\\n2\\n3\\n4\\n')\n\n// this Result now has a Array<number> inside it\nconst newResult = linesResult.map(\n  (arr: Array<string>) => arr.map(parseInt)\n)\n\nnewResult.isOk() // true\n```\n\n----------------------------------------\n\nTITLE: Using Result.mapErr Method\nDESCRIPTION: Example of using the mapErr method to handle errors in a Result.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { parseHeaders } from 'imaginary-http-parser'\n// imagine that parseHeaders has the following signature:\n// parseHeaders(raw: string): Result<SomeKeyValueMap, ParseError>\n\nconst rawHeaders = 'nonsensical gibberish and badly formatted stuff'\n\nconst parseResult = parseHeaders(rawHeaders)\n\nparseResult.mapErr(parseError => {\n  res.status(400).json({\n    error: parseError\n  })\n})\n\nparseResult.isErr() // true\n```\n\n----------------------------------------\n\nTITLE: Using Result.unwrapOr Method\nDESCRIPTION: Example of using the unwrapOr method to provide a default value when unwrapping a Result.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst myResult = err('Oh noooo')\n\nconst multiply = (value: number): number => value * 2\n\nconst unwrapped: number = myResult.map(multiply).unwrapOr(10)\n```\n\n----------------------------------------\n\nTITLE: Default Value Handling with ResultAsync.unwrapOr\nDESCRIPTION: Method that returns the success value or a default value if the ResultAsync contains an error. Returns a Promise of the value type.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nclass ResultAsync<T, E> {\n  unwrapOr<T>(value: T): Promise<T> { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Result Types\nDESCRIPTION: Shows different approaches to testing Result types, including unsafe unwrapping methods and direct comparison testing.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nexpect(myResult._unsafeUnwrap()).toBe(someExpectation)\n```\n\n----------------------------------------\n\nTITLE: Testing Results with Direct Comparison\nDESCRIPTION: Demonstrates testing Result types by comparing them directly without unwrapping, using the ok constructor from neverthrow.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ok } from 'neverthrow'\n\nexpect(callSomeFunctionThatReturnsAResult(\"with\", \"some\", \"args\")).toEqual(ok(someExpectation));\n```\n\n----------------------------------------\n\nTITLE: Configuring Unsafe Unwrap with Stack Traces\nDESCRIPTION: Shows how to configure the unsafe unwrap methods to include stack traces in the error objects for debugging purposes.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\n_unsafeUnwrapErr({\n  withStackTrace: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Using ResultAsync Constructor Functions\nDESCRIPTION: Shows how to create ResultAsync instances using okAsync and errAsync constructor functions for handling asynchronous operations.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { okAsync, errAsync } from 'neverthrow'\n\nconst myResultAsync = okAsync({ myData: 'test' })\nconst myResult = await myResultAsync\n\nconst myErrorAsync = errAsync('Oh nooo')\nconst myError = await myErrorAsync\n```\n\n----------------------------------------\n\nTITLE: Implementing Safe Promise Handling with ResultAsync.fromSafePromise\nDESCRIPTION: Static method that converts a Promise to a ResultAsync without handling rejections. Used for promises that are known to be safe from rejections.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nResultAsync.fromSafePromise<T, E>(\n  promise: PromiseLike<T>\n): ResultAsync<T, E> { ... }\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport const slowDown = <T>(ms: number) => (value: T) =>\n  ResultAsync.fromSafePromise<T, RouteError>(\n    new Promise((resolve) => {\n      setTimeout(() => {\n        resolve(value)\n      }, ms)\n    })\n  )\n```\n\n----------------------------------------\n\nTITLE: Traditional Result Handling in TypeScript\nDESCRIPTION: Demonstrates the traditional way of handling Result types with explicit error checking and value unwrapping, showing the verbose approach that safeTry aims to improve.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare function mayFail1(): Result<number, string>;\ndeclare function mayFail2(): Result<number, string>;\n\nfunction myFunc(): Result<number, string> {\n    const result1 = mayFail1();\n    if (result1.isErr()) {\n        return err(`aborted by an error from 1st function, ${result1.error}`);\n    }\n    const value1 = result1.value\n\n    const result2 = mayFail2();\n    if (result2.isErr()) {\n        return err(`aborted by an error from 2nd function, ${result2.error}`);\n    }\n    const value2 = result2.value\n\n    return ok(value1 + value2);\n}\n```\n\n----------------------------------------\n\nTITLE: Importing NeverThrow Components\nDESCRIPTION: Example of importing various components and functions from the NeverThrow package.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  ok,\n  Ok,\n  err,\n  Err,\n  Result,\n  okAsync,\n  errAsync,\n  ResultAsync,\n  fromAsyncThrowable,\n  fromThrowable,\n  fromPromise,\n  fromSafePromise,\n  safeTry,\n} from 'neverthrow'\n```\n\n----------------------------------------\n\nTITLE: Creating Ok Result with 'ok' Function\nDESCRIPTION: Example of using the 'ok' function to create an Ok variant of Result.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ok } from 'neverthrow'\n\nconst myResult = ok({ myData: 'test' }) // instance of `Ok`\n\nmyResult.isOk() // true\nmyResult.isErr() // false\n```\n\n----------------------------------------\n\nTITLE: Creating Err Result with 'err' Function\nDESCRIPTION: Example of using the 'err' function to create an Err variant of Result.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { err } from 'neverthrow'\n\nconst myResult = err('Oh noooo') // instance of `Err`\n\nmyResult.isOk() // false\nmyResult.isErr() // true\n```\n\n----------------------------------------\n\nTITLE: TypeScript Code Update for orElse Method\nDESCRIPTION: Example showing the breaking change for the orElse type argument list in version 8.0.0, where the ok type must now be provided before the err type.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/CHANGELOG.md#2025-04-07_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n- result.orElse<ErrType>(foo)\n+ result.orElse<OkType, ErrType>(foo)\n```\n\n----------------------------------------\n\nTITLE: Installing NeverThrow Package\nDESCRIPTION: Command to install the NeverThrow package using npm.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n> npm install neverthrow\n```\n\n----------------------------------------\n\nTITLE: Installing eslint-plugin-neverthrow\nDESCRIPTION: Command to install the eslint-plugin-neverthrow package for enforcing proper error handling.\nSOURCE: https://github.com/supermacro/neverthrow/blob/master/README.md#2025-04-07_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n> npm install eslint-plugin-neverthrow\n```"
  }
]