[
  {
    "owner": "99designs",
    "repo": "gqlgen",
    "content": "TITLE: Initializing gqlgen Project Skeleton - Shell\nDESCRIPTION: Initializes the recommended gqlgen project structure using the gqlgen CLI. This command generates configuration files, schema, model stubs, and entry point code, setting up the environment for further development. Requires 'gqlgen' to be installed as a dependency.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/getting-started.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ngo run github.com/99designs/gqlgen init\n```\n\n----------------------------------------\n\nTITLE: GraphQL Schema: Single File Upload\nDESCRIPTION: Defines the GraphQL schema for a single file upload using the `Upload` scalar. The schema includes a `Mutation` with a `singleUpload` field that accepts an `Upload` type.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/file-upload.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\n\"The `UploadFile, // b.txt` scalar type represents a multipart file upload.\"\nscalar Upload\n\n\"The `Query` type, represents all of the entry points into our object graph.\"\ntype Query {\n    ...\n}\n\n\"The `Mutation` type, represents all updates we can make to our data.\"\ntype Mutation {\n    singleUpload(file: Upload!): Boolean!\n}\n```\n\n----------------------------------------\n\nTITLE: Resolver Implementations for Creating and Querying Todos - Go\nDESCRIPTION: Implements the 'CreateTodo' mutation and 'Todos' query resolvers. 'CreateTodo' creates a todo with a random ID, stores it in an in-memory slice, and returns it. 'Todos' returns all stored todos. Uses 'crypto/rand' and 'fmt'; requires imports and the Resolver struct defined in the application context.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/getting-started.md#_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nfunc (r *mutationResolver) CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error) {\n\trandNumber, _ := rand.Int(rand.Reader, big.NewInt(100))\n\ttodo := &model.Todo{\n\t\tText: input.Text,\n\t\tID:   fmt.Sprintf(\"T%d\", randNumber),\n\t\tUser: &model.User{ID: input.UserID, Name: \"user \" + input.UserID},\n\t}\n\tr.todos = append(r.todos, todo)\n\treturn todo, nil\n}\n\nfunc (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {\n\treturn r.todos, nil\n}\n```\n\n----------------------------------------\n\nTITLE: GraphQL Mutation for Multiple File Upload with Payload\nDESCRIPTION: Defines a GraphQL mutation `multipleUploadWithPayload` that accepts a list of `UploadFile!` input objects. This allows uploading multiple files, each associated with its own set of data (like an ID), within a single mutation. It returns details for each processed item in the list.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/fileupload/readme.md#_snippet_10\n\nLANGUAGE: GraphQL\nCODE:\n```\n{\n  query: `\n    mutation($req: [UploadFile!]!)\n      multipleUploadWithPayload(req: $req) {\n        id,\n        name,\n        content\n      }\n    }\n  `,\n  variables: {\n    req: [\n        {\n            id: 1,\n            File, // b.txt\n        },\n        {\n            id: 2,\n            File, // c.txt\n        }\n    ] \n  }\n}\n```\n\n----------------------------------------\n\nTITLE: cURL Request for Multiple File Upload\nDESCRIPTION: Shows how to upload multiple files (`b.txt`, `c.txt`) using a single cURL command. Each file is added with a separate `-F` flag, and the `map` parameter correlates each file part (`0`, `1`) to its corresponding position in the `variables.files` array.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/fileupload/readme.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\ncurl localhost:8087/query \\\n  -F operations='{ \"query\": \"mutation($files: [Upload!]!) { multipleUpload(files: $files) { id, name, content } }\", \"variables\": { \"files\": [null, null] } }' \\\n  -F map='{ \"0\": [\"variables.files.0\"], \"1\": [\"variables.files.1\"] }' \\\n  -F 0=@./_examples/fileupload/testfiles/b.txt \\\n  -F 1=@./_examples/fileupload/testfiles/c.txt\n```\n\n----------------------------------------\n\nTITLE: cURL Command: Multiple File Upload\nDESCRIPTION: Demonstrates a cURL command for multiple file uploads to a GraphQL endpoint. It utilizes multipart form data with `operations`, `map`, and file data for each file.  Two files b.txt and c.txt are uploaded with ids 1 and 2 respectively.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/file-upload.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncurl localhost:4000/query \\\n  -F operations='{ \"query\": \"mutation($req: [UploadFile!]!) { multipleUpload(req: $req) { id, name, content } }\", \"variables\": { \"req\": [ { \"id\": 1, \"file\": null }, { \"id\": 2, \"file\": null } ] } }' \\\n  -F map='{ \"0\": [\"variables.req.0.file\"], \"1\": [\"variables.req.1.file\"] }' \\\n  -F 0=@b.txt \\\n  -F 1=@c.txt\n```\n\n----------------------------------------\n\nTITLE: Generated Resolver Function Stubs - Go\nDESCRIPTION: Stub resolver functions for the 'createTodo' mutation and 'todos' query, auto-generated by gqlgen when schema fields cannot be matched to models. These serve as implementation placeholders that the developer must complete. Inputs are context and query/mutation parameters; outputs should conform to the schema.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/getting-started.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc (r *mutationResolver) CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error) {\n\tpanic(fmt.Errorf(\"not implemented\"))\n}\n\nfunc (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {\n\tpanic(fmt.Errorf(\"not implemented\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving User Data from Context in GraphQL Resolvers\nDESCRIPTION: Illustrates how to access the authenticated user information within GraphQL resolver functions using the context. The function calls the `ForContext` utility to extract user data; if absent or unauthorized, it returns an error. This pattern enables authorization checks based on user roles or privileges inside resolvers.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/authentication.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nfunc (r *queryResolver) Hero(ctx context.Context, episode Episode) (Character, error) {\n\tif user := auth.ForContext(ctx) ; user == nil || !user.IsAdmin {\n\t\treturn Character{}, fmt.Errorf(\"Access denied\")\n\t}\n\n\tif episode == EpisodeEmpire {\n\t\treturn r.humans[\"1000\"], nil\n\t}\n\treturn r.droid[\"2001\"], nil\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Go Module and Running gqlgen Setup - Shell\nDESCRIPTION: These shell commands create a new Go module, track gqlgen as a tool dependency, update dependencies, initialize the gqlgen configuration, and start a GraphQL server. Prerequisites: Go 1.18+ installed. Inputs: project directory, module name. Output: directory structure with gqlgen setup and a running server.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/_introduction.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nmkdir example\ncd example\ngo mod init example\n```\n\nLANGUAGE: shell\nCODE:\n```\nprintf '//go:build tools\\npackage tools\\nimport (_ \"github.com/99designs/gqlgen\"\\n _ \"github.com/99designs/gqlgen/graphql/introspection\")' | gofmt > tools.go\ngo mod tidy\n```\n\nLANGUAGE: shell\nCODE:\n```\ngo run github.com/99designs/gqlgen init\ngo mod tidy\n```\n\nLANGUAGE: shell\nCODE:\n```\ngo run server.go\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication Middleware using net/http in Go\nDESCRIPTION: Defines middleware that authenticates users through a cookie, retrieves user data from the database, and stores it in the request context. The middleware ensures that subsequent handlers, such as GraphQL resolvers, can access user information seamlessly. Key functions include cookie validation, user retrieval, and context injection.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/authentication.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage auth\n\nimport (\n\t\"database/sql\"\n\t\"net/http\"\n\t\"context\"\n)\n\n// A private key for context that only this package can access. This is important\n// to prevent collisions between different context uses\nvar userCtxKey = &contextKey{\"user\"}\ntype contextKey struct {\n\n\tname string\n}\n\n// A stand-in for our database backed user object\n type User struct {\n\tName string\n\tIsAdmin bool\n}\n\n// Middleware decodes the share session cookie and packs the session into context\nfunc Middleware(db *sql.DB) func(http.Handler) http.Handler {\n\treturn func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tc, err := r.Cookie(\"auth-cookie\")\n\n\t\t\t// Allow unauthenticated users in\n\t\t\tif err != nil || c == nil {\n\t\t\t\tnext.ServeHTTP(w, r)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tuserId, err := validateAndGetUserID(c)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Invalid cookie\", http.StatusForbidden)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// get the user from the database\n\t\t\tuser := getUserByID(db, userId)\n\n\t\t\t// put it in context\n\t\t\tctx := context.WithValue(r.Context(), userCtxKey, user)\n\n\t\t\t// and call the next with our new context\n\t\t\tr = r.WithContext(ctx)\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t}\n}\n\n// ForContext finds the user from the context. REQUIRES Middleware to have run.\nfunc ForContext(ctx context.Context) *User {\n\traw, _ := ctx.Value(userCtxKey).(*User)\n\treturn raw\n}\n\n```\n\n----------------------------------------\n\nTITLE: Tidying Go Module and Adding Specific gqlgen Version - Shell\nDESCRIPTION: Runs commands to ensure dependencies are fetched and the go.mod is up-to-date. If a specific gqlgen version is desired, replaces 'VERSION' with the required one. Use 'go mod tidy' to remove unused dependencies, and 'go get' to fetch a particular version if necessary.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/getting-started.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ngo mod tidy\n```\n\nLANGUAGE: shell\nCODE:\n```\ngo get -d github.com/99designs/gqlgen@VERSION\n```\n\n----------------------------------------\n\nTITLE: Declaring Application State in Resolver - Go\nDESCRIPTION: Defines a Resolver struct to hold in-memory application state for todos. The struct is referenced in resolver methods and represents a basic dependency injection point. No methods are defined here; additional dependencies can be added as needed.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/getting-started.md#_snippet_6\n\nLANGUAGE: go\nCODE:\n```\ntype Resolver struct{\n\ttodos []*model.Todo\n}\n```\n\n----------------------------------------\n\nTITLE: GraphQL Mutation and Query Examples - GraphQL\nDESCRIPTION: Demonstrates usage of the API with a mutation to create a new todo and a query to fetch all todos. These examples are meant to be run against the GraphQL server endpoint (e.g., via GraphQL Playground or cURL). Inputs match the schema requirements; outputs reflect the fields queried or mutated.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/getting-started.md#_snippet_9\n\nLANGUAGE: graphql\nCODE:\n```\nmutation createTodo {\n  createTodo(input: { text: \"todo\", userId: \"1\" }) {\n    user {\n      id\n    }\n    text\n    done\n  }\n}\n```\n\nLANGUAGE: graphql\nCODE:\n```\nquery findTodos {\n  todos {\n    text\n    done\n    user {\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Recursively Regenerating Code - Shell\nDESCRIPTION: Runs Go's code generation command across all packages, triggering any '//go:generate' directives found in Go source files. Use this to keep generated code synchronized with schema and model changes.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/getting-started.md#_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\ngo generate ./...\n```\n\n----------------------------------------\n\nTITLE: WebSocket Initialization for Authentication in GraphQL Subscriptions using Go\nDESCRIPTION: Provides a sample InitFunc for WebSocket transports in GraphQL that extracts an auth token from the init payload for connection authentication. It demonstrates how to verify, process, and store the token in context for subsequent use, supporting token validation for subscription-based workflows.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/authentication.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/99designs/gqlgen/graphql/handler\"\n\t\"github.com/99designs/gqlgen/graphql/handler/extension\"\n\t\"github.com/99designs/gqlgen/graphql/handler/transport\"\n\t\"github.com/99designs/gqlgen/graphql/playground\"\n\t\"github.com/go-chi/chi\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/gqlgen/_examples/websocket-initfunc/server/graph\"\n\t\"github.com/gqlgen/_examples/websocket-initfunc/server/graph/generated\"\n\t\"github.com/rs/cors\"\n)\n\nfunc webSocketInit(ctx context.Context, initPayload transport.InitPayload) (context.Context, error) {\n\t// Get the token from payload\n\ty := initPayload[\"authToken\"]\n\t\t\n\t\ntoken, ok := y.(string)\n\tif !ok || token == \"\" {\n\t\treturn nil, errors.New(\"authToken not found in transport payload\")\n\t}\n\n\t// Perform token verification and authentication...\n\t// For example, retrieve userId from token\n\tuserId := \"john.doe\" // replace with real token validation logic\n\n\t// put it in context\n\tctxNew := context.WithValue(ctx, \"username\", userId)\n\n\treturn ctxNew, nil\n}\n\nconst defaultPort = \"8080\"\n\nfunc main() {\n\tport := os.Getenv(\"PORT\")\n\tif port == \"\" {\n\t\tport = defaultPort\n\t}\n\n\trouter := chi.NewRouter()\n\n\t// Set up CORS\n\tc := cors.New(cors.Options{\n\t\tAllowedOrigins:   []string{\"*\"},\n\t\tAllowCredentials: true,\n\t\tDebug:            false,\n\t})\n\n\tsrv := handler.New(generated.NewExecutableSchema(generated.Config{Resolvers: &graph.Resolver{}}))\n\n\t// Add WebSocket transport with InitFunc\n\tsrv.AddTransport(transport.Websocket{\n\t\tKeepAlivePingInterval: 10 * time.Second,\n\t\tUpgrader: websocket.Upgrader{\n\t\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\t\treturn true\n\t\t\t},\n\t\t},\n\t\tInitFunc: func(ctx context.Context, initPayload transport.InitPayload) (context.Context, error) {\n\t\t\treturn webSocketInit(ctx, initPayload)\n\t\t},\n\t})\n\n\t// Add POST transport\n\tsrv.AddTransport(transport.POST{})\n\n\t// Enable introspection\n\tsrv.Use(extension.Introspection{})\n\n\t// Set routes\n\trouter.Handle(\"/\", playground.Handler(\"My GraphQL App\", \"/app\"))\n\trouter.Handle(\"/app\", c.Handler(srv))\n\n\t// Start server\n\tlog.Printf(\"connect to http://localhost:%s/ for GraphQL playground\", port)\n\tlog.Fatal(http.ListenAndServe(\":\" + port, router))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Starting the GraphQL Server - Shell\nDESCRIPTION: Runs the application's entry point to start the GraphQL server at the default port. This command should be executed from the project root where 'server.go' exists. Requires all prior steps to be complete and dependencies installed.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/getting-started.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\ngo run server.go\n```\n\n----------------------------------------\n\nTITLE: Marking GraphQL Field as Explicit Resolver in gqlgen.yml - YAML\nDESCRIPTION: This config snippet forces gqlgen to generate a resolver for the 'friends' field on the User type. Used when retaining generated models but customizing field fetching. Dependency: GraphQL schema with friends field present. Output: A method in the generated resolvers. Limitation: Requires manual implementation.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/_introduction.md#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nmodels:\n  User:\n    fields:\n      friends:\n        resolver: true # force a resolver to be generated\n```\n\n----------------------------------------\n\nTITLE: Updated Resolver Implementations for Lazy User Field - Go\nDESCRIPTION: Updates the mutation resolver to reference the new Todo model without eagerly loading User, and adds a separate resolver for fetching the User field. The 'User' resolver fetches user data when requested, simulating a database lookup. This separation improves performance and mimics real-world best practices.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/getting-started.md#_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nfunc (r *mutationResolver) CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error) {\n\trandNumber, _ := rand.Int(rand.Reader, big.NewInt(100))\n\ttodo := &model.Todo{\n\t\tText:   input.Text,\n\t\tID:     fmt.Sprintf(\"T%d\", randNumber),\n\t\tUserID: input.UserID,\n\t}\n\tr.todos = append(r.todos, todo)\n\treturn todo, nil\n}\n\nfunc (r *todoResolver) User(ctx context.Context, obj *model.Todo) (*model.User, error) {\n\treturn &model.User{ID: obj.UserID, Name: \"user \" + obj.UserID}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SSE Transport Keep-Alive in Go\nDESCRIPTION: This Go code demonstrates configuring the SSE transport with a `KeepAlivePingInterval`. This setting sends periodic heartbeat messages over the SSE connection to prevent intermediate proxies or load balancers with idle timeouts from closing the connection, particularly relevant for HTTP/1 connections.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/subscriptions.md#_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nsrv.AddTransport(transport.SSE{\n\t// Load balancers, proxies, or firewalls often have idle timeout\n\t// settings that specify the maximum duration a connection can\n\t// remain open without data being sent across it. If the idle\n\t// timeout is exceeded without any data being transmitted, the\n\t// connection may be closed when connecting SSE over HTTP/1.\n\t//\n\t// End-to-end HTTP/2 connections do not require a ping interval\n\t// to keep the connection open.\n\tKeepAlivePingInterval: 10 * time.Second,\n})\n```\n\n----------------------------------------\n\nTITLE: Using @goExtraField Directive to Extend GraphQL User Type Inline\nDESCRIPTION: Demonstrates how to add multiple extra fields inline on the User type within the GraphQL schema by using the @goExtraField directive. Example adds fields Session, Activated boolean, and an anonymous embedded time.Time type with descriptions and tags. These fields will be generated in the Go struct but remain hidden in the GraphQL interface.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/extra_fields.md#_snippet_4\n\nLANGUAGE: graphql\nCODE:\n```\ntype User\n\t@goExtraField(\n\t\tname: \"Session\"\n\t\ttype: \"github.com/author/mypkg.Session\"\n\t\tdescription: \"A Session used by this user\"\n\t\toverrideTags: \"xml:\\\"session\\\"\"\n\t)\n\t@goExtraField(name: \"Activated\", type: \"bool\")\n\t@goExtraField(\n\t\ttype: \"time.Time\"\n\t\tdescription: \"type without name will be embedded\"\n\t) {\n\tid: ID\n\tname: String\n}\n```\n\n----------------------------------------\n\nTITLE: Mutating Generated Models with modelgen Plugin Hook in gqlgen (Go)\nDESCRIPTION: This Go code defines a mutateHook function that appends a custom orm_binding tag to every struct field of models generated by gqlgen. The mutateHook is registered on the modelgen.Plugin and invoked during code generation by running go generate or go run generate.go. Key dependencies are github.com/99designs/gqlgen/api, codegen/config, and plugin/modelgen. The main parameters are the ModelBuild containing all models to mutate and the resulting effect is additional field tags present in the generated Go structs.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/modelgen-hook.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n//go:build ignore\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/99designs/gqlgen/api\"\n\t\"github.com/99designs/gqlgen/codegen/config\"\n\t\"github.com/99designs/gqlgen/plugin/modelgen\"\n)\n\n// Defining mutation function\nfunc mutateHook(b *modelgen.ModelBuild) *modelgen.ModelBuild {\n\tfor _, model := range b.Models {\n\t\tfor _, field := range model.Fields {\n\t\t\tfield.Tag += ` orm_binding:\"` + model.Name + `.` +  field.Name + `\"`\n\t\t}\n\t}\n\n\treturn b\n}\n\nfunc main() {\n\tcfg, err := config.LoadConfigFromDefaultLocations()\n\tif err != nil {\n\t\tfmt.Fprintln(os.Stderr, \"failed to load config\", err.Error())\n\t\tos.Exit(2)\n\t}\n\n\t// Attaching the mutation function onto modelgen plugin\n\tp := modelgen.Plugin{\n\t\tMutateHook: mutateHook,\n\t}\n\n\terr = api.Generate(cfg, api.ReplacePlugin(&p))\n\n\tif err != nil {\n\t\tfmt.Fprintln(os.Stderr, err.Error())\n\t\tos.Exit(3)\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: GraphQL Schema with Constraint Directive (GraphQL)\nDESCRIPTION: This GraphQL schema defines a @constraint directive with a format argument and applies it to fields within ObjectInput. This configuration allows the connected Go generation hook to read field constraints and populate validation tags accordingly. Direct usage is as input to gqlgen in projects that require field validation based on schema annotations.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/modelgen-hook.md#_snippet_4\n\nLANGUAGE: graphql\nCODE:\n```\ndirective @constraint(\n\tformat: String\n) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION\n\ninput ObjectInput {\n\tcontactEmail: String @constraint(format: \"email\")\n\twebsite: String @constraint(format: \"uri\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Map Scalar in GraphQL\nDESCRIPTION: This defines a GraphQL scalar named `Map`. It maps an arbitrary GraphQL value to a `map[string]interface{}` Go type.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/scalars.md#_snippet_4\n\nLANGUAGE: graphql\nCODE:\n```\nscalar Map\n```\n\n----------------------------------------\n\nTITLE: Defining the @goExtraField GraphQL Directive for Inline Extra Fields\nDESCRIPTION: Defines a repeatable GraphQL directive @goExtraField with arguments to specify additional Go fields directly within the GraphQL schema definition. This directive allows fields like name, type, overrideTags, and description to be specified inline on OBJECT or INPUT_OBJECT types enabling embedding Go-specific extra fields without editing gqlgen.yaml.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/extra_fields.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\ndirective @goExtraField(\n\tname: String\n\ttype: String!\n\toverrideTags: String\n\tdescription: String\n) repeatable on OBJECT | INPUT_OBJECT\n```\n\n----------------------------------------\n\nTITLE: Custom Todo Model with Lazy-Loaded User Field - Go\nDESCRIPTION: Defines a custom Todo struct to support more efficient data fetching. The struct includes a UserID and a pointer to a User object, with JSON struct tags for serialization. This supports separation of concerns, enabling user details to be fetched only when requested.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/getting-started.md#_snippet_11\n\nLANGUAGE: go\nCODE:\n```\npackage model\n\ntype Todo struct {\n\tID     string `json:\"id\"`\n\tText   string `json:\"text\"`\n\tDone   bool   `json:\"done\"`\n\tUserID string `json:\"userId\"`\n\tUser   *User  `json:\"user\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a GraphQL Server with CORS Support in Go\nDESCRIPTION: Complete example showing how to set up a GraphQL server with CORS headers using gqlgen, chi router, and rs/cors. Includes WebSocket configuration with origin checking for subscription support.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/cors.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/99designs/gqlgen/graphql/handler/transport\"\n\t\"github.com/99designs/gqlgen/_examples/starwars\"\n\t\"github.com/99designs/gqlgen/graphql/handler\"\n\t\"github.com/go-chi/chi\"\n\t\"github.com/rs/cors\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/99designs/gqlgen/graphql/playground\"\n)\n\nfunc main() {\n\trouter := chi.NewRouter()\n\n\t// Add CORS middleware around every request\n\t// See https://github.com/rs/cors for full option listing\n\trouter.Use(cors.New(cors.Options{\n\t\tAllowedOrigins:   []string{\"http://localhost:8080\"},\n\t\tAllowCredentials: true,\n\t\tDebug:            true,\n\t}).Handler)\n\n\n\tsrv := handler.New(starwars.NewExecutableSchema(starwars.NewResolver()))\n\n\t// Handle cross-origin checks in for websocket upgrade requests:\n\tsrv.AddTransport(&transport.Websocket{\n\t\tUpgrader: websocket.Upgrader{\n\t\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\t\t// Check against your desired domains here\n\t\t\t\treturn r.Host == \"example.org\"\n\t\t\t},\n\t\t\tReadBufferSize:  1024,\n\t\t\tWriteBufferSize: 1024,\n\t\t},\n\t})\n\tsrv.AddTransport(transport.POST{})\n\n\trouter.Handle(\"/\", playground.Handler(\"Starwars\", \"/query\"))\n\trouter.Handle(\"/query\", srv)\n\n\terr := http.ListenAndServe(\":8080\", router)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Testing SSE Subscription with Curl in Bash\nDESCRIPTION: This Bash command uses `curl` to test a GraphQL subscription over Server-Sent Events (SSE). It sends a POST request to the `/query` endpoint with the subscription query in the body, and includes the necessary headers `accept: text/event-stream` and `content-type: application/json` to indicate an SSE request. The `-N` flag prevents buffering, showing events as they arrive.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/subscriptions.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncurl -N --request POST --url http://localhost:8080/query \\\n--data '{\"query\":\"subscription { currentTime { unixTime timeStamp } }\"}' \\\n-H \"accept: text/event-stream\" -H 'content-type: application/json' \\\n--verbose\n```\n\n----------------------------------------\n\nTITLE: Implementing gqlgen Query and Subscription Resolvers in Go\nDESCRIPTION: This Go code provides the resolver implementations for the GraphQL schema defined in `schema.graphqls`. It includes a simple 'Placeholder' query resolver returning a static string \"Hello World\" and a 'CurrentTime' subscription resolver that sends the current time (as a `model.Time` struct) every second via a Go channel. The subscription goroutine listens for context cancellation to gracefully shut down.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/subscriptions.md#_snippet_10\n\nLANGUAGE: Go\nCODE:\n```\npackage graph\n\n// This file will be automatically regenerated based on the schema, any resolver implementations\n// will be copied through when generating and any unknown code will be moved to the end.\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/example/test/graph/generated\"\n\t\"github.com/example/test/graph/model\"\n)\n\n// Placeholder is the resolver for the placeholder field.\nfunc (r *queryResolver) Placeholder(ctx context.Context) (*string, error) {\n\tstr := \"Hello World\"\n\treturn &str, nil\n}\n\n// CurrentTime is the resolver for the currentTime field.\nfunc (r *subscriptionResolver) CurrentTime(ctx context.Context) (<-chan *model.Time, error) {\n\tch := make(chan *model.Time)\n\n\tgo func() {\n\t\tdefer close(ch)\n\n\t\tfor {\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t\tfmt.Println(\"Tick\")\n\n\t\t\tcurrentTime := time.Now()\n\n\t\t\tt := &model.Time{\n\t\t\t\tUnixTime:  int(currentTime.Unix()),\n\t\t\t\tTimeStamp: currentTime.Format(time.RFC3339),\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\t// Exit on cancellation\n\t\t\t\tfmt.Println(\"Subscription closed.\")\n\t\t\t\treturn\n\n\t\t\tcase ch <- t:\n\t\t\t\t// Our message went through, do nothing\n\t\t\t}\n\n\t\t}\n\t}()\n\treturn ch, nil\n}\n\n// Query returns generated.QueryResolver implementation.\nfunc (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }\n\n// Subscription returns generated.SubscriptionResolver implementation.\nfunc (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }\n\ntype queryResolver struct{ *Resolver }\ntype subscriptionResolver struct{ *Resolver }\n```\n\n----------------------------------------\n\nTITLE: Initializing gqlgen Server with WebSocket Transport in Go\nDESCRIPTION: This Go code snippet demonstrates how to initialize a gqlgen GraphQL server and add the WebSocket transport using `srv.AddTransport(transport.Websocket{})`. It also shows adding other common transports like Options, GET, and POST, emphasizing that WebSocket should typically be added first, and POST transport last. It sets up the basic server structure, port handling, and GraphQL playground.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/subscriptions.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/99designs/gqlgen/graphql/handler\"\n\t\"github.com/99designs/gqlgen/graphql/handler/transport\"\n\t\"github.com/99designs/gqlgen/graphql/playground\"\n\t\"github.com/example/test/graph\"\n\t\"github.com/example/test/graph/generated\"\n)\n\nconst defaultPort = \"8080\"\n\nfunc main() {\n\tport := os.Getenv(\"PORT\")\n\tif port == \"\" {\n\t\tport = defaultPort\n\t}\n\n\tsrv := handler.New(generated.NewExecutableSchema(generated.Config{Resolvers: &graph.Resolver{}}))\n\n\tsrv.AddTransport(transport.Websocket{}) // Add WebSocket first. Here there is no config, see below for examples.\n\tsrv.AddTransport(transport.Options{})   // If you are using the playground, it's smart to add Options and GET.\n\tsrv.AddTransport(transport.GET{})       // ...\n\tsrv.AddTransport(transport.POST{})      // ... Make sure this is after the WebSocket transport!\n\n\thttp.Handle(\"/\", playground.Handler(\"GraphQL playground\", \"/query\"))\n\thttp.Handle(\"/query\", srv)\n\n\tlog.Printf(\"connect to http://localhost:%s/ for GraphQL playground\", port)\n\tlog.Fatal(http.ListenAndServe(\":\"+port, nil))\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Upload Scalar in GraphQL\nDESCRIPTION: This defines the `Upload` GraphQL scalar and maps it to the `graphql.Upload` struct in Go. This struct is defined in the following Go code snippet.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/scalars.md#_snippet_5\n\nLANGUAGE: graphql\nCODE:\n```\nscalar Upload\n```\n\n----------------------------------------\n\nTITLE: Defining Time Scalar in GraphQL\nDESCRIPTION: This snippet defines a `Time` GraphQL scalar which maps to a `time.Time` struct in Go. This scalar adheres to the RFC3339Nano format.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/scalars.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\nscalar Time\n```\n\n----------------------------------------\n\nTITLE: Defining a GraphQL Schema with Query and Subscription\nDESCRIPTION: This GraphQL schema defines a basic API structure. It includes a placeholder query field returning a String and a 'currentTime' subscription field that returns a 'Time' object containing the Unix timestamp (Int!) and a formatted timestamp string (String!).\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/subscriptions.md#_snippet_9\n\nLANGUAGE: GraphQL\nCODE:\n```\ntype Query {\n  placeholder: String\n}\n\ntype Time {\n  unixTime: Int!\n  timeStamp: String!\n}\n\ntype Subscription {\n  currentTime: Time!\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Server-Sent Events (SSE) Transport in Go\nDESCRIPTION: This Go snippet shows how to add the Server-Sent Events (SSE) transport to a gqlgen server using `srv.AddTransport(transport.SSE{})`. It highlights that the SSE transport should typically be added before other transports like Options, GET, and POST.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/subscriptions.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nsrv := handler.New(generated.NewExecutableSchema(generated.Config{Resolvers: &graph.Resolver{}}))\n\nsrv.AddTransport(transport.SSE{}) // Add SSE first.\n\n// Continue server setup:\nsrv.AddTransport(transport.Options{})\nsrv.AddTransport(transport.GET{})\nsrv.AddTransport(transport.POST{})\n```\n\n----------------------------------------\n\nTITLE: Applying Custom Complexity Functions for Field Weighting in gqlgen with Go\nDESCRIPTION: Extends gqlgen server setup by defining and assigning a custom complexity calculation function (countComplexity) for the 'posts' and 'related' fields. This function multiplies the 'count' parameter by the child field's complexity, reflecting the real cost of resolving nested arrays. The server limits total complexity using FixedComplexityLimit. Inputs: GraphQL queries with varying 'count' arguments; Outputs: Dynamic complexity calculation and enforcement. Dependencies: gqlgen server, Complexities configuration, extension and transport packages; Constraints: Custom function must match gqlgen complexity signature and be correctly assigned.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/complexity.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\nfunc main() {\n\tc := Config{ Resolvers: &resolvers{} }\n\n\tcountComplexity := func(childComplexity, count int) int {\n\t\treturn count * childComplexity\n\t}\n\tc.Complexity.Query.Posts = countComplexity\n\tc.Complexity.Post.Related = countComplexity\n\n\tsrv := handler.New(blog.NewExecutableSchema(c))\n\tsrv.AddTransport(transport.POST{})\n\tsrv.Use(extension.FixedComplexityLimit(5))\n\thttp.Handle(\"/query\", gqlHandler)\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Enums via GraphQL Directives in gqlgen\nDESCRIPTION: This snippet demonstrates defining `@goModel` and `@goEnum` directives to bind GraphQL enum values to specific Go model enums and constants. It maps GraphQL enum fields to Go types and constants, facilitating seamless data conversions between schema and application layer.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/enum.md#_snippet_1\n\nLANGUAGE: GraphQL\nCODE:\n```\ndirective @goModel(\n    model: String\n    models: [String!]\n) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION\n\ndirective @goEnum(\n    value: String\n) on ENUM_VALUE\n\ntype Query {\n    example(arg: EnumUntyped): EnumTyped\n}\n\nenum EnumTyped @goModel(model: \"./model.EnumTyped\") {\n    ONE @goEnum(value: \"./model.EnumTypedOne\")\n    TWO @goEnum(value: \"./model.EnumTypedTwo\")\n}\n\nenum EnumUntyped @goModel(model: \"github.com/99designs/gqlgen/graphql.Int\") {\n    ONE @goEnum(value: \"./model.EnumUntypedOne\")\n    TWO @goEnum(value: \"./model.EnumUntypedTwo\")\n}\n```\n\n----------------------------------------\n\nTITLE: Configuration-Based Enum Binding in YAML for gqlgen\nDESCRIPTION: This snippet shows how to configure enum-model bindings using YAML, specifying the model type and mapping enum values to Go constants. It provides an alternative to directives for setting up enum bindings, enabling flexible configuration management.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/enum.md#_snippet_2\n\nLANGUAGE: YAML\nCODE:\n```\nmodels:\n  EnumTyped:\n    model: ./model.EnumTyped\n    enum_values:\n      ONE:\n        value: ./model.EnumTypedOne\n      TWO:\n        value: ./model.EnumTypedTwo\n  EnumUntyped:\n    model: github.com/99designs/gqlgen/graphql.Int\n    enum_values:\n      ONE:\n        value: ./model.EnumUntypedOne\n      TWO:\n        value: ./model.EnumUntypedTwo\n```\n\n----------------------------------------\n\nTITLE: Implementing JSON Marshalling for Int-Based Enums in Go\nDESCRIPTION: This code provides custom `MarshalJSON` and `UnmarshalJSON` methods for the `EnumTyped` type to convert between enum values and their JSON string representations. These functions ensure correct serialization and deserialization when communicating over GraphQL, especially for int-based enums that require string representation for client interactions.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/enum.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\nfunc (t EnumTyped) String() string {\n\tswitch t {\n\tcase EnumTypedOne:\n\t\treturn \"ONE\"\n\tcase EnumTypedTwo:\n\t\treturn \"TWO\"\n\tdefault:\n\t\treturn \"UNKNOWN\"\n\t}\n}\n\nfunc (t EnumTyped) MarshalJSON() ([]byte, error) {\n\treturn []byte(fmt.Sprintf(`\"%s\"`, t.String())), nil\n}\n\nfunc (t *EnumTyped) UnmarshalJSON(b []byte) (err error) {\n\tvar s string\n\n\tif err = json.Unmarshal(b, &s); err != nil {\n\t\treturn err\n\t}\n\n\tswitch s {\n\tcase \"ONE\":\n\t\t*t = EnumTypedOne\n\tcase \"TWO\":\n\t\t*t = EnumTypedTwo\n\tdefault:\n\t\treturn fmt.Errorf(\"unexpected enum value %q\", s)\n\t}\n\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Gin Context from Context in Go GraphQL Resolvers\nDESCRIPTION: Helper function to extract the Gin context from the context.Context object passed to GraphQL resolvers.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/gin.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc GinContextFromContext(ctx context.Context) (*gin.Context, error) {\n\tginContext := ctx.Value(\"GinContextKey\")\n\tif ginContext == nil {\n\t\terr := fmt.Errorf(\"could not retrieve gin.Context\")\n\t\treturn nil, err\n\t}\n\n\tgc, ok := ginContext.(*gin.Context)\n\tif !ok {\n\t\terr := fmt.Errorf(\"gin.Context has wrong type\")\n\t\treturn nil, err\n\t}\n\treturn gc, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Dataloader Middleware to a GraphQL Server in Go\nDESCRIPTION: Shows how to wrap a GraphQL query handler with the dataloader middleware using the database connection to inject data loaders into each HTTP request context. This integration ensures dataloaders are available in resolver calls during query execution.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/dataloaders.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n// create the query handler\nh := handler.New(generated.NewExecutableSchema(...))\nh.AddTransport(transport.POST{})\n\n// wrap the query handler with middleware to inject dataloader in requests.\n// pass in your dataloader dependencies, in this case the db connection.\nsrv = loaders.Middleware(db, h)\n\n// register the wrapped handler\nhttp.Handle(\"/query\", srv)\n```\n\n----------------------------------------\n\nTITLE: Initializing a New gqlgen Project - Bash\nDESCRIPTION: This Bash command initializes a new Go gqlgen project which will act as an individual federated microservice. It pulls dependencies and prepares the basic project structure. Requires Go tooling and network access.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/federation.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\ngo run github.com/99designs/gqlgen\n```\n\n----------------------------------------\n\nTITLE: Forcing Federation 2 in gqlgen - YAML\nDESCRIPTION: This YAML configuration explicitly sets the federation version to 2, upgrading gqlgen projects to use Apollo Federation 2. This flag overrides automatic schema upgrades and should be used when all participating services must align with Federation 2 features.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/federation.md#_snippet_1\n\nLANGUAGE: YAML\nCODE:\n```\nfederation:\n  filename: graph/federation.go\n  package: graph\n  version: 2\n```\n\n----------------------------------------\n\nTITLE: Configuring gqlgen Extra Fields for Go Models Using YAML\nDESCRIPTION: Shows how to configure extra fields for gqlgen generated Go models via the gqlgen.yaml configuration file. Here, the User model is extended with an internal Session field having a Go type and optional struct tags. This configuration ensures the extra field appears in the generated Go struct but is hidden from the GraphQL schema clients.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/extra_fields.md#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nmodels:\n  User:\n    extraFields:\n      Session:\n        description: \"A Session used by this user\"\n        type: \"github.com/author/mypkg.Session\"\n        overrideTags: 'xml:\"session\"'\n```\n\n----------------------------------------\n\nTITLE: Todo Application Schema Using @requires - GraphQL\nDESCRIPTION: This GraphQL snippet defines a simple federated Todo application schema with @key and @requires directives, illustrating a computed statusText field whose value depends on the assignee's name. This setup is used to demonstrate the usage and impact of Federation's @requires directive.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/federation.md#_snippet_11\n\nLANGUAGE: GraphQL\nCODE:\n```\ntype Todo @key(fields:\"id\") {\n  id: ID!\n  text: String!\n  statusText: String! @requires(fields: \"assignee { name }\")\n  status: String!\n  owner: User!\n  assignee: User! @external\n}\n\ntype User @key(fields:\"id\") {\n  id: ID!\n  name: String! @external\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Field Collection Helpers in Go\nDESCRIPTION: Go functions that retrieve all requested fields from a GraphQL query as a string slice, supporting nested fields with proper prefixing. These helpers allow resolvers to fetch only the requested data.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/field-collection.md#_snippet_3\n\nLANGUAGE: golang\nCODE:\n```\nfunc GetPreloads(ctx context.Context) []string {\n\treturn GetNestedPreloads(\n\t\tgraphql.GetOperationContext(ctx),\n\t\tgraphql.CollectFieldsCtx(ctx, nil),\n\t\t\"\",\n\t)\n}\n\nfunc GetNestedPreloads(ctx *graphql.OperationContext, fields []graphql.CollectedField, prefix string) (preloads []string) {\n\tfor _, column := range fields {\n\t\tprefixColumn := GetPreloadString(prefix, column.Name)\n\t\tpreloads = append(preloads, prefixColumn)\n\t\tpreloads = append(preloads, GetNestedPreloads(ctx, graphql.CollectFields(ctx, column.Selections, nil), prefixColumn)...)\n\t}\n\treturn\n}\n\nfunc GetPreloadString(prefix, name string) string {\n\tif len(prefix) > 0 {\n\t\treturn prefix + \".\" + name\n\t}\n\treturn name\n}\n```\n\n----------------------------------------\n\nTITLE: Using extensions such as Introspection and Persisted Queries in gqlgen in Go\nDESCRIPTION: This code demonstrates applying pre-defined extensions to a gqlgen server instance including enabling introspection, automatic persisted queries with an LRU cache, and Apollo tracing. These extensions add capabilities such as schema introspection, query persistence, and tracing for performance tracking.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/migration-0.11.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\nsrv := handler.New(es)\nsrv.Use(extension.Introspection{})\nsrv.Use(extension.AutomaticPersistedQuery{\n\tCache: lru.New(100),\n})\nsrv.Use(apollotracing.Tracer{})\n```\n\n----------------------------------------\n\nTITLE: Updating gqlparser import with sed command\nDESCRIPTION: A shell command using sed to replace outdated gqlparser import paths with the new v2 version across all Go files in the project. This ensures compatibility with gqlparser v2, which is required after breaking changes in version 0.11.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/migration-0.11.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\nsed -i 's/github.com\\/vektah\\/gqlparser/github.com\\/vektah\\/gqlparser\\/v2/' $(find -name '*.go')\n```\n\n----------------------------------------\n\nTITLE: Defining a GraphQL User Type Schema\nDESCRIPTION: Defines a simple User type schema in GraphQL with two fields: id and name. This schema serves as the base model which will be extended with extra fields later. It is a prerequisite for generating the corresponding Go struct with gqlgen.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/extra_fields.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\ntype User {\n\tid: ID!\n\tname: String!\n}\n```\n\n----------------------------------------\n\nTITLE: JavaScript Mutation with File Variable\nDESCRIPTION: Demonstrates how to pass a `File` object as a variable in a GraphQL mutation when using Apollo Client.  The file is passed to the `singleUpload` mutation.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/file-upload.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  query: `\n    mutation($file: Upload!) {\n      singleUpload(file: $file) {\n        id\n      }\n    }\n  `,\n  variables: {\n    file: new File(...)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Go resolver implementation for friends field\nDESCRIPTION: Sample Go function implementing the friends resolver for User, retrieving related user data from a data source. This is required when configuring gqlgen to resolve nested relationships with custom logic.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/README.md#_snippet_7\n\nLANGUAGE: Go\nCODE:\n```\nfunc (r *userResolver) Friends(ctx context.Context, obj *User) ([]*User, error) {\n  // select * from user where friendid = obj.ID\n  return friends, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Enum with Collisions - Example B\nDESCRIPTION: Example B defines a GraphQL enum that demonstrates potential naming collisions. The example intends to show how various combinations of case variations within a GraphQL enum can be handled during the Go code generation. The goal is to translate these names into unique and valid Go constants.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/name-collision.md#_snippet_4\n\nLANGUAGE: graphql\nCODE:\n```\n# graphql\n\nenum MyEnum {\n  TitleValue\n  title_value\n  title_Value\n  Title_Value\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Duration Scalar in GraphQL\nDESCRIPTION: Defines a `Duration` GraphQL scalar, conforming to ISO8601 standard, that maps to a `time.Duration` type in Go. It references a config change in `gqlgen.yml`\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/scalars.md#_snippet_8\n\nLANGUAGE: graphql\nCODE:\n```\nscalar Duration\n```\n\n----------------------------------------\n\nTITLE: Enabling Apollo Federation in gqlgen Configuration - YAML\nDESCRIPTION: This YAML snippet demonstrates uncommenting and configuring the federation section in the gqlgen.yml file to enable Apollo Federation functionalities. It sets the output filename, package location for generated federation Go code, and optionally enforces the Federation 2 standard by specifying a version. Required for any gqlgen-based microservice participating in a federated graph.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/federation.md#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\nfederation:\n  filename: graph/federation.go\n  package: graph\n```\n\n----------------------------------------\n\nTITLE: Disabling GraphQL Introspection Based on Request Context/Authentication in Go (gqlgen)\nDESCRIPTION: Illustrates disabling introspection on a per-request basis using `AroundOperations` middleware. It checks a condition (e.g., user authentication like `!userForContext(ctx).IsAdmin`) and sets `graphql.GetOperationContext(ctx).DisableIntrospection = true` if the condition is met. Requires `context`, `github.com/99designs/gqlgen/graphql`, and implicitly assumes `extension.Introspection{}` was already added. Assumes a `userForContext` function exists to retrieve user details from the context.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/introspection.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nsrv := handler.New(es)\n\n// Server setup...\n\nsrv.Use(extension.Introspection{})\nsrv.AroundOperations(func(ctx context.Context, next graphql.OperationHandler) graphql.ResponseHandler {\n    if !userForContext(ctx).IsAdmin {\n        graphql.GetOperationContext(ctx).DisableIntrospection = true\n    }\n\n    return next(ctx)\n})\n```\n\n----------------------------------------\n\nTITLE: JavaScript Operation: Multiple File Upload\nDESCRIPTION: Illustrates the JavaScript operation equivalent of the cURL command for multiple file uploads. It shows the structure of the query, variables, and the `UploadFile` input type.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/file-upload.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  query: `\n    mutation($req: [UploadFile!]!)\n      multipleUpload(req: $req) {\n        id,\n        name,\n        content\n      }\n    }\n  `,\n  variables: {\n    req: [\n        {\n            id: 1,\n            File, // b.txt\n        },\n        {\n            id: 2,\n            File, // c.txt\n        }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring UserChanges Model Backing Type in gqlgen (YAML)\nDESCRIPTION: Specifies in the gqlgen YAML config that 'UserChanges' input should be generated using the Go type 'map[string]interface{}'. This allows dynamic field presence detection when processing mutations. The YAML must be applied before running code generation and requires gqlgen setup.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/changesets.md#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nmodels:\n  UserChanges:\n    model: \"map[string]interface{}\"\n```\n\n----------------------------------------\n\nTITLE: Implementing UpdateUser Mutation Resolver in gqlgen (Go)\nDESCRIPTION: Provides a Go resolver function for the 'updateUser' mutation, accepting a context, user ID, and a map of changes. The function retrieves a user object, applies updates (logic implied), saves, and returns the result. Dependencies include generated gqlgen types and a backing database interface. Inputs are an integer ID and a map; output is a pointer to User and an error. Assumes presence of fetchFromDb and saveToDb helpers.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/changesets.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc (r *mutationResolver) UpdateUser(ctx context.Context, id int, changes map[string]interface{}) (*User, error) {\n\tu := fetchFromDb(id)\n\t/// apply the changes\n\tsaveToDb(u)\n\treturn u, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Computed @requires and Argument Directives - YAML\nDESCRIPTION: This YAML snippet demonstrates enabling the federation.options.computed_requires and call_argument_directives_with_null options in gqlgen.yml in order to support computed fields using the @requires directive. These flags are necessary for proper argument injection and compatibility with Federation 2 advanced features.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/federation.md#_snippet_10\n\nLANGUAGE: YAML\nCODE:\n```\nfederation:\n  filename: graph/federation.go\n  package: graph\n  version: 2\n  options:\n    computed_requires: true\n\ncall_argument_directives_with_null: true\n```\n\n----------------------------------------\n\nTITLE: Defining Int64 Scalar in GraphQL\nDESCRIPTION: This snippet defines a GraphQL scalar type named `Int64`.  This scalar is used to represent 64-bit integers in Go, addressing potential overflow issues with the default `Int` type.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/scalars.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\nscalar Int64\n```\n\n----------------------------------------\n\nTITLE: Go Model Generation With enable_model_json_omitempty_tag Set to False\nDESCRIPTION: This Go struct example shows model generation when the gqlgen configuration option `enable_model_json_omitempty_tag` is explicitly set to false. In this case, the nullable fields do not have the \",omitempty\" JSON tag applied, so empty values are always included in the JSON output. This is useful if downstream consumers expect the field even when empty or null.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/model-generation.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype OmitEmptyJSONTagTest struct {\n\tValueNonNil string  `json:\"ValueNonNil\" database:\"OmitEmptyJsonTagTestValueNonNil\"`\n\tValue       *string `json:\"Value\" database:\"OmitEmptyJsonTagTestValue\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring UUID Scalar with YAML\nDESCRIPTION: This YAML snippet configures the mapping of the `UUID` GraphQL scalar to the Go `uuid.UUID` type using gqlgen's model configuration.  It specifies the model's import path.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/scalars.md#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nmodels:\n  UUID:\n    model:\n      - github.com/99designs/gqlgen/graphql.UUID\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Scalar with YAML\nDESCRIPTION: This YAML snippet illustrates how to configure a custom scalar type,  `MyCustomBooleanScalar`, for marshalling and unmarshalling using external functions, within the gqlgen configuration.  It provides the model import path.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/scalars.md#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\nmodels:\n  MyCustomBooleanScalar:\n    model: github.com/me/mypkg.MyCustomBooleanScalar\n```\n\n----------------------------------------\n\nTITLE: Configuring WebSocket Transport Options in Go\nDESCRIPTION: This Go snippet shows how to configure the `transport.Websocket` struct when adding it to the gqlgen server. It sets the `KeepAlivePingInterval` to maintain connection health and configures the `Upgrader` from `github.com/gorilla/websocket` to perform origin checking for security against cross-site request forgery (CSRF) attacks, allowing specific origins.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/subscriptions.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nsrv.AddTransport(transport.Websocket{\n\t// Keep-alives are important for WebSockets to detect dead connections. This is\n\t// not unlike asking a partner who seems to have zoned out while you tell them\n\t// a story crucial to understanding the dynamics of your workplace: \"Are you\n\t// listening to me?\"\n\t//\n\t// Failing to set a keep-alive interval can result in the connection being held\n\t// open and the server expending resources to communicate with a client that has\n\t// long since walked to the kitchen to make a sandwich instead.\n\tKeepAlivePingInterval: 10 * time.Second,\n\n\t// The `github.com/gorilla/websocket.Upgrader` is used to handle the transition\n\t// from an HTTP connection to a WebSocket connection. Among other options, here\n\t// you must check the origin of the request to prevent cross-site request forgery\n\t// attacks.\n\tUpgrader: websocket.Upgrader{\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\t\t// Allow exact match on host.\n\t\t\t\torigin := r.Header.Get(\"Origin\")\n\t\t\t\tif origin == \"\" || origin == r.Header.Get(\"Host\") {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\n\t\t\t\t// Match on allow-listed origins.\n\t\t\t\treturn slices.Contains([]string{\":3000\", \"https://ui.mysite.com\"}, origin)\n\t\t},\n\t},\n})\n```\n\n----------------------------------------\n\nTITLE: Custom Length Scalar Implementation in Go\nDESCRIPTION: This Go code defines a custom scalar type `Length` and implements the `graphql.ContextUnmarshaler` and `graphql.ContextMarshaler` interfaces.  This allows accessing the request context during marshalling and unmarshalling.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/scalars.md#_snippet_11\n\nLANGUAGE: go\nCODE:\n```\n//\n// Scalars that need access to the request context\n//\n\ntype Length float64\n\n// UnmarshalGQLContext implements the graphql.ContextUnmarshaler interface\nfunc (l *Length) UnmarshalGQLContext(ctx context.Context, v interface{}) error {\n\ts, ok := v.(string)\n\tif !ok {\n\t\treturn fmt.Errorf(\"Length must be a string\")\n\t}\n\tlength, err := ParseLength(s)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*l = length\n\treturn nil\n}\n\n// MarshalGQLContext implements the graphql.ContextMarshaler interface\nfunc (l Length) MarshalGQLContext(ctx context.Context, w io.Writer) error {\n\ts, err := l.FormatContext(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tw.Write([]byte(strconv.Quote(s)))\n\treturn nil\n}\n\n// ParseLength parses a length measurement string with unit on the end (eg: \"12.45in\")\nfunc ParseLength(string) (Length, error)\n\n// ParseLength formats the string using a value in the context to specify format\nfunc (l Length) FormatContext(ctx context.Context) (string, error)\n```\n\n----------------------------------------\n\nTITLE: Defining Mutation and Input Types in GraphQL Schema\nDESCRIPTION: Defines a mutation operation 'updateUser' that accepts an 'id' and a 'changes' input of type 'UserChanges'. The 'UserChanges' input object allows optional 'name' and 'email' fields. Used to support partial updates and explicit presence checks. No dependencies outside standard GraphQL schema definition.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/changesets.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\ntype Mutation {\n\tupdateUser(id: ID!, changes: UserChanges!): User\n}\n\ninput UserChanges {\n\tname: String\n\temail: String\n}\n```\n\n----------------------------------------\n\nTITLE: Custom YesNo Scalar Implementation in Go\nDESCRIPTION: This Go code defines a custom scalar type `YesNo` and implements the `graphql.Unmarshaler` and `graphql.Marshaler` interfaces.  It handles the conversion from string values (\"yes\" or anything else) to a boolean.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/scalars.md#_snippet_10\n\nLANGUAGE: go\nCODE:\n```\npackage mypkg\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"strconv\"\n)\n\n//\n// Most common scalars\n//\n\ntype YesNo bool\n\n// UnmarshalGQL implements the graphql.Unmarshaler interface\nfunc (y *YesNo) UnmarshalGQL(v interface{}) error {\n\tyes, ok := v.(string)\n\tif !ok {\n\t\treturn fmt.Errorf(\"YesNo must be a string\")\n\t}\n\n\tif yes == \"yes\" {\n\t\t*y = true\n\t} else {\n\t\t*y = false\n\t}\n\treturn nil\n}\n\n// MarshalGQL implements the graphql.Marshaler interface\nfunc (y YesNo) MarshalGQL(w io.Writer) {\n\tif y {\n\t\tw.Write([]byte(`\"yes\"`))\n\t} else {\n\t\tw.Write([]byte(`\"no\"`))\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Built-in gqlgen Directives in GraphQL Schema\nDESCRIPTION: This GraphQL schema snippet defines the built-in gqlgen directives: `@goModel`, `@goField`, `@goTag`, and `@goExtraField`. These directives are used within the GraphQL schema to control how gqlgen generates Go code, such as mapping GraphQL types to Go types, renaming fields, adding struct tags, or adding extra fields to generated models.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/config.md#_snippet_1\n\nLANGUAGE: GraphQL\nCODE:\n```\ndirective @goModel(\n\tmodel: String\n\tmodels: [String!]\n\tforceGenerate: Boolean\n) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION\n\ndirective @goField(\n\tforceResolver: Boolean\n\tname: String\n\tomittable: Boolean\n\ttype: String\n) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION\n\ndirective @goTag(\n\tkey: String!\n\tvalue: String\n) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION\n\ndirective @goExtraField(\n\tname: String\n\ttype: String!\n\toverrideTags: String\n\tdescription: String\n) repeatable on OBJECT | INPUT_OBJECT\n```\n\n----------------------------------------\n\nTITLE: Defining DirectiveRoot with HasRole resolver function in Go using gqlgen\nDESCRIPTION: Extends gqlgen's DirectiveRoot to include a HasRole function that performs role-based access checks within the GraphQL request lifecycle. It utilizes context and the resolver chain to enforce permissions, serving as middleware for protected fields.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/directives.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\ntype DirectiveRoot struct {\n\tHasRole func(ctx context.Context, obj interface{}, next graphql.Resolver, role Role) (res interface{}, err error)\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Go User Model Definition - Go\nDESCRIPTION: This Go struct omits the friends field to avoid eager loading in resolvers. Used when mapping GraphQL types to custom Go types via configuration. Dependency: referenced in gqlgen.yml. Input: ID and Name fields. Output: Go struct for User without recursion.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/_introduction.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype User struct {\n  ID int\n  Name string\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Go Model with Validation Tags (Go)\nDESCRIPTION: This Go code shows the resulting struct after applying the constraintFieldHook, with fields containing validate tags that match the @constraint directive's format argument in the schema. It is the output of the code generation process with validation logic encoded in struct tags.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/modelgen-hook.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\ntype ObjectInput struct {\n\tcontactEmail *string  `json:\"contactEmail\" validate:\"email\"`\n\twebsite      *string  `json:\"website\" validate:\"uri\"`\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing PopulateTodoRequires Function - Golang\nDESCRIPTION: This Go function, generated by gqlgen when explicit_requires is enabled, defines a populator for computed @requires fields. It conditionally sets the statusText field on the Todo entity using the injected representation map, relying on manual type assertions and key existence checks. Used in legacy gqlgen Federation setups.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/federation.md#_snippet_15\n\nLANGUAGE: Golang\nCODE:\n```\n// PopulateTodoRequires is the requires populator for the Todo entity.\nfunc (ec *executionContext) PopulateTodoRequires(ctx context.Context, entity *model.Todo, reps map[string]interface{}) error {\n\tif reps[\"assignee\"] != nil {\n\t\tentity.StatusText = entity.Status + \" by \" + reps[\"assignee\"].(map[string]interface{})[\"name\"].(string)\n\t}\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Duration Scalar with YAML\nDESCRIPTION: This YAML snippet configures the mapping of the `Duration` GraphQL scalar to the Go `time.Duration` type using gqlgen's model configuration. It specifies the model's import path.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/scalars.md#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\nmodels:\n  Duration:\n    model:\n      - github.com/99designs/gqlgen/graphql.Duration\n```\n\n----------------------------------------\n\nTITLE: Creating Gin Context Middleware for GraphQL in Go\nDESCRIPTION: Middleware function that adds the Gin context to the request context, making it accessible to GraphQL resolvers.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/gin.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc GinContextToContextMiddleware() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\tctx := context.WithValue(c.Request.Context(), \"GinContextKey\", c)\n\t\tc.Request = c.Request.WithContext(ctx)\n\t\tc.Next()\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Binding GraphQL Types Directly to Go Struct Fields\nDESCRIPTION: Demonstrates the most common binding method where GraphQL field names directly correspond to exported Go struct field names (case-insensitive). It requires defining the Go struct, the GraphQL type, and configuring the model mapping in the gqlgen configuration file.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/resolvers.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\ntype Car struct {\n    Make string\n    Model string\n    Color string\n    OdometerReading int\n}\n```\n\nLANGUAGE: GraphQL\nCODE:\n```\ntype Car {\n    make: String!\n    model: String!\n    color: String!\n    odometerReading: Int!\n}\n```\n\nLANGUAGE: YAML\nCODE:\n```\nmodels:\n    Car:\n        model: github.com/my/app/models.Car\n```\n\n----------------------------------------\n\nTITLE: Mutating Fields with Schema-Aware FieldHook in gqlgen (Go)\nDESCRIPTION: This Go code defines constraintFieldHook, a function that inspects GraphQL schema field definitions to apply validator tags (using @constraint directive) to generated Go struct fields. The FieldHook is set on modelgen.Plugin and executed during gqlgen model generation. Required dependencies: github.com/99designs/gqlgen/api, codegen/config, plugin/modelgen, and github.com/vektah/gqlparser/v2/ast. It expects GraphQL directives named constraint with a format argument, and adds a validate tag accordingly.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/modelgen-hook.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"fmt\"\n\t\"github.com/vektah/gqlparser/v2/ast\"\n\t\"os\"\n\n\t\"github.com/99designs/gqlgen/api\"\n\t\"github.com/99designs/gqlgen/codegen/config\"\n\t\"github.com/99designs/gqlgen/plugin/modelgen\"\n)\n\n// Defining mutation function\nfunc constraintFieldHook(td *ast.Definition, fd *ast.FieldDefinition, f *modelgen.Field) (*modelgen.Field, error) {\n\t// Call default hook to proceed standard directives like goField and goTag.\n\t// You can omit it, if you don't need.\n\tif f, err := modelgen.DefaultFieldMutateHook(td, fd, f); err != nil {\n\t\treturn f, err\n\t}\n\n\tc := fd.Directives.ForName(\"constraint\")\n\tif c != nil {\n\t\tformatConstraint := c.Arguments.ForName(\"format\")\n\n\t\tif formatConstraint != nil{\n\t\t\tf.Tag += \" validate:\"+formatConstraint.Value.String()\n\t\t}\n\n\t}\n\n\treturn f, nil\n}\n\nfunc main() {\n\tcfg, err := config.LoadConfigFromDefaultLocations()\n\tif err != nil {\n\t\tfmt.Fprintln(os.Stderr, \"failed to load config\", err.Error())\n\t\tos.Exit(2)\n\t}\n\n\t// Attaching the mutation function onto modelgen plugin\n\tp := modelgen.Plugin{\n\t\tFieldHook: constraintFieldHook,\n\t}\n\n\terr = api.Generate(cfg, api.ReplacePlugin(&p))\n\n\tif err != nil {\n\t\tfmt.Fprintln(os.Stderr, err.Error())\n\t\tos.Exit(3)\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: JSON Variables for Error Example\nDESCRIPTION: This JSON code defines the variables used in a GraphQL mutation with an invalid email address, demonstrating the error handling behavior.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/scalars.md#_snippet_16\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"userInput\": {\n    \"name\": \"George\",\n    \"primaryContactDetails\": {\n      \"email\": \"not-an-email\"\n    },\n    \"secondaryContactDetails\": {\n      \"email\": \"george@gmail.com\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Refactoring Resolver to Use User DataLoader in Go\nDESCRIPTION: Updates the todo's User resolver to fetch the user via the dataloader helper, enabling batching and caching instead of individual queries. This eliminates the N+1 queries by relying on the injected dataloader in the request context.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/dataloaders.md#_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nfunc (r *todoResolver) User(ctx context.Context, obj *model.Todo) (*model.User, error) {\n\treturn loaders.GetUser(ctx, obj.UserID)\n}\n```\n\n----------------------------------------\n\nTITLE: Practical Example GraphQL Query\nDESCRIPTION: A practical GraphQL query example that requests nested fields, used to demonstrate field collection application.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/field-collection.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\nquery {\n  flowBlocks {\n    id\n    block {\n      id\n      title\n      type\n      choices {\n        id\n        title\n        description\n        slug\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing a gqlgen GraphQL Server with Multiple Transports in Go\nDESCRIPTION: This Go code initializes an HTTP server for a GraphQL API using the gqlgen library. It sets up the main GraphQL handler with the generated schema and resolvers, configures multiple transports including SSE, WebSocket (with keep-alive and custom origin check allowing specific origins), GET, POST, and OPTIONS. It also exposes the GraphQL Playground UI at the root path and listens on a configurable port (defaulting to 8080).\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/subscriptions.md#_snippet_8\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"slices\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/99designs/gqlgen/graphql/handler\"\n\t\"github.com/99designs/gqlgen/graphql/handler/transport\"\n\t\"github.com/99designs/gqlgen/graphql/playground\"\n\t\"github.com/example/test/graph\"\n\t\"github.com/example/test/graph/generated\"\n)\n\nconst defaultPort = \"8080\"\n\nfunc main() {\n\tport := os.Getenv(\"PORT\")\n\tif port == \"\" {\n\t\tport = defaultPort\n\t}\n\n\tsrv := handler.New(\n\t\tgenerated.NewExecutableSchema(\n\t\t\tgenerated.Config{Resolvers: &graph.Resolver{}},\n\t\t),\n\t)\n\tsrv.AddTransport(transport.SSE{})\n\tsrv.AddTransport(transport.Websocket{\n\t\tKeepAlivePingInterval: 10 * time.Second,\n\t\tUpgrader: websocket.Upgrader{\n\t\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\t\t\torigin := r.Header.Get(\"Origin\")\n\t\t\t\t\tif origin == \"\" || origin == r.Header.Get(\"Host\") {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t\treturn slices.Contains([]string{\":3000\", \"https://ui.mysite.com\"}, origin)\n\t\t\t},\n\t\t},\n\t})\n\tsrv.AddTransport(transport.Options{})\n\tsrv.AddTransport(transport.GET{})\n\tsrv.AddTransport(transport.POST{})\n\n\thttp.Handle(\"/\", playground.Handler(\"GraphQL playground\", \"/query\"))\n\thttp.Handle(\"/query\", srv)\n\n\tlog.Printf(\"connect to http://localhost:%s/ for GraphQL playground\", port)\n\tlog.Fatal(http.ListenAndServe(\":\"+port, nil))\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Autobind and Field Resolvers in gqlgen Configuration - YAML\nDESCRIPTION: Configures gqlgen to use existing Go models and specifies field resolvers for advanced data fetching. The 'autobind' section allows gqlgen to bind user-defined Go types to schema types, and the 'models' section customizes type mappings and field resolver requirements. This YAML configuration must be added to 'gqlgen.yml' and ensures proper integration between schema and Go code.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/getting-started.md#_snippet_10\n\nLANGUAGE: yml\nCODE:\n```\nautobind:\n - \"github.com/[username]/gqlgen-todos/graph/model\"\n```\n\nLANGUAGE: yml\nCODE:\n```\nmodels:\n  ID:\n    model:\n      - github.com/99designs/gqlgen/graphql.ID\n      - github.com/99designs/gqlgen/graphql.Int\n      - github.com/99designs/gqlgen/graphql.Int64\n      - github.com/99designs/gqlgen/graphql.Int32\n  Int:\n    model:\n      - github.com/99designs/gqlgen/graphql.Int32\n  Todo:\n    fields:\n      user:\n        resolver: true\n```\n\n----------------------------------------\n\nTITLE: Crafting an Exponentially Expensive GraphQL Query in GraphQL\nDESCRIPTION: Demonstrates a sample GraphQL query that requests posts and their related posts in multiple layers of nesting with high 'count' parameters. The query exemplifies how easily response size (and thus computational cost) can grow exponentially in recursive schemas. Inputs: None, but assumes query is executed against the schema above; Outputs: Nested post data with potentially very large result size; Limitations: Only safe when adequate complexity limiting is applied.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/complexity.md#_snippet_1\n\nLANGUAGE: GraphQL\nCODE:\n```\n{\n  posts(count: 100) {\n    related(count: 100) {\n      related(count: 100) {\n        related(count: 100) {\n          title\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a User DataLoader and Middleware Injection in Go\nDESCRIPTION: Defines a Go package with a userReader struct implementing a batch fetch method querying multiple users by IDs in one SQL statement. It wraps the dataloader with the vikstrous/dataloadgen library, provides loader instantiation, HTTP middleware injecting loaders into request context, and helper functions to access loaders from context and load single or multiple users efficiently by batching. This snippet demonstrates preparing SQL with variable placeholders, scanning rows to user models, and organizing loaders for reuse in HTTP handlers.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/dataloaders.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\npackage loaders\n\n// import vikstrous/dataloadgen with your other imports\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/vikstrous/dataloadgen\"\n)\n\ntype ctxKey string\n\nconst (\n\tloadersKey = ctxKey(\"dataloaders\")\n)\n\n// userReader reads Users from a database\ntype userReader struct {\n\tdb *sql.DB\n}\n\n// getUsers implements a batch function that can retrieve many users by ID,\n// for use in a dataloader\nfunc (u *userReader) getUsers(ctx context.Context, userIDs []string) ([]*model.User, []error) {\n\tstmt, err := u.db.PrepareContext(ctx, `SELECT id, name FROM users WHERE id IN (?`+strings.Repeat(\",?\", len(userIDs)-1)+`)`)\n\tif err != nil {\n\t\treturn nil, []error{err}\n\t}\n\tdefer stmt.Close()\n\n\trows, err := stmt.QueryContext(ctx, userIDs)\n\tif err != nil {\n\t\treturn nil, []error{err}\n\t}\n\tdefer rows.Close()\n\n\tusers := make([]*model.User, 0, len(userIDs))\n\terrs := make([]error, 0, len(userIDs))\n\tfor rows.Next() {\n\t\tvar user model.User\n\t\terr := rows.Scan(&user.ID, &user.Name)\n\t\tusers = append(users, &user)\n\t\terrs = append(errs, err)\n\t}\n\treturn users, errs\n}\n\n// Loaders wrap your data loaders to inject via middleware\ntype Loaders struct {\n\tUserLoader *dataloadgen.Loader[string, *model.User]\n}\n\n// NewLoaders instantiates data loaders for the middleware\nfunc NewLoaders(conn *sql.DB) *Loaders {\n\t// define the data loader\n\tur := &userReader{db: conn}\n\treturn &Loaders{\n\t\tUserLoader: dataloadgen.NewLoader(ur.getUsers, dataloadgen.WithWait(time.Millisecond)),\n\t}\n}\n\n// Middleware injects data loaders into the context\nfunc Middleware(conn *sql.DB, next http.Handler) http.Handler {\n\t// return a middleware that injects the loader to the request context\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tloader := NewLoaders(conn)\n\t\tr = r.WithContext(context.WithValue(r.Context(), loadersKey, loader))\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\n// For returns the dataloader for a given context\nfunc For(ctx context.Context) *Loaders {\n\treturn ctx.Value(loadersKey).(*Loaders)\n}\n\n// GetUser returns single user by id efficiently\nfunc GetUser(ctx context.Context, userID string) (*model.User, error) {\n\tloaders := For(ctx)\n\treturn loaders.UserLoader.Load(ctx, userID)\n}\n\n// GetUsers returns many users by ids efficiently\nfunc GetUsers(ctx context.Context, userIDs []string) ([]*model.User, error) {\n\tloaders := For(ctx)\n\treturn loaders.UserLoader.LoadAll(ctx, userIDs)\n}\n```\n\n----------------------------------------\n\nTITLE: Automating Code Generation with go generate - Go\nDESCRIPTION: Uses a special Go build comment at the top of resolver.go to automate gqlgen code generation. This allows running 'go generate' to update generated code automatically. Place the comment between 'package' and 'import' declarations.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/getting-started.md#_snippet_13\n\nLANGUAGE: go\nCODE:\n```\n//go:generate go run github.com/99designs/gqlgen generate\n```\n\n----------------------------------------\n\nTITLE: Using Field Collection in a GraphQL Resolver\nDESCRIPTION: An example of how to call the field collection helpers within a resolver function to get the list of requested fields.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/field-collection.md#_snippet_4\n\nLANGUAGE: golang\nCODE:\n```\nfunc (r *queryResolver) FlowBlocks(ctx context.Context) ([]*FlowBlock, error) {\n\tpreloads := GetPreloads(ctx)\n```\n\n----------------------------------------\n\nTITLE: Go Model Generation With enable_model_json_omitzero_tag Set to True\nDESCRIPTION: This Go struct snippet illustrates model generation when the gqlgen config option `enable_model_json_omitzero_tag` is set to true. Nullable GraphQL fields receive the `json:\",omitzero\"` tag, ensuring that fields with zero values (empty or null) are omitted from the JSON output. This tag is an alternative to \",omitempty\" and controls JSON marshaling behavior more precisely.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/model-generation.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ntype OmitEmptyJSONTagTest struct {\n\tValueNonNil string  `json:\"ValueNonNil\" database:\"OmitEmptyJsonTagTestValueNonNil\"`\n\tValue       *string `json:\"Value,omitzero\" database:\"OmitEmptyJsonTagTestValue\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Entity and Relationship Resolvers - Go\nDESCRIPTION: This Go snippet provides resolver implementations for finding federated Product and User entities by their primary keys and linking reviews to Users and Products. It illustrates basic resolver boilerplate for id-only node types and also how to return hardcoded sample data for demonstration. These resolver signatures are generated by gqlgen per the schema and must be implemented for federation to function.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/federation.md#_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\n// These two methods are required for gqlgen to resolve the internal id-only wrapper structs.\n// This boilerplate might be removed in a future version of gqlgen that can no-op id only nodes.\nfunc (r *entityResolver) FindProductByUpc(ctx context.Context, upc string) (*model.Product, error) {\n\treturn &model.Product{\n\t\tUpc: upc,\n\t}, nil\n}\n\nfunc (r *entityResolver) FindUserByID(ctx context.Context, id string) (*model.User, error) {\n\treturn &model.User{\n\t\tID: id,\n\t}, nil\n}\n\n// Here we implement the stitched part of this service, returning reviews for a product. Of course normally you would\n// go back to the database, but we are just making some data up here.\nfunc (r *productResolver) Reviews(ctx context.Context, obj *model.Product) ([]*model.Review, error) {\n\tswitch obj.Upc {\n\tcase \"top-1\":\n\t\treturn []*model.Review{{\n\t\t\tBody: \"A highly effective form of birth control.\",\n\t\t}}, nil\n\n\tcase \"top-2\":\n\t\treturn []*model.Review{{\n\t\t\tBody: \"Fedoras are one of the most fashionable hats around and can look great with a variety of outfits.\",\n\t\t}}, nil\n\n\tcase \"top-3\":\n\t\treturn []*model.Review{{\n\t\t\tBody: \"This is the last straw. Hat you will wear. 11/10\",\n\t\t}}, nil\n\n\t}\n\treturn nil, nil\n}\n\nfunc (r *userResolver) Reviews(ctx context.Context, obj *model.User) ([]*model.Review, error) {\n\tif obj.ID == \"1234\" {\n\t\treturn []*model.Review{{\n\t\t\tBody: \"Has an odd fascination with hats.\",\n\t\t}}, nil\n\t}\n\treturn nil, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Naive User Resolver Causing N+1 Database Queries in Go\nDESCRIPTION: This Go function resolves the user for a todo by preparing and executing a separate SQL query for each user ID. It demonstrates the classic N+1 query problem where each nested field requires an individual database call, resulting in excessive query overhead. It depends on a `database/sql` connection and returns a user model or error.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/dataloaders.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc (r *todoResolver) User(ctx context.Context, obj *model.Todo) (*model.User, error) {\n\tstmt, err := r.db.PrepareContext(ctx, \"SELECT id, name FROM users WHERE id = ?\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer stmt.Close()\n\n\trows, err := stmt.QueryContext(ctx, obj.UserID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tif !rows.Next() {\n\t\treturn nil, rows.Err()\n\t}\n\n\tvar user model.User\n\tif err := rows.Scan(&user.ID, &user.Name); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &user, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Todo Application Schema with Explicit @requires - GraphQL\nDESCRIPTION: This schema variant demonstrates a federated Todo application utilizing the deprecated explicit @requires API. The assignee field is no longer marked as @external. This reflects a legacy pattern for computed field population using explicit populator functions.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/federation.md#_snippet_14\n\nLANGUAGE: GraphQL\nCODE:\n```\ntype Todo @key(fields:\"id\") {\n  id: ID!\n  text: String!\n  statusText: String! @requires(fields: \"assignee { name }\")\n  status: String!\n  owner: User!\n  assignee: User!\n}\n\ntype User @key(fields:\"id\") {\n  id: ID!\n  name: String! @external\n}\n```\n\n----------------------------------------\n\nTITLE: Go Model Generation Without enable_model_json_omitempty_tag (Default Behavior)\nDESCRIPTION: This Go struct demonstrates the default JSON serialization behavior generated by gqlgen when the `enable_model_json_omitempty_tag` configuration is not set or set to true. Nullable GraphQL fields are annotated with the `json:\",omitempty\"` struct tag to omit empty values during JSON marshaling. The struct also contains database tags reflecting the model fields.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/model-generation.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype OmitEmptyJSONTagTest struct {\n\tValueNonNil string  `json:\"ValueNonNil\" database:\"OmitEmptyJsonTagTestValueNonNil\"`\n\tValue       *string `json:\"Value,omitempty\" database:\"OmitEmptyJsonTagTestValue\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Query Resolver Field Go\nDESCRIPTION: Defines the resolver function for the 'Resolver' field within the 'queryCustomResolverType'. This function is called by the GraphQL execution engine to resolve this specific field on the Query type. It takes a context and is expected to return a value of the custom Resolver type and an error. The current implementation is a placeholder.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/plugin/resolvergen/testdata/filetemplate/out/schema.custom.go.txt#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\nfunc (r *queryCustomResolverType) Resolver(ctx context.Context) (*customresolver.Resolver, error) {\n\t// CustomerResolverType.Resolver implementation\n\treturn nil, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Providing Resolver Resolver Implementation Go\nDESCRIPTION: Returns an instance of the `customresolver.ResolverResolver` interface implementation. This method is part of the main `CustomResolverType` struct and is used by gqlgen to delegate the resolution of fields on the custom Resolver type to the specific `resolverCustomResolverType` instance, which typically embeds the main resolver struct.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/plugin/resolvergen/testdata/filetemplate/out/schema.custom.go.txt#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\nfunc (r *CustomResolverType) Resolver() customresolver.ResolverResolver {\n\treturn &resolverCustomResolverType{r}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Redis Cache for gqlgen APQ in Go\nDESCRIPTION: This Go code provides an example implementation of the `graphql.Cache` interface required by gqlgen's `extension.AutomaticPersistedQuery`. It uses the `go-redis` library to store APQ hashes and their corresponding queries in a Redis instance. The code defines a `Cache` struct, a constructor `NewCache`, and methods `Add` and `Get` to fulfill the cache contract, alongside a snippet showing how to integrate this cache with a gqlgen handler in a `main` function. Dependencies include `github.com/go-redis/redis` and gqlgen packages.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/apq.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/99designs/gqlgen/graphql/handler\"\n\t\"github.com/99designs/gqlgen/graphql/handler/extension\"\n\t\"github.com/99designs/gqlgen/graphql/handler/transport\"\n\t\"github.com/go-redis/redis\"\n)\n\ntype Cache struct {\n\tclient redis.UniversalClient\n\tttl    time.Duration\n}\n\nconst apqPrefix = \"apq:\"\n\nfunc NewCache(redisAddress string, ttl time.Duration) (*Cache, error) {\n\tclient := redis.NewClient(&redis.Options{\n\t\tAddr:     redisAddress,\n\t})\n\n\terr := client.Ping().Err()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not create cache: %w\", err)\n\t}\n\n\treturn &Cache{client: client, ttl: ttl}, nil\n}\n\nfunc (c *Cache) Add(ctx context.Context, key string, value interface{}) {\n\tc.client.Set(apqPrefix+key, value, c.ttl)\n}\n\nfunc (c *Cache) Get(ctx context.Context, key string) (interface{}, bool) {\n\ts, err := c.client.Get(apqPrefix + key).Result()\n\tif err != nil {\n\t\treturn struct{}{}, false\n\t}\n\treturn s, true\n}\n\nfunc main() {\n\tcache, err := NewCache(cfg.RedisAddress, 24*time.Hour)\n\tif err != nil {\n\t\tlog.Fatalf(\"cannot create APQ redis cache: %v\", err);\n\t}\n\n\tc := Config{ Resolvers: &resolvers{} }\n\tgqlHandler := handler.New(\n\t\tgenerated.NewExecutableSchema(c),\n\t)\n\tgqlHandler.AddTransport(transport.POST{})\n\tgqlHandler.Use(extension.AutomaticPersistedQuery{Cache: cache})\n\thttp.Handle(\"/query\", gqlHandler);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Subscription Schema\nDESCRIPTION: This GraphQL schema definition demonstrates how to add a `Subscription` type alongside a basic `Query` type. It defines a `Time` object type and a `currentTime` subscription field within the `Subscription` type, which is intended to stream `Time` objects to the client.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/subscriptions.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\n\"\"\"\nMake sure you have at least something in your `Query` type.\nIf you don't have a query the playground will be unable\nto introspect your schema!\n\"\"\"\ntype Query {\n  placeholder: String\n}\n\n\"\"\"\n`Time` is a simple type only containing the current time as\na unix epoch timestamp and a string timestamp.\n\"\"\"\ntype Time {\n  unixTime: Int!\n  timeStamp: String!\n}\n\n\"\"\"\n`Subscription` is where all the subscriptions your clients can\nrequest. You can use Schema Directives like normal to restrict\naccess.\n\"\"\"\ntype Subscription {\n  \"\"\"\n  `currentTime` will return a stream of `Time` objects.\n  \"\"\"\n  currentTime: Time!\n}\n```\n\n----------------------------------------\n\nTITLE: Example SQL Queries Illustrating N+1 Query Pattern\nDESCRIPTION: A sequence of SQL queries showing the initial todo retrieval followed by multiple user queries for each todo's user. Highlights inefficiency when multiple todos belong to the same user, and the need for batching to reduce query count.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/dataloaders.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nSELECT id, todo, user_id FROM todo\nSELECT id, name FROM users WHERE id = ?\nSELECT id, name FROM users WHERE id = ?\nSELECT id, name FROM users WHERE id = ?\nSELECT id, name FROM users WHERE id = ?\nSELECT id, name FROM users WHERE id = ?\nSELECT id, name FROM users WHERE id = ?\n```\n\n----------------------------------------\n\nTITLE: Starting Federated Go Services and Gateway - Bash\nDESCRIPTION: This Bash snippet shows how to launch the individual federated Go services (accounts, products, reviews) and the Node.js Apollo Federation gateway. Each command starts a separate microservice. Each should be executed in a separate shell terminal for the federation to work properly.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/federation.md#_snippet_7\n\nLANGUAGE: Bash\nCODE:\n```\ngo run accounts/server.go\ngo run products/server.go\ngo run reviews/server.go\nnode gateway/index.js\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Directives for Code Generation Only\nDESCRIPTION: This YAML configuration snippet shows how to mark a custom GraphQL directive (named `constraint` in this example) to be used only during gqlgen's code generation process and not exposed during GraphQL introspection. Setting `skip_runtime: true` prevents the directive from being included in the generated runtime code.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/config.md#_snippet_3\n\nLANGUAGE: YAML\nCODE:\n```\n# custom directives which are not exposed during introspection. These directives are\n# used for code generation only\ndirectives:\n  constraint:\n    skip_runtime: true\n```\n\n----------------------------------------\n\nTITLE: GraphQL Mutation for Single File Upload\nDESCRIPTION: Defines a GraphQL mutation `singleUpload` designed to accept a single file. The `Upload!` type is provided by gqlgen and represents a file upload. The mutation returns the `id` of the uploaded file.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/fileupload/readme.md#_snippet_1\n\nLANGUAGE: GraphQL\nCODE:\n```\n{\n  query: `\n    mutation($file: Upload!) {\n      singleUpload(file: $file) {\n        id\n      }\n    }\n  `,\n  variables: {\n    file: File // a.txt\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Go Model with Custom ORM Tag (Go)\nDESCRIPTION: This Go code demonstrates the output after running the model mutation hook, with the generated struct containing JSON and custom orm_binding tags. The struct fields are pointers to basic types. This is an example output, so no dependencies or direct execution applies.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/modelgen-hook.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype Object struct {\n\tfield1 *string  `json:\"field1\" orm_binding:\"Object.field1\"`\n\tfield2 *int     `json:\"field2\" orm_binding:\"Object.field2\"`\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing gqlgen Plugin Entrypoint in Go\nDESCRIPTION: This snippet defines a standalone Go main package to set up gqlgen code generation using a custom plugin. It loads gqlgen configuration from default locations, and then calls api.Generate applying the custom plugin via api.AddPlugin(yourplugin.New()). An error during config loading or code generation exits the program with a non-zero status. Dependencies include gqlgen's api, config, and plugin packages. This file is intended to be run via go generate as an alternative to the default gqlgen generate command, enabling the injection of custom plugins.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/plugins.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// go:build ignore\n\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/99designs/gqlgen/api\"\n\t\"github.com/99designs/gqlgen/codegen/config\"\n\t\"github.com/99designs/gqlgen/plugin/stubgen\"\n)\n\nfunc main() {\n\tcfg, err := config.LoadConfigFromDefaultLocations()\n\tif err != nil {\n\t\tfmt.Fprintln(os.Stderr, \"failed to load config\", err.Error())\n\t\tos.Exit(2)\n\t}\n\n\t\n\terr = api.Generate(cfg,\n\t\tapi.AddPlugin(yourplugin.New()), // This is the magic line\n\t)\n\tif err != nil {\n\t\tfmt.Fprintln(os.Stderr, err.Error())\n\t\tos.Exit(3)\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Fixed Complexity Limit in gqlgen Server with Go\nDESCRIPTION: Initializes a GraphQL server using gqlgen's handler.New and applies the FixedComplexityLimit extension to globally restrict maximum query complexity to 5. The code expects the presence of 'handler', 'extension', and the gqlgen-generated schema and resolvers. The /query endpoint is registered in the HTTP router. Inputs: Incoming HTTP GraphQL queries; Outputs: HTTP-level rejection of queries exceeding the complexity threshold. Dependencies: gqlgen, Go HTTP server, the 'extension' package.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/complexity.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nfunc main() {\n\tc := Config{ Resolvers: &resolvers{} }\n\n\tsrv := handler.New(blog.NewExecutableSchema(c))\n\t// Server setup...\n\n\tsrv.Use(extension.FixedComplexityLimit(5)) // This line is key\n\n\tr.Handle(\"/query\", srv)\n}\n```\n\n----------------------------------------\n\nTITLE: Running gqlgen File Upload Server\nDESCRIPTION: Command to start the example GraphQL server that handles file uploads using gqlgen. This server must be running before attempting any of the subsequent requests.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/fileupload/readme.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngo run ./server/server.go\n```\n\n----------------------------------------\n\nTITLE: Single File Upload Request Payload Example\nDESCRIPTION: Illustrates the structure of the multipart/form-data HTTP request payload for a single file upload. It includes sections for the GraphQL `operations`, the `map` defining file-to-variable mapping, and the actual file content.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/fileupload/readme.md#_snippet_3\n\nLANGUAGE: plain text\nCODE:\n```\n--------------------------e6b2b29561e71173\nContent-Disposition: form-data; name=\"operations\"\n\n{ \"query\": \"mutation ($file: Upload!) { singleUpload(file: $file) { id, name, content } }\", \"variables\": { \"file\": null } }\n--------------------------e6b2b29561e71173\nContent-Disposition: form-data; name=\"map\"\n\n{ \"0\": [\"variables.file\"] }\n--------------------------e6b2b29561e71173\nContent-Disposition: form-data; name=\"0\"; filename=\"a.txt\"\nContent-Type: text/plain\n\nAlpha file content.\n--------------------------e6b2b29561e711173--\n```\n\n----------------------------------------\n\nTITLE: cURL Request for Multiple File Upload with Payload\nDESCRIPTION: Shows how to upload multiple files (`b.txt`, `c.txt`), each linked to an item in an input array, using cURL. The `map` parameter is crucial for mapping each file part (`0`, `1`) to the correct nested field (`variables.req.0.file`, `variables.req.1.file`) within the array of input objects.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/fileupload/readme.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\ncurl localhost:8087/query \\\n  -F operations='{ \"query\": \"mutation($req: [UploadFile!]!) { multipleUploadWithPayload(req: $req) { id, name, content } }\", \"variables\": { \"req\": [ { \"id\": 1, \"file\": null }, { \"id\": 2, \"file\": null } ] } }' \\\n  -F map='{ \"0\": [\"variables.req.0.file\"], \"1\": [\"variables.req.1.file\"] }' \\\n  -F 0=@./_examples/fileupload/testfiles/b.txt \\\n  -F 1=@./_examples/fileupload/testfiles/c.txt\n```\n\n----------------------------------------\n\nTITLE: Multiple File Upload with Payload Request Payload Example\nDESCRIPTION: Illustrates the multipart/form-data payload for uploading multiple files, where each file is part of an object within an input array. The `operations` and `map` parts demonstrate how file fields nested within array elements are referenced for the upload.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/fileupload/readme.md#_snippet_12\n\nLANGUAGE: plain text\nCODE:\n```\n--------------------------65aab09fb49ee66f\nContent-Disposition: form-data; name=\"operations\"\n\n{ \"query\": \"mutation($req: [UploadFile!]!) { multipleUploadWithPayload(req: $req) { id, name, content } }\", \"variables\": { \"req\": [ { \"id\": 1, \"file\": null }, { \"id\": 2, \"file\": null } ] } }\n--------------------------65aab09fb49ee66f\nContent-Disposition: form-data; name=\"map\"\n\n{ \"0\": [\"variables.req.0.file\"], \"1\": [\"variables.req.1.file\"] }\n--------------------------65aab09fb49ee66f\nContent-Disposition: form-data; name=\"0\"; filename=\"b.txt\"\nContent-Type: text/plain\n\nBravo file content.\n--------------------------65aab09fb49ee66f\nContent-Disposition: form-data; name=\"1\"; filename=\"c.txt\"\nContent-Type: text/plain\n\nCharlie file content.\n--------------------------65aab09fb49ee66f--\n```\n\n----------------------------------------\n\nTITLE: Querying a specific post with comments using GraphQL\nDESCRIPTION: This GraphQL query retrieves a specific post by its ID, along with a paginated list of its comments.  It uses cursor-based pagination to retrieve the first 5 comments, including their IDs, text content, author IDs, creation dates, and cursor information for pagination.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/mini-habr-with-subscriptions/README.md#_snippet_5\n\nLANGUAGE: GraphQL\nCODE:\n```\nquery {\n    post(postID: 1) {\n        id\n        title\n        text\n        comments(first: 5) {\n            edges {\n                node {\n                    id\n                    text\n                    authorID\n                    createDate\n                }\n                cursor\n            }\n            pageInfo {\n                hasNextPage\n                endCursor\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Go Project Dependencies with gqlgen - Bash\nDESCRIPTION: This Bash snippet shows how to update Go module dependencies, specifically fetching the latest version of the github.com/99designs/gqlgen package. Running 'go mod tidy' ensures that the go.mod and go.sum files are accurate and removes unused dependencies. The subsequent 'go get -u' command updates the gqlgen package to its latest version. Both commands must be run from within the Go project's root directory and require Go to be installed.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/websocket-initfunc/server/readme.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngo mod tidy\ngo get -u github.com/99designs/gqlgen\n```\n\n----------------------------------------\n\nTITLE: Enabling Explicit @requires API - YAML\nDESCRIPTION: This YAML configuration activates the deprecated explicit_requires flag in gqlgen for projects that depend on the alternate explicit populator functions for handling nested or array @requires fields in Apollo Federation 2. This configuration is no longer recommended but is provided for legacy compatibility.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/federation.md#_snippet_13\n\nLANGUAGE: YAML\nCODE:\n```\nfederation:\n  filename: graph/federation.go\n  package: graph\n  version: 2\n  options:\n    explicit_requires: true\n```\n\n----------------------------------------\n\nTITLE: Federated Gateway Sample Query - GraphQL\nDESCRIPTION: This GraphQL query fetches the currently logged-in user's username and their reviews with referenced product details (name, upc) from the federated gateway. Used to test cross-service data resolution via the federated schema.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/federation.md#_snippet_8\n\nLANGUAGE: GraphQL\nCODE:\n```\nquery {\n  me {\n    username\n    reviews {\n      body\n      product {\n        name\n        upc\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Recursive User Type in GraphQL Schema - GraphQL\nDESCRIPTION: This GraphQL SDL snippet defines a User type with an ID, name, and a self-referencing friends field (list of Users). Useful for social graph or nested relationships. Consumed by gqlgen for schema-first development. Input/Output: GraphQL object definitions. Limitations: Recursive types can require special resolver logic.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/_introduction.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\ntype User {\n\tid: ID!\n\tname: String!\n\tfriends: [User!]!\n}\n```\n\n----------------------------------------\n\nTITLE: Building the Server Application Using Make - Bash\nDESCRIPTION: This Bash code snippet invokes the 'make' command to build the server application. It assumes the existence of a Makefile with a 'build' target that compiles the Go source, likely producing an executable named 'server'. The Make utility and Go must be installed for successful execution. The operation must be run from the project root directory.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/websocket-initfunc/server/readme.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmake build\n```\n\n----------------------------------------\n\nTITLE: Configuring custom YesNo scalar with YAML\nDESCRIPTION: This YAML snippet configures the mapping of the `YesNo` GraphQL scalar to the Go type using gqlgen's model configuration. It specifies the model's import path.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/scalars.md#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\nmodels:\n  YesNo:\n    model: github.com/me/mypkg.YesNo\n```\n\n----------------------------------------\n\nTITLE: Custom GO model to omit friends field\nDESCRIPTION: A custom Go struct representing User with limited fields for optimized or controlled data retrieval. This approach allows developers to exclude fields from generated models and reference these custom types via configuration.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/README.md#_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\ntype User struct {\n  ID int\n  Name string\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing @requires Resolver Function - Golang\nDESCRIPTION: This Go resolver function, generated by gqlgen with computed_requires enabled, implements the logic for a computed statusText field in a Todo entity. It shows how to extract the required field value from the injected federationRequires argument, which contains a selection set from the @requires directive. The function expects a map mapping field names to their values and demonstrates structured type assertions and safe returns.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/federation.md#_snippet_12\n\nLANGUAGE: Golang\nCODE:\n```\nfunc (r *todoResolver) StatusText(ctx context.Context, entity *model.Todo, federationRequires map[string]interface{} /* new argument generated onto your resolver function */) (string, error) {\n  if federationRequires[\"assignee\"] == nil {\n    return \"\", nil\n  }\n\n  // federationRequires will contain the \"assignee.name\" field provided by the Federation router\n  statusText := entity.Status + \" by \" + federationRequires[\"assignee\"].(map[string]interface{})[\"name\"].(string)\n  return statusText, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Regenerating gqlgen Code - Bash\nDESCRIPTION: This Bash command regenerates the gqlgen Go code based on the current GraphQL schema and configuration. It should be run after any schema modification. Requires gqlgen to be installed in the project.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/federation.md#_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\ngo run github.com/99designs/gqlgen\n```\n\n----------------------------------------\n\nTITLE: Inline GraphQL Schema with goModel and goField Directives - GraphQL\nDESCRIPTION: This GraphQL schema defines custom directives for goModel and goField, mapping schema elements to Go types and customizing resolver requirements. The User type is mapped to a specific Go model and configures field renaming and resolver enforcement. Dependency: gqlgen supports these directives. Input: annotated schema SDL. Output: tightly controlled Go code generation.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/_introduction.md#_snippet_6\n\nLANGUAGE: graphql\nCODE:\n```\ndirective @goModel(\n\tmodel: String\n\tmodels: [String!]\n) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION\n\ndirective @goField(\n\tforceResolver: Boolean\n\tname: String\n\tomittable: Boolean\n\ttype: String\n) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION\n\ntype User @goModel(model: \"github.com/you/pkg/model.User\") {\n\tid: ID! @goField(name: \"todoId\")\n\tfriends: [User!]! @goField(forceResolver: true)\n}\n```\n\n----------------------------------------\n\nTITLE: Returning multiple GraphQL errors using gqlgen in Go\nDESCRIPTION: This Go code snippet demonstrates how to add multiple errors within a GraphQL resolver using gqlgen's graphql.AddError and graphql.AddErrorf functions. It shows three different ways to create errors: adding a formatted error message, passing an existing gqlerror error, and building a fully customized error with a message, path, and extensions map. The resolver still returns a final error alongside the added errors. Dependencies include gqlgen packages github.com/99designs/gqlgen/graphql and github.com/vektah/gqlparser/v2/gqlerror. Inputs are the context and resolver method, outputs include the errors collected and returned to the client in order.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/errors.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage foo\n\nimport (\n\t\"context\"\n\t\"errors\"\n\n\t\"github.com/vektah/gqlparser/v2/gqlerror\"\n\t\"github.com/99designs/gqlgen/graphql\"\n)\n\n// DoThings add errors to the stack.\nfunc (r Query) DoThings(ctx context.Context) (bool, error) {\n\t// Print a formatted string\n\tgraphql.AddErrorf(ctx, \"Error %d\", 1)\n\n\t// Pass an existing error out\n\tgraphql.AddError(ctx, gqlerror.Errorf(\"zzzzzt\"))\n\n\t// Or fully customize the error\n\tgraphql.AddError(ctx, &gqlerror.Error{\n\t\tPath:       graphql.GetPath(ctx),\n\t\tMessage:    \"A descriptive error message\",\n\t\tExtensions: map[string]interface{}{\n\t\t\t\"code\": \"10-4\",\n\t\t},\n\t})\n\n\t// And you can still return an error if you need\n\treturn false, gqlerror.Errorf(\"BOOM! Headshot\")\n}\n```\n\n----------------------------------------\n\nTITLE: Executing GraphQL Subscription Query\nDESCRIPTION: This GraphQL query demonstrates how to subscribe to the `currentTime` field defined in the schema. When executed against a compatible GraphQL server (like one configured in the previous steps), it will initiate a persistent connection (e.g., WebSocket) and receive a stream of `Time` objects containing `unixTime` and `timeStamp`.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/subscriptions.md#_snippet_4\n\nLANGUAGE: graphql\nCODE:\n```\nsubscription {\n  currentTime {\n    unixTime\n    timeStamp\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Go Code from Example C\nDESCRIPTION: This Go snippet shows the outcome of the name collision resolution strategy from Example C. Specifically, it demonstrates how duplicate or very similar values in the GraphQL enum are mapped to unique Go constant names, with the addition of a numeric suffix to resolve the naming conflict. This highlights the importance of maintaining order in the schema.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/name-collision.md#_snippet_7\n\nLANGUAGE: go\nCODE:\n```\n// golang\n\ntype MyEnum string\n\nconst (\n\tMyEnumValue  = \"value\"\n\tMyEnumValue0 = \"Value\"\n)\n```\n\n----------------------------------------\n\nTITLE: Generated Go Code from Example B\nDESCRIPTION: This Go code snippet shows the Go code that is generated from the GraphQL enum defined in Example B. The result provides unique names for all values defined, demonstrating the ability to handle various naming scenarios in the schema. This ensures that each GraphQL enum value is translated to a unique Go constant.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/name-collision.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n// golang\n\ntype MyEnum string\n\nconst (\n\tMyEnumTitleValue MyEnum  = \"TitleValue\"\n\tMyEnumtitle_value MyEnum = \"title_value\"\n\tMyEnumtitle_Value MyEnum = \"title_Value\"\n\tMyEnumTitle_Value MyEnum = \"Title_Value\"\n)\n```\n\n----------------------------------------\n\nTITLE: Federated Gateway Sample Response - JSON\nDESCRIPTION: Demonstrates the expected JSON response from the federated GraphQL gateway for the me query, including user details, review bodies, and product information. This helps validate correct resolver implementations and data stitching between services.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/federation.md#_snippet_9\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"data\": {\n    \"me\": {\n      \"username\": \"Me\",\n      \"reviews\": [\n        {\n          \"body\": \"A highly effective form of birth control.\",\n          \"product\": {\n            \"name\": \"Trilby\",\n            \"upc\": \"top-1\"\n          }\n        },\n        {\n          \"body\": \"Fedoras are one of the most fashionable hats around and can look great with a variety of outfits.\",\n          \"product\": {\n            \"name\": \"Trilby\",\n            \"upc\": \"top-1\"\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized Batched SQL Query for Users\nDESCRIPTION: The final SQL query example after applying dataloader optimization that retrieves all required users in a single query using the IN clause with multiple user IDs, significantly reducing the total number of database calls.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/dataloaders.md#_snippet_7\n\nLANGUAGE: sql\nCODE:\n```\nSELECT id, todo, user_id FROM todo\nSELECT id, name from user WHERE id IN (?,?,?,?,?)\n```\n\n----------------------------------------\n\nTITLE: Generated Go Code from Example A\nDESCRIPTION: This Go snippet illustrates how the generated code handles collisions in Example A. By transposing the GraphQL names, the code demonstrates how different enum values in the GraphQL schema are mapped to unique constant names in the generated Golang code to avoid conflicts. The process capitalizes names to make them unique.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/name-collision.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n// golang\n\ntype MyEnum string\n\nconst (\n\tMyEnumValue MyEnum       = \"Value\"\n\tMyEnumvalue MyEnum       = \"value\"\n\tMyEnumTitleValue MyEnum  = \"TitleValue\"\n\tMyEnumtitle_value MyEnum = \"title_value\"\n)\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Enum with Collisions - Example A\nDESCRIPTION: Example A showcases a GraphQL enum containing values that highlight the resolution process to prevent naming collisions. The example demonstrates a scenario where different variations of naming conventions may arise. The resulting Golang code will demonstrate the successful avoidance of name conflicts.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/name-collision.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\n# graphql\n\nenum MyEnum {\n  Value\n  value\n  TitleValue\n  title_value\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Gin Context in GraphQL Resolver\nDESCRIPTION: Example of how to access the Gin context within a GraphQL resolver function using the helper function.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/gin.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc (r *resolver) Todo(ctx context.Context) (*Todo, error) {\n\tgc, err := GinContextFromContext(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Subscription Resolver in Go\nDESCRIPTION: This Go code shows the implementation of a `CurrentTime` resolver function for a GraphQL subscription. It creates a Go channel (`chan *model.Time`), starts a goroutine to periodically send the current time to the channel, and handles context cancellation to close the channel and stop the goroutine when the client disconnects. The resolver returns the channel to gqlgen, which manages the subscription stream.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/subscriptions.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n// CurrentTime is the resolver for the currentTime field.\nfunc (r *subscriptionResolver) CurrentTime(ctx context.Context) (<-chan *model.Time, error) {\n\t// First you'll need to `make()` your channel. Use your type here!\n\tch := make(chan *model.Time)\n\n\t// You can (and probably should) handle your channels in a central place outside of `schema.resolvers.go`.\n\t// For this example we'll simply use a Goroutine with a simple loop.\n\tgo func() {\n\t\t// Handle deregistration of the channel here. Note the `defer`\n\t\tdefer close(ch)\n\n\t\tfor {\n\t\t\t// In our example we'll send the current time every second.\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t\tfmt.Println(\"Tick\")\n\n\t\t\t// Prepare your object.\n\t\t\tcurrentTime := time.Now()\n\t\t\tt := &model.Time{\n\t\t\t\tUnixTime:  int(currentTime.Unix()),\n\t\t\t\tTimeStamp: currentTime.Format(time.RFC3339),\n\t\t\t}\n\n\t\t\t// The subscription may have got closed due to the client disconnecting.\n\t\t\t// Hence we do send in a select block with a check for context cancellation.\n\t\t\t// This avoids goroutine getting blocked forever or panicking,\n\t\t\tselect {\n\t\t\tcase <-ctx.Done(): // This runs when context gets cancelled. Subscription closes.\n\t\t\t\tfmt.Println(\"Subscription Closed\")\n\t\t\t\t// Handle deregistration of the channel here. `close(ch)`\n\t\t\t\treturn // Remember to return to end the routine.\n\n\t\t\tcase ch <- t: // This is the actual send.\n\t\t\t\t// Our message went through, do nothing\n\t\t\t}\n\t\t}\n\t}()\n\n\t// We return the channel and no error.\n\treturn ch, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Enum with Collisions - Example C - State B\nDESCRIPTION: This GraphQL snippet demonstrates the same enum but with the values in reverse order compared to State A. This is meant to highlight the impact order has on the resolution of name collisions. Changing the order of the elements will lead to different constant value mappings, despite the constants having the same name.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/name-collision.md#_snippet_10\n\nLANGUAGE: graphql\nCODE:\n```\n# graphql\n\nenum MyEnum {\n  Value\n  value\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Apollo Federation Gateway Server - TypeScript\nDESCRIPTION: This TypeScript snippet sets up an Apollo Federation gateway using ApolloServer and ApolloGateway on the Node.js platform. It defines federated subgraphs' service URLs and composes the unified supergraph SDL. Subscriptions are disabled. Requires installation of @apollo/gateway, apollo-server, and graphql npm packages.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/federation.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst { ApolloServer } = require('apollo-server');\nconst { ApolloGateway, IntrospectAndCompose } = require(\"@apollo/gateway\");\n\nconst gateway = new ApolloGateway({\n    supergraphSdl: new IntrospectAndCompose({\n        subgraphs: [\n            { name: 'accounts', url: 'http://localhost:4001/query' },\n            { name: 'products', url: 'http://localhost:4002/query' },\n            { name: 'reviews', url: 'http://localhost:4003/query' }\n        ]\n    })\n});\n\nconst server = new ApolloServer({\n    gateway,\n\n    subscriptions: false,\n});\n\nserver.listen().then(({ url }) => {\n    console.log(`🚀 Server ready at ${url}`);\n});\n```\n\n----------------------------------------\n\nTITLE: Default gqlgen Configuration Example\nDESCRIPTION: This YAML snippet shows the default configuration generated by `gqlgen init`. It defines schema file locations, output paths for generated Go code (exec, federation, model), resolver settings, autobinding paths, model type mappings, and various optional settings for code generation behavior.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/config.md#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\n# Where are all the schema files located? globs are supported eg  src/**/*.graphqls\nschema:\n  - graph/*.graphqls\n\n# Where should the generated server code go?\nexec:\n  package: graph\n  layout: single-file # Only other option is \"follow-schema,\" ie multi-file.\n\n  # Only for single-file layout:\n  filename: graph/generated.go\n\n  # Only for follow-schema layout:\n  # dir: graph\n  # filename_template: \"{name}.generated.go\"\n\n  # Optional: Maximum number of goroutines in concurrency to use per child resolvers(default: unlimited)\n  # worker_limit: 1000\n\n# Comment or remove this section to skip Apollo Federation support\nfederation:\n  filename: graph/federation.go\n  package: graph\n  version: 2\n  options:\n    computed_requires: true\n\n# Where should any generated models go?\nmodel:\n  filename: graph/model/models_gen.go\n  package: model\n\n  # Optional: Pass in a path to a new gotpl template to use for generating the models\n  # model_template: [your/path/model.gotpl]\n\n# Where should the resolver implementations go?\nresolver:\n  package: graph\n  layout: follow-schema # Only other option is \"single-file.\"\n\n  # Only for single-file layout:\n  # filename: graph/resolver.go\n\n  # Only for follow-schema layout:\n  dir: graph\n  filename_template: \"{name}.resolvers.go\"\n\n  # Optional: turn on to not generate template comments above resolvers\n  # omit_template_comment: false\n  # Optional: Pass in a path to a new gotpl template to use for generating resolvers\n  # resolver_template: [your/path/resolver.gotpl]\n  # Optional: turn on to avoid rewriting existing resolver(s) when generating\n  # preserve_resolver: false\n\n# Optional: turn on use `gqlgen:\"fieldName\"` tags in your models\n# struct_tag: json\n\n# Optional: turn on to split imports in generated files into local modules and third-party packages\n# local_prefix: github.com/myrepo\n\n# Optional: turn on to use []Thing instead of []*Thing\n# omit_slice_element_pointers: false\n\n# Optional: turn on to omit Is<Name>() methods to interface and unions\n# omit_interface_checks : true\n\n# Optional: turn on to skip generation of ComplexityRoot struct content and Complexity function\n# omit_complexity: false\n\n# Optional: turn on to not generate any file notice comments in generated files\n# omit_gqlgen_file_notice: false\n\n# Optional: turn on to exclude the gqlgen version in the generated file notice. No effect if `omit_gqlgen_file_notice` is true.\n# omit_gqlgen_version_in_file_notice: false\n\n# Optional: turn on to exclude root models such as Query and Mutation from the generated models file.\n# omit_root_models: false\n\n# Optional: turn on to exclude resolver fields from the generated models file.\n# omit_resolver_fields: false\n\n# Optional: turn off to make struct-type struct fields not use pointers\n# e.g. type Thing struct { FieldA OtherThing } instead of { FieldA *OtherThing }\n# struct_fields_always_pointers: true\n\n# Optional: turn off to make resolvers return values instead of pointers for structs\n# resolvers_always_return_pointers: true\n\n# Optional: turn on to return pointers instead of values in unmarshalInput\n# return_pointers_in_unmarshalinput: false\n\n# Optional: wrap nullable input fields with Omittable\n# nullable_input_omittable: true\n\n# Optional: set to speed up generation time by not performing a final validation pass.\n# skip_validation: true\n\n# Optional: set to skip running `go mod tidy` when generating server code\n# skip_mod_tidy: true\n\n# Optional: if this is set to true, argument directives that\n# decorate a field with a null value will still be called.\n#\n# This enables argumment directives to not just mutate\n# argument values but to set them even if they're null.\ncall_argument_directives_with_null: true\n\n# This enables gql server to use function syntax for execution context\n# instead of generating receiver methods of the execution context.\n# use_function_syntax_for_execution_context: true\n\n# Optional: set build tags that will be used to load packages\n# go_build_tags:\n#  - private\n#  - enterprise\n\n# Optional: set to modify the initialisms regarded for Go names\n# go_initialisms:\n#   replace_defaults: false # if true, the default initialisms will get dropped in favor of the new ones instead of being added\n#   initialisms: # List of initialisms to for Go names\n#     - 'CC'\n#     - 'BCC'\n\n# gqlgen will search for any type names in the schema in these go packages\n# if they match it will use them, otherwise it will generate them.\nautobind:\n#  - \"{{.}}/graph/model\"\n\n# This section declares type mapping between the GraphQL and go type systems\n#\n# The first line in each type will be used as defaults for resolver arguments and\n# modelgen, the others will be allowed when binding to fields. Configure them to\n# your liking\nmodels:\n  ID:\n    model:\n      - github.com/99designs/gqlgen/graphql.ID\n      - github.com/99designs/gqlgen/graphql.Int\n      - github.com/99designs/gqlgen/graphql.Int64\n      - github.com/99designs/gqlgen/graphql.Int32\n  # gqlgen provides a default GraphQL UUID convenience wrapper for github.com/google/uuid\n  # but you can override this to provide your own GraphQL UUID implementation\n  UUID:\n    model:\n      - github.com/99designs/gqlgen/graphql.UUID\n\n  # The GraphQL spec explicitly states that the Int type is a signed 32-bit\n  # integer. Using Go int or int64 to represent it can lead to unexpected\n  # behavior, and some GraphQL tools like Apollo Router will fail when\n  # communicating numbers that overflow 32-bits.\n  #\n  # You may choose to use the custom, built-in Int64 scalar to represent 64-bit\n  # integers, or ignore the spec and bind Int to graphql.Int / graphql.Int64\n  # (the default behavior of gqlgen). This is fine in simple use cases when you\n  # do not need to worry about interoperability and only expect small numbers.\n  Int:\n    model:\n      - github.com/99designs/gqlgen/graphql.Int32\n  Int64:\n    model:\n      - github.com/99designs/gqlgen/graphql.Int\n      - github.com/99designs/gqlgen/graphql.Int64\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Enum with Collisions - Example C - State A\nDESCRIPTION: This GraphQL snippet provides the enum as defined in Example C. It highlights the impact of enum order on the resolved output. The order of the enum elements directly impacts the outcome of the generated Go code, which the examples in this document also showcase.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/name-collision.md#_snippet_8\n\nLANGUAGE: graphql\nCODE:\n```\n# graphql\n\nenum MyEnum {\n  value\n  Value\n}\n```\n\n----------------------------------------\n\nTITLE: Skipping Directive Publication in gqlgen.yml (YAML)\nDESCRIPTION: This YAML fragment configures gqlgen to prevent the constraint directive from being published during introspection by setting skip_runtime:true for the directive. This ensures that certain validation directives or metadata remain server-side only. It must be included in gqlgen.yml if privacy over directive publication is required.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/modelgen-hook.md#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\ndirectives:\n  constraint:\n    skip_runtime: true\n\n```\n\n----------------------------------------\n\nTITLE: Binding Mismatched Fields Using gqlgen Configuration\nDESCRIPTION: Provides an alternative method for mapping mismatched field names by explicitly defining the mapping in the gqlgen configuration file using the `fields` property under the model definition. This maps the GraphQL `state` field to the Go `LongState` field.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/resolvers.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\ntype Car struct {\n    Make string\n    ShortState string\n    LongState string\n    Model string\n    Color string\n    OdometerReading int\n}\n```\n\nLANGUAGE: GraphQL\nCODE:\n```\ntype Car {\n    make: String!\n    model: String!\n    state: String!\n    color: String!\n    odometerReading: Int!\n}\n```\n\nLANGUAGE: YAML\nCODE:\n```\nmodels:\n    Car:\n        model: github.com/my/app/models.Car\n        fields:\n            state:\n                fieldName: LongState\n```\n\n----------------------------------------\n\nTITLE: GraphQL Mutation for Multiple File Upload\nDESCRIPTION: Defines a GraphQL mutation `multipleUpload` that accepts a list of required files (`[Upload!]!`). This allows uploading multiple files in a single mutation call. It returns the `id` for each uploaded file in the list.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/fileupload/readme.md#_snippet_7\n\nLANGUAGE: GraphQL\nCODE:\n```\n{\n  query: `\n    mutation($files: [Upload!]!) {\n      multipleUpload(files: $files) {\n        id\n      }\n    }\n  `,\n  variables: {\n    files: [\n      File, // b.txt\n      File  // c.txt\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Schema for Model Generation (GraphQL)\nDESCRIPTION: This GraphQL schema defines an Object type with two fields, demonstrating the structure that will be targeted by the Go code generation and tag mutation processes. No dependencies are required beyond a standard GraphQL environment. Usage: This schema is used as input for gqlgen to generate Go structs.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/modelgen-hook.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\ntype Object {\n\tfield1: String\n\tfield2: Int\n}\n\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Schema with Interface and Union\nDESCRIPTION: A GraphQL schema defining an interface, a type implementing that interface, and a union type that includes the concrete type.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/field-collection.md#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\ninterface Shape {\n    area: Float\n}\ntype Circle implements Shape {\n    radius: Float\n    area: Float\n}\nunion Shapes = Circle\n```\n\n----------------------------------------\n\nTITLE: GraphQL Mutation for Single File Upload with Payload\nDESCRIPTION: Defines a GraphQL mutation `singleUploadWithPayload` that accepts an `UploadFile!` input object. This object allows combining a file upload (`file` field) with other data (`id` field). It returns details about the processed item.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/fileupload/readme.md#_snippet_4\n\nLANGUAGE: GraphQL\nCODE:\n```\n{\n  query: `\n    mutation($file: Upload!) {\n      singleUpload(file: $file) {\n        id\n      }\n    }\n  `,\n  variables: {\n    file: File // a.txt\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding extensions and defining middleware in gqlgen handler in Go\nDESCRIPTION: This snippet illustrates configuring a gqlgen server with extension points such as AroundFields, AroundOperations, and AroundResponses using inline functions. These middleware functions intercept and wrap around field resolution, operation execution, and response delivery, enabling custom logic or instrumentation at each stage.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/migration-0.11.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nsrv := handler.New(es)\nsrv.AroundFields(func(ctx context.Context, next graphql.Resolver) (res interface{}, err error) {\n\t// Called around every field\n\treturn next(ctx)\n})\nsrv.AroundOperations(func(ctx context.Context, next graphql.OperationHandler) graphql.ResponseHandler {\n\t// Called around every operation\n\treturn next(ctx)\n})\nsrv.AroundResponses(func(ctx context.Context, next graphql.ResponseHandler) *graphql.Response {\n\t// Called around each response\n\treturn next(ctx)\n})\n```\n\n----------------------------------------\n\nTITLE: Running the Star Wars GraphQL Server in Go\nDESCRIPTION: This code snippet shows how to execute the Star Wars GraphQL server written in Go. It involves running the server program located at './server/server.go' using the Go command, enabling local testing and development. No dependencies or additional setup steps are explicitly described beyond executing the command.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/starwars/readme.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngo run ./server/server.go\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Query with Fragments\nDESCRIPTION: A sample GraphQL query that demonstrates field selection with fragments and type conditions.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/field-collection.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\nquery {\n    foo {\n        fieldA\n        ... on Bar {\n            fieldB\n        }\n        ... on Baz {\n            fieldC\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple File Upload Request Payload Example\nDESCRIPTION: Illustrates the multipart/form-data payload for uploading multiple files. The `operations` and `map` parts define the mutation and map multiple file parts (identified by `0`, `1`, etc.) to indices within the `variables.files` array.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/fileupload/readme.md#_snippet_9\n\nLANGUAGE: plain text\nCODE:\n```\n--------------------------d7aca2a93c3655e0\nContent-Disposition: form-data; name=\"operations\"\n\n{ \"query\": \"mutation($files: [Upload!]!) { multipleUpload(files: $files) { id, name, content } }\", \"variables\": { \"files\": [null, null] } }\n--------------------------d7aca2a93c3655e0\nContent-Disposition: form-data; name=\"map\"\n\n{ \"0\": [\"variables.files.0\"], \"1\": [\"variables.files.1\"] }\n--------------------------d7aca2a93c3655e0\nContent-Disposition: form-data; name=\"0\"; filename=\"b.txt\"\nContent-Type: text/plain\n\nBravo file content.\n--------------------------d7aca2a93c3655e0\nContent-Disposition: form-data; name=\"1\"; filename=\"c.txt\"\nContent-Type: text/plain\n\nCharlie file content.\n--------------------------d7aca2a93c3655e0--\n```\n\n----------------------------------------\n\nTITLE: Binding Fields from Embedded Go Structs\nDESCRIPTION: Explains that fields from an embedded Go struct (like `Car` within `Truck`) are automatically considered for binding to the corresponding GraphQL type (`Truck`), following the same binding rules as non-embedded fields.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/resolvers.md#_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\ntype Truck struct {\n    Car\n\n    Is4x4 bool\n}\n\ntype Car struct {\n    Make string\n    ShortState string\n    LongState string\n    Model string\n    Color string\n    OdometerReading int\n}\n```\n\nLANGUAGE: GraphQL\nCODE:\n```\ntype Truck {\n    make: String!\n    model: String!\n    state: String!\n    color: String!\n    odometerReading: Int!\n    is4x4: Bool!\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a new GraphQL server with multiple transports in Go\nDESCRIPTION: This code snippet demonstrates initializing a new GraphQL server instance and configuring it with various transports including WebSocket, GET, POST, MultipartForm, UrlEncodedForm, and GRAPHQL. These transports handle different incoming HTTP request types, allowing flexible client interactions.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/migration-0.11.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nsrv := New(es)\n\nsrv.AddTransport(transport.Websocket{\n\tKeepAlivePingInterval: 10 * time.Second,\n})\nsrv.AddTransport(transport.Options{})\nsrv.AddTransport(transport.GET{})\nsrv.AddTransport(transport.POST{})\nsrv.AddTransport(transport.MultipartForm{})\nsrv.AddTransport(transport.UrlEncodedForm{})\nsrv.AddTransport(transport.GRAPHQL{})\n```\n\n----------------------------------------\n\nTITLE: cURL Request for Single File Upload\nDESCRIPTION: Demonstrates how to send a single file upload request to the gqlgen server using cURL. It utilizes the multipart/form-data content type, mapping the file `a.txt` to the `variables.file` parameter in the GraphQL mutation.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/fileupload/readme.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncurl localhost:8087/query \\\n  -F operations='{ \"query\": \"mutation ($file: Upload!) { singleUpload(file: $file) { id, name, content } }\", \"variables\": { \"file\": null } }' \\\n  -F map='{ \"0\": [\"variables.file\"] }' \\\n  -F 0=@./_examples/fileupload./testfiles/a.txt\n```\n\n----------------------------------------\n\nTITLE: Applying Gin Context Middleware in Router Configuration\nDESCRIPTION: Code snippet showing how to apply the Gin context middleware in the router setup.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/gin.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nr.Use(GinContextToContextMiddleware())\n```\n\n----------------------------------------\n\nTITLE: Setting Up Project Directory and Go Module - Shell\nDESCRIPTION: Creates the project directory and initializes it as a Go module. This step bootstraps a new Go workspace and prepares it for dependency tracking and further development. It requires the Go SDK to be installed and network access to fetch dependencies. Run these commands from your preferred terminal.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/getting-started.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nmkdir gqlgen-todos\ncd gqlgen-todos\ngo mod init github.com/[username]/gqlgen-todos\n```\n\n----------------------------------------\n\nTITLE: Implementing Name Resolver in Go (gqlgen)\nDESCRIPTION: This snippet defines the resolver for the `Name` field. It takes a context and a `customresolver.Resolver` object as input, and returns a string and an error. This implementation is a placeholder and returns an empty string and a nil error. The comment indicates the location where the actual implementation should reside.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/plugin/resolvergen/testdata/followschema/out/schema.resolvers.go.txt#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nfunc (r *resolverCustomResolverType) Name(ctx context.Context, obj *customresolver.Resolver) (string, error) {\n\t// CustomerResolverType.Name implementation\n\treturn \"\", nil\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Boolean Scalar Example in Go\nDESCRIPTION: This Go code demonstrates creating a custom scalar implementation for handling booleans, including marshalling and unmarshalling functions using `graphql.Marshaler` and `graphql.Unmarshaler` and supporting different input types such as strings, integers and booleans.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/scalars.md#_snippet_13\n\nLANGUAGE: go\nCODE:\n```\npackage mypkg\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\n\t\"github.com/99designs/gqlgen/graphql\"\n)\n\n\nfunc MarshalMyCustomBooleanScalar(b bool) graphql.Marshaler {\n\treturn graphql.WriterFunc(func(w io.Writer) {\n\t\tif b {\n\t\t\tw.Write([]byte(\"true\"))\n\t\t} else {\n\t\t\tw.Write([]byte(\"false\"))\n\t\t}\n\t})\n}\n\nfunc UnmarshalMyCustomBooleanScalar(v interface{}) (bool, error) {\n\tswitch v := v.(type) {\n\tcase string:\n\t\treturn \"true\" == strings.ToLower(v), nil\n\tcase int:\n\t\treturn v != 0, nil\n\tcase bool:\n\t\treturn v, nil\n\tdefault:\n\t\treturn false, fmt.Errorf(\"%T is not a bool\", v)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Federation Example GraphQL Schema - GraphQL\nDESCRIPTION: This GraphQL schema defines the federated model including Review, User, and Product types using Apollo Federation directives like @provides, @key, and @external. It exposes extension points for both User and Product with federated key fields and relationships, supporting catalog and review services.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/federation.md#_snippet_3\n\nLANGUAGE: GraphQL\nCODE:\n```\ntype Review {\n  body: String\n  author: User @provides(fields: \"username\")\n  product: Product\n}\n\nextend type User @key(fields: \"id\") {\n  id: ID! @external # External directive not required for key fields in federation v2\n  reviews: [Review]\n}\n\nextend type Product @key(fields: \"upc\") {\n  upc: String! @external # External directive not required for key fields in federation v2\n  reviews: [Review]\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Getter Generation in gqlgen.yml Configuration - YAML\nDESCRIPTION: This yaml option for gqlgen disables automatic generation of getter methods on interfaces, which may be unsuitable for certain complex or connection types. Input: boolean setting. Output: Generated code without interface getters. Limitations: defaults to 'false', disabling may change access patterns.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/_introduction.md#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\nomit_getters: true\n```\n\n----------------------------------------\n\nTITLE: Defining UUID Scalar in GraphQL\nDESCRIPTION: Defines a `UUID` scalar mapping to a `uuid.UUID` type in Go.  It also references a configuration change in `gqlgen.yml` to enable the mapping.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/scalars.md#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\nscalar UUID\n```\n\n----------------------------------------\n\nTITLE: Implementing Resolver for Query Field in Go (gqlgen)\nDESCRIPTION: This snippet implements the `Resolver` field resolver for the `queryCustomResolverType`. It takes a context as input and returns a pointer to a `customresolver.Resolver` and an error.  It uses named return values and is designed to be automatically regenerated. The `err` variable can be used to return errors within the resolver.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/plugin/resolvergen/testdata/followschema/out/schema.resolvers.go.txt#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\nfunc (r *queryCustomResolverType) Resolver(ctx context.Context) (_ *customresolver.Resolver, err error) {\n\t// Named return values are supported.\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Go Code from Example C - State B\nDESCRIPTION: This Go code shows how a simple reordering of enum values leads to the values associated with the Go constants changing. Even though the constant names remain the same, their mapped values change. This demonstrates the need to be cautious about schema modification and the impact of the enum order.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/name-collision.md#_snippet_11\n\nLANGUAGE: go\nCODE:\n```\n// golang\n\ntype MyEnum string\n\nconst (\n\tMyEnumValue  = \"Value\"\n\tMyEnumValue0 = \"value\"\n)\n```\n\n----------------------------------------\n\nTITLE: Returning multiple GraphQL errors as a gqlerror.List in Go\nDESCRIPTION: This Go snippet illustrates returning multiple errors from a GraphQL resolver by collecting and returning a gqlerror.List, which allows returning several errors simultaneously. It shows appending wrapped existing errors, formatted errors, and fully customized errors with extensions to the list. The error list is then returned from the resolver. Dependencies are gqlgen packages github.com/99designs/gqlgen/graphql and github.com/vektah/gqlparser/v2/gqlerror. This approach provides ordered, rich error data to the GraphQL client.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/errors.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage foo\n\nimport (\n\t\"context\"\n\t\"errors\"\n\n\t\"github.com/vektah/gqlparser/v2/gqlerror\"\n\t\"github.com/99designs/gqlgen/graphql\"\n)\n\nvar errSomethingWrong = errors.New(\"some validation failed\")\n\n// DoThingsReturnMultipleErrors collect errors and returns it if any.\nfunc (r Query) DoThingsReturnMultipleErrors(ctx context.Context) (bool, error) {\n\terrList := gqlerror.List{}\n\n\t// Add existing error\n\terrList = append(errList, gqlerror.Wrap(errSomethingWrong))\n\n\t// Create new formatted and append\n\terrList = append(errList, gqlerror.Errorf(\"invalid value: %s\", \"invalid\"))\n\n\t// Or fully customize the error and append\n\terrList = append(errList, &gqlerror.Error{\n\t\tPath:       graphql.GetPath(ctx),\n\t\tMessage:    \"A descriptive error message\",\n\t\tExtensions: map[string]interface{}{\n\t\t\t\"code\": \"10-4\",\n\t\t},\n\t})\n\n\treturn false, errList\n}\n```\n\n----------------------------------------\n\nTITLE: Example Generated Go Struct with Extra Fields by gqlgen\nDESCRIPTION: An example of the Go struct generated by gqlgen when extra fields are configured. The User struct includes ID and Name fields from the schema plus the additional Session field with its custom tag. This struct is used internally in the Go service and the extra field is not exposed to GraphQL clients.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/extra_fields.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.\n\ntype User struct {\n\tID   string\n\tName string\n\t// A Session used by this user.\n\tSession mypkg.Session `xml:\"session\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Upload Struct in Go\nDESCRIPTION: This Go struct defines the structure used for the `Upload` scalar.  It consists of file data, file name, size, and content type.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/scalars.md#_snippet_6\n\nLANGUAGE: go\nCODE:\n```\ntype Upload struct {\n\tFile        io.ReadSeeker\n\tFilename    string\n\tSize        int64\n\tContentType string\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ResolverResolver in Go (gqlgen)\nDESCRIPTION: This snippet implements the `Resolver` resolver for the `CustomResolverType`.  It returns an instance of `resolverCustomResolverType`. This acts as a factory or a bridge to the underlying resolver resolvers.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/plugin/resolvergen/testdata/followschema/out/schema.resolvers.go.txt#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\nfunc (r *CustomResolverType) Resolver() customresolver.ResolverResolver {\n\treturn &resolverCustomResolverType{r}\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Go Code with Collisions\nDESCRIPTION: This Go code snippet shows how the GraphQL enum from the previous example might be transpiled. It demonstrates the conflict that arises from naming conventions, where multiple enum values map to identical constant names, causing compilation errors.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/name-collision.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// golang\n\ntype MyEnum string\n\nconst (\n\tMyEnumValue1 MyEnum = \"value1\"\n\tMyEnumValue2 MyEnum = \"value2\"\n\tMyEnumValue3 MyEnum = \"value3\"\n\tMyEnumValue4 MyEnum = \"value4\"\n\tMyEnumValue4 MyEnum = \"Value4\"\n\tMyEnumValue4 MyEnum = \"Value_4\"\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Any Scalar in GraphQL\nDESCRIPTION: Defines a `Any` GraphQL scalar. It maps an arbitrary GraphQL value to a Go `interface{}` type.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/scalars.md#_snippet_7\n\nLANGUAGE: graphql\nCODE:\n```\nscalar Any\n```\n\n----------------------------------------\n\nTITLE: Defining Helper Function in Go\nDESCRIPTION: This code defines a helper function, `AUserHelperFunction`.  It contains a comment to show where the function's implementation will be added.  This is a general-purpose function and doesn't depend on gqlgen directly, although it could be used within the resolvers.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/plugin/resolvergen/testdata/followschema/out/schema.resolvers.go.txt#_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\nfunc AUserHelperFunction() {\n\t// AUserHelperFunction implementation\n}\n```\n\n----------------------------------------\n\nTITLE: Running GraphQL Server using Go\nDESCRIPTION: This command utilizes the Go runtime to compile and execute the server code located in the `./server` directory, specifically the `server.go` file. This starts the GraphQL server instance, typically making it accessible via a local network address and port.\n\nPrerequisites: A working Go installation and the project source code available.\nInput: Execution of the command in a terminal or command prompt.\nOutput: The GraphQL server starts and runs, potentially outputting logs or status messages to the console.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/selection/readme.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngo run ./server/server.go\n```\n\n----------------------------------------\n\nTITLE: Installing the 'vikstrous/dataloadgen' Go Package\nDESCRIPTION: Shows the bash command to install the external dataloadgen library which facilitates creating dataloaders for batching and caching database calls in Go.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/dataloaders.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngo get github.com/vikstrous/dataloadgen\n```\n\n----------------------------------------\n\nTITLE: Implementing GetMany Entity Resolver for MultiHello in Go\nDESCRIPTION: This Go code snippet illustrates the function signature generated by the gqlgen federation plugin when the `@entityResolver(multi: true)` directive is applied to a GraphQL entity like `MultiHello`. This `FindManyMultiHellosByName` function, part of an `entityResolver` type, takes a context and a slice of input representations (`reps`) and is expected to return a slice of the resolved entity objects or an error. The logic to fetch entities based on the provided representations goes inside this function.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/plugin/federation/readme.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nfunc (r *entityResolver) FindManyMultiHellosByName(ctx context.Context, reps []*generated.ManyMultiHellosByNameInput) ([]*generated.MultiHello, error) {\n  /// <Your code to resolve the list of items>\n}\n```\n\n----------------------------------------\n\nTITLE: Adding gqlgen as a Tool Dependency - Go\nDESCRIPTION: Defines a Go file for tool dependencies to ensure gqlgen is properly tracked in go.mod. This file uses build tags and blank imports. No inputs or outputs; simply tracks the tool for reproducible builds. Place it in your project and run 'go mod tidy' after editing.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/getting-started.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//go:build tools\n\npackage tools\n\nimport (\n\t_ \"github.com/99designs/gqlgen\"\n)\n```\n\n----------------------------------------\n\nTITLE: Applying Changesets Using mapstructure in Go with Custom DecodeHook\nDESCRIPTION: Implements an ApplyChanges function that reflects over a map[string]interface{} to update a target Go struct, using the mapstructure library. A custom DecodeHook supports proper handling of gqlgen unmarshaling for custom scalars. Required dependencies: the mapstructure and reflect packages, as well as conforming types for schema and custom scalars. Takes 'changes' map and a destination object pointer as parameters and returns an error if decoding fails.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/changesets.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc ApplyChanges(changes map[string]interface{}, to interface{}) error {\n\tdec, err := mapstructure.NewDecoder(&mapstructure.DecoderConfig{\n\t\tErrorUnused: true,\n\t\tTagName:     \"json\",\n\t\tResult:      to,\n\t\tZeroFields:  true,\n\t\t// This is needed to get mapstructure to call the gqlgen unmarshaler func for custom scalars (eg Date)\n\t\tDecodeHook: func(a reflect.Type, b reflect.Type, v interface{}) (interface{}, error) {\n\t\t\tif reflect.PtrTo(b).Implements(reflect.TypeOf((*graphql.Unmarshaler)(nil)).Elem()) {\n\t\t\t\tresultType := reflect.New(b)\n\t\t\t\tresult := resultType.MethodByName(\"UnmarshalGQL\").Call([]reflect.Value{reflect.ValueOf(v)})\n\t\t\t\terr, _ := result[0].Interface().(error)\n\t\t\t\treturn resultType.Elem().Interface(), err\n\t\t\t}\n\n\t\t\treturn v, nil\n\t\t},\n\t})\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn dec.Decode(changes)\n}\n```\n\n----------------------------------------\n\nTITLE: gqlgen.yml configuration to use custom User model\nDESCRIPTION: YAML configuration snippet mapping the GraphQL User type to a custom Go model, enabling type safety and customized data handling without altering the schema. This configuration is essential for integrating custom models into the generated code.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/README.md#_snippet_5\n\nLANGUAGE: YAML\nCODE:\n```\n# gqlgen.yml\nmodels:\n  User:\n    model: github.com/you/pkg/model.User\n```\n\n----------------------------------------\n\nTITLE: Running the Compiled Server Application - Bash\nDESCRIPTION: This command starts the compiled 'server' executable, launching the GraphQL server locally. No additional arguments are required; output provides a URL (http://localhost:8080/) for accessing the GraphQL playground. The server binary must exist in the current or specified directory, and the appropriate ports must be open and available.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/websocket-initfunc/server/readme.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./server\n```\n\n----------------------------------------\n\nTITLE: Providing Query Resolver Implementation Go\nDESCRIPTION: Returns an instance of the `customresolver.QueryResolver` interface implementation. This method is part of the main `CustomResolverType` struct and is used by gqlgen to delegate the resolution of Query fields to the specific `queryCustomResolverType` instance, which typically embeds the main resolver struct to access shared dependencies.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/plugin/resolvergen/testdata/filetemplate/out/schema.custom.go.txt#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nfunc (r *CustomResolverType) Query() customresolver.QueryResolver { return &queryCustomResolverType{r} }\n```\n\n----------------------------------------\n\nTITLE: Integrating Authentication Middleware into GraphQL Server Setup in Go\nDESCRIPTION: Shows how to incorporate the created authentication middleware into a GraphQL server routing setup with Chi router. The snippet demonstrates wrapping the router with middleware, setting up GraphQL schema and handlers, and starting the HTTP server. This structure ensures that user context is available during GraphQL request processing.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/authentication.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/99designs/gqlgen/_examples/starwars\"\n\t\"github.com/99designs/gqlgen/graphql/handler\"\n\t\"github.com/99designs/gqlgen/graphql/handler/transport\"\n\t\"github.com/99designs/gqlgen/graphql/playground\"\n\t\"github.com/go-chi/chi\"\n)\n\nfunc main() {\n\trouter := chi.NewRouter()\n\n\t// Inject authentication middleware\n\trouter.Use(auth.Middleware(db))\n\n\t// Create GraphQL server with schema and resolvers\n\tsrv := handler.New(starwars.NewExecutableSchema(starwars.NewResolver()))\n\n\t// Add POST transport\n\tsrv.AddTransport(transport.POST{})\n\n\t// Set route handlers\n\trouter.Handle(\"/\", playground.Handler(\"Starwars\", \"/query\"))\n\trouter.Handle(\"/query\", srv)\n\n\t// Start server\n\terr := http.ListenAndServe(\":8080\", router)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining User Helper Function Go\nDESCRIPTION: Defines a user-added helper function named `AUserHelperFunction`. This function is not automatically generated by gqlgen and serves a custom purpose within the resolver logic. It has no parameters and no return values. The current implementation is a placeholder.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/plugin/resolvergen/testdata/filetemplate/out/schema.custom.go.txt#_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\nfunc AUserHelperFunction() {\n\t// AUserHelperFunction implementation\n}\n```\n\n----------------------------------------\n\nTITLE: Running React Client with apollo-link-ws Implementation\nDESCRIPTION: Command to start the React client using the apollo-link-ws implementation, which relies on the deprecated subscriptions-transport-ws library for WebSocket communication.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/chat/readme.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run start\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Resolver Structs Go\nDESCRIPTION: Defines helper structs used to implement resolver methods for specific GraphQL types (Query and the custom Resolver type) within the main `CustomResolverType`. These structs (`queryCustomResolverType` and `resolverCustomResolverType`) typically embed the main resolver type to provide access to shared dependencies or configuration across different resolver methods.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/plugin/resolvergen/testdata/filetemplate/out/schema.custom.go.txt#_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\ntype queryCustomResolverType struct{ *CustomResolverType }\ntype resolverCustomResolverType struct{ *CustomResolverType }\n```\n\n----------------------------------------\n\nTITLE: Applying Built-in gqlgen Directives to GraphQL Types\nDESCRIPTION: This GraphQL schema snippet demonstrates how to apply the built-in gqlgen directives (`@goModel`, `@goField`, `@goTag`, `@goExtraField`) to GraphQL types and fields. They influence code generation, such as mapping `User` to a specific Go struct (`github.com/my/app/models.User`), renaming the `id` field in the generated Go model, adding struct tags, and forcing resolver generation for `name`.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/config.md#_snippet_2\n\nLANGUAGE: GraphQL\nCODE:\n```\ntype User\n\t@goModel(model: \"github.com/my/app/models.User\")\n\t@goExtraField(name: \"Activated\", type: \"bool\") {\n\tid: ID! @goField(name: \"todoId\")\n\tname: String!\n\t\t@goField(forceResolver: true)\n\t\t@goTag(key: \"xorm\", value: \"-\")\n\t\t@goTag(key: \"yaml\")\n}\n\n# This make sense when autobind activated.\ntype Person @goModel(forceGenerate: true) {\n\tid: ID!\n\tname: String!\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing the gqlgen error presenter hook in Go\nDESCRIPTION: This Go snippet shows how to override gqlgen's default error presenter by configuring the GraphQL server with a custom error presenter function using server.SetErrorPresenter. This function receives the resolver context and error, allowing modification of the error message or other properties before sending it to the client. It shows using errors.As to detect a custom error type and modify the message accordingly, while otherwise delegating to the default error presenter. Dependencies include github.com/99designs/gqlgen/graphql/handler for server creation and gqlerror for error types.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/errors.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage bar\n\nimport (\n\t\"context\"\n\t\"errors\"\n\n\t\"github.com/vektah/gqlparser/v2/gqlerror\"\n\t\"github.com/99designs/gqlgen/graphql\"\n\t\"github.com/99designs/gqlgen/graphql/handler\"\n)\n\nfunc main() {\n\tserver := handler.New(MakeExecutableSchema(resolvers))\n\n\t// Server setup...\n\n\tserver.SetErrorPresenter(func(ctx context.Context, e error) *gqlerror.Error {\n\t\terr := graphql.DefaultErrorPresenter(ctx, e)\n\n\t\tvar myErr *MyError\n\t\tif errors.As(e, &myErr) {\n\t\t\terr.Message = \"Eeek!\"\n\t\t}\n\n\t\treturn err\n\t})\n}\n```\n\n----------------------------------------\n\nTITLE: Remapping ID type from String to Integer in gqlgen\nDESCRIPTION: YAML configuration that remaps the GraphQL ID scalar to an integer type in Go by specifying multiple underlying types. This allows IDs to be represented as integers in code, enhancing type safety and consistency.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/README.md#_snippet_9\n\nLANGUAGE: YAML\nCODE:\n```\nmodels:\n  ID:\n    model:\n      - github.com/99designs/gqlgen/graphql.IntID\n      - github.com/99designs/gqlgen/graphql.ID\n      - github.com/99designs/gqlgen/graphql.UintID\n```\n\n----------------------------------------\n\nTITLE: Implementing QueryResolver in Go (gqlgen)\nDESCRIPTION: This snippet implements the `Query` resolver for the `CustomResolverType`. It returns an instance of `queryCustomResolverType`. It acts as a factory or a bridge to the underlying query resolvers.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/plugin/resolvergen/testdata/followschema/out/schema.resolvers.go.txt#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nfunc (r *CustomResolverType) Query() customresolver.QueryResolver { return &queryCustomResolverType{r} }\n```\n\n----------------------------------------\n\nTITLE: Setting a panic recovery function in gqlgen GraphQL server in Go\nDESCRIPTION: This Go snippet demonstrates configuring gqlgen's panic handler by setting a custom recovery function on the GraphQL server using server.SetRecoverFunc. The function receives the context and the panic value, allowing the developer to notify bug trackers or log details before returning a sanitized gqlerror to the client. Returned errors from this function also pass through the error presenter. This handler prevents server crashes during panics, improving production stability.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/errors.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nserver := handler.New(MakeExecutableSchema(resolvers))\n\n// Server setup...\n\nserver.SetRecoverFunc(func(ctx context.Context, err interface{}) error {\n    // Notify bug tracker...\n\n\treturn gqlerror.Errorf(\"Internal server error!\")\n})\n```\n\n----------------------------------------\n\nTITLE: cURL Command: Single File Upload\nDESCRIPTION: Demonstrates a cURL command to perform a single file upload to a GraphQL endpoint. It uses multipart form data with the `operations`, `map`, and file data.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/file-upload.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl localhost:4000/graphql \\\n  -F operations='{ \"query\": \"mutation ($file: Upload!) { singleUpload(file: $file) }\", \"variables\": { \"file\": null } }' \\\n  -F map='{ \"0\": [\"variables.file\"] }' \\\n  -F 0=@a.txt\n```\n\n----------------------------------------\n\nTITLE: Subscribing to new comments using GraphQL Subscription\nDESCRIPTION: This GraphQL subscription allows clients to receive real-time updates when new comments are added to a specific post.  It specifies the post ID to subscribe to and retrieves the ID, text, author ID, and creation date of each new comment.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/mini-habr-with-subscriptions/README.md#_snippet_8\n\nLANGUAGE: GraphQL\nCODE:\n```\nsubscription {\n    commentAdded(postID: 1) {\n        id\n        text\n        authorID\n        createDate\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditionally Enabling GraphQL Introspection via Environment Variable in Go (gqlgen)\nDESCRIPTION: Shows how to enable GraphQL introspection only in specific environments (e.g., 'development') by checking an environment variable (`os.Getenv(\"ENVIRONMENT\")`) before adding the `extension.Introspection{}` middleware. Depends on the `os` package and `github.com/99designs/gqlgen/graphql/handler/extension`.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/introspection.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nsrv := handler.New(es)\n\n// Server setup...\n\nif os.Getenv(\"ENVIRONMENT\") == \"development\" {\n    srv.Use(extension.Introspection{})\n}\n```\n\n----------------------------------------\n\nTITLE: cURL Request for Single File Upload with Payload\nDESCRIPTION: Shows how to upload a single file (`a.txt`) as part of a complex input object (`UploadFile!`) using cURL. The `map` parameter correctly points the file content to the nested `variables.req.file` field within the input object.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/fileupload/readme.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ncurl localhost:8087/query \\\n  -F operations='{ \"query\": \"mutation ($req: UploadFile!) { singleUploadWithPayload(req: $req) { id, name, content } }\", \"variables\": { \"req\": {\"file\": null, \"id\": 1 } } }' \\\n  -F map='{ \"0\": [\"variables.req.file\"] }' \\\n  -F 0=@./_examples/fileupload/testfiles/a.txt\n```\n\n----------------------------------------\n\nTITLE: Setting Up GraphQL and Playground Handlers with Gin in Go\nDESCRIPTION: Comprehensive setup of a GraphQL server using Gin and gqlgen, including imports, handler definitions, and router configuration. Configures various transports and extensions for the GraphQL server.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/gin.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"github.com/[username]/gqlgen-todos/graph\"\t// Replace username with your github username\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/vektah/gqlparser/v2/ast\"\n\n\t\"github.com/99designs/gqlgen/graphql/handler\"\n\t\"github.com/99designs/gqlgen/graphql/handler/extension\"\n\t\"github.com/99designs/gqlgen/graphql/handler/lru\"\n\t\"github.com/99designs/gqlgen/graphql/handler/transport\"\n\t\"github.com/99designs/gqlgen/graphql/playground\"\n)\n\n// Defining the Graphql handler\nfunc graphqlHandler() gin.HandlerFunc {\n\t// NewExecutableSchema and Config are in the generated.go file\n\t// Resolver is in the resolver.go file\n\th := handler.New(graph.NewExecutableSchema(graph.Config{Resolvers: &graph.Resolver{}}))\n\n\t// Server setup:\n\th.AddTransport(transport.Options{})\n\th.AddTransport(transport.GET{})\n\th.AddTransport(transport.POST{})\n\n\th.SetQueryCache(lru.New[*ast.QueryDocument](1000))\n\n\th.Use(extension.Introspection{})\n\th.Use(extension.AutomaticPersistedQuery{\n\t\tCache: lru.New[string](100),\n\t})\n\n\treturn func(c *gin.Context) {\n\t\th.ServeHTTP(c.Writer, c.Request)\n\t}\n}\n\n// Defining the Playground handler\nfunc playgroundHandler() gin.HandlerFunc {\n\th := playground.Handler(\"GraphQL\", \"/query\")\n\n\treturn func(c *gin.Context) {\n\t\th.ServeHTTP(c.Writer, c.Request)\n\t}\n}\n\nfunc main() {\n\t// Setting up Gin\n\tr := gin.Default()\n\tr.POST(\"/query\", graphqlHandler())\n\tr.GET(\"/\", playgroundHandler())\n\tr.Run()\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for React Client\nDESCRIPTION: Command to install the required npm dependencies for the React client application before running it with any of the supported WebSocket implementations.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/chat/readme.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Building the Go application in the Dockerfile\nDESCRIPTION: This instruction in the Dockerfile compiles the Go application and creates an executable named `main`.  The optional `-s m` flag can be added to use in-memory storage instead of PostgreSQL for testing purposes.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/mini-habr-with-subscriptions/README.md#_snippet_2\n\nLANGUAGE: Dockerfile\nCODE:\n```\nRUN go build -o main ./cmd/main.go\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Schema for Posts and Related Posts in GraphQL\nDESCRIPTION: Defines the root Query type and Post type in GraphQL, including the ability to list posts and recursively query related posts. The 'posts' and 'related' fields take an integer 'count' parameter (default 10) to limit the number of results. This schema enables the demonstration of exponential response growth via recursive traversal of related posts. Requires a GraphQL server and resolvers supporting these fields and types. Inputs: 'count' for pagination; Outputs: arrays of Post objects with 'title', 'text', and nested related posts.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/complexity.md#_snippet_0\n\nLANGUAGE: GraphQL\nCODE:\n```\ntype Query {\n  posts(count: Int = 10): [Post!]!\n}\n\ntype Post {\n  title: String!\n  text: String!\n  related(count: Int = 10): [Post!]!\n}\n```\n\n----------------------------------------\n\nTITLE: Querying GraphQL Server with cURL and Bash\nDESCRIPTION: This snippet demonstrates a cURL command used to query the GraphQL server. It sends a POST request to the `/query` endpoint with a GraphQL query in the request body. The query retrieves the ID, text, state, and verified fields of todos. The server is expected to return the data matching the provided query in a JSON format.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/type-system-extension/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -X POST 'http://localhost:8080/query' --data-binary '{\"query\":\"{ todos { id text state verified } }\"}'\n```\n\n----------------------------------------\n\nTITLE: Example Generated Go Struct with Inline @goExtraField Extensions\nDESCRIPTION: Shows the Go struct generated by gqlgen after parsing the @goExtraField directives inline in the schema. The User struct inherits all base fields, plus embedded and named extra fields such as Session, Activated, and an embedded time.Time type. Tags and comments are included as specified in the directives.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/extra_fields.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\ntype User struct {\n  ID   string\n  Name string\n  // A Session used by this user.\n  Session   mypkg.Session `xml:\"session\"`\n  Activated bool\n  time.Time\n}\n```\n\n----------------------------------------\n\nTITLE: Configuration to disable gqlgen panic handler forcing crash behavior in YAML\nDESCRIPTION: This YAML snippet configures gqlgen to omit the panic handler, which disables graceful panic recovery and allows the program to crash normally. This is useful during development for generating core dumps and debugging panics more effectively. Setting omit_panic_handler to true causes gqlgen to not recover from panics internally.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/errors.md#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nomit_panic_handler: true\n```\n\n----------------------------------------\n\nTITLE: Running a GraphQL Server with Go\nDESCRIPTION: This snippet shows the command needed to run the GraphQL server. It uses the `go run` command to execute the server application which is assumed to be located in the specified directory path. The server starts on port 8080, which also hosts the GraphQL playground.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/type-system-extension/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ngo run ./server/server.go\n```\n\n----------------------------------------\n\nTITLE: Generated GraphQL Schema Example - GraphQL\nDESCRIPTION: Defines the types and operations for the GraphQL API, including Todo and User types, Query and Mutation entry points, and an input type for creating todos. This schema must be saved as a .graphqls file and drives gqlgen's code generation. Inputs are requests via the API; outputs are returned as defined by the schema.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/getting-started.md#_snippet_4\n\nLANGUAGE: graphql\nCODE:\n```\ntype Todo {\n  id: ID!\n  text: String!\n  done: Boolean!\n  user: User!\n}\n\ntype User {\n  id: ID!\n  name: String!\n}\n\ntype Query {\n  todos: [Todo!]!\n}\n\ninput NewTodo {\n  text: String!\n  userId: String!\n}\n\ntype Mutation {\n  createTodo(input: NewTodo!): Todo!\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling getters in generated interfaces for gqlgen\nDESCRIPTION: Configuration setting to omit automatically generated getter methods on GraphQL interface types, giving developers more control over interfaces and implementation details.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/README.md#_snippet_10\n\nLANGUAGE: YAML\nCODE:\n```\n# gqlgen.yml\nomit_getters: true\n```\n\n----------------------------------------\n\nTITLE: Creating a new post using GraphQL Mutation\nDESCRIPTION: This GraphQL mutation creates a new post with the provided input, including the author ID, title, text content, and comment enablement status.  It then retrieves the ID, title, and creation date of the newly created post.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/mini-habr-with-subscriptions/README.md#_snippet_6\n\nLANGUAGE: GraphQL\nCODE:\n```\nmutation {\n    addPost(postInput: {\n        authorID: \"a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11\"\n        title: \"New post\"\n        text: \"Post content\"\n        commentsEnabled: true\n    }) {\n        id\n        title\n        createDate\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Mismatched Fields Using Go Struct Tags\nDESCRIPTION: Shows how to use Go struct tags (e.g., `gqlgen:\"state\"`) to map a Go struct field (`LongState`) to a GraphQL field with a different name (`state`). This requires enabling the `struct_tag` option in the gqlgen configuration file.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/resolvers.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\ntype Car struct {\n    Make string\n    ShortState string\n    LongState string `gqlgen:\"state\"`\n    Model string\n    Color string\n    OdometerReading int\n}\n```\n\nLANGUAGE: GraphQL\nCODE:\n```\ntype Car {\n    make: String!\n    model: String!\n    state: String!\n    color: String!\n    odometerReading: Int!\n}\n```\n\nLANGUAGE: YAML\nCODE:\n```\nstruct_tag: gqlgen\n\nmodels:\n    Car:\n        model: github.com/my/app/models.Car\n```\n\n----------------------------------------\n\nTITLE: Launching the application using Docker Compose\nDESCRIPTION: This command uses Docker Compose to build and start the application containers defined in the `docker-compose.yml` file.  This sets up the necessary environment for the application to run.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/mini-habr-with-subscriptions/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker-compose up\n```\n\n----------------------------------------\n\nTITLE: Declaring the @hasRole directive and Role enum in GraphQL schema\nDESCRIPTION: Defines the @hasRole directive to restrict field access based on user roles, and the Role enum listing possible roles. The directive is applicable to field definitions, enabling role-based authorization in GraphQL schemas.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/directives.md#_snippet_0\n\nLANGUAGE: GraphQL\nCODE:\n```\ndirective @hasRole(role: Role!) on FIELD_DEFINITION\n\nenum Role {\n    ADMIN\n    USER\n}\n```\n\n----------------------------------------\n\nTITLE: Apollo Client Configuration for File Upload\nDESCRIPTION: Shows how to configure Apollo Client for file uploads using `apollo-upload-client`. It involves importing `ApolloClient` and `createUploadLink`, and then initializing the client with the upload link.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/file-upload.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport ApolloClient from \"apollo-client\";\nimport { createUploadLink } from \"apollo-upload-client\";\n\nconst client = new ApolloClient({\n\tcache: new InMemoryCache(),\n\tlink: createUploadLink({ uri: \"/graphql\" })\n});\n```\n\n----------------------------------------\n\nTITLE: Cloning the Repository using Git\nDESCRIPTION: This command clones the specified Git repository to your local machine, allowing you to access the project's source code and related files.  The `cd` command then navigates to the newly cloned directory.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/mini-habr-with-subscriptions/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/nabishec/ozon_habr_api.git\ncd ozon_habr_api\n```\n\n----------------------------------------\n\nTITLE: Implementing the @hasRole directive in Go server setup\nDESCRIPTION: Shows how to assign the logic of the @hasRole directive within the GraphQL server configuration. The function checks the current user's role, blocking access if insufficient permissions, or passing control to the next resolver otherwise.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/directives.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nfunc main() {\n\tc := Config{ Resolvers: &resolvers{} }\n\tc.Directives.HasRole = func(ctx context.Context, obj interface{}, next graphql.Resolver, role Role) (interface{}, error) {\n\t\tif !getCurrentUser(ctx).HasRole(role) {\n\t\t\t// block calling the next resolver\n\t\t\treturn nil, fmt.Errorf(\"Access denied\")\n\t\t}\n\n\t\t// or let it pass through\n\t\treturn next(ctx)\n\t}\n\n\tsrv := handler.New(NewExecutableSchema(c))\n\tsrv.AddTransport(transport.POST{})\n\n\thttp.Handle(\"/query\", srv)\n\tlog.Fatal(http.ListenAndServe(\":8081\", nil))\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Go Enums for Typed and Untyped Binding\nDESCRIPTION: This snippet defines Go enum types for typed (`EnumTyped`) and untyped (`EnumUntyped`) binding. Constants for each enum are declared, supporting the binding of enum values to specific models or literals within the application.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/enum.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage model\n\ntype EnumTyped int\n\nconst (\n\tEnumTypedOne EnumTyped = iota + 1\n\tEnumTypedTwo\n)\n\nconst (\n\tEnumUntypedOne = iota + 1\n\tEnumUntypedTwo\n)\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Enum with Collisions - Example C\nDESCRIPTION: Example C showcases a GraphQL enum definition with two values that could easily result in a naming conflict when transposing to Go code. It aims to illustrate the process of handling name collisions when the values are very similar, leading to the use of an appended number to ensure uniqueness.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/name-collision.md#_snippet_6\n\nLANGUAGE: graphql\nCODE:\n```\n# graphql\n\nenum MyEnum {\n  value\n  Value\n}\n```\n\n----------------------------------------\n\nTITLE: Running the gqlgen Release Script in Bash\nDESCRIPTION: Executes the release script located in the bin directory, passing the new version number as an argument. This script automates part of the release process.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/RELEASE-CHECKLIST.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./bin/release $NEW_VERSION\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Enum with Collisions\nDESCRIPTION: This GraphQL snippet defines an enum with multiple values that could lead to naming collisions when translated into Go code. The enum illustrates the problem by including values that would, when converted to Go const names, potentially conflict with each other.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/name-collision.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\n# graphql\n\nenum MyEnum {\n  value1\n  value2\n  value3\n  value4\n  Value4\n  Value_4\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Global GraphQL Introspection in Go (gqlgen)\nDESCRIPTION: Demonstrates how to enable GraphQL introspection for the entire gqlgen server by adding the `extension.Introspection{}` middleware. Requires importing `github.com/99designs/gqlgen/graphql/handler` for `handler.New` and `github.com/99designs/gqlgen/graphql/handler/extension` for `extension.Introspection`. This allows clients to query the schema.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/introspection.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\nsrv := handler.New(es)\n\n// Add server setup.\nsrv.AddTransport(transport.Options{})\nsrv.AddTransport(transport.POST{})\n\n// Add the introspection middleware.\nsrv.Use(extension.Introspection{})\n```\n\n----------------------------------------\n\nTITLE: Generated Go Code from Example C - State A\nDESCRIPTION: This Go snippet is the result of transposing the enum into code. It shows the same values from the schema that create the same constants, as the order of the definition is consistent. This demonstrates that even with reordering of the schema, the const names remain identical.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/name-collision.md#_snippet_9\n\nLANGUAGE: go\nCODE:\n```\n// golang\n\ntype MyEnum string\n\nconst (\n\tMyEnumValue  = \"value\"\n\tMyEnumValue0 = \"Value\"\n)\n```\n\n----------------------------------------\n\nTITLE: Starting the gqlgen GraphQL server\nDESCRIPTION: Command to run the server.go file, which starts the GraphQL server. It assumes that the previous steps generated the server setup and models, allowing the server to be tested and used.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\ngo run server.go\n```\n\n----------------------------------------\n\nTITLE: Remapping the GraphQL ID Scalar to Custom Go Types in gqlgen.yml - YAML\nDESCRIPTION: This yaml snippet configures how gqlgen should map the GraphQL ID scalar to Go types. Allows for IDs as int, string, or uint types by specifying alternative model paths. Input: GraphQL ID occurrences. Output: Code and resolver arguments using the selected Go type. Limitation: The first listed model acts as default in code generation and resolver signatures.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/_introduction.md#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\nmodels:\n  ID: # The GraphQL type ID is backed by\n    model:\n      - github.com/99designs/gqlgen/graphql.IntID # a go integer\n      - github.com/99designs/gqlgen/graphql.ID # or a go string\n      - github.com/99designs/gqlgen/graphql.UintID # or a go uint\n```\n\n----------------------------------------\n\nTITLE: Running Go Subgraphs for gqlgen Federation\nDESCRIPTION: Command to compile and run the Go application located in the `./all/` directory, which starts the federation subgraphs. This step is necessary before starting the gateway for testing and allows for debugging the Go processes.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/federation/readme.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ go run ./all/main.go\n```\n\n----------------------------------------\n\nTITLE: Starting the Federation Gateway using npm\nDESCRIPTION: Command to execute the 'start-gateway' script defined in the project's `package.json` file using npm. This starts the federation gateway, which requires the Go subgraphs (started previously) to be running.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/federation/readme.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ npm run start-gateway\n```\n\n----------------------------------------\n\nTITLE: Defining Federation Entity with GetMany Resolver in GraphQL\nDESCRIPTION: This GraphQL schema snippet defines a custom directive `@entityResolver` with a `multi` argument and applies it to the `MultiHello` object type. The `multi: true` argument is used by the gqlgen federation plugin to indicate that a `GetMany` style resolver should be generated for this entity. The `@key(fields: \"name\")` directive marks `MultiHello` as a federated entity identifiable by its `name` field.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/plugin/federation/readme.md#_snippet_0\n\nLANGUAGE: GraphQL\nCODE:\n```\ndirective @entityResolver(multi: Boolean) on OBJECT\n\ntype MultiHello @key(fields: \"name\") @entityResolver(multi: true) {\n    name: String!\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Gin Framework in Go\nDESCRIPTION: Command to install the Gin web framework using Go modules.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/recipes/gin.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/gin-gonic/gin\n```\n\n----------------------------------------\n\nTITLE: Using Embedded Structs as Wrappers for Data Access Types\nDESCRIPTION: Demonstrates a pattern using embedded structs to create thin wrappers around data access types (e.g., embedding `db.Cat`). This allows adding or overriding resolver logic, like creating a custom `ID` method, while still leveraging the underlying data structure. The corresponding model configuration in `gqlgen.yml` is shown.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/resolvers.md#_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\ntype Cat struct {\n    db.Cat\n    //...\n}\n\nfunc (c *Cat) ID() string {\n    // return a custom id based on the db shard and the cat's id\n     return fmt.Sprintf(\"%d:%d\", c.Shard, c.Id)\n}\n```\n\nLANGUAGE: YAML\nCODE:\n```\nmodels:\n    Cat:\n        model: github.com/my/app/models.Cat\n```\n\n----------------------------------------\n\nTITLE: Querying all posts with GraphQL\nDESCRIPTION: This GraphQL query retrieves a list of all posts from the API, including their IDs, titles, text content, author IDs, comment enablement status, and creation dates. It demonstrates basic data retrieval using GraphQL.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/mini-habr-with-subscriptions/README.md#_snippet_4\n\nLANGUAGE: GraphQL\nCODE:\n```\nquery{\n    posts{\n        id\n        title \n        text\n        authorID\n        commentsEnabled\n        createDate\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Single File Upload with Payload Request Payload Example\nDESCRIPTION: Illustrates the multipart/form-data payload for uploading a single file nested within a larger input object. The `map` and `operations` parts reflect the structure, referencing the file via `variables.req.file`, followed by the file content part.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/fileupload/readme.md#_snippet_6\n\nLANGUAGE: plain text\nCODE:\n```\n--------------------------38752760889d14aa\nContent-Disposition: form-data; name=\"operations\"\n\n{ \"query\": \"mutation ($req: UploadFile!) { singleUploadWithPayload(req: $req) { id, name, content } }\", \"variables\": { \"req\": {\"file\": null, \"id\": 1 } } }\n--------------------------38752760889d14aa\nContent-Disposition: form-data; name=\"map\"\n\n{ \"0\": [\"variables.req.file\"] }\n--------------------------38752760889d14aa\nContent-Disposition: form-data; name=\"0\"; filename=\"a.txt\"\nContent-Type: text/plain\n\nAlpha file content.\n--------------------------38752760889d14aa--\n```\n\n----------------------------------------\n\nTITLE: Creating a new comment using GraphQL Mutation\nDESCRIPTION: This GraphQL mutation creates a new comment associated with a specific post and parent comment (for replies).  It requires the author ID, post ID, parent ID (can be the post ID itself for top-level comments), and the comment text. The mutation returns the ID, text, and parent ID of the created comment.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/mini-habr-with-subscriptions/README.md#_snippet_7\n\nLANGUAGE: GraphQL\nCODE:\n```\nmutation {\n    addComment(commentInput: {\n        authorID: \"123e4567-e89b-12d3-a456-426614174000\",\n        postID: 1,\n        parentID: 1, # ID of existing comment\n        text: \"This is a reply to comment 1\"\n    }) {\n        id\n        text\n        parentID\n    }   \n}\n```\n\n----------------------------------------\n\nTITLE: Building the Go application with in-memory storage\nDESCRIPTION: This instruction in the Dockerfile compiles the Go application and creates an executable named `main`.  The `-s m` flag is added to use in-memory storage instead of PostgreSQL for testing purposes.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/mini-habr-with-subscriptions/README.md#_snippet_3\n\nLANGUAGE: Dockerfile\nCODE:\n```\nRUN go build -o main ./cmd/main.go -s m\n```\n\n----------------------------------------\n\nTITLE: Running React Client with graphql-sse Implementation\nDESCRIPTION: Command to start the React client using the graphql-sse implementation, which utilizes Server-Sent Events (SSE) instead of WebSockets for subscription data.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/chat/readme.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm run start:graphql-sse\n```\n\n----------------------------------------\n\nTITLE: Running gqlgen Go Server for Integration Testing - Bash\nDESCRIPTION: Starts the gqlgen server implemented in Go which serves as the backend during integration testing. This command must be run first to allow the client test suite to connect and verify operations. It requires Go to be installed and the server source code available at the specified path.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/integration/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngo run server/cmd/integration/server.go\n```\n\n----------------------------------------\n\nTITLE: Initializing gqlgen project and generating models\nDESCRIPTION: Commands to initialize gqlgen configuration and generate code based on schema. This setup creates the necessary configuration files and models, enabling rapid development of GraphQL servers with type safety and boilerplate reduction.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\ngo run github.com/99designs/gqlgen init\ngo mod tidy\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies and Running Apollo Client Integration Tests - Bash\nDESCRIPTION: Navigates to the integration test directory, installs necessary npm dependencies using 'npm ci', and executes the test script via 'npm run test'. This runs the Apollo client test suite that connects to the running gqlgen server to validate end-to-end GraphQL connectivity. Requires npm and Node.js installed.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/integration/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd integration\nnpm ci\nnpm run test\n```\n\n----------------------------------------\n\nTITLE: Initializing Go Module and setting up gqlgen dependencies\nDESCRIPTION: Steps to create a new Go module, add gqlgen as a dependency, and set up tools.go for managing tool dependencies. This sequence prepares the project environment for using gqlgen by initializing the module, managing dependencies, and installing necessary tools.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nmkdir example\ncd example\ngo mod init example\n```\n\nLANGUAGE: Shell\nCODE:\n```\nprintf '//go:build tools\\npackage tools\\nimport (_ \"github.com/99designs/gqlgen\"\\n _ \"github.com/99designs/gqlgen/graphql/introspection\")' | gofmt > tools.go\ngo mod tidy\n```\n\n----------------------------------------\n\nTITLE: Implementing Resolver Type Field Go\nDESCRIPTION: Defines the resolver function for the 'Name' field within the 'resolverCustomResolverType'. This function is called to resolve the 'Name' field on objects of the custom Resolver type. It takes a context and the parent object (an instance of customresolver.Resolver) and is expected to return a string and an error. The current implementation is a placeholder.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/plugin/resolvergen/testdata/filetemplate/out/schema.custom.go.txt#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nfunc (r *resolverCustomResolverType) Name(ctx context.Context, obj *customresolver.Resolver) (string, error) {\n\t// CustomerResolverType.Name implementation\n\treturn \"\", nil\n}\n```\n\n----------------------------------------\n\nTITLE: GraphQL schema snippet defining User type with friends relationship\nDESCRIPTION: Schema definition illustrating a recursive User type with a friends field. This example demonstrates nested or recursive schema design, where users can have a list of friends, and highlights the need for custom resolvers or models to optimize data fetching.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/README.md#_snippet_3\n\nLANGUAGE: GraphQL\nCODE:\n```\ntype User {\n\tid: ID!\n\tname: String!\n\tfriends: [User!]!\n}\n```\n\n----------------------------------------\n\nTITLE: Binding GraphQL Fields to Go Struct Methods\nDESCRIPTION: Illustrates binding a GraphQL field to a method defined on the corresponding Go struct. When the 'owner' field is requested in GraphQL, the 'Owner' method on the 'Car' struct is called. The method can optionally accept a context as its first argument for parallel execution.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/resolvers.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\ntype Person struct {\n    Name string\n}\n\ntype Car struct {\n    Make string\n    Model string\n    Color string\n    OwnerID *string\n    OdometerReading int\n}\n\nfunc (c *Car) Owner() (*Person) {\n    // get the car owner\n    //....\n    return owner\n}\n```\n\nLANGUAGE: GraphQL\nCODE:\n```\ntype Car {\n    make: String!\n    model: String!\n    color: String!\n    odometerReading: Int!\n    owner: Person\n}\n```\n\nLANGUAGE: YAML\nCODE:\n```\nmodels:\n    Car:\n        model: github.com/my/app/models.Car\n    Person:\n        model: github.com/my/app/models.Person\n```\n\n----------------------------------------\n\nTITLE: Implementing a GraphQL Field Resolver in Go\nDESCRIPTION: This Go function implements the resolver logic for the 'friends' field on the User type. Inputs: a context, the User object. Output: a list of User pointers and error. Dependencies: matching GraphQL schema and configuration with resolver enabled. Key: customizes data fetching for nested/recursive fields.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/_introduction.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc (r *userResolver) Friends(ctx context.Context, obj *User) ([]*User, error) {\n  // select * from user where friendid = obj.ID\n  return friends,  nil\n}\n```\n\n----------------------------------------\n\nTITLE: GraphQL Schema: Multiple File Upload\nDESCRIPTION: Defines the GraphQL schema for multiple file uploads. It includes the `Upload` scalar, `File` type for the response, and `UploadFile` input type for the request. The `Mutation` has a `multipleUpload` field that accepts an array of `UploadFile`.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/file-upload.md#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\n\"The `Upload` scalar type represents a multipart file upload.\"\nscalar Upload\n\n\"The `File` type, represents the response of uploading a file.\"\ntype File {\n    id: Int!\n    name: String!\n    content: String!\n}\n\n\"The `UploadFile` type, represents the request for uploading a file with a certain payload.\"\ninput UploadFile {\n    id: Int!\n    file: Upload!\n}\n\n\"The `Query` type, represents all of the entry points into our object graph.\"\ntype Query {\n    ...\n}\n\n\"The `Mutation` type, represents all updates we can make to our data.\"\ntype Mutation {\n    multipleUpload(req: [UploadFile!]!): [File!]!\n}\n\n```\n\n----------------------------------------\n\nTITLE: Referencing Custom Model in gqlgen Configuration - YAML\nDESCRIPTION: This yaml fragment shows how to map the GraphQL User type to a custom Go struct. Dependency: the Go type must exist and be imported. Inputs: Go import path. Limitation: Model field must correctly map fields to SDL definition.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/_introduction.md#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nmodels:\n  User:\n    model: github.com/you/pkg/model.User # go import path to the User struct above\n```\n\n----------------------------------------\n\nTITLE: Explicit resolver configuration for nested fields\nDESCRIPTION: YAML snippet specifying that the friends field in User requires a resolver, enabling lazy loading or custom data fetching logic. This facilitates fine-grained control over data retrieval, especially for recursive or nested associations.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/README.md#_snippet_6\n\nLANGUAGE: YAML\nCODE:\n```\n# gqlgen.yml\nmodels:\n  User:\n    fields:\n      friends:\n        resolver: true\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Type with Nullable and Non-Nullable Fields\nDESCRIPTION: This GraphQL schema snippet defines a type `OmitEmptyJsonTagTest` with one non-nullable field (`ValueNonNil: String!`) and one nullable field (`Value: String`). This difference influences the JSON serialization behavior of generated Go models.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/model-generation.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\ntype OmitEmptyJsonTagTest {\n    ValueNonNil: String!\n    Value: String\n}\n```\n\n----------------------------------------\n\nTITLE: Error Response Example\nDESCRIPTION: Illustrates an example of a GraphQL error response from the unmarshalling process, which includes the error message and a path identifying the field where the error occurred. This path helps pinpoint the location of the error within the GraphQL query or mutation.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/scalars.md#_snippet_17\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"message\": \"email invalid\",\n  \"path\": [\n    \"updateUser\",\n    \"userInput\",\n    \"primaryContactDetails\",\n    \"email\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Using directives for optimizing nested data fetching\nDESCRIPTION: GraphQL schema with directives indicating that the friends field should be resolved explicitly. Directives provide a schema-based way to enforce resolver requirements and optimize data fetching strategies.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/README.md#_snippet_8\n\nLANGUAGE: GraphQL\nCODE:\n```\ntype User @goModel(model: \"github.com/you/pkg/model.User\") {\n  id: ID! @goField(name: \"todoId\")\n  friends: [User!]! @goField(forceResolver: true)\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Todos and Users GraphQL Query Example\nDESCRIPTION: An example GraphQL query fetching all todos and each todo's user name. Demonstrates the GraphQL request structure that triggers nested resolver calls leading to the N+1 problem.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/dataloaders.md#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\nquery { todos { user { name } } }\n```\n\n----------------------------------------\n\nTITLE: GraphQL schema for error example\nDESCRIPTION: This GraphQL schema defines the structure for an example demonstrating error handling during scalar unmarshalling. It includes an `Email` scalar and a nested input type.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/scalars.md#_snippet_15\n\nLANGUAGE: graphql\nCODE:\n```\nextend type Mutation{\n    updateUser(userInput: UserInput!): User!\n}\n\ninput UserInput {\n    name: String!\n    primaryContactDetails: ContactDetailsInput!\n    secondaryContactDetails: ContactDetailsInput!\n}\n\nscalar Email\n\ninput ContactDetailsInput {\n    email: Email!\n}\n```\n\n----------------------------------------\n\nTITLE: JavaScript Operation: Single File Upload\nDESCRIPTION: Illustrates the JavaScript operation equivalent of the cURL command for single file upload. It showcases the structure of the query and variables.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/docs/content/reference/file-upload.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  query: `\n    mutation($file: Upload!) {\n      singleUpload(file: $file)\n    }\n  `,\n  variables: {\n    file: File // a.txt\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running React Client with graphql-ws Implementation\nDESCRIPTION: Command to start the React client using the graphql-ws implementation with the newer graphql-transport-ws protocol for WebSocket communication.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/chat/readme.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm run start:graphql-transport-ws\n```\n\n----------------------------------------\n\nTITLE: Running the Go Server for Chat Application\nDESCRIPTION: Command to start the GraphQL server component of the chat application. The server handles GraphQL operations including subscriptions for real-time chat functionality.\nSOURCE: https://github.com/99designs/gqlgen/blob/master/_examples/chat/readme.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngo run ./server/server.go\n```"
  }
]