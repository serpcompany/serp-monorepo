[
  {
    "owner": "neondatabase",
    "repo": "neon",
    "content": "TITLE: Illustrating WAL Safekeeper and S3 Architecture in ASCII\nDESCRIPTION: ASCII diagram showing the architecture of Neon's WAL processing, where a primary node sends WAL to multiple WAL safekeepers and S3 for durability. The diagram visualizes how WAL is distributed across the system components.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/004-durability.md#2025-04-22_snippet_0\n\nLANGUAGE: ascii\nCODE:\n```\n                                +----------------+\n                        +-----> | WAL safekeeper |\n                        |       +----------------+\n                        |       +----------------+\n                        +-----> | WAL safekeeper |\n+------------+          |       +----------------+\n|  Primary   |          |       +----------------+\n| Processing | ---------+-----> | WAL safekeeper |\n|   Node     |          |       +----------------+\n+------------+          |       +----------------+\n            \\           +-----> | WAL safekeeper |\n             \\          |       +----------------+\n              \\         |       +----------------+\n               \\        +-----> | WAL safekeeper |\n                \\               +----------------+\n                 \\\n                  \\\n                   \\\n                    \\\n                     \\          +--------+\n                      \\         |        |\n                       +------> |   S3   |\n                                |        |\n                                +--------+\n```\n\n----------------------------------------\n\nTITLE: Creating Compute Releases Database Table Schema in SQL\nDESCRIPTION: SQL schema definition for the compute_releases table in the control plane. This table stores information about compute releases including revision, version, tag, status, manifest, and timestamps for tracking deployment history.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/038-independent-compute-release.md#2025-04-22_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE compute_releases (\n  -- Unique release ID\n  -- N.B. Revision won't by synchronized across all regions, because all control planes are technically independent\n  -- services. We have the same situation with Helm releases as well because they could be deployed and rolled back\n  -- independently in different clusters.\n  revision BIGSERIAL PRIMARY KEY,\n  -- Numeric version of the compute image, e.g. 9057\n  version BIGINT NOT NULL,\n  -- Compute image tag, e.g. `release-9057`\n  tag TEXT NOT NULL,\n  -- Current release status. Currently, it will be a simple enum\n  -- * `deployed` -- release is deployed and used for new compute starts.\n  --                 Exactly one release can have this status at a time.\n  -- * `superseded` -- release has been replaced by a newer one.\n  -- But we can always extend it in the future when we need more statuses\n  -- for more complex deployment strategies.\n  status TEXT NOT NULL,\n  -- Any additional metadata for compute in the corresponding release\n  manifest JSONB NOT NULL,\n  -- Timestamp when release record was created in the control plane database\n  created_at TIMESTAMP NOT NULL DEFAULT now(),\n  -- Timestamp when release deployment was finished\n  deployed_at TIMESTAMP\n);\n```\n\n----------------------------------------\n\nTITLE: Running Neon Database Locally\nDESCRIPTION: Series of commands to initialize and start a Neon database instance locally. Includes starting the pageserver, safekeeper, creating a tenant, and starting a PostgreSQL compute node.\nSOURCE: https://github.com/neondatabase/neon/blob/main/README.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# Create repository in .neon with proper paths to binaries and data\n# Later that would be responsibility of a package install script\n> cargo neon init\nInitializing pageserver node 1 at '127.0.0.1:64000' in \".neon\"\n\n# start pageserver, safekeeper, and broker for their intercommunication\n> cargo neon start\nStarting neon broker at 127.0.0.1:50051.\nstorage_broker started, pid: 2918372\nStarting pageserver node 1 at '127.0.0.1:64000' in \".neon\".\npageserver started, pid: 2918386\nStarting safekeeper at '127.0.0.1:5454' in '.neon/safekeepers/sk1'.\nsafekeeper 1 started, pid: 2918437\n\n# create initial tenant and use it as a default for every future neon_local invocation\n> cargo neon tenant create --set-default\ntenant 9ef87a5bf0d92544f6fafeeb3239695c successfully created on the pageserver\nCreated an initial timeline 'de200bd42b49cc1814412c7e592dd6e9' at Lsn 0/16B5A50 for tenant: 9ef87a5bf0d92544f6fafeeb3239695c\nSetting tenant 9ef87a5bf0d92544f6fafeeb3239695c as a default one\n\n# create postgres compute node\n> cargo neon endpoint create main\n\n# start postgres compute node\n> cargo neon endpoint start main\nStarting new endpoint main (PostgreSQL v14) on timeline de200bd42b49cc1814412c7e592dd6e9 ...\nStarting postgres at 'postgresql://cloud_admin@127.0.0.1:55432/postgres'\n\n# check list of running postgres instances\n> cargo neon endpoint list\n ENDPOINT  ADDRESS          TIMELINE                          BRANCH NAME  LSN        STATUS\n main      127.0.0.1:55432  de200bd42b49cc1814412c7e592dd6e9  main         0/16B5BA8  running\n```\n\n----------------------------------------\n\nTITLE: Creating Branch in Proposed Serverless Workflow\nDESCRIPTION: Command to create a branch in the proposed serverless workflow. This is simplified compared to the current workflow as it doesn't require explicit PostgreSQL instance creation and startup.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/007-serverless-on-laptop.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ neon branch heikki main\nbranching at end of WAL: 0/15ECF68\n```\n\n----------------------------------------\n\nTITLE: Running Basic Pytest Commands for Neon Tests\nDESCRIPTION: Commands for running all tests, specific test files, or tests with particular names using the pytest wrapper script.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/pytest\n./scripts/pytest test_pgbench.py\n./scripts/pytest -k bench\n```\n\n----------------------------------------\n\nTITLE: Illustrating WAL Flow from Compute Node to Pageservers via WAL Service\nDESCRIPTION: This ASCII diagram illustrates the flow of WAL data from the compute node through the WAL service to the pageservers. It shows the high-level architecture of the WAL service in the Neon database system.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/walservice.md#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n+--------------+              +------------------+\n|              |     WAL      |                  |\n| Compute node |  ----------> |   WAL Service    |\n|              |              |                  |\n+--------------+              +------------------+\n                                     |\n                                     |\n                                     | WAL\n                                     |\n                                     |\n                                     V\n                              +--------------+\n                              |              |\n                              | Pageservers  |\n                              |              |\n                              +--------------+\n```\n\n----------------------------------------\n\nTITLE: Installing Neon and Creating a PostgreSQL Instance\nDESCRIPTION: Demonstrates how to install Neon using Homebrew and create a new PostgreSQL instance using the Neon CLI.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/003-laptop-cli.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n> brew install pg-neon \n> neon pg create # creates pgdata with default pattern pgdata$i\n> neon pg list\nID            PGDATA        USED    STORAGE            ENDPOINT\nprimary1      pgdata1       0G      neon-local       localhost:5432\n```\n\n----------------------------------------\n\nTITLE: Defining Compute Settings Manifest Structure in YAML\nDESCRIPTION: Proposed structure for the compute/manifest.yaml file that defines PostgreSQL settings for compute nodes. It includes common settings for all versions, as well as version-specific configurations with separate sections for primary and replica nodes.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/038-independent-compute-release.md#2025-04-22_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\npg_settings:\n  # Common settings for primaries and secondaries of all versions.\n  common:\n    wal_log_hints: \"off\"\n    max_wal_size: \"1024\"\n\n  per_version:\n    14:\n      # Common settings for both replica and primary of version PG 14\n      common:\n        shared_preload_libraries: \"neon,pg_stat_statements,extension_x\"\n    15:\n      common:\n        shared_preload_libraries: \"neon,pg_stat_statements,extension_x\"\n      # Settings that should be applied only to\n      replica:\n        # Available only starting Postgres 15th\n        recovery_prefetch: \"off\"\n    # ...\n    17:\n      common:\n        # For example, if third-party `extension_x` is not yet available for PG 17\n        shared_preload_libraries: \"neon,pg_stat_statements\"\n      replica:\n        recovery_prefetch: \"off\"\n```\n\n----------------------------------------\n\nTITLE: Connecting to Neon Postgres and Running Queries\nDESCRIPTION: Example of connecting to the Neon Postgres instance using psql and running basic SQL queries to create a table and insert data.\nSOURCE: https://github.com/neondatabase/neon/blob/main/README.md#2025-04-22_snippet_9\n\nLANGUAGE: text\nCODE:\n```\n> psql -p 55432 -h 127.0.0.1 -U cloud_admin postgres\npostgres=# CREATE TABLE t(key int primary key, value text);\nCREATE TABLE\npostgres=# insert into t values(1,1);\nINSERT 0 1\npostgres=# select * from t;\n key | value\n-----+-------\n   1 | 1\n(1 row)\n```\n\n----------------------------------------\n\nTITLE: Installing and Starting Neon Local\nDESCRIPTION: Simple one-line command to install and start Neon using Cargo package manager\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/005-zenith_local.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo install neon && neon start\n```\n\n----------------------------------------\n\nTITLE: Depicting WAL Service with Multiple Safekeepers\nDESCRIPTION: This ASCII diagram shows the internal structure of the WAL service, consisting of multiple WAL safekeepers. Each safekeeper stores a copy of the WAL, and a consensus algorithm is used to manage the quorum for ensuring data durability.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/walservice.md#2025-04-22_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n  +-------------------------------------------+\n  | WAL Service                               |\n  |                                           |\n  |                                           |\n  |  +------------+                           |\n  |  | safekeeper |                           |\n  |  +------------+                           |\n  |                                           |\n  |  +------------+                           |\n  |  | safekeeper |                           |\n  |  +------------+                           |\n  |                                           |\n  |  +------------+                           |\n  |  | safekeeper |                           |\n  |  +------------+                           |\n  |                                           |\n  +-------------------------------------------+\n```\n\n----------------------------------------\n\nTITLE: S3 Remote Storage Configuration\nDESCRIPTION: Complete S3 remote storage configuration example including bucket settings, region configuration, and performance parameters.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/settings.md#2025-04-22_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[remote_storage]\n# Name of the bucket to connect to\nbucket_name = 'some-sample-bucket'\n\n# Name of the region where the bucket is located at\nbucket_region = 'eu-north-1'\n\n# A \"subfolder\" in the bucket, to use the same bucket separately by multiple pageservers at once.\n# Optional, pageserver uses entire bucket if the prefix is not specified.\nprefix_in_bucket = '/some/prefix/'\n\n# S3 API query limit to avoid getting errors/throttling from AWS.\nconcurrency_limit = 100\n```\n\n----------------------------------------\n\nTITLE: Building Neon and Patched Postgres on Linux\nDESCRIPTION: Commands to clone the Neon repository and build the project on Linux. Includes options for debug and release builds.\nSOURCE: https://github.com/neondatabase/neon/blob/main/README.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --recursive https://github.com/neondatabase/neon.git\ncd neon\n\n# The preferred and default is to make a debug build. This will create a\n# demonstrably slower build than a release build. For a release build,\n# use \"BUILD_TYPE=release make -j`nproc` -s\"\n# Remove -s for the verbose build log\n\nmake -j`nproc` -s\n```\n\n----------------------------------------\n\nTITLE: Initializing Neon Repository and Starting Page Server in Shell\nDESCRIPTION: Commands to create a new Neon repository and start the page server. This initializes the environment where PostgreSQL branches can be created.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/007-serverless-on-laptop.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ neon init\n...\ncreated main branch\nnew neon repository was created in .neon\n\n$ neon pageserver start\nStarting pageserver at '127.0.0.1:64000' in .neon\nPage server started\n```\n\n----------------------------------------\n\nTITLE: Propagating Errors in Rust Functions\nDESCRIPTION: Demonstrates the proper way to propagate errors to callers without logging them, using the ? operator to unwrap Results or propagate errors.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/error-handling.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn read_motd_file() -> std::io::Result<String> {\n    let mut f = File::open(\"/etc/motd\")?\n    let mut result = String::new();\n    f.read_to_string(&mut result)?;\n    result\n}\n```\n\n----------------------------------------\n\nTITLE: Describing Garbage Collection Process in Neon Database\nDESCRIPTION: Explains the garbage collection process in Neon's pageserver, which removes layers older than the GC horizon that are no longer needed. This helps manage disk space and improve overall system efficiency.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/012-background-tasks.md#2025-04-22_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n# Garbage collection\n\nRemove a layer that's older than the GC horizon, and isn't needed anymore.\n```\n\n----------------------------------------\n\nTITLE: Defining Safekeeper Timeline Pending Operations Table in Rust\nDESCRIPTION: This code snippet defines the schema for the 'safekeeper_timeline_pending_ops' table using Rust's diesel ORM. The table stores pending operations for safekeepers, including the operation type, timeline details, and generation number.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/035-safekeeper-dynamic-membership-change.md#2025-04-22_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\ntable! {\n    // timeline_id, sk_id is primary key\n    safekeeper_timeline_pending_ops (sk_id, tenant_id, timeline_id) {\n        sk_id -> int8,\n        tenant_id -> Varchar,\n        timeline_id -> Varchar,\n        generation -> Int4,\n        op_type -> Varchar,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Pre-commit Hook in Neon Project\nDESCRIPTION: Instructions for setting up a pre-commit hook that runs rustfmt and checks for Python files before each commit. The hook script is provided in pre-commit.py and needs to be linked to the git hooks directory.\nSOURCE: https://github.com/neondatabase/neon/blob/main/CONTRIBUTING.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nln -s ../../pre-commit.py .git/hooks/pre-commit\n```\n\n----------------------------------------\n\nTITLE: Initializing and Cloning Neon Repositories\nDESCRIPTION: Commands to initialize a new Neon repository and clone an existing one from a remote source.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/006-laptop-cli-v2-CLI.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nneon init\nneon clone neon://neon.tech/piedpiper/northwind -- clones a repo to the northwind directory\n```\n\n----------------------------------------\n\nTITLE: Describing Coalescing Process in Neon Database\nDESCRIPTION: Explains the coalescing process in Neon's pageserver, which replaces multiple consecutive layers of a segment with one larger layer. This reduces the number of small files that need to be uploaded to S3.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/012-background-tasks.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n# Coalescing\n\nReplace N consecutive layers of a segment with one larger layer.\n\n- To reduce the number of small files that needs to be uploaded to S3\n```\n\n----------------------------------------\n\nTITLE: Configuring AWS S3 Remote Storage for Backups in TOML\nDESCRIPTION: TOML configuration for setting up an AWS S3 bucket as remote storage for the backup service. Includes bucket name, region, and optional prefix within the bucket.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/pageserver-services.md#2025-04-22_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[remote_storage]\nbucket_name = 'some-sample-bucket'\nbucket_region = 'eu-north-1'\nprefix_in_bucket = '/test_prefix/'\n```\n\n----------------------------------------\n\nTITLE: Connecting to Neon PostgreSQL Database\nDESCRIPTION: Commands for connecting to a Neon compute node using psql and performing basic SQL operations. This snippet shows how to connect to the PostgreSQL instance and execute table creation and data insertion commands.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/docker.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ psql postgresql://cloud_admin:cloud_admin@localhost:55433/postgres\npsql (16.3)\nType \"help\" for help.\n\npostgres=# CREATE TABLE t(key int primary key, value text);\nCREATE TABLE\npostgres=# insert into t values(1, 1);\nINSERT 0 1\npostgres=# select * from t;\n key | value\n-----+-------\n   1 | 1\n(1 row)\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Starting PostgreSQL Instance on a Branch in Shell\nDESCRIPTION: Current workflow for creating a branch, initializing PostgreSQL on it, and starting the PostgreSQL server instance. This demonstrates the multi-step process that the proposal aims to simplify.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/007-serverless-on-laptop.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ neon branch heikki main\nbranching at end of WAL: 0/15ECF68\n\n$ neon pg create heikki\nInitializing Postgres on timeline 76cf9279915be7797095241638e64644...\nExtracting base backup to create postgres instance: path=.neon/pgdatadirs/pg1 port=55432\n\n$ neon pg start pg1\nStarting postgres node at 'host=127.0.0.1 port=55432 user=heikki'\nwaiting for server to start.... done\nserver started\n```\n\n----------------------------------------\n\nTITLE: Layer File History View from Child Branch Perspective\nDESCRIPTION: Shows the history of layer files for the 'orders' table from the child branch's perspective, including inherited files from the parent branch plus branch-specific files.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/pageserver-storage.md#2025-04-22_snippet_9\n\nLANGUAGE: markdown\nCODE:\n```\nmain/orders_100\nmain/orders_100_200\nmain/orders_200\nmain/orders_200_300\nchild/orders_250_300\nchild/orders_300\nchild/orders_300_400\nchild/orders_400\n```\n\n----------------------------------------\n\nTITLE: Visualizing Pageserver Architecture with ASCII Diagram\nDESCRIPTION: ASCII diagram showing the architecture of the Pageserver with its main components including Page Service, WAL Receiver, Backup Service, and various background processes. The diagram illustrates data flow between components and external systems.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/pageserver-services.md#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n                                           | WAL\n                                           V\n                                   +--------------+\n                                   |              |\n                                   | WAL receiver |\n                                   |              |\n                                   +--------------+\n                                                                                 ......\n                  +---------+                              +--------+            .    .\n                  |         |                              |        |            .    .\n GetPage@LSN      |         |                              | backup |  ------->  . S3 .\n------------->    |  Page   |         repository           |        |            .    .\n                  | Service |                              +--------+            .    .\n   page           |         |                                                    ......\n<-------------    |         |\n                  +---------+     +-----------+     +--------------------+\n                                  | WAL redo  |     | Checkpointing,     |\n                  +----------+    | processes |     | Garbage collection |\n                  |          |    +-----------+     +--------------------+\n                  |   HTTP   |\n                  | mgmt API |\n                  |          |\n                  +----------+\n\nLegend:\n\n+--+\n|  |   A thread or multi-threaded service\n+--+\n\n--->   Data flow\n<---\n```\n\n----------------------------------------\n\nTITLE: Defining Configuration Structure in Rust\nDESCRIPTION: Defines the data structure for safekeeper configurations, including generation number, current safekeeper set, and optional new safekeeper set. The presence of new_sk_set indicates a joint configuration used during membership transitions.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/035-safekeeper-dynamic-membership-change.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Configuration {\n    generation: Generation, // a number uniquely identifying configuration\n    sk_set: Vec<NodeId>, // current safekeeper set\n    new_sk_set: Optional<Vec<NodeId>>,\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Neon Environment with neon_env_builder\nDESCRIPTION: Demonstrates how to build a custom Neon Environment with specific configuration options like multiple safekeepers and JWT authentication. The environment is initialized and started using the neon_env_builder fixture.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/README.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndef test_foobar(neon_env_builder: NeonEnvBuilder):\n    # Prescribe the environment.\n    # We want to have 3 safekeeper nodes, and use JWT authentication in the\n    # connections to the page server\n    neon_env_builder.num_safekeepers = 3\n    neon_env_builder.set_pageserver_auth(True)\n\n    # Now create the environment. This initializes the repository, and starts\n    # up the page server and the safekeepers\n    env = neon_env_builder.init_start()\n\n    # Run the test\n    ...\n```\n\n----------------------------------------\n\nTITLE: Layer File Organization After Checkpoint with Selective Updates\nDESCRIPTION: Demonstrates how layer files are created after a checkpoint when only certain tables have been modified, showing incremental layer files only for the 'orders' table that has changes.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/pageserver-storage.md#2025-04-22_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\nmain/orders_100\nmain/orders_100_200\nmain/orders_200\nmain/orders_200_300\nmain/orders_300\nmain/orders_300_400\nmain/orders_400\nmain/customers_100\nmain/customers_100_200\nmain/customers_200\nmain/customers_200_500\nmain/customers_500\n```\n\n----------------------------------------\n\nTITLE: Implementing Leader Election Transaction in PostgreSQL\nDESCRIPTION: SQL transaction that provides compare-and-exchange semantics for updating the leader table. Uses REPEATABLE READ isolation level to prevent lost updates when multiple storage controllers attempt to become leader concurrently.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/037-storage-controller-restarts.md#2025-04-22_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nSTART TRANSACTION ISOLATION LEVEL REPEATABLE READ\nUPDATE leader SET hostname=<new_hostname>, start_timestamp=<new_start_ts>\nWHERE hostname=<old_hostname>, start_timestampt=<old_start_ts>;\n```\n\n----------------------------------------\n\nTITLE: Starting and Managing Neon Compute Nodes\nDESCRIPTION: Commands to start compute nodes for local and cloud-based Neon catalogs, including specifying ports and branches.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/006-laptop-cli-v2-CLI.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n-- here is how you a compute node\nneon start /home/pipedpiper/northwind:main -- starts a compute instance\nneon start neon://neon.tech/northwind:main -- starts a compute instance in the cloud\n-- you can start a compute node against any hash or branch\nneon start /home/pipedpiper/northwind:experimental --port 8008 -- start another compute instance (on different port)\n-- you can start a compute node against any hash or branch\nneon start /home/pipedpiper/northwind:<hash> --port 8009 -- start another compute instance (on different port)\n\n-- After running some DML you can run \n-- neon status and see how there are two WAL streams one on top of \n-- the main branch\nneon status \n-- and another on top of the experimental branch\nneon status -b experimental\n\n-- you can commit each branch separately\nneon commit main\n-- or\nneon commit -c /home/pipedpiper/northwind:experimental\n```\n\n----------------------------------------\n\nTITLE: Timeline Data Synchronization Locks Explanation\nDESCRIPTION: Explanation of key synchronization primitives including write_lock (Mutex<()>), layer_flush_lock (Mutex<()>), partitioning (Mutex<(KeyPartitioning, Lsn)>), gc_cs (Mutex<()>), layer_removal_cs (Mutex<()>), and file_lock (RwLock<()>). These locks manage concurrent access to timeline data, layer flushing, garbage collection, and compaction operations.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/017-timeline-data-management.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nwrite_lock: Mutex<()>           // Ensures serialized writes to in-memory layers\nlayer_flush_lock: Mutex<()>      // Controls layer creation and flushing\npartitioning: Mutex<(KeyPartitioning, Lsn)>  // Syncs timeline data state\ngc_cs: Mutex<()>                 // Prevents concurrent branching and GC\nlayer_removal_cs: Mutex<()>      // Serializes GC, compaction and deletion\nfile_lock: RwLock<()>           // Controls GC and compaction task lifecycle\n```\n\n----------------------------------------\n\nTITLE: Illustrating L0 Layer Structure in Pageserver\nDESCRIPTION: A visual representation of how L0 layers are organized in Neon's LSM tree variant. This shows stacked L0 layers covering entire page spaces at decreasing LSN ranges, demonstrating why they contribute to read amplification.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/pageserver-compaction.md#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n| Page 0-99 @ LSN 0400-04ff |\n| Page 0-99 @ LSN 0300-03ff |\n| Page 0-99 @ LSN 0200-02ff |\n| Page 0-99 @ LSN 0100-01ff |\n| Page 0-99 @ LSN 0000-00ff |\n```\n\n----------------------------------------\n\nTITLE: Diagram: Local Testing Environment Architecture\nDESCRIPTION: ASCII diagram illustrating the proposed architecture for local testing environment after implementing the control-plane service. It shows the relationships between various components including control-plane, storage, computes, and proxy.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/017-console-split.md#2025-04-22_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\n┌─────────────────────┐     ┌───────────────────────┐\n│                     │     │      Storage (local)  │\n│  control-plane db   │     │                       │\n│   (local process)   │     │ - safekeepers         │\n│                     │     │ - pageservers         │\n└──────────▲──────────┘     │                       │\n           │                │     Dependencies      │\n┌──────────┴──────────┐     │                       │\n│                     │     │ - etcd                │\n│    control-plane    ├────►│ - S3                  │\n│   (local process)   │     │ - more?               │\n│                     │     │                       │\n└──────────┬──────────┘     └───────────────────────┘\n       ▲   │                            ▲\n       │   │                            │\n       │   │                ┌───────────┴───────────┐\n       │   │                │                       │\n       │   └───────────────►│       computes        │\n       │                    │   (local processes)   │\n       │                    │                       │\n┌──────┴──────────────┐     └───────────────────────┘\n│                     │                 ▲\n│        proxy        │                 │\n│   (local process)   ├─────────────────┘\n│                     │\n└─────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Creating Timelines Table Schema in SQL\nDESCRIPTION: Defines the schema for the 'timelines' table, including fields for timeline and tenant IDs, LSN, generation, safekeeper sets, and deletion timestamp.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/035-safekeeper-dynamic-membership-change.md#2025-04-22_snippet_6\n\nLANGUAGE: sql\nCODE:\n```\ntable! {\n    // timeline_id is primary key\n    timelines (tenant_id, timeline_id) {\n        timeline_id -> Varchar,\n        tenant_id -> Varchar,\n        start_lsn -> pg_lsn,\n        generation -> Int4,\n        sk_set -> Array<Int4>, // list of safekeeper ids\n        new_sk_set -> Nullable<Array<Int8>>, // list of safekeeper ids, null if not joint conf\n        cplane_notified_generation -> Int4,\n        deleted_at -> Nullable<Timestamptz>,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Neon Cloud Environments\nDESCRIPTION: Commands to start compute instances against cloud environments, stream changes, and manage branches in the cloud.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/006-laptop-cli-v2-CLI.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n-- you can start a compute instance against the cloud environment\n-- in this case all of the changes will be streamed into the cloud\nneon start https://neon:tecj/pipedpiper/northwind:main\nneon start https://neon:tecj/pipedpiper/northwind:main\nneon status -c https://neon:tecj/pipedpiper/northwind:main\nneon commit -c https://neon:tecj/pipedpiper/northwind:main\nneon branch -c https://neon:tecj/pipedpiper/northwind:<hash> experimental\n```\n\n----------------------------------------\n\nTITLE: Creating PostgreSQL Instance from Remote Snapshot\nDESCRIPTION: Demonstrates creating a new PostgreSQL instance directly from a remote snapshot URL, combining the download and instantiation steps.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/003-laptop-cli.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n> neon pg create --snapshot basebackup://replication@localhost:5432/\nDownloading snapshot... Done.\nStarted postgres on localhost:5432\nDestroying snapshot... Done.\n```\n\n----------------------------------------\n\nTITLE: Read-Only Mode Relocation with Safety Measures in Mermaid\nDESCRIPTION: Sequence diagram showing a relocation approach using read-only mode on the target pageserver to ensure safe rollback if necessary. Background operations on the target only start after successful verification.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/023-the-state-of-pageserver-tenant-relocation.md#2025-04-22_snippet_3\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    participant CP as Control Plane\n    participant PS1 as Pageserver 1\n    participant PS2 as Pageserver 2\n    participant S3\n\n    CP->>PS1: Pause background jobs, pause uploading new layers.\n    CP->>PS2: Attach tenant X in remote readonly mode.\n    PS2->>S3: Fetch timelines, index\n    PS2->>CP: Accepted\n    CP->>CP: Monitor PS2 last record lsn, ensure OK lag\n    CP->>CP: Change pageserver id in project\n    CP->>CP: Run successful availability check\n    CP->>PS2: Start uploads, background tasks\n    CP->>PS1: Detach\n```\n\n----------------------------------------\n\nTITLE: Implementing Vectored Timeline Get Function in Rust\nDESCRIPTION: Example implementation showing the functional equivalent behavior of Timeline::get_vectored method that processes multiple keys in a batch operation. The method takes an LSN and array of KeyVec structs as input and returns a vector of reconstructed page images.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/030-vectored-timeline-get.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet mut keys_iter: impl Iterator<Item=Key>\n  = src.map(|KeyVec{ base, count }| (base..base+count)).flatten();\nlet mut out = Vec::new();\nfor key in keys_iter {\n    let data = Timeline::get(key, lsn)?;\n    out.push(data);\n}\nreturn out;\n```\n\n----------------------------------------\n\nTITLE: Configuring Pageserver Metadata JSON\nDESCRIPTION: Example metadata.json configuration for registering a pageserver with the storage controller. Specifies host and port settings for both postgres and HTTP API access.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/storage_controller.md#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\"host\":\"acmehost.localdomain\",\"http_host\":\"acmehost.localdomain\",\"http_port\":9898,\"port\":64000}\n```\n\n----------------------------------------\n\nTITLE: Initializing Empty Pageserver with Storage Configuration\nDESCRIPTION: Commands to initialize and start an empty pageserver with specified storage destination. Uses storage_dest parameter to define object storage type with other parameters passed via environment variables.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/009-snapshot-first-storage-cli.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nneon init --storage_dest=S3_PREFIX\nneon start\n```\n\n----------------------------------------\n\nTITLE: Launching PostgreSQL Instance with Neon Datadir\nDESCRIPTION: Command to start a PostgreSQL server using a specific data directory from the Neon repository structure. This allows direct access to a timeline without performing a traditional restore operation.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/006-laptop-cli-v2-repository-structure.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npostgres -D .neon/datadirs/4543be3daeab2ed4e58a285cbb8dd1fce6970f8c\n```\n\n----------------------------------------\n\nTITLE: Configuring Timeline State API Endpoint Request Body\nDESCRIPTION: JSON request body structure for the PUT endpoint to configure a timeline's state between active and archive.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/035-timeline-archive.md#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  'state': 'active|archive'\n}\n```\n\n----------------------------------------\n\nTITLE: Using neon_local CLI for Tenant Management in Neon\nDESCRIPTION: Examples of tenant management commands using the neon_local CLI tool, including listing tenants, creating tenants with generated or specified IDs, and creating PostgreSQL instances for specific tenants.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/multitenancy.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nneon_local tenant list\n\nneon_local tenant create // generates new id\n\nneon_local tenant create ee6016ec31116c1b7c33dfdfca38892f\n\nneon_local pg create main // default tenant from neon init\n\nneon_local pg create main --tenant_id=ee6016ec31116c1b7c33dfdfca38892f\n\nneon_local branch --tenant_id=ee6016ec31116c1b7c33dfdfca38892f\n```\n\n----------------------------------------\n\nTITLE: Creating a New Compute Release (JSON)\nDESCRIPTION: API payload for creating a new compute release with version, tag, and manifest information. The response includes additional details such as revision, status, and timestamps.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/038-independent-compute-release.md#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"version\": 9057,\n  \"tag\": \"release-9057\",\n  \"manifest\": {}\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"revision\": 53,\n  \"version\": 9057,\n  \"tag\": \"release-9057\",\n  \"status\": \"deployed\",\n  \"manifest\": {},\n  \"created_at\": \"2024-08-15T15:52:01.0000Z\",\n  \"deployed_at\": \"2024-08-15T15:52:01.0000Z\"\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Existing Snapshot to Neon\nDESCRIPTION: Commands to initialize and start Neon using an existing snapshot, specifying both the snapshot source and format, while configuring a different storage destination for future snapshots.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/009-snapshot-first-storage-cli.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nneon init --snapshot_path=FILE_PREFIX --snapshot_format=pgdata --storage_dest=S3_PREFIX\nneon start\n```\n\n----------------------------------------\n\nTITLE: Running Neon Pageserver Benchmark Tests\nDESCRIPTION: Command to execute pageserver throughput benchmark tests using pytest with specific environment configurations. Uses overlayfs for snapshots to improve iteration time and sets PostgreSQL version to 17 with release build type.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/performance/pageserver/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nRUST_BACKTRACE=1 NEON_ENV_BUILDER_USE_OVERLAYFS_FOR_SNAPSHOTS=1 DEFAULT_PG_VERSION=17 BUILD_TYPE=release \\\n    ./scripts/pytest test_runner/performance/pageserver/pagebench/test_pageserver_max_throughput_getpage_at_latest_lsn.py\n```\n\n----------------------------------------\n\nTITLE: Running Proxy with Testing Features (Bash)\nDESCRIPTION: Command to build and run the proxy binary with testing features enabled, configuring authentication backend and SSL certificates.\nSOURCE: https://github.com/neondatabase/neon/blob/main/proxy/README.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nRUST_LOG=proxy cargo run -p proxy --bin proxy --features testing -- --auth-backend postgres --auth-endpoint 'postgresql://postgres:proxy-postgres@127.0.0.1:5432/postgres' -c server.crt -k server.key\n```\n\n----------------------------------------\n\nTITLE: Defining Key Mapping for Sparse Keyspace\nDESCRIPTION: Illustrates the key mapping structure for the new sparse keyspace approach. It encodes relation information (spcnode, dbnode, relnode, forknum) into the key with a value indicating existence or deletion.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/041-rel-sparse-keyspace.md#2025-04-22_snippet_1\n\nLANGUAGE: plain\nCODE:\n```\n(REL_DIR_KEY_PREFIX, spcnode, dbnode, relnode, forknum, 1) -> deleted\n(REL_DIR_KEY_PREFIX, spcnode, dbnode, relnode, forknum, 1) -> exists\n```\n\n----------------------------------------\n\nTITLE: RemoteStorageKind Enum in Rust\nDESCRIPTION: Definition of the RemoteStorageKind enum in Rust code, showing the supported remote storage implementations.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/README.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\npub enum RemoteStorageKind {\n    /// Storage based on local file system.\n    /// Specify a root folder to place all stored files into.\n    LocalFs(Utf8PathBuf),\n    /// AWS S3 based storage, storing all files in the S3 bucket\n    /// specified by the config\n    AwsS3(S3Config),\n    /// Azure Blob based storage, storing all files in the container\n    /// specified by the config\n    AzureContainer(AzureConfig),\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Local Postgres Container for Testing (Bash)\nDESCRIPTION: Docker command to set up a local Postgres container for testing the proxy, specifying environment variables and port mapping.\nSOURCE: https://github.com/neondatabase/neon/blob/main/proxy/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker run \\\n  --detach \\\n  --name proxy-postgres \\\n  --env POSTGRES_PASSWORD=proxy-postgres \\\n  --publish 5432:5432 \\\n  postgres:17-bookworm\n```\n\n----------------------------------------\n\nTITLE: Connecting to PostgreSQL with PSQL in Current Workflow\nDESCRIPTION: Command to connect to the PostgreSQL instance using the psql command-line client in the current workflow. This connects to the manually started server.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/007-serverless-on-laptop.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ psql \"dbname=postgres port=55432\"\npsql (14devel)\nType \"help\" for help.\n\npostgres=# \n```\n\n----------------------------------------\n\nTITLE: Connecting to Neon using Connection URL in PostgreSQL\nDESCRIPTION: Shows the basic connection string format for connecting to a Neon PostgreSQL instance using a cluster ID. This connects to the primary instance on the 'main' branch by default.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/016-connection-routing.md#2025-04-22_snippet_1\n\nLANGUAGE: postgresql\nCODE:\n```\npostgres://<username>@<cluster-id>.db.neon.tech/<dbname>\n```\n\n----------------------------------------\n\nTITLE: Connecting to Neon with Advanced Options in PostgreSQL\nDESCRIPTION: Demonstrates how to connect to a specific branch and point-in-time using the 'options' parameter in the connection URL. This example connects to the 'testing' branch as it was on March 31, 2022.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/016-connection-routing.md#2025-04-22_snippet_2\n\nLANGUAGE: postgresql\nCODE:\n```\npostgres://alice@cluster-1234.db.neon.tech/postgres?options=branch:testing,timestamp:2022-03-31\n```\n\n----------------------------------------\n\nTITLE: JWT Token Header Structure in JSON\nDESCRIPTION: Example of the JWT token header used in Neon's authentication system, specifying the EdDSA algorithm as defined in RFC8037.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/authentication.md#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"alg\": \"EdDSA\",\n  \"typ\": \"JWT\"\n}\n```\n\n----------------------------------------\n\nTITLE: Compute Node State Diagram in Mermaid\nDESCRIPTION: A state diagram visualization showing the lifecycle states of a compute node, including Empty, Init, Running, Failed, and Terminated states along with their transitions.\nSOURCE: https://github.com/neondatabase/neon/blob/main/compute_tools/README.md#2025-04-22_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\n%% https://mermaid.js.org/syntax/stateDiagram.html\nstateDiagram-v2\n  [*] --> Empty : Compute spawned\n  Empty --> ConfigurationPending : Waiting for compute spec\n  ConfigurationPending --> Configuration : Received compute spec\n  Configuration --> Failed : Failed to configure the compute\n  Configuration --> Running : Compute has been configured\n  Empty --> Init : Compute spec is immediately available\n  Empty --> TerminationPending : Requested termination\n  Init --> Failed : Failed to start Postgres\n  Init --> Running : Started Postgres\n  Running --> TerminationPending : Requested termination\n  TerminationPending --> Terminated : Terminated compute\n  Failed --> [*] : Compute exited\n  Terminated --> [*] : Compute exited\n```\n\n----------------------------------------\n\nTITLE: WAL Record Format Modifications\nDESCRIPTION: Adds t_cid field to heap WAL records to support transaction tracking in Neon. Modifies WAL record format making it incompatible with vanilla PostgreSQL.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/core_changes.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nsrc/backend/access/heap/heapam.c                            |   26 +-\nsrc/include/access/heapam_xlog.h                            |    6 +-\n```\n\n----------------------------------------\n\nTITLE: Running Python Code Quality Checks\nDESCRIPTION: Commands to run code formatting (ruff), linting (ruff check), and type checking (mypy) on the Python codebase. These checks are mandatory for the project.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/sourcetree.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npoetry run ruff format . # All code is reformatted\npoetry run ruff check .  # Python linter\npoetry run mypy .        # Ensure there are no typing errors\n```\n\n----------------------------------------\n\nTITLE: Connecting to Neon using Link Auth in PostgreSQL\nDESCRIPTION: Demonstrates the connection string format for Link Auth authentication in Neon. This method provides a link for browser-based GitHub authentication.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/016-connection-routing.md#2025-04-22_snippet_0\n\nLANGUAGE: postgresql\nCODE:\n```\npostgres://<username>@start.neon.tech/<dbname>\n```\n\n----------------------------------------\n\nTITLE: Generating Ed25519 Key Pair Using OpenSSL\nDESCRIPTION: Bash commands used by the CLI during initialization to generate the Ed25519 key pair for JWT token signing and validation.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/authentication.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nopenssl genpkey -algorithm ed25519 -out auth_private_key.pem\nopenssl pkey -in auth_private_key.pem -pubout -out auth_public_key.pem\n```\n\n----------------------------------------\n\nTITLE: Current Console API Endpoints for Projects\nDESCRIPTION: Lists the existing HTTP API endpoints in the console service related to project management, database operations, and role management. These endpoints follow a pattern with project_id as the primary identifier.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/017-console-split.md#2025-04-22_snippet_1\n\nLANGUAGE: http\nCODE:\n```\nGET /projects/{project_id}\nPATCH /projects/{project_id}\nPOST /projects/{project_id}/branches\nGET /projects/{project_id}/databases\nPOST /projects/{project_id}/databases\nGET /projects/{project_id}/databases/{database_id}\nPUT /projects/{project_id}/databases/{database_id}\nDELETE /projects/{project_id}/databases/{database_id}\nPOST /projects/{project_id}/delete\nGET /projects/{project_id}/issue_token\nGET /projects/{project_id}/operations\nGET /projects/{project_id}/operations/{operation_id}\nPOST /projects/{project_id}/query\nGET /projects/{project_id}/roles\nPOST /projects/{project_id}/roles\nGET /projects/{project_id}/roles/{role_name}\nDELETE /projects/{project_id}/roles/{role_name}\nPOST /projects/{project_id}/roles/{role_name}/reset_password\nPOST /projects/{project_id}/start\nPOST /projects/{project_id}/stop\nPOST /psql_session/{psql_session_id}\n```\n\n----------------------------------------\n\nTITLE: Defining Drain/Fill API Endpoints in HTTP\nDESCRIPTION: Specifies the HTTP endpoints for triggering and canceling drain and fill operations on nodes. It includes the request method, path, and possible response codes.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/033-storage-controller-drain-and-fill.md#2025-04-22_snippet_1\n\nLANGUAGE: HTTP\nCODE:\n```\nPUT /v1/control/node/:node_id/{drain,fill}\nDELETE /v1/control/node/:node_id/{drain,fill}\n```\n\n----------------------------------------\n\nTITLE: Installing Python 3.11 on Ubuntu\nDESCRIPTION: Bash commands to install Python 3.11 on Ubuntu using the deadsnakes PPA. This is useful if the system Python version is not compatible with the project requirements.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/sourcetree.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo add-apt-repository ppa:deadsnakes/ppa\nsudo apt update\nsudo apt install python3.11\n```\n\n----------------------------------------\n\nTITLE: Exporting Neon Snapshot\nDESCRIPTION: Command to manually export a snapshot to a specified destination with optional format specification, supporting both pgdata and neon formats.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/009-snapshot-first-storage-cli.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nneon export --snapshot_path=FILE_PREFIX --snapshot_format=pgdata\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Minio S3\nDESCRIPTION: Command for running tests using a local Minio S3-compatible server.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/README.md#2025-04-22_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n# with AWS PROFILE\nENABLE_REAL_S3_REMOTE_STORAGE=true \\\nREMOTE_STORAGE_S3_BUCKET=mybucket \\\nREMOTE_STORAGE_S3_REGION=doesntmatterforminio \\\nAWS_PROFILE=local-minio \\\n./scripts/pytest\n```\n\n----------------------------------------\n\nTITLE: Local FS Remote Storage Configuration\nDESCRIPTION: TOML configuration example for setting up local filesystem-based remote storage backup functionality.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/settings.md#2025-04-22_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[remote_storage]\nlocal_path = '/some/local/path/'\n```\n\n----------------------------------------\n\nTITLE: Node Scheduling Policy State Machine Diagram\nDESCRIPTION: ASCII diagram showing the state transitions for node scheduling policies during drain and fill operations. Illustrates the flow between Active, Draining, PauseForRestart, and Filling states along with transition triggers.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/033-storage-controller-drain-and-fill.md#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n                          Operator requested drain\n               +-----------------------------------------+\n               |                                         |\n       +-------+-------+                         +-------v-------+\n       |               |                         |               |\n       |     Pause     |             +----------->    Draining   +----------+\n       |               |             |           |               |          |\n       +---------------+             |           +-------+-------+          |\n                                     |                   |                  |\n                                     |                   |                  |\n                      Drain requested|                   |                  |\n                                     |                   |Drain complete    | Drain failed\n                                     |                   |                  | Cancelled/PS reattach/Storcon restart\n                                     |                   |                  |\n                             +-------+-------+           |                  |\n                             |               |           |                  |\n               +-------------+    Active     <-----------+------------------+\n               |             |               |           |\nFill requested |             +---^---^-------+           |\n               |                 |   |                   |\n               |                 |   |                   |\n               |                 |   |                   |\n               |   Fill completed|   |                   |\n               |                 |   |PS reattach        |\n               |                 |   |after restart      |\n       +-------v-------+         |   |           +-------v-------+\n       |               |         |   |           |               |\n       |    Filling    +---------+   +-----------+PauseForRestart|\n       |               |                         |               |\n       +---------------+                         +---------------+\n```\n\n----------------------------------------\n\nTITLE: Batch Format Structure for Metrics in JSON\nDESCRIPTION: Shows the JSON structure used for sending batches of metrics to the HTTP endpoint. Metrics are sent in batches of up to 1000 metrics with no particular grouping guarantees.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/consumption_metrics.md#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{ \"events\" : [metric1, metric2, ...]}\n```\n\n----------------------------------------\n\nTITLE: Downloading DBpedia Entities Dataset with Git LFS\nDESCRIPTION: Commands to install Git LFS and clone the dataset repository from Hugging Face.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/performance/pgvector/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbrew install git-lfs\ngit-lfs clone https://huggingface.co/datasets/Qdrant/dbpedia-entities-openai3-text-embedding-3-large-1536-1M\n```\n\n----------------------------------------\n\nTITLE: Executing Scan Metadata Command\nDESCRIPTION: Command to analyze pageserver S3 bucket contents and generate statistics about timelines and layers\nSOURCE: https://github.com/neondatabase/neon/blob/main/storage_scrubber/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nenv AWS_PROFILE=dev REGION=eu-west-1 BUCKET=my-dev-bucket CLOUD_ADMIN_API_TOKEN=${NEON_CLOUD_ADMIN_API_STAGING_KEY} CLOUD_ADMIN_API_URL=[url] cargo run --release -- scan-metadata --node-kind pageserver\n```\n\n----------------------------------------\n\nTITLE: Creating S3 Bucket with AWS CLI\nDESCRIPTION: Command for creating an S3 bucket using the AWS CLI with a specified profile.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/README.md#2025-04-22_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n# (don't forget to have AWS_PROFILE env var set; or use --profile)\naws --profile local-minio s3 mb s3://mybucket\n```\n\n----------------------------------------\n\nTITLE: Running Integration Tests\nDESCRIPTION: Shell commands for cloning the Neon repository and running integration tests with cargo build flags for testing features.\nSOURCE: https://github.com/neondatabase/neon/blob/main/README.md#2025-04-22_snippet_13\n\nLANGUAGE: sh\nCODE:\n```\ngit clone --recursive https://github.com/neondatabase/neon.git\n\nCARGO_BUILD_FLAGS=\"--features=testing\" make\n\n./scripts/pytest\n```\n\n----------------------------------------\n\nTITLE: Handling and Logging Errors in Rust\nDESCRIPTION: Shows how to properly handle and log errors with appropriate error levels when consuming them rather than propagating. Demonstrates expected vs unexpected error handling.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/error-handling.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn get_message_of_the_day() -> String {\n    // Get the motd from /etc/motd, or return the default proverb\n    match read_motd_file() {\n        Ok(motd) => motd,\n        Err(err)  => {\n            // It's normal that /etc/motd doesn't exist, but if we fail to\n            // read it for some other reason, that's unexpected. The message\n            // of the day isn't very important though, so we just WARN and\n            // continue with the default in any case.\n            if err.kind() != std::io::ErrorKind::NotFound {\n                 tracing::warn!(\"could not read \\\"/etc/motd\\\": {err:?}\");\n            }\n            \"An old error is always more popular than a new truth. - German proverb\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Timeline Migration JSON Structure in Rust\nDESCRIPTION: Specifies the JSON structure for timeline migration requests, including a vector of desired safekeeper IDs.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/035-safekeeper-dynamic-membership-change.md#2025-04-22_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n{\n    \"desired_set\": Vec<u32>,\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Update Branch\nDESCRIPTION: Command to create a new branch based on the stable Neon branch for the update process.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/updating-postgres.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ngit checkout -b my-branch-15 REL_15_STABLE_neon\n```\n\n----------------------------------------\n\nTITLE: Running Debezium Logical Replication Tests with Docker Compose\nDESCRIPTION: This snippet shows the process of setting up the environment, launching Docker containers, executing Debezium-specific tests, and then stopping the containers. It uses the same Neon database connection string and pytest for running the tests.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/logical_repl/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport BENCHMARK_CONNSTR=postgres://user:pass@ep-abc-xyz-123.us-east-2.aws.neon.build/neondb\n\ndocker compose -f test_runner/logical_repl/debezium/docker-compose.yml up -d\n./scripts/pytest -m remote_cluster -k test_debezium\ndocker compose -f test_runner/logical_repl/debezium/docker-compose.yml down\n```\n\n----------------------------------------\n\nTITLE: Testing Ansible Connection (Bash)\nDESCRIPTION: This command tests the Ansible connection to all hosts in the inventory using the ping module.\nSOURCE: https://github.com/neondatabase/neon/blob/main/scripts/sk_collect_dumps/readme.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nansible all -m ping -v\n```\n\n----------------------------------------\n\nTITLE: Building Neon and Patched Postgres on macOS\nDESCRIPTION: Commands to clone the Neon repository and build the project on macOS. Includes options for debug and release builds.\nSOURCE: https://github.com/neondatabase/neon/blob/main/README.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --recursive https://github.com/neondatabase/neon.git\ncd neon\n\n# The preferred and default is to make a debug build. This will create a\n# demonstrably slower build than a release build. For a release build,\n# use \"BUILD_TYPE=release make -j`sysctl -n hw.logicalcpu` -s\"\n# Remove -s for the verbose build log\n\nmake -j`sysctl -n hw.logicalcpu` -s\n```\n\n----------------------------------------\n\nTITLE: Installing Rust for Neon Development\nDESCRIPTION: Command to install Rust programming language, which is required for building Neon. Uses the official Rust installation script.\nSOURCE: https://github.com/neondatabase/neon/blob/main/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n----------------------------------------\n\nTITLE: Querying SafekeeperInfo using gRPC in Protobuf\nDESCRIPTION: This command demonstrates how to use grpcurl to query the current SafekeeperInfo values being pushed to the storage broker. It sends a subscription request to the BrokerService's SubscribeSafekeeperInfo endpoint.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/storage_broker.md#2025-04-22_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\ngrpcurl -proto broker/proto/broker.proto -d '{\"all\":{}}' -plaintext localhost:50051 storage_broker.BrokerService/SubscribeSafekeeperInfo\n```\n\n----------------------------------------\n\nTITLE: Branch Push Commands for NeonDB Pageservers\nDESCRIPTION: Commands for pushing branch data to remote pageservers. Supports pushing to both matching and different branch names on the remote server.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/008-push-pull.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nneon push mybranch cloudserver # push to eponymous branch in cloudserver\nneon push mybranch cloudserver:otherbranch # push to a different branch in cloudserver\n```\n\n----------------------------------------\n\nTITLE: Single Node Safekeeper Cleanup Commands\nDESCRIPTION: Series of commands to execute the cleanup script on a single safekeeper node. Includes steps to connect to the node, list tenants, create backup directory, and run the script with various options.\nSOURCE: https://github.com/neondatabase/neon/blob/main/scripts/sk_cleanup_tenants/readme.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nzsh nsh safekeeper-0.us-east-2.aws.neon.build\n\nls /storage/safekeeper/data/ | grep -v safekeeper > tenants.txt\n\nmkdir -p /storage/neon-trash/2023-01-01--cleanup\n\nexport CONSOLE_API_TOKEN=\npython3 script.py --trash-dir /storage/neon-trash/2023-01-01--cleanup --safekeeper-id $(cat /storage/safekeeper/data/safekeeper.id) --safekeeper-host $HOSTNAME --dry-run\n\ncat tenants.txt | python3 script.py --trash-dir /storage/neon-trash/2023-01-01--cleanup --safekeeper-id $(cat /storage/safekeeper/data/safekeeper.id) --safekeeper-host $HOSTNAME --dry-run\n\ncat tenants.txt | python3 script.py --trash-dir /storage/neon-trash/2023-01-01--cleanup --safekeeper-id $(cat /storage/safekeeper/data/safekeeper.id) --safekeeper-host $HOSTNAME |& tee logs.txt\n```\n\n----------------------------------------\n\nTITLE: Uploading Dumps to PostgreSQL Database (Bash)\nDESCRIPTION: This command runs a shell script to upload the collected dumps to a specified table in a PostgreSQL database. The database connection string is provided as an environment variable.\nSOURCE: https://github.com/neondatabase/neon/blob/main/scripts/sk_collect_dumps/readme.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nDB_CONNSTR=... ./upload.sh prod_feb30\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Branches in Neon\nDESCRIPTION: Commands to create a new branch in Neon, start a PostgreSQL instance on the new branch, and demonstrate data isolation between branches.\nSOURCE: https://github.com/neondatabase/neon/blob/main/README.md#2025-04-22_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n# create branch named migration_check\n> cargo neon timeline branch --branch-name migration_check\nCreated timeline 'b3b863fa45fa9e57e615f9f2d944e601' at Lsn 0/16F9A00 for tenant: 9ef87a5bf0d92544f6fafeeb3239695c. Ancestor timeline: 'main'\n\n# check branches tree\n> cargo neon timeline list\n(L) main [de200bd42b49cc1814412c7e592dd6e9]\n(L) ┗━ @0/16F9A00: migration_check [b3b863fa45fa9e57e615f9f2d944e601]\n\n# create postgres on that branch\n> cargo neon endpoint create migration_check --branch-name migration_check\n\n# start postgres on that branch\n> cargo neon endpoint start migration_check\nStarting new endpoint migration_check (PostgreSQL v14) on timeline b3b863fa45fa9e57e615f9f2d944e601 ...\nStarting postgres at 'postgresql://cloud_admin@127.0.0.1:55434/postgres'\n\n# check the new list of running postgres instances\n> cargo neon endpoint list\n ENDPOINT         ADDRESS          TIMELINE                          BRANCH NAME      LSN        STATUS\n main             127.0.0.1:55432  de200bd42b49cc1814412c7e592dd6e9  main             0/16F9A38  running\n migration_check  127.0.0.1:55434  b3b863fa45fa9e57e615f9f2d944e601  migration_check  0/16F9A70  running\n\n# this new postgres instance will have all the data from 'main' postgres,\n# but all modifications would not affect data in original postgres\n> psql -p 55434 -h 127.0.0.1 -U cloud_admin postgres\npostgres=# select * from t;\n key | value\n-----+-------\n   1 | 1\n(1 row)\n\npostgres=# insert into t values(2,2);\nINSERT 0 1\n```\n\n----------------------------------------\n\nTITLE: Running Ansible Playbook with SSM for Dump Collection (Bash)\nDESCRIPTION: This command runs an Ansible playbook to collect dumps from safekeeper nodes using AWS Systems Manager (SSM). It specifies the inventory, variables, and limits the execution to specific safekeeper nodes in a given region.\nSOURCE: https://github.com/neondatabase/neon/blob/main/scripts/sk_collect_dumps/readme.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nAWS_DEFAULT_PROFILE=dev ansible-playbook -i inventory_aws_ec2.yaml -i staging.us-east-2.vars.yaml -e @ssm_config -l 'safekeeper:&us_east_2' -e \"auth_token=${AUTH_TOKEN}\" ~/neon/neon/scripts/sk_collect_dumps/remote.yaml\n```\n\n----------------------------------------\n\nTITLE: Running Parallel Tests with pytest-xdist\nDESCRIPTION: Command for running tests in parallel using multiple workers with the pytest-xdist plugin.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/pytest -n4\n```\n\n----------------------------------------\n\nTITLE: Neon SQL Extension Functions\nDESCRIPTION: SQL functions defined in neon--*.sql files that expose Neon-specific information and metrics collection capabilities to users. These functions are automatically created in all databases within the cluster.\nSOURCE: https://github.com/neondatabase/neon/blob/main/pgxn/neon/README.md#2025-04-22_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Enabling Authentication in Neon Tests\nDESCRIPTION: Python code to enable authentication in Neon tests by setting the auth_enabled flag and generating appropriate tokens using the AuthKeys class.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/authentication.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nneon_env_builder.auth_enabled = True\n```\n\n----------------------------------------\n\nTITLE: Configuring AWS CLI Credentials for Minio\nDESCRIPTION: Interactive command to configure AWS CLI credentials for connecting to a local Minio server.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/README.md#2025-04-22_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n# Terminal 2\n$ aws --profile local-minio configure\nAWS Access Key ID [None]: minioadmin\nAWS Secret Access Key [None]: minioadmin\nDefault region name [None]:\nDefault output format [None]:\n```\n\n----------------------------------------\n\nTITLE: Downloading Dumps with Ansible Playbook (Bash)\nDESCRIPTION: These commands create a result directory and run an Ansible playbook to download the debug dumps from the safekeeper nodes using the previously obtained auth token.\nSOURCE: https://github.com/neondatabase/neon/blob/main/scripts/sk_collect_dumps/readme.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p result && rm -f result/*\nansible-playbook -e \"auth_token=${AUTH_TOKEN}\" remote.yaml\n```\n\n----------------------------------------\n\nTITLE: Querying PostgreSQL Database\nDESCRIPTION: Example of connecting to and querying a PostgreSQL database running on port 55432 using psql client as cloud_admin user.\nSOURCE: https://github.com/neondatabase/neon/blob/main/README.md#2025-04-22_snippet_11\n\nLANGUAGE: sql\nCODE:\n```\npsql -p 55432 -h 127.0.0.1 -U cloud_admin postgres\nselect * from t;\n key | value\n-----+-------\n   1 | 1\n(1 row)\n```\n\n----------------------------------------\n\nTITLE: Connecting to Neon using Pre-defined Endpoint in PostgreSQL\nDESCRIPTION: Shows the connection string format for connecting to a pre-defined endpoint in Neon. Endpoints can be created with specific settings like cluster, branch, and timestamp.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/016-connection-routing.md#2025-04-22_snippet_3\n\nLANGUAGE: postgresql\nCODE:\n```\npostgres://<username>@<endpoint-id>.endpoint.neon.tech/<dbname>\n```\n\n----------------------------------------\n\nTITLE: Illustrating WAL Processing Flow in Pageserver\nDESCRIPTION: ASCII diagram showing the flow of WAL data from Safekeeper through Pageserver's memory, L0/L1 storage layers, and into Cloud Storage. Demonstrates how data is reorganized and stored at different levels.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/pageserver-storage.md#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nCloud Storage                   Page Server                           Safekeeper\n                        L1               L0             Memory            WAL\n\n+----+               +----+----+\n|AAAA|               |AAAA|AAAA|      +---+-----+         |\n+----+               +----+----+      |   |     |         |AA\n|BBBB|               |BBBB|BBBB|      |BB | AA  |         |BB\n+----+----+          +----+----+      |C  | BB  |         |CC\n|CCCC|CCCC|  <----   |CCCC|CCCC| <--- |D  | CC  |  <---   |DDD     <----   ADEBAABED\n+----+----+          +----+----+      |   | DDD |         |E\n|DDDD|DDDD|          |DDDD|DDDD|      |E  |     |         |\n+----+----+          +----+----+      |   |     |\n|EEEE|               |EEEE|EEEE|      +---+-----+\n+----+               +----+----+\n```\n\n----------------------------------------\n\nTITLE: Sending SQL Query via cURL to SQL over HTTP Endpoint (Bash)\nDESCRIPTION: Example cURL command to send a SQL query to the SQL over HTTP endpoint, demonstrating how to specify connection string, query, and parameters.\nSOURCE: https://github.com/neondatabase/neon/blob/main/proxy/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -k -X POST 'https://proxy.local.neon.build:4444/sql' \\\n  -H 'Neon-Connection-String: postgres://stas:pass@proxy.local.neon.build:4444/postgres' \\\n  -H 'Content-Type: application/json' \\\n  --data '{\n    \"query\":\"SELECT $1::int[] as arr, $2::jsonb as obj, 42 as num\",\n    \"params\":[ \"{{1,2},{\\\"3\\\",4}}\", {\"key\":\"val\", \"ikey\":4242}]\n  }' | jq\n```\n\n----------------------------------------\n\nTITLE: Basic Pageserver TOML Configuration\nDESCRIPTION: Default configuration example showing core pageserver settings including network listeners, checkpoint settings, garbage collection parameters, and broker endpoint configuration.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/settings.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n# Initial configuration file created by 'pageserver --init'\nlisten_pg_addr = '127.0.0.1:64000'\nlisten_http_addr = '127.0.0.1:9898'\n\ncheckpoint_distance = '268435456' # in bytes\ncheckpoint_timeout = '10m'\n\ngc_period = '1 hour'\ngc_horizon = '67108864'\n\nmax_file_descriptors = '100'\n\n# initial superuser role name to use when creating a new tenant\ninitial_superuser_name = 'cloud_admin'\n\nbroker_endpoint = 'http://127.0.0.1:50051'\n\n# [remote_storage]\n```\n\n----------------------------------------\n\nTITLE: Pushing Final Changes\nDESCRIPTION: Commands to push the final branch changes and update the submodule reference.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/updating-postgres.md#2025-04-22_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\ngit push origin my-branch-15:REL_15_STABLE_neon\ngit submodule set-branch --branch REL_15_STABLE_neon vendor/postgres-v15\ngit commit --amend --no-edit\ngit push --force origin\n```\n\n----------------------------------------\n\nTITLE: S3Config Structure in Rust\nDESCRIPTION: Definition of the S3Config structure in Rust with comments mapping to test suite environment variables.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/README.md#2025-04-22_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\npub struct S3Config {\n    // test suite env var: REMOTE_STORAGE_S3_BUCKET\n    pub bucket_name: String,\n    // test suite env var: REMOTE_STORAGE_S3_REGION\n    pub bucket_region: String,\n    // test suite determines this\n    pub prefix_in_bucket: Option<String>,\n    // no env var exists; test suite sets it for MOCK_S3, because that's how moto works\n    pub endpoint: Option<String>,\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Default Tenant and Timeline in Neon Environment\nDESCRIPTION: Shows how to use the default tenant and timeline provided by the Neon Environment. The example demonstrates starting a compute endpoint, getting a pageserver client, and accessing timeline details using the built-in initial tenant and timeline.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/README.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef test_foobar2(neon_env_builder: NeonEnvBuilder):\n    env = neon_env_builder.init_start() # Start the environment\n    with env.endpoints.create_start(\"main\") as endpoint:\n        # Start the compute endpoint\n    client = env.pageserver.http_client() # Get the pageserver client\n\n    tenant_id = env.initial_tenant\n    timeline_id = env.initial_timeline\n    client.timeline_detail(tenant_id=tenant_id, timeline_id=timeline_id)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Timeline Structure Before Detachment\nDESCRIPTION: ASCII diagram showing the timeline structure before calling the detach ancestor API, with an 'old main' timeline, a 'new main' timeline, and two child timelines A and B at different branch points.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/034-ancestor-deletion.md#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n----\"old main\" timeline-------X-------------------------------------------->\n                |             |                         |\n                |-> child A   |                         |\n                              |-> \"new main\" timeline   |\n                                                        -> child B\n```\n\n----------------------------------------\n\nTITLE: Stopping Neon Services\nDESCRIPTION: Command to stop all running Neon services including pageserver, safekeeper and postgres instances using the cargo neon CLI tool.\nSOURCE: https://github.com/neondatabase/neon/blob/main/README.md#2025-04-22_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\ncargo neon stop\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Neon on Arch Linux\nDESCRIPTION: Command to install necessary packages for building Neon on Arch-based systems. Includes base development tools and specific libraries required for the project.\nSOURCE: https://github.com/neondatabase/neon/blob/main/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npacman -S base-devel readline zlib libseccomp openssl clang \\\npostgresql-libs cmake postgresql protobuf curl lsof\n```\n\n----------------------------------------\n\nTITLE: Setting Up Native Cross-Compilation for Linux from macOS\nDESCRIPTION: Series of commands to set up native cross-compilation from macOS to Linux using Rustup and Homebrew toolchains.\nSOURCE: https://github.com/neondatabase/neon/blob/main/compute_tools/README.md#2025-04-22_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\nrustup target add x86_64-unknown-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Running Tests with AWS Access Keys\nDESCRIPTION: Command for running tests using real S3 storage with long-term AWS access keys.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/README.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# with long-term AWS access keys\nENABLE_REAL_S3_REMOTE_STORAGE=true \\\nREMOTE_STORAGE_S3_BUCKET=mybucket \\\nREMOTE_STORAGE_S3_REGION=eu-central-1 \\\nAWS_ACCESS_KEY_ID=... \\\nAWS_SECRET_ACCESS_KEY=... \\\n./scripts/pytest\n```\n\n----------------------------------------\n\nTITLE: Describing Eviction Process in Neon Database\nDESCRIPTION: Explains the eviction process in Neon's pageserver, which writes in-memory layers to disk as delta layers. This process helps release memory and allows the WAL service to remove old WAL entries.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/012-background-tasks.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Eviction\n\n Write out in-memory layer to disk, into a delta layer.\n\n- To release memory\n- To make it possible to advance disk_consistent_lsn and allow the WAL\n  service to release some WAL.\n\n- Triggered if we are short on memory\n- Or if the oldest in-memory layer is so old that it's holding back\n  the WAL service from removing old WAL\n```\n\n----------------------------------------\n\nTITLE: Example Console Management API Request in cURL\nDESCRIPTION: Example of a PATCH request to the internal management API for atomically creating, dropping, or altering roles and databases. The API accepts an array of operations to be performed as a single transaction.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/024-user-mgmt.md#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\ncurl -X PATCH /api/v1/roles_and_databases -d '\n[\n    {\"op\":\"create\", \"type\":\"role\", \"name\": \"kurt\", \"password\":\"lYgT3BlbkFJ2vBZrqv\"},\n    {\"op\":\"drop\", \"type\":\"role\", \"name\": \"trout\"},\n    {\"op\":\"alter\", \"type\":\"role\", \"name\": \"kilgore\", \"password\":\"3BlbkFJ2vB\"},\n    {\"op\":\"create\", \"type\":\"database\", \"name\": \"db2\", \"owner\": \"eliot\"},\n]\n'\n```\n\n----------------------------------------\n\nTITLE: Visualizing PITR Horizon and WAL in Synthetic Size Calculation\nDESCRIPTION: This ASCII diagram illustrates the relationship between the PITR (Point-in-Time Recovery) horizon, WAL (Write-Ahead Log), and snapshot in the synthetic size calculation model.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/synthetic-size.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n                             WAL\n   -----------------------#########>\n                          ^\n                       snapshot\n\nLegend:\n  ##### PITR horizon. This is the region that you can still access\n        with Point-in-time query and you can still create branches\n        from.\n  ----- history that has fallen out of the PITR horizon, and can no\n        longer be accessed\n```\n\n----------------------------------------\n\nTITLE: Creating PostgreSQL Instance from Public Snapshot\nDESCRIPTION: Shows how to create a new PostgreSQL instance from a publicly shared snapshot hosted on a web server.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/003-laptop-cli.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n> neon pg create --snapshot http://learn-postgres.com/movies_db.neon movies\n```\n\n----------------------------------------\n\nTITLE: Running Neon Tests\nDESCRIPTION: Command to run the Neon test suite for the updated Postgres version.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/updating-postgres.md#2025-04-22_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n./scripts/poetry -k pg15\n```\n\n----------------------------------------\n\nTITLE: Production Environment Ansible Deployment\nDESCRIPTION: Commands to deploy the cleanup script using Ansible in a production environment. Includes endpoint configuration change and execution steps.\nSOURCE: https://github.com/neondatabase/neon/blob/main/scripts/sk_cleanup_tenants/readme.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/neon/.github/ansible\n\nexport AWS_DEFAULT_PROFILE=prod\n\nansible-playbook -i prod.us-east-2.hosts.yaml -e @ssm_config ../../scripts/sk_cleanup_tenants/remote.yaml\n\n# add --extra-vars \"api_token=\" to set console api token\n```\n\n----------------------------------------\n\nTITLE: Running PostgreSQL Regression Tests on Remote Cluster\nDESCRIPTION: Bash command to execute the PostgreSQL regression tests on a remote Neon cluster using pytest, filtering for cloud-specific regression tests.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/cloud_regress/README.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ scripts/pytest -m remote_cluster -k cloud_regress\n```\n\n----------------------------------------\n\nTITLE: Visualizing Diverging Branches in Synthetic Size Calculation\nDESCRIPTION: This ASCII diagram illustrates how diverging branches are represented in the synthetic size calculation, showing separate snapshots and WAL regions for each branch.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/synthetic-size.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n                              snapshot\n                                  v     WAL\n  child                 +---------##############>\n                        |\n                        |\n  main     -------------+---------##############>\n                                  ^     WAL\n                              snapshot\n```\n\n----------------------------------------\n\nTITLE: Configuring Point-in-Time Recovery (PITR) Area\nDESCRIPTION: Shows how to create a PITR area for continuous snapshots with a specified storage location, time-to-live (TTL), and name.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/003-laptop-cli.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n> neon pitr create --storage s3tank --ttl 30d --name pitr_last_month\n```\n\n----------------------------------------\n\nTITLE: Running Tests for Compute Tools\nDESCRIPTION: Command to execute all tests for the compute tools codebase using Cargo.\nSOURCE: https://github.com/neondatabase/neon/blob/main/compute_tools/README.md#2025-04-22_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ncargo test\n```\n\n----------------------------------------\n\nTITLE: Generating Type Stubs for H2 Module using Poetry and stubgen\nDESCRIPTION: This command uses Poetry to run stubgen, generating type stubs for the H2 module. The output is directed to the test_runner/stubs directory.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/stubs/h2/README.md#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npoetry run stubgen -p h2 -o test_runner/stubs\n```\n\n----------------------------------------\n\nTITLE: Configuring preload_libraries in Neon Project\nDESCRIPTION: JSON configuration to disable default libraries and specify an empty list of enabled libraries for the Neon project.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/cloud_regress/README.md#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n\"preload_libraries\": {\n    \"use_defaults\": false,\n    \"enabled_libraries\": []\n  }\n```\n\n----------------------------------------\n\nTITLE: Origin Management Commands for NeonDB Pageservers\nDESCRIPTION: Basic commands for managing remote pageserver connections using a git-like syntax. Commands allow adding, listing, and removing remote origins using connection URIs.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/008-push-pull.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nneon origin add <name> <connection_uri>\nneon origin list\nneon origin remove <name>\n```\n\n----------------------------------------\n\nTITLE: Example Layer File Organization in Single Branch System\nDESCRIPTION: Shows the file organization in a simple system with one branch ('main') and two tables ('orders' and 'customers'), illustrating how layer files are organized by branch and table with LSN ranges.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/pageserver-storage.md#2025-04-22_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\nmain/orders_100\nmain/orders_100_200\nmain/orders_200\nmain/customers_100\nmain/customers_100_200\nmain/customers_200\n```\n\n----------------------------------------\n\nTITLE: General Remote Storage Configuration\nDESCRIPTION: Common remote storage configuration parameters applicable to all storage types, showing concurrent sync and error handling settings.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/settings.md#2025-04-22_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[remote_storage]\n# Max number of concurrent timeline synchronized (layers uploaded or downloaded) with the remote storage at the same time.\nmax_concurrent_syncs = 50\n\n# Max number of errors a single task can have before it's considered failed and not attempted to run anymore.\nmax_sync_errors = 10\n```\n\n----------------------------------------\n\nTITLE: Cloning Neon Postgres Repository\nDESCRIPTION: Command to clone the Neon Postgres repository from GitHub.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/updating-postgres.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit clone git@github.com:neondatabase/postgres.git\n```\n\n----------------------------------------\n\nTITLE: Displaying Detailed PostgreSQL Instance Information\nDESCRIPTION: Illustrates the output of the 'neon pg show' command, providing detailed information about a specific PostgreSQL instance, including storage usage and snapshots.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/003-laptop-cli.md#2025-04-22_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nmy_pg:\n    storage: local\n    space used on local: 5.1G\n    space used on all storages: 15.1G\n    snapshots:\n        on local:\n            snap1: 1G\n            snap2: 1G\n        on zcloud:\n            snap2: 1G\n        on s3tank:\n            snap5: 2G\n    pitr:\n        on s3tank:\n            pitr_one_month: 45G\n```\n\n----------------------------------------\n\nTITLE: Updating Python Dependencies with Poetry\nDESCRIPTION: Bash command to synchronize Python dependencies using the pysync script, ensuring all required packages are installed.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/cloud_regress/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ scripts/pysync\n```\n\n----------------------------------------\n\nTITLE: Installing PostgreSQL Client on macOS\nDESCRIPTION: Commands to install PostgreSQL client (psql) on macOS using Homebrew, without installing the full PostgreSQL server.\nSOURCE: https://github.com/neondatabase/neon/blob/main/README.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nbrew install libpq\nbrew link --force libpq\n```\n\n----------------------------------------\n\nTITLE: Configuring Postgres for Proxy Testing (Bash)\nDESCRIPTION: Series of SQL commands to set up the necessary schema, table, and role for testing the proxy with a local Postgres instance.\nSOURCE: https://github.com/neondatabase/neon/blob/main/proxy/README.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndocker exec -it proxy-postgres psql -U postgres -c \"CREATE SCHEMA IF NOT EXISTS neon_control_plane\"\ndocker exec -it proxy-postgres psql -U postgres -c \"CREATE TABLE neon_control_plane.endpoints (endpoint_id VARCHAR(255) PRIMARY KEY, allowed_ips VARCHAR(255))\"\ndocker exec -it proxy-postgres psql -U postgres -c \"CREATE ROLE proxy WITH SUPERUSER LOGIN PASSWORD 'password';\"\n```\n\n----------------------------------------\n\nTITLE: Layer File Organization in Multiple Branches\nDESCRIPTION: Shows how layer files are organized when a child branch is created from the main branch at a specific LSN (250), with different modifications to tables in each branch.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/pageserver-storage.md#2025-04-22_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\nmain/orders_100\nmain/orders_100_200\nmain/orders_200\nmain/orders_200_300\nmain/orders_300\nmain/orders_300_400\nmain/orders_400\nmain/customers_100\nmain/customers_100_200\nmain/customers_200\nchild/orders_250_300\nchild/orders_300\nchild/orders_300_400\nchild/orders_400\n```\n\n----------------------------------------\n\nTITLE: Rolling Back to a Previous Compute Release (JSON)\nDESCRIPTION: API payload for rolling back to a previously deployed compute release by specifying the revision number.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/038-independent-compute-release.md#2025-04-22_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"revision\": 52\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Postgres Upstream Remote\nDESCRIPTION: Command to add the official Postgres repository as an upstream remote.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/updating-postgres.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngit remote add upstream https://git.postgresql.org/git/postgresql.git\n```\n\n----------------------------------------\n\nTITLE: Error Message Style Using Anyhow Context\nDESCRIPTION: Demonstrates the preferred style for adding context to anyhow errors and logging them with proper formatting.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/error-handling.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n  match list_users().context(\"list users\") else {\n    Ok(_) => ...,\n    Err(e) => tracing::error!(\"failed to {e:#}\"),\n  }\n}\nfn list_users() {\n  http_get_users().context(\"load users from server\")?;\n}\nfn http_get_users() {\n  let response = client....?;\n  response.parse().context(\"parse response\")?; // fails with serde error \"invalid json\"\n}\n```\n\n----------------------------------------\n\nTITLE: Rolling Back PostgreSQL to Previous Snapshot\nDESCRIPTION: Illustrates the process of creating a snapshot, listing snapshots, and then rolling back the database to a previous snapshot state using the checkout command.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/003-laptop-cli.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n> neon pg list\nID            PGDATA        USED    STORAGE            ENDPOINT\nprimary1      pgdata1       5G      neon-local       localhost:5432\n\n> neon snapshot create pgdata1@snap1\n\n> neon snapshot list\nID                    SIZE        PARENT\noldpg                 5G          -\npgdata1@snap1         6G          -\npgdata1@CURRENT       6G          -\n\n> neon pg checkout pgdata1@snap1\nStopping postgres on pgdata1.\nRolling back pgdata1@CURRENT to pgdata1@snap1.\nStarting postgres on pgdata1.\n\n> neon snapshot list\nID                    SIZE        PARENT\noldpg                 5G          -\npgdata1@snap1         6G          -\npgdata1@HEAD{0}       6G          -\npgdata1@CURRENT       6G          -\n```\n\n----------------------------------------\n\nTITLE: Parametrizing Tests with Different Component Versions\nDESCRIPTION: Demonstrates how to use pytest.mark.parametrize with fixtures.utils.allpairs_versions() to test various version combinations of Neon components. This allows testing compatibility across different versions.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/README.md#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n@pytest.mark.parametrize(**fixtures.utils.allpairs_versions())\ndef test_something(\n...\n```\n\n----------------------------------------\n\nTITLE: Visualizing Compute Release Workflow (Mermaid)\nDESCRIPTION: A sequence diagram illustrating the complete workflow for releasing a new compute version, including interactions between repositories, CI processes, and deployment stages.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/038-independent-compute-release.md#2025-04-22_snippet_4\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n\n  actor oncall as Compute on-call person\n  participant neon as neondatabase/neon\n\n  box private\n    participant cloud as neondatabase/cloud\n    participant exts as neondatabase/build-custom-extensions\n    participant infra as neondatabase/infra\n  end\n\n  box cloud\n    participant preprod as Pre-prod control plane\n    participant prod as Production control plane\n    participant k8s as Compute k8s\n  end\n\n  oncall ->> neon: Open release PR into release-compute\n\n  activate neon\n  neon ->> cloud: CI: trigger e2e compatibility tests\n  activate cloud\n  cloud -->> neon: CI: e2e tests pass\n  deactivate cloud\n  neon ->> neon: CI: pass PR checks, get approvals\n  deactivate neon\n\n  oncall ->> neon: Merge release PR into release-compute\n\n  activate neon\n  neon ->> neon: CI: pass checks, build and push images\n  neon ->> exts: CI: trigger extensions build\n  activate exts\n  exts -->> neon: CI: extensions are ready\n  deactivate exts\n  neon ->> neon: CI: create release tag\n  neon ->> infra: Trigger release workflow using the produced tag\n  deactivate neon\n\n  activate infra\n  infra ->> infra: CI: pass checks\n  infra ->> preprod: Release new compute image to pre-prod automatically <br/> POST /management/api/v2/compute_releases\n  activate preprod\n  preprod -->> infra: 200 OK\n  deactivate preprod\n\n  infra ->> infra: CI: wait for per-region production deploy approvals\n  oncall ->> infra: CI: approve deploys region by region\n  infra ->> k8s: Prewarm new compute image\n  infra ->> prod: POST /management/api/v2/compute_releases\n  activate prod\n  prod -->> infra: 200 OK\n  deactivate prod\n  deactivate infra\n```\n\n----------------------------------------\n\nTITLE: Cloning Neon Repository\nDESCRIPTION: Command to clone the main Neon repository.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/updating-postgres.md#2025-04-22_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\ngit clone git@github.com:neondatabase/neon.git\n```\n\n----------------------------------------\n\nTITLE: Defining Key Structure for Pageserver in Rust\nDESCRIPTION: This code snippet defines the structure of a Key used in the pageserver's getpage@lsn interface. It includes fields for various components of the key, such as spcnode, dbnode, relnode, forknum, and blknum.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/031-sharding-static.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub struct Key {\n    pub field1: u8,\n    pub field2: u32,\n    pub field3: u32,\n    pub field4: u32,\n    pub field5: u8,\n    pub field6: u32,\n}\n```\n\n----------------------------------------\n\nTITLE: Exploring and Managing Neon Catalog History\nDESCRIPTION: Commands to view commit history, check status, create commits, and manage branches in a Neon catalog.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/006-laptop-cli-v2-CLI.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nneon log -- returns a list of commits\nneon status -- returns if there are changes in the catalog that can be committed\nneon commit -- commits the changes and generates a new commit hash\nneon branch experimental <hash> -- creates a branch called testdb based on a given commit hash\n```\n\n----------------------------------------\n\nTITLE: Refactored Protocol Flow Documentation\nDESCRIPTION: Documentation of the refactored WAL ingestion pipeline introducing InterpretedWalRecords for improved processing efficiency.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/041-sharded-ingest.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n1. `handle_walreceiver_connection` reads a stream of binary WAL records off a network\\n2. A `InterpretedWalRecords` is generated from the incoming WAL records. This does not\\n   require a reference to a Timeline.\\n3. The logic that is current spread between `WalIngest` and `DatadirModification` for updating\\n   metadata will be refactored to consume the metadata operations from the `InterpretedWalRecords`\\n   and turn them into literal writes to metadata pages. This part must be done sequentially.\\n4. The resulting buffer of metadata page writes is combined with the buffer of relation block\\n   writes, and written into the `InMemoryLayer`.\n```\n\n----------------------------------------\n\nTITLE: Fetching CPU Profile via cURL\nDESCRIPTION: Command to fetch CPU profile data from a service endpoint and save it as a compressed protobuf file.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/040-profiling.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ curl localhost:9898/profile/cpu >profile.pb.gz\n```\n\n----------------------------------------\n\nTITLE: Executing Purge Garbage Command\nDESCRIPTION: Command to delete identified garbage objects from S3 bucket using the garbage list generated by find-garbage\nSOURCE: https://github.com/neondatabase/neon/blob/main/storage_scrubber/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nenv AWS_PROFILE=dev cargo run --release -- purge-garbage --input-path=eu-west-1-garbage.json\n```\n\n----------------------------------------\n\nTITLE: Querying Top Tenant Shards API Example\nDESCRIPTION: Example of the API endpoint for querying the largest tenant shards by physical size that are candidates for splitting. This API allows filtering by current shard count and sorting by resident size.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/032-shard-splitting.md#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n/v1/top_n_tenant?shard_count_lt=8&sort_by=resident_size\n```\n\n----------------------------------------\n\nTITLE: Listing PostgreSQL Instances\nDESCRIPTION: Shows the output of the 'neon pg list' command, displaying information about various PostgreSQL instances managed by Neon.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/003-laptop-cli.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nROLE                 PGDATA        USED    STORAGE            ENDPOINT\nprimary              my_pg         5.1G    local              localhost:5432\nreplica-1                                                     localhost:5433\nreplica-2                                                     localhost:5434\nprimary              my_pg2        3.2G    local.compr        localhost:5435\n-                    my_pg3        9.2G    local.compr        -\n```\n\n----------------------------------------\n\nTITLE: Implementing Happy Path Deletion Flow\nDESCRIPTION: Sequence diagram showing the normal flow of tenant deletion between Control Plane, Pageserver, and S3. Illustrates the creation of deletion marks and the sequential deletion of layer files.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/022-pageserver-delete-from-s3.md#2025-04-22_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    participant CP as Control Plane\n    participant PS as Pageserver\n    participant S3\n\n    CP->>PS: Delete tenant\n    PS->>S3: Create deleted mark file at <br> /tenant/meta/deleted\n    PS->>PS: Create deleted mark file locally\n    PS->>CP: Accepted\n    PS->>PS: delete local files other than deleted mark\n    loop Delete layers for each timeline\n        PS->>S3: delete(..)\n        CP->>PS: Finished?\n        PS->>CP: False\n    end\n    PS->>S3: Delete mark file\n    PS->>PS: Delete local mark file\n\n    loop Poll for status\n        CP->>PS: Finished?\n        PS->>CP: True or False\n    end\n```\n\n----------------------------------------\n\nTITLE: PITR Command Reference for Neon Database CLI\nDESCRIPTION: A set of commands for managing Point-in-Time Recovery (PITR) in Neon database. These commands handle WAL streams with configurable TTL policies, allowing for snapshot creation, garbage collection, listing, and deletion of PITR areas.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/003-laptop-cli.md#2025-04-22_snippet_10\n\nLANGUAGE: plaintext\nCODE:\n```\n**neon pitr create** name\n\n--ttl = inf | period\n\n--size-limit = inf | limit\n\n--storage = storage_name\n\n**neon pitr extract-snapshot** pitr_name --lsn xxx\n\n**neon pitr gc** pitr_name\n\n**neon pitr list**\n\n**neon pitr destroy**\n```\n\n----------------------------------------\n\nTITLE: Creating New RFC File using Shell Command\nDESCRIPTION: This shell command creates a new RFC file using the provided template, with a timestamp prefix to avoid naming conflicts.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/README.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncp docs/rfcs/YYYY-MM-DD-copy-me.md docs/rfcs/$(date +\"%Y-%m-%d\")-<name>.md\n```\n\n----------------------------------------\n\nTITLE: Running Performance Tests\nDESCRIPTION: Command for explicitly running performance tests which are excluded by default.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/pytest test_runner/performance\n```\n\n----------------------------------------\n\nTITLE: Running Cargo Formatter for Compute Tools\nDESCRIPTION: Command to run Cargo formatter for code style consistency in the compute tools codebase.\nSOURCE: https://github.com/neondatabase/neon/blob/main/compute_tools/README.md#2025-04-22_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ncargo fmt\n```\n\n----------------------------------------\n\nTITLE: Neon Shared Library Components\nDESCRIPTION: Core components of the neon.so shared preload library including storage manager, WAL proposer, control plane connector, extension server, file cache, and relation size cache implementations. The library handles core database operations and communications with external services.\nSOURCE: https://github.com/neondatabase/neon/blob/main/pgxn/neon/README.md#2025-04-22_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Creating and Pushing Snapshot to Cloud\nDESCRIPTION: Demonstrates creating a snapshot of an existing PostgreSQL instance and pushing it to a remote storage location.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/003-laptop-cli.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n> neon snapshot create pgdata1@snap1\n> neon snapshot push --to ssh://stas@neon.tech pgdata1@snap1\n```\n\n----------------------------------------\n\nTITLE: JWT Token Payload Structure in JSON\nDESCRIPTION: Example payload structure for JWT tokens in Neon, showing the scope and tenant_id fields. The scope determines access permissions across different components.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/authentication.md#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scope\": \"tenant\",  # \"tenant\", \"pageserverapi\", or \"safekeeperdata\"\n  \"tenant_id\": \"5204921ff44f09de8094a1390a6a50f6\",\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Overlapping LSN Ranges for a Relation\nDESCRIPTION: An example showing overlapping LSN ranges for the same relation (orders). This illustrates a potential transient state during garbage collection around branch points or recovery points.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/pageserver-storage.md#2025-04-22_snippet_11\n\nLANGUAGE: plaintext\nCODE:\n```\n\tmain/orders_100\n\tmain/orders_100_200\n\tmain/orders_200\n\tmain/orders_200_300\n\tmain/orders_300\n\tmain/orders_250_350\n\tmain/orders_350\n\tmain/orders_300_400\n\tmain/orders_400\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for Neon Build\nDESCRIPTION: Bash commands to set required environment variables for building Neon binaries, specifying PostgreSQL version and build type.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/cloud_regress/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ export DEFAULT_PG_VERSION=17\n$ export BUILD_TYPE=release\n```\n\n----------------------------------------\n\nTITLE: Configuring Jemalloc Memory Profiling in Rust\nDESCRIPTION: Rust code to configure the jemalloc allocator with profiling enabled, sampling every 2MB of allocation.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/040-profiling.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[global_allocator]\nstatic GLOBAL: tikv_jemallocator::Jemalloc = tikv_jemallocator::Jemalloc;\n\n#[allow(non_upper_case_globals)]\n#[export_name = \"malloc_conf\"]\npub static malloc_conf: &[u8] = b\"prof:true,prof_active:true,lg_prof_sample:21\\0\";\n```\n\n----------------------------------------\n\nTITLE: Structuring Extension Storage in S3 for PostgreSQL Versions\nDESCRIPTION: Demonstrates the layout of the S3 bucket for storing PostgreSQL extensions across different versions and build numbers. It shows how extension archives and index files are organized.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/024-extension-loading.md#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n5615610098 // this is an extension build number\n├── v14\n│   ├── extensions\n│   │   ├── anon.tar.zst\n│   │   └── embedding.tar.zst\n│   └── ext_index.json\n└── v15\n    ├── extensions\n    │   ├── anon.tar.zst\n    │   └── embedding.tar.zst\n    └── ext_index.json\n5615261079\n├── v14\n│   ├── extensions\n│   │   └── anon.tar.zst\n│   └── ext_index.json\n└── v15\n    ├── extensions\n    │   └── anon.tar.zst\n    └── ext_index.json\n5623261088\n├── v14\n│   ├── extensions\n│   │   └── embedding.tar.zst\n│   └── ext_index.json\n└── v15\n    ├── extensions\n    │   └── embedding.tar.zst\n    └── ext_index.json\n```\n\n----------------------------------------\n\nTITLE: Viewing Container Logs for Neon Compute Node\nDESCRIPTION: Commands for checking container status and viewing logs for Neon components. This snippet demonstrates how to list running containers and stream logs from a specific container for monitoring and troubleshooting.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/docker.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# check the container name you want to see\n$ docker ps\nCONTAINER ID   IMAGE                                              COMMAND                  CREATED         STATUS         PORTS                                                                                      NAMES\n3582f6d76227   docker-compose_compute                             \"/shell/compute.sh\"      2 minutes ago   Up 2 minutes   0.0.0.0:3080->3080/tcp, :::3080->3080/tcp, 0.0.0.0:55433->55433/tcp, :::55433->55433/tcp   docker-compose_compute_1\n(...omit...)\n\n$ docker logs -f docker-compose_compute_1\n2022-10-21 06:15:48.757 GMT [56] LOG:  connection authorized: user=cloud_admin database=postgres application_name=psql\n2022-10-21 06:17:00.307 GMT [56] LOG:  [NEON_SMGR] libpagestore: connected to 'host=pageserver port=6400'\n(...omit...)\n```\n\n----------------------------------------\n\nTITLE: Starting Proxy with Local Postgres for SQL over HTTP (Bash)\nDESCRIPTION: Command to start the proxy binary with a local Postgres installation, configuring SSL certificates and authentication backend for testing SQL over HTTP functionality.\nSOURCE: https://github.com/neondatabase/neon/blob/main/proxy/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./target/debug/proxy -c server.crt -k server.key --auth-backend=postgres --auth-endpoint=postgres://stas@127.0.0.1:5432/stas --wss 0.0.0.0:4444\n```\n\n----------------------------------------\n\nTITLE: WALProposer Shutdown Order Modification in C\nDESCRIPTION: This patch modifies the shutdown process to treat the walproposer background worker like a WAL sender, ensuring it's shut down only after the checkpointer has written the shutdown checkpoint record. This ensures the shutdown record reaches the safekeepers.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/core_changes.md#2025-04-22_snippet_5\n\nLANGUAGE: c\nCODE:\n```\n+                       /* Neon: Also allow walproposer background worker to be treated like a WAL sender, so that it's shut down last */\n+                       if ((bp->bkend_type == BACKEND_TYPE_NORMAL || bp->bkend_type == BACKEND_TYPE_BGWORKER) &&\n```\n\n----------------------------------------\n\nTITLE: Running GitHub Workflow to Pin Build-Tools Image\nDESCRIPTION: Command to update the 'pinned' tag of the build-tools image using the pin-build-tools-image.yml workflow. The command specifies the source tag to use for pinning.\nSOURCE: https://github.com/neondatabase/neon/blob/main/CONTRIBUTING.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngh workflow -R neondatabase/neon run pin-build-tools-image.yml \\\n            -f from-tag=cc98d9b00d670f182c507ae3783342bd7e64c31e\n```\n\n----------------------------------------\n\nTITLE: Defining RelDirectory Structure in Rust\nDESCRIPTION: Defines the RelDirectory struct used to serialize relation directory information into a single key. It contains a HashSet of relations identified by Oid and fork number.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/041-rel-sparse-keyspace.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug, Serialize, Deserialize, Default)]\npub(crate) struct RelDirectory {\n    // Set of relations that exist. (relfilenode, forknum)\n    //\n    // TODO: Store it as a btree or radix tree or something else that spans multiple\n    // key-value pairs, if you have a lot of relations\n    pub(crate) rels: HashSet<(Oid, u8)>,\n}\n```\n\n----------------------------------------\n\nTITLE: Structuring Extension Index JSON for PostgreSQL\nDESCRIPTION: Shows the structure of the ext_index.json file, which contains information about public extensions, library indices, and extension data including control files and archive paths.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/024-extension-loading.md#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"public_extensions\": [\n        \"anon\",\n        \"pg_buffercache\"\n    ],\n    \"library_index\": {\n        \"anon\": \"anon\",\n        \"pg_buffercache\": \"pg_buffercache\"\n        // for more complex extensions like postgis\n        // we might have something like:\n        // address_standardizer: postgis\n        // postgis_tiger: postgis\n    },\n    \"extension_data\": {\n        \"pg_buffercache\": {\n            \"control_data\": {\n                \"pg_buffercache.control\": \"# pg_buffercache extension \\ncomment = 'examine the shared buffer cache' \\ndefault_version = '1.3' \\nmodule_pathname = '$libdir/pg_buffercache' \\nrelocatable = true \\ntrusted=true\"\n            },\n            \"archive_path\": \"5670669815/v14/extensions/pg_buffercache.tar.zst\"\n        },\n        \"anon\": {\n            \"control_data\": {\n                \"anon.control\": \"# PostgreSQL Anonymizer (anon) extension \\ncomment = 'Data anonymization tools' \\ndefault_version = '1.1.0' \\ndirectory='extension/anon' \\nrelocatable = false \\nrequires = 'pgcrypto' \\nsuperuser = false \\nmodule_pathname = '$libdir/anon' \\ntrusted = true \\n\"\n            },\n            \"archive_path\": \"5670669815/v14/extensions/anon.tar.zst\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Validate API Response Schema\nDESCRIPTION: JSON schema for the /validate API response containing tenant IDs and their validation status\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/025-generation-numbers.md#2025-04-22_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  'tenants': [{tenant: <tenant id>, status: <bool>}...]\n}\n```\n\n----------------------------------------\n\nTITLE: SQL over HTTP Response Example (JSON)\nDESCRIPTION: Sample JSON response from the SQL over HTTP endpoint, showing the structure of the result including command, fields, row count, and data rows.\nSOURCE: https://github.com/neondatabase/neon/blob/main/proxy/README.md#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"command\": \"SELECT\",\n  \"fields\": [\n    { \"dataTypeID\": 1007, \"name\": \"arr\" },\n    { \"dataTypeID\": 3802, \"name\": \"obj\" },\n    { \"dataTypeID\": 23, \"name\": \"num\" }\n  ],\n  \"rowCount\": 1,\n  \"rows\": [\n    {\n      \"arr\": [[1,2],[3,4]],\n      \"num\": 42,\n      \"obj\": {\n        \"ikey\": 4242,\n        \"key\": \"val\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting to Proxy with psql Client (Bash)\nDESCRIPTION: Example psql command to connect to the proxy using SSL/TLS, demonstrating how to specify the root certificate and connection string.\nSOURCE: https://github.com/neondatabase/neon/blob/main/proxy/README.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nPGSSLROOTCERT=./server.crt psql  \"postgresql://proxy:password@endpoint.local.neon.build:4432/postgres?sslmode=verify-full\"\n```\n\n----------------------------------------\n\nTITLE: Checking Rust Third-Party Dependencies\nDESCRIPTION: Command to run Cargo Deny, a tool that checks the project's dependency graph for security issues, license compliance, and trusted sources.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/sourcetree.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo deny check\n```\n\n----------------------------------------\n\nTITLE: Visualizing Timeline State Transitions with Mermaid Diagram\nDESCRIPTION: A state diagram showing the lifecycle of a timeline through different states: from active to archived, offloaded, and back to active (either cold or warm).\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/035-timeline-archive.md#2025-04-22_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nstateDiagram\n  [*] --> Active(warm)\n  Active(warm) --> Archived\n  Archived --> Offloaded\n  Archived --> Active(warm)\n  Offloaded --> Active(cold)\n  Active(cold) --> Active(warm)\n```\n\n----------------------------------------\n\nTITLE: HTTP API Routes in Pageserver\nDESCRIPTION: The HTTP API endpoints for managing tenants and timelines in the pageserver. These endpoints provide a high-level CRUD interface for tenant and timeline management without directly interacting with layer-level operations.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/017-timeline-data-management.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n.get(\"/v1/status\", status_handler) // pageserver status\n.get(\"/v1/tenant\", tenant_list_handler)\n.post(\"/v1/tenant\", tenant_create_handler) // can create \"empty\" timelines or branch off the existing ones\n.get(\"/v1/tenant/:tenant_id\", tenant_status) // the only tenant public metadata\n.put(\"/v1/tenant/config\", tenant_config_handler) // tenant config data and local file manager\n.get(\"/v1/tenant/:tenant_id/timeline\", timeline_list_handler)\n.post(\"/v1/tenant/:tenant_id/timeline\", timeline_create_handler)\n.post(\"/v1/tenant/:tenant_id/attach\", tenant_attach_handler) // download entire tenant from the remote storage and load its timelines memory\n.post(\"/v1/tenant/:tenant_id/detach\", tenant_detach_handler) // delete all tenant timelines from memory, remote corresponding storage and local FS files\n.get(\"/v1/tenant/:tenant_id/timeline/:timeline_id\", timeline_detail_handler)\n.delete(\"/v1/tenant/:tenant_id/timeline/:timeline_id\", timeline_delete_handler)\n.get(\"/v1/tenant/:tenant_id/timeline/:timeline_id/wal_receiver\", wal_receiver_get_handler) // get walreceiver stats metadata\n```\n\n----------------------------------------\n\nTITLE: Running Clippy Linter for Compute Tools\nDESCRIPTION: Command to run the Clippy linter on all targets with strict warnings and idiom checks for the compute tools codebase.\nSOURCE: https://github.com/neondatabase/neon/blob/main/compute_tools/README.md#2025-04-22_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ncargo clippy --all --all-targets -- -Dwarnings -Drust-2018-idioms\n```\n\n----------------------------------------\n\nTITLE: Defining Transaction States in Rust for Neon Control Plane\nDESCRIPTION: This code snippet defines the data structures used by the Control Plane to track transaction states. It includes a Tenant struct with transaction tracking and a Transaction struct with various states representing the lifecycle of a transaction.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/026-pageserver-s3-mvcc.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Tenant {\n  ...\n\n  txns: HashMap<TxnId, Transaction>,\n  // the most recently started txn's id; only most recently started can win\n  next_winner_txn: Option<TxnId>,\n}\nstruct Transaction {\n  id: TxnId, // immutable\n  last_committed_txn: TxnId, // immutable; the most recent txn in state `Committed`\n                             // when self was started\n  pageserver_id: PageserverId,\n  state: enum {\n    Open,\n    Committed,\n    RejectPending,\n    RejectAcknowledged, // invariant: we know all S3 activity has ceded\n    GarbageCollected,\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Self-Signed Certificate for Testing (Bash)\nDESCRIPTION: OpenSSL command to generate a self-signed certificate for local testing of the proxy with SSL/TLS support.\nSOURCE: https://github.com/neondatabase/neon/blob/main/proxy/README.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nopenssl req -new -x509 -days 365 -nodes -text -out server.crt -keyout server.key -subj \"/CN=*.local.neon.build\"\n```\n\n----------------------------------------\n\nTITLE: Safekeeper State Example\nDESCRIPTION: Example showing the state of three safekeepers (S1, S2, S3) with different epochs and WAL records, demonstrating how the system handles record synchronization and epoch changes.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/safekeeper-protocol.md#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nS1(1): R1(a)\nS2(1): R1(a),R2(b)\nS3(1): R1(a),R2(b),R3(c),R4(d)  - offline\n```\n\n----------------------------------------\n\nTITLE: Visualizing Tenant Migration Flow with Mermaid\nDESCRIPTION: A sequence diagram showing the interaction between Control Plane, Node A (source), Node B (destination), and Endpoint during the tenant migration process. It illustrates the steps from initial state change through WAL ingestion to final cutover.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/028-pageserver-migration.md#2025-04-22_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\nparticipant CP as Control plane\nparticipant A as Node A\nparticipant B as Node B\nparticipant E as Endpoint\n\nCP->>A: PUT Flush & go to AttachedStale\nnote right of A: A continues to ingest WAL\nCP->>B: PUT AttachedMulti\nCP->>B: PUT Download layers from latest heatmap\nnote right of B: B downloads from S3\nloop Poll until download complete\nCP->>B: GET download status\nend\nactivate B\nnote right of B: B ingests WAL\nloop Poll until catch up\nCP->>B: GET visible WAL\nCP->>A: GET visible WAL\nend\ndeactivate B\nCP->>E: Configure to use Node B\nE->>B: Connect for reads\nCP->>B: PUT AttachedSingle\nCP->>A: PUT Secondary\n```\n\n----------------------------------------\n\nTITLE: Configuring Storage Controller for Safekeeper Selection\nDESCRIPTION: Adds a configuration option to the storage controller to enable or disable safekeeper selection for timeline creation.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/035-safekeeper-dynamic-membership-change.md#2025-04-22_snippet_11\n\nLANGUAGE: markdown\nCODE:\n```\n- storcon gets `-set-safekeepers` config option disabled by\\n  default.\n```\n\n----------------------------------------\n\nTITLE: Connecting to PostgreSQL in Proposed Serverless Workflow\nDESCRIPTION: Command demonstrating how to connect to PostgreSQL in the proposed serverless workflow. This uses a 'branch' parameter in the connection string to automatically launch the appropriate PostgreSQL instance.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/007-serverless-on-laptop.md#2025-04-22_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ psql \"dbname=postgres port=5432 branch=heikki\"\npsql (14devel)\nType \"help\" for help.\n\npostgres=# \n```\n\n----------------------------------------\n\nTITLE: Defining Tenant Manifest JSON Structure for Offloaded Timelines\nDESCRIPTION: JSON schema for the tenant manifest file that tracks offloaded timelines, including metadata about timeline states, logical and physical sizes, and parent-child relationships.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/035-timeline-archive.md#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"offload_timelines\": [\n    {\n      \"timeline_id\": ...\n      \"last_record_lsn\": ...\n      \"last_record_lsn_time\": ...\n      \"pitr_interval\": ...\n      \"last_gc_lsn\": ...  # equal to last_record_lsn if this branch has no history (i.e. a snapshot)\n      \"logical_size\": ...  # The size at last_record_lsn\n      \"physical_size\" ...\n      \"parent\": Option<{\n        \"timeline_id\"...\n        \"lsn\"... # Branch point LSN on the parent\n        \"requires_data\": bool # True if this branch depends on layers in its parent, identify it here\n\n      }>\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Neon Cluster with Docker Compose\nDESCRIPTION: Command sequence for creating and managing Neon database containers using Docker Compose. This snippet demonstrates how to specify PostgreSQL version and image tag, tear down existing containers, and create a new cluster.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/docker.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ cd docker-compose/\n$ docker-compose down   # remove the containers if exists\n$ PG_VERSION=16 TAG=latest docker-compose up --build -d  # You can specify the postgres and image version\nCreating network \"dockercompose_default\" with the default driver\nCreating docker-compose_storage_broker_1       ... done\n(...omit...)\n```\n\n----------------------------------------\n\nTITLE: Pageserver Metric Format Example in JSON\nDESCRIPTION: Illustrates the format of a pageserver metric being sent to the endpoint. This example shows an 'absolute' type metric for remote storage size with various metadata including tenant_id and timeline_id.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/consumption_metrics.md#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n\"metric\": \"remote_storage_size\",\n\"type\": \"absolute\",\n\"time\": \"2022-12-28T11:07:19.317310284Z\",\n\"idempotency_key\": \"2022-12-28 11:07:19.317310324 UTC-1-4019\",\n\"value\": 12345454,\n\"tenant_id\": \"5d07d9ce9237c4cd845ea7918c0afa7d\",\n\"timeline_id\": \"a03ebb4f5922a1c56ff7485cc8854143\",\n}\n```\n\n----------------------------------------\n\nTITLE: ASCII Diagram of LSM Tree Architecture\nDESCRIPTION: A visual representation of the LSM tree structure showing the hierarchy of Memtable, L0, and L1 layers along with their relationship to LSN and Page ID dimensions. Also includes a simple representation of a layer file.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/014-storage-lsm.md#2025-04-22_snippet_0\n\nLANGUAGE: ascii-art\nCODE:\n```\n^\nLSN\n|\n|      Memtable:     +-----------------------------+\n|                    |                             |\n|                    +-----------------------------+\n|\n|\n|            L0:     +-----------------------------+\n|                    |                             |\n|                    +-----------------------------+\n|\n|                    +-----------------------------+\n|                    |                             |\n|                    +-----------------------------+\n|\n|                    +-----------------------------+\n|                    |                             |\n|                    +-----------------------------+\n|\n|                    +-----------------------------+\n|                    |                             |\n|                    +-----------------------------+\n|\n|\n|           L1:      +-------+ +-----+ +--+  +-+\n|                    |       | |     | |  |  | |\n|                    |       | |     | |  |  | |\n|                    +-------+ +-----+ +--+  +-+\n|\n|                       +----+ +-----+ +--+  +----+\n|                       |    | |     | |  |  |    |\n|                       |    | |     | |  |  |    |\n|                       +----+ +-----+ +--+  +----+\n|\n+--------------------------------------------------------------> Page ID\n\n\n+---+\n|   |   Layer file\n+---+\n```\n\n----------------------------------------\n\nTITLE: Configuration Switch Response Structure in Rust\nDESCRIPTION: Defines the response structure returned when a safekeeper processes a configuration switch request. It contains the current configuration, term information, and the flush LSN (Log Sequence Number).\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/035-safekeeper-dynamic-membership-change.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct ConfigurationSwitchResponse {\n    conf: Configuration,\n    term: Term,\n    last_log_term: Term,\n    flush_lsn: Lsn,\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Test User and Database in Neon Environment\nDESCRIPTION: Commands to set up a test environment with neon_superuser role and test user access. Creates a neondb database and test user similar to the cloud service configuration.\nSOURCE: https://github.com/neondatabase/neon/blob/main/control_plane/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo neon endpoint create main --pg-version 16 --update-catalog true\ncargo neon endpoint start main --create-test-user true\n```\n\n----------------------------------------\n\nTITLE: Database Table Design for Leader Management\nDESCRIPTION: Schema design for leader table tracking storage controller leadership with fields for hostname, start_timestamp, last_renewed, lease_duration, and term to manage leader election and prevent split brain scenarios.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/037-storage-controller-restarts.md#2025-04-22_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE leader (\n  hostname TEXT,\n  start_timestamp TIMESTAMP,\n  last_renewed TIMESTAMP,\n  lease_duration INTERVAL,\n  term INTEGER\n)\n```\n\n----------------------------------------\n\nTITLE: Starting Minio Server for Local S3 Testing\nDESCRIPTION: Command for starting a Minio server for local S3-compatible testing.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/README.md#2025-04-22_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n# Start in Terminal 1\nmkdir /tmp/minio_data\nminio server /tmp/minio_data --console-address 127.0.0.1:9001 --address 127.0.0.1:9000\n```\n\n----------------------------------------\n\nTITLE: Converting LSN to float8 for Prometheus Metrics\nDESCRIPTION: Best practice for handling LSN (Log Sequence Number) values in sql_exporter metrics. LSN values should be cast to float8 for Prometheus compatibility, as it only supports float values. The float8 type can safely store integers between -2^53 and +2^53.\nSOURCE: https://github.com/neondatabase/neon/blob/main/compute/etc/README.md#2025-04-22_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCAST(lsn_value AS float8)\n```\n\n----------------------------------------\n\nTITLE: Protocol Flow Documentation for Ingest Processing\nDESCRIPTION: Documentation of the WAL ingestion pipeline showing the sequence of operations from network socket read to InMemoryLayer writing.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/041-sharded-ingest.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n1. `handle_walreceiver_connection` reads a stream of binary WAL records off a network\\n2. `WalIngest::ingest_record` to translate the record into a series of page-level modifications\\n3. `DatadirModification` accumulates page updates from several `ingest_record` calls, and when\\n   its `commit()` method is called, flushes these into a Timeline's open `InMemoryLayer`.\n```\n\n----------------------------------------\n\nTITLE: Defining MigrationRequest Enum in Rust\nDESCRIPTION: Defines an enum for migration requests, representing either a migration to specific nodes or a request to finish pending operations.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/035-safekeeper-dynamic-membership-change.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nenum MigrationRequest {\n    To(Vec<NodeId>),\n    FinishPending,\n}\n```\n\n----------------------------------------\n\nTITLE: Restarting Pageserver from Latest Snapshot\nDESCRIPTION: Command to restart pageserver using storage configuration from existing config, automatically using the latest snapshot from the configured storage destination.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/009-snapshot-first-storage-cli.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nneon start\n```\n\n----------------------------------------\n\nTITLE: Running Clickhouse Logical Replication Tests with Docker Compose\nDESCRIPTION: This snippet demonstrates how to set up the environment, start Docker containers, run Clickhouse-specific tests, and then tear down the containers. It uses a Neon database connection string and pytest for test execution.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/logical_repl/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport BENCHMARK_CONNSTR=postgres://user:pass@ep-abc-xyz-123.us-east-2.aws.neon.build/neondb\n\ndocker compose -f test_runner/logical_repl/clickhouse/docker-compose.yml up -d\n./scripts/pytest -m remote_cluster -k test_clickhouse\ndocker compose -f test_runner/logical_repl/clickhouse/docker-compose.yml down\n```\n\n----------------------------------------\n\nTITLE: Running TLC Model Checker Command\nDESCRIPTION: Command to execute the TLA+ model checker (TLC) for verifying the consensus algorithm specifications. Files with MC*.tla contain TLC-specific configurations while other .tla files contain the core specifications.\nSOURCE: https://github.com/neondatabase/neon/blob/main/safekeeper/spec/readme.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmodelcheck.sh\n```\n\n----------------------------------------\n\nTITLE: Converting Relation and Block Number to Key in Rust\nDESCRIPTION: This function converts a relation tag (RelTag) and block number (BlockNumber) into a Key structure. It maps various components of the relation and block number to the corresponding fields in the Key structure.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/031-sharding-static.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn rel_block_to_key(rel: RelTag, blknum: BlockNumber) -> Key {\n    Key {\n        field1: 0x00,\n        field2: rel.spcnode,\n        field3: rel.dbnode,\n        field4: rel.relnode,\n        field5: rel.forknum,\n        field6: blknum,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Structure for Safekeeper Identity\nDESCRIPTION: JSON schema representing a safekeeper identity with node_id and host information. This structure is used as part of the safekeeper notification payload to identify each safekeeper in the configuration.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/035-safekeeper-dynamic-membership-change.md#2025-04-22_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n   node_id: u64,\n   host: String\n}\n```\n\n----------------------------------------\n\nTITLE: Markdown Documentation Structure\nDESCRIPTION: Documentation outline showing the hierarchical organization of Neon's technical documentation, including architecture components, services, and implementation details.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/SUMMARY.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Summary\n\n# Looking for `neon.tech` docs?\n\nThis page linkes to a selection of technical content about the open source code in this repository.\n\nPlease visit https://neon.tech/docs for documentation about using the Neon service, which is based on the code\nin this repository.\n\n# Architecture\n\n[Introduction]()\n- [Separation of Compute and Storage](./separation-compute-storage.md)\n\n- [Compute]()\n  - [Postgres changes](./core_changes.md)\n\n- [Pageserver](./pageserver.md)\n    - [Services](./pageserver-services.md)\n    - [Thread management](./pageserver-thread-mgmt.md)\n    - [WAL Redo](./pageserver-walredo.md)\n    - [Page cache](./pageserver-pagecache.md)\n    - [Storage](./pageserver-storage.md)\n    - [Compaction](./pageserver-compaction.md)\n    - [Processing a GetPage request](./pageserver-processing-getpage.md)\n    - [Processing WAL](./pageserver-processing-wal.md)\n\n- [WAL Service](walservice.md)\n  - [Consensus protocol](safekeeper-protocol.md)\n\n- [Source view](./sourcetree.md)\n  - [docker.md](./docker.md) — Docker images and building pipeline.\n  - [Error handling and logging](./error-handling.md)\n\n- [Glossary](./glossary.md)\n\n# Uncategorized\n\n- [authentication.md](./authentication.md)\n- [multitenancy.md](./multitenancy.md) — how multitenancy is organized in the pageserver and Zenith CLI.\n- [settings.md](./settings.md)\n#FIXME: move these under sourcetree.md\n#- [postgres_ffi/README.md](/libs/postgres_ffi/README.md)\n#- [test_runner/README.md](/test_runner/README.md)\n\n\n# RFCs\n\nMajor changes are documented in RFCS:\n- See [RFCs](./rfcs/README.md) for more information\n- view the RFCs at https://github.com/neondatabase/neon/tree/main/docs/rfcs\n```\n\n----------------------------------------\n\nTITLE: Simplistic Approach with Maintenance Mode in Mermaid\nDESCRIPTION: Sequence diagram showing a simplified approach using maintenance mode, where the source pageserver is put into ignore state first, followed by attaching on the target pageserver. This approach trades off some downtime for simplicity.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/023-the-state-of-pageserver-tenant-relocation.md#2025-04-22_snippet_5\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    participant CP as Control Plane\n    participant PS1 as Pageserver 1\n    participant PS2 as Pageserver 2\n    participant SK as Safekeeper\n    participant S3\n\n    CP->>CP: Enable maintenance mode\n    CP->>PS1: Ignore\n    CP->>PS2: Attach\n    PS2->>CP: Accepted\n    loop Delete layers for each timeline\n        CP->>PS2: Get last record lsn\n        CP->>SK: Get commit lsn\n        CP->>CP: OK? Timed out?\n    end\n    CP->>CP: Change pageserver id in project\n    CP->>CP: Run successful availability check\n    CP->>CP: Disable maintenance mode\n    CP->>PS1: Detach ignored\n```\n\n----------------------------------------\n\nTITLE: External Elections Flow for Pageserver Leadership\nDESCRIPTION: This sequence diagram shows how a pageserver would determine its leadership role by querying the Control Plane, then either assuming leader responsibilities (running background jobs) or becoming a follower and subscribing to index changes.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/020-pageserver-s3-coordination.md#2025-04-22_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    participant PS1\n    participant CP as Control Plane\n    participant S3\n    participant PS2\n\n    note over PS1,PS2: PS1 starts up and still a leader\n    PS1->>CP: Am I still the leader for Tenant X?\n    activate CP\n    CP->>PS1: Yes\n    deactivate CP\n    PS1->>S3: Fetch PS1 index.\n    note over PS1: Continue operations, start background jobs\n    note over PS1,PS2: PS1 starts up and still and is not a leader anymore\n    PS1->>CP: Am I still the leader for Tenant X?\n    CP->>PS1: No\n    PS1->>PS2: Subscribe to index changes\n    PS1->>S3: Fetch PS1 and PS2 indexes\n    note over PS1: Combine index file to include layers <br> from both indexes to be able <br> to see newer files from leader (PS2)\n    note over PS1: Continue operations, do not start background jobs\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Neon on Ubuntu/Debian\nDESCRIPTION: Command to install necessary packages for building Neon on Ubuntu or Debian-based systems. Includes build tools, libraries, and development packages.\nSOURCE: https://github.com/neondatabase/neon/blob/main/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\napt install build-essential libtool libreadline-dev zlib1g-dev flex bison libseccomp-dev \\\nlibssl-dev clang pkg-config libpq-dev cmake postgresql-client protobuf-compiler \\\nlibprotobuf-dev libcurl4-openssl-dev openssl python3-poetry lsof libicu-dev\n```\n\n----------------------------------------\n\nTITLE: File Modifications for Index Building\nDESCRIPTION: Changes to GIN, GiST, and SPGiST index building process to explicitly mark index builds that use buffer manager without logging. Includes modifications to smgr interface to track unlogged build operations.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/core_changes.md#2025-04-22_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nsrc/backend/access/gin/gininsert.c                          |    7 +\nsrc/backend/access/gist/gistbuild.c                         |   15 +-\nsrc/backend/access/spgist/spginsert.c                       |    8 +-\n```\n\n----------------------------------------\n\nTITLE: Visualizing Concurrent GC and Compaction Issues in Mermaid\nDESCRIPTION: Sequence diagram illustrating how concurrent GC and compaction operations between two pageservers can lead to data inconsistency in S3 storage, particularly with index files. Shows how uploading new layers while compaction is happening can create invalid state.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/023-the-state-of-pageserver-tenant-relocation.md#2025-04-22_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    participant PS1\n    participant S3\n    participant PS2\n\n    PS1->>S3: Uploads L1, L2 <br/> Index contains L1 L2\n    PS2->>S3: Attach called, sees L1, L2\n    PS1->>S3: Compaction comes <br/> Removes L1, adds L3\n    note over S3: Index now L2, L3\n    PS2->>S3: Uploads new layer L4 <br/> (added to previous view of the index)\n    note over S3: Index now L1, L2, L4\n```\n\n----------------------------------------\n\nTITLE: Architectural Diagram - Service Components and Data Flow\nDESCRIPTION: ASCII diagram showing the proposed architecture with console, control-plane, storage components and their interactions. Illustrates separation between external/internal areas and closed/open-source boundaries.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/017-console-split.md#2025-04-22_snippet_0\n\nLANGUAGE: markup\nCODE:\n```\n.                    x\n       external area x internal area\n       (our clients) x (our services)\n                     x\n                     x                                                      ┌───────────────────────┐\n                     x ┌───────────────┐   >    ┌─────────────────────┐     │      Storage (EC2)    │\n                     x │  console db   │   >    │  control-plane db   │     │                       │\n                     x └───────────────┘   >    └─────────────────────┘     │ - safekeepers         │\n                     x         ▲           >               ▲                │ - pageservers         │\n                     x         │           >               │                │                       │\n┌──────────────────┐ x ┌───────┴───────┐   >               │                │     Dependencies      │\n│    browser UI    ├──►│               │   >    ┌──────────┴──────────┐     │                       │\n└──────────────────┘ x │               │   >    │                     │     │ - etcd                │\n                     x │    console    ├───────►│    control-plane    ├────►│ - S3                  │\n┌──────────────────┐ x │               │   >    │  (deployed in k8s)  │     │ - more?               │\n│public API clients├──►│               │   >    │                     │     │                       │\n└──────────────────┘ x └───────┬───────┘   >    └──────────┬──────────┘     └───────────────────────┘\n                     x         │           >          ▲    │                            ▲\n                     x         │           >          │    │                            │\n                     x ┌───────┴───────┐   >          │    │                ┌───────────┴───────────┐\n                     x │ dependencies  │   >          │    │                │                       │\n                     x │- analytics    │   >          │    └───────────────►│       computes        │\n                     x │- auth         │   >          │                     │   (deployed in k8s)   │\n                     x │- billing      │   >          │                     │                       │\n                     x └───────────────┘   >          │                     └───────────────────────┘\n                     x                     >          │                                 ▲\n                     x                     >    ┌─────┴───────────────┐                 │\n┌──────────────────┐ x                     >    │                     │                 │\n│                  │ x                     >    │        proxy        ├─────────────────┘\n│     postgres     ├───────────────────────────►│  (deployed in k8s)  │\n│      users       │ x                     >    │                     │\n│                  │ x                     >    └─────────────────────┘\n└──────────────────┘ x                     >\n                                           >\n                                           >\n                             closed-source > open-source\n                                           >\n                                           >\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Structure for Safekeeper Notification in Control Plane API\nDESCRIPTION: JSON schema for the \"/notify-safekeepers\" endpoint that allows the storage controller to inform the control plane about updated safekeeper configurations. It includes tenant and timeline identifiers, configuration generation number, and the list of safekeepers.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/035-safekeeper-dynamic-membership-change.md#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n   tenant_id: String,\n   timeline_id: String,\n   generation: u32,\n   safekeepers: Vec<SafekeeperId>,\n}\n```\n\n----------------------------------------\n\nTITLE: Running compute_ctl with Command Line Arguments\nDESCRIPTION: Example command showing how to start the compute_ctl wrapper with necessary parameters including data directory path, connection string, spec file location, and postgres binary path.\nSOURCE: https://github.com/neondatabase/neon/blob/main/compute_tools/README.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncompute_ctl -D /var/db/postgres/compute \\\n            -C 'postgresql://cloud_admin@localhost/postgres' \\\n            -S /var/db/postgres/specs/current.json \\\n            -b /usr/local/bin/postgres\n```\n\n----------------------------------------\n\nTITLE: Building Neon with Testing Features for Performance Tests\nDESCRIPTION: Command to build Neon with release optimization and testing features enabled, using make with parallel jobs for faster compilation.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/performance/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nBUILD_TYPE=release CARGO_BUILD_FLAGS=\"--features=testing\" make -s -j8\n```\n\n----------------------------------------\n\nTITLE: ProcessInterrupts Callback Hook for Backpressure in C\nDESCRIPTION: This modification adds a callback hook to the ProcessInterrupts function, allowing the pageserver to implement backpressure when it can't ingest WAL fast enough. The callback can signal to retry interrupt processing if needed.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/core_changes.md#2025-04-22_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n@@ -3200,6 +3202,7 @@ ProcessInterrupts(void)\n                return;\n        InterruptPending = false;\n \n+retry:\n        if (ProcDiePending)\n        {\n                ProcDiePending = false;\n@@ -3447,6 +3450,13 @@ ProcessInterrupts(void)\n \n        if (ParallelApplyMessagePending)\n                HandleParallelApplyMessages();\n+\n+       /* Call registered callback if any */\n+       if (ProcessInterruptsCallback)\n+       {\n+               if (ProcessInterruptsCallback())\n+                       goto retry;\n+       }\n }\n```\n\n----------------------------------------\n\nTITLE: Pageserver Cutover Sequence Diagram\nDESCRIPTION: Mermaid sequence diagram showing the process of cutting over from an unavailable pageserver to a new node, depicting interactions between Node A, Control plane, Node B, and Endpoint\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/028-pageserver-migration.md#2025-04-22_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\nparticipant A as Node A\nparticipant CP as Control plane\nparticipant B as Node B\nparticipant E as Endpoint\n\nnote right of A: Node A offline\nactivate A\nCP->>B: PUT AttachedSingle\nCP->>E: Configure to use Node B\nE->>B: Connect for reads\ndeactivate A\n```\n\n----------------------------------------\n\nTITLE: Defining Pageserver Storage Path Format for Sharded Tenants\nDESCRIPTION: Storage path format for layer files in sharded tenants, including the tenant ID, shard number, shard count, timeline ID, layer file name and generation number.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/031-sharding-static.md#2025-04-22_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\npageserver/v1/tenants/<tenant_id>-<shard_number><shard_count>/timelines/<timeline id>/<layer file name>-<generation>\n```\n\n----------------------------------------\n\nTITLE: Visualizing Final Timeline Structure After Cleanup\nDESCRIPTION: ASCII diagram showing the final clean timeline structure after removing unwanted timelines, leaving only the 'new main' timeline and child A without any trace of the rollback operation.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/034-ancestor-deletion.md#2025-04-22_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n| ----\"new main\" timeline----------->\n                |\n                |-> child A\n\n\n```\n\n----------------------------------------\n\nTITLE: Proposed Control-Plane API Endpoints\nDESCRIPTION: Lists the proposed HTTP API endpoints for the new control-plane service, following a similar pattern to the existing console API, but using tenant_id as the primary identifier instead of project_id.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/017-console-split.md#2025-04-22_snippet_2\n\nLANGUAGE: http\nCODE:\n```\nGET /tenants/{tenant_id}\nPATCH /tenants/{tenant_id}\nPOST /tenants/{tenant_id}/branches\nGET /tenants/{tenant_id}/databases\nPOST /tenants/{tenant_id}/databases\nGET /tenants/{tenant_id}/databases/{database_id}\nPUT /tenants/{tenant_id}/databases/{database_id}\nDELETE /tenants/{tenant_id}/databases/{database_id}\nPOST /tenants/{tenant_id}/delete\nGET /tenants/{tenant_id}/issue_token\nGET /tenants/{tenant_id}/operations\nGET /tenants/{tenant_id}/operations/{operation_id}\nPOST /tenants/{tenant_id}/query\nGET /tenants/{tenant_id}/roles\nPOST /tenants/{tenant_id}/roles\nGET /tenants/{tenant_id}/roles/{role_name}\nDELETE /tenants/{tenant_id}/roles/{role_name}\nPOST /tenants/{tenant_id}/roles/{role_name}/reset_password\nPOST /tenants/{tenant_id}/start\nPOST /tenants/{tenant_id}/stop\nPOST /psql_session/{psql_session_id}\n```\n\n----------------------------------------\n\nTITLE: Running Performance Tests with Poetry and Pytest\nDESCRIPTION: Command to execute performance tests using Poetry and Pytest, specifying PostgreSQL version 17 and using the release build of Neon.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/performance/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nDEFAULT_PG_VERSION=17 NEON_BIN=./target/release poetry run pytest test_runner/performance\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Full Migration Process\nDESCRIPTION: Shows an example of the full migration process during image layer generation. It illustrates how old reldir keys are transformed into the new sparse keyspace format.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/041-rel-sparse-keyspace.md#2025-04-22_snippet_2\n\nLANGUAGE: plain\nCODE:\n```\ndb1/reldir_key -> (table 1, table 2, table 3)\n...db1 rel keys\ndb2/reldir_key -> (table 4, table 5, table 6)\n...db2 rel keys\nsparse_reldir_db2_table7 -> exists\nsparse_reldir_db1_table8 -> deleted\n```\n\n----------------------------------------\n\nTITLE: Basic Tenant Relocation Sequence in Mermaid\nDESCRIPTION: Sequence diagram showing the original proposed implementation for tenant relocation between pageservers. The process involves attaching the tenant to a new pageserver, fetching data from S3, updating project configuration, and detaching from the original pageserver.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/023-the-state-of-pageserver-tenant-relocation.md#2025-04-22_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    participant CP as Control Plane\n    participant PS1 as Pageserver 1\n    participant PS2 as Pageserver 2\n    participant S3\n\n    CP->>PS2: Attach tenant X\n    PS2->>S3: Fetch timelines, indexes for them\n    PS2->>CP: Accepted\n    CP->>CP: Change pageserver id in project\n    CP->>PS1: Detach\n```\n\n----------------------------------------\n\nTITLE: Defining LayeredTimelineEntry Enum in Rust\nDESCRIPTION: This code snippet defines an enum 'LayeredTimelineEntry' with two variants: 'Loaded' containing an Arc<LayeredTimeline>, and 'Unloaded' containing a timeline ID and metadata. It demonstrates the current approach to timeline management, which is proposed to be changed.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/017-timeline-data-management.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Clone)]\nenum LayeredTimelineEntry {\n    Loaded(Arc<LayeredTimeline>),\n    Unloaded {\n        id: ZTimelineId,\n        metadata: TimelineMetadata,\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Sequence Caching in PostgreSQL\nDESCRIPTION: Disables PostgreSQL's sequence value pre-logging by setting SEQ_LOG_VALS to 0 instead of 32. This ensures each sequence update is WAL logged to maintain sequence order in Neon, preventing gaps when pages are evicted from buffer cache.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/core_changes.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ndiff --git a/src/backend/commands/sequence.c b/src/backend/commands/sequence.c\nindex 0415df9ccb..9f9db3c8bc 100644\n--- a/src/backend/commands/sequence.c\n+++ b/src/backend/commands/sequence.c\n@@ -53,7 +53,9 @@\n  * so we pre-log a few fetches in advance. In the event of\n  * crash we can lose (skip over) as many values as we pre-logged.\n  */\n-#define SEQ_LOG_VALS   32\n+/* Neon XXX: to ensure sequence order of sequence in Zenith we need to WAL log each sequence update. */\n+/* #define SEQ_LOG_VALS        32 */\n+#define SEQ_LOG_VALS   0\n```\n\n----------------------------------------\n\nTITLE: Running Cargo Benchmarks for Pageserver\nDESCRIPTION: Commands for executing benchmarks at different scopes using Cargo's bench command. Includes options for running all benchmarks, specific benchmark files, or individual benchmark functions.\nSOURCE: https://github.com/neondatabase/neon/blob/main/pageserver/benches/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo bench\n```\n\nLANGUAGE: shell\nCODE:\n```\ncargo bench --bench bench_layer_map\n```\n\nLANGUAGE: shell\nCODE:\n```\ncargo bench --bench bench_layer_map -- real_map_uniform_queries\n```\n\n----------------------------------------\n\nTITLE: Layer File History View from Main Branch Perspective\nDESCRIPTION: Shows the history of layer files for the 'orders' table from the main branch's perspective, showing the linear progression of layer files.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/pageserver-storage.md#2025-04-22_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\nmain/orders_100\nmain/orders_100_200\nmain/orders_200\nmain/orders_200_300\nmain/orders_300\nmain/orders_300_400\nmain/orders_400\n```\n\n----------------------------------------\n\nTITLE: Implementing WalProposer and Safekeeper Processes in Python for Neon Database\nDESCRIPTION: This code snippet defines two main processes: WalProposer and safekeeper. The WalProposer handles WAL replication, recovery, and coordination among safekeepers. The safekeeper process manages WAL storage, handles proposer requests, and maintains its state. Both processes work together to ensure consistent and fault-tolerant WAL management in the Neon database system.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/safekeeper-protocol.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nprocess WalProposer(safekeepers,server,curr_epoch,restart_lsn=0,message_queue={},feedbacks={})\n    function do_recovery(epoch,restart_lsn,VCL)\n        leader = i:safekeepers[i].state.epoch=epoch and safekeepers[i].state.flushLsn=VCL\n        wal_stream = safekeepers[leader].start_replication(restart_lsn,VCL)\n        do\n            message = wal_stream.read()\n            message_queue.append(message)\n        while message.startPos < VCL\n\n        for i in 1..safekeepers.size()\n            for message in message_queue\n                if message.endLsn < safekeepers[i].state.flushLsn\n                    message.delivered += i\n                else\n                    send_message(i, message)\n                    break\n    end function\n\n    function send_message(i,msg)\n        msg.restartLsn = restart_lsn\n        msg.commitLsn = get_commit_lsn()\n        safekeepers[i].send(msg, response_handler)\n    end function\n\n    function do_broadcast(message)\n        for i in 1..safekeepers.size()\n            if not safekeepers[i].sending()\n                send_message(i, message)\n    end function\n\n    function get_commit_lsn()\n        sorted_feedbacks = feedbacks.sort()\n        return sorted_feedbacks[safekeepers.size() - quorum]\n    end function\n\n    function response_handler(i,message,response)\n        feedbacks[i] = if response.epoch=curr_epoch then response.flushLsn else VCL\n        server.write(get_commit_lsn())\n\n        message.delivered += i\n        next_message = message_queue.next(message)\n        if next_message\n            send_message(i, next_message)\n\n        while message_queue.head.delivered.size() = safekeepers.size()\n            if restart_lsn < message_queue.head.beginLsn\n                restart_lsn = message_queue.head.endLsn\n            message_queue.pop_head()\n    end function\n\n    server_info = server.read()\n\n    safekeepers.write(server_info)\n    safekeepers.state = safekeepers.read()\n    next_term = max(safekeepers.state.nodeId.term)+1\n    restart_lsn = max(safekeepers.state.restartLsn)\n    epoch,VCL = max(safekeepers.state.epoch,safekeepers.state.flushLsn)\n    curr_epoch = epoch + 1\n\n    proposal = Proposal(NodeId(next_term,server.id),curr_epoch,VCL)\n    safekeepers.send(proposal)\n    responses = safekeepers.read()\n    if any responses.is_rejected()\n        exit()\n\n    for i in 1..safekeepers.size()\n        feedbacks[i].flushLsn = if epoch=safekeepers[i].state.epoch then safekeepers[i].state.flushLsn else restart_lsn\n\n    if restart_lsn != VCL\n        do_recovery(epoch,restart_lsn,VCL)\n\n    wal_stream = server.start_replication(VCL)\n    for ever\n        message = wal_stream.read()\n        message_queue.append(message)\n        do_broadcast(message)\nend process\n\nprocess safekeeper(gateway,state)\n    function handshake()\n        proposer = gateway.accept()\n        server_info = proposer.read()\n        proposer.write(state)\n        proposal = proposer.read()\n        if proposal.nodeId < state.nodeId\n            proposer.write(rejected)\n            return null\n        else\n            state.nodeId = proposal.nodeId\n            state.proposed_epoch = proposal.epoch\n            state.VCL = proposal.VCL\n            write_control_file(state)\n            proposer.write(accepted)\n            return proposer\n    end function\n\n    state = read_control_file()\n    state.flushLsn = locate_end_of_wal()\n\n    for ever\n        proposer = handshake()\n        if not proposer\n            continue\n        for ever\n            req = proposer.read()\n            if req.nodeId != state.nodeId\n                break\n            save_wal_file(req.data)\n            state.restartLsn = req.restartLsn\n            if state.epoch < state.proposed_epoch and req.endPos > max(state.flushLsn,state.VCL)\n                state.epoch = state.proposed_epoch\n            if req.endPos > state.flushLsn\n                state.flushLsn = req.endPos\n            save_control_file(state)\n            resp = Response(state.epoch,req.endPos)\n            proposer.write(resp)\n            notify_wal_sender(Min(req.commitLsn,req.endPos))\nend process\n```\n\n----------------------------------------\n\nTITLE: AUX File Key Encoding Example\nDESCRIPTION: Demonstration of how file paths are encoded into the keyspace, showing the structure of a 128-bit key including prefix and FNV hash components.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/038-aux-file-v2.md#2025-04-22_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n62 0000 01 01 7F8B83D94F7081693471ABF91C\n^ aux prefix\n        ^ assigned prefix of pg_logical/\n           ^ assigned prefix of mappings/\n              ^ 13B FNV hash of test1\n   ^ not used due to key representation\n```\n\n----------------------------------------\n\nTITLE: Generating SVG Flamegraph\nDESCRIPTION: Command to generate and view a flamegraph SVG directly from the profiling endpoint.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/040-profiling.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ curl localhost:9898/profile/cpu?format=svg >profile.svg\n$ open profile.svg\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Neon Data with Cloud\nDESCRIPTION: Commands to pull commits from the cloud and push local commits to the cloud environment.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/006-laptop-cli-v2-CLI.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n-- pull all the commits from the cloud\nneon pull\n-- push all the commits to the cloud\nneon push\n```\n\n----------------------------------------\n\nTITLE: Running Utils Package Benchmarks in Neon Project\nDESCRIPTION: Commands for running benchmarks in the utils package, including options for running all benchmarks, specific files or benchmarks, listing available benchmarks, and generating flamegraph profiles with pprof-rs.\nSOURCE: https://github.com/neondatabase/neon/blob/main/libs/utils/benches/README.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n# All benchmarks.\ncargo bench --package utils\n\n# Specific file.\ncargo bench --package utils --bench benchmarks\n\n# Specific benchmark.\ncargo bench --package utils --bench benchmarks log_slow/enabled=true\n\n# List available benchmarks.\ncargo bench --package utils --benches -- --list\n\n# Generate flamegraph profiles using pprof-rs, profiling for 10 seconds.\n# Output in target/criterion/*/profile/flamegraph.svg.\ncargo bench --package utils --bench benchmarks log_slow/enabled=true --profile-time 10\n```\n\n----------------------------------------\n\nTITLE: Illustrating L1 Layer Structure in Pageserver\nDESCRIPTION: A visual representation of how L1 layers are organized with a base of image layers and delta layers above them. This shows how different page ranges are managed at different LSN ranges, reducing read amplification compared to L0.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/pageserver-compaction.md#2025-04-22_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nDelta layers:               |     30-84@0310-04ff      |\nDelta layers:    | 10-42@0200-02ff |           | 65-92@0174-02aa |\nImage layers: |    0-39@0100    |    40-79@0100    |    80-99@0100    |\n```\n\n----------------------------------------\n\nTITLE: Neon Timeline Relocation Process\nDESCRIPTION: Sequence diagram showing the timeline relocation process between pageservers, including error scenarios and recovery mechanisms.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/015-storage-messaging.md#2025-04-22_snippet_4\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    participant C as Compute\n    participant SK1\n    participant SK2\n    participant SK3\n    participant PS1\n    participant PS2\n    participant O as Orchestrator\n    participant M as Metadata Service\n\n    note over C,M: Timeline is being relocated from PS1 to PS2\n    O->>+PS2: Attach timeline\n    PS2->>-O: 202 Accepted if timeline exists in S3\n    note over PS2: Download timeline from S3\n     note over O: Poll for timeline download (or subscribe to metadata service)\n    loop wait for attach to complete\n        O->>PS2: timeline detail should answer that timeline is ready\n    end\n    PS2->>M: Register downloaded timeline\n    PS2->>M: Get safekeepers for timeline, subscribe to changes\n    PS2->>SK1: Start replication to catch up\n    note over O: PS2 caught up, time to switch compute\n    O->>C: Restart compute with new pageserver url in config\n    note over C: Wal push is restarted\n    loop request pages\n        C->>+PS2: get_page@lsn\n        PS2->>-C: page image\n    end\n    O->>PS1: detach timeline\n    note over C,M: Scenario 1: Attach call failed\n    O--xPS2: Attach timeline\n    note over O: The operation can be safely retried, <br> if we hit some threshold we can try another pageserver\n    note over C,M: Scenario 2: Attach succeeded but pageserver failed to download the data or start replication\n    loop wait for attach to complete\n        O--xPS2: timeline detail should answer that timeline is ready\n    end\n    note over O: Can wait for a timeout, and then try another pageserver <br> there should be a limit on number of different pageservers to try\n    note over C,M: Scenario 3: Detach fails\n    O--xPS1: Detach timeline\n    note over O: can be retried, if continues to fail might lead to data duplication in s3\n```\n\n----------------------------------------\n\nTITLE: Defining etcd Data Structure for Timeline State Management in Ruby\nDESCRIPTION: Demonstrates the conceptual data structure for storing timeline state in etcd, showing how safekeepers would report their status including write_lsn, commit_lsn, and connection state.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/015-storage-messaging.md#2025-04-22_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\n\"compute_#{tenant}_#{timeline}\" => {\n    safekeepers => {\n        \"sk_#{sk_id}\" => {\n            write_lsn: \"0/AEDF130\",\n            commit_lsn: \"0/AEDF100\",\n            compute_connected: true,\n            last_updated: 1642621138,\n        },\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks with Cargo for postgres_ffi Package\nDESCRIPTION: This code snippet demonstrates various commands for running benchmarks using Cargo. It includes examples for running all benchmarks, specific files, individual benchmarks, listing available benchmarks, and generating flamegraph profiles. The commands target the postgres_ffi package and use the waldecoder benchmark as an example.\nSOURCE: https://github.com/neondatabase/neon/blob/main/libs/postgres_ffi/benches/README.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n# All benchmarks.\ncargo bench --package postgres_ffi\n\n# Specific file.\ncargo bench --package postgres_ffi --bench waldecoder\n\n# Specific benchmark.\ncargo bench --package postgres_ffi --bench waldecoder complete_record/size=1024\n\n# List available benchmarks.\ncargo bench --package postgres_ffi --benches -- --list\n\n# Generate flamegraph profiles using pprof-rs, profiling for 10 seconds.\n# Output in target/criterion/*/profile/flamegraph.svg.\ncargo bench --package postgres_ffi --bench waldecoder complete_record/size=1024 -- --profile-time 10\n```\n\n----------------------------------------\n\nTITLE: Pageserver Directory Structure for Multitenancy\nDESCRIPTION: The directory structure used by the pageserver to organize data by tenant. Each tenant has a separate directory identified by its hex ID.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/multitenancy.md#2025-04-22_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n<pageserver working directory>\n├── pageserver.log\n├── pageserver.pid\n├── pageserver.toml\n└── tenants\n   ├── 537cffa58a4fa557e49e19951b5a9d6b\n   ├── de182bc61fb11a5a6b390a8aed3a804a\n   └── ee6016ec31116c1b7c33dfdfca38891f\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling for Linux using Docker\nDESCRIPTION: Commands to cross-compile the compute tools from macOS to Linux using a Docker container with the Rust toolchain.\nSOURCE: https://github.com/neondatabase/neon/blob/main/compute_tools/README.md#2025-04-22_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\ndocker run --rm \\\n    -v $(pwd):/compute_tools \\\n    -w /compute_tools \\\n    -t rustlang/rust:nightly cargo build --release --target=x86_64-unknown-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Implementing Generation-Aware Safekeeper Configuration in Control Plane\nDESCRIPTION: Updates the control plane to prefix the safekeeper configuration with a generation number, enabling or disabling the new generation-based behavior.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/035-safekeeper-dynamic-membership-change.md#2025-04-22_snippet_12\n\nLANGUAGE: markdown\nCODE:\n```\n- control_plane [see above](storage_controller-<->-control-plane interface-and-changes)\\n  prefixes `neon.safekeepers` GUC with generation number.\n```\n\n----------------------------------------\n\nTITLE: Chunk Splitting Process in Neon Database\nDESCRIPTION: Outlines the step-by-step process for splitting a chunk when it reaches a soft storage limit. This process includes finding separation keys, updating metadata, and handling WAL replay.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/002-storage.md#2025-04-22_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n1. Find separation key and spawn two new chunks with [lo, mid) [mid, hi) boundaries.\n\n2. Prohibit WAL deletion and old SSTables deletion on original chunk.\n\n3. On each lsm layer we would need to split only one SSTable, all other would fit within left or right range. Symlink/split that files to new chunks.\n\n4. Start WAL replay on new chunks.\n\n5. Update global metadata about new chunk boundaries.\n\n6. Eventually (metadata update should be pushed to processing node by metadata service) storage node will start sending WAL and page requests to the new nodes.\n\n7. New chunk may start serving read queries when following conditions are met:\n\na) it receives at least on WAL record from processing node\n\nb) it replayed all WAL up to the new received one\n\nc) checked by downlinks that there were no WAL gaps.\n```\n\n----------------------------------------\n\nTITLE: Neon Service Interaction Flow - Typical Operations\nDESCRIPTION: Sequence diagram illustrating three key scenarios: pageserver checkpoint process, safekeeper lag detection and recovery, and pageserver handling of lagging safekeepers.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/015-storage-messaging.md#2025-04-22_snippet_3\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    participant C as Compute\n    participant SK1\n    participant SK2\n    participant SK3\n    participant PS1\n    participant PS2\n    participant O as Orchestrator\n    participant M as Metadata Service\n\n    note over C,M: Scenario 1: Pageserver checkpoint\n    note over PS1: Upload data to S3\n    PS1->>M: Update remote consistent lsn\n    M->>SK1: propagate remote consistent lsn update\n    note over SK1: truncate WAL up to remote consistent lsn\n    M->>SK2: propagate remote consistent lsn update\n    note over SK2: truncate WAL up to remote consistent lsn\n    M->>SK3: propagate remote consistent lsn update\n    note over SK3: truncate WAL up to remote consistent lsn\n    note over C,M: Scenario 2: SK1 finds itself lagging behind MAX(150 (SK2), 200 (SK2)) - 100 (SK1) > THRESHOLD\n    SK1->>SK2: Fetch WAL delta between 100 (SK1) and 200 (SK2)\n    note over C,M: Scenario 3: PS1 detects that SK1 is lagging behind: Connection from SK1 is broken or there is no messages from it in 30 seconds.\n    note over PS1: e.g. SK2 is at 150, SK3 is at 100, chose SK2 as a new replication source\n    PS1->>SK2: start replication\n```\n\n----------------------------------------\n\nTITLE: Initializing Neon Development Environment with Postgres 16\nDESCRIPTION: Series of commands to create and start a local Neon development environment using Postgres 16. Requires specifying the --pg-version flag for initialization, tenant creation, and endpoint creation.\nSOURCE: https://github.com/neondatabase/neon/blob/main/control_plane/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo neon init --pg-version 16\ncargo neon start\ncargo neon tenant create --set-default --pg-version 16\ncargo neon endpoint create main --pg-version 16\ncargo neon endpoint start main\n```\n\n----------------------------------------\n\nTITLE: Issuing Admin Token for Neon API Access (Bash)\nDESCRIPTION: This snippet demonstrates how to issue an admin token for accessing the Neon API in both staging and production environments. It uses curl to make a POST request and jq to extract the JWT from the response.\nSOURCE: https://github.com/neondatabase/neon/blob/main/scripts/sk_collect_dumps/readme.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# staging:\nAUTH_TOKEN=$(curl https://console-stage.neon.build/regions/console/api/v1/admin/issue_token -H \"Accept: application/json\" -H \"Content-Type: application/json\" -H \"Authorization: Bearer $NEON_STAGING_KEY\" -X POST -d '{\"ttl_seconds\": 43200, \"scope\": \"safekeeperdata\"}' 2>/dev/null | jq --raw-output '.jwt')\n# prod:\nAUTH_TOKEN=$(curl https://console.neon.tech/regions/console/api/v1/admin/issue_token -H \"Accept: application/json\" -H \"Content-Type: application/json\" -H \"Authorization: Bearer $NEON_PROD_KEY\" -X POST -d '{\"ttl_seconds\": 43200, \"scope\": \"safekeeperdata\"}' 2>/dev/null | jq --raw-output '.jwt')\n# check\necho $AUTH_TOKEN\n```\n\n----------------------------------------\n\nTITLE: Handling Pageserver Crashes Before Mark Creation\nDESCRIPTION: Sequence diagram demonstrating the recovery process when pageserver crashes before the deleted mark file is persisted to S3, showing the retry mechanism.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/022-pageserver-delete-from-s3.md#2025-04-22_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    participant CP as Control Plane\n    participant PS as Pageserver\n    participant S3\n\n    CP->>PS: Delete tenant\n    note over PS: Crash point 1.\n    CP->>PS: Retry delete request\n\n    PS->>S3: Create deleted mark file at <br> /tenant/meta/deleted\n    PS->>PS: Create deleted mark file locally\n\n    PS->>CP: Accepted\n\n    PS->>PS: delete local files other than deleted mark\n\n    loop Delete layers for each timeline\n        PS->>S3: delete(..)\n        CP->>PS: Finished?\n        PS->>CP: False\n    end\n    PS->>S3: Delete mark file\n    PS->>PS: Delete local mark file\n\n    CP->>PS: Finished?\n    PS->>CP: True\n```\n\n----------------------------------------\n\nTITLE: Running Cross-Compilation with Native Toolchain\nDESCRIPTION: Command to build a Linux executable from macOS using the installed cross-compiler toolchain with Cargo.\nSOURCE: https://github.com/neondatabase/neon/blob/main/compute_tools/README.md#2025-04-22_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\nCARGO_TARGET_X86_64_UNKNOWN_LINUX_GNU_LINKER=x86_64-unknown-linux-gnu-gcc cargo build --target=x86_64-unknown-linux-gnu --release\n```\n\n----------------------------------------\n\nTITLE: Illustrating MVCC Tenant Relocation Sequence with Mermaid\nDESCRIPTION: This diagram illustrates the sequence of events during a tenant relocation from Pageserver A to Pageserver B during a network partition. It demonstrates the transaction management process, including how the Control Plane marks transactions as RejectPending and RejectAcknowledged, and how the system maintains data integrity through the transaction ID-based storage scheme.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/026-pageserver-s3-mvcc.md#2025-04-22_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n\n   participant CP\n   participant A\n   participant S3\n   participant B\n\n\t CP -->> A: attach tenant\n   activate A\n\t A -->> CP: start txn\n\t CP -->> A: txn=23, last_committed_txn=22\n\n\n\t Note over CP,A: network partition\n\t CP --x A: heartbeat\n\t CP --x A: heartbeat\n\n\t Note over CP: relocate tenant to avoid downtime\n\t CP -->> B: attach tenant\n   activate B\n\t B -->> CP: start txn\n   Note over CP: mark A's txn 23 as RejectPending\n\t CP -->> B: txn=24, last-committed txn is 22\n\t B -->> S3: PUT X.layer.24<br>PUT index_part.json.24 referencing X.layer.24\n\t B -->> CP: request commit\n\t CP -->> B: granted\n   B -->> CP: start txn\n  CP -->> B: txn=25, last_committed_txn=22\n\n   A -->> S3: PUT Y.layer.23 <br> PUT index_part.json.23 referencing Y.layer.23\n  A --x CP: request commit\n\t A --x CP: request commit\n\n   Note over CP,A: partition is over\n\n   A -->> CP: request commit\n\n   Note over CP: most recently started txn is 25, not 23, reject\n\n   CP -->> A: reject\n   A -->> CP: acknowledge reject\n\n   Note over CP: mark A's txn 23 as RejectAcknowledged\n\n  deactivate A\n\n  B -->> S3: PUT 000-FFF_X-Y.layer.**************25**************<br>...\n\n  deactivate B\n```\n\n----------------------------------------\n\nTITLE: Compute Hook Notification Request Structure\nDESCRIPTION: Data structure definition for the notify-attach hook request body, used when tenant attachments change. Includes tenant ID, stripe size, and shard information.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/storage_controller.md#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"tenant_id\": \"1f359dd625e519a1a4e8d7509690f6fc\",\n  \"stripe_size\": 2048,\n  \"shards\": [\n      {\"node_id\": 344, \"shard_number\": 0},\n      {\"node_id\": 722, \"shard_number\": 1}\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Cluster Startup Sequence Diagram in Mermaid\nDESCRIPTION: Visualizes the sequence of events during cluster startup, showing how compute, safekeepers, pageservers and the metadata service interact to establish replication connections based on LSN states.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/015-storage-messaging.md#2025-04-22_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    participant C as Compute\n    participant SK1\n    participant SK2\n    participant SK3\n    participant PS1\n    participant PS2\n    participant O as Orchestrator\n    participant M as Metadata Service\n\n    PS1->>M: subscribe to updates to state of timeline N\n    C->>+SK1: WAL push\n    loop constantly update current lsns\n        SK1->>-M: I'm at lsn A\n    end\n    C->>+SK2: WAL push\n    loop constantly update current lsns\n        SK2->>-M: I'm at lsn B\n    end\n    C->>+SK3: WAL push\n    loop constantly update current lsns\n        SK3->>-M: I'm at lsn C\n    end\n    loop request pages\n        C->>+PS1: get_page@lsn\n        PS1->>-C: page image\n    end\n    M->>PS1: New compute appeared for timeline N. SK1 at A, SK2 at B, SK3 at C\n    note over PS1: Say SK1 at A=200, SK2 at B=150 SK3 at C=100 <br> so connect to SK1 because it is the most up to date one\n    PS1->>SK1: start replication\n```\n\n----------------------------------------\n\nTITLE: Configuring Local Filesystem Remote Storage for Backups in TOML\nDESCRIPTION: TOML configuration for setting up a local filesystem as remote storage for the backup service. This configuration is primarily intended for testing purposes.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/pageserver-services.md#2025-04-22_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[remote_storage]\nlocal_path = '/Users/someonetoignore/Downloads/tmp_dir/'\n```\n\n----------------------------------------\n\nTITLE: Merging Upstream Release\nDESCRIPTION: Commands to fetch and merge the new Postgres release version.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/updating-postgres.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ngit fetch upstream REL_15_4\ngit merge REL_15_4\n```\n\n----------------------------------------\n\nTITLE: Installing macOS Cross-Compiler Toolchain\nDESCRIPTION: Commands to install the necessary cross-compiler toolchain on macOS using Homebrew for Linux targets.\nSOURCE: https://github.com/neondatabase/neon/blob/main/compute_tools/README.md#2025-04-22_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\nbrew tap SergioBenitez/osxct\nbrew install x86_64-unknown-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Defining Safekeeper Migration JSON Structure in Rust\nDESCRIPTION: Specifies the JSON structure for safekeeper migration requests, including source and destination safekeeper IDs and an optional limit.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/035-safekeeper-dynamic-membership-change.md#2025-04-22_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n{\n    \"src_sk\": u32,\n    \"dst_sk\": u32,\n    \"limit\": Optional<u32>,\n}\n```\n\n----------------------------------------\n\nTITLE: Describing Materialization Process in Neon Database\nDESCRIPTION: Details the materialization process in Neon's pageserver, which creates a new image layer of a segment by performing WAL redo. This reduces WAL replay on GetPage requests and enables garbage collection of old layers.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/012-background-tasks.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n# Materialization\n\nCreate a new image layer of a segment, by performing WAL redo\n\n- To reduce the amount of WAL that needs to be replayed on a GetPage request.\n- To allow garbage collection of old layers\n\n- Triggered by distance to last full image of a page\n```\n\n----------------------------------------\n\nTITLE: Visualizing WAL State with Term and Epoch Information (Step 1)\nDESCRIPTION: A text representation showing the WAL state across 5 safekeepers (A-E) after P1 writes record 1.1 everywhere and additional records only on safekeeper A. Each safekeeper's state includes term (t) and epoch (e) values.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/013-term-history.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nA(t=1, e=1) 1.1 1.2 1.3 1.4\nB(t=1, e=1) 1.1\nC(t=1, e=1) 1.1\nD(t=1, e=1) 1.1\nE(t=1, e=1) 1.1\n```\n\n----------------------------------------\n\nTITLE: Generating JWKS for Neon Compute with OpenSSL\nDESCRIPTION: A series of shell commands to generate Ed25519 key pairs, convert public keys to the appropriate format, and prepare them for use as JSON Web Key Sets (JWKS). This process creates the cryptographic materials needed for compute node authentication in Neon.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docker-compose/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nopenssl genpkey -algorithm Ed25519 -out private-key.pem\nopenssl pkey -in private-key.pem -pubout -out public-key.pem\nopenssl pkey -pubin -inform pem -in public-key.pem -pubout -outform der -out public-key.der\nkey=\"$(xxd -plain -cols 32 -s -32 public-key.der)\"\nkey_id=\"$(printf '%s' \"$key\" | sha256sum | awk '{ print $1 }' | basenc --base64url --wrap=0)\"\nx=\"$(printf '%s' \"$key\" | basenc --base64url --wrap=0)\"\n```\n\n----------------------------------------\n\nTITLE: Pushing Update Branch\nDESCRIPTION: Command to push the update branch to the Neon Postgres repository.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/updating-postgres.md#2025-04-22_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ngit push origin my-branch-15\n```\n\n----------------------------------------\n\nTITLE: Illustrating Branch Structure with ASCII Diagram in Markdown\nDESCRIPTION: A simple ASCII diagram showing how two branches (A and B) can diverge from a main branch in a database system. This illustrates the scenario used to explain the challenges of branch size calculation.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/synthetic-size.md#2025-04-22_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n                      +------> A\n                     /\n--------------------*-------------------------------> main\n                     \\\n                      +--------> B\n```\n\n----------------------------------------\n\nTITLE: Full Layer File Path Example\nDESCRIPTION: Complete example of a layer file path showing the full directory structure including tenant ID, timeline ID, and relation information.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/pageserver-storage.md#2025-04-22_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\n.neon/tenants/941ddc8604413b88b3d208bddf90396c/timelines/4af489b06af8eed9e27a841775616962/rel_1663_13990_2609_0_10_000000000169C348_0000000001702000\n```\n\n----------------------------------------\n\nTITLE: Visualizing Index Part Ancestry in Generation-Based System\nDESCRIPTION: This code diagram illustrates the ancestry relationship between index_part.json files across different generations, showing how multiple branches can occur when concurrent pageservers write indices.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/025-generation-numbers.md#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n0001 -> 0002\n     |\n     -> 0003\n```\n\n----------------------------------------\n\nTITLE: Running WAL Decoder Benchmarks with AWS Authentication\nDESCRIPTION: Shell commands for authenticating with AWS SSO and running various WAL decoder benchmarks. These commands demonstrate how to run all benchmarks, specific benchmark files, individual benchmarks, list available benchmarks, and generate flamegraph profiles for performance analysis.\nSOURCE: https://github.com/neondatabase/neon/blob/main/libs/wal_decoder/benches/README.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\naws sso login --profile dev\n\n# All benchmarks.\nAWS_PROFILE=dev cargo bench --package wal_decoder\n\n# Specific file.\nAWS_PROFILE=dev cargo bench --package wal_decoder --bench bench_interpret_wal\n\n# Specific benchmark.\nAWS_PROFILE=dev cargo bench --package wal_decoder --bench bench_interpret_wal unsharded\n\n# List available benchmarks.\ncargo bench --package wal_decoder --benches -- --list\n\n# Generate flamegraph profiles using pprof-rs, profiling for 10 seconds.\n# Output in target/criterion/*/profile/flamegraph.svg.\nAWS_PROFILE=dev cargo bench --package wal_decoder --bench bench_interpret_wal unsharded -- --profile-time 10\n```\n\n----------------------------------------\n\nTITLE: Running Single PostgreSQL Test with Neon Database Connection\nDESCRIPTION: Instructions for setting up a PostgreSQL connection string environment variable and running a specific test that contains 'serverless' in the name using pytest with remote cluster configuration.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/pg_clients/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport BENCHMARK_CONNSTR=postgres://user:pass@ep-abc-xyz-123.us-east-2.aws.neon.build/neondb\n\n# will filter only tests with \"serverless\" in the name\n./scripts/pytest -m remote_cluster -k serverless\n```\n\n----------------------------------------\n\nTITLE: Viewing Profile with pprof Web UI\nDESCRIPTION: Command to launch pprof's web UI for interactive exploration of profile data including flamegraphs and call graphs.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/040-profiling.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ pprof -http :6060 <profile>\n```\n\n----------------------------------------\n\nTITLE: Chunk Directory Structure in Alternative Neon Storage Node\nDESCRIPTION: Illustrates the hierarchical directory structure of a chunk in the storage system, showing the organization of store, WAL files, and metadata within a chunk directory.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/002-storage.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n|-chunk_42/\n  |-store/ -- contains lsm with pages/pagediffs ranging from\n  |\t      page_key_lo to page_key_hi\n  |-wal/\n  |  |- db_1234/ db-specific wal files with pages from page_key_lo\n  |\t\t to page_key_hi\n  |\n  |-chunk.meta -- small file with snapshot references\n\t\t  (page_key_prefix+lsn+name)\n\t\t  and PITR regions (page_key_start, page_key_end)\n```\n\n----------------------------------------\n\nTITLE: Handling Cancellation-Unsafe Channel Operations in Rust\nDESCRIPTION: Demonstrates a pattern for reading messages from one channel and sending them to another, highlighting potential issues with cancellation safety. If cancelled during the send operation, the message read from the receiver could be lost.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/pageserver-thread-mgmt.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nwhile let Some(i) = work_inbox.recv().await {\n\tif let Err(_) = results_outbox.send(i).await {\n\t\tprintln!(\"receiver dropped\");\n\t\treturn;\n\t\t}\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Relocation with Rollback Capability in Mermaid\nDESCRIPTION: Sequence diagram showing how tenant relocation can be rolled back if availability checks fail. The process reverts to the original pageserver and resumes remote operations there.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/023-the-state-of-pageserver-tenant-relocation.md#2025-04-22_snippet_4\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    participant CP as Control Plane\n    participant PS1 as Pageserver 1\n    participant PS2 as Pageserver 2\n    participant S3\n\n    CP->>PS1: Pause background jobs, pause uploading new layers.\n    CP->>PS2: Attach tenant X in remote readonly mode.\n    PS2->>S3: Fetch timelines, index\n    PS2->>CP: Accepted\n    CP->>CP: Monitor PS2 last record lsn, ensure OK lag\n    CP->>CP: Change pageserver id in project\n    CP->>CP: Availability check Failed\n    CP->>CP: Change pageserver id back\n    CP->>PS1: Resume remote operations\n    CP->>PS2: Ignore (instead of detach for investigation purposes)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Index Corruption During Pageserver Relocation\nDESCRIPTION: This sequence diagram demonstrates how index corruption can occur when two pageservers concurrently write to S3 during tenant relocation, leading to an inconsistent state where the index references layers that no longer exist.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/020-pageserver-s3-coordination.md#2025-04-22_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    participant PS1\n    participant S3\n    participant PS2\n\n    PS1->>S3: Uploads L1, L2 <br/> Index contains L1 L2\n    PS2->>S3: Attach called, sees L1, L2\n    PS1->>S3: Compaction comes <br/> Removes L1, adds L3\n    note over S3: Index now L2, L3\n    PS2->>S3: Uploads new layer L4 <br/> (added to previous view of the index)\n    note over S3: Index now L1, L2, L4\n```\n\n----------------------------------------\n\nTITLE: Configuring Azure Storage for Backups in TOML\nDESCRIPTION: TOML configuration for setting up Azure Storage as remote storage for the backup service. Includes container name, storage account details, region, and optional prefix within the container.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/pageserver-services.md#2025-04-22_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[remote_storage]\ncontainer_name = 'some-container-name'\nstorage_account = 'somestorageaccnt'\ncontainer_region = 'us-east'\nprefix_in_container = '/test-prefix/'\n```\n\n----------------------------------------\n\nTITLE: Re-attach API Response Schema\nDESCRIPTION: JSON schema for the /re-attach API response showing tenant IDs and their generation numbers\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/025-generation-numbers.md#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  tenants: [{id: <TenantId>, gen: <u32>}]\n}\n```\n\n----------------------------------------\n\nTITLE: CPU Profiling Metrics with Frame Pointer in Rust\nDESCRIPTION: Performance benchmarks showing stack trace timing using frame-pointer vs libunwind approaches. Frame pointer implementation takes 11 µs for 40-frame stack while libunwind with DWARF takes 1.4 µs but has stability issues.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/040-profiling.md#2025-04-22_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nCPU profiles at 19 Hz frequency: 0.1% overhead\\nHeap profiles at 2 MB frequency: 3% allocation overhead\\nProfile call/encoding/symbolization: 20 ms every 60 seconds\\nProfile symbolization caches: 125 MB memory\n```\n\n----------------------------------------\n\nTITLE: Local Environment pgdatadirs Structure for Multitenancy\nDESCRIPTION: The directory structure for PostgreSQL data directories in a local testing environment, showing how data is organized by tenant and instance name.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/multitenancy.md#2025-04-22_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\npgdatadirs\n└── tenants\n   ├── de182bc61fb11a5a6b390a8aed3a804a\n   │  └── main\n   └── ee6016ec31116c1b7c33dfdfca38892f\n      └── main\n```\n\n----------------------------------------\n\nTITLE: Proxy Metric Format Example in JSON\nDESCRIPTION: Shows the JSON format for a proxy metric. This example demonstrates an 'incremental' type metric for tracking outbound traffic per client with start and stop times for the measurement period.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/consumption_metrics.md#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n\"metric\": \"proxy_io_bytes_per_client\",\n\"type\": \"incremental\",\n\"start_time\": \"2022-12-28T11:07:19.317310284Z\",\n\"stop_time\": \"2022-12-28T11:07:19.317310284Z\",\n\"idempotency_key\": \"2022-12-28 11:07:19.317310324 UTC-1-4019\",\n\"value\": 12345454,\n\"endpoint_id\": \"5d07d9ce9237c4cd845ea7918c0afa7d\",\n}\n```\n\n----------------------------------------\n\nTITLE: Improved Relocation with Background Task Pausing in Mermaid\nDESCRIPTION: Sequence diagram showing an improved approach that pauses background jobs and uploads on the source pageserver before tenant migration. This prevents issues with concurrent modifications to S3 state during migration.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/023-the-state-of-pageserver-tenant-relocation.md#2025-04-22_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    participant CP as Control Plane\n    participant PS1 as Pageserver 1\n    participant PS2 as Pageserver 2\n    participant S3\n\n    CP->>PS1: Pause background jobs, pause uploading new layers.\n    CP->>PS2: Attach tenant X.\n    PS2->>S3: Fetch timelines, index, start background operations\n    PS2->>CP: Accepted\n    CP->>CP: Monitor PS2 last record lsn, ensure OK lag\n    CP->>CP: Change pageserver id in project\n    CP->>PS1: Detach\n```\n\n----------------------------------------\n\nTITLE: Defining RelSize Key Structure in Plain Text\nDESCRIPTION: Documents the structure of relation size keys in the storage system, showing the format with space node, database node, relation node, fork and a fixed suffix.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/041-rel-sparse-keyspace.md#2025-04-22_snippet_3\n\nLANGUAGE: plain\nCODE:\n```\n// RelSize:\n// 00 SPCNODE  DBNODE   RELNODE  FORK FFFFFFFF\n```\n\n----------------------------------------\n\nTITLE: Enabling Test Output to Terminal\nDESCRIPTION: Command to let stdout, stderr, and INFO log messages go to the terminal instead of being captured.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/pytest -s --log-cli-level=INFO ...\n```\n\n----------------------------------------\n\nTITLE: RemoteStorageKind Enum in Python\nDESCRIPTION: Definition of the RemoteStorageKind enum in Python, showing the test suite's storage implementation options.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/README.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n@enum.unique\nclass RemoteStorageKind(StrEnum):\n    LOCAL_FS = \"local_fs\"\n    MOCK_S3 = \"mock_s3\"\n    REAL_S3 = \"real_s3\"\n```\n\n----------------------------------------\n\nTITLE: Validate API Request Schema\nDESCRIPTION: JSON schema for the /validate API request containing tenant IDs and their attachment generations\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/025-generation-numbers.md#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  'tenants': [{tenant: <tenant id>, attach_gen: <gen>}, ...]\n}\n```\n\n----------------------------------------\n\nTITLE: Internal Elections Flow for Pageserver Leadership\nDESCRIPTION: This sequence diagram illustrates how pageservers can determine leadership roles internally through ping messages and timeouts, without relying on an external control plane, allowing for automatic leader election and failover.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/020-pageserver-s3-coordination.md#2025-04-22_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    participant PS1\n    participant S3\n\n    note over PS1: Starts up\n    note over PS1: Subscribes to changes, waits for two ping <br> timeouts to see if there is a leader\n    PS1->>S3: Fetch indexes from s3\n    alt there is a leader\n        note over PS1: do not start background jobs, <br> continue applying index updates\n    else there is no leader\n        note over PS1: start background jobs, <br> broadcast index changes\n    end\n\n    note over PS1,S3: Then the picture is similar to external elections <br> the difference is that follower can become a leader <br> if there are no pings after some timeout new leader gets elected\n```\n\n----------------------------------------\n\nTITLE: Location Configuration API Request Body Schema\nDESCRIPTION: JSON schema for the location configuration API endpoint '/tenant/<tenant_id>/location/config', defining the structure for tenant state management requests\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/028-pageserver-migration.md#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  state: 'enum{Detached, Secondary, AttachedSingle, AttachedMulti, AttachedStale}',\n  generation: Option<u32>,\n  configuration: `Option<TenantConfig>`\n  flush: bool\n}\n```\n\n----------------------------------------\n\nTITLE: Proxy Traffic Metrics Event Schema\nDESCRIPTION: JSON schema for proxy service metrics events tracking IO bytes per client with incremental reporting over time intervals\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/021-metering.md#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n\"metric\": \"proxy_io_bytes_per_client\",\n\"type\": \"incremental\",\n\"start_time\": \"2022-12-28T11:07:19.317310284Z\",\n\"stop_time\": \"2022-12-28T11:07:19.317310284Z\",\n\"idempotency_key\": \"2022-12-28 11:07:19.317310324 UTC-1-4019\",\n\"value\": 12345454,\n\"endpoint_id\": \"5d07d9ce9237c4cd845ea7918c0afa7d\"\n}\n```\n\n----------------------------------------\n\nTITLE: Exiting After First Test Failure\nDESCRIPTION: Command to make pytest exit after the first test failure occurs.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/README.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/pytest -x ...\n```\n\n----------------------------------------\n\nTITLE: Configuring CCLS for C/C++ Development in Emacs\nDESCRIPTION: Emacs configuration snippet to improve LSP performance by disabling lens feature when working with ccls\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/tools.md#2025-04-22_snippet_0\n\nLANGUAGE: elisp\nCODE:\n```\n(setq lsp-lens-enable nil)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Timeline Structure After Detachment\nDESCRIPTION: ASCII diagram showing the timeline structure after calling the detach ancestor API, where 'new main' timeline and child A are no longer dependent on 'old main', while child B still remains connected to 'old main'.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/034-ancestor-deletion.md#2025-04-22_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n|----\"old main\" timeline---------------------------------------------------->\n                                                         |\n                                                         |\n                                                         |\n                                                         -> child B\n\n|----\"new main\" timeline--------->\n                 |\n                 |-> child A\n\n\n```\n\n----------------------------------------\n\nTITLE: Handling Pageserver Crashes During Mark Creation\nDESCRIPTION: Sequence diagram showing recovery handling when pageserver crashes while creating the deletion mark, including remote state reconciliation and retry logic.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/022-pageserver-delete-from-s3.md#2025-04-22_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    participant CP as Control Plane\n    participant PS as Pageserver\n    participant S3\n\n    CP->>PS: Delete tenant\n    PS->>S3: Create deleted mark file at <br> /tenant/meta/deleted\n\n    note over PS: Crash point 2.\n    note over PS: During startup we reconcile <br> with remote and see <br> whether the remote mark exists\n    alt Remote mark exists\n        PS->>PS: create local mark if its missing\n        PS->>PS: delete local files other than deleted mark\n        loop Delete layers for each timeline\n            PS->>S3: delete(..)\n        end\n\n        note over CP: Eventually console should <br> retry delete request\n\n        CP->>PS: Retry delete tenant\n        PS->>CP: Not modified\n    else Mark is missing\n        note over PS: Continue to operate the tenant as if deletion didn't happen\n\n        note over CP: Eventually console should <br> retry delete request\n\n        CP->>PS: Retry delete tenant\n        PS->>S3: Create deleted mark file at <br> /tenant/meta/deleted\n        PS->>CP: Delete tenant\n    end\n\n    PS->>PS: Continue with layer file deletions\n    loop Delete layers for each timeline\n        PS->>S3: delete(..)\n        CP->>PS: Finished?\n        PS->>CP: False\n    end\n\n    PS->>S3: Delete mark file\n    PS->>PS: Delete local mark file\n\n    CP->>PS: Finished?\n    PS->>CP: True\n```\n\n----------------------------------------\n\nTITLE: Depicting WAL Sections with Epoch in Safekeeper\nDESCRIPTION: ASCII diagram showing the WAL sections in a safekeeper with the additional Accepted Epoch (555) information. This illustrates how epochs are tracked alongside the VCL and LSN positions in the WAL.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/004-durability.md#2025-04-22_snippet_2\n\nLANGUAGE: ascii\nCODE:\n```\nAccepted Epoch: 555                VCL                   LSN\n                                     |                     |\n                                     V                     V\n.................ccccccccccccccccccccXXXXXXXXXXXXXXXXXXXXXXX\nArchived WAL       Completed WAL          In-flight WAL\n```\n\n----------------------------------------\n\nTITLE: Event Subscription API Endpoint\nDESCRIPTION: Defines an HTTP API endpoint for subscribing to storage events with cursor-based pagination. The endpoint returns a list of events and a cursor for fetching subsequent events.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/017-console-split.md#2025-04-22_snippet_3\n\nLANGUAGE: http\nCODE:\n```\nGET /events/<cursor>\n\n{\n  \"events\": [...],\n  \"next_cursor\": 123\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies for Neon Database\nDESCRIPTION: This snippet defines two Python package dependencies with their version requirements. pg8000 is pinned to version 1.31.2, while scramp requires version 1.4.3 or higher.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/pg_clients/python/pg8000/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\npg8000==1.31.2\nscramp>=1.4.3\n```\n\n----------------------------------------\n\nTITLE: Executing Find Garbage Command\nDESCRIPTION: Command to identify deletable tenants and timelines in S3 bucket by cross-referencing with Console API\nSOURCE: https://github.com/neondatabase/neon/blob/main/storage_scrubber/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nenv AWS_PROFILE=dev REGION=eu-west-1 BUCKET=my-dev-bucket CLOUD_ADMIN_API_TOKEN=[client_key] CLOUD_ADMIN_API_URL=[url] cargo run --release -- find-garbage --node-kind=pageserver --depth=tenant --output-path=eu-west-1-garbage.json\n```\n\n----------------------------------------\n\nTITLE: Key Space Partition Visualization using ASCII Art\nDESCRIPTION: Visual representation of how key space can be partitioned at a natural split point, showing layers on both sides of a dotted line partition. This illustrates how compaction can be performed separately on each partition.\nSOURCE: https://github.com/neondatabase/neon/blob/main/pageserver/compaction/TODO.md#2025-04-22_snippet_0\n\nLANGUAGE: ascii-art\nCODE:\n```\n              :\n+--+ +----+ :  +------+\n|  | |    | :  |      |\n+--+ +----+ :  +------+\n              :\n+-----+ +-+ : +--------+\n|     | | | : |        |\n+-----+ +-+ : +--------+\n              :\n```\n\n----------------------------------------\n\nTITLE: Visualizing WAL State with Term and Epoch Information (Step 2)\nDESCRIPTION: A text representation showing the WAL state after P2 is elected by safekeepers CDE in term 2 and writes records 2.2 and 2.3 on safekeepers C and D.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/013-term-history.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\nA(t=1, e=1) 1.1 1.2 1.3 1.4\nB(t=1, e=1) 1.1\nC(t=2, e=2) 1.1 2.2 2.3\nD(t=2, e=2) 1.1 2.2 2.3\nE(t=2, e=1) 1.1\n```\n\n----------------------------------------\n\nTITLE: Visualizing WAL Sections in Safekeeper Nodes\nDESCRIPTION: ASCII diagram illustrating how WAL is divided into three portions in safekeeper nodes: Archived WAL (already stored in S3), Completed WAL (written to quorum of safekeepers), and In-flight WAL (persisted but not yet confirmed durable).\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/004-durability.md#2025-04-22_snippet_1\n\nLANGUAGE: ascii\nCODE:\n```\n                                    VCL                   LSN\n                                     |                     |\n                                     V                     V\n.................ccccccccccccccccccccXXXXXXXXXXXXXXXXXXXXXXX\nArchived WAL       Completed WAL          In-flight WAL\n```\n\n----------------------------------------\n\nTITLE: AWS CLI Config for Minio\nDESCRIPTION: AWS CLI profile configuration for connecting to a local Minio server.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/README.md#2025-04-22_snippet_11\n\nLANGUAGE: ini\nCODE:\n```\n# append to ~/.aws/config\n[profile local-minio]\nservices = local-minio-services\n[services local-minio-services]\ns3 =\n  endpoint_url=http://127.0.0.1:9000/\n```\n\n----------------------------------------\n\nTITLE: Running Safekeeper Benchmarks in Cargo\nDESCRIPTION: Commands for executing different types of benchmarks for the safekeeper package, including running all benchmarks, specific benchmark files, individual benchmarks, listing available benchmarks, and generating performance profiles with flamegraphs.\nSOURCE: https://github.com/neondatabase/neon/blob/main/safekeeper/benches/README.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n# All benchmarks.\ncargo bench --package safekeeper\n\n# Specific file.\ncargo bench --package safekeeper --bench receive_wal\n\n# Specific benchmark.\ncargo bench --package safekeeper --bench receive_wal process_msg/fsync=false\n\n# List available benchmarks.\ncargo bench --package safekeeper --benches -- --list\n\n# Generate flamegraph profiles using pprof-rs, profiling for 10 seconds.\n# Output in target/criterion/*/profile/flamegraph.svg.\ncargo bench --package safekeeper --bench receive_wal process_msg/fsync=false --profile-time 10\n```\n\n----------------------------------------\n\nTITLE: Delta Layer File Naming Convention\nDESCRIPTION: Example showing the naming format for delta layer files, which includes the start key, end key, start LSN, and end LSN components that define the layer's coverage area.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/pageserver-storage.md#2025-04-22_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n000000067F000032BE0000400000000020B6-000000067F000032BE0000400000000030B6__000000578C6B29-0000000057A50051\n          start key                          end key                          start LSN     end LSN\n```\n\n----------------------------------------\n\nTITLE: Console Command Reference for Neon Database CLI\nDESCRIPTION: Command for opening the Neon web console through a browser. The web console provides similar functionality to the command-line interface described in the documentation.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/003-laptop-cli.md#2025-04-22_snippet_11\n\nLANGUAGE: plaintext\nCODE:\n```\n**neon console**\n```\n\n----------------------------------------\n\nTITLE: Generating Compilation Database for CLion with Neon C Code\nDESCRIPTION: This bash script sequence generates a compilation database for CLion to properly index Neon's C code. It installs the compiledb tool, cleans the build tree, rebuilds Postgres parts, and creates the necessary compilation database file that CLion can use instead of CMakeLists.txt.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/sourcetree.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# Install a `compiledb` tool which can parse make's output and generate the compilation database.\npoetry add -D compiledb\n# Clean the build tree so we can rebuild from scratch.\n# Unfortunately, our and Postgres Makefiles do not work well with either --dry-run or --assume-new,\n# so we don't know a way to generate the compilation database without recompiling everything,\n# see https://github.com/neondatabase/neon/issues/2378#issuecomment-1241421325\nmake distclean\n# Rebuild the Postgres parts from scratch and save the compilation commands to the compilation database.\n# You can alter the -j parameter to your liking.\n# Note that we only build for a specific version of Postgres. The extension code is shared, but headers are\n# different, so we set up CLion to only use a specific version of the headers.\nmake -j$(nproc) --print-directory postgres-v15 neon-pg-ext-v15 | poetry run compiledb --verbose --no-build\n# Uninstall the tool\npoetry remove -D compiledb\n# Make sure the compile_commands.json file is not committed.\necho /compile_commands.json >>.git/info/exclude\n```\n\n----------------------------------------\n\nTITLE: Visualizing WAL State with Term and Epoch Information (Step 3)\nDESCRIPTION: A text representation showing the WAL state after P3 is elected by safekeepers CDE in term 3 and writes record 3.4 on safekeeper D.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/013-term-history.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\nA(t=1, e=1) 1.1 1.2 1.3 1.4\nB(t=1, e=1) 1.1\nC(t=3, e=2) 1.1 2.2 2.3\nD(t=3, e=3) 1.1 2.2 2.3 3.4\nE(t=3, e=1) 1.1\n```\n\n----------------------------------------\n\nTITLE: Enumerating Node Scheduling Policies in Rust\nDESCRIPTION: Lists the various scheduling policies used for nodes during drain and fill operations. These policies control how the storage controller manages node assignments.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/033-storage-controller-drain-and-fill.md#2025-04-22_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nNodeSchedulingPolicy::Active\nNodeSchedulingPolicy::Pause\nNodeSchedulingPolicy::Draining\nNodeSchedulingPolicy::PauseForRestart\nNodeSchedulingPolicy::Filling\n```\n\n----------------------------------------\n\nTITLE: Updating Hakari Manifest for Cargo Dependencies\nDESCRIPTION: Commands to update the Hakari manifest after adding new Cargo dependencies. This process updates the Cargo.lock file and workspace_hack directory.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/sourcetree.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo hakari generate\ncargo hakari manage-deps\n```\n\n----------------------------------------\n\nTITLE: Patching PostgreSQL Regression Test Files\nDESCRIPTION: Bash command to apply a patch to the PostgreSQL v17 regression test files, making them compatible with Neon cloud environment.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/cloud_regress/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ cd vendor/postgres-v17\n$ patch -p1 <../../compute/patches/cloud_regress_pg17.patch\n```\n\n----------------------------------------\n\nTITLE: Specifying asyncpg Package Version Requirement\nDESCRIPTION: Defines the required version of the asyncpg package, which is a high-performance PostgreSQL client library for Python. The version is pinned to exactly 0.29.0.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/pg_clients/python/asyncpg/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nasyncpg==0.29.0\n```\n\n----------------------------------------\n\nTITLE: Visualizing Corrupted WAL State After Recovery Without Proper Truncation\nDESCRIPTION: A text representation showing how safekeeper A's WAL could become corrupted if P3 recovers by adding record 2.2 without truncating old 1.3 and 1.4 records, resulting in an invalid sequence.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/013-term-history.md#2025-04-22_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\nA(t=1, e=1) 1.1 <b>2.2</b> 1.3 1.4\nB(t=1, e=1) 1.1 1.2\nC(t=3, e=2) 1.1 2.2 2.3\nD(t=3, e=3) 1.1 2.2 2.3 3.4\nE(t=3, e=1) 1.1\n```\n\n----------------------------------------\n\nTITLE: Image Layer File Naming Convention\nDESCRIPTION: Example showing the naming format for image layer files, which includes the start key, end key, and LSN components that define the layer's coverage area.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/pageserver-storage.md#2025-04-22_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n000000067F000032BE0000400000000070B6-000000067F000032BE0000400000000080B6__00000000346BC568\n          start key                          end key                           LSN\n```\n\n----------------------------------------\n\nTITLE: Basic Key Iteration Pattern in Rust\nDESCRIPTION: Example demonstrating the basic key iteration pattern that needs to be avoided with sparse keyspaces due to performance implications on large keyspaces.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/038-aux-file-v2.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nloop {\n    // do something\n    key = key.next();\n}\n```\n\n----------------------------------------\n\nTITLE: L0 Layer File Example\nDESCRIPTION: Example of an L0 (Level 0) layer file name that covers the entire key range of the system.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/pageserver-storage.md#2025-04-22_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\n000000000000000000000000000000000000-FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF__000000578C6B29-0000000057A50051\n```\n\n----------------------------------------\n\nTITLE: Flattened etcd Key Structure for Timeline State in Ruby\nDESCRIPTION: Shows the flattened key structure used in etcd to support nested object updates, demonstrating how the hierarchical data model is translated to a key-value store format.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/015-storage-messaging.md#2025-04-22_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\n\"compute_#{tenant}_#{timeline}/safekeepers/sk_#{sk_id}/write_lsn\",\n\"compute_#{tenant}_#{timeline}/safekeepers/sk_#{sk_id}/commit_lsn\",\n...\n```\n\n----------------------------------------\n\nTITLE: Example of Separate LSN Ranges for Different Relations\nDESCRIPTION: An example showing how different relations (orders and customers) can have independent LSN ranges in their checkpoint files. This is theoretically supported although not currently implemented in practice.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/pageserver-storage.md#2025-04-22_snippet_10\n\nLANGUAGE: plaintext\nCODE:\n```\n\tmain/orders_100\n\tmain/orders_100_200\n\tmain/orders_200\n\tmain/orders_200_300\n\tmain/orders_300\n\tmain/orders_300_400\n\tmain/orders_400\n\tmain/customers_150\n\tmain/customers_150_250\n\tmain/customers_250\n\tmain/customers_250_500\n\tmain/customers_500\n```\n\n----------------------------------------\n\nTITLE: Updating Git Submodule\nDESCRIPTION: Commands to update the Postgres submodule to point to the new branch.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/updating-postgres.md#2025-04-22_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\ngit submodule set-branch --branch my-branch-15 vendor/postgres-v15\ngit submodule update --remote vendor/postgres-v15\n```\n\n----------------------------------------\n\nTITLE: Console CPU Time Metrics Event Schema\nDESCRIPTION: JSON schema for console service metrics events tracking effective compute seconds with incremental reporting\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/021-metering.md#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"metric\": \"effective_compute_seconds\",\n    \"type\": \"increment\",\n    \"endpoint_id\": \"blazing-warrior-34\",\n    \"event_start_time\": ...,\n    \"event_stop_time\": ...,\n    \"value\": 12345454\n}\n```\n\n----------------------------------------\n\nTITLE: SSTable Content Example in LSM-based Storage\nDESCRIPTION: Demonstrates the content structure of an SSTable in the LSM tree, showing how full pages and per-page diffs are stored with corresponding page keys and LSN values.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/002-storage.md#2025-04-22_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n(pg_id, db_id, ... , pageno=42, lsn=100) (full 8k page data)\n(pg_id, db_id, ... , pageno=42, lsn=150) (per-page diff)\n(pg_id, db_id, ... , pageno=42, lsn=180) (per-page diff)\n(pg_id, db_id, ... , pageno=42, lsn=200) (per-page diff)\n(pg_id, db_id, ... , pageno=42, lsn=220) (full 8k page data)\n(pg_id, db_id, ... , pageno=42, lsn=250) (per-page diff)\n(pg_id, db_id, ... , pageno=42, lsn=270) (per-page diff)\n(pg_id, db_id, ... , pageno=5000, lsn=100) (full 8k page data)\n```\n\n----------------------------------------\n\nTITLE: Pageserver Storage Metrics Event Schema\nDESCRIPTION: JSON schema for pageserver service metrics events tracking remote storage size with absolute value reporting\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/021-metering.md#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n\"metric\": \"remote_storage_size\",\n\"type\": \"absolute\",\n\"time\": \"2022-12-28T11:07:19.317310284Z\",\n\"idempotency_key\": \"2022-12-28 11:07:19.317310324 UTC-1-4019\",\n\"value\": 12345454,\n\"tenant_id\": \"5d07d9ce9237c4cd845ea7918c0afa7d\",\n\"timeline_id\": \"a03ebb4f5922a1c56ff7485cc8854143\"\n}\n```\n\n----------------------------------------\n\nTITLE: GIN WAL Redo Modified to Handle BLK_DONE State in C\nDESCRIPTION: This patch modifies ginRedoSplit in ginxlog.c to handle the BLK_DONE return state from XLogReadBufferForRedo. In Neon, this function is modified to return BLK_DONE for pages that aren't the target of the current replay operation, optimizing the WAL replay process.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/core_changes.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n@@ -415,21 +416,27 @@ ginRedoSplit(XLogReaderState *record)\n        if (!isLeaf)\n                ginRedoClearIncompleteSplit(record, 3);\n \n-       if (XLogReadBufferForRedo(record, 0, &lbuffer) != BLK_RESTORED)\n+       action = XLogReadBufferForRedo(record, 0, &lbuffer);\n+       if (action != BLK_RESTORED && action != BLK_DONE)\n                elog(ERROR, \"GIN split record did not contain a full-page image of left page\");\n```\n\n----------------------------------------\n\nTITLE: Usage Events API Request Schema\nDESCRIPTION: JSON schema for the HTTP POST endpoint that receives usage events from various services for consumption tracking\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/021-metering.md#2025-04-22_snippet_3\n\nLANGUAGE: json\nCODE:\n```\nPOST /usage_events HTTP/1.1\nContent-Type: application/json\n\n[\n{\n\"metric\": \"remote_storage_size\",\n\"type\": \"absolute\",\n\"time\": \"2022-12-28T11:07:19.317310284Z\",\n\"idempotency_key\": \"2022-12-28 11:07:19.317310324 UTC-1-4019\",\n\"value\": 12345454,\n\"tenant_id\": \"5d07d9ce9237c4cd845ea7918c0afa7d\",\n\"timeline_id\": \"a03ebb4f5922a1c56ff7485cc8854143\"\n},\n...\n]\n```\n\n----------------------------------------\n\nTITLE: Describing Neon Database Configuration for Testing\nDESCRIPTION: Comments explaining the nature and purpose of a captured database configuration from a staging environment. It specifies the content mixture, layer count, and intended use for smoke testing.\nSOURCE: https://github.com/neondatabase/neon/blob/main/pageserver/test_data/indices/mixed_workload/README.md#2025-04-22_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n# This was captured from one shard of a large tenant in staging.\n\n# It has a mixture of deltas and image layers, >1000 layers in total.\n\n# This is suitable for general smoke tests that want an index which is not\n# trivially small, but doesn't contain weird/pathological cases.\n```\n\n----------------------------------------\n\nTITLE: Running Python Script for Dependency Synchronization\nDESCRIPTION: Command to run the pysync script which likely synchronizes Python dependencies needed for the test environment.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/performance/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/pysync\n```\n\n----------------------------------------\n\nTITLE: Example of Safekeeper Configuration in GUC Setting\nDESCRIPTION: Example of the modified format for the \"neon.safekeepers\" GUC (Grand Unified Configuration) setting, which now includes a generation number prefix to facilitate version checking by compute nodes.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/035-safekeeper-dynamic-membership-change.md#2025-04-22_snippet_4\n\nLANGUAGE: plain\nCODE:\n```\ng#42:safekeeper-0.eu-central-1.aws.neon.tech:6401,safekeeper-2.eu-central-1.aws.neon.tech:6401,safekeeper-1.eu-central-1.aws.neon.tech:6401\n```\n\n----------------------------------------\n\nTITLE: Visualizing Branching in Synthetic Size Calculation\nDESCRIPTION: This ASCII diagram shows how branching is represented in the synthetic size calculation, illustrating the relationship between the main branch, child branch, and their respective WAL regions.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/synthetic-size.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n  child                 +#####>\n                        |\n                        |    WAL\n  main    ---------###############>\n                   ^\n                snapshot\n```\n\n----------------------------------------\n\nTITLE: Defining Pageserver Index Part Storage Path for Sharded Tenants\nDESCRIPTION: Storage path format for index part files in sharded tenants, including the tenant ID, shard number, shard count, timeline ID, and generation number.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/031-sharding-static.md#2025-04-22_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\npageserver/v1/tenants/<tenant_id>-<shard_number><shard_count>/timelines/<timeline id>/index_part.json-<generation>\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Neon on Fedora\nDESCRIPTION: Command to install necessary packages for building Neon on Fedora-based systems. Includes development tools and libraries required for the project.\nSOURCE: https://github.com/neondatabase/neon/blob/main/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndnf install flex bison readline-devel zlib-devel openssl-devel \\\n  libseccomp-devel perl clang cmake postgresql postgresql-contrib protobuf-compiler \\\n  protobuf-devel libcurl-devel openssl poetry lsof libicu-devel libpq-devel python3-devel \\\n  libffi-devel\n```\n\n----------------------------------------\n\nTITLE: Postgres Instance Management REST API Commands\nDESCRIPTION: REST API endpoints and corresponding CLI commands for managing Postgres instances in Neon\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/005-zenith_local.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\nCLI  | REST API\n------------- | -------------\npg create -n name --s storage_name | PUT  -d { \"name\": \"name\", \"storage_name\": \"storage_name\" } /pgs\npg destroy -n name | DELETE /pgs/:pg_name \npg start -n name --replica | POST -d {\"action\": \"start\", \"is_replica\":\"replica\"}  /pgs/:pg_name /actions\npg stop -n name | POST  -d {\"action\": \"stop\"}  /pgs/:pg_name /actions\npg promote -n name | POST  -d {\"action\": \"promote\"}  /pgs/:pg_name /actions\npg list | GET /pgs\npg show -n name | GET /pgs/:pg_name\n```\n\n----------------------------------------\n\nTITLE: Configuring Safekeeper Protocol Version in Compute Nodes\nDESCRIPTION: Sets a flag in compute nodes to determine the safekeeper protocol version. This allows for backward compatibility during the rollout process.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/035-safekeeper-dynamic-membership-change.md#2025-04-22_snippet_10\n\nLANGUAGE: markdown\nCODE:\n```\n- compute gets `neon.safekeepers_proto_version` flag.\n```\n\n----------------------------------------\n\nTITLE: Updating Ansible Inventory for TSH Method (Bash)\nDESCRIPTION: These commands update the Ansible inventory file for the TSH (Teleport SSH) method. It creates a list of safekeeper hosts for either staging or production environments, optionally filtered by region.\nSOURCE: https://github.com/neondatabase/neon/blob/main/scripts/sk_collect_dumps/readme.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nrm -f hosts && echo '[safekeeper]' >> hosts\n# staging:\ntsh ls | awk '{print $1}' | grep safekeeper | grep \"neon.build\" | grep us-east-2 >> hosts\n# prod:\ntsh ls | awk '{print $1}' | grep safekeeper | grep \"neon.tech\" | grep us-east-2 >> hosts\n```\n\n----------------------------------------\n\nTITLE: Running Tests with AWS Profile\nDESCRIPTION: Command for running tests using real S3 storage with AWS profile credentials.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/README.md#2025-04-22_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n# with AWS PROFILE\nENABLE_REAL_S3_REMOTE_STORAGE=true \\\nREMOTE_STORAGE_S3_BUCKET=mybucket \\\nREMOTE_STORAGE_S3_REGION=eu-central-1 \\\nAWS_PROFILE=... \\\n./scripts/pytest\n```\n\n----------------------------------------\n\nTITLE: Importing Standalone PostgreSQL to Neon\nDESCRIPTION: Shows the process of importing an existing PostgreSQL database into Neon using snapshots, creating a new instance from the snapshot, and then destroying the temporary snapshot.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/003-laptop-cli.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n> neon snapshot import --from=basebackup://replication@localhost:5432/ oldpg\n[====================------------] 60% | 20MB/s\n> neon snapshot list\nID          SIZE        PARENT\noldpg       5G          -\n\n> neon pg create --snapshot oldpg\nStarted postgres on localhost:5432\n\n> neon pg list\nID            PGDATA        USED    STORAGE            ENDPOINT\nprimary1      pgdata1       5G      neon-local       localhost:5432\n\n> neon snapshot destroy oldpg\nOk\n```\n\n----------------------------------------\n\nTITLE: Module Path Structure Example\nDESCRIPTION: Demonstrates the organization of PostgreSQL version-specific code modules in the codebase. Shows how code is separated into v14, v15, and v16 namespaces with shared functionality exposed in the main postgres_ffi module.\nSOURCE: https://github.com/neondatabase/neon/blob/main/libs/postgres_ffi/README.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npostgres_ffi::v14\npostgres_ffi::v15\npostgres_ffi::v16\npostgres_ffi\n```\n\n----------------------------------------\n\nTITLE: Staging Environment Ansible Deployment\nDESCRIPTION: Commands to deploy the cleanup script using Ansible in a staging environment. Sets AWS profile and executes the ansible-playbook command.\nSOURCE: https://github.com/neondatabase/neon/blob/main/scripts/sk_cleanup_tenants/readme.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/neon/.github/ansible\n\nexport AWS_DEFAULT_PROFILE=dev\n\nansible-playbook -i staging.us-east-2.hosts.yaml -e @ssm_config ../../scripts/sk_cleanup_tenants/remote.yaml\n\n# add --extra-vars \"api_token=\" to set console api token\n```\n\n----------------------------------------\n\nTITLE: Running Postgres Tests\nDESCRIPTION: Commands to run the Postgres test suite using make or meson.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/updating-postgres.md#2025-04-22_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nmake check\n# OR\nmeson test -C builddir\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Neon on macOS\nDESCRIPTION: Series of commands to install necessary dependencies for building Neon on macOS. Includes XCode command line tools and Homebrew packages.\nSOURCE: https://github.com/neondatabase/neon/blob/main/README.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nxcode-select --install\nbrew install protobuf openssl flex bison icu4c pkg-config m4\n\n# add openssl to PATH, required for ed25519 keys generation in neon_local\necho 'export PATH=\"$(brew --prefix openssl)/bin:$PATH\"' >> ~/.zshrc\n```\n\n----------------------------------------\n\nTITLE: One-Line Docker Cross-Compilation Command\nDESCRIPTION: Simplified one-line command to cross-compile the compute tools using the latest Rust Docker image.\nSOURCE: https://github.com/neondatabase/neon/blob/main/compute_tools/README.md#2025-04-22_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\ndocker run --rm -v $(pwd):/compute_tools -w /compute_tools -t rust:latest cargo build --release --target=x86_64-unknown-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Archived Timelines API Endpoint Response\nDESCRIPTION: Response structure for the GET endpoint to retrieve information about archived timelines, returning the same content format as the tenant manifest for each timeline.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/035-timeline-archive.md#2025-04-22_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  ...same per-timeline content as the tenant manifest...\n}\n```\n\n----------------------------------------\n\nTITLE: Describing Bundling Process in Neon Database\nDESCRIPTION: Details the bundling process in Neon's pageserver, which combines multiple small files from different segments into a single file. This reduces the number of small files that need to be uploaded to S3.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/012-background-tasks.md#2025-04-22_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n# Bundling\n\nZip together multiple small files belonging to different segments.\n\n- To reduce the number of small files that needs to be uploaded to S3\n```\n\n----------------------------------------\n\nTITLE: Running Random Operations Test for Neon API in Bash\nDESCRIPTION: This snippet demonstrates how to run the random operations test for Neon API stability using pytest. It includes variations for specifying an API key, setting a random seed for reproducibility, and customizing the number of operations.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/random_ops/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nNEON_API_KEY=your_api_key ./scripts/pytest test_runner/random_ops/test_random_ops.py -m remote_cluster\n```\n\nLANGUAGE: bash\nCODE:\n```\nRANDOM_SEED=12345 NEON_API_KEY=your_api_key ./scripts/pytest test_runner/random_ops/test_random_ops.py -m remote_cluster\n```\n\nLANGUAGE: bash\nCODE:\n```\nNUM_OPERATIONS=500 NEON_API_KEY=your_api_key ./scripts/pytest test_runner/random_ops/test_random_ops.py -m remote_cluster\n```\n\n----------------------------------------\n\nTITLE: Listing Attached Storage\nDESCRIPTION: Demonstrates the output of the 'neon storage list' command, showing various types of storage attached to the Neon installation.\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/003-laptop-cli.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n> neon storage list\nNAME            USED    TYPE                OPTIONS          PATH\nlocal           5.1G    neon-local                         /opt/neon/store/local\nlocal.compr     20.4G   neon-local        compression=on    /opt/neon/store/local.compr\nzcloud          60G     neon-remote                        neon.tech/stas/mystore\ns3tank          80G     S3\n```\n\n----------------------------------------\n\nTITLE: Storage Management REST API Commands\nDESCRIPTION: REST API endpoints and corresponding CLI commands for managing storage in Neon\nSOURCE: https://github.com/neondatabase/neon/blob/main/docs/rfcs/005-zenith_local.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\nCLI  | REST API\n------------- | -------------\nstorage attach -n name --type [native\\s3]  --path=[datadir\\URL] | PUT  -d { \"name\": \"name\", \"type\": \"native\", \"path\": \"/tmp\" } /storages\nstorage detach -n name | DELETE /storages/:storage_name \nstorage list | GET /storages\nstorage show -n name | GET /storages/:storage_name\n```\n\n----------------------------------------\n\nTITLE: Running Targeted Integration Tests\nDESCRIPTION: Command to run integration tests for a specific PostgreSQL version and build type configuration.\nSOURCE: https://github.com/neondatabase/neon/blob/main/README.md#2025-04-22_snippet_14\n\nLANGUAGE: sh\nCODE:\n```\nDEFAULT_PG_VERSION=17 BUILD_TYPE=release ./scripts/pytest\n```\n\n----------------------------------------\n\nTITLE: Loading Data into PostgreSQL\nDESCRIPTION: Reference to a Python script for loading the dataset into a PostgreSQL database.\nSOURCE: https://github.com/neondatabase/neon/blob/main/test_runner/performance/pgvector/README.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# see loaddata.py in this directory\n```"
  }
]