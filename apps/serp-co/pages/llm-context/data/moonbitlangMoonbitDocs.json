[
  {
    "owner": "moonbitlang",
    "repo": "moonbit-docs",
    "content": "TITLE: Defining and Using a Custom Error Type in MoonBit\nDESCRIPTION: This MoonBit code snippet demonstrates the correct way to define and use a custom error type using the `type!` keyword. The String type is wrapped within a `StringError` error type, which can then be used after the '!' in the function's return type and can be raised within the function.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4127.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntype! StringError String\n\npub fn may_raise_error() -> Unit!StringError {\n  raise StringError(\"Failed\")\n}\n```\n\n----------------------------------------\n\nTITLE: Struct Initialization and Field Access in MoonBit\nDESCRIPTION: Shows how to initialize a struct using a struct literal in MoonBit. Also, shows how to access and modify struct fields using dot syntax. Note the use of `mut` keyword to make fields mutable.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_72\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  var p = Person { name: \"Alice\", age: 30, email: \"alice@example.com\" }\n  debug(p.name)\n  debug(p.age)\n  debug(p.email)\n\n  struct MutablePerson {\n    name : String\n    age : Int\n    mut email : String\n  }\n\n  var mp = MutablePerson { name: \"Bob\", age: 25, email: \"bob@example.com\" }\n  mp.email = \"bob.new@example.com\"\n  debug(mp.email)\n}\n```\n\n----------------------------------------\n\nTITLE: Generics in MoonBit\nDESCRIPTION: This snippet demonstrates defining a generic list data type and functions in MoonBit. It includes the definition of a generic `List` enum and functions `map` and `reduce`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_104\n\nLANGUAGE: moonbit\nCODE:\n```\nenum List[T] {\n  Nil,\n  Cons(T, List[T]),\n}\n\nfn map[T, U](list: List[T], f: Fn(T) -> U) -> List[U] {\n  match list {\n    Nil => Nil,\n    Cons(head, tail) => Cons(f(head), map(tail, f)),\n  }\n}\n\nfn reduce[T, U](list: List[T], initial: U, f: Fn(U, T) -> U) -> U {\n  match list {\n    Nil => initial,\n    Cons(head, tail) => f(reduce(tail, initial, f), head),\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Foreign Function in MoonBit (Wasm/Wasm GC)\nDESCRIPTION: This snippet demonstrates how to import a foreign function in MoonBit for the Wasm and Wasm GC backends. It shows how to specify the module name and function name from the runtime host.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/ffi.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn cos(d : Double) -> Double = \"math\" \"cos\"\n```\n\n----------------------------------------\n\nTITLE: Using the Error Type in MoonBit\nDESCRIPTION: This snippet illustrates the usage of the built-in `Error` type in MoonBit. It shows how to define functions that can raise errors, how to catch errors using `try...catch`, and how to handle specific error types.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_24\n\nLANGUAGE: moonbit\nCODE:\n```\n// These signatures are equivalent. They all raise Error.\nfn f() -> Unit! { .. }\nfn f!() -> Unit { .. }\nfn f() -> Unit!Error { .. }\n\nfn test_error() -> Result[Int, Error] {\n  fn f() -> _!_ {\n    raise DivisionByZeroError(\"err\")\n  }\n\n  try {\n    Ok(f!())\n  } catch {\n    err => Err(err)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Enum Pattern Matching Example in MoonBit\nDESCRIPTION: Illustrates pattern matching with enums in MoonBit. It shows how to construct enum values and use `case` statements to determine which enum case a value belongs to.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_77\n\nLANGUAGE: moonbit\nCODE:\n```\nfn print_color(color : Color) {\n  case color {\n    Red => debug(\"Red\")\n    Green => debug(\"Green\")\n    Blue => debug(\"Blue\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Bash: Install MoonBit toolchain\nDESCRIPTION: This script installs the MoonBit toolchain on Linux and macOS systems. It downloads the installation script and executes it using bash, placing MoonBit in `$HOME/.moon` and adding it to the PATH.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/tutorial/tour.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -fsSL https://cli.moonbitlang.com/install/unix.sh | bash\n```\n\n----------------------------------------\n\nTITLE: Implementing Traits in MoonBit\nDESCRIPTION: This snippet demonstrates how to implement a trait for a type using the `impl Trait for Type with method_name(...) { ... }` syntax.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_11\n\nLANGUAGE: moonbit\nCODE:\n```\n// start trait 2\ntrait Foo {\n  fn bar(self : Self) -> Int\n}\n\nimpl Foo for Int with bar(self) {\n  self + 1\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Pattern Matching in MoonBit\nDESCRIPTION: This snippet demonstrates basic pattern matching in MoonBit, including matching against literals and binding values to identifiers. The `match` expression checks the value of `x` and binds it to `y` if it's 1, or uses wildcard `_` if it doesn't care about the value.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_93\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(x : Int) -> Int {\n  match x {\n    1 => { 1 }\n    _ => { 0 }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Newtypes to Avoid Type Alias Cycles in MoonBit\nDESCRIPTION: This code snippet demonstrates the recommended way to avoid type alias cycles by using newtypes. By defining both A and B as new types using `type A B` and `type B A`, we avoid the circular dependency that causes the E4129 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4129.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntype A B\ntype B A\n```\n\n----------------------------------------\n\nTITLE: Defining a Type Alias in MoonBit\nDESCRIPTION: This snippet showcases the definition of a type alias in MoonBit using the `typealias` keyword. A type alias does not create a new type but acts as a type macro, behaving identically to its definition.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_91\n\nLANGUAGE: moonbit\nCODE:\n```\ntypealias I = Int\n```\n\n----------------------------------------\n\nTITLE: Extending Traits in MoonBit\nDESCRIPTION: This snippet demonstrates how a trait can depend on other traits, requiring implementers to also satisfy the dependencies.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_10\n\nLANGUAGE: moonbit\nCODE:\n```\n// start super trait 1\ntrait Foo {\n  fn bar(self : Self) -> Int\n}\n\ntrait Bar: Foo {\n  fn baz(self : Self) -> Int\n}\n```\n\n----------------------------------------\n\nTITLE: try/catch with Simple Expression\nDESCRIPTION: This snippet shows the short hand syntax for try/catch blocks where the body is a single expression and the catch keyword is omitted.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_10\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  try\n    f!() catch\n    MyError => println(\"caught MyError\")\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Array Elements in MoonBit\nDESCRIPTION: This code shows how to access array elements using their index within square brackets.  The index starts at 0.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_23\n\nLANGUAGE: moonbit\nCODE:\n```\nnumbers[x]\n```\n\n----------------------------------------\n\nTITLE: Matching Error Types in MoonBit\nDESCRIPTION: This snippet shows how to perform exhaustive matching on the `Error` type using a `match` statement.  It demonstrates how to handle specific error types like `DivisionByZeroError` and provides a catch-all case `_`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_25\n\nLANGUAGE: moonbit\nCODE:\n```\ntype! ArithmeticError\n\nfn what_error_is_this(e : Error) -> Unit {\n  match e {\n    DivisionByZeroError(_) => println(\"DivisionByZeroError\")\n    ArithmeticError => println(\"ArithmeticError\")\n    ... => println(\"...\")\n    _ => println(\"Error\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving Hash for Structs in MoonBit\nDESCRIPTION: This example demonstrates how to derive the `Hash` trait for a struct in MoonBit. The generated `Hash` implementation allows the struct to be used as a key in hash-based data structures like `HashMap` and `HashSet`. All fields within the struct must also implement the `Hash` trait.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/derive.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Point { x: Int; y: Int } derive(Hash)\n\nfn main() {\n  // Example usage with HashMap would go here\n  // but HashMap is not directly shown in this snippet\n}\n```\n\n----------------------------------------\n\nTITLE: Pipe Operator Usage in MoonBit\nDESCRIPTION: This snippet demonstrates the use of the pipe operator `|>` in MoonBit. It allows chaining function calls by passing the result of one function as the first argument to the next function.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_105\n\nLANGUAGE: moonbit\nCODE:\n```\nfn add1(x : Int) -> Int { x + 1 }\nfn mul2(x : Int) -> Int { x * 2 }\n\nfn main {\n  let result = 5 |> add1 |> mul2\n  debug(result) // Output: 12\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Tuple in MoonBit\nDESCRIPTION: This code snippet demonstrates how to define a tuple in MoonBit. A tuple is a collection of finite values constructed using round brackets `()` with the elements separated by commas `,`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_18\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let tuple : (Int, Bool, String) = (1, true, \"hello\")\n  println(tuple)\n}\n```\n\n----------------------------------------\n\nTITLE: Enum with Payload Data in MoonBit\nDESCRIPTION: Illustrates an enum definition where cases carry payload data. The example uses an integer list type to demonstrate this concept.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_79\n\nLANGUAGE: moonbit\nCODE:\n```\nenum IntList {\n  Nil\n  Cons(head : Int, tail : IntList)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Sub Traits in MoonBit\nDESCRIPTION: This snippet demonstrates implementing a sub-trait, requiring implementation of both the sub-trait's methods and the methods of any super-traits it depends on.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_14\n\nLANGUAGE: moonbit\nCODE:\n```\n// start super trait 2\ntrait Foo {\n  fn bar(self : Self) -> Int\n}\n\ntrait Bar: Foo {\n  fn baz(self : Self) -> Int\n}\n\nimpl Bar for Int with bar(self), baz(self) {\n  self + 1\n}\n\n```\n\n----------------------------------------\n\nTITLE: Optional Arguments in MoonBit (Dependency)\nDESCRIPTION: This code shows that the default expression for an optional argument can depend on the value of previous arguments. This allows creating flexible argument defaults.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_41\n\nLANGUAGE: moonbit\nCODE:\n```\nfn range(start : Int, end~ : Int = start + 10) {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Optional Arguments in MoonBit (Declaration)\nDESCRIPTION: This code demonstrates how to define optional arguments in MoonBit using the syntax `label~ : Type = default_expr`. If the argument is not supplied, the default expression is used.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_38\n\nLANGUAGE: moonbit\nCODE:\n```\nfn greet(name~ : String = \"World\") {\n  IO::println(\"Hello, \" ++ name ++ \"!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving Show for Structs in MoonBit\nDESCRIPTION: This code snippet demonstrates how to derive the `Show` trait for a struct in MoonBit. The `Show` trait generates a pretty-printing method for the type, which displays the struct's fields and their values. All fields within the struct must also implement the `Show` trait.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/derive.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Point { x: Int; y: Int } derive(Show)\n\nfn main() {\n  let p = Point { x: 1, y: 2 }\n  println(\"{}\", p) // prints \"Point { x: 1, y: 2 }\"\n}\n```\n\n----------------------------------------\n\nTITLE: Function with Error Type\nDESCRIPTION: This snippet shows how to define a function that can return an error of a specific type. It uses the `raise` keyword to return an error value.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntype! DivError String\nfn div(x : Int, y : Int) -> Int!DivError {\n  if y == 0 {\n    raise DivError(\"division by zero\")\n  }\n  x / y\n}\n```\n\n----------------------------------------\n\nTITLE: Using 'let' for Initialization in MoonBit\nDESCRIPTION: This code snippet shows how to use the `let` keyword in MoonBit as an alternative to `const` when the value needs to be computed at initialization time. The expression `1 + 1` is evaluated during program startup, and the result is assigned to the variable `a`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4142.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nlet a : Int = 1 + 1 // These will be computed at initialization time.\n```\n\n----------------------------------------\n\nTITLE: Error Handling on Method Invocation\nDESCRIPTION: This snippet demonstrates how to use the `!` and `?` attributes on method invocations and the pipe operator for error handling.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_11\n\nLANGUAGE: moonbit\nCODE:\n```\nx.foo!()\nx.foo?()\nx |> foo!()\nx |> foo?()\n```\n\n----------------------------------------\n\nTITLE: Importing Foreign Function in MoonBit (C)\nDESCRIPTION: This snippet illustrates how to import a foreign function from a C library in MoonBit.  The `extern \"C\"` keyword is used, and the function name is specified.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/ffi.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\nextern \"C\" fn put_char(ch : UInt) = \"function_name\"\n```\n\n----------------------------------------\n\nTITLE: `main` Function Definition in MoonBit\nDESCRIPTION: This code defines a `main` function in MoonBit, which serves as the entry point of the program and gets executed after initialization. It demonstrates a basic `main` function that binds a value to a local variable and prints it. Only `main` packages can define a `main` function.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/introduction.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let x = 2\n  println(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Trait Declaration in MoonBit\nDESCRIPTION: This snippet demonstrates how to declare a trait in MoonBit, defining a list of operations that a type must implement to satisfy the trait.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_9\n\nLANGUAGE: moonbit\nCODE:\n```\n// start trait 1\ntrait Foo {\n  fn bar(self : Self) -> Int\n}\n```\n\n----------------------------------------\n\nTITLE: `for .. in` Loop in MoonBit\nDESCRIPTION: This example shows a basic `for .. in` loop in MoonBit, which is used to iterate over elements of a data structure. The standard library's `Iter` trait facilitates this.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_62\n\nLANGUAGE: moonbit\nCODE:\n```\nfor elem in collection {\n  // process elem\n}\n```\n\n----------------------------------------\n\nTITLE: Method Call Syntax in MoonBit\nDESCRIPTION: This snippet illustrates the difference in calling methods defined using the two syntaxes. Methods defined with `fn method_name(self : T, ..)` can be invoked directly like regular functions, while those defined with `fn T::method_name(..)` must be invoked using the qualified syntax `T::method_name(..)`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\n// Method call syntax example\nfn f(self : Foo) -> Int {\n  1\n}\n\nfn main {\n  let foo = Foo {}\n  f(foo) // call method f\n}\n```\n\n----------------------------------------\n\nTITLE: try/catch with omitted else block\nDESCRIPTION: This snippet shows how to use try/catch where the else block is omitted.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_9\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  try {\n    f!()\n  } catch {\n    MyError => println(\"caught MyError\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Main Package Configuration (main/moon.pkg.json)\nDESCRIPTION: Configures the `main` package to be linked into a WASM file and specifies its dependencies. The `is_main: true` flag indicates that this package should be built into an executable.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/tutorial.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"is_main\": true,\n  \"import\": [\n    \"username/hello/lib\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit: Implement count_qualified_students with iterator\nDESCRIPTION: This code implements the `count_qualified_students` function in MoonBit using iterator functions. It filters the array of students using the `is_qualified` function and then counts the remaining students, providing a concise functional approach.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/tutorial/tour.md#_snippet_16\n\nLANGUAGE: moonbit\nCODE:\n```\nfn count_qualified_students(\n  students : Array[Student],\n  is_qualified : (Student) -> ExamResult\n) -> Int {\n  students.iter().filter(fn(student) { is_qualified(student) == Pass }).count()\n}\n```\n\n----------------------------------------\n\nTITLE: Calling Constrained Generic Functions in MoonBit\nDESCRIPTION: This snippet shows an example of calling a constrained generic function with a type that implements the required trait, in this case, `Eq`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_16\n\nLANGUAGE: moonbit\nCODE:\n```\n// start trait 6\ntrait Eq[Self] {\n  fn eq(self : Self, other : Self) -> Bool\n}\n\nimpl Eq[Int] for Int with eq(self, other) {\n  self == other\n}\n\nfn main {\n  let arr = [1, 2, 3]\n  contains(arr, 1)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Option and Result in MoonBit\nDESCRIPTION: This code snippet demonstrates how to define Option and Result in MoonBit. `Option` and `Result` are the most common types to represent a possible error or failure in MoonBit.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_21\n\nLANGUAGE: moonbit\nCODE:\n```\nlet option : Int? = none\nlet result : Result[Int, String] = Ok(10)\n```\n\n----------------------------------------\n\nTITLE: Implementing `op_add` for Infix Operator in MoonBit\nDESCRIPTION: This code snippet demonstrates the correct implementation of the `op_add` method for the struct `S`, enabling the use of the `+` infix operator. The `op_add` method takes two instances of `S` as input and returns a new instance of `S` with the sum of their `v` fields.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4016.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct S { v : Int }\n\nlet s : S = { v: 3 }\nlet t = s + s\n\nfn S::op_add(self : S, other : S) -> S {\n  { v: self.v + other.v }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining WordSize Trait and Implementations in Moonbit\nDESCRIPTION: This snippet defines the `WordSize` trait with a `word_size()` method that returns an `Int`. It provides implementations of the `WordSize` trait for `Float` and `Double`, specifying the word size for each type. The `WordSize` trait and its implementations are used to demonstrate the trait constraint issue.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4135.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait WordSize { word_size() -> Int }\nimpl WordSize for Float with word_size() { 1 }\nimpl WordSize for Double with word_size() { 2 }\n```\n\n----------------------------------------\n\nTITLE: Constrained Generic Functions with Traits in MoonBit\nDESCRIPTION: This snippet demonstrates declaring a generic function with type parameters constrained by traits, ensuring the type parameters implement specific traits.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_15\n\nLANGUAGE: moonbit\nCODE:\n```\n// start trait 5\nfn contains[T: Eq](arr : Array[T], elem : T) -> Bool {\n  for x in arr {\n    if x == elem { return true }\n  }\n  return false\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Extracting Newtype Values in MoonBit\nDESCRIPTION: This snippet demonstrates creating a newtype value and extracting its underlying representation using pattern matching. The `main` function creates an instance of the newtype `T` and then extracts the `Int` value contained within it using pattern matching.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_89\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let x = T(10)\n  match x {\n    T(y) => { debug(y) }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Calling Async Functions in MoonBit\nDESCRIPTION: This snippet illustrates how to call an async function in MoonBit using the `!` operator. It highlights that the `!` operator will rethrow errors if the async function may throw an error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/async-experimental.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nlet name = await get_name!()\nlet greeting = await hello!(name)\n```\n\n----------------------------------------\n\nTITLE: Deriving Eq and Compare for Enums in MoonBit\nDESCRIPTION: This code snippet shows deriving the `Eq` and `Compare` traits for an enum in MoonBit. The generated methods allow for checking equality and ordering between different enum variants. The order of enum cases is determined by their definition order.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/derive.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nenum Order {\n  Less\n  Equal\n  Greater\n} derive(Eq, Compare)\n\nfn main() {\n  println(\"{}\", Less == Less)    // prints \"true\"\n  println(\"{}\", Less == Greater) // prints \"false\"\n  println(\"{}\", Less < Greater)   // prints \"true\"\n}\n```\n\n----------------------------------------\n\nTITLE: Enum Definition in MoonBit\nDESCRIPTION: Shows the definition of an enum type in MoonBit. Enums are similar to algebraic data types and can have multiple cases (constructors). Constructor names must start with a capitalized letter.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_76\n\nLANGUAGE: moonbit\nCODE:\n```\nenum Color {\n  Red\n  Green\n  Blue\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Generic Type Definitions in MoonBit\nDESCRIPTION: This MoonBit code snippet shows two possible corrections for the error E4000. The first example renames the duplicate type variable 'T' in the 'Container' struct to 'T1' and 'T2'. The 'transform' function is updated to use 'A' and 'B'. The second example demonstrates that if the intention was to use the same type, the duplicate type parameter can be removed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4000.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Container[T1, T2] {\n  value : T1\n}\n\nfn transform[A, B](x : A) -> B {\n  // ... implementation\n}\n```\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Container[T] {\n  value : T\n}\n\nfn transform[A](x : A) -> A {\n  x\n}\n```\n\n----------------------------------------\n\nTITLE: C Callback Registration with MoonBit Closure\nDESCRIPTION: This MoonBit code shows how to bind a C function that accepts a callback and extra data, and how to pass a MoonBit closure to it.  It defines a `register_callback_ffi` function using `extern \"C\"` to bind to the C function and uses `FuncRef` to pass a closed MoonBit function.  The `register_callback` function then calls `register_callback_ffi` with a lambda that invokes the callback, thus effectively passing the original callback as a closure.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/ffi.md#_snippet_9\n\nLANGUAGE: moonbit\nCODE:\n```\nextern \"C\" fn register_callback_ffi(\n  call_closure : FuncRef[(() -> Unit) -> Unit],\n  closure : () -> Unit\n) = \"register_callback\"\n\nfn register_callback(callback : () -> Unit) -> Unit {\n  register_callback_ffi(\n    fn (f) { f() },\n    callback\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Trait Object Example\nDESCRIPTION: This code snippet demonstrates how to pack methods of a type that implements a trait into a runtime object using `as &I` syntax in MoonBit. This enables runtime polymorphism.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_19\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait Foo {\n  bar(Self) -> Int\n}\n\nstruct A {}\nimpl Foo for A {\n  fn bar(self: Self) -> Int { 1 }\n}\n\nstruct B {}\nimpl Foo for B {\n  fn bar(self: Self) -> Int { 2 }\n}\n\nfn main() {\n  let a: A = A{};\n  let b: B = B{};\n\n  let arr: Array<&Foo> = Array::new(2);\n  arr[0] = &a;\n  arr[1] = &b;\n  {\n    let i = 0;\n    while i < arr.length() {\n      debug(arr[i].bar())\n      i = i + 1\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Module Name Configuration in moon.mod.json\nDESCRIPTION: Defines the 'name' field in the moon.mod.json file, which specifies the module's name.  It is a required field and must follow certain naming conventions, especially for modules published to mooncakes.io (starting with the username).\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/module.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"example\",\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Enum with Mutable Fields in MoonBit\nDESCRIPTION: This snippet demonstrates how to define an enum with mutable fields in MoonBit. This is useful for defining imperative data structures. The mutable field is prefixed with `mut` keyword.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_87\n\nLANGUAGE: moonbit\nCODE:\n```\nenum T {\n  T(mut Int)\n}\n```\n\n----------------------------------------\n\nTITLE: Access Control Examples\nDESCRIPTION: Demonstrates access control rules in MoonBit, showing how private types (`priv`) affect the visibility of fields in public structs and the parameters/return types of public functions.  Highlights the restrictions to avoid exposing private types via public entities.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/packages.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\npub(all) type T1\npub(all) type T2\npriv type T3\n\npub(all) struct S {\n  x: T1  // OK\n  y: T2  // OK\n  z: T3  // ERROR: public field has private type `T3`!\n}\n\n// ERROR: public function has private parameter type `T3`!\npub fn f1(_x: T3) -> T1 { ... }\n// ERROR: public function has private return type `T3`!\npub fn f2(_x: T1) -> T3 { ... }\n// OK\npub fn f3(_x: T1) -> T1 { ... }\n\npub let a: T3 = { ... } // ERROR: public variable has private type `T3`!\n```\n\n----------------------------------------\n\nTITLE: Overloaded String Literal in MoonBit\nDESCRIPTION: This code snippet demonstrates overloaded string literals in MoonBit. When the expected type is `String`, the array literal syntax is overloaded to construct the `String` by specifying each character in the string.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_11\n\nLANGUAGE: moonbit\nCODE:\n```\nlet s : String = ['H', 'e', 'l', 'l', 'o']\n```\n\n----------------------------------------\n\nTITLE: Guard Statement with `is` Expression in MoonBit\nDESCRIPTION: This MoonBit snippet showcases the use of a `guard` statement along with an `is` expression. It demonstrates how to ensure that a resource is a plain text resource and handle it accordingly.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_51\n\nLANGUAGE: moonbit\nCODE:\n```\nguard let Text(text) = path else { return Err(\"not a text resource\") }\n// process text\n```\n\n----------------------------------------\n\nTITLE: Enum with Labelled Arguments - Usage in Main Function in MoonBit\nDESCRIPTION: Shows how to construct enums with labelled arguments and utilize the labeled arguments during pattern matching in the main function.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_86\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let move = Move { x: 10, y: 20 }\n  print_message(move)\n}\n```\n\n----------------------------------------\n\nTITLE: Trait Example\nDESCRIPTION: Demonstrates the definition and implementation of a trait in MoonBit. It showcases how traits can define interfaces and how different types can implement those interfaces. It also illustrates that abstract traits have limited visibility from outside the defining package.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/packages.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait Number {\n op_add(Self, Self) -> Self\n op_sub(Self, Self) -> Self\n}\n\nfn add[N : Number](x : N, y: N) -> N {\n  Number::op_add(x, y)\n}\n\nfn sub[N : Number](x : N, y: N) -> N {\n  Number::op_sub(x, y)\n}\n\nimpl Number for Int with op_add(x, y) { x + y }\nimpl Number for Int with op_sub(x, y) { x - y }\n\nimpl Number for Double with op_add(x, y) { x + y }\nimpl Number for Double with op_sub(x, y) { x - y }\n```\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait Number\n\nfn op_add[N : Number](x : N, y : N) -> N\nfn op_sub[N : Number](x : N, y : N) -> N\n\nimpl Number for Int\nimpl Number for Double\n```\n\n----------------------------------------\n\nTITLE: Default Implementations in MoonBit Traits\nDESCRIPTION: This snippet demonstrates defining default implementations for methods in a trait, allowing implementers to omit providing their own implementations.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_12\n\nLANGUAGE: moonbit\nCODE:\n```\n// start trait 3\ntrait J {\n  fn f(self : Self) -> Int\n  fn f_twice(self : Self) -> Int { self.f() + self.f() }\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving Builtin Traits\nDESCRIPTION: This example shows how MoonBit can automatically derive implementations for built-in traits like `Eq`, `Debug`, and `Default` for custom types, simplifying code and reducing boilerplate.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_21\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Point { x: Int, y: Int } #[Eq, Debug, Default]\n\nfn main() {\n  let p: Point = Point::default()\n  debug(p)\n  let q = Point { x: 0, y: 0 }\n  debug(p == q)\n}\n```\n\n----------------------------------------\n\nTITLE: For-Loop with 'else' Branch (Solution)\nDESCRIPTION: This example demonstrates how to resolve the E4108 error by adding an 'else' branch to the for-loop. The 'else' branch specifies the value to be returned when the loop completes normally. The value returned in the `else` branch in this case is the accumulated value `acc`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4108.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(x: Int) -> Int {\n  for i = 0, acc = 0; i < x; i = i + 1, acc = acc + i {\n  } else {\n    acc\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Full Snapshot Test in MoonBit\nDESCRIPTION: This snippet demonstrates a full snapshot test using `@test.T::write` and `@test.T::writeln`. This allows capturing the output of an entire process, such as the content of a generated file.  `@test.T::snapshot` should be used at the end of a test block.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/tests.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\nfn test_snapshot_anything() {\n  @test.T::write(\"hello world\")\n  @test.T::writeln(\"hello moonbit\")\n  @test.T::snapshot(\"record_anything.txt\")\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Module Configuration with Package Import (main/moon.pkg.json)\nDESCRIPTION: Configures the import of the `username/hello/lib` package within the `main` package configuration file. This allows the `main` package to access code defined in the `lib` package.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/tutorial.md#_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"is_main\": true,\n  \"import\": [\n    \"username/hello/lib\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: `for .. in` Loop with Array Index in MoonBit\nDESCRIPTION: This MoonBit snippet shows how to iterate through an array while keeping track of the array index using `for .. in` with two loop variables.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_65\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let arr = [1, 2, 3, 4, 5]\n  for i, elem in arr.indexed() {\n    debug(i, elem)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Literal Creation in MoonBit\nDESCRIPTION: This code demonstrates how to create JSON data in MoonBit by overloading literals.  Number, string, array, and map literals can be used directly when the expected type is `Json`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_29\n\nLANGUAGE: moonbit\nCODE:\n```\nlet json : Json = { \"a\": 1, \"b\": [true, \"hello\"] }\n```\n\n----------------------------------------\n\nTITLE: Using Labelled Argument with Default Value in MoonBit\nDESCRIPTION: Demonstrates how to properly define a default value for an argument in MoonBit using a labelled argument (denoted by `~`).  This allows the function to be called with or without the argument, defaulting to \"World\" if omitted. The example also shows how to call the function both with and without the named argument.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3010.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn greet(name~ : String = \"World\") -> Unit {\n  println(\"Hello, \" + name + \"!\")\n}\n\nfn main {\n  // Can be called as:\n  greet() // Uses default value \"World\"\n  greet(name=\"Alice\") // Uses provided value \"Alice\"\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Wildcards in MoonBit\nDESCRIPTION: This snippet demonstrates pattern matching with wildcards in MoonBit. The `_` is used to ignore a specific value, and `..` is used to ignore the remaining fields of a struct or enum.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_94\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Point { x : Int, y : Int }\n\nfn f(p : Point) -> Int {\n  match p {\n    { x, y: _ } => { x }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Moving Derive to the Original Type in MoonBit\nDESCRIPTION: This code snippet shows the correct way to derive the `Show` trait in MoonBit when working with type aliases. Instead of deriving the trait for the alias, it's derived for the original type (`MyStruct`).  The type alias then simply refers to the derived type.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4130.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct MyStruct {\n  field: Int\n} derive(Show)\n\ntypealias StructAlias = MyStruct // Remove `derive`\n```\n\n----------------------------------------\n\nTITLE: Division by Zero Error Example\nDESCRIPTION: This example shows how to define a custom error type `DivisionByZeroError` and use it in a `div` function that raises the error when dividing by zero.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_14\n\nLANGUAGE: moonbit\nCODE:\n```\ntype! DivisionByZeroError String\nfn div(x : Int, y : Int) -> Int!DivisionByZeroError {\n  if y == 0 {\n    raise DivisionByZeroError(\"division by zero\")\n  }\n  x / y\n}\n```\n\n----------------------------------------\n\nTITLE: Guard Statement Example in MoonBit\nDESCRIPTION: This code shows the usage of a `guard` statement in MoonBit. It checks an invariant, and if the condition is not satisfied, the code in the `else` block is executed and its evaluation result is returned.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_50\n\nLANGUAGE: moonbit\nCODE:\n```\nguard cond else { return default_value }\n```\n\n----------------------------------------\n\nTITLE: Struct Update Syntax in MoonBit\nDESCRIPTION: Illustrates the struct update syntax in MoonBit, which allows creating a new struct based on an existing one, updating specific fields. The `...existing_struct` syntax copies all fields from the original struct, and then specified fields are updated.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_75\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let p = Person { name: \"Alice\", age: 30, email: \"alice@example.com\" }\n  // Updating age and email, keeping name the same\n  let p2 = { ...p, age: 31, email: \"alice.new@example.com\" }\n  debug(p2.name)\n  debug(p2.age)\n  debug(p2.email)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Top-Level Function in MoonBit\nDESCRIPTION: This code shows how to define a top-level function in MoonBit using the `fn` keyword.  Type annotations are required for arguments and the return value.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_30\n\nLANGUAGE: moonbit\nCODE:\n```\nfn add(x : Int, y : Int, z : Int) -> Int {\n  x + y + z\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Main Function (main.mbt)\nDESCRIPTION: Defines the `main` function that calls the `hello` function from the `lib` package and prints the result to the console.  It uses the package alias `@lib`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/tutorial.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  println(@lib.hello())\n}\n```\n\n----------------------------------------\n\nTITLE: Overloading Operators Example in MoonBit\nDESCRIPTION: This snippet showcases how to overload operators by implementing the corresponding traits or defining the special methods. It uses `Array::op_get` to access an element.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\n// start operator 3\nfn main {\n  let arr = Array { data: [1, 2, 3] }\n  let x = arr[0] // desugared to arr.op_get(0)\n  debug(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Enum with Labelled Arguments - Function Definition in MoonBit\nDESCRIPTION: Demonstrates a function that processes an enum with labelled arguments using pattern matching. The labels can be directly used within the matching cases.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_83\n\nLANGUAGE: moonbit\nCODE:\n```\nfn process_message(msg : Message) {\n  case msg {\n    Quit => debug(\"Quit\")\n    Move { x, y } => debug(\"Move to x=\\(x), y=\\(y)\")\n    Write { text } => debug(\"Write \\(text)\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: For Loop with Continue and Update in MoonBit\nDESCRIPTION: This MoonBit example shows the usage of the `continue` statement within a `for` loop, updating binding variables. The loop calculates the sum of even numbers from 1 to 6.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_61\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  var sum = 0\n  for var i = 1; i <= 6; i = i + 1 {\n    if i % 2 != 0 { continue i + 1 }\n    sum = sum + i\n  }\n  debug(sum)\n}\n```\n\n----------------------------------------\n\nTITLE: Labelled Arguments in MoonBit (Declaration)\nDESCRIPTION: This code shows how to declare a top-level function with labelled arguments using the `label~ : Type` syntax in MoonBit. The label serves as the parameter name inside the function body.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_36\n\nLANGUAGE: moonbit\nCODE:\n```\nfn area(width~ : Int, height~ : Int) -> Int {\n  width * height\n}\n```\n\n----------------------------------------\n\nTITLE: Labelled Arguments in MoonBit (Usage)\nDESCRIPTION: This code shows how to supply labelled arguments using the `label=arg` syntax. The `label=label` can be abbreviated as `label~`. Labelled arguments can be supplied in any order.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_37\n\nLANGUAGE: moonbit\nCODE:\n```\nIO::println(area(height~=10, width~=5))\nIO::println(area(width=5, height=10))\n```\n\n----------------------------------------\n\nTITLE: Sliding Stack Elements in MoonBit\nDESCRIPTION: This MoonBit code snippet implements the `Slide` instruction.  The `Slide(n)` instruction skips the first address on the stack and then removes the next N addresses. It's used to clean up addresses of local variables in `let` and `letrec` expressions that are no longer needed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-2.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nSlide(n: Int),\n\n    Slide(n) => {\n      let addr = state.stack.last()\n      let new_stack = list::drop_last(state.stack)\n      let new_stack = list::drop(new_stack, n)\n      {state with stack = list::push(new_stack, addr)}\n    }\n```\n\n----------------------------------------\n\nTITLE: JavaScript Closure Implementation for Wasm FFI\nDESCRIPTION: This JavaScript code demonstrates a possible implementation of the `make_closure` function for the Wasm backend. It takes a MoonBit function reference (`funcref`) and a closure object, and returns a host's function by binding the `funcref` to the `closure`. This is required to adapt MoonBit closures to Wasm's `externref` type.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/ffi.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n{ \n  \"moonbit:ffi\": {\n    \"make_closure\": (funcref, closure) => funcref.bind(null, closure)\n  } \n}\n```\n\n----------------------------------------\n\nTITLE: FixedArray Solution in MoonBit\nDESCRIPTION: This code shows the correct way to initialize a `FixedArray` with unique objects for each index using `FixedArray::makei()`. This avoids the pitfall of all cells referencing the same object.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_25\n\nLANGUAGE: moonbit\nCODE:\n```\nlet arr : FixedArray[Int] = FixedArray::makei(3, (i) => 0)\narr[0] = 1\nIO::println(Debug::toString(arr)) // [1, 0, 0]\n```\n\n----------------------------------------\n\nTITLE: Checking for Single Possible Value in MoonBit\nDESCRIPTION: This function checks if a list contains only one element. If the list is empty, it returns `Err(false)`. If the list contains a single element `x`, it returns `Ok(x)`. If the list contains more than one element, it returns `Err(true)`. This function is used in the `eliminate` function to determine if a square has only one possible value left.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/sudoku/index.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n// Return `Err(false)` if the list is empty\n// Return `Ok(x)` if the list contains only `[x]`\n// Return `Err(true)` if the list contains `[x1, x2, ......]`\nfn single[T](this : List[T]) -> Result[T, Bool] {\n  match this {\n    Nil => Err(false)\n    Cons(x, Nil) => Ok(x)\n    _ => Err(true)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Bytes in MoonBit\nDESCRIPTION: This code snippet demonstrates how to define Bytes in MoonBit. A `Bytes` is an immutable sequence of bytes. Similar to byte, bytes literals have the form of `b\"...\"`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_15\n\nLANGUAGE: moonbit\nCODE:\n```\nlet bytes : Bytes = b\"hello world\"\n```\n\n----------------------------------------\n\nTITLE: Overloading `op_get` and `op_set` Methods in MoonBit\nDESCRIPTION: This snippet demonstrates operator overloading using the `op_get` and `op_set` methods, which are used to overload the `_[_]` (get item) and `_[_] = _` (set item) operators, respectively.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\n// start operator 2\nfn Array::op_get(self : Array[T], index : Int) -> T {\n  self.data[index]\n}\n\nfn Array::op_set(self : Array[T], index : Int, value : T) -> Unit {\n  self.data[index] = value\n}\n```\n\n----------------------------------------\n\nTITLE: Optional Arguments in MoonBit (Lifting)\nDESCRIPTION: This code demonstrates how to lift the default expression to a top-level `let` declaration if you want to share the result of the default expression between different function calls.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_40\n\nLANGUAGE: moonbit\nCODE:\n```\nlet default_value = expensive_calculation()\n\nfn bar(x~ : Int = default_value) {\n  IO::println(x)\n}\n```\n\n----------------------------------------\n\nTITLE: While Loop with Return Value and Break in MoonBit\nDESCRIPTION: This MoonBit example shows a `while` loop that returns a value using the `else` clause and the `break` statement. When breaking from the loop, a return value of the same type as the else clause is required.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_56\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  var i = 0\n  while i < 3 {\n    debug(i)\n    i = i + 1\n    if i == 2 { break 100 }\n  } else {\n    1\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Error Types in MoonBit\nDESCRIPTION: This snippet demonstrates how to define error types in MoonBit using the `type!` keyword. It showcases defining a simple error type.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntype! MyError String\n```\n\n----------------------------------------\n\nTITLE: Map Pattern Matching in MoonBit\nDESCRIPTION: This snippet demonstrates map pattern matching in MoonBit, using `key : value` to match if the key exists with corresponding value and `key? : value` to match whether or not the key exists.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_100\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(m : Map[String, Int]) -> Int {\n  match m {\n    {\"a\" : 1, \"b\"? : x, ..} => x.get_or_default(0)\n    _ => 0\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Package Configuration JSON\nDESCRIPTION: Defines the configuration for a MoonBit package named `pkgB`. This file declares dependencies between packages.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/packages.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"pkgB\"\n}\n```\n\n----------------------------------------\n\nTITLE: Create a New MoonBit Module\nDESCRIPTION: Creates a new MoonBit module named `username/hello` in the `my-project` directory using the `moon new` command.  It uses default values provided via the CLI prompts.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/tutorial.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ moon new\nEnter the path to create the project (. for current directory): my-project\nSelect the create mode: exec\nEnter your username: username\nEnter your project name: hello\nEnter your license: Apache-2.0\nCreated my-project\n```\n\n----------------------------------------\n\nTITLE: Importing Foreign Function in MoonBit (JavaScript)\nDESCRIPTION: This snippet demonstrates importing a foreign function in MoonBit for the JavaScript backend. The specified module and function name are interpreted as `module.function`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/ffi.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nfn cos(d : Double) -> Double = \"Math\" \"cos\"\n```\n\n----------------------------------------\n\nTITLE: Optional Parameter with Default Value\nDESCRIPTION: Demonstrates the syntax for defining an optional parameter with a default value in MoonBit.  The parameter `a` is an optional integer with a default value of 0. When the function `f` is called without providing a value for `a`, it will default to 0.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3015.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(a~ : Int = 0) -> Unit {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving FromJson and ToJson in MoonBit\nDESCRIPTION: This snippet demonstrates deriving `FromJson` and `ToJson` traits for a struct in MoonBit, enabling serialization to and deserialization from JSON format. It showcases a basic example without advanced configurations.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/derive.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Point { x: Int; y: Int } derive(FromJson, ToJson)\n\nfn main() {\n  // Example of serialization/deserialization would go here,\n  // but is not directly shown in this snippet\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Use of a Single Intrinsic in MoonBit\nDESCRIPTION: This code snippet demonstrates the correct usage of a single intrinsic in a MoonBit function. The `MyArray::get` function is modified to use only the `%array.get` intrinsic.  This resolves the E4071 error by adhering to the rule of associating a function with only one intrinsic. The function retrieves an element from an array using an index.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4071.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\n/// @intrinsic %array.get\nfn MyArray::get[T](self : MyArray[T], index : Int) -> T {\n  return self._[index]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Arithmetic Operations in MoonBit\nDESCRIPTION: This MoonBit code defines helper functions for implementing binary operations. The op function takes two addresses from the stack, evaluates them to NNum nodes, performs the operation, and pushes the result back onto the stack.  It handles potential errors by returning the original state if the nodes are not NNum.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-2.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\nfn op(state : GState, f : Fn(Int, Int) -> Int) -> GState {\n  let (a1, a2) = state.pop2()\n  let state = {state with stack = list::push(state.stack, a2)}\n  let state = eval(state)\n  let a2 = state.stack.last()\n  let state = {state with stack = list::drop_last(state.stack)}\n\n  let state = {state with stack = list::push(state.stack, a1)}\n  let state = eval(state)\n  let a1 = state.stack.last()\n  let state = {state with stack = list::drop_last(state.stack)}\n\n  match (state.heap[a1], state.heap[a2]) {\n    (Node::NNum(n1), Node::NNum(n2)) => {\n      let newnode = Node::NNum(f(n1, n2))\n      let addr = state.heap.alloc(newnode)\n      {\n        state with\n        stack = list::push(state.stack, addr)\n      }\n    }\n    _ => state\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Test Block in MoonBit\nDESCRIPTION: This snippet demonstrates a basic test block in MoonBit. It uses the `assert_eq` function from the standard library to check for equality. If the assertion fails, the test terminates and outputs an error message.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/tests.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn test_normal() {\n  assert_eq(1 + 1, 2)\n}\n\nfn test_named(\"test_name\") {\n  assert_eq(1 * 2, 2)\n}\n```\n\n----------------------------------------\n\nTITLE: Substitution Function for TermDBI in MoonBit\nDESCRIPTION: This code snippet implements the `subst` function for substituting a `TermDBI` into another `TermDBI` at a given depth in MoonBit. It recursively traverses the target term, replacing variables at the specified depth with the substitution term. The `subst` function is a key component of beta reduction in the Lambda calculus interpreter.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/lambda/index.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\nfn subst(self : TermDBI, depth : Int, term : TermDBI) -> TermDBI {\n  match self {\n    VarDBI(i, s) => {\n      if i == depth {\n        term\n      } else if i > depth {\n        VarDBI(i - 1, s)\n      } else {\n        self\n      }\n    }\n    AbsDBI(varname, body) => {\n      AbsDBI(varname, subst(body, depth + 1, term))\n    }\n    AppDBI(t1, t2) => {\n      AppDBI(subst(t1, depth, term), subst(t2, depth, term))\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: C Implementation of `open_ffi` with Reference Counting\nDESCRIPTION: This is the C implementation of the foreign function `open_ffi` that is bound to Moonbit's `open` function. It demonstrates how to properly decrement the reference count after using the `filename` parameter.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/ffi.md#_snippet_15\n\nLANGUAGE: c\nCODE:\n```\nint open_ffi(moonbit_bytes_t filename, int flags) {\n  int fd = open(filename, flags);\n  moonbit_decref(filename);\n  return fd;\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Pattern Matching in MoonBit\nDESCRIPTION: This snippet demonstrates JSON pattern matching in MoonBit. It uses literal patterns and constructors to match against JSON values.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_101\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(j : Json) -> Int {\n  match j {\n    Json::Object({\"a\": Json::Number(1.0), ..}) => 1\n    _ => 0\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Map Pattern in MoonBit\nDESCRIPTION: Demonstrates how to correctly use a map pattern in a MoonBit match statement to avoid the E3012 error. It uses a map pattern to extract the value associated with the key \"value\" from the struct 'S'.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3012.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let s : S = { value: 42 }\n  match s {\n    { \"value\": value } => println(\"Value is: \\{value}\")\n    _ => println(\"No value\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Overloaded Operator in MoonBit\nDESCRIPTION: This MoonBit code snippet shows the corrected version of the overloaded `op_add` operator for type `A`. The second argument `other` is now of type `A`, which aligns with the expected parameter type for this operator.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4066.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn A::op_add(self : A, other : A) -> A {\n  self._ + other._\n}\n```\n\n----------------------------------------\n\nTITLE: `for .. in` Loop with Integer Sequence in MoonBit\nDESCRIPTION: Demonstrates iterating through a sequence of integers using the `for .. in` loop in MoonBit.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_63\n\nLANGUAGE: moonbit\nCODE:\n```\nfor i in 0..10 {\n  debug(i)\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected MoonBit For Loop Break without Value\nDESCRIPTION: This code snippet shows how to fix the error E4110 by removing the argument from the `break` statement. This is appropriate when a value is not needed when exiting the loop.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4110.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(x: Int) -> Unit {\n  for i in 0..=x {\n    break\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Default Trait Implementation (MoonBit)\nDESCRIPTION: Demonstrates using default trait implementations as an alternative solution to avoid E4053 when implementing a trait for all types.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4053.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nimpl A with f(self : Self) -> Int {\n  ignore(self)\n  0\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies in moon.pkg.json\nDESCRIPTION: This JSON snippet demonstrates how to import dependencies in a `moon.pkg.json` file.  It imports the `moonbitlang/quickcheck` package directly and the `encode` function from the `moonbitlang/x/encoding` package, aliasing it as `lib`. User can write `@lib.encode` instead of `encode`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/package.md#_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"import\": [\n    \"moonbitlang/quickcheck\",\n    { \"path\" : \"moonbitlang/x/encoding\", \"alias\": \"lib\", \"value\": [\"encode\"] }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing trait B for a wrapper type WrapA - MoonBit\nDESCRIPTION: This MoonBit code demonstrates a solution to the orphan rule violation by creating a new type `WrapA` that wraps the original type `@a.A`.  It then implements the trait `@a.B` for this new wrapper type `WrapA`. This avoids the orphan rule because the trait implementation and the `WrapA` type are in the same package.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4061.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntype WrapA @a.A\n\nimpl @a.B for WrapA with to_int(self : WrapA) -> Int {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Array in MoonBit\nDESCRIPTION: This code snippet demonstrates how to initialize an array in MoonBit using square brackets and comma-separated elements. The elements can be accessed using their index, starting from zero.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_22\n\nLANGUAGE: moonbit\nCODE:\n```\n[1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Marking Incomplete Code in MoonBit\nDESCRIPTION: Demonstrates the use of `...` to represent unfinished code within a function definition. This allows the code to compile, but results in a runtime error if the function is called.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0028.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f() -> Unit {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Snapshot Test with `Show` in MoonBit\nDESCRIPTION: This snippet illustrates how to perform a snapshot test using the `Show` trait. The `inspect!` macro captures the string representation of a value that implements `Show` and compares it against a stored snapshot. The `content` label is used to name the snapshot.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/tests.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Foo { x : Int, y : String }\n\nfn test_snapshot_show() {\n  let foo = Foo { x = 1, y = \"hello\" }\n  inspect!(foo, content = \"foo\")\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving E4091: Accessing Existing Struct Fields (Moonbit)\nDESCRIPTION: This code snippet demonstrates how to resolve the E4091 error by accessing existing fields of the `Point` struct, specifically `x` and `y`. It defines the `Point` struct and then accesses the `x` and `y` fields, printing their values. The code requires the Moonbit compiler to be installed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4091.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Point {\n  x : Double\n  y : Double\n}\n\nfn main {\n  let point = Point::{ x : 1.0, y : 2.0 }\n  println(point.x)\n  println(point.y)\n}\n```\n\n----------------------------------------\n\nTITLE: Mutable Struct Example in MoonBit\nDESCRIPTION: This code snippet demonstrates how to use a struct with mutable fields to achieve the desired behavior of modifying data. The `mut` keyword is used to declare that the `c` field of the `MyStruct` struct can be modified.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4090.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub struct MyStruct {\n  a: Int\n  b: Int\n  mut c: Int\n}\n\nfn main {\n  let a : MyStruct = { a : 1, b : 2, c : 3 }\n  a.c = 4\n  println(a.c)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Methods in MoonBit\nDESCRIPTION: This snippet demonstrates two ways to define methods in MoonBit: using `fn method_name(self : SelfType, ..)` and `fn SelfTypeName::method_name(...)`. The former defines a regular function that can be invoked directly, while the latter defines a method in the namespace of `SelfTypeName` and must be invoked using qualified syntax.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn method_name(self : SelfType, ..)\nfn SelfTypeName::method_name(...)\n```\n\n----------------------------------------\n\nTITLE: MoonBit Solution for E4086\nDESCRIPTION: This example shows the correct way to call the function `f` with the required labeled argument `name`. By using `name=\"John\"`, the error is resolved and the code compiles successfully.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4086.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(name~ : String) -> Unit {\n  println(\"Hello, \\{name}\")\n}\n\nfn main {\n  f(name=\"John\")\n}\n```\n\n----------------------------------------\n\nTITLE: Range Pattern with Named Constant - MoonBit\nDESCRIPTION: This code demonstrates the solution to E3018 by declaring a named constant `A` and using it as the upper bound in the range pattern. This satisfies the compiler's requirement for constant bounds.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3018.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nconst A = 3\nfn main {\n  match 0 {\n    0..<A => println(\"Between 0 and 3\")\n    _ => println(\"Not between 0 and 3\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: GPrint instruction definition in MoonBit\nDESCRIPTION: This MoonBit code defines the `GPrint` instruction for the G-Machine. This instruction recursively evaluates and writes the result of a node into the `output` component of the `GState`. It's crucial for handling `NConstr` nodes with substructures, which may be unevaluated `NApp` nodes.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-3.md#_snippet_13\n\nLANGUAGE: moonbit\nCODE:\n```\n/* start gprint definition */\n  | GPrint\n  /* end gprint definition */\n```\n\n----------------------------------------\n\nTITLE: MoonBit Record Field Corrected\nDESCRIPTION: This MoonBit code snippet shows the corrected version of the previous example where the record is now initialized with the correct field 'a'. The code now properly initializes the record 't' of type 'T' using the defined field 'a'.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4026.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct T { a : Int }\nfn main {\n  let t = { a: 42 }\n}\n```\n\n----------------------------------------\n\nTITLE: Function Alias in MoonBit\nDESCRIPTION: This code demonstrates how to declare function aliases, allowing functions to be called with alternative names. This is useful for assigning shorter names to foreign functions or re-exporting functions.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_46\n\nLANGUAGE: moonbit\nCODE:\n```\nalias my_add = add\n```\n\n----------------------------------------\n\nTITLE: Wasm GC Backend Imported String Constants Configuration\nDESCRIPTION: This JSON snippet demonstrates how to configure the `imported-string-constants` option for the Wasm GC backend in the `link` section of a `moon.pkg.json` file. It specifies the imported string namespace used by the JS String Builtin Proposal. The default value is `_`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/package.md#_snippet_8\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"link\": {\n      \"wasm-gc\": {\n        \"use-js-builtin-string\": true,\n        \"imported-string-constants\": \"_\"\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Fix: Adding the Missing Field to Constructor\nDESCRIPTION: Presents a solution for E4113 by adding the missing field `b` to the constructor `A` in the enum `E` definition. This resolves the error by making the accessed field available. Requires the MoonBit compiler to verify the fix.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4113.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub enum E {\n  A(a~: Int, b~: Bool)\n}\n\npub fn f(x: E) -> Unit {\n  match x {\n    A(..) as a => {\n      println(a.a)\n      println(a.b)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected MoonBit For Loop Break with Else Branch\nDESCRIPTION: This code snippet demonstrates how to fix the error E4110 by adding an `else` branch. The `else` branch handles the case where the loop completes normally, and it provides a return value. In this example, if the loop completes without a `break`, the function returns 42.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4110.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(x: Int) -> Int {\n  for i in 0..=x {\n    break i\n  } else {\n    42\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Array Pattern Matching in MoonBit\nDESCRIPTION: This snippet demonstrates array pattern matching in MoonBit, using `..` to capture the remaining elements in the array. The `match` expression checks the structure of an array and binds values to variables based on the defined patterns.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_96\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(arr : Array[Int]) -> Int {\n  match arr {\n    [a, ..rest, b] => { a + b }\n    _ => 0\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Async Timer Example with JS Integration in MoonBit\nDESCRIPTION: This code demonstrates integrating MoonBit's async programming with JavaScript's callback-based API, specifically using `setTimeout` for a timer. It showcases how to use `resume_ok` to continue the MoonBit coroutine when the timer expires.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/async-experimental.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\nextern def setTimeout(callback: fn(), timeout: Int) -> ()\n\nfn async_timer() -> String:\n  let result = %async.suspend[String]((cb: Result[fn(String), fn(Error)]) => {\n    match cb {\n      Ok(resume_ok) => {\n        setTimeout(() => {\n          resume_ok(\"Timer expired!\")\n        }, 1000)\n      }\n      Err(resume_err) => {\n        resume_err(Error::new(\"Timer cancelled!\"))\n      }\n    }\n  })\n  result\n```\n\n----------------------------------------\n\nTITLE: MoonBit Main Function with Alias (main.mbt)\nDESCRIPTION: Modifies the `main` function to import the `fib` package with a custom alias (`my_awesome_fibonacci`) and use both Fibonacci functions, printing the results along with the \"Hello, world!\" message from the `lib` package.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/tutorial.md#_snippet_16\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let a = @my_awesome_fibonacci.fib(10)\n  let b = @my_awesome_fibonacci.fib2(11)\n  println(\"fib(10) = \\{a}, fib(11) = \\{b}\")\n\n  println(@lib.hello())\n}\n```\n\n----------------------------------------\n\nTITLE: Using @buffer.T in MoonBit\nDESCRIPTION: This code snippet demonstrates the use of `@buffer.T` in MoonBit. `@buffer.T` is a constructor for bytes that comes with methods for writing different kinds of data.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_16\n\nLANGUAGE: moonbit\nCODE:\n```\nlet buffer = @buffer.T()\nbuffer.write_int32(10)\nbuffer.write_string(\"hello\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Trait with Default Method in MoonBit\nDESCRIPTION: This snippet shows how implementing a trait with a default method only requires implementing the non-default methods. The default method can be overridden if needed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_13\n\nLANGUAGE: moonbit\nCODE:\n```\n// start trait 4\ntrait J {\n  fn f(self : Self) -> Int\n  fn f_twice(self : Self) -> Int { self.f() + self.f() }\n}\n\nimpl J for Int with f(self) {\n  self + 1\n}\n```\n\n----------------------------------------\n\nTITLE: Overloading `op_as_view` for Custom View in MoonBit\nDESCRIPTION: This snippet demonstrates how to implement `op_as_view` method for creating a view for user-defined type, allowing to implement slicing.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\n// start view 2\nfn Array::op_as_view(self : Array[T], start? : Option[Int], end? : Option[Int]) -> Array[T] {\n  let start = match start? {\n    None => 0\n    Some(v) => v\n  }\n  let end = match end? {\n    None => len(self.data)\n    Some(v) => v\n  }\n  let view = Array { data : [] }\n  for i = start; i < end; i = i + 1 {\n    view.data.push(self[i])\n  }\n  view\n}\n```\n\n----------------------------------------\n\nTITLE: Using #borrow with open function in MoonBit\nDESCRIPTION: This code snippet shows an example of using the `#borrow` attribute with the `open` function in MoonBit. By specifying `filename` as a borrowed parameter, the MoonBit runtime avoids the need for a stub function to manage the reference count of the `filename` Bytes object, simplifying the FFI interaction.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/ffi.md#_snippet_17\n\nLANGUAGE: moonbit\nCODE:\n```\n#borrow(filename)\nextern \"C\" fn open(filename : Bytes, flags : Int) -> Int = \"open\"\n```\n\n----------------------------------------\n\nTITLE: Wrapping External Type in a New Type (MoonBit)\nDESCRIPTION: This code snippet shows another solution to E4059: wrapping the type `@a.A` from package `a` inside a new type `WrapA` declared in the current package. The method `f` can then be defined on `WrapA`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4059.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\npub type WrapA @a.A\n\nfn f(self : WrapA) -> Int {\n  ignore(self._) // Use `._` to access the wrapped value if @a.A is public\n  0\n}\n```\n\n----------------------------------------\n\nTITLE: Iter Implementation Example in MoonBit\nDESCRIPTION: Shows an example of an `Iter` implementation in MoonBit, a built-in type used for internal iterators. It illustrates the basic structure of an iterator that allows traversal of a sequence.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_69\n\nLANGUAGE: moonbit\nCODE:\n```\nfn iter[T](arr : Array[T]) : Iter[T] {\n  var i = 0\n  fn(yield : (T) -> IterResult) : IterResult {\n    if i < array::length(arr) {\n      let res = yield(arr[i])\n      i = i + 1\n      res\n    } else {\n      IterEnd\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Number Literals in MoonBit\nDESCRIPTION: This code snippet shows examples of defining integer and unsigned integer literals in MoonBit, including the use of the `U` and `L` suffixes to specify unsigned and 64-bit numbers respectively.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nlet x : Int = 123\nlet y : UInt = 123U\nlet z : Int64 = 123L\n```\n\n----------------------------------------\n\nTITLE: Corrected Continue Arguments in For Loop - MoonBit\nDESCRIPTION: This example demonstrates a corrected MoonBit `for` loop where the `continue` statement provides the correct number of arguments (two or none). Using `continue i + 2, j + 1` provides two arguments, matching i and j. `continue` with no arguments utilizes the default update expressions.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4104.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn g(x : Int, y : Int) -> Int {\n  for i = x, j = y; i + j < 10; i = i + 1, j = j + 1 {\n    if i < j {\n      continue i + 2, j + 1\n    } else {\n      continue\n    }\n  } else {\n    42\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting to Result with ?\nDESCRIPTION: This snippet shows how to convert a function call to return a `Result` type using the `?` operator.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\nfn bar() -> Result[Unit, Error] {\n  foo?()\n}\n```\n\n----------------------------------------\n\nTITLE: Snapshot File Example\nDESCRIPTION: This is an example of the snapshot file generated by `test_snapshot_anything`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/tests.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\nhello worldhello moonbit\n\n```\n\n----------------------------------------\n\nTITLE: Marking Unused Generic Type Variable with '_'\nDESCRIPTION: This MoonBit code demonstrates the alternative solution to use `_` to explicitly mark the generic type variable as intentionally unused.  This avoids the E0005 error while preserving the generic type parameter. It indicates to the compiler that the type parameter is present but will not be used. It requires a MoonBit compiler to execute.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0005.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Foo[_] {\n  bar : Int\n}\n```\n\n----------------------------------------\n\nTITLE: Take Function for Stream in MoonBit\nDESCRIPTION: Defines the `take` function for `Stream` in MoonBit. It extracts the first `n` elements from the stream, forcing computation. The function returns a regular `List[T]` containing the extracted elements.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nfn take[T](self : Stream[T], n : Int) -> List[T] {\n  if n == 0 {\n    Nil\n  } else {\n    match self {\n      Empty => Nil\n      Cons(x, xs) => Cons(x, xs().take(n - 1))\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Segment Tree in MoonBit\nDESCRIPTION: This snippet implements the `query` function for a segment tree in MoonBit.  It takes the root of the segment tree and a query range (query_l, query_r) as input and returns the sum of the elements in the specified range.  If the query range does not overlap with the current range (l, r), it returns an empty node.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/segment-tree/segment-tree.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\nfn query(root : Node, l : Int, r : Int, query_l : Int, query_r : Int) -> Node {\n  let empty_node : Node = Nil\n  if query_l > r || query_r < l {\n    empty_node\n  } else if query_l <= l && query_r >= r {\n    root\n  } else {\n    match root {\n      Nil => empty_node\n      Node(_, left, right) => {\n        let mid = l + (r - l) / 2\n        let left_result = query(left, l, mid, query_l, query_r)\n        let right_result = query(right, mid + 1, r, query_l, query_r)\n        op_add(left_result, right_result)\n      }\n    }\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: While Loop with Break and Continue in MoonBit\nDESCRIPTION: This example shows how to use `break` and `continue` statements within a `while` loop in MoonBit. `break` exits the loop, while `continue` skips to the next iteration.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_54\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  var i = 0\n  while true {\n    i = i + 1\n    if i % 2 == 0 { continue }\n    debug(i)\n    if i > 10 { break }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Binary Number in MoonBit\nDESCRIPTION: This code snippet demonstrates how to define binary numbers in MoonBit, which start with `0b` or `0B`. The digits after `0b`/`0B` must be `0` or `1`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nlet b1 : Int = 0b101010\nlet b2 : Int = 0B101010\n```\n\n----------------------------------------\n\nTITLE: MoonBit Function Definition with Type Annotation\nDESCRIPTION: This code snippet provides a solution to the error E4075 by adding a type annotation to the parameter `param`. Here, the parameter `param` is explicitly typed as `Int`. The function is defined to return a `Unit` type.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4075.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(param: Int) -> Unit {\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving Default for Structs in MoonBit\nDESCRIPTION: This example demonstrates deriving the `Default` trait for a struct in MoonBit. The generated `default` method returns a new instance of the struct where all fields are initialized to their default values.  Each field type must implement the `Default` trait.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/derive.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Point { x: Int; y: Int } derive(Default)\n\nfn main() {\n  let p = Point::default()\n  println(\"{}\", p) // prints \"Point { x: 0, y: 0 }\"\n}\n```\n\n----------------------------------------\n\nTITLE: Fix: Remove Labelled Arguments (MoonBit)\nDESCRIPTION: This example demonstrates the alternative solution of removing the labelled argument from the local function `h`. By changing `x~: Int` to `x: Int` and calling `h(42)` instead of `h(x=42)`, the error is avoided because labelled arguments are no longer being used in the local function.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4114.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f() -> Unit {\n  fn h(x: Int) -> Unit {\n    println(x)\n  }\n  h(42)\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Index Depth in MoonBit\nDESCRIPTION: This code snippet defines a helper function to find the corresponding `depth` based on a specific `name` from an immutable list of `Index` structs. The function recursively searches the list for a matching name and returns its depth or an error if not found. This helper function aids in the `bruijn` conversion process.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/lambda/index.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\n// Find the depth of a name in the index list\nfn find_depth(name : String, index : @immut/list.T[Index]) -> Result[Int, String] {\n  fn go(name : String, index : @immut/list.T[Index]) -> Result[Int, String] {\n    match index {\n      Nil => Err(\"find_depth(): Name not found: \\{\"name}\"\")\n      Cons(head, tail) => {\n        if head.name == name {\n          Ok(head.depth)\n        } else {\n          go(name, tail)\n        }\n      }\n    }\n  }\n  go(name, index)\n}\n```\n\n----------------------------------------\n\nTITLE: Dot Syntax Method Calls in MoonBit\nDESCRIPTION: This snippet shows how methods can be called using dot syntax `x.method(...)` when the first parameter of a method is also the type it belongs to. MoonBit automatically finds the correct method based on the type of `x`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\n// start method 1\nfn f(self : Foo) -> Int {\n  1\n}\n\nfn main {\n  let foo = Foo {}\n  foo.f()\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Guard Condition in MoonBit\nDESCRIPTION: This snippet demonstrates the usage of guard conditions in MoonBit pattern matching. The guard condition is a boolean expression that must be true for the case to be matched.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_102\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(x : Int) -> Int {\n  match x {\n    y if y > 0 => y\n    _ => 0\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: JS Backend Format Configuration in moon.pkg.json\nDESCRIPTION: This JSON snippet demonstrates how to configure the `format` option for the JS backend in the `link` section of a `moon.pkg.json` file. It sets the output format of the current package to ES Module (`esm`).\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/package.md#_snippet_10\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"link\": {\n      \"js\": {\n        \"format\": \"esm\"\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Suggestion: Implementing the Show trait for type S in MoonBit\nDESCRIPTION: This code shows how to implement the `Show` trait for the struct `S` in MoonBit, resolving the E4018 error. It demonstrates the use of `impl Show for S with output(self, logger)` to define how an instance of `S` should be represented as a string.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4018.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct S { v : Int }\n\nlet s : S = { v: 3 }\nlet t = Show::to_string(s)\n\nimpl Show for S with output(self, logger) {\n  logger.write_object(self.v)\n}\n```\n\n----------------------------------------\n\nTITLE: Example Output of `init` and `main` Functions\nDESCRIPTION: This snippet shows the expected output of running the previous `init` and `main` function examples.  It shows the values printed to the console.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/introduction.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n1\n2\n```\n\n----------------------------------------\n\nTITLE: Diff Output - Good Quality\nDESCRIPTION: Illustrates a 'good quality' diff output, showing the addition of a new function `RHSet::new` after a struct definition. It emphasizes the importance of placing insertions in logical locations within the code for readability.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff.md#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n struct RHSet[T] {\n    set : RHTable[T, Unit]\n  }\n+\n+ fn RHSet::new[T](capacity : Int) -> RHSet[T] {\n+  let set : RHTable[T, Unit]= RHTable::new(capacity)\n+  { set : set }\n+ }\n```\n\n----------------------------------------\n\nTITLE: Defining Matrix Function in MoonBit\nDESCRIPTION: This code demonstrates defining a matrix function in MoonBit, which leverages pattern matching for different input structures. This enables concise handling of various argument combinations.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_32\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(Some(x), Some(y)) { x + y }\nfn f(Some(x), None) { x }\nfn f(None, Some(y)) { y }\nfn f(None, None) { 0 }\n```\n\n----------------------------------------\n\nTITLE: Creating Bytes Dynamically with @buffer.T in MoonBit\nDESCRIPTION: This code snippet shows the correct way to dynamically create a `Bytes` value in MoonBit using `@buffer.new()`. It initializes a buffer, writes a string literal, writes the integer `x` using `write_object`, writes another string literal, and converts the buffer to `Bytes` using `to_bytes()`. This avoids the E4096 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4096.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let x : Int = 42\n  let buf = @buffer.new()\n  let _ : Bytes = buf\n    ..write_string(\"(\")\n    ..write_object(x)\n    ..write_string(\")\")\n    .to_bytes()\n}\n```\n\n----------------------------------------\n\nTITLE: Unicode-Safe String Palindrome Check in MoonBit\nDESCRIPTION: This snippet provides a unicode-safe way to check if a string is a palindrome using array pattern matching in MoonBit. The string is matched against a pattern that checks if the first and last characters are equal, and recursively calls the function on the remaining string view.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_97\n\nLANGUAGE: moonbit\nCODE:\n```\nfn is_palindrome(s : String) -> Bool {\n  match s.view {\n    [] => true\n    [a,.._,b] => a == b && is_palindrome(s.view.slice(1, s.length - 1).to_string)\n    [a] => true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Solution 3: Annotate Collection Creation\nDESCRIPTION: Addresses the E0013 error by adding type annotations directly to the creation of collections. This explicitly defines the element type and prevents the compiler from defaulting to `Unit`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0013.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let a = ([] : Array[Int])\n  println(a.length())\n  let b = (None : Option[Int])\n  println(b.is_empty())\n}\n\n```\n\n----------------------------------------\n\nTITLE: Moonbit: Corrected Type Declaration\nDESCRIPTION: This snippet shows the corrected way to declare the variable `a` with a complete type annotation, `Option[Int]`. This resolves the E4041 error by providing a specific type for the `Option` type.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4041.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nlet a : Option[Int] = Some(3)\n```\n\n----------------------------------------\n\nTITLE: Example `test` Block in MoonBit\nDESCRIPTION: This is an example of a `test` block, that defines inline tests.  The contents of the file are not shown inline but are included via a literal include using start and end markers.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/introduction.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\n{literalinclude} /sources/language/src/test/top.mbt\n:language: moonbit\n:start-after: start test 1\n:end-before: end test 1\n```\n\n----------------------------------------\n\nTITLE: Correct Main Function Definition (MoonBit)\nDESCRIPTION: Shows the correct way to define a `main` function by only having one `main` function in the package. This ensures that there is only one entry point.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4068.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  println(\"Hello, World!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Module Dependencies Configuration in moon.mod.json\nDESCRIPTION: Defines the 'deps' field in the moon.mod.json file, which lists the module's dependencies. This section is automatically managed by commands like `moon add` and `moon remove`, simplifying dependency management.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/module.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"username/hello\",\n  \"deps\": {\n    \"moonbitlang/x\": \"0.4.6\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Package Configuration (fib/moon.pkg.json)\nDESCRIPTION: Defines an empty configuration file for the `fib` package, indicating that the directory should be treated as a package by the build system.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/tutorial.md#_snippet_15\n\nLANGUAGE: json\nCODE:\n```\n{}\n```\n\n----------------------------------------\n\nTITLE: Corrected Continue Arguments in Loop - MoonBit\nDESCRIPTION: This example demonstrates the corrected MoonBit `loop` where the `continue` statement now provides two arguments, matching the loop's expectation. The arguments are derived from a and b, ensuring correct program execution.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4104.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(x: Int, y: Int) -> Int {\n  loop x, y {\n    0, 0 => 0\n    a, b => continue a - 1, b - 1\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: While Loop Example in MoonBit\nDESCRIPTION: This MoonBit code illustrates a basic `while` loop. It executes a block of code repeatedly as long as a condition is true. The condition is evaluated before each execution of the loop body.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_53\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  var i = 0\n  while i < 10 {\n    debug(i)\n    i = i + 1\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Materializing Error in MoonBit\nDESCRIPTION: This MoonBit code demonstrates how to materialize a potential error into a `Result[T, E]` type using the `?` operator.  The result of `may_raise_error?(42)` will be either a success value or an error value which can then be examined.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4120.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let result = may_raise_error?(42)\n  println(\"Result: \\{result}\")\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Error Type with Error Bound\nDESCRIPTION: This example shows how to define a generic function that can return an error, using the `Error` bound for the error type.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\nfn generic_error[E: Error](e : E) -> Unit!E {\n  raise e\n}\n```\n\n----------------------------------------\n\nTITLE: String Interpolation in MoonBit\nDESCRIPTION: This code snippet demonstrates string interpolation in MoonBit. It enables you to substitute variables within interpolated strings. Variables used for string interpolation must support the `to_string` method.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_9\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main() {\n  let name : String = \"MoonBit\"\n  let greeting : String = \"Hello, {name}!\"\n  println(greeting)\n}\n```\n\n----------------------------------------\n\nTITLE: Run MoonBit Program (with relative path)\nDESCRIPTION: Executes the MoonBit program using the `moon run` command, specifying the path to the main package. Uses a relative path.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/tutorial.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ moon run ./src/main\nHello, world!\n```\n\n----------------------------------------\n\nTITLE: Corrected MoonBit Range Pattern\nDESCRIPTION: This code snippet demonstrates the corrected range pattern, where the starting value is less than the ending value, satisfying the ordering constraint. The `main` function uses a `match` statement with a valid range `-10..<0`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4147.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let value = 1\n  match value {\n    -10..<0 => println(\"0..=10\")\n    _ => println(\"_\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Result Values in MoonBit\nDESCRIPTION: This snippet demonstrates how to use the `map` and `map_err` functions on `Result` types. `map` applies a function to the value within an `Ok` result, while `map_err` applies a function to the error value within an `Err` result.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_22\n\nLANGUAGE: moonbit\nCODE:\n```\nlet res1: Result[Int, String] = Ok(42)\nlet new_result = res1.map(fn(x) { x + 1 }) // Ok(43)\n\nlet res2: Result[Int, String] = Err(\"error\")\nlet new_result = res2.map_err(fn(x) { x + \"!\" }) // Err(\"error!\")\n```\n\n----------------------------------------\n\nTITLE: Deriving Default for Enums in MoonBit\nDESCRIPTION: This code snippet shows how to derive the `Default` trait for an enum in MoonBit. The generated `default` method returns the enum case that has no parameters. Enums with no parameterless cases or with more than one such case cannot derive `Default`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/derive.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\nenum State {\n  Idle\n  Running\n  Finished\n} derive(Default)\n\nfn main() {\n  let state = State::default()\n  println(\"{}\", state) // prints \"Idle\"\n}\n```\n\n----------------------------------------\n\nTITLE: Applicable Function Values in MoonBit\nDESCRIPTION: This code shows that any expression that evaluates to a function value is applicable in MoonBit. This includes lambda expressions defined inline.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_35\n\nLANGUAGE: moonbit\nCODE:\n```\n(fn(x, y) { x * x + y * y })(3, 4)\n```\n\n----------------------------------------\n\nTITLE: Labelled Loop with Continue/Break in MoonBit\nDESCRIPTION: Illustrates the usage of labelled loops in MoonBit, enabling control flow from nested loops using `break` and `continue` statements with labels. This example shows how to exit or continue specific outer loops from within inner loops.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_68\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main() {\n  loop out(x : Int) : Int {\n    loop in(y : Int) : Int {\n      case x + y > 10 => break out x + y\n      case y > 3 => continue in y - 1\n      case _ => continue in y + 1\n    }\n    case _ => break out 0\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling with try/catch\nDESCRIPTION: This snippet demonstrates the use of `try` and `catch` blocks to handle errors in MoonBit. It includes an `else` block for code to execute when no error occurs.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  try {\n    f!()\n  } catch {\n    MyError => println(\"caught MyError\")\n  } else {\n    println(\"no error\")\n  }\n}\n```\n\nLANGUAGE: moonbit\nCODE:\n```\nOutput\n```\n\n----------------------------------------\n\nTITLE: Moonbit Record Pattern with Field Matching\nDESCRIPTION: This code snippet demonstrates how to match specific fields in a `Point` struct using a record pattern and `..` to ignore the remaining fields. It shows how to combine field matching with the ellipsis to specify partial record patterns.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3009.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn process_point(p: Point) -> Unit {\n  match p {\n    { x: 0, .. } => println(\"Point on y-axis\")\n    _ => println(\"Other point\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Syntax Error Correction\nDESCRIPTION: This MoonBit code snippet shows the corrected version of the previous example, with the missing closing parenthesis added to the `println` function call. This adheres to the required syntax.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3002.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  println(\"Hello, world!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Ambiguous Method Call in MoonBit\nDESCRIPTION: This MoonBit code demonstrates how to resolve the E4017 error by explicitly specifying the trait from which the `to_string` method should be called. By using `Tee::to_string(s)`, the code clarifies that the `to_string` method from the `Tee` trait should be used, resolving the ambiguity.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4017.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct S { v : Int } derive(Show)\n\ntrait Tee { to_string(Self) -> String }\n\nimpl Tee for S with to_string(_self) { \"Tee\" }\n\nlet s : S = { v: 3 }\nlet t = Tee::to_string(s)\n```\n\n----------------------------------------\n\nTITLE: Pre-build Configuration using Embed Command\nDESCRIPTION: This JSON snippet demonstrates how to use the `pre-build` configuration in `moon.pkg.json` to embed a text file (`a.txt`) into a MoonBit source file (`a.mbt`) using the `:embed` command.  The command converts the text file into a MoonBit string literal. It requires a `moon.pkg.json` file in the current directory.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/package.md#_snippet_16\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"pre-build\": [\n    {\n      \"input\": \"a.txt\",\n      \"output\": \"a.mbt\",\n      \"command\": \":embed -i $input -o $output\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Inline WASM Function Definition in MoonBit\nDESCRIPTION: This code snippet shows the corrected version of the previous example. The `i32_load` function now includes a closing parenthesis in the inline WASM code, resolving the E3014 syntax error. The function now correctly defines a WASM function that loads an i32 value from memory.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3014.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nextern \"wasm\" fn i32_load(addr : Int) -> Int =\n  #|(func (param i32) (result i32)\n  #| (i32.load (local.get 0)))\n```\n\n----------------------------------------\n\nTITLE: Default Error Type Usage\nDESCRIPTION: This snippet illustrates the usage of the default error type `Error` in MoonBit.  It shows how to annotate a function to indicate it might return the default error type.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn foo1() -> Int! {\n  //...\n}\n\nfn foo2!() -> Int {\n  //...\n}\n\nfn foo3() -> Int!Error {\n  //...\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Abort Function Usage in MoonBit\nDESCRIPTION: This code snippet demonstrates the correct way to abort a MoonBit program using the `abort` function provided by the `moonbitlang/core`. This function is the recommended approach for program termination and avoids using potentially unstable internal intrinsics.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4070.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  abort(\"Abort!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Handling d = 0, k = 0 case in MoonBit\nDESCRIPTION: This code handles the base case where the edit distance `d` is 0 and `k` is 0. It skips over matching lines at the beginning of both input arrays and updates the `v` array with the final `x` coordinate.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff.md#_snippet_9\n\nLANGUAGE: moonbit\nCODE:\n```\nif d == 0 { // When d equals 0, k must also equal 0\n  x = 0\n  y = x - k\n  while x < n && y < m && old[x].text == new[y].text {\n    // Skip all matching lines\n    x = x + 1\n    y = y + 1\n  }\n  v[k] = x\n}\n\n```\n\n----------------------------------------\n\nTITLE: MoonBit: MkApp Instruction Implementation\nDESCRIPTION: This MoonBit code implements the `MkApp` instruction. It pops two addresses from the stack (representing the function and argument), creates a new `NApp` node in the heap pointing to these two addresses, and pushes the address of this new `NApp` node onto the stack. This effectively constructs a function application node.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_18\n\nLANGUAGE: moonbit\nCODE:\n```\n  fn mk_apply(s : GState) -> GState {\n    match s.stack {\n      Nil => { abort(\"Stack underflow\") }\n      Cons(arg_addr, rest) => {\n        match rest {\n          Nil => { abort(\"Stack underflow\") }\n          Cons(fun_addr, new_stack) => {\n            let addr = new_addr(s.heap)\n            let new_heap = { nodes = array_set(s.heap.nodes, addr, { app = (fun_addr, arg_addr) }) }\n            { s with heap = new_heap, stack = cons(addr, new_stack) }\n          }\n        }\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Corrected Moonbit Code: Positional Argument in Nested Function\nDESCRIPTION: This Moonbit code provides one solution to the E4119 error.  It removes the labelled argument `name~` from the nested `greet` function and uses a positional argument `name` instead.  This allows the code to compile without errors because nested functions do not support labelled arguments.  The `greet` function is then called with the argument \"world\".\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4119.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  fn greet(name : String) -> Unit {\n    println(\"Hello, \\{name}\")\n  }\n  greet(\"world\")\n}\n```\n\n----------------------------------------\n\nTITLE: Snapshot Test with `JSON` in MoonBit\nDESCRIPTION: This snippet demonstrates a snapshot test using `@json.inspect!`. This approach serializes the data structure to JSON, which can be more readable than the output of the `Show` trait, especially after formatting. This requires the type to implement `ToJson`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/tests.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Foo { x : Int, y : String }\n\nderive ToJson for Foo\n\nfn test_snapshot_json() {\n  let foo = Foo { x = 1, y = \"hello\" }\n  @json.inspect!(foo, content = \"foo\")\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Unused Variants MoonBit\nDESCRIPTION: This example demonstrates removing the unused variant `C` from the enum `T`. This resolves the E0006 error by eliminating the unused variant if it is indeed unnecessary.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0006.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\nenum T {\n  A\n  B\n}\n```\n\n----------------------------------------\n\nTITLE: Module Source Directory Configuration in moon.mod.json\nDESCRIPTION: Defines the 'source' field in the moon.mod.json file, which specifies the source code directory for the module. If not provided or set to null/empty string, it defaults to the directory containing the moon.mod.json file.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/module.md#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"source\": \"src\"\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected MoonBit For-Loop: Initialization Block\nDESCRIPTION: This example demonstrates how to fix the E4106 error by declaring the variable `j` in the initialization block of the for-loop. The function `f` now initializes both `i` and `j` within the `for` statement, resolving the error. It iterates and prints the values of `i` and `j`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4106.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(x: Int) -> Unit {\n   for i = 0, j = 0; i < x; i = i + 1, j = j + 1 {\n    println(i)\n    println(j)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Range Modifications in MoonBit\nDESCRIPTION: This code implements the range modification function. It's similar to a query function but applies the necessary LazyTag for the modification to each relevant node. The function returns a newly created segment tree without modifying the original one, demonstrating the persistent or immutable nature of the implementation.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/segment-tree/segment-tree2.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\nfn modify[Data: Op_add[Data, Tag] + Op_add_tag[Data, Tag], Tag: Op_add_tag[Data, Tag]](node: Node[Data, Tag], l: Int, r: Int, ql: Int, qr: Int, tag: Tag) -> Node[Data, Tag] {\n  if ql <= l && qr >= r {\n    return apply(node, tag)\n  }\n  if qr < l || ql > r {\n    return node\n  }\n\n  match node {\n    Leaf(_) => node\n    Node { left, right, data, tag: old_tag, len } => {\n      // Propagate tag to children\n      let left = apply(left, old_tag)\n      let right = apply(right, old_tag)\n\n      let mid = l + (r - l) / 2\n      let left = modify(left, l, mid, ql, qr, tag)\n      let right = modify(right, mid + 1, r, ql, qr, tag)\n\n      Node { left, right, data: op_add(left, right), tag: Nil, len }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Making the Implementation Private in MoonBit\nDESCRIPTION: This code snippet presents an alternative solution where the visibility of the implementation is adjusted to be private.  Since both the trait `I` and the implementation are now private, there is no visibility conflict and the code compiles successfully. The `pub` keyword is removed from `pub impl` making it just `impl`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4046.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\npriv trait I { m(Self) -> Unit }\nimpl I for Int with m(self) {}\n```\n\n----------------------------------------\n\nTITLE: Correct Pattern Matching in MoonBit\nDESCRIPTION: This MoonBit code snippet provides a correct example of pattern matching. The variable `a` is now bound in both the `A` and `B` patterns, resolving the error. It shows the correct way to ensure all pattern variables are bound when using the `|` operator in a `match` statement in MoonBit.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4082.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(value : E) -> Unit {\n  match value {\n    A(a, _) | B(a) => println(\"Hello\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Read-Only Struct Example\nDESCRIPTION: Illustrates the use of `pub` for read-only structs in MoonBit, showing how they can be accessed within the defining package and the restrictions on construction and mutation from other packages.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/packages.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\n// Package A\npub struct RO {\n  field: Int\n}\ntest {\n  let r = { field: 4 }       // OK\n  let r = { ..r, field: 8 }  // OK\n}\n\n// Package B\nfn println(r : RO) -> Unit {\n  println(\"{ field: \")\n  println(r.field)  // OK\n  println(\" }\")\n}\ntest {\n  let r : RO = { field: 4 }  // ERROR: Cannot create values of the public read-only type RO!\n  let r = { ..r, field: 8 }  // ERROR: Cannot mutate a public read-only field!\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Foreign Type in MoonBit\nDESCRIPTION: This snippet shows how to declare a foreign type in MoonBit using the `extern type` syntax.  The interpretation of the type varies depending on the backend (Wasm, JavaScript, or C).\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/ffi.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nextern type ExternalRef\n```\n\n----------------------------------------\n\nTITLE: Exporting Functions in MoonBit\nDESCRIPTION: This JSON snippet demonstrates how to export functions in MoonBit using the `exports` field in the link configuration.  It shows how to export functions with the same name or with a different name using the `name:alias` syntax.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/ffi.md#_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"link\": {\n    \"<backend>\": {\n      \"exports\": [ \"add\", \"fib:test\" ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Solution 2: Unwrap Optional Value Before Passing (MoonBit)\nDESCRIPTION: This snippet demonstrates unwrapping the optional value using a `match` statement before passing it to the function `f`. If the optional value is `Some(value)`, the value is extracted; otherwise, a default value is used. The unwrapped value is then passed to the function.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4141.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let opt = Some(42)\n  let opt = match opt {\n    Some(opt) => opt\n    None => 4\n  }\n  f(opt~)\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit: Implement Eq for ExamResult\nDESCRIPTION: This code provides an explicit implementation of the `Eq` trait for the `ExamResult` enum in MoonBit. It defines the `op_equal` function using pattern matching to compare two `ExamResult` values, returning `true` if both are `Pass` or both are `Fail`, and `false` otherwise.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/tutorial/tour.md#_snippet_10\n\nLANGUAGE: moonbit\nCODE:\n```\nimpl Eq for ExamResult with op_equal(self, other) {\n  match (self, other) {\n    (Pass, Pass) | (Fail, Fail) => true\n    _ => false\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Suggestion: Explicitly Ignoring with `ignore()`\nDESCRIPTION: This code shows the suggested solution to error E4139 by using the `ignore(...)` function to explicitly discard the result of `1 + 1`. This makes it clear that the result is intentionally being ignored.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4139.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  ignore(1 + 1)\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Record Matching with Ignore in MoonBit\nDESCRIPTION: This snippet provides a solution to the E4044 error by using the `..` syntax to ignore unmatched record fields in the pattern. It demonstrates how to correctly match records when some fields are not explicitly specified in the pattern.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4044.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct S { a : Int; b: Int }\nlet a : Int = match S::{ a: 2, b: 3 } {\n  { a: 2, b: 3 } => 4\n  { a: 2, .. } => 5\n  _ => 6\n}\n```\n\n----------------------------------------\n\nTITLE: Convert to Result with Pattern Matching\nDESCRIPTION: This snippet demonstrates how to use pattern matching to extract values from a `Result` type obtained by calling a function with `?`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_19\n\nLANGUAGE: moonbit\nCODE:\n```\nlet res = div?(10, 0)\nmatch res {\n  Ok(x) => println(x)\n  Err(DivisionByZeroError(e)) => println(e)\n}\n```\n\n----------------------------------------\n\nTITLE: Mutable Record Field Example in MoonBit\nDESCRIPTION: This code snippet shows how to declare a mutable record field in MoonBit using the `mut` keyword. It demonstrates a struct `S` with a mutable field `value`.  The `value` field is of type `Int`. This allows the field to be modified after the struct is initialized.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4088.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct S {\n  mut value : Int\n}\n\nfn main {\n  let s = { value: 42 }\n  s.value = 43\n  println(s.value)\n}\n```\n\n----------------------------------------\n\nTITLE: Fibonacci Stand-alone Tests (fib_test.mbt)\nDESCRIPTION: Defines a stand-alone test file for blackbox tests, which are automatically created as a package for test purposes. These tests verify the `fib` and `fib2` functions using the automatically created `@fib` alias.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/tutorial.md#_snippet_19\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  assert_eq!(@fib.fib(1), 1)\n  assert_eq!(@fib.fib2(2), 1)\n  assert_eq!(@fib.fib(3), 2)\n  assert_eq!(@fib.fib2(4), 3)\n  assert_eq!(@fib.fib(5), 5)\n}\n```\n\n----------------------------------------\n\nTITLE: Valid Assignment: Mutable Variable on Left-Hand Side (Moonbit)\nDESCRIPTION: This code snippet demonstrates the correct way to assign a new value to a variable in Moonbit using a mutable variable. It initializes a mutable variable `n` with the value 4 and then reassigns it the value 5 within the `main` function. The `mut` keyword indicates that the variable's value can be changed after its initial assignment.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3011.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let mut n = 4\n  n = 5\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Sudoku Grid in MoonBit\nDESCRIPTION: This function parses a Sudoku grid represented as a string into a `SquareMap` where each square is associated with a list of possible characters (digits). The digits variable holds the string representation of the grid's columns. The function initializes each square with all possible digits '1' to '9'.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/sudoku/index.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn parseGrid(s : String) -> SquareMap[List[Char]] {\n  let digits = cols.to_list()\n  let values : SquareMap[List[Char]] = SquareMap::new(digits)\n  ......\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Diff Implementation in MoonBit\nDESCRIPTION: This snippet provides the complete diff implementation by combining the shortest edit distance calculation and backtracking to generate the edit sequence. It calculates and returns the complete difference between two sequences.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff2.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\nfn diff[T: Eq](xs: List[T], ys: List[T]) -> List[Edit[T]] {\n  let edits = backtrack_fst(xs, ys)\n  let edits = backtrack_snd::remove_dup(edits)\n  backtrack_snd::reverse(edits)\n}\n```\n\n----------------------------------------\n\nTITLE: Main Function calling Square in coreF (Clojure-like)\nDESCRIPTION: Defines the `main` function in coreF, calling the `square` function with the result of another `square` call. This function demonstrates how the `square` function can be used in a more complex expression.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_7\n\nLANGUAGE: clojure\nCODE:\n```\n(defn main[] (square (square 3)))\n```\n\n----------------------------------------\n\nTITLE: Correct Loop Label Declaration in MoonBit\nDESCRIPTION: Demonstrates the correct way to declare and use a loop label in MoonBit. The label `read~` is declared at the beginning of the loop, allowing the `continue read~` statement to correctly jump to the beginning of the loop.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4148.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  read~: loop read() {\n    [] => break\n    _ => continue read~ read()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Wildcard Pattern - MoonBit\nDESCRIPTION: This MoonBit code snippet demonstrates how to add a wildcard pattern (`_`) to catch all remaining cases in a `match` expression. This ensures that all possible values are handled, avoiding the partial match warning.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0011.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  match Some(1) {\n    Some(x) => println(x)\n    _ => println(\"Other\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Enum with Payload Data - Usage in MoonBit\nDESCRIPTION: Demonstrates the creation and use of an enum with payload data within a `main` function.  It shows how to construct an `IntList` and then calculate the sum.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_81\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let list = Cons(1, Cons(2, Cons(3, Nil)))\n  let total = sum(list)\n  debug(total)\n}\n```\n\n----------------------------------------\n\nTITLE: Trait Method Duplicate Implementation - MoonBit\nDESCRIPTION: Demonstrates the E4072 error in MoonBit, where a trait method `to_int` already has a default implementation, and a second `impl` block attempts to provide another default implementation. This causes a compilation error. The code shows the erroneous example and the corrected version by removing the duplicate implementation.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4072.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait T {\n  to_int(Self) -> Int\n}\n\ntype A Int\n\nimpl T with to_int(self : Self) -> Int {\n  0\n}\n\nimpl T with to_int(self : Self) -> Int { // Error: Method to_int of trait T already has a default implementation at\n  0\n}\n```\n\n----------------------------------------\n\nTITLE: Fibonacci Inline Tests (a.mbt)\nDESCRIPTION: Defines inline tests for the `fib` function, verifying the first five Fibonacci numbers.  Inline tests are discarded in non-test compilation modes.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/tutorial.md#_snippet_18\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  assert_eq!(fib(1), 1)\n  assert_eq!(fib(2), 1)\n  assert_eq!(fib(3), 2)\n  assert_eq!(fib(4), 3)\n  assert_eq!(fib(5), 5)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Newtype in MoonBit\nDESCRIPTION: This snippet illustrates how to define a newtype in MoonBit. Newtypes are enums with a single constructor having the same name as the newtype. They provide a way to create a distinct type without runtime overhead.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_88\n\nLANGUAGE: moonbit\nCODE:\n```\nnewtype T = T(Int)\n```\n\n----------------------------------------\n\nTITLE: MoonBit: Define assert_eq! function\nDESCRIPTION: This code defines a generic `assert_eq!` function in MoonBit that takes two values of the same type, constrained by the `Eq` and `Show` traits. It compares the values for equality and, if they are not equal, it prints an error message, using `Show` to display the values.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/tutorial/tour.md#_snippet_9\n\nLANGUAGE: moonbit\nCODE:\n```\nfn assert_eq![A : Eq + Show](value : A, other : A) -> Unit {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving Show for Enums in MoonBit\nDESCRIPTION: This snippet shows how to automatically derive the `Show` trait for an enum in MoonBit. The generated `Show` implementation provides a way to represent the enum variants as strings, showing the variant name and any associated data.  All data types used within enum variants must implement `Show`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/derive.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nenum Option[T] {\n  Some(T)\n  None\n} derive(Show)\n\nfn main() {\n  let some_int: Option[Int] = Some(10)\n  println(\"{}\", some_int) // prints \"Some(10)\"\n\n  let none_int: Option[Int] = None\n  println(\"{}\", none_int) // prints \"None\"\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Hello World Function (hello.mbt)\nDESCRIPTION: Defines a public function `hello` that returns the string \"Hello, world!\".  This function is part of the `lib` package.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/tutorial.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn hello() -> String {\n    \"Hello, world!\"\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect use of 'priv' visibility in MoonBit\nDESCRIPTION: This code snippet demonstrates the erroneous usage of the `priv` visibility modifier on a variable in MoonBit.  Since entities are private by default, explicitly declaring `priv` results in an error. The snippet showcases the incorrect syntax and the resulting error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3005.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npriv let value = 3 // Error: No 'priv' visibility for value.\n```\n\n----------------------------------------\n\nTITLE: Fixing Deprecation Alert by Using the Suggested Function in MoonBit\nDESCRIPTION: Shows how to resolve the deprecation alert by using the suggested `greet()` function with a name parameter. This removes the alert during compilation. The code snippet provides a replacement for the erroneous example to address the 'deprecated' alert.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E2000.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\n// ... code in the example above ...\nfn main {\n  println(greet(name=\"world\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Direct Trait Method Invocation in MoonBit\nDESCRIPTION: This snippet demonstrates calling trait methods directly via `Trait::method`. MoonBit will infer the type of `Self` and check if `Self` indeed implements `Trait`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_17\n\nLANGUAGE: moonbit\nCODE:\n```\n// start trait 7\ntrait Foo {\n  fn bar(self : Self) -> Int\n}\n\nimpl Foo for Int with bar(self) {\n  self + 1\n}\n\nfn main {\n  Foo::bar(1)\n}\n```\n\n----------------------------------------\n\nTITLE: Splitting String into Array[Line] in MoonBit\nDESCRIPTION: This snippet presents a function that splits a given string into an `Array[Line]` based on newline characters. It also assigns line numbers starting from 1, encapsulating both text and its corresponding number in the `Line` struct.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\nfn lines(content : String) -> Array[Line] {\n  let split = String::split(content, \"\\n\")\n  Array::make_from(0, split.length(), (i : Int) => Line{num: i + 1, text: split[i]})\n}\n\n```\n\n----------------------------------------\n\nTITLE: As-is calling with error re-raising\nDESCRIPTION: This snippet shows how to call an error-able function and re-raise the error without handling it directly.  It requires matching error types.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_16\n\nLANGUAGE: moonbit\nCODE:\n```\n// We have to match the error type of `div2` with `div`\nfn div2(x : Int, y : Int) -> Int!DivisionByZeroError {\n  div!(x,y)\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Against a Constant in MoonBit\nDESCRIPTION: Illustrates how to correctly match against a constant in MoonBit by removing the payload from the pattern.  The `match` arm is adjusted to directly match the `Value` constant without attempting to apply arguments.  This approach is suitable when the intention is simply to check if the value being matched is equal to the constant.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4144.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  match { ... } {\n    Value => println(\"Value\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling Letrec Expressions in MoonBit\nDESCRIPTION: This MoonBit code compiles 'letrec' expressions.  It allocates N addresses using `Alloc(n)`, builds a complete environment using a `loop` expression, compiles the local variables in `defs` using the `Update` instruction to update the pre-allocated addresses, compiles the main expression, and uses `Slide` to clean up.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-2.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\nfn compile_letrec(defs : List[(String, Core)], body : Core, comp : Fn(Core, Env) -> List[Instruction], env : Env) -> List[Instruction] {\n  let n = list::length(defs)\n  let alloc_instr = list::singleton(Instruction::Alloc(n))\n\n  let new_env = list::fold_left(defs, env, (env, def) => {\n    let name = def._1\n    let new_env = map::insert(env, name, EnvValue::Addr(map::size(env)))\n    new_env\n  })\n  let def_compiles = list::map(defs, (def) => compileC(def._2, new_env))\n  let update_instrs = list::make_with_index(n, (i) => Instruction::Update(n - 1 - i))\n\n  let body_compile = comp(body, new_env)\n  let slide_instr = list::singleton(Instruction::Slide(n))\n\n  list::append(list::append(list::append(list::append(alloc_instr, list::interleave(def_compiles, update_instrs)), body_compile), slide_instr)\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Package manifest JSON importing the trait\nDESCRIPTION: This is a `moon.pkg.json` file for package `b`, which imports package `a` (module `username/hello/a`) containing the trait definition. This import is necessary to attempt implementing the trait defined in package `a`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4073.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"import\": [\n    \"username/hello/a\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Borrow Attribute Syntax in MoonBit\nDESCRIPTION: This snippet demonstrates the syntax for using the `#borrow` attribute in MoonBit to modify the calling convention of an FFI function. The `params` argument specifies which parameters should be passed using a borrow-based calling convention, eliminating the need for `decref` within the foreign function.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/ffi.md#_snippet_16\n\nLANGUAGE: moonbit\nCODE:\n```\n#borrow(params..)\nextern \"C\" fn c_ffi(..) -> .. = ..\n```\n\n----------------------------------------\n\nTITLE: Solution 4: Provide Context Through Usage\nDESCRIPTION: Shows how to resolve the E0013 error by providing sufficient context through usage, allowing the compiler to infer the types of variables. In this example, an arithmetic operation forces the compiler to infer an `Int` type.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0013.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f1() -> Unit {\n  fn f(x) {\n    match x {\n      None => ()\n      Some(a) => println(a + 1)\n//                       ^^^^^ through this usage, the compiler can infer the\n//                             type of `x` is `Option[Int]`.\n    }\n  }\n  f(None)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Edit Type Definition in MoonBit\nDESCRIPTION: This code snippet defines the `Edit` type in MoonBit, which represents the possible edit operations: `Insert`, `Delete`, and `Keep`. These operations form the basis for constructing the edit sequence.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff2.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nenum Edit[T] {\n  Insert(T)\n  Delete(T)\n  Keep(T)\n}\n```\n\n----------------------------------------\n\nTITLE: Variable Binding and Constant Declaration in MoonBit\nDESCRIPTION: This snippet illustrates variable binding with `let` (immutable) and `let mut` (mutable), along with constant declaration using `const` in MoonBit. It demonstrates reassigning a mutable variable and the usage of variables and constants in an expression within the `main` function.  Top level variables require explicit type annotations.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/introduction.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nlet zero = 0\n\nconst ZERO = 0\n\nfn main {\n  //! const ZERO = 0 \n  let mut i = 10\n  i = 20\n  println(i + zero + ZERO)\n}\n```\n\n----------------------------------------\n\nTITLE: `for .. in` Loop with Two Loop Variables in MoonBit\nDESCRIPTION: This code demonstrates the usage of `for .. in` with two loop variables, facilitating iteration over sequences of pairs, such as those provided by a `Map` through the `Iter2` trait.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_64\n\nLANGUAGE: moonbit\nCODE:\n```\nfor key, value in map {\n  // process key and value\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Newtype Internal Representation with `._` in MoonBit\nDESCRIPTION: This snippet illustrates how to extract the internal representation of a newtype using the `._` syntax. The `main` function demonstrates creating a newtype instance and then extracting the underlying `Int` value using `x._`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_90\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let x = T(10)\n  debug(x._)\n}\n```\n\n----------------------------------------\n\nTITLE: Eliminating Value from a Square in MoonBit\nDESCRIPTION: This function eliminates a possible value from a square and applies heuristic strategies to propagate the constraints. It takes a `SquareMap`, a square `key`, and a value `val` to eliminate. It checks if `val` exists in the square's possible values before attempting elimination. The function returns `true` if the elimination is successful and `false` if a contradiction occurs (i.e., the square has no possible values left).\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/sudoku/index.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn eliminate(values : SquareMap[List[Char]], key : String, val : Char) -> Bool {\n  if not(exist(values[key], fn (v) { v == val })) {\n    return true\n  }\n  values[key] = values[key].remove(val)\n  // If `key` has only one possible value left, remove this value from its peers\n  match single(values[key]) {\n    Err(b) => {\n      if not(b) {\n        return false\n      }\n    }\n    Ok(val) => {\n      let mut result = true\n      peers[key].iter(fn (key) {\n        result = result && eliminate(values, key, val)\n      })\n      if not(result) {\n        return false\n      }\n    }\n  }\n  //  If there is only one square in the unit of `key` that can hold `val`, assign `val` to that square\n  let unit = units[key]\n  let places = unit.filter(fn (sq) {\n    exist(values[sq], fn (v) { v == val })\n  })\n  match single(places) {\n    Err(b) => {\n      return b\n    }\n    Ok(key) => {\n      return assign(values, key, val)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Operator Overloading with Traits in MoonBit\nDESCRIPTION: This snippet demonstrates operator overloading using the `Add` trait for the `+` operator. It shows how to implement the trait for a user-defined type to enable the operator.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\n// start operator 1\ntrait Add[Self, Other, Output] {\n  fn add(self : Self, other : Other) -> Output\n}\n\nfn main {\n  // let x = 1 + 2\n}\n```\n\n----------------------------------------\n\nTITLE: Define struct with capitalized type name in MoonBit\nDESCRIPTION: Presents the corrected code snippet. The `Point` struct is defined with a capitalized name, adhering to the recommended MoonBit naming convention for types.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0014.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Point {\n  x: Int\n  y: Int\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Record Pattern in MoonBit\nDESCRIPTION: Demonstrates how to correctly use a record pattern in a MoonBit match statement to avoid the E3012 error.  It uses a record pattern to extract the value of the field 'value' from the struct 'S'.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3012.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let s : S = { value: 42 }\n  match s {\n    { value } => println(\"Value is: \\{value}\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Result to Option in MoonBit\nDESCRIPTION: This snippet shows how to convert a `Result` to an `Option` using the `to_option` function. An `Ok` result is converted to `Some`, while an `Err` result is converted to `None`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_23\n\nLANGUAGE: moonbit\nCODE:\n```\nlet res1: Result[Int, String] = Ok(42)\nlet option = res1.to_option() // Some(42)\n\nlet res2: Result[Int, String] = Err(\"error\")\nlet option1 = res2.to_option() // None\n```\n\n----------------------------------------\n\nTITLE: Defining Local Types in MoonBit\nDESCRIPTION: This snippet demonstrates defining a local type (struct in this example) inside a toplevel function in MoonBit. Local types are only visible within the function they are declared in and can use generic parameters of the function.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_92\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f[T] (x : T) {\n    struct S[U] {\n        f : U\n    }\n    let s : S[T] = {f : x}\n    debug(s)\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with `as` and `|` in MoonBit\nDESCRIPTION: This snippet demonstrates the use of `as` and `|` in MoonBit pattern matching. `as` assigns a name to the matched value, and `|` matches several cases at once. The same set of variables should be bound on both sides of `|` patterns.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_95\n\nLANGUAGE: moonbit\nCODE:\n```\nenum Option[T] { Some(T), None }\n\nfn f(x : Option[Int]) -> Int {\n  match x {\n    Some(y as z) | None => { 0 }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Enum with Labelled Arguments - Access in Pattern Matching in MoonBit\nDESCRIPTION: Demonstrates how to access labelled arguments of enum constructors directly in pattern matching. The `msg.x` syntax allows direct access within the case.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_85\n\nLANGUAGE: moonbit\nCODE:\n```\nfn print_message(msg : Message) {\n  case msg {\n    Quit => debug(\"Quit\")\n    msg @ Move { x, y } => debug(\"Move to x=\\(x), y=\\(y)\")\n    Write { text } => debug(\"Write \\(text)\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Enum with Labelled Arguments in MoonBit\nDESCRIPTION: Shows an example of defining an enum where constructors have labelled arguments. This allows specifying arguments by name when creating enum instances.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_82\n\nLANGUAGE: moonbit\nCODE:\n```\nenum Message {\n  Quit\n  Move { x : Int, y : Int }\n  Write { text : String }\n}\n```\n\n----------------------------------------\n\nTITLE: Searching for Sudoku Solution in MoonBit\nDESCRIPTION: This function searches for a solution to the Sudoku puzzle using a recursive backtracking algorithm. It takes a `SquareMap` representing the current state of the grid.  If there are no squares with more than one possible value, it means a solution has been found and returns `Some(values)`. Otherwise, it finds the square with the fewest possible values and tries each value recursively using `assign`. If a value leads to a contradiction, it backtracks and tries the next value.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/sudoku/index.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nfn search(values : SquareMap[List[Char]]) -> Option[SquareMap[List[Char]]] {\n  if values.contains(fn (digits){ not(isSingleton(digits)) }) {\n    // // Find the square with the smallest number of possible values greater than 1, and start the search from this square\n    // This is just a heuristic strategy; you can try finding a smarter and more effective one\n    let mut minsq = \"\"\n    let mut n = 10\n    squares.iter(fn (sq) {\n      let len = values[sq].length()\n      if len > 1 {\n        if len < n {\n          n = len\n          minsq = sq\n        }\n      }\n    })\n    // Iterate through assignments and stop if a successful search is found\n    loop values[minsq] {\n      Nil => None\n      Cons(digit, rest) => {\n        let another = values.copy()\n        if assign(another, minsq, digit){\n          match search(another) {\n            None => continue rest\n            Some(_) as result => result\n          }\n        } else {\n          continue rest\n        }\n      }\n    }\n  } else {\n    return Some(values)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Snake and Box Types in Moonbit\nDESCRIPTION: This snippet defines the `Snake` and `Box` types in Moonbit. The `Snake` represents the middle snake in the edit graph, and the `Box` represents a sub-edit graph (square in shape) used in the divide-and-conquer approach. These types are fundamental for representing the search space and intermediate results in the linear Myers algorithm.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff3.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Snake {\n  x: Int,\n  y: Int,\n  px: Int,\n  py: Int\n}\n\nstruct Box {\n  x0: Int,\n  y0: Int,\n  x1: Int,\n  y1: Int\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining BPArray (Bounded Parameter Array) in MoonBit\nDESCRIPTION: This code defines a `BPArray` struct in MoonBit, which wraps an array and allows negative indexing.  This is useful because the algorithm uses 'k' as an index, which can be negative. The `make` function creates a new `BPArray` with a specified size and initial value.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct BPArray {\n  arr : Array[Int]\n  offset : Int\n}\n\nfn make(size : Int, initial : Int) -> BPArray {\n  let arr = Array::make(size, initial)\n  BPArray{arr: arr, offset: size / 2}\n}\n\nfn get(self : BPArray, index : Int) -> Int {\n  self.arr[index + self.offset]\n}\n\nfn set(mut self : BPArray, index : Int, value : Int) {\n  self.arr[index + self.offset] = value\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using Match Expression in Moonbit\nDESCRIPTION: Shows how to use a `match` expression to achieve conditional logic that the erroneous `guard let` attempted. The code checks if `input` matches `Some(_..<0)` and aborts if it does, otherwise it does nothing (`_ => ()`).  `input` is expected to be an optional Int (`Int?`).\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0038.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(input : Int?) -> Int {\n  match input {\n    Some(_..<0) => abort(\"Invalid input\")\n    _ => ()\n  }\n  3\n}\n```\n\n----------------------------------------\n\nTITLE: Implicitly Implementing the Coordinated Trait in MoonBit\nDESCRIPTION: This code defines a struct `Point` with `x` and `y` fields of type `Int`. It then defines functions `x` and `y` that take a `Point` as input and return the corresponding field, implicitly implementing the `Coordinated` trait.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4062.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Point {\n  x : Int\n  y : Int\n}\n\nfn x(self : Point) -> Int {\n  self.x\n}\n\nfn y(self : Point) -> Int {\n  self.y\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Async Functions in MoonBit\nDESCRIPTION: This code snippet demonstrates how to declare an async function in MoonBit using the `async` keyword.  The defined function must be called using the `!` operator.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/async-experimental.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nasync def hello(name: String) -> String:\n  \"Hello, \" + name\n```\n\n----------------------------------------\n\nTITLE: Suggestion: Using ignore() on a Toplevel Function\nDESCRIPTION: This snippet demonstrates the use of `ignore()` to suppress the E0001 warning for the `greeting` function.  The `ignore()` function marks the function as intentionally used, even if it's not directly called.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0001.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn greeting() -> String {\n  \"Hello, world!\"\n}\n\nfn init {\n  ignore(greeting)\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit: G-Machine State Definition\nDESCRIPTION: This MoonBit code defines the `GState` type, representing the state of the G-Machine. It includes the heap (`heap`), stack (`stack`), global table (`globals`), current code sequence (`code`), and instruction count (`instruction_count`). This represents the complete execution context of the G-Machine.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_13\n\nLANGUAGE: moonbit\nCODE:\n```\n  struct GState {\n    heap : NHeap,\n    stack : List[Addr],\n    globals : GlobalTable,\n    code : List[Instr],\n    instruction_count : Int,\n  }\n```\n\n----------------------------------------\n\nTITLE: Corrected Moonbit Function Definition (Type Match)\nDESCRIPTION: Shows a corrected Moonbit function `f` where the return type matches the argument count of the returned function, resolving the E4013 error. The return type now expects one Int argument.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4013.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f() -> ((Int) -> Int) {\n  fn (x: Int) { x }\n}\n```\n\n----------------------------------------\n\nTITLE: Bash Completion Installation\nDESCRIPTION: Installs bash completion for the Moon CLI. It first creates the necessary directory if it doesn't exist, then appends the shell completion script to the bash completion file.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/commands.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ mkdir -p ~/.local/share/bash-completion/completions\n$ moon shell-completion --shell bash >> ~/.local/share/bash-completion/completions/moon\n```\n\n----------------------------------------\n\nTITLE: Making the Trait Public in MoonBit\nDESCRIPTION: This code snippet shows the solution where the visibility of the trait `I` is adjusted to be public. This allows the public implementation to successfully implement the trait without triggering the E4046 error.  The trait `I` is changed from `priv trait I` to `trait I`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4046.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait I { m(Self) -> Unit }\npub impl I for Int with m(self) {}\n```\n\n----------------------------------------\n\nTITLE: Defining a Main Package (JSON)\nDESCRIPTION: Defines a MoonBit package as a main package, indicating that it should be compiled into an executable.  The `is-main` field must be set to `true`. This configuration is necessary for the package to be considered an entry point for the program.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4068.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"is-main\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Evaluation (Reduction) Function for TermDBI in MoonBit\nDESCRIPTION: This code snippet implements the `eval` function for reducing `TermDBI` expressions in MoonBit. It performs beta reduction by evaluating the left-hand side of an `AppDBI` term. If the result is an `AbsDBI`, it substitutes the argument into the abstraction's body using the `subst` function and recursively evaluates the result. Lambdas are returned as is.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/lambda/index.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\nfn eval(self : TermDBI) -> TermDBI {\n  match self {\n    AppDBI(t1, t2) => {\n      let t1_reduced = eval(t1)\n      let t2_reduced = eval(t2)\n      match t1_reduced {\n        AbsDBI(varname, body) => {\n          eval(subst(body, 0, t2_reduced))\n        }\n        _ => AppDBI(t1_reduced, t2_reduced)\n      }\n    }\n    AbsDBI(varname, body) => AbsDBI(varname, body)\n    VarDBI(i, s) => VarDBI(i, s)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Match Expression Example in MoonBit\nDESCRIPTION: This example demonstrates the use of a `match` expression in MoonBit. It uses pattern matching to determine which consequent to evaluate and can extract variables at the same time.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_49\n\nLANGUAGE: moonbit\nCODE:\n```\nmatch opt {\n  Some(x) => { x + 1 }\n  None => { 0 }\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Definition Cycle with Ref (MoonBit)\nDESCRIPTION: Illustrates how to resolve the E4050 error using `Ref[_?]` to break the definition cycle. The variable `a` is initialized as a `Ref[Int?]` and then updated with the result of `f()` in the `init` block.  Dependencies: `Ref`. Inputs: None. Output: A valid MoonBit program without definition cycle errors.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4050.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub let a : Ref[Int?] = Ref::new(None)\n\nfn init {\n  a.val = Some(f())\n}\n\nfn f() -> Int {\n  a.val.unwrap()\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected MoonBit Code: Removing Incorrect Attributes\nDESCRIPTION: This MoonBit code shows the corrected version of the previous example. The `!`, `?`, and `!!` attributes have been removed from the calls to `IntErr` and `square`, resolving the E4121 errors. The code now compiles and runs without issues.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4121.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  IntErr(1) |> ignore()\n  IntErr(2) |> ignore()\n  IntErr(3) |> ignore()\n  square(1) |> ignore()\n  square(2) |> ignore()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ByteSize Trait and Implementations in Moonbit\nDESCRIPTION: This snippet defines the `ByteSize` trait with a `byte_size()` method that returns an `Int`. It provides implementations of the `ByteSize` trait for `Byte` and `Int`, specifying the byte size for each type. The `ByteSize` trait and its implementations are used to demonstrate the trait constraint issue.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4135.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait ByteSize { byte_size() -> Int}\nimpl ByteSize for Byte with byte_size() { 1 }\nimpl ByteSize for Int with byte_size() { 4 }\n```\n\n----------------------------------------\n\nTITLE: Shadowing Variables in MoonBit Using a Block\nDESCRIPTION: This code shows how to shadow a variable in MoonBit using a block. The inner 'a' is only visible within the block, so there is no E4051 error. This allows re-using the same variable name without conflict.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4051.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\npub let a = {\n  let a = 0\n  1\n}\n```\n\n----------------------------------------\n\nTITLE: C Callback Function Signature\nDESCRIPTION: This C code declares a function `register_callback` that accepts a function pointer `callback` and a pointer to user data `data`. This is a typical pattern in C libraries that allows passing extra context to the callback function.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/ffi.md#_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nvoid register_callback(void (*callback)(void*), void *data);\n```\n\n----------------------------------------\n\nTITLE: Moonbit Doc Comment Example\nDESCRIPTION: This code snippet illustrates the structure of a doc comment in Moonbit, prefixed with `///` for each line and containing markdown text. It shows the basic syntax for documenting top-level structures like functions, enums, structs or types.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/docs.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\n/// doc string 1\n/// doc string 2\npub fn f() -> Unit {\n  {}\n}\n```\n\n----------------------------------------\n\nTITLE: Wasm Backend Exports Configuration\nDESCRIPTION: This JSON snippet demonstrates how to configure the `exports` option for the Wasm backend in the `link` section of a `moon.pkg.json` file. It exports the `hello` function as `hello` and the `foo` function as `bar` in the Wasm module.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/package.md#_snippet_3\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"link\": {\n      \"wasm\": {\n        \"exports\": [\n          \"hello\",\n          \"foo:bar\"\n        ]\n      },\n      \"wasm-gc\": {\n        \"exports\": [\n          \"hello\",\n          \"foo:bar\"\n        ]\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: JS Backend Exports Configuration in moon.pkg.json\nDESCRIPTION: This JSON snippet demonstrates how to configure the `exports` option for the JS backend in the `link` section of a `moon.pkg.json` file. It exports the `hello` function from the current package as `hello` in the JavaScript module.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/package.md#_snippet_9\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"link\": {\n      \"js\": {\n        \"exports\": [\n          \"hello\"\n        ]\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Re-raising Error in MoonBit\nDESCRIPTION: This MoonBit code shows how to handle a potentially raising function by re-raising the error with the `!` operator inside a `try...catch` block. If `may_raise_error` fails, the error is caught and printed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4120.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  try {\n    may_raise_error!(42)\n  } catch {\n    error => println(\"Error: \\{error}\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Building Segment Tree in MoonBit\nDESCRIPTION: This snippet demonstrates how to build a segment tree from a linear sequence using MoonBit's `ArrayView`. It recursively divides the segment at the midpoint, builds left and right subtrees, and merges them using the `op_add` function.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/segment-tree/segment-tree.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn build(arr : ArrayView[Int]) -> Node {\n  let len = array::length(arr)\n  if len == 1 {\n    Node(arr[0], Nil, Nil)\n  } else {\n    let mid = len / 2\n    let left = build(array::slice(arr, 0, mid))\n    let right = build(array::slice(arr, mid, len))\n    op_add(left, right)\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: C Binding to `open` with Reference Counting\nDESCRIPTION: This example shows a lifetime-correct binding to the standard `open` function in C, demonstrating how to handle reference counting for MoonBit objects passed to foreign functions. The `moonbit_decref` function is called to decrement the reference count of the `filename` parameter after it has been used to open the file. This is essential to avoid memory leaks when using the Wasm and C backends.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/ffi.md#_snippet_14\n\nLANGUAGE: moonbit\nCODE:\n```\nextern \"C\" open(filename : Bytes, flags : Int) -> Int = \"open_ffi\"\n```\n\n----------------------------------------\n\nTITLE: Determining x Coordinate Based on k Value in MoonBit\nDESCRIPTION: This snippet determines the x coordinate based on the value of k and previous coordinates. It prioritizes deletions over insertions by choosing the path with the larger x value. Boundary conditions for k = -d and k = d are handled appropriately.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff.md#_snippet_10\n\nLANGUAGE: moonbit\nCODE:\n```\nif k == -d {\n  x = v[k + 1]\n} else if k == d {\n  x = v[k - 1] + 1 // add 1 to move horizontally\n} else if v[k - 1] < v[k + 1] {\n  x = v[k + 1]\n} else {\n  x = v[k - 1] + 1\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining LazyTag and Apply Function in MoonBit\nDESCRIPTION: This code defines the LazyTag type and the `apply` function, which is used to apply a LazyTag to a node. It defines how to merge existing LazyTags and how to compute the new value of the node based on the LazyTag and segment length. The crucial part is to compute the correct node's value with the segment's length and the value of LazyTag.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/segment-tree/segment-tree2.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait Op_add_tag[Data, Tag] {\n  fn op_add_tag(Tag, Tag) -> Tag\n  fn apply(data: Data, tag: Tag, len: Int) -> Data\n}\n\nimpl [Data: Op_add_tag[Data, Tag], Tag: Op_add_tag[Data, Tag]] Op_add_tag[Node[Data, Tag], Tag] for Node[Data, Tag] {\n  fn op_add_tag(tag1: Tag, tag2: Tag) -> Tag {\n    op_add_tag(tag1, tag2)\n  }\n\n  fn apply(node: Node[Data, Tag], tag: Tag) -> Node[Data, Tag] {\n    match node {\n      Leaf(data) => {\n        let new_data = apply(data, tag, 1)\n        Leaf(new_data)\n      }\n      Node { left, right, data, tag: old_tag, len } => {\n        let new_tag = op_add_tag(old_tag, tag)\n        let new_data = apply(data, new_tag, len)\n        Node { left, right, data: new_data, tag: new_tag, len }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Struct Definition in MoonBit\nDESCRIPTION: Illustrates the definition of a struct in MoonBit, showcasing named fields and their types. Structs are similar to tuples, but their fields are accessed by names.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_71\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Person {\n  name : String\n  age : Int\n  email : String\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Inline Function in MoonBit (JavaScript)\nDESCRIPTION: This snippet shows how to write an inline JavaScript function using a lambda expression in MoonBit. The function is defined directly using JavaScript syntax.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/ffi.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\nextern \"js\" fn cos(d : Double) -> Double =\n  #|(d) => Math.cos(d)\n```\n\n----------------------------------------\n\nTITLE: Removing main function in non-main package (MoonBit)\nDESCRIPTION: This code snippet demonstrates the suggested solution to remove the `main` function from a non-main package in MoonBit. This resolves the E4069 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4069.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\n// Remove the main function\n//- fn main {\n//-   println(\"Hello, world!\")\n//- }\n```\n\n----------------------------------------\n\nTITLE: Correct Async Function Call in MoonBit\nDESCRIPTION: This example shows the correct way to call an async function. The containing function `g` is changed to an async function, allowing the async function `f` to be called without error. Requires the surrounding context to understand f's definition.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4149.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nasync fn g() -> Int {\n  f!!()\n}\n```\n\n----------------------------------------\n\nTITLE: Publicly Constructible Struct Definition in MoonBit\nDESCRIPTION: This code demonstrates how to make a struct publicly constructible using the `pub(all)` visibility modifier. This allows other packages to construct instances of the struct.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0009.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\npub(all) struct A {\n  value : Int\n}\n```\n\n----------------------------------------\n\nTITLE: Constructor Arity Mismatch Example in Moonbit\nDESCRIPTION: Demonstrates a constructor arity mismatch error within an enum definition. The constructor 'A' for enum 'E' requires three arguments (Int, Double, String), but it is called with two arguments in both the constructor call and the match arm, leading to the error. The code showcases the error occurring in both the construction and pattern matching of the enum variant.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4080.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nenum E {\n  A(Int, Double, String)\n}\n\nfn main {\n  match A(0, 1.0) { // Error: This function has type (Int, Double, String) -> E, which requires 3 arguments, but is given 2 arguments.\n    A(_, _) => ... // Error: The constructor A requires 3 arguments, but is given 2 arguments.\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Map Function for Stream in MoonBit\nDESCRIPTION: Defines the `map` function for `Stream` in MoonBit. It applies a function `f` to each element of the stream lazily, wrapping the result in a new `Stream`. The mapping operation is deferred until the stream is actually consumed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn map[X, Y](self : Stream[X], f : (X) -> Y) -> Stream[Y] {\n  match self {\n    Empty => Empty\n    Cons(x, xs) => Cons(f(x), fn () { xs().map(f) })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Local Function in MoonBit\nDESCRIPTION: This code demonstrates defining a local function within another function in MoonBit. Type annotations can often be omitted as they are automatically inferred.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_31\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main() {\n  let add = fn(x, y, z) {\n    x + y + z\n  }\n  IO::println(add(1, 2, 3))\n}\n```\n\n----------------------------------------\n\nTITLE: Using New Type to Resolve E4053 (MoonBit)\nDESCRIPTION: Shows how to resolve the E4053 error by wrapping the type with a 'new type' (using the `type` keyword), allowing it to be used with 'self'.  Demonstrates usage in function definitions and trait implementations.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4053.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\npub(all) type Wrap[T] T\n\nfn f[T](self : Wrap[T]) -> Int {\n  ignore(self)\n  0\n}\n\nfn g(self : Wrap[(Int) -> Unit]) -> Unit {\n  (self._)(0)\n}\n\nimpl[X] A for Wrap[X] with f(self : Wrap[X]) -> Int {\n  ignore(self)\n  0\n}\n```\n\n----------------------------------------\n\nTITLE: Suggested MoonBit code using '.' and '?' correctly\nDESCRIPTION: This code demonstrates the correct way to handle potential errors in MoonBit code where a method might fail. It suggests using the single dot '.' syntax to call the method and store the result in a variable, which allows handling the `Result[T, E]` type returned by the method. This avoids the type mismatch caused by combining '..' and '?'.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4125.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let a : A = 1.0\n  let b : A = 2.0\n  println(a.div(b).check?())\n}\n```\n\n----------------------------------------\n\nTITLE: Optional Arguments with Option Type in MoonBit (Forwarding)\nDESCRIPTION: This code shows how to pass a value of type `T?` directly to an optional argument using the `label?=value` syntax, where `label?` is an abbreviation of `label?=label`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_44\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(x? : Int) {\n  g(x?)\n}\n\nfn g(x? : Int) {\n  IO::println(Debug::toString(x))\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing the G-Machine State in MoonBit\nDESCRIPTION: This MoonBit code snippet defines the initial instruction sequence for the G-Machine. It starts with an Unwind instruction, followed by Eval, and then Unwind again. This sets up the initial state for evaluating the program.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-2.md#_snippet_11\n\nLANGUAGE: moonbit\nCODE:\n```\nlet init_instrs = list::from_array([Instruction::Unwind, Instruction::Eval, Instruction::Unwind])\n```\n\n----------------------------------------\n\nTITLE: Enum Usage with Function in MoonBit\nDESCRIPTION: Demonstrates constructing and using enum values within a function, showcasing how to call the `print_color` function defined previously with different enum cases.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_78\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let red = Red\n  let green = Green\n  let blue = Blue\n  print_color(red)\n  print_color(green)\n  print_color(blue)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Floating-point Number in MoonBit\nDESCRIPTION: This code snippet demonstrates how to define floating-point numbers in MoonBit. A floating-point number literal is 64-bit floating-point number. To define a float, type annotation is needed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\nlet f : Double = 3.14\n```\n\n----------------------------------------\n\nTITLE: Fish Completion Installation\nDESCRIPTION: Installs fish completion for the Moon CLI.  Creates the completion directory and then saves the moon shell completion script to the specified fish completion file.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/commands.md#_snippet_2\n\nLANGUAGE: fish\nCODE:\n```\n$ mkdir -p ~/.config/fish/completions\n$ moon shell-completion --shell fish > ~/.config/fish/completions/moon.fish\n```\n\n----------------------------------------\n\nTITLE: Range Pattern Matching in MoonBit\nDESCRIPTION: This snippet demonstrates range pattern matching for integer types in MoonBit. It uses the `..<` (exclusive upper bound) and `..=` (inclusive upper bound) operators to match values within specified ranges.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_99\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(x : Int) -> Int {\n  match x {\n    10..<20 => 1\n    20..=30 => 2\n    _ => 0\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Shortest Edit Function in MoonBit\nDESCRIPTION: This code presents the completed `shortest_edit` function, integrating the k-based coordinate logic and boundary conditions. The primary objective of this function is to determine the minimum number of edits needed to transform the 'old' array into the 'new' array.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff.md#_snippet_12\n\nLANGUAGE: moonbit\nCODE:\n```\nfn shortest_edit(old~ : Array[Line], new~ : Array[Line]) -> Int {\n  let n = old.length()\n  let m = new.length()\n  let max = n + m\n  let v = BPArray::make(2 * max + 1, 0)\n  for d = 0; d < max + 1; d = d + 1 {\n    for k = -d; k < d + 1; k = k + 2 {\n      let mut x = 0\n      if k == -d || (k != d && v[k - 1] < v[k + 1]) {\n        x = v[k + 1]\n      } else {\n        x = v[k - 1] + 1\n      }\n      let mut y = x - k\n\n      while x < n && y < m && old[x].text == new[y].text {\n        x = x + 1\n        y = y + 1\n      }\n\n      v.set(k, x)\n      if x == n && y == m {\n        return d\n      }\n    }\n  }\n  return max\n}\n\n```\n\n----------------------------------------\n\nTITLE: MoonBit: Test is_qualified function\nDESCRIPTION: This code defines a test case for the `is_qualified` function in MoonBit. It uses `assert_eq!` to verify the function's behavior with different student scores and criteria, checking if the student passes or fails as expected.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/tutorial/tour.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"is qualified\" {\n  assert_eq!(is_qualified(Student::{ id : \"0\", score : 50.0 }, 60.0), Fail)\n  assert_eq!(is_qualified(Student::{ id : \"1\", score : 60.0 }, 60.0), Pass)\n  assert_eq!(is_qualified(Student::{ id : \"2\", score : 13.0 }, 7.0), Pass)\n}\n```\n\n----------------------------------------\n\nTITLE: Suggesting Removal of `!` in `catch` Block in MoonBit\nDESCRIPTION: This code snippet provides the suggested correction for the E0026 error. It removes the `!` from the `catch!` block, making it simply `catch`. This is the correct way to handle single error types within a `try` block in MoonBit.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0026.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntype! E\n\nfn f() -> Unit!E {\n  raise E\n}\n\nfn g() -> Unit! {\n  try {\n    f!()\n  } catch {\n    E => raise E\n  }\n}\n\nfn main {\n  try {\n    g!()\n  } catch {\n    _ => println(\"Error\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Wasm Linear Backend Heap Start Address Configuration\nDESCRIPTION: This JSON snippet demonstrates how to configure the `heap-start-address` option for the Wasm linear backend in the `link` section of a `moon.pkg.json` file. It sets the starting address of the linear memory to 1024.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/package.md#_snippet_6\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"link\": {\n      \"wasm\": {\n        \"heap-start-address\": 1024\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: PowerShell Check Profile Existence\nDESCRIPTION: Checks if a PowerShell profile exists.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/commands.md#_snippet_8\n\nLANGUAGE: powershell\nCODE:\n```\nPS C:\\> Test-Path $profile\n```\n\n----------------------------------------\n\nTITLE: MoonBit Package Configuration - Non-Main\nDESCRIPTION: Demonstrates the alternative solution of setting the 'is-main' field to false in the package configuration, which removes the requirement for a main function.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4067.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"is-main\": false\n}\n```\n\n----------------------------------------\n\nTITLE: Evaluating Expressions in MoonBit\nDESCRIPTION: This MoonBit code snippet implements the `Eval` instruction.  It pops the top address from the stack, saves the current instruction sequence and stack into the dump, clears the stack and pushes the saved address, and replaces the current instruction sequence with `Unwind`. This forces the computation of the expression at the given address to Weak Head Normal Form (WHNF).\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-2.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\nEval,\n\n    Eval => {\n      let addr = state.stack.last()\n      let new_stack = list::drop_last(state.stack)\n      let dump_item = (state.instructions, new_stack)\n      let new_dump = list::push(state.dump, dump_item)\n      {\n        state with\n        instructions = list::singleton(Instruction::Unwind),\n        stack = list::singleton(addr),\n        dump = new_dump\n      }\n    }\n```\n\n----------------------------------------\n\nTITLE: Custom Iter Implementation for Bytes in MoonBit\nDESCRIPTION: Demonstrates how to implement `Iter` for a custom sequence type, specifically `Bytes` in MoonBit. This example focuses on the structure and highlights the iteration block, which is often similar across different `Iter` implementations.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_70\n\nLANGUAGE: moonbit\nCODE:\n```\nimport bytes\n\nfn iter(bytes : Bytes) : Iter[Byte] {\n  var i = 0\n  fn(yield : (Byte) -> IterResult) : IterResult {\n    if i < bytes::length(bytes) {\n      let res = yield(bytes[i])\n      i = i + 1\n      res\n    } else {\n      IterEnd\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Mutable Enum Constructor with Label - MoonBit\nDESCRIPTION: This code snippet shows the corrected way to define a mutable field within an enum constructor in MoonBit. By adding a label (x~) to the mutable field, the E4012 error is resolved.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4012.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nenum E {\n  F(mut x~ : Int)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating ArrayView in MoonBit\nDESCRIPTION: This code shows how to create a view of an array, referencing a specific segment of the array from `start` to `end` (exclusive). Both `start` and `end` indices can be omitted.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_27\n\nLANGUAGE: moonbit\nCODE:\n```\ndata[start:end]\n```\n\n----------------------------------------\n\nTITLE: MoonBit: Define Show trait\nDESCRIPTION: This code defines the `Show` trait in MoonBit. The trait requires types to implement either an `output` function (which writes the value to a `Logger`) or a `to_string` function (which converts the value to a `String`), allowing values to be displayed or converted to a string representation.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/tutorial/tour.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait Show {\n  output(Self, &Logger) -> Unit\n  to_string(Self) -> String\n}\n```\n\n----------------------------------------\n\nTITLE: Using Qualified Name for Constructor in MoonBit\nDESCRIPTION: Shows how to disambiguate a constructor from a constant with the same name by using a qualified name (e.g., `@a.Value`). This clarifies that the intention is to use the constructor from a specific package (`a`) rather than the constant. This is important when a constructor and a constant share a name across different scopes.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4144.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  match { ... } {\n    @a.Value(_) => println(\"Value\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Overloading Addition Operator for Segment Tree Nodes in MoonBit\nDESCRIPTION: This snippet defines an overloaded `op_add` function for the `Node` type in MoonBit. This function is used to merge two `Node` instances by summing their values.  It acts as the \"pushup\" operation, maintaining segment sums.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/segment-tree/segment-tree.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn op_add(n1 : Node, n2 : Node) -> Node {\n  match (n1, n2) {\n    (Nil, Nil) => Nil\n    (Node(i, _, _), Nil) => Node(i, Nil, Nil)\n    (Nil, Node(i, _, _)) => Node(i, Nil, Nil)\n    (Node(i, _, _), Node(j, _, _)) => Node(i+j, Nil, Nil)\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Main Function in MoonBit (main) using qualified name\nDESCRIPTION: Defines the main function in the 'main' package. It prints the result of calling the 'greeting' function from the imported 'hello' package using the qualified name.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0033.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  println(@hello.greeting())\n}\n```\n\n----------------------------------------\n\nTITLE: Duplicate Label Declaration in MoonBit\nDESCRIPTION: This code snippet demonstrates an erroneous example where the label `g` is declared twice within the function `f` in MoonBit, leading to an E4019 error. The function attempts to define `g` as both an `Int` and a `String` parameter.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4019.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(g~ : Int, g~ : String) -> Int {\n  g\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Optional Parameter Definition\nDESCRIPTION: This code snippet shows the corrected way to define an optional parameter in MoonBit. By simply declaring `a? : Int` without assigning `= None`, the parameter correctly defaults to `None` when not provided in the function call, resolving the E3015 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3015.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(a? : Int) -> Unit {\n  println(a)\n}\n```\n\n----------------------------------------\n\nTITLE: Index Struct Definition in MoonBit\nDESCRIPTION: This code defines a `struct` named `Index` to store variable names along with their associated nesting depth. This struct is used as an intermediate data structure during the conversion from regular Lambda terms to de Bruijn index representation.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/lambda/index.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Index {\n  name : String\n  depth : Int\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Duplicate Function Definition - MoonBit\nDESCRIPTION: This code snippet shows the corrected version of the previous example, where the duplicate function definition is resolved by renaming the functions to `helper1` and `helper2`.  This ensures that each function has a unique name within the `main` function's scope, thus avoiding the E4006 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4006.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  fn helper1() {\n    1 + 1\n  }\n\n  fn helper2() {\n    2 + 2\n  }\n\n  helper1()\n  helper2()\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Error E4086 Example\nDESCRIPTION: This example demonstrates the E4086 error where a function `f` requires a labeled argument `name~` but is called with a positional argument. The error message indicates that the labels are required but not supplied.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4086.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(name~ : String) -> Unit {\n  println(\"Hello, \\{name}\")\n}\n\nfn main {\n  f(\"John\") // Error: The labels name~ are required by this function, but not supplied.\n}\n```\n\n----------------------------------------\n\nTITLE: Correct MoonBit 'for in' Loop with Index and Value\nDESCRIPTION: This code demonstrates a correct usage of the 'for in' loop with two loop variables in MoonBit.  It iterates over the array [1, 2, 3] and assigns the index to variable 'i' and the value to variable 'v'. This is a valid way to iterate over an array in MoonBit when you need both the index and the value.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4133.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  for i, v in [1, 2, 3] {\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Tuple in MoonBit\nDESCRIPTION: This code snippet demonstrates how to access tuples via pattern matching or index in MoonBit.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_19\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main() {\n  let tuple : (Int, Bool) = (1, true)\n  let (x, y) = tuple\n  println(x)\n  println(y)\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Constants in Array Pattern in MoonBit\nDESCRIPTION: This snippet demonstrates how to combine consecutive char or byte constants in an array pattern using the `..` operator in MoonBit. This can make the code cleaner when dealing with multiple consecutive constants.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_98\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(s : String) -> Bool {\n  match s.view {\n    ['a', 'b', ..\"cde\"] => true\n    _ => false\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Async Primitives for Suspension in MoonBit\nDESCRIPTION: This snippet presents the two core primitives for async programming in MoonBit: `%async.suspend` and `%async.run`. These primitives are not intended for direct use, but are currently necessary due to the standard library's ongoing development.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/async-experimental.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nbuiltin %async.run : (fn () -> ()) -> ()\nbuiltin %async.suspend : (fn (Result[fn(T), fn(Error)]) -> ()) -> T\n```\n\n----------------------------------------\n\nTITLE: Testing Segment Tree Query in MoonBit\nDESCRIPTION: This snippet demonstrates how to test the `query` function in MoonBit. It builds a segment tree from an array, then queries the sum from index 1 to 6.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/segment-tree/segment-tree.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main() {\n  let arr = [1, 2, 3, 4, 5, 6, 7]\n  let tree = build(arr)\n  let result = query(tree, 0, 6, 1, 6)\n  debug(result)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Public Variable Example - MoonBit\nDESCRIPTION: Shows how to resolve the E0002 warning for a toplevel variable by declaring it as public using the `pub` keyword. This indicates that the variable is part of the module's public API and prevents the unused variable warning.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0002.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub let p = 42\n```\n\n----------------------------------------\n\nTITLE: Function without Error Type in MoonBit\nDESCRIPTION: This MoonBit code defines a corrected version of the `greet` function. The error type (`!`) has been removed from the function signature, making it `Unit` instead of `Unit!`. This resolves the E0024 error because the function no longer declares an error type that it doesn't use.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0024.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn greet() -> Unit {\n  println(\"Hello, world!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Definition Cycle Error Example (MoonBit)\nDESCRIPTION: Demonstrates the E4050 error where a definition cycle exists between variable `a` and function `f`.  The variable `a` depends on the result of `f()`, and `f()` in turn uses `a`, creating a cycle. Dependencies: None. Inputs: None. Output: Compiler error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4050.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub let a : Int = f() // Error: Definition cycle detected : a -> f -> a\n\nfn f() -> Int { // Error: Definition cycle detected : a -> f -> a\n  a\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning Value to a Square in MoonBit\nDESCRIPTION: This function assigns a specific value to a square in the Sudoku grid. It takes a `SquareMap` representing the grid, the `key` (square's identifier as a string), and the `val` (value to assign as a character).  It directly sets the value of the specified square to a list containing only the assigned value.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/sudoku/index.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn assign(values : SquareMap[List[Char]], key : String, val : Char) {\n  values[key] = Cons(val, Nil)\n}\n```\n\n----------------------------------------\n\nTITLE: Map Value Access\nDESCRIPTION: Accesses a value in the map using the key with the `map[key]` syntax. This syntax returns the value associated with the specified key. If the key does not exist, it may result in an error or a default value, depending on the implementation details.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/moonbit-tour/tour/chapter1_basics/lesson8_map/index.md#_snippet_2\n\nLANGUAGE: MoonBit\nCODE:\n```\nmap[key]\n```\n\n----------------------------------------\n\nTITLE: Suggestion: Corrected Function Call with Different Labels (Moonbit)\nDESCRIPTION: This code demonstrates the corrected function call where the second label `a` has been corrected to `b`.  This assumes that the original intention was to pass two different labeled parameters to a function, where only the `f` function signature needs to be corrected to accept the new `b` parameter.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4084.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  f(a=0, b=1)\n}\n```\n\n----------------------------------------\n\nTITLE: Modify Trait Visibility to 'pub(open)' in MoonBit\nDESCRIPTION: This code snippet demonstrates the solution to the E4145 error by changing the visibility of the `Sealed` trait to `pub(open)`. This makes the trait publicly accessible and allows other packages to implement it. The `pub(open)` modifier makes the trait visible for implementation from other packages, resolving the original error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4145.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\npub(open) trait Sealed {\n  to_int() -> Int\n}\n```\n\n----------------------------------------\n\nTITLE: Valid Const Declaration in MoonBit\nDESCRIPTION: This code snippet demonstrates the correct usage of the `const` keyword in MoonBit. It assigns a literal integer value (2) to the constant variable `A`. This is a valid `const` declaration because the assigned value is a constant expression.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4142.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nconst A : Int = 2 // This is a constant value.\n```\n\n----------------------------------------\n\nTITLE: Compiling Let Expressions in MoonBit\nDESCRIPTION: This MoonBit code snippet shows how to compile 'let' expressions. It compiles the expressions corresponding to local variables using `compileC`, then iterates over the variable definitions, compiling and updating offsets. Finally, it compiles the main expression using the passed `comp` function and adds the `Slide` instruction to clean up the unused addresses.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-2.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nfn compile_let(defs : List[(String, Core)], body : Core, comp : Fn(Core, Env) -> List[Instruction], env : Env) -> List[Instruction] {\n  let def_compiles = list::map(defs, (def) => compileC(def._2, env))\n  let body_compile = comp(body, env)\n  let slide_instr = list::singleton(Instruction::Slide(list::length(defs)))\n  list::append(list::append(list::concat(def_compiles), body_compile), slide_instr)\n}\n```\n\n----------------------------------------\n\nTITLE: Suggested Moonbit Code: Exclusive Range with Wildcard Upper Bound\nDESCRIPTION: This Moonbit code snippet provides a solution to the error E3019 by replacing the inclusive range pattern with an exclusive range pattern `0..< _`. This allows the code to compile and function as intended, effectively checking if a value is greater than or equal to a specified lower bound.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3019.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  match 0 {\n    0..< _ => println(\"Big than or equal to 0\")\n    _ => println(\"Less than 0\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Cannot Derive Default 2\nDESCRIPTION: This code snippet demonstrates another case where `Default` trait cannot be derived. This is because the enum contains multiple cases without parameters and there is no default value which can be returned.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/derive.md#_snippet_10\n\nLANGUAGE: moonbit\nCODE:\n```\nenum CannotDerive2 {\n    Case1\n    Case2\n} derive(Default) // Case1 and Case2 are both candidates as default constructor\n```\n\n----------------------------------------\n\nTITLE: Defining Ref in MoonBit\nDESCRIPTION: This code snippet demonstrates how to define a `Ref` in MoonBit. A `Ref[T]` is a mutable reference containing a value `val` of type `T`. It can be constructed using `{ val : x }`, and can be accessed using `ref.val`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_20\n\nLANGUAGE: moonbit\nCODE:\n```\nlet ref : Ref[Int] = { val : 10 }\nref.val = 20\nprintln(ref.val)\n```\n\n----------------------------------------\n\nTITLE: Defining Byte in MoonBit\nDESCRIPTION: This code snippet demonstrates how to define byte literals in MoonBit. A byte literal in MoonBit is either a single ASCII character or a single escape enclosed in single quotes `'`, and preceded by the character `b`. Byte literals are of type `Byte`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_14\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let ascii_a : Byte = b'a'\n  let newline : Byte = b'\\n'\n  println(ascii_a)\n  println(newline)\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Example: Multiple Bindings of 'a' in Pattern (MoonBit)\nDESCRIPTION: This MoonBit code demonstrates the E4081 error. The identifier 'a' is bound twice within the pattern `(Some(a), Some(a))` of the `match` expression. This is invalid because 'a' cannot simultaneously represent potentially different values from both `Some(a)` patterns.  The code attempts to match two optional integers and print their values if both are present.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4081.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(a : Int?, b : Int?) -> Unit {\n  match (a, b) {\n    (Some(a), Some(a)) => println(\"Some({a})\")\n    //    ^ Error: The identifier a is bound more than once in the same pattern.\n    _ => println(\"None\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Fibonacci Function (b.mbt)\nDESCRIPTION: Defines a public function `fib2` that calculates the nth Fibonacci number using tail-call optimization.  This function is also part of the `fib` package.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/tutorial.md#_snippet_14\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn fib2(num : Int) -> Int {\n  fn aux(n, acc1, acc2) {\n    match n {\n      0 => acc1\n      1 => acc2\n      _ => aux(n - 1, acc2, acc1 + acc2)\n    }\n  }\n\n  aux(num, 0, 1)\n}\n```\n\n----------------------------------------\n\nTITLE: Renaming Struct Field in MoonBit\nDESCRIPTION: This code snippet demonstrates the suggested solution for the MoonBit error E4055.  Instead of declaring the same field multiple times, the duplicate field `a` is renamed to `b`. This allows the struct to compile successfully with distinct field names.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4055.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct A {\n  a : Int\n  b : Double\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit: Heap definition for G-Machine\nDESCRIPTION: This MoonBit code defines the `Addr` and `NHeap` types that represent addresses in the heap and the heap itself. The heap stores various node types such as `NNum` (integer), `NApp` (application), `NGlobal` (global function), and `NInd` (indirection). The heap is implemented as a mutable array.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_12\n\nLANGUAGE: moonbit\nCODE:\n```\n  type Addr = Int\n\n  type NHeap = {\n    nodes : Array[NNode],\n  }\n\n  builtin {\n    array_new : Int -> a -> Array[a]\n  }\n\n  builtin {\n    array_get : Array[a] -> Int -> a\n  }\n\n  builtin {\n    array_set : Array[a] -> Int -> a -> ()\n  }\n\n  type NNode = {\n    num : Int\n  } | {\n    app : (Addr, Addr)\n  } | {\n    global : String\n  } | {\n    ind : Addr\n  }\n```\n\n----------------------------------------\n\nTITLE: `init` Function Definition in MoonBit\nDESCRIPTION: This code defines an `init` function in MoonBit, which is a special function that's implicitly called during package initialization. It showcases a simple `init` function that binds a value to a local variable and prints it. `init` functions can only consist of statements.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/introduction.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn init {\n  let x = 1\n  println(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Connection Error Type\nDESCRIPTION: This snippet defines an error type `ConnectionError` as an enum with multiple constructors.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_15\n\nLANGUAGE: moonbit\nCODE:\n```\ntype! ConnectionError {\n  BrokenPipe(Int,String)\n  ConnectionReset\n  ConnectionAbort\n  ConnectionRefused\n}\n```\n\n----------------------------------------\n\nTITLE: Compile Constant Numbers\nDESCRIPTION: This snippet compiles constant numbers by pushing them onto the stack. When compiling in a strict context, this avoids unnecessary evaluations. The constant is converted to a Value and then pushed onto the stack.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-3.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\n| Num n => [PushValue (VNum n)]\n```\n\n----------------------------------------\n\nTITLE: Defining Lambda Term with de Bruijn Index Enum in MoonBit\nDESCRIPTION: This code snippet defines an enum type `TermDBI` in MoonBit to represent Lambda expressions using de Bruijn indices. It includes `VarDBI` for variables represented by their de Bruijn index, `AbsDBI` for lambda abstractions, and `AppDBI` for function applications. This representation simplifies variable substitution during Beta reduction.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/lambda/index.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nenum TermDBI {\n  VarDBI(Int, String)\n  AbsDBI(String, TermDBI)\n  AppDBI(TermDBI, TermDBI)\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Function and Method Calls in MoonBit\nDESCRIPTION: Shows the corrected MoonBit code that replaces the invalid pipe expressions with standard function and method calls, resolving the E4101 error. The snippet defines a type `T`, a method `m`, and a function `f` and demonstrates how to properly call the anonymous function and method without using the pipe operator.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4101.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntype T Int\n\nfn m(self: T, x: Int) -> Unit {\n  println(self._ + x)\n}\n\npub fn f(t: T, x: Int) -> Unit {\n  fn(x: Int) { println(x)}(x)\n  t.m(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Trait Definition in Moonbit\nDESCRIPTION: This code snippet demonstrates the error E4100 in Moonbit, where a type alias is incorrectly used as a trait in a trait definition. It highlights the problematic line and indicates the compiler's error message.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4100.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntype Original Int\n\ntypealias Alias = Original\n\ntrait Trait: Alias {\n  //         ^~~~~\n  // Error: The type Alias is not a trait\n}\n```\n\n----------------------------------------\n\nTITLE: Fixed MoonBit Loop with Break Argument\nDESCRIPTION: This MoonBit code snippet fixes the E4105 error by providing an argument to the `break` statement that matches the loop's result type, `Int`. The `break` statement now includes `i` as its argument, which is an integer.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4105.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn g(x: Int) -> Int {\n  for i in 0..=x {\n    if i == 42 {\n      break i\n    }\n  } else {\n    0\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Option Usage in MoonBit\nDESCRIPTION: This code snippet shows the corrected way to use the `Option` type in MoonBit, providing the `Int` type argument. This resolves the E4040 error by giving the expected number of type arguments to the `Option` constructor.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4040.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nlet a : Option[Int] = Some(3)\n```\n\n----------------------------------------\n\nTITLE: Implementing midpoint function in Moonbit\nDESCRIPTION: This code provides the implementation of the `midpoint` function in Moonbit, which finds the middle snake within a given `Box`. It performs alternating forward and backward searches, storing the results in arrays. The function checks for overlap between the forward and backward searches to identify the middle snake. If the box has size 0, it returns `None`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff3.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn midpoint(box: Box, a: Array[String], b: Array[String]) -> Option[Snake] {\n  let x0 = box.x0\n  let y0 = box.y0\n  let x1 = box.x1\n  let y1 = box.y1\n\n  let w = x1 - x0\n  let h = y1 - y0\n\n  if w == 0 || h == 0 {\n    return None\n  }\n\n  let delta = w - h\n  let half = (w + h + 1) / 2\n\n  let forward = init[Int](w + h + 3, x0 - 1)\n  let backward = init[Int](w + h + 3, x1 + 1)\n\n  backward[half - delta - 1] = x1\n\n  for d in range(0, half + 1) {\n    match search(d, forward, a, b, box, true) {\n      Some(snake) => {\n        return Some(snake)\n      }\n      None => {}\n    }\n    match search(d, backward, a, b, box, false) {\n      Some(snake) => {\n        return Some(snake)\n      }\n      None => {}\n    }\n  }\n  None\n}\n\n```\n\n----------------------------------------\n\nTITLE: Manually Implementing a Trait in MoonBit\nDESCRIPTION: This code snippet shows the correct way to implement a user-defined trait `T` for type `A` in MoonBit. Instead of using `derive(T)`, the trait is implemented manually using the `impl` keyword.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4077.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait T {\n  f(Self) -> Int\n}\n\n// Remove derive(T)\ntype A Int\n\nimpl T for A with f(self : A) -> Int {\n  0\n}\n```\n\n----------------------------------------\n\nTITLE: Function Definitions with Expressions and Statements in MoonBit\nDESCRIPTION: This code snippet demonstrates the use of expressions and statements within MoonBit function definitions. The `foo` function showcases an expression as the return value, while the `bar` function highlights the last clause being an expression. The `let` keyword is used for variable binding.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/introduction.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn foo() -> Int {\n  let x = 1\n  x + 1\n}\n\nfn bar() -> Int {\n  let x = 1\n  //! x + 1\n  x + 2\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Enum with Duplicated Tag Values in MoonBit\nDESCRIPTION: This MoonBit code demonstrates the E4153 error. The enum `Bad` has constructor `C` assigned the same tag value as `B`, causing a duplication error. Constructor `B`'s implicit tag is calculated from `A`'s tag, then `C`'s tag is explicitly set to the same value.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4153.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nenum Bad {\n  A = 1\n  B // the tag of `B` is `A + 1 = 2`\n  C = 2 // duplicates with `B`\n}\n```\n\n----------------------------------------\n\nTITLE: Solution 2: Using `match` instead of `loop` (MoonBit)\nDESCRIPTION: Provides an alternative solution to the E0018 error by replacing the `loop` expression with a `match` statement.  Since a `continue` statement is not needed, a simpler control flow construct like `match` can be used.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0018.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn countdown(n : Int) -> Int {\n  let mut count = n\n  match count {\n    _..<0 => ()\n    _ => count = count - 1\n  }\n  return count\n}\n```\n\n----------------------------------------\n\nTITLE: Missing Method in Trait Implementation - MoonBit\nDESCRIPTION: Demonstrates the error E4063 in MoonBit when a type `A` attempts to implement the `Number` trait but omits the `to_float` method, leading to a compilation error. The code shows the initial incomplete implementation and the error message.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4063.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait Number {\n  to_int(Self) -> Int\n  to_float(Self) -> Float\n}\n\ntype A Int\n\nimpl Number for A with to_int(self : A) -> Int {\n//^~~~~~~~~~~~~~~\n// Error: Type A does not implement trait Number, although an `impl` is defined.\n// hint:\n//   method to_float is missing.\n  self._\n}\n```\n\n----------------------------------------\n\nTITLE: Suggested Correct Match Function Definition in Moonbit\nDESCRIPTION: This code snippet demonstrates the correct way to define a match function in Moonbit, avoiding the E4009 error. All branches handle the same number of arguments, ensuring consistency and preventing the error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4009.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nlet f = fn {\n  0 => 0\n  a => a\n}\n```\n\n----------------------------------------\n\nTITLE: Fixed MoonBit Loop with Unit Return Type\nDESCRIPTION: This MoonBit code snippet addresses the E4105 error by changing the return type of the function to `Unit`. This allows the `break` statement without arguments to be valid, as it now matches the `Unit` return type.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4105.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn g(x: Int) -> Unit {\n  for i in 0..=x {\n    if i == 42 {\n      break\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Definition of the Eq Trait in MoonBit\nDESCRIPTION: This code snippet shows the definition of the `Eq` trait in MoonBit.  The `op_equal` method takes two `Self` parameters, making the trait non-object-safe. Object-safe traits should only use `Self` as the type of the first parameter.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4038.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub(open) trait Eq {\n  op_equal(Self, Self) -> Bool\n}\n```\n\n----------------------------------------\n\nTITLE: Overloaded Bytes Literal in MoonBit\nDESCRIPTION: This code snippet demonstrates overloaded bytes literals in MoonBit. When the expected type is `Bytes`, the array literal syntax is overloaded to construct a `Bytes` by specifying each byte in the sequence.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_17\n\nLANGUAGE: moonbit\nCODE:\n```\nlet b : Bytes = [b'H', b'e', b'l', b'l', b'o']\n```\n\n----------------------------------------\n\nTITLE: MoonBit Module Configuration (moon.mod.json)\nDESCRIPTION: Defines the module's metadata, including its name, version, readme file, repository, license, keywords, description, and source directory. The `source` field specifies where the module's source code is located.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/tutorial.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"username/hello\",\n  \"version\": \"0.1.0\",\n  \"readme\": \"README.md\",\n  \"repository\": \"\",\n  \"license\": \"Apache-2.0\",\n  \"keywords\": [],\n  \"description\": \"\",\n  \"source\": \"src\"\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Code - Missing Main Function\nDESCRIPTION: Shows MoonBit code that defines a type `A` and a method `to_int`, but lacks a `main` function within a package designated as 'main', resulting in the E4067 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4067.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntype A Int\n\npub fn A::to_int(self : A) -> Int {\n  self._\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Break Usage in Loop Initialization - Moonbit\nDESCRIPTION: This code demonstrates the E4111 error, which arises when a `break` statement is incorrectly placed within the initialization section of a for loop. The error prevents compilation and highlights the misuse of `break` outside of a loop's body.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4111.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(x: Int, y: Int) -> Unit {\n  for i = 0; i < x; i = i + 1 {\n    for j = { break }; j < y; j = j + 1 {\n//            ^^^^^ Error: The usage of break statement is invalid.\n        println(i + j)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit Trait Implementation MoonBit\nDESCRIPTION: This code snippet showcases the suggested explicit trait implementation using the `impl` declaration in MoonBit. The `op_equal` function is now part of the `impl Eq for MyType` block, explicitly associating it with the `Eq` trait. This makes the intention clearer and avoids the deprecation warning. The `impl` can be called using dot syntax.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0045.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntype MyType Int\n\nimpl Eq for MyType with op_equal(self, other) {\n  self._ == other._\n}\n\ntest {\n  println(MyType(1) == MyType(2))\n}\n```\n\n----------------------------------------\n\nTITLE: Solution 1: Modify Function to Accept Optional Argument (MoonBit)\nDESCRIPTION: This snippet shows how to modify the function `f` to accept an optional argument.  It uses a `match` statement to handle both `Some` and `None` cases, providing a default value when `None` is encountered. This makes the function compatible with optional values.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4141.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(opt? : Int) -> Unit {\n  let opt = match opt {\n    Some(opt) => opt\n    None => 4\n  }\n  println(\"opt: \\{opt}\")\n}\n```\n\n----------------------------------------\n\nTITLE: Struct Shorthand Example in MoonBit\nDESCRIPTION: Demonstrates struct initialization using shorthand syntax in MoonBit when variable names match field names. This simplifies struct creation by omitting redundant field names.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_73\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let name = \"Alice\"\n  let age = 30\n  let email = \"alice@example.com\"\n  // Constructing Person with shorthand\n  let p = Person { name, age, email }\n  debug(p.name)\n  debug(p.age)\n  debug(p.email)\n}\n```\n\n----------------------------------------\n\nTITLE: Optional Arguments with Option Type in MoonBit (Simplified)\nDESCRIPTION: This code demonstrates the simplified declaration of optional arguments with `label? : T`. When supplying this kind of optional argument directly, MoonBit automatically inserts a `Some`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_43\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(x? : Int) {\n  IO::println(Debug::toString(x))\n}\n\nf(x=1) // Some(1)\n```\n\n----------------------------------------\n\nTITLE: Implicit Struct Construction in MoonBit\nDESCRIPTION: Shows how to construct a struct without explicitly mentioning the struct name when there's no ambiguity (i.e., no other struct has the same fields).\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_74\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let name = \"Alice\"\n  let age = 30\n  let email = \"alice@example.com\"\n  // Constructing Person with shorthand\n  let p = { name, age, email }\n  debug(p.name)\n  debug(p.age)\n  debug(p.email)\n}\n```\n\n----------------------------------------\n\nTITLE: Moving Type Definition to Current Package (MoonBit)\nDESCRIPTION: This example demonstrates one solution to the E4059 error. By defining the type `A` within the same package as the method `f`, the method definition becomes valid.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4059.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\npub type A Int\n\nfn f(self : A) -> Int {\n  0\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit: Implement is_qualified function\nDESCRIPTION: This code implements the `is_qualified` function in MoonBit. It compares a student's score to the given criteria. If the score is greater than or equal to the criteria, it returns `Pass`; otherwise, it returns `Fail`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/tutorial/tour.md#_snippet_13\n\nLANGUAGE: moonbit\nCODE:\n```\nfn is_qualified(student : Student, criteria : Double) -> ExamResult {\n  if student.score >= criteria {\n    Pass\n  } else {\n    Fail\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Fixed MoonBit Example: Valid Token\nDESCRIPTION: This MoonBit code snippet shows the corrected version of the erroneous example. The addition of the closing apostrophe resolves the invalid token error and allows the code to compile successfully.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3001.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  println('3')\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unnecessary `catch!` Usage in MoonBit\nDESCRIPTION: This code snippet demonstrates the E0026 error in MoonBit, where `catch!` is used unnecessarily. The `f()` function raises error `E`, and the `try...catch!` block in `g()` catches it. The compiler already knows that only `E` can be raised, making `catch!` redundant.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0026.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntype! E\n\nfn f() -> Unit!E {\n  raise E\n}\n\nfn g() -> Unit! {\n  try {\n    f!()\n  } catch! {\n    E => raise E\n  }\n}\n\nfn main {\n  try {\n    g!()\n  } catch {\n    _ => println(\"Error\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running G-Machine with run - MoonBit\nDESCRIPTION: The `run` function combines the above components to execute the G-Machine. It initializes the heap, executes the steps, and reifies the final result. This function serves as the entry point for running compiled super combinators on the G-Machine.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_27\n\nLANGUAGE: moonbit\nCODE:\n```\nfn run() {\n  // This is a placeholder function for running the G-Machine.\n}\n```\n\n----------------------------------------\n\nTITLE: Manually Implementing Trait in MoonBit\nDESCRIPTION: This code snippet demonstrates how to manually implement a trait (Hash in this case) for a type (T) when automatic derivation is not possible.  This is the suggested workaround for the E4078 error when attempting to derive traits on abstract types.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4078.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntype T\n\nimpl Hash for T with hash_combine(self : T, hasher: Hasher) {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Enum with Custom Integer Values\nDESCRIPTION: This MoonBit code demonstrates how to customize the integer representation of each constructor in a constant enum. By adding `= <integer literal>` after the constructor declaration, you can specify the integer value.  Constructors without specified values default to one plus the value of the previous constructor (or zero for the first).\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/ffi.md#_snippet_11\n\nLANGUAGE: moonbit\nCODE:\n```\nenum SpecialNumbers {\n  Zero = 0\n  One\n  Two\n  Three\n  Ten = 10\n  FourtyTwo = 42\n}\n```\n\n----------------------------------------\n\nTITLE: Define Stream Enum in MoonBit\nDESCRIPTION: Defines the `Stream` enum in MoonBit, representing a lazy list. The `Cons` variant holds a value and a thunk (a parameterless function) that produces the rest of the stream, enabling lazy evaluation.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nenum Stream[T] {\n  Empty\n  Cons(T, () -> Stream[T])\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Main Function in MoonBit\nDESCRIPTION: This code snippet shows the correct way to define the `main` function in MoonBit. The function has no arguments and no return type annotation. The `println` function is used to print \"Hello, world!\" to the console. This is the standard entry point for a MoonBit program.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3003.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  println(\"Hello, world!\")\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Error Example: Cannot Auto-fill Int Parameter\nDESCRIPTION: This code snippet demonstrates the E4115 error in MoonBit, which arises when trying to auto-fill a parameter of type `Int`. The error message indicates that MoonBit does not support auto-filling parameters of type `Int` without a default value.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4115.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(parameter~ : Int = _) -> Unit {\n  // ^~~~~~~~~ Error: Cannot auto-fill parameter of type Int\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit: Define Eq trait\nDESCRIPTION: This code defines the `Eq` trait in MoonBit. The trait specifies that types implementing `Eq` must have an `op_equal` function, which compares two values of the same type and returns a `Bool` indicating whether they are equal.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/tutorial/tour.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait Eq {\n  op_equal(Self, Self) -> Bool\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit: PushInt Instruction Implementation\nDESCRIPTION: This MoonBit code implements the `PushInt` instruction. It allocates a new `NNum` node on the heap with the specified integer value, and then pushes the address of this newly created node onto the stack. This instruction effectively loads an integer constant onto the stack.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_15\n\nLANGUAGE: moonbit\nCODE:\n```\n  fn push_int(s : GState, i : Int) -> GState {\n    let addr = new_addr(s.heap)\n    let new_heap = { nodes = array_set(s.heap.nodes, addr, { num = i }) }\n    { s with heap = new_heap, stack = cons(addr, s.stack) }\n  }\n```\n\n----------------------------------------\n\nTITLE: Compile Expression in Strict Context\nDESCRIPTION: This snippet shows the default case for compiling an expression in a strict context. It compiles the expression using the standard compilation method (`compileC`) and then adds an `Eval` instruction to ensure the value is in WHNF. This function is used to implement strictness analysis.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-3.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nelse\n  compileC e ++ [Eval]\n```\n\n----------------------------------------\n\nTITLE: Suggestion: Using ignore() on a Local Function\nDESCRIPTION: This snippet demonstrates the use of `ignore()` to suppress the E0001 warning for a local function `local_greeting`. This indicates that the function is intentionally defined but not directly called within its scope.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0001.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  fn local_greeting() -> String {\n    \"Hello, world!\"\n  }\n  ignore(local_greeting)\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Pipe Usage in MoonBit\nDESCRIPTION: Illustrates the E4101 error in MoonBit that arises when an unsupported expression, such as a lambda or method call, is used after the pipe operator. The code defines a type `T`, a method `m`, and a function `f` demonstrating the error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4101.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntype T Int\n\nfn m(self: T, x: Int) -> Unit {\n  println(self._ + x)\n}\n\npub fn f(t: T, x: Int) -> Unit {\n  x |> fn(x: Int) { println(x)}\n//     ^^^^^^^^^^^^^^^^^^^^^^^^ Error: Unsupported expression after the pipe operator.\n  x |> t.m()\n//     ^^^^ Error: Unsupported expression after the pipe operator.\n}\n```\n\n----------------------------------------\n\nTITLE: Solution 1: Add Type Annotations to Function Parameters\nDESCRIPTION: Fixes the E0013 error by adding explicit type annotations to the parameters of local functions, allowing the compiler to infer the correct types. This resolves the ambiguity that leads to the error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0013.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f1() -> Unit {\n  fn f(x: Option[Int]) {\n    match x {\n      None => ()\n      Some(a) => println(a)\n    }\n  }\n  f(None)\n}\n\npub fn f2() -> Unit {\n  fn f(x : Array[Int]) -> Int {\n    x.length()\n  }\n  println(f([]))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Multi-line String Interpolation in MoonBit\nDESCRIPTION: This code snippet demonstrates multi-line string interpolation in MoonBit. Multi-line strings do not support interpolation by default, but you can enable interpolation for a specific line by changing the leading `#|` to `$|`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_10\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main() {\n  let version : String = \"0.1.0\"\n  let info : String = $|\\nThis is MoonBit version {version}.\\nIt is a programming language.\\n|\n  println(info)\n}\n```\n\n----------------------------------------\n\nTITLE: Fix: Explicit Type Annotation in MoonBit\nDESCRIPTION: Shows how to fix the type inference and public definition annotation errors in MoonBit by explicitly specifying the type of the variable. The examples demonstrate annotating the type for both local variables and public variables accessed from other packages.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4074.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\nlet a : Int = 1 + 1\n```\n\nLANGUAGE: moonbit\nCODE:\n```\npub let value : Double = @a.value\n```\n\n----------------------------------------\n\nTITLE: Implementing op_get for Map Pattern Matching in MoonBit\nDESCRIPTION: This code snippet provides the suggested solution to resolve the E4118 error by implementing the `op_get` method for the custom `MyMap` type. The `op_get` method takes the map and a key as input and returns an optional value. This enables map pattern matching to work correctly with the custom type.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4118.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn MyMap::op_get[K: Eq + Hash, V](self : MyMap[K, V], key : K) -> V? {\n  self._[key]\n}\n```\n\n----------------------------------------\n\nTITLE: Trait Method Definition with Dynamic Dispatch in MoonBit\nDESCRIPTION: This code snippet provides a suggested solution for the problem of defining a trait method that can handle different types. Instead of using generics, it utilizes dynamic dispatch by accepting a `&Show` trait object as an argument. This allows the `stringify` method to work with any type that implements the `Show` trait. This approach circumvents the limitation of generic methods within trait definitions.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4004.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait Stringer {\n  stringify(Self, &Show) -> String\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Segment Tree Node in MoonBit\nDESCRIPTION: This snippet defines the basic structure of a segment tree node in MoonBit. It includes a `Node` variant with an integer value and left/right child nodes, and a `Nil` variant representing an empty tree.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/segment-tree/segment-tree.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nenum Node {\n  Nil\n  Node(Int, Node, Node)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Wasm GC Backend JS String Builtin Configuration\nDESCRIPTION: This JSON snippet shows how to enable the JS String Builtin Proposal for the Wasm GC backend using the `use-js-builtin-string` option in the `link` section of a `moon.pkg.json` file. It will make the `String` in MoonBit equivalent to the `String` in JavaScript host runtime.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/package.md#_snippet_7\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"link\": {\n      \"wasm-gc\": {\n        \"use-js-builtin-string\": true\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Module Description Configuration in moon.mod.json\nDESCRIPTION: Specifies the 'description' field in the moon.mod.json file, providing a human-readable description of the module's purpose and functionality.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/module.md#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"description\": \"This is a description of the module.\"\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit: PushArg Instruction Implementation\nDESCRIPTION: This MoonBit code implements the `PushArg` instruction. It retrieves the address of an argument from the stack based on the specified `offset`. It assumes that the stack contains a sequence of addresses where the first address is the super combinator and subsequent addresses are the arguments. It pushes the address of the argument at the given offset onto the stack.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_17\n\nLANGUAGE: moonbit\nCODE:\n```\n  fn push_arg(s : GState, offset : Int) -> GState {\n    match list_nth(s.stack, offset + 1) {\n      Some(addr) => { { s with stack = cons(addr, s.stack) } }\n      None => { abort(\"Arg not found\") }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Using public constructor to create struct instance in MoonBit\nDESCRIPTION: This MoonBit code demonstrates the correct way to create an instance of the struct `R` by using the public constructor `R::new`. This avoids the E4036 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4036.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nlet r : @lib.R = @lib.R::new(1)\n```\n\n----------------------------------------\n\nTITLE: Compile Binary Operations\nDESCRIPTION: This snippet compiles binary operations by looking up the corresponding instruction in the `builtinOpS` hash table. It compiles the two operands using `compileC`, then retrieves the appropriate instruction and appends it to the instruction list.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-3.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\n| App(op, [e1, e2]) =>\n  match builtinOpS.get(op) with\n    | Some instr => compileC e1 ++ compileC e2 ++ [instr]\n    | None => compileC (App(op, [e1, e2])) ++ [Eval]\n```\n\n----------------------------------------\n\nTITLE: Modify Unwind Instruction for NGlobal\nDESCRIPTION: This snippet modifies the `Unwind` instruction's behavior for the `NGlobal` branch. When the number of arguments is insufficient and the dump contains saved stacks, it retains the original redex and restores the stack, ensuring correct handling of partial applications. This change is crucial for the context-based compilation strategy to work correctly with higher-order functions.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-3.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\n| NGlobal sym num_args =>\n  if args.length < num_args && not dump.is_empty() then\n    let (stack_top, new_dump) = dump.pop()\n    {\n      stack: stack_top,\n      dump: new_dump,\n      globals: globals,\n      code: [Unwind],\n      arg_stack: arg_stack\n    }\n  else\n    let global_code = globals[sym].code\n    {\n      stack: args,\n      dump: dump,\n      globals: globals,\n      code: global_code,\n      arg_stack: arg_stack\n    }\n```\n\n----------------------------------------\n\nTITLE: MoonBit Suggestion 2: Binding a Field\nDESCRIPTION: This snippet demonstrates how to correct the E3016 error by binding the value of the `b` field to a variable `c` using `b=c`. This allows access to the value of `b` within the match block.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3016.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nenum A {\n  A(b~ : Int)\n}\n\nfn main {\n  match A(b=1) {\n    A(b=c) => {\n      println(\"Hello, world! \\{c}\")\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Coordinate Conversion to Integer Index in Rust\nDESCRIPTION: This Rust function converts a Sudoku grid coordinate (e.g., \"A1\") to an integer index (0-80). It checks if the input string is a valid coordinate and then calculates the index based on the row and column.  The function also uses a helper function `in` to validate if the characters are within the expected ranges. It will `abort` if an invalid coordinate is given.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/sudoku/index.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// A1 => 0, A2 => 1\nfn square_to_int(s : String) -> Int {\n  if in(s[0], 'A', 'I') && in(s[1], '1', '9') {\n    let row = s[0].to_int() - 65 // 'A' <=> 0\n    let col = s[1].to_int() - 49 // '1' <=> 0\n    return row * 9 + col\n  } else {\n    abort(\"square_to_int(): \\{s} is not a square\")\n  }\n}\n\n// Helper function `in` checks if a character is between `lw` and `up`\nfn in(this : Char, lw : Char, up : Char) -> Bool {\n  this >= lw && this <= up\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Record Initialization in MoonBit\nDESCRIPTION: This MoonBit code snippet demonstrates a scenario that triggers the E4034 error. The compiler cannot infer the intended record type because multiple structs have the same field names and types. This ambiguity results in a compilation error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4034.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  struct S { x : Int; y : Int }\n  struct T { x : Int; y : Int }\n  let c = { x: 2, y: 1 }\n}\n```\n\n----------------------------------------\n\nTITLE: Compile Let/Letrec Expressions\nDESCRIPTION: This snippet handles the compilation of `let` and `letrec` expressions in a strict context.  It utilizes the `compileLet` and `compileLetrec` functions to compile the main expression within the let binding using compileE, ensuring strict evaluation.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-3.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\n| LetRec defs body => compileLetrec defs (compileE body)\n| Let defs body => compileLet defs (compileE body)\n```\n\n----------------------------------------\n\nTITLE: Erroneous MoonBit Code: Incorrect Attribute Usage\nDESCRIPTION: This MoonBit code demonstrates the E4121 error.  The error occurs because the `!`, `?`, and `!!` attributes are incorrectly used on the `IntErr` constructor and the `square` function, which does not raise errors. The attributes are removed in the suggestion section.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4121.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nenum Err {\n  IntErr(Int)\n}\n\nfn square(x: Int) -> Int {\n  x * x\n}\n\nfn main {\n  IntErr!(1) |> ignore() // Error: The attribute `!` cannot be used on constructors.\n  IntErr?(2) |> ignore() // Error: The attribute `?` cannot be used on constructors.\n  IntErr!!(3) |> ignore() // Error: The attribute `!!` cannot be used on constructors.\n  square!(1) |> ignore() // Error: The attribute `!` cannot be used on application that does not raise errors\n  square?(2) |> ignore() // Error: The attribute `?` cannot be used on application that does not raise errors\n}\n```\n\n----------------------------------------\n\nTITLE: While Loop with Else Clause in MoonBit\nDESCRIPTION: This snippet demonstrates a `while` loop with an `else` clause in MoonBit. The `else` clause is executed when the loop condition becomes false and the loop terminates normally (not by `break`).\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_55\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  var i = 0\n  while i < 3 {\n    debug(i)\n    i = i + 1\n  } else {\n    debug(\"loop finished\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Generic Type Definition in MoonBit\nDESCRIPTION: This MoonBit code snippet demonstrates the error E4000 where the same type variable name 'T' is used twice in the generic type definition of the 'Container' struct. This will cause a compilation error because each type parameter must have a unique name. Also, the function transform attempts to use the same variable name 'A' twice.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4000.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Container[T, T] {\n  value : T\n}\n\nfn transform[A, A](x : A) -> A {\n  x\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling Super Combinators with compile_sc - MoonBit\nDESCRIPTION: This code snippet defines the `compile_sc` function, which is responsible for compiling super combinators. It outlines the initial stack setup required before executing the compiled super combinator, including the NGlobal node and N addresses pointing to App nodes. The function maintains an environment to track parameter positions and includes the number of parameters N for clearing the stack after instantiation.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_21\n\nLANGUAGE: moonbit\nCODE:\n```\nfn compile_sc(name : String, args : List[String], body : Expr) -> Code {\n  // Compilation logic for super combinators\n  // This is a placeholder, replace with actual implementation\n  Code::Nil\n}\n```\n\n----------------------------------------\n\nTITLE: Using Failure for Trivial Errors in MoonBit\nDESCRIPTION: This snippet demonstrates the use of the `Failure` error type for handling trivial errors. It shows how to raise a `Failure` when a specific condition is met, such as division by zero.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_26\n\nLANGUAGE: moonbit\nCODE:\n```\nfn div_trivial(x : Int, y : Int) -> Int!Failure {\n  if y == 0 {\n    raise Failure(\"division by zero\")\n  }\n  x / y\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Inline Function in MoonBit (Wasm/Wasm GC)\nDESCRIPTION: This snippet demonstrates how to write an inline function using Wasm syntax within MoonBit for the Wasm and Wasm GC backends.  The function is defined directly using Wasm instructions.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/ffi.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nextern \"wasm\" fn identity(d : Double) -> Double =\n  #|(func (param f64) (result f64))\n```\n\n----------------------------------------\n\nTITLE: MoonBit Module Definition\nDESCRIPTION: Defines a simple MoonBit module 'a' with a public variable 'value' initialized to a floating-point number.  This showcases the context for the subsequent error example involving cross-package references.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4074.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\npub let value = 1.0\n```\n\n----------------------------------------\n\nTITLE: Enum with Labelled Arguments - Usage in MoonBit\nDESCRIPTION: Illustrates how to construct and use enum variants with labelled arguments in a `main` function. This example creates different `Message` enum instances and then processes them.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_84\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let quit = Quit\n  let move = Move { x: 10, y: 20 }\n  let write = Write { text: \"Hello, MoonBit!\" }\n\n  process_message(quit)\n  process_message(move)\n  process_message(write)\n}\n```\n\n----------------------------------------\n\nTITLE: Duplicate Method Definition in MoonBit\nDESCRIPTION: This code snippet demonstrates the E4056 error in MoonBit, which arises when a method is defined twice for the same struct (Point in this case). The compiler flags the second definition as an error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4056.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Point {\n  x: Int\n  y: Int\n}\n\nfn Point::to_string(self : Point) -> String {\n  \"(\" + self.x.to_string() + \",\" + self.y.to_string() + \")\"\n}\n\nfn Point::to_string(self : Point) -> String {\n  \"<\" + self.x.to_string() + \",\" + self.y.to_string() + \">\"\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Shortest Edit Path Length in MoonBit\nDESCRIPTION: This code defines the `shortest_edit` function in MoonBit, which calculates the length of the shortest edit path between two arrays of `Line` structs using the Myers diff algorithm. It initializes the search space and uses a loop to iterate over possible edit distances.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\nfn shortest_edit(old~ : Array[Line], new~ : Array[Line]) -> Int {\n  let n = old.length()\n  let m = new.length()\n  let max = n + m\n  let v = BPArray::make(2 * max + 1, 0)\n  for d = 0; d < max + 1; d = d + 1 {\n    for k = -d; k < d + 1; k = k + 2 {\n    ......\n    }\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Corrected Type Matching Example in MoonBit\nDESCRIPTION: This code snippet presents a corrected version of the previous example, resolving the E4014 error.  The function `fst` now returns `a` of type `X`, which matches the declared return type `X` of the function.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4014.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn fst[X, Y] (a: X, b: Y) -> X {\n  a\n}\n```\n\n----------------------------------------\n\nTITLE: Trait Object Methods\nDESCRIPTION: This snippet demonstrates how to define new methods for trait objects, similar to defining methods for structs and enums. It showcases extending the functionality of trait objects.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_20\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait Foo {\n  bar(Self) -> Int\n}\n\nfn f(x: &Foo) -> Int {\n  x.bar()\n}\n\nstruct A {}\nimpl Foo for A {\n  fn bar(self: Self) -> Int { 1 }\n}\n\nfn main() {\n  let a: A = A{};\n  debug(f(&a))\n}\n```\n\n----------------------------------------\n\nTITLE: Error Inference Example\nDESCRIPTION: This code shows how the compiler infers `Error` as the common error type within a `try` block when multiple error types can be raised, and how to use a wildcard in the `catch` block.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_12\n\nLANGUAGE: moonbit\nCODE:\n```\ntype! E1\ntype! E2\nfn f1() -> Unit!E1 { raise E1 }\nfn f2() -> Unit!E2 { raise E2 }\nfn f() -> Unit! {\n  try {\n    f1!()\n    f2!()\n  } catch {\n    _ => println(\"Error occurred\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Constructor Ambiguity in MoonBit\nDESCRIPTION: This MoonBit code demonstrates the solution to the E4124 error. By explicitly specifying the enum type before the constructor name (e.g., `A::A(1)`), the ambiguity is resolved, and the compiler knows which constructor to use. This allows the program to compile and execute successfully.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4124.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let a = A::A(1)\n}\n```\n\n----------------------------------------\n\nTITLE: Function Application in MoonBit\nDESCRIPTION: This code demonstrates how to apply a function to a list of arguments in parentheses in MoonBit. It shows that any expression that evaluates to a function value is applicable.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_34\n\nLANGUAGE: moonbit\nCODE:\n```\nlet add3 = fn(x, y, z) { x + y + z }\nIO::println(add3(1, 2, 7))\n```\n\n----------------------------------------\n\nTITLE: Complete Match Example - MoonBit\nDESCRIPTION: This MoonBit code snippet demonstrates a corrected version of the partial match example. This example shows how a corrected example would look like with the suggestion to add missing cases.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0011.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  match Some(1) {\n    Some(x) => println(x)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: E_Constr_Case Compilation Definition in MoonBit\nDESCRIPTION: This MoonBit code defines the compilation logic for `case` expressions involving constructors (`E_Constr_Case`) within the `compileE` function. It handles pattern matching on data constructors. Since the object matched by the `case` expression needs to be evaluated to WHNF, it is compiled within `compileE`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-3.md#_snippet_12\n\nLANGUAGE: moonbit\nCODE:\n```\n/* start e_constr_case definition */\n  | E_Constr_Case(e, cases) => {\n    val addr = fresh();\n    val labels = cases.map(c => fresh_label());\n    acc.push(Grab addr);\n    compileE(e, env, acc);\n    acc.push(CaseJump labels);\n    cases.zip(labels).iter((c, label) => {\n      acc.push(LabelDef label);\n      match c {\n        (pattern, body) => {\n          // pattern: (Constr, List[Bind])\n          match pattern {\n            (Constr(name, binders), exp) => {\n              if (binders.length != 0) {\n                acc.push(Split { fail : fresh_label() });\n                binders.iteri((i, name) => {\n                  acc.push(GrabOffset { offset : i, addr : env.get(name).get() });\n                });\n                compileE(exp, env, acc);\n              } else {\n                compileE(exp, env, acc);\n              }\n            }\n          }\n        }\n      }\n    });\n    acc;\n  }\n  /* end e_constr_case definition */\n```\n\n----------------------------------------\n\nTITLE: Invalid Constant Declaration MoonBit\nDESCRIPTION: This code snippet demonstrates an attempt to declare a constant `A` of type `Array[Int]` and initializes it with a list of integers. This is an erroneous example because arrays are not considered immutable primitive types in MoonBit, and therefore cannot be declared as constants.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4143.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nconst A : Array[Int] = [1, 2, 3] // Error: Not a valid constant type, only immutable primitive types are allowed.\n```\n\n----------------------------------------\n\nTITLE: Reifying G-Machine Result with reify - MoonBit\nDESCRIPTION: The `reify` function continuously executes the `step` function until the final state is reached. This function orchestrates the execution of the G-Machine by repeatedly calling `step` until the machine halts, effectively reducing the expression to its final result.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_26\n\nLANGUAGE: moonbit\nCODE:\n```\nfn reify() {\n  // This is a placeholder function for G-Machine reification.\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Code Block in MoonBit\nDESCRIPTION: This code snippet illustrates the basic structure of a code block in MoonBit. It consists of statements that are executed sequentially, followed by an optional expression whose value becomes the return value of the code block. If the expression is omitted, the code block returns `()` of type `Unit`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/moonbit-tour/tour/zh/chapter1_basics/lesson4_block/index.md#_snippet_0\n\nLANGUAGE: MoonBit\nCODE:\n```\n{\n  statement1\n  statement2\n  expression\n}\n```\n\n----------------------------------------\n\nTITLE: Solution: Using Derived Implementation by removing manual one\nDESCRIPTION: Illustrates how to resolve the E4079 error by removing the manual implementation of the `Show` trait, allowing the compiler to derive it automatically for type `A`. This ensures that only the derived implementation is used.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4079.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\n// Remove the manual implementation\n// impl Show for A with output(self : A, logger : &Logger) -> Unit {\n//   logger.write_object(self._)\n// }\n\ntype A Int derive(Hash, Show)\n```\n\n----------------------------------------\n\nTITLE: Closed Matching Map Pattern with Pattern Guard in MoonBit\nDESCRIPTION: Illustrates the correct way to achieve closed matching in MoonBit using a pattern guard. This approach ensures that the map contains only the specified keys by checking the map's size.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0041.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(map : Map[String, Int]) -> Unit {\n  match map {\n    { \"x\": x, \"y\": y, .. } if map.size() == 2 => println(x + y)\n    _ => ()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Tuple Index Out of Bounds - Erroneous Example - MoonBit\nDESCRIPTION: This MoonBit code snippet demonstrates the E4089 error. It attempts to access the third element (index 2) of a tuple that only has two elements, leading to a compilation error. The tuple is defined as (1, 2) and the code tries to print tuple.2.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4089.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let tuple = (1, 2)\n  println(tuple.2)\n}\n```\n\n----------------------------------------\n\nTITLE: C_Constr Compilation Definition in MoonBit\nDESCRIPTION: This MoonBit code defines the compilation logic for constructors (`C_Constr`) within the `compileC` function. It generates instructions to construct data structures based on their constructors. It is essential for handling custom data types like lazy lists during the compilation process.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-3.md#_snippet_11\n\nLANGUAGE: moonbit\nCODE:\n```\n/* start c_constr definition */\n  | C_Constr(name, args) => {\n    args.iter(arg => {\n      compileC(arg, env, acc);\n    });\n    acc.push(Pack);\n  }\n  /* end c_constr definition */\n```\n\n----------------------------------------\n\nTITLE: Zsh Completion Installation (Add to .zshrc)\nDESCRIPTION: Adds the custom directory to the fpath in the .zshrc file.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/commands.md#_snippet_5\n\nLANGUAGE: zsh\nCODE:\n```\nfpath+=~/.zfunc\n```\n\n----------------------------------------\n\nTITLE: While Loop with Return and Break MoonBit\nDESCRIPTION: Illustrates the return behavior of a while loop with break and else clause in Moonbit, showcasing different scenarios.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_57\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  var i = 0\n  while i < 3 {\n    i = i + 1\n    if i == 2 { break 100 }\n  } else {\n    0\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling User Preset Alerts\nDESCRIPTION: This JSON snippet demonstrates how to disable user-defined alerts using the `alert-list` configuration in `moon.pkg.json`.  The alerts are disabled by listing their names with a leading minus sign. Here, `alert_1` and `alert_2` are disabled.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/package.md#_snippet_19\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"alert-list\": \"-alert_1-alert_2\"\n}\n```\n\n----------------------------------------\n\nTITLE: Define a Constant Enum with Custom Tag Values in MoonBit\nDESCRIPTION: This snippet demonstrates a valid constant enum `Flag` in MoonBit where each constructor (A, B, C) is explicitly assigned a custom integer value.  This is allowed because the enum is constant, meaning none of the constructors have payloads.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4154.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nenum Flag {\n  A = 1\n  B = 2\n  C = 3\n}\n```\n\n----------------------------------------\n\nTITLE: Rearranging Stack for Supercombinator Parameters in MoonBit\nDESCRIPTION: This MoonBit code snippet defines the `rearrange` function which adjusts the stack before calling a supercombinator.  It takes the top N addresses on the stack, assuming they point to NApp nodes, keeps the bottommost one for Redex update, cleans up the top N-1 addresses, and places N addresses pointing directly to the parameters. This allows accessing parameters and local variables in a consistent way.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-2.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn rearrange(state: GState, n: Int) -> GState {\n  let addr = state.stack.last()\n  let new_stack = list::drop_last(state.stack)\n  let new_stack = list::drop(new_stack, n - 1)\n  let new_stack = list::push(new_stack, addr)\n  let new_stack = list::append(new_stack, list::take(state.stack, n))\n  { state with stack = new_stack }\n}\n```\n\n----------------------------------------\n\nTITLE: Using fail! for Error Reporting in MoonBit\nDESCRIPTION: This snippet displays the use of the `fail!` macro for reporting errors with source location information. It shows the definition of `fail` and emphasizes its preference over directly using the `Failure` constructor.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_27\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn fail[T](msg : String, ~loc : SourceLoc = _) -> T!Failure {\n  raise Failure(\"FAILED: \\{loc} \\{msg}\")\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Type/Trait Usage with `Bool` in MoonBit\nDESCRIPTION: This snippet illustrates another possible correction utilizing the type `Bool`. This requires `Bool` to define or implement the `to_string` method.  This snippet showcases the appropriate usage of the `Bool` type.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4024.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nlet a = Bool::to_string(true)\n```\n\n----------------------------------------\n\nTITLE: Erroneous Enum Constructor with Visibility Modifiers (MoonBit)\nDESCRIPTION: This MoonBit code snippet demonstrates the E3006 error.  It attempts to declare an enum `A` where the constructors `A1` and `A2` are given individual visibility modifiers (`priv` and `pub`). This is not allowed in MoonBit. The code will result in a compiler error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3006.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nenum A {\n  priv A1 // Error: No individual visibility for enum constructor.\n  pub A2 // Error: No individual visibility for enum constructor.\n}\n```\n\n----------------------------------------\n\nTITLE: Alert List Configuration in moon.mod.json\nDESCRIPTION: Configures the `alert-list` to disable specific user-defined alerts. In this example, `alert_1` and `alert_2` are disabled.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/module.md#_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"alert-list\": \"-alert_1-alert_2\"\n}\n```\n\n----------------------------------------\n\nTITLE: Enum with Custom Tag Values in MoonBit\nDESCRIPTION: This MoonBit code defines an enum named `Flag` where each constructor has an explicitly assigned integer value as its tag. This demonstrates the custom tag feature for enums in MoonBit.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4153.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nenum Flag {\n  A = 1\n  B = 2\n  C = 3\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Record Field Access in MoonBit\nDESCRIPTION: This MoonBit code snippet demonstrates the correct way to update a record. It defines a record type `T` with a single field `a`. The code updates the existing field `a` within record `t` when creating record `u`, avoiding the E4030 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4030.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct T { a : Int }\nlet t : T = { a: 42 }\nlet u : T = { ..t, a: 43 }\n```\n\n----------------------------------------\n\nTITLE: Changing Return Type to Unit (Alternative Solution)\nDESCRIPTION: This example demonstrates an alternative solution to the E4108 error: changing the function's return type to `Unit`. This is appropriate if the loop is not intended to return a value.  In this case the function performs an action via the for loop, but does not need to explicitly return any value.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4108.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn g(x: Int) -> Unit {\n  for i in 0..=x {\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Define Moonbit Package (Main) - Corrected\nDESCRIPTION: This JSON file defines a corrected Moonbit main package configuration, removing the unused import to resolve the E0029 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0029.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\n{\n  \"is-main\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Segment Tree Data Structure in MoonBit\nDESCRIPTION: This code defines the segment tree data structure using an `enum` with labeled arguments. It includes `Data`, `Tag`, and `Length` attributes for clearer initialization and pattern matching. The `Data` type is abstracted with a `len` attribute to represent the length of the current range.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/segment-tree/segment-tree2.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nenum Node[Data, Tag] {\n  Leaf(Data)\n  Node {\n    left: Node[Data, Tag],\n    right: Node[Data, Tag],\n    data: Data,\n    tag: Tag,\n    len: Int\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Native Backend Linker Flags Configuration\nDESCRIPTION: This JSON snippet demonstrates how to configure the `cc-link-flags` option for the native backend in the `link` section of a `moon.pkg.json` file. It passes the `-s` flag to the linker to strip symbol information from the produced binary.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/package.md#_snippet_13\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"link\": {\n      \"native\": {\n        \"cc-link-flags\": \"-s\"\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Sending Coverage Report to Coveralls via GitHub Actions\nDESCRIPTION: This snippet shows an example of using the `moon coverage report` command in a GitHub Actions workflow to send a Coveralls JSON report to Coveralls. It includes setting environment variables and using command-line arguments to specify the service name, job ID, and pull request number. The `COVERALLS_REPO_TOKEN` secret must be configured in the GitHub repository settings.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/coverage.md#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nmoon coverage report \\\n    -f coveralls \\\n    -o codecov_report.json \\\n    --service-name github \\\n    --service-job-id \"$GITHUB_RUN_NUMBER\" \\\n    --service-pull-request \"${{ github.event.number }}\" \\\n    --send-to coveralls\n\nenv:\n    COVERALLS_REPO_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```\n\n----------------------------------------\n\nTITLE: Unused Generic Type Variable Example (Erroneous)\nDESCRIPTION: This MoonBit code demonstrates the E0005 error: an unused generic type variable 'T' in the 'Foo' struct. This can lead to type inference issues when creating instances of the struct.  The example shows how the type checker might infer a placeholder type `_/0` instead of `Int` leading to potential unexpected runtime behavior. It requires a MoonBit compiler to execute.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0005.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Foo[T] { // Warning: Unused type variable 'T'.\n  bar : Int\n}\n\nfn main {\n  let foo : Foo[Int] = { bar : 42 }\n  let baz = { bar : 42 } // Warning: The type of this expression is Foo[_/0]\n  println(foo.bar)\n  println(baz.bar)\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Code Coverage in Tests with Moon Test\nDESCRIPTION: This snippet shows how to enable code coverage instrumentation when running Moonbit tests.  It requires the `moon` command-line tool to be installed and the project to be a valid Moonbit project. The command recompiles the project if it wasn't previously compiled with coverage enabled, and generates coverage result files under the `target` directory.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/coverage.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ moon test --enable-coverage\n...\nTotal tests: 3077, passed: 3077, failed: 0.\n```\n\n----------------------------------------\n\nTITLE: Example `moon.pkg.json` File\nDESCRIPTION: This is an example of a `moon.pkg.json` file, which is used for package configuration in MoonBit. The contents of the file are not shown inline but are included via a literal include.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/introduction.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{literalinclude} /sources/language/src/main/moon.pkg.json\n:language: json\n:caption: moon.pkg.json\n```\n\n----------------------------------------\n\nTITLE: Run all MoonBit tests\nDESCRIPTION: Runs all tests in the project, including inline tests and tests in files ending with `_test.mbt`. The `-v` option provides verbose output.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/tutorial.md#_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\n$ moon test\nTotal tests: 3, passed: 3, failed: 0.\n$ moon test -v\ntest username/hello/lib/hello_test.mbt::hello ok\ntest username/hello/lib/fib/a.mbt::0 ok\ntest username/hello/lib/fib/fib_test.mbt::0 ok\nTotal tests: 3, passed: 3, failed: 0.\n```\n\n----------------------------------------\n\nTITLE: Fixing Unused Pattern by Refining - MoonBit\nDESCRIPTION: This code shows another way to fix the E0010 error by refining the first pattern to exclude what the second pattern covers.  Instead of using the wildcard `_`, it uses `None` to match only the `None` case, allowing the `Some(a)` pattern to match the `Some` case.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0010.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  match Some(1) {\n    None => println(\"_\")\n    Some(a) => println(\"Some({a})\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit for loop example\nDESCRIPTION: This snippet illustrates the general structure of a for loop in MoonBit. It consists of an initialization section, a condition expression, and an increment expression, followed by the loop body. The loop continues as long as the condition expression evaluates to true.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/moonbit-tour/tour/zh/chapter1_basics/lesson10_loop/index.md#_snippet_0\n\nLANGUAGE: MoonBit\nCODE:\n```\nfor 初始化; 条件; 增量 {\n    // 循环体\n}\n```\n\n----------------------------------------\n\nTITLE: Package definition for package a - JSON\nDESCRIPTION: This JSON code defines an empty package configuration for the MoonBit package 'a'.  It doesn't import any other packages.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4061.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{}\n```\n\n----------------------------------------\n\nTITLE: Defining a Combined Trait in Moonbit\nDESCRIPTION: This snippet shows how to create a new trait called `ByteWordSize` which combines the `byte_size()` and `word_size()` methods, addressing the issue of inconsistent trait implementations by creating a unified interface. Types must then manually implement this combined trait.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4135.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait ByteWordSize {\n  byte_size() -> Int\n  word_size() -> Int\n}\n```\n\n----------------------------------------\n\nTITLE: Using Let Expression in Moonbit\nDESCRIPTION: Demonstrates replacing a useless `guard let` with a simple `let` expression. The `let _ = input` statement assigns the value of `input` to a wildcard variable. `input` is expected to be an optional Int (`Int?`).\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0038.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(input : Int?) -> Int {\n  let _ = input\n  3\n}\n```\n\n----------------------------------------\n\nTITLE: Array Type Inference in MoonBit\nDESCRIPTION: This code demonstrates how MoonBit can automatically infer the array type when the expected type is known. Otherwise, `Array[T]` is created.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_26\n\nLANGUAGE: moonbit\nCODE:\n```\nlet a = [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Missing Parameter List in Moonbit\nDESCRIPTION: This snippet shows the error E3004 that occurs when a function definition in Moonbit lacks a parameter list. The function `greet` is defined without parentheses, causing the compiler to report a missing parameter list error. There are no dependencies.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3004.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn greet { // Error: Missing parameters list. Add `()` if function `greet` has 0 parameter.\n  println(\"Hello, world!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Correct MoonBit Pattern Match with `..` Placement\nDESCRIPTION: This snippet shows the correct way to use `..` in a MoonBit pattern match for struct destructuring. The `..` is placed at the end of the pattern to indicate that the remaining fields should be ignored, resolving the E3007 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3007.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\n// ...\nfn main {\n  // ...\n  let { a, c, .. } = s\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Error Type\nDESCRIPTION: This snippet demonstrates how to pattern match on the `Error` type using the wildcard `_` to catch any error types.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\nfn handle_error(e : Error) {\n  match e {\n    _ => println(\"Error occurred\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit: Derive Show for ExamResult\nDESCRIPTION: This code uses the `derive(Show)` macro in MoonBit to automatically generate an implementation of the `Show` trait for the `ExamResult` enum.  This simplifies the process of making `ExamResult` printable, as the implementation is automatically generated.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/tutorial/tour.md#_snippet_11\n\nLANGUAGE: moonbit\nCODE:\n```\nenum ExamResult {\n  Pass\n  Fail\n} derive(Show)\n```\n\n----------------------------------------\n\nTITLE: Valid Extern C Function Name MoonBit\nDESCRIPTION: This code snippet demonstrates the correct way to declare an external C function using `extern \"C\"` in MoonBit. The function name `f1()` is a valid C identifier and is used correctly in the context of binding to an external C function or symbol.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4140.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nextern \"C\" fn f1() = \"f1\"\n```\n\n----------------------------------------\n\nTITLE: Rethrowing Errors with !\nDESCRIPTION: This snippet illustrates how to rethrow an error directly using the `!` operator in a function application.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\nfn bar() -> Unit! {\n  foo!()\n}\n```\n\n----------------------------------------\n\nTITLE: Define Moonbit Main Function\nDESCRIPTION: This Moonbit code defines an empty main function, indicating that the imported package is not actually being used within the main application.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0029.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected MoonBit Trait Implementation\nDESCRIPTION: This MoonBit code shows the correct implementation of the trait `A` for type `T`. The method `f` in the `impl` block has the same type `(T) -> Int` as defined in the trait, resolving the type mismatch error. This ensures the method signature matches the trait's expectation.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4060.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nimpl A for T with f(self : T) -> Int {\n  ignore(self)\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Example: Removing Public Modifier from Default Trait Implementation (Moonbit)\nDESCRIPTION: This code snippet shows the correct way to define a default trait implementation in Moonbit. It removes the `pub` (public) modifier from the implementation, allowing it to inherit the visibility of the trait itself. The `impl` block for the `Stringer` trait no longer has the `pub` keyword.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4010.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub(open) trait Stringer {\n  stringify(Self) -> String\n}\n\nimpl Stringer with stringify(_self) { \"hey\" }\n```\n\n----------------------------------------\n\nTITLE: `for .. in` Loop with Control Flow in MoonBit\nDESCRIPTION: This example showcases control flow operations (`return`, `break`) within a `for .. in` loop in MoonBit.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_66\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let arr = [1, 2, 3, 4, 5]\n  for elem in arr {\n    if elem == 3 { break }\n    debug(elem)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation Targets in moon.pkg.json\nDESCRIPTION: This JSON snippet shows how to use the `targets` field in a `moon.pkg.json` file to specify conditional compilation for different files based on backend and optimization level. The expressions can include `and`, `or`, and `not` operators for defining complex conditions.  If a file is not listed in `targets`, it will be compiled under all conditions by default.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/package.md#_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"targets\": {\n    \"only_js.mbt\": [\"js\"],\n    \"only_wasm.mbt\": [\"wasm\"],\n    \"only_wasm_gc.mbt\": [\"wasm-gc\"],\n    \"all_wasm.mbt\": [\"wasm\", \"wasm-gc\"],\n    \"not_js.mbt\": [\"not\", \"js\"],\n    \"only_debug.mbt\": [\"debug\"],\n    \"js_and_release.mbt\": [\"and\", [\"js\"], [\"release\"]],\n    \"js_only_test.mbt\": [\"js\"],\n    \"js_or_wasm.mbt\": [\"js\", \"wasm\"],\n    \"wasm_release_or_js_debug.mbt\": [\"or\", [\"and\", \"wasm\", \"release\"], [\"and\", \"js\", \"debug\"]]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving Eq and Compare for Structs in MoonBit\nDESCRIPTION: This example demonstrates deriving the `Eq` and `Compare` traits for a struct in MoonBit. The generated methods enable equality testing and comparison between instances of the struct. Fields are compared in the order they are defined within the struct.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/derive.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Point { x: Int; y: Int } derive(Eq, Compare)\n\nfn main() {\n  let p1 = Point { x: 1, y: 2 }\n  let p2 = Point { x: 1, y: 2 }\n  let p3 = Point { x: 2, y: 3 }\n\n  println(\"{}\", p1 == p2) // prints \"true\"\n  println(\"{}\", p1 == p3) // prints \"false\"\n  println(\"{}\", p1 < p3)  // prints \"true\"\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected For-Loop Declaration Moonbit\nDESCRIPTION: This code snippet provides a corrected version of the previous example, resolving the E4107 error. It changes the second variable declaration from 'i' to 'j' within the for-loop initialization. This ensures that all variables declared in the initialization block have unique names, allowing the loop to function correctly.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4107.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(x: Int) -> Unit {\n  for i = 0, j = 1; i < x; i = i + 1 {\n    println(i)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Pragma Example MoonBit\nDESCRIPTION: This snippet demonstrates an incorrect usage of a pragma in MoonBit. The `@deprecated` pragma is not a valid pragma supported by the compiler, resulting in an error. This example helps identify potential mistakes in pragma usage.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0020.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\n///|\n/// @deprecated \"This function is deprecated\"\nfn f() {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Overloaded Number Literal in MoonBit\nDESCRIPTION: This code snippet demonstrates overloaded literals in MoonBit. When the expected type is known, MoonBit can automatically overload literal, and there is no need to specify the type of number via letter postfix.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(x : Int) -> Int { x }\n\nfn main() {\n  println(f(1))\n}\n```\n\n----------------------------------------\n\nTITLE: Duplicate Local Function Definition - MoonBit\nDESCRIPTION: This code snippet demonstrates the E4006 error in MoonBit, which occurs when a local function is defined with the same name within the same scope. The `helper` function is defined twice, leading to the error. To resolve, function names must be unique within their scope.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4006.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  fn helper() {\n    1 + 1\n  }\n\n  fn helper() { // E4006: local function 'helper' is already defined\n    2 + 2\n  }\n\n  helper()\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Constructor Arity in Moonbit\nDESCRIPTION: Presents the corrected code demonstrating how to properly construct and match the enum variant 'A' with the correct number of arguments (three in this case). This resolves the arity mismatch error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4080.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  match A(0, 1.0, \"foo\") {\n    A(_, _, _) => ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected MoonBit moon.pkg.json\nDESCRIPTION: A corrected `moon.pkg.json` file that includes imports for both `@middle` and `@ty` packages.  This resolves the E4037 error by ensuring all necessary packages are declared as dependencies.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4037.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"import\": [\"<PACKAGE>/middle\", \"<PACKAGE>/ty\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Moonbit Record Pattern with Wildcard\nDESCRIPTION: This code snippet shows the correct way to match any `Point` struct using the wildcard pattern `_` in a `match` statement. This resolves the E3009 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3009.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Point {\n  x: Int\n  y: Int\n}\n\nfn process_point(p: Point) -> Unit {\n  match p {\n    _ => println(\"Got a point\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Loop Label Declaration in MoonBit\nDESCRIPTION: Illustrates the E4148 error where a loop label is used in a `continue` statement but is either undeclared or declared outside the correct loop. The `continue read~` statement attempts to jump to a label that's not within the current loop's scope, resulting in an error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4148.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn read() -> @bytes.View {\n  ...\n}\n\nfn main {\n  loop read() {\n    [] => break\n    _ => continue read~ read()\n    //            ^~~~~\n    // Error: The label read is undeclared.\n  }\n  // Defining the label here does not work since continue cannot jump to a different loop.\n  read~: loop read() {\n    [] => break\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Diff Output - Good vs Bad Example\nDESCRIPTION: Illustrates the difference between a 'good' and 'bad' diff output for adding multiple lines. The 'good' example groups deletions and insertions, while the 'bad' example interleaves them.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff.md#_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\nGood:   - one         Bad:    - one\n        - two                 + four\n        - three               - two\n        + four                + five\n        + five                + six\n        + six                 - three\n```\n\n----------------------------------------\n\nTITLE: Erroneous Struct Literal in MoonBit\nDESCRIPTION: This code snippet demonstrates the erroneous use of a struct literal in MoonBit that triggers the E0022 error due to ambiguity. It declares a struct `S` with a field `value` and attempts to initialize it using `{ value }` without a trailing comma, which is interpreted as a potential block expression.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0022.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct S {\n  value : Int\n}\n\nfn main {\n  let value = 3\n  let s = { value }\n  ignore(s)\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Example: Conflicting Trait Implementations in MoonBit\nDESCRIPTION: This code demonstrates the E4062 error. It defines a trait `T`, a type `A`, and then provides both an implicit implementation (`A::f`) and an explicit `impl` block that redefines `f` for type `A`. This shadowing causes inconsistent behavior depending on where the trait is accessed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4062.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\npub(open) trait T {\n  f(Self) -> Int\n}\n\npub type A Int\n\npub fn A::f(self : A) -> Int {\n  println(\"A::f\")\n  self._\n}\n\nimpl T for A with f(self : A) -> Int {\n  //              ^\n  // Error: This `impl` shadows method f of A previously defined at ...\n  //        This will result in different implementations for T inside and outside current package.\n  println(\"impl T for A with f\")\n  self._\n}\n```\n\n----------------------------------------\n\nTITLE: Direct struct instantiation with private field (Erroneous) in MoonBit\nDESCRIPTION: This MoonBit code attempts to directly create an instance of the struct `R` defined in `lib/lib.mbt`, which results in an E4036 error because it tries to access the private field `__private`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4036.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nlet r : @lib.R = { x: 1, __private: 42 }\n```\n\n----------------------------------------\n\nTITLE: MoonBit Struct Definition in Package 'a'\nDESCRIPTION: Defines a public struct `T` with a mutable integer field `value` and a constructor `new` that initializes the field to 0. It also defines a setter method `set` to modify the value. The package `a` is part of the `username/hello` module.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4094.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub struct T {\n  mut value : Int\n}\n\npub fn T::new() -> T {\n  T::{ value: 0 }\n}\n\npub fn T::set(self : T, value : Int) -> Unit {\n  self.value = value\n}\n\n```\n\n----------------------------------------\n\nTITLE: Module Source Directory Configuration (Empty) in moon.mod.json\nDESCRIPTION: Examples showing how to default the module source directory to the directory containing `moon.mod.json` by setting the `source` field to `null`, an empty string, or `.`\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/module.md#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"source\": null\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"source\": \"\"\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"source\": \".\"\n}\n```\n\n----------------------------------------\n\nTITLE: C API for Managing External Objects in MoonBit\nDESCRIPTION: This C code defines the function `moonbit_make_external_object` that allows MoonBit to manage the lifetime of external objects/resources using its own memory management system. It also defines a `finalize` function signature which should be implemented to release external resources/memory held by the object's payload.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/ffi.md#_snippet_13\n\nLANGUAGE: c\nCODE:\n```\nvoid *moonbit_make_external_object(\n  void (*finalize)(void *self),\n  uint32_t payload_size\n);\n```\n\n----------------------------------------\n\nTITLE: Incorrect Trait Usage in Function Parameter (MoonBit)\nDESCRIPTION: This code snippet demonstrates the E4099 error where the `Eq` trait is used directly as a type annotation for a function parameter, which is invalid in MoonBit. MoonBit expects a concrete type or a trait object reference (`&Trait`) in this context. This will result in a compilation error. The function `f` attempts to take a parameter of type `Eq`, which should be `&Eq` if a trait object is intended.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4099.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\n// `Eq` is a trait, not a type\nfn f(_ : Eq) -> Unit {\n}\n\n```\n\n----------------------------------------\n\nTITLE: MoonBit Main Function in Package 'b' (Erroneous)\nDESCRIPTION: Shows an example of attempting to directly modify the `value` field of struct `T` from package 'a' within package 'b'. This results in an E4094 error because `value` is considered read-only outside package 'a'.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4094.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let a = @a.T::new()\n  a.value = 3 // Error: Cannot modify a read-only field: value\n}\n\n```\n\n----------------------------------------\n\nTITLE: Cyclic const and fnalias Declarations in MoonBit\nDESCRIPTION: This MoonBit code snippet demonstrates the E4155 error caused by cyclic dependencies in `const` and `fnalias` declarations. The constants `A` and `B` are defined in terms of each other, and similarly, function aliases `f` and `g` also refer to each other, creating a cycle.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4155.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nconst A : Int = B + 1\nconst B : Int = A + 1\n\nfnalias f = g\nfnalias g = f\n```\n\n----------------------------------------\n\nTITLE: Corrected Record Initialization in MoonBit\nDESCRIPTION: This MoonBit code snippet demonstrates the correct record initialization. It defines a struct `S` with fields `x` and `y`, and initializes a record `c` with the same fields `x` and `y`. This avoids the E4033 compiler error because all fields used in the initialization are defined in the struct `S`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4033.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  struct S { x : Int; y : Int }\n  let c = { x: 2, y: 1 }\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Suggestion 1: Ignoring a Field\nDESCRIPTION: This snippet shows how to fix the E3016 error by using `b~` to ignore the `b` field in the match expression. This is appropriate when the value of `b` is not needed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3016.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nenum A {\n  A(b~ : Int)\n}\n\nfn main {\n  match A(b=1) {\n    A(b~) => {\n      println(\"Hello, world! \\{b}\")\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Infinite For Loops in MoonBit\nDESCRIPTION: This MoonBit code showcases two examples of infinite `for` loops. The loops continue indefinitely because the conditions are omitted or always true.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_60\n\nLANGUAGE: moonbit\nCODE:\n```\nfor ; ; { }\n\nfor var i = 0; ; i = i + 1 { }\n```\n\n----------------------------------------\n\nTITLE: Example of an Object-Safe Trait in MoonBit\nDESCRIPTION: This code snippet illustrates the definition of the `Show` trait, an example of an object-safe trait in MoonBit. Its methods, such as `output` and `to_string`, only use `Self` as the type of the first parameter, thus complying with object safety requirements.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4038.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\npub(open) trait Show {\n  output(Self, &Logger) -> Unit\n  to_string(Self) -> String\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Boolean values in MoonBit\nDESCRIPTION: This code snippet demonstrates how to define boolean values (`true` and `false`) in MoonBit. Boolean values are used in conditional expressions and control structures.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nlet t : Bool = true\nlet f : Bool = false\n```\n\n----------------------------------------\n\nTITLE: main function in MoonBit\nDESCRIPTION: This MoonBit code snippet demonstrates a valid `main` function within a package configured as a main package. It prints \"Hello, world!\" to the console.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4069.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  println(\"Hello, world!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Compiler Warnings\nDESCRIPTION: This JSON snippet demonstrates how to disable specific compiler warnings using the `warn-list` configuration in `moon.pkg.json`. In this example, warning number 2 (Unused variable) is disabled by specifying `-2` in the warn-list.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/package.md#_snippet_18\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"warn-list\": \"-2\"\n}\n```\n\n----------------------------------------\n\nTITLE: Backtracking Second Part in MoonBit\nDESCRIPTION: This code shows the second part of backtracking implementation. It includes array deduplication and reversing the edit sequence\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff2.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\n  // delete duplicated adjacent Delete/Insert edit\n  fn remove_dup[T: Eq](edits: List[Edit[T]]) -> List[Edit[T]] {\n    match edits {\n      Nil => edits,\n      Cons(head, tail) => {\n        match head {\n          Insert(e1) => match tail {\n            Cons(Insert(e2), _) => remove_dup(Cons(Keep(e1), Cons(Insert(e2), tail.tail()))),\n            _ => Cons(head, remove_dup(tail)),\n          },\n          Delete(e1) => match tail {\n            Cons(Delete(e2), _) => remove_dup(Cons(Keep(e1), Cons(Delete(e2), tail.tail()))),\n            _ => Cons(head, remove_dup(tail)),\n          },\n          _ => Cons(head, remove_dup(tail)),\n        }\n      }\n    }\n  }\n\n  // reverse edit order\n  fn reverse[T](edits: List[T]) -> List[T] {\n    var result: List[T] = List::new()\n    var current = edits\n    while !current.is_empty() {\n      match current {\n        Cons(head, tail) => {\n          result = Cons(head, result)\n          current = tail\n        }\n        Nil => {}\n      }\n    }\n    result\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining Lambda Term Enum in MoonBit\nDESCRIPTION: This code snippet defines an enum type `Term` in MoonBit to represent Lambda expressions. It includes three variants: `Var` for variables, `Abs` for lambda abstractions, and `App` for function applications. The enum serves as the primary data structure for representing Lambda terms before conversion to de Bruijn indices.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/lambda/index.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nenum Term {\n  Var(String)\n  Abs(String, Term)\n  App(Term, Term)\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Immutable Variable Assignment Error in MoonBit\nDESCRIPTION: This snippet demonstrates the E4087 error in MoonBit that arises from attempting to reassign a value to a variable declared without the `mut` keyword. The code attempts to assign the value 1 to the immutable variable `a` after it's initialized to 0, triggering the error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4087.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let a = 0\n  a = 1 // Error: The variable a is not mutable.\n  println(a)\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Unused Struct Fields in MoonBit\nDESCRIPTION: This example demonstrates how to resolve the E0007 error by removing the unused field from the struct. The struct `S` is modified to have no fields.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0007.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct S {\n}\n```\n\n----------------------------------------\n\nTITLE: Lexical Closures in MoonBit\nDESCRIPTION: This code illustrates how local functions in MoonBit are lexical closures, meaning they can access variables from the surrounding lexical scope.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_33\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main() {\n  let x = 10\n  let add_x = fn(y) {\n    x + y\n  }\n  IO::println(add_x(5)) // Output: 15\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit: App data structure representing Spine\nDESCRIPTION: This MoonBit code defines a simplified abstract syntax tree using the `App` constructor to represent function application.  It demonstrates nested `App` nodes forming a \"Spine\" from `add` to the outermost `App` node. This structure arises from the default currying behavior, where functions are applied one argument at a time.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_10\n\nLANGUAGE: moonbit\nCODE:\n```\nApp(App(add, 33), App(square, 3))\n```\n\n----------------------------------------\n\nTITLE: Shortest Edit Definition in MoonBit\nDESCRIPTION: This snippet showcases the definition of the `shortest_edit` function in MoonBit, responsible for calculating the shortest edit distance between two sequences by searching a graph.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff2.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn shortest_edit[T: Eq](xs: List[T], ys: List[T]) -> Int {\n  let max_len = xs.length() + ys.length()\n  let v = Array::make(2 * max_len + 1, 0)\n  let delta = xs.length() - ys.length()\n  let max_d = xs.length() + ys.length()\n\n  // Function to check if the path reaches the end\n  fn reach_end(x: Int, y: Int, xs: List[T], ys: List[T]) -> Bool {\n    x == xs.length() && y == ys.length()\n  }\n\n  // Function to perform a free move\n  fn free_move(x: Int, y: Int, xs: List[T], ys: List[T]) -> (Int, Int) {\n    var x = x\n    var y = y\n    while x < xs.length() && y < ys.length() && xs[x] == ys[y] {\n      x += 1\n      y += 1\n    }\n    (x, y)\n  }\n\n  for d in 0..=max_d {\n    for k in -d..=d by 2 {\n      let x = if k == -d || (k != d && v[max_len + k - 1] < v[max_len + k + 1]) {\n        v[max_len + k + 1]\n      } else {\n        v[max_len + k - 1] + 1\n      }\n      let y = x - k\n\n      let (x, y) = free_move(x, y, xs, ys)\n      v[max_len + k] = x\n      if reach_end(x, y, xs, ys) {\n        return d\n      }\n    }\n  }\n  max_d\n}\n```\n\n----------------------------------------\n\nTITLE: Ambiguous Method Call in MoonBit\nDESCRIPTION: This MoonBit code demonstrates the E4017 error, where the `to_string` method call on a struct `S` is ambiguous because it is defined in both the `Show` trait (derived) and the `Tee` trait (implemented). The compiler cannot determine which trait's method to use, resulting in an error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4017.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct S { v : Int } derive(Show)\n\ntrait Tee { to_string(Self) -> String }\n\nimpl Tee for S with to_string(_self) { \"Tee\" }\n\nlet s : S = { v: 3 }\nlet t = s.to_string()\n```\n\n----------------------------------------\n\nTITLE: Coordinate System Visualization\nDESCRIPTION: Illustrative bash representation of coordinate systems k and c for forward and backward searches in Myers Diff.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff3.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n        x                       k\n                                  0     1     2     3\n        0     1     2     3         \\     \\     \\     \\\n  y  0  o-----o-----o-----o           o-----o-----o-----o\n        |     |     |     |      -1   |     |     |     | \\\n        |     |     |     |         \\ |     |     |     |   2\n     1  o-----o-----o-----o           o-----o-----o-----o\n        |     | \\   |     |      -2   |     | \\   |     | \\\n        |     |   \\ |     |         \\ |     |   \\ |     |   1\n     2  o-----o-----o-----o           o-----o-----o-----o\n                                        \\     \\     \\     \\\n                                        -3    -2    -1      0\n                                                              c\n```\n\n----------------------------------------\n\nTITLE: Erroneous Example: Unresolved Type Variables\nDESCRIPTION: Illustrates the E0013 error in MoonBit with local functions and empty collections lacking explicit type annotations. The compiler defaults unresolved type variables to `Unit`, which can lead to unexpected behavior.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0013.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f1() -> Unit {\n  fn f(x) {\n//     ^ Warning: The type of this expression is Option[_/0], which contains\n//                unresolved type variables. The type variable is default to\n//                Unit.\n    match x {\n      None => ()\n      Some(a) => println(a)\n    }\n  }\n\n  f(None)\n}\n\npub fn f2() -> Unit {\n  fn f(x : Array[_]) -> Int {\n//     ^ Warning: The type of this expression is Array[_/0], which contains\n//                unresolved type variables. The type variable is default to\n//                Unit.\n    x.length()\n  }\n\n  println(f([]))\n}\n\nfn main {\n  let a = []\n//        ^^ Warning: The type of this expression is Array[_/0], which contains\n//           unresolved type variables. The type variable is default to Unit.\n  println(a.length())\n  let b = None\n//        ^^ Warning: The type of this expression is Option[_/0], which contains\n//           unresolved type variables. The type variable is default to Unit.\n  println(b.is_empty())\n}\n\n```\n\n----------------------------------------\n\nTITLE: MoonBit Module Definition\nDESCRIPTION: Defines a MoonBit module that imports and uses functionality from the `pkgB` package. It demonstrates how to access entities from other packages using the `@pkg` syntax.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/packages.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nimport \"./pkgB\" as pkgB\n\nfn init() {\n  println(\"hello world from pkgB\")\n}\n```\n\n----------------------------------------\n\nTITLE: Compiler Warning List Configuration in moon.mod.json\nDESCRIPTION: Configures the `warn-list` field to disable specific preset compiler warnings. In this example, warning number 2 (Unused variable) is disabled by specifying `-2`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/module.md#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"warn-list\": \"-2\",\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous MoonBit Loop Pattern\nDESCRIPTION: This example demonstrates the E4103 error.  The loop takes two arguments (x and y), but the second arm only provides one pattern (a). This mismatch between the number of arguments and patterns triggers the error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4103.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(x: Int, y: Int) -> Int {\n  loop x, y {\n    0, 0 => 0\n    a => continue a - 1, 0\n//  ^ Error: This loop has 2 arguments, but 1 patterns are supplied\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Example: Accessing Non-Existent Field\nDESCRIPTION: Demonstrates the E4113 error in MoonBit. The code defines an enum `E` with a constructor `A` containing a field `a`. It then attempts to access a non-existent field `b` on an instance of `A`, triggering the error. Requires the MoonBit compiler to reproduce.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4113.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub enum E {\n  A(a~: Int)\n}\n\npub fn f(x: E) -> Unit {\n  match x {\n    A(..) as a => {\n      println(a.a)\n      println(a.b)\n//            ^^^ Error: Constructor A of type E has no field b.\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Error: Public Definition Must Be Annotated\nDESCRIPTION: Demonstrates the 'Public definition a must be annotated with its type' error in MoonBit. This arises when accessing a public variable from another package without explicitly annotating its type in the importing package.  The example shows accessing the variable 'value' from package 'a' within package 'b'.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4074.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\npub let value = @a.value // Error: Public definition a must be annotated with its type.\n```\n\n----------------------------------------\n\nTITLE: Optional Arguments with Option Type in MoonBit (Declaration)\nDESCRIPTION: This code demonstrates the verbose way of declaring an optional argument using `T?` with `None` as the default value, requiring explicit wrapping with `Some` when passing the argument.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_42\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(x? : Int? = None) {\n  IO::println(Debug::toString(x))\n}\n\nf(x=Some(1)) // Some(1)\n```\n\n----------------------------------------\n\nTITLE: Sudoku Grid Constants in Rust\nDESCRIPTION: These Rust constants define the rows, columns, and squares of a Sudoku grid. The `squares`, `units`, and `peers` constants are used to represent the structure of the Sudoku grid and are necessary for the solving algorithm. The `units` constant is a `SquareMap` that maps a square to a list of other squares in the same unit. The `peers` constant is a `SquareMap` that maps a square to a list of its peers.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/sudoku/index.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet rows = \"ABCDEFGHI\"\nlet cols = \"123456789\"\n\n// squares contains the coordinates of each square\nlet squares : List[String] = ......\n\n// units[coord] contains the other squares in the unit of the square at coord\n// for example：units[\"A3\"] => [C3, C2, C1, B3, B2, B1, A2, A1]\nlet units : SquareMap[List[String]] = ......\n\n// peers[coord] contains all the peers of the square at coord\n// for example：peers[\"A3\"] => [A1, A2, A4, A5, A6, A7, A8, A9, B1, B2, B3, C1, C2, C3, D3, E3, F3, G3, H3, I3]\nlet peers : SquareMap[List[String]] = ......\n```\n\n----------------------------------------\n\nTITLE: Defining String using double quotes in MoonBit\nDESCRIPTION: This code snippet demonstrates how to define a string using double quotes in MoonBit. The string holds a sequence of UTF-16 code units.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main() {\n  let s : String = \"Hello, MoonBit!\"\n  println(s)\n}\n```\n\n----------------------------------------\n\nTITLE: Run MoonBit Program (without relative path)\nDESCRIPTION: Executes the MoonBit program using the `moon run` command, specifying the path to the main package. Omits the `./` at the start of the path.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/tutorial.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ moon run src/main\nHello, world!\n```\n\n----------------------------------------\n\nTITLE: Building HTML Documentation with Make\nDESCRIPTION: This command uses the `make` utility to build the HTML version of the documentation and then starts a simple HTTP server to serve the generated files. It requires the `make` command to be available in the system.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/README-zh.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmake html\npython3 -m http.server -d _build/html\n```\n\n----------------------------------------\n\nTITLE: Defining a Coordinated Trait in MoonBit\nDESCRIPTION: This code defines a trait `Coordinated` with two methods, `x` and `y`, that take `Self` as an argument and return an `Int`. The `pub(open)` keyword allows the trait to be implemented outside the current package.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4062.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait Coordinated { // use pub(open) when you want to implement it outside current package.\n  x(Self) -> Int\n  y(Self) -> Int\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Qualified Students in MoonBit\nDESCRIPTION: This code snippet demonstrates a black box test for the `examine` package, specifically testing the `count_qualified_students` function. It defines an array of `Student` records with `id` and `score` fields, and uses two different criteria to count qualified students. Type annotations are included to specify the types of the `students` variable.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/tutorial/tour.md#_snippet_17\n\nLANGUAGE: moonbit\nCODE:\n```\n:class: top-level\ntest \"count qualified students\" {\n  let students: Array[@examine.Student] = [\n    { id: \"0\", score: 10.0 },\n    { id: \"1\", score: 50.0 },\n    { id: \"2\", score: 61.0 },\n  ]\n  let criteria1 = fn(student) { @examine.is_qualified(student, 10) }\n  let criteria2 = fn(student) { @examine.is_qualified(student, 50) }\n  assert_eq!(@examine.count_qualified_students(students, criteria1), 3)\n  assert_eq!(@examine.count_qualified_students(students, criteria2), 2)\n}\n```\n\n----------------------------------------\n\nTITLE: Unused Attribute Example - MoonBit\nDESCRIPTION: This example demonstrates the E0043 error where the `#deprecated` attribute is applied to the `main` function in MoonBit. Since the `main` function doesn't support the `#deprecated` attribute, it is considered unused and has no effect. This results in a compiler warning or error, indicating that the attribute should be removed or applied to a supported entity.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0043.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\n// the attribute is unused and has no effect\n#deprecated\nfn main {\n}\n\n```\n\n----------------------------------------\n\nTITLE: Resolving Duplicate Method Definition in MoonBit\nDESCRIPTION: This code snippet demonstrates the suggested solution for the E4056 error in MoonBit. By removing the duplicate method definition, the error is resolved, and the code becomes valid. Only one implementation of the `to_string` method is kept.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4056.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Point {\n  x: Int\n  y: Int\n}\n\nfn Point::to_string(self : Point) -> String {\n  \"(\" + self.x.to_string() + \",\" + self.y.to_string() + \")\"\n}\n\n// Remove the second Point::to_string method\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Branching in MoonBit\nDESCRIPTION: This MoonBit code implements the Cond instruction, which performs conditional branching based on the value on the top of the stack. If the value is 0 (false), it executes the 'else' branch; otherwise (true), it executes the 'then' branch. The instructions for the chosen branch replace the current instruction sequence.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-2.md#_snippet_9\n\nLANGUAGE: moonbit\nCODE:\n```\nCond(then_branch: List[Instruction], else_branch: List[Instruction]),\n\n    Cond(then_branch, else_branch) => {\n      let addr = state.stack.last()\n      match state.heap[addr] {\n        Node::NNum(0) => {\n          {state with instructions = else_branch, stack = list::drop_last(state.stack)}\n        }\n        _ => {\n          {state with instructions = then_branch, stack = list::drop_last(state.stack)}\n        }\n      }\n    }\n```\n\n----------------------------------------\n\nTITLE: Simplified x Coordinate Calculation in MoonBit\nDESCRIPTION: This is a simplified version of the previous code. This logic combines the previous four branches into one. It calculates the x coordinate based on k and previous coordinate values from v array\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff.md#_snippet_11\n\nLANGUAGE: moonbit\nCODE:\n```\nif k == -d || (k != d && v[k - 1] < v[k + 1]) {\n  x = v[k + 1]\n} else {\n  x = v[k - 1] + 1\n}\n\n```\n\n----------------------------------------\n\nTITLE: Erroneous Constant as Constructor in MoonBit\nDESCRIPTION: Demonstrates the E4144 error when a constant is incorrectly used as a constructor in a pattern matching scenario.  The code attempts to apply arguments to a constant `Value` in a `match` statement, resulting in the error. The `Value` constant is defined as an Int and then used in a `match` arm with a wildcard pattern.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4144.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub const Value : Int = 1\n\nfn main {\n  match { ... } {\n    Value(_) => println(\"Value\")\n  //^~~~\n  // Error: 'Value' is a constant, not a constructor, it cannot be applied to arguments.\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Moonbit Function Definition (Argument Forwarding)\nDESCRIPTION: Presents an alternative correction for the Moonbit function `f` where the outer function now takes an Int argument, and the inner function closes over this argument, satisfying the type signature.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4013.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(x: Int) -> (() -> Int) {\n  fn() { x }\n}\n```\n\n----------------------------------------\n\nTITLE: Define struct with lowercase type name in MoonBit\nDESCRIPTION: Illustrates the erroneous code that triggers the E0014 error. The `point` struct is defined with a lowercase name, violating the MoonBit naming convention.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0014.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct point {\n  x: Int\n  y: Int\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Hello World Test (hello_test.mbt)\nDESCRIPTION: Tests the `hello` function to ensure it returns the expected string.  This is a blackbox test, so it uses the package alias `@lib`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/tutorial.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"hello\" {\n  if @lib.hello() != \"Hello, world!\" {\n    fail!(\"@lib.hello() != \\\"Hello, world!\\\"\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Example: Calling Function with Correct Type - Moonbit\nDESCRIPTION: Shows the correct usage of the function `f`. Instead of passing `None`, a tuple `(3, 4)` is passed, which matches the expected input type of `f`, resolving the E4029 error. The function f is now called with its expected tuple input.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4029.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  fn f {\n    (a, b) => a + b\n  }\n  let a = f((3, 4))\n}\n```\n\n----------------------------------------\n\nTITLE: Lazy Evaluation Simulation in MoonBit\nDESCRIPTION: Simulates in-place update for lazy evaluation using MoonBit code with a mutable field. The `extract` method computes the value only once and updates the mutable field, ensuring that subsequent calls return the cached result without recomputation. This mimics how graph reduction works in lazy evaluation.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\nfn square(thunk : () -> Int) -> Int {\n  thunk() * thunk()\n}\n```\n\n----------------------------------------\n\nTITLE: Module Keywords Configuration in moon.mod.json\nDESCRIPTION: Defines the 'keywords' field in the moon.mod.json file, listing keywords associated with the module to improve discoverability.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/module.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"keywords\": [\"example\", \"test\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Correcting 'priv' visibility usage in MoonBit\nDESCRIPTION: This code snippet presents the correct way to declare a private variable in MoonBit.  By omitting the `priv` keyword, the variable defaults to private visibility, which is the intended behavior. This illustrates the suggested solution for the E3005 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3005.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nlet value = 3 // This is already `priv` by default.\n```\n\n----------------------------------------\n\nTITLE: Corrected Type/Trait Usage with `Show` in MoonBit\nDESCRIPTION: This code snippet shows the suggested correction using the proper trait name `Show`. It demonstrates how to call the `to_string` method correctly, assuming that the `Show` trait is appropriately defined and provides a `to_string` method.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4024.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nlet a = Show::to_string(true)\n```\n\n----------------------------------------\n\nTITLE: Erroneous MoonBit main.mbt\nDESCRIPTION: Illustrates an incorrect MoonBit program where a function from an unimported package `@middle` is called. This code will result in a compiler error related to the missing import.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4037.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let a = @middle.return_Obj().m()\n}\n```\n\n----------------------------------------\n\nTITLE: For Loop Example in MoonBit\nDESCRIPTION: This code shows a C-style `for` loop in MoonBit. It demonstrates variable initialization, loop conditions, and update clauses. The variable `i` is immutable within the loop's scope.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_58\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  for var i = 0; i < 5; i = i + 1 {\n    debug(i)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Record Field Access in MoonBit\nDESCRIPTION: This MoonBit code snippet demonstrates the E4030 error. It defines a record type `T` with a single field `a`. The code then attempts to create a new record of type `T` using record update syntax, but introduces a new field `b` which is not defined in `T`, resulting in the error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4030.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct T { a : Int }\nlet t : T = { a: 42 }\nlet u : T = { ..t, b: 43 }\n```\n\n----------------------------------------\n\nTITLE: Defining Hexadecimal Number in MoonBit\nDESCRIPTION: This code snippet demonstrates how to define hexadecimal numbers in MoonBit, which start with `0x` or `0X`. The digits after the `0x`/`0X` must be in the range `0123456789ABCDEF`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\nlet h1 : Int = 0x123456789abcdef\nlet h2 : Int = 0X123456789ABCDEF\n```\n\n----------------------------------------\n\nTITLE: Corrected Function Call in Moonbit\nDESCRIPTION: This code demonstrates the correct way to call the function `f` in Moonbit. The function `f` is called with the correct number of arguments without any labeled parameters.  The function expects only one positional argument.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4085.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(name : String) -> Unit {\n  println(\"Hello, \\{name}\")\n}\n\nfn main {\n  f(\"John\")\n}\n```\n\n----------------------------------------\n\nTITLE: Toplevel Variable Type Inference in MoonBit\nDESCRIPTION: Demonstrates MoonBit's ability to infer the type of toplevel variables when their values are literals. It shows examples of inferring types for integers, floats, strings, and arrays without explicit type annotations.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4074.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub let forty_two = 42\npub let float = 1.0\npub let string = \"Hello, world!\"\npub let array = [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: MoonBit: Declare count_qualified_students function\nDESCRIPTION: This code declares the `count_qualified_students` function in MoonBit. It takes an `Array[Student]` and a function `(Student) -> ExamResult` as input, which represents the qualification criteria. It returns an `Int`, indicating the number of students who have passed based on the provided criteria. The function body is left unimplemented initially using `...`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/tutorial/tour.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\nfn count_qualified_students(\n  students : Array[Student],\n  is_qualified : (Student) -> ExamResult\n) -> Int {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Ignore Unused Variable - MoonBit\nDESCRIPTION: Demonstrates the use of the `ignore()` function to explicitly mark a variable as used, even if it is not directly referenced in the code. This is useful when the variable is intentionally left unused but needs to be defined for other reasons or to prevent compiler warnings.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0002.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nlet p : Int = {\n  println(\"Side effect\")\n  42\n}\n\nfn init {\n  ignore(p)\n}\n\nfn main {\n  let x = 42\n  ignore(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Suggestion: Using Different Names for Identifiers (MoonBit)\nDESCRIPTION: This MoonBit code demonstrates the corrected approach by using distinct names for the identifiers within the pattern. 'a' and 'b' are now separate bindings, each representing the value inside their respective `Some` options. This allows the match to succeed and the values to be accessed individually.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4081.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(a : Int?, b : Int?) -> Unit {\n  match (a, b) {\n    (Some(a), Some(b)) => println(\"Some({a}), Some({b})\")\n    _ => println(\"None\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Method Declaration (MoonBit)\nDESCRIPTION: This code snippet demonstrates an alternative solution by modifying the method declaration to `fn f(self : A) -> Int`. This allows calling the method directly using `f(A(1))` without triggering the deprecation warning.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0040.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(self : A) -> Int {\n  self._\n}\n\nfn main {\n  let _ = f(A(1))\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous MoonBit For Loop Break with Value\nDESCRIPTION: This code snippet demonstrates the MoonBit error E4110. It shows a `for` loop using `break` with an argument, which is invalid because `for` loops in MoonBit are not designed to yield values directly with `break`. The expected return type is Unit, indicating no return value.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4110.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(x: Int) -> Unit {\n  for i in 0..=x {\n    break i\n//  ^^^^^^^^ Error: The for loop is not expected to yield a value, please\n//                  remove the argument of the `break` or add an `else` branch.\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Correcting Missing Parameter List in Moonbit\nDESCRIPTION: This snippet demonstrates the correct way to define a function in Moonbit that takes no parameters. By adding `()` after the function name `greet`, the error E3004 is resolved. There are no dependencies.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3004.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn greet() {\n  println(\"Hello, world!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Making a Struct Public in MoonBit\nDESCRIPTION: Demonstrates how to resolve the unused type warning by removing the `priv` keyword, making the struct publicly accessible. This snippet shows the `Foo` struct with the `priv` keyword removed, which means it is now part of the public API of the module, preventing the warning.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0003.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Foo {\n    bar : Int\n  }\n```\n\n----------------------------------------\n\nTITLE: Erroneous MoonBit Loop with Unused Label\nDESCRIPTION: Demonstrates the E0037 error in MoonBit where a loop has a label ('read~:') that is never used in a 'break' or 'continue' statement, leading to a compiler warning. The function 'read()' is assumed to return a 'BytesView'.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0037.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn read() -> BytesView {\n  ...\n}\n\nfn main {\n  let mut bytes = []\n  read~: loop read() {\n    [] => break\n    bs => {\n      bytes = [..bytes, ..bs]\n      continue read()\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Panic Test Block in MoonBit\nDESCRIPTION: This snippet shows how to write a test that expects a panic. If a test name starts with `\"panic\"`, the test will only pass if a panic is triggered during its execution.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/tests.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn test_panic() {\n  assert_eq(1 + 1, 3)\n}\n\nfn test_panic_named(\"panic_test\") {\n  assert_eq(1 * 2, 3)\n}\n```\n\n----------------------------------------\n\nTITLE: Suggested MoonBit Placeholder Example\nDESCRIPTION: This code snippet demonstrates the correct usage of the ellipsis `...` as a placeholder for unfinished code in MoonBit. The code will compile, but the compiler will issue a warning to indicate that the code is not complete.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4116.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  ... // Warning: unfinished code\n}\n```\n\n----------------------------------------\n\nTITLE: Variable Declaration using `let` MoonBit\nDESCRIPTION: This code snippet demonstrates how to declare a variable `a` of type `Array[Int]` and initialize it with a list of integers using the `let` keyword. This is the correct approach for assigning values to variables whose types are not immutable primitives when a constant is not needed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4143.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nlet a : Array[Int] = [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Duplicate Toplevel Type Definition in MoonBit\nDESCRIPTION: This code demonstrates the E4051 error in MoonBit, caused by defining two toplevel types (enum and struct) with the same name 'A'. This is not allowed; each toplevel type must have a unique identifier.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4051.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\npub enum A {}\npub struct A {} // Error: The type A is declared twice: it was previously defined at ...\n```\n\n----------------------------------------\n\nTITLE: Converting Term to TermDBI with Helper Function in MoonBit\nDESCRIPTION: This code defines the core conversion logic from `Term` to `TermDBI` in MoonBit.  It uses a helper function `go` that recursively traverses the Lambda term, maintaining a list of variable names and their corresponding depths. The function handles `Var`, `Abs`, and `App` cases, updating the index list and generating the appropriate `TermDBI` representation.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/lambda/index.md#_snippet_6\n\nLANGUAGE: moonbit\nCODE:\n```\nfn bruijn(self : Term) -> Result[TermDBI, String] {\n  struct Ctx {\n    index : @immut/list.T[Index]\n  }\n\n  fn go(index : @immut/list.T[Index], term : Term) -> Result[TermDBI, String] {\n    match term {\n      Var(varname) => {\n        match find_depth(varname, index) {\n          Ok(depth) => Ok(VarDBI(depth, varname))\n          Err(err) => Err(err)\n        }\n      }\n      Abs(varname, body) => {\n        let new_index = Cons(Index { name : varname, depth : 0 }, index.map(fn (x) { Index { name : x.name, depth : x.depth + 1 } }))\n        match go(new_index, body) {\n          Ok(body_dbi) => Ok(AbsDBI(varname, body_dbi))\n          Err(err) => Err(err)\n        }\n      }\n      App(t1, t2) => {\n        match (go(index, t1), go(index, t2)) {\n          (Ok(t1_dbi), Ok(t2_dbi)) => Ok(AppDBI(t1_dbi, t2_dbi))\n          (Err(err), _) => Err(err)\n          (_, Err(err)) => Err(err)\n        }\n      }\n    }\n  }\n\n```\n\nLANGUAGE: moonbit\nCODE:\n```\n  go(Nil, self)\n}\n```\n\n----------------------------------------\n\nTITLE: Trait Constraints for Specific Implementations (MoonBit)\nDESCRIPTION: Illustrates how to add constraints to a trait definition to provide specific implementations for types that meet those constraints, offering another approach to handling the E4053 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4053.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait A: Default {\n  f(Self) -> Int\n}\n\nimpl A with f(self : Self) -> Int {\n  ignore(self)\n  0\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Moonbit Code: Toplevel Function with Labelled Argument\nDESCRIPTION: This Moonbit code demonstrates another solution to the E4119 error. It moves the `greet` function to the toplevel scope, allowing it to use the labelled argument `name~`. The `main` function then calls `greet` with the labelled argument `name=\"World\"`, which is now valid.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4119.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn greet(name~ : String) -> Unit {\n  println(\"Hello, \\{name}\")\n}\n\nfn main {\n  greet(name=\"World\")\n}\n```\n\n----------------------------------------\n\nTITLE: Trait Implementation for FFI Interaction (Suggestion)\nDESCRIPTION: This code demonstrates a more complex scenario for interacting with FFI by defining a trait `Ider` and implementing it for a specific type (`Int`). This allows using the `id` function through the trait, which is then implemented by an FFI function.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4008.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait Ider {\n  id(Self) -> Self\n}\n\nimpl Ider for Int with id(self) { int_id(self) }\n```\n\n----------------------------------------\n\nTITLE: Pretty Printing Definition in MoonBit\nDESCRIPTION: This code defines the `pprint` function in MoonBit for printing the diff in a human-readable format, aligning text and presenting insertions, deletions, and unchanged lines clearly.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff2.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\nfn pprint[T: ToString](edits: List[Edit[T]]) -> Effect[Unit] {\n  for (i, edit) in edits.iter().enumerate() {\n    match edit {\n      Insert(t) => println(\"+\\t\\t{t}\"),\n      Delete(t) => println(\"-\\t\\t{t}\"),\n      Keep(t) => println(\" \\t{i}\\t{t}\"),\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Type/Trait Name Duplication in MoonBit\nDESCRIPTION: Shows how to resolve the E4052 error by renaming either the type or the trait so that they have distinct names. This example renames the trait from 'A' to 'B', eliminating the naming conflict.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4052.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub type A\npub trait B {}\n```\n\n----------------------------------------\n\nTITLE: MoonBit: Unwind Instruction Implementation\nDESCRIPTION: This MoonBit code implements the `Unwind` instruction, which is the core evaluation loop of the G-Machine. It checks the node type at the top of the stack and performs different actions based on the type. It handles `NNum`, `NApp`, `NGlobal`, and `NInd` nodes, recursively unwinding the stack until a normal form or a global function with enough arguments is found.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_20\n\nLANGUAGE: moonbit\nCODE:\n```\n  fn unwind(s : GState) -> GState {\n    match s.stack {\n      Nil => { abort(\"Stack underflow\") }\n      Cons(addr, _) => {\n        match array_get(s.heap.nodes, addr) {\n          { num } => { s }\n          { app } => {\n            // Push the left node and unwind again\n            let (fun_addr, _) = app\n            { s with stack = cons(fun_addr, s.stack) }\n          }\n          { global } => {\n            // Check if there are enough parameters on the stack\n            // Load this super combinator into the current code\n            s\n          }\n          { ind } => {\n            // Push the address contained within this indirect node onto the stack and Unwind again.\n            { s with stack = cons(ind, s.stack) }\n          }\n        }\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Unused Private Struct Definition with Function in MoonBit\nDESCRIPTION: This code shows a private struct `A` and a function `f` that takes `A` as an argument and accesses its field `value`. However, since the struct is never constructed, the compiler will still issue a warning.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0009.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npriv struct A { // Warning: The struct A is never constructed\n  value : Int\n}\n\nfn f(a : A) -> Int {\n  a.value\n}\n```\n\n----------------------------------------\n\nTITLE: Changing Field Visibility to Match Struct Visibility in MoonBit\nDESCRIPTION: This code snippet demonstrates the suggested correction for the visibility error. The visibility of the field is changed to be private, matching the visibility of the struct. This resolves the compiler error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4001.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npriv struct S {\n  field: Int\n}\n```\n\n----------------------------------------\n\nTITLE: Display MoonBit CLI Help\nDESCRIPTION: Shows the usage instructions for the MoonBit command-line interface. This command is used to get a list of available commands and options.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/tutorial.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ moon help\n...\n```\n\n----------------------------------------\n\nTITLE: Erroneous Async Call in MoonBit\nDESCRIPTION: This code snippet demonstrates an incorrect asynchronous function call in MoonBit where the `f()` function is called without the required `!!` marker inside the `g()` function. This will result in an error because MoonBit requires explicit marking of async calls.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4150.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nasync fn f() -> Int {\n  ...\n}\n\nasync fn g() -> Int {\n  f() // Error: async function call must be marked with `!!`\n}\n```\n\n----------------------------------------\n\nTITLE: Define Built-in Operations Hash Table\nDESCRIPTION: This snippet defines a hash table called `builtinOpS` to store the corresponding instructions for built-in operations. The table is used for querying the instructions by the name of the primitive, facilitating efficient code generation.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-3.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\nlet builtinOpS : Map[Symbol, Instruction] = {\n  `add : Prim Add,\n  `sub : Prim Sub,\n  `mul : Prim Mul,\n  `div : Prim Div,\n  `eq : Prim Eq,\n  `lt : Prim Lt,\n  `gt : Prim Gt\n}\n```\n\n----------------------------------------\n\nTITLE: Function with Unused Error Type in MoonBit\nDESCRIPTION: This MoonBit code defines a function `greet` that returns `Unit!` (Unit with an error type). However, the function body doesn't actually use or handle the error type, leading to the E0024 compiler error. The function simply prints \"Hello, world!\" to the console.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0024.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn greet() -> Unit! {\n  println(\"Hello, world!\")\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Module Configuration with Aliased Package Import (main/moon.pkg.json)\nDESCRIPTION: Configures the import of the `username/hello/lib/fib` package with a custom alias `my_awesome_fibonacci` in `src/main/moon.pkg.json`.  Also imports the `username/hello/lib` package without an alias.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/tutorial.md#_snippet_17\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"is_main\": true,\n  \"import\": [\n    \"username/hello/lib\",\n    {\n      \"path\": \"username/hello/lib/fib\",\n      \"alias\": \"my_awesome_fibonacci\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Unused Pattern by Reordering - MoonBit\nDESCRIPTION: This code shows how to fix the E0010 error by swapping the order of the match arms.  By placing the `Some(a)` pattern before the `_` pattern, the code now correctly matches the `Some` case first.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0010.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  match Some(1) {\n    Some(a) => println(\"Some({a})\")\n    _ => println(\"_\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Translation Templates with Sphinx-intl\nDESCRIPTION: This command updates the translation templates using `sphinx-intl`. It first uses `make gettext` to extract translatable strings and then uses `sphinx-intl update` to update the translation files. It requires `sphinx-intl` to be installed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/README-zh.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nmake gettext\nsphinx-intl update -p _build/gettext -l zh_CN\n```\n\n----------------------------------------\n\nTITLE: Implementing Queries with Lazy Propagation in MoonBit\nDESCRIPTION: This code implements the query function. The query function pushes the LazyTag downwards to ensure correct results when querying ranges. It applies the lazy tag to the children before making the recursive calls.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/segment-tree/segment-tree2.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\nfn query[Data: Op_add[Data, Tag] + Op_add_tag[Data, Tag], Tag: Op_add_tag[Data, Tag]](node: Node[Data, Tag], l: Int, r: Int, ql: Int, qr: Int) -> Data {\n  if ql <= l && qr >= r {\n    match node {\n      Leaf(data) => data\n      Node { data, .. } => data\n    }\n  } else if qr < l || ql > r {\n    // Return a neutral element that doesn't affect the sum\n    // This depends on the specific Data type and operation\n    // For example, if Data is Int and the operation is addition, return 0\n    // If Data is Int and the operation is multiplication, return 1\n    // Here, we assume Data has a zero() function to return a neutral element\n    zero()\n  } else {\n    match node {\n      Leaf(data) => data\n      Node { left, right, data, tag, len } => {\n        let left = apply(left, tag)\n        let right = apply(right, tag)\n\n        let mid = l + (r - l) / 2\n        let left_result = query(left, l, mid, ql, qr)\n        let right_result = query(right, mid + 1, r, ql, qr)\n        op_add(left_result, right_result)\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: PowerShell Create Profile\nDESCRIPTION: Creates a new PowerShell profile if one doesn't exist.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/commands.md#_snippet_9\n\nLANGUAGE: powershell\nCODE:\n```\nPS C:\\> New-Item -path $profile -type file -force\n```\n\n----------------------------------------\n\nTITLE: Defining Primitive Functions in MoonBit Compilation\nDESCRIPTION: This MoonBit code defines a map of primitive functions to their corresponding Core expressions. This allows the compiler to recognize and handle primitive operations such as addition, subtraction, multiplication, division, negation, equality, inequality, less than, less than or equal to, greater than, and greater than or equal to.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-2.md#_snippet_10\n\nLANGUAGE: moonbit\nCODE:\n```\nlet prim_map = map::from_array([\n  (\"primAdd\", Core::NNum(1)),\n  (\"primSub\", Core::NNum(2)),\n  (\"primMul\", Core::NNum(3)),\n  (\"primDiv\", Core::NNum(4)),\n  (\"primNeg\", Core::NNum(5)),\n  (\"primEq\", Core::NNum(6)),\n  (\"primNe\", Core::NNum(7)),\n  (\"primLt\", Core::NNum(8)),\n  (\"primLe\", Core::NNum(9)),\n  (\"primGt\", Core::NNum(10)),\n  (\"primGe\", Core::NNum(11)),\n])\n```\n\n----------------------------------------\n\nTITLE: Result unwrap example\nDESCRIPTION: Example of using the unwrap method on result to return value or panic.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_21\n\nLANGUAGE: moonbit\nCODE:\n```\nlet res2: Result[Int, String] = Ok(42)\nlet value = res2.unwrap() // 42\n```\n\n----------------------------------------\n\nTITLE: Erroneous MoonBit moon.pkg.json\nDESCRIPTION: An incorrect `moon.pkg.json` file for `main` package that is missing the import of the `@ty` package. This leads to a compiler error because `main.mbt` indirectly uses `@ty` through `@middle`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4037.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"import\": [\"<PACKAGE>/middle\"]\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Main Function in Package 'b' (Corrected)\nDESCRIPTION: Demonstrates the recommended solution: using the setter method `set` defined in package 'a' to modify the `value` field of struct `T`. This ensures controlled access and encapsulation.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4094.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let a = @a.T::new()\n  a.set(3)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Module Name Configuration for Mooncakes\nDESCRIPTION: Specifies the 'name' field for modules intended to be published on mooncakes.io. The module name must begin with the username followed by a slash and the module name itself, conforming to the mooncakes.io repository structure.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/module.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"moonbitlang/core\",\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit: Define ExamResult enum\nDESCRIPTION: This code defines an `ExamResult` enum in MoonBit with two possible values: `Pass` and `Fail`. This enum represents the result of an exam, providing a clear and type-safe way to represent pass/fail outcomes.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/tutorial/tour.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nenum ExamResult {\n  Pass\n  Fail\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous MoonBit Range Pattern\nDESCRIPTION: This code snippet demonstrates an erroneous range pattern where the starting value is greater than the ending value, violating the ordering constraint. This results in a compile-time error. The code defines a `main` function with a `match` statement that attempts to match a value against an invalid range.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4147.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let value = 1\n  match value {\n    0..<-10 => println(\"0..<-10\")\n  //^~~~~~~\n  // Error: Range pattern `a..<b` must satisfy `a < b`.\n    _ => println(\"_\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Unicode Escape Sequence in MoonBit\nDESCRIPTION: This code snippet demonstrates an invalid Unicode escape sequence in a MoonBit character literal. The error E4064 occurs because the Unicode code point \\uD800 is not a valid Unicode character.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4064.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  println('\\uD800')\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Second Main Package (JSON)\nDESCRIPTION: Defines a second MoonBit package (`main2`) as a main package. This allows it to be compiled into a separate executable. The `is-main` field is set to `true`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4068.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"is-main\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Native Backend Compiler Configuration\nDESCRIPTION: This JSON snippet demonstrates how to configure the `cc` option for the native backend in the `link` section of a `moon.pkg.json` file. It specifies the compiler to use for compiling the moonc-generated C source files.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/package.md#_snippet_11\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"link\": {\n      \"native\": {\n        \"cc\": \"/usr/bin/gcc13\"\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Erroneous Record and Map Pattern Mixing in MoonBit\nDESCRIPTION: Illustrates the E3012 error in MoonBit, which arises when attempting to mix record patterns and map patterns within a single match statement. The example defines a struct 'S' and attempts to match against it using a mixed pattern, resulting in an error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3012.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct S {\n  value : Int\n}\n\npub fn S::op_get(self : S, index : String) -> Int? {\n  if index == \"value\" {\n    return Some(self.value)\n  }\n  return None\n}\n\nfn main {\n  let s : S = { value: 42 }\n  match s {\n    { \"value\": value, value } => println(\"Value is: \\{value}\") // Error: Record pattern and map pattern cannot be mixed.\n    _ => println(\"No value\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Greeting Function in MoonBit (lib)\nDESCRIPTION: Defines a public function `greeting` in MoonBit that returns a string.  This function is meant to be imported and used by other MoonBit packages.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0033.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn greeting() -> String {\n  \"Hello, world!\"\n}\n```\n\n----------------------------------------\n\nTITLE: Solution 1: Adding a Continue Statement (MoonBit)\nDESCRIPTION: Demonstrates how to resolve the E0018 error by adding a `continue` statement within the `loop` expression.  The `countdown` function now includes a `continue` statement to restart the loop after decrementing the counter.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0018.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn countdown(n : Int) -> Int {\n  let mut count = n\n  loop count {\n    _..<0 => break\n    _ => {\n      continue count - 1\n    }\n  }\n  return count\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid MoonBit Package Alias\nDESCRIPTION: This JSON configuration demonstrates an invalid package alias in MoonBit. The 'alias' field for the imported package 'username/hello/lib' is empty, which triggers the E0030 warning.  The configuration file is intended to define how MoonBit projects are structured and which external libraries they depend on.  The empty alias will cause MoonBit to use a default alias instead.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0030.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"is-main\": true,\n  \"import\": [\n    {\n      \"path\": \"username/hello/lib\",\n      \"alias\": \"\" // Warning: The package alias is empty. The default package alias will be used instead.\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Building Initial Heap with build_ih - MoonBit\nDESCRIPTION: This snippet defines the `build_ih` function, which is responsible for placing the compiled super combinators onto the heap and adding their addresses to the global table. This function is called recursively to handle nested super combinator definitions. This is the first step in running the compiled code.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_24\n\nLANGUAGE: moonbit\nCODE:\n```\nfn build_ih() {\n  // This is a placeholder for heap construction logic.\n}\n```\n\n----------------------------------------\n\nTITLE: Installing dependencies and starting the development server\nDESCRIPTION: This shell script installs project dependencies using pnpm and starts the development server. The tour website can then be viewed at http://localhost:8080.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/moonbit-tour/README-zh.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\npnpm install\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Using Struct Fields with Pattern Matching and Dot-Syntax in MoonBit\nDESCRIPTION: This example demonstrates two ways to use struct fields to resolve the E0007 error: pattern matching and dot-syntax access. By accessing the `value` field of the struct `S`, the warning is avoided.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0007.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let s = S::{ value : 1 }\n  match s {\n    { value } => println(\"S({\\{value}})\")\n  }\n  println(\"S({\\{s.value}})\")\n}\n```\n\n----------------------------------------\n\nTITLE: G-Machine Step Execution with step - MoonBit\nDESCRIPTION: The `step` function updates the state of the G-Machine by one step. It returns `false` if the final state has been reached, indicating the termination of the computation. The function processes instructions and modifies the machine's stack, heap, and program counter.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_25\n\nLANGUAGE: moonbit\nCODE:\n```\nfn step() -> Bool {\n  // This is a placeholder function for one G-Machine step.\n  false\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Trait Implementation without Type Parameter (MoonBit)\nDESCRIPTION: This MoonBit code provides the correct way to define a default implementation for the `Stringer` trait without using a type parameter. The type parameter `T` is removed from the `impl` block.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4011.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub(open) trait Stringer {\n  stringify(Self) -> String\n}\n\nimpl Stringer with stringify(_self) { \"hey\" }\n```\n\n----------------------------------------\n\nTITLE: MoonBit: PushGlobal Instruction Implementation\nDESCRIPTION: This MoonBit code implements the `PushGlobal` instruction. It retrieves the address of the global super combinator (identified by its name) from the global table and pushes that address onto the stack. It assumes the global table contains the mapping between names and heap addresses of the combinators.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_16\n\nLANGUAGE: moonbit\nCODE:\n```\n  fn push_global(s : GState, name : String) -> GState {\n    match get(s.globals, name) {\n      Some(addr) => { { s with stack = cons(addr, s.stack) } }\n      None => { abort(\"Global not found\") }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Testing Segment Tree Construction in MoonBit\nDESCRIPTION: This snippet shows how to test the `build` function in MoonBit. It creates an array of integers, builds a segment tree from it, and prints the result.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/segment-tree/segment-tree.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main() {\n  let arr = [1, 2, 3, 4, 5, 6, 7]\n  debug(build(arr))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Immutable Array Declaration - Moonbit\nDESCRIPTION: This Moonbit code demonstrates the corrected version of the previous example, where the `mut` keyword is removed from the array declaration. This avoids the E0015 warning because the array is no longer unnecessarily declared as mutable. It relies on the Moonbit standard library for printing.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0015.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let x = [1, 2, 3]\n  x[0] = 0\n  println(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Pushing Arguments onto the Stack in MoonBit\nDESCRIPTION: This MoonBit code snippet defines the `Push` instruction, which pushes an argument onto the stack. It takes an offset as input, accesses the element at that offset in the stack, and pushes it onto the top of the stack. This generalizes the original `PushArg` instruction, allowing access to both parameters and local variables.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-2.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nPush(offset: Int),\n\n    Push(offset) => {\n      let addr = list::get(state.stack, offset)\n      {state with stack = list::push(state.stack, addr)}\n    }\n```\n\n----------------------------------------\n\nTITLE: Duplicate Local Type Definition in MoonBit\nDESCRIPTION: This code snippet shows the E4051 error occurring within a function, when two local types are defined with the same name.  The second definition of `A` generates a compiler error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4051.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn g() -> Unit {\n  struct A {}\n  struct A {} // Error: The local type A is declared twice: it was previously defined at ...\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit: Implement count_qualified_students with for loop\nDESCRIPTION: This code implements the `count_qualified_students` function using a mutable counter and a `for` loop in MoonBit. It iterates through the array of students, checks if each student is qualified based on the provided `is_qualified` function, and increments the counter if they are. Finally, it returns the total count of qualified students.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/tutorial/tour.md#_snippet_14\n\nLANGUAGE: moonbit\nCODE:\n```\nfn count_qualified_students(\n  students : Array[Student],\n  is_qualified : (Student) -> ExamResult\n) -> Int {\n  let mut count = 0\n  for i = 0; i < students.length(); i = i + 1 {\n    if is_qualified(students[i]) == Pass {\n      count += 1\n    }\n  }\n  count\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Anonymous Function Declaration in MoonBit\nDESCRIPTION: This code demonstrates the MoonBit compiler error E4134. The anonymous function `fn(luck : Int) -> Int` is expected to return an error type (`Int!`) because it uses `fail!`. However, the return type annotation is missing the error type. This causes the compiler to raise error E4134.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4134.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let draw : (Int) -> Int! = fn(luck : Int) -> Int {\n    //                                         ^~~\n    // Error: The return type of this anonymous function is expected include an\n    // error type. Please add the error type to the return type annotation or\n    // use `fn!` instead.\n    if luck == 7 {\n      return 42\n    }\n    fail!(\"Bad luck\") // E4122 as well\n  }\n  try {\n    println(\"Draw: \\{draw!(7)}\")\n  } catch {\n    error => println(\"Error: \\{error}\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Building PDF Documentation with Latex\nDESCRIPTION: This command uses `make` to generate a PDF version of the documentation using LaTeX. It then opens the generated PDF file. It requires LaTeX and `latexmk` to be installed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/README-zh.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmake latexpdf\nopen ./_build/latex/moonbitdocument.pdf\n```\n\n----------------------------------------\n\nTITLE: moon.pkg.json configuration for main package in MoonBit\nDESCRIPTION: This JSON configuration file indicates that the package is a main package, allowing it to contain a `main` function. This is used when moving the `main` function to a dedicated main package.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4069.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"is-main\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Public Enum Declaration MoonBit\nDESCRIPTION: This example demonstrates how to make the enum `T` public using the `pub` keyword. This allows the variants to be read outside the current package.  This makes the internal implementation of the enum visible to users of the package.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0006.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\npub enum T {\n  A\n  B\n  C\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Enum Constructor Call in MoonBit\nDESCRIPTION: This example demonstrates the error E4007, which arises when attempting to invoke an enum constructor without a payload (e.g., `Done()`) as a function. The code defines an enum `Status` with two variants, `Done` and `Pending`, and then attempts to create a `status` variable by calling `Done()`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4007.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nenum Status {\n  Done\n  Pending\n}\n\nfn main {\n  let status = Done() // Error: constructor without payload cannot be called with ()\n}\n```\n\n----------------------------------------\n\nTITLE: Correct MoonBit Test Parameter Usage\nDESCRIPTION: Shows the correct way to define a test function in MoonBit, by using the predefined `@test.T` type as a parameter. This avoids the E4132 compiler error. The `it` parameter represents the test context.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4132.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest (it : @test.T) {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Wrapping Type and Implementing Trait Manually in MoonBit\nDESCRIPTION: This code snippet presents a workaround for deriving traits when you don't have control over the original type. It creates a new type (`StructWrapper`) that wraps the original type (`MyStruct`).  It then implements the `Show` trait for the wrapper type manually, requiring knowledge of how to print the underlying `MyStruct`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4130.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntype StructWrapper MyStruct\n\nimpl Show for StructWrapper with output(self, logger) {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Unused Private Struct Declaration MoonBit\nDESCRIPTION: Illustrates the compiler warning E0003 when a private struct is declared but not used within the module. The warning suggests either removing the struct or making it public if it's intended to be part of the module's API. The struct `Foo` is marked as `priv` and is not referenced elsewhere, triggering the warning.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0003.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npriv struct Foo { // Warning: Unused type 'Foo'.\n  bar : Int\n}\n\nfn main {\n  struct Bar { // Warning: Unused type 'Bar'.\n    foot : Int\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected MoonBit Example: Using the Correct Identifier\nDESCRIPTION: This code provides the corrected version of the previous example. It replaces the incorrect function name `to_integer` with the correct function name `to_int` within the `@bool` package, resolving the E4021 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4021.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nlet a = @bool.to_int(true)\n```\n\n----------------------------------------\n\nTITLE: Erroneous Async Function Call in MoonBit\nDESCRIPTION: This example demonstrates the E4149 error that occurs when attempting to call an async function from within a non-async function. The async function `f` is called using `f!!()` inside the non-async function `g`, resulting in the error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4149.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nasync fn f() -> Int {\n  ...\n}\n\nfn g() -> Int {\n  f!!()\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Enum with Unique Constructors - MoonBit\nDESCRIPTION: This MoonBit code snippet demonstrates the corrected enum definition where the duplicate constructor has been renamed to 'B'. This resolves the E4057 error. The code defines an enum 'E' with two unique constructors, 'A' and 'B', where 'B' takes an Int argument.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4057.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nenum E {\n  A\n  B(Int)\n}\n```\n\n----------------------------------------\n\nTITLE: Solution 2: Specify Variable/Collection Element Type\nDESCRIPTION: Resolves the E0013 error by explicitly specifying the type of a variable or the element type of a collection. This provides the necessary type information for the compiler to avoid defaulting to `Unit`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0013.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let a : Array[Int] = []\n  println(a.length())\n  let b : Option[Int] = None\n  println(b.is_empty())\n}\n\n```\n\n----------------------------------------\n\nTITLE: MoonBit: Update Instruction Implementation\nDESCRIPTION: This MoonBit code implements the `Update` instruction. It updates a node in the heap with an indirection (`NInd`) to the result of the computation. The offset specifies which node to update based on the stack layout.  If updating a CAF (constant applicative form), it updates the `NGlobal` node directly.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_19\n\nLANGUAGE: moonbit\nCODE:\n```\n  fn update(s : GState, offset : Int) -> GState {\n    match s.stack {\n      Nil => { abort(\"Stack underflow\") }\n      Cons(result_addr, rest) => {\n        match list_nth(s.stack, offset + 1) {\n          Some(update_addr) => {\n            let new_heap = { nodes = array_set(s.heap.nodes, update_addr, { ind = result_addr }) }\n            { s with heap = new_heap }\n          }\n          None => { abort(\"Update address not found\") }\n        }\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Corrected Alert Pragma MoonBit\nDESCRIPTION: This snippet shows the corrected version of the previous example, replacing the invalid `@deprecated` pragma with the valid `@alert` pragma. This provides a direct comparison and highlights the correct syntax for emitting a deprecation warning in MoonBit.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0020.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\n///|\n/// @alert deprecated \"This function is deprecated\"\nfn f() {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Trait with Single Method Declaration in MoonBit\nDESCRIPTION: This code snippet shows the corrected version of the previous example, where the duplicate `make_sound` method declaration is removed. The `Animal` trait now has a single definition for the `make_sound` method, resolving the E4005 error. This demonstrates the proper way to define a trait with unique method names in MoonBit.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4005.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait Animal {\n  make_sound(Self) -> String  // Only declare the method once\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Method Definition for Type from Another Package (MoonBit)\nDESCRIPTION: This code demonstrates the E4059 error, triggered when attempting to define a method `f` for a type `A` that is defined in a different package `a`. MoonBit restricts method definitions to types within the same package.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4059.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub type A Int\n```\n\n----------------------------------------\n\nTITLE: Corrected Struct Field Visibility in MoonBit\nDESCRIPTION: This code snippet provides a corrected example where the visibility modifier is removed from the struct field.  Since the struct is declared as `pub`, its fields are public by default and do not require an explicit visibility modifier. Alternatively, `pub field: Int` could also be used.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4002.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub struct S {\n  field: Int\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Extern C Function Name MoonBit\nDESCRIPTION: This code snippet demonstrates an invalid C function name used within an `extern \"C\"` declaration in MoonBit. The function name `f1()` is invalid because it doesn't represent a valid C identifier in the context of the string it's being equated to.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4140.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nextern \"C\" fn f1() = \"1\" // Error: Invalid C function name in extern \"C\" declaration\n```\n\n----------------------------------------\n\nTITLE: Suppressing Deprecation Alerts in moon.pkg.json\nDESCRIPTION: Illustrates how to suppress 'deprecated' alerts by modifying the `moon.pkg.json` file. Adding `\"alert-list\": \"-deprecated\"` disables all deprecated alerts for the package.  This should be used with caution and only when the implications of using deprecated APIs are fully understood.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E2000.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\n{\n  // ... other fields in the file\n  \"alert-list\": \"-deprecated\"\n}\n```\n\n----------------------------------------\n\nTITLE: Trait Method Correct Implementation - MoonBit\nDESCRIPTION: Illustrates the correct way to implement a trait method in MoonBit, avoiding the E4072 error. It shows the removal of the duplicated default implementation of the trait. By removing the second `impl` block, the error is resolved.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4072.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nimpl T with to_int(self : Self) -> Int {\n  0\n}\n\n// Remove this implementation\n// impl T with to_int(self : Self) -> Int {\n//   0\n// }\n```\n\n----------------------------------------\n\nTITLE: Reserved Type Name Error\nDESCRIPTION: Illustrates the error E4003 by attempting to define a struct named 'Error'. The 'Error' type name is reserved in MoonBit for the built-in error type, so it cannot be used for a custom type.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4003.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Error {}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Match Function Definition in Moonbit\nDESCRIPTION: This code snippet demonstrates an incorrect use of a match function in Moonbit, resulting in the E4009 error.  The error arises because the branches within the match function handle different numbers of arguments, leading to a mismatch.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4009.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nlet f = fn {\n  0 => 0\n  a, b => a + b\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Record Field Access in MoonBit\nDESCRIPTION: This snippet shows the correct way to access record fields in a MoonBit `match` statement. The `match` statement correctly uses the defined field `a` of the struct `S`.  The `..` allows for matching records with additional, unspecified fields. This resolves the E4045 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4045.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct S { a : Int, b : Int }\nlet a : Int = match S::{ a: 2, b: 3 } {\n  { a: 2, .. } => 5\n  _ => 6\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Record Definition/Matching in Moonbit\nDESCRIPTION: This code snippet demonstrates the E4043 error in Moonbit, which happens when a record field (in this case, 'a') is defined multiple times during record creation and when pattern matching. The error occurs because Moonbit enforces that record fields are uniquely specified.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4043.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct S { a : Int }\nlet a : Int = match S::{ a: 2, a: 3 } {\n  { a: 2, a: 3 } => 4\n  _ => 5\n}\n```\n\n----------------------------------------\n\nTITLE: SquareMap Data Structure Implementation in Rust\nDESCRIPTION: This Rust code implements a `SquareMap` data structure for storing Sudoku grid values, using an array as the underlying storage. It provides methods for creating a `SquareMap`, copying it, and accessing/setting values using the `op_get` and `op_set` methods, which enable convenient syntax like `table[\"A2\"]`.  This struct represents the 9x9 Sudoku grid.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/sudoku/index.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct SquareMap[T] {\n  contents : Array[T]\n}\n\nfn SquareMap::new[T](val : T) -> SquareMap[T] {\n  { contents : Array::make(81, val) }\n}\n\nfn copy[T](self : SquareMap[T]) -> SquareMap[T] {\n  let arr = Array::make(81, self.contents[0])\n  let mut i = 0\n  while i < 81 {\n    arr[i] = self.contents[i]\n    i = i + 1\n  }\n  return { contents : arr }\n}\n\nfn op_get[T](self : SquareMap[T], square : String) -> T {\n  self.contents[square_to_int(square)]\n}\n\nfn op_set[T](self : SquareMap[T], square : String, x : T) -> Unit {\n  self.contents[square_to_int(square)] = x\n}\n```\n\n----------------------------------------\n\nTITLE: Async Primitive Example in MoonBit\nDESCRIPTION: This code provides an example of how the `%async.suspend` and `%async.run` primitives work together. `suspend` captures the current coroutine's continuation and passes it to a callback for resuming or throwing an error. This enables coroutine cancellation.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/async-experimental.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nfn async_worker(i: Int) -> Int:\n  builtin %println(debug_show(\"async_worker \" + debug_show(i)))\n  let result = %async.suspend[Int]((cb: Result[fn(Int), fn(Error)]) => {\n    builtin %println(debug_show(\"suspend \" + debug_show(i)))\n    match cb {\n      Ok(resume_ok) => {\n        builtin %println(debug_show(\"resume_ok \" + debug_show(i)))\n        resume_ok(i + 1)\n      }\n      Err(resume_err) => {\n        builtin %println(debug_show(\"resume_err \" + debug_show(i)))\n        resume_err(Error::new(\"resume_err\"))\n      }\n    }\n  })\n  builtin %println(debug_show(\"after suspend \" + debug_show(i)))\n  result\n\nfn run_async() -> Result[Int, Error]:\n  %async.run(() => {\n    let result = async_worker(1)\n    builtin %println(debug_show(\"result: \" + debug_show(result)))\n  })\n\n```\n\n----------------------------------------\n\nTITLE: Running Sphinx Autobuild for Live Document Reloading\nDESCRIPTION: This command utilizes `sphinx-autobuild` to automatically rebuild the documentation upon changes, allowing for live previewing during development. It specifies the source directory ('.') and the output directory ('./_build/html').\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/README-zh.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsphinx-autobuild . ./_build/html\n# 或者 sphinx-autobuild -D language='zh_CN' . ./_build/html\n```\n\n----------------------------------------\n\nTITLE: Optional Parameter without Default Value\nDESCRIPTION: Demonstrates the syntax for defining an optional parameter without a default value in MoonBit. If the parameter `a` is not provided when calling the function `f`, its value will be `None` by default. The type of `a` is `Int?`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3015.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(a? : Int) -> Unit { // a has type Int?\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Record Construction in MoonBit\nDESCRIPTION: Illustrates the error E4093 in MoonBit, which occurs when trying to construct a non-record type (enum) using record syntax. The code attempts to initialize a `Point` enum variant with named fields, leading to the error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4093.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nenum Point {\n  D2(Double, Double)\n  D3(Double, Double, Double)\n}\n\nfn main {\n  let a = Point::{ x : 1.0, y : 2.0 }\n  //      ^~~~~\n  // Error: The type Point is not a record type\n}\n```\n\n----------------------------------------\n\nTITLE: Calling Trait Implementations with Dot Syntax in MoonBit\nDESCRIPTION: This snippet demonstrates calling trait implementations via dot syntax. It showcases the rules for resolving method calls when both regular methods and trait implementations are available.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_18\n\nLANGUAGE: moonbit\nCODE:\n```\n// start trait 8\ntrait Foo {\n  fn bar(self : Self) -> Int\n}\n\nimpl Foo for Int with bar(self) {\n  self + 1\n}\n\nfn main {\n  1.bar()\n}\n```\n\n----------------------------------------\n\nTITLE: Functional Loop Example in MoonBit\nDESCRIPTION: Demonstrates a functional loop in MoonBit using the `loop` keyword, including arguments, a loop body with pattern matching, and the use of `continue` and `break` keywords for controlling loop flow. If no pattern matches, the loop will panic.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_67\n\nLANGUAGE: moonbit\nCODE:\n```\nloop 9(x : Int) : Int {\n  case x < 0 => break 0\n  case x == 0 => break 1\n  case x > 10 => break 2\n  case _ => continue x - 1\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit 'for in' Loop with Tuple Destructuring\nDESCRIPTION: This code demonstrates how to iterate over an array of tuples and destructure each tuple inside the loop body.  The code iterates over an array of tuples [(1, 2, 3), (4, 5, 6)] and assigns each tuple to variable 'v'. Inside the loop, the tuple 'v' is then destructured into variables a, b, and c using a 'let' binding.  This allows accessing the individual elements of the tuple within the loop.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4133.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  for v in [(1, 2, 3), (4, 5, 6)] {\n    let (a, b, c) = v\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Positional Argument Without Default Value in MoonBit\nDESCRIPTION: Shows how to define a positional argument in MoonBit without a default value. This requires the argument to be explicitly provided when calling the function. The code defines the `greet` function with a required `name` argument.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3010.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn greet(name: String) -> Unit {\n  println(\"Hello, \" + name + \"!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Unused Struct Fields in MoonBit\nDESCRIPTION: This example demonstrates the E0007 error when struct fields are unused. It shows a struct `S` with a field `value` that is never read. The code produces a warning during compilation due to this unused field.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0007.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct S {\n  value : Int // Warning: Field 'value' is never read\n}\n\nfn main {\n  ignore(S::{ value : 1 })\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Error Type Usage in MoonBit\nDESCRIPTION: This MoonBit code snippet demonstrates the incorrect usage of a non-error type (String) after the '!' in a function's return type. This will raise error E4127. The function attempts to raise a string literal as an error, which is not allowed directly in MoonBit.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4127.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn may_raise_error() -> Unit!String {\n  //                             ^~~~~~\n  // Error: Type String is not an error type.\n  raise \"Failed\" // Error: Type String is not an error type.\n}\n```\n\n----------------------------------------\n\nTITLE: Duplicate Toplevel Function Definition in MoonBit\nDESCRIPTION: This code snippet demonstrates the E4051 error in MoonBit that happens when defining two toplevel functions with the same name. The second declaration of the function 'f' causes a compiler error because function names must be unique at the top level.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4051.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f() -> Unit {}\npub fn f() -> Unit {} // Error: The toplevel identifier f is declared twice: it was previously defined at ...\n```\n\n----------------------------------------\n\nTITLE: Defining a pub(open) trait in MoonBit\nDESCRIPTION: This code defines a trait `T` within a MoonBit package `a` (module `username/hello`). The trait has a function `f` that takes `Self` as input and returns an `Int`. The `pub(open)` visibility modifier allows external packages to implement this trait.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4073.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\n// We need the trait to be pub(open) so that it can be implemented from outside.\npub(open) trait T {\n  f(Self) -> Int\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit: Test count_qualified_students function\nDESCRIPTION: This code defines a test case for the `count_qualified_students` function in MoonBit.  It creates an array of students, defines lambda expressions to represent different qualification criteria, and uses `assert_eq!` to verify that the function returns the correct count of qualified students for each criteria.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/tutorial/tour.md#_snippet_12\n\nLANGUAGE: moonbit\nCODE:\n```\ntest \"count qualified students\" {\n  let students = [\n    { id: \"0\", score: 10.0 },\n    { id: \"1\", score: 50.0 },\n    { id: \"2\", score: 61.0 },\n  ]\n  let criteria1 = fn(student) { is_qualified(student, 10) }\n  let criteria2 = fn(student) { is_qualified(student, 50) }\n  assert_eq!(count_qualified_students(students, criteria1), 3)\n  assert_eq!(count_qualified_students(students, criteria2), 2)\n}\n\n```\n\n----------------------------------------\n\nTITLE: For Loop Expression\nDESCRIPTION: This code snippet represents a basic for loop structure similar to C-style for loops. It initializes variables in the 'init' section, checks the 'condition', executes the loop body if the condition is true, runs the 'increment' expression, and repeats the process until the condition becomes false.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/moonbit-tour/tour/chapter1_basics/lesson10_loop/index.md#_snippet_0\n\nLANGUAGE: MoonBit\nCODE:\n```\nfor init; condition; increment {\n    // loop body\n}\n```\n\n----------------------------------------\n\nTITLE: G-Machine Initial Code Definition in MoonBit\nDESCRIPTION: This MoonBit code defines the initial code for the G-Machine. This sets up the initial state of the machine, including the code to be executed.  Changing the initial code allows for the execution of programs that utilize lazy lists and custom data structures.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-3.md#_snippet_14\n\nLANGUAGE: moonbit\nCODE:\n```\n/* start init definition */\nlet init_code = {\n  let fibs = E_App(E_App(E_Var(`Cons`), E_Num(0)), E_App(E_App(E_Var(`Cons`), E_Num(1)), E_App(E_App(E_App(E_Var(`zipWith`), E_Var(`add`)), E_Var(`fibs`)), E_App(E_Var(`tail`), E_Var(`fibs`)))))\n  compileE(fibs, [], []).push(GPrint).push(Halt)\n}\n\n{\n  code : init_code,\n  stack : [],\n  heap : [],\n  globals : [\n    (`add`, builtin_add_addr),\n    (`zipWith`, builtin_zipWith_addr),\n    (`tail`, builtin_tail_addr),\n    (`Cons`, builtin_cons_addr),\n    (`Nil`, builtin_nil_addr)\n  ],\n  output : [],\n}/* end init definition */\n```\n\n----------------------------------------\n\nTITLE: Erroneous Method Definition for Built-in Type (MoonBit)\nDESCRIPTION: This code snippet shows the E4059 error occurring when a method `f` is defined directly on the built-in type `Int`. MoonBit does not allow extending built-in types with new methods.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4059.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(self : Int) -> Int { // Error: Cannot define method f for builtin type Int\n  0\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Enum Usage in MoonBit: Singleton Value\nDESCRIPTION: This snippet demonstrates the correct way to assign an enum variant without a payload to a variable in MoonBit. Instead of calling the constructor like a function, the variant is directly assigned as a singleton value. This avoids the E4007 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4007.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\n// ...\nfn main {\n  let status = Done\n}\n```\n\n----------------------------------------\n\nTITLE: Bruijn Index Conversion Function Signature in MoonBit\nDESCRIPTION: This code snippet shows the function signature for converting a standard Lambda term (`Term`) to a de Bruijn indexed Lambda term (`TermDBI`) in MoonBit. The function returns a `Result` type, indicating either success (`Ok`) with the converted term or failure (`Err`) with an error message.  This function is crucial for eliminating variable capture issues during reduction.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/lambda/index.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nfn bruijn(self : Term) -> Result[TermDBI, String]\n```\n\n----------------------------------------\n\nTITLE: Corrected Type Parameter Usage MoonBit\nDESCRIPTION: This code snippet provides a corrected version where the type parameter `T` is used in the function signature for both the input argument and the return type. This resolves the E4027 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4027.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn id[T](a: T) -> T { a }\n```\n\n----------------------------------------\n\nTITLE: Python Environment Setup\nDESCRIPTION: This snippet creates a virtual environment, activates it, and installs the required Python packages from `requirements.txt`. This isolates the project's dependencies.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m venv .env\nsource .env/bin/activate\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: FFI Function with Concrete Type (Suggestion)\nDESCRIPTION: This code snippet provides a suggestion for resolving the E4008 error by using a concrete type (Int) instead of a type parameter in the FFI function declaration. This allows the FFI function to be defined correctly.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4008.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nextern \"js\" fn int_id(x: Int) -> Int = \"(x) => x\"\n```\n\n----------------------------------------\n\nTITLE: MoonBit: Implement count_qualified_students with for..in loop\nDESCRIPTION: This code implements the `count_qualified_students` function in MoonBit using a `for .. in` loop for iterating over the array of students. It checks each student's qualification using the provided `is_qualified` function and increments the counter if the student has passed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/tutorial/tour.md#_snippet_15\n\nLANGUAGE: moonbit\nCODE:\n```\nfn count_qualified_students(\n  students : Array[Student],\n  is_qualified : (Student) -> ExamResult\n) -> Int {\n  let mut count = 0\n  for student in students {\n    if is_qualified(student) == Pass { count += 1}\n  }\n  count\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing search function in Moonbit\nDESCRIPTION: This code snippet presents the implementation of the `search` function in Moonbit. This function performs either a forward or backward search within a given `Box` to find a Snake. It calculates the previous coordinate (`px`) and converts between global and local coordinates. The backward search minimizes `y` as a heuristic, although minimizing `x` would also work.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff3.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nfn search(d: Int, v: Array[Int], a: Array[String], b: Array[String], box: Box, forward: Bool) -> Option[Snake] {\n  let x0 = box.x0\n  let y0 = box.y0\n  let x1 = box.x1\n  let y1 = box.y1\n  let w = x1 - x0\n  let h = y1 - y0\n\n  let delta = w - h\n\n  if forward {\n    for k in range(-d, d + 1, 2) {\n      let real_k = k + w - h\n      let prev_k = real_k - 1\n      let next_k = real_k + 1\n\n      let px = if k == -d || v[prev_k] < v[next_k] {\n        v[next_k]\n      } else {\n        v[prev_k] + 1\n      }\n\n      let py = px - k\n      let mut x = px\n      let mut y = py\n\n      while x < x1 && y < y1 && x >= x0 && y >= y0 && a[x] == b[y] {\n        x = x + 1\n        y = y + 1\n      }\n\n      v[real_k] = x\n      if delta % 2 != 0 && delta - d <= k && k <= delta + d && x > v[k + w - h] {\n        return Some(Snake { x: x, y: y, px: px, py: py })\n      }\n    }\n  } else {\n    for c in range(-d, d + 1, 2) {\n      let real_c = c + d\n      let prev_c = real_c - 1\n      let next_c = real_c + 1\n\n      let px = if c == d || v[prev_c] < v[next_c] {\n        v[prev_c]\n      } else {\n        v[next_c] + 1\n      }\n\n      let py = px - (delta + c)\n      let mut x = px\n      let mut y = py\n\n      while x > x0 && y > y0 && x <= x1 && y <= y1 && a[x - 1] == b[y - 1] {\n        x = x - 1\n        y = y - 1\n      }\n\n      v[real_c] = x\n\n      if delta % 2 == 0 && -d - delta <= c && c <= d - delta && x < v[c + d] {\n        return Some(Snake { x: x, y: y, px: px, py: py })\n      }\n    }\n  }\n  None\n}\n\n```\n\n----------------------------------------\n\nTITLE: Erroneous Record Matching in MoonBit\nDESCRIPTION: This snippet demonstrates the error E4044, which occurs when trying to match a record without providing all fields in the pattern. It highlights the problem of unmatched record fields during pattern matching in MoonBit.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4044.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct S { a : Int; b: Int }\nlet a : Int = match S::{ a: 2, b: 3 } {\n  { a: 2 } => 4\n  _ => 6\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Infix Operator Usage in MoonBit\nDESCRIPTION: This code demonstrates an attempt to use the infix operator `+` on a user-defined struct `S` without implementing the necessary `op_add` method. It showcases the error that occurs when an infix operator is used on a type that doesn't provide the corresponding method.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4016.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct S { v : Int }\n\nlet s : S = { v: 3 }\nlet t = s + s\n```\n\n----------------------------------------\n\nTITLE: Compile If and Negate Functions\nDESCRIPTION: This snippet compiles the `if` and `negate` functions in a strict context, providing special handling due to their specific argument requirements.  This demonstrates function specific compilation logic.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-3.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\n| App(`if, [e1, e2, e3]) => compileC e1 ++ compileE e2 ++ compileE e3 ++ [Prim If]\n| App(`negate, [e1]) => compileC e1 ++ [Prim Negate]\n```\n\n----------------------------------------\n\nTITLE: Corrected Function Arity in Moonbit\nDESCRIPTION: Shows the corrected code where the function 'f' is called with the correct number of arguments (two in this case). This avoids the arity mismatch error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4080.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  f(0, 1.0)\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Super Combinator Instantiation Code with compileR - MoonBit\nDESCRIPTION: The `compileR` function generates code for instantiating super combinators. It calls `compileC` to compile the body of the super combinator and then appends three instructions: `Update(N)` to update the original redex, `Pop(N)` to clear redundant addresses from the stack, and `Unwind` to find the next redex for reduction. N represents the number of parameters.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_22\n\nLANGUAGE: moonbit\nCODE:\n```\n// compileR generates code for instantiating super combinators\nfn compileR(env: Env, body: Expr, n: Int) -> Code {\n    // Placeholder implementation\n    Code::Nil\n}\n```\n\n----------------------------------------\n\nTITLE: Building Localized HTML Documentation with Make\nDESCRIPTION: This command builds the HTML documentation for a specific language (zh_CN in this case) using `make`, setting the `LANGUAGE` environment variable. It then serves the generated HTML files using a simple Python HTTP server.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/README-zh.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nLANGUAGE=\"zh_CN\" make html\npython3 -m http.server -d _build/html\n```\n\n----------------------------------------\n\nTITLE: Corrected Return Inside Function - MoonBit\nDESCRIPTION: This code snippet provides the corrected version of the erroneous example, demonstrating how to properly structure the code without using `return` statements outside a function. Instead of returning from the `let` binding, the value is directly assigned.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4109.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub let x: Int = 42\npub let y: Int = {\n  if x == 42 {\n    x + 1\n  } else {\n    0\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Map Creation with Map::of\nDESCRIPTION: Creates a map using the `Map::of` function. This function takes an array of two-element tuples, where the first element is the key and the second element is the value. This method is required when the map keys or values are not basic types.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/moonbit-tour/tour/chapter1_basics/lesson8_map/index.md#_snippet_1\n\nLANGUAGE: MoonBit\nCODE:\n```\nMap::of([(key1, value1), (key2, value2)])\n```\n\n----------------------------------------\n\nTITLE: Enabling Linking in moon.pkg.json\nDESCRIPTION: This JSON snippet shows how to enable linking for a package using the `link` option. Setting `link` to `true` indicates that the package should be linked, and the output will vary depending on the specified backend during the build process.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/package.md#_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"link\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Enum Constructor with Explicit Unit Argument in MoonBit\nDESCRIPTION: This example shows how to define an enum constructor that explicitly takes a `Unit` argument, allowing it to be called with parentheses. This approach can be used if the constructor needs to explicitly construct values. The `Done` variant of the `Status` enum is defined to take a `Unit` argument.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4007.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nenum Status {\n  Done(Unit)\n  Pending\n}\n\nfn main {\n  let status = Done(())\n}\n```\n\n----------------------------------------\n\nTITLE: Install and Preview MoonBit Tour\nDESCRIPTION: This snippet installs the necessary dependencies, builds the MoonBit language tour project, and starts a local preview server.  It requires pnpm to be installed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/moonbit-tour/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm install\npnpm build\npnpm preview\n```\n\n----------------------------------------\n\nTITLE: Correct Enum Construction in MoonBit\nDESCRIPTION: Demonstrates the correct way to construct an enum variant in MoonBit. The code initializes the `Point::D2` variant by passing the required `Double` values directly to the constructor, avoiding the record syntax error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4093.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let a = Point::D2(1.0, 2.0)\n}\n```\n\n----------------------------------------\n\nTITLE: Define a Non-constant Enum with Custom Tag Values in MoonBit\nDESCRIPTION: This snippet shows an example of an invalid non-constant enum `Bad` in MoonBit that will result in the E4154 error. It attempts to assign custom integer values to the constructors A and B, but constructor C has a payload of type `Int`, making the enum non-constant. Custom tag values are not permitted in this situation.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4154.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nenum Bad {\n  A = 1\n  B = 2\n  C(Int)\n}\n```\n\n----------------------------------------\n\nTITLE: Inconsistent Size Trait Implementations for Array in Moonbit\nDESCRIPTION: This snippet demonstrates the E4135 error in Moonbit. It attempts to implement the `Size` trait for `Array[T]` twice, once with the constraint `T : ByteSize` and once with the constraint `T : WordSize`. This results in an error because the implementations have different constraints. The error message highlights the conflicting implementations at specific lines.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4135.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nimpl[T : ByteSize] Size for Array[T] with size(self) {\n  self.length() * T::byte_size()\n}\n\nimpl[T : WordSize] Size for Array[T] with size(self) {\n//<~~~~~~~~~~~~~~~\n// Error: Inconsistent `impl` of trait Size for Array at 11:1 and 15:1:\n//   type parameters of implementations have different constraints\n  self.length() * T::word_size() * 4\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving FromJson and ToJson with arguments in MoonBit\nDESCRIPTION: This example shows deriving `FromJson` and `ToJson` traits with arguments for configuration. This allows customizing the serialization and deserialization behavior. Note that the behavior of JSON serialization arguments is unstable.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/derive.md#_snippet_8\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Point { x: Int; y: Int } derive(FromJson, ToJson)\n\nfn main() {\n    // Example usage with arguments for FromJson and ToJson\n    // would go here, but is not directly shown in this snippet\n}\n```\n\n----------------------------------------\n\nTITLE: Errorneous Function Call in MoonBit\nDESCRIPTION: This code snippet demonstrates an erroneous function call in MoonBit. The function `may_raise_error` may raise an error, but the call in `main` doesn't handle it using `!` or `?`, leading to a compilation error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4120.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn may_raise_error(input : Int) -> Unit! {\n  if input == 42 {\n    return\n  }\n  fail!(\"failed\")\n}\n\nfn main {\n  may_raise_error(42)\n  // Error: The application might raise errors of type Error, but it's not handled.\n  // Try adding a infix operator `!` or `?` to the application, so that it looks like `...!(...)` or `...?(...)`.\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Type/Trait Usage in MoonBit\nDESCRIPTION: This code snippet demonstrates an erroneous example where the `Sh0w` type/trait is used incorrectly, leading to a 'Type/Trait not found' error. The correct trait name `Show` or type name `Bool` should be used instead to resolve this issue.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4024.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nlet a = Sh0w::to_string(true)\n```\n\n----------------------------------------\n\nTITLE: Suggestion: Using an alternative type name\nDESCRIPTION: Suggests using an alternative name, such as `MyError`, to avoid the E4003 error. This allows creating a custom type without conflicting with the reserved 'Error' type name.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4003.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct MyError {}\n```\n\n----------------------------------------\n\nTITLE: Trait with Distinct Method Names in MoonBit\nDESCRIPTION: This code snippet illustrates an alternative solution for handling different method behaviors in a MoonBit trait. Instead of declaring the same method multiple times, distinct method names are used, such as `make_sound` and `make_loud_sound`. This allows for different implementations without causing the E4005 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4005.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait Animal {\n  make_sound(Self) -> String\n  make_loud_sound(Self) -> String  // Use a different name for different behavior\n}\n```\n\n----------------------------------------\n\nTITLE: Private Struct with Constructor and Method in MoonBit\nDESCRIPTION: This code shows a private struct `A` with a constructor function `A::new` and a method `A::value`. This approach allows controlled instantiation of the struct within its own package.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0009.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\npriv struct A {\n  value : Int\n}\n\nfn A::new(value : Int) -> A {\n  A::{ value }\n}\n\nfn A::value(self : A) -> Int {\n  self.value\n}\n```\n\n----------------------------------------\n\nTITLE: Mutable Array Declaration - Moonbit\nDESCRIPTION: This Moonbit code demonstrates the error scenario where a mutable array 'x' is declared but its mutability is not required. The code assigns a new value to an element of the array, which doesn't necessitate the array itself being mutable, leading to the E0015 warning. It requires Moonbit language support.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0015.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let mut x = [1, 2, 3] // Warning: The mutability of 'x' is never used.\n  x[0] = 0\n  println(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Guard Condition and Partial Match Warning in MoonBit\nDESCRIPTION: This snippet demonstrates a case where using guard conditions may result in a partial match warning, because the compiler does not consider the guard conditions when checking pattern coverage.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_103\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(x : Int) -> Int {\n  match x {\n    y if y > 0 => y\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Enum Constructor Fields in MoonBit\nDESCRIPTION: This example shows how to use enum constructor fields in a pattern match to resolve the E0007 error. It expands the pattern to access the fields and use them, thus avoiding the warning.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0007.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  // ...\n  match A(1) {\n    A(x) => println(\"A({\\{x}})\")\n    B(value~) => println(\"B({\\{value}})\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Newtype Access Example - MoonBit\nDESCRIPTION: This code demonstrates the correct way to access a field of a struct wrapped in a newtype in MoonBit. By defining `Outer` as a true `type` rather than `type!`, the `value` field can be accessed directly.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4136.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntype Outer Inner\n\nfn main {\n  let outer : Outer = Inner::{ value: 1 }\n  println(outer.value)\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Map Pattern Matching in MoonBit\nDESCRIPTION: This code snippet demonstrates an erroneous example where map pattern matching is attempted on a custom type `MyMap` without implementing the `op_get` method. This results in the E4118 error. The code defines a `MyMap` type and tries to match a map pattern against it in a `match` expression, causing a compile-time error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4118.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntype MyMap[K, V] Map[K, V]\n\nfn main {\n  let map : MyMap[String, Int] = { \"a\": 1, \"b\": 2, \"c\": 3 }\n  match map {\n    { \"a\": a, .. } => println(\"a: \\{a}\")\n  //^~~~~~~~~~~~~~\n  // Error: Please implement method `op_get` for type MyMap[String, Int] to match it with map pattern.\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct op_add implementation in MoonBit\nDESCRIPTION: This code snippet shows the corrected implementation of the `op_add` method for the custom type `A` in MoonBit. It demonstrates the correct number of arguments (two) required for overloading the `+` operator, resolving the E4065 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4065.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn A::op_add(self : A, other : A) -> A {\n  self._ + other._\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Default Value Definition in MoonBit\nDESCRIPTION: Illustrates the E3010 error in MoonBit where a default value is incorrectly assigned to a positional argument. The code attempts to define a default value for the `name` argument in the `greet` function, which is not allowed for positional arguments.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3010.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn greet(name : String = \"World\") -> Unit {\n  //                   ^ Error: Only labelled arguments can have default value.\n  println(\"Hello, \" + name + \"!\")\n}\n```\n\n----------------------------------------\n\nTITLE: FixedArray Pitfall in MoonBit\nDESCRIPTION: This code demonstrates a common pitfall when creating a `FixedArray` with the same initial value. All cells reference the same object, leading to unexpected behavior when modifying elements.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_24\n\nLANGUAGE: moonbit\nCODE:\n```\nlet arr : FixedArray[Int] = FixedArray::make(3, 0)\narr[0] = 1\nIO::println(Debug::toString(arr)) // [1, 1, 1]\n```\n\n----------------------------------------\n\nTITLE: Second Main Function in Separate Package (MoonBit)\nDESCRIPTION: Defines a `main` function within the `main2` package. Because it is in a different package from the first `main` function, there is no conflict. The program will run and print the specified text.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4068.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  println(\"Hello, World! Again!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Number Range with until Method MoonBit\nDESCRIPTION: This code snippet shows how to generate a range of numbers in MoonBit using the `until` method. This method provides an alternative to range operators when they cannot be used directly, such as when assigning a range to a variable.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4137.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let range = (0).until(10)\n  for i in range {\n    println(i)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Split and Pack instructions definition in MoonBit\nDESCRIPTION: This MoonBit code defines the `Split` and `Pack` virtual machine instructions for deconstructing and constructing lists. These instructions are essential for handling custom data structures like lazy lists in the G-Machine.  The `Split` instruction is used to deconstruct a list into its head and tail, while the `Pack` instruction is used to construct a new list from a head and a tail.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-3.md#_snippet_9\n\nLANGUAGE: moonbit\nCODE:\n```\n/* start split_pack definition */\n  | Split {\n    // sp -> addr of list (nconstr)\n    // if head is Nil, jump to the label\n    // otherwise,\n    //   move head node addr to sp + 0\n    //   move tail node addr to sp + 1\n    //   continue\n    fail : Label, \n  }\n  | Pack {\n    // sp+0: head node addr\n    // sp+1: tail node addr\n    // addr <- Cons head tail\n    // sp -> addr\n  }\n  /* end split_pack definition */\n```\n\n----------------------------------------\n\nTITLE: Invalid MoonBit Package JSON\nDESCRIPTION: This example demonstrates an invalid `moon.pkg.json` file that will cause the E3017 error due to a missing comma after the `\"is-main\": true` line. This can be caught by a JSON parser.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3017.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"is-main\": true\n  \"import\": [] // Error: Expect_comma_or_rbrace\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Anonymous Function Error E4134 in MoonBit\nDESCRIPTION: This code shows the corrected version of the erroneous example, resolving the MoonBit compiler error E4134. The fix involves updating the anonymous function's return type annotation to include the error type (`Int!`). This indicates that the function can return either an `Int` or an error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4134.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let draw : (Int) -> Int! = fn(luck : Int) -> Int! {\n    if luck == 7 {\n      return 42\n    }\n    fail!(\"Bad luck\")\n  }\n  try {\n    println(\"Draw: \\{draw!(7)}\")\n  } catch {\n    error => println(\"Error: \\{error}\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous MoonBit For-Loop Example\nDESCRIPTION: This example demonstrates the E4106 error in MoonBit. The variable `j` is used in the update expression of the for-loop but is not declared in the initialization block, leading to the error. The function `f` takes an integer `x` and attempts to print `i` and `j` within the loop.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4106.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(x: Int) -> Unit {\n  let mut j = 0\n  for i = 0; i < x; i = i + 1, j = j + 1 {\n//                             ^ --- Error: Unknown binder j in the for-loop\n//                                          steps. Binders in the steps must be\n//                                          declared in the initialization\n//                                          block of the for-loop.\n    println(i)\n    println(j)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Return Type Annotation\nDESCRIPTION: Demonstrates the corrected code snippet by adding the explicit return type annotation to the function definition. In this case, the function returns `Unit`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4076.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f() -> Unit {\n}\n```\n\n----------------------------------------\n\nTITLE: Result or example\nDESCRIPTION: Example of using the or method on result to default to a value.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_20\n\nLANGUAGE: moonbit\nCODE:\n```\nlet res1: Result[Int, String] = Err(\"error\")\nlet value = res1.or(0) // 0\n```\n\n----------------------------------------\n\nTITLE: Dot Syntax with Package Alias in MoonBit\nDESCRIPTION: This snippet demonstrates how dot syntax works when using packages with alias lists, showcasing method invocation using a type from an aliased package.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\n// start dot syntax example\nimport Foo as F\n\nfn f(self : F::Foo) -> Int {\n  1\n}\n\nfn main {\n  let foo = F::Foo {}\n  foo.f()\n}\n```\n\n----------------------------------------\n\nTITLE: cc-link-flags configuration in moon.pkg.json\nDESCRIPTION: This JSON snippet shows how to add `cc-link-flags` to `moon.pkg.json` to dynamically link with a foreign C library. These flags are passed directly to the C compiler.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/ffi.md#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  // ...\n  \"link\": {\n    \"native\": {\n      \"cc-link-flags\": \"-l<c library>\"\n    }\n  },\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Map Value Update\nDESCRIPTION: Updates the value associated with a key in the map using the `map[key] = new_value` syntax. If the key exists, its value is updated. If the key does not exist, it may be added to the map, depending on the implementation details of the map data structure.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/moonbit-tour/tour/chapter1_basics/lesson8_map/index.md#_snippet_3\n\nLANGUAGE: MoonBit\nCODE:\n```\nmap[key] = new_value\n```\n\n----------------------------------------\n\nTITLE: Corrected Trait Method Call in MoonBit\nDESCRIPTION: This code snippet shows the corrected version of the erroneous example, using the correct method name `to_string` instead of the non-existent `to_str` when calling a method from the `Show` trait in MoonBit.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4039.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nlet a : String = Show::to_string(42)\n```\n\n----------------------------------------\n\nTITLE: Partial Match Example (Erroneous) - MoonBit\nDESCRIPTION: This MoonBit code snippet demonstrates an erroneous example of a partial match. The `match` expression only handles the `Some(x)` case and does not account for the `None` case of the `Option` type, resulting in a compiler warning.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0011.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  match Some(1) { // Partial match, some hints: None\n    Some(x) => println(x)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Package definition for package b - JSON\nDESCRIPTION: This JSON code defines the package configuration for the MoonBit package 'b'. It specifies that package 'b' imports package 'a' (username/hello/a). This import is necessary to access the type A and trait B from package a.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4061.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"import\": [\n    \"username/hello/a\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Suggesting Removal of Conflicting Implementation in Moonbit\nDESCRIPTION: This snippet suggests removing one of the conflicting implementations of the `Size` trait for `Array[T]` as a solution to the E4135 error. It shows the `WordSize` implementation commented out.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4135.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\n// Remove the implementation for WordSize\n// impl[T : WordSize] Size for Array[T] with size(self) {\n//   self.length() * T::word_size() * 4\n// }\n```\n\n----------------------------------------\n\nTITLE: Module Version Configuration in moon.mod.json\nDESCRIPTION: Configures the 'version' field in moon.mod.json, specifying the module's version.  This field is optional, but for modules published to mooncakes.io, the version must adhere to Semantic Versioning 2.0.0.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/module.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"example\",\n  \"version\": \"0.1.0\",\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Test Without Parameters\nDESCRIPTION: Illustrates how to define a test function in MoonBit without any parameters. This is also a valid way to define tests when the test context is not needed.  It avoids the E4132 compiler error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4132.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Toplevel Declaration in MoonBit\nDESCRIPTION: Illustrates a MoonBit code snippet that triggers the E0019 error due to leading spaces before the `let` declaration. This example demonstrates incorrect syntax where the toplevel declaration is not left-aligned.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0019.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\n  let x = 1\n```\n\n----------------------------------------\n\nTITLE: Incorrect Option Usage in MoonBit\nDESCRIPTION: This code snippet demonstrates the E4040 error in MoonBit by attempting to instantiate the `Option` type without providing any type arguments. The `Option` type requires one type argument to specify the type it holds.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4040.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nlet a : Option = Some(3)\n```\n\n----------------------------------------\n\nTITLE: Using Integer Range and Conversion in MoonBit\nDESCRIPTION: This snippet shows the correct usage of range operators with integer types in MoonBit. It iterates over the integer range from 0 to 9, converts each integer to a float using `to_float()`, and then prints the float value.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4138.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  for i in 0..<10 {\n    println(i.to_float())\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Record Assignment - MoonBit\nDESCRIPTION: This code snippet demonstrates the E4028 error in MoonBit. It attempts to assign a record literal to a variable declared as an Int, which is a non-record type. The MoonBit compiler flags this as an error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4028.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct T { a : Int }\nlet a : Int = { a: 42 }\n```\n\n----------------------------------------\n\nTITLE: Conditional Expression Example in MoonBit\nDESCRIPTION: This code snippet demonstrates a conditional expression in MoonBit. It evaluates a condition and returns one of two values based on the result. The curly brackets around the consequent are required.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_47\n\nLANGUAGE: moonbit\nCODE:\n```\nif cond { consequent } else { alternative }\n```\n\n----------------------------------------\n\nTITLE: Resolving Ambiguous Record Initialization in MoonBit\nDESCRIPTION: This MoonBit code snippet demonstrates how to resolve the E4034 error by adding a type annotation. By explicitly specifying the type of the variable `c`, the compiler can correctly infer the intended record type, resolving the ambiguity.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4034.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  struct S { x : Int; y : Int }\n  struct T { x : Int; y : Int }\n  let c : S = { x: 2, y: 1 }\n  let c2 = S::{ x : 2, y : 1 }\n}\n```\n\n----------------------------------------\n\nTITLE: Loop Label Shadowing Example in MoonBit\nDESCRIPTION: This code snippet demonstrates the E0036 warning in MoonBit where a loop label `l` is reused in a nested loop, shadowing the outer label. This can lead to confusion when using `break` or `continue` statements. The suggestion is to use distinct, descriptive label names.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0036.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(xss : Array[Array[Int]]) -> Unit {\n  l~: for xs in xss {\n    l~: for x in xs {\n//  ^^  Warning: The label name `l` shadows a label name that is already in\n//               scope.\n      if x > 0 {\n        break l~\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Define Moonbit Function\nDESCRIPTION: This Moonbit code defines a public function named `greeting` that returns the string \"Hello, world!\".\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0029.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn greeting() -> String {\n  \"Hello, world!\"\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Coverage Result Files in Target Directory\nDESCRIPTION: This command lists the coverage result files generated in the target directory after running tests with coverage enabled. These files contain information used by the toolchain to determine which parts of the program were executed and which were not.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/coverage.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ ls target/wasm-gc/debug/test/ -w1\narray\n...\nmoonbit_coverage_1735628238436873.txt\nmoonbit_coverage_1735628238436883.txt\n...\nmoonbit_coverage_1735628238514678.txt\noption/\n...\n```\n\n----------------------------------------\n\nTITLE: Renaming Identifiers in MoonBit to Avoid E4051\nDESCRIPTION: This code snippet demonstrates how to resolve the E4051 error in MoonBit by renaming one of the duplicate identifiers. Instead of defining 'a' twice, we define 'a' and 'b'.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4051.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\npub let a = 0\npub let b = 1\n```\n\n----------------------------------------\n\nTITLE: Illustrating E4091: Accessing Non-existent Struct Field (Moonbit)\nDESCRIPTION: This code snippet demonstrates the E4091 error in Moonbit. It defines a struct `Point` with fields `x` and `y`, and then attempts to access a non-existent field `z`, which will trigger the error. The code requires the Moonbit compiler to be installed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4091.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Point {\n  x : Double\n  y : Double\n}\n\nfn main {\n  let point = Point::{ x : 1.0, y : 2.0 }\n  println(point.z) // Error: The type Point has no field z.\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Method Call on String (Moonbit)\nDESCRIPTION: This code snippet demonstrates an incorrect attempt to call the `upper()` method on a string literal in Moonbit. The Moonbit compiler will report an error because the String type does not have a method named `upper()`. The corrected version uses the `to_upper()` method.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4015.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nlet hey = \"hey\".upper()\n```\n\n----------------------------------------\n\nTITLE: Erroneous Main Function Definition (MoonBit)\nDESCRIPTION: Shows an example of the error E4068 by defining two `main` functions within the same `main` package. This is not allowed in MoonBit because each main package must have only one entry point.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4068.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  println(\"Hello, World!\")\n}\n\nfn main { // Error: Main function is already defined at ...\n  println(\"Hello, World! Again!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Suggested MoonBit Code: Labelled Argument\nDESCRIPTION: This MoonBit code demonstrates the suggested refactoring of the previous erroneous example. The optional argument `opt` is converted into a labelled argument. This removes the unused default value and clarifies that the argument must always be explicitly provided.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0032.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(opt~ : Int) -> Int {\n  ignore(opt)\n  0\n}\n\nfn main {\n  println(f(opt=3))\n  println(f(opt=3))\n}\n```\n\n----------------------------------------\n\nTITLE: Block Structure in MoonBit\nDESCRIPTION: This code snippet demonstrates the basic structure of a block in MoonBit. A block consists of a sequence of statements followed by an optional expression. The statements are executed in order, and the result of the block is the evaluation result of the expression, or `()` (Unit) if the expression is omitted.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/moonbit-tour/tour/chapter1_basics/lesson4_block/index.md#_snippet_0\n\nLANGUAGE: MoonBit\nCODE:\n```\n{\n  statement1\n  statement2\n  expression\n}\n```\n\n----------------------------------------\n\nTITLE: Rethrowing Uncaught Errors with catch!\nDESCRIPTION: This snippet demonstrates how to use `catch!` to handle a specific error and rethrow any uncaught errors.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_13\n\nLANGUAGE: moonbit\nCODE:\n```\ntype! E1\ntype! E2\nfn f1() -> Unit!E1 { raise E1 }\nfn f2() -> Unit!E2 { raise E2 }\nfn f() -> Unit! {\n  try {\n    f1!()\n    f2!()\n  } catch! {\n    E1 => println(\"E1\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Optional Arguments in MoonBit (Side Effects)\nDESCRIPTION: This code shows that the default expression for optional arguments is evaluated every time it is used, and any side effects within the expression are triggered.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_39\n\nLANGUAGE: moonbit\nCODE:\n```\nvar counter = 0\nfn increment() -> Int {\n  counter = counter + 1\n  counter\n}\n\nfn foo(x~ : Int = increment()) {\n  IO::println(x)\n}\n\nfoo()\nfoo()\n```\n\n----------------------------------------\n\nTITLE: As-is calling with try...catch\nDESCRIPTION: This snippet shows how to call an error-able function using a `try...catch` block to handle the error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_17\n\nLANGUAGE: moonbit\nCODE:\n```\nfn div3(x : Int, y : Int) -> Unit {\n  try {\n    div!(x, y)\n  } catch { // `catch` and `except` works the same.\n    DivisionByZeroError(e) => println(\"inf: \\{e}\")\n  } else {\n    v => println(v)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Default moon.pkg.json for non-main package in MoonBit\nDESCRIPTION: This JSON configuration file represents the default setting for a non-main package in MoonBit. The absence of `\"is-main\": true` indicates that the package is treated as a library.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4069.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{}\n```\n\n----------------------------------------\n\nTITLE: Corrected Trait Usage in MoonBit\nDESCRIPTION: This code snippet showcases the corrected usage of a trait in MoonBit. It casts a boolean value to a trait named `Show`. This assumes that the `Show` trait is properly defined and available within the current scope.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4023.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nlet a = true as &Show\n```\n\n----------------------------------------\n\nTITLE: Main Function in coreF (Clojure-like)\nDESCRIPTION: Defines the `main` function in coreF, which calls the `factorial` function with the argument 42. Execution of a coreF program begins with `main`. `main` is considered a Constant Applicative Form (CAF).\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_5\n\nLANGUAGE: clojure\nCODE:\n```\n(defn main[] (factorial 42))\n```\n\n----------------------------------------\n\nTITLE: Generating Text Summary Coverage Report\nDESCRIPTION: This command generates a text summary of the code coverage data and prints it to stdout. The report shows the number of covered points and total coverage points for each file in the project. It requires the `moon` command-line tool to be installed and a coverage result to be present.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/coverage.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ moon coverage report -f summary\narray/array.mbt: 21/22\narray/array_nonjs.mbt: 3/3\narray/blit.mbt: 3/3\narray/deprecated.mbt: 0/0\narray/fixedarray.mbt: 115/115\narray/fixedarray_sort.mbt: 110/116\narray/fixedarray_sort_by.mbt: 58/61\narray/slice.mbt: 6/6\narray/sort.mbt: 70/70\narray/sort_by.mbt: 56/61\n...\n```\n\n----------------------------------------\n\nTITLE: Removing Unnecessary Try Expression in Moonbit\nDESCRIPTION: This code snippet shows the suggested solution to Moonbit error E0023. The `try...catch` block has been removed, and the `println` statement is executed directly. This eliminates the unnecessary error handling.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0023.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  println(\"Hello, world!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Cannot Derive Default 1\nDESCRIPTION: This code snippet demonstrates a case where `Default` trait cannot be derived. This is because the enum contains only cases with parameters and it is impossible to create default value for such enums.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/derive.md#_snippet_9\n\nLANGUAGE: moonbit\nCODE:\n```\nenum CannotDerive1 {\n    Case1(String)\n    Case2(Int)\n} derive(Default) // cannot find a constant constructor as default\n```\n\n----------------------------------------\n\nTITLE: Valid MoonBit Package Alias\nDESCRIPTION: This JSON configuration demonstrates a valid package alias in MoonBit. The 'alias' field for the imported package 'username/hello/lib' is set to 'hello', which resolves the E0030 warning. This configuration is used to define the structure and dependencies of a MoonBit project, ensuring clear and unambiguous references to external libraries.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0030.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"is-main\": true,\n  \"import\": [\n    {\n      \"path\": \"username/hello/lib\",\n      \"alias\": \"hello\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Struct Definition with `pub(all)` Visibility\nDESCRIPTION: Modifies the struct `T` in package 'a' to have `pub(all)` visibility. This allows modification of the `value` field from any package. However, it may expose implementation details.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4094.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\npub(all) struct T {\n  mut value : Int\n}\n\n```\n\n----------------------------------------\n\nTITLE: Trait with Duplicate Method Declaration in MoonBit\nDESCRIPTION: This code snippet demonstrates the error E4005 in MoonBit, which occurs when a trait has multiple declarations of the same method name. The `Animal` trait attempts to define the `make_sound` method twice, leading to the error. This highlights the requirement for unique method names within a trait.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4005.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait Animal {\n  make_sound(Self) -> String\n  make_sound(Self) -> String  // Error: method make_sound is declared twice\n}\n```\n\n----------------------------------------\n\nTITLE: Postadd Script Configuration in moon.mod.json\nDESCRIPTION: Defines a custom script that automatically runs after a module is added. The current working directory (cwd) during script execution is the directory where the moon.mod.json file is located. This snippet configures a 'postadd' script to execute a Python build script.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/module.md#_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"postadd\": \"python3 build.py\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring and Assigning Mutable Variables in MoonBit\nDESCRIPTION: This snippet showcases the correct way to declare and assign a new value to a variable in MoonBit by using the `mut` keyword. By declaring `a` as `let mut a = 0`, subsequent assignment `a = 1` is valid.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4087.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let mut a = 0\n  a = 1\n  println(a)\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated Method Call Example (MoonBit)\nDESCRIPTION: This code snippet demonstrates the deprecated method call style in MoonBit that triggers the E0040 error. It defines a type `A` and a method `A::f`. The `main` function then attempts to call `f` directly, resulting in a deprecation warning.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0040.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntype A Int\n\nfn A::f(self : A) -> Int {\n  self._\n}\n\nfn main {\n  let _ = f(A(1))\n  // Warning:\n  // This method is declared as A::f, calling this kind of method directly via\n  // f(..) is deprecated, use qualified syntax A::f(..), or declare the method\n  // as `fn f(self : A, ..)` instead.\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Self Type in Trait Implementation (MoonBit)\nDESCRIPTION: Illustrates the E4053 error when attempting to implement a trait for a type parameter 'X' using 'self' of type 'X', which is not a type constructor. Includes examples with and without constraints.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4053.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub trait A {\n  f(Self) -> Int\n}\n\n// Without constraints\nimpl[X] A for X with f(self : X) -> Int { // Error: Invalid type for \"self\": must be a type constructor.\n  ignore(self)\n  0\n}\n\n// With constraints\nimpl[X: Default] A for X with f(self : X) -> Int { // Error: Invalid type for \"self\": must be a type constructor.\n  ignore(self)\n  0\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous MoonBit code using '?.' together\nDESCRIPTION: This code demonstrates the E4125 error, showing the incorrect usage of the '?' operator after a method chained with '..'.  The '..' operator expects a method returning `Unit`, while `?` converts the result to `Result[T, E]`, leading to a type mismatch. The code defines a struct `A` with methods `check` and `div`. The `main` function attempts to print the result of `a.div(b)..check?()`, which triggers the error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4125.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntype A Double derive(Show)\n\npub fn A::check(self : A) -> Unit! {\n  if self._.is_nan() {\n    fail!(\"NaN\")\n  }\n}\n\npub fn A::div(self : A, other : A) -> A {\n  A(self._ / other._)\n}\n\nfn main {\n  let a : A = 1.0\n  let b : A = 2.0\n  println(a.div(b)..check?())\n}\n```\n\n----------------------------------------\n\nTITLE: Building Markdown Documentation\nDESCRIPTION: This snippet installs the `sphinx-markdown-builder` package using `pip` and then uses `make` to build the documentation in Markdown format. It requires `sphinx-markdown-builder` to be installed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/README-zh.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npip install sphinx-markdown-builder\nmake markdown\n```\n\n----------------------------------------\n\nTITLE: Define Moonbit Module\nDESCRIPTION: This JSON file defines a Moonbit module named `username/hello` with version, readme, and source directory specified.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0029.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"username/hello\",\n  \"version\": \"0.1.0\",\n  \"readme\": \"README.md\",\n  \"source\": \"src\"\n}\n```\n\n----------------------------------------\n\nTITLE: try with local error-able function\nDESCRIPTION: Example of using try-catch with a locally defined function that raises an error and returns a Result type.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_18\n\nLANGUAGE: moonbit\nCODE:\n```\nfn test_try() -> Result[Int, Error] {\n  // compiler can figure out the type of a local error-able function.\n  fn f() -> _!_ {\n    raise Failure(\"err\")\n  }\n\n  try Ok(f!()) { err => Err(err) }\n}\n```\n\n----------------------------------------\n\nTITLE: Native Backend Compiler Flags Configuration\nDESCRIPTION: This JSON snippet demonstrates how to configure the `cc-flags` option for the native backend in the `link` section of a `moon.pkg.json` file. It defines a macro called `MOONBIT` that will be passed to the compiler.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/package.md#_snippet_12\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"link\": {\n      \"native\": {\n        \"cc-flags\": \"-DMOONBIT\"\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Fix: Move Function to Toplevel (MoonBit)\nDESCRIPTION: This example demonstrates the solution of moving the function `h` that uses labelled arguments to the top level of the module. By defining `h` outside of any other function, it becomes a toplevel function, and the labelled argument `x~` is allowed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4114.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn h(x~: Int) -> Unit {\n  println(x)\n}\n\npub fn f() -> Unit {\n  h(x=42)\n}\n```\n\n----------------------------------------\n\nTITLE: Setup Development Environment\nDESCRIPTION: This snippet installs the necessary dependencies and starts the development server for the MoonBit language tour. This allows for live editing and previewing of changes.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/moonbit-tour/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npnpm install\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Suggestion: Discarding the First Binding with '_' (MoonBit)\nDESCRIPTION: This MoonBit code demonstrates shadowing by explicitly discarding the first binding using `_`. The first `Some`'s value is ignored, and only the second `Some(a)`'s value is bound to the identifier 'a'. This effectively shadows any previous binding of 'a' in the pattern.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4081.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(a : Int?, b : Int?) -> Unit {\n  match (a, b) {\n    (Some(_), Some(a)) => println(\"Some({a})\")\n    _ => println(\"None\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous MoonBit Pattern Match with `..` Placement\nDESCRIPTION: This snippet demonstrates the E3007 error in MoonBit, which occurs when `..` is not placed at the end of the pattern in a struct destructuring. The code attempts to destructure a struct `S` but incorrectly places `..` between `a` and `c`, leading to a compilation error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3007.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct S {\n  a : Int\n  b : Int\n  c : Int\n}\n\nfn main {\n  let s : S = { a : 1, b : 2, c : 3 }\n  let { a, .., c } = s\n  //       ^^\n  // Error: Unexpected `..` here, add `, ..` behind the last field to ignore the rest of record.\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous implementation of trait B for type A - MoonBit\nDESCRIPTION: This MoonBit code attempts to implement the trait `@a.B` for type `@a.A` within package 'b'.  This violates the orphan rule since both the trait and the type are defined in a different package ('a'). The code will result in a compilation error, as indicated in the comment.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4061.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nimpl @a.B for @a.A with to_int(self : @a.A) -> Int {\n  //                    ^~~~~~\n  // Error: Cannot define method to_int of trait @a.B from package a for type @a.A from package a\n  self._\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect MoonBit 'for in' Loop\nDESCRIPTION: This code demonstrates the E4133 error in MoonBit, where a 'for in' loop uses three loop variables. MoonBit only supports one or two loop variables in 'for in' loops.  The code attempts to iterate over an array [1, 2, 3] and assign each element to variables a, b, and c, which is not allowed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4133.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  for a, b, c in [1, 2, 3] { // Error: This `for .. in` loop has 3 loop variables, but at most 2 is expected.\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Method Call on String (Moonbit)\nDESCRIPTION: This code snippet shows the correct way to convert a string to uppercase in Moonbit.  It uses the `to_upper()` method which is the correct method for the `String` type. This snippet resolves the E4015 error by using the correct method name.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4015.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nlet hey = \"hey\".to_upper()\n```\n\n----------------------------------------\n\nTITLE: Using 'until' for Floating-Point Range in MoonBit\nDESCRIPTION: This snippet demonstrates using the `until` function in MoonBit to construct a range of floating-point numbers.  It creates an iterator `range` from 0.0 up to (but not including) 10.0, and then iterates over this range, printing each value.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4138.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let range : Iter[Double] = (0.0).until(10.0)\n  for i in range {\n    println(i)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Guard Let Example in Moonbit\nDESCRIPTION: Illustrates the E0038 error where a `guard let` with an irrefutable pattern renders the guard useless.  The code attempts to conditionally abort based on input, but the `guard let _ = input` always succeeds, preventing the early return.  `input` is expected to be an optional Int (`Int?`).\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0038.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(input : Int?) -> Int {\n  guard let _ = input else {\n    Some(_..<0) => abort(\"Invalid input\")\n  }\n  3\n}\n\nfn main {\n  ignore(f(None))\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Self Type in Function Definition (MoonBit)\nDESCRIPTION: Demonstrates the E4053 error when defining a function with 'self' as a type parameter or a function type, which are not type constructors.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4053.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f[T](self : T) -> Int { // Error: Invalid type for \"self\": must be a type constructor.\n  ignore(self)\n  0\n}\n\nfn g(self : (Int) -> Unit) -> Unit { // Error: Invalid type for \"self\": must be a type constructor.\n  self(0)\n}\n```\n\n----------------------------------------\n\nTITLE: Moonbit Unreachable Code Example\nDESCRIPTION: This Moonbit code snippet demonstrates the E0012 error. The `return` statement causes the program to exit the `main` function before the `println` statement is executed, leading to unreachable code.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0012.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  return\n  println(\"Hello, World!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Overloaded Char Literal in MoonBit\nDESCRIPTION: This code snippet demonstrates char literals can be overloaded to type `Int` when the expected type is `Int`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_13\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(x : Int) -> Int { x }\n\nfn main() {\n  println(f('A'))\n}\n```\n\n----------------------------------------\n\nTITLE: Elvish Completion Installation\nDESCRIPTION: Installs elvish completion for the Moon CLI. Appends the elvish completion script to the `completers.elv` file and also needs `use completers` added to rc.elv.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/commands.md#_snippet_3\n\nLANGUAGE: elvish\nCODE:\n```\n$ moon shell-completion --shell elvish >> ~/.config/elvish/lib/completers.elv\n```\n\n----------------------------------------\n\nTITLE: Square Function in coreF (Clojure-like)\nDESCRIPTION: Defines a `square` function in coreF. It takes an argument `x` and returns its square by multiplying `x` by itself using the `mul` primitive.  This example highlights the issue of redundant computation in non-lazy evaluation.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_6\n\nLANGUAGE: clojure\nCODE:\n```\n(defn square[x]  (mul x x))\n```\n\n----------------------------------------\n\nTITLE: PowerShell Completion Installation\nDESCRIPTION: Installs PowerShell completion by appending the completion script to the PowerShell profile.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/commands.md#_snippet_10\n\nLANGUAGE: powershell\nCODE:\n```\nPS C:\\> moon shell-completion --shell powershell >>\n    ${env:USERPROFILE}\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1\n```\n\n----------------------------------------\n\nTITLE: Wrapping Function Type in a Struct (MoonBit)\nDESCRIPTION: This code provides a solution to the E4131 error by wrapping the function type `(Int) -> Unit` in a new type `FuncWrap`.  A method `call` can then be defined on this new type. This allows for method-like behavior to be associated with function types.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4131.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntype FuncWrap (Int) -> Unit\n\npub fn FuncWrap::call(self : FuncWrap) -> Unit {\n  (self._)(0)\n}\n```\n\n----------------------------------------\n\nTITLE: Setting package as main using moon.pkg.json (MoonBit)\nDESCRIPTION: This JSON configuration file sets the `\"is-main\"` property to `true`, marking the package as a main package in MoonBit. This allows the presence of a `main` function without causing an E4069 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4069.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"is-main\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Function Arity Mismatch Example in Moonbit\nDESCRIPTION: Illustrates a function arity mismatch error where a function requiring two arguments (Int, Double) is called with only one argument.  The code defines a function 'f' that takes two arguments and attempts to call it with a single argument, resulting in the error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4080.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(x : Int, y : Double) -> Unit {\n  ignore((x, y))\n}\n\nfn main {\n  f(0) // Error: This function has type (Int, Double) -> Unit, which requires 2 arguments, but is given 1 argument.\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Async Call in MoonBit\nDESCRIPTION: This code snippet shows the correct way to call an asynchronous function `f()` inside another asynchronous function `g()` in MoonBit. The `f!!()` call includes the `!!` marker, indicating that it's an async function call and the control flow might be suspended.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4150.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nasync fn g() -> Int {\n  f!!()\n}\n```\n\n----------------------------------------\n\nTITLE: Struct Field with Invalid Visibility Modifier MoonBit\nDESCRIPTION: This code snippet demonstrates an erroneous example where the `pub(open)` visibility modifier is used on a field within a public struct. This usage is not supported in MoonBit and results in a compilation error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4002.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub struct S {\n  pub(open) field: Int\n}\n```\n\n----------------------------------------\n\nTITLE: Backtracking First Part in MoonBit\nDESCRIPTION: This code provides the first part of the backtracking logic for reconstructing the edit path in the Myers diff algorithm. It takes the end point and traverses backwards to determine the specific path used.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff2.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn backtrack_fst[T: Eq](xs: List[T], ys: List[T]) -> List[Edit[T]] {\n  let max_len = xs.length() + ys.length()\n  let v = Array::make(2 * max_len + 1, 0)\n  let delta = xs.length() - ys.length()\n  let max_d = xs.length() + ys.length()\n  let path = List::new()\n\n  // Function to check if the path reaches the start\n  fn reach_start(x: Int, y: Int) -> Bool {\n    x == 0 && y == 0\n  }\n\n  // Function to perform a free move in reverse\n  fn free_move_back(x: Int, y: Int, xs: List[T], ys: List[T]) -> (Int, Int) {\n    var x = x\n    var y = y\n    while x > 0 && y > 0 && xs[x - 1] == ys[y - 1] {\n      x -= 1\n      y -= 1\n    }\n    (x, y)\n  }\n\n  fn shortest_edit_back[T: Eq](xs: List[T], ys: List[T]) -> (Array[Int],Int) {\n    let max_len = xs.length() + ys.length()\n    let v = Array::make(2 * max_len + 1, 0)\n    let delta = xs.length() - ys.length()\n    let max_d = xs.length() + ys.length()\n    for d in 0..=max_d {\n      for k in -d..=d by 2 {\n        let x = if k == -d || (k != d && v[max_len + k - 1] < v[max_len + k + 1]) {\n          v[max_len + k + 1]\n        } else {\n          v[max_len + k - 1] + 1\n        }\n        let y = x - k\n\n        let (x, y) = free_move(x, y, xs, ys)\n        v[max_len + k] = x\n        if x == xs.length() && y == ys.length(){\n          return (v,d)\n        }\n      }\n    }\n    (v,max_d)\n  }\n\n  let (v,max_d) = shortest_edit_back(xs,ys)\n\n  var x = xs.length()\n  var y = ys.length()\n  var d = max_d\n\n  while d >= 0 {\n    let k = x - y\n    let prev_k:Int = if k == -d || (k != d && v[max_len + k - 1] < v[max_len + k + 1]) {\n      k+1\n    }else{\n      k-1\n    }\n\n    let prev_x:Int = if k == -d || (k != d && v[max_len + k - 1] < v[max_len + k + 1]) {\n      v[max_len + k + 1]\n    }else{\n      v[max_len + k - 1] + 1\n    }\n    let prev_y = prev_x - prev_k\n\n    let (x_back,y_back) = free_move_back(x,y,xs,ys)\n\n    if x_back != x{\n      //println(\"Free Move!\")\n      x = x_back\n      y = y_back\n      d -= 1\n      continue\n    }\n\n    if k > prev_k{\n      //println(\"Delete!\")\n      path.push_front(Edit::Delete(xs[x-1]))\n      x -= 1\n      d -= 1\n    }else{\n      //println(\"Insert!\")\n      path.push_front(Edit::Insert(ys[y-1]))\n      y -= 1\n      d -= 1\n    }\n\n    if reach_start(x,y) {\n      break\n    }\n  }\n  path\n}\n```\n\n----------------------------------------\n\nTITLE: Diff Output - Bad Quality\nDESCRIPTION: Illustrates a 'bad quality' diff output, where the insertion of a function is interleaved with the existing struct definition. It highlights the undesirability of such interleaved changes and the need for algorithms that prioritize logical placement of edits.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff.md#_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\n struct RHSet[T] {\n    set : RHTable[T, Unit]\n+ }\n+\n+ fn RHSet::new[T](capacity : Int) -> RHSet[T] {\n+  let set : RHTable[T, Unit]= RHTable::new(capacity)\n+  { set : set }\n  }\n```\n\n----------------------------------------\n\nTITLE: Using Qualified Syntax (MoonBit)\nDESCRIPTION: This code snippet shows the recommended way to call the method `A::f` using qualified syntax `A::f(A(1))`. This approach avoids the deprecation warning and is the preferred way to call methods declared in this style.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0040.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let _ = A::f(A(1))\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Continue Arguments in Loop - MoonBit\nDESCRIPTION: This example demonstrates the E4104 error in a MoonBit `loop` where the `continue` statement provides only one argument, but the loop expects two. The error message highlights the mismatch in the number of arguments. The loop takes two integer arguments x and y.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4104.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(x: Int, y: Int) -> Int {\n  loop x, y {\n    0, 0 => 0\n    a, _ => continue a - 1\n//          ^^^^^^^^^^^^^^ Error: Current loop expects 2 arguments, but\n//                                `continue` is supplied with 1 arguments\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Missing Return Type Annotation\nDESCRIPTION: Illustrates the MoonBit compiler error E4076, where a function definition is missing the return type annotation.  MoonBit requires explicit type annotations for top-level functions.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4076.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f() { // Error: Missing type annotation for the return value.\n}\n```\n\n----------------------------------------\n\nTITLE: Cyclic Type Alias Definition in MoonBit\nDESCRIPTION: This code snippet demonstrates the E4129 error in MoonBit, which arises from a cyclic dependency between type aliases. In this case, type alias A is defined as B, and type alias B is defined as A, creating a cycle.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4129.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntypealias A = B // Found cycle A -> B -> A in type alias.\ntypealias B = A\n```\n\n----------------------------------------\n\nTITLE: Erroneous Example: Labelled Argument in Local Function (MoonBit)\nDESCRIPTION: This example demonstrates the error E4114 by defining a local function `h` within `f` that attempts to use a labelled argument `x~`. The MoonBit compiler will flag this as an error because labelled arguments are only allowed in toplevel functions.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4114.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f() -> Unit {\n  fn h(x~: Int) -> Unit {\n//     ^^ Error: Only toplevel functions can have labelled arguments.\n    println(x)\n  }\n  h(x=42)\n}\n```\n\n----------------------------------------\n\nTITLE: For Loop with Multiple Bindings in MoonBit\nDESCRIPTION: This example demonstrates a `for` loop in MoonBit with multiple variable initialization clauses. It initializes two variables, `i` and `j`, within the loop.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_59\n\nLANGUAGE: moonbit\nCODE:\n```\nfor var i = 0, var j = 10; i < 5; i = i + 1, j = j - 1 {\n  debug(i, j)\n}\n```\n\n----------------------------------------\n\nTITLE: Factorial Function in coreF (Clojure-like)\nDESCRIPTION: Defines a `factorial` function in the coreF language, resembling Clojure. This function calculates the factorial of a given number `n` using recursion. Note that `eq`, `mul`, and `sub` are built-in functions in coreF.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_4\n\nLANGUAGE: clojure\nCODE:\n```\n(defn factorial[n] ;; n is the parameter, this function calculates the factorial of n\n  (if (eq n 0) ;; The definition starts here and continues for the next three lines\n    1\n    (mul n (factorial (sub n 1)))))\n```\n\n----------------------------------------\n\nTITLE: Range Pattern with Wildcard - MoonBit\nDESCRIPTION: This code demonstrates the use of a wildcard as the upper bound in a range pattern.  This alters the functionality to simply check if the matched value is greater than or equal to the lower bound (0).\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3018.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let a = 3\n  match 0 {\n    0..<_ => println(\"Big than or equal to 0\")\n    _ => println(\"Less than 0\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous MoonBit Loop with Break Type Mismatch\nDESCRIPTION: This MoonBit code snippet demonstrates the E4105 error. The loop is expected to return an `Int`, but the `break` statement has no argument, causing a type mismatch. The `else` block also returns an `Int`, reinforcing the expected return type.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4105.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn g(x: Int) -> Int {\n  for i in 0..=x {\n    if i == 42 {\n      break\n//    ^^^^^ Error: Current loop has result type Int, but `break` is supplied\n//                 with no arguments.\n    }\n  } else {\n    0\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Define Moonbit Package (Main) with Unused Import\nDESCRIPTION: This JSON file defines a Moonbit main package that imports the `username/hello/lib` package, but it is unused, causing the E0029 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0029.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"is-main\": true,\n  \"import\": [\n    \"username/hello/lib\" // Unused package 'username/hello/lib'\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Error: Cannot Infer Type of Variable\nDESCRIPTION: Illustrates the 'Cannot infer the type of variable' error in MoonBit. It occurs when the compiler cannot deduce the variable's type from the assigned expression, necessitating explicit type annotation.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4074.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nlet a = 1 + 1 // Error: Cannot infer the type of variable a, please add more type annotation.\n```\n\n----------------------------------------\n\nTITLE: Duplicated Type/Trait Definition in MoonBit\nDESCRIPTION: Demonstrates the E4052 error in MoonBit when a type and a trait are defined with the same name ('A'). This example will result in a compile-time error indicating the duplication.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4052.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub type A\npub trait A {} // Error: The trait A duplicates with type A previously defined at ...\n```\n\n----------------------------------------\n\nTITLE: Erroneous Pattern Matching with Omitted Arguments in Moonbit\nDESCRIPTION: This snippet demonstrates the E0021 error in Moonbit.  It shows how pattern matching fails when some constructor arguments are omitted without using the `..` operator. This results in a compiler warning.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0021.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nenum E {\n  A(Int, w~ : Int, h~ : Int)\n}\n\nfn main {\n  match A(0, w=1, h=2) {\n    A(v, w~) => { // Warning: The argument(s) h of constructor A are omitted.\n      println(v)\n      println(w)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Unused Type Parameter Definition MoonBit\nDESCRIPTION: This code snippet demonstrates the error E4027, where a type parameter `T` is declared in the function signature but not used. This results in a compiler error indicating the unused type parameter.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4027.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn id[T](a: Int) -> Int { a }\n```\n\n----------------------------------------\n\nTITLE: Autofill Arguments in MoonBit\nDESCRIPTION: This code demonstrates autofill arguments, where MoonBit automatically fills optional arguments with `_` as the default value, such as `SourceLoc` or `ArgsLoc` at the call site.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_45\n\nLANGUAGE: moonbit\nCODE:\n```\nimport debug \"github.com/moonbitlang/debug @ latest\"\n\nfn log(msg : String, loc? : debug::SourceLoc = _) {\n  debug::log(msg, loc)\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Enum Constructor - MoonBit\nDESCRIPTION: This code snippet demonstrates an error where an enum variant 'W' is used, but it is not defined in the enum 'U'. This results in the E4031 compiler error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4031.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nenum U { V }\nlet v : U = W\n```\n\n----------------------------------------\n\nTITLE: Unused Toplevel Variable Example - MoonBit\nDESCRIPTION: Demonstrates an example of an unused toplevel variable 'p' in MoonBit, which triggers the E0002 warning. The warning indicates that the variable is not used and any side effects within its definition will not occur.  The suggestion is to use `fn init { .. }` to wrap the effect.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0002.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nlet p : Int = {\n//  ^ Warning: Unused toplevel variable 'p'.\n//             Note if the body contains side effect, it will not happen.\n//             Use `fn init { .. }` to wrap the effect.\n  println(\"Side effect\")\n  42\n}\n\nfn main {\n  let x = 42 // Warning: Unused variable 'x'\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Moonbit Code: Labelled Argument in Nested Function\nDESCRIPTION: This Moonbit code demonstrates the E4119 error, where a nested function `greet` attempts to use a labelled argument `name~`. This is not allowed in Moonbit, as only toplevel functions can have labelled arguments. The `main` function contains the nested function that causes the error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4119.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  fn greet(name~ : String) -> Unit {\n    println(\"Hello, \\{name}\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Coveralls JSON Coverage Report\nDESCRIPTION: This snippet demonstrates how to generate a coverage report in Coveralls JSON format. This format is line-based and suitable for use with Coveralls and CodeCov. The output is a JSON file containing coverage information for each source file.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/coverage.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ moon coverage report -f coveralls\n$ cat coveralls.json\n{\n    \"source_files\": [\n        {\n            \"name\": \"builtin/console.mbt\",\n            \"source_digest\": \"1c24532e12ac5bdf34b7618c9f38bd82\",\n            \"coverage\": [null,null,...,null,null]\n        },\n        {\n            \"name\": \"immut/array/array.mbt\",\n            \"source_digest\": \"bcf1fb1d2f143ebf4423565d5a57e84f\",\n            \"coverage\": [null,null,null,...\n\n```\n\n----------------------------------------\n\nTITLE: Erroneous MoonBit Example: Invalid Token\nDESCRIPTION: This MoonBit code snippet demonstrates an example that causes the E3001 error. The missing closing apostrophe in the `println` statement results in an unrecognized character error during lexing.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3001.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  println('3)\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Inconsistent Behavior\nDESCRIPTION: This code shows how the conflicting implementations of trait `T` for type `A` can lead to different outputs depending on where the `probe` function is defined and how the trait is accessed (using `@a.T` vs. `T`).\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4062.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nfn probe[T : @a.T](t : T) -> Unit {\n  ignore(t.f())\n}\n\n```\n\nLANGUAGE: moonbit\nCODE:\n```\nfn probe[T : T](t : T) -> Unit {\n  ignore(t.f())\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Use of Multiple Intrinsics in MoonBit\nDESCRIPTION: This code snippet demonstrates the incorrect usage of multiple intrinsics in a MoonBit function. The `MyArray::get` function attempts to associate both `%array.get` and `%fixedarray.get` intrinsics, leading to an E4071 error. The function aims to retrieve an element from an array-like structure using an index.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4071.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntype MyArray[T] Array[T]\n\n/// @intrinsic %array.get\n/// @intrinsic %fixedarray.get\nfn MyArray::get[T](self : MyArray[T], index : Int) -> T { // Error: Multiple intrinsic is not unsupported.\n  return self._[index]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Private Trait Publicly in MoonBit\nDESCRIPTION: This code snippet demonstrates the error E4046 in MoonBit, where a public implementation attempts to implement a private trait. The private trait `I` is defined, and then a public implementation attempts to implement it for the `Int` type. This results in a compiler error because a public definition cannot depend on a private entity.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4046.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npriv trait I { m(Self) }\npub impl I for Int with m(self) {}\n```\n\n----------------------------------------\n\nTITLE: Labelled Arguments Error Example - MoonBit\nDESCRIPTION: This code demonstrates the E4117 error in MoonBit. The `accumulate` function uses a labelled argument (`acc~`) and is passed to `func_takes_closure`. This is not allowed in MoonBit, resulting in the error message 'Function with labelled arguments can only be applied directly.'\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4117.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn func_takes_closure[F](f : F) -> Unit {\n  ...\n}\n\npub fn accumulate(acc~ : Int, value : Int) -> Int {\n  acc + value\n}\n\nfn main {\n  func_takes_closure(accumulate)\n  //                 ^~~~~~~~~~\n  // Error: Function with labelled arguments can only be applied directly.\n}\n```\n\n----------------------------------------\n\nTITLE: Zsh Completion Installation (Install Completion Script)\nDESCRIPTION: Installs zsh completion for the Moon CLI by saving the shell completion script to the custom directory.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/commands.md#_snippet_6\n\nLANGUAGE: zsh\nCODE:\n```\n$ moon shell-completion --shell zsh > ~/.zfunc/_moon\n```\n\n----------------------------------------\n\nTITLE: Compiling Super Combinator Definitions with compileC - MoonBit\nDESCRIPTION: This snippet demonstrates the `compileC` function, responsible for compiling the definition of super combinators.  Variables not recognized as parameters are treated as other super combinators. For function application, the right-hand side is compiled first, offsets in the environment are incremented, then the left-hand side is compiled, and finally `MkApp` instruction is appended.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_23\n\nLANGUAGE: moonbit\nCODE:\n```\n// compileC compiles the definition of super combinators\nfn compileC(env: Env, expr: Expr) -> Code {\n    // Placeholder implementation\n    Code::Nil\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Range Pattern with Double in MoonBit\nDESCRIPTION: This code snippet demonstrates the E4146 error, showing an attempt to use a Double value in a range pattern. MoonBit range patterns only support integer types, causing this error when applied to other types like Double.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4146.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let value = 1.0\n  match value {\n    _..<0.0 => println(\"negative\") // Error: Type Double is not supported by range pattern.\n    _ => println(\"zero or positive\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Expanding Wildcard Pattern MoonBit\nDESCRIPTION: This example shows how to resolve the E0006 error by expanding the wildcard pattern to include all variants of the enum `T`. This ensures that all variants are accounted for in the match statement.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0006.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  match T::A {\n    B => ()\n    C => ()\n    A => ()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid FuncRef Assignment in MoonBit\nDESCRIPTION: This code snippet demonstrates an erroneous attempt to assign a function with a captured variable `x` to a `FuncRef[() -> Unit]`. This will result in an error because `FuncRef` requires capture-free functions.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4151.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let x : Int = 42\n  let _ : FuncRef[() -> Unit] = fn () { println(x) }\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Main Function in MoonBit\nDESCRIPTION: This code snippet demonstrates an incorrect implementation of the `main` function in MoonBit. The `main` function is defined with a return type `Unit`, which is not allowed. This will result in a compilation error. The `println` function is used to print \"Hello, world!\" to the console.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3003.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main() -> Unit { // Error: Main function must have no arguments and no return value.\n  println(\"Hello, world!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Unused Variant Example MoonBit\nDESCRIPTION: This example demonstrates the E0006 error in MoonBit, where variants A, B, and C are never read, never constructed, or both, within the `priv enum T`. The match statement only considers `B` and a wildcard, leaving `A` and `C` unused.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0006.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npriv enum T {\n  A // Warning: Variant 'A' is never read\n  B // Warning: Variant 'B' is never constructed\n  C // Warning: Variant 'C' is unused\n}\n\nfn main {\n  match T::A {\n    B => ()\n    _ => ()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Allocating Indirect Nodes in MoonBit\nDESCRIPTION: This MoonBit code defines the `Alloc(N)` instruction, which pre-allocates N `NInd` (indirect) nodes on the heap and pushes their addresses onto the stack. The addresses in these indirect nodes are initialized to negative values as placeholders. This instruction is used for implementing `letrec` expressions.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-2.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\nAlloc(n: Int),\n\n    Alloc(n) => {\n      let addrs = list::make_with_index(n, (i) => state.heap.alloc(Node::NInd(-1)))\n      {state with stack = list::append(state.stack, addrs)}\n    }\n```\n\n----------------------------------------\n\nTITLE: Default Compile & Link Command for GCC-like Compilers\nDESCRIPTION: This shell command represents the default compilation and linking process used for GCC-like compilers within the MoonBit build system.  It defines how source files are compiled and linked to create the target executable. Flags enclosed in square brackets `[]` are optional and may not be present in all modes.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/package.md#_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\ncc -o $target -I$MOON_HOME/include -L$MOON_HOME/lib [-g] [-shared -fPIC] \\\n   -fwrapv -fno-strict-aliasing (-O2|-Og) [$MOON_HOME/lib/libmoonbitrun.o] \\\n   $sources -lm $cc_flags $cc_link_flags\n```\n\n----------------------------------------\n\nTITLE: Assigning a Single Value and Eliminating Others in MoonBit\nDESCRIPTION: This function assigns a specific value to a square by eliminating all other possible values. It takes a `SquareMap`, a square `key`, and a value `val` to assign. It removes all values from `key` except `val` and returns a boolean indicating success or failure based on constraint propagation.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/sudoku/index.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn assign(values : SquareMap[List[Char]], key : String, val : Char) -> Bool {\n  let other_values = values[key].remove(val)\n  let mut result = true\n  other_values.iter(fn (val) {\n    result = result && eliminate(values, key, val)\n  })\n  return result\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Enum Constructor Definition (MoonBit)\nDESCRIPTION: This MoonBit code snippet shows the correct way to define an enum `A`. The constructors `A1` and `A2` are declared without any visibility modifiers.  Visibility is controlled at the enum level, not at the constructor level. This is the recommended way to define enums in MoonBit to avoid the E3006 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3006.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nenum A {\n  A1\n  A2\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Enum with Duplicate Constructor - MoonBit\nDESCRIPTION: This MoonBit code snippet demonstrates an enum definition with a duplicate constructor named 'A'. This will result in the E4057 error. The code defines an enum 'E' with two constructors, both named 'A', one without arguments and one taking an Int.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4057.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nenum E {\n  A\n  A(Int)\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Trait Usage in MoonBit\nDESCRIPTION: This code snippet demonstrates the incorrect usage of a trait in MoonBit. It attempts to cast a boolean value to a trait named `Sh0w`, which is not defined or available in the current scope. This results in a compiler error indicating that the trait cannot be found.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4023.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nlet a = true as &Sh0w\n```\n\n----------------------------------------\n\nTITLE: Corrected MoonBit Loop Pattern\nDESCRIPTION: This example demonstrates the correct way to structure a MoonBit loop when using two arguments. The loop takes two arguments (x and y) and each arm provides two patterns (a and b).  This ensures each pattern matches an argument.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4103.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(x: Int, y: Int) -> Int {\n  loop x, y {\n    0, 0 => 0\n    a, b => continue a - 1, b - 1\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Trait Implementation with Type Parameter (MoonBit)\nDESCRIPTION: This MoonBit code demonstrates the E4011 error. It attempts to define a default implementation for the `Stringer` trait using a type parameter `T`, which is not permitted.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4011.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub(open) trait Stringer {\n  stringify(Self) -> String\n}\n\nimpl[T] Stringer with stringify(_self) { \"hey\" }\n```\n\n----------------------------------------\n\nTITLE: Erroneous Struct Expression in MoonBit\nDESCRIPTION: Demonstrates the incorrect syntax for struct expressions in MoonBit that causes the E3020 error.  The error occurs when using `=` instead of `:` to assign a value to a field in a struct update expression. This example shows the incorrect assignment `a = 1` within a struct update.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3020.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct S {\n  a : Int\n  b : Int\n}\n\nfn main {\n  let s : S = { a : 1, b : 2 }\n  let ss = { ..s, a = 1 } // Error: Unexpected `=` in struct expression.\n  ignore(ss)\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Assignment: Constant on Left-Hand Side (Moonbit)\nDESCRIPTION: This code snippet demonstrates the E3011 error in Moonbit, where attempting to assign a value to a constant variable results in a compilation error. The code defines a constant `N` and then attempts to assign the value 5 to it within the `main` function. This is not allowed in Moonbit because constants cannot be modified after their initial declaration.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3011.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nconst N = 4\n\nfn main {\n  N = 5 // Error: Invalid left value for assignment.\n}\n```\n\n----------------------------------------\n\nTITLE: Pseudo Code for Free Variable Check in Moonbit (Hypothetical)\nDESCRIPTION: This is pseudo code that represents a potential, but ultimately not implemented, approach to handling variable capture. It highlights the complexities of checking for free variables during substitution. The final implementation uses de Bruijn indices to avoid this issue altogether, making the substitution process simpler and more efficient.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/lambda/index.md#_snippet_9\n\nLANGUAGE: moonbit\nCODE:\n```\n// (λx.E) T => E.subst(x, T)\nfn subst(self : Term, var : String, term : Term) -> Term {\n  let freeVars : Set[String] = term.get_free_vars()\n  match self {\n    Abs(variable, body) => {\n      if freeVars.contains(variable) {\n        // The variable name is in the set of free variables \n        // of the current inner Lambda, indicating variable capture\n        abort(\"subst(): error while encountering {variable}\")\n      } else {\n        ...\n      }\n    }\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous MoonBit Placeholder Example\nDESCRIPTION: This code snippet demonstrates the incorrect usage of the underscore `_` as a placeholder in MoonBit. This will cause a compilation error as the compiler interprets it as an incomplete or missing expression.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4116.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  _ // Error: Found hole _\n}\n```\n\n----------------------------------------\n\nTITLE: Defining function with valid identifier in MoonBit\nDESCRIPTION: This code snippet provides a suggestion for resolving the E0035 error. It renames the function from the reserved keyword `module` to `module_`, which is a valid identifier in MoonBit. The function returns an integer.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0035.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn module_() -> Int {\n  3\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Hexadecimal Floating-point Number in MoonBit\nDESCRIPTION: This code snippet demonstrates how to define 64-bit floating-point numbers using hexadecimal format in MoonBit.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\nlet f : Double = 0x1.FFFFFFFFFFFFFp1023\n```\n\n----------------------------------------\n\nTITLE: Wasm Backend Memory Import Configuration\nDESCRIPTION: This JSON snippet demonstrates how to configure the `import-memory` option for the Wasm backend in the `link` section of a `moon.pkg.json` file. It specifies that the Wasm module imports linear memory named `memory` from the `env` module.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/package.md#_snippet_4\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"link\": {\n      \"wasm\": {\n        \"import-memory\": {\n          \"module\": \"env\",\n          \"name\": \"memory\"\n        }\n      },\n      \"wasm-gc\": {\n        \"import-memory\": {\n          \"module\": \"env\",\n          \"name\": \"memory\"\n        }\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: MoonBit Package Definition for Package 'a'\nDESCRIPTION: Defines the `moon.pkg.json` file for package 'a', indicating an empty package configuration. This file is located in the directory 'a' and part of the module 'username/hello'.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4094.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{}\n\n```\n\n----------------------------------------\n\nTITLE: MoonBit ty.mbt\nDESCRIPTION: Defines the trait `Obj` and a type `T` that implements it. This is required to be imported to satisfy the return type in middle.mbt.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4037.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\npub(all) type T Int\n\npub fn f(self: T) -> Unit {\n  println(self._)\n}\n\npub(open) trait Obj {\n  f(Self) -> Unit\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Intrinsic Usage in MoonBit\nDESCRIPTION: This code snippet demonstrates the erroneous usage of an unknown intrinsic `%abort` in MoonBit. The MoonBit compiler will throw an error E4070 because this intrinsic is not recognized. This example highlights the risk of directly using internal intrinsics.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4070.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn my_abort(message : String) -> Unit = \"%abort\"\n// Error: Unknown intrinsic: %abort\n\nfn main {\n  my_abort(\"Abort!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Continue Arguments in For Loop - MoonBit\nDESCRIPTION: This example shows the E4104 error within a MoonBit `for` loop. The `continue` statement is given three arguments (i + 2, j + 1, i + j) while the loop only expects two (i, j). The error message points out this discrepancy, leading to the compilation failure.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4104.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn g(x : Int, y : Int) -> Int {\n  for i = x, j = y; i + j < 10; i = i + 1, j = j + 1 {\n    if i < j {\n      continue i + 2, j + 1, i + j\n//    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Error: Current loop expects 2 arguments, but\n//                                       `continue` is supplied with 3 arguments\n    }\n  } else {\n    42\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Attribute Example in MoonBit\nDESCRIPTION: Demonstrates the E0042 warning by using an unrecognized attribute `#unrecognized` and an invalid number of arguments for the `#deprecated` attribute. The unrecognized attribute causes a warning, and the incorrect number of arguments for `#deprecated` also triggers a warning during compilation. It showcases two common scenarios that result in the E0042 warning.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0042.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\n// unrecognized attribute\n#unrecognized\nfn f() -> Unit {}\n\n// `#deprecated` can accept at most one message\n#deprecated(\"multiple\", \"message\")\nfn g() -> Unit {}\n```\n\n----------------------------------------\n\nTITLE: Corrected Record Definition/Matching in Moonbit\nDESCRIPTION: This code snippet demonstrates the corrected version of the E4043 error example in Moonbit. The record field 'a' is now defined and matched only once, resolving the error. The code creates a struct S with a single field 'a', creates an instance and uses pattern matching on 'a'.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4043.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct S { a : Int }\nlet a : Int = match S::{ a: 2 } {\n  { a: 2 } => 4\n  _ => 5\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect MoonBit Enum, Struct, and Error Type Definition\nDESCRIPTION: This code snippet demonstrates the E3800 error in MoonBit. The error occurs when a comma is used to separate constructors in an `enum` definition, fields in a `struct` definition, and constructors in a `type!` definition. The MoonBit compiler expects either a newline or a semicolon as a delimiter.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3800.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nenum V {\n  A, // Error: Expecting a newline or `;` here, but encountered another delimiter `,`.\n}\n\nstruct S {\n  a : Int, // Error: Expecting a newline or `;` here, but encountered another delimiter `,`.\n}\n\ntype! E {\n  A, // Error: Expecting a newline or `;` here, but encountered another delimiter `,`.\n}\n```\n\n----------------------------------------\n\nTITLE: Zsh Completion Installation (Create Custom Directory)\nDESCRIPTION: Creates a hidden directory for storing zsh completion files.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/commands.md#_snippet_4\n\nLANGUAGE: zsh\nCODE:\n```\n$ mkdir ~/.zfunc\n```\n\n----------------------------------------\n\nTITLE: MoonBit Package Configuration (main) with import removal\nDESCRIPTION: Suggests removing the unused imported value from the moon.pkg.json file. This configuration removes the specific 'greeting' function from the 'value' array of the import configuration.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0033.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  // ...\n  \"import\": [\n    {\n      \"path\": \"username/hello/lib\",\n      \"alias\": \"hello\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous MoonBit Function Definition\nDESCRIPTION: This code snippet demonstrates the error E4075 in MoonBit. It shows a function `f` defined without a type annotation for its parameter `param`, which will result in a compilation error. The function is intended to return a `Unit` type.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4075.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(param) -> Unit { // Error: Missing type annotation for the parameter param.\n}\n```\n\n----------------------------------------\n\nTITLE: Type Mismatch Example in MoonBit\nDESCRIPTION: This code snippet demonstrates the E4014 error in MoonBit. The function `fst` is defined to return a value of type `X`, but it returns `b` of type `Y`, causing a type mismatch.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4014.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn fst[X, Y] (a: X, b: Y) -> X {\n  b\n}\n```\n\n----------------------------------------\n\nTITLE: Zsh Completion Installation (Reload Configuration)\nDESCRIPTION: Reloads the zsh configuration file to apply the changes.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/commands.md#_snippet_7\n\nLANGUAGE: zsh\nCODE:\n```\n$ . ~/.zshrc\n```\n\n----------------------------------------\n\nTITLE: Struct definition with private field in MoonBit\nDESCRIPTION: This MoonBit code defines a struct `R` with a public field `x` and a private field `__private`. It also provides a public constructor `R::new` to create instances of `R`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4036.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub(all) struct R {\n  x : Int\n  priv __private : Int\n}\n\npub fn R::new(x: Int) -> R {\n  {x, __private: 42}\n}\n```\n\n----------------------------------------\n\nTITLE: CaseJump instruction definition in MoonBit\nDESCRIPTION: This MoonBit code defines the `CaseJump` virtual machine instruction. This instruction is needed to implement the `case` expression for pattern matching on data structures. It checks the tag of a data constructor and jumps to the corresponding label based on the tag value.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-3.md#_snippet_10\n\nLANGUAGE: moonbit\nCODE:\n```\n/* start casejump definition */\n  | CaseJump {\n    // sp -> addr of node\n    // jump to labels[tag]\n    labels : List[Label],\n  }\n  /* end casejump definition */\n```\n\n----------------------------------------\n\nTITLE: Generic MoonBit Function Definition\nDESCRIPTION: This code snippet presents another solution to the error E4075 by making the function generic. The function `f` is parameterized with a type variable `T`, and the parameter `param` is typed as `T`. The function returns a `Unit` type.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4075.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f[T](param: T) -> Unit {\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous MoonBit Trait Implementation\nDESCRIPTION: This MoonBit code demonstrates error E4060, where the method `f` in the `impl` block has a type `(T) -> Unit`, while the trait `A` expects `(T) -> Int`. This mismatch causes the compiler error. The example highlights that the method signatures must be exactly the same.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4060.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait A {\n  f(Self) -> Int\n}\n\ntype T Int\n\nimpl A for T with f(self : T) -> Int {\n  //              ^\n  // Error: Method f of trait A is expected to have type (T) -> Int,\n  //        it cannot be implemented with type (T) -> Unit\n  ignore(self)\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Example: Duplicate Label in Function Call (Moonbit)\nDESCRIPTION: This code demonstrates the E4084 error. The function `f` is called with the labeled parameter `a` specified twice, which is not allowed.  This results in a compiler error. The function `f` expects a labeled parameter `a~` of type `Int`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4084.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(a~ : Int) -> Unit {\n  println(\"Hello, \\{a}\")\n}\n\nfn main {\n  f(a=0, a=1) // Error: The label a~ is supplied twice.\n}\n```\n\n----------------------------------------\n\nTITLE: Suggested Solution: Remove Optional Argument (Moonbit)\nDESCRIPTION: This Moonbit code snippet presents a solution to the E0031 error by removing the optional argument `opt` from the function `f` and defining it as a local variable within the function. This eliminates the warning and maintains the original functionality.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0031.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f() -> Int {\n  let opt = 4\n  ignore(opt)\n  0\n}\n\nfn main {\n  println(f())\n  println(f())\n}\n```\n\n----------------------------------------\n\nTITLE: Tuple Mutability Error in MoonBit\nDESCRIPTION: This code snippet demonstrates the error that occurs when attempting to modify an element of a tuple in MoonBit.  Tuples are immutable, so assigning a new value to a tuple element results in a compile-time error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4090.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let a = (1, 2, 3)\n  a.2 = 4 // Error: tuples are not mutable\n  println(a.2)\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Int Array to JS via FFI\nDESCRIPTION: This MoonBit code demonstrates how to pass an integer array to JavaScript through FFI when using the WASM linear backend. It defines an external type `JsArray` and functions to create and push elements to a JavaScript array. The `make_js_array` and `push_js_array` functions are FFI functions that interact with JavaScript host functions.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4042.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nextern type JsArray\nfn make_js_array() -> JsArray = \"mod\" \"make_js_array\"\nfn push_js_array(array : JsArray, value : Int) -> Unit = \"mod\" \"push_js_array\"\n```\n\n----------------------------------------\n\nTITLE: Erroneous Example: Deriving trait with existing implementation\nDESCRIPTION: Demonstrates the E4079 error. The code attempts to derive the `Show` trait for type `A`, but `A` already has a manual implementation for the `output` method required by the `Show` trait, causing a conflict.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4079.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nimpl Show for A with output(self : A, logger : &Logger) -> Unit {\n  logger.write_object(self._)\n}\n\ntype A Int derive(Hash, Show) // Error: Cannot derive trait Show for A: method output is already defined at ...\n```\n\n----------------------------------------\n\nTITLE: Generated MoonBit Code from Embedded Text File\nDESCRIPTION: This MoonBit code shows the generated content of `a.mbt` after embedding the `a.txt` file. The `resource` variable is a string containing the content of `a.txt`, with each line prefixed by `#|`. The embedding happens during the pre-build phase.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/package.md#_snippet_17\n\nLANGUAGE: moonbit\nCODE:\n```\nlet resource : String =\n  #|hello,\n  #|world\n  #|\n```\n\n----------------------------------------\n\nTITLE: Erroneous Range Pattern Example - MoonBit\nDESCRIPTION: This code snippet demonstrates the E3018 error in MoonBit, where a variable is used as the upper bound in a range pattern within a match expression. The compiler expects a constant, named constant, or wildcard instead of a variable.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3018.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let a = 3\n  match 0 {\n    0..<a => println(\"Between 0 and 3\") // Error: Bounds of range pattern must be constant, named constant or wildcard.\n    _ => println(\"Not between 0 and 3\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Attempt to define method for external type (MoonBit)\nDESCRIPTION: This code snippet shows the erroneous attempt to define the method `f` for the type `@a.A`. This is not allowed in Moonbit, and will cause compiler error `E4059`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4059.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(self : @a.A) -> Int { // Error: Cannot define method f for type @a.A from package a\n  0\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Fibonacci Function (a.mbt)\nDESCRIPTION: Defines a public function `fib` that calculates the nth Fibonacci number using recursion. This function is part of the `fib` package.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/tutorial.md#_snippet_13\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn fib(n : Int) -> Int {\n  match n {\n    0 => 0\n    1 => 1\n    _ => fib(n - 1) + fib(n - 2)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Bash Completion Installation (macOS/Homebrew)\nDESCRIPTION: Installs bash completion for the Moon CLI on macOS using Homebrew. It creates the directory if necessary and redirects the output to the completion file.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/commands.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ mkdir -p $(brew --prefix)/etc/bash_completion.d\n$ moon shell-completion --shell bash > $(brew --prefix)/etc/bash_completion.d/moon.bash-completion\n```\n\n----------------------------------------\n\nTITLE: HTML Build and Serve\nDESCRIPTION: This snippet uses `make html` to build the HTML documentation and then starts a simple Python web server to serve the generated files. This allows you to view the documentation locally in a browser.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmake html\npython3 -m http.server -d _build/html\n```\n\n----------------------------------------\n\nTITLE: Renaming Labels to Avoid Conflicts in MoonBit\nDESCRIPTION: This code snippet provides a suggested solution to the E4019 error by renaming one of the duplicate labels. Instead of declaring `g` twice, the second label is renamed to `h`, resolving the conflict and allowing the function to be defined without errors.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4019.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(g~ : Int, h~ : String) -> Int {\n  g\n}\n```\n\n----------------------------------------\n\nTITLE: Using `is` Syntax for Conditional Matching - MoonBit\nDESCRIPTION: This MoonBit code snippet demonstrates how to use the `is` syntax to handle pattern matching as a condition. It checks if `Some(1)` matches the pattern `Some(x)` and executes the code inside the `if` block if it matches.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0011.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  if Some(1) is Some(x) {\n    println(x)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous MoonBit Example with Unused Default\nDESCRIPTION: This MoonBit code shows an example that triggers the E0032 warning.  The optional argument `opt` in function `f` has a default value of 4, but it is always explicitly provided a value when the function is called, rendering the default value useless. This example highlights the need to refactor the optional argument into a labelled argument.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0032.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(opt~ : Int = 4) -> Int {\n  ignore(opt)\n  0\n}\n\nfn main {\n  println(f(opt=3))\n  println(f(opt=3))\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Integer Literal Assignment in MoonBit\nDESCRIPTION: This code snippet shows a corrected version of the previous example.  The `int` variable of type `Int` is assigned the value 256, which is within the valid range for `Int`.  This avoids the E4095 error in MoonBit.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4095.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let int : Int = 256\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Moonbit Function Definition\nDESCRIPTION: Demonstrates a Moonbit function `f` that declares a return type expecting no arguments but returns a function that expects one argument, causing an E4013 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4013.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f() -> (() -> Int) {\n  fn (x: Int) { x }\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous For-Loop Declaration Moonbit\nDESCRIPTION: This code snippet demonstrates the E4107 error in Moonbit, where the variable 'i' is declared multiple times in the initialization block of a for-loop. This leads to ambiguity and compilation failure. The function 'f' attempts to iterate and print a value, but the redeclaration of 'i' prevents it.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4107.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(x: Int) -> Unit {\n   for i = 0, i = 1; i < x; i = i + 1 {\n//            ^ --- Error: i is declared multiple times in this for-loop\n    println(i)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Struct Literal with Comma in MoonBit\nDESCRIPTION: This code snippet shows the corrected way to initialize a struct literal in MoonBit to resolve the E0022 error. By adding a trailing comma to the struct literal `{ value, }`, it explicitly defines it as a struct initialization, removing the ambiguity.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0022.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let value = 3\n  let s = { value, }\n  ignore(s)\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Package Configuration (main) with unused import\nDESCRIPTION: Configures the 'main' package to import the 'greeting' function from the 'lib' package. This example leads to the E0033 warning because the imported 'greeting' is not directly used but is instead accessed using the qualified name (@hello.greeting()).\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0033.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"is-main\": true,\n  \"import\": [\n    {\n      \"path\": \"username/hello/lib\",\n      \"alias\": \"hello\",\n      \"value\": [\n        \"greeting\" // Warning: The import value greeting is never used directly.\n      ]\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: FFI Function with Type Parameter (Error)\nDESCRIPTION: This code snippet demonstrates an erroneous example of an FFI function in MoonBit that uses a type parameter. FFI functions cannot have type parameters directly. This results in a compile-time error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4008.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nextern \"js\" fn id[T](x: T) -> T = \"(x) => x\"\n```\n\n----------------------------------------\n\nTITLE: Erroneous main function in non-main MoonBit package\nDESCRIPTION: This MoonBit code snippet shows an example of the E4069 error. The `main` function is defined within a package that is not configured as a main package.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4069.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main { // Error: Unexpected main function in the non-main package.\n  println(\"Hello, world!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Example: Calling Function with Incorrect Type - Moonbit\nDESCRIPTION: Demonstrates the E4029 error. The function `f` expects a tuple `(Int, Int)`, but it's being called with `None`, which is a variant of `Option[_]`. This type mismatch triggers the error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4029.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  fn f {\n    (a, b) => a + b\n  }\n  let a = f(None)\n}\n```\n\n----------------------------------------\n\nTITLE: Development Server Setup\nDESCRIPTION: This snippet uses `sphinx-autobuild` to automatically rebuild the documentation and serve it in a web browser. It takes the source directory as input and outputs the built HTML to the specified output directory. Optionally you can set the language.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsphinx-autobuild . ./_build/html\n# or sphinx-autobuild -D language='zh_CN' . ./_build/html\n```\n\n----------------------------------------\n\nTITLE: Unused Public Struct Definition in MoonBit\nDESCRIPTION: This code demonstrates a scenario where a public struct `A` is defined but never constructed. The compiler issues a warning because the struct, while accessible to other packages, is never actually instantiated.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0009.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub struct A { // Warning: The struct A is never constructed\n  value : Int\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Syntax Error Example\nDESCRIPTION: This MoonBit code snippet demonstrates a syntax error where a closing parenthesis is missing in the `println` function call. This example will cause a parsing error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3002.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main() -> Unit {\n  println(\"Hello, world!\"\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Example: Unused Optional Argument (Moonbit)\nDESCRIPTION: This Moonbit code snippet demonstrates the E0031 error, where an optional argument `opt` is defined but never supplied when calling the function `f`. The `ignore(opt)` call exists but doesn't mitigate the issue of the parameter never being specified externally.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0031.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(opt~ : Int = 4) -> Int {\n  ignore(opt)\n  0\n}\n\nfn main {\n  println(f())\n  println(f())\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Suggestion: Using a Default Value\nDESCRIPTION: This code snippet provides a solution for the E4115 error in MoonBit by assigning a default value (0) to the `Int` parameter. This allows the code to compile without triggering the auto-fill error, as the compiler no longer needs to infer a default value.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4115.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(parameter~ : Int = 0) -> Unit {\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Missing Method in Trait - MoonBit\nDESCRIPTION: Shows the corrected MoonBit code that implements the missing `to_float` method for the type `A`, thus resolving the E4063 error. This snippet provides a complete implementation of the Number trait.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4063.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nimpl Number for A with to_float(self : A) -> Float {\n  self._.to_float()\n}\n```\n\n----------------------------------------\n\nTITLE: Module License Configuration in moon.mod.json\nDESCRIPTION: Specifies the 'license' field in the moon.mod.json file, defining the module's license. The specified license type must comply with the SPDX License List.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/module.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"license\": \"MIT\"\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid 'break' within a code block - MoonBit\nDESCRIPTION: Demonstrates an incorrect usage of the 'break' statement inside a code block that is not within a loop. The 'break' statement is only valid within the context of a loop to terminate its execution.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4102.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let x = { break }\n//          ^^^^^ Error: 'break' outside of a loop\n  println(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Return Outside Function - MoonBit\nDESCRIPTION: This code snippet demonstrates the E4109 error in MoonBit. The `return` statement is used within a `let` binding outside a function context, which is invalid. This example shows the error occurring directly within a `let` binding and also within an `else` branch.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4109.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub let x: Int = { return 42 }\n//                 ^^^^^^^^^ Error: Return must be inside a function.\npub let y: Int = {\n  if x == 42 {\n    x + 1\n  } else {\n    return 0\n//  ^^^^^^^^ Error: Return must be inside a function.\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Octal Number in MoonBit\nDESCRIPTION: This code snippet demonstrates how to define octal numbers in MoonBit, which start with `0o` or `0O`. The digits after `0o`/`0O` must be in the range from `0` through `7`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nlet o1 : Int = 0o1234567\nlet o2 : Int = 0O1234567\n```\n\n----------------------------------------\n\nTITLE: Erroneous Optional Parameter with None Default\nDESCRIPTION: This code snippet demonstrates the erroneous use of assigning `None` as the default value to an optional parameter in MoonBit. This causes the E3015 error, as optional parameters implicitly default to `None` if not provided.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3015.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(a? : Int = None) -> Unit { // Error: The parameter a? already has default value `None`.\n  println(a)\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Record Initialization in MoonBit\nDESCRIPTION: This MoonBit code snippet demonstrates an erroneous record initialization. It defines a struct `S` with fields `x` and `y`, but then attempts to initialize a record `c` with fields `x` and `w`. This triggers the E4033 compiler error because the field `w` is not defined in the struct `S` or any other record type.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4033.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  struct S { x : Int; y : Int }\n  let c = { x: 2, w: 1 }\n}\n```\n\n----------------------------------------\n\nTITLE: Range Operator Error with Float Type in MoonBit\nDESCRIPTION: This snippet demonstrates an error that occurs when using floating-point numbers (specifically `Float` or `Double`) with range operators in MoonBit. The code attempts to iterate from 0.0 up to (but not including) 1.0, which results in a type error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4138.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  for f in 0.0..<1.0 {\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Main Function in MoonBit (main) using direct call\nDESCRIPTION: Demonstrates how to fix the E0033 error by directly calling the imported 'greeting' function instead of using the qualified package name. This requires the 'greeting' function to be explicitly imported without using the alias when it is used.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0033.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  println(greeting())\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Package Usage in MoonBit\nDESCRIPTION: This snippet shows the corrected code where the `@boolean` package is replaced with the correct `@bool` package. This resolves the 'Package not found' error and allows the `to_int` method to be called successfully on a boolean value.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4020.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nlet a = @bool.to_int(true)\n```\n\n----------------------------------------\n\nTITLE: Correct Record Assignment - MoonBit\nDESCRIPTION: This code snippet shows the correct way to assign a record literal to a variable in MoonBit. The variable 'a' is declared with the record type 'T', ensuring type compatibility and avoiding the E4028 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4028.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct T { a : Int }\nlet a : T = { a: 42 }\n```\n\n----------------------------------------\n\nTITLE: Invalid Record Field Access in MoonBit\nDESCRIPTION: This snippet demonstrates the E4045 error in MoonBit when trying to match a record with a field that is not defined in the record type's definition.  The struct `S` is defined with fields `a` and `b`, but the `match` statement attempts to use a non-existent field `c`. This will result in a compile-time error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4045.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct S { a : Int, b : Int }\nlet a : Int = match S::{ a: 2, b: 3 } {\n  { c: 2, .. } => 5\n  _ => 6\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Example: Passing Optional to Non-Optional Argument (MoonBit)\nDESCRIPTION: Demonstrates the E4141 error. The code defines a function `f` with a default labeled argument and attempts to pass an optional value `opt?` to it, which results in an error because the argument is not declared as optional.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4141.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(opt~ : Int = 4) -> Unit {\n  println(\"opt: \\{opt}\")\n}\n\nfn main {\n  let opt = Some(42)\n  f(opt?) // Error: This form of application is invalid for argument opt~, because it is not declared with opt? : _.\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Example: Implicitly Ignoring Int\nDESCRIPTION: This code demonstrates the error E4139, where the result of `1 + 1` (an `Int`) is implicitly ignored, which is disallowed in MoonBit. This is because the result of the expression is discarded and the computation is deemed useless.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4139.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  1 + 1 // This expression has type Int, its value cannot be implicitly ignored.\n}\n```\n\n----------------------------------------\n\nTITLE: Moonbit Corrected Code Example\nDESCRIPTION: This Moonbit code snippet shows the correct way to structure the code to avoid the E0012 error. The `println` statement is placed before the `return` statement, ensuring that it will be executed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0012.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  println(\"Hello, World!\")\n  return\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling E0031 Warning in moon.pkg.json\nDESCRIPTION: This snippet demonstrates how to enable the E0031 warning by adding `+31` to the `warn-list` in the `moon.pkg.json` file. This configuration change allows the compiler to detect and report unused optional arguments.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0031.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  // ...\n  \"warn-list\": \"+31\"\n}\n```\n\n----------------------------------------\n\nTITLE: Duplicate Toplevel Variable Definition in MoonBit\nDESCRIPTION: This code snippet demonstrates the E4051 error in MoonBit, which occurs when a toplevel variable is defined twice with the same identifier. The second declaration of 'a' results in a compiler error because toplevel identifiers must be unique within a MoonBit program.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4051.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub let a = 0\npub let a = 1 // Error: The toplevel identifier a is declared twice: it was previously defined at ...\n```\n\n----------------------------------------\n\nTITLE: native-stub configuration in moon.pkg.json\nDESCRIPTION: This JSON snippet shows how to specify C stub files in `moon.pkg.json`. These stub files can contain wrapper functions for interacting with C code.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/ffi.md#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n  // ...\n  \"native-stub\": [ \n    // list of stub file names\n  ],\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Overloaded Operator in MoonBit\nDESCRIPTION: This MoonBit code snippet demonstrates an error where the overloaded `op_add` operator for type `A` has an inconsistent parameter type. It expects the second argument to be of type `A`, but the provided code uses `Int` instead.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4066.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntype A Int\nfn A::op_add(self : A, other : Int) -> A {\n  return self._ + other\n}\n```\n\n----------------------------------------\n\nTITLE: Convert List to Stream in MoonBit\nDESCRIPTION: Converts a regular `List` to a lazy `Stream` in MoonBit.  It uses a thunk to delay the conversion of the tail of the list, avoiding immediate computation. This function takes a `List[T]` as input and returns a `Stream[T]`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn Stream::from_list[T](l : List[T]) -> Stream[T] {\n  match l {\n    Nil => Empty\n    Cons(x, xs) => Cons(x, fn () { Stream::from_list(xs) })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Method Definition on Function Type Alias (MoonBit)\nDESCRIPTION: This code demonstrates the E4131 error. It attempts to define a method `call` for a type alias `FuncAlias`, which is an alias for a function type `(Int) -> Unit`. MoonBit does not allow method definitions on type aliases that are function types.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4131.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntypealias FuncAlias = (Int) -> Unit\n\npub fn FuncAlias::call(self : FuncAlias) -> Unit {\n  //   ^~~~~~~~~\n  // Error: The type alias FuncAlias is a function type, not a type constructor.\n  self(0)\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Example: Calling Show::to_string on type S without Show implementation\nDESCRIPTION: This code snippet demonstrates the E4018 error. It attempts to call the `to_string` method from the `Show` trait on a struct `S` without implementing the `Show` trait for `S`. This results in a compilation error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4018.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct S { v : Int }\n\nlet s : S = { v: 3 }\nlet t = Show::to_string(s)\n```\n\n----------------------------------------\n\nTITLE: MoonBit Package Configuration (lib)\nDESCRIPTION: Defines the package configuration for the 'lib' directory. This JSON file specifies package metadata.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0033.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Inline WASM Function Definition in MoonBit\nDESCRIPTION: This code snippet demonstrates an example of incorrect inline WASM syntax within a MoonBit function definition. The `i32_load` function is declared as external WASM, but the inline WASM code has an unmatched parenthesis, causing the E3014 error. The error message indicates the location of the unmatched parenthesis.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3014.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nextern \"wasm\" fn i32_load(addr : Int) -> Int = // Error: Inline wasm syntax error: unmatched parenthesis at 1:1-1:57\n  #|(func (param i32) (result i32)\n  #| (i32.load (local.get 0))\n```\n\n----------------------------------------\n\nTITLE: Erroneous Example: Loop without Continue (MoonBit)\nDESCRIPTION: Illustrates the compiler error E0018 in MoonBit, where a `loop` expression is used without a `continue` statement, making the loop redundant. The `countdown` function attempts to decrement a counter within a loop, but without `continue`, the loop executes only once.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0018.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn countdown(n : Int) -> Int {\n  let mut count = n\n  loop count {\n    _..<0 => break\n    _ => count = count - 1\n  }\n  return count\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid FFI Stub Type Example (WASM)\nDESCRIPTION: This MoonBit code demonstrates the E4042 error.  The `FixedArray[Int]` type is not a valid stub type for FFI on the WASM linear backend. The compiler will report an error, as `FixedArray` cannot be directly represented in the WASM environment. The function attempts to define an FFI function `ffi` that takes a `FixedArray[Int]` as input.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4042.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn ffi(array : FixedArray[Int]) -> Unit = \"mod\" \"ffi\"\n//             ^~~~~~~~~~~~~~~ Error: Invalid stub type.\n```\n\n----------------------------------------\n\nTITLE: Corrected Struct Expression in MoonBit\nDESCRIPTION: Illustrates the correct syntax for struct expressions in MoonBit. The corrected example replaces the incorrect `=` assignment with the correct `:` assignment within the struct update expression. This fixes the E3020 error by using `a : 1` instead of `a = 1`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3020.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct S {\n  a : Int\n  b : Int\n}\n\nfn main {\n  let s : S = { a : 1, b : 2 }\n  let ss = { ..s, a : 1 }\n  ignore(ss)\n}\n```\n\n----------------------------------------\n\nTITLE: Define Sealed Trait in MoonBit 'a.mbt'\nDESCRIPTION: This code defines a sealed trait named `Sealed` within the `a.mbt` file of package 'a'. The trait contains a single method, `to_int`, which takes no arguments and returns an `Int`. The `pub` keyword indicates that the trait is publicly accessible within its own package.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4145.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub trait Sealed {\n  to_int() -> Int\n}\n```\n\n----------------------------------------\n\nTITLE: Moonbit Struct with Redundant Modifier\nDESCRIPTION: This snippet demonstrates the E0008 error in Moonbit. The `priv` modifier on `value` in struct `A` and the `pub` modifier on `value` in struct `B` are redundant because fields have default visibility according to the struct's visibility.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0008.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct A {\n  priv value : Int\n  // Warning: The private modifier is redundant here\n  //          since field value is private by default\n}\n\npub struct B {\n  pub value : Int\n  // Warning: The public modifier is redundant here\n  //          since field value is public by default\n}\n```\n\n----------------------------------------\n\nTITLE: Map Literal Creation\nDESCRIPTION: Creates a map literal with key-value pairs. This approach is valid only when the keys and values are basic types like Int, String, Bool, or Double. The keys must be unique within the map.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/moonbit-tour/tour/chapter1_basics/lesson8_map/index.md#_snippet_0\n\nLANGUAGE: MoonBit\nCODE:\n```\n{\"key1\": value1, \"key2\": value2}\n```\n\n----------------------------------------\n\nTITLE: Enable E0032 Warning in moon.pkg.json\nDESCRIPTION: This JSON snippet demonstrates how to enable the E0032 warning by adding '+32' to the warn-list in the moon.pkg.json configuration file. This will cause the MoonBit compiler to issue a warning when it encounters an optional argument with an unused default value.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0032.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  // ...\n  \"warn-list\": \"+32\"\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous MoonBit Test Parameter\nDESCRIPTION: Demonstrates the incorrect usage of test parameters in MoonBit. This example shows a test function definition that uses a `String` type parameter, which leads to the E4132 compiler error because only `@test.T` is allowed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4132.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest (name : String) {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Newtype Access Error Example - MoonBit\nDESCRIPTION: This code demonstrates the error that occurs when trying to access a field of a struct directly when it's defined within a struct or enum that is not a newtype. It attempts to access the `value` field of an `Inner` struct within `ErrorOuter` (a type alias, which causes an error) and `EnumOuter` (an enum).\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4136.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Inner {\n  value : Int\n}\n\ntype! ErrorOuter Inner\n\nenum EnumOuter {\n  Outer(Inner)\n}\n\nfn main {\n  let outer : ErrorOuter = ErrorOuter(Inner::{ value: 1 })\n  println(outer.value) // Error: This expression has type ErrorOuter, which is a error type type and not a record.\n  let outer : EnumOuter = Outer(Inner::{ value: 2 })\n  println(outer.value) // Error: This expression has type EnumOuter, which is a variant type and not a record.\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit while loop example\nDESCRIPTION: This snippet demonstrates the structure of a while loop in MoonBit. The loop continues to execute as long as the condition expression remains true. The loop body is executed in each iteration until the condition becomes false.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/moonbit-tour/tour/zh/chapter1_basics/lesson10_loop/index.md#_snippet_1\n\nLANGUAGE: MoonBit\nCODE:\n```\nwhile 条件 {\n    // 循环体\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Size Trait in Moonbit\nDESCRIPTION: This snippet defines the `Size` trait with a `size()` method that takes a `Self` parameter and returns an `Int`.  This trait serves as the focal point for demonstrating the inconsistent `impl` error.  It requires an implementation for `Array[T]`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4135.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait Size { size(Self) -> Int }\n```\n\n----------------------------------------\n\nTITLE: Coverage Skip Pragma Example MoonBit\nDESCRIPTION: This snippet shows how to use the `@coverage.skip` pragma in MoonBit. It instructs the compiler to exclude the `function_to_skip` from code coverage calculations. This can be useful for excluding generated or test-only code.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0020.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\n///|\n/// @coverage.skip\nfn function_to_skip() {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Trait Definition using Trait Alias in Moonbit\nDESCRIPTION: This code snippet shows the corrected version of the erroneous example, using a trait and trait alias. It demonstrates the proper way to define a trait and use its alias in another trait definition.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4100.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait Original {\n  to_int(Self) -> Int\n}\n\ntypealias Alias = Original\n\ntrait Trait: Alias {\n  to_int(Self) -> Int\n}\n```\n\n----------------------------------------\n\nTITLE: Correct MoonBit Enum, Struct, and Error Type Definition\nDESCRIPTION: This code snippet demonstrates the correct syntax for defining enums, structs, and error types in MoonBit. It replaces the incorrect commas with newlines as delimiters between constructors/fields, adhering to the recommended MoonBit style.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3800.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nenum V {\n  A\n}\n\nstruct S {\n  a : Int\n}\n\ntype! E {\n  A\n}\n```\n\n----------------------------------------\n\nTITLE: Suggestion: Making a Function Public\nDESCRIPTION: This snippet shows how to resolve the E0001 warning by marking the `greeting` function as `pub`, making it part of the module's public API.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0001.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn greeting() -> String {\n  \"Hello!\"\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Integer Literal Assignment in MoonBit\nDESCRIPTION: This code snippet demonstrates the E4095 error.  The `byte` variable of type `Byte` is assigned the value 256, which is outside the valid range (0-255) for `Byte`. This results in a compilation error in MoonBit.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4095.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let byte : Byte = 256\n}\n```\n\n----------------------------------------\n\nTITLE: Block Expression Solution in MoonBit\nDESCRIPTION: This code snippet demonstrates the resolution of the E0022 error by treating the ambiguous expression as a block. When a block consists of only a single variable, the braces are redundant and can be removed, converting the expression to a simple variable assignment.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0022.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let value = 3\n  let s = value\n  ignore(s)\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous For-Loop Example (Missing Else)\nDESCRIPTION: This example demonstrates a for-loop used as the return expression of a function with a non-Unit return type, but it lacks the required 'else' branch. This results in the E4108 compiler error. The function 'f' is intended to return an Int, but the for-loop does not explicitly provide a value when it completes normally. Function 'g' exhibits same issue.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4108.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(x: Int) -> Int {\n  for i = 0, acc = 0; i < x; i = i + 1, acc = acc + i {\n//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Error: The for loop is\n//                                                      not expected to yield a\n//                                                      value, please add an\n//                                                      `else` branch.\n  }\n}\n\npub fn g(x: Int) -> Int {\n  for i in 0..=x {\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Create Module with Default Values\nDESCRIPTION: Creates a new MoonBit module using default values for all parameters.  This command is a shortcut to creating a module without needing to interact with prompts.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/tutorial.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ moon new my-project\n```\n\n----------------------------------------\n\nTITLE: Erroneous Example: Unused Function Definition\nDESCRIPTION: This snippet demonstrates an example of an unused function, `greeting`, which triggers the E0001 warning because it's neither called nor marked as `pub`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0001.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn greeting() -> String {\n  \"Hello!\"\n}\n\nfn main {\n  fn local_greeting() -> String {\n    \"Hello, world!\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Clojure: Higher-order function example\nDESCRIPTION: This Clojure code snippet demonstrates a higher-order function `map` being used with a partially applied function `(mul 3)`.  `(mul 3)` is not considered a redex because it lacks sufficient arguments. The example shows `map` applying `(mul 3)` to each element in `list-of-int`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_11\n\nLANGUAGE: clojure\nCODE:\n```\n(map (mul 3) list-of-int)\n```\n\n----------------------------------------\n\nTITLE: Immutable Record Field Example in MoonBit\nDESCRIPTION: This code snippet demonstrates the E4088 error in MoonBit. It shows a struct `S` with an immutable field `value`, and attempts to modify it, leading to a compilation error.  The `value` field is of type `Int`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4088.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct S {\n  value : Int\n}\n\nfn main {\n  let s = { value: 42 }\n  s.value = 43 // Error: The record field value is immutable.\n  println(s.value)\n}\n```\n\n----------------------------------------\n\nTITLE: Guard Statement with Implicit Termination in MoonBit\nDESCRIPTION: This example demonstrates a `guard` statement in MoonBit where the `else` part is omitted. In this case, if the condition specified in the `guard` statement is not true, the program terminates.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_52\n\nLANGUAGE: moonbit\nCODE:\n```\nguard cond\n```\n\n----------------------------------------\n\nTITLE: Removing Unused Generic Type Variable\nDESCRIPTION: This MoonBit code shows the suggested solution to remove the unused generic type variable 'T' from the 'Foo' struct. This resolves the E0005 error and avoids potential type inference problems.  The example simplifies the struct definition by removing the generic type parameter altogether. It requires a MoonBit compiler to execute.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0005.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Foo { // Remove the unused type variable.\n  bar : Int\n}\n```\n\n----------------------------------------\n\nTITLE: Example Diff Output\nDESCRIPTION: Illustrates the output of the `diff` command, showing changes between two versions of a `main.mbt` file. It highlights added and removed lines, demonstrating the basic functionality of diff utilities in version control systems.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/main/main.mbt b/main/main.mbt\nindex 99f4c4c..52b1388 100644\n--- a/main/main.mbt\n+++ b/main/main.mbt\n@@ -3,7 +3,7 @@\n\n fn main {\n   let a = lines(\"A\\nB\\nC\\nA\\nB\\nB\\nA\")\n-  let b = lines(\"C\\nB\\nA\\nB\\nA\\nC\")\n+  let b = lines(\"C\\nB\\nA\\nB\\nA\\nA\")\n   let r = shortst_edit(a, b)\n   println(r)\n }\n```\n\n----------------------------------------\n\nTITLE: Incorrect op_add implementation in MoonBit\nDESCRIPTION: This code snippet demonstrates an incorrect implementation of the `op_add` method for a custom type `A` in MoonBit. The `op_add` method is intended to overload the `+` operator, but it incorrectly accepts three arguments instead of the expected two, leading to the E4065 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4065.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntype A Int\n\nfn A::op_add(self : A, other : A, opt? : A) -> A {\n  //  ^~~~~~\n  // Error: overloaded operator \"op_add\" should accept 2 arguments, but it accepts 3 arguments\n  let opt = match opt {\n    None => 0\n    Some(opt) => opt._\n  }\n  return self._ + other._ + opt\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Code - Adding Main Function\nDESCRIPTION: Illustrates the solution by adding a `main` function to the MoonBit code, which resolves the E4067 error. The function initializes a variable of type `A` and prints its integer representation.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4067.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\n// ...\nfn main {\n  let a : A = 42\n  println(a.to_int())\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Example: Public Modifier on Default Trait Implementation (Moonbit)\nDESCRIPTION: This code snippet demonstrates the E4010 error in Moonbit. It shows an attempt to declare a default trait implementation with a `pub` (public) modifier, which is not allowed. The `pub` keyword is used on the default implementation of the `Stringer` trait, leading to the error.  The trait `Stringer` itself is defined with `pub(open)` visibility.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4010.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub(open) trait Stringer {\n  stringify(Self) -> String\n}\n\npub impl Stringer with stringify(_self) { \"hey\" }\n```\n\n----------------------------------------\n\nTITLE: Valid Enum Constructor - MoonBit\nDESCRIPTION: This code snippet shows the correct way to assign an enum variant. The variant 'V' is a valid constructor for the enum 'U', so no error occurs.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4031.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nenum U { V }\nlet v : U = V\n```\n\n----------------------------------------\n\nTITLE: Default Compile & Link Command for MSVC\nDESCRIPTION: This shell command shows the default compilation and linking process for MSVC (Microsoft Visual C++). It showcases how source files are compiled and linked, using MSVC's specific flags and options, to produce the target executable.  It uses the cl compiler.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/package.md#_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\ncl (/Fo|/Fe)$target -I$MOON_HOME/include [/LD] /utf-8 /wd4819 /nologo (/O2|/Od) \\\n   /link /LIBPATH:$MOON_HOME/lib\n```\n\n----------------------------------------\n\nTITLE: Deprecated Function with Alert in MoonBit\nDESCRIPTION: Demonstrates a deprecated function `greeting()` marked with an alert message recommending the use of `greet()` instead. The `main` function calls `greeting()`, triggering the alert.  The alert is a compile-time warning that suggests migrating to the new `greet` API.  The `/// @alert` annotation is used to specify the alert.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E2000.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\n/// @alert deprecated \"Use `greet` instead\"\nfn greeting() -> String {\n  \"Hello!\"\n}\n\nfn greet(name~ : String = \"\") -> String {\n  if name != \"\" {\n    \"Hello!\"\n  } else {\n    \"Hello, \\{name}!\"\n  }\n}\n\nfn main {\n  println(greeting())\n  //      ^~~~~~~~ Warning (Alert deprecated): Use `greet` instead(2000)\n}\n```\n\n----------------------------------------\n\nTITLE: PowerShell: Install MoonBit toolchain\nDESCRIPTION: This script installs the MoonBit toolchain on Windows systems using PowerShell. It sets the execution policy for the current user to allow remote scripts and then downloads and executes the installation script, adding MoonBit to the PATH.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/tutorial/tour.md#_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\nSet-ExecutionPolicy RemoteSigned -Scope CurrentUser; irm https://cli.moonbitlang.com/install/powershell.ps1 | iex\n```\n\n----------------------------------------\n\nTITLE: Unused Enum Constructor Fields in MoonBit\nDESCRIPTION: This example demonstrates the E0007 error when enum constructor fields are unused. It shows an enum `E` with constructors `A` and `B`, both having fields that are never read. The code produces warnings during compilation due to these unused fields.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0007.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nenum E {\n  A(Int) // Warning: The 1st positional argument of constructor 'A' is unused.\n  B(value~ : Int) // Warning: Field 'value' of constructor 'B' is unused.\n}\n\nfn main {\n  ignore(B(value=1))\n  match A(1) {\n    A(_) => println(\"A\")\n    B(_) => println(\"B\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Struct Field Redeclaration Error in MoonBit\nDESCRIPTION: This code snippet demonstrates the MoonBit error E4055, which occurs when a field is declared multiple times within the same struct. The struct `A` attempts to declare the field `a` twice, with different types.  The compiler will report an error due to this duplicate declaration.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4055.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct A {\n  a : Int\n  a : Double\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit middle.mbt\nDESCRIPTION: Defines a function `return_Obj` that returns an object of trait `Obj` defined in `@ty`. This snippet shows the function implementation.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4037.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn return_Obj() -> &@ty.Obj {\n  @ty.T(42)\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Mutable Enum Constructor - MoonBit\nDESCRIPTION: This code snippet demonstrates the incorrect usage of a mutable field without a label within an enum constructor. This will result in the E4012 error in MoonBit.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4012.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nenum E {\n  F(mut x : Int)\n}\n```\n\n----------------------------------------\n\nTITLE: Bash Example Usage\nDESCRIPTION: This is a placeholder bash code snippet demonstrating how the git diff outputs may be interpreted.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff3.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14\n 0  o---o---o---o---o---o---o\n    |   |   |   |   |   |   |\n 1  o---o---o---o---o---o---o\n    |   | \\ |   |   |   |   |\n 2  o---o---o---o---o---o---o\n    |   |   |   |   |   |   |\n 3  o---o---o---o---o---o---o\n    |   |   |   |   | \\ |   |\n 4  o---o---o---o---o---o---o\n    |   |   |   |   |   |   |\n 5  o---o---o---o---o---o---o\n                              \\\n 6                              @\n                                  \\\n 7                                  @---o---o---o---o---o---o\n                                        |   |   |   |   |   |\n 8                                      o---o---o---o---o---o\n                                        | \\ |   |   |   |   |\n 9                                      o---o---o---o---o---o\n                                        |   |   |   |   |   |\n10                                      o---o---o---o---o---o\n                                        |   |   |   |   |   |\n11                                      o---o---o---o---o---o\n                                        |   |   | \\ |   |   |\n12                                      o---o---o---o---o---o\n                                        |   |   |   |   |   |\n13                                      o---o---o---o---o---o\n                                        |   |   |   |   | \\ |\n14                                      o---o---o---o---o---o\n```\n\n----------------------------------------\n\nTITLE: Struct Pattern Matching with Useless '..'\nDESCRIPTION: This Moonbit code demonstrates the E0046 error. The '..' in the struct pattern `{ x, y, .. }` is useless because the `Point` struct only has two fields, `x` and `y`, both of which are already matched. Removing `..` will resolve the warning.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0046.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Point {\n  x : Int\n  y : Int\n}\n\nfn f(p : Point) -> Unit {\n  let { x, y, .. } = p\n  println(x + y)\n}\n\ntest {\n  f({ x: 1, y: 2 })\n}\n```\n\n----------------------------------------\n\nTITLE: Define MoonBit Package 'a'\nDESCRIPTION: This snippet defines the `moon.pkg.json` file for package 'a', which is an empty configuration file indicating a MoonBit package. It signifies the package's existence and can contain metadata about the package.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4145.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{}\n```\n\n----------------------------------------\n\nTITLE: Define Moonbit Package (Library)\nDESCRIPTION: This JSON file defines a Moonbit library package with no specific configuration.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0029.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{}\n```\n\n----------------------------------------\n\nTITLE: Invalid Const Declaration in MoonBit\nDESCRIPTION: This code snippet demonstrates an erroneous use of the `const` keyword in MoonBit. It attempts to assign the result of an addition operation (1 + 1) to a constant variable `A`. This results in the compiler error E4142 because the assigned value is not a literal.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4142.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nconst A : Int = 1 + 1 // Error: This 'const' declaration is not constant.\n```\n\n----------------------------------------\n\nTITLE: Defining function using reserved keyword in MoonBit\nDESCRIPTION: This code snippet demonstrates the E0035 error, which occurs when a reserved keyword (`module`) is used as a function name in MoonBit.  This is not allowed as these keywords are reserved for future use. The function attempts to return an integer.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0035.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn module() -> Int { // Warning: The word `module` is reserved for possible future use. Please consider using another name.\n  3\n}\n```\n\n----------------------------------------\n\nTITLE: Completing a MoonBit Function\nDESCRIPTION: Shows how to complete a function definition in MoonBit by providing a concrete implementation.  This avoids the runtime error associated with using `...`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0028.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f() -> Unit {\n  println(\"Hello, world!\")\n}\n```\n\n----------------------------------------\n\nTITLE: PDF Build\nDESCRIPTION: This snippet uses `make latexpdf` to build the documentation in PDF format using LaTeX. The resulting PDF file is then opened using the `open` command on macOS.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmake latexpdf\nopen ./_build/latex/moonbitdocument.pdf\n```\n\n----------------------------------------\n\nTITLE: Incorrect Package Usage in MoonBit\nDESCRIPTION: This snippet demonstrates an erroneous example where the `boolean` package is used, leading to a 'Package not found' error because the correct package name is `@bool`.  The code attempts to call the `to_int` method on a boolean value within a non-existent package.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4020.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nlet a = @boolean.to_int(true)\n```\n\n----------------------------------------\n\nTITLE: Ambiguous Constructor in MoonBit\nDESCRIPTION: This MoonBit code demonstrates the E4124 error, where the constructor `A` is ambiguous because it's defined in both enums `A` and `B`. The code attempts to create a value using the ambiguous constructor `A(1)` without specifying which enum it belongs to, leading to a compile-time error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4124.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nenum A {\n  A(Int)\n  B(Bool)\n  C(Double)\n}\n\nenum B {\n  A(Double)\n  B(Int)\n  C(Bool)\n}\n\nfn main {\n  let a = A(1) // Error: The constructor A is ambiguous: it may come from type B or A.\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Char in MoonBit\nDESCRIPTION: This code snippet demonstrates defining Char in MoonBit. `Char` represents a Unicode code point.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_12\n\nLANGUAGE: moonbit\nCODE:\n```\nlet c : Char = 'A'\n```\n\n----------------------------------------\n\nTITLE: MoonBit Record Field Error\nDESCRIPTION: This MoonBit code snippet demonstrates an error (E4026) where the field 'b' is not found in the record 'T' when creating a record instance. The program attempts to create a record with a field `b` when only a field `a` is defined.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4026.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct T { a : Int }\nfn main {\n  let t = { b: 42 }\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Trait and Implementation in MoonBit\nDESCRIPTION: This code shows the correct way to define a trait and its default implementation. Both the trait `T` and the implementation are located in the same package `b`.  The `pub(open)` visibility modifier allows external packages to implement this trait.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4073.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\npub(open) trait T {\n  f(Self) -> Int\n}\n\nimpl T with f(self : Self) -> Int {\n  ignore(self)\n  0\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Trait Object Creation in MoonBit\nDESCRIPTION: This code snippet demonstrates an attempt to create a trait object for the `Eq` trait in MoonBit. The error E4038 arises because the `Eq` trait is not object-safe, as its `op_equal` method uses `Self` multiple times in the type signature.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4038.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let a = 3 as &Eq\n}\n```\n\n----------------------------------------\n\nTITLE: Define MoonBit Package 'b'\nDESCRIPTION: This snippet defines the `moon.pkg.json` file for package 'b'. It specifies a dependency on package 'a' using the `import` key, allowing package 'b' to access the definitions from package 'a'.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4145.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"import\": [\n    \"username/hello/a\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Continue Usage in Loop Initialization - Moonbit\nDESCRIPTION: This Moonbit code demonstrates the E4112 error. The `continue` statement is incorrectly used within the initialization part of an inner `for` loop, which is not allowed. The compiler will flag this as an invalid usage.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4112.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(x: Int, y: Int) -> Unit {\n  for i = 0; i < x; i = i + 1 {\n    for j = { continue }; j < y; j = j + 1 {\n//            ^^^^^^^^ Error: The usage of continue statement is invalid.\n        println(i + j)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected MoonBit Loop Removing Unused Label\nDESCRIPTION: Shows the corrected version of the code snippet, removing the unused loop label. The example demonstrates a loop reading data using 'read()' and appending it to 'bytes' until 'read()' returns an empty 'BytesView', at which point the loop breaks.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0037.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let mut bytes = []\n  loop {\n    let bs = read()\n    if bs == [] {\n      break\n    }\n    bytes = [..bytes, ..bs]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Trait Method Definition with Type Parameter in MoonBit\nDESCRIPTION: This code snippet demonstrates an incorrect way to define a trait method in MoonBit. It shows a `Stringer` trait with a `stringify` method that attempts to use a type parameter `T`. MoonBit does not support generic methods within trait definitions, leading to a compilation error. The goal is to showcase what is currently not allowed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4004.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait Stringer {\n  stringify[T: Show](Self, T) -> String\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Unused Enum Constructor Fields in MoonBit\nDESCRIPTION: This example shows how to resolve the E0007 error by removing the unused fields from the enum constructor. The enum `E` is modified to have constructors `A` and `B` without any fields.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0007.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\nenum E {\n  A\n  B\n}\n```\n\n----------------------------------------\n\nTITLE: Side-Effect with init Block - MoonBit\nDESCRIPTION: Illustrates how to ensure side effects are executed when using a toplevel variable by wrapping the side effect within a `fn init` block.  This is used when you want to ensure that the side effects associated with initializing the variable are executed during module initialization.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0002.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn init {\n  println(\"Side effect\")\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative with If-Else for Double Comparison in MoonBit\nDESCRIPTION: This code snippet presents a solution to compare Double values without using range patterns. It employs an `if-else` structure to check if the value is less than 0.0 and prints corresponding messages.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4146.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let value = 1.0\n  if value < 0.0 {\n    println(\"negative\")\n  } else {\n    println(\"zero or positive\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Map in MoonBit\nDESCRIPTION: This code demonstrates how to create a `Map` in MoonBit using a literal syntax.  Keys must be constant expressions.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_28\n\nLANGUAGE: moonbit\nCODE:\n```\n{ \"a\": 1, \"b\": 2 }\n```\n\n----------------------------------------\n\nTITLE: Tuple Index Corrected Example - MoonBit\nDESCRIPTION: This MoonBit code snippet demonstrates the correct way to access a tuple element within bounds. It accesses the second element (index 1) of a tuple containing two elements. This code will compile and print the value 2.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4089.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let tuple = (1, 2)\n  println(tuple.1)\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Inline WASM: Unbound Function Call (MoonBit)\nDESCRIPTION: Illustrates an invalid inline WASM code snippet in MoonBit where the WASM code attempts to call a function that does not exist (`$does_not_exist`).  This results in an unbound function error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0044.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nextern \"wasm\" fn g() =\n  #| (func $g (call $does_not_exist))\n```\n\n----------------------------------------\n\nTITLE: Defining Line Struct in MoonBit\nDESCRIPTION: This code snippet defines a `Line` struct in MoonBit. The struct likely contains the text of the line and potentially metadata such as line number. It is used to represent a single line of text in the diff algorithm.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff.md#_snippet_5\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Line {\n  num : Int\n  text : String\n}\n\n```\n\n----------------------------------------\n\nTITLE: Erroneous Function Call in Moonbit\nDESCRIPTION: This code demonstrates the Moonbit error E4085. The function `f` is called with a non-existent labeled argument `age=20`. This causes the compiler to raise an error because the function signature doesn't define a parameter with that label.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4085.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(name : String) -> Unit {\n  println(\"Hello, \\{name}\")\n}\n\nfn main {\n  f(\"John\", age=20) // Error: This function has no parameter with label age~.\n}\n```\n\n----------------------------------------\n\nTITLE: Defining type A and trait B in package a - MoonBit\nDESCRIPTION: This MoonBit code defines a public type `A` as an integer and a public open trait `B` with a method `to_int` that converts a type to an integer. Both `A` and `B` are defined within the package 'a'.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4061.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub(all) type A Int\npub(open) trait B {\n  to_int(Self) -> Int\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected MoonBit Package JSON\nDESCRIPTION: This example shows a corrected `moon.pkg.json` file with the missing comma added after the `\"is-main\": true` line. Adding the comma resolves the E3017 error, making the JSON valid.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3017.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"is-main\": true,\n  \"import\": []\n}\n```\n\n----------------------------------------\n\nTITLE: Unsupported Escape Sequence in MoonBit Byte Literal\nDESCRIPTION: This code snippet demonstrates an unsupported escape sequence in a MoonBit Byte literal. The error E4064 occurs because Byte literals only support \\x and \\o escape sequences. Using \\uD000 is not allowed for Byte literals.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4064.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let _ : Byte = '\\uD000'\n}\n```\n\n----------------------------------------\n\nTITLE: Implicit Trait Implementation MoonBit\nDESCRIPTION: This code snippet demonstrates the deprecated implicit trait implementation in MoonBit. The `op_equal` function is defined as a regular method, which is implicitly used for the `Eq` trait. This behavior is being deprecated, and a warning (E0045) will be emitted. The intention is to make trait implementations more explicit.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0045.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntype MyType Int\n\nfn op_equal(self : MyType, other : MyType) -> Bool {\n  self._ == other._\n}\n\ntest {\n  // `==` will call `Eq::op_equal`\n  println(MyType(1) == MyType(2))\n}\n```\n\n----------------------------------------\n\nTITLE: Unused Pattern Example - MoonBit\nDESCRIPTION: This code demonstrates the E0010 error where the `Some(a)` pattern is unused because the `_` pattern always matches first. It shows a match statement on an option type where the wildcard pattern covers all cases, making the subsequent `Some(a)` pattern unreachable.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0010.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  match Some(1) {\n    _ => println(\"_\")\n    Some(a) => println(\"Some({a})\") // Warning: Unused pattern\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected Toplevel Declaration in MoonBit\nDESCRIPTION: Shows the correct way to declare a variable `x` at the toplevel in MoonBit, ensuring that there are no leading spaces before the `let` keyword. This example fixes the E0019 error by adhering to the required left alignment.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0019.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nlet x = 1\n```\n\n----------------------------------------\n\nTITLE: Installing dependencies and previewing the MoonBit Tour\nDESCRIPTION: This shell script installs project dependencies using pnpm, builds the project, and then starts a preview server. The tour website can then be viewed at http://localhost:3000.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/moonbit-tour/README-zh.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\npnpm install\npnpm build\npnpm preview\n```\n\n----------------------------------------\n\nTITLE: Invalid Inline WASM: Unmatched Parenthesis (MoonBit)\nDESCRIPTION: Demonstrates an invalid inline WASM code snippet in MoonBit due to an unmatched parenthesis in the WASM code. This results in a syntax error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0044.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nextern \"wasm\" fn f() =\n  #| (func $f\n```\n\n----------------------------------------\n\nTITLE: Moonbit Struct without Redundant Modifier\nDESCRIPTION: This snippet shows the corrected Moonbit code. The redundant `priv` and `pub` modifiers are removed from the struct fields, resolving the E0008 error. This relies on the default visibility of fields in structs.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0008.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct A {\n  value : Int\n}\n\npub struct B {\n  value : Int\n}\n```\n\n----------------------------------------\n\nTITLE: Localized HTML Build and Serve\nDESCRIPTION: This snippet builds the HTML documentation for a specific language (Chinese) and serves it using a Python web server. The `LANGUAGE` environment variable specifies the language for the build.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nLANGUAGE=\"zh_CN\" make html\npython3 -m http.server -d _build/html\n```\n\n----------------------------------------\n\nTITLE: Erroneous Map Pattern Example in MoonBit\nDESCRIPTION: Demonstrates an incorrect usage of map pattern matching in MoonBit, where the pattern lacks '..' and thus doesn't explicitly allow for extra elements. This example will trigger the E0041 warning.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0041.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn f(map : Map[String, Int]) -> Unit {\n  match map {\n    // the pattern still matches if `map` contain elements other than \"x\" and \"y\"\n    { \"x\": x, \"y\": y } => println(x + y)\n    _ => ()\n  }\n}\n\ntest {\n f({ \"x\": 1, \"y\": 2, \"z\": 3 })\n}\n```\n\n----------------------------------------\n\nTITLE: Breaking Type Alias Cycle with New Type in MoonBit\nDESCRIPTION: This code snippet shows one approach to resolving the E4129 error by introducing a new type. By declaring `type A B` before defining the type alias B as A, we effectively break the cycle.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4129.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntype A B\ntypealias B = A\n```\n\n----------------------------------------\n\nTITLE: Erroneous Default Trait Implementation in MoonBit\nDESCRIPTION: This code demonstrates the erroneous attempt to provide a default implementation for trait `T` (defined in package `a`) within package `b`. This triggers compiler error E4073 because default trait implementations are only allowed in the package where the trait is defined.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4073.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nimpl @a.T with f(self : Self) -> Int {\n  //           ^\n  // Error: Cannot provide default implementation for trait @a.T from package a\n  ignore(self)\n  0\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Error Example: Unexpected '~' in Argument\nDESCRIPTION: This code snippet demonstrates the MoonBit error E3016, which arises from incorrectly using the `~` operator within an enum constructor's argument in a match expression. The compiler expects either `label=pattern` for binding or `label~` for ignoring a field.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3016.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nenum A {\n  A(b~ : Int)\n}\n\nfn main {\n  match A(b=1) {\n    A(b~=c) => {\n      println(\"Hello, world! \\{c}\") // Error: unexpected `~` in argument. Did you mean `label=pattern` or `label~`?\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Derive on Type Alias in MoonBit\nDESCRIPTION: This code snippet demonstrates the E4130 error in MoonBit. It attempts to derive the `Show` trait for a type alias `StructAlias` of `MyStruct`, which is not allowed. This is because a type alias should behave identically to its underlying type and cannot independently derive traits.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4130.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct MyStruct {\n  field: Int\n}\n\ntypealias StructAlias = MyStruct derive(Show) // Error: `derive` is not allowed for type alias\n```\n\n----------------------------------------\n\nTITLE: Erroneous Trait Derivation in MoonBit\nDESCRIPTION: This code snippet demonstrates the incorrect attempt to automatically derive a user-defined trait `T` for type `A` in MoonBit. This results in a compilation error because MoonBit only supports deriving pre-defined traits.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4077.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait T {\n  f(Self) -> Int\n}\n\ntype A Int derive(T) // Error: Don't know how to derive trait T for type A\n```\n\n----------------------------------------\n\nTITLE: Erroneous MoonBit Example: Unbound Value Identifier\nDESCRIPTION: This code demonstrates the E4021 error in MoonBit. It attempts to call a non-existent function `to_integer` within the `@bool` package. This results in the 'Value to_integer not found in package `bool`' error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4021.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nlet a = @bool.to_integer(true)\n```\n\n----------------------------------------\n\nTITLE: Invalid Type Alias in MoonBit\nDESCRIPTION: This code snippet demonstrates the MoonBit error E4128. It attempts to define a type alias `Wrap[T]` that directly aliases the type parameter `T`. This is not allowed in MoonBit, as type aliases should not directly alias type parameters.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4128.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntypealias Wrap[T] = T // Error: Target of type alias must not be a type parameter.\n```\n\n----------------------------------------\n\nTITLE: Defining Addition Operation for Nodes in MoonBit\nDESCRIPTION: This code defines the addition operation between `Node` types, taking into account the abstracted `Data` type. It merges the data of the left and right nodes and sets the resulting tag to `Nil`, indicating that the parent's LazyTag no longer applies to the merged node.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/segment-tree/segment-tree2.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\ntrait Op_add[Data, Tag] {\n  fn op_add(Data, Data) -> Data\n}\n\nimpl [Data: Op_add[Data, Tag], Tag] Op_add[Node[Data, Tag], Tag] for Node[Data, Tag] {\n  fn op_add(left: Node[Data, Tag], right: Node[Data, Tag]) -> Node[Data, Tag] {\n    let left_data = match left {\n      Leaf(data) => data\n      Node { data, .. } => data\n    }\n    let right_data = match right {\n      Leaf(data) => data\n      Node { data, .. } => data\n    }\n    let data = op_add(left_data, right_data)\n    Node { left, right, data, tag: Nil, len: 0 }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Moonbit Record Pattern\nDESCRIPTION: This code snippet demonstrates the E3009 error that occurs when a record pattern contains only `..`. The `match` statement attempts to match any `Point` struct with an empty pattern using `..`, which is not allowed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3009.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Point {\n  x: Int\n  y: Int\n}\n\nfn process_point(p: Point) -> Unit {\n  match p {\n    { .. } => println(\"Got a point\")\n  //^~~~~~\n  // Error: Record pattern cannot contain only `..`, use wildcard pattern `_` instead.\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Infinite Fibonacci sequence in Clojure\nDESCRIPTION: This Clojure code defines an infinite Fibonacci sequence using lazy lists. It leverages the `Cons` constructor to build the list, with the first two elements being 0 and 1.  Subsequent elements are generated by zipping the `fibs` list with its tail, adding corresponding elements together.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-3.md#_snippet_15\n\nLANGUAGE: clojure\nCODE:\n```\n(defn fibs[] (Cons 0 (Cons 1 (zipWith add fibs (tail fibs)))))\n```\n\n----------------------------------------\n\nTITLE: Invalid Range Operator Usage MoonBit\nDESCRIPTION: This code snippet demonstrates the incorrect usage of range operators in MoonBit. Range operators like `0..<10` are only allowed directly within `for .. in` loops and cannot be assigned to a variable.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4137.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let range = 0..<10 // Error: Range operators are currently only supported in `for .. in` loops.\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Package Configuration - Error\nDESCRIPTION: Demonstrates an erroneous package configuration where the 'is-main' field is set to true, but no main function is present in the associated MoonBit file, leading to the E4067 error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4067.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"is-main\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Alert Pragma Example MoonBit\nDESCRIPTION: This snippet demonstrates the correct usage of the `@alert` pragma in MoonBit. It emits a warning message when the `deprecated_function` is encountered during compilation. The pragma takes a category and a message as arguments.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0020.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\n///|\n/// @alert deprecated \"This function is deprecated\"\nfn deprecated_function() {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Array Pattern with Multiple Range Patterns in MoonBit\nDESCRIPTION: Demonstrates the E3008 error in MoonBit, where an array destructuring pattern includes more than one '..' range pattern. The code defines an array and attempts to destructure it with multiple '..' patterns, resulting in a compiler error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3008.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  let array = [1, 2, 3, 4, 5]\n  let [fst, .., .., snd] = array\n  //            ^^\n  // Error: At most one `..` is allowed in array pattern.\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Package Import\nDESCRIPTION: Defines a JSON configuration for a MoonBit package 'b'. It specifies the import of the module 'username/hello/a', setting up a dependency between the two packages and highlighting the need for explicit type annotations in cross-package references.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4074.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"import\": [\n    \"username/hello/a\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Trait Method Call in MoonBit\nDESCRIPTION: This code snippet demonstrates an error in MoonBit where a method `to_str` is called on the `Show` trait, but the method is not defined in the trait definition, resulting in a compiler error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4039.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nlet a : String = Show::to_str(42)\n```\n\n----------------------------------------\n\nTITLE: Invalid String Interpolation with Bytes in MoonBit\nDESCRIPTION: This code demonstrates an erroneous attempt to use string interpolation with a `Bytes` variable in MoonBit. It highlights that string interpolation is not supported for `Bytes`, resulting in the E4096 error. The variable `x` of type `Int` is intended to be interpolated into the byte string.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4096.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntest {\n  let x : Int = 42\n  let _ : Bytes = \"({x})\"\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Moonbit Code: Inclusive Range with Wildcard Upper Bound\nDESCRIPTION: This Moonbit code snippet demonstrates the error E3019. It attempts to use an inclusive range pattern `0..=_` within a `match` statement, which is invalid because the upper bound is a wildcard. The code results in a compilation error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3019.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  match 0 {\n    0..=_ => println(\"Big than or equal to 0\")\n    //  ^\n    // Error: Inclusive range pattern `a..=b` cannot have `_` as upper bound\n    _ => println(\"Less than 0\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit: Declare is_qualified function\nDESCRIPTION: This code declares the `is_qualified` function in MoonBit. It takes a `Student` and a `Double` (criteria) as input and returns an `ExamResult`, indicating whether the student has passed based on the given criteria. The function body is left unimplemented initially using `...`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/tutorial/tour.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\nfn is_qualified(student : Student, criteria: Double) -> ExamResult {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Clojure: Defining square and main functions\nDESCRIPTION: This Clojure code defines two functions: `square` which calculates the square of a number, and `main` which adds 33 to the square of 3.  `square` takes one argument `x` and returns the result of multiplying `x` by itself. `main` takes no arguments and returns the result of adding 33 to the square of 3.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_9\n\nLANGUAGE: clojure\nCODE:\n```\n(defn square[x]  (mul x x))\n(defn main[] (add 33 (square 3)))\n```\n\n----------------------------------------\n\nTITLE: Moonbit: Invalid Partial Type Declaration\nDESCRIPTION: This snippet demonstrates the E4041 error in Moonbit, which occurs when a top-level declaration uses a partial type annotation, specifically `Option[_]`. This is not allowed, and the compiler will throw an error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4041.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nlet a : Option[_] = Some(3)\n```\n\n----------------------------------------\n\nTITLE: Conditional Expression with Type Matching in MoonBit\nDESCRIPTION: This MoonBit code shows a conditional expression where the return values of the consequent and the else clause must be of the same type. This example highlights the type safety of conditional expressions in MoonBit.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_48\n\nLANGUAGE: moonbit\nCODE:\n```\nif x > 0 { 1 } else { -1 }\n```\n\n----------------------------------------\n\nTITLE: Fixing Array Pattern with Single Range Pattern in MoonBit\nDESCRIPTION: Suggests a fix for the E3008 error by removing the extra '..' range pattern, so only one '..' range pattern exist. Demonstrates the array destructuring with one '..' range pattern in the corrected code.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3008.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  // ...\n  let [fst, .., snd] = array\n}\n```\n\n----------------------------------------\n\nTITLE: Solution: Using Manual Implementation and omitting derive\nDESCRIPTION: Shows how to resolve the E4079 error by keeping the manual implementation of the `Show` trait and removing `Show` from the derive list. This tells the compiler to use the manually defined method and to avoid automatic derivation of the `Show` trait.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4079.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nimpl Show for A with output(self : A, logger : &Logger) -> Unit {\n  logger.write_object(self._)\n}\n\ntype A Int derive(Hash)\n```\n\n----------------------------------------\n\nTITLE: Unwinding Stack in MoonBit\nDESCRIPTION: This MoonBit code implements the `Unwind` instruction. It checks the node type on the top of the stack. If it's a number (NNum), it checks if there's a recoverable context in the dump. If so, it restores the context. If the node is an application (NApp), it pushes the left child's address onto the stack and continues unwinding. If it's a supercombinator (NAp), it rearranges the stack if necessary and executes the supercombinator's instructions. If it's an indirection node (NInd), update the stack with the address it points to and re-unwind.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-2.md#_snippet_7\n\nLANGUAGE: moonbit\nCODE:\n```\nUnwind => {\n      let addr = state.stack.last()\n      let node = state.heap[addr]\n      match node {\n        Node::NNum(_) => {\n          match list::last_opt(state.dump) {\n            Some((old_instrs, old_stack)) => {\n              let new_dump = list::drop_last(state.dump)\n              {\n                state with\n                instructions = old_instrs,\n                stack = list::push(old_stack, addr),\n                dump = new_dump\n              }\n            }\n            None => state // Program completes\n          }\n        }\n        Node::NApp(a1, _) => {\n          let new_stack = list::drop_last(state.stack)\n          {\n            state with\n            stack = list::push(new_stack, a1)\n          }\n        }\n        Node::NAp(n, instrs) => {\n          let new_state = if n == 0 {\n            state\n          } else {\n            rearrange(state, n)\n          }\n          {\n            new_state with\n            instructions = instrs\n          }\n        }\n        Node::NInd(addr2) => {\n          let new_stack = list::drop_last(state.stack)\n          {\n            state with\n            stack = list::push(new_stack, addr2)\n          }\n        }\n      }\n    }\n```\n\n----------------------------------------\n\nTITLE: Suggestion: Fixing Conflicting Trait Implementations in MoonBit\nDESCRIPTION: This code snippet suggests making both the implicit and explicit implementations of the trait have the same visibility (in this case, `pub`). By adding `pub` to the `impl` block, the compiler will enforce consistency.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4062.md#_snippet_4\n\nLANGUAGE: moonbit\nCODE:\n```\n// ...\npub impl T for A with f(self : A) -> Int {\n  println(\"impl T for A with f\")\n  self._\n}\n```\n\n----------------------------------------\n\nTITLE: Range Pattern with Constant Value - MoonBit\nDESCRIPTION: This code shows another solution to E3018 by directly using a constant value (3) as the upper bound in the range pattern. This satisfies the compiler's requirement, avoiding the error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E3018.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  match 0 {\n    0..<3 => println(\"Between 0 and 3\")\n    _ => println(\"Not between 0 and 3\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Show Implementation for TermDBI in MoonBit\nDESCRIPTION: This code snippet implements the `Show` trait for the `TermDBI` enum in MoonBit, allowing Lambda terms represented with de Bruijn indices to be printed and viewed easily.  The implementation recursively prints the structure of the term, using the stored string for variable names to improve readability.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/lambda/index.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nimpl Show for TermDBI {\n  fn show(self : Self) -> String {\n    match self {\n      VarDBI(i, s) => s + \"#\" + show(i)\n      AbsDBI(s, t) => \"(\\\\ \" + s + \".\" + show(t) + \")\"\n      AppDBI(t1, t2) => show(t1) + \" \" + show(t2)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Take function definition in Clojure\nDESCRIPTION: This Clojure code defines a `take` function that takes the first `n` elements of a list `l`. It uses pattern matching with `case` to handle empty lists (`Nil`) and non-empty lists (`Cons x xs`). If `n` is less than or equal to 0, it returns `Nil`; otherwise, it returns a new list containing the first element `x` and the result of recursively calling `take` with `n-1` and the rest of the list `xs`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-3.md#_snippet_8\n\nLANGUAGE: clojure\nCODE:\n```\n(defn take[n l]\n  (case l\n    [(Nil) Nil]\n    [(Cons x xs)\n      (if (le n 0)\n        Nil\n        (Cons x (take (sub n 1) xs)))]))\n```\n\n----------------------------------------\n\nTITLE: Enum with Payload Data - Function Definition in MoonBit\nDESCRIPTION: Presents a function that uses an enum with payload data. This example defines a function to calculate the sum of an `IntList`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/fundamentals.md#_snippet_80\n\nLANGUAGE: moonbit\nCODE:\n```\nfn sum(list : IntList) : Int {\n  case list {\n    Nil => 0\n    Cons(head, tail) => head + sum(tail)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example Diff Output (Deletion and Insertion)\nDESCRIPTION: Shows an example of a diff output with both deletions (marked with '-') and insertions (marked with '+'). The example demonstrates how `diff` can be used to represent changes made to text, highlighting the lines that were removed or added.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n- A\n- B\n  C\n+ B\n  A\n  B\n- B\n  A\n+ C\n```\n\n----------------------------------------\n\nTITLE: Building the Segment Tree in MoonBit\nDESCRIPTION: This code implements the tree-building function. It recursively constructs the tree from a given array of data.  It creates `Leaf` nodes for single elements and `Node` nodes by combining the results of building subtrees for the left and right halves of the array. The addition operations from the `Op_add` trait are used to calculate data for the parent nodes.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/segment-tree/segment-tree2.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn build[Data: Op_add[Data, Tag], Tag](arr: List[Data], l: Int, r: Int) -> Node[Data, Tag] {\n  if l == r {\n    match arr {\n      Cons(x, _) => Leaf(x)\n      Nil => panic \"unreachable\"\n    }\n  } else {\n    let mid = l + (r - l) / 2\n    let left = build(arr, l, mid)\n    let right = build(arr, mid + 1, r)\n    let len = r - l + 1\n    let data = match left {\n      Leaf(data) => data\n      Node { data, .. } => data\n    }\n    match right {\n      Leaf(data) => data\n      Node { data, .. } => data\n    }\n    Node { left, right, data: op_add(left, right), tag: Nil, len }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing find_path function in Moonbit\nDESCRIPTION: This code shows the implementation of the `find_path` function in Moonbit. This function recursively searches for the complete edit path by finding the middle snake using the `midpoint` function.  If no middle snake is found, it returns an empty array, otherwise, it splits the problem into two subproblems and recursively calls `find_path` on them.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/myers-diff/myers-diff3.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn find_path(a: Array[String], b: Array[String], box: Box) -> Array[Snake] {\n  match midpoint(box, a, b) {\n    None => { [] }\n    Some(snake) => {\n      if snake.px == box.x0 && snake.py == box.y0 {\n        let box1 = Box { x0: snake.x, y0: snake.y, x1: box.x1, y1: box.y1 }\n        let path1 = find_path(a, b, box1)\n        [snake, ..path1]\n      } else if snake.x == box.x1 && snake.y == box.y1 {\n        let box0 = Box { x0: box.x0, y0: box.y0, x1: snake.px, y1: snake.py }\n        let path0 = find_path(a, b, box0)\n        [..path0, snake]\n      } else {\n        let box0 = Box { x0: box.x0, y0: box.y0, x1: snake.px, y1: snake.py }\n        let box1 = Box { x0: snake.x, y0: snake.y, x1: box.x1, y1: box.y1 }\n        let path0 = find_path(a, b, box0)\n        let path1 = find_path(a, b, box1)\n        [..path0, snake, ..path1]\n      }\n    }\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Erroneous Pattern Matching in MoonBit\nDESCRIPTION: This MoonBit code snippet demonstrates error E4082. The variable `a` is only bound in the `A` pattern but not in the `B` pattern, causing a compile-time error. The code defines an enum `E` and a function `f` that attempts to match on the enum variants, resulting in the error because the variable 'a' isn't bound in all patterns.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4082.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nenum E {\n  A(Int, Double)\n  B(Int)\n}\n\nfn f(value : E) -> Unit {\n  match value {\n    A(a, _) | B(_) => println(\"Hello\") // Error: Variable a is not bound in all patterns.\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Omitted Arguments using `..` in Moonbit\nDESCRIPTION: This snippet shows how to correctly handle omitted constructor arguments in Moonbit by adding `..` to the end of the pattern. This tells the compiler that some arguments are intentionally omitted.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0021.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  match A(0, w=1, h=2) {\n    A(v, w~, ..) => {\n      println(v)\n      println(w)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with All Arguments in Moonbit\nDESCRIPTION: This snippet demonstrates how to match all arguments of a constructor in Moonbit. This avoids the E0021 error by explicitly matching all the constructor's fields.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0021.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  match A(0, w=1, h=2) {\n    A(v, w~, h~) => {\n      println(v)\n      println(w)\n      println(h)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Suggestion: Corrected Function Call with Single Label (Moonbit)\nDESCRIPTION: This code demonstrates the corrected function call where the labeled parameter `a` is supplied only once. This is the simplest fix when the error occurs due to redundancy. The function `f` now receives the labeled parameter `a` with the value 0.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4084.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  f(a=0)\n}\n```\n\n----------------------------------------\n\nTITLE: Corrected MoonBit For-Loop: Separate Update\nDESCRIPTION: This example demonstrates an alternative fix for the E4106 error. The variable `j` is declared outside the for-loop, and its update is moved to the loop body, removing it from the update expressions of the `for` statement. The function `f` now updates `j` inside the loop after printing its value.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4106.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(x: Int) -> Unit {\n  let mut j = 0\n  for i = 0; i < x; i = i + 1 {\n    println(i)\n    println(j)\n    j = j + 1\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit: G-Machine Instruction Set Definition\nDESCRIPTION: This MoonBit code defines the instruction set (`Instr`) for the simplified G-Machine.  The instructions include `PushInt` (push integer), `PushGlobal` (push global function), `PushArg` (push argument), `MkApp` (make application), `Update` (update node), `Unwind` (unwind stack), and `Pop` (pop arguments). Each instruction performs a specific operation on the G-Machine's state.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-1.md#_snippet_14\n\nLANGUAGE: moonbit\nCODE:\n```\n  enum Instr {\n    PushInt(Int),\n    PushGlobal(String),\n    PushArg(Int),\n    MkApp,\n    Update(Int),\n    Unwind,\n    Pop(Int),\n  }\n```\n\n----------------------------------------\n\nTITLE: Run MoonBit Tests\nDESCRIPTION: Executes the MoonBit tests using the `moon test` command. This command finds and executes all tests in the project.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/tutorial.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ moon test\nTotal tests: 1, passed: 1, failed: 0.\n```\n\n----------------------------------------\n\nTITLE: Public Variant Declaration MoonBit\nDESCRIPTION: This example shows how to make all variants of the enum `T` public using `pub(all)`. This allows variants to be constructed outside the current package. This exposes internal implementation details.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0006.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\npub(all) enum T {\n  A\n  B\n  C\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit Package Definition for Package 'b'\nDESCRIPTION: Defines the `moon.pkg.json` file for package 'b', marking it as the main package and importing package 'a' from module 'username/hello'.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4094.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"is-main\": true,\n  \"import\": [\n    \"username/hello/a\"\n  ]\n}\n\n```\n\n----------------------------------------\n\nTITLE: Erroneous Try Expression in Moonbit\nDESCRIPTION: This code snippet demonstrates Moonbit error E0023. The `try` block contains a `println` statement that never raises an error, making the `try...catch` construct redundant. The compiler flags this as an error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E0023.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nfn main {\n  try {\n    println(\"Hello, world!\")\n  } catch {\n    _ => println(\"Error\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Method Overloading in MoonBit\nDESCRIPTION: This snippet demonstrates method overloading using the `TypeName::method_name` syntax. Different types can define methods of the same name because each method lives in a different namespace.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/methods.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\n// method overload example\nfn Foo::f() -> Int {\n  1\n}\n\nfn Bar::f() -> Int {\n  2\n}\n\nfn main {\n  Foo::f() + Bar::f()\n}\n```\n\n----------------------------------------\n\nTITLE: MoonBit: Define Student struct\nDESCRIPTION: This code defines a `Student` struct in MoonBit, which contains a student's ID (as a String) and their score (as a Double). This custom data type represents a student record, enhancing code readability and maintainability.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/tutorial/tour.md#_snippet_2\n\nLANGUAGE: moonbit\nCODE:\n```\nstruct Student {\n  id : String\n  score : Double\n}\n```\n\n----------------------------------------\n\nTITLE: Attempt Sealed Trait Implementation in MoonBit 'b.mbt'\nDESCRIPTION: This snippet attempts to implement the sealed trait `Sealed` (defined in package `a`) for a type `A` in package `b`. This triggers the E4145 error because sealed traits cannot be implemented outside their defining package without being explicitly opened. It highlights the restrictions on trait implementation in MoonBit and the error message produced.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4145.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\ntype A Int\n\nimpl @a.Sealed for A with to_int(self : A) -> Int { // Error: Cannot implement trait '@a.Sealed' because it is readonly.\n  self._\n}\n```\n\n----------------------------------------\n\nTITLE: Attempting to Derive Trait for Abstract Type in MoonBit\nDESCRIPTION: This code snippet demonstrates the compiler error E4078, which occurs when attempting to derive a trait (Hash in this case) for an abstract type (T). MoonBit does not allow automatic derivation for abstract types.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4078.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\ntype T derive(Hash) // Error: Cannot derive trait Hash for type T: target type is abstract\n```\n\n----------------------------------------\n\nTITLE: Invalid 'continue' outside of a loop - MoonBit\nDESCRIPTION: Shows an example where a 'continue' statement is used outside of any loop construct. This leads to a compiler error as 'continue' is designed to skip to the next iteration of a loop and has no effect outside a loop.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4102.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn g(x: Int) -> Int {\n  continue x\n// ^^^^^^^^ Error: 'continue' outside of a loop\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid 'break' in 'else' branch of a loop - MoonBit\nDESCRIPTION: Illustrates an erroneous example where a 'break' statement is used within the 'else' branch of a for loop, which is outside the loop's primary context. This results in a compiler error because 'break' can only be used to exit the loop early.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4102.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npub fn f(xs: Array[Int]) -> Int {\n  for i in xs {\n    ignore(i)\n  } else {\n    break 42\n//  ^^^^^^^^ Error: 'break' outside of a loop\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Public Field in a Private Struct in MoonBit\nDESCRIPTION: This code snippet demonstrates an erroneous example of declaring a public field within a private struct in MoonBit. This is not allowed and will result in a compiler error. The visibility of the field should match the visibility of the struct.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error_codes/E4001.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\npriv struct S {\n  pub field: Int\n}\n```\n\n----------------------------------------\n\nTITLE: Wasm Backend Memory Export Configuration\nDESCRIPTION: This JSON snippet demonstrates how to configure the `export-memory-name` option for the Wasm backend in the `link` section of a `moon.pkg.json` file. It specifies that the Wasm module exports the linear memory with the name `memory`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/package.md#_snippet_5\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"link\": {\n      \"wasm\": {\n        \"export-memory-name\": \"memory\"\n      },\n      \"wasm-gc\": {\n        \"export-memory-name\": \"memory\"\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Anonymous Function with Error\nDESCRIPTION: This snippet shows how to use the `!` suffix with anonymous functions to indicate they might return an error.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/error-handling.md#_snippet_3\n\nLANGUAGE: moonbit\nCODE:\n```\nlet f : fn(Int) -> Int! = fn!(x) { x + 1 }\n\ntype! MyError\nlet x : Error = MyError\n```\n\n----------------------------------------\n\nTITLE: Compile Primitive Functions\nDESCRIPTION: This snippet demonstrates how primitive functions are compiled in MoonBit. It shows the basic structure for defining primitive operations within the compiler. The function takes a `Symbol` and a list of expressions and returns a list of `Instruction`s.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/example/gmachine/gmachine-3.md#_snippet_0\n\nLANGUAGE: moonbit\nCODE:\n```\nmatch prim with\n  | `add =>\n    compileC e1 ++ compileC e2 ++ [Prim Add]\n  | `sub =>\n    compileC e1 ++ compileC e2 ++ [Prim Sub]\n  | `mul =>\n    compileC e1 ++ compileC e2 ++ [Prim Mul]\n  | `div =>\n    compileC e1 ++ compileC e2 ++ [Prim Div]\n  | `eq =>\n    compileC e1 ++ compileC e2 ++ [Prim Eq]\n  | `lt =>\n    compileC e1 ++ compileC e2 ++ [Prim Lt]\n  | `gt =>\n    compileC e1 ++ compileC e2 ++ [Prim Gt]\n  | `if =>\n    compileC e1 ++ compileC e2 ++ compileC e3 ++ [Prim If]\n  | `negate =>\n    compileC e1 ++ [Prim Negate]\n  | _ => abort \"Unimplemented primitive\"\n```\n\n----------------------------------------\n\nTITLE: Lib Package Configuration (lib/moon.pkg.json)\nDESCRIPTION: Defines an empty configuration file for the `lib` package. This file informs the build system that the directory should be treated as a package.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/toolchain/moon/tutorial.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{}\n```\n\n----------------------------------------\n\nTITLE: Moonbit Alert Pragmas Example\nDESCRIPTION: This code snippet demonstrates the use of `@alert` pragmas within doc comments in Moonbit.  The `@alert` pragma is used to mark functions as `deprecated` or `unsafe`, providing a mechanism for generating warnings when these functions are referenced.  It takes the form `@alert category \"alert message...\"`.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/language/docs.md#_snippet_1\n\nLANGUAGE: moonbit\nCODE:\n```\n/// @alert deprecated \"Use foo2 instead\"\npub fn foo() -> Unit {\n  ...\n}\n\n/// @alert unsafe \"Div will cause an error when y is zero\"\npub fn div(x : Int, y : Int) -> Int {\n  ...\n}\n\ntest {\n  // Warning (Alert deprecated): Use foo2 instead\n  foo()\n  // Warning (Alert unsafe): Div will cause an error when y is zero\n  div(1, 2) |> ignore\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Activating Python Virtual Environment\nDESCRIPTION: This snippet creates a Python virtual environment, activates it, and installs the required dependencies from `requirements.txt`. It uses `venv` for environment creation and `pip` for package installation.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/README-zh.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m venv .env\nsource .env/bin/activate\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Translation Template Update\nDESCRIPTION: This snippet updates the translation template using `make gettext` to extract translatable strings and `sphinx-intl update` to merge them into the existing translation files. This process prepares the documentation for localization.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/README.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nmake gettext\nsphinx-intl update -p _build/gettext -l zh_CN\n```\n\n----------------------------------------\n\nTITLE: Markdown Build\nDESCRIPTION: This snippet installs the `sphinx-markdown-builder` package and uses `make markdown` to build the documentation in Markdown format. This requires the `sphinx-markdown-builder` package to be installed.\nSOURCE: https://github.com/moonbitlang/moonbit-docs/blob/main/next/README.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npip install sphinx-markdown-builder\nmake markdown\n```"
  }
]