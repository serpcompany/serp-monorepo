[
  {
    "owner": "yhirose",
    "repo": "cpp-httplib",
    "content": "TITLE: Implementing HTTP/HTTPS Client with cpp-httplib\nDESCRIPTION: Shows how to create HTTP and HTTPS clients, make GET requests, and access response properties like status and body content.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\n#define CPPHTTPLIB_OPENSSL_SUPPORT\n#include \"path/to/httplib.h\"\n\n// HTTP\nhttplib::Client cli(\"http://yhirose.github.io\");\n\n// HTTPS\nhttplib::Client cli(\"https://yhirose.github.io\");\n\nauto res = cli.Get(\"/hi\");\nres->status;\nres->body;\n```\n\n----------------------------------------\n\nTITLE: Setting up Basic HTTP/HTTPS Server and Client in C++\nDESCRIPTION: Demonstrates how to initialize both HTTP and HTTPS servers and clients using cpp-httplib. Shows basic request handling and response generation with OpenSSL support.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\n#define CPPHTTPLIB_OPENSSL_SUPPORT\n#include \"path/to/httplib.h\"\n\n// HTTP\nhttplib::Server svr;\n\n// HTTPS\nhttplib::SSLServer svr;\n\nsvr.Get(\"/hi\", [](const httplib::Request &, httplib::Response &res) {\n  res.set_content(\"Hello World!\", \"text/plain\");\n});\n\nsvr.listen(\"0.0.0.0\", 8080);\n```\n\n----------------------------------------\n\nTITLE: Configuring SSL Support in cpp-httplib\nDESCRIPTION: Demonstrates SSL configuration for both server and client implementations, including certificate paths, CA bundle usage, and verification options.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\n#define CPPHTTPLIB_OPENSSL_SUPPORT\n#include \"path/to/httplib.h\"\n\n// Server\nhttplib::SSLServer svr(\"./cert.pem\", \"./key.pem\");\n\n// Client\nhttplib::Client cli(\"https://localhost:1234\"); // scheme + host\nhttplib::SSLClient cli(\"localhost:1234\"); // host\nhttplib::SSLClient cli(\"localhost\", 1234); // host, port\n\n// Use your CA bundle\ncli.set_ca_cert_path(\"./ca-bundle.crt\");\n\n// Disable cert verification\ncli.enable_server_certificate_verification(false);\n\n// Disable host verification\ncli.enable_server_hostname_verification(false);\n```\n\n----------------------------------------\n\nTITLE: HTTP POST with Multipart Form Data in C++ HTTP Client\nDESCRIPTION: Demonstrates how to send multipart form data including text fields and file attachments with different content types.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_36\n\nLANGUAGE: c++\nCODE:\n```\nhttplib::MultipartFormDataItems items = {\n  { \"text1\", \"text default\", \"\", \"\" },\n  { \"text2\", \"aÏ‰b\", \"\", \"\" },\n  { \"file1\", \"h\\ne\\n\\nl\\nl\\no\\n\", \"hello.txt\", \"text/plain\" },\n  { \"file2\", \"{\\n  \\\"world\\\", true\\n}\\n\", \"world.json\", \"application/json\" },\n  { \"file3\", \"\", \"\", \"application/octet-stream\" },\n};\n\nauto res = cli.Post(\"/multipart\", items);\n```\n\n----------------------------------------\n\nTITLE: HTTP GET with Headers in C++ HTTP Client\nDESCRIPTION: Demonstrates how to make GET requests with custom HTTP headers. Shows three different approaches to setting headers for requests.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_30\n\nLANGUAGE: c++\nCODE:\n```\nhttplib::Headers headers = {\n  { \"Hello\", \"World!\" }\n};\nauto res = cli.Get(\"/hi\", headers);\n```\n\n----------------------------------------\n\nTITLE: Creating a Full HTTP Server with Multiple Route Handlers\nDESCRIPTION: Demonstrates a complete HTTP server implementation with different route patterns, including regex matching, path parameters, header and query parameter handling, and connection state polling.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\n#include <httplib.h>\n\nint main(void)\n{\n  using namespace httplib;\n\n  Server svr;\n\n  svr.Get(\"/hi\", [](const Request& req, Response& res) {\n    res.set_content(\"Hello World!\", \"text/plain\");\n  });\n\n  // Match the request path against a regular expression\n  // and extract its captures\n  svr.Get(R\"(/numbers/(\\d+))\", [&](const Request& req, Response& res) {\n    auto numbers = req.matches[1];\n    res.set_content(numbers, \"text/plain\");\n  });\n\n  // Capture the second segment of the request path as \"id\" path param\n  svr.Get(\"/users/:id\", [&](const Request& req, Response& res) {\n    auto user_id = req.path_params.at(\"id\");\n    res.set_content(user_id, \"text/plain\");\n  });\n\n  // Extract values from HTTP headers and URL query params\n  svr.Get(\"/body-header-param\", [](const Request& req, Response& res) {\n    if (req.has_header(\"Content-Length\")) {\n      auto val = req.get_header_value(\"Content-Length\");\n    }\n    if (req.has_param(\"key\")) {\n      auto val = req.get_param_value(\"key\");\n    }\n    res.set_content(req.body, \"text/plain\");\n  });\n\n  // If the handler takes time to finish, you can also poll the connection state\n  svr.Get(\"/task\", [&](const Request& req, Response& res) {\n    const char * result = nullptr;\n    process.run(); // for example, starting an external process\n    while (result == nullptr) {\n      sleep(1);\n      if (req.is_connection_closed()) {\n        process.kill(); // kill the process\n        return;\n      }\n      result = process.stdout(); // != nullptr if the process finishes\n    }\n    res.set_content(result, \"text/plain\");\n  });\n\n  svr.Get(\"/stop\", [&](const Request& req, Response& res) {\n    svr.stop();\n  });\n\n  svr.listen(\"localhost\", 1234);\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP POST with Parameters in C++ HTTP Client\nDESCRIPTION: Demonstrates how to make POST requests with parameters using the Params structure. Shows both constructing parameters incrementally and all at once.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_34\n\nLANGUAGE: c++\nCODE:\n```\nhttplib::Params params;\nparams.emplace(\"name\", \"john\");\nparams.emplace(\"note\", \"coder\");\n\nauto res = cli.Post(\"/post\", params);\n```\n\n----------------------------------------\n\nTITLE: HTTP PUT, DELETE, and OPTIONS Methods in C++ HTTP Client\nDESCRIPTION: Shows how to use PUT, DELETE, and OPTIONS HTTP methods with the client. Examples include sending content with PUT and making OPTIONS requests.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_37\n\nLANGUAGE: c++\nCODE:\n```\nres = cli.Put(\"/resource/foo\", \"text\", \"text/plain\");\n```\n\n----------------------------------------\n\nTITLE: Configuring Authentication in C++ HTTP Client\nDESCRIPTION: Shows how to set up different types of authentication for the HTTP client, including Basic, Digest, and Bearer Token authentication. Note that OpenSSL is required for Digest Authentication.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_46\n\nLANGUAGE: cpp\nCODE:\n```\n// Basic Authentication\ncli.set_basic_auth(\"user\", \"pass\");\n\n// Digest Authentication\ncli.set_digest_auth(\"user\", \"pass\");\n\n// Bearer Token Authentication\ncli.set_bearer_token_auth(\"token\");\n```\n\n----------------------------------------\n\nTITLE: Setting Timeout Parameters in C++ HTTP Client\nDESCRIPTION: Demonstrates configuring various timeout parameters for the client including connection timeout, read timeout, write timeout, and maximum total timeout.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_40\n\nLANGUAGE: c++\nCODE:\n```\ncli.set_connection_timeout(0, 300000); // 300 milliseconds\ncli.set_read_timeout(5, 0); // 5 seconds\ncli.set_write_timeout(5, 0); // 5 seconds\n\n// This method works the same as curl's `--max-timeout` option\nsvr.set_max_timeout(5000); // 5 seconds\n```\n\n----------------------------------------\n\nTITLE: Configuring a Static File Server with cpp-httplib\nDESCRIPTION: Demonstrates how to set up a static file server with multiple mount points, directory search order, and custom MIME type mappings.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n// Mount / to ./www directory\nauto ret = svr.set_mount_point(\"/\", \"./www\");\nif (!ret) {\n  // The specified base directory doesn't exist...\n}\n\n// Mount /public to ./www directory\nret = svr.set_mount_point(\"/public\", \"./www\");\n\n// Mount /public to ./www1 and ./www2 directories\nret = svr.set_mount_point(\"/public\", \"./www1\"); // 1st order to search\nret = svr.set_mount_point(\"/public\", \"./www2\"); // 2nd order to search\n\n// Remove mount /\nret = svr.remove_mount_point(\"/\");\n\n// Remove mount /public\nret = svr.remove_mount_point(\"/public\");\n```\n\n----------------------------------------\n\nTITLE: Receiving Content with Callback in C++ HTTP Client\nDESCRIPTION: Shows how to handle large response bodies by receiving content incrementally with a callback function instead of storing the entire response in memory.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_41\n\nLANGUAGE: c++\nCODE:\n```\nstd::string body;\n\nauto res = cli.Get(\"/large-data\",\n  [&](const char *data, size_t data_length) {\n    body.append(data, data_length);\n    return true;\n  });\n```\n\n----------------------------------------\n\nTITLE: Handling Redirects in C++ HTTP Client\nDESCRIPTION: Shows how to handle HTTP redirects using the client. The example demonstrates checking the initial redirect status and then enabling automatic redirect following to reach the final destination.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_50\n\nLANGUAGE: cpp\nCODE:\n```\nhttplib::Client cli(\"yahoo.com\");\n\nauto res = cli.Get(\"/\");\nres->status; // 301\n\ncli.set_follow_location(true);\nres = cli.Get(\"/\");\nres->status; // 200\n```\n\n----------------------------------------\n\nTITLE: Basic HTTP Client Example in C++\nDESCRIPTION: Shows a simple HTTP client that makes a GET request and handles the response. The example demonstrates error handling and status code checking.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_28\n\nLANGUAGE: c++\nCODE:\n```\n#include <httplib.h>\n#include <iostream>\n\nint main(void)\n{\n  httplib::Client cli(\"localhost\", 1234);\n\n  if (auto res = cli.Get(\"/hi\")) {\n    if (res->status == StatusCode::OK_200) {\n      std::cout << res->body << std::endl;\n    }\n  } else {\n    auto err = res.error();\n    std::cout << \"HTTP error: \" << httplib::to_string(err) << std::endl;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Compression in C++ HTTP Client\nDESCRIPTION: Shows how to handle compression in the HTTP client, including setting the Accept-Encoding header, compressing request bodies, and handling compressed responses. The example demonstrates default behavior and how to customize compression settings.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_52\n\nLANGUAGE: cpp\nCODE:\n```\nres = cli.Get(\"/resource/foo\");\nres = cli.Get(\"/resource/foo\", {{\"Accept-Encoding\", \"gzip, deflate, br\"}});\n```\n\nLANGUAGE: cpp\nCODE:\n```\nres = cli.Get(\"/resource/foo\", {{\"Accept-Encoding\", \"\"}});\n```\n\nLANGUAGE: cpp\nCODE:\n```\ncli.set_compress(true);\nres = cli.Post(\"/resource/foo\", \"...\", \"text/plain\");\n```\n\nLANGUAGE: cpp\nCODE:\n```\ncli.set_decompress(false);\nres = cli.Get(\"/resource/foo\");\nres->body; // Compressed data\n```\n\n----------------------------------------\n\nTITLE: Setting Default Headers in C++ HTTP Client\nDESCRIPTION: Demonstrates setting default headers that will be used for all requests made by the client instance.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_32\n\nLANGUAGE: c++\nCODE:\n```\ncli.set_default_headers({\n  { \"Hello\", \"World!\" }\n});\nauto res = cli.Get(\"/hi\");\n```\n\n----------------------------------------\n\nTITLE: Extended Content Reception with Response Handler in C++ HTTP Client\nDESCRIPTION: Demonstrates receiving content with both a response handler and a content receiver callback. Allows inspecting response status before receiving the content.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_42\n\nLANGUAGE: cpp\nCODE:\n```\nstd::string body;\n\nauto res = cli.Get(\n  \"/stream\", Headers(),\n  [&](const Response &response) {\n    EXPECT_EQ(StatusCode::OK_200, response.status);\n    return true; // return 'false' if you want to cancel the request.\n  },\n  [&](const char *data, size_t data_length) {\n    body.append(data, data_length);\n    return true; // return 'false' if you want to cancel the request.\n  });\n```\n\n----------------------------------------\n\nTITLE: Processing Multipart Form Data in POST Requests\nDESCRIPTION: Shows how to handle file uploads and multipart/form-data POST requests, accessing file metadata and content.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\nsvr.Post(\"/multipart\", [&](const auto& req, auto& res) {\n  auto size = req.files.size();\n  auto ret = req.has_file(\"name1\");\n  const auto& file = req.get_file_value(\"name1\");\n  // file.filename;\n  // file.content_type;\n  // file.content;\n});\n```\n\n----------------------------------------\n\nTITLE: Sending Content with Content Provider in C++ HTTP Server\nDESCRIPTION: Shows how to stream content to clients using a content provider with a specified content length. The example streams data in chunks of a predefined size and includes cleanup using a completion handler.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_15\n\nLANGUAGE: cpp\nCODE:\n```\nconst size_t DATA_CHUNK_SIZE = 4;\n\nsvr.Get(\"/stream\", [&](const Request &req, Response &res) {\n  auto data = new std::string(\"abcdefg\");\n\n  res.set_content_provider(\n    data->size(), // Content length\n    \"text/plain\", // Content type\n    [&, data](size_t offset, size_t length, DataSink &sink) {\n      const auto &d = *data;\n      sink.write(&d[offset], std::min(length, DATA_CHUNK_SIZE));\n      return true; // return 'false' if you want to cancel the process.\n    },\n    [data](bool success) { delete data; });\n});\n```\n\n----------------------------------------\n\nTITLE: Receiving Content with ContentReader in C++ HTTP Server\nDESCRIPTION: Demonstrates how to handle content receiving in a POST endpoint using a ContentReader callback. Shows handling of both multipart form data and regular request bodies by reading data chunks.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_14\n\nLANGUAGE: cpp\nCODE:\n```\nsvr.Post(\"/content_receiver\",\n  [&](const Request &req, Response &res, const ContentReader &content_reader) {\n    if (req.is_multipart_form_data()) {\n      // NOTE: `content_reader` is blocking until every form data field is read\n      MultipartFormDataItems files;\n      content_reader(\n        [&](const MultipartFormData &file) {\n          files.push_back(file);\n          return true;\n        },\n        [&](const char *data, size_t data_length) {\n          files.back().content.append(data, data_length);\n          return true;\n        });\n    } else {\n      std::string body;\n      content_reader([&](const char *data, size_t data_length) {\n        body.append(data, data_length);\n        return true;\n      });\n    }\n  });\n```\n\n----------------------------------------\n\nTITLE: Streaming Content without Known Length in C++ HTTP Server\nDESCRIPTION: Demonstrates streaming content to clients without specifying the content length in advance. Useful for dynamic content where the total size isn't known before transmission begins.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_16\n\nLANGUAGE: cpp\nCODE:\n```\nsvr.Get(\"/stream\", [&](const Request &req, Response &res) {\n  res.set_content_provider(\n    \"text/plain\", // Content type\n    [&](size_t offset, DataSink &sink) {\n      if (/* there is still data */) {\n        std::vector<char> data;\n        // prepare data...\n        sink.write(data.data(), data.size());\n      } else {\n        sink.done(); // No more data\n      }\n      return true; // return 'false' if you want to cancel the process.\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Chunked Transfer Encoding in C++ HTTP Server\nDESCRIPTION: Shows how to use chunked transfer encoding for streaming content without specifying content length. The example writes multiple chunks of data before signaling completion.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_17\n\nLANGUAGE: cpp\nCODE:\n```\nsvr.Get(\"/chunked\", [&](const Request& req, Response& res) {\n  res.set_chunked_content_provider(\n    \"text/plain\",\n    [](size_t offset, DataSink &sink) {\n      sink.write(\"123\", 3);\n      sink.write(\"345\", 3);\n      sink.write(\"789\", 3);\n      sink.done(); // No more data\n      return true; // return 'false' if you want to cancel the process.\n    }\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Chunked Transfer with Trailer Headers in C++ HTTP Server\nDESCRIPTION: Demonstrates chunked transfer encoding with trailer headers sent after the data. The example sets up trailer headers and provides values for them after sending the chunked content.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_18\n\nLANGUAGE: cpp\nCODE:\n```\nsvr.Get(\"/chunked\", [&](const Request& req, Response& res) {\n  res.set_header(\"Trailer\", \"Dummy1, Dummy2\");\n  res.set_chunked_content_provider(\n    \"text/plain\",\n    [](size_t offset, DataSink &sink) {\n      sink.write(\"123\", 3);\n      sink.write(\"345\", 3);\n      sink.write(\"789\", 3);\n      sink.done_with_trailer({\n        {\"Dummy1\", \"DummyVal1\"},\n        {\"Dummy2\", \"DummyVal2\"}\n      });\n      return true;\n    }\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Serving File Content in C++ HTTP Server\nDESCRIPTION: Shows how to serve file content in HTTP responses. The examples demonstrate both automatic content type detection and explicit content type specification.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_19\n\nLANGUAGE: cpp\nCODE:\n```\nsvr.Get(\"/content\", [&](const Request &req, Response &res) {\n  res.set_file_content(\"./path/to/content.html\");\n});\n\nsvr.Get(\"/content\", [&](const Request &req, Response &res) {\n  res.set_file_content(\"./path/to/content\", \"text/html\");\n});\n```\n\n----------------------------------------\n\nTITLE: Handling 'Expect: 100-Continue' Requests in C++ HTTP Server\nDESCRIPTION: Demonstrates custom handling of the 'Expect: 100-continue' header. Examples show how to reject requests with expectation failed status or send unauthorized responses without reading the message body.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_20\n\nLANGUAGE: cpp\nCODE:\n```\n// Send a '417 Expectation Failed' response.\nsvr.set_expect_100_continue_handler([](const Request &req, Response &res) {\n  return StatusCode::ExpectationFailed_417;\n});\n```\n\n----------------------------------------\n\nTITLE: Sending Content with Provider in C++ HTTP Client\nDESCRIPTION: Shows how to send content using a provider callback that writes data in chunks. Useful for sending large bodies without loading everything into memory.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_43\n\nLANGUAGE: cpp\nCODE:\n```\nstd::string body = ...;\n\nauto res = cli.Post(\n  \"/stream\", body.size(),\n  [](size_t offset, size_t length, DataSink &sink) {\n    sink.write(body.data() + offset, length);\n    return true; // return 'false' if you want to cancel the request.\n  },\n  \"text/plain\");\n```\n\n----------------------------------------\n\nTITLE: Handling 'Expect: 100-Continue' with Custom Status in C++ HTTP Server\nDESCRIPTION: Shows how to respond to 'Expect: 100-continue' requests with custom status codes, allowing rejection of requests without reading the message body.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_21\n\nLANGUAGE: cpp\nCODE:\n```\n// Send a final status without reading the message body.\nsvr.set_expect_100_continue_handler([](const Request &req, Response &res) {\n  return res.status = StatusCode::Unauthorized_401;\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Timeout Parameters in C++ HTTP Server\nDESCRIPTION: Demonstrates how to set various timeout parameters for the server including read timeout, write timeout, and idle interval for connections.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_23\n\nLANGUAGE: c++\nCODE:\n```\nsvr.set_read_timeout(5, 0); // 5 seconds\nsvr.set_write_timeout(5, 0); // 5 seconds\nsvr.set_idle_interval(0, 100000); // 100 milliseconds\n```\n\n----------------------------------------\n\nTITLE: Chunked Transfer Encoding in C++ HTTP Client\nDESCRIPTION: Demonstrates sending data using chunked transfer encoding. The example writes multiple chunks of data before signaling completion using the stream operator.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_44\n\nLANGUAGE: cpp\nCODE:\n```\nauto res = cli.Post(\n  \"/stream\",\n  [](size_t offset, DataSink &sink) {\n    sink.os << \"chunked data 1\";\n    sink.os << \"chunked data 2\";\n    sink.os << \"chunked data 3\";\n    sink.done();\n    return true; // return 'false' if you want to cancel the request.\n  },\n  \"text/plain\");\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Payload Length in C++ HTTP Server\nDESCRIPTION: Shows how to set the maximum allowed size for request bodies. Important for preventing denial of service attacks by limiting server resource consumption.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_24\n\nLANGUAGE: c++\nCODE:\n```\nsvr.set_payload_max_length(1024 * 1024 * 512); // 512MB\n```\n\n----------------------------------------\n\nTITLE: Implementing Progress Callback in C++ HTTP Client\nDESCRIPTION: Demonstrates how to use a progress callback function with the HTTP client to track download progress. The callback receives the current length and total size, allowing for percentage calculation and cancellation of the request.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_45\n\nLANGUAGE: cpp\nCODE:\n```\nhttplib::Client cli(url, port);\n\n// prints: 0 / 000 bytes => 50% complete\nauto res = cli.Get(\"/\", [](uint64_t len, uint64_t total) {\n  printf(\"%lld / %lld bytes => %d%% complete\\n\",\n    len, total,\n    (int)(len*100/total));\n  return true; // return 'false' if you want to cancel the request.\n}\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Thread Pool in C++ HTTP Server\nDESCRIPTION: Demonstrates how to override the default thread pool with a custom implementation. The example shows setting a specific thread count for handling requests.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_25\n\nLANGUAGE: cpp\nCODE:\n```\nsvr.new_task_queue = [] { return new ThreadPool(12); };\n```\n\n----------------------------------------\n\nTITLE: Configuring Thread Pool with Request Limits in C++ HTTP Server\nDESCRIPTION: Shows how to configure the thread pool with a limit on pending requests. This helps prevent resource exhaustion when the server is under heavy load.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_26\n\nLANGUAGE: cpp\nCODE:\n```\nsvr.new_task_queue = [] { return new ThreadPool(/*num_threads=*/12, /*max_queued_requests=*/18); };\n```\n\n----------------------------------------\n\nTITLE: Client Connection Options in C++ HTTP Client\nDESCRIPTION: Shows different ways to initialize an HTTP client with various formats of host, port, and scheme specifications.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_29\n\nLANGUAGE: c++\nCODE:\n```\nhttplib::Client cli(\"localhost\");\nhttplib::Client cli(\"localhost:8080\");\nhttplib::Client cli(\"http://localhost\");\nhttplib::Client cli(\"http://localhost:8080\");\nhttplib::Client cli(\"https://localhost\");\nhttplib::SSLClient cli(\"localhost\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Thread Pool in C++ HTTP Server\nDESCRIPTION: Demonstrates how to implement a custom thread pool task queue for the server. Shows the required interface implementation with enqueue and shutdown methods.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_27\n\nLANGUAGE: cpp\nCODE:\n```\nclass YourThreadPoolTaskQueue : public TaskQueue {\npublic:\n  YourThreadPoolTaskQueue(size_t n) {\n    pool_.start_with_thread_count(n);\n  }\n\n  virtual bool enqueue(std::function<void()> fn) override {\n    /* Return true if the task was actually enqueued, or false\n     * if the caller must drop the corresponding connection. */\n    return pool_.enqueue(fn);\n  }\n\n  virtual void shutdown() override {\n    pool_.shutdown_gracefully();\n  }\n\nprivate:\n  YourThreadPool pool_;\n};\n\nsvr.new_task_queue = [] {\n  return new YourThreadPoolTaskQueue(12);\n};\n```\n\n----------------------------------------\n\nTITLE: HTTP POST Requests in C++ HTTP Client\nDESCRIPTION: Shows how to make POST requests with different content types. Examples include plain text and form-urlencoded data.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_33\n\nLANGUAGE: c++\nCODE:\n```\nres = cli.Post(\"/post\", \"text\", \"text/plain\");\nres = cli.Post(\"/person\", \"name=john1&note=coder\", \"application/x-www-form-urlencoded\");\n```\n\n----------------------------------------\n\nTITLE: Alternative Parameter Specification for HTTP POST in C++ HTTP Client\nDESCRIPTION: Shows an inline method for specifying parameters when making a POST request.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_35\n\nLANGUAGE: c++\nCODE:\n```\nhttplib::Params params{\n  { \"name\", \"john\" },\n  { \"note\", \"coder\" }\n};\n\nauto res = cli.Post(\"/post\", params);\n```\n\n----------------------------------------\n\nTITLE: HTTP DELETE Method in C++ HTTP Client\nDESCRIPTION: Demonstrates how to make DELETE requests to remove resources from the server.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_38\n\nLANGUAGE: c++\nCODE:\n```\nres = cli.Delete(\"/resource/foo\");\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom File Request Handler\nDESCRIPTION: Shows how to set up a custom handler that is called before file responses are sent to clients, allowing for response modification.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n// The handler is called right before the response is sent to a client\nsvr.set_file_request_handler([](const Request &req, Response &res) {\n  ...\n});\n```\n\n----------------------------------------\n\nTITLE: HTTP OPTIONS Method in C++ HTTP Client\nDESCRIPTION: Shows how to make OPTIONS requests to query the server about available communication options.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_39\n\nLANGUAGE: c++\nCODE:\n```\nres = cli.Options(\"*\");\nres = cli.Options(\"/resource/foo\");\n```\n\n----------------------------------------\n\nTITLE: Setting Up Proxy Support in C++ HTTP Client\nDESCRIPTION: Demonstrates how to configure proxy settings for the HTTP client, including setting the proxy host and port, as well as authentication methods for the proxy. OpenSSL is required for Digest Authentication.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_47\n\nLANGUAGE: cpp\nCODE:\n```\ncli.set_proxy(\"host\", port);\n\n// Basic Authentication\ncli.set_proxy_basic_auth(\"user\", \"pass\");\n\n// Digest Authentication\ncli.set_proxy_digest_auth(\"user\", \"pass\");\n\n// Bearer Token Authentication\ncli.set_proxy_bearer_token_auth(\"pass\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Range Requests in C++ HTTP Client\nDESCRIPTION: Shows how to make range requests using the HTTP client, allowing for partial content retrieval. The example demonstrates creating range headers for different byte ranges and checking the response status and body.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_48\n\nLANGUAGE: cpp\nCODE:\n```\nhttplib::Client cli(\"httpbin.org\");\n\nauto res = cli.Get(\"/range/32\", {\n  httplib::make_range_header({{1, 10}}) // 'Range: bytes=1-10'\n});\n// res->status should be 206.\n// res->body should be \"bcdefghijk\".\n```\n\nLANGUAGE: cpp\nCODE:\n```\nhttplib::make_range_header({{1, 10}, {20, -1}})      // 'Range: bytes=1-10, 20-'\nhttplib::make_range_header({{100, 199}, {500, 599}}) // 'Range: bytes=100-199, 500-599'\nhttplib::make_range_header({{0, 0}, {-1, 1}})        // 'Range: bytes=0-0, -1'\n```\n\n----------------------------------------\n\nTITLE: Managing Keep-Alive Connections in C++ HTTP Client\nDESCRIPTION: Demonstrates how to control keep-alive connections in the HTTP client. The example shows how to enable and disable keep-alive, affecting the 'Connection' header in subsequent requests.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_49\n\nLANGUAGE: cpp\nCODE:\n```\nhttplib::Client cli(\"localhost\", 1234);\n\ncli.Get(\"/hello\");         // with \"Connection: close\"\n\ncli.set_keep_alive(true);\ncli.Get(\"/world\");\n\ncli.set_keep_alive(false);\ncli.Get(\"/last-request\");  // with \"Connection: close\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Keep-Alive Connections in C++ HTTP Server\nDESCRIPTION: Shows how to configure keep-alive connection parameters for a server. Controls the maximum number of requests per connection and the timeout for idle connections.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_22\n\nLANGUAGE: cpp\nCODE:\n```\nsvr.set_keep_alive_max_count(2); // Default is 5\nsvr.set_keep_alive_timeout(10);  // Default is 5\n```\n\n----------------------------------------\n\nTITLE: Implementing Unix Domain Socket Support in C++ HTTP Server/Client\nDESCRIPTION: Demonstrates how to use Unix Domain Sockets with the HTTP server and client on Linux and macOS. The example shows setting up the server to listen on a socket file and configuring the client to connect to it.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_53\n\nLANGUAGE: cpp\nCODE:\n```\n// Server\nhttplib::Server svr;\nsvr.set_address_family(AF_UNIX).listen(\"./my-socket.sock\", 80);\n\n// Client\nhttplib::Client cli(\"./my-socket.sock\");\ncli.set_address_family(AF_UNIX);\n```\n\n----------------------------------------\n\nTITLE: Setting Custom MIME Type Mappings for File Extensions\nDESCRIPTION: Shows how to define custom file extension to MIME type mappings for the static file server.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n// User defined file extension and MIME type mappings\nsvr.set_file_extension_and_mimetype_mapping(\"cc\", \"text/x-c\");\nsvr.set_file_extension_and_mimetype_mapping(\"cpp\", \"text/x-c\");\nsvr.set_file_extension_and_mimetype_mapping(\"hh\", \"text/x-h\");\n```\n\n----------------------------------------\n\nTITLE: Adding Request and Response Logging\nDESCRIPTION: Demonstrates how to implement a custom logger for HTTP requests and responses.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nsvr.set_logger([](const auto& req, const auto& res) {\n  your_logger(req, res);\n});\n```\n\n----------------------------------------\n\nTITLE: Binding Server to Multiple Interfaces and Dynamic Port\nDESCRIPTION: Shows how to bind a server to multiple network interfaces and any available port, useful for dynamic port allocation.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nint port = svr.bind_to_any_port(\"0.0.0.0\");\nsvr.listen_after_bind();\n```\n\n----------------------------------------\n\nTITLE: Setting Up Custom Error Handling\nDESCRIPTION: Shows how to implement a custom error handler to format error responses.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nsvr.set_error_handler([](const auto& req, auto& res) {\n  auto fmt = \"<p>Error Status: <span style='color:red;'>%d</span></p>\";\n  char buf[BUFSIZ];\n  snprintf(buf, sizeof(buf), fmt, res.status);\n  res.set_content(buf, \"text/html\");\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Exception Handling in Request Routes\nDESCRIPTION: Shows how to catch and handle exceptions thrown by request handlers to prevent server crashes.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\nsvr.set_exception_handler([](const auto& req, auto& res, std::exception_ptr ep) {\n  auto fmt = \"<h1>Error 500</h1><p>%s</p>\";\n  char buf[BUFSIZ];\n  try {\n    std::rethrow_exception(ep);\n  } catch (std::exception &e) {\n    snprintf(buf, sizeof(buf), fmt, e.what());\n  } catch (...) { // See the following NOTE\n    snprintf(buf, sizeof(buf), fmt, \"Unknown Exception\");\n  }\n  res.set_content(buf, \"text/html\");\n  res.status = StatusCode::InternalServerError_500;\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Up Pre-Routing Request Handlers\nDESCRIPTION: Shows how to implement handlers that run before the regular routing system, allowing for early response or request modification.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\nsvr.set_pre_routing_handler([](const auto& req, auto& res) {\n  if (req.path == \"/hello\") {\n    res.set_content(\"world\", \"text/html\");\n    return Server::HandlerResponse::Handled;\n  }\n  return Server::HandlerResponse::Unhandled;\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Post-Routing Response Modification\nDESCRIPTION: Demonstrates how to modify responses after they've been generated by route handlers but before they're sent to clients.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\nsvr.set_post_routing_handler([](const auto& req, auto& res) {\n  res.set_header(\"ADDITIONAL_HEADER\", \"value\");\n});\n```\n\n----------------------------------------\n\nTITLE: Alternative HTTP Header Specification in C++ HTTP Client\nDESCRIPTION: Shows an inline method for specifying HTTP headers when making a request.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_31\n\nLANGUAGE: c++\nCODE:\n```\nauto res = cli.Get(\"/hi\", {{\"Hello\", \"World!\"}})\n```\n\n----------------------------------------\n\nTITLE: Specifying Network Interface in C++ HTTP Client\nDESCRIPTION: Demonstrates how to set a specific network interface for the HTTP client. This feature allows binding to a particular interface by name, IP address, or hostname. Note that this feature is not available on Windows.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_51\n\nLANGUAGE: cpp\nCODE:\n```\ncli.set_interface(\"eth0\"); // Interface name, IP address or host name\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building CPP-HTTPLIB with CMake\nDESCRIPTION: This CMake configuration script sets up the build environment for cpp-httplib. It extracts the version from the header file, configures build options, finds dependencies, and prepares for installation. The script supports both header-only and compiled library modes.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14.0 FATAL_ERROR)\n\n# Get the CPPHTTPLIB_VERSION value and use it as a version\n# This gets the string with the CPPHTTPLIB_VERSION value from the header.\n# This is so the maintainer doesn't actually need to update this manually.\nfile(STRINGS httplib.h _raw_version_string REGEX \"CPPHTTPLIB_VERSION \\\"([0-9]+\\\\.[0-9]+\\\\.[0-9]+)\\\"\")\n\n# Extracts just the version string itself from the whole string contained in _raw_version_string\n# since _raw_version_string would contain the entire line of code where it found the version string\nstring(REGEX MATCH \"([0-9]+\\\\.?)+\" _httplib_version \"${_raw_version_string}\")\n\nproject(httplib\n\tVERSION ${_httplib_version}\n\tLANGUAGES CXX\n\tDESCRIPTION \"A C++ header-only HTTP/HTTPS server and client library.\"\n\tHOMEPAGE_URL \"https://github.com/yhirose/cpp-httplib\"\n)\n\n# Change as needed to set an OpenSSL minimum version.\n# This is used in the installed Cmake config file.\nset(_HTTPLIB_OPENSSL_MIN_VER \"3.0.0\")\n\n# Lets you disable C++ exception during CMake configure time.\n# The value is used in the install CMake config file.\noption(HTTPLIB_NO_EXCEPTIONS \"Disable the use of C++ exceptions\" OFF)\n# Allow for a build to require OpenSSL to pass, instead of just being optional\noption(HTTPLIB_REQUIRE_OPENSSL \"Requires OpenSSL to be found & linked, or fails build.\" OFF)\noption(HTTPLIB_REQUIRE_ZLIB \"Requires ZLIB to be found & linked, or fails build.\" OFF)\n# Allow for a build to casually enable OpenSSL/ZLIB support, but silently continue if not found.\n# Make these options so their automatic use can be specifically disabled (as needed)\noption(HTTPLIB_USE_OPENSSL_IF_AVAILABLE \"Uses OpenSSL (if available) to enable HTTPS support.\" ON)\noption(HTTPLIB_USE_ZLIB_IF_AVAILABLE \"Uses ZLIB (if available) to enable Zlib compression support.\" ON)\n# Lets you compile the program as a regular library instead of header-only\noption(HTTPLIB_COMPILE \"If ON, uses a Python script to split the header into a compilable header & source file (requires Python v3).\" OFF)\n# Lets you disable the installation (useful when fetched from another CMake project)\noption(HTTPLIB_INSTALL \"Enables the installation target\" ON)\noption(HTTPLIB_TEST \"Enables testing and builds tests\" OFF)\noption(HTTPLIB_REQUIRE_BROTLI \"Requires Brotli to be found & linked, or fails build.\" OFF)\noption(HTTPLIB_USE_BROTLI_IF_AVAILABLE \"Uses Brotli (if available) to enable Brotli decompression support.\" ON)\noption(HTTPLIB_USE_CERTS_FROM_MACOSX_KEYCHAIN \"Enable feature to load system certs from the Apple Keychain.\" ON)\noption(HTTPLIB_REQUIRE_ZSTD \"Requires ZSTD to be found & linked, or fails build.\" OFF)\noption(HTTPLIB_USE_ZSTD_IF_AVAILABLE \"Uses ZSTD (if available) to enable zstd support.\" ON)\n# Defaults to static library\noption(BUILD_SHARED_LIBS \"Build the library as a shared library instead of static. Has no effect if using header-only.\" OFF)\nif (BUILD_SHARED_LIBS AND WIN32 AND HTTPLIB_COMPILE)\n\t# Necessary for Windows if building shared libs\n\t# See https://stackoverflow.com/a/40743080\n\tset(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON)\nendif()\n\n# Set some variables that are used in-tree and while building based on our options\nset(HTTPLIB_IS_COMPILED ${HTTPLIB_COMPILE})\nset(HTTPLIB_IS_USING_CERTS_FROM_MACOSX_KEYCHAIN ${HTTPLIB_USE_CERTS_FROM_MACOSX_KEYCHAIN})\n\n# Threads needed for <thread> on some systems, and for <pthread.h> on Linux\nset(THREADS_PREFER_PTHREAD_FLAG TRUE)\nfind_package(Threads REQUIRED)\n# Since Cmake v3.11, Crypto & SSL became optional when not specified as COMPONENTS.\nif(HTTPLIB_REQUIRE_OPENSSL)\n\tfind_package(OpenSSL ${_HTTPLIB_OPENSSL_MIN_VER} COMPONENTS Crypto SSL REQUIRED)\n\tset(HTTPLIB_IS_USING_OPENSSL TRUE)\nelseif(HTTPLIB_USE_OPENSSL_IF_AVAILABLE)\n\tfind_package(OpenSSL ${_HTTPLIB_OPENSSL_MIN_VER} COMPONENTS Crypto SSL QUIET)\n\t# Avoid a rare circumstance of not finding all components but the end-user did their\n\t# own call for OpenSSL, which might trick us into thinking we'd otherwise have what we wanted\n\tif (TARGET OpenSSL::SSL AND TARGET OpenSSL::Crypto)\n\t\tset(HTTPLIB_IS_USING_OPENSSL ${OPENSSL_FOUND})\n\telse()\n\t\tset(HTTPLIB_IS_USING_OPENSSL FALSE)\n\tendif()\nendif()\n\nif(HTTPLIB_REQUIRE_ZLIB)\n\tfind_package(ZLIB REQUIRED)\n\tset(HTTPLIB_IS_USING_ZLIB TRUE)\nelseif(HTTPLIB_USE_ZLIB_IF_AVAILABLE)\n\tfind_package(ZLIB QUIET)\n\t# FindZLIB doesn't have a ZLIB_FOUND variable, so check the target.\n\tif(TARGET ZLIB::ZLIB)\n\t\tset(HTTPLIB_IS_USING_ZLIB TRUE)\n\tendif()\nendif()\n\n# Adds our cmake folder to the search path for find_package\n# This is so we can use our custom FindBrotli.cmake\nlist(APPEND CMAKE_MODULE_PATH \"${CMAKE_CURRENT_SOURCE_DIR}/cmake\")\nif(HTTPLIB_REQUIRE_BROTLI)\n\tfind_package(Brotli COMPONENTS encoder decoder common REQUIRED)\n\tset(HTTPLIB_IS_USING_BROTLI TRUE)\nelseif(HTTPLIB_USE_BROTLI_IF_AVAILABLE)\n\tfind_package(Brotli COMPONENTS encoder decoder common QUIET)\n\tset(HTTPLIB_IS_USING_BROTLI ${Brotli_FOUND})\nendif()\n\nif(HTTPLIB_REQUIRE_ZSTD)\n\tfind_package(zstd)\n\tif(NOT zstd_FOUND)\n\t\tfind_package(PkgConfig REQUIRED)\n\t\tpkg_check_modules(zstd REQUIRED IMPORTED_TARGET libzstd)\n\t\tadd_library(zstd::libzstd ALIAS PkgConfig::zstd)\n\tendif()\n\tset(HTTPLIB_IS_USING_ZSTD TRUE)\nelseif(HTTPLIB_USE_ZSTD_IF_AVAILABLE)\n\tfind_package(zstd QUIET)\n\tif(NOT zstd_FOUND)\n\t\tfind_package(PkgConfig QUIET)\n\t\tif(PKG_CONFIG_FOUND)\n\t\t\tpkg_check_modules(zstd QUIET IMPORTED_TARGET libzstd)\n\n\t\t\tif(TARGET PkgConfig::zstd)\n\t\t\t\tadd_library(zstd::libzstd ALIAS PkgConfig::zstd)\n\t\t\tendif()\n\t\tendif()\n\tendif()\n\t# Both find_package and PkgConf set a XXX_FOUND var\n\tset(HTTPLIB_IS_USING_ZSTD ${zstd_FOUND})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring cpp-httplib Build Options in CMake\nDESCRIPTION: Sets up build options for cpp-httplib, including compilation mode, installation paths, and dependency management. It handles file splitting for compiled mode and sets up target properties.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(GNUInstallDirs)\n\nif(HTTPLIB_COMPILE)\n\tconfigure_file(split.py \"${CMAKE_CURRENT_BINARY_DIR}/split.py\"\n\t\tCOPYONLY\n\t)\n\tconfigure_file(httplib.h \"${CMAKE_CURRENT_BINARY_DIR}/httplib.h\"\n\t\tCOPYONLY\n\t)\n\n\tset(_INTERFACE_OR_PUBLIC PUBLIC)\n\tfind_package(Python3 REQUIRED)\n\texecute_process(COMMAND ${Python3_EXECUTABLE} \"${CMAKE_CURRENT_BINARY_DIR}/split.py\"\n\t\tWORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}\n\t\tERROR_VARIABLE _httplib_split_error\n\t)\n\tif(_httplib_split_error)\n\t\tmessage(FATAL_ERROR \"Failed when trying to split cpp-httplib with the Python script.\\n${_httplib_split_error}\")\n\tendif()\n\n\tset(_httplib_build_includedir \"${CMAKE_CURRENT_BINARY_DIR}/out\")\n\tadd_library(${PROJECT_NAME} \"${_httplib_build_includedir}/httplib.cc\")\n\ttarget_sources(${PROJECT_NAME}\n\t\tPUBLIC\n\t\t\t$<BUILD_INTERFACE:${_httplib_build_includedir}/httplib.h>\n\t\t\t$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}/httplib.h>\n\t)\n\tset_target_properties(${PROJECT_NAME}\n\t\tPROPERTIES\n\t\t\tVERSION ${${PROJECT_NAME}_VERSION}\n\t\t\tSOVERSION \"${${PROJECT_NAME}_VERSION_MAJOR}.${${PROJECT_NAME}_VERSION_MINOR}\"\n\t\t\tOUTPUT_NAME cpp-httplib\n\t)\nelse()\n\tset(_INTERFACE_OR_PUBLIC INTERFACE)\n\tadd_library(${PROJECT_NAME} INTERFACE)\n\tset(_httplib_build_includedir \"${CMAKE_CURRENT_SOURCE_DIR}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting up cpp-httplib Target Properties and Dependencies in CMake\nDESCRIPTION: Configures the cpp-httplib target with include directories, compiler features, and links necessary libraries. It also sets up compile definitions for optional features based on build options.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(${PROJECT_NAME}::${PROJECT_NAME} ALIAS ${PROJECT_NAME})\n\ntarget_compile_features(${PROJECT_NAME} ${_INTERFACE_OR_PUBLIC} cxx_std_11)\n\ntarget_include_directories(${PROJECT_NAME} SYSTEM ${_INTERFACE_OR_PUBLIC}\n    $<BUILD_INTERFACE:${_httplib_build_includedir}>\n    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\n)\n\ntarget_link_libraries(${PROJECT_NAME} ${_INTERFACE_OR_PUBLIC}\n\t\tThreads::Threads\n\t\t$<$<PLATFORM_ID:Windows>:ws2_32>\n\t\t$<$<PLATFORM_ID:Windows>:crypt32>\n\t\t\"$<$<AND:$<PLATFORM_ID:Darwin>,$<BOOL:${HTTPLIB_IS_USING_OPENSSL}>,$<BOOL:${HTTPLIB_USE_CERTS_FROM_MACOSX_KEYCHAIN}>>:-framework CoreFoundation -framework Security>\"\n\t\t$<$<BOOL:${HTTPLIB_IS_USING_BROTLI}>:Brotli::common>\n\t\t$<$<BOOL:${HTTPLIB_IS_USING_BROTLI}>:Brotli::encoder>\n\t\t$<$<BOOL:${HTTPLIB_IS_USING_BROTLI}>:Brotli::decoder>\n\t\t$<$<BOOL:${HTTPLIB_IS_USING_ZLIB}>:ZLIB::ZLIB>\n\t\t$<$<BOOL:${HTTPLIB_IS_USING_ZSTD}>:zstd::libzstd>\n\t\t$<$<BOOL:${HTTPLIB_IS_USING_OPENSSL}>:OpenSSL::SSL>\n\t\t$<$<BOOL:${HTTPLIB_IS_USING_OPENSSL}>:OpenSSL::Crypto>\n)\n\ntarget_compile_definitions(${PROJECT_NAME} ${_INTERFACE_OR_PUBLIC}\n\t$<$<BOOL:${HTTPLIB_NO_EXCEPTIONS}>:CPPHTTPLIB_NO_EXCEPTIONS>\n\t$<$<BOOL:${HTTPLIB_IS_USING_BROTLI}>:CPPHTTPLIB_BROTLI_SUPPORT>\n\t$<$<BOOL:${HTTPLIB_IS_USING_ZLIB}>:CPPHTTPLIB_ZLIB_SUPPORT>\n\t$<$<BOOL:${HTTPLIB_IS_USING_ZSTD}>:CPPHTTPLIB_ZSTD_SUPPORT>\n\t$<$<BOOL:${HTTPLIB_IS_USING_OPENSSL}>:CPPHTTPLIB_OPENSSL_SUPPORT>\n\t$<$<AND:$<PLATFORM_ID:Darwin>,$<BOOL:${HTTPLIB_IS_USING_OPENSSL}>,$<BOOL:${HTTPLIB_IS_USING_CERTS_FROM_MACOSX_KEYCHAIN}>>:CPPHTTPLIB_USE_CERTS_FROM_MACOSX_KEYCHAIN>\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring cpp-httplib CMake Package in CMake\nDESCRIPTION: Sets up CMake package configuration files for cpp-httplib, including version file and export targets. It also handles installation of headers, documentation, and license files.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(_TARGET_INSTALL_CMAKEDIR \"${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}\")\n\ninclude(CMakePackageConfigHelpers)\n\nconfigure_package_config_file(\"cmake/${PROJECT_NAME}Config.cmake.in\"\n\t\"${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake\"\n\tINSTALL_DESTINATION \"${_TARGET_INSTALL_CMAKEDIR}\"\n\tPATH_VARS CMAKE_INSTALL_FULL_INCLUDEDIR\n)\n\nif(HTTPLIB_COMPILE)\n\twrite_basic_package_version_file(\"${PROJECT_NAME}ConfigVersion.cmake\"\n\t\tCOMPATIBILITY SameMinorVersion\n\t)\nelse()\n\twrite_basic_package_version_file(\"${PROJECT_NAME}ConfigVersion.cmake\"\n\t\tCOMPATIBILITY SameMinorVersion\n\t\tARCH_INDEPENDENT\n\t)\nendif()\n\nif(HTTPLIB_INSTALL)\n\tinstall(TARGETS ${PROJECT_NAME} EXPORT httplibTargets)\n\n\tinstall(FILES \"${_httplib_build_includedir}/httplib.h\" TYPE INCLUDE)\n\n\tinstall(FILES\n\t\t\"${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake\"\n\t\t\"${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}ConfigVersion.cmake\"\n\t\t\"${CMAKE_CURRENT_SOURCE_DIR}/cmake/FindBrotli.cmake\"\n\t\tDESTINATION ${_TARGET_INSTALL_CMAKEDIR}\n\t)\n\n\tinstall(EXPORT httplibTargets\n\t\tNAMESPACE ${PROJECT_NAME}::\n\t\tDESTINATION ${_TARGET_INSTALL_CMAKEDIR}\n\t)\n\n\tinstall(FILES \"README.md\" DESTINATION \"${CMAKE_INSTALL_DOCDIR}\")\n\tinstall(FILES \"LICENSE\" DESTINATION \"${CMAKE_INSTALL_DATADIR}/licenses/${PROJECT_NAME}\")\n\n\tinclude(CPack)\nendif()\n\nif(HTTPLIB_TEST)\n    include(CTest)\n    add_subdirectory(test)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Running Docker Container for Static HTTP Server\nDESCRIPTION: Provides instructions for building and running a Docker container that serves as a static HTTP server using cpp-httplib. The server listens on port 80 and serves files from the /html directory in the container.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/README.md#2025-04-21_snippet_54\n\nLANGUAGE: bash\nCODE:\n```\n> docker build -t cpp-httplib-server .\n...\n\n> docker run --rm -it -p 8080:80 -v ./docker/html:/html cpp-httplib-server\nServing HTTP on 0.0.0.0 port 80 ...\n192.168.65.1 - - [31/Aug/2024:21:33:56 +0000] \"GET / HTTP/1.1\" 200 599 \"-\" \"curl/8.7.1\"\n192.168.65.1 - - [31/Aug/2024:21:34:26 +0000] \"GET / HTTP/1.1\" 200 599 \"-\" \"Mozilla/5.0 ...\"\n192.168.65.1 - - [31/Aug/2024:21:34:26 +0000] \"GET /favicon.ico HTTP/1.1\" 404 152 \"-\" \"Mozilla/5.0 ...\"\n```\n\nLANGUAGE: bash\nCODE:\n```\n> docker run --rm -it -p 8080:80 -v ./docker/html:/html yhirose4dockerhub/cpp-httplib-server\nServing HTTP on 0.0.0.0 port 80 ...\n192.168.65.1 - - [31/Aug/2024:21:33:56 +0000] \"GET / HTTP/1.1\" 200 599 \"-\" \"curl/8.7.1\"\n192.168.65.1 - - [31/Aug/2024:21:34:26 +0000] \"GET / HTTP/1.1\" 200 599 \"-\" \"Mozilla/5.0 ...\"\n192.168.65.1 - - [31/Aug/2024:21:34:26 +0000] \"GET /favicon.ico HTTP/1.1\" 404 152 \"-\" \"Mozilla/5.0 ...\"\n```\n\n----------------------------------------\n\nTITLE: Configuring cpp-httplib Fuzzing Test Build\nDESCRIPTION: Creates and configures a fuzzing test executable for cpp-httplib. It collects corpus files, sets up the test executable with necessary source files, links against the httplib library, and creates a test target.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/test/fuzzing/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nfile(GLOB HTTPLIB_CORPUS corpus/*)\nadd_executable(httplib-test-fuzz\n    server_fuzzer.cc\n    standalone_fuzz_target_runner.cpp\n)\ntarget_link_libraries(httplib-test-fuzz PRIVATE httplib)\nadd_test(\n    NAME httplib-test-fuzz\n    COMMAND httplib-test-fuzz ${HTTPLIB_CORPUS}\n)\n```\n\n----------------------------------------\n\nTITLE: gtest.h Macro Definitions\nDESCRIPTION: Core customization macros for Google Test including stack trace getter implementation and temporary directory function override.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/test/gtest/include/gtest/internal/custom/README.md#2025-04-21_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nGTEST_OS_STACK_TRACE_GETTER_\nGTEST_CUSTOM_TEMPDIR_FUNCTION_\n```\n\n----------------------------------------\n\nTITLE: gtest-port.h Logging Macros\nDESCRIPTION: Logging-related macros and functions for customizing test output behavior.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/test/gtest/include/gtest/internal/custom/README.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nGTEST_LOG_(severity)\nGTEST_CHECK_(condition)\n```\n\n----------------------------------------\n\nTITLE: gtest-port.h Threading Macros\nDESCRIPTION: Threading-related macros for mutex, thread local storage, and lock management customization.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/test/gtest/include/gtest/internal/custom/README.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nGTEST_HAS_NOTIFICATION_\nGTEST_HAS_MUTEX_AND_THREAD_LOCAL_\nGTEST_EXCLUSIVE_LOCK_REQUIRED_(locks)\nGTEST_LOCK_EXCLUDED_(locks)\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Options for cpp-httplib using Meson\nDESCRIPTION: This snippet defines Meson build options for cpp-httplib. It includes toggles for various features like OpenSSL, zlib, and Brotli support, as well as compilation and testing options. Each option is defined with a type, default value, and description.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/meson_options.txt#2025-04-21_snippet_0\n\nLANGUAGE: meson\nCODE:\n```\noption('cpp-httplib_openssl', type: 'feature', value: 'auto', description: 'Enable OpenSSL support')\noption('cpp-httplib_zlib',    type: 'feature', value: 'auto', description: 'Enable zlib support')\noption('cpp-httplib_brotli',  type: 'feature', value: 'auto', description: 'Enable Brotli support')\noption('cpp-httplib_macosx_keychain', type: 'feature', value: 'auto', description: 'Enable loading certs from the Keychain on Apple devices')\noption('cpp-httplib_compile', type: 'boolean', value: false,  description: 'Split the header into a compilable header & source file (requires python3)')\noption('cpp-httplib_test',    type: 'boolean', value: false,  description: 'Build tests')\n```\n\n----------------------------------------\n\nTITLE: gtest-port.h Library Support Macros\nDESCRIPTION: Macros for configuring underlying library support features and API symbol exports.\nSOURCE: https://github.com/yhirose/cpp-httplib/blob/master/test/gtest/include/gtest/internal/custom/README.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nGTEST_HAS_CXXABI_H_\nGTEST_API_\n```"
  }
]