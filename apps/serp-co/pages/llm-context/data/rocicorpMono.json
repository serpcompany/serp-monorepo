[
  {
    "owner": "rocicorp",
    "repo": "mono",
    "content": "TITLE: TypeScript Interface for Push Request\nDESCRIPTION: Definition of the PushRequest and Mutation types that form the body of push requests. Contains client information, mutations to be applied, and schema version data.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/reference/server-push.md#2025-04-10_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\ntype PushRequest = {\n  pushVersion: 1;\n  clientGroupID: string;\n  mutations: Mutation[];\n  profileID: string;\n  schemaVersion: string;\n};\n\ntype Mutation = {\n  clientID: string;\n  id: number;\n  name: string;\n  args: ReadonlyJSONValue;\n  timestamp: number;\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Replicache Subscription in React\nDESCRIPTION: Demonstrates how to use Replicache subscriptions in a React component to automatically refresh UI when data changes. The subscription scans todos with a prefix and renders them in a list.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/concepts/how-it-works.md#2025-04-10_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst todos = useSubscribe(rep, async tx => {\n  return await tx.scan({prefix: 'todo/'}).toArray();\n});\nreturn (\n  <ul>\n    {todos.map(todo => (\n      <li key={todo.id}>{todo.text}</li>\n    ))}\n  </ul>\n);\n```\n\n----------------------------------------\n\nTITLE: TypeScript Definition of Replicache PullRequest\nDESCRIPTION: TypeScript type definition for the PullRequest object, which is sent as the JSON-encoded body of the HTTP request when pulling data.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/reference/server-pull.md#2025-04-10_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ntype PullRequest = {\n  pullVersion: 1;\n  clientGroupID: string;\n  cookie: JSONValue;\n  profileID: string;\n  schemaVersion: string;\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a React Chat UI with Replicache\nDESCRIPTION: Creates a React component that renders a chat UI using Replicache for data management. The component uses the useSubscribe hook to reactively display messages from the local database and includes a form for message submission. It also demonstrates proper lifecycle management for Replicache instances.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/byob/render-ui.md#2025-04-10_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport React, {useEffect, useRef, useState} from 'react';\nimport ReactDOM from 'react-dom/client';\nimport {Replicache, TEST_LICENSE_KEY, WriteTransaction} from 'replicache';\nimport {Message, MessageWithID} from 'shared';\nimport {useSubscribe} from 'replicache-react';\nimport Pusher from 'pusher-js';\nimport {nanoid} from 'nanoid';\n\nasync function init() {\n  const licenseKey =\n    import.meta.env.VITE_REPLICACHE_LICENSE_KEY || TEST_LICENSE_KEY;\n  if (!licenseKey) {\n    throw new Error('Missing VITE_REPLICACHE_LICENSE_KEY');\n  }\n\n  function Root() {\n    const [r, setR] = useState<Replicache<any> | null>(null);\n\n    useEffect(() => {\n      console.log('updating replicache');\n      const r = new Replicache({\n        name: 'chat-user-id',\n        licenseKey,\n        pushURL: `/api/replicache/push`,\n        pullURL: `/api/replicache/pull`,\n        logLevel: 'debug',\n      });\n      setR(r);\n      listen(r);\n      return () => {\n        void r.close();\n      };\n    }, []);\n\n    const messages = useSubscribe(\n      r,\n      async tx => {\n        const list = await tx\n          .scan<Message>({prefix: 'message/'})\n          .entries()\n          .toArray();\n        list.sort(([, {order: a}], [, {order: b}]) => a - b);\n        return list;\n      },\n      {default: []},\n    );\n\n    const usernameRef = useRef<HTMLInputElement>(null);\n    const contentRef = useRef<HTMLInputElement>(null);\n\n    const onSubmit = async (e: React.FormEvent<HTMLFormElement>) => {\n      e.preventDefault();\n      // TODO: Create Message\n    };\n\n    return (\n      <div>\n        <form onSubmit={onSubmit}>\n          <input ref={usernameRef} required /> says:\n          <input ref={contentRef} required /> <input type=\"submit\" />\n        </form>\n        {messages.map(([k, v]) => (\n          <div key={k}>\n            <b>{v.from}: </b>\n            {v.content}\n          </div>\n        ))}\n      </div>\n    );\n  }\n\n  ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(\n    <React.StrictMode>\n      <Root />\n    </React.StrictMode>,\n  );\n}\n\nfunction listen(rep: Replicache) {\n  // TODO: Listen for changes on server\n}\n\nawait init();\n```\n\n----------------------------------------\n\nTITLE: TypeScript Definition of Replicache PatchOperation\nDESCRIPTION: TypeScript type definition for the PatchOperation, which supports put, del, and clear operations for updating the client's data store.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/reference/server-pull.md#2025-04-10_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ntype PatchOperation =\n  | {\n      op: 'put';\n      key: string;\n      value: JSONValue;\n    }\n  | {op: 'del'; key: string}\n  | {op: 'clear'};\n```\n\n----------------------------------------\n\nTITLE: Initializing In-Memory Postgres Database with Snapshot Isolation for Replicache\nDESCRIPTION: Implementation of a database utility module using pg-mem (in-memory Postgres) with transaction support configured for snapshot isolation (repeatable read). The code provides functions to initialize the database, retrieve a database connection, and execute transactions with proper isolation level.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/byob/database-setup.md#2025-04-10_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\nimport {newDb} from 'pg-mem';\nimport pgp, {IDatabase, ITask} from 'pg-promise';\n\nconst {isolationLevel} = pgp.txMode;\n\nexport const serverID = 1;\n\nasync function initDB() {\n  console.log('initializing database...');\n  const db = newDb().adapters.createPgPromise();\n  return db;\n}\n\nfunction getDB() {\n  // Cache the database in the Node global so that it survives HMR.\n  if (!global.__db) {\n    global.__db = initDB();\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  return global.__db as IDatabase<{}>;\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type Transaction = ITask<{}>;\ntype TransactionCallback<R> = (t: Transaction) => Promise<R>;\n\n// In Postgres, snapshot isolation is known as \"repeatable read\".\nexport async function tx<R>(f: TransactionCallback<R>, dbp = getDB()) {\n  const db = await dbp;\n  return await db.tx(\n    {\n      mode: new pgp.txMode.TransactionMode({\n        tiLevel: isolationLevel.repeatableRead,\n      }),\n    },\n    f,\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Replicache for Unit Tests - JavaScript\nDESCRIPTION: Example configuration showing key settings for unit testing with Replicache, including disabling sync, using in-memory storage, and setting up test license keys.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/howto/unit-test.md#2025-04-10_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst rep = new Replicache({\n  name: 'test-' + Math.random(), // Random name for isolation\n  licenseKey: TEST_LICENSE_KEY,\n  pullURL: undefined, // Disable sync\n  pushURL: undefined,\n  pushDelay: 1000000, // Long delay to prevent auto-push\n  pullInterval: 1000000, // Long interval between pulls\n  kvStore: 'mem' // Use in-memory storage\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Pull Handler in TypeScript with Express and Replicache\nDESCRIPTION: Implementation of a pull endpoint that handles data synchronization between client and server. The code manages database transactions, version tracking, and builds response patches based on client requests. It includes functionality for handling last mutation IDs and managing deleted records.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/byob/dynamic-pull.md#2025-04-10_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {serverID, tx, type Transaction} from './db';\nimport type {PatchOperation, PullResponse} from 'replicache';\nimport type {Request, Response, NextFunction} from 'express';\n\nexport async function handlePull(\n  req: Request,\n  res: Response,\n  next: NextFunction,\n): Promise<void> {\n  try {\n    const resp = await pull(req, res);\n    res.json(resp);\n  } catch (e) {\n    next(e);\n  }\n}\n\nasync function pull(req: Request, res: Response) {\n  const pull = req.body;\n  console.log(`Processing pull`, JSON.stringify(pull));\n  const {clientGroupID} = pull;\n  const fromVersion = pull.cookie ?? 0;\n  const t0 = Date.now();\n\n  try {\n    // Read all data in a single transaction so it's consistent.\n    await tx(async t => {\n      // Get current version.\n      const {version: currentVersion} = await t.one<{version: number}>(\n        'select version from replicache_server where id = $1',\n        serverID,\n      );\n\n      if (fromVersion > currentVersion) {\n        throw new Error(\n          `fromVersion ${fromVersion} is from the future - aborting. This can happen in development if the server restarts. In that case, clear appliation data in browser and refresh.`,\n        );\n      }\n\n      // Get lmids for requesting client groups.\n      const lastMutationIDChanges = await getLastMutationIDChanges(\n        t,\n        clientGroupID,\n        fromVersion,\n      );\n\n      // Get changed domain objects since requested version.\n      const changed = await t.manyOrNone<{\n        id: string;\n        sender: string;\n        content: string;\n        ord: number;\n        version: number;\n        deleted: boolean;\n      }>(\n        'select id, sender, content, ord, version, deleted from message where version > $1',\n        fromVersion,\n      );\n\n      // Build and return response.\n      const patch: PatchOperation[] = [];\n      for (const row of changed) {\n        const {id, sender, content, ord, version: rowVersion, deleted} = row;\n        if (deleted) {\n          if (rowVersion > fromVersion) {\n            patch.push({\n              op: 'del',\n              key: `message/${id}`,\n            });\n          }\n        } else {\n          patch.push({\n            op: 'put',\n            key: `message/${id}`,\n            value: {\n              from: sender,\n              content,\n              order: ord,\n            },\n          });\n        }\n      }\n\n      const body: PullResponse = {\n        lastMutationIDChanges: lastMutationIDChanges ?? {},\n        cookie: currentVersion,\n        patch,\n      };\n      res.json(body);\n      res.end();\n    });\n  } catch (e) {\n    console.error(e);\n    res.status(500).send(e);\n  } finally {\n    console.log('Processed pull in', Date.now() - t0);\n  }\n}\n\nasync function getLastMutationIDChanges(\n  t: Transaction,\n  clientGroupID: string,\n  fromVersion: number,\n) {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  const rows = await t.manyOrNone<{id: string; last_mutation_id: number}>(\n    `select id, last_mutation_id\n    from replicache_client\n    where client_group_id = $1 and version > $2`,\n    [clientGroupID, fromVersion],\n  );\n  return Object.fromEntries(rows.map(r => [r.id, r.last_mutation_id]));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Blob Synchronization with Error Handling\nDESCRIPTION: Subscribes to blob changes and synchronizes them between local cache and remote storage. Handles both upload and download scenarios with proper error handling and state management.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/howto/blobs.md#2025-04-10_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nrep.subscribe(tx => tx.scan({prefix: blobPrefix}).entries().toArray(), {\n  async onData(blobs: [string, {shouldUpload: boolean}][]) {\n    const cache = await caches.open(cacheName);\n    for (const [key, value] of blobs) {\n      const hash = key.slice(blobPrefix.length);\n      const {shouldUpload} = value;\n      await syncBlob(rep, cache, hash, shouldUpload);\n    }\n  },\n});\n\nasync function syncBlob(rep, cache, hash, shouldUpload) {\n  const response = await cache.match(blobURL(hash));\n  if (response) {\n    if (shouldUpload) {\n      const buffer = await response.arrayBuffer();\n      await uploadBlob(rep, new Uint8Array(buffer), hash);\n    }\n  } else {\n    const resp = await downloadBlob(hash);\n    if (resp.ok) {\n      await cache.put(blobURL(hash), resp);\n      if (shouldUpload) {\n        // Mark as uploaded, so we don't try to upload it again.\n        await rep.mutate.addBlob({hash, shouldUpload: false});\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Push Handler in TypeScript with Express\nDESCRIPTION: Main implementation of the push endpoint handling logic including mutation processing, version control, and client state management. Includes error handling and transaction management for atomic updates.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/byob/remote-mutations.md#2025-04-10_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {serverID, tx, type Transaction} from './db';\nimport type {MessageWithID} from 'shared';\nimport type {MutationV1, PushRequestV1} from 'replicache';\nimport type {Request, Response, NextFunction} from 'express';\n\nexport async function handlePush(\n  req: Request,\n  res: Response,\n  next: NextFunction,\n): Promise<void> {\n  try {\n    await push(req, res);\n  } catch (e) {\n    next(e);\n  }\n}\n\nasync function push(req: Request, res: Response) {\n  const push: PushRequestV1 = req.body;\n  console.log('Processing push', JSON.stringify(push));\n\n  const t0 = Date.now();\n  try {\n    // Iterate each mutation in the push.\n    for (const mutation of push.mutations) {\n      const t1 = Date.now();\n\n      try {\n        await tx(t => processMutation(t, push.clientGroupID, mutation));\n      } catch (e) {\n        console.error('Caught error from mutation', mutation, e);\n\n        // Handle errors inside mutations by skipping and moving on. This is\n        // convenient in development but you may want to reconsider as your app\n        // gets close to production:\n        // https://doc.replicache.dev/reference/server-push#error-handling\n        await tx(t =>\n          processMutation(t, push.clientGroupID, mutation, e as string),\n        );\n      }\n\n      console.log('Processed mutation in', Date.now() - t1);\n    }\n\n    res.send('{}');\n\n    await sendPoke();\n  } catch (e) {\n    console.error(e);\n    res.status(500).send(e);\n  } finally {\n    console.log('Processed push in', Date.now() - t0);\n  }\n}\n\nasync function processMutation(\n  t: Transaction,\n  clientGroupID: string,\n  mutation: MutationV1,\n  error?: string | undefined,\n) {\n  const {clientID} = mutation;\n\n  // Get the previous version and calculate the next one.\n  const {version: prevVersion} = await t.one(\n    'select version from replicache_server where id = $1 for update',\n    serverID,\n  );\n  const nextVersion = prevVersion + 1;\n\n  const lastMutationID = await getLastMutationID(t, clientID);\n  const nextMutationID = lastMutationID + 1;\n\n  console.log('nextVersion', nextVersion, 'nextMutationID', nextMutationID);\n\n  // It's common due to connectivity issues for clients to send a\n  // mutation which has already been processed. Skip these.\n  if (mutation.id < nextMutationID) {\n    console.log(\n      `Mutation ${mutation.id} has already been processed - skipping`,\n    );\n    return;\n  }\n\n  // If the Replicache client is working correctly, this can never\n  // happen. If it does there is nothing to do but return an error to\n  // client and report a bug to Replicache.\n  if (mutation.id > nextMutationID) {\n    throw new Error(\n      `Mutation ${mutation.id} is from the future - aborting. This can happen in development if the server restarts. In that case, clear appliation data in browser and refresh.`,\n    );\n  }\n\n  if (error === undefined) {\n    console.log('Processing mutation:', JSON.stringify(mutation));\n\n    // For each possible mutation, run the server-side logic to apply the\n    // mutation.\n    switch (mutation.name) {\n      case 'createMessage':\n        await createMessage(t, mutation.args as MessageWithID, nextVersion);\n        break;\n      default:\n        throw new Error(`Unknown mutation: ${mutation.name}`);\n    }\n  } else {\n    // TODO: You can store state here in the database to return to clients to\n    // provide additional info about errors.\n    console.log(\n      'Handling error from mutation',\n      JSON.stringify(mutation),\n      error,\n    );\n  }\n\n  console.log('setting', clientID, 'last_mutation_id to', nextMutationID);\n  // Update lastMutationID for requesting client.\n  await setLastMutationID(\n    t,\n    clientID,\n    clientGroupID,\n    nextMutationID,\n    nextVersion,\n  );\n\n  // Update global version.\n  await t.none('update replicache_server set version = $1 where id = $2', [\n    nextVersion,\n    serverID,\n  ]);\n}\n\nexport async function getLastMutationID(t: Transaction, clientID: string) {\n  const clientRow = await t.oneOrNone(\n    'select last_mutation_id from replicache_client where id = $1',\n    clientID,\n  );\n  if (!clientRow) {\n    return 0;\n  }\n  return parseInt(clientRow.last_mutation_id);\n}\n\nasync function setLastMutationID(\n  t: Transaction,\n  clientID: string,\n  clientGroupID: string,\n  mutationID: number,\n  version: number,\n) {\n  const result = await t.result(\n    `update replicache_client set\n      client_group_id = $2,\n      last_mutation_id = $3,\n      version = $4\n    where id = $1`,\n    [clientID, clientGroupID, mutationID, version],\n  );\n  if (result.rowCount === 0) {\n    await t.none(\n      `insert into replicache_client (\n        id,\n        client_group_id,\n        last_mutation_id,\n        version\n      ) values ($1, $2, $3, $4)`,\n      [clientID, clientGroupID, mutationID, version],\n    );\n  }\n}\n\nasync function createMessage(\n  t: Transaction,\n  {id, from, content, order}: MessageWithID,\n  version: number,\n) {\n  await t.none(\n    `insert into message (\n    id, sender, content, ord, deleted, version) values\n    ($1, $2, $3, $4, false, $5)`,\n    [id, from, content, order, version],\n  );\n}\n\nasync function sendPoke() {\n  // TODO\n}\n```\n\n----------------------------------------\n\nTITLE: Base64 Encoding User Data with Pictures in Replicache\nDESCRIPTION: Demonstrates how to store and retrieve user profile data including binary picture data using base64 encoding. Shows basic implementation of mutators and query functions.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/howto/blobs.md#2025-04-10_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// npm install base64-arraybuffer\nimport * as base64 from 'base64-arraybuffer';\n\ntype User = {\n  id: string;\n  name: string;\n  picture: Uint8Array;\n};\n\ntype RepUser = {\n  id: string;\n  name: string;\n  // Note how Replicache needs to use a string here!\n  picture: string;\n};\n\nconst rep = new Replicache({\n  name: 'user-id',\n  licenseKey: '...',\n  mutators: {\n    async setUserData(tx: WriteTransaction, user: RepUser) {\n      await tx.set(`user/${user.id}`, user);\n    },\n  },\n});\n\nasync function setUserData(rep: Replicache, user: User) {\n  const {id, name, picture} = user;\n  const repUser = {\n    id,\n    name,\n    picture: base64.encode(picture.buffer),\n  };\n  await rep.mutate.setUserData(repUser);\n}\n\nasync function getUserData(rep: Replicache, id: string): Promise<User> {\n  const repUser = await rep.query(tx => tx.get(`user/${id}`));\n  const {id, name, picture} = repUser;\n  return {\n    id,\n    name,\n    picture: new Uint8Array(base64.decode(picture)),\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Mutators with Replicache in TypeScript\nDESCRIPTION: Demonstrates how to register mutator functions with a Replicache instance. Two mutators are defined: 'createTodo' for adding new todo items and 'markTodoComplete' for updating the completion status of existing todos.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/concepts/how-it-works.md#2025-04-10_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst rep = new Replicache({\n  ...\n  mutators: {\n    createTodo,\n    markTodoComplete,\n  },\n});\n\nasync function createTodo(tx: WriteTransaction, todo: Todo) {\n  await tx.set(`/todo/${todo.id}`, todo);\n}\n\nasync function markTodoComplete(tx: WriteTransaction,\n    {id, complete}: {id: string, complete: boolean}) {\n  const key = `/todo/${id}`;\n  const todo = await tx.get(key);\n  if (!todo) {\n    return;\n  }\n  todo.complete = complete;\n  await tx.set(key, todo);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Pull Operation in JSON\nDESCRIPTION: JSON snippets for handling the pull operation, including default CVR structure, client group object, and pull response format. These structures are used to manage and diff client views during synchronization.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/strategies/row-version.md#2025-04-10_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": \"\",\n  \"entries\": {}\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": \"body.clientGroupID\",\n  \"userID\": \"userID\",\n  \"cvrVersion\": 0\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"cookie\": \"prevCookie\",\n  \"lastMutationIDChanges\": {},\n  \"patch\": []\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": \"clientGroup.id\",\n  \"userID\": \"clientGroup.userID\",\n  \"cvrVersion\": \"nextCVRVersion\"\n}\n```\n\n----------------------------------------\n\nTITLE: Invoking Mutators to Change the Client View in TypeScript\nDESCRIPTION: Shows how to call registered mutators to modify data in the Client View. The example demonstrates creating a new todo and marking an existing todo as complete, which triggers UI updates for any dependent components.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/concepts/how-it-works.md#2025-04-10_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nawait rep.mutate.createTodo({id: nanoid(), text: \"take out the trash\"});\n...\nawait rep.mutate.markTodoComplete({id: \"t1\", complete: true});\n```\n\n----------------------------------------\n\nTITLE: Implementing Push Operation in JSON\nDESCRIPTION: JSON snippets showing the structure of client group and client objects during the push operation. These objects are used to track changes and maintain consistency in the Replicache system.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/strategies/row-version.md#2025-04-10_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": \"body.clientGroupID\",\n  \"userID\": \"userID\",\n  \"cvrVersion\": 0\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": \"mutation.clientID\",\n  \"clientGroupID\": \"body.clientGroupID\",\n  \"lastMutationID\": 0\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": \"body.clientGroupID\",\n  \"userID\": \"userID\",\n  \"cvrVersion\": \"clientGroup.cvrVersion\"\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": \"mutation.clientID\",\n  \"clientGroupID\": \"body.clientGroupID\",\n  \"lastMutationID\": \"nextMutationID\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Pull Handler in TypeScript\nDESCRIPTION: Express handler implementation for the Replicache pull endpoint that serves the client view data as a patch operation.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/byob/design-client-view.md#2025-04-10_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type {Request, Response, NextFunction} from 'express';\n\nexport async function handlePull(\n  _req: Request,\n  res: Response,\n  next: NextFunction,\n): Promise<void> {\n  try {\n    res.json({\n      // We will discuss these two fields in later steps.\n      lastMutationIDChanges: {},\n      cookie: 42,\n      patch: [\n        {op: 'clear'},\n        {\n          op: 'put',\n          key: 'message/qpdgkvpb9ao',\n          value: {\n            from: 'Jane',\n            content: \"Hey, what's for lunch?\",\n            order: 1,\n          },\n        },\n        {\n          op: 'put',\n          key: 'message/5ahljadc408',\n          value: {\n            from: 'Fred',\n            content: 'tacos?',\n            order: 2,\n          },\n        },\n      ],\n    });\n  } catch (e) {\n    next(e);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Undoable Todo Creation\nDESCRIPTION: Example of wrapping a todo creation mutation with undo functionality using undoManager.add()\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/howto/undo.md#2025-04-10_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n  // new item with undo\n  const handleNewItem = (text: string) => {\n    const id = nanoid();\n    undoManager.add({\n      execute: () => {\n        rep.mutate.putTodo({\n          id,\n          text: text,\n          sort: todos.length > 0 ? todos[todos.length - 1].sort + 1 : 0,\n          completed: false,\n        });\n      };,\n      undo: () => rep.mutate.deleteTodos([id]),\n    });\n  };\n```\n\n----------------------------------------\n\nTITLE: Periodic Blob Synchronization Implementation\nDESCRIPTION: Sets up periodic blob synchronization with an interval of 5 minutes. Includes subscription to blob changes and regular polling mechanism to handle network failures.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/howto/blobs.md#2025-04-10_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst blobsTx = (tx: ReadTransaction) =>\n  tx.scan({prefix: blobPrefix}).entries().toArray();\n\nasync function syncAllBlobs(blobs: [string, {shouldUpload: boolean}][]) {\n  const cache = await caches.open(cacheName);\n  for (const [key, value] of blobs) {\n    const hash = key.slice(blobPrefix.length);\n    const {shouldUpload} = value;\n    await syncBlob(rep, cache, hash, shouldUpload);\n  }\n}\n\nrep.subscribe(blobsTx, {\n  onData: syncAllBlobs,\n});\n\nsetInterval(\n  async () => {\n    const blobs = await rep.query(blobsTx);\n    await syncAllBlobs(blobs);\n  },\n  5 * 60 * 1000,\n);\n```\n\n----------------------------------------\n\nTITLE: Using TEST_LICENSE_KEY for Unit Testing Replicache\nDESCRIPTION: Code example demonstrating how to use the special TEST_LICENSE_KEY constant in automated tests to prevent license pings and usage charges. Note that instances created with this key will shut down after a few minutes.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/concepts/licensing.md#2025-04-10_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Replicache, TEST_LICENSE_KEY} from 'replicache';\n...\n\ntest('my test', () => {\n\tconst r = new Replicache({\n\t\tlicenseKey: TEST_LICENSE_KEY,\n\t\t...\n\t});\n  ...\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing PostgreSQL Database Schema for Replicache Backend in TypeScript\nDESCRIPTION: Creates the necessary database tables for a Replicache backend implementation using the Global Version strategy. Sets up tables for global version tracking (replicache_server), message storage with versioning, and client state management (replicache_client). Each table includes Replicache-specific fields for version control and soft deletion support.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/byob/database-schema.md#2025-04-10_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nasync function initDB() {\n  console.log('initializing database...');\n  const db = newDb().adapters.createPgPromise();\n  await tx(async t => {\n    // A single global version number for the entire database.\n    await t.none(\n      `create table replicache_server (id integer primary key not null, version integer)`,\n    );\n    await t.none(\n      `insert into replicache_server (id, version) values ($1, 1)`,\n      serverID,\n    );\n\n    // Stores chat messages.\n    await t.none(`create table message (\n        id text primary key not null,\n        sender varchar(255) not null,\n        content text not null,\n        ord integer not null,\n        deleted boolean not null,\n        version integer not null)`);\n\n    // Stores last mutationID processed for each Replicache client.\n    await t.none(`create table replicache_client (\n        id varchar(36) primary key not null,\n        client_group_id varchar(36) not null,\n        last_mutation_id integer not null,\n        version integer not null)`);\n\n    // TODO: indexes\n  }, db);\n  return db;\n}\n```\n\n----------------------------------------\n\nTITLE: Default Client Configuration JSON\nDESCRIPTION: Defines the default configuration for new client initialization with version tracking.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/strategies/global-version.md#2025-04-10_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": \"mutation.clientID\",\n  \"clientGroupID\": \"body.clientGroupID\",\n  \"lastMutationID\": 0,\n  \"lastModifiedVersion\": \"lastModifiedVersion\"\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Replicache Instance with Name and License Key in JavaScript\nDESCRIPTION: This code snippet demonstrates how to construct a Replicache instance. It requires a 'name' parameter (typically the user's ID) for storage isolation and a 'licenseKey' for authentication. The example uses a tutorial license key, but recommends obtaining a personal key for actual development.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/tutorial/constructing-replicache.md#2025-04-10_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nnew Replicache({\n  name: 'user-id',\n  licenseKey: 'TUTORIAL_LICENSE_KEY'\n});\n```\n\n----------------------------------------\n\nTITLE: Writing Updated ReplicacheClient in Push Endpoint\nDESCRIPTION: JSON structure used to update the ReplicacheClient record after processing a mutation. Updates the lastMutationID to track the latest processed mutation.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/strategies/reset.md#2025-04-10_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  id: mutation.clientID,\n  clientGroupID: body.clientGroupID,\n  lastMutationID: nextMutationID,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Client-Side Pusher Listener\nDESCRIPTION: Client-side implementation of the listen function that subscribes to Pusher events and triggers Replicache pull operations when pokes are received.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/byob/poke.md#2025-04-10_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction listen(rep: Replicache) {\n  console.log('listening');\n  // Listen for pokes, and pull whenever we get one.\n  Pusher.logToConsole = true;\n  if (\n    !import.meta.env.VITE_PUBLIC_REPLICHAT_PUSHER_KEY ||\n    !import.meta.env.VITE_PUBLIC_REPLICHAT_PUSHER_CLUSTER\n  ) {\n    throw new Error('Missing PUSHER_KEY or PUSHER_CLUSTER in env');\n  }\n  const pusher = new Pusher(import.meta.env.VITE_PUBLIC_REPLICHAT_PUSHER_KEY, {\n    cluster: import.meta.env.VITE_PUBLIC_REPLICHAT_PUSHER_CLUSTER,\n  });\n  const channel = pusher.subscribe('default');\n  channel.bind('poke', async () => {\n    console.log('got poked');\n    await rep.pull();\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Soft Delete Schema\nDESCRIPTION: Demonstrates an alternative approach to implementing soft deletes using separate collections.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/strategies/global-version.md#2025-04-10_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ntype Monster = {\n  replicacheVersion: number;\n};\n\ntype MonsterDeleted = {\n  replicacheVersion: number;\n};\n```\n\n----------------------------------------\n\nTITLE: Complete Replicache Undo Implementation Example\nDESCRIPTION: Full example showing how to implement undo functionality in a Replicache React component, including imports, state management, and event handling\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/howto/undo.md#2025-04-10_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Replicache } from \"replicache\";\nimport { useSubscribe } from \"replicache-react\";\n...\nimport { UndoManager } from \"@rocicorp/undo\";\nimport { HotKeys } from \"react-hotkeys\";\n\n// Replicache and UndoManager are initialized outside of the initial component render.\n// undoManager = new UndoManager()\nconst App = ({ rep }: { rep: Replicache<M>; undoManager: UndoManager }) => {\n  const todos = useSubscribe(rep, listTodos, [], [rep]);\n\n  // new item with undo\n  const handleNewItem = (text: string) => {\n      const id = nanoid();\n      undoManager.add({\n        execute: () => {\n          rep.mutate.putTodo({\n            id,\n            text: text,\n            sort: todos.length > 0 ? todos[todos.length - 1].sort + 1 : 0,\n            completed: false,\n          });\n        };,\n        undo: () => rep.mutate.deleteTodos([id]),\n      });\n    };\n  };\n\n  const handlers = {\n    undo: () => undoManager.undo(),\n    redo: () => undoManager.redo(),\n  };\n\n  const keyMap = {\n    undo: [\"ctrl+z\", \"command+z\"],\n    redo: [\"ctrl+y\", \"command+shift+z\", \"ctrl+shift+z\"],\n  };\n\n  return (\n    <Hotkeys\n      {...{\n        keyMap,\n        handlers,\n      }}\n    >\n        <Header onNewItem={handleNewItem} />\n        <MainSection todos={todos} />\n    </Hotkeys>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: ReplicacheSpace JSON Structure for Per-Space Version Strategy\nDESCRIPTION: JSON object showing the structure for updating a ReplicacheSpace record during push operations. It includes the client group ID, space ID from the request parameters, and incremented version number.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/strategies/per-space-version.md#2025-04-10_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  id: body.clientGroupID,\n  spaceID: request.params.spaceID,\n  version: nextVersion,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing onSubmit for Message Creation in Replicache\nDESCRIPTION: This code implements the onSubmit function that invokes the createMessage mutator when a user submits a message. It calculates the order of the new message based on the last message, collects the username and content from form inputs, and generates a unique ID for the message using nanoid.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/byob/local-mutations.md#2025-04-10_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n    const onSubmit = async (e: React.FormEvent<HTMLFormElement>) => {\n      e.preventDefault();\n      let last: Message | null = null;\n      if (messages.length) {\n        const lastMessageTuple = messages[messages.length - 1];\n        last = lastMessageTuple[1];\n      }\n      const order = (last?.order ?? 0) + 1;\n      const username = usernameRef.current?.value ?? '';\n      const content = contentRef.current?.value ?? '';\n\n      await r?.mutate.createMessage({\n        id: nanoid(),\n        from: username,\n        content,\n        order,\n      });\n\n      if (contentRef.current) {\n        contentRef.current.value = '';\n      }\n    };\n```\n\n----------------------------------------\n\nTITLE: Default ReplicacheClientGroup JSON Structure for Pull Operations\nDESCRIPTION: JSON object representing the default structure of a ReplicacheClientGroup record when not found in the database during pull operations. It includes the client group ID and user ID.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/strategies/per-space-version.md#2025-04-10_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  id: body.clientGroupID,\n  userID\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Replicache with Sync URLs in JavaScript\nDESCRIPTION: This code snippet shows how to initialize Replicache with push and pull URLs for syncing. It also includes the creation of a new space for data storage.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/tutorial/sync.md#2025-04-10_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst space = await initSpace();\nconst rep = new Replicache({\n  name: 'sync-13',\n  licenseKey: 'license_key_here',\n  pushURL: `https://replicache-sample-todo.vercel.app/api/replicache-push?spaceID=${space}`,\n  pullURL: `https://replicache-sample-todo.vercel.app/api/replicache-pull?spaceID=${space}`,\n});\n```\n\n----------------------------------------\n\nTITLE: Default ReplicacheClientGroup JSON Structure\nDESCRIPTION: JSON structure for creating a new ReplicacheClientGroup when one doesn't exist in the database. It includes the client group ID from the request and the user ID from authentication.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/strategies/reset.md#2025-04-10_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  id: body.clientGroupID,\n  userID\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Replicache Client Instance\nDESCRIPTION: Creates a new Replicache client instance with a unique user ID. The name parameter ensures separate caches for different users within the same browser profile.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/concepts/how-it-works.md#2025-04-10_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {Replicache} from \"replicache\";\n\nconst rep = new Replicache({\n  name: userID,\n  ...\n});\n\nconsole.log(rep.clientID);\n```\n\n----------------------------------------\n\nTITLE: Default ReplicacheClient JSON Structure for Per-Space Version Strategy\nDESCRIPTION: JSON object representing the default structure of a ReplicacheClient record when not found in the database during push operations. It includes client ID, client group ID, lastMutationID, and lastModifiedVersion.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/strategies/per-space-version.md#2025-04-10_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  id: mutation.clientID,\n  clientGroupID: body.clientGroupID,\n  lastMutationID: 0,\n  lastModifiedVersion\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Replicache Schema for Per-Space Version Strategy in TypeScript\nDESCRIPTION: TypeScript definitions for the database schema needed to implement the Per-Space Version Strategy in Replicache. It includes types for ReplicacheSpace, ReplicacheClientGroup, ReplicacheClient, and a sample Todo entity with space-specific fields.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/strategies/per-space-version.md#2025-04-10_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype ReplicacheSpace = {\n  id: string;\n\n  // Same as Global Version Strategy.\n  version: number;\n};\n\ntype ReplicacheClientGroup = {\n  // Same as Global Version Strategy.\n  id: string;\n  userID: any;\n\n  spaceID: string;\n};\n\ntype ReplicacheClient = {\n  // Same as Global Version Strategy.\n  id: string;\n  clientGroupID: string;\n  lastMutationID: number;\n  lastModifiedVersion: number;\n};\n\n// Each of your domain entities will have three additional fields.\ntype Todo = {\n  // ... fields needed for your application (id, title, complete, etc)\n\n  // Same as Global Version Strategy.\n  lastModifiedVersion: number;\n  deleted: boolean;\n\n  spaceID: string;\n};\n```\n\n----------------------------------------\n\nTITLE: Default ReplicacheClient JSON Structure\nDESCRIPTION: JSON structure for creating a new ReplicacheClient when one doesn't exist in the database. Includes the client ID, client group ID, and initializes lastMutationID to 0.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/strategies/reset.md#2025-04-10_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  id: mutation.clientID,\n  clientGroupID: body.clientGroupID,\n  lastMutationID: 0,\n}\n```\n\n----------------------------------------\n\nTITLE: Schema Definition in TypeScript\nDESCRIPTION: Defines the core data structures needed for the global version strategy, including ReplicacheSpace for version tracking, ReplicacheClientGroup for user management, ReplicacheClient for client state, and Todo for domain entities.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/strategies/global-version.md#2025-04-10_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype ReplicacheSpace = {\n  version: number;\n};\n\ntype ReplicacheClientGroup = {\n  id: string;\n  userID: any;\n};\n\ntype ReplicacheClient = {\n  id: string;\n  clientGroupID: string;\n  lastMutationID: number;\n  lastModifiedVersion: number;\n};\n\ntype Todo = {\n  lastModifiedVersion: number;\n  deleted: boolean;\n};\n```\n\n----------------------------------------\n\nTITLE: HTTP POST Method for Push Endpoint\nDESCRIPTION: HTTP method used by Replicache for sending push requests to the server. Replicache always uses a POST method to submit mutation data.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/reference/server-push.md#2025-04-10_snippet_1\n\nLANGUAGE: http\nCODE:\n```\nPOST /replicache-push HTTP/2\n```\n\n----------------------------------------\n\nTITLE: TypeScript Definitions for Replicache PullResponse\nDESCRIPTION: TypeScript type definitions for the PullResponse, including PullResponseOK, ClientStateNotFoundResponse, and VersionNotSupportedResponse.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/reference/server-pull.md#2025-04-10_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport type PullResponse =\n  | PullResponseOK\n  | ClientStateNotFoundResponse\n  | VersionNotSupportedResponse;\n\nexport type PullResponseOK = {\n  cookie: Cookie;\n  lastMutationIDChanges: Record<ClientID, number>;\n  patch: PatchOperation[];\n};\n\nexport type Cookie =\n  | null\n  | string\n  | number\n  | (ReadonlyJSONValue & {readonly order: number | string});\n\nexport type ClientStateNotFoundResponse = {\n  error: 'ClientStateNotFound';\n};\n\nexport type VersionNotSupportedResponse = {\n  error: 'VersionNotSupported';\n  versionType?: 'pull' | 'push' | 'schema' | undefined;\n};\n```\n\n----------------------------------------\n\nTITLE: HTTP POST Request for Replicache Pull Endpoint\nDESCRIPTION: Example of the HTTP POST request format used by Replicache to fetch data from the pull endpoint.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/reference/server-pull.md#2025-04-10_snippet_1\n\nLANGUAGE: http\nCODE:\n```\nPOST /replicache-pull HTTP/2\n```\n\n----------------------------------------\n\nTITLE: Defining Client View Record Type in TypeScript\nDESCRIPTION: TypeScript interface for a Client View Record (CVR), representing a snapshot of a Client View at a particular moment in time. It includes client IDs, last mutation IDs, and entity versions.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/strategies/row-version.md#2025-04-10_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype CVR = {\n  id: string;\n  // Map of clientID->lastMutationID pairs, one for each client in the\n  // client group.\n  lastMutationIDs: Record<string, number>;\n  // Map of key->version pairs, one for each entity in the client view.\n  entities: Record<string, number>;\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Replicache Push URL in JavaScript\nDESCRIPTION: Example of how to specify the Push URL when creating a new Replicache instance. The pushURL option indicates where mutation batches should be sent.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/reference/server-push.md#2025-04-10_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst rep = new Replicache({\n  // ...\n  pushURL: '/replicache-push',\n});\n```\n\n----------------------------------------\n\nTITLE: Internal Representation of Mutations in JavaScript\nDESCRIPTION: Illustrates how Replicache internally tracks mutations as records of mutator calls with specific arguments. Each mutation has a sequential ID, mutator name, and the arguments passed to the mutator.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/concepts/how-it-works.md#2025-04-10_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n[\n  {id: 1, name: \"createTodo\", args: {id: \"t1\", text: \"take out the trash\"}},\n  {id: 2, name: \"markTodoComplete\", args: {id: \"t1\", complete: true}},\n]\n```\n\n----------------------------------------\n\nTITLE: Setting Up Keyboard Shortcuts for Undo/Redo\nDESCRIPTION: Implementation of keyboard shortcuts for undo/redo operations using react-hotkeys\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/howto/undo.md#2025-04-10_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n  const handlers = {\n    undo: () => undoManager.undo(),\n    redo: () => undoManager.redo(),\n  };\n\n  const keyMap = {\n    undo: [\"ctrl+z\", \"command+z\"],\n    redo: [\"ctrl+y\", \"command+shift+z\", \"ctrl+shift+z\"],\n  };\n\n  return (\n    <Hotkeys\n      {...{\n        keyMap,\n        handlers,\n      }}\n    >\n      ...\n    </HotKeys>\n```\n\n----------------------------------------\n\nTITLE: HTTP Headers for Replicache Pull Request\nDESCRIPTION: Example of the HTTP headers sent with Replicache pull requests, including Content-type, Authorization, and X-Replicache-RequestID.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/reference/server-pull.md#2025-04-10_snippet_2\n\nLANGUAGE: http\nCODE:\n```\nContent-type: application/json\nAuthorization: <auth>\nX-Replicache-RequestID: <request-id>\n```\n\n----------------------------------------\n\nTITLE: Building and Installing Zero Package Locally\nDESCRIPTION: Series of commands to clone the Rocicorp mono repository, build the project, and create a local package for development or testing purposes.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/zero/README.md#2025-04-10_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:rocicorp/mono.git\ncd mono\nnpm install\nnpm run build\ncd packages/zero\nnpm pack\n```\n\n----------------------------------------\n\nTITLE: Content-Addressed Binary Data Storage\nDESCRIPTION: Implements a content-addressed storage system using SHA-256 hashing for binary data, ideal for immutable and shared data.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/howto/blobs.md#2025-04-10_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ntype RepUser = {\n  id: string;\n  name: string;\n  picture: string;\n  pictureHash: string;\n};\n\nasync function computeHash(data: Uint8Array): Promise<string> {\n  const buf = await crypto.subtle.digest('SHA-256', data);\n  return Array.from(new Uint8Array(buf), b =>\n    b.toString(16).padStart(2, '0'),\n  ).join('');\n}\n\nconst rep = new Replicache({\n  name: 'user-id',\n  licenseKey: '...',\n  mutators: {\n    async setUserData(tx: WriteTransaction, user: RepUser) {\n      const {id, name, picture, pictureHash} = user;\n      await tx.set(`user/${id}`, {id, name, pictureHash});\n      await tx.set(`blob/${pictureHash}`, picture);\n    },\n  },\n});\n\nasync function setUserData(rep: Replicache, user: User) {\n  const {id, name, picture} = user;\n  const pictureHash = await computeHash(picture);\n  const repUser = {\n    id,\n    name,\n    picture: base64.encode(picture.buffer),\n    pictureHash,\n  };\n  await rep.mutate.setUserData(repUser);\n}\n\nasync function getUserData(rep: Replicache, id: string): Promise<User> {\n  const {name, picture} = await rep.query(async tx => {\n    const {name, pictureHash} = await tx.get(`user/${id}`);\n    const picture = await tx.get(`blob/${pictureHash}`);\n    return {name, picture};\n  });\n  return {\n    id,\n    name,\n    picture: new Uint8Array(base64.decode(picture)),\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Building the Docker Image for Zero Load Generator\nDESCRIPTION: Command to build a Docker image for the load generator tool from the repository root directory.\nSOURCE: https://github.com/rocicorp/mono/blob/main/tools/load-generator/README.md#2025-04-10_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# From the root of the repository\ndocker build -t load-generator -f tools/load-generator/Dockerfile .\n```\n\n----------------------------------------\n\nTITLE: Obtaining a Replicache License Key via npm\nDESCRIPTION: Command to get a Replicache license key using npm. This will ask a few questions and generate a unique license key for your use.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/concepts/licensing.md#2025-04-10_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx replicache@latest get-license\n```\n\n----------------------------------------\n\nTITLE: Running the Zero Load Generator with Basic Configuration\nDESCRIPTION: Docker run command with environment variables to configure and run the load generator against a PostgreSQL database. This example shows setting the target database, QPS, table name, key column, and fields to perturb.\nSOURCE: https://github.com/rocicorp/mono/blob/main/tools/load-generator/README.md#2025-04-10_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -e ZERO_UPSTREAM_DB=\"postgresql://user:password@host.docker.internal:6434/postgres\" \\\n  -e ZERO_QPS=20 \\\n  -e ZERO_PERTURB_TABLE=\"issue\" \\\n  -e ZERO_PERTURB_KEY=\"id\" \\\n  -e ZERO_PERTURB_BOOLS=\"open\" \\\n  -e ZERO_PERTURB_INTS=\"modified\" \\\n  load-generator:latest\n```\n\n----------------------------------------\n\nTITLE: Initializing Replicache with a License Key\nDESCRIPTION: JavaScript code example showing how to pass a license key to the Replicache constructor. The licenseKey parameter is required for all Replicache usage.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/concepts/licensing.md#2025-04-10_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nnew Replicache({\n\tlicenseKey: \"l123d3baa14984beca21bc42aee593064\",\n\t...\n});\n```\n\n----------------------------------------\n\nTITLE: Starting the ZBugs Web Application\nDESCRIPTION: Command to start the web application development server, which connects to the zero-cache server.\nSOURCE: https://github.com/rocicorp/mono/blob/main/apps/zbugs/README.md#2025-04-10_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Defining Replicache Schema Types in TypeScript\nDESCRIPTION: TypeScript interfaces for ReplicacheClientGroup, ReplicacheClient, and Todo entities. These types define the structure for managing client groups, individual clients, and domain entities with version tracking.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/strategies/row-version.md#2025-04-10_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype ReplicacheClientGroup = {\n  // Same as the Reset Strategy.\n  id: string;\n  userID: any;\n\n  // Replicache requires that cookies are ordered within a client group.\n  // To establish this order we simply keep a counter.\n  cvrVersion: number;\n};\n\ntype ReplicacheClient = {\n  // Same as the Reset Strategy.\n  id: string;\n  clientGroupID: string;\n  lastMutationID: number;\n};\n\n// Each of your domain entities will have one extra field.\ntype Todo = {\n  // ... fields needed for your application (id, title, complete, etc)\n\n  // Incremented each time this row is updated.\n  // In Postgres, there is no need to declare this as Postgres tracks its\n  // own per-row version 'xmin' which we can use for this purpose:\n  // https://www.postgresql.org/docs/current/ddl-system-columns.html\n  version: number;\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Server-Side Poke with Pusher\nDESCRIPTION: Server-side implementation of the sendPoke function using Pusher to trigger real-time updates. Validates environment variables and initializes Pusher client with proper configuration.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/byob/poke.md#2025-04-10_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport Pusher from 'pusher';\n//...\nasync function sendPoke() {\n  if (\n    !process.env.REPLICHAT_PUSHER_APP_ID ||\n    !process.env.REPLICHAT_PUSHER_KEY ||\n    !process.env.REPLICHAT_PUSHER_SECRET ||\n    !process.env.REPLICHAT_PUSHER_CLUSTER\n  ) {\n    throw new Error('Missing Pusher environment variables');\n  }\n  const pusher = new Pusher({\n    appId: process.env.REPLICHAT_PUSHER_APP_ID,\n    key: process.env.REPLICHAT_PUSHER_KEY,\n    secret: process.env.REPLICHAT_PUSHER_SECRET,\n    cluster: process.env.REPLICHAT_PUSHER_CLUSTER,\n    useTLS: true,\n  });\n  const t0 = Date.now();\n  await pusher.trigger('default', 'poke', {});\n  console.log('Sent poke in', Date.now() - t0);\n}\n```\n\n----------------------------------------\n\nTITLE: Storing Binary Data in Separate Keys\nDESCRIPTION: Shows how to optimize binary data storage by keeping it in separate keys to avoid unnecessary data transfer when unrelated fields change.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/howto/blobs.md#2025-04-10_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst rep = new Replicache({\n  name: 'user-id',\n  mutators: {\n    async setUserData(tx: WriteTransaction, user: RepUser) {\n      const {id, name, picture} = user;\n      await tx.set(`user/${id}`, {id, name});\n      await tx.set(`user/${id}/picture`, picture);\n    },\n  },\n});\n\nasync function getUserData(rep: Replicache, id: string): Promise<User> {\n  const {name, picture} = await rep.query(async tx => {\n    const {name} = await tx.get(`user/${id}`);\n    const picture = await tx.get(`user/${id}/picture`);\n    return {name, picture};\n  });\n  return {\n    id,\n    name,\n    picture: new Uint8Array(base64.decode(picture)),\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Local Development Environment with Source Maps\nDESCRIPTION: Commands for creating a local development setup with unminified builds and source maps for easier debugging.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache/README.md#2025-04-10_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n# in your replicache-internal dir\nnpm link\n\n# creates an unminified and unmangled build so that you can see symbols in the debugger/watches\nnpm run build -- --debug\n```\n\n----------------------------------------\n\nTITLE: Configuring Webpack for Local Debugging with Source Maps\nDESCRIPTION: JavaScript configuration for a Next.js webpack setup that enables source map loading for Replicache debugging.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache/README.md#2025-04-10_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\n// next.config.js\nmodule.exports = {\n  ...\n  webpack: (config) => {\n    config.module.rules.push({\n      test: /\\.mjs$/,\n      use: [\"source-map-loader\"],\n    });\n    return config;\n  },\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: High Load Configuration with Multiple Fields for Zero Load Generator\nDESCRIPTION: An advanced example showing how to configure the load generator for higher QPS and multiple boolean and integer fields to modify.\nSOURCE: https://github.com/rocicorp/mono/blob/main/tools/load-generator/README.md#2025-04-10_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -e ZERO_UPSTREAM_DB=\"postgresql://user:password@host.docker.internal:6434/postgres\" \\\n  -e ZERO_QPS=50 \\\n  -e ZERO_PERTURB_TABLE=\"issue\" \\\n  -e ZERO_PERTURB_KEY=\"id\" \\\n  -e ZERO_PERTURB_BOOLS=\"open,resolved\" \\\n  -e ZERO_PERTURB_INTS=\"modified,priority\" \\\n  load-generator:latest\n```\n\n----------------------------------------\n\nTITLE: ReplicacheClientGroup Update JSON Structure for Per-Space Version Strategy\nDESCRIPTION: JSON object showing the structure for updating a ReplicacheClientGroup record during push operations. It includes the client group ID, user ID, and space ID.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/strategies/per-space-version.md#2025-04-10_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  id: body.clientGroupID,\n  userID,\n  spaceId,\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Frontend Code for Large Dataset Handling\nDESCRIPTION: Diff showing code modifications to limit data loading in the frontend when working with large datasets, including adding pagination limits to queries.\nSOURCE: https://github.com/rocicorp/mono/blob/main/apps/zbugs/README.md#2025-04-10_snippet_10\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/apps/zbugs/src/pages/list/list-page.tsx b/apps/zbugs/src/pages/list/list-page.tsx\nindex 33cf7ef0b..c6955f753 100644\n--- a/apps/zbugs/src/pages/list/list-page.tsx\n+++ b/apps/zbugs/src/pages/list/list-page.tsx\n@@ -93,6 +93,8 @@ export function ListPage({onReady}: {onReady: () => void}) {\n     q = q.whereExists('labels', q => q.where('name', label));\n   }\n \n+  q = q.limit(200);\n+\n   const [issues, issuesResult] = useQuery(q);\n   if (issues.length > 0 || issuesResult.type === 'complete') {\n     onReady();\ndiff --git a/apps/zbugs/src/zero-setup.ts b/apps/zbugs/src/zero-setup.ts\nindex 020330c40..8d0223a6a 100644\n--- a/apps/zbugs/src/zero-setup.ts\n+++ b/apps/zbugs/src/zero-setup.ts\n@@ -60,7 +60,9 @@ export function preload(z: Zero<Schema>) {\n \n   const baseIssueQuery = z.query.issue\n     .related('labels')\n-    .related('viewState', q => q.where('userID', z.userID));\n+    .related('viewState', q => q.where('userID', z.userID))\n+    .orderBy('modified', 'desc')\n+    .limit(200);\n \n   const {cleanup, complete} = baseIssueQuery.preload();\n   complete.then(() => {\n```\n\n----------------------------------------\n\nTITLE: Defining ReplicacheClientGroup and ReplicacheClient Types in TypeScript\nDESCRIPTION: TypeScript definitions for the database schema required to support Replicache. Includes ReplicacheClientGroup for tracking related clients and ReplicacheClient for tracking sync state of individual clients.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/strategies/reset.md#2025-04-10_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\n// A group of related ReplicacheClients. Typically there is one per browser\n// profile.\ntype ReplicacheClientGroup = {\n  // Globally unique ID, generated by Replicache.\n  id: string;\n\n  // Optional, but required if the application is authenticated. The userID\n  // that created this ReplicacheClientGroup.\n  userID: any;\n};\n\n// An instance of the Replicache JS class that has ever synced with the server.\ntype ReplicacheClient = {\n  // Globally unique ID, generated by Replicache.\n  id: string;\n\n  // The ClientGroup this client is part of.\n  clientGroupID: string;\n\n  // Last mutation the server has processed from this client.\n  lastMutationID: number;\n};\n```\n\n----------------------------------------\n\nTITLE: Referencing PostgreSQL Repeatable Read in Markdown\nDESCRIPTION: A markdown tip block explaining that PostgreSQL's equivalent to Snapshot Isolation is called 'REPEATABLE READ'.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-doc/docs/concepts/isolation.md#2025-04-10_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n:::tip\n\nIn PostgreSQL, this isolation level is confusingly called \"[REPEATABLE READ](https://www.postgresql.org/docs/current/transaction-iso.html#XACT-REPEATABLE-READ)\".\n\n:::\n```\n\n----------------------------------------\n\nTITLE: Building and Comparing Replicache Versions for API Changes\nDESCRIPTION: Commands for building the current version of Replicache and comparing it with the previous release to identify API changes. This includes downloading the previous package, extracting it, and comparing type definition files.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache/README.md#2025-04-10_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# BUILD\ncd rocicorp/mono\nnpm run build\n\n# DOWNLOAD\ncd /tmp\nnpm pack replicache@$LAST_RELEASE_VERSION\ntar -xvf replicache-$LAST_RELEASE_VERSION.tgz\ncd -\n\n# COMPARE\ndiff -u /tmp/package/out/replicache.d.ts packages/replicache/out/replicache.d.ts | less\n# or\n# code --diff /tmp/package/out/replicache.d.ts packages/replicache/out/replicache.d.ts\n```\n\n----------------------------------------\n\nTITLE: Publishing a Canary Release\nDESCRIPTION: Command to publish a canary version of the package to npm for testing before the final release.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache/README.md#2025-04-10_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncd packages/replicache\nnpm publish --tag=canary\n```\n\n----------------------------------------\n\nTITLE: Installing Canary Version in Sample Apps\nDESCRIPTION: npm command to update sample applications to use the canary version of Replicache for testing.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache/README.md#2025-04-10_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nnpm add replicache@canary\n```\n\n----------------------------------------\n\nTITLE: Testing License Generation Feature\nDESCRIPTION: Command to test the get-license script functionality with the canary release.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache/README.md#2025-04-10_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nnpx replicache@canary get-license\n```\n\n----------------------------------------\n\nTITLE: Running Postgres Database Container with Docker Compose\nDESCRIPTION: Commands to start the upstream Postgres database using Docker Compose from the docker directory, which serves as the authoritative data source for ZBugs.\nSOURCE: https://github.com/rocicorp/mono/blob/main/apps/zbugs/README.md#2025-04-10_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd docker\ndocker compose up\n```\n\n----------------------------------------\n\nTITLE: Merging the Release to Main Branch\nDESCRIPTION: Git commands to merge the tagged release into the main branch from your primary checkout.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache/README.md#2025-04-10_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# !!! IMPORTANT !!! From your main checkout (NOT temp dir - /tmp/release)\ngit fetch -t\ngit merge replicache/v$NEW_VERSION\ngit push origin main\n```\n\n----------------------------------------\n\nTITLE: Updating Documentation Branch\nDESCRIPTION: Git commands to update the docs branch with the latest release content.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache/README.md#2025-04-10_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout docs\ngit pull\ngit reset --hard replicache/v$NEW_VERSION\ngit push origin docs\n```\n\n----------------------------------------\n\nTITLE: Tagging the Release in Git\nDESCRIPTION: Git commands to tag the release on the branch and push the tag to the remote repository.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache/README.md#2025-04-10_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# From temp dir we published from above\ngit tag replicache/v$NEW_VERSION\ngit push origin --tags\n```\n\n----------------------------------------\n\nTITLE: Cherry-picking Documentation Updates\nDESCRIPTION: Git commands for cherry-picking documentation improvements onto the docs branch without a full release.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache/README.md#2025-04-10_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout docs\ngit pull\n# The '-x' appends the hash of the original commit to the cherry-pick'd commit.\n# This makes it easier to find missing commits during releases.\ngit cherry-pick -x <hash-of-spruce-commit>\ngit push origin docs\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for ZBugs Project in Node.js\nDESCRIPTION: Command to install the required Node.js dependencies for the ZBugs project before running the application.\nSOURCE: https://github.com/rocicorp/mono/blob/main/apps/zbugs/README.md#2025-04-10_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Promoting Canary Release to Latest\nDESCRIPTION: npm command to update the dist-tag for the release, promoting it from canary to latest so it becomes the default version.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache/README.md#2025-04-10_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n# note: this will publish the release to the \"latest\" tag, which means it's what\n# people will get when they `npm install`. If this is a beta release, you should\n# use the `beta` tag but also make sure the semver has beta in it.\nnpm dist-tag add replicache@$NEW_VERSION latest\n```\n\n----------------------------------------\n\nTITLE: Publishing Private Release Version\nDESCRIPTION: Git and npm commands to publish a private, unminified version of Replicache with sourcemaps for paying customers.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache/README.md#2025-04-10_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout rocicorp-replicache\n\n# Merge new release\ngit merge replicache/v$NEW_VERSION\n\n# Verify that the only diff is the name and the sourcemap\ngit diff replicache/v$NEW_VERSION\n\ngit push origin rocicorp-replicache\n\nnpm publish\n```\n\n----------------------------------------\n\nTITLE: Viewing Git Commit History Since Last Release\nDESCRIPTION: Git command to list all commits on the main branch from the commit prior to the last tagged release to the current HEAD, which helps in reviewing changes for the release notes.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache/README.md#2025-04-10_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# List all commits on main from the commit prior to last tag (which should be\n# present on main) to HEAD.\ngit log --oneline replicache/v$LAST_RELEASE_VERSION^..HEAD\n```\n\n----------------------------------------\n\nTITLE: Setting Up Clean Checkout for Release\nDESCRIPTION: Commands to create a clean checkout of the repository for the release process, ensuring a pristine environment for building and testing.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache/README.md#2025-04-10_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nrm -rf /tmp/release\nmkdir /tmp/release\ncd /tmp/release\ngit clone --depth=1 git@github.com:rocicorp/mono.git\ncd mono\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Bumping the Package Version\nDESCRIPTION: Steps to update the version number in package.json, synchronize dependencies across the monorepo, and commit the version bump changes.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache/README.md#2025-04-10_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nvim packages/replicache/package.json\n# Must be done in root of mono checkout\nnpx syncpack fix-mismatches\nnpm install\nnpm run build\ngit commit -a -m 'chore(replicache): Bump version to v$NEW_VERSION'\n```\n\n----------------------------------------\n\nTITLE: Linking Replicache and Installing Source Map Loader\nDESCRIPTION: Commands for linking the local Replicache build to an app and installing the source-map-loader package for debugging.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache/README.md#2025-04-10_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ncd <your replicache app, like repliear or replicache-todo>\nnpm link replicache\n\nnpm install -D source-map-loader\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables for ZBugs Application\nDESCRIPTION: Sample .env file configuration for the ZBugs application, including database connection, authentication settings, and other required environment variables for both the server and client components.\nSOURCE: https://github.com/rocicorp/mono/blob/main/apps/zbugs/README.md#2025-04-10_snippet_2\n\nLANGUAGE: ini\nCODE:\n```\n#### zero.config.js Variables ####\n\n# The \"upstream\" authoritative postgres database\n# In the future we will support other types of upstreams besides PG\nZERO_UPSTREAM_DB = \"postgresql://user:password@127.0.0.1:6434/postgres\"\n\n# Where to send custom mutations\nZERO_PUSH_URL = \"http://localhost:5173/api/push\"\n\n# Place to store the SQLite data zero-cache maintains. This can be lost, but if\n# it is, zero-cache will have to re-replicate next time it starts up.\nZERO_REPLICA_FILE = \"/tmp/zbugs-sync-replica.db\"\n\nZERO_LOG_LEVEL = \"info\"\n\n# Use \"json\" for logs consumed by structured logging services.\nZERO_LOG_FORMAT = \"text\"\n\n# Public key used to verify JWTs.\n# You can create a JWK pair via `npm run create-keys`\n# in the `zbugs` directory.\n#\n# The public key goes here and in `VITE_PUBLIC_JWK`.\n# The private key goes in `PRIVATE_JWK`\nZERO_AUTH_JWK=''\n\n#### ZBugs API Server Variables ####\n\n# The client id for the GitHub OAuth app responisble for OAuth:\n# https://docs.github.com/en/apps/creating-github-apps\n# Rocicorp team, see:\n# https://docs.google.com/document/d/1aGHaB0L15SY67wkXQMsST80uHh4-IooTUVzKcUlzjdk/edit#bookmark=id.bb6lqbetv2lm\nGITHUB_CLIENT_ID = \"\"\n# The secret for the client\nGITHUB_CLIENT_SECRET = \"\"\n# See comment on `ZERO_AUTH_JWK`\nPRIVATE_JWK = \"\"\n\n\n#### Vite Variables ####\nVITE_PUBLIC_SERVER=\"http://localhost:4848\"\n# See comment on `ZERO_AUTH_JWK`\nVITE_PUBLIC_JWK=''\n\n# Discord webhook to send notifications to. Not required. Notifications won't\n# be sent if absent.\nDISCORD_WEBHOOK_URL=''\n```\n\n----------------------------------------\n\nTITLE: Starting the Zero-Cache Server\nDESCRIPTION: Command to start the zero-cache server after configuring the environment variables in the .env file.\nSOURCE: https://github.com/rocicorp/mono/blob/main/apps/zbugs/README.md#2025-04-10_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm run zero\n```\n\n----------------------------------------\n\nTITLE: Clearing the SQLite Replica Database\nDESCRIPTION: Command to remove the SQLite replica database files, which forces the zero-cache to re-replicate data from the upstream database on next startup.\nSOURCE: https://github.com/rocicorp/mono/blob/main/apps/zbugs/README.md#2025-04-10_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nrm /tmp/zbugs-sync-replica.db*\n```\n\n----------------------------------------\n\nTITLE: Removing Docker Volumes for Database Reset\nDESCRIPTION: Command to stop Docker containers and remove associated volumes, effectively clearing the upstream Postgres database.\nSOURCE: https://github.com/rocicorp/mono/blob/main/apps/zbugs/README.md#2025-04-10_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose down -v\n```\n\n----------------------------------------\n\nTITLE: Loading Large Dataset for Testing\nDESCRIPTION: Commands to download and set up a 1.5GB Rocinante dataset for testing with larger data volumes, including shutting down existing containers and pulling data from S3.\nSOURCE: https://github.com/rocicorp/mono/blob/main/apps/zbugs/README.md#2025-04-10_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncd docker\ndocker compose down -v\n```\n\n----------------------------------------\n\nTITLE: Retrieving Test Data from S3\nDESCRIPTION: Command to fetch large test dataset from S3 storage for local use.\nSOURCE: https://github.com/rocicorp/mono/blob/main/apps/zbugs/README.md#2025-04-10_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n./get-data.sh\n```\n\n----------------------------------------\n\nTITLE: Starting Docker with Large Dataset Configuration\nDESCRIPTION: Command to start Docker Compose with a specific configuration file designed for handling the 1GB dataset.\nSOURCE: https://github.com/rocicorp/mono/blob/main/apps/zbugs/README.md#2025-04-10_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose -f ./docker-compose-1gb.yml up\n```\n\n----------------------------------------\n\nTITLE: Running ZQL Analysis Scripts with npx\nDESCRIPTION: Shows the basic command syntax for executing the analyze-query and transform-query scripts. Both scripts need to be run from a folder containing the .env file for your product to access schema, permissions, and replica data.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/analyze-query/README.md#2025-04-10_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx analyze-query --query=your_query_string --schema=path_to_schema.ts\nnpx transform-query  --hash=hash --schema=path_to_schema.ts\n```\n\n----------------------------------------\n\nTITLE: Example ZQL Query Analysis Commands\nDESCRIPTION: Provides concrete examples for using the analyze-query and transform-query scripts with specific parameters. The first example analyzes a query for related comments on an issue, while the second transforms a query hash with a reference to the schema path.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/analyze-query/README.md#2025-04-10_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx analyze-query --query='issue.where(\"id\", \"=\", 1).related(\"comments\")' --schema=./shared/schema.ts\nnpm run transform-query --hash=2i81bazy03a00 --path=./shared/schema.ts\n```\n\n----------------------------------------\n\nTITLE: Converting AST to ZQL using npx\nDESCRIPTION: Basic usage example showing how to pipe an AST JSON file to the conversion tool.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/ast-to-zql/README.md#2025-04-10_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncat ast.json | npx ast-to-zql\n```\n\n----------------------------------------\n\nTITLE: Converting AST to ZQL with schema mapping\nDESCRIPTION: Advanced usage example demonstrating how to apply name mapping from a schema file during conversion.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/ast-to-zql/README.md#2025-04-10_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncat ast.json | npx ast-to-zql --schema schema.ts\n```\n\n----------------------------------------\n\nTITLE: Cloning OTEL Docker Repository\nDESCRIPTION: Command to clone the Docker-based OpenTelemetry setup repository from Grafana.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/otel/README.md#2025-04-10_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/grafana/docker-otel-lgtm\n```\n\n----------------------------------------\n\nTITLE: Changing Directory to OTEL Setup\nDESCRIPTION: Command to change the current directory to the cloned OTEL setup repository.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/otel/README.md#2025-04-10_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd docker-otel-lgtm\n```\n\n----------------------------------------\n\nTITLE: Running LGTM Script for OTEL Setup\nDESCRIPTION: Command to execute the LGTM (Loki, Grafana, Tempo, Mimir) script for setting up the OTEL environment.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/otel/README.md#2025-04-10_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./run-lgtm.sh\n```\n\n----------------------------------------\n\nTITLE: Configuring OTEL Trace Collector in .env File\nDESCRIPTION: Environment variable to be added to the .env file for specifying the OTEL trace collector endpoint.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/otel/README.md#2025-04-10_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nZERO_LOG_TRACE_COLLECTOR = \"http://localhost:4318/v1/traces\"\n```\n\n----------------------------------------\n\nTITLE: Installing Zero Package from npm\nDESCRIPTION: Command to install the Zero package from the npm registry.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/zero/README.md#2025-04-10_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @rocicorp/zero\n```\n\n----------------------------------------\n\nTITLE: Installing Local Zero Package in Another Project\nDESCRIPTION: Command to install the locally built Zero package tarball in another project. The path should point to the generated tarball file with the appropriate version number.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/zero/README.md#2025-04-10_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm install /path/to/rocicorp-zero-<VERSION>.tgz\n```\n\n----------------------------------------\n\nTITLE: Running Tests with npm for zero-cache Project\nDESCRIPTION: This command runs the test suite for the zero-cache project. It requires Docker and uses Testcontainers with PostgreSQL.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/zero-cache/README.md#2025-04-10_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run test\n```\n\n----------------------------------------\n\nTITLE: Running Playwright Tests Locally with UI Mode\nDESCRIPTION: Command for executing Playwright tests locally with the UI interface. Requires setting the ZERO_AUTH_JWK environment variable and specifies test parameters including URL and PERCENT_DIRECT.\nSOURCE: https://github.com/rocicorp/mono/blob/main/apps/zbugs/playwright/README.md#2025-04-10_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nURL=\"http://localhost:5174\" PERCENT_DIRECT=1 npx playwright test --ui\n```\n\n----------------------------------------\n\nTITLE: Basic Usage Example for Zero Load Generator\nDESCRIPTION: A minimal configuration example for running the load generator. This sets up the database connection and configures which table and fields to modify.\nSOURCE: https://github.com/rocicorp/mono/blob/main/tools/load-generator/README.md#2025-04-10_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -e ZERO_UPSTREAM_DB=\"postgresql://user:password@host.docker.internal:6434/postgres\" \\\n  -e ZERO_PERTURB_TABLE=\"issue\" \\\n  -e ZERO_PERTURB_KEY=\"id\" \\\n  -e ZERO_PERTURB_BOOLS=\"open\" \\\n  load-generator:latest\n```\n\n----------------------------------------\n\nTITLE: Generating a Login URL with Query Parameters in JavaScript\nDESCRIPTION: Creates a login URL by encoding and appending query parameters to a base URL. The function accounts for redirect URLs and optional query parameters.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-perf/data/iphonex-safari.txt#2025-04-10_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nexport function loginURL({\n  host,\n  clientID,\n  redirect,\n  provider,\n  params,\n}: {\n  host: string;\n  clientID: string;\n  redirect: string;\n  provider?: string;\n  params?: URLSearchParams;\n}): string {\n  const result = new URL(`${host}/api/auth/signin`);\n  const redirectURL = new URL(redirect);\n\n  result.searchParams.set(\"callbackUrl\", redirectURL.toString());\n  result.searchParams.set(\"clientId\", clientID);\n\n  if (provider) {\n    result.searchParams.set(\"provider\", provider);\n  }\n\n  if (params) {\n    for (const [key, value] of params.entries()) {\n      redirectURL.searchParams.set(key, value);\n    }\n    result.searchParams.set(\"callbackUrl\", redirectURL.toString());\n  }\n\n  return result.toString();\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Cookie with Options in JavaScript\nDESCRIPTION: Sets a cookie with specified name and value, along with optional parameters like expiration, path, and security flags. Handles encoding of the cookie value.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-perf/data/iphonex-safari.txt#2025-04-10_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport function setCookie(\n  name: string,\n  value: string,\n  options: {\n    expires?: Date;\n    path?: string;\n    domain?: string;\n    secure?: boolean;\n    \"max-age\"?: number;\n    httponly?: boolean;\n    samesite?: \"lax\" | \"strict\" | \"none\";\n  } = {},\n): void {\n  options = { path: \"/\", ...options };\n\n  if (options.expires instanceof Date) {\n    options.expires = options.expires.toUTCString();\n  }\n\n  let updatedCookie = encodeURIComponent(name) + \"=\" + encodeURIComponent(value);\n\n  for (const optionKey in options) {\n    if (Object.prototype.hasOwnProperty.call(options, optionKey)) {\n      const optionValue = options[optionKey as keyof typeof options];\n      updatedCookie += \"; \" + optionKey;\n      if (optionValue !== true) {\n        updatedCookie += \"=\" + optionValue;\n      }\n    }\n  }\n\n  document.cookie = updatedCookie;\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Cookie Value by Name in JavaScript\nDESCRIPTION: Retrieves and decodes a cookie value by its name from the document.cookie string. Returns undefined if the cookie doesn't exist.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-perf/data/iphonex-safari.txt#2025-04-10_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport function getCookie(name: string): string | undefined {\n  const matches = document.cookie.match(\n    new RegExp(\n      \"(?:^|; )\" +\n        name.replace(/([.$?*|{}()[\\]\\\\^])/g, \"\\\\$1\") +\n        \"=([^;]*)\",\n    ),\n  );\n  return matches ? decodeURIComponent(matches[1]) : undefined;\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting a Cookie in JavaScript\nDESCRIPTION: Removes a cookie by setting its expiration date to the past. Uses the setCookie function with expiration date set to a past date.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-perf/data/iphonex-safari.txt#2025-04-10_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nexport function deleteCookie(name: string): void {\n  setCookie(name, \"\", {\n    \"max-age\": -1,\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Logging IndexedDB Write Transaction Failures\nDESCRIPTION: A comprehensive error log showing failed attempts to write ArrayBuffer data to IndexedDB. The errors indicate connection losses and internal server issues across different data sizes and batch quantities. Each line shows the transaction type, data format, batch size, data size, and resulting error message.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-perf/data/iphonex-chrome.txt#2025-04-10_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nidb write tx (arraybuffer) 15x31 KiB: Error: UnknownError: An internal error was encountered in the Indexed Database server\nidb write tx (arraybuffer) 15x32 KiB: Error: UnknownError: Connection to Indexed Database server lost. Refresh the page to try again\nidb write tx (arraybuffer) 15x63 KiB: Error: UnknownError: Connection to Indexed Database server lost. Refresh the page to try again\nidb write tx (arraybuffer) 15x64 KiB: Error: UnknownError: Connection to Indexed Database server lost. Refresh the page to try again\n```\n\n----------------------------------------\n\nTITLE: IndexedDB Read Transaction Performance Data\nDESCRIPTION: Benchmark results for reading ArrayBuffer data from IndexedDB, showing performance metrics (50/75/90/95 percentiles) for various data sizes and batch counts. Measurements include latency and throughput.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-perf/data/apple-m1-chromium-90.0.4430.0.txt#2025-04-10_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nidb read tx (arraybuffer) 1x1 B 50/75/90/95%=0.13,0.17,0.17,0.21ms/op 0.01 MB/s (3229 runs sampled)\nidb read tx (arraybuffer) 1x1 KiB 50/75/90/95%=0.16,0.17,0.17,0.20ms/op 6.10 MB/s (3218 runs sampled)\n```\n\n----------------------------------------\n\nTITLE: IndexedDB Write Transaction Performance Data\nDESCRIPTION: Benchmark results for writing ArrayBuffer data to IndexedDB, showing performance metrics (50/75/90/95 percentiles) for various data sizes and batch counts. Measurements include latency and throughput.\nSOURCE: https://github.com/rocicorp/mono/blob/main/packages/replicache-perf/data/apple-m1-chromium-90.0.4430.0.txt#2025-04-10_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nidb write tx (arraybuffer) 1x1 B 50/75/90/95%=0.29,0.33,0.33,0.34ms/op 0.00 MB/s (1610 runs sampled)\nidb write tx (arraybuffer) 1x1 KiB 50/75/90/95%=0.33,0.33,0.38,0.38ms/op 2.96 MB/s (1315 runs sampled)\n```"
  }
]