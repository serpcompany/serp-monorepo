[
  {
    "owner": "phlex-ruby",
    "repo": "phlex.fun",
    "content": "TITLE: Basic Content Yielding in Ruby Phlex Component\nDESCRIPTION: Demonstrates a basic Card component that yields content within an article element. The component accepts a title parameter and yields the content block.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/yielding.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nclass Card < Phlex::HTML\n  def initialize(title)\n    @title = title\n  end\n\n  def view_template\n    article(class: \"card\") do\n      h2(class: \"card-title\") { @title }\n      yield\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Rendering a Polymorphic Renderable Property - Ruby\nDESCRIPTION: Defines a Phlex::HTML component that accepts any renderable object and renders it through its 'render' method. Demonstrates Phlex's polymorphism for component composition, supporting various data types including components, procs, and enumerables. Requires Phlex.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/rendering.md#2025-04-23_snippet_10\n\nLANGUAGE: ruby\nCODE:\n```\nclass Example < Phlex::HTML\n  def initialize(renderable:)\n    @renderable = renderable\n  end\n\n  def view_template\n    render @renderable\n  end\nend\n\n```\n\n----------------------------------------\n\nTITLE: Installing phlex-rails Gem in Ruby on Rails\nDESCRIPTION: This command adds the phlex-rails gem to your Rails application's Gemfile and installs it along with its dependencies.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/introduction/getting-started.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nbundle add phlex-rails\n```\n\n----------------------------------------\n\nTITLE: Rendering Phlex View in Rails Controller\nDESCRIPTION: Example of how to render a Phlex view from a Rails controller, demonstrating passing data to the view through initialization.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/rails/views.md#2025-04-23_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nclass ArticlesController < ApplicationController\n  def index\n    render Views::Articles::Index.new(\n      articles: Article.all\n    )\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Phlex Component - Ruby\nDESCRIPTION: Defines a basic Phlex::HTML component class in Ruby with an initializer accepting a 'name' parameter. The 'view_template' method renders an h1 tag with a personalized greeting. Requires the 'phlex' gem and expects a string for the 'name' parameter. The output is an HTML node with the greeting message.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/rendering.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nclass MyComponent < Phlex::HTML\n  def initialize(name:)\n    @name = name\n  end\n\n  def view_template\n    h1 { \"Hello, #{@name}\" }\n  end\nend\n\n```\n\n----------------------------------------\n\nTITLE: Instantiating a Phlex Component - Ruby\nDESCRIPTION: Creates a new instance of the MyComponent class, passing in the required 'name' argument. The snippet assumes the prior definition of MyComponent. This step prepares the component for subsequent rendering.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/rendering.md#2025-04-23_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\ncomponent = MyComponent.new(name: \"World\")\n\n```\n\n----------------------------------------\n\nTITLE: Nesting Components with Content Blocks - Ruby\nDESCRIPTION: Defines a Phlex component that renders another component, 'Components::Card', passing a block that renders an h1 containing the article's title. This structure allows the inner component to yield content while maintaining access to the parent's context. Requires both 'Phlex' and the nested component.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/rendering.md#2025-04-23_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nclass Components::Article < Phlex::HTML\n  def initialize(article:)\n    @article = article\n  end\n\n  def view_template\n    render Components::Card do\n      h1 { @article.title }\n    end\n  end\nend\n\n```\n\n----------------------------------------\n\nTITLE: Rendering a Component for Each Element in a Collection - Ruby\nDESCRIPTION: Defines a Phlex component 'Views::Articles::Index' that accepts an array of articles and renders a 'Components::Article' component for each entry using the 'render' instance method. The article is passed as a named argument to maintain context. Requires both Phlex and a 'Components::Article' class.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/rendering.md#2025-04-23_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nclass Views::Articles::Index < Phlex::HTML\n  def initialize(articles:)\n    @articles = articles\n  end\n\n  def view_template\n    @articles.each do |article|\n      render Components::Article.new(article:)\n    end\n  end\nend\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Phlex Component in Ruby on Rails\nDESCRIPTION: This code shows the new structure for creating a Phlex component in a Rails application, using the Components namespace.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/v2-upgrade.md#2025-04-23_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\n# frozen_string_literal: true\n\nclass Components::Button < Components::Base\n  def view_template\n    button { \"Click me\" }\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Rendering a User Profile with Phlex\nDESCRIPTION: This snippet demonstrates how to render a user profile using Phlex. It shows the component-based approach with Ruby classes and methods for templating.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/compare/action-view.md#2025-04-23_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\n# app/views/users/show_component.rb\nclass Users::ShowComponent < ApplicationView\n  def initialize(user:)\n    @user = user\n  end\n\n  def template\n    h1 { @user.name }\n\n    if @user.bio.present?\n      p { @user.bio }\n    end\n\n    h2 { \"Posts\" }\n    ul {\n      @user.posts.each do |post|\n        li { post.title }\n      end\n    }\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Card Component in Phlex Kit\nDESCRIPTION: Demonstrates how to create a Card component within the Components Kit namespace with title and content functionality.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/kits.md#2025-04-23_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nclass Components::Card < Phlex::HTML\n  def initialize(title)\n    @title = title\n  end\n\n  def view_template\n    article(class: \"card\") do\n      h2(class: \"card-title\") { @title }\n      yield\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Render and Parse Helpers Using Nokogiri for HTML Assertions in Ruby\nDESCRIPTION: Defines two methods: `render_fragment` and `render_document` for rendering components and parsing the resultant HTML using Nokogiri. `render_fragment` parses as an HTML fragment, suitable for partial HTML; `render_document` parses as a full HTML document. Both rely on the existence of a `render` helper and the Nokogiri gem, specifically `Nokogiri::HTML5`. Inputs are renderable objects; outputs are Nokogiri document/fragment trees for advanced assertions.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/testing.md#2025-04-23_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\ndef render_fragment(...)\n  html = render(...)\n  Nokogiri::HTML5.fragment(html)\nend\n\ndef render_document(...)\n  html = render(...)\n  Nokogiri::HTML5(html)\nend\n```\n\n----------------------------------------\n\nTITLE: Streaming Phlex View in Rails Controller\nDESCRIPTION: Demonstrates how to stream a Phlex view component from a Rails controller action using the Phlex::Rails::Streaming module. The example shows streaming an Articles index view with a collection of articles.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/streaming.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\ndef index\n  stream Views::Articles::Index.new(\n    articles: Article.all\n  )\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Render Helper for Phlex Components in Ruby\nDESCRIPTION: Implements a simple Ruby function, `render`, for executing a Phlex component and returning its HTML string output by calling `component.call`. Assumes the input object responds to `call` for rendering. No external dependencies are required; this acts as a minimal test helper.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/testing.md#2025-04-23_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\ndef render(component)\n  component.call\nend\n```\n\n----------------------------------------\n\nTITLE: Rendering Multiple Components Including a Static Class - Ruby\nDESCRIPTION: Extends the previous example to also render a sidebar component (which does not require initialization) using the same 'render' method. Demonstrates that Phlex will instantiate the component class automatically if no arguments are given. Shows rendering both a static sidebar and a dynamic list.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/rendering.md#2025-04-23_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nclass Views::Articles::Index < Phlex::HTML\n  def initialize(articles:)\n    @articles = articles\n  end\n\n  def view_template\n    render Components::Sidebar\n\n    @articles.each do |article|\n      render Components::Article.new(article:)\n    end\n  end\nend\n\n```\n\n----------------------------------------\n\nTITLE: Basic Fragment Caching in Phlex Components\nDESCRIPTION: Demonstrates how to use the `cache` method to cache fragments of a component template using object instances as cache keys. The cached content will only be regenerated when the cache keys change.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/caching.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\ndef view_template\n  cache(@user, @article) do\n    h1 { @article.title }\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Fragment Caching with Expiration Options\nDESCRIPTION: Shows how to use the `cache` method with expiration options. This example caches an article title for 12 hours by passing the `expires_in` option, which gets delegated to the cache store.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/caching.md#2025-04-23_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\ncache(@article, expires_in: 12.hours) do\n  h1 { @article.title }\nend\n```\n\n----------------------------------------\n\nTITLE: Rendering HTML Attributes with Phlex in Ruby\nDESCRIPTION: Demonstrates how Phlex handles different attribute key types, including symbols and strings. Shows how underscores in symbol keys are converted to dashes, while string keys are used verbatim.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/attributes.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nh1(data_controller: \"hello\") { \"Hello!\" }\nh1(\"data_controller\" => \"hello\") { \"Hello!\" }\n```\n\nLANGUAGE: html\nCODE:\n```\n<h1 data-controller=\"hello\">Hello!</h1>\n<h1 data_controller=\"hello\">Hello!</h1>\n```\n\n----------------------------------------\n\nTITLE: Implementing Snippets as Methods in a Phlex Component\nDESCRIPTION: This code snippet shows how to create a Sidebar component in Phlex, using private methods as snippets to organize the rendering logic. It demonstrates the main view_template method calling three separate rendering methods for different parts of the sidebar.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/snippets.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nclass Sidebar < Phlex::HTML\n  def view_template\n    render_intro\n    render_links\n    render_footer\n  end\n\n  private\n\n  def render_intro\n    h2 \"Welcome to the site!\"\n    p \"This is the sidebar.\"\n  end\n\n  def render_links\n    # ...\n  end\n\n  def render_footer\n    # ...\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Working with Legacy Layouts in Phlex\nDESCRIPTION: Shows how to use Phlex components as Rails layouts by including Phlex::Rails::Layout module. This allows integrating Phlex into existing Rails apps while still supporting normal non-Phlex views.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/rails/layouts.md#2025-04-23_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nclass Components::Layout < Components::Base\n  include Phlex::Rails::Layout\n\n  def view_template\n    doctype\n\n    html do\n      head do\n        title { yield(:title) }\n      end\n\n      body { yield }\n    end\n  end\nend\n```\n\nLANGUAGE: ruby\nCODE:\n```\nclass ArticlesController\n  layout { Components::Layout }\nend\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Phlex Method Component\nDESCRIPTION: Shows how to create a simple button component as a Ruby method in Phlex. This approach provides a basic level of abstraction for UI elements.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/compare/slim.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\ndef MyButton(...)\n  button(class: \"my button classes\", ...)\nend\n```\n\n----------------------------------------\n\nTITLE: Using Rails Cache Store with Phlex\nDESCRIPTION: Demonstrates how to integrate Phlex's caching with Rails by using the Rails cache store. This works because Rails' cache interface is a superset of Phlex's cache store interface.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/caching.md#2025-04-23_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nclass Components::Base\n  def cache_store\n    Rails.cache\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Including Routes Helper in Phlex Base Component\nDESCRIPTION: Shows how to include the Routes helper in a Phlex base component. This makes all route helpers available in derived components.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/rails/helpers.md#2025-04-23_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nclass Components::Base < Phlex::HTML\n  include Phlex::Rails::Helpers::Routes\nend\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Helper Adapters in Phlex\nDESCRIPTION: Demonstrates how to register custom value and output helpers in a Phlex component. This allows the use of custom Rails helpers or those provided by gems within Phlex components.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/rails/helpers.md#2025-04-23_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nclass Components::Base < Phlex::HTML\n  # Register a Rails helper that returns a value that shouldn't be pushed to the output buffer.\n  # e.g. if you want to use it like `div { format_release_date(book.date) }`\n  register_value_helper :format_release_date\n\n  # Register a Rails helper that returns safe HTML to be pushed to the output buffer.\n  register_output_helper :pagy_nav\nend\n```\n\n----------------------------------------\n\nTITLE: Using link_to and article_path Helpers in Ruby\nDESCRIPTION: Demonstrates the use of both output (link_to) and value (article_path) helpers in Ruby. This snippet shows how these helpers are typically used together in Rails.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/rails/helpers.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nlink_to \"Article\", article_path(@article)\n```\n\n----------------------------------------\n\nTITLE: Defining Fragment Component in Phlex Ruby\nDESCRIPTION: Example showing how to define a Phlex component with a named fragment using the fragment helper. The fragment wraps a list that can be selectively rendered.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/fragments.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nclass MyComponent < Phlex::HTML\n  def view_template\n    section do\n      fragment(\"my-list\") do  # Explicitly declare renderable fragment [!code ++]\n        ul do\n          li { \"Item 1\" }\n          li { \"Item 2\" }\n        end\n      end # [!code ++]\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Unit Test Example Using a Render Helper for Phlex Components in Ruby\nDESCRIPTION: Demonstrates invocation of the `render` function in a test, creating a Hello component and asserting equality with expected HTML output. Expects the existence of `Components::Hello` and an assertion library (such as Minitest). Inputs are a component instance and expected HTML; output is a test result.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/testing.md#2025-04-23_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\noutput = render Components::Hello.new\nassert_equal \"<h1>Hello</h1>\", output\n```\n\n----------------------------------------\n\nTITLE: Rendering ViewComponent Components in Phlex - Ruby\nDESCRIPTION: Illustrates rendering a Rails ViewComponent ('CardComponent') from within a Phlex component, while also yielding additional content via a block. This approach allows seamless integration of ViewComponent-based UI elements. Requires the ViewComponent gem and Phlex.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/rendering.md#2025-04-23_snippet_9\n\nLANGUAGE: ruby\nCODE:\n```\nclass Components::Article < Phlex::HTML\n  def initialize(article:)\n    @article = article\n  end\n\n  def view_template\n    render CardComponent.new(title: \"Hello\") do\n      h1 { @article.title }\n    end\n  end\nend\n\n```\n\n----------------------------------------\n\nTITLE: Rendering an SVG Element with Phlex (Ruby)\nDESCRIPTION: This Ruby code snippet demonstrates how to render an `<svg>` element using the `svg` helper method in the Phlex library. The method accepts a block, yielding a `Phlex::SVG` component instance (represented by `s`). This allows for the definition of nested SVG elements, such as `<rect>`, along with their attributes (e.g., `x`, `y`, `width`, `height`) within the block.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/html-elements.md#2025-04-23_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\n```ruby\nsvg do |s|\n  s.rect x: 10, y: 10, width: 100, height: 100\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Rendering Specific Fragments in Phlex Ruby\nDESCRIPTION: Demonstrates how to render specific fragments by passing the fragment names to the call method. This allows selective rendering of only the desired fragments.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/fragments.md#2025-04-23_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nMyComponent.new.call(fragments: [\"my-list\"])\n```\n\n----------------------------------------\n\nTITLE: Rendering Rails Partials in Phlex - Ruby\nDESCRIPTION: A Phlex component utilizes the 'partial' method to refer to a Rails partial, then renders it with specified local variables and a block for additional content. Demonstrates interoperating with traditional Rails partials from a Phlex context. Requires Rails, Phlex, and a matching '_card.html.*' partial.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/rendering.md#2025-04-23_snippet_8\n\nLANGUAGE: ruby\nCODE:\n```\nclass Components::Article < Phlex::HTML\n  def initialize(article:)\n    @article = article\n  end\n\n  def view_template\n    render partial(\"card\", title: \"Hello\") do\n      h1 { @article.title }\n    end\n  end\nend\n\n```\n\n----------------------------------------\n\nTITLE: Final Component Class Definition with DSL Support in Ruby\nDESCRIPTION: Presents the final version of the `Component` class, incorporating the `plain` method and the updated `call` method that yields `self`. This version supports basic HTML generation, nesting, plain text, and component-specific DSLs via yielding.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_24\n\nLANGUAGE: ruby\nCODE:\n```\nclass Component\n  def call(buffer = [])\n    @buffer = buffer\n    view_template { yield(self) if block_given? }\n    @buffer.join\n  end\n\n  def div(content = nil, **attributes)\n    @buffer << \"<div\"\n\n    attributes.each do |key, value|\n      @buffer << \" #{key}=\\\"#{value}\\\"\"; # Changed \"key=\"value\"\" to avoid premature JSON termination\n    end\n\n    @buffer << \">\"\n\n    if content\n      @buffer << content\n    elsif block_given?\n      yield\n    end\n\n    @buffer << \"</div>\"\n  end\n\n  def plain(content)\n    @buffer << content\n  end\n\n  def render(component, &)\n    component.call(@buffer, &)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Special Handling of Style Attribute in Phlex\nDESCRIPTION: Demonstrates how Phlex converts a hash passed to the style attribute into a CSS string.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/attributes.md#2025-04-23_snippet_6\n\nLANGUAGE: ruby\nCODE:\n```\nh1(style: { color: \"red\", font_size: \"16px\" }) { \"Hello!\" }\n```\n\nLANGUAGE: html\nCODE:\n```\n<h1 style=\"color: red; font-size: 16px;\">Hello!</h1>\n```\n\n----------------------------------------\n\nTITLE: Generating Phlex View in Rails\nDESCRIPTION: Command to generate a new Phlex view using Rails generator, specifically for creating an Articles Index view.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/rails/views.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nbundle exec rails g phlex:view Articles::Index\n```\n\n----------------------------------------\n\nTITLE: Rendering a Phlex Component from a Rails Controller - Ruby\nDESCRIPTION: Shows usage of the Rails controller 'render' method to render a Phlex component, specifically an instance of 'Views::Articles::Index' initialized with a collection of articles. This example is meant for integration within Rails MVC and makes Rails' view context and helpers accessible to the component. Expects Rails and Phlex gems.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/rendering.md#2025-04-23_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\ndef index\n  render Views::Articles::Index.new(\n    articles: Article.all\n  )\nend\n\n```\n\n----------------------------------------\n\nTITLE: Handling Event Attributes Safely in Phlex\nDESCRIPTION: Demonstrates how to use event attributes in Phlex by marking them as safe, bypassing the default security restrictions.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/attributes.md#2025-04-23_snippet_8\n\nLANGUAGE: ruby\nCODE:\n```\nbutton(onclick: safe(\"alert(1)\"))\n```\n\n----------------------------------------\n\nTITLE: Rendering Various Component Types (Phlex, ViewComponent, ERB) in Ruby with Rails Test Helpers\nDESCRIPTION: Illustrates usage examples of the previously defined Rails-integrated `render` helper. Shows how to render a Phlex component, a ViewComponent, an ERB partial, and a full ERB view with layout. Assumes all dependencies from Rails, ViewComponent, and Phlex are configured in the test environment.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/testing.md#2025-04-23_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\n# Phlex\nrender SomePhlexComponent.new\n\n# ViewComponent\nrender SomeViewComponent.new\n\n# ERB Partial\nrender \"some_partial\"\n\n# ERB View\nrender template: \"some_view_template\", layout: \"some_layout\"\n```\n\n----------------------------------------\n\nTITLE: Initializing Component with Buffer in Ruby\nDESCRIPTION: Defines the initial `Component` class with an `initialize` method that sets up an empty array `@buffer` as an instance variable. This buffer will store the generated HTML fragments.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nclass Component\n  def initialize\n    @buffer = []\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Layouts through Composition in Phlex\nDESCRIPTION: Shows how to implement layouts through composition by rendering a layout component from a controller and view. The controller disables Rails layouts, and the view renders a layout component passing content via a block.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/rails/layouts.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nclass ArticlesController < ApplicationController\n  layout false\n\n  def index\n    render Views::Articles::Index.new(\n      articles: Article.all.limit(10)\n    )\n  end\nend\n```\n\nLANGUAGE: ruby\nCODE:\n```\nclass Views::Articles::Index < Views::Base\n  def initialize(articles:)\n    @articles = articles\n  end\n\n  def view_template\n    Layout(title: \"Articles\") do\n      h1 { \"Articles\" }\n\n      ul do\n        @articles.each do |article|\n          li { article.title }\n        end\n      end\n    end\n  end\nend\n```\n\nLANGUAGE: ruby\nCODE:\n```\nclass Components::Layout < Components::Base\n  def initialize(title:)\n    @title = title\n  end\n\n  def view_template\n    doctype\n\n    html do\n      head do\n        title { @title }\n      end\n\n      body { yield }\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Integrating Rails View Context into Render Helpers for Phlex Components in Ruby\nDESCRIPTION: Defines three methods for integrating Phlex-Rails component testing: `render` delegates rendering to `view_context`, `view_context` delegates to a test controller, and `controller` memoizes an ActionView test controller instance. These helpers require Rails and access to ActionView::TestCase, supporting rendering of Phlex, ViewComponent, ERB views, and partials. Key inputs include template/component objects or strings and optional options; outputs are rendered HTML.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/testing.md#2025-04-23_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\ndef render(...)\n  view_context.render(...)\nend\n\ndef view_context\n  controller.view_context\nend\n\ndef controller\n  @controller ||= ActionView::TestCase::TestController.new\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Initial `call` Method for Rendering in Ruby\nDESCRIPTION: Adds a `call` instance method to the `Component` class. This method is intended to be the main entry point for rendering. It first calls `view_template` (responsible for defining the component's structure) and then joins the `@buffer` array into a single HTML string.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\ndef call\n  view_template\n  @buffer.join\nend\n```\n\n----------------------------------------\n\nTITLE: Registering Custom HTML Elements in Phlex\nDESCRIPTION: Demonstrates how to register and use a custom HTML element in a Phlex component. The example shows registering a 'trix_editor' element and using it in the view template.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/html-elements.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nclass Example < Phlex::HTML\n  register_element :trix_editor\n\n  def view_template\n    trix_editor\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Interface Yielding Nav Component\nDESCRIPTION: Implementation of a Nav component that provides a specialized interface for adding navigation items and dividers.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/yielding.md#2025-04-23_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nclass Nav < Phlex::HTML\n  def view_template(&)\n    nav(class: \"special-nav\", &)\n  end\n\n  def item(href, &)\n    a(class: \"special-nav-item\", href:, &)\n  end\n\n  def divider\n    span(class: \"special-nav-divider\")\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Rendering a User Profile with ActionView and ERB\nDESCRIPTION: This snippet shows how to render a user profile using ActionView and ERB. It includes conditional rendering and iterating over a collection.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/compare/action-view.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\n<%# app/views/users/show.html.erb %>\n<h1><%= @user.name %></h1>\n\n<% if @user.bio.present? %>\n  <p><%= @user.bio %></p>\n<% end %>\n\n<h2>Posts</h2>\n<ul>\n  <% @user.posts.each do |post| %>\n    <li><%= post.title %></li>\n  <% end %>\n</ul>\n```\n\n----------------------------------------\n\nTITLE: Generating HTML Doctype using Phlex Method in Ruby\nDESCRIPTION: This Ruby code snippet, intended for use within a `Phlex::HTML` component, calls the `doctype` method. This method is specifically designed to render the standard `<!doctype html>` declaration required at the beginning of an HTML5 document. No parameters are needed.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/doctype.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\ndoctype\n```\n\n----------------------------------------\n\nTITLE: Implementing Layouts through Inheritance in Phlex\nDESCRIPTION: Demonstrates implementing layouts through inheritance by creating an abstract base view class that renders the layout around the template. The view classes inherit from this base class and define specific content.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/rails/layouts.md#2025-04-23_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nclass ArticlesController < ApplicationController\n  layout false\n\n  def index\n    render Views::Articles::Index.new(\n      articles: Article.all.limit(10)\n    )\n  end\nend\n```\n\nLANGUAGE: ruby\nCODE:\n```\nclass Views::Articles::Index < Views::Base\n  def initialize(articles:)\n    @articles = articles\n  end\n\n  def page_title = \"Articles\"\n\n  def view_template\n    h1 { \"Articles\" }\n\n    ul do\n      @articles.each do |article|\n        li { article.title }\n      end\n    end\n  end\nend\n```\n\nLANGUAGE: ruby\nCODE:\n```\nclass Views::Base < Phlex::HTML\n  def around_template\n    doctype\n\n    html do\n      head do\n        title { page_title }\n      end\n\n      body { super }\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Integrating Ruby Code in Phlex and Haml Templates\nDESCRIPTION: This snippet demonstrates how to incorporate Ruby code within Phlex and Haml templates. It shows variable interpolation and iteration over an array to generate list items.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/compare/haml.md#2025-04-23_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\n# Phlex\nclass Example < Phlex::HTML\n  def initialize(name)\n    @name = name\n  end\n\n  def template\n    h1 { \"Hello #{@name}\" }\n    ul do\n      [1, 2, 3].each do |i|\n        li { i.to_s }\n      end\n    end\n  end\nend\n\n# Haml\n%h1 Hello #{@name}\n%ul\n  - [1, 2, 3].each do |i|\n    %li= i\n```\n\n----------------------------------------\n\nTITLE: Creating a Phlex View in Ruby on Rails\nDESCRIPTION: This snippet demonstrates the new structure for creating a Phlex view in a Rails application, using the Views namespace.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/v2-upgrade.md#2025-04-23_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\n# frozen_string_literal: true\n\nclass Views::Articles::Index < Views::Base\n  def view_template\n    h1 { \"Articles\" }\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Phlex Kit\nDESCRIPTION: Shows how to create a basic Kit by extending Phlex::Kit in a Ruby module.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/kits.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nmodule Components\n  extend Phlex::Kit\nend\n```\n\n----------------------------------------\n\nTITLE: Outputting Raw HTML from Markdown in Phlex Ruby\nDESCRIPTION: This snippet demonstrates how to output raw HTML generated by a Markdown renderer in Phlex. It uses the 'raw' method in combination with 'safe' to indicate that the HTML string is trusted and safe to render without escaping.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/raw.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nraw safe(\n  Commonmarker.to_html(@markdown)\n)\n```\n\n----------------------------------------\n\nTITLE: Outputting Plain Text with Phlex in Ruby\nDESCRIPTION: Demonstrates the use of the 'plain' method to output plain text in Phlex. This is the simplest way to render text without HTML tags.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/text.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nplain \"Hello, world!\"\n```\n\n----------------------------------------\n\nTITLE: Implicit Text Output from Blocks in Phlex Ruby\nDESCRIPTION: Shows how Phlex implicitly outputs the return value of a block as plain text when the block doesn't render any HTML elements or modify the buffer.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/text.md#2025-04-23_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nh1 { \"Hello World\" }\n```\n\n----------------------------------------\n\nTITLE: Combining HTML Elements and Plain Text in Phlex Ruby\nDESCRIPTION: Illustrates how to combine HTML elements (like 'strong') with plain text inside a block. This is necessary when you want to wrap part of the text in HTML tags while keeping other parts as plain text.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/text.md#2025-04-23_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nh1 do\n  strong { \"Hello\" }\n  plain \" World\"\nend\n```\n\n----------------------------------------\n\nTITLE: Rendering HTML Comments with Phlex\nDESCRIPTION: Shows how to use the comment method to wrap Phlex content in HTML comments. The method takes a block of Phlex code and outputs it wrapped in HTML comment tags.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/comments.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\ncomment do\n  h1 { \"Hello\" }\nend\n```\n\nLANGUAGE: html\nCODE:\n```\n<!-- <h1>Hello</h1> -->\n```\n\n----------------------------------------\n\nTITLE: Rendering Kit Component Example\nDESCRIPTION: Shows how to render a Kit component using the simplified Kit syntax.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/kits.md#2025-04-23_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nclass Example < Phlex::HTML\n  def view_template\n    Components::Card(\"Hello, World!\") do\n      p { \"This is a card.\" }\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Advanced Content Yielding with Block Parameter\nDESCRIPTION: Enhanced version of the Card component that passes the content block to a div element using &content syntax.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/yielding.md#2025-04-23_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nclass Card < Phlex::HTML\n  def initialize(title)\n    @title = title\n  end\n\n  def view_template(&content)\n    article(class: \"card\") do\n      h2(class: \"card-title\") { @title }\n      div(class: \"card-content\", &content)\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Rendered HTML Output with Whitespace in Phlex\nDESCRIPTION: This snippet shows the resulting HTML output when using the 'whitespace' method in Phlex. It demonstrates how a single space character is inserted between the two anchor elements, allowing for proper inline spacing.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/whitespace.md#2025-04-23_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<nav><a href=\"/\">Home</a> <a href=\"/about\">About</a></nav>\n```\n\n----------------------------------------\n\nTITLE: Basic Card Component with Manual Attribute Handling\nDESCRIPTION: Example showing manual handling of component attributes by explicitly defining parameters in the initializer. This approach provides fine-grained control but can become unwieldy with many attributes.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/helpers.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nclass Card < Phlex::HTML\n  def initialize(id: nil, data: {})\n    @id = id\n    @data = data\n  end\n\n  def view_template\n    div(id: @id, data: @data) do\n      # ...\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Handling Boolean Attribute Values in Phlex\nDESCRIPTION: Shows how Phlex renders boolean attribute values, omitting the attribute for false values and rendering without a value for true.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/attributes.md#2025-04-23_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\ntextarea(disabled: true)\ntextarea(disabled: false)\n```\n\nLANGUAGE: html\nCODE:\n```\n<textarea disabled></textarea> <textarea></textarea>\n```\n\n----------------------------------------\n\nTITLE: Inserting Whitespace Between Links in Phlex Ruby\nDESCRIPTION: This snippet demonstrates how to use the 'whitespace' method in Phlex to insert a single space character between two inline anchor elements within a navigation block. This allows for proper text wrapping and spacing in the rendered HTML.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/whitespace.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nnav do\n  a(href: \"/\") { \"Home\" }\n  whitespace\n  a(href: \"/about\") { \"About\" }\nend\n```\n\n----------------------------------------\n\nTITLE: Mix Helper Implementation\nDESCRIPTION: Source code for the mix helper that handles attribute merging with support for various data types and special bang (!) syntax for overriding values.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/helpers.md#2025-04-23_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\ndef mix(*args)\n  args.each_with_object({}) do |object, result|\n    result.merge!(object) do |_key, old, new|\n      case [old, new].freeze\n      in [Array, Array] | [Set, Set]\n        old + new\n      in [Array, Set]\n        old + new.to_a\n      in [Array, String]\n        old + [new]\n      in [Hash, Hash]\n        mix(old, new)\n      in [Set, Array]\n        old.to_a + new\n      in [Set, String]\n        old.to_a + [new]\n      in [String, Array]\n        [old] + new\n      in [String, Set]\n        [old] + new.to_a\n      in [String, String]\n        \"#{old} #{new}\"\n      in [_, nil]\n        old\n      else\n        new\n      end\n    end\n\n    result.transform_keys! do |key|\n      key.end_with?(\"!\") ? key.name.chop.to_sym : key\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Rendering a Phlex Component in ERB - ERB\nDESCRIPTION: Shows how to render a Phlex component within an ERB template, supporting blocks for content. The 'Card' component receives a title and the content block renders raw HTML. This integration requires Rails with ActiveSupport for HTML safety and the Phlex gem.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/rendering.md#2025-04-23_snippet_7\n\nLANGUAGE: erb\nCODE:\n```\n<%= render Card.new(title: \"Hello\") do %>\n  <h1>Inside Bar</h1>\n<% end %>\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Kit Usage in Ruby\nDESCRIPTION: This snippet shows how to use Kits in Phlex v2, including automatic Kit extension to nested modules.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/v2-upgrade.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nmodule Components\n  extend Phlex::Kit\n\n  module Articles\n    # this is automatically upgraded to a kit\n\n    class List < Phlex::HTML\n      # this is available on the `Components::Articles` kit\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Rendering Card Component with Content Block\nDESCRIPTION: Shows how to render the Card component while passing a content block with a paragraph element.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/yielding.md#2025-04-23_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nrender Card.new(\"Hello\") do\n  p { \"Hello, World\" }\nend\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Phlex against ERB in Ruby\nDESCRIPTION: This code snippet demonstrates a performance benchmark comparing Phlex to ERB (Embedded Ruby) for rendering a simple HTML template. It measures the time taken for 100,000 iterations of rendering.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/design/performance.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nrequire \"benchmark/ips\"\n\nclass PhlexComponent < Phlex::HTML\n  def template\n    h1 { \"Hello world!\" }\n  end\nend\n\nERB_TEMPLATE = ERB.new <<~ERB\n  <h1>Hello world!</h1>\nERB\n\nBenchmark.ips do |x|\n  x.report(\"Phlex\") { PhlexComponent.new.call }\n  x.report(\"ERB\") { ERB_TEMPLATE.result }\n  x.compare!\nend\n```\n\n----------------------------------------\n\nTITLE: Rendering a Component by Calling 'call' - Ruby\nDESCRIPTION: Demonstrates how to render a Phlex component manually by calling its 'call' method, storing the resulting HTML string in 'html_output'. This pattern is used outside of Rails controller actions or views and requires that 'component' be an inline or previously instantiated Phlex component object. The output is a string representing the component's HTML.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/rendering.md#2025-04-23_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\ncomponent = MyComponent.new(name: \"World\")\n\nhtml_output = component.call\n\n```\n\n----------------------------------------\n\nTITLE: Handling String Attribute Values in Phlex\nDESCRIPTION: Shows how Phlex outputs string attribute values without modification, unless they contain double-quotes which are escaped.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/attributes.md#2025-04-23_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\ninput(name: \"first_name\")\n```\n\nLANGUAGE: html\nCODE:\n```\n<input name=\"first_name\" />\n```\n\n----------------------------------------\n\nTITLE: Table Component with Vanishing Yield\nDESCRIPTION: Complex table component implementation that uses vanishing yield to collect column definitions before rendering the final HTML structure.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/yielding.md#2025-04-23_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nclass Table < Phlex::HTML\n  def initialize(rows)\n    @rows = rows\n    @columns = []\n  end\n\n  def view_template(&)\n    vanish(&)\n\n    table do\n      thead do\n        @columns.each do |column|\n          th { column[:header] }\n        end\n      end\n\n      tbody do\n        @rows.each do |row|\n          tr do\n            @columns.each do |column|\n              td { column[:content].call(row) }\n            end\n          end\n        end\n      end\n    end\n  end\n\n  def column(header, &content)\n    @columns << { header:, content: }\n    nil\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Handling Array Attribute Values in Phlex\nDESCRIPTION: Shows how Phlex compacts and joins array attribute values with spaces, allowing for conditional class assignments.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/attributes.md#2025-04-23_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\na(\n  class: [\n    (\"button\"),\n    (\"active\" if is_active),\n    (\"disabled\" if is_disabled)\n  ]\n) { \"Click me\" }\n```\n\n----------------------------------------\n\nTITLE: Using Symbol Attribute Values in Phlex\nDESCRIPTION: Demonstrates how Phlex replaces underscores with dashes in symbol attribute values.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/attributes.md#2025-04-23_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\ndiv(contenteditable: :plaintext_only)\n```\n\nLANGUAGE: html\nCODE:\n```\n<div contenteditable=\"plaintext-only\"></div>\n```\n\n----------------------------------------\n\nTITLE: Using Hash Attribute Values in Phlex\nDESCRIPTION: Demonstrates how Phlex flattens nested hash attribute values, joining levels with dashes.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/attributes.md#2025-04-23_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nh1(data: { controller: \"hello\" }) { \"Hello!\" }\n```\n\nLANGUAGE: html\nCODE:\n```\n<h1 data-controller=\"hello\">Hello!</h1>\n```\n\n----------------------------------------\n\nTITLE: Defining Properties in a Phlex Component using Literal\nDESCRIPTION: This example demonstrates how to use the 'prop' method to define properties in a Phlex component. It includes type definitions, unions, and default values for various properties such as href, size, variant, and disabled.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/literal-properties.md#2025-04-23_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nclass Components::LinkButton < Components::Base\n  Size = _Union(:small, :medium, :large)\n  Variant = _Union(:primary, :success, :danger)\n\n  prop :href, String\n  prop :size, Size, default: :medium\n  prop :variant, Variant, default: :primary\n  prop :disabled, _Boolean, default: false\n\n  def view_template\n    # ...\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Combining Inheritance and Composition for Layouts in Phlex\nDESCRIPTION: Illustrates a flexible approach that combines inheritance and composition for layouts in Phlex. The view inherits from a base class and defines layout methods, while the base class renders the specified layout component.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/rails/layouts.md#2025-04-23_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nclass ArticlesController < ApplicationController\n  layout false\n\n  def index\n    render Views::Articles::Index.new(\n      articles: Article.all.limit(10)\n    )\n  end\nend\n```\n\nLANGUAGE: ruby\nCODE:\n```\nclass Views::Articles::Index < Views::Base\n  def initialize(articles:)\n    @articles = articles\n  end\n\n  def page_title = \"Articles\"\n  def layout = Layout\n\n  def view_template\n    h1 { \"Articles\" }\n\n    ul do\n      @articles.each do |article|\n        li { article.title }\n      end\n    end\n  end\nend\n```\n\nLANGUAGE: ruby\nCODE:\n```\nclass Views::Base < Phlex::HTML\n\tinclude Components\n\n  PageInfo = Data.define(:title)\n\n  def around_template\n    render layout.new(page_info) do\n      super\n    end\n  end\n\n  def page_info\n    PageInfo.new(\n      title: page_title\n    )\n  end\nend\n```\n\nLANGUAGE: ruby\nCODE:\n```\nclass Components::Layout < Components::Base\n  def initialize(page_info)\n    @page_info = page_info\n  end\n\n  def view_template\n    doctype\n\n    html do\n      head do\n        title { @page_info.title }\n      end\n\n      body { yield }\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Handling JavaScript Links Safely in Phlex\nDESCRIPTION: Shows how to bypass Phlex's security feature for javascript: links using the safe method. This should be used with caution to prevent XSS attacks.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/attributes.md#2025-04-23_snippet_7\n\nLANGUAGE: ruby\nCODE:\n```\na(href: safe(\"javascript:alert(1)\")) { \"Click me\" }\n```\n\n----------------------------------------\n\nTITLE: Low-Level Fragment Caching in Phlex\nDESCRIPTION: Demonstrates the `low_level_cache` method which gives full control over the cache key without Phlex adding supplemental keys. This requires manually handling cache invalidation logic.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/caching.md#2025-04-23_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nlow_level_cache([@article], expires_in: 12.hours) do\n  h1 { @article.title }\nend\n```\n\n----------------------------------------\n\nTITLE: Component Class Definition with Nesting Support in Ruby\nDESCRIPTION: Shows the complete `Component` class after refactoring `call` and adding the `render` method. The `initialize` method is removed as buffer handling is now managed by `call`. This version supports rendering nested components.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_15\n\nLANGUAGE: ruby\nCODE:\n```\nclass Component\n  def call(buffer = [], &)\n    @buffer = buffer\n    view_template(&)\n    @buffer.join\n  end\n\n  def div(content = nil, **attributes)\n    @buffer << \"<div\"\n\n    attributes.each do |key, value|\n      @buffer << \" #{key}=\\\"#{value}\\\"\"; # Changed \"key=\"value\"\" to avoid premature JSON termination\n    end\n\n    @buffer << \">\"\n\n    if content\n      @buffer << content\n    elsif block_given?\n      yield\n    end\n\n    @buffer << \"</div>\"\n  end\n\n  def render(component, &)\n    component.call(@buffer, &)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Passing Parameters to Layouts in Phlex\nDESCRIPTION: Demonstrates how to pass parameters to layout components directly when specifying the layout in a Rails controller. This enables customization of layouts based on controller data.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/rails/layouts.md#2025-04-23_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nclass ApplicationController < ActionController::Base\n  layout -> { Components::Layout.new(banner: show_banner?) }\n\n  def show_banner?\n    cookies[:accepted] != \"true\"\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Reusable Card Component in Ruby\nDESCRIPTION: Defines a new `Card` component inheriting from `Component`. Its `view_template` renders a single `div` with the class `card` and passes along any block it receives (`&`), allowing content to be nested within the card.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_16\n\nLANGUAGE: ruby\nCODE:\n```\nclass Card < Component\n  def view_template(&)\n    div(class: \"card\", &)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Grab Helper Implementation\nDESCRIPTION: Source code for the grab helper that safely handles keyword arguments that conflict with Ruby reserved words.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/helpers.md#2025-04-23_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\ndef grab(**bindings)\n  if bindings.size > 1\n    bindings.values\n  else\n    bindings.values.first\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Updating `call` Method to Yield Self for DSL Support in Ruby\nDESCRIPTION: Modifies the `call` method to enable the pattern of yielding the component instance to the block provided during rendering. It wraps the call to `view_template` in a block that explicitly yields `self` if a block was originally passed to `call`.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_23\n\nLANGUAGE: ruby\nCODE:\n```\ndef call(buffer = [])\n  @buffer = buffer\n  view_template { yield(self) if block_given? }\n  @buffer.join\nend\n```\n\n----------------------------------------\n\nTITLE: Defining `render` Method for Component Nesting in Ruby\nDESCRIPTION: Adds a `render` instance method to the `Component` class. This method takes another `component` instance, calls its `call` method, and crucially passes the current component's `@buffer` and any provided block (`&`). This enables rendering one component within another.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_14\n\nLANGUAGE: ruby\nCODE:\n```\ndef render(component, &)\n  component.call(@buffer, &)\nend\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Rendering HelloWorld Component in Ruby\nDESCRIPTION: Demonstrates how to create an instance of the `HelloWorld` component and call its `call` method to render its HTML output to the standard output using `puts`.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nputs HelloWorld.new.call\n```\n\n----------------------------------------\n\nTITLE: Card Component Using Mix Helper\nDESCRIPTION: Improved implementation using the mix helper to combine attributes flexibly. This approach allows for more dynamic attribute handling while maintaining the component's base styling.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/helpers.md#2025-04-23_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nclass Card < Phlex::HTML\n  def initialize(**attributes)\n    @attributes = attributes\n  end\n\n  def view_template\n    div(**mix({ class: \"card\" }, @attributes)) do\n      # ...\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Refactoring `call` Method for Component Nesting in Ruby\nDESCRIPTION: Refactors the `call` method to support component nesting. It now accepts an optional `buffer` argument (defaulting to a new array) and a block (`&`). The `@buffer` is set to the passed-in buffer, and the block is passed to `view_template`. This allows components to render into a parent's buffer.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_13\n\nLANGUAGE: ruby\nCODE:\n```\ndef call(buffer = [], &)\n  @buffer = buffer\n  view_template(&)\n  @buffer.join\nend\n```\n\n----------------------------------------\n\nTITLE: Updating `div` Method for Attribute Handling in Ruby\nDESCRIPTION: Enhances the `div` method to accept keyword arguments (`**attributes`) for HTML attributes. It iterates over the `attributes` hash and appends each key-value pair in the format `key=\"value\"` to the opening tag.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_10\n\nLANGUAGE: ruby\nCODE:\n```\ndef div(content = nil, **attributes)\n  @buffer << \"<div\"\n\n  attributes.each do |key, value|\n    @buffer << \" #{key}=\\\"#{value}\\\"\"; # Changed \"key=\"value\"\" to avoid premature JSON termination\n  end\n\n  @buffer << \">\"\n\n  if content\n    @buffer << content\n  elsif block_given?\n    yield\n  end\n\n  @buffer << \"</div>\"\nend\n```\n\n----------------------------------------\n\nTITLE: Table Component with Kits\nDESCRIPTION: Compares table component rendering with and without Kit syntax.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/kits.md#2025-04-23_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\nTable(@people) do |t|\n  t.column(\"Name\", &:name)\n  t.column(\"Age\", &:age)\nend\n```\n\nLANGUAGE: ruby\nCODE:\n```\nrender Table.new(@people) do |t|\n  t.column(\"Name\", &:name)\n  t.column(\"Age\", &:age)\nend\n```\n\n----------------------------------------\n\nTITLE: Running Phlex Install Generator in Ruby on Rails\nDESCRIPTION: This command runs the Phlex install generator, which sets up the necessary configuration for using Phlex components in your Rails application.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/introduction/getting-started.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nbundle exec rails generate phlex:install\n```\n\n----------------------------------------\n\nTITLE: Defining Basic HelloWorld Component in Ruby\nDESCRIPTION: Defines a `HelloWorld` class inheriting from `Component`. It implements the `view_template` method to render two nested divs using the `div` helper method provided by the parent class.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nclass HelloWorld < Component\n  def view_template\n    div {\n      div\n    }\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring a Custom FIFO Cache Store\nDESCRIPTION: Shows how to configure a custom FIFO cache store for Phlex components by defining the `cache_store` method. The example creates a shared cache with a 20MB size limit.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/caching.md#2025-04-23_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nclass Components::Base\n  CACHE = Phlex::FIFOCacheStore.new(\n    max_bytesize: 20_000_000 # 20MB\n  )\n\n  def cache_store\n    CACHE\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: ERB Integration with Nav Component\nDESCRIPTION: Example of rendering the Nav component from ERB templates with block syntax.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/yielding.md#2025-04-23_snippet_5\n\nLANGUAGE: erb\nCODE:\n```\n<%= render Nav do |nav| %>\n  <% nav.item(\"/\") do %>\n    <strong>Home</strong>\n  <% end %>\n\n  <% nav.item(\"/about\") do %>\n    About\n  <% end %>\n\n  <% nav.divider %>\n\n  <% nav.item(\"/contact\") do %>\n    Contact\n  <% end %>\n<% end %>\n```\n\n----------------------------------------\n\nTITLE: Complete Initial Component Class Definition in Ruby\nDESCRIPTION: Shows the complete `Component` class after defining the `initialize`, `call`, and basic `div` methods. This forms the foundation for creating renderable components.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nclass Component\n  def initialize\n    @buffer = []\n  end\n\n  def call\n    view_template\n    @buffer.join\n  end\n\n  def div\n    @buffer << \"<div>\"\n    yield if block_given?\n    @buffer << \"</div>\"\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Optimized Attribute Caching Using Hash Integer in Ruby\nDESCRIPTION: Shows an improved caching method using the hash integer of the attributes hash as the cache key for faster lookups.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/design/attribute-caching.md#2025-04-23_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nCACHE[attributes_hash.hash] ||= calculate_attributes(attributes_hash)\n```\n\n----------------------------------------\n\nTITLE: Implementing DeferredRender in Ruby\nDESCRIPTION: This code snippet demonstrates how to recreate the effect of the removed DeferredRender feature using a module.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/v2-upgrade.md#2025-04-23_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nmodule DeferredRender\n  def before_template(&)\n  \tvanish(&)\n  \tsuper\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Phlex in Rails Initializer\nDESCRIPTION: This code sets up the Views and Components modules and configures autoloading for Phlex in a Rails application.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/v2-upgrade.md#2025-04-23_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\n# frozen_string_literal: true\n\nmodule Views\nend\n\nmodule Components\n  extend Phlex::Kit\nend\n\nRails.autoloaders.main.push_dir(\n  \"#{Rails.root}/app/views\", namespace: Views\n)\n\nRails.autoloaders.main.push_dir(\n  \"#{Rails.root}/app/components\", namespace: Components\n)\n```\n\n----------------------------------------\n\nTITLE: Basic Attribute Caching in Ruby\nDESCRIPTION: Demonstrates a simple caching mechanism for attribute calculations using a hash as the cache key.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/design/attribute-caching.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nCACHE[attributes_hash] ||= calculate_attributes(attributes_hash)\n```\n\n----------------------------------------\n\nTITLE: Avoiding Race Conditions in Cached Attribute Access\nDESCRIPTION: Demonstrates an incorrect way to access cached attributes that could lead to race conditions in a multi-threaded environment.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/design/attribute-caching.md#2025-04-23_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nif CACHE[key]\n  do_something_with(CACHE[key])\nend\n```\n\n----------------------------------------\n\nTITLE: Comparing Basic HTML Structure in Phlex and Haml\nDESCRIPTION: This snippet shows how to create a basic HTML structure with a header and paragraph in both Phlex and Haml. It demonstrates the syntax differences for defining elements and attributes.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/compare/haml.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\n# Phlex\nclass Example < Phlex::HTML\n  def template\n    h1(class: \"title\") { \"Hello world\" }\n    p { \"Welcome to my website\" }\n  end\nend\n\n# Haml\n%h1.title Hello world\n%p Welcome to my website\n```\n\n----------------------------------------\n\nTITLE: Updating HelloWorld Component with Attributes in Ruby\nDESCRIPTION: Updates the `HelloWorld` component's `view_template` to add `class` attributes to both the outer and inner divs, using the keyword argument syntax supported by the enhanced `div` method.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_11\n\nLANGUAGE: ruby\nCODE:\n```\nclass HelloWorld < Component\n  def view_template\n    div(class: \"outer\") {\n      div(\"Hello, World!\", class: \"inner\")\n    }\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Basic `div` Tag Helper in Ruby\nDESCRIPTION: Adds a `div` instance method to the `Component` class. It pushes the opening `<div>` tag to the buffer, yields to a block if provided (for nested content), and then pushes the closing `</div>` tag.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\ndef div\n  @buffer << \"<div>\"\n  yield if block_given?\n  @buffer << \"</div>\"\nend\n```\n\n----------------------------------------\n\nTITLE: Defining `plain` Method for Raw Text Rendering in Ruby\nDESCRIPTION: Adds a `plain` instance method to the `Component` class. This method simply takes a `content` string and pushes it directly onto the `@buffer`, allowing for rendering text nodes without wrapping them in an HTML tag.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_19\n\nLANGUAGE: ruby\nCODE:\n```\ndef plain(content)\n  @buffer << content\nend\n```\n\n----------------------------------------\n\nTITLE: Adding Component-Specific DSL Method (`title`) to Card in Ruby\nDESCRIPTION: Enhances the `Card` component by adding a `title` method. This method acts as a specific interface (DSL) for adding a title, rendering the content within a `div` with the class `card-title`.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_21\n\nLANGUAGE: ruby\nCODE:\n```\nclass Card < Component\n  def view_template(&)\n    div(class: \"card\", &)\n  end\n\n  def title(content)\n    div(content, class: \"card-title\")\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Updating Partial Rendering in Ruby\nDESCRIPTION: These snippets demonstrate the change in rendering Rails partials from Phlex, introducing the new partial method.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/v2-upgrade.md#2025-04-23_snippet_7\n\nLANGUAGE: ruby\nCODE:\n```\nrender \"foo\"\n```\n\nLANGUAGE: ruby\nCODE:\n```\nrender partial(\"foo\")\n```\n\n----------------------------------------\n\nTITLE: Defining a Component Test Helper Module in Ruby\nDESCRIPTION: Defines a Ruby module intended for test helper methods relevant to Phlex component testing. This module is meant to be included in component test classes, providing a reusable namespace for custom helper logic. No dependencies are required for declaring the module itself; helper methods can be added inside as needed.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/testing.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nmodule ComponentTestHelper\n  # helper methods here\nend\n```\n\n----------------------------------------\n\nTITLE: Using useData() API in Markdown/Vue\nDESCRIPTION: This snippet demonstrates how to import and use the useData() function from VitePress to access theme, page, and frontmatter data. It shows the setup in a script tag and how to display the data in the Markdown content.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/api-examples.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n<script setup>\nimport { useData } from 'vitepress'\n\nconst { theme, page, frontmatter } = useData()\n</script>\n\n## Results\n\n### Theme Data\n<pre>{{ theme }}</pre>\n\n### Page Data\n<pre>{{ page }}</pre>\n\n### Page Frontmatter\n<pre>{{ frontmatter }}</pre>\n```\n\n----------------------------------------\n\nTITLE: Card Component Usage Examples\nDESCRIPTION: Demonstrates different ways to instantiate and customize the Card component using various attributes.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/helpers.md#2025-04-23_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nrender Card.new(id: \"my-card\")\nrender Card.new(data: { controller: \"fancy-card\" })\nrender Card.new(class: \"purple-card\")\n```\n\n----------------------------------------\n\nTITLE: Importing useData in Vue Script Setup\nDESCRIPTION: This Vue script setup block imports the useData function from VitePress and destructures it to access site, theme, page, and frontmatter data. This data can then be used in the template to display information about the current page and site.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/api-examples.md#2025-04-23_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { useData } from 'vitepress'\n\nconst { site, theme, page, frontmatter } = useData()\n</script>\n```\n\n----------------------------------------\n\nTITLE: Collision-Safe Attribute Caching in Ruby\nDESCRIPTION: Implements a collision-safe caching mechanism that stores both the original attributes hash and the calculated HTML string, keyed by the hash integer.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/design/attribute-caching.md#2025-04-23_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nkey = attributes_hash.hash\ncached = CACHE[key]\n\nif cached && cached[0] == attributes_hash\n  cached[1]\nelse\n  CACHE[key] = [attributes_hash, calculate_attributes(attributes_hash)]\nend\n```\n\n----------------------------------------\n\nTITLE: HelloWorld Component HTML Output with Attributes\nDESCRIPTION: Shows the expected HTML output after adding class attributes to the `HelloWorld` component. Both divs now have their respective `class` attributes.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_12\n\nLANGUAGE: html\nCODE:\n```\n<div class=\"outer\"><div class=\"inner\">Hello, World!</div></div>\n```\n\n----------------------------------------\n\nTITLE: Final HelloWorld HTML Output Using Card DSL\nDESCRIPTION: Shows the final HTML output generated by `HelloWorld` after implementing and using the `Card` component's `title` DSL method. The text \"Hello, World!\" is now wrapped in a `<div class=\"card-title\">` inside the card.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_25\n\nLANGUAGE: html\nCODE:\n```\n<div class=\"outer\">\n  <div class=\"card\">\n    <div class=\"card-title\">Hello, World!</div>\n  </div>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Updating HelloWorld to Render Nested Card Component in Ruby\nDESCRIPTION: Modifies the `HelloWorld` component's `view_template` to use the `render` method. It renders an instance of the `Card` component inside the outer div, passing a block to `render` which defines the content of the card (the inner div).\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_17\n\nLANGUAGE: ruby\nCODE:\n```\nclass HelloWorld < Component\n  def view_template\n    div(class: \"outer\") {\n      render Card.new do\n        div(\"Hello, World!\", class: \"inner\")\n      end\n    }\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Running Spellcheck for Phlex.fun Documentation\nDESCRIPTION: Command to perform a spellcheck on the Phlex.fun documentation using Bun.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nbun run spellcheck\n```\n\n----------------------------------------\n\nTITLE: Updating `div` Method for Text Content Handling in Ruby\nDESCRIPTION: Modifies the `div` method in the `Component` class to accept an optional `content` argument. If `content` is provided, it's pushed to the buffer; otherwise, it yields to a block if given. This allows rendering text inside the div.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_7\n\nLANGUAGE: ruby\nCODE:\n```\ndef div(content = nil)\n  @buffer << \"<div>\"\n\n  if content\n    @buffer << content\n  elsif block_given?\n    yield\n  end\n\n  @buffer << \"</div>\"\nend\n```\n\n----------------------------------------\n\nTITLE: Including Kit Components\nDESCRIPTION: Demonstrates how to include a Kit to use its components without namespace qualification.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/kits.md#2025-04-23_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\nclass Example < Phlex::HTML\n  include Components\n\n  def view_template\n    Card(\"Hello, World!\") do\n      p { \"This is a card.\" }\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using Card's `title` DSL via Yielded Component Instance in Ruby\nDESCRIPTION: Updates `HelloWorld` to utilize the `Card`'s `title` method. The block passed to `render` now accepts the `Card` instance (`|card|`) which is yielded by the rendering process. This allows calling `card.title` directly within the block.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_22\n\nLANGUAGE: ruby\nCODE:\n```\nclass HelloWorld < Component\n  def view_template\n    div(class: \"outer\") {\n      render Card.new do |card|\n        card.title \"Hello, World!\"\n      end\n    }\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring VitePress Home Page Content - YAML\nDESCRIPTION: This snippet delineates the YAML-based configuration for the VitePress home page, specifying layout type, page titling, hero branding, and a set of detailed features for the Phlex documentation. It requires VitePress as a dependency, with structured properties for hero section and features collection, each allowing for styled presentation and external/internal links within the generated site. It does not process parameters programmatically but serves as the input for VitePress’s static site builder, with the expected output being an HTML-rendered home page. The configuration is static and expects to be read by VitePress during site generation.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/index.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n# https://vitepress.dev/reference/default-theme-home-page\nlayout: home\n\ntitle: Phlex\ntitleTemplate: View components in Ruby\ndescription: Phlex is a Ruby gem for building stunning server-side rendered object-oriented view components.\n\nhero:\n  name: \"Phlex\"\n  text: \"Stunning server-side rendered views\"\n  tagline: A little Ruby gem for building HTML and SVG view components.\n  actions:\n    - theme: brand\n      text: Documentation\n      link: /introduction\n    - theme: alt\n      text: GitHub Repo\n      link: https://github.com/phlex-ruby/phlex\n\nfeatures:\n  - title: Pure, beautiful Ruby\n    icon: 🧑‍🍳\n    details: Phlex gives you HTML semantics in Ruby so you can use your existing skills designing object-oriented views.\n  - title: Fast enough\n    icon: 🚀\n    details: Phlex renders HTML at ~1.4gbps per core on a MacBook Pro (M3 Max) and it doesn’t slow exponentially the more components you extract.\n  - title: Rails integration\n    icon: 🚂\n    details: Phlex works great with Rails. It supports all Rails helpers and plays nicely with ERB, ViewComponent, Stimulus, Turbo and Tailwind.\n  - title: Ruby tooling\n    icon: 🧰\n    details: Use tools like RubyLSP, RuboCop and SimpleCov.\n  - title: Kits\n    link: /components/kits\n    icon: 🎒\n    details: Package up components into Kits (Ruby modules) for easy reuse across projects.\n  - title: Structural safety\n    link: /miscellaneous/structural-safety\n    icon: 🛡️\n    details: Phlex is designed to structurally prevent cross-site-scripting (XSS) attacks.\n  - title: Sensible isolation\n    icon: 🧪\n    details: Phlex components only depend on the data you pass in, making them easier to test and reuse.\n  - title: Selective rendering\n    link: /components/fragments\n    icon: 🔎\n    details: Render a view targeting a specific fragment of HTML and Phlex only does the work to render just the parts you want.\n  - title: Streaming\n    link: /components/streaming\n    icon: 🌊\n    details: Phlex can stream responses to improve time-to-first-byte (TTFB). Let users see content before the database has even responded.\n  - title: Fragment caching\n    link: /components/caching\n    icon: 💵\n    details: Rails-compatible fragment caching lets you control how different parts of your view are cached.\n  - title: HTML / SVG string-builder\n    icon: 🧵\n    details: You can also use the Phlex DSL to build HTML and SVG strings directly, without creating a component class.\n```\n\n----------------------------------------\n\nTITLE: Creating a Class-based Phlex Component\nDESCRIPTION: Demonstrates how to upgrade a simple method component to a full Ruby class component with configuration options. This class-based approach allows for more sophisticated components with initialization parameters.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/compare/slim.md#2025-04-23_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nclass Components::MyButton < Components::Base\n  def initialize(style:, color:)\n    @style = style\n    @color = color\n  end\n\n  def view_template(&)\n    button(class: [@style, @color], &)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Updating HelloWorld to Use `plain` Method in Ruby\nDESCRIPTION: Modifies the `HelloWorld` component to use the new `plain` method within the block passed to `render Card.new`. This renders the \"Hello, World!\" text directly inside the card, replacing the inner div.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_20\n\nLANGUAGE: ruby\nCODE:\n```\nclass HelloWorld < Component\n  def view_template\n    div(class: \"outer\") {\n      render Card.new do\n        plain \"Hello, World!\"\n      end\n    }\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Updating Selective Rendering in Ruby\nDESCRIPTION: These snippets show the changes in selective rendering between Phlex v1 and v2, demonstrating the new explicit fragment declaration.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/v2-upgrade.md#2025-04-23_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\n# Before (Phlex ~> 1.10)\ndef view_template\n  section do\n    ul(id: \"the-list\") do  # Could target this by ID\n      li { \"Item 1\" }\n      li { \"Item 2\" }\n    end\n  end\nend\n\n# Usage:\ncomponent.call(fragments: [\"the-list\"])\n```\n\nLANGUAGE: ruby\nCODE:\n```\n# After (Phlex 2.0)\ndef view_template\n  section do\n    fragment(\"the-list\") do  # Explicitly declare renderable fragment\n      ul(id: \"the-list\") do\n        li { \"Item 1\" }\n        li { \"Item 2\" }\n      end\n    end\n  end\nend\n\n# Usage remains the same:\ncomponent.call(fragments: [\"the-list\"])\n```\n\n----------------------------------------\n\nTITLE: Kit Method Definition Example\nDESCRIPTION: Illustrates the implicit method definition that Kits create for components.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/components/kits.md#2025-04-23_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nmodule Components\n  def Card(...)\n    render Card.new(...)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Extending Literal::Properties in Phlex Base Component\nDESCRIPTION: This snippet shows how to extend the Literal::Properties module in a base Phlex component class. This allows the use of the 'prop' method in all derived component classes.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/literal-properties.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nclass Components::Base < Phlex::HTML\n  extend Literal::Properties\nend\n```\n\n----------------------------------------\n\nTITLE: Extending turbo_frame Method in Ruby\nDESCRIPTION: This snippet shows how to automatically make all Turbo Frames selectively renderable by extending the turbo_frame method.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/v2-upgrade.md#2025-04-23_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\ndef turbo_frame(id:, ...)\n  fragment(id) { super }\nend\n```\n\n----------------------------------------\n\nTITLE: Updating HelloWorld Component with Text Content in Ruby\nDESCRIPTION: Updates the `HelloWorld` component's `view_template` to pass a string \"Hello, World!\" as the content to the inner `div` call, utilizing the updated `div` method.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_8\n\nLANGUAGE: ruby\nCODE:\n```\nclass HelloWorld < Component\n  def view_template\n    div {\n      div(\"Hello, World!\")\n    }\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: HTML Doctype Declaration Output\nDESCRIPTION: This snippet shows the resulting HTML output when the `doctype` method is called in a Phlex component. It is the standard `<!doctype html>` declaration which signifies an HTML5 document to the browser.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/sgml/doctype.md#2025-04-23_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<!doctype html>\n```\n\n----------------------------------------\n\nTITLE: Counting Phlex HTML Components in Rails Console (Ruby)\nDESCRIPTION: This Ruby code snippet, intended for use in the Rails console (`rails c`), counts the total number of classes that inherit from `Phlex::HTML`. It serves as a metric for tracking the adoption of Phlex components within a Rails application. Requires Phlex to be loaded in the environment.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/rails/adopting-phlex.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nPhlex::HTML.descendants.size\n```\n\n----------------------------------------\n\nTITLE: HTML Output with Nested Card Component\nDESCRIPTION: Shows the expected HTML output after nesting the `Card` component within `HelloWorld`. The structure now includes the `<div class=\"card\">` element wrapping the inner content.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_18\n\nLANGUAGE: html\nCODE:\n```\n<div class=\"outer\">\n  <div class=\"card\">\n    <div class=\"inner\">Hello, World!</div>\n  </div>\n</div>\n```\n\n----------------------------------------\n\nTITLE: HelloWorld Component HTML Output with Text Content\nDESCRIPTION: Shows the expected HTML output after updating the `HelloWorld` component to include text content. The inner div now contains the text \"Hello, World!\".\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_9\n\nLANGUAGE: html\nCODE:\n```\n<div><div>Hello, World!</div></div>\n```\n\n----------------------------------------\n\nTITLE: Setting Up the Phlex.fun Development Environment with Bun\nDESCRIPTION: Steps for setting up the Phlex.fun project locally using Bun package manager, including installation, dependencies setup, and launching the development server.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncd into the project directory\nbun install\nbun run docs:dev\n```\n\n----------------------------------------\n\nTITLE: Initial HelloWorld Component HTML Output\nDESCRIPTION: Shows the expected HTML output generated by calling the initial `HelloWorld` component. It consists of a simple `<div>` element nested inside another `<div>`.\nSOURCE: https://github.com/phlex-ruby/phlex.fun/blob/main/miscellaneous/under-the-hood.md#2025-04-23_snippet_6\n\nLANGUAGE: html\nCODE:\n```\n<div><div></div></div>\n```"
  }
]