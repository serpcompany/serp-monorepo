[
  {
    "owner": "arktypeio",
    "repo": "arktype",
    "content": "TITLE: Defining Divisible Numbers with String Syntax in ArkType\nDESCRIPTION: Shows how to constrain a number to be divisible by a specific integer using string syntax in ArkType.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst Evens = type({\n\tkey: \"number % 2\"\n})\n```\n\n----------------------------------------\n\nTITLE: Decoupling Types for Reusability in ArkType with TypeScript\nDESCRIPTION: Demonstrates how to create separate, reusable type definitions in ArkType. The 'Device' type is defined independently and then used within the 'User' type.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/intro/your-first-type.mdx#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst Device = type({\n\tplatform: \"'android' | 'ios'\",\n\t\"versions?\": \"(number | string)[]\"\n})\n\nconst User = type({\n\tname: \"string\",\n\tdevice: Device\n})\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic User Type with ArkType in TypeScript\nDESCRIPTION: Demonstrates how to define a simple User type using ArkType's 'type' function. It includes string, union, and optional array properties, and shows how to extract the TypeScript type.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/intro/your-first-type.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type } from \"arktype\"\n\nconst User = type({\n\tname: \"string\",\n\tplatform: \"'android' | 'ios'\",\n\t\"versions?\": \"(number | string)[]\"\n})\n\n// extract the type if needed\ntype User = typeof User.infer\n```\n\n----------------------------------------\n\nTITLE: Comparing Pattern Matching Performance: ArkType vs ts-pattern\nDESCRIPTION: Demonstrates the performance advantage of ArkType's pattern matching versus ts-pattern when converting values to JSON. The example shows how to handle different data types including primitives, bigints, and objects with significantly lower execution times.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/blog/2.1.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @noErrors\nconst toJsonArkType = match({\n\t\"string | number | boolean | null\": v => v,\n\tbigint: b => `${b}n`,\n\tobject: o => {\n\t\tfor (const k in o) {\n\t\t\to[k] = toJsonArkType(o[k])\n\t\t}\n\t\treturn o\n\t},\n\tdefault: \"assert\"\n})\n\nconst toJsonTsPattern = (value: unknown) =>\n\ttsPatternMatch(value)\n\t\t.with(P.union(P.string, P.number, P.boolean, null), v => v)\n\t\t.with(P.bigint, v => `${v}n`)\n\t\t.with({}, o => {\n\t\t\tfor (const k in o) {\n\t\t\t\to[k] = toJsonTsPattern(o[k])\n\t\t\t}\n\t\t\treturn o\n\t\t})\n\t\t.otherwise(() => {\n\t\t\tthrow new Error(\"value is not valid JSON\")\n\t\t})\n\n// \"foo\" (9 nanoseconds)\ntoJsonArkType(\"foo\")\n// \"foo\" (765 nanoseconds)\ntoJsonTsPattern(\"foo\")\n\n// \"5n\" (33 nanoseconds)\ntoJsonArkType(5n)\n// \"5n\" (924 nanoseconds)\ntoJsonTsPattern(5n)\n\n// { nestedValue: \"5n\" } (44 nanoseconds)\ntoJsonArkType({ nestedValue: 5n })\n// { nestedValue: \"5n\" } (2080 nanoseconds)\ntoJsonTsPattern({ nestedValue: 5n })\n```\n\n----------------------------------------\n\nTITLE: Defining Required Properties in ArkType Objects (TypeScript)\nDESCRIPTION: Demonstrates how to define required properties in ArkType objects using both string and fluent syntax. Includes an example of using symbolic keys and nested definitions.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/objects/index.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst symbolicKey = Symbol()\n\nconst MyObj = type({\n\trequiredKey: \"string\",\n\t// Nested definitions don't require additional `type` calls!\n\t[symbolicKey]: {\n\t\tnested: \"unknown\"\n\t}\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst symbolicKey = Symbol()\n\nconst MyObj = type({\n\trequiredKey: type.string,\n\t// Nested definitions don't require additional `type` calls!\n\t[symbolicKey]: {\n\t\tnested: type.unknown\n\t}\n})\n```\n\n----------------------------------------\n\nTITLE: Runtime Validation with Error Handling using ArkType in TypeScript\nDESCRIPTION: Illustrates how to perform runtime validation using an ArkType-defined type. It includes error handling for invalid input, demonstrating ArkType's ability to provide detailed error messages.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/intro/your-first-type.mdx#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst User = type({\n\tname: \"string\",\n\tdevice: {\n\t\tplatform: \"'android' | 'ios'\",\n\t\t\"versions?\": \"(number | string)[]\"\n\t}\n})\n\ninterface RuntimeErrors extends type.errors {\n\t/**device.platform must be \"android\" or \"ios\" (was \"enigma\")\ndevice.versions[2] must be a number or a string (was bigint)*/\n\tsummary: string\n}\n\nconst narrowMessage = (e: type.errors): e is RuntimeErrors => true\n\nconst out = User({\n\tname: \"Alan Turing\",\n\tdevice: {\n\t\tplatform: \"enigma\",\n\t\tversions: [0, \"1\", 0n]\n\t}\n})\n\nif (out instanceof type.errors) {\n\tconsole.error(out.summary)\n} else {\n\tconsole.log(`Hello, ${out.name}`)\n}\n```\n\n----------------------------------------\n\nTITLE: Using Undefined in Union Types with Fluent Syntax in ArkType\nDESCRIPTION: Shows how to use undefined in a union type and optional properties using fluent syntax in ArkType.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nconst MyObj = type({\n\trequiredKey: type.number.or(type.undefined),\n\toptionalKey: type.number.or(type.undefined).optional()\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Optional Properties in ArkType Objects (TypeScript)\nDESCRIPTION: Shows how to define optional properties in ArkType objects using string, fluent, and tuple syntax. Includes examples of using symbolic keys and array types.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/objects/index.mdx#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst symbolicKey = Symbol()\n\nconst MyObj = type({\n\t\"optionalKey?\": \"number[]\",\n\t[symbolicKey]: \"string?\"\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst symbolicKey = Symbol()\n\nconst MyObj = type({\n\toptionalKey: type.number.array().optional(),\n\t[symbolicKey]: type.string.optional()\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst symbolicKey = Symbol()\n\nconst MyObj = type({\n\toptionalKey: [{ type: \"'script'\" }, \"?\"],\n\t[symbolicKey]: [{ ark: \"'type'\" }, \"?\"]\n})\n```\n\n----------------------------------------\n\nTITLE: Composing Nested Types with ArkType in TypeScript\nDESCRIPTION: Shows how to create nested type definitions in ArkType, moving the 'platform' and 'version' properties into a new 'device' object within the User type.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/intro/your-first-type.mdx#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst User = type({\n\tname: \"string\",\n\t// nested definitions don't need to be wrapped\n\tdevice: {\n\t\tplatform: \"'android' | 'ios'\",\n\t\t\"versions?\": \"(number | string)[]\"\n\t}\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Types Using Basic TypeScript Keywords in ArkType\nDESCRIPTION: Demonstrates how to use built-in TypeScript keywords like 'string' and 'Date' in ArkType's type definition system using string-based syntax. This is a basic way to define types that correspond to TypeScript's native types.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/keywords.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Keywords = type({\n\tstring: \"string\",\n\tdate: \"Date\"\n})\n```\n\n----------------------------------------\n\nTITLE: Handling Undeclared Properties in ArkType Objects (TypeScript)\nDESCRIPTION: Demonstrates how to handle undeclared properties in ArkType objects using string and fluent syntax. Includes examples of rejecting, deleting, and ignoring undeclared keys.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/objects/index.mdx#2025-04-11_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// fail if any key other than \"onlyAllowedKey\" is present\nconst MyClosedObject = type({\n\t\"+\": \"reject\",\n\tonlyAllowedKey: \"string\"\n})\n\n// delete all non-symbolic keys other than \"onlyPreservedStringKey\"\nconst MyStrippedObject = type({\n\t\"+\": \"delete\",\n\t\"[symbol]\": \"unknown\",\n\tonlyPreservedStringKey: \"string\"\n})\n\n// allow and preserve undeclared keys (the default behavior)\nconst MyOpenObject = type({\n\t// only specify \"ignore\" if you explicitly configured the default elsewhere\n\t\"+\": \"ignore\",\n\tnonexclusiveKey: \"number\"\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// fail if any key other than \"onlyAllowedKey\" is present\nconst MyClosedObject = type({\n\tonlyAllowedKey: \"string\"\n}).onUndeclaredKey(\"reject\")\n\n// delete all non-symbolic keys other than \"onlyPreservedStringKey\"\nconst MyStrippedObject = type({\n\t\"[symbol]\": \"unknown\",\n\tonlyPreservedStringKey: \"string\"\n}).onUndeclaredKey(\"delete\")\n\n// allow and preserve undeclared keys (the default behavior)\nconst MyOpenObject = type({\n\tnonexclusiveKey: \"number\"\n\t// only specify \"ignore\" if you explicitly configured the default elsewhere\n}).onUndeclaredKey(\"ignore\")\n\n// there is also a method for altering nested objects recursively\nconst MyDeeplyStrippedObject = type({\n\tpreserved: \"string\",\n\tnested: {\n\t\tpreserved: \"string\"\n\t}\n}).onDeepUndeclaredKey(\"delete\")\n```\n\n----------------------------------------\n\nTITLE: Defining Types with Constraints in TypeScript using ArkType\nDESCRIPTION: Creates a Contact type with constraints for an email field and a score that must be an integer less than 100. Shows how to infer the TypeScript type from the ArkType definition.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/intro/adding-constraints.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Contact = type({\n\t// many common constraints are available as builtin keywords\n\temail: \"string.email\",\n\t// others can be written as type-safe expressions\n\tscore: \"number.integer < 100\"\n})\n\n// if you need the TS type, just infer it out as normal\ntype Contact = typeof Contact.infer\n```\n\n----------------------------------------\n\nTITLE: Configuring Undeclared Key Behavior in ArkType\nDESCRIPTION: Demonstrates how to change the default behavior for handling undeclared keys during validation, choosing between ignoring, deleting, or rejecting undeclared properties.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/configuration/index.mdx#2025-04-11_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configure } from \"arktype/config\"\n\nconfigure({ onUndeclaredKey: \"delete\" })\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport \"./config.ts\"\n// import your config file before arktype\nimport { type } from \"arktype\"\n\nconst UserForm = type({\n\tname: \"string\"\n})\n\n// out is now { name: \"Alice\" }\nconst out = UserForm({\n\tname: \"Alice\",\n\tage: \"42\"\n})\n```\n\n----------------------------------------\n\nTITLE: Creating JSON Parser with ArkType in TypeScript\nDESCRIPTION: Shows how to create a JSON parser using ArkType's type function with string methods and custom type definitions.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/faq.mdx#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst parseJson = type(\"string.json.parse\").to({\n\tname: \"string\",\n\tversion: \"string.semver\"\n})\n```\n\n----------------------------------------\n\nTITLE: Defining User Type with ArkType in TypeScript\nDESCRIPTION: Demonstrates how to define a User type using ArkType's type function. It includes string and union types for properties, as well as an optional property.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/faq.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst User = type({\n\tname: \"string\",\n\tplatform: \"'android' | 'ios'\",\n\t\"version?\": \"number | string\"\n})\n```\n\n----------------------------------------\n\nTITLE: Customizing Complete Error Messages with Path Information\nDESCRIPTION: Shows how to use the 'message' option to completely customize error messages including the path at which the error occurred, providing more context for nested validation errors.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/configuration/index.mdx#2025-04-11_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst User = type({\n\tpassword: \"string >= 8\"\n}).configure({\n\tmessage: ctx =>\n\t\t`${ctx.propString || \"(root)\"}: ${ctx.actual} isn't ${ctx.expected}`\n})\n// ArkErrors: (root): a string isn't an object\nconst out1 = User(\"ez123\")\n// `.configure` only applies shallowly, so the nested error isn't changed!\n// ArkErrors: password must be at least length 8 (was 5)\nconst out2 = User({ password: \"ez123\" })\n```\n\n----------------------------------------\n\nTITLE: Composing Types with Constraints in TypeScript using ArkType\nDESCRIPTION: Demonstrates how to create and extend types with constraints using ArkType, then create a non-empty array type from the defined Contact type using the chain syntax.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/intro/adding-constraints.mdx#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst _Contact = type({\n\temail: \"string.email\",\n\tscore: \"number.integer < 100\"\n})\n\ntype _Contact = typeof _Contact.t\n\ninterface Contact extends _Contact {}\n\nexport const Contact: type<Contact> = _Contact\n// a non-empty list of Contact\nconst Contacts = Contact.array().atLeastLength(1)\n```\n\n----------------------------------------\n\nTITLE: Narrowing Types with Custom Validation in TypeScript using ArkType\nDESCRIPTION: Shows how to use custom validation logic with ArkType's narrow method to create an 'Odd' type, then compose it with other constraints to validate user input and handle validation errors.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/intro/adding-constraints.mdx#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface RuntimeErrors extends type.errors {\n\t/**even must be even (was 7)\nodd must be odd (was 8)*/\n\tsummary: string\n}\n\nconst narrowMessage = (e: type.errors): e is RuntimeErrors => true\n\n// there's no \"not divisible\" expression - need to narrow\nconst Odd = type(\"number\").narrow((n, ctx) =>\n\t// if even, add a customizable error and return false\n\tn % 2 === 0 ? ctx.mustBe(\"odd\") : true\n)\n\nconst FavoriteNumbers = type({\n\teven: \"number % 2\",\n\todd: Odd\n})\n\nconst out = FavoriteNumbers({\n\teven: 7,\n\todd: 8\n})\n\nif (out instanceof type.errors) {\n\t// hover summary to see validation errors\n\tconsole.error(out.summary)\n} else {\n\tconsole.log(out.odd)\n}\n```\n\n----------------------------------------\n\nTITLE: Using type.module Shorthand in ArkType\nDESCRIPTION: Shows how to use the type.module shorthand for inline scope export, which is syntactic sugar for scope({...}).export().\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/scopes/index.mdx#2025-04-11_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst ezModule = type.module({\n\tEz: \"'moochi'\"\n})\n```\n\n----------------------------------------\n\nTITLE: Chaining Validation with Pipe Method in TypeScript\nDESCRIPTION: Shows how to chain multiple validation steps by piping the output of JSON parsing to another type validator, providing both parsing and schema validation in one operation.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/intro/morphs-and-more.mdx#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst parseJson = type(\"string\").pipe.try(\n\t(s): object => JSON.parse(s),\n\ttype({\n\t\tname: \"string\",\n\t\tversion: \"string.semver\"\n\t})\n)\n\nconst out = parseJson('{ \"name\": \"arktype\", \"version\": \"2.0.0\" }')\n\nif (!(out instanceof type.errors)) {\n\t// Logs \"arktype:2.0.0\"\n\tconsole.log(`${out.name}:${out.version}`)\n}\n```\n\n----------------------------------------\n\nTITLE: Basic JSON Parsing with Pipe in TypeScript\nDESCRIPTION: Demonstrates how to use ArkType's pipe method to transform a string into an object by parsing JSON. Shows both successful parsing and error handling when invalid input is provided.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/intro/morphs-and-more.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Hover to see the type-level representation\nconst parseJson = type(\"string\").pipe((s): object => JSON.parse(s))\n\n// object: { ark: \"type\" }\nconst out = parseJson('{ \"ark\": \"type\" }')\n\n// ArkErrors: must be a string (was object)\nconst badOut = parseJson(out)\n```\n\n----------------------------------------\n\nTITLE: Creating a Configured Scope in ArkType\nDESCRIPTION: Shows how to create a configured scope in ArkType where configurations apply to all Types parsed within that scope, including custom error messages.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/configuration/index.mdx#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst myScope = scope(\n\t{ User: { age: \"number < 100\" } },\n\t{\n\t\tmax: {\n\t\t\tactual: () => \"unacceptably large\"\n\t\t}\n\t}\n)\nconst types = myScope.export()\n// ArkErrors: age must be less than 100 (was unacceptably large)\ntypes.User({ name: \"Alice\", age: 101 })\nconst parsedAfter = myScope.type({\n\tage: \"number <= 100\"\n})\n// ArkErrors: age must be at most 100 (was unacceptably large)\nparsedAfter({ age: 101 })\n```\n\n----------------------------------------\n\nTITLE: Integrating ArkType with oRPC for Input Validation in TypeScript\nDESCRIPTION: This snippet demonstrates how to use ArkType with oRPC, which has built-in support for Standard Schema. It shows how to define input validation using ArkType types.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/integrations/index.mdx#2025-04-11_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// @noErrors\nos.input(\n\ttype({\n\t\tname: \"string\",\n\t\t\"age?\": \"number\"\n\t})\n)\n```\n\n----------------------------------------\n\nTITLE: Integrating ArkType with react-hook-form in TypeScript\nDESCRIPTION: This snippet illustrates how to use ArkType with react-hook-form via the @hookform/resolvers package. It shows the creation of a User type and its integration with useForm for form validation.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/integrations/index.mdx#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// @noErrors\nimport { useForm } from \"react-hook-form\"\nimport { arktypeResolver } from \"@hookform/resolvers/arktype\"\nimport { type } from \"arktype\"\n\nconst User = type({\n\tfirstName: \"string\",\n\tage: \"number.integer > 0\"\n})\n\n// in your component\nconst {\n\tregister,\n\thandleSubmit,\n\tformState: { errors }\n} = useForm({\n\tresolver: arktypeResolver(user)\n})\n```\n\n----------------------------------------\n\nTITLE: Using the Case Record API for Type Matching in TypeScript\nDESCRIPTION: Demonstrates the basic Case Record API of the match function, using ArkType definition strings as keys with corresponding handlers as values. Shows how to handle different types (string, array, number, bigint) and define default behavior.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/match.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { match } from \"arktype\"\n\nconst sizeOf = match({\n\t\"string | Array\": v => v.length,\n\tnumber: v => v,\n\tbigint: v => v,\n\tdefault: \"assert\"\n})\n\n// a match definition is complete once a `default` has been specified,\n// either as a case or via the .default() method\n\nsizeOf(\"abc\") // 3\nsizeOf([1, 2, 3, 4]) // 4\nsizeOf(5n) // 5n\n// ArkErrors: must be an object, a string, a number or a bigint (was boolean)\nsizeOf(true)\n```\n\n----------------------------------------\n\nTITLE: Using Built-in JSON Parsing with ArkType in TypeScript\nDESCRIPTION: Demonstrates ArkType's built-in string.json.parse alias combined with the .to method for a cleaner implementation of JSON parsing and validation.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/intro/morphs-and-more.mdx#2025-04-11_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ninterface RuntimeErrors extends type.errors {\n\t/**name must be a string (was true) \nversion must be a semantic version (see https://semver.org/) (was \"v2.0.0\")*/\n\tsummary: string\n}\n\nconst narrowMessage = (e: type.errors): e is RuntimeErrors => true\n\n// ---cut---\n// .to is a sugared .pipe for a single parsed output validator\nconst parseJson = type(\"string.json.parse\").to({\n\tname: \"string\",\n\tversion: \"string.semver\"\n})\n\nconst out = parseJson('{ \"name\": true, \"version\": \"v2.0.0\" }')\n\nif (out instanceof type.errors) {\n\t// ---cut-start---\n\tif (!narrowMessage(out)) throw new Error()\n\t// ---cut-end---\n\t// hover out.summary to see the default error message\n\tconsole.error(out.summary)\n}\n```\n\n----------------------------------------\n\nTITLE: Default Attest Configuration\nDESCRIPTION: The default configuration options for Attest, showing all available settings and their default values.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/attest/README.md#2025-04-11_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport const getDefaultAttestConfig = (): BaseAttestConfig => ({\n\ttsconfig:\n\t\texistsSync(fromCwd(\"tsconfig.json\")) ? fromCwd(\"tsconfig.json\") : undefined,\n\tattestAliases: [\"attest\", \"attestInternal\"],\n\tupdateSnapshots: false,\n\tskipTypes: false,\n\tskipInlineInstantiations: false,\n\ttsVersions: \"typescript\",\n\tbenchPercentThreshold: 20,\n\tbenchErrorOnThresholdExceeded: true,\n\tfilter: undefined,\n\ttestDeclarationAliases: [\"bench\", \"it\", \"test\"],\n\tformatter: `npm exec --no -- prettier --write`,\n\tshouldFormat: true,\n\ttypeToStringFormat: {}\n})\n```\n\n----------------------------------------\n\nTITLE: Defining and Instantiating Generics in ArkType\nDESCRIPTION: Demonstrates how to define and instantiate generics using ArkType's 'type' function. It creates a generic 'boxOf' type and instantiates it with a specific structure.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/generics/index.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type } from \"arktype\"\n\nconst boxOf = type(\"<t>\", { box: \"t\" })\n\n// hover me!\nconst schrodingersBox = boxOf({ cat: { isAlive: \"boolean\" } })\n```\n\n----------------------------------------\n\nTITLE: Using ArkType with Hono for Request Validation in TypeScript\nDESCRIPTION: This example shows how to use ArkType with Hono via the @hono/arktype-validator package. It demonstrates creating a User type and using it for JSON request validation in a POST route.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/integrations/index.mdx#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// @noErrors\nconst User = type({\n\tname: \"string\",\n\tage: \"number\"\n})\n\napp.post(\"/author\", arktypeValidator(\"json\", user), c => {\n\tconst data = c.req.valid(\"json\")\n\treturn c.json({\n\t\tsuccess: true,\n\t\tmessage: `${data.name} is ${data.age}`\n\t})\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Grammar Settings for TypeScript with ArkType\nDESCRIPTION: JSON configuration for testing standalone TypeScript with ArkType highlighting rules in package.json. This temporary configuration should be used only during testing and reverted before publishing.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/extension/README.md#2025-04-11_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n\"grammars\": {\n\t\"scopeName\": \"source.ts\",\n\t\"language\": \"typescript\",\n\t\"path\": \"tsWithArkType.tmLanguage.json\"\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Case Record and Fluent APIs for Advanced Matching\nDESCRIPTION: Shows how to combine the Case Record and Fluent APIs. The example matches strings, numbers, and bigints directly, then uses the fluent API to match objects with a numeric length property, and provides a default fallback.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/match.mdx#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { match } from \"arktype\"\n\n// the Case Record and Fluent APIs can be easily combined\nconst sizeOf = match({\n\tstring: v => v.length,\n\tnumber: v => v,\n\tbigint: v => v\n})\n\t// match any object with a numeric length property and extract it\n\t.case({ length: \"number\" }, o => o.length)\n\t// return 0 for all other data\n\t.default(() => 0)\n\nsizeOf(\"abc\") // 3\nsizeOf({ name: \"David\", length: 5 }) // 5\nsizeOf(null) // 0\n```\n\n----------------------------------------\n\nTITLE: Input Narrowing and Property Matching with in and at Methods\nDESCRIPTION: Demonstrates using specialized match methods for input narrowing and property-based matching. Uses the .in<T>() method to specify the TypeScript type, and .at() to match based on a specific property (in this case, discriminating by 'id').\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/match.mdx#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// @errors: 2345\nimport { match } from \"arktype\"\n\ntype Data =\n\t| {\n\t\t\tid: 1\n\t\t\toneValue: number\n\t  }\n\t| {\n\t\t\tid: 2\n\t\t\ttwoValue: string\n\t  }\n\nconst discriminateValue = match\n\t// .in allows you to specify the input TypeScript allows for your matcher\n\t.in<Data>()\n\t// .at allows you to specify a key at which your input will be matched\n\t.at(\"id\")\n\t.match({\n\t\t1: o => `${o.oneValue}!`,\n\t\t2: o => o.twoValue.length,\n\t\tdefault: \"assert\"\n\t})\n\ndiscriminateValue({ id: 1, oneValue: 1 }) // \"1!\"\ndiscriminateValue({ id: 2, twoValue: \"two\" }) // 3\ndiscriminateValue({ oneValue: 3 })\n```\n\n----------------------------------------\n\nTITLE: Using Match with Fluent API in ArkType\nDESCRIPTION: Demonstrates ArkType's match function with the Fluent API for more complex pattern matching scenarios. The example combines Case Record and Fluent APIs to match objects with specific properties.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/blog/2.1.mdx#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// the Case Record and Fluent APIs can be easily combined\nconst sizeOf = match({\n\tstring: v => v.length,\n\tnumber: v => v,\n\tbigint: v => v\n})\n\t// match any object with a numeric length property and extract it\n\t.case({ length: \"number\" }, o => o.length)\n\t// return 0 for all other data\n\t.default(() => 0)\n\nsizeOf(\"abc\") // 3\nsizeOf({ name: \"David\", length: 5 }) // 5\nsizeOf(null) // 0\n```\n\n----------------------------------------\n\nTITLE: Integrating ArkType with tRPC in TypeScript\nDESCRIPTION: This snippet shows how to use ArkType types with tRPC procedures for input validation. It covers both tRPC versions 11 and above, and versions below 11.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/integrations/index.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @noErrors\n// trpc >= 11 accepts a Type directly\nt.procedure.input(\n\ttype({\n\t\tname: \"string\",\n\t\t\"age?\": \"number\"\n\t})\n)\n\n// tRPC < 11 accepts the `.assert` prop\nt.procedure.input(\n\ttype({\n\t\tname: \"string\",\n\t\t\"age?\": \"number\"\n\t}).assert\n)\n```\n\n----------------------------------------\n\nTITLE: Using Match with 'in' and 'at' for Discriminated Unions\nDESCRIPTION: Shows how to use ArkType's match function with discriminated unions. The example uses the .in method to specify the input type and .at method to specify which property to match against.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/blog/2.1.mdx#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// @errors: 2345\ntype Data =\n\t| {\n\t\t\tid: 1\n\t\t\toneValue: number\n\t  }\n\t| {\n\t\t\tid: 2\n\t\t\ttwoValue: string\n\t  }\n\nconst discriminateValue = match\n\t// .in allows you to specify the input TypeScript allows for your matcher\n\t.in<Data>()\n\t// .at allows you to specify a key at which your input will be matched\n\t.at(\"id\")\n\t.match({\n\t\t1: o => `${o.oneValue}!`,\n\t\t2: o => o.twoValue.length,\n\t\tdefault: \"assert\"\n\t})\n\ndiscriminateValue({ id: 1, oneValue: 1 }) // \"1!\"\ndiscriminateValue({ id: 2, twoValue: \"two\" }) // 3\ndiscriminateValue({ oneValue: 3 })\n```\n\n----------------------------------------\n\nTITLE: Exporting a Scope to a Module for Runtime Validation\nDESCRIPTION: Demonstrates how to export a scope to a module for runtime validation. Shows error handling when validating user data with custom error types.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/scopes/index.mdx#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst coolScope = scope({\n\tId: \"string\",\n\tUser: { id: \"Id\", friends: \"Id[]\" },\n\tUsersById: {\n\t\t\"[Id]\": \"User | undefined\"\n\t}\n})\n\ninterface RuntimeErrors extends type.errors {\n\t/**friends[1] must be a string (was a number)*/\n\tsummary: string\n}\n\nconst narrowMessage = (e: type.errors): e is RuntimeErrors => true\n\nconst coolModule = coolScope.export()\n\nconst out = coolModule.User({\n\tid: \"99\",\n\tfriends: [\"7\", 8, \"9\"]\n})\n\nif (out instanceof type.errors) {\n\t// hover summary to see validation errors\n\tconsole.error(out.summary)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Enumerated Types in TypeScript with ArkType\nDESCRIPTION: Shows how to create types from a set of allowed values using type.enumerated and alternative syntaxes.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySymbol = Symbol()\n\nconst ExactValueFromSet = type.enumerated(1337, true, mySymbol)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySymbol = Symbol()\n\nconst ExactValueFromSet = type([\"===\", 1337, true, mySymbol])\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySymbol = Symbol()\n\nconst ExactValueFromSet = type(\"===\", 1337, true, mySymbol)\n```\n\n----------------------------------------\n\nTITLE: Defining String Types with Keywords in ArkType\nDESCRIPTION: Examples of using string keywords to define email, JSON, and UUID types in ArkType. Keywords can be referenced in type definitions to create specialized string types.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst Email = type(\"string.email\")\n\nconst User = type({\n\tdata: \"string.json.parse\",\n\tids: \"string.uuid.v4[]\"\n})\n```\n\n----------------------------------------\n\nTITLE: Defining String Patterns with Regular Expressions in ArkType\nDESCRIPTION: Shows how to create string patterns using regular expressions in ArkType, either as string-embedded regex or direct RegExp instances.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst Literals = type({\n\tstringEmbedded: \"/^a.*z$/\",\n\tregexLiteral: /^a.*z$/\n})\n```\n\n----------------------------------------\n\nTITLE: Using Match with Case Record API in ArkType\nDESCRIPTION: Shows the basic usage of ArkType's match function with the Case Record API. The example demonstrates how to handle different input types (string, array, number, bigint) and define a default case for assertion.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/blog/2.1.mdx#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { match } from \"arktype\"\n\nconst sizeOf = match({\n\t\"string | Array\": v => v.length,\n\tnumber: v => v,\n\tbigint: v => v,\n\tdefault: \"assert\"\n})\n\n// a match definition is complete once a `default` has been specified,\n// either as a case or via the .default() method\n\nsizeOf(\"abc\") // 3\nsizeOf([1, 2, 3, 4]) // 4\nsizeOf(5n) // 5n\n// ArkErrors: must be an object, a string, a number or a bigint (was boolean)\nsizeOf(true)\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Box Creator in TypeScript\nDESCRIPTION: Demonstrates two methods of creating a generic box function using ArkType: one with explicit casting and another using function overloads.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/faq.mdx#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// via explicit cast\nconst createBox = <const def>(\n\tof: type.validate<def>\n): type.instantiate<{ of: def }> =>\n\ttype.raw({\n\t\tbox: of\n\t\t// when implementing generics, never is your go-to\n\t\t// for allowing an arbitrary assignment with less risk than `any`\n\t}) as never\n\n// via overloads\n// only the external signatures are considered on invocation\nfunction createBox2<const def>(\n\tof: type.validate<def>\n): type.instantiate<{ of: def }>\n// the signature associated with the implementation is much looser and should\n// be thought of as equivalent to casting in terms of type safety\nfunction createBox2(of: unknown) {\n\treturn type.raw({\n\t\tbox: of\n\t})\n}\n```\n\n----------------------------------------\n\nTITLE: Using ArkType's Fluent Pattern Matching API\nDESCRIPTION: Shows how to use the fluent API for pattern matching, combining Case Record and Fluent APIs for more complex matching scenarios including object properties.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/type/CHANGELOG.md#2025-04-11_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst sizeOf = match({\n\tstring: v => v.length,\n\tnumber: v => v,\n\tbigint: v => v\n})\n\t// match any object with a numeric length property and extract it\n\t.case({ length: \"number\" }, o => o.length)\n\t// return 0 for all other data\n\t.default(() => 0)\n\nsizeOf(\"abc\") // 3\nsizeOf({ name: \"David\", length: 5 }) // 5\nsizeOf(null) // 0\n```\n\n----------------------------------------\n\nTITLE: Constraining String Lengths with Fluent Syntax in ArkType\nDESCRIPTION: Shows how to constrain string length using fluent syntax in ArkType, with methods like moreThanLength, atLeastLength, lessThanLength, and atMostLength.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst Bounded = type({\n\tnonEmpty: type.string.moreThanLength(0),\n\tatLeastLength3: type.keywords.string.alphanumeric.atLeastLength(3),\n\tlessThanLength10: type.string.lessThanLength(10),\n\tatMostLength5: type.string.atMostLength(5)\n})\n```\n\n----------------------------------------\n\nTITLE: Constraining String Lengths with String Syntax in ArkType\nDESCRIPTION: Demonstrates how to constrain string length using the string syntax in ArkType, including greater than, less than, and range expressions.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst Bounded = type({\n\tnonEmpty: \"string > 0\",\n\tatLeastLength3: \"string.alphanumeric >= 3\",\n\tlessThanLength10: \"string < 10\",\n\tatMostLength5: \"string <= 5\"\n})\n```\n\n----------------------------------------\n\nTITLE: Union Type Morphing Constraints and Examples\nDESCRIPTION: Illustrates constraints and valid/invalid patterns when using morphs with union types, showing cases where morphing behavior is deterministic or ambiguous.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// operands overlap, but neither transforms data\nconst Okay = type(\"number > 0\").or(\"number < 10\")\n// operand transforms data, but there's no overlap between the inputs\nconst AlsoOkay = type(\"string.numeric.parse\").or({ box: \"string\" })\n// operands overlap and transform data, but in the same way\nconst StillOkay = type(\"string > 5\", \"=>\", Number.parseFloat).or([\n\t\"0 < string < 10\",\n\t\"=>\",\n\tNumber.parseFloat\n])\n// ParseError: An unordered union of a type including a morph and a type with overlapping input is indeterminate\nconst Bad = type({ box: \"string.numeric.parse\" }).or({ box: \"string\" })\nconst SameError = type({ a: \"string.numeric.parse\" }).or({ b: \"string.numeric.parse\" })\n```\n\n----------------------------------------\n\nTITLE: Safe JSON Parsing with Try Method in TypeScript\nDESCRIPTION: Demonstrates using ArkType's pipe.try method to safely handle JSON parsing without crashing on invalid input, returning an introspectable error object instead.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/intro/morphs-and-more.mdx#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst parseJson = type(\"string\").pipe.try((s): object => JSON.parse(s))\n\n// Now returns an introspectable error instead of crashing 🎉\nconst badOut = parseJson('{ unquoted: \"keys\" }')\n\nconst out = parseJson('{ \"ark\": \"type\" }')\n\nif (out instanceof type.errors) out.throw()\n// Unfortunately, a validated `object` still isn't very useful...\nelse console.log(out)\n```\n\n----------------------------------------\n\nTITLE: Defining Index Signatures in ArkType Objects (TypeScript)\nDESCRIPTION: Shows how to define index signatures in ArkType objects using string syntax. Includes examples of string and symbol index signatures.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/objects/index.mdx#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst MyObj = type({\n\t// index signatures do not require a label\n\t\"[string]\": \"number.integer\",\n\t// arbitrary string or symbolic expressions are allowed\n\t\"[string | symbol]\": \"number\"\n})\n```\n\n----------------------------------------\n\nTITLE: Narrow Expression with Fluent API for Form Validation\nDESCRIPTION: Shows how to use a narrow expression with the fluent API to validate that password and confirmation fields match, providing a custom error message with path information.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst Form = type({\n\tpassword: \"string\",\n\tconfirmPassword: \"string\"\n}).narrow((data, ctx) => {\n\tif (data.password === data.confirmPassword) {\n\t\treturn true\n\t}\n\treturn ctx.reject({\n\t\texpected: \"identical to password\",\n\t\t// don't display the password in the error message!\n\t\tactual: \"\",\n\t\tpath: [\"confirmPassword\"]\n\t})\n})\n\n// ArkErrors: confirmPassword must be identical to password\nconst out = Form({\n\tpassword: \"arktype\",\n\tconfirmPassword: \"artkype\"\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Types from Drizzle Schemas with ArkType in TypeScript\nDESCRIPTION: This example demonstrates how to use the official 'drizzle-arktype' package to create ArkType Types from Drizzle schemas. It shows the creation of a 'User' type based on a Drizzle table definition.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/integrations/index.mdx#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// @noErrors\nimport { pgTable, text, integer } from \"drizzle-orm/pg-core\"\nimport { createSelectSchema } from \"drizzle-arktype\"\n\nconst users = pgTable(\"users\", {\n\tid: integer().generatedAlwaysAsIdentity().primaryKey(),\n\tname: text().notNull(),\n\tage: integer().notNull()\n})\n\n// Type<{ id: number; name: string; age: number }>\nconst User = createSelectSchema(users)\n```\n\n----------------------------------------\n\nTITLE: Defining Types Using Fluent Syntax for TypeScript Keywords in ArkType\nDESCRIPTION: Shows how to use ArkType's fluent API to define types, where keywords are exposed directly on the 'type' object for easier access and better IDE support. This approach provides a more object-oriented way to define types.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/keywords.mdx#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst Keywords = type({\n\tstring: type.string,\n\tdate: type.Date\n})\n```\n\n----------------------------------------\n\nTITLE: Using Constrained Parameters with Generics in ArkType\nDESCRIPTION: Shows how to use constrained parameters in ArkType generics. It defines a 'nonEmpty' type that ensures arrays have at least one element.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/generics/index.mdx#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type } from \"arktype\"\n\nconst nonEmpty = type(\"<arr extends unknown[]>\", \"arr > 0\")\n\nconst nonEmptyNumberArray = nonEmpty(\"number[]\")\n```\n\n----------------------------------------\n\nTITLE: Narrow Expression with Args Syntax for Form Validation\nDESCRIPTION: Shows how to implement form validation using a narrow expression with args syntax, checking that password fields match and providing a clear error message.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst Form = type(\n\t{\n\t\tpassword: \"string\",\n\t\tconfirmPassword: \"string\"\n\t},\n\t\":\",\n\t(data, ctx) => {\n\t\tif (data.password === data.confirmPassword) {\n\t\t\treturn true\n\t\t}\n\t\treturn ctx.reject({\n\t\t\texpected: \"identical to password\",\n\t\t\t// don't display the password in the error message!\n\t\t\tactual: \"\",\n\t\t\tpath: [\"confirmPassword\"]\n\t\t})\n\t}\n)\n\n// ArkErrors: confirmPassword must be identical to password\nconst out = Form({\n\tpassword: \"arktype\",\n\tconfirmPassword: \"artkype\"\n})\n```\n\n----------------------------------------\n\nTITLE: Invoking Generics in ArkType\nDESCRIPTION: Demonstrates different ways to invoke generics in ArkType, including direct invocation, chained invocation, and using predefined keywords.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/generics/index.mdx#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type } from \"arktype\"\n\nconst One = type(\"Extract<0 | 1, 1>\")\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type } from \"arktype\"\n\nconst User = type({\n\tname: \"string\",\n\t\"age?\": \"number\",\n\tisAdmin: \"boolean\"\n})\n\n// hover me!\nconst basicUser = User.pick(\"name\", \"age\")\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type } from \"arktype\"\n\nconst unfalse = type.keywords.Exclude(\"boolean\", \"false\")\n```\n\n----------------------------------------\n\nTITLE: Converting JSON Schema to ArkType Type\nDESCRIPTION: Demonstrates converting a JSON Schema string validation definition to an ArkType Type using jsonSchemaToType function\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/json-schema/README.md#2025-04-11_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { jsonSchemaToType } from \"@ark/json-schema\"\n\nconst T = jsonSchemaToType({ type: \"string\", minLength: 5, maxLength: 10 })\n```\n\n----------------------------------------\n\nTITLE: Creating External Generic Wrappers in ArkType\nDESCRIPTION: Demonstrates how to create external generic wrappers for ArkType. It includes two examples: a basic pattern for wrapping a Type and a more advanced integration that parses a definition directly.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/generics/index.mdx#2025-04-11_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst createBox = <t extends string>(of: type.Any<t>) =>\n\ttype({\n\t\tbox: of\n\t})\n\n// @ts-expect-error\ncreateBox(type(\"number\"))\n\n// Type<{ box: string }>\nconst BoxType = createBox(type(\"string\"))\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst createBox = <const def>(\n\tof: type.validate<def>\n): type.instantiate<{ of: def }> =>\n\ttype.raw({\n\t\tbox: of\n\t}) as never\n\n// Type<{ box: string }>\nconst BoxType = createBox(\"string\")\n```\n\n----------------------------------------\n\nTITLE: Using Number Keywords in ArkType\nDESCRIPTION: Examples of using number keywords to define epoch timestamps and non-negative integers in ArkType.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst User = type({\n\tcreatedAt: \"number.epoch\",\n\tage: \"number.integer >= 0\"\n})\n```\n\n----------------------------------------\n\nTITLE: String Range Expressions with Fluent Syntax in ArkType\nDESCRIPTION: Shows how to use fluent syntax to create range expressions for strings in ArkType, chaining methods like moreThanLength, atMostLength, atLeastLength, and lessThanLength.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst Range = type({\n\tnonEmptyAtMostLength10: type.string.moreThanLength(0).atMostLength(10),\n\tintegerStringWith2To5Digits: type.keywords.string.integer.root\n\t\t.atLeastLength(2)\n\t\t.lessThanLength(6)\n})\n```\n\n----------------------------------------\n\nTITLE: Creating String Intersection Types in ArkType\nDESCRIPTION: Demonstrates creating an intersection between a string email type and a regex pattern to validate email addresses with a specific domain.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst MyObj = type({\n\t// an email address with the domain arktype.io\n\tintersected: \"string.email & /@arktype\\\\.io$/\"\n})\n```\n\n----------------------------------------\n\nTITLE: Constraining Number Ranges with String Syntax in ArkType\nDESCRIPTION: Demonstrates how to constrain number values with min and max bounds using string syntax in ArkType.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst Bounded = type({\n\tpositive: \"number > 0\",\n\tatLeast3: \"number.integer >= 3\",\n\tlessThanPi: \"number < 3.14159\",\n\tatMost5: \"number <= 5\"\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Cyclic Types with Scopes in ArkType\nDESCRIPTION: Demonstrates how to create recursive type definitions using scopes. Shows Package and Contributor types that reference each other cyclically.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/scopes/index.mdx#2025-04-11_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport const types = scope({\n\tPackage: {\n\t\tname: \"string\",\n\t\t\"dependencies?\": \"Package[]\",\n\t\t\"contributors?\": \"Contributor[]\"\n\t},\n\tContributor: {\n\t\temail: \"string.email\",\n\t\t\"packages?\": \"Package[]\"\n\t}\n}).export()\n```\n\n----------------------------------------\n\nTITLE: Constraining Number Ranges with Fluent Syntax in ArkType\nDESCRIPTION: Shows how to constrain number values with min and max bounds using fluent syntax in ArkType.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst Bounded = type({\n\tpositive: type.number.moreThan(0),\n\tatLeast3: type.keywords.number.integer.atLeast(3),\n\tlessThanPi: type.number.lessThan(3.14159),\n\tatMost5: type.number.atMost(5)\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Intersection Types with Tuple Syntax\nDESCRIPTION: Shows how to use tuple syntax to create an intersection between two object types, using the '&' operator to combine their properties.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// an object requiring both foo and bar\nconst FoobarObject = type([\n\t{\n\t\tfoo: \"string\"\n\t},\n\t\"&\",\n\t{\n\t\tbar: \"number\"\n\t}\n])\n```\n\n----------------------------------------\n\nTITLE: Number Range Expressions with String Syntax in ArkType\nDESCRIPTION: Demonstrates complex number range constraints using string syntax in ArkType, including a range for positive numbers and constraints on even numbers.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst Range = type({\n\tpositiveAtMostE: \"0 < number <= 2.71828\",\n\tevenNumberAbsoluteValueLessThan50: \"-50 < (number % 2) < 50\"\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Defaultable Properties in ArkType Objects (TypeScript)\nDESCRIPTION: Illustrates how to define defaultable properties in ArkType objects using string, fluent, and tuple syntax. Provides an example with a boolean property defaulting to false.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/objects/index.mdx#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst MyObj = type({\n\tdefaultableKey: \"boolean = false\"\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst MyObj = type({\n\tdefaultableKey: type.boolean.default(false)\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst MyObj = type({\n\tdefaultableKey: [\"boolean\", \"=\", false]\n})\n```\n\n----------------------------------------\n\nTITLE: Narrow Expression with Tuple Syntax for Form Validation\nDESCRIPTION: Demonstrates form validation using a narrow expression with tuple syntax, ensuring that password and confirmation fields match and providing a custom error message.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst Form = type([\n\t{\n\t\tpassword: \"string\",\n\t\tconfirmPassword: \"string\"\n\t},\n\t\":\",\n\t(data, ctx) => {\n\t\tif (data.password === data.confirmPassword) {\n\t\t\treturn true\n\t\t}\n\t\treturn ctx.reject({\n\t\t\texpected: \"identical to password\",\n\t\t\t// don't display the password in the error message!\n\t\t\tactual: \"\",\n\t\t\tpath: [\"confirmPassword\"]\n\t\t})\n\t}\n])\n\n// ArkErrors: confirmPassword must be identical to password\nconst out = Form({\n\tpassword: \"arktype\",\n\tconfirmPassword: \"artkype\"\n})\n```\n\n----------------------------------------\n\nTITLE: Validating Cyclic Data with ArkType\nDESCRIPTION: Shows how to use cyclic types to validate cyclic data at runtime. Demonstrates error handling for invalid data within a cyclic structure.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/scopes/index.mdx#2025-04-11_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport const types = scope({\n\tPackage: {\n\t\tname: \"string\",\n\t\t\"dependencies?\": \"Package[]\",\n\t\t\"contributors?\": \"Contributor[]\"\n\t},\n\tContributor: {\n\t\temail: \"string.email\",\n\t\t\"packages?\": \"Package[]\"\n\t}\n}).export()\n\nexport type Package = typeof types.Package.infer\n\nconst packageData: Package = {\n\tname: \"arktype\",\n\tdependencies: [{ name: \"typescript\" }],\n\tcontributors: [{ email: \"david@sharktypeio\" }]\n}\n\n// update arktype to depend on itself\npackageData.dependencies![0].dependencies = [packageData]\n\n// ArkErrors: contributors[0].email must be an email address (was \"david@sharktypeio\")\nconst out = types.Package(packageData)\n```\n\n----------------------------------------\n\nTITLE: Narrow with Type Predicate Using Tuple Syntax\nDESCRIPTION: Shows how to use a narrow expression with a type predicate using tuple syntax, validating that a string starts with 'ark' and refining the inferred type.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n// hover to see how the predicate is propagated to the outer `Type`\nconst ArkString = type([\n\t\"string\",\n\t\":\",\n\t(data, ctx): data is `ark${string}` =>\n\t\tdata.startsWith(\"ark\") ?? ctx.reject(\"a string starting with 'ark'\")\n])\n```\n\n----------------------------------------\n\nTITLE: Creating Union Types with String Syntax\nDESCRIPTION: Shows how to define a union type using string syntax, allowing a property to be either a string or a number.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst Unions = type({\n\tkey: \"string | number\"\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Morph Operations with Tuple Syntax\nDESCRIPTION: Shows how to create a morph operation using tuple syntax with the '=>' operator to transform a string by trimming its leading whitespace.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n// hover to see how morphs are represented at a type-level\nconst trimStringStart = type([\"string\", \"=>\", str => str.trimStart()])\n```\n\n----------------------------------------\n\nTITLE: Creating Object Intersection Types with Fluent API\nDESCRIPTION: Shows how to create an intersection between two object types using the fluent API, requiring the resulting object to have properties from both original types.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst FooObject = type({\n\tfoo: \"string\"\n})\n\n// an object requiring both foo and bar\nconst FoobarObject = FooObject.and({\n\tbar: \"number\"\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Morph Operations with Args Syntax\nDESCRIPTION: Demonstrates creating a morph operation using args syntax with the '=>' operator to transform a string by trimming its leading whitespace.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\n// hover to see how morphs are represented at a type-level\nconst trimStringStart = type(\"string\", \"=>\", str => str.trimStart())\n```\n\n----------------------------------------\n\nTITLE: Customizing Actual Value Display in Error Messages\nDESCRIPTION: Shows how to use the 'actual' option to customize or omit the display of the actual value in error messages, useful for sensitive data like passwords.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/configuration/index.mdx#2025-04-11_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst Password = type(\"string >= 8\").configure({ actual: () => \"\" })\n// ArkErrors: must be at least length 8\nconst out = Password(\"ez123\")\n```\n\n----------------------------------------\n\nTITLE: Using 'to' Operator with Fluent API for Chained Validation\nDESCRIPTION: Demonstrates using the 'to' operator with fluent API to chain validation, parsing a numeric string and checking if it's even.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nconst parseEvenTo = type(\"string.numeric.parse\").to(\"number % 2\")\n\nconst Even = type(\"number % 2\")\n// equivalent to parseEvenTo\nconst parseEvenPipe = type(\"string.numeric.parse\").pipe(Even)\n```\n\n----------------------------------------\n\nTITLE: String Range Expressions with String Syntax in ArkType\nDESCRIPTION: Demonstrates using range expressions to specify both min and max length constraints for strings using string syntax in ArkType.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst Range = type({\n\tnonEmptyAtMostLength10: \"0 < string <= 10\",\n\tintegerStringWith2To5Digits: \"2 <= string.integer < 6\"\n})\n```\n\n----------------------------------------\n\nTITLE: Using 'to' Operator with Tuple Syntax for Chained Validation\nDESCRIPTION: Shows how to use the 'to' operator with tuple syntax to create a type that parses a numeric string and validates it's even.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nconst parseEvenTo = type([\"string.numeric.parse\", \"|>\", \"number % 2\"])\n\nconst Even = type(\"number % 2\")\n// equivalent to parseEvenTo\nconst parseEvenPipe = type(\"string.numeric.parse\").pipe(Even)\n```\n\n----------------------------------------\n\nTITLE: Type-Safe JSON Schema String Definition\nDESCRIPTION: Shows type-safe JSON Schema definition for string values with TypeScript validation, using @ark/json-schema specific imports\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/json-schema/README.md#2025-04-11_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { StringSchema } from \"@ark/json-schema\"\nconst stringSchema: StringSchema = {\n\ttype: \"string\",\n\tminLength: \"3\" // errors stating that 'minLength' must be a number\n}\n```\n\n----------------------------------------\n\nTITLE: Using 'to' Operator with Args Syntax for Chained Validation\nDESCRIPTION: Demonstrates using the 'to' operator with args syntax to chain validation, parsing a numeric string and checking if the result is even.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nconst parseEvenTo = type(\"string.numeric.parse\", \"|>\", \"number % 2\")\n\nconst Even = type(\"number % 2\")\n// equivalent to parseEvenTo\nconst parseEvenPipe = type(\"string.numeric.parse\").pipe(Even)\n```\n\n----------------------------------------\n\nTITLE: Creating Union Types with Tuple Syntax\nDESCRIPTION: Demonstrates creating union types using tuple syntax, allowing a property to be either a string or an object with a name property.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst Unions = type({\n\tkey: [\"string\", \"|\", { name: \"string\" }]\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Unit Types in TypeScript with ArkType\nDESCRIPTION: Demonstrates different syntax methods for creating unit types with exact values using ArkType's type.unit functionality.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySymbol = Symbol()\n\nconst ExactValue = type.unit(mySymbol)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySymbol = Symbol()\n\nconst ExactValue = type([\"===\", mySymbol])\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySymbol = Symbol()\n\nconst ExactValue = type(\"===\", mySymbol)\n```\n\n----------------------------------------\n\nTITLE: Type-Level Configuration in ArkType\nDESCRIPTION: Demonstrates how to apply configuration to a specific Type, which will affect all Types shallowly referenced by the configured Type, such as customizing error messages.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/configuration/index.mdx#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// avoid logging \"was xxx\" for password\nconst Password = type(\"string >= 8\").configure({ actual: () => \"\" })\nconst User = type({\n\temail: \"string.email\",\n\tpassword: Password\n})\n// ArkErrors: password must be at least length 8\nconst out = User({\n\temail: \"david@arktype.io\",\n\tpassword: \"ez123\"\n})\n```\n\n----------------------------------------\n\nTITLE: Converting TypeScript Enums to ArkType Types\nDESCRIPTION: Examples of converting TypeScript enums to ArkType types using type.valueOf, including handling of numeric enum values.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nenum TsEnum {\n\tnumeric = 1\n}\n\nconst EnumType = type.valueOf(TsEnum) // Type<1>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst equivalentObject = {\n\tnumeric: 1,\n\t\"1\": \"numeric\"\n} as const\n\nconst EquivalentObject = type.valueOf(equivalentObject)\n```\n\n----------------------------------------\n\nTITLE: Combining Scopes using Spread Operator in ArkType\nDESCRIPTION: Shows how to combine multiple scopes by exporting them to modules and spreading them into a new scope definition. Demonstrates selective inclusion of aliases.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/scopes/index.mdx#2025-04-11_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst coolScope = scope({\n\tId: \"string\",\n\tUser: { id: \"Id\", friends: \"Id[]\" },\n\tUsersById: {\n\t\t\"[Id]\": \"User | undefined\"\n\t}\n})\n\nconst threeSixtyNoScope = scope({\n\tthree: \"3\",\n\tsixty: \"60\",\n\tno: \"'no'\"\n})\n\nconst superScope = scope({\n\t...coolScope.export(),\n\t// if you don't want to include the entire scope, you can pass a list of ...aliases\n\t...threeSixtyNoScope.export(\"three\", \"sixty\"),\n\tsaiyan: {\n\t\tpowerLevel: \"number > 9000\"\n\t}\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Type Metadata in ArkType\nDESCRIPTION: Demonstrates how to add metadata to types including descriptions that affect error messages.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nconst SpecialString = type(\"string\").configure({\n\tdescription: \"a special string\"\n})\n\nconst SpecialNumber = type(\"number\").describe(\"a special number\")\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst SpecialString = type([\n\t\"string\",\n\t\"@\",\n\t{\n\t\tdescription: \"a special string\"\n\t}\n])\n\nconst SpecialNumber = type([\"number\", \"@\", \"a special number\"])\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst SpecialString = type(\"string\", \"@\", {\n\tdescription: \"a special string\"\n})\n\nconst SpecialNumber = type(\"number\", \"@\", \"a special number\")\n```\n\n----------------------------------------\n\nTITLE: Creating Morph Operations with Fluent API\nDESCRIPTION: Shows how to create a morph operation using the fluent API to transform a string by trimming its leading whitespace after validation.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n// hover to see how morphs are represented at a type-level\nconst trimStringStart = type(\"string\").pipe(str => str.trimStart())\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Builtin Keywords in ArkType\nDESCRIPTION: Demonstrates how to globally configure ArkType's builtin keywords for customizing error messages. The example shows customization of 'string' and 'string.email' validators with custom error messages.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/blog/2.1.mdx#2025-04-11_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configure } from \"arktype/config\"\n\nconfigure({\n\tkeywords: {\n\t\tstring: \"shorthand description\",\n\t\t\"string.email\": {\n\t\t\tactual: () => \"definitely fake\"\n\t\t}\n\t}\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Union Types with Fluent API\nDESCRIPTION: Demonstrates creating a union type using the fluent API, combining string and number types for a property value.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst Unions = type({\n\tkey: type.string.or(type.number)\n})\n```\n\n----------------------------------------\n\nTITLE: Using Globally Configured Keywords in ArkType\nDESCRIPTION: Shows how globally configured keywords are applied in an application. The example creates a User type with custom error messages for string and email validation.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/blog/2.1.mdx#2025-04-11_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport \"./config.ts\"\nimport { type } from \"arktype\"\n\nconst User = type({\n\tname: \"string\",\n\temail: \"string.email\"\n})\n\nconst out = User({\n\t// ArkErrors: name must be shorthand description (was a number)\n\tname: 5,\n\t// ArkErrors: email must be an email address (was definitely fake)\n\temail: \"449 Canal St\"\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Morph Operations with Function Syntax\nDESCRIPTION: Demonstrates creating a chain of morphs using function syntax to trim a string, then validate that it's non-empty after trimming.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\n// accepts ...morphsOrTypes\nconst trimStartToNonEmpty = type.pipe(\n\ttype.string,\n\ts => s.trimStart(),\n\ttype.string.atLeastLength(1)\n)\n```\n\n----------------------------------------\n\nTITLE: Using Tuple and Args Expressions for .to in ArkType\nDESCRIPTION: Demonstrates the use of the 'to' operator with tuple and args expressions for chaining transformations. The examples show different ways to achieve the same result with various syntax styles.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/blog/2.1.mdx#2025-04-11_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst FluentStillWorks = type(\"string.numeric.parse\").to(\"number % 2\")\n\nconst NowSoDoesTuple = type({\n\tsomeKey: [\"string.numeric.parse\", \"|>\", \"number % 2\"]\n})\n\nconst AndSpreadArgs = type(\"string.numeric.parse\", \"|>\", \"number % 2\")\n```\n\n----------------------------------------\n\nTITLE: Defining Number Literals in ArkType\nDESCRIPTION: Shows how to define a number literal in ArkType using string syntax.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst Literals = type({\n\tnumber: \"1337\"\n})\n```\n\n----------------------------------------\n\nTITLE: Fixed Discriminated Union Behavior in ArkType\nDESCRIPTION: Demonstrates a fix for discriminated unions that previously incorrectly rejected some valid cases. The example shows how ArkType now correctly handles overlapping properties in discriminated union branches.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/blog/2.1.mdx#2025-04-11_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst Discriminated = type({\n\tid: \"0\",\n\tk1: \"number\"\n})\n\t.or({ id: \"1\", k1: \"number\" })\n\t.or({\n\t\tname: \"string\"\n\t})\n\n// previously, this was rejected as requiring a \"k1\" key\n// will now hit the case discriminated for id: 1,\n// but still correctly be allowed via the { name: \"string\" } branch\nDiscriminated({ name: \"foo\", id: 1 })\n```\n\n----------------------------------------\n\nTITLE: Fluent API Property Merging\nDESCRIPTION: Demonstrates property merging using ArkType's fluent API syntax with symbol support.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/objects/index.mdx#2025-04-11_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst zildjian = Symbol()\n\nconst Base = type({\n\t\"[string]\": \"number\",\n\tfoo: \"0\",\n\t[zildjian]: \"true\"\n})\n\nconst chainedResult = Base.merge({\n\t\"[string]\": \"bigint\",\n\t\"foo?\": \"1n\"\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Settings in TypeScript with ArkType\nDESCRIPTION: Demonstrates how to apply global configuration to all Types parsed after the config is applied by using the 'arktype/config' entrypoint.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/configuration/index.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configure } from \"arktype/config\"\n// use the \"arktype/config\" entrypoint\nconfigure({ numberAllowsNaN: true })\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport \"./config.ts\"\n// import your config file before arktype\nimport { type } from \"arktype\"\n\ntype.number.allows(Number.NaN) // true\n```\n\n----------------------------------------\n\nTITLE: Creating Branded Types with Fluent API\nDESCRIPTION: Demonstrates creating a branded type for even numbers using the fluent API, applying a brand symbol that TypeScript can enforce during compile-time type checking.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n// @noErrors\nconst even = type.number.divisibleBy(2).brand(\"even\")\ntype Even = typeof even.infer\n\nconst good: Even = even.assert(2)\n// TypeScript: Type 'number' is not assignable to type 'Brand<number, \"even\">'\nconst bad: Even = 5\n```\n\n----------------------------------------\n\nTITLE: Configuring Errors by Code in ArkType\nDESCRIPTION: Demonstrates how to configure errors by their associated code property at a scope level, allowing for error-specific customization with context-sensitive data.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/configuration/index.mdx#2025-04-11_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst mod = type.module(\n\t{ isEven: \"number%2\" },\n\t{\n\t\tdivisor: {\n\t\t\t// the available `ctx` types will include data specific to your errors\n\t\t\texpected: ctx => `% ${ctx.rule} !== 0`,\n\t\t\tproblem: ctx => `${ctx.actual} ${ctx.expected}`\n\t\t}\n\t}\n)\n// ArkErrors: 3 % 2 !== 0\nmod.isEven(3)\n```\n\n----------------------------------------\n\nTITLE: Function-based Property Merging\nDESCRIPTION: Shows how to merge properties using the functional approach in ArkType with multiple object definitions.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/objects/index.mdx#2025-04-11_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst zildjian = Symbol()\n\nconst Base = type({\n\t\"[string]\": \"number\",\n\tfoo: \"0\",\n\t[zildjian]: \"true\"\n})\n\nconst functionResult = type.merge(\n\tBase,\n\t{\n\t\t\"[string]\": \"bigint\",\n\t\t\"foo?\": \"1n\"\n\t},\n\t{\n\t\tincludeThisPropAlso: \"true\"\n\t}\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Keywords Globally in ArkType\nDESCRIPTION: Shows how to globally configure built-in keywords like 'string.email' to customize their behavior or error messages without creating aliases or wrappers.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/configuration/index.mdx#2025-04-11_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configure } from \"arktype/config\"\n\nconfigure({\n\tkeywords: {\n\t\tstring: \"shorthand description\",\n\t\t\"string.email\": {\n\t\t\tactual: () => \"definitely fake\"\n\t\t}\n\t}\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport \"./config.ts\"\n// import your config file before arktype\nimport { type } from \"arktype\"\n\nconst User = type({\n\tname: \"string\",\n\temail: \"string.email\"\n})\n\nconst out = User({\n\t// ArkErrors: name must be shorthand description (was a number)\n\tname: 5,\n\t// ArkErrors: email must be an email address (was definitely fake)\n\temail: \"449 Canal St\"\n})\n```\n\n----------------------------------------\n\nTITLE: Using Subtype Keywords with Fluent Syntax in ArkType\nDESCRIPTION: Shows how to use ArkType's fluent API to access subtype keywords through the type.keywords namespace. Demonstrates the use of .root to get the base type of a subtyped module, and how to create transforms for date handling.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/keywords.mdx#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst Keywords = type({\n\tdateFormattedString: type.keywords.string.date.root,\n\tisoFormattedString: type.keywords.string.date.iso.root,\n\ttransformStringToDate: type.keywords.string.date.parse,\n\ttransformIsoFormattedStringToDate: type.keywords.string.date.iso.parse\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Clone Behavior with structuredClone in ArkType\nDESCRIPTION: Demonstrates how to provide an alternate clone implementation, such as structuredClone, to customize how ArkType clones input values before applying morphs.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/configuration/index.mdx#2025-04-11_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configure } from \"arktype/config\"\n\nconfigure({ clone: structuredClone })\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport \"./config.ts\"\n// import your config file before arktype\nimport { type } from \"arktype\"\n\n// will now create a new object using structuredClone\nconst UserForm = type({\n\tage: \"string.numeric.parse\"\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Divisible Numbers with Fluent Syntax in ArkType\nDESCRIPTION: Shows how to constrain a number to be divisible by a specific integer using fluent syntax in ArkType.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst Evens = type({\n\tkey: type.number.divisibleBy(2)\n})\n```\n\n----------------------------------------\n\nTITLE: Optional Property Type Validation Example\nDESCRIPTION: Demonstrates default behavior of optional property validation in ArkType with exactOptionalPropertyTypes enabled.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/configuration/index.mdx#2025-04-11_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst MyObj = type({\n\t\"key?\": \"number\"\n})\n\n// valid data\nconst validResult = MyObj({})\n\n// Error: key must be a number (was undefined)\nconst errorResult = MyObj({ key: undefined })\n```\n\n----------------------------------------\n\nTITLE: Customizing Problem Description in Error Messages\nDESCRIPTION: Demonstrates how to use the 'problem' option to completely customize the description of the problem in error messages by providing a function that formats the error message.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/configuration/index.mdx#2025-04-11_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst Password = type(\"string >= 8\").configure({\n\tproblem: ctx => `${ctx.actual} isn't ${ctx.expected}`\n})\n// ArkErrors: 5 isn't at least length 8\nconst out1 = Password(\"ez123\")\n// ArkErrors: a number isn't a string\nconst out2 = Password(12345678)\n```\n\n----------------------------------------\n\nTITLE: Using Modified Optional Property Settings\nDESCRIPTION: Example showing how optional properties behave after configuring exactOptionalPropertyTypes to false.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/configuration/index.mdx#2025-04-11_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport \"./config.ts\"\n// import your config file before arktype\nimport { type } from \"arktype\"\n\nconst MyObj = type({\n\t\"key?\": \"number\"\n})\n\n// valid data\nconst validResult = MyObj({})\n\n// now also valid data (would be an error by default)\nconst secondResult = MyObj({ key: undefined })\n```\n\n----------------------------------------\n\nTITLE: Using 'to' Operator with String Syntax for Chained Validation\nDESCRIPTION: Shows how to use the 'to' operator with string syntax to create a type that parses a numeric string and validates it's even, with equivalent alternate approaches.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nconst parseEvenTo = type(\"string.numeric.parse |> number % 2\")\n\nconst Even = type(\"number % 2\")\n// equivalent to parseEvenTo\nconst parseEvenPipe = type(\"string.numeric.parse\").pipe(Even)\n```\n\n----------------------------------------\n\nTITLE: Default Values Behavior Example\nDESCRIPTION: Demonstrates current behavior of default values in ArkType, which is not yet affected by exactOptionalPropertyTypes.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/configuration/index.mdx#2025-04-11_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst MyObj = type({\n\tkey: \"number = 5\"\n})\n\n// { key: 5 }\nconst omittedResult = MyObj({})\n\n// { key: undefined }\nconst undefinedResult = MyObj({ key: undefined })\n```\n\n----------------------------------------\n\nTITLE: Creating Union Types with Args Syntax\nDESCRIPTION: Shows how to create a union type using args syntax, combining string and object types with the '|' operator.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst Unions = type({\n\tkey: type(\"string\", \"|\", { name: \"string\" })\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Type-Safe Metadata\nDESCRIPTION: Demonstrates how to add and type custom metadata for ArkType types.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/configuration/index.mdx#2025-04-11_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n// add this anywhere in your project\ndeclare global {\n\tinterface ArkEnv {\n\t\tmeta(): {\n\t\t\t// meta properties should always be optional\n\t\t\tsecretIngredient?: string\n\t\t}\n\t}\n}\n\n// now types you define can specify and access your metadata\nconst MrPingsSecretIngredientSoup = type({\n\tbroth: \"'miso' | 'vegetable'\",\n\tingredients: \"string[]\"\n}).configure({ secretIngredient: \"nothing!\" })\n```\n\n----------------------------------------\n\nTITLE: Number Range Expressions with Fluent Syntax in ArkType\nDESCRIPTION: Shows complex number range constraints using fluent syntax in ArkType, with chained methods to create the same constraints as the string syntax example.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst Range = type({\n\tpositiveAtMostE: type.number.moreThan(0).atMost(2.71828),\n\tevenNumberAbsoluteValueLessThan50: type.number\n\t\t.divisibleBy(2)\n\t\t.moreThan(-50)\n\t\t.lessThan(50)\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Intersection Types with Function Syntax\nDESCRIPTION: Demonstrates using the function syntax to create an intersection of multiple object types, combining their properties into a single type definition.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst FooObject = type({\n\tfoo: \"string\"\n})\n\n// accepts ...definitions\nconst FoobarObject = type.and(\n\tFooObject,\n\t{\n\t\tbar: \"number\"\n\t},\n\t{\n\t\tbaz: \"string\"\n\t}\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Branded Types with String Syntax\nDESCRIPTION: Shows how to create a branded type for numbers divisible by 2, allowing type-checking to enforce this constraint for values labeled with the brand.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// @noErrors\nconst Even = type(\"(number % 2)#even\")\ntype Even = typeof even.infer\n\nconst good: Even = even.assert(2)\n// TypeScript: Type 'number' is not assignable to type 'Brand<number, \"even\">'\nconst bad: Even = 5\n```\n\n----------------------------------------\n\nTITLE: Creating Intersection Types with Args Syntax\nDESCRIPTION: Demonstrates creating an intersection between object types using the args syntax, with the '&' operator placed between type definitions.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// an object requiring both foo and bar\nconst FoobarObject = type(\n\t{\n\t\tfoo: \"string\"\n\t},\n\t\"&\",\n\t{\n\t\tbar: \"number\"\n\t}\n)\n```\n\n----------------------------------------\n\nTITLE: Narrow with Type Predicate Using Fluent API\nDESCRIPTION: Demonstrates using a narrow expression with a type predicate to refine the inferred type, checking if a string starts with 'ark' and providing a custom error message.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n// hover to see how the predicate is propagated to the outer `Type`\nconst ArkString = type(\"string\").narrow(\n\t(data, ctx): data is `ark${string}` =>\n\t\tdata.startsWith(\"ark\") ?? ctx.reject(\"a string starting with 'ark'\")\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Union Types with Function Syntax\nDESCRIPTION: Shows how to use function syntax to create a union of multiple types, accepting string literals, type references, and object types.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// accepts ...definitions\nconst Union = type.or(type.string, \"number\", { key: \"unknown\" })\n```\n\n----------------------------------------\n\nTITLE: Defining Boolean Literals with Fluent Syntax in ArkType\nDESCRIPTION: Demonstrates how to specify exact boolean values and unions of boolean values using fluent syntax in ArkType.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nconst Booleans = type({\n\ta: type.keywords.true,\n\tb: type.keywords.false,\n\t// equivalent to the \"boolean\" keyword\n\tc: type.keywords.true.or(type.keywords.false)\n})\n```\n\n----------------------------------------\n\nTITLE: Using Parenthetical Expressions in ArkType\nDESCRIPTION: Demonstrates how to control operator precedence using parenthetical expressions in type definitions.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nconst Groups = type({\n\tstringOrArrayOfNumbers: \"string | number[]\",\n\tarrayOfStringsOrNumbers: \"(string | number)[]\"\n})\n```\n\n----------------------------------------\n\nTITLE: Keyof Operator Usage\nDESCRIPTION: Demonstrates the keyof operator's functionality with index signatures and special key handling.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/objects/index.mdx#2025-04-11_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst RecordWithSpecialKeys = type({\n\t\"[string]\": \"unknown\",\n\tverySpecialKey: \"0 < number <= 3.14159\",\n\tmoderatelySpecialKey: \"-9.51413 <= number < 0\"\n})\n\nconst Key = RecordWithSpecialKeys.keyof()\n\nconsole.log(Key.equals(\"string\"))\n```\n\n----------------------------------------\n\nTITLE: Implementing Scoped Generics in ArkType\nDESCRIPTION: Illustrates the usage of scoped generics in ArkType using the 'scope' function. It defines a generic 'box' type and a specific 'bitBox' type within a scope.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/generics/index.mdx#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { scope } from \"arktype\"\n\nconst types = scope({\n\t\"box<t, u>\": {\n\t\tbox: \"t | u\"\n\t},\n\tbitBox: \"box<0, 1>\"\n}).export()\n\nconst out = types.bitBox({ box: 0 })\n```\n\n----------------------------------------\n\nTITLE: Using Description for Custom Error Messages in ArkType\nDESCRIPTION: Shows how to use the 'describe' method to customize error messages by providing a summary of the constraint that completes the phrase 'must be ___'.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/configuration/index.mdx#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst Password = type.string.atLeastLength(8).describe(\"a valid password\")\n// ArkErrors: must be a valid password\nconst out = Password(\"ez123\")\n```\n\n----------------------------------------\n\nTITLE: Handling JSON Parsing Errors with TypeScript\nDESCRIPTION: Shows how JSON parsing can fail with an uncaught exception when invalid JSON is provided, highlighting the need for better error handling.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/intro/morphs-and-more.mdx#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst parseJson = type(\"string\").pipe((s): object => JSON.parse(s))\n// ---cut---\n\n// Uncaught SyntaxError: Expected property name ☠️ // [!code error]\nconst badOut = parseJson('{ unquoted: \"keys\" }')\n```\n\n----------------------------------------\n\nTITLE: Configuring Expected Error Messages in ArkType\nDESCRIPTION: Demonstrates how to use the 'expected' option to customize error messages based on the error context, providing more specific error messages for different error codes.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/configuration/index.mdx#2025-04-11_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst Password = type.string.atLeastLength(8).configure({\n\texpected: ctx =>\n\t\tctx.code === \"minLength\" ? `${ctx.rule} characters or better` : \"way better\"\n})\n// ArkErrors: must be 8 characters or better (was 5)\nconst out1 = Password(\"ez123\").toString()\n// ArkErrors: must be way better (was a number)\nconst out2 = Password(12345678).toString()\n```\n\n----------------------------------------\n\nTITLE: Configuring VSCode Settings for ArkType\nDESCRIPTION: VSCode settings necessary for optimal ArkType functionality. These settings enable autocomplete for ArkType expressions in string literals and prioritize ArkType's \"type\" for auto-imports by excluding certain modules from auto-import suggestions.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/intro/setup.mdx#2025-04-11_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n// allow autocomplete for ArkType expressions like \"string | num\"\n\"editor.quickSuggestions\": {\n\t\"strings\": \"on\"\n},\n// prioritize ArkType's \"type\" for autoimports\n\"typescript.preferences.autoImportSpecifierExcludeRegexes\": [\n\t\"^(node:)?os$\"\n],\n```\n\n----------------------------------------\n\nTITLE: Configuring Type Prototypes\nDESCRIPTION: Shows how to configure prototype handling for special class types in ArkType type inference.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/configuration/index.mdx#2025-04-11_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare global {\n\tinterface ArkEnv {\n\t\tprototypes(): MySpecialClass\n\t}\n}\n\nclass MySpecialClass {}\n\nconst T = type.instanceOf(MySpecialClass)\n//    ^? Type<MySpecialClass>\n```\n\n----------------------------------------\n\nTITLE: Narrow with Type Predicate Using Args Syntax\nDESCRIPTION: Demonstrates implementing a narrow expression with a type predicate using args syntax, checking if a string starts with 'ark' and refining the inferred type.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n// hover to see how the predicate is propagated to the outer `Type`\nconst ArkString = type(\n\t\"string\",\n\t\":\",\n\t(data, ctx): data is `ark${string}` =>\n\t\tdata.startsWith(\"ark\") ?? ctx.reject(\"a string starting with 'ark'\")\n)\n```\n\n----------------------------------------\n\nTITLE: Enhanced ArkErrors with JSON Stringification Support\nDESCRIPTION: ArkErrors are now JSON stringifiable and have two new properties: flatByPath and flatProblemsByPath, providing more structured error information.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/type/CHANGELOG.md#2025-04-11_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst NEvenAtLeast2 = type({\n\tn: \"number % 2 > 2\"\n})\n\nconst out = nEvenAtLeast2({ n: 1 })\n\nif (out instanceof type.errors) {\n\tconsole.log(out.flatByPath)\n\tconst output = {\n\t\tn: [\n\t\t\t{\n\t\t\t\tdata: 1,\n\t\t\t\tpath: [\"n\"],\n\t\t\t\tcode: \"divisor\",\n\t\t\t\tdescription: \"even\",\n\t\t\t\tmeta: {},\n\t\t\t\trule: 2,\n\t\t\t\texpected: \"even\",\n\t\t\t\tactual: \"1\",\n\t\t\t\tproblem: \"must be even (was 1)\",\n\t\t\t\tmessage: \"n must be even (was 1)\"\n\t\t\t},\n\t\t\t{\n\t\t\t\tdata: 1,\n\t\t\t\tpath: [\"n\"],\n\t\t\t\tcode: \"min\",\n\t\t\t\tdescription: \"at least 2\",\n\t\t\t\tmeta: {},\n\t\t\t\trule: 2,\n\t\t\t\texpected: \"at least 2\",\n\t\t\t\tactual: \"1\",\n\t\t\t\tproblem: \"must be at least 2 (was 1)\",\n\t\t\t\tmessage: \"n must be at least 2 (was 1)\"\n\t\t\t}\n\t\t]\n\t}\n\n\tconsole.log(out.flatProblemsByPath)\n\tconst output2 = {\n\t\tn: [\"must be even (was 1)\", \"must be at least 2 (was 1)\"]\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Type Casting in ArkType\nDESCRIPTION: Shows how to use type casting to specify type inference without affecting runtime behavior.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\ntype AutocompletedString = \"foo\" | \"bar\" | (string & {})\n\nconst MyObj = type({\n\tautocompletedString: \"string\" as type.cast<AutocompletedString>\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\ntype AutocompletedString = \"foo\" | \"bar\" | (string & {})\n\nconst MyObj = type({\n\tautocompletedString: type.string.as<AutocompletedString>()\n})\n```\n\n----------------------------------------\n\nTITLE: Using Subtype Keywords with String Syntax in ArkType\nDESCRIPTION: Demonstrates how to use subtype keywords to refine or transform types using string-based syntax. This example shows date-related string refinements and transformations that can validate format or convert strings to Date objects.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/keywords.mdx#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst Keywords = type({\n\tdateFormattedString: \"string.date\",\n\ttransformStringToDate: \"string.date.parse\",\n\tisoFormattedString: \"string.date.iso\",\n\ttransformIsoFormattedStringToDate: \"string.date.iso.parse\"\n})\n```\n\n----------------------------------------\n\nTITLE: Defining BigInt Type with String Syntax in ArkType\nDESCRIPTION: Shows how to define a type that accepts any bigint value using string syntax in ArkType.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst Bigints = type({\n\tfoo: \"bigint\"\n})\n```\n\n----------------------------------------\n\nTITLE: Spread Operator Usage in TypeScript with ArkType\nDESCRIPTION: Demonstrates using the spread operator to merge property sets in ArkType, showing how it handles property merging differently from intersection.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/objects/index.mdx#2025-04-11_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst User = type({ isAdmin: \"false\", name: \"string\" })\n\nconst Admin = type({\n\t\"...\": User,\n\tisAdmin: \"true\",\n\tpermissions: \"string[]\" \n})\n```\n\n----------------------------------------\n\nTITLE: Defining BigInt Type with Fluent Syntax in ArkType\nDESCRIPTION: Shows how to define a type that accepts any bigint value using fluent syntax in ArkType.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst Symbols = type({\n\tfoo: type.bigint\n})\n```\n\n----------------------------------------\n\nTITLE: Property Merging with String Syntax\nDESCRIPTION: Shows how to merge properties using the string syntax and Merge keyword in ArkType.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/objects/index.mdx#2025-04-11_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst types = type.module({\n\tbase: {\n\t\t\"foo?\": \"0\",\n\t\t\"bar?\": \"0\"\n\t},\n\tmerged: {\n\t\tbar: \"1\",\n\t\t\"baz?\": \"1\"\n\t},\n\tresult: \"Merge<base, merged>\"\n})\n\ntype Result = typeof types.result.infer\n```\n\n----------------------------------------\n\nTITLE: Handling exactOptionalPropertyTypes in ArkType\nDESCRIPTION: Documentation of ArkType's handling of optional properties with the exactOptionalPropertyTypes setting, showing validation behavior and how to configure it globally.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/type/CHANGELOG.md#2025-04-11_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst MyObj = type({\n\t\"key?\": \"number\"\n})\n\n// valid data\nconst validResult = myObj({})\n\n// Error: key must be a number (was undefined)\nconst errorResult = myObj({ key: undefined })\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configure } from \"arktype/config\"\n\n// since the default in ArkType is `true`, this will only have an effect if set to `false`\nconfigure({ exactOptionalPropertyTypes: false })\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport \"./config.ts\"\n// import your config file before arktype\nimport { type } from \"arktype\"\n\nconst MyObj = type({\n\t\"key?\": \"number\"\n})\n\n// valid data\nconst validResult = myObj({})\n\n// now also valid data (would be an error by default)\nconst secondResult = myObj({ key: undefined })\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst MyObj = type({\n\tkey: \"number = 5\"\n})\n\n// { key: 5 }\nconst omittedResult = myObj({})\n\n// { key: undefined }\nconst undefinedResult = myObj({ key: undefined })\n```\n\n----------------------------------------\n\nTITLE: Array Type Definition Examples\nDESCRIPTION: Shows different ways to define array types using string, fluent, tuple, and args syntax.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/objects/index.mdx#2025-04-11_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst Arrays = type({\n\tkey: \"string[]\"\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Standalone Functions for N-ary Operators\nDESCRIPTION: Introduction of standalone functions for n-ary operators like type.or, type.and, type.merge, and type.pipe to create combined types with multiple inputs.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/type/CHANGELOG.md#2025-04-11_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n//  accept ...definitions\nconst union = type.or(type.string, \"number\", { key: \"unknown\" })\n\nconst Base = type({\n\tfoo: \"string\"\n})\n\n// accepts ...definitions\nconst intersection = type.and(\n\tbase,\n\t{\n\t\tbar: \"number\"\n\t},\n\t{\n\t\tbaz: \"string\"\n\t}\n)\n\nconst zildjian = Symbol()\n\nconst Base = type({\n\t\"[string]\": \"number\",\n\tfoo: \"0\",\n\t[zildjian]: \"true\"\n})\n\n// accepts ...objectDefinitions\nconst merged = type.merge(\n\tbase,\n\t{\n\t\t\"[string]\": \"bigint\",\n\t\t\"foo?\": \"1n\"\n\t},\n\t{\n\t\tincludeThisPropAlso: \"true\"\n\t}\n)\n\n// accepts ...morphsOrTypes\nconst trimStartToNonEmpty = type.pipe(\n\ttype.string,\n\ts => s.trimStart(),\n\ttype.string.atLeastLength(1)\n)\n```\n\n----------------------------------------\n\nTITLE: Array Length Constraints\nDESCRIPTION: Demonstrates how to apply length constraints to arrays using various comparison operators.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/objects/index.mdx#2025-04-11_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst Bounded = type({\n\tnonEmptyStringArray: \"string[] > 0\",\n\tatLeast3Integers: \"number.integer[] >= 3\",\n\tlessThan10Emails: \"string.email[] < 10\",\n\tatMost5Booleans: \"boolean[] <= 5\"\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Boolean Type with String Syntax in ArkType\nDESCRIPTION: Shows how to define a type that accepts boolean values using string syntax in ArkType.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst Booleans = type({\n\tkey: \"boolean\"\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Tuple Types in TypeScript\nDESCRIPTION: Demonstrates creating a tuple type with a string and nested object containing coordinates.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/objects/index.mdx#2025-04-11_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst MyTuple = type([\n\t\"string\",\n\t// Object definitions can be nested in tuples- and vice versa!\n\t{\n\t\tcoordinates: [\"number\", \"number\"]\n\t}\n])\n```\n\n----------------------------------------\n\nTITLE: Defining BigInt Literals in ArkType\nDESCRIPTION: Demonstrates how to specify exact bigint values in ArkType using the 'n' suffix with string-embedded number literals.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst Literals = type({\n\tbigint: \"1337n\"\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Pattern Matching with Case Record API in TypeScript\nDESCRIPTION: Demonstrates using ArkType's match function with definition strings as keys and corresponding handlers as values. Shows handling of strings, arrays, numbers and bigints with different default behaviors.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/type/CHANGELOG.md#2025-04-11_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { match } from \"arktype\"\n\nconst sizeOf = match({\n\t\"string | Array\": v => v.length,\n\tnumber: v => v,\n\tbigint: v => v,\n\tdefault: \"assert\"\n})\n\n// a match definition is complete once a `default` has been specified,\n// either as a case or via the .default() method\n\nsizeOf(\"abc\") // 3\nsizeOf([1, 2, 3, 4]) // 4\nsizeOf(5n) // 5n\n// ArkErrors: must be an object, a string, a number or a bigint (was boolean)\nsizeOf(true)\n```\n\n----------------------------------------\n\nTITLE: Defining Defaultable Tuple Elements\nDESCRIPTION: Shows how to create tuple types with defaultable elements that have specified default values.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/objects/index.mdx#2025-04-11_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst MyTuple = type([\"string\", \"boolean = false\", \"number = 0\"])\n```\n\n----------------------------------------\n\nTITLE: Using Undefined in Union Types with String Syntax in ArkType\nDESCRIPTION: Shows how to use 'undefined' in a union type and optional properties using string syntax in ArkType.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nconst MyObj = type({\n\trequiredKey: \"number | undefined\",\n\t\"optionalKey?\": \"number | undefined\"\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Optional Tuple Elements\nDESCRIPTION: Demonstrates creating tuple types with optional elements using the ? operator.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/objects/index.mdx#2025-04-11_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst MyTuple = type([\"string\", \"bigint = 999n\", \"boolean?\", \"number?\"])\n```\n\n----------------------------------------\n\nTITLE: Using Private Aliases in ArkType Scopes\nDESCRIPTION: Demonstrates how to use private aliases with the # prefix to create internal definitions that won't be exposed when the scope is exported.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/scopes/index.mdx#2025-04-11_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst shapeScope = scope({\n\t// aliases with a \"#\" prefix are treated as private\n\t\"#BaseShapeProps\": {\n\t\tperimeter: \"number\",\n\t\tarea: \"number\"\n\t},\n\tEllipse: {\n\t\t// when referencing a private alias, the \"#\" should not be included\n\t\t\"...\": \"BaseShapeProps\",\n\t\tradii: [\"number\", \"number\"]\n\t},\n\tRectangle: {\n\t\t\"...\": \"BaseShapeProps\",\n\t\twidth: \"number\",\n\t\theight: \"number\"\n\t}\n})\n\n// private aliases can be referenced from any scoped definition,\n// even outside the original scope\nconst PartialShape = shapeScope.type(\"Partial<BaseShapeProps>\")\n\n// when the scope is exported to a Module, they will not be included\n// hover to see the Scope's exports\nconst shapeModule = shapeScope.export()\n```\n\n----------------------------------------\n\nTITLE: Defining Variadic Tuple Elements\nDESCRIPTION: Shows how to create tuple types with variadic elements using the ... operator.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/objects/index.mdx#2025-04-11_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n// allows a string followed by zero or more numbers\nconst MyTuple = type([\"string\", \"...\", \"number[]\"])\n```\n\n----------------------------------------\n\nTITLE: Configuring exactOptionalPropertyTypes\nDESCRIPTION: Shows how to configure exactOptionalPropertyTypes globally in ArkType to match TypeScript's behavior.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/configuration/index.mdx#2025-04-11_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configure } from \"arktype/config\"\n\n// since the default in ArkType is `true`, this will only have an effect if set to `false`\nconfigure({ exactOptionalPropertyTypes: false })\n```\n\n----------------------------------------\n\nTITLE: Fixing Configure with Selector API\nDESCRIPTION: A fix for the .configure() method with selectors, ensuring that selectors are correctly applied when configuring references.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/type/CHANGELOG.md#2025-04-11_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst User = type({\n\tname: \"string\",\n\tplatform: \"'android' | 'ios'\",\n\t\"version?\": \"number | string\"\n})\n\n// prior to 2.1.15, the selector was not applied\n// when configuring references\nconst ConfiguredUser = User.configure(\n\t{ description: \"A STRING\" },\n\t{\n\t\tkind: \"domain\",\n\t\twhere: d => d.domain === \"string\"\n\t}\n)\n\n// old: A STRING\n// new: A STRING\nConfiguredUser.get(\"name\").description\n\n// old: A STRING\n// new: \"android\" | \"ios\"\nConfiguredUser.get(\"platform\").description\n\n// old: A STRING or undefined\n// new: a number, A STRING or undefined\nConfiguredUser.get(\"version\").description\n```\n\n----------------------------------------\n\nTITLE: Defining String Literals in ArkType\nDESCRIPTION: Demonstrates how to define string literals using both single and double quotes in ArkType type definitions.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst Literals = type({\n\tsingleQuoted: \"'typescript'\",\n\tdoubleQuoted: '\"arktype\"'\n})\n```\n\n----------------------------------------\n\nTITLE: Get Operator Implementation\nDESCRIPTION: Shows how to use the get operator to extract Type values based on key definitions.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/objects/index.mdx#2025-04-11_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst snorfUsage = type.enumerated(\"eating plants\", \"looking adorable\")\n\nconst Manatee = type({\n\tisFriendly: \"true\",\n\tsnorf: {\n\t\tuses: snorfUsage.array()\n\t}\n})\n\nconst True = Manatee.get(\"isFriendly\")\n\nconst SnorfUses = Manatee.get(\"snorf\", \"uses\")\n```\n\n----------------------------------------\n\nTITLE: Defining Symbol Type with String Syntax in ArkType\nDESCRIPTION: Shows how to define a type that accepts any symbol value using string syntax in ArkType.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nconst Symbols = type({\n\tkey: \"symbol\"\n})\n```\n\n----------------------------------------\n\nTITLE: Using the Select Method for Type Introspection\nDESCRIPTION: Introduction of the select method for introspecting type references and using selectors to configure references, allowing targeted customization.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/type/CHANGELOG.md#2025-04-11_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// extract deep references to exclusive `min` nodes\nconst result = myType.select({\n\tkind: \"min\",\n\twhere: node => node.exclusive\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// configure string node references\nconst result = myType.configure(\n\t{ description: \"a referenced string\" },\n\t{\n\t\tkind: \"domain\",\n\t\twhere: node => node.domain === \"string\"\n\t}\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Boolean Type with Fluent Syntax in ArkType\nDESCRIPTION: Shows how to define a type that accepts boolean values using fluent syntax in ArkType.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nconst Booleans = type({\n\tkey: type.boolean\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Higher-Kinded Types (HKT) in ArkType\nDESCRIPTION: Shows an advanced implementation of Higher-Kinded Types in ArkType, using the 'Partial' type as an example. It demonstrates how to create custom generic types with complex behavior.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/generics/index.mdx#2025-04-11_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generic, Hkt } from \"arktype\"\n\nconst Partial = generic([\"T\", \"object\"])(\n\targs => args.T.partial(),\n\tclass PartialHkt extends Hkt<[object]> {\n\t\tdeclare body: Partial<this[0]>\n\t}\n)\n```\n\n----------------------------------------\n\nTITLE: Input Narrowing and Property Matching in ArkType\nDESCRIPTION: Demonstrates type narrowing with .in and property matching with .at methods for discriminated unions.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/type/CHANGELOG.md#2025-04-11_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ntype Data =\n\t| {\n\t\t\tid: 1\n\t\t\toneValue: number\n\t  }\n\t| {\n\t\t\tid: 2\n\t\t\ttwoValue: string\n\t  }\n\nconst discriminateValue = match\n\t// .in allows you to specify the input TypeScript allows for your matcher\n\t.in<Data>()\n\t// .at allows you to specify a key at which your input will be matched\n\t.at(\"id\")\n\t.match({\n\t\t1: o => `${o.oneValue}!`,\n\t\t2: o => o.twoValue.length,\n\t\tdefault: \"assert\"\n\t})\n\ndiscriminateValue({ id: 1, oneValue: 1 }) // \"1!\"\ndiscriminateValue({ id: 2, twoValue: \"two\" }) // 3\ndiscriminateValue({ oneValue: 3 })\n```\n\n----------------------------------------\n\nTITLE: Defining Boolean Literals with String Syntax in ArkType\nDESCRIPTION: Demonstrates how to specify exact boolean values and unions of boolean values using string syntax in ArkType.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nconst Booleans = type({\n\ta: \"true\",\n\tb: \"false\",\n\t// equivalent to the \"boolean\" keyword\n\tc: \"true | false\"\n})\n```\n\n----------------------------------------\n\nTITLE: Using import() for Private Alias Conversion in ArkType\nDESCRIPTION: Shows how to use the import() method to reference utilities internally without including them in the exported module. Demonstrates creating utilities that extend objects with IDs.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/scopes/index.mdx#2025-04-11_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst utilityScope = scope({\n\t\"withId<o extends object>\": {\n\t\t\"...\": \"o\",\n\t\tid: \"string\"\n\t}\n})\n\nconst userModule = type.module({\n\t// because we use `import()` here, we can reference our utilities\n\t// internally, but they will not be included in `userModule`.\n\t// if we used `export()` instead, `withId` could be accessed on `userModule`.\n\t...utilityScope.import(),\n\tPayload: {\n\t\tname: \"string\",\n\t\tage: \"number\"\n\t},\n\tdb: \"withId<Payload>\"\n})\n```\n\n----------------------------------------\n\nTITLE: Using Null in Union Types with String Syntax in ArkType\nDESCRIPTION: Demonstrates how to use the 'null' keyword in a union type using string syntax in ArkType to create nullable types.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nconst MyObj = type({\n\tfoo: \"number | null\"\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Rooted Submodules in ArkType\nDESCRIPTION: Demonstrates how to create rooted submodules that can be referenced both as types themselves and as prefixes for accessing subaliases. Shows extending base types with subaliases.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/scopes/index.mdx#2025-04-11_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst userModule = type.module({\n\troot: {\n\t\tname: \"string\"\n\t},\n\t// subaliases can extend a base type by referencing 'root'\n\t// like any other alias\n\tAdmin: {\n\t\t\"...\": \"root\",\n\t\tisAdmin: \"true\"\n\t},\n\tSaiyan: {\n\t\t\"...\": \"root\",\n\t\tpowerLevel: \"number > 9000\"\n\t}\n})\n\nconst types = type.module({\n\tUser: userModule,\n\t// user can now be referenced directly in a definition\n\tGroup: \"User[]\",\n\t// or used as a prefix to access subaliases\n\tElevatedUser: \"User.Admin | User.Saiyan\"\n})\n```\n\n----------------------------------------\n\nTITLE: Using Null in Union Types with Fluent Syntax in ArkType\nDESCRIPTION: Demonstrates how to use the null type in a union type using fluent syntax in ArkType to create nullable types.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nconst MyObj = type({\n\tfoo: type.number.or(type.null)\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Symbol Type with Fluent Syntax in ArkType\nDESCRIPTION: Shows how to define a type that accepts any symbol value using fluent syntax in ArkType.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/primitives/index.mdx#2025-04-11_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst Symbols = type({\n\tkey: type.symbol\n})\n```\n\n----------------------------------------\n\nTITLE: Improved JSDoc and Go-to Definition for Unparsed Keys\nDESCRIPTION: Enhancements to provide better IDE support for unparsed keys, including JSDoc comments and go-to definition functionality.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/type/CHANGELOG.md#2025-04-11_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst T = type({\n\t/** FOO */\n\tfoo: \"string\",\n\t/** BAR */\n\tbar: \"number?\"\n})\n\nconst out = T.assert({ foo: \"foo\" })\n\n// go-to definition will now navigate to the foo prop from the type call\n// hovering foo now displays \"FOO\"\nconsole.log(out.foo)\n\n// go-to definition will now navigate to the bar prop from the type call\n// hovering bar now displays \"BAR\"\n// (the ? must be in the value for this to work)\nconsole.log(out.bar)\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Scope in TypeScript with ArkType\nDESCRIPTION: Creates a custom scope with type aliases for Id, User, and UsersById. Demonstrates how to reference custom aliases within scope definitions.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/scopes/index.mdx#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { scope } from \"arktype\"\n\nconst coolScope = scope({\n\t// keywords are still available in your scope\n\tId: \"string\",\n\t// but you can also reference your own aliases directly!\n\tUser: { id: \"Id\", friends: \"Id[]\" },\n\t// your aliases will be autocompleted and validated alongside ArkType's keywords\n\tUsersById: {\n\t\t\"[Id]\": \"User | undefined\"\n\t}\n})\n```\n\n----------------------------------------\n\nTITLE: Type-Safe JSON Schema Numeric Definition\nDESCRIPTION: Demonstrates type-safe JSON Schema definition for numeric values with TypeScript validation\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/json-schema/README.md#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { JsonSchema } from \"arktype\"\n\nconst integerSchema: JsonSchema.Numeric = {\n\ttype: \"integer\",\n\tmultipleOf: \"3\" // errors stating that 'multipleOf' must be a number\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect vs Correct Scope Definition Patterns in ArkType\nDESCRIPTION: Demonstrates the correct way to reference scoped definitions within a scope. Shows why wrapping definitions in type() fails and how to properly define entities within a scope.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/scopes/index.mdx#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// @errors: 2322\nconst badScope = scope({\n\tId: \"string\",\n\t// ❌ wrapping this definition in `type` will fail\n\tBadEntity: type({\n\t\tid: \"Id\"\n\t}),\n\t// ✅ reference scoped definitions directly instead of wrapping them\n\tGoodEntity: {\n\t\tid: \"Id\"\n\t}\n})\n```\n\n----------------------------------------\n\nTITLE: Simplified Error Configuration with Strings in ArkType\nDESCRIPTION: Shows how error configurations in ArkType now accept a string directly instead of requiring a function. This simplifies setting static error messages for types.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/blog/2.1.mdx#2025-04-11_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst CustomOne = type(\"1\", \"@\", {\n\t// previously only a function returning a string was allowed here\n\tmessage: \"Yikes.\"\n})\n\n// ArkErrors: Yikes.\nCustomOne(2)\n```\n\n----------------------------------------\n\nTITLE: Creating Types from a Scope in ArkType\nDESCRIPTION: Shows how to use a scope to create new types that can access the scope's aliases. Demonstrates defining a 'group' type and chaining definitions while preserving the scope context.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/scopes/index.mdx#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst coolScope = scope({\n\tId: \"string\",\n\tUser: { id: \"Id\", friends: \"Id[]\" },\n\tUsersById: {\n\t\t\"[Id]\": \"User | undefined\"\n\t}\n})\n\nconst group = coolScope.type({\n\tname: \"string\",\n\tmembers: \"User[]\"\n})\n\n// chained definitions are parsed in the same scope as the original Type\nconst ownedGroup = group.and({\n\townerId: \"Id\"\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring In-Place Mutation by Disabling Cloning in ArkType\nDESCRIPTION: Shows how to disable cloning completely, causing ArkType to mutate input objects directly when applying morphs, which can be more efficient but changes the original data.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/configuration/index.mdx#2025-04-11_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configure } from \"arktype/config\"\n\nconfigure({ clone: false })\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport \"./config.ts\"\n// import your config file before arktype\nimport { type } from \"arktype\"\n\nconst UserForm = type({\n\tage: \"string.numeric.parse\"\n})\n\nconst formData = {\n\tage: \"42\"\n}\n\nconst out = UserForm(formData)\n\n// the original object's age key is now a number\nconsole.log(formData.age)\n```\n\n----------------------------------------\n\nTITLE: Inline Scope Export in ArkType\nDESCRIPTION: Demonstrates how to export a scope inline when you don't need to reuse it for creating additional types.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/scopes/index.mdx#2025-04-11_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst ezModule = scope({\n\tEz: \"'moochi'\"\n}).export()\n```\n\n----------------------------------------\n\nTITLE: Using Thunk Definition in Arktype Scope for Complex Types\nDESCRIPTION: This snippet shows how to use a thunk definition to access the `type` method on the Scope being defined, allowing for more complex type definitions with fluent methods.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/scopes/index.mdx#2025-04-11_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst $ = scope({\n\tId: \"string#id\",\n\texpandUserGroup: () =>\n\t\t$.type({\n\t\t\tname: \"string\",\n\t\t\tid: \"Id\"\n\t\t})\n\t\t\t.or(\"Id\")\n\t\t\t.pipe(user =>\n\t\t\t\ttypeof user === \"string\" ? { id: user, name: \"Anonymous\" } : user\n\t\t\t)\n\t\t\t.array()\n\t\t\t.atLeastLength(2)\n})\n\nconst types = $.export()\n\n// input is validated and transformed to:\n// [{ name: \"Magical Crawdad\", id: \"777\" }, { name: \"Anonymous\", id: \"778\" }]\nconst groups = types.expandUserGroup([\n\t{ name: \"Magical Crawdad\", id: \"777\" },\n\t\"778\"\n])\n```\n\n----------------------------------------\n\nTITLE: String-Embeddable Pipe Operator\nDESCRIPTION: The |> operator can now be used within string type definitions to pipe output to another Type, providing a more concise way to compose transformations.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/type/CHANGELOG.md#2025-04-11_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst TrimToNonEmpty = type(\"string.trim |> string > 0\")\n\nconst Equivalent = type(\"string.trim\").to(\"string > 0\")\n```\n\n----------------------------------------\n\nTITLE: Creating Submodules in ArkType\nDESCRIPTION: Demonstrates how to create submodules to group related aliases with a shared prefix. Shows how to reference subaliases in type definitions.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/scopes/index.mdx#2025-04-11_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst subAliases = type.module({ alias: \"number\" })\n\nconst rootScope = scope({\n\ta: \"string\",\n\tb: \"sub.alias\",\n\tsub: subAliases\n})\n\nconst myType = rootScope.type({\n\tsomeKey: \"sub.alias[]\"\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Recursive Types with 'this' in ArkType\nDESCRIPTION: Shows how to create recursive type definitions using the 'this' keyword and scope-based alternatives.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/expressions/index.mdx#2025-04-11_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nconst DisappointingGift = type({\n\tlabel: \"string\",\n\t\"box?\": \"this\"\n})\n\nconst out = DisappointingGift({\n\tlabel: \"foo\",\n\tbox: { label: \"bar\", box: {} }\n})\n\nif (out instanceof type.errors) {\n\tconsole.error(out.summary)\n} else {\n\tconsole.log(out.box?.box?.label)\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst types = scope({\n\tDisappointingGift: {\n\t\tlabel: \"string\",\n\t\t\"box?\": \"DisappointingGift\"\n\t}\n}).export()\n```\n\n----------------------------------------\n\nTITLE: Nesting Submodules in ArkType\nDESCRIPTION: Shows how to nest submodules to arbitrary depth. Demonstrates referencing nested subaliases in type definitions.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/scopes/index.mdx#2025-04-11_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst subAliases = type.module({ alias: \"number\" })\n\nconst rootScope = scope({\n\ta: \"string\",\n\tb: \"sub.alias\",\n\tsub: subAliases\n})\n\nconst rootScopeSquared = scope({\n\t// reference rootScope from our previous example\n\tnewRoot: rootScope.export()\n})\n\nconst myNewType = rootScopeSquared.type({\n\tsomeOtherKey: \"newRoot.sub.alias | boolean\"\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Postfix Tuple Elements\nDESCRIPTION: Demonstrates creating tuple types with postfix elements after variadic elements.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/objects/index.mdx#2025-04-11_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n// allows zero or more numbers followed by a boolean, then a string\nconst MyTuple = type([\"...\", \"number[]\", \"boolean\", \"string\"])\n```\n\n----------------------------------------\n\nTITLE: Fixing Error Message Configuration for Non-Serializable Config\nDESCRIPTION: A fix for an issue where non-serializable error configuration would lead to incorrect error messages in JIT-mode cases.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/type/CHANGELOG.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst MyUnion = type('\"abc\" | \"cde\"').configure({\n\tmessage: () => \"fail\"\n})\n\n// old: \"$ark.message\"\n// new: \"fail\"\nMyUnion.assert(\"efg\")\n```\n\n----------------------------------------\n\nTITLE: Correcting Nested Type in Scope Error in TypeScript\nDESCRIPTION: This snippet demonstrates how to correctly define a scope without using a nested `type` call, which would cause an error.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/scopes/index.mdx#2025-04-11_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst myScope = scope({\n\tId: \"string#id\",\n\tUser: {\n\t\tname: \"string\",\n\t\t// now resolves correctly\n\t\tid: \"Id\"\n\t}\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Date Literals\nDESCRIPTION: Shows how to create date literal types for exact date values.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/objects/index.mdx#2025-04-11_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nconst Literals = type({\n\tsingleQuoted: \"d'01-01-1970'\",\n\tdoubleQuoted: 'd\"01-01-1970\"'\n})\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Thunk Usage Outside of Scope Definition\nDESCRIPTION: This snippet illustrates that thunk definitions can be used anywhere a `Type` definition is expected, although it's not recommended for clarity and elegance.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/scopes/index.mdx#2025-04-11_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n// you *can* use them anywhere, but *should* you? (no)\nconst MyInelegantType = type(() =>\n\ttype({ inelegantKey: () => type(\"'inelegant value'\") })\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Date Ranges\nDESCRIPTION: Demonstrates creating date types with range constraints using comparison operators.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/objects/index.mdx#2025-04-11_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst tenYearsAgo = new Date()\n\t.setFullYear(new Date().getFullYear() - 10)\n\t.valueOf()\n\nconst Bounded = type({\n\tdateInTheLast10Years: `${tenYearsAgo} <= Date < ${Date.now()}`\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Keywords in ArkType\nDESCRIPTION: Shows how to globally configure builtin keywords for customizing error messages across an application.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/type/CHANGELOG.md#2025-04-11_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configure } from \"arktype/config\"\n\nconfigure({\n\tkeywords: {\n\t\tstring: \"shorthand description\",\n\t\t\"string.email\": {\n\t\t\tactual: () => \"definitely fake\"\n\t\t}\n\t}\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport \"./config.ts\"\nimport { type } from \"arktype\"\n\nconst User = type({\n\tname: \"string\",\n\temail: \"string.email\"\n})\n\nconst out = user({\n\t// ArkErrors: name must be shorthand description (was a number)\n\tname: 5,\n\t// ArkErrors: email must be an email address (was definitely fake)\n\temail: \"449 Canal St\"\n})\n```\n\n----------------------------------------\n\nTITLE: Using instanceof Type Check\nDESCRIPTION: Shows how to use instanceof to constrain types to specific classes.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/objects/index.mdx#2025-04-11_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nclass MyClass {}\n\nconst instances = type.instanceOf(MyClass)\n```\n\n----------------------------------------\n\nTITLE: Improving Completion Triggers for Shallow String Definitions in TypeScript\nDESCRIPTION: An optimization to trigger autocomplete faster for shallow string definitions. This demonstrates the performance improvement between old and new versions.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/type/CHANGELOG.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// old: ~1s delay after typing this before completions\n// new: completions are almost instant\ntype(\"\")\n```\n\n----------------------------------------\n\nTITLE: Equivalent ArkType Definition\nDESCRIPTION: Shows the equivalent direct ArkType type definition for string validation with length constraints\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/json-schema/README.md#2025-04-11_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { type } from \"arktype\"\n\nconst T = type(\"5<=string<=10\")\n```\n\n----------------------------------------\n\nTITLE: Converting ArkType to JSON Schema\nDESCRIPTION: Example of converting an ArkType Type to JSON Schema using the built-in toJsonSchema() method\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/json-schema/README.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type } from \"arktype\"\n\n// { type: \"string\", minLength: 5, maxLength: 10 }\nconst schema = type(\"5<=string<=10\").toJsonSchema()\n```\n\n----------------------------------------\n\nTITLE: Using Tuple and Args Expressions with .to Operator\nDESCRIPTION: Demonstrates different ways to use the .to operator for piping to parsed definitions, including fluent, tuple and spread args syntax.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/type/CHANGELOG.md#2025-04-11_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst FluentStillWorks = type(\"string.numeric.parse\").to(\"number % 2\")\n\nconst NowSoDoesTuple = type({\n\tsomeKey: [\"string.numeric.parse\", \"|>\", \"number % 2\"]\n})\n\nconst AndSpreadArgs = type(\"string.numeric.parse\", \"|>\", \"number % 2\")\n```\n\n----------------------------------------\n\nTITLE: Comparing Types with Regex in TypeScript\nDESCRIPTION: Shows how to use regex or partial matching for toString assertions on types. This can be used to check if a type matches a certain pattern without requiring an exact match.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/attest/CHANGELOG.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// ok\nattest({ ark: \"type\" }).type.toString(/^{.*}$/)\n\n// AssertionError: Actual string 'string[]' did not match regex '^{.*}$'\nattest([\"ark\", \"type\"]).type.toString(/^{.*}$/)\n```\n\n----------------------------------------\n\nTITLE: Fixing Metatype Extraction from Recursive Definitions\nDESCRIPTION: A fix for an issue where metatypes like Default and Out were not being extracted correctly from recursive definitions, showing the difference in behavior before and after the fix.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/type/CHANGELOG.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst T = type({\n\tdefaulted: \"number = 0\",\n\t\"nested?\": \"this\"\n})\n\nconst t = T.assert({})\n\n// old: Default<number, 0> | undefined\n// new: number | undefined\nt.nested?.defaulted\n```\n\n----------------------------------------\n\nTITLE: Working Around Degenerate Global Prototype Resolutions\nDESCRIPTION: A workaround for environments where global prototypes like FormData have degenerate resolutions, showing how type inference is improved.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/type/CHANGELOG.md#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst T = type(\"string.numeric.parse\")\n\n// previously, if a global prototype like FormData resolved to {}, it prevented\n// ArkType from extracting the input/output of morphs, leading to inference like the following:\n\n// old (with @bun/types): (In: string) => To<number>\n// new (with @bun/types): number\ntype Parsed = typeof T.inferOut\n```\n\n----------------------------------------\n\nTITLE: Replacing withMeta Method with Configure + Selector\nDESCRIPTION: The internal .withMeta method was removed in favor of using .configure with a self-selector, providing a more consistent API.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/type/CHANGELOG.md#2025-04-11_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// < 2.1.15\nmyType.withMeta(\"some shallow description\")\n\n// >= 2.1.15\nmyType.configure(\"some shallow description\", \"self\")\n```\n\n----------------------------------------\n\nTITLE: Improving Expression Display for Regex Constraints\nDESCRIPTION: An improvement to the .expression property for regex constraints, making it display the regex pattern more clearly.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/type/CHANGELOG.md#2025-04-11_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst T = type(/^a.*z$/)\n\n// old: string /^a.*z$/\n// new: /^a.*z$/\nconsole.log(T.expression)\n```\n\n----------------------------------------\n\nTITLE: Using satisfies for Type Assertions in TypeScript\nDESCRIPTION: Demonstrates how to use the satisfies method to assert that a value matches a specific ArkType definition. This allows for more flexible type checking beyond exact matches.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/attest/CHANGELOG.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// ok\nattest({ ark: \"type\" }).type.toString.satisfies(/^{.*}$/)\n\n// AssertionError: ark must be a number (was string)\nattest({ ark: \"type\" }).satisfies({ ark: \"number\" })\n```\n\n----------------------------------------\n\nTITLE: Simplified Error Configuration in ArkType\nDESCRIPTION: Shows how error configurations now accept string literals directly instead of requiring functions.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/type/CHANGELOG.md#2025-04-11_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nconst CustomOne = type(\"1\", \"@\", {\n\t// previously only a function returning a string was allowed here\n\tmessage: \"Yikes.\"\n})\n\n// ArkErrors: Yikes.\ncustomOne(2)\n```\n\n----------------------------------------\n\nTITLE: Formatting Serialized Types with Prettier in TypeScript\nDESCRIPTION: Shows how serialized types are now formatted using Prettier, making long serialized types more readable. This example compares the old and new formatting styles.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/attest/CHANGELOG.md#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// old\nattest({\n\tark: \"type\",\n\ttype: \"script\",\n\tvali: \"dator\",\n\topti: \"mized\",\n\tfrom: \"editor\",\n\tto: \"runtime\"\n}).type.toString.snap(\n\t`{ \tark: string; type: string; vali: string; opti: string; from: string; to: string; }`\n)\n\n// new\nattest({\n\tark: \"type\",\n\ttype: \"script\",\n\tvali: \"dator\",\n\topti: \"mized\",\n\tfrom: \"editor\",\n\tto: \"runtime\"\n}).type.toString.snap(`{\n\tark: string\n\ttype: string\n\tvali: string\n\topti: string\n\tfrom: string\n\tto: string\n}`)\n```\n\n----------------------------------------\n\nTITLE: Configuring Jitless Mode\nDESCRIPTION: Shows how to disable JIT compilation of validation logic in ArkType.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/configuration/index.mdx#2025-04-11_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configure } from \"arktype/config\"\n\nconfigure({ jitless: true })\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport \"./config.ts\"\n// import your config file before arktype\nimport { type } from \"arktype\"\n\n// will not be precompiled\nconst MyObject = type({\n\tfoo: \"string\"\n})\n```\n\n----------------------------------------\n\nTITLE: Installing Attest Package\nDESCRIPTION: Command for installing the Attest package via npm. The package is currently in alpha state.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/attest/README.md#2025-04-11_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @ark/attest\n```\n\n----------------------------------------\n\nTITLE: Configuring onFail Handler\nDESCRIPTION: Example of setting up global error handling for validation failures in ArkType.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/configuration/index.mdx#2025-04-11_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configure } from \"arktype/config\"\n\nconst config = configure({\n\tonFail: errors => errors.throw()\n})\n\n// be sure to specify both the runtime and static configs\n\ndeclare global {\n\tinterface ArkEnv {\n\t\tonFail: typeof config.onFail\n\t}\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport \"./config.ts\"\n// import your config file before arktype\nimport { type } from \"arktype\"\n\n// data is inferred as string- no need to discriminate!\nconst data = type.string(\"foo\")\n\n// now thrown instead of returned\n// ArkErrors: must be a string (was number)\nconst bad = type.string(5)\n```\n\n----------------------------------------\n\nTITLE: Configuring Vitest for Attest\nDESCRIPTION: Configuration for Vitest to use Attest's global setup. This is added to the vitest.config.ts file.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/attest/README.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from \"vitest/config\"\n\nexport default defineConfig({\n\ttest: {\n\t\tglobalSetup: [\"setupVitest.ts\"]\n\t}\n})\n```\n\n----------------------------------------\n\nTITLE: Asserting JSDoc Contents in TypeScript\nDESCRIPTION: Demonstrates how to use attest to check JSDoc comments associated with a value. This snippet shows asserting the JSDoc content for a property in a typed object.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/attest/CHANGELOG.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst T = type({\n\t/** FOO */\n\tfoo: \"string\"\n})\n\nconst out = T.assert({ foo: \"foo\" })\n\n// match or snapshot expected jsdoc associated with the value passed to attest\nattest(out.foo).jsdoc.snap(\"FOO\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Mocha for Attest\nDESCRIPTION: Mocha configuration in package.json to require the Attest setup file before running tests.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/attest/README.md#2025-04-11_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n\"mocha\": {\n\t\"require\": \"./setupMocha.ts\"\n}\n```\n\n----------------------------------------\n\nTITLE: Attest Options Setup Example\nDESCRIPTION: Example showing how to configure Attest options in the setup file.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/attest/README.md#2025-04-11_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as attest from \"@ark/attest\"\n\nexport const setup = () =>\n\tattest.setup({\n\t\tskipTypes: true,\n\t\tbenchPercentThreshold: 10\n\t})\n```\n\n----------------------------------------\n\nTITLE: Setting Up Attest with Mocha\nDESCRIPTION: Implementation of the setupMocha.ts file that initializes and tears down Attest for Mocha tests.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/attest/README.md#2025-04-11_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { setup, teardown } from \"@ark/attest\"\n\n// config options can be passed here\nexport const mochaGlobalSetup = () => setup({})\n\nexport const mochaGlobalTeardown = teardown\n```\n\n----------------------------------------\n\nTITLE: Setting Up Attest with Vitest\nDESCRIPTION: Implementation of the setupVitest.ts file that initializes Attest for use with Vitest tests.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/attest/README.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { setup } from \"@ark/attest\"\n\n// config options can be passed here\nexport default () => setup({})\n```\n\n----------------------------------------\n\nTITLE: Examples of Attest Type Assertions and Snapshots\nDESCRIPTION: Examples demonstrating various Attest features including type assertions, error assertions, completion snapshotting, JSDoc snapshotting, and performance benchmarking.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/attest/README.md#2025-04-11_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// @ark/attest assertions can be made from any unit test framework with a global setup/teardown\ndescribe(\"attest features\", () => {\n\tit(\"type and value assertions\", () => {\n\t\tconst Even = type(\"number%2\")\n\t\t// asserts even.infer is exactly number\n\t\tattest<number>(even.infer)\n\t\t// make assertions about types and values seamlessly\n\t\tattest(even.infer).type.toString.snap(\"number\")\n\t\t// including object literals- no more long inline strings!\n\t\tattest(even.json).snap({\n\t\t\tintersection: [{ domain: \"number\" }, { divisor: 2 }]\n\t\t})\n\t})\n\n\tit(\"error assertions\", () => {\n\t\t// Check type errors, runtime errors, or both at the same time!\n\t\t// @ts-expect-error\n\t\tattest(() => type(\"number%0\")).throwsAndHasTypeError(\n\t\t\t\"% operator must be followed by a non-zero integer literal (was 0)\"\n\t\t)\n\t\t// @ts-expect-error\n\t\tattest(() => type({ \"[object]\": \"string\" })).type.errors(\n\t\t\t\"Indexed key definition 'object' must be a string, number or symbol\"\n\t\t)\n\t})\n\n\tit(\"completion snapshotting\", () => {\n\t\t// snapshot expected completions for any string literal!\n\t\t// @ts-expect-error (if your expression would throw, prepend () =>)\n\t\tattest(() => type({ a: \"a\", b: \"b\" })).completions({\n\t\t\ta: [\"any\", \"alpha\", \"alphanumeric\"],\n\t\t\tb: [\"bigint\", \"boolean\"]\n\t\t})\n\t\ttype Legends = { faker?: \"🐐\"; [others: string]: unknown }\n\t\t// works for keys or index access as well (may need prettier-ignore to avoid removing quotes)\n\t\t// prettier-ignore\n\t\tattest({ \"f\": \"🐐\" } as Legends).completions({ \"f\": [\"faker\"] })\n\t})\n\n\tit(\"jsdoc snapshotting\", () => {\n\t\t// match or snapshot expected jsdoc associated with the value passed to attest\n\t\tconst T = type({\n\t\t\t/** FOO */\n\t\t\tfoo: \"string\"\n\t\t})\n\n\t\tconst out = T.assert({ foo: \"foo\" })\n\n\t\tattest(out.foo).jsdoc.snap(\"FOO\")\n\t})\n\n\tit(\"integrate runtime logic with type assertions\", () => {\n\t\tconst ArrayOf = type(\"<t>\", \"t[]\")\n\t\tconst numericArray = arrayOf(\"number | bigint\")\n\t\t// flexibly combine runtime logic with type assertions to customize your\n\t\t// tests beyond what is possible from pure static-analysis based type testing tools\n\t\tif (getTsVersionUnderTest().startsWith(\"5\")) {\n\t\t\t// this assertion will only occur when testing TypeScript 5+!\n\t\t\tattest<(number | bigint)[]>(numericArray.infer)\n\t\t}\n\t})\n\n\tit(\"integrated type performance benchmarking\", () => {\n\t\tconst User = type({\n\t\t\tkind: \"'admin'\",\n\t\t\t\"powers?\": \"string[]\"\n\t\t})\n\t\t\t.or({\n\t\t\t\tkind: \"'superadmin'\",\n\t\t\t\t\"superpowers?\": \"string[]\"\n\t\t\t})\n\t\t\t.or({\n\t\t\t\tkind: \"'pleb'\"\n\t\t\t})\n\t\tattest.instantiations([7574, \"instantiations\"])\n\t})\n})\n```\n\n----------------------------------------\n\nTITLE: Test Scripts Configuration\nDESCRIPTION: Example package.json scripts for running tests with and without type checking.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/attest/README.md#2025-04-11_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n\t\t\"test\": \"ATTEST_skipTypes=1 vitest run\",\n\t\t\"testWithTypes\": \"vitest run\",\n```\n\n----------------------------------------\n\nTITLE: Basic Type Benchmarking Example\nDESCRIPTION: Example of using Attest to benchmark the number of type instantiations used in complex templated types.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/attest/README.md#2025-04-11_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// Combinatorial template literals often result in expensive types- let's benchmark this one!\ntype makeComplexType<s extends string> =\n\ts extends `${infer head}${infer tail}` ? head | tail | makeComplexType<tail>\n\t:\ts\n\nbench(\"bench type\", () => {\n\treturn {} as makeComplexType<\"defenestration\">\n\t// This is an inline snapshot that will be populated or compared when you run the file\n}).types([169, \"instantiations\"])\n\nbench(\n\t\"bench runtime and type\",\n\t() => {\n\t\treturn {} as makeComplexType<\"antidisestablishmentarianism\">\n\t},\n\tfakeCallOptions\n)\n\t// Average time it takes the function execute\n\t.mean([2, \"ms\"])\n\t// Seems like our type is O(n) with respect to the length of the input- not bad!\n\t.types([337, \"instantiations\"])\n```\n\n----------------------------------------\n\nTITLE: Setting up Type API documentation page using JSX/MDX\nDESCRIPTION: A simple documentation page setup for the Type API using MDX format. It includes a title section and an ApiTable component that displays API details for the 'Type' group.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/type-api.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n---\ntitle: Type API\n---\n\n<ApiTable group=\"Type\" />\n```\n\n----------------------------------------\n\nTITLE: API Benchmarking with Baseline\nDESCRIPTION: Example showing how to benchmark an API with a baseline expression to avoid counting initial instantiations.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/attest/README.md#2025-04-11_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { bench } from \"@ark/attest\"\nimport { type } from \"arktype\"\n\n// baseline expression\ntype(\"boolean\")\n\nbench(\"single-quoted\", () => {\n\tconst _ = type(\"'nineteen characters'\")\n\t// would be 2697 without baseline\n}).types([610, \"instantiations\"])\n\nbench(\"keyword\", () => {\n\tconst _ = type(\"string\")\n\t// would be 2507 without baseline\n}).types([356, \"instantiations\"])\n```\n\n----------------------------------------\n\nTITLE: Creating LinkCard Components for Blog Post Navigation in JSX\nDESCRIPTION: This code defines two LinkCard components that serve as navigation links to blog posts announcing ArkType version releases. Each card includes a title, description, link to the full post, and publication date.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/content/docs/blog/index.mdx#2025-04-11_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n<LinkCard\n\ttitle=\"Announcing ArkType 2.1\"\n\tdescription=\"Optimized pattern matching from type syntax\"\n\thref=\"/docs/blog/2.1\"\n\tdate=\"February 27, 2025\"\n/>\n\n<LinkCard\n\ttitle=\"Announcing ArkType 2.0\"\n\tdescription=\"100x faster validation with DX that will blow your mind\"\n\thref=\"/docs/blog/2.0\"\n\tdate=\"January 17, 2025\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Running Attest Stats CLI Command\nDESCRIPTION: Example of using the Attest CLI to run the stats command, which summarizes type performance metrics across packages.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/attest/README.md#2025-04-11_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nnpm run attest stats packages/*\n```\n\n----------------------------------------\n\nTITLE: Sponsor Table HTML Markup\nDESCRIPTION: HTML table markup displaying project sponsors with their GitHub avatars and links.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/README.md#2025-04-11_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<table>\n    <tr>\n        <th>sam-goodwin</th>\n        <th>inspatiallabs</th>\n    </tr>\n    <tr>\n        <td>\n            <a href=\"https://github.com/sam-goodwin\"\n                ><img\n                    height=\"64px\"\n                    src=\"https://avatars.githubusercontent.com/sam-goodwin\"\n            /></a>\n        </td>\n        <td>\n            <a href=\"https://github.com/inspatiallabs\"\n                ><img\n                    height=\"64px\"\n                    src=\"https://avatars.githubusercontent.com/inspatiallabs\"\n            /></a>\n        </td>\n    </tr>\n</table>\n```\n\n----------------------------------------\n\nTITLE: Running Development Server for Next.js Application\nDESCRIPTION: Commands for starting the development server of a Next.js application using different package managers.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/ark/docs/README.md#2025-04-11_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n# or\npnpm dev\n# or\nyarn dev\n```\n\n----------------------------------------\n\nTITLE: Project Header HTML Markup\nDESCRIPTION: HTML markup for the project header section including title, description and video element.\nSOURCE: https://github.com/arktypeio/arktype/blob/main/README.md#2025-04-11_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<h1 align=\"center\">ArkType</h1>\n<h3 align=\"center\"><i>TypeScript's 1:1 validator, optimized from editor to runtime</i></h1>\n\n<video\nautoPlay\nloop\ncontrols\nplaysInline\nmuted\ndisablePictureInPicture\nsrc=\"https://github.com/user-attachments/assets/69fdded6-50a9-402d-a28c-afa58db63c90\"\n/>\n```"
  }
]