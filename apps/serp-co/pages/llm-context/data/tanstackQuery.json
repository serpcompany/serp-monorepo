[
  {
    "owner": "tanstack",
    "repo": "query",
    "content": "TITLE: Implementing Basic Todo App with TanStack Query\nDESCRIPTION: Demonstrates setting up a basic Todo application using TanStack Query, including client setup, queries for fetching todos, mutations for adding new todos, and query invalidation for data refetching. Shows integration with React components and proper provider setup.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/quick-start.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  useQuery,\n  useMutation,\n  useQueryClient,\n  QueryClient,\n  QueryClientProvider,\n} from '@tanstack/react-query'\nimport { getTodos, postTodo } from '../my-api'\n\n// Create a client\nconst queryClient = new QueryClient()\n\nfunction App() {\n  return (\n    // Provide the client to your App\n    <QueryClientProvider client={queryClient}>\n      <Todos />\n    </QueryClientProvider>\n  )\n}\n\nfunction Todos() {\n  // Access the client\n  const queryClient = useQueryClient()\n\n  // Queries\n  const query = useQuery({ queryKey: ['todos'], queryFn: getTodos })\n\n  // Mutations\n  const mutation = useMutation({\n    mutationFn: postTodo,\n    onSuccess: () => {\n      // Invalidate and refetch\n      queryClient.invalidateQueries({ queryKey: ['todos'] })\n    },\n  })\n\n  return (\n    <div>\n      <ul>{query.data?.map((todo) => <li key={todo.id}>{todo.title}</li>)}</ul>\n\n      <button\n        onClick={() => {\n          mutation.mutate({\n            id: Date.now(),\n            title: 'Do Laundry',\n          })\n        }}\n      >\n        Add Todo\n      </button>\n    </div>\n  )\n}\n\nrender(<App />, document.getElementById('root'))\n```\n\n----------------------------------------\n\nTITLE: Using useQuery Hook in TanStack Query with Custom Options (TSX)\nDESCRIPTION: This code demonstrates the use of the useQuery hook from TanStack Query (react-query) in a TypeScript/React (TSX) environment. It destructures comprehensive state and utility values from the hook and passes a detailed options object and optional QueryClient instance. Key parameters include queryKey for cache scoping, queryFn as the data fetcher, and various controls for cache time, retry logic, initial and placeholder data, selectors, and revalidation triggers. The code expects all dependencies, including @tanstack/react-query installed, and any custom QueryClient provided must be correctly instantiated. Inputs are the configuration objects; outputs are the current query state including data, errors, status, and mutation methods.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useQuery.md#2025-04-23_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nconst {\n  data,\n  dataUpdatedAt,\n  error,\n  errorUpdatedAt,\n  failureCount,\n  failureReason,\n  fetchStatus,\n  isError,\n  isFetched,\n  isFetchedAfterMount,\n  isFetching,\n  isInitialLoading,\n  isLoading,\n  isLoadingError,\n  isPaused,\n  isPending,\n  isPlaceholderData,\n  isRefetchError,\n  isRefetching,\n  isStale,\n  isSuccess,\n  promise,\n  refetch,\n  status,\n} = useQuery(\n  {\n    queryKey,\n    queryFn,\n    gcTime,\n    enabled,\n    networkMode,\n    initialData,\n    initialDataUpdatedAt,\n    meta,\n    notifyOnChangeProps,\n    placeholderData,\n    queryKeyHashFn,\n    refetchInterval,\n    refetchIntervalInBackground,\n    refetchOnMount,\n    refetchOnReconnect,\n    refetchOnWindowFocus,\n    retry,\n    retryOnMount,\n    retryDelay,\n    select,\n    staleTime,\n    structuralSharing,\n    subscribed,\n    throwOnError,\n  },\n  queryClient,\n)\n```\n\n----------------------------------------\n\nTITLE: Angular Component with TanStack Query and Mutation\nDESCRIPTION: This snippet demonstrates a complete Angular component using TanStack Query for fetching and mutating data. It includes a query for fetching todos, a mutation for adding a new todo, and a service for handling HTTP requests.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/quick-start.md#2025-04-23_snippet_2\n\nLANGUAGE: angular-ts\nCODE:\n```\nimport { Component, Injectable, inject } from '@angular/core'\nimport { HttpClient } from '@angular/common/http'\nimport { lastValueFrom } from 'rxjs'\n\nimport {\n  injectMutation,\n  injectQuery,\n  QueryClient\n} from '@tanstack/angular-query-experimental'\n\n@Component({\n  standalone: true,\n  template: `\n    <div>\n      <button (click)=\"onAddTodo()\">Add Todo</button>\n\n      <ul>\n        @for (todo of query.data(); track todo.title) {\n          <li>{{ todo.title }}</li>\n        }\n      </ul>\n    </div>\n  `,\n})\nexport class TodosComponent {\n  todoService = inject(TodoService)\n  queryClient = inject(QueryClient)\n\n  query = injectQuery(() => ({\n    queryKey: ['todos'],\n    queryFn: () => this.todoService.getTodos(),\n  }))\n\n  mutation = injectMutation(() => ({\n    mutationFn: (todo: Todo) => this.todoService.addTodo(todo),\n    onSuccess: () => {\n      this.queryClient.invalidateQueries({ queryKey: ['todos'] })\n    },\n  }))\n\n  onAddTodo() {\n    this.mutation.mutate({\n      id: Date.now().toString(),\n      title: 'Do Laundry',\n    })\n  }\n}\n\n@Injectable({ providedIn: 'root' })\nexport class TodoService {\n  private http = inject(HttpClient)\n\n  getTodos(): Promise<Todo[]> {\n    return lastValueFrom(\n      this.http.get<Todo[]>('https://jsonplaceholder.typicode.com/todos'),\n    )\n  }\n\n  addTodo(todo: Todo): Promise<Todo> {\n    return lastValueFrom(\n      this.http.post<Todo>('https://jsonplaceholder.typicode.com/todos', todo),\n    )\n  }\n}\n\ninterface Todo {\n  id: string\n  title: string\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Data Fetching with TanStack Query in React\nDESCRIPTION: Demonstrates the basic setup and usage of TanStack Query to fetch GitHub repository data. Shows initialization of QueryClient, provider setup, and usage of useQuery hook for data fetching with loading and error states.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/overview.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  QueryClient,\n  QueryClientProvider,\n  useQuery,\n} from '@tanstack/react-query'\n\nconst queryClient = new QueryClient()\n\nexport default function App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Example />\n    </QueryClientProvider>\n  )\n}\n\nfunction Example() {\n  const { isPending, error, data } = useQuery({\n    queryKey: ['repoData'],\n    queryFn: () =>\n      fetch('https://api.github.com/repos/TanStack/query').then((res) =>\n        res.json(),\n      ),\n  })\n\n  if (isPending) return 'Loading...'\n\n  if (error) return 'An error has occurred: ' + error.message\n\n  return (\n    <div>\n      <h1>{data.name}</h1>\n      <p>{data.description}</p>\n      <strong>üëÄ {data.subscribers_count}</strong>{' '}\n      <strong>‚ú® {data.stargazers_count}</strong>{' '}\n      <strong>üç¥ {data.forks_count}</strong>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Todo List Query Implementation with Status Handling\nDESCRIPTION: Full implementation of a Todo list component using useQuery with proper loading, error, and success state handling using boolean flags.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/queries.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nfunction Todos() {\n  const { isPending, isError, data, error } = useQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodoList,\n  })\n\n  if (isPending) {\n    return <span>Loading...</span>\n  }\n\n  if (isError) {\n    return <span>Error: {error.message}</span>\n  }\n\n  // We can assume by this point that `isSuccess === true`\n  return (\n    <ul>\n      {data.map((todo) => (\n        <li key={todo.id}>{todo.title}</li>\n      ))}\n    </ul>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Query Key Usage in TanStack Query (TSX)\nDESCRIPTION: These examples show the correct way to include all dependencies in the query key. This ensures proper caching and automatic refetching when variables change.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/exhaustive-deps.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nuseQuery({\n  queryKey: ['todo', todoId],\n  queryFn: () => api.getTodo(todoId),\n})\n\nconst todoQueries = {\n  detail: (id) => ({ queryKey: ['todo', id], queryFn: () => api.getTodo(id) }),\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Query Implementation in React Query\nDESCRIPTION: Demonstrates the basic usage of useQuery hook with required parameters including a unique queryKey and queryFn that returns a promise.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/queries.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQuery } from '@tanstack/react-query'\n\nfunction App() {\n  const info = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using `useMutation` Hook in TSX\nDESCRIPTION: This snippet demonstrates initializing the `useMutation` hook in a React component using TSX. It shows destructuring the hook's return values (state variables like `data`, `error`, `status`, `isPending`, etc., and functions like `mutate`, `mutateAsync`, `reset`). The hook accepts an options object (configuring the mutation behavior, including the core `mutationFn`, lifecycle callbacks like `onMutate`, `onSuccess`, `onError`, `onSettled`, caching (`gcTime`), retries (`retry`, `retryDelay`), `mutationKey`, `networkMode`, error handling (`throwOnError`), and `meta` data) and an optional `queryClient` instance. It also shows how to call the returned `mutate` function, passing variables and optional per-call lifecycle callbacks.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useMutation.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst {\\n  data,\\n  error,\\n  isError,\\n  isIdle,\\n  isPending,\\n  isPaused,\\n  isSuccess,\\n  failureCount,\\n  failureReason,\\n  mutate,\\n  mutateAsync,\\n  reset,\\n  status,\\n  submittedAt,\\n  variables,\\n} = useMutation(\\n  {\\n    mutationFn,\\n    gcTime,\\n    meta,\\n    mutationKey,\\n    networkMode,\\n    onError,\\n    onMutate,\\n    onSettled,\\n    onSuccess,\\n    retry,\\n    retryDelay,\\n    scope,\\n    throwOnError,\\n  },\\n  queryClient,\\n)\\n\\nmutate(variables, {\\n  onError,\\n  onSettled,\\n  onSuccess,\\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Dependent Queries with useQuery in TanStack Query (TSX)\nDESCRIPTION: This snippet demonstrates how to create a dependent query using the useQuery hook. It first fetches a user by email, then uses the user's ID to fetch their projects. The second query is enabled only when the user ID is available.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/dependent-queries.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// Get the user\nconst { data: user } = useQuery({\n  queryKey: ['user', email],\n  queryFn: getUserByEmail,\n})\n\nconst userId = user?.id\n\n// Then get the user's projects\nconst {\n  status,\n  fetchStatus,\n  data: projects,\n} = useQuery({\n  queryKey: ['projects', userId],\n  queryFn: getProjectsByUser,\n  // The query will not execute until the userId exists\n  enabled: !!userId,\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Optimistic Updates for Todo Updates in Angular\nDESCRIPTION: This example demonstrates a complete optimistic update flow for updating a todo. It includes cancelling ongoing queries, optimistically updating the cache, and rolling back on error.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/optimistic-updates.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nqueryClient = inject(QueryClient)\n\nupdateTodo = injectMutation(() => ({\n  mutationFn: updateTodo,\n  // When mutate is called:\n  onMutate: async (newTodo) => {\n    // Cancel any outgoing refetches\n    // (so they don't overwrite our optimistic update)\n    await this.queryClient.cancelQueries({ queryKey: ['todos'] })\n\n    // Snapshot the previous value\n    const previousTodos = client.getQueryData(['todos'])\n\n    // Optimistically update to the new value\n    this.queryClient.setQueryData(['todos'], (old) => [...old, newTodo])\n\n    // Return a context object with the snapshotted value\n    return { previousTodos }\n  },\n  // If the mutation fails,\n  // use the context returned from onMutate to roll back\n  onError: (err, newTodo, context) => {\n    client.setQueryData(['todos'], context.previousTodos)\n  },\n  // Always refetch after error or success:\n  onSettled: () => {\n    this.queryClient.invalidateQueries({ queryKey: ['todos'] })\n  },\n}))\n```\n\n----------------------------------------\n\nTITLE: Querying and Rendering with TanStack Query in React Components (TypeScript/TSX)\nDESCRIPTION: Shows the use of the `useQuery` hook to fetch required data in a parent-child React component structure. The `Article` component waits for the main article data, then renders both article and comments by delegating the comments query to the child `Comments` component, potentially causing a request waterfall. Needed dependencies: TanStack Query and appropriate fetch functions. Accepts `id` as a parameter and outputs rendered JSX based on query status and results.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nfunction Article({ id }) {\n  const { data: articleData, isPending } = useQuery({\n    queryKey: ['article', id],\n    queryFn: getArticleById,\n  })\n\n  if (isPending) {\n    return 'Loading article...'\n  }\n\n  return (\n    <>\n      <ArticleHeader articleData={articleData} />\n      <ArticleBody articleData={articleData} />\n      <Comments id={id} />\n    </>\n  )\n}\n\nfunction Comments({ id }) {\n  const { data, isPending } = useQuery({\n    queryKey: ['article-comments', id],\n    queryFn: getArticleCommentsById,\n  })\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing QueryClient for SSR in Next.js Pages Router\nDESCRIPTION: Demonstrates the correct way to initialize `QueryClient` within a Next.js `_app.tsx` component for server-side rendering. It uses `React.useState` to ensure a unique `QueryClient` instance per request, preventing cache sharing between users. It also sets a default `staleTime` suitable for SSR.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// _app.tsx\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\nimport React from 'react';\n\n// NEVER DO THIS:\n// const queryClient = new QueryClient()\n//\n// Creating the queryClient at the file root level makes the cache shared\n// between all requests and means _all_ data gets passed to _all_ users.\n// Besides being bad for performance, this also leaks any sensitive data.\n\nexport default function MyApp({ Component, pageProps }) {\n  // Instead do this, which ensures each request has its own cache:\n  const [queryClient] = React.useState(\n    ()\n      =>\n      new QueryClient({\n        defaultOptions: {\n          queries: {\n            // With SSR, we usually want to set some default staleTime\n            // above 0 to avoid refetching immediately on the client\n            staleTime: 60 * 1000,\n          },\n        },\n      }),\n  )\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Component {...pageProps} />\n    </QueryClientProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing useInfiniteQuery for Paginated Fetching in React Query (TypeScript)\nDESCRIPTION: This snippet demonstrates initializing the useInfiniteQuery hook in a TypeScript-based React component using React Query. Dependencies include the @tanstack/react-query library, and the enclosing React environment with TypeScript support. It requires a queryKey, a query function (queryFn) that accepts a page parameter, and configuration for determining the next and previous pages. The code sets up both imperative fetching (next/previous page) and tracks the status of each. Expected inputs are the queryKey, queryFn, initialPageParam, options, and page selector functions, while outputs are result properties and data for use throughout the component lifecycle. This approach is suitable for cursor- or number-based paginated APIs. Limitations may exist if getNextPageParam or getPreviousPageParam are improperly defined, especially when using the maxPages option.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useInfiniteQuery.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst {\n  fetchNextPage,\n  fetchPreviousPage,\n  hasNextPage,\n  hasPreviousPage,\n  isFetchingNextPage,\n  isFetchingPreviousPage,\n  promise,\n  ...result\n} = useInfiniteQuery({\n  queryKey,\n  queryFn: ({ pageParam }) => fetchPage(pageParam),\n  initialPageParam: 1,\n  ...options,\n  getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) =>\n    lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, allPages, firstPageParam, allPageParams) =>\n    firstPage.prevCursor,\n})\n```\n\n----------------------------------------\n\nTITLE: Fetching Paginated API Data with TanStack Query in Vue (TypeScript)\nDESCRIPTION: This code snippet sets up a paginated query within a Vue component using TanStack Query and TypeScript. It fetches posts from a sample API using a page ref, manages loading and error states, and retains previously fetched data while requesting a new page. Dependencies include Vue (with Composition API), @tanstack/vue-query, and TypeScript support. The API limit is hardcoded to 10 items per page, with navigation handled by prevPage and nextPage functions. Inputs include the current page state, and outputs include the displayed posts list, current state info, and error messages as needed.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/paginated-queries.md#2025-04-23_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\\\"ts\\\">\\nimport { ref, Ref } from 'vue'\\nimport { useQuery, keepPreviousData } from '@tanstack/vue-query'\\n\\nconst fetcher = (page: Ref<number>) =>\\n  fetch(\\n    `https://jsonplaceholder.typicode.com/posts?_page=${page.value}&_limit=10`,\\n  ).then((response) => response.json())\\n\\nconst page = ref(1)\\nconst { isPending, isError, data, error, isFetching, isPlaceholderData } =\\n  useQuery({\\n    queryKey: ['projects', page],\\n    queryFn: () => fetcher(page),\\n    placeholderData: keepPreviousData,\\n  })\\nconst prevPage = () => {\\n  page.value = Math.max(page.value - 1, 1)\\n}\\nconst nextPage = () => {\\n  if (!isPlaceholderData.value) {\\n    page.value = page.value + 1\\n  }\\n}\\n<\\/script>\\n\\n<template>\\n  <h1>Posts<\\/h1>\\n  <p>Current Page: {{ page }} | Previous data: {{ isPlaceholderData }}<\\/p>\\n  <button @click=\\\"prevPage\\\">Prev Page<\\/button>\\n  <button @click=\\\"nextPage\\\">Next Page<\\/button>\\n  <div v-if=\\\"isPending\\\">Loading...<\\/div>\\n  <div v-else-if=\\\"isError\\\">An error has occurred: {{ error }}<\\/div>\\n  <div v-else-if=\\\"data\\\">\\n    <ul>\\n      <li v-for=\\\"item in data\\\" :key=\\\"item.id\\\">\\n        {{ item.title }}\\n      <\\/li>\\n    <\\/ul>\\n  <\\/div>\\n<\\/template>\n```\n\n----------------------------------------\n\nTITLE: Using initialData with useQuery in TanStack Query (TSX)\nDESCRIPTION: Demonstrates how to provide initial data directly to a query using the `initialData` option in the `useQuery` hook. This prepopulates the cache with `initialTodos` if it's empty and skips the initial loading state. It depends on the `useQuery` hook and a pre-existing variable `initialTodos` containing the data.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n})\n```\n\n----------------------------------------\n\nTITLE: Type Inference with `select` Option in useQuery (TypeScript)\nDESCRIPTION: Shows how the `select` option affects type inference in `useQuery`. The `data` variable's type changes from the `queryFn`'s return type (`number`) to the `select` function's return type (`string`), resulting in `string | undefined`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst { data } = useQuery({\n  //      ^? const data: string | undefined\n  queryKey: ['test'],\n  queryFn: () => Promise.resolve(5),\n  select: (data) => data.toString(),\n})\n```\n\n----------------------------------------\n\nTITLE: Rendering Optimistic UI Updates in React Query\nDESCRIPTION: Demonstrates how to render a list of todos with an optimistic update shown while the mutation is pending. Includes temporary item display with reduced opacity.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/optimistic-updates.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n<ul>\n  {todoQuery.items.map((todo) => (\n    <li key={todo.id}>{todo.text}</li>\n  ))}\n  {isPending && <li style={{ opacity: 0.5 }}>{variables}</li>}\n</ul>\n```\n\n----------------------------------------\n\nTITLE: Implementing Dependent Queries with injectQuery in Angular\nDESCRIPTION: This snippet demonstrates how to create dependent queries using injectQuery in Angular. It first queries for a user by email, then uses the user's ID to query for their projects. The second query is only enabled when the user ID is available.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/dependent-queries.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Get the user\nuserQuery = injectQuery(() => ({\n  queryKey: ['user', email],\n  queryFn: getUserByEmail,\n}))\n\n// Then get the user's projects\nprojectsQuery = injectQuery(() => ({\n  queryKey: ['projects', this.userQuery.data()?.id],\n  queryFn: getProjectsByUser,\n  // The query will not execute until the user id exists\n  enabled: !!this.userQuery.data()?.id,\n}))\n```\n\n----------------------------------------\n\nTITLE: Advanced Paginated Query with keepPreviousData in TanStack Query\nDESCRIPTION: Complete implementation of a paginated query interface using keepPreviousData to maintain previous results while fetching new pages. Includes pagination controls, loading states, and error handling.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/paginated-queries.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { keepPreviousData, useQuery } from '@tanstack/react-query'\nimport React from 'react'\n\nfunction Todos() {\n  const [page, setPage] = React.useState(0)\n\n  const fetchProjects = (page = 0) =>\n    fetch('/api/projects?page=' + page).then((res) => res.json())\n\n  const { isPending, isError, error, data, isFetching, isPlaceholderData } =\n    useQuery({\n      queryKey: ['projects', page],\n      queryFn: () => fetchProjects(page),\n      placeholderData: keepPreviousData,\n    })\n\n  return (\n    <div>\n      {isPending ? (\n        <div>Loading...</div>\n      ) : isError ? (\n        <div>Error: {error.message}</div>\n      ) : (\n        <div>\n          {data.projects.map((project) => (\n            <p key={project.id}>{project.name}</p>\n          ))}\n        </div>\n      )}\n      <span>Current Page: {page + 1}</span>\n      <button\n        onClick={() => setPage((old) => Math.max(old - 1, 0))}\n        disabled={page === 0}\n      >\n        Previous Page\n      </button>\n      <button\n        onClick={() => {\n          if (!isPlaceholderData && data.hasMore) {\n            setPage((old) => old + 1)\n          }\n        }}\n        // Disable the Next Page button until we know a next page is available\n        disabled={isPlaceholderData || !data?.hasMore}\n      >\n        Next Page\n      </button>\n      {isFetching ? <span> Loading...</span> : null}\n    </div>\n  )\n```\n\n----------------------------------------\n\nTITLE: Updating Query Cache with Mutation Response in TanStack Query\nDESCRIPTION: Demonstrates how to update existing query data with mutation response using QueryClient's setQueryData method. Shows the basic pattern of updating a todo item and automatically reflecting the changes in related queries.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/updates-from-mutation-responses.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst queryClient = useQueryClient()\n\nconst mutation = useMutation({\n  mutationFn: editTodo,\n  onSuccess: (data) => {\n    queryClient.setQueryData(['todo', { id: 5 }], data)\n  },\n})\n\nmutation.mutate({\n  id: 5,\n  name: 'Do the laundry',\n})\n\n// The query below will be updated with the response from the\n// successful mutation\nconst { status, data, error } = useQuery({\n  queryKey: ['todo', { id: 5 }],\n  queryFn: fetchTodoById,\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Mutation with UI Updates in React Query\nDESCRIPTION: Shows how to create a mutation for adding a todo item with query invalidation on completion. Uses the useMutation hook to handle the POST request and manage mutation state.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/optimistic-updates.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst addTodoMutation = useMutation({\n  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),\n  // make sure to _return_ the Promise from the query invalidation\n  // so that the mutation stays in `pending` state until the refetch is finished\n  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),\n})\n\nconst { isPending, submittedAt, variables, mutate, isError } = addTodoMutation\n```\n\n----------------------------------------\n\nTITLE: Using mutationOptions Helper with TypeScript in TanStack Query\nDESCRIPTION: This snippet demonstrates how to implement the mutationOptions helper in a QueriesService class to update a post. It shows how to define mutation functions, mutation keys, and success handlers with proper TypeScript typing.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/mutation-options.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport class QueriesService {\n  private http = inject(HttpClient)\n\n  updatePost(id: number) {\n    return mutationOptions({\n      mutationFn: (post: Post) => Promise.resolve(post),\n      mutationKey: ['updatePost', id],\n      onSuccess: (newPost) => {\n        //           ^? newPost: Post\n        this.queryClient.setQueryData(['posts', id], newPost)\n      },\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Providing TanStack Query Client in Angular (Standalone)\nDESCRIPTION: This snippet demonstrates how to provide the TanStack Query client to a standalone Angular application. It uses the provideTanStackQuery function along with a new QueryClient instance.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/quick-start.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { provideHttpClient } from '@angular/common/http'\nimport {\n  provideTanStackQuery,\n  QueryClient,\n} from '@tanstack/angular-query-experimental'\n\nbootstrapApplication(AppComponent, {\n  providers: [provideHttpClient(), provideTanStackQuery(new QueryClient())],\n})\n```\n\n----------------------------------------\n\nTITLE: Fetching Messages for Multiple Users using TanStack Query `useQueries` in TypeScript\nDESCRIPTION: This snippet showcases fetching data for multiple entities dynamically using TanStack Query's `useQueries` hook in TypeScript. It first fetches a list of user IDs using `useQuery` and the `select` option to transform the data. Then, it uses a computed property (`queries`) to dynamically generate an array of query configurations based on the fetched user IDs. If no user IDs are available, an empty array is generated. Finally, `useQueries` executes these generated queries concurrently to fetch messages for each user.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/dependent-queries.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// Get the users ids\nconst { data: userIds } = useQuery({\n  queryKey: ['users'],\n  queryFn: getUsersData,\n  select: (users) => users.map((user) => user.id),\n})\n\nconst queries = computed(() => {\n  return userIds.value.length\n    ? userIds.value.map((id) => {\n        return {\n          queryKey: ['messages', id],\n          queryFn: () => getMessagesByUsers(id),\n        }\n      })\n    : []\n})\n\n// Then get the users messages\nconst usersMessages = useQueries({\n  queries, // if users is undefined, an empty array will be returned\n})\n```\n\n----------------------------------------\n\nTITLE: Form Submission with Event Handling in React\nDESCRIPTION: Demonstrates proper event handling with mutations in React forms, showing both incorrect and correct implementations for React 16 and earlier versions.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// This will not work in React 16 and earlier\nconst CreateTodo = () => {\n  const mutation = useMutation({\n    mutationFn: (event) => {\n      event.preventDefault()\n      return fetch('/api', new FormData(event.target))\n    },\n  })\n\n  return <form onSubmit={mutation.mutate}>...</form>\n}\n\n// This will work\nconst CreateTodo = () => {\n  const mutation = useMutation({\n    mutationFn: (formData) => {\n      return fetch('/api', formData)\n    },\n  })\n  const onSubmit = (event) => {\n    event.preventDefault()\n    mutation.mutate(new FormData(event.target))\n  }\n\n  return <form onSubmit={onSubmit}>...</form>\n}\n```\n\n----------------------------------------\n\nTITLE: Query Result Assignment in React Query\nDESCRIPTION: Shows how to store the query result in a variable for accessing various query states and data.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/queries.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })\n```\n\n----------------------------------------\n\nTITLE: Implementing Infinite Scroll with useInfiniteQuery in Vue\nDESCRIPTION: This Vue 3 Composition API component demonstrates fetching paginated project data using the `useInfiniteQuery` hook from `@tanstack/vue-query`. It defines an async fetch function (`fetchProjects`), configures the query with `queryKey`, `queryFn`, and `getNextPageParam`, and manages states like loading, error, and pagination. The template conditionally renders UI based on query status, displays fetched projects grouped by page, and includes a button to trigger `fetchNextPage` to load more data.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/infinite-queries.md#2025-04-23_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { useInfiniteQuery } from '@tanstack/vue-query'\n\nconst fetchProjects = async ({ pageParam = 0 }) => {\n  const res = await fetch('/api/projects?cursor=' + pageParam)\n  return res.json()\n}\n\nconst {\n  data,\n  error,\n  fetchNextPage,\n  hasNextPage,\n  isFetching,\n  isFetchingNextPage,\n  isPending,\n  isError,\n} = useInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n})\n</script>\n\n<template>\n  <span v-if=\"isPending\">Loading...</span>\n  <span v-else-if=\"isError\">Error: {{ error.message }}</span>\n  <div v-else-if=\"data\">\n    <span v-if=\"isFetching && !isFetchingNextPage\">Fetching...</span>\n    <ul v-for=\"(group, index) in data.pages\" :key=\"index\">\n      <li v-for=\"project in group.projects\" :key=\"project.id\">\n        {{ project.name }}\n      </li>\n    </ul>\n    <button\n      @click=\"() => fetchNextPage()\"\n      :disabled=\"!hasNextPage || isFetchingNextPage\"\n    >\n      <span v-if=\"isFetchingNextPage\">Loading more...</span>\n      <span v-else-if=\"hasNextPage\">Load More</span>\n      <span v-else>Nothing more to load</span>\n    </button>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using the useSuspenseQuery Hook for Type-Safe Data Fetching in Tanstack Query (JavaScript)\nDESCRIPTION: Introduces the new `useSuspenseQuery` hook in Tanstack Query v5, designed for use with React Suspense. This hook ensures that the returned `data` property is always defined on the type level, eliminating the need for undefined checks when Suspense is active. The experimental `suspense: boolean` flag on older hooks is removed. Requires `@tanstack/react-query` v5+ and React 18+.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-23_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\n```js\nconst { data: post } = useSuspenseQuery({\n  // ^? const post: Post\n  queryKey: ['post', postId],\n  queryFn: () => fetchPost(postId),\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Basic Mutation Setup in TanStack Query\nDESCRIPTION: Simple example showing how to set up a mutation for posting a todo item using the useMutation hook.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/invalidations-from-mutations.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst mutation = useMutation({ mutationFn: postTodo })\n```\n\n----------------------------------------\n\nTITLE: Using initialData with staleTime in useQuery (TSX)\nDESCRIPTION: Illustrates how setting `staleTime` (e.g., 1000 ms) alongside `initialData` prevents immediate refetching upon mount. The provided `initialTodos` data is considered fresh for the duration specified by `staleTime`, delaying the refetch until after that period or upon specific interaction events.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n  staleTime: 1000,\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Reusable Mutation Hook in TanStack Query\nDESCRIPTION: Shows how to create a reusable mutation hook that encapsulates the logic for updating query cache on successful mutations. The hook handles todo updates and automatically updates corresponding queries.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/updates-from-mutation-responses.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst useMutateTodo = () => {\n  const queryClient = useQueryClient()\n\n  return useMutation({\n    mutationFn: editTodo,\n    // Notice the second argument is the variables object that the `mutate` function receives\n    onSuccess: (data, variables) => {\n      queryClient.setQueryData(['todo', { id: variables.id }], data)\n    },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Using initialData with Next.js getServerSideProps\nDESCRIPTION: Shows how to use the `initialData` option in `useQuery` with Next.js pages router. Data is fetched within `getServerSideProps`, passed as props to the page component, and then supplied to `useQuery` to populate the initial state without needing the full hydration API.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQuery } from '@tanstack/react-query';\n\ndeclare function getPosts(): Promise<any[]>; // Example declaration\n\nexport async function getServerSideProps() {\n  const posts = await getPosts()\n  return { props: { posts } }\n}\n\nfunction Posts(props: { posts: any[] }) {\n  const { data } = useQuery({\n    queryKey: ['posts'],\n    queryFn: getPosts,\n    initialData: props.posts,\n  })\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Fetch API Integration with TanStack Query\nDESCRIPTION: Demonstrates how to properly handle errors when using the fetch API with TanStack Query, including manual error throwing for non-OK responses.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-functions.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nuseQuery({\n  queryKey: ['todos', todoId],\n  queryFn: async () => {\n    const response = await fetch('/todos/' + todoId)\n    if (!response.ok) {\n      throw new Error('Network response was not ok')\n    }\n    return response.json()\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing QueryClient with SSR Awareness in SvelteKit (Svelte)\nDESCRIPTION: This Svelte component sets up the QueryClient with options that disable queries on the server by checking the 'browser' flag from SvelteKit. The QueryClient is provided to the component tree via QueryClientProvider. This approach ensures that data-fetching queries are only enabled on the client, preventing unwanted server-side execution post-SSR. Dependencies are '@tanstack/svelte-query' and SvelteKit's '$app/environment'. The input is a SvelteKit page/component and the output is that descendents receive the QueryClient context.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/ssr.md#2025-04-23_snippet_0\n\nLANGUAGE: svelte\nCODE:\n```\n<script lang=\\\"ts\\\">\\n  import { browser } from '$app/environment'\\n  import { QueryClient, QueryClientProvider } from '@tanstack/svelte-query'\\n\\n  const queryClient = new QueryClient({\\n    defaultOptions: {\\n      queries: {\\n        enabled: browser,\\n      },\\n    },\\n  })\\n</script>\\n\\n<QueryClientProvider client={queryClient}>\\n  <slot />\\n</QueryClientProvider>\\n\n```\n\n----------------------------------------\n\nTITLE: Advanced Mutation with Optimistic Updates and Offline Support\nDESCRIPTION: Comprehensive example that demonstrates advanced mutation patterns including default configurations, optimistic updates, hydration/dehydration for offline support, and resuming paused mutations. Shows the complete lifecycle of a mutation with query client integration.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-23_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nconst queryClient = new QueryClient()\n\n// Define the \"addTodo\" mutation\nqueryClient.setMutationDefaults(['addTodo'], {\n  mutationFn: addTodo,\n  onMutate: async (variables) => {\n    // Cancel current queries for the todos list\n    await queryClient.cancelQueries({ queryKey: ['todos'] })\n\n    // Create optimistic todo\n    const optimisticTodo = { id: uuid(), title: variables.title }\n\n    // Add optimistic todo to todos list\n    queryClient.setQueryData(['todos'], (old) => [...old, optimisticTodo])\n\n    // Return context with the optimistic todo\n    return { optimisticTodo }\n  },\n  onSuccess: (result, variables, context) => {\n    // Replace optimistic todo in the todos list with the result\n    queryClient.setQueryData(['todos'], (old) =>\n      old.map((todo) =>\n        todo.id === context.optimisticTodo.id ? result : todo,\n      ),\n    )\n  },\n  onError: (error, variables, context) => {\n    // Remove optimistic todo from the todos list\n    queryClient.setQueryData(['todos'], (old) =>\n      old.filter((todo) => todo.id !== context.optimisticTodo.id),\n    )\n  },\n  retry: 3,\n})\n\nclass someComponent {\n  // Start mutation in some component:\n  mutation = injectMutation(() => ({ mutationKey: ['addTodo'] }))\n\n  someMethod() {\n    mutation.mutate({ title: 'title' })\n  }\n}\n\n// If the mutation has been paused because the device is for example offline,\n// Then the paused mutation can be dehydrated when the application quits:\nconst state = dehydrate(queryClient)\n\n// The mutation can then be hydrated again when the application is started:\nhydrate(queryClient, state)\n\n// Resume the paused mutations:\nqueryClient.resumePausedMutations()\n```\n\n----------------------------------------\n\nTITLE: Creating Custom useQuery Hooks with Select (React Query, JavaScript)\nDESCRIPTION: These JavaScript snippets demonstrate how to define custom hooks (useTodos and useTodoCount) with React Query to fetch todos, and then select a specific piece of the data (e.g., the count). The useTodos hook is parameterized with a select function, allowing consumers to subscribe only to relevant data, thereby minimizing unnecessary re-renders. Requires react-query, a fetchTodos function, and the React framework. The useTodoCount hook is a wrapper that selects the length property from the todos list. Both hooks expect properly set up React Query context and a valid fetchTodos implementation.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/render-optimizations.md#2025-04-23_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nexport const useTodos = (select) => {\n  return useQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodos,\n    select,\n  })\n}\n\nexport const useTodoCount = () => {\n  return useTodos((data) => data.length)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Prefetching and Route-Based Data Fetching Integration with TanStack Router and Query (TSX)\nDESCRIPTION: Illustrates how to integrate TanStack Query with a routing solution (TanStack Router) to manage data dependencies for routes. The snippet sets up beforeLoad and loader hooks to specify what data needs to be loaded, prefetched, or awaited before rendering the /article route. It demonstrates using both blocking (await) and non-blocking (fire-and-forget prefetch) data loading strategies. Dependencies include QueryClient, RouterContext, Route, and useQuery. The primary parameters are query options and route context; output is a rendered component tree with the necessary data prefetched or loaded per configuration. This pattern helps prevent request waterfalls at navigation level.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-23_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nconst queryClient = new QueryClient()\nconst routerContext = new RouterContext()\nconst rootRoute = routerContext.createRootRoute({\n  component: () => { ... }\n})\n\nconst articleRoute = new Route({\n  getParentRoute: () => rootRoute,\n  path: 'article',\n  beforeLoad: () => {\n    return {\n      articleQueryOptions: { queryKey: ['article'], queryFn: fetchArticle },\n      commentsQueryOptions: { queryKey: ['comments'], queryFn: fetchComments },\n    }\n  },\n  loader: async ({\n    context: { queryClient },\n    routeContext: { articleQueryOptions, commentsQueryOptions },\n  }) => {\n    // Fetch comments asap, but don't block\n    queryClient.prefetchQuery(commentsQueryOptions)\n\n    // Don't render the route at all until article has been fetched\n    await queryClient.prefetchQuery(articleQueryOptions)\n  },\n  component: ({ useRouteContext }) => {\n    const { articleQueryOptions, commentsQueryOptions } = useRouteContext()\n    const articleQuery = useQuery(articleQueryOptions)\n    const commentsQuery = useQuery(commentsQueryOptions)\n\n    return (\n      ...\n    )\n  },\n  errorComponent: () => 'Oh crap!',\n})\n```\n\n----------------------------------------\n\nTITLE: Async Mutation Callbacks\nDESCRIPTION: Example of using async callbacks in mutations, demonstrating the order of execution for multiple callback functions.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nuseMutation({\n  mutationFn: addTodo,\n  onSuccess: async () => {\n    console.log(\"I'm first!\")\n  },\n  onSettled: async () => {\n    console.log(\"I'm second!\")\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Prefetching Queries with TanStack Query in TypeScript/TSX\nDESCRIPTION: Demonstrates how to use the `queryClient.prefetchQuery` function to asynchronously prefetch and cache data in React applications before it is required, based on a provided query key and fetch function. This snippet requires TanStack Query and an initialized `queryClient`. It receives no parameters and does not return data, but ensures that subsequent queries with the same key are fast and served from cache. Output is a `Promise<void>` and error handling is implicit; to handle errors or access data, use `fetchQuery` instead.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst prefetchTodos = async () => {\n  // The results of this query will be cached like a normal query\n  await queryClient.prefetchQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodos,\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Invalidating Multiple Query Keys on Mutation Success using Vue Query\nDESCRIPTION: This TypeScript snippet demonstrates defining a mutation with `@tanstack/vue-query`. It uses the `useMutation` hook and gets the `queryClient` via `useQueryClient`. Upon successful execution of the `addTodo` mutation function (assumed to be defined elsewhere), the `onSuccess` callback invalidates all queries associated with the query keys `['todos']` and `['reminders']` by calling `queryClient.invalidateQueries` for each key. This pattern ensures that data related to 'todos' and 'reminders' is marked as stale and potentially refetched after adding a new todo.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/invalidations-from-mutations.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useMutation, useQueryClient } from '@tanstack/vue-query'\n\nconst queryClient = useQueryClient()\n\n// When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key\nconst mutation = useMutation({\n  mutationFn: addTodo,\n  onSuccess: () => {\n    queryClient.invalidateQueries({ queryKey: ['todos'] })\n    queryClient.invalidateQueries({ queryKey: ['reminders'] })\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Invoking useSuspenseQueries Hook in TanStack Query (TypeScript/React)\nDESCRIPTION: This snippet demonstrates the basic invocation of the `useSuspenseQueries` hook. It takes an `options` argument, which is an array of query configurations similar to `useQueries`, but prohibits the use of `suspense`, `throwOnError`, `enabled`, and `placeholderData` properties within each query object. The hook integrates with React Suspense, ensuring the component only renders after all queries have successfully fetched data. The returned `result` is an array mirroring the structure returned by `useQueries`, but guarantees that `data` is defined for each query and the `status` will only be `success` or `error`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useSuspenseQueries.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nconst result = useSuspenseQueries(options)\n```\n```\n\n----------------------------------------\n\nTITLE: Using onSettled for Mutation Handling\nDESCRIPTION: Demonstrates using the onSettled handler as an alternative to separate onError and onSuccess handlers in mutations.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/optimistic-updates.md#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nuseMutation({\n  mutationFn: updateTodo,\n  // ...\n  onSettled: async (newTodo, error, variables, context) => {\n    if (error) {\n      // do something\n    }\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Fetching Posts Server-side in SvelteKit Load Function (TypeScript)\nDESCRIPTION: Implements a load function in a SvelteKit page that asynchronously fetches posts using 'getPosts' and returns them in the load data. This data can then be used as initial data for Svelte Query components in the client. Requirements: SvelteKit route, a 'getPosts' function. Inputs: none; Outputs: an object with a 'posts' property containing the returned posts.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/ssr.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport async function load() {\\n  const posts = await getPosts()\\n  return { posts }\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Basic Query Invalidation using invalidateQueries in TypeScript\nDESCRIPTION: Demonstrates the basic usage of `queryClient.invalidateQueries`. The first call invalidates every query currently in the cache. The second call invalidates all queries whose query key starts with the array `['todos']`, effectively performing prefix matching.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-invalidation.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// Invalidate every query in the cache\nqueryClient.invalidateQueries()\n// Invalidate every query with a key that starts with `todos`\nqueryClient.invalidateQueries({ queryKey: ['todos'] })\n```\n\n----------------------------------------\n\nTITLE: Async Mutation with Promise Handling\nDESCRIPTION: Example of using mutateAsync to handle mutations with promises, including proper error handling and side effects.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-23_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nconst mutation = useMutation({ mutationFn: addTodo })\n\ntry {\n  const todo = await mutation.mutateAsync(todo)\n  console.log(todo)\n} catch (error) {\n  console.error(error)\n} finally {\n  console.log('done')\n}\n```\n\n----------------------------------------\n\nTITLE: Handling useQuery Return Values in SolidJS (No Destructuring)\nDESCRIPTION: Explains that unlike React Query, the store object returned by Solid Query primitives like `useQuery` should not be destructured directly outside a reactive context (like JSX). Doing so would lose reactivity. Instead, properties like `query.isPending`, `query.error`, and `query.data` must be accessed directly within reactive scopes (JSX in this example) for SolidJS to track their changes correctly. The example fetches GitHub repo data and renders it based on the query state using `Switch` and `Match`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/quick-start.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  QueryClient,\n  QueryClientProvider,\n  useQuery,\n} from '@tanstack/solid-query'\nimport { Match, Switch } from 'solid-js'\n\nconst queryClient = new QueryClient()\n\nexport default function App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Example />\n    </QueryClientProvider>\n  )\n}\n\nfunction Example() {\n  // ‚ùå react version -- supports destructing outside reactive context\n  // const { isPending, error, data } = useQuery({\n  //   queryKey: ['repoData'],\n  //   queryFn: () =>\n  //     fetch('https://api.github.com/repos/tannerlinsley/react-query').then(\n  //       (res) => res.json()\n  //     ),\n  // })\n\n  // ‚úÖ solid version -- does not support destructuring outside reactive context\n  const query = useQuery(() => ({\n    queryKey: ['repoData'],\n    queryFn: () =>\n      fetch('https://api.github.com/repos/tannerlinsley/react-query').then(\n        (res) => res.json(),\n      ),\n  }))\n\n  // ‚úÖ access query properties in JSX reactive context\n  return (\n    <Switch>\n      <Match when={query.isPending}>Loading...</Match>\n      <Match when={query.isError}>Error: {query.error.message}</Match>\n      <Match when={query.isSuccess}>\n        <div>\n          <h1>{query.data.name}</h1>\n          <p>{query.data.description}</p>\n          <strong>üëÄ {query.data.subscribers_count}</strong>{' '}\n          <strong>‚ú® {query.data.stargazers_count}</strong>{' '}\n          <strong>üç¥ {query.data.forks_count}</strong>\n        </div>\n      </Match>\n    </Switch>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Data Transformation with Select Option\nDESCRIPTION: Example of using the select option to transform infinite query data by reversing pages and page parameters.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/infinite-queries.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nquery = injectInfiniteQuery(() => ({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  select: (data) => ({\n    pages: [...data.pages].reverse(),\n    pageParams: [...data.pageParams].reverse(),\n  }),\n}))\n```\n\n----------------------------------------\n\nTITLE: Conditional Initial Data with Time Check\nDESCRIPTION: Implements a query that only uses cached data as initial data if it's not older than 10 seconds, otherwise forces a fresh fetch.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nresult = injectQuery(() => ({\n  queryKey: ['todo', this.todoId()],\n  queryFn: () => fetch(`/todos/${this.todoId()}`),\n  initialData: () => {\n    // Get the query state\n    const state = queryClient.getQueryState(['todos'])\n\n    // If the query exists and has data that is no older than 10 seconds...\n    if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {\n      // return the individual todo\n      return state.data.find((d) => d.id === this.todoId())\n    }\n\n    // Otherwise, return undefined and let it fetch from a hard loading state!\n  },\n}))\n```\n\n----------------------------------------\n\nTITLE: Implementing Simplified Optimistic Updates with useMutation in Tanstack Query (TSX)\nDESCRIPTION: Presents a new, simplified pattern for optimistic updates in Tanstack Query v5. Instead of directly manipulating the query cache, this approach uses the `variables` returned by the `useMutation` hook along with the `isPending` status to conditionally render an optimistic UI state while the mutation is in flight. It relies on invalidation (`onSettled`) to fetch the final state. Dependencies include `@tanstack/react-query` and potentially a data fetching library like `axios`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-23_snippet_17\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nconst queryInfo = useTodos()\nconst addTodoMutation = useMutation({\n  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),\n  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),\n})\n\nif (queryInfo.data) {\n  return (\n    <ul>\n      {queryInfo.data.items.map((todo) => (\n        <li key={todo.id}>{todo.text}</li>\n      ))}\n      {addTodoMutation.isPending && (\n        <li key={String(addTodoMutation.submittedAt)} style={{ opacity: 0.5 }}>\n          {addTodoMutation.variables}\n        </li>\n      )}\n    </ul>\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Prefetching Data on User Events with TanStack Query in TypeScript/TSX\nDESCRIPTION: Illustrates prefetching data when specific events (such as mouse enter or focus) occur on a component. This approach uses the `queryClient.prefetchQuery` API inside a React event handler to populate the cache on demand. Prerequisites are TanStack Query, a `useQueryClient` hook, and a defined `getDetailsData` fetch function. A custom `staleTime` is set to determine when prefetch should re-fire. Inputs and outputs are handled via React events; no data is returned directly from the handler.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nfunction ShowDetailsButton() {\n  const queryClient = useQueryClient()\n\n  const prefetch = () => {\n    queryClient.prefetchQuery({\n      queryKey: ['details'],\n      queryFn: getDetailsData,\n      // Prefetch only fires when data is older than the staleTime,\n      // so in a case like this you definitely want to set one\n      staleTime: 60000,\n    })\n  }\n\n  return (\n    <button onMouseEnter={prefetch} onFocus={prefetch} onClick={...}>\n      Show Details\n    </button>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Immutable Query Cache Updates in TanStack Query\nDESCRIPTION: Illustrates the correct way to perform immutable updates to the query cache using setQueryData. Shows both incorrect mutable approach and correct immutable approach for updating post data.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/updates-from-mutation-responses.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nqueryClient.setQueryData(['posts', { id }], (oldData) => {\n  if (oldData) {\n    // ‚ùå do not try this\n    oldData.title = 'my new post title'\n  }\n  return oldData\n})\n\nqueryClient.setQueryData(\n  ['posts', { id }],\n  // ‚úÖ this is the way\n  (oldData) =>\n    oldData\n      ? {\n          ...oldData,\n          title: 'my new post title',\n        }\n      : oldData,\n)\n```\n\n----------------------------------------\n\nTITLE: Creating QueryClient in SvelteKit Server Load Function (TypeScript)\nDESCRIPTION: Defines a load function for +layout.ts that instantiates a new QueryClient with SSR-aware defaults (using the 'browser' flag to control query availability). The QueryClient instance is returned for passing into the Svelte frontend. Dependencies: '@tanstack/svelte-query', SvelteKit's '$app/environment'. Input: none; Output: object with a 'queryClient' property containing the new QueryClient instance.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/ssr.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { browser } from '$app/environment'\\nimport { QueryClient } from '@tanstack/svelte-query'\\n\\nexport async function load() {\\n  const queryClient = new QueryClient({\\n    defaultOptions: {\\n      queries: {\\n        enabled: browser,\\n      },\\n    },\\n  })\\n\\n  return { queryClient }\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Prefetching Query on Server in SvelteKit Load Function (TypeScript)\nDESCRIPTION: Implements a server load function for +page.ts that uses the parent layout-provided QueryClient to prefetch a 'posts' query. Uses SvelteKit's provided 'fetch' function to retrieve '/api/posts' and seeds the QueryClient's cache. Requirements: SvelteKit route context, parent providing QueryClient, endpoint '/api/posts'. Inputs: fetch, parent context; Output: server cache is primed for client hydration.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/ssr.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport async function load({ parent, fetch }) {\\n  const { queryClient } = await parent()\\n\\n  // You need to use the SvelteKit fetch function here\\n  await queryClient.prefetchQuery({\\n    queryKey: ['posts'],\\n    queryFn: async () => (await fetch('/api/posts')).json(),\\n  })\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Optimistic Updates for Individual Todo Items in Angular\nDESCRIPTION: This snippet shows how to implement optimistic updates for individual todo items. It demonstrates cancelling queries, updating specific items, and rolling back changes for individual todos.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/optimistic-updates.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nqueryClient = inject(QueryClient)\n\nupdateTodo = injectMutation(() => ({\n  mutationFn: updateTodo,\n  // When mutate is called:\n  onMutate: async (newTodo) => {\n    // Cancel any outgoing refetches\n    // (so they don't overwrite our optimistic update)\n    await this.queryClient.cancelQueries({ queryKey: ['todos', newTodo.id] })\n\n    // Snapshot the previous value\n    const previousTodo = this.queryClient.getQueryData(['todos', newTodo.id])\n\n    // Optimistically update to the new value\n    this.queryClient.setQueryData(['todos', newTodo.id], newTodo)\n\n    // Return a context with the previous and new todo\n    return { previousTodo, newTodo }\n  },\n  // If the mutation fails, use the context we returned above\n  onError: (err, newTodo, context) => {\n    this.queryClient.setQueryData(\n      ['todos', context.newTodo.id],\n      context.previousTodo,\n    )\n  },\n  // Always refetch after error or success:\n  onSettled: (newTodo) => {\n    this.queryClient.invalidateQueries({ queryKey: ['todos', newTodo.id] })\n  },\n}))\n```\n\n----------------------------------------\n\nTITLE: Retrieving initialData from Cache in useQuery (TSX)\nDESCRIPTION: Shows how to use data from another query's cache (identified by `['todos']`) as the `initialData` for a new query (identified by `['todo', todoId]`). It uses `queryClient.getQueryData(['todos'])` within an `initialData` function to find and return a specific item based on `todoId`, potentially avoiding a network request if the data is already available.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nconst result = useQuery({\n  queryKey: ['todo', todoId],\n  queryFn: () => fetch('/todos'),\n  initialData: () => {\n    // Use a todo from the 'todos' query as the initial data for this todo query\n    return queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId)\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Getting Variables of Pending Mutations using useMutationState (TSX)\nDESCRIPTION: This snippet demonstrates how to use the `useMutationState` hook to retrieve the `variables` associated with all mutations that are currently in the 'pending' status. It utilizes the `filters` option to specify the status and the `select` option to extract the `variables` from each matching mutation's state. Requires the `@tanstack/react-query` library.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useMutationState.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport { useMutationState } from '@tanstack/react-query'\n\nconst variables = useMutationState({\n  filters: { status: 'pending' },\n  select: (mutation) => mutation.state.variables,\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Infinite Query with Load More Button\nDESCRIPTION: Complete example of implementing infinite queries with TanStack Query, including loading states and error handling\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useInfiniteQuery } from '@tanstack/react-query'\n\nfunction Projects() {\n  const fetchProjects = async ({ pageParam }) => {\n    const res = await fetch('/api/projects?cursor=' + pageParam)\n    return res.json()\n  }\n\n  const {\n    data,\n    error,\n    fetchNextPage,\n    hasNextPage,\n    isFetching,\n    isFetchingNextPage,\n    status,\n  } = useInfiniteQuery({\n    queryKey: ['projects'],\n    queryFn: fetchProjects,\n    initialPageParam: 0,\n    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  })\n\n  return status === 'pending' ? (\n    <p>Loading...</p>\n  ) : status === 'error' ? (\n    <p>Error: {error.message}</p>\n  ) : (\n    <>\n      {data.pages.map((group, i) => (\n        <React.Fragment key={i}>\n          {group.data.map((project) => (\n            <p key={project.id}>{project.name}</p>\n          ))}\n        </React.Fragment>\n      ))}\n      <div>\n        <button\n          onClick={() => fetchNextPage()}\n          disabled={!hasNextPage || isFetchingNextPage}\n        >\n          {isFetchingNextPage\n            ? 'Loading more...'\n            : hasNextPage\n              ? 'Load More'\n              : 'Nothing more to load'}\n        </button>\n      </div>\n      <div>{isFetching && !isFetchingNextPage ? 'Fetching...' : null}</div>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using useSuspenseInfiniteQuery Hook in TypeScript\nDESCRIPTION: Demonstrates the basic invocation of the `useSuspenseInfiniteQuery` hook. This hook is specifically designed for React Suspense integration. It accepts options similar to `useInfiniteQuery`, but excludes `enabled`, `placeholderData`, `suspense`, and `throwOnError` as they are handled differently in a Suspense context. The hook returns an object where `data` is guaranteed to be defined upon successful resolution, and the `status` will only be 'success' or 'error'. Note that query cancellation is not supported with this hook.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useSuspenseInfiniteQuery.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nconst result = useSuspenseInfiniteQuery(options)\n```\n```\n\n----------------------------------------\n\nTITLE: Using Vue Query with script setup syntax\nDESCRIPTION: Example of how to use Vue Query's useQuery hook with the script setup syntax in Vue components. This demonstrates the recommended way to use Vue Query in Vue 3 applications.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/installation.md#2025-04-23_snippet_5\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { useQuery } from '@tanstack/vue-query'\n\nconst { isPending, isFetching, isError, data, error } = useQuery({\n  queryKey: ['todos'],\n  queryFn: getTodos,\n})\n</script>\n\n<template>...</template>\n```\n\n----------------------------------------\n\nTITLE: Type Inference with Data Transformation Using select\nDESCRIPTION: Shows how the select option transforms the query result type. The query function returns a number, but the select function converts it to a string, which is correctly inferred.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-23_snippet_1\n\nLANGUAGE: angular-ts\nCODE:\n```\n@Component({\n  // ...\n  template: `@let data = query.data();`,\n  //               ^? data: string | undefined\n})\nclass MyComponent {\n  query = injectQuery(() => ({\n    queryKey: ['test'],\n    queryFn: () => Promise.resolve(5),\n    select: (data) => data.toString(),\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Network Request Handling in Query Functions\nDESCRIPTION: Demonstrates how to make a fetch request within a query function, handle the response, and manage potential network errors by checking response.ok.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-functions.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ntodos = injectQuery(() => ({\n  queryKey: ['todos', todoId()],\n  queryFn: async () => {\n    const response = await fetch('/todos/' + todoId)\n    if (!response.ok) {\n      throw new Error('Network response was not ok')\n    }\n    return response.json()\n  },\n}))\n```\n\n----------------------------------------\n\nTITLE: Using HydrationBoundary Component in React Query\nDESCRIPTION: React component that hydrates dehydrated state into the nearest QueryClient context. Useful for server-side rendering scenarios.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/hydration.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { HydrationBoundary } from '@tanstack/react-query'\n\nfunction App() {\n  return <HydrationBoundary state={dehydratedState}>...</HydrationBoundary>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Query Cancellation with useQuery and cancelQueries in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates using the `useQuery` hook from TanStack Query to fetch data. The `queryFn` accepts an `AbortSignal` which is passed to the native `fetch` API to allow for request cancellation. A separate function `onButtonClick` shows how to use `queryClient.cancelQueries` to programmatically cancel the query identified by the key `['todos']`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/query-cancellation.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: async ({ signal }) => {\n    const resp = await fetch('/todos', { signal })\n    return resp.json()\n  },\n})\n\nconst queryClient = useQueryClient()\n\nfunction onButtonClick() {\n  queryClient.cancelQueries({ queryKey: ['todos'] })\n}\n```\n\n----------------------------------------\n\nTITLE: Type Inference with Select Function in Vue Query\nDESCRIPTION: Shows how the 'select' option affects type inference. The 'data' type is inferred as Ref<string> | Ref<undefined> due to the toString() transformation in the select function.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/typescript.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst { data } = useQuery({\n  //      ^? const data: Ref<string> | Ref<undefined>\n  queryKey: ['test'],\n  queryFn: () => Promise.resolve(5),\n  select: (data) => data.toString(),\n})\n```\n\n----------------------------------------\n\nTITLE: Persisting Offline Mutations with PersistQueryClientProvider in TypeScript/React\nDESCRIPTION: This snippet explains how to persist TanStack Query mutations using the PersistQueryClientProvider and recover them from browser storage (e.g., localStorage). It highlights the need to set a default mutation function (mutationFn) so that resumed mutations after hydration will not fail. Dependencies include TanStack Query's QueryClient, PersistQueryClientProvider, and createSyncStoragePersister, as well as a working API for updating todos. The key parameters are the storage provider, mutation defaults, and hydration options. After hydration, queued mutations are resumed with resumePausedMutations. Limitations involve the inability to serialize mutation functions, hence why they must be provided as defaults.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-23_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nconst persister = createSyncStoragePersister({\n  storage: window.localStorage,\n})\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      gcTime: 1000 * 60 * 60 * 24, // 24 hours\n    },\n  },\n})\n\n// we need a default mutation function so that paused mutations can resume after a page reload\nqueryClient.setMutationDefaults(['todos'], {\n  mutationFn: ({ id, data }) => {\n    return api.updateTodo(id, data)\n  },\n})\n\nexport default function App() {\n  return (\n    <PersistQueryClientProvider\n      client={queryClient}\n      persistOptions={{ persister }}\n      onSuccess={() => {\n        // resume mutations after initial restore from localStorage was successful\n        queryClient.resumePausedMutations()\n      }}\n    >\n      <RestOfTheApp />\n    </PersistQueryClientProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching User Projects Based on User ID using TanStack Query in JavaScript\nDESCRIPTION: This snippet demonstrates a dependent query pattern using TanStack Query (`useQuery`). It first fetches user data based on an email. It then uses a computed property (`userId`) derived from the user data as part of the `queryKey` for a second query to fetch the user's projects. Another computed property (`enabled`) ensures the second query only executes when the user ID is available.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/dependent-queries.md#2025-04-23_snippet_0\n\nLANGUAGE: js\nCODE:\n```\n// Get the user\nconst { data: user } = useQuery({\n  queryKey: ['user', email],\n  queryFn: () => getUserByEmail(email.value),\n})\n\nconst userId = computed(() => user.value?.id)\nconst enabled = computed(() => !!user.value?.id)\n\n// Then get the user's projects\nconst { isIdle, data: projects } = useQuery({\n  queryKey: ['projects', userId],\n  queryFn: () => getProjectsByUser(userId.value),\n  enabled, // The query will not execute until `enabled == true`\n})\n```\n\n----------------------------------------\n\nTITLE: Basic TanStack Query Implementation in Vue\nDESCRIPTION: A comprehensive Vue component example that demonstrates using TanStack Query to fetch todos, display loading/error states, and add new todos through mutations. The example shows how to use useQuery for data fetching and useMutation for data updates.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/quick-start.md#2025-04-23_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { useQueryClient, useQuery, useMutation } from '@tanstack/vue-query'\n\n// Access QueryClient instance\nconst queryClient = useQueryClient()\n\n// Query\nconst { isPending, isError, data, error } = useQuery({\n  queryKey: ['todos'],\n  queryFn: getTodos,\n})\n\n// Mutation\nconst mutation = useMutation({\n  mutationFn: postTodo,\n  onSuccess: () => {\n    // Invalidate and refetch\n    queryClient.invalidateQueries({ queryKey: ['todos'] })\n  },\n})\n\nfunction onButtonClick() {\n  mutation.mutate({\n    id: Date.now(),\n    title: 'Do Laundry',\n  })\n}\n</script>\n\n<template>\n  <span v-if=\"isPending\">Loading...</span>\n  <span v-else-if=\"isError\">Error: {{ error.message }}</span>\n  <!-- We can assume by this point that `isSuccess === true` -->\n  <ul v-else>\n    <li v-for=\"todo in data\" :key=\"todo.id\">{{ todo.title }}</li>\n  </ul>\n  <button @click=\"onButtonClick\">Add Todo</button>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Basic Suspense Query Implementation in TypeScript\nDESCRIPTION: Shows how to implement a basic suspense-enabled query using the useSuspenseQuery hook from React Query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/suspense.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useSuspenseQuery } from '@tanstack/react-query'\n\nconst { data } = useSuspenseQuery({ queryKey, queryFn })\n```\n\n----------------------------------------\n\nTITLE: Setting Query Data with TanStack Query Client\nDESCRIPTION: Demonstrates how to use queryClient.setQueryData to update cached query data synchronously. Shows both direct value updates and updater function approaches.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nqueryClient.setQueryData(queryKey, updater)\n```\n\nLANGUAGE: tsx\nCODE:\n```\nsetQueryData(queryKey, newData)\n```\n\nLANGUAGE: tsx\nCODE:\n```\nsetQueryData(queryKey, (oldData) => newData)\n```\n\n----------------------------------------\n\nTITLE: Basic Mutation Implementation with TanStack Query\nDESCRIPTION: Example showing how to implement a basic todo creation mutation using the useMutation hook with loading, error, and success states.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction App() {\n  const mutation = useMutation({\n    mutationFn: (newTodo) => {\n      return axios.post('/todos', newTodo)\n    },\n  })\n\n  return (\n    <div>\n      {mutation.isPending ? (\n        'Adding todo...'\n      ) : (\n        <>\n          {mutation.isError ? (\n            <div>An error occurred: {mutation.error.message}</div>\n          ) : null}\n\n          {mutation.isSuccess ? <div>Todo added!</div> : null}\n\n          <button\n            onClick={() => {\n              mutation.mutate({ id: new Date(), title: 'Do Laundry' })\n            }}\n          >\n            Create Todo\n          </button>\n        </>\n      )}\n    </div>\n  )\n```\n\n----------------------------------------\n\nTITLE: Connecting QueryClientProvider in TanStack React Query (TypeScript)\nDESCRIPTION: This code snippet demonstrates initializing a new QueryClient instance and supplying it to the React application using the QueryClientProvider component from @tanstack/react-query. It requires '@tanstack/react-query' as a dependency. The QueryClientProvider expects a 'client' prop, which should be the instance of QueryClient, and should wrap the application's subtree to enable query caching and state management throughout. The main inputs are the QueryClient instance and any child components; no output is directly produced, but this enables React Query features within the app.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/QueryClientProvider.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\n\nconst queryClient = new QueryClient()\n\nfunction App() {\n  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>\n}\n```\n\n----------------------------------------\n\nTITLE: Server-Side Prefetching and HydrationBoundary Usage - React Query - TypeScript\nDESCRIPTION: Implements Next.js Server Component page logic using a QueryClient to prefetch queries without awaiting completion and passes the dehydrated state to the HydrationBoundary for client-side hydration. This enables partial streaming and progressive rendering as data becomes available, following the React Query/Next.js prefetching paradigm. Requires @tanstack/react-query, a getQueryClient function, and a Posts component; main parameters are queryKey, queryFn, and the dehydrate function.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// app/posts/page.tsx\nimport { dehydrate, HydrationBoundary } from '@tanstack/react-query'\nimport { getQueryClient } from './get-query-client'\nimport Posts from './posts'\n\n// the function doesn't need to be `async` because we don't `await` anything\nexport default function PostsPage() {\n  const queryClient = getQueryClient()\n\n  // look ma, no await\n  queryClient.prefetchQuery({\n    queryKey: ['posts'],\n    queryFn: getPosts,\n  })\n\n  return (\n    <HydrationBoundary state={dehydrate(queryClient)}>\n      <Posts />\n    </HydrationBoundary>\n  )\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing a Basic Query with TanStack Vue Query in TypeScript\nDESCRIPTION: This snippet shows the fundamental usage of the `useQuery` hook from `@tanstack/vue-query`. It initiates a data fetch associated with the query key `['todos']` using the provided `fetchTodoList` function. The result object contains the query's state and data.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/queries.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useQuery } from '@tanstack/vue-query'\n\nconst result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })\n```\n\n----------------------------------------\n\nTITLE: Custom Error Serialization for React Query Dehydration\nDESCRIPTION: Example showing how to handle serialization of non-JSON-serializable values like Error objects during dehydration and hydration process.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/hydration.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// server\nconst state = dehydrate(client, { shouldDehydrateQuery: () => true }) // to also include Errors\nconst serializedState = mySerialize(state) // transform Error instances to objects\n\n// client\nconst state = myDeserialize(serializedState) // transform objects back to Error instances\nhydrate(client, state)\n```\n\n----------------------------------------\n\nTITLE: Creating a Reactive Query Composable in Vue\nDESCRIPTION: A properly implemented reactive query composable that accepts a ref directly so it can track changes to the value and trigger a re-fetch when needed.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/reactivity.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport function useUserProjects(userId: Ref<string>) {\n  return useQuery(\n    queryKey: ['userProjects', userId],\n    queryFn: () => api.fetchUserProjects(userId.value),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Infinite Query Pagination\nDESCRIPTION: Example of testing infinite query pagination with multiple page loads.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst { result } = renderHook(() => useInfiniteQueryCustomHook(), {\n  wrapper,\n})\n\nawait waitFor(() => expect(result.current.isSuccess).toBe(true))\n\nexpect(result.current.data.pages).toStrictEqual(generateMockedResponse(1))\n\nresult.current.fetchNextPage()\n\nawait waitFor(() =>\n  expect(result.current.data.pages).toStrictEqual([\n    ...generateMockedResponse(1),\n    ...generateMockedResponse(2),\n  ]),\n)\n\nexpectation.done()\n```\n\n----------------------------------------\n\nTITLE: Setting Default Query Options with setQueryDefaults in React Query (TSX)\nDESCRIPTION: Demonstrates using the `QueryClient.setQueryDefaults` method (introduced in v3) to define default options, like a `queryFn`, for queries matching a specific query key or prefix (e.g., `['posts']`). This simplifies subsequent `useQuery` calls by allowing them to omit the defaulted options. Requires `QueryClient` and `useQuery` from React Query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_19\n\nLANGUAGE: tsx\nCODE:\n```\nqueryClient.setQueryDefaults(['posts'], { queryFn: fetchPosts })\n\nfunction Component() {\n  const { data } = useQuery(['posts'])\n}\n```\n\n----------------------------------------\n\nTITLE: Predicate-Based Query Invalidation in TypeScript\nDESCRIPTION: Illustrates using a predicate function for fine-grained query invalidation. The function receives each `Query` object from the cache and returns `true` if the query should be invalidated based on custom logic. In this example, it invalidates 'todos' queries where the version in the second part of the key is greater than or equal to 10.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-invalidation.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nqueryClient.invalidateQueries({\n  predicate: (query) =>\n    query.queryKey[0] === 'todos' && query.queryKey[1]?.version >= 10,\n})\n\n// The query below will be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { version: 20 }],\n  queryFn: fetchTodoList,\n})\n\n// The query below will be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { version: 10 }],\n  queryFn: fetchTodoList,\n})\n\n// However, the following query below will NOT be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { version: 5 }],\n  queryFn: fetchTodoList,\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing QueryClient and Provider in Remix Application (app/root.tsx) - TypeScript\nDESCRIPTION: Configures the QueryClient for Remix using React's useState for single instantiation, and injects the client into the QueryClientProvider at the root of the Remix app. This enables SSR caching and hydration, ensuring all nested routes have access to the React Query context. Requires @tanstack/react-query and @remix-run/react.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-23_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\n// app/root.tsx\nimport { Outlet } from '@remix-run/react'\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\n\nexport default function MyApp() {\n  const [queryClient] = React.useState(\n    () =>\n      new QueryClient({\n        defaultOptions: {\n          queries: {\n            // With SSR, we usually want to set some default staleTime\n            // above 0 to avoid refetching immediately on the client\n            staleTime: 60 * 1000,\n          },\n        },\n      }),\n  )\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Outlet />\n    </QueryClientProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using `getQueryData` Without `queryOptions` (TypeScript)\nDESCRIPTION: Illustrates the behavior of `queryClient.getQueryData` when not using a key derived from `queryOptions`. Without the associated type information, `getQueryData` returns `unknown` unless an explicit generic type (`<Group[]>`) is provided.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-23_snippet_12\n\nLANGUAGE: ts\nCODE:\n```\nconst data = queryClient.getQueryData<Group[]>(['groups'])\n```\n\n----------------------------------------\n\nTITLE: Basic Data Fetching with useQuery in SolidJS\nDESCRIPTION: Demonstrates the fundamental usage of `useQuery` from `@tanstack/solid-query` within a SolidJS component. It sets up a `QueryClient`, wraps the application with `QueryClientProvider`, and uses `useQuery` to fetch data (`fetchTodos`). The component utilizes SolidJS's `Switch`, `Match`, and `For` components to render different UI based on the query's state (pending, error, success). Assumes a `fetchTodos` function exists.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/quick-start.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  QueryClient,\n  QueryClientProvider,\n  useQuery,\n} from '@tanstack/solid-query'\nimport { Switch, Match, For } from 'solid-js'\n\nconst queryClient = new QueryClient()\n\nfunction Example() {\n  const query = useQuery(() => ({\n    queryKey: ['todos'],\n    queryFn: fetchTodos,\n  }))\n\n  return (\n    <div>\n      <Switch>\n        <Match when={query.isPending}>\n          <p>Loading...</p>\n        </Match>\n        <Match when={query.isError}>\n          <p>Error: {query.error.message}</p>\n        </Match>\n        <Match when={query.isSuccess}>\n          <For each={query.data}>{(todo) => <p>{todo.title}</p>}</For>\n        </Match>\n      </Switch>\n    </div>\n  )\n}\n\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Example />\n    </QueryClientProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom QueryClient and Exporting getQueryClient - React Query - TypeScript\nDESCRIPTION: Defines a factory to create a QueryClient with options to dehydrate pending queries and optional error redaction, enabling seamless SSR hydration and compatibility with streaming in Next.js Server Components. This snippet exports getQueryClient, which guarantees a single QueryClient instance in the browser and always creates a new one on the server, helping avoid bugs related to client instance reuse or React suspense behavior. Dependencies include @tanstack/react-query and next, and main parameters are cache config (staleTime), shouldDehydrateQuery, shouldRedactErrors, and usage of browser/server environment detection.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// app/get-query-client.ts\nimport {\n  isServer,\n  QueryClient,\n  defaultShouldDehydrateQuery,\n} from '@tanstack/react-query'\n\nfunction makeQueryClient() {\n  return new QueryClient({\n    defaultOptions: {\n      queries: {\n        staleTime: 60 * 1000,\n      },\n      dehydrate: {\n        // include pending queries in dehydration\n        shouldDehydrateQuery: (query) =>\n          defaultShouldDehydrateQuery(query) ||\n          query.state.status === 'pending',\n        shouldRedactErrors: (error) => {\n          // We should not catch Next.js server errors\n          // as that's how Next.js detects dynamic pages\n          // so we cannot redact them.\n          // Next.js also automatically redacts errors for us\n          // with better digests.\n          return false\n        },\n      },\n    },\n  })\n}\n\nlet browserQueryClient: QueryClient | undefined = undefined\n\nexport function getQueryClient() {\n  if (isServer) {\n    // Server: always make a new query client\n    return makeQueryClient()\n  } else {\n    // Browser: make a new query client if we don't already have one\n    // This is very important, so we don't re-make a new client if React\n    // suspends during the initial render. This may not be needed if we\n    // have a suspense boundary BELOW the creation of the query client\n    if (!browserQueryClient) browserQueryClient = makeQueryClient()\n    return browserQueryClient\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Fetching Data with createQuery in Svelte\nDESCRIPTION: Demonstrates fetching data within a Svelte component using the `createQuery` function from '@tanstack/svelte-query'. It defines a query with a unique `queryKey` (['todos']) and a `queryFn` (fetchTodos) to perform the data retrieval. The component uses Svelte's reactive store syntax (`$query`) to access the query's state (isLoading, isError, isSuccess, data, error) and conditionally renders UI based on the fetching status.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/overview.md#2025-04-23_snippet_1\n\nLANGUAGE: svelte\nCODE:\n```\n<script lang=\"ts\">\n  import { createQuery } from '@tanstack/svelte-query'\n\n  const query = createQuery({\n    queryKey: ['todos'],\n    queryFn: () => fetchTodos(),\n  })\n</script>\n\n<div>\n  {#if $query.isLoading}\n    <p>Loading...</p>\n  {:else if $query.isError}\n    <p>Error: {$query.error.message}</p>\n  {:else if $query.isSuccess}\n    {#each $query.data as todo}\n      <p>{todo.title}</p>\n    {/each}\n  {/if}\n</div>\n```\n\n----------------------------------------\n\nTITLE: Explicitly Persisting Cache with persistQueryClientSave - TanStack Query - TypeScript\nDESCRIPTION: This function call example shows how to persist the current QueryClient cache immediately using persistQueryClientSave. Accepts queryClient, persister, an optional buster string for invalidation, and optional dehydrateOptions for customizing what is saved. This is throttled (e.g., to once per second) for built-in persisters. Saves dehydrated cache to a specified storage mechanism provided by persister.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/persistQueryClient.md#2025-04-23_snippet_2\n\nLANGUAGE: TSX\nCODE:\n```\npersistQueryClientSave({\n  queryClient,\n  persister,\n  buster = '',\n  dehydrateOptions = undefined,\n})\n```\n\n----------------------------------------\n\nTITLE: Refetching Queries with TanStack Query\nDESCRIPTION: Examples of refetching queries using queryClient.refetchQueries with different filtering options.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\n// refetch all queries:\nawait queryClient.refetchQueries()\n\n// refetch all stale queries:\nawait queryClient.refetchQueries({ stale: true })\n\n// refetch all active queries partially matching a query key:\nawait queryClient.refetchQueries({ queryKey: ['posts'], type: 'active' })\n\n// refetch all active queries exactly matching a query key:\nawait queryClient.refetchQueries({\n  queryKey: ['posts', 1],\n  type: 'active',\n  exact: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing GitHub Repository Data Fetching with TanStack Query in Angular\nDESCRIPTION: Example component demonstrating how to fetch GitHub repository data using TanStack Query with Angular. Shows integration with HttpClient, template handling of loading/error states, and displaying repository statistics. Uses Angular's standalone components and OnPush change detection.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/overview.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ChangeDetectionStrategy, Component, inject } from '@angular/core'\nimport { HttpClient } from '@angular/common/http'\nimport { CommonModule } from '@angular/common'\nimport { injectQuery } from '@tanstack/angular-query-experimental'\nimport { lastValueFrom } from 'rxjs'\n\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  selector: 'simple-example',\n  standalone: true,\n  template: `\n    @if (query.isPending()) {\n      Loading...\n    }\n    @if (query.error()) {\n      An error has occurred: {{ query.error().message }}\n    }\n    @if (query.data(); as data) {\n      <h1>{{ data.name }}</h1>\n      <p>{{ data.description }}</p>\n      <strong>üëÄ {{ data.subscribers_count }}</strong>\n      <strong>‚ú® {{ data.stargazers_count }}</strong>\n      <strong>üç¥ {{ data.forks_count }}</strong>\n    }\n  `\n})\nexport class SimpleExampleComponent {\n  http = inject(HttpClient)\n\n  query = injectQuery(() => ({\n    queryKey: ['repoData'],\n    queryFn: () =>\n      lastValueFrom(\n        this.http.get<Response>('https://api.github.com/repos/tanstack/query'),\n      ),\n  }))\n}\n\ninterface Response {\n  name: string\n  description: string\n  subscribers_count: number\n  stargazers_count: number\n  forks_count: number\n}\n```\n\n----------------------------------------\n\nTITLE: Invoking useSuspenseQuery with Options in TanStack Query (TSX)\nDESCRIPTION: Demonstrates how to call the useSuspenseQuery hook with a configurable options object in a React TSX component. The options parameter accepts most properties from useQuery except throwOnError, enabled, and placeholderData. Requires TanStack Query library and a React environment. The returned result object guarantees that data is always defined, omits isPlaceholderData, and restricts status to success or error, with appropriate derived flags. Note that query cancellation is not supported with useSuspenseQuery.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useSuspenseQuery.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst result = useSuspenseQuery(options)\n```\n\n----------------------------------------\n\nTITLE: Reactive Query Options with useQuery in Solid Query (TypeScript/TSX)\nDESCRIPTION: This example uses useQuery in combination with a reactive signal ('filter') to refetch todos when the filter changes, utilizing reactive scoping in SolidJS. Dependencies include @tanstack/solid-query and SolidJS's createSignal. The queryKey includes the filter value for cache separation, and the queryFn fetches todos based on the current filter. Inputs are the current filter and the API endpoint; outputs include filtered data and relevant query status properties.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/reference/useQuery.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQuery } from '@tanstack/solid-query'\n\nfunction App() {\n  const [filter, setFilter] = createSignal('all')\n\n  const todos = useQuery(() => ({\n    queryKey: ['todos', filter()],\n    queryFn: async () => {\n      const response = await fetch(`/api/todos?filter=${filter()}`)\n      if (!response.ok) {\n        throw new Error('Failed to fetch todos')\n      }\n      return response.json()\n    },\n  }))\n\n  return (\n    <div>\n      <div>\n        <button onClick={() => setFilter('all')}>All</button>\n        <button onClick={() => setFilter('active')}>Active</button>\n        <button onClick={() => setFilter('completed')}>Completed</button>\n      </div>\n      <Show when={todos.isError}>\n        <div>Error: {todos.error.message}</div>\n      </Show>\n      <Show when={todos.isLoading}>\n        <div>Loading...</div>\n      </Show>\n      <Show when={todos.isSuccess}>\n        <div>\n          <div>Todos:</div>\n          <ul>\n            <For each={todos.data}>{(todo) => <li>{todo.title}</li>}</For>\n          </ul>\n        </div>\n      </Show>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Bi-directional Infinite Query Configuration\nDESCRIPTION: Configuration for implementing bi-directional infinite scrolling with previous and next page parameters\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nuseInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,\n})\n```\n\n----------------------------------------\n\nTITLE: Fetching Dependent Queries and Server Prefetching for SSR - TypeScript\nDESCRIPTION: Demonstrates fetching dependent queries using useQuery composition, and prefetching these queries for server-side rendering with a QueryClient. On the server, fetches the user first, then, if a userId is available, prefetches related projects; this structure supports both Next.js (getServerSideProps) and Remix (loader). Requires @tanstack/react-query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-23_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Get the user\nconst { data: user } = useQuery({\n  queryKey: ['user', email],\n  queryFn: getUserByEmail,\n})\n\nconst userId = user?.id\n\n// Then get the user's projects\nconst {\n  status,\n  fetchStatus,\n  data: projects,\n} = useQuery({\n  queryKey: ['projects', userId],\n  queryFn: getProjectsByUser,\n  // The query will not execute until the userId exists\n  enabled: !!userId,\n})\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n// For Remix, rename this to loader instead\nexport async function getServerSideProps() {\n  const queryClient = new QueryClient()\n\n  const user = await queryClient.fetchQuery({\n    queryKey: ['user', email],\n    queryFn: getUserByEmail,\n  })\n\n  if (user?.userId) {\n    await queryClient.prefetchQuery({\n      queryKey: ['projects', userId],\n      queryFn: getProjectsByUser,\n    })\n  }\n\n  // For Remix:\n  // return json({ dehydratedState: dehydrate(queryClient) })\n  return { props: { dehydratedState: dehydrate(queryClient) } }\n}\n```\n\n----------------------------------------\n\nTITLE: Query with Conditional Rendering\nDESCRIPTION: Shows how to handle loading, error, and success states using Angular's template syntax with if/else conditions.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/queries.md#2025-04-23_snippet_2\n\nLANGUAGE: angular-ts\nCODE:\n```\n@Component({\n  selector: 'todos',\n  standalone: true,\n  template: `\n    @if (todos.isPending()) {\n      <span>Loading...</span>\n    } @else if (todos.isError()) {\n      <span>Error: {{ todos.error()?.message }}</span>\n    } @else {\n      <!-- We can assume by this point that status === 'success' -->\n      @for (todo of todos.data(); track todo.id) {\n        <li>{{ todo.title }}</li>\n      } @empty {\n        <li>No todos found</li>\n      }\n    }\n  `,\n})\nexport class PostsComponent {\n  todos = injectQuery(() => ({\n    queryKey: ['todos'],\n    queryFn: fetchTodoList,\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling with queryClient.fetchQuery and Custom Dehydration Logic - TypeScript\nDESCRIPTION: Provides an error-handling pattern for SSR using queryClient.fetchQuery to throw and catch request errors, allowing servers to respond appropriately (e.g., with error status codes). Also shows how to use the shouldDehydrateQuery option in dehydrate to include failed queries in the dehydrated state or to apply custom query filtering logic. Depends on @tanstack/react-query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-23_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nlet result\n\ntry {\n  result = await queryClient.fetchQuery(...)\n} catch (error) {\n  // Handle the error, refer to your framework documentation\n}\n\n// You might also want to check and handle any invalid `result` here\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\ndehydrate(queryClient, {\n  shouldDehydrateQuery: (query) => {\n    // This will include all queries, including failed ones,\n    // but you can also implement your own logic by inspecting `query`\n    return true\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Integrating useQuery with Suspense and ErrorBoundary in Solid Query (TypeScript/TSX)\nDESCRIPTION: This snippet shows how to leverage useQuery with SolidJS Suspense and ErrorBoundary components, enabling unified handling of loading and error states for fetched data. It uses the throwOnError: true option, which causes query errors to propagate and trigger ErrorBoundary. The dependencies are @tanstack/solid-query, Suspense, and ErrorBoundary components from SolidJS; expected inputs are query options and fallback UI. Outputs are rendered error, loading, or data views based on query status.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/reference/useQuery.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQuery } from '@tanstack/solid-query'\n\nfunction App() {\n  const todos = useQuery(() => ({\n    queryKey: 'todos',\n    queryFn: async () => {\n      const response = await fetch('/api/todos')\n      if (!response.ok) {\n        throw new Error('Failed to fetch todos')\n      }\n      return response.json()\n    },\n    throwOnError: true,\n  }))\n\n  return (\n    <ErrorBoundary fallback={<div>Error: {todos.error.message}</div>}>\n      <Suspense fallback={<div>Loading...</div>}>\n        <div>\n          <div>Todos:</div>\n          <ul>\n            <For each={todos.data}>{(todo) => <li>{todo.title}</li>}</For>\n          </ul>\n        </div>\n      </Suspense>\n    </ErrorBoundary>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Invalidating Specific Queries with Variables in TanStack Query\nDESCRIPTION: This example demonstrates how to invalidate queries with specific variables by providing a more detailed query key. It shows which queries will be invalidated and which won't based on the specificity of the query key.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-invalidation.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nqueryClient.invalidateQueries({\n  queryKey: ['todos', { type: 'done' }],\n})\n\n// The query below will be invalidated\ntodoListQuery = injectQuery(() => ({\n  queryKey: ['todos', { type: 'done' }],\n  queryFn: fetchTodoList,\n}))\n\n// However, the following query below will NOT be invalidated\ntodoListQuery = injectQuery(() => ({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n}))\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Query Keys in TanStack Query (TSX)\nDESCRIPTION: Demonstrates the basic usage of `useQuery` with simple, constant array keys. These are suitable for fetching generic lists or non-hierarchical resources where the key is a fixed array of strings. Dependencies include the `useQuery` hook from TanStack Query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-keys.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// A list of todos\nuseQuery({ queryKey: ['todos'], ... })\n\n// Something else, whatever!\nuseQuery({ queryKey: ['something', 'special'], ... })\n```\n\n----------------------------------------\n\nTITLE: Server-side Data Prefetch and Dehydrate with Composition API in Nuxt 2 (TypeScript)\nDESCRIPTION: Demonstrates advanced server-side prefetching using the composition API in a Nuxt 2 page component, including using both useContext and useQueryClient to access the QueryClient instance. Queries can be prefetched and dehydrated by wiring suspense to onServerPrefetch and storing state in the correct SSR context. Some queries are prefetched for SSR, others are left for client fetching. Dependencies include '@nuxtjs/composition-api', '@tanstack/vue-query', and server-side hooks. Inputs are handled by useQuery (e.g., queryKey, queryFn). Outputs include prefetched data, refetch methods, and data reactive references for use in the template. Limitations: proper SSR/CSR distinction, explicit state transfer is required.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/ssr.md#2025-04-23_snippet_4\n\nLANGUAGE: vue\nCODE:\n```\n// pages/todos.vue\n<template>\n  <div>\n    <button @click=\"refetch\">Refetch</button>\n    <p>{{ data }}</p>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  onServerPrefetch,\n  useContext,\n} from '@nuxtjs/composition-api'\nimport { useQuery, useQueryClient, dehydrate } from '@tanstack/vue-query'\n\nexport default defineComponent({\n  setup() {\n    // Get QueryClient either from SSR context, or Vue context\n    const { ssrContext } = useContext()\n    // Make sure to provide `queryClient` as a second parameter to `useQuery` calls\n    const queryClient =\n      (ssrContext != null && ssrContext.VueQuery) || useQueryClient()\n\n    // This will be prefetched and sent from the server\n    const { data, refetch, suspense } = useQuery(\n      {\n        queryKey: ['todos'],\n        queryFn: getTodos,\n      },\n      queryClient,\n    )\n    // This won't be prefetched, it will start fetching on client side\n    const { data2 } = useQuery(\n      {\n        queryKey: 'todos2',\n        queryFn: getTodos,\n      },\n      queryClient,\n    )\n\n    onServerPrefetch(async () => {\n      await suspense()\n      ssrContext.nuxt.vueQueryState = dehydrate(queryClient)\n    })\n\n    return {\n      refetch,\n      data,\n    }\n  },\n})\n</script>\n```\n\n----------------------------------------\n\nTITLE: Disabling Queries with enabled Flag in TanStack Query\nDESCRIPTION: Demonstrates how to disable a query from automatically running using enabled: false option. Shows handling of loading, error, and success states, along with manual refetch functionality.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/disabling-queries.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction Todos() {\n  const { isLoading, isError, data, error, refetch, isFetching } = useQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodoList,\n    enabled: false,\n  })\n\n  return (\n    <div>\n      <button onClick={() => refetch()}>Fetch Todos</button>\n\n      {data ? (\n        <>\n          <ul>\n            {data.map((todo) => (\n              <li key={todo.id}>{todo.title}</li>\n            ))}\n          </ul>\n        </>\n      ) : isError ? (\n        <span>Error: {error.message}</span>\n      ) : isLoading ? (\n        <span>Loading...</span>\n      ) : (\n        <span>Not ready ...</span>\n      )}\n\n      <div>{isFetching ? 'Fetching...' : null}</div>\n    </div>\n  )\n```\n\n----------------------------------------\n\nTITLE: Deriving Placeholder Data from List Cache with useQuery in React Query (TypeScript)\nDESCRIPTION: This snippet shows how to dynamically compute placeholder data for a detail query by accessing and filtering data from another cached query (a list query) using the queryClient.getQueryData method in React Query. The useQuery hook fetches a specific blog post by blogPostId and leverages a function for placeholderData to immediately display information if the post can be found in the existing blogPosts list cache. Required dependencies include React Query and a properly initialized queryClient. The implementation expects blogPostId to be a valid identifier, and it provides seamless placeholder transitions between list and detail queries.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/placeholder-query-data.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst result = useQuery({\n  queryKey: ['blogPost', blogPostId],\n  queryFn: () => fetch(`/blogPosts/${blogPostId}`),\n  placeholderData: () => {\n    // Use the smaller/preview version of the blogPost from the 'blogPosts'\n    // query as the placeholder data for this blogPost query\n    return queryClient\n      .getQueryData(['blogPosts'])\n      ?.find((d) => d.id === blogPostId)\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using useQuery Hook in TanStack Query (JavaScript)\nDESCRIPTION: This snippet demonstrates the usage of the useQuery hook from TanStack Query to fetch and cache todo data. It shows how the query behaves when mounted, unmounted, and remounted, illustrating caching and refetching mechanisms.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/caching.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nuseQuery({ queryKey: ['todos'], queryFn: fetchTodos })\n```\n\n----------------------------------------\n\nTITLE: Selecting and Mapping Query Results - Solid Query - TypeScript/TSX\nDESCRIPTION: Showcases usage of the select parameter in useQuery to transform the resolved data from a number to a string. All dependencies are the same as the previous example, but includes a select function to perform mapping. The resulting data property is inferred to be string or undefined.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/typescript.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQuery } from '@tanstack/solid-query'\n\nconst query = useQuery(() => ({\n  queryKey: ['test'],\n  queryFn: () => Promise.resolve(5),\n  select: (data) => data.toString(),\n}))\n\nquery.data\n//    ^? (property) data: string | undefined\n\n```\n\n----------------------------------------\n\nTITLE: Using `queryOptions` Helper for Type-Safe Reusable Options (TypeScript)\nDESCRIPTION: Introduces the `queryOptions` helper function from TanStack Query. It allows extracting query configurations into reusable, type-safe units, preserving type inference when used with `useQuery` or `prefetchQuery`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-23_snippet_10\n\nLANGUAGE: ts\nCODE:\n```\nimport { queryOptions } from '@tanstack/react-query'\n\nfunction groupOptions() {\n  return queryOptions({\n    queryKey: ['groups'],\n    queryFn: fetchGroups,\n    staleTime: 5 * 1000,\n  })\n}\n\nuseQuery(groupOptions())\nqueryClient.prefetchQuery(groupOptions())\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Default Retry Delay Strategy in Vue Query (TypeScript)\nDESCRIPTION: This TypeScript snippet shows how to set a global default retry delay strategy for all queries in a Vue application using TanStack Vue Query. It utilizes the `VueQueryPlugin` options, specifically setting `queryClientConfig.defaultOptions.queries.retryDelay` to a function that implements exponential backoff with a maximum delay of 30 seconds. This configuration is applied when the `VueQueryPlugin` is installed via `app.use()`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/query-retries.md#2025-04-23_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\n```ts\nimport { VueQueryPlugin } from '@tanstack/vue-query'\n\nconst vueQueryPluginOptions = {\n  queryClientConfig: {\n    defaultOptions: {\n      queries: {\n        retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),\n      },\n    },\n  },\n}\napp.use(VueQueryPlugin, vueQueryPluginOptions)\n```\n```\n\n----------------------------------------\n\nTITLE: Cancelling a TanStack Query Fetch Request in TypeScript\nDESCRIPTION: This snippet demonstrates how to implement query cancellation with TanStack Query. The `queryFn` receives an options object containing an `AbortSignal` (`signal`), which is passed to the `fetch` call. This allows TanStack Query to abort the HTTP request if the query is cancelled either automatically (e.g., on component unmount) or manually via `queryClient.cancelQueries`. The example includes a button click handler (`onButtonClick`) that explicitly cancels queries with the key `['todos']`. Requires `@tanstack/react-query` (or its framework-specific variant like `@tanstack/solid-query`) and the standard `fetch` API.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/guides/query-cancellation.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: async ({ signal }) => {\n    const resp = await fetch('/todos', { signal })\n    return resp.json()\n  },\n})\n\nconst queryClient = useQueryClient()\n\nfunction onButtonClick() {\n  queryClient.cancelQueries({ queryKey: ['todos'] })\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Type Inference with useQuery in TypeScript\nDESCRIPTION: Demonstrates automatic type inference in React Query using `useQuery`. The `data` variable is inferred to be `number | undefined` based on the `queryFn` returning a `Promise<number>`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst { data } = useQuery({\n  //    ^? const data: number | undefined\n  queryKey: ['test'],\n  queryFn: () => Promise.resolve(5),\n})\n```\n\n----------------------------------------\n\nTITLE: Component-Level Prefetching with useQuery in TanStack Query (TypeScript/TSX)\nDESCRIPTION: Prefetches related query data during the parent component's lifecycle using `useQuery`, while preventing unnecessary re-renders by passing `notifyOnChangeProps: []`. This ensures both article and comments queries are fired concurrently, avoiding waterfalls. Dependencies include TanStack Query, relevant fetchers, and use of the `useQuery` hook. Parameters and outputs match those of the regular component structure, except that the secondary prefetched query does not trigger UI updates.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nfunction Article({ id }) {\n  const { data: articleData, isPending } = useQuery({\n    queryKey: ['article', id],\n    queryFn: getArticleById,\n  })\n\n  // Prefetch\n  useQuery({\n    queryKey: ['article-comments', id],\n    queryFn: getArticleCommentsById,\n    // Optional optimization to avoid rerenders when this query changes:\n    notifyOnChangeProps: [],\n  })\n\n  if (isPending) {\n    return 'Loading article...'\n  }\n\n  return (\n    <>\n      <ArticleHeader articleData={articleData} />\n      <ArticleBody articleData={articleData} />\n      <Comments id={id} />\n    </>\n  )\n}\n\nfunction Comments({ id }) {\n  const { data, isPending } = useQuery({\n    queryKey: ['article-comments', id],\n    queryFn: getArticleCommentsById,\n  })\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Static Parallel Queries with injectQuery in Angular\nDESCRIPTION: This snippet demonstrates how to execute multiple queries in parallel by using separate injectQuery calls in an Angular component. Each query has its own queryKey and queryFn, and they will all execute simultaneously when the component initializes.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/parallel-queries.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport class AppComponent {\n  // The following queries will execute in parallel\n  usersQuery = injectQuery(() => ({ queryKey: ['users'], queryFn: fetchUsers }))\n  teamsQuery = injectQuery(() => ({ queryKey: ['teams'], queryFn: fetchTeams }))\n  projectsQuery = injectQuery(() => ({\n    queryKey: ['projects'],\n    queryFn: fetchProjects,\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Query Cancellation with Legacy Axios in TanStack Query\nDESCRIPTION: Implementation of query cancellation for Axios versions below 0.22.0 using CancelToken source.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-cancellation.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport axios from 'axios'\n\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: ({ signal }) => {\n    // Create a new CancelToken source for this request\n    const CancelToken = axios.CancelToken\n    const source = CancelToken.source()\n\n    const promise = axios.get('/todos', {\n      // Pass the source token to your request\n      cancelToken: source.token,\n    })\n\n    // Cancel the request if TanStack Query signals to abort\n    signal?.addEventListener('abort', () => {\n      source.cancel('Query was cancelled by TanStack Query')\n    })\n\n    return promise\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Initial Data with Update Timestamp from Cache\nDESCRIPTION: Configures a query that uses both data and update timestamp from an existing query in the cache.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nresult = injectQuery(() => ({\n  queryKey: ['todos', this.todoId()],\n  queryFn: () => fetch(`/todos/${this.todoId()}`),\n  initialData: () =>\n    queryClient.getQueryData(['todos'])?.find((d) => d.id === this.todoId()),\n  initialDataUpdatedAt: () =>\n    queryClient.getQueryState(['todos'])?.dataUpdatedAt,\n}))\n```\n\n----------------------------------------\n\nTITLE: Form Handling with Mutations in Angular\nDESCRIPTION: An Angular component that integrates a Reactive Form with TanStack Query mutations. It demonstrates form validation, error handling, and reset functionality when creating a todo item.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-23_snippet_1\n\nLANGUAGE: angular-ts\nCODE:\n```\n@Component({\n  standalone: true,\n  selector: 'todo-item',\n  imports: [ReactiveFormsModule],\n  template: `\n    <form [formGroup]=\"todoForm\" (ngSubmit)=\"onCreateTodo()\">\n      @if (mutation.error()) {\n        <h5 (click)=\"mutation.reset()\">{{ mutation.error() }}</h5>\n      }\n      <input type=\"text\" formControlName=\"title\" />\n      <br />\n      <button type=\"submit\">Create Todo</button>\n    </form>\n  `,\n})\nexport class TodosComponent {\n  mutation = injectMutation(() => ({\n    mutationFn: createTodo,\n  }))\n\n  fb = inject(NonNullableFormBuilder)\n\n  todoForm = this.fb.group({\n    title: this.fb.control('', {\n      validators: [Validators.required],\n    }),\n  })\n\n  title = toSignal(this.todoForm.controls.title.valueChanges, {\n    initialValue: '',\n  })\n\n  onCreateTodo = () => {\n    this.mutation.mutate(this.title())\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Prefetching and Hydrating Data with Loader in Remix Route (app/routes/posts.tsx) - TypeScript\nDESCRIPTION: Uses a Remix loader to instantiate a QueryClient, prefetch data for posts, and return a dehydrated state as JSON via Remix's loader infrastructure, with client-side rehydration using HydrationBoundary. The Posts component demonstrates mixing SSR-prefetched and client-prefetched queries. Requires @tanstack/react-query and @remix-run/node.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\n// app/routes/posts.tsx\nimport { json } from '@remix-run/node'\nimport {\n  dehydrate,\n  HydrationBoundary,\n  QueryClient,\n  useQuery,\n} from '@tanstack/react-query'\n\nexport async function loader() {\n  const queryClient = new QueryClient()\n\n  await queryClient.prefetchQuery({\n    queryKey: ['posts'],\n    queryFn: getPosts,\n  })\n\n  return json({ dehydratedState: dehydrate(queryClient) })\n}\n\nfunction Posts() {\n  // This useQuery could just as well happen in some deeper child to\n  // the <PostsRoute>, data will be available immediately either way\n  const { data } = useQuery({ queryKey: ['posts'], queryFn: getPosts })\n\n  // This query was not prefetched on the server and will not start\n  // fetching until on the client, both patterns are fine to mix\n  const { data: commentsData } = useQuery({\n    queryKey: ['posts-comments'],\n    queryFn: getComments,\n  })\n\n  // ...\n}\n\nexport default function PostsRoute() {\n  const { dehydratedState } = useLoaderData<typeof loader>()\n  return (\n    <HydrationBoundary state={dehydratedState}>\n      <Posts />\n    </HydrationBoundary>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Query Data with Custom Stale Time\nDESCRIPTION: Shows how to fetch query data with a specific staleTime configuration, only fetching when data is older than the specified time.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\ntry {\n  const data = await queryClient.fetchQuery({\n    queryKey,\n    queryFn,\n    staleTime: 10000,\n  })\n} catch (error) {\n  console.log(error)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Global Background Fetching Indicator in React with TanStack Query\nDESCRIPTION: This snippet shows how to create a global loading indicator that displays when any query is fetching, including background fetches. It uses the 'useIsFetching' hook from TanStack Query to determine if any queries are currently fetching.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/background-fetching-indicators.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useIsFetching } from '@tanstack/react-query'\n\nfunction GlobalLoadingIndicator() {\n  const isFetching = useIsFetching()\n\n  return isFetching ? (\n    <div>Queries are fetching in the background...</div>\n  ) : null\n}\n```\n\n----------------------------------------\n\nTITLE: Using useIsMutating Hook in TanStack React Query (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to import and utilize the `useIsMutating` hook from `@tanstack/react-query`. It shows two use cases: first, getting the total count of all currently fetching mutations, and second, getting the count of mutations that match a specific `mutationKey` filter (in this case, ['posts']). The hook returns a number representing the count of active mutations.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useIsMutating.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useIsMutating } from '@tanstack/react-query'\n// How many mutations are fetching?\nconst isMutating = useIsMutating()\n// How many mutations matching the posts prefix are fetching?\nconst isMutatingPosts = useIsMutating({ mutationKey: ['posts'] })\n```\n\n----------------------------------------\n\nTITLE: Installing React Query via Yarn (Bash)\nDESCRIPTION: Installs the `@tanstack/react-query` package using the Yarn package manager. This command downloads and adds the library to your project's dependencies.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/installation.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @tanstack/react-query\n```\n\n----------------------------------------\n\nTITLE: Initial Data with Stale Time Control\nDESCRIPTION: Configures a query with initial data and a stale time of 1000ms to delay refetching until after the specified duration.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Show initialTodos immediately, but won't refetch until\n// another interaction event is encountered after 1000 ms\nresult = injectQuery(() => ({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n  staleTime: 1000,\n}))\n```\n\n----------------------------------------\n\nTITLE: Using a Reactive Query Composable in Vue\nDESCRIPTION: Using a reactive query composable that properly updates when the referenced value changes, as TanStack Query is now tracking the ref object.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/reactivity.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst onChangeUser = (newUserId: string) => {\n  // Query refetches data with new user ID!\n  userId.value = newUserId\n}\n```\n\n----------------------------------------\n\nTITLE: Prefetching with Suspense Integration Using usePrefetchQuery Hook in TanStack Query (TypeScript/TSX)\nDESCRIPTION: Demonstrates using the `usePrefetchQuery` hook to initiate prefetching before a Suspense boundary, allowing the main data to be fetched with `useSuspenseQuery` while comments are prefetched to be ready when needed. Prerequisites include TanStack Query's Suspense integration hooks, React Suspense component, and relevant fetchers. `id` is required as a parameter, and output is a component tree where fallback rendering is handled by Suspense. Prefetching does not block rendering.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nfunction ArticleLayout({ id }) {\n  usePrefetchQuery({\n    queryKey: ['article-comments', id],\n    queryFn: getArticleCommentsById,\n  })\n\n  return (\n    <Suspense fallback=\"Loading article\">\n      <Article id={id} />\n    </Suspense>\n  )\n}\n\nfunction Article({ id }) {\n  const { data: articleData, isPending } = useSuspenseQuery({\n    queryKey: ['article', id],\n    queryFn: getArticleById,\n  })\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Infinite Query with Numeric Pagination\nDESCRIPTION: Implementation of infinite query using numeric page numbers instead of cursors\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-23_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nreturn useInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, allPages, lastPageParam) => {\n    if (lastPage.length === 0) {\n      return undefined\n    }\n    return lastPageParam + 1\n  },\n  getPreviousPageParam: (firstPage, allPages, firstPageParam) => {\n    if (firstPageParam <= 1) {\n      return undefined\n    }\n    return firstPageParam - 1\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Client-Side Suspense Query Usage - React Query - TypeScript\nDESCRIPTION: Shows usage of useSuspenseQuery within a Next.js Client Component to access prefetched query data; relies on the server putting a Promise in the QueryCache, which the client picks up automatically, allowing seamless SSR hydration with React Suspense. Dependencies include React, @tanstack/react-query, and a getPosts query function. Takes queryKey and queryFn, returns query data (posts), and should be a functional component marked with 'use client'.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// app/posts/posts.tsx\n'use client'\n\nexport default function Posts() {\n  const { data } = useSuspenseQuery({ queryKey: ['posts'], queryFn: getPosts })\n\n  // ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Invalidating Queries with TanStack Query in Angular\nDESCRIPTION: This snippet shows how to invalidate queries using the QueryClient in Angular. It demonstrates invalidating all 'todos' queries, including those with additional parameters.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-invalidation.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { injectQuery, QueryClient } from '@tanstack/angular-query-experimental'\n\nclass QueryInvalidationExample {\n  queryClient = inject(QueryClient)\n\n  invalidateQueries() {\n    this.queryClient.invalidateQueries({ queryKey: ['todos'] })\n  }\n\n  // Both queries below will be invalidated\n  todoListQuery = injectQuery(() => ({\n    queryKey: ['todos'],\n    queryFn: fetchTodoList,\n  }))\n  todoListQuery = injectQuery(() => ({\n    queryKey: ['todos', { page: 1 }],\n    queryFn: fetchTodoList,\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Async Mutation with Error Handling\nDESCRIPTION: Demonstrates using mutateAsync to handle mutations with async/await syntax. Shows how to handle successful mutations, errors, and cleanup in a try/catch/finally block.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-23_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nmutation = injectMutation(() => ({ mutationFn: addTodo }))\n\ntry {\n  const todo = await mutation.mutateAsync(todo)\n  console.log(todo)\n} catch (error) {\n  console.error(error)\n} finally {\n  console.log('done')\n}\n```\n\n----------------------------------------\n\nTITLE: Exact Query Invalidation in TanStack Query\nDESCRIPTION: This snippet shows how to use the 'exact' option in invalidateQueries to only invalidate queries that exactly match the provided query key, without any additional variables or subkeys.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-invalidation.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nqueryClient.invalidateQueries({\n  queryKey: ['todos'],\n  exact: true,\n})\n\n// The query below will be invalidated\ntodoListQuery = injectQuery(() => ({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n}))\n\n// However, the following query below will NOT be invalidated\nconst todoListQuery = injectQuery(() => ({\n  queryKey: ['todos', { type: 'done' }],\n  queryFn: fetchTodoList,\n}))\n```\n\n----------------------------------------\n\nTITLE: Query Cancellation with Legacy GraphQL Client in TanStack Query\nDESCRIPTION: Shows how to implement query cancellation for GraphQL client versions below 4.0.0 by passing the signal in the client constructor.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-cancellation.md#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: ({ signal }) => {\n    const client = new GraphQLClient(endpoint, {\n      signal,\n    })\n    return client.request(query, variables)\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing Latest Mutation Data by Key using useMutationState (TSX)\nDESCRIPTION: This snippet builds upon the previous example. After defining a mutation with `useMutation` and retrieving all associated data using `useMutationState` filtered by `mutationKey`, it demonstrates how to access the data from the *most recent* invocation of that mutation. Since `useMutationState` returns an array of results (one for each invocation still in the cache), the last element `data[data.length - 1]` corresponds to the latest mutation data. Depends on `@tanstack/react-query`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useMutationState.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport { useMutation, useMutationState } from '@tanstack/react-query'\n\nconst mutationKey = ['posts']\n\n// Some mutation that we want to get the state for\nconst mutation = useMutation({\n  mutationKey,\n  mutationFn: (newPost) => {\n    return axios.post('/posts', newPost)\n  },\n})\n\nconst data = useMutationState({\n  // this mutation key needs to match the mutation key of the given mutation (see above)\n  filters: { mutationKey },\n  select: (mutation) => mutation.state.data,\n})\n\n// Latest mutation data\nconst latest = data[data.length - 1]\n```\n```\n\n----------------------------------------\n\nTITLE: Consecutive Mutations Handler\nDESCRIPTION: Demonstrates handling of consecutive mutations and their callback behaviors, particularly focusing on execution order and component mounting considerations.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nuseMutation({\n  mutationFn: addTodo,\n  onSuccess: (data, variables, context) => {\n    // Will be called 3 times\n  },\n})\n\nconst todos = ['Todo 1', 'Todo 2', 'Todo 3']\ntodos.forEach((todo) => {\n  mutate(todo, {\n    onSuccess: (data, variables, context) => {\n      // Will execute only once, for the last mutation (Todo 3),\n      // regardless which mutation resolves first\n    },\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Paginated Query Component with TanStack Query in Angular\nDESCRIPTION: This Angular component implements a paginated query using TanStack Query. It includes features such as displaying loading states, error handling, pagination controls, and prefetching the next page. The component uses signals for reactivity and injectQuery for data fetching.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/paginated-queries.md#2025-04-23_snippet_1\n\nLANGUAGE: angular-ts\nCODE:\n```\n@Component({\n  selector: 'pagination-example',\n  template: `\n    <div>\n      <p>\n        In this example, each page of data remains visible as the next page is\n        fetched. The buttons and capability to proceed to the next page are also\n        suppressed until the next page cursor is known. Each page is cached as a\n        normal query too, so when going to previous pages, you'll see them\n        instantaneously while they are also re-fetched invisibly in the\n        background.\n      </p>\n      @if (query.status() === 'pending') {\n        <div>Loading...</div>\n      } @else if (query.status() === 'error') {\n        <div>Error: {{ query.error().message }}</div>\n      } @else {\n        <!-- 'data' will either resolve to the latest page's data -->\n        <!-- or if fetching a new page, the last successful page's data -->\n        <div>\n          @for (project of query.data().projects; track project.id) {\n            <p>{{ project.name }}</p>\n          }\n        </div>\n      }\n\n      <div>Current Page: {{ page() + 1 }}</div>\n      <button (click)=\"previousPage()\" [disabled]=\"page() === 0\">\n        Previous Page\n      </button>\n      <button\n        (click)=\"nextPage()\"\n        [disabled]=\"query.isPlaceholderData() || !query.data()?.hasMore\"\n      >\n        Next Page\n      </button>\n      <!-- Since the last page's data potentially sticks around between page requests, -->\n      <!-- we can use 'isFetching' to show a background loading -->\n      <!-- indicator since our status === 'pending' state won't be triggered -->\n      @if (query.isFetching()) {\n        <span> Loading...</span>\n      }\n    </div>\n  `,\n})\nexport class PaginationExampleComponent {\n  page = signal(0)\n  queryClient = inject(QueryClient)\n\n  query = injectQuery(() => ({\n    queryKey: ['projects', this.page()],\n    queryFn: () => lastValueFrom(fetchProjects(this.page())),\n    placeholderData: keepPreviousData,\n    staleTime: 5000,\n  }))\n\n  constructor() {\n    effect(() => {\n      // Prefetch the next page!\n      if (!this.query.isPlaceholderData() && this.query.data()?.hasMore) {\n        this.#queryClient.prefetchQuery({\n          queryKey: ['projects', this.page() + 1],\n          queryFn: () => lastValueFrom(fetchProjects(this.page() + 1)),\n        })\n      }\n    })\n  }\n\n  previousPage() {\n    this.page.update((old) => Math.max(old - 1, 0))\n  }\n\n  nextPage() {\n    this.page.update((old) => (this.query.data()?.hasMore ? old + 1 : old))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Handling Mutations with TanStack Vue Query - Vue\nDESCRIPTION: This Vue example demonstrates how to initialize and use the useMutation hook from @tanstack/vue-query to add a new todo item via an axios POST request. The snippet showcases reactive mutation states (isPending, isError, isSuccess), error feedback, and submitting a new todo via the mutate function. Dependencies include @tanstack/vue-query and axios, and the component expects to run within a Vue 3 + Composition API setup. The inputs are new todo data, and outputs are mutation state indicators displayed in the UI.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/mutations.md#2025-04-23_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\\nimport { useMutation } from '@tanstack/vue-query'\\n\\nconst { isPending, isError, error, isSuccess, mutate } = useMutation({\\n  mutationFn: (newTodo) => axios.post('/todos', newTodo),\\n})\\n\\nfunction addTodo() {\\n  mutate({ id: new Date(), title: 'Do Laundry' })\\n}\\n<\\/script>\\n\\n<template>\\n  <span v-if=\\\"isPending\\\">Adding todo...<\\/span>\\n  <span v-else-if=\\\"isError\\\">An error occurred: {{ error.message }}<\\/span>\\n  <span v-else-if=\\\"isSuccess\\\">Todo added!<\\/span>\\n  <button @click=\\\"addTodo\\\">Create Todo<\\/button>\\n<\\/template>\n```\n\n----------------------------------------\n\nTITLE: Using useQueryClient Hook in React Query (TypeScript)\nDESCRIPTION: This code snippet shows how to import and call the `useQueryClient` hook from `@tanstack/react-query`. It retrieves the `QueryClient` instance currently available in the React context, or accepts an optional `QueryClient` instance as an argument to use a specific client. The returned `queryClient` instance can then be used to interact with the query cache, invalidate queries, etc.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useQueryClient.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```tsx\nimport { useQueryClient } from '@tanstack/react-query'\n\nconst queryClient = useQueryClient(queryClient?: QueryClient)\n```\n```\n\n----------------------------------------\n\nTITLE: Mutation Lifecycle Callbacks\nDESCRIPTION: Implementation of mutation lifecycle callbacks including onMutate, onError, onSuccess, and onSettled for handling different stages of the mutation process.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nuseMutation({\n  mutationFn: addTodo,\n  onMutate: (variables) => {\n    // A mutation is about to happen!\n\n    // Optionally return a context containing data to use when for example rolling back\n    return { id: 1 }\n  },\n  onError: (error, variables, context) => {\n    // An error happened!\n    console.log(`rolling back optimistic update with id ${context.id}`)\n  },\n  onSuccess: (data, variables, context) => {\n    // Boom baby!\n  },\n  onSettled: (data, error, variables, context) => {\n    // Error or success... doesn't matter!\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Next.js React Query Provider Setup\nDESCRIPTION: Configuration for setting up React Query with NextJS including streamed hydration support.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/suspense.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\n\nimport {\n  isServer,\n  QueryClient,\n  QueryClientProvider,\n} from '@tanstack/react-query'\nimport * as React from 'react'\nimport { ReactQueryStreamedHydration } from '@tanstack/react-query-next-experimental'\n\nfunction makeQueryClient() {\n  return new QueryClient({\n    defaultOptions: {\n      queries: {\n        staleTime: 60 * 1000,\n      },\n    },\n  })\n}\n\nlet browserQueryClient: QueryClient | undefined = undefined\n\nfunction getQueryClient() {\n  if (isServer) {\n    return makeQueryClient()\n  } else {\n    if (!browserQueryClient) browserQueryClient = makeQueryClient()\n    return browserQueryClient\n  }\n}\n\nexport function Providers(props: { children: React.ReactNode }) {\n  const queryClient = getQueryClient()\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <ReactQueryStreamedHydration>\n        {props.children}\n      </ReactQueryStreamedHydration>\n    </QueryClientProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Paginated Query Implementation in TanStack Query\nDESCRIPTION: Simple example showing how to include page information in the query key for pagination. This basic implementation demonstrates the foundational approach to paginated queries.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/paginated-queries.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst result = useQuery({\n  queryKey: ['projects', page],\n  queryFn: fetchProjects,\n})\n```\n\n----------------------------------------\n\nTITLE: Prefetching and Hydrating Data for SSR in Next.js Route (pages/posts.tsx) - TypeScript\nDESCRIPTION: Implements SSR data prefetching for posts using React Query in a Next.js page route. The getStaticProps asynchronously creates a QueryClient, prefetches posts, and returns a dehydrated state for hydration on the client. Uses HydrationBoundary to rehydrate prefetched state, with additional queries running client-side if not included in SSR. Depends on @tanstack/react-query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\n// pages/posts.tsx\nimport {\n  dehydrate,\n  HydrationBoundary,\n  QueryClient,\n  useQuery,\n} from '@tanstack/react-query'\n\n// This could also be getServerSideProps\nexport async function getStaticProps() {\n  const queryClient = new QueryClient()\n\n  await queryClient.prefetchQuery({\n    queryKey: ['posts'],\n    queryFn: getPosts,\n  })\n\n  return {\n    props: {\n      dehydratedState: dehydrate(queryClient),\n    },\n  }\n}\n\nfunction Posts() {\n  // This useQuery could just as well happen in some deeper child to\n  // the <PostsRoute>, data will be available immediately either way\n  const { data } = useQuery({ queryKey: ['posts'], queryFn: getPosts })\n\n  // This query was not prefetched on the server and will not start\n  // fetching until on the client, both patterns are fine to mix\n  const { data: commentsData } = useQuery({\n    queryKey: ['posts-comments'],\n    queryFn: getComments,\n  })\n\n  // ...\n}\n\nexport default function PostsRoute({ dehydratedState }) {\n  return (\n    <HydrationBoundary state={dehydratedState}>\n      <Posts />\n    </HydrationBoundary>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Reusable Query Options with `queryOptions` in TypeScript\nDESCRIPTION: Demonstrates creating a reusable function `groupOptions` using `queryOptions` from `@tanstack/react-query`. This function encapsulates `queryKey`, `queryFn` (calling a hypothetical `fetchGroups` function), and `staleTime` for fetching group data based on an ID. The example shows how these structured options can be easily consumed by various TanStack Query hooks (`useQuery`, `useSuspenseQuery`, `useQueries`) and client methods (`prefetchQuery`, `setQueryData`), promoting code reuse and consistency.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-options.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { queryOptions } from '@tanstack/react-query'\n\nfunction groupOptions(id: number) {\n  return queryOptions({\n    queryKey: ['groups', id],\n    queryFn: () => fetchGroups(id),\n    staleTime: 5 * 1000,\n  })\n}\n\n// usage:\n\nuseQuery(groupOptions(1))\nuseSuspenseQuery(groupOptions(5))\nuseQueries({\n  queries: [groupOptions(1), groupOptions(2)],\n})\nqueryClient.prefetchQuery(groupOptions(23))\nqueryClient.setQueryData(groupOptions(42).queryKey, newGroups)\n```\n\n----------------------------------------\n\nTITLE: Overriding Query Options with `select` in TypeScript\nDESCRIPTION: Illustrates how to override or extend query options defined via `queryOptions` when using them with `useQuery`. This example takes the base configuration from `groupOptions(1)` and adds a `select` function to transform the fetched data, extracting only the `groupName`. It highlights that TypeScript type inference correctly determines the type of `query.data` based on the return type of the `select` function, not the original `queryFn`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-options.md#2025-04-23_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\n// Type inference still works, so query.data will be the return type of select instead of queryFn\n\nconst query = useQuery({\n  ...groupOptions(1),\n  select: (data) => data.groupName,\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Vue Query Plugin for Nuxt 3 (TypeScript)\nDESCRIPTION: This snippet sets up a Nuxt 3 plugin integrating Vue Query for SSR, configuring a custom QueryClient, and wiring dehydration/hydration logic into Nuxt app lifecycle hooks. It imports necessary modules, modifies global Vue Query settings with a default staleTime, and conditionally dehydrates or hydrates query state based on server or client execution. Dependencies include '@tanstack/vue-query' and Nuxt 3 plugin/module system. It exports a default Nuxt plugin, expecting this file to be placed in the plugins directory and used automatically if properly configured. Inputs are the Nuxt app context and Vue Query options; outputs are a globally configured Vue Query instance with SSR hydration.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/ssr.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport type {\n  DehydratedState,\n  VueQueryPluginOptions,\n} from '@tanstack/vue-query'\nimport {\n  VueQueryPlugin,\n  QueryClient,\n  hydrate,\n  dehydrate,\n} from '@tanstack/vue-query'\n// Nuxt 3 app aliases\nimport { defineNuxtPlugin, useState } from '#imports'\n\nexport default defineNuxtPlugin((nuxt) => {\n  const vueQueryState = useState<DehydratedState | null>('vue-query')\n\n  // Modify your Vue Query global settings here\n  const queryClient = new QueryClient({\n    defaultOptions: { queries: { staleTime: 5000 } },\n  })\n  const options: VueQueryPluginOptions = { queryClient }\n\n  nuxt.vueApp.use(VueQueryPlugin, options)\n\n  if (import.meta.server) {\n    nuxt.hooks.hook('app:rendered', () => {\n      vueQueryState.value = dehydrate(queryClient)\n    })\n  }\n\n  if (import.meta.client) {\n    hydrate(queryClient, vueQueryState.value)\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Integrating PersistQueryClientProvider with React - TanStack Query - TypeScript/React\nDESCRIPTION: This code demonstrates end-to-end integration of caching persistence in a React application by using PersistQueryClientProvider from @tanstack/react-query-persist-client. Shows setting up a QueryClient with custom gcTime, creating a persister using localStorage, and rendering the provider at the root of the app. Ensures cache restoration/subscription ties into the React lifecycle, avoiding race-conditions and resource leaks.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/persistQueryClient.md#2025-04-23_snippet_7\n\nLANGUAGE: TSX\nCODE:\n```\nimport { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'\nimport { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister'\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      gcTime: 1000 * 60 * 60 * 24, // 24 hours\n    },\n  },\n})\n\nconst persister = createSyncStoragePersister({\n  storage: window.localStorage,\n})\n\nReactDOM.createRoot(rootElement).render(\n  <PersistQueryClientProvider\n    client={queryClient}\n    persistOptions={{ persister }}\n  >\n    <App />\n  </PersistQueryClientProvider>,\n)\n```\n\n----------------------------------------\n\nTITLE: Basic Query Keys in TanStack Query with Vue\nDESCRIPTION: Simple examples of defining query keys for different resources. The first example uses a single string 'todos' for querying a list, while the second uses an array with multiple strings for more specific identification.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-keys.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// A list of todos\ninjectQuery(() => ({ queryKey: ['todos'], ... }))\n\n// Something else, whatever!\ninjectQuery(() => ({ queryKey: ['something', 'special'], ... }))\n```\n\n----------------------------------------\n\nTITLE: Custom Error Type Specification in injectQuery\nDESCRIPTION: Demonstrates how to specify a custom error type (string) as the second type parameter to injectQuery.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-23_snippet_5\n\nLANGUAGE: angular-ts\nCODE:\n```\n@Component({\n  // ...\n  template: `@let error = query.error();`,\n  //                ^? error: string | null\n})\nclass MyComponent {\n  query = injectQuery<Group[], string>(() => ({\n    queryKey: ['groups'],\n    queryFn: fetchGroups,\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Todo List with Optimistic UI in Angular Template\nDESCRIPTION: This Angular component template renders a list of todos and shows a pending item during the addition process. It demonstrates how to integrate mutation state into the UI for optimistic updates.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/optimistic-updates.md#2025-04-23_snippet_1\n\nLANGUAGE: angular-ts\nCODE:\n```\n@Component({\n  template: `\n    @for (todo of todos.data(); track todo.id) {\n      <li>{{ todo.title }}</li>\n    }\n    @if (addTodo.isPending()) {\n      <li style=\"opacity: 0.5\">{{ addTodo.variables() }}</li>\n    }\n  `,\n})\nclass TodosComponent {}\n```\n\n----------------------------------------\n\nTITLE: Prefetching Related Data in useEffect with TanStack Query (TypeScript/TSX)\nDESCRIPTION: Prefetches comments data within a React `useEffect` hook when the main component mounts or its dependencies change. Utilizes `queryClient.prefetchQuery` and relies on TanStack Query and React's hooks. Inputs are the current `queryClient` instance and `id`; no direct outputs except population of the query cache for future use. Should be used only if not relying on Suspense for immediate query resolution.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-23_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nconst queryClient = useQueryClient()\n\nuseEffect(() => {\n  queryClient.prefetchQuery({\n    queryKey: ['article-comments', id],\n    queryFn: getArticleCommentsById,\n  })\n}, [queryClient, id])\n```\n\n----------------------------------------\n\nTITLE: Initializing QueryClientProvider in Svelte\nDESCRIPTION: Initializes a new QueryClient instance and wraps a root-level Svelte component (Example.svelte) with the QueryClientProvider. This setup makes the query client available to all descendant components via Svelte's context API. Requires the '@tanstack/svelte-query' package.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/overview.md#2025-04-23_snippet_0\n\nLANGUAGE: svelte\nCODE:\n```\n<script lang=\"ts\">\n  import { QueryClient, QueryClientProvider } from '@tanstack/svelte-query'\n  import Example from './lib/Example.svelte'\n\n  const queryClient = new QueryClient()\n</script>\n\n<QueryClientProvider client={queryClient}>\n  <Example />\n</QueryClientProvider>\n```\n\n----------------------------------------\n\nTITLE: Serial Suspense Queries\nDESCRIPTION: Example showing how multiple suspense queries can create waterfalls and the correct way to handle multiple suspense queries using useSuspenseQueries.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/request-waterfalls.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction App () {\n  // The following queries will execute in serial, causing separate roundtrips to the server:\n  const usersQuery = useSuspenseQuery({ queryKey: ['users'], queryFn: fetchUsers })\n  const teamsQuery = useSuspenseQuery({ queryKey: ['teams'], queryFn: fetchTeams })\n  const projectsQuery = useSuspenseQuery({ queryKey: ['projects'], queryFn: fetchProjects })\n\n  // Note that since the queries above suspend rendering, no data\n  // gets rendered until all of the queries finished\n  ...\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst [usersQuery, teamsQuery, projectsQuery] = useSuspenseQueries({\n  queries: [\n    { queryKey: ['users'], queryFn: fetchUsers },\n    { queryKey: ['teams'], queryFn: fetchTeams },\n    { queryKey: ['projects'], queryFn: fetchProjects },\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Initial Query Data Setup\nDESCRIPTION: Basic example of setting up a query with initial data that will be shown immediately and then refetched.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nresult = injectQuery(() => ({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n}))\n```\n\n----------------------------------------\n\nTITLE: Serializing Data on the Server for Prefetched Queries - React Query - TypeScript\nDESCRIPTION: Demonstrates how to serialize query data on the server during prefetch by passing a function to queryFn that serializes the result (e.g., with a custom serialize function). This pattern is required when caching complex objects or types, and ensures that the client receives data in the expected format. Dependencies include @tanstack/react-query, getQueryClient, serialize, and a Posts component. Key parameters are queryKey, queryFn (which serializes), and the dehydrate function.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// app/posts/page.tsx\nimport {\n  dehydrate,\n  HydrationBoundary,\n  QueryClient,\n} from '@tanstack/react-query'\nimport { getQueryClient } from './get-query-client'\nimport { serialize } from './transformer'\nimport Posts from './posts'\n\nexport default function PostsPage() {\n  const queryClient = getQueryClient()\n\n  // look ma, no await\n  queryClient.prefetchQuery({\n    queryKey: ['posts'],\n    queryFn: () => getPosts().then(serialize), // <-- serialize the data on the server\n  })\n\n  return (\n    <HydrationBoundary state={dehydrate(queryClient)}>\n      <Posts />\n    </HydrationBoundary>\n  )\n}\n\n```\n\n----------------------------------------\n\nTITLE: Getting Mutation Data by Mutation Key using useMutationState (TSX)\nDESCRIPTION: This example shows how to define a mutation using `useMutation` with a specific `mutationKey`. It then uses `useMutationState` with a matching `mutationKey` in the `filters` option to retrieve the `data` (results) from the state of all mutations associated with that key. The `select` function extracts the `data` property from the mutation state. Depends on `@tanstack/react-query` and likely an HTTP client like `axios` for the `mutationFn`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useMutationState.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport { useMutation, useMutationState } from '@tanstack/react-query'\n\nconst mutationKey = ['posts']\n\n// Some mutation that we want to get the state for\nconst mutation = useMutation({\n  mutationKey,\n  mutationFn: (newPost) => {\n    return axios.post('/posts', newPost)\n  },\n})\n\nconst data = useMutationState({\n  // this mutation key needs to match the mutation key of the given mutation (see above)\n  filters: { mutationKey },\n  select: (mutation) => mutation.state.data,\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Event-Based Infinite Query Implementation\nDESCRIPTION: Shows how to implement infinite queries triggered by events like scroll or click, with debouncing to prevent multiple simultaneous requests.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/infinite-queries.md#2025-04-23_snippet_2\n\nLANGUAGE: angular-ts\nCODE:\n```\n@Component({\n  template: ` <list-component (endReached)=\"fetchNextPage()\" /> `,\n})\nexport class Example {\n  query = injectInfiniteQuery(() => ({\n    queryKey: ['projects'],\n    queryFn: async ({ pageParam }) => {\n      return lastValueFrom(this.projectsService.getProjects(pageParam))\n    },\n  }))\n\n  fetchNextPage() {\n    // Do nothing if already fetching\n    if (this.query.isFetching()) return\n    this.query.fetchNextPage()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating useQuery with SolidJS Suspense\nDESCRIPTION: Shows how `@tanstack/solid-query` integrates with SolidJS's built-in `<Suspense>` component for handling loading states declaratively. Accessing the `query.data` property within a `<Suspense>` boundary automatically triggers the specified `fallback` UI while the asynchronous query is pending. Accessing the data outside the `<Suspense>` boundary will not trigger the fallback, demonstrating the importance of placement for Suspense integration.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/quick-start.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { For, Suspense } from 'solid-js'\n\nfunction Example() {\n  const query = useQuery(() => ({\n    queryKey: ['todos'],\n    queryFn: fetchTodos,\n  }))\n  return (\n    <div>\n      {/* ‚úÖ Will trigger loading fallback, data accessed in a suspense boundary. */}\n      <Suspense fallback={'Loading...'}>\n        <For each={query.data}>{(todo) => <div>{todo.title}</div>}</For>\n      </Suspense>\n      {/* ‚ùå Will not trigger loading fallback, data not accessed in a suspense boundary. */}\n      <For each={query.data}>{(todo) => <div>{todo.title}</div>}</For>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Installing React Query via PNPM (Bash)\nDESCRIPTION: Installs the `@tanstack/react-query` package using the Performant NPM (PNPM). This command downloads and adds the library to your project's dependencies, often optimizing disk space.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/installation.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @tanstack/react-query\n```\n\n----------------------------------------\n\nTITLE: Accessing Mutation State Globally in Angular with TanStack Query\nDESCRIPTION: This snippet shows how to set up a mutation with a specific key and access its state globally using injectMutationState. It's useful for sharing mutation state across components.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/optimistic-updates.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// somewhere in your app\naddTodo = injectMutation(() => ({\n  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),\n  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),\n  mutationKey: ['addTodo'],\n}))\n\n// access variables somewhere else\n\nmutationState = injectMutationState<string>(() => ({\n  filters: { mutationKey: ['addTodo'], status: 'pending' },\n  select: (mutation) => mutation.state.variables,\n}))\n```\n\n----------------------------------------\n\nTITLE: Client-Side Suspense Query Usage With Custom Serialized Data - React Query - TypeScript\nDESCRIPTION: Shows a Client Component consuming posts data using useSuspenseQuery, working in conjunction with server-side serialization. This enables seamless SSR hydration even with non-JSON data. Same requirements and parameters as the standard example, but used when data has been serialized/deserialized across the server/client boundary.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n// app/posts/posts.tsx\n'use client'\n\nexport default function Posts() {\n  const { data } = useSuspenseQuery({ queryKey: ['posts'], queryFn: getPosts })\n\n  // ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Codemod Commands for Migration\nDESCRIPTION: Commands to run the migration codemod for JavaScript/JSX and TypeScript/TSX files.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpx jscodeshift@latest ./path/to/src/ \\\n  --extensions=js,jsx \\\n  --transform=./node_modules/@tanstack/react-query/build/codemods/src/v5/remove-overloads/remove-overloads.cjs\n```\n\n----------------------------------------\n\nTITLE: Prefetching Query Data with Default QueryFn\nDESCRIPTION: Shows how to prefetch query data using only a query key when a default queryFn is configured.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nawait queryClient.prefetchQuery({ queryKey })\n```\n\n----------------------------------------\n\nTITLE: Configuring QueryClient with createPersister for Vue Query\nDESCRIPTION: Example of creating a QueryClient with persister configuration in Vue Query. This sets up persistence with localStorage and configures garbage collection time and maximum age for cached queries.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/plugins/createPersister.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { QueryClient } from '@tanstack/vue-query'\nimport { experimental_createPersister } from '@tanstack/query-persist-client-core'\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      gcTime: 1000 * 30, // 30 seconds\n      persister: experimental_createPersister({\n        storage: localStorage,\n        maxAge: 1000 * 60 * 60 * 12, // 12 hours\n      }),\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Mutation Lifecycle Callbacks Implementation\nDESCRIPTION: Implementation of mutation lifecycle callbacks including onMutate, onError, onSuccess, and onSettled. Demonstrates how to handle different phases of the mutation process with context passing between callbacks.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-23_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nmutation = injectMutation(() => ({\n  mutationFn: addTodo,\n  onMutate: (variables) => {\n    // A mutation is about to happen!\n\n    // Optionally return a context containing data to use when for example rolling back\n    return { id: 1 }\n  },\n  onError: (error, variables, context) => {\n    // An error happened!\n    console.log(`rolling back optimistic update with id ${context.id}`)\n  },\n  onSuccess: (data, variables, context) => {\n    // Boom baby!\n  },\n  onSettled: (data, error, variables, context) => {\n    // Error or success... doesn't matter!\n  },\n}))\n```\n\n----------------------------------------\n\nTITLE: Implementing Query Loading Tracker in Angular using injectIsFetching\nDESCRIPTION: A function that returns a signal tracking the number of active loading/fetching queries in an Angular application. Takes optional query filters and an Angular injector as parameters. Used for implementing application-wide loading indicators.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectisfetching.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction injectIsFetching(filters?, injector?): Signal<number>\n```\n\n----------------------------------------\n\nTITLE: Single Todo Optimistic Update\nDESCRIPTION: Shows how to implement optimistic updates for a single todo item with cache manipulation and rollback handling.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/optimistic-updates.md#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nuseMutation({\n  mutationFn: updateTodo,\n  // When mutate is called:\n  onMutate: async (newTodo) => {\n    // Cancel any outgoing refetches\n    // (so they don't overwrite our optimistic update)\n    await queryClient.cancelQueries({ queryKey: ['todos', newTodo.id] })\n\n    // Snapshot the previous value\n    const previousTodo = queryClient.getQueryData(['todos', newTodo.id])\n\n    // Optimistically update to the new value\n    queryClient.setQueryData(['todos', newTodo.id], newTodo)\n\n    // Return a context with the previous and new todo\n    return { previousTodo, newTodo }\n  },\n  // If the mutation fails, use the context we returned above\n  onError: (err, newTodo, context) => {\n    queryClient.setQueryData(\n      ['todos', context.newTodo.id],\n      context.previousTodo,\n    )\n  },\n  // Always refetch after error or success:\n  onSettled: (newTodo) =>\n    queryClient.invalidateQueries({ queryKey: ['todos', newTodo.id] }),\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Per-Query Window Focus Refetching\nDESCRIPTION: Demonstrates how to disable window focus refetching for a specific query using the refetchOnWindowFocus option in useQuery hook.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/window-focus-refetching.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nuseQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodos,\n  refetchOnWindowFocus: false,\n})\n```\n\n----------------------------------------\n\nTITLE: Checking Fetching Status with TanStack Query\nDESCRIPTION: Shows how to check if any queries are currently fetching using queryClient.isFetching.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_19\n\nLANGUAGE: tsx\nCODE:\n```\nif (queryClient.isFetching()) {\n  console.log('At least one query is fetching!')\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing React Query Devtools in Production\nDESCRIPTION: Example of how to lazy load React Query Devtools in a production environment, including a toggle function.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/devtools.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport * as React from 'react'\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools'\nimport { Example } from './Example'\n\nconst queryClient = new QueryClient()\n\nconst ReactQueryDevtoolsProduction = React.lazy(() =>\n  import('@tanstack/react-query-devtools/build/modern/production.js').then(\n    (d) => ({\n      default: d.ReactQueryDevtools,\n    }),\n  ),\n)\n\nfunction App() {\n  const [showDevtools, setShowDevtools] = React.useState(false)\n\n  React.useEffect(() => {\n    // @ts-expect-error\n    window.toggleDevtools = () => setShowDevtools((old) => !old)\n  }, [])\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Example />\n      <ReactQueryDevtools initialIsOpen />\n      {showDevtools && (\n        <React.Suspense fallback={null}>\n          <ReactQueryDevtoolsProduction />\n        </React.Suspense>\n      )}\n    </QueryClientProvider>\n  )\n}\n\nexport default App\n```\n\n----------------------------------------\n\nTITLE: Mutation State Reset Implementation\nDESCRIPTION: Shows how to implement state reset functionality in a mutation to clear error or data states using the reset function.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst CreateTodo = () => {\n  const [title, setTitle] = useState('')\n  const mutation = useMutation({ mutationFn: createTodo })\n\n  const onCreateTodo = (e) => {\n    e.preventDefault()\n    mutation.mutate({ title })\n  }\n\n  return (\n    <form onSubmit={onCreateTodo}>\n      {mutation.error && (\n        <h5 onClick={() => mutation.reset()}>{mutation.error}</h5>\n      )}\n      <input\n        type=\"text\"\n        value={title}\n        onChange={(e) => setTitle(e.target.value)}\n      />\n      <br />\n      <button type=\"submit\">Create Todo</button>\n    </form>\n  )\n```\n\n----------------------------------------\n\nTITLE: Creating Client Component with Query Hooks\nDESCRIPTION: Implements a client component that uses prefetched data through React Query hooks\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\n\nexport default function Posts() {\n  const { data } = useQuery({\n    queryKey: ['posts'],\n    queryFn: () => getPosts(),\n  })\n\n  const { data: commentsData } = useQuery({\n    queryKey: ['posts-comments'],\n    queryFn: getComments,\n  })\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing QueryClient and Provider in Next.js Application (_app.tsx) - TypeScript\nDESCRIPTION: Sets up a global React QueryClient with sensible defaults, using React useState for singleton instantiation, in a Next.js custom _app.tsx. Wraps all rendered pages in a QueryClientProvider to enable SSR, caching, and hydration throughout the app. Requires @tanstack/react-query and React, with the queryClient providing defaultOptions such as staleTime for optimized client/server transitions.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n// _app.tsx\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\n\nexport default function MyApp({ Component, pageProps }) {\n  const [queryClient] = React.useState(\n    () =>\n      new QueryClient({\n        defaultOptions: {\n          queries: {\n            // With SSR, we usually want to set some default staleTime\n            // above 0 to avoid refetching immediately on the client\n            staleTime: 60 * 1000,\n          },\n        },\n      }),\n  )\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Component {...pageProps} />\n    </QueryClientProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Simplifying Hydration by Moving HydrationBoundary to App Provider (_app.tsx) - TypeScript\nDESCRIPTION: Eliminates route-level HydrationBoundary boilerplate by wrapping the component hierarchy with HydrationBoundary in the custom Next.js _app.tsx. This ensures all pages receive hydrated state automatically from pageProps, making route code more concise. Depends on @tanstack/react-query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-23_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\n// _app.tsx\nimport {\n  HydrationBoundary,\n  QueryClient,\n  QueryClientProvider,\n} from '@tanstack/react-query'\n\nexport default function MyApp({ Component, pageProps }) {\n  const [queryClient] = React.useState(() => new QueryClient())\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <HydrationBoundary state={pageProps.dehydratedState}>\n        <Component {...pageProps} />\n      </HydrationBoundary>\n    </QueryClientProvider>\n  )\n}\n\n// pages/posts.tsx\n// Remove PostsRoute with the HydrationBoundary and instead export Posts directly:\nexport default function Posts() { ... }\n```\n\n----------------------------------------\n\nTITLE: Cache-based Optimistic Updates for Todo List\nDESCRIPTION: Implements optimistic updates by directly manipulating the query cache, including rollback functionality on error.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/optimistic-updates.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nconst queryClient = useQueryClient()\n\nuseMutation({\n  mutationFn: updateTodo,\n  // When mutate is called:\n  onMutate: async (newTodo) => {\n    // Cancel any outgoing refetches\n    // (so they don't overwrite our optimistic update)\n    await queryClient.cancelQueries({ queryKey: ['todos'] })\n\n    // Snapshot the previous value\n    const previousTodos = queryClient.getQueryData(['todos'])\n\n    // Optimistically update to the new value\n    queryClient.setQueryData(['todos'], (old) => [...old, newTodo])\n\n    // Return a context object with the snapshotted value\n    return { previousTodos }\n  },\n  // If the mutation fails,\n  // use the context returned from onMutate to roll back\n  onError: (err, newTodo, context) => {\n    queryClient.setQueryData(['todos'], context.previousTodos)\n  },\n  // Always refetch after error or success:\n  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Vue Query State Sync with vite-ssr (JavaScript)\nDESCRIPTION: Illustrates integrating Vue Query with vite-ssr for SSR hydration and dehydration. The entry main.js file creates a new QueryClient for each SSR request, attaches dehydrated state to the initialState object for SSR, and hydrates client state on the browser before mounting. Includes using app.use to install VueQueryPlugin. Dependencies are '@tanstack/vue-query', 'vite-ssr/vue', and the routing system. No input parameters; expects App and initialState provided by viteSSR. Outputs include application state with hydrated queries, ready for seamless SSR-to-client transition.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/ssr.md#2025-04-23_snippet_5\n\nLANGUAGE: js\nCODE:\n```\n// main.js (entry point)\nimport App from './App.vue'\nimport viteSSR from 'vite-ssr/vue'\nimport {\n  QueryClient,\n  VueQueryPlugin,\n  hydrate,\n  dehydrate,\n} from '@tanstack/vue-query'\n\nexport default viteSSR(App, { routes: [] }, ({ app, initialState }) => {\n  // -- This is Vite SSR main hook, which is called once per request\n\n  // Create a fresh VueQuery client\n  const queryClient = new QueryClient()\n\n  // Sync initialState with the client state\n  if (import.meta.env.SSR) {\n    // Indicate how to access and serialize VueQuery state during SSR\n    initialState.vueQueryState = { toJSON: () => dehydrate(queryClient) }\n  } else {\n    // Reuse the existing state in the browser\n    hydrate(queryClient, initialState.vueQueryState)\n  }\n\n  // Mount and provide the client to the app components\n  app.use(VueQueryPlugin, { queryClient })\n})\n```\n\n----------------------------------------\n\nTITLE: Invalidating Queries with Specific Variables in TypeScript\nDESCRIPTION: Shows how to invalidate queries matching a specific, more detailed query key, including variables. Passing `queryKey: ['todos', { type: 'done' }]` will only invalidate queries that match this exact key structure, leaving other related queries (like the base `['todos']` query) unaffected.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-invalidation.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nqueryClient.invalidateQueries({\n  queryKey: ['todos', { type: 'done' }],\n})\n\n// The query below will be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { type: 'done' }],\n  queryFn: fetchTodoList,\n})\n\n// However, the following query below will NOT be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n})\n```\n\n----------------------------------------\n\nTITLE: Hydrating Query Client State in React Query\nDESCRIPTION: Adds previously dehydrated state back into a QueryClient cache. Takes a QueryClient instance, dehydrated state, and optional configuration options.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/hydration.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { hydrate } from '@tanstack/react-query'\n\nhydrate(queryClient, dehydratedState, options)\n```\n\n----------------------------------------\n\nTITLE: Fetching Infinite Query Data with Pages Access\nDESCRIPTION: Shows how to use queryClient.fetchInfiniteQuery to fetch and cache infinite query data with access to the pages array.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\ntry {\n  const data = await queryClient.fetchInfiniteQuery({ queryKey, queryFn })\n  console.log(data.pages)\n} catch (error) {\n  console.log(error)\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified Query Implementation\nDESCRIPTION: Demonstrates a minimal query implementation without imports or class declaration.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/queries.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nresult = injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchTodoList }))\n```\n\n----------------------------------------\n\nTITLE: Query Cancellation with Modern GraphQL Client in TanStack Query\nDESCRIPTION: Demonstrates query cancellation implementation for modern GraphQL client versions that support AbortSignal in the request method.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-cancellation.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nconst client = new GraphQLClient(endpoint)\n\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: ({ signal }) => {\n    client.request({ document: query, signal })\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Disabling Queries with Enabled Option in Angular TanStack Query\nDESCRIPTION: This snippet demonstrates how to disable a query by default using the 'enabled: false' option in the injectQuery configuration. The query can be manually triggered using the refetch method.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/disabling-queries.md#2025-04-23_snippet_0\n\nLANGUAGE: angular-ts\nCODE:\n```\n@Component({\n  selector: 'todos',\n  template: `<div>\n    <button (click)=\"query.refetch()\">Fetch Todos</button>\n\n    @if (query.data()) {\n      <ul>\n        @for (todo of query.data(); track todo.id) {\n          <li>{{ todo.title }}</li>\n        }\n      </ul>\n    } @else {\n      @if (query.isError()) {\n        <span>Error: {{ query.error().message }}</span>\n      } @else if (query.isLoading()) {\n        <span>Loading...</span>\n      } @else if (!query.isLoading() && !query.isError()) {\n        <span>Not ready ...</span>\n      }\n    }\n\n    <div>{{ query.isLoading() ? 'Fetching...' : '' }}</div>\n  </div>`,\n})\nexport class TodosComponent {\n  query = injectQuery(() => ({\n    queryKey: ['todos'],\n    queryFn: fetchTodoList,\n    enabled: false,\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Mutation Result Types with Svelte Query in TypeScript\nDESCRIPTION: This snippet defines a TypeScript type alias `CreateMutationResult` to represent the result of a mutation created using TanStack's Svelte Query. It wraps the base mutation result in a Svelte `Readable` store for reactivity, allowing developers to reactively observe mutation states. The type parameters enable customization for response data, error type, input variables, and context type. It depends on Svelte's store and the core Svelte Query mutation types. Typical usage involves returning this type from functions handling remote mutations. Inputs are specified via generics, and the output is a readable store conforming to those shapes. It requires importing `Readable` and Svelte Query's types.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/createmutationresult.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype CreateMutationResult<TData, TError, TVariables, TContext>: Readable<CreateBaseMutationResult<TData, TError, TVariables, TContext>>;\n```\n\n----------------------------------------\n\nTITLE: Using Mutation Filters in TanStack Query\nDESCRIPTION: Examples of using MutationFilters to check mutation status and filter mutations based on mutation keys or predicate functions.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/filters.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// Get the number of all fetching mutations\nawait queryClient.isMutating()\n\n// Filter mutations by mutationKey\nawait queryClient.isMutating({ mutationKey: ['post'] })\n\n// Filter mutations using a predicate function\nawait queryClient.isMutating({\n  predicate: (mutation) => mutation.state.variables?.id === 1,\n})\n```\n\n----------------------------------------\n\nTITLE: Retrieving Multiple Queries' Data with Filters\nDESCRIPTION: Demonstrates how to get cached data for multiple queries that match specified filters.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nconst data = queryClient.getQueriesData(filters)\n```\n\n----------------------------------------\n\nTITLE: Invoking `usePrefetchQuery` Hook in TypeScript/React\nDESCRIPTION: This snippet shows the basic invocation syntax for the `usePrefetchQuery` hook in a TypeScript/React application using TanStack Query. It takes an options object (containing at least `queryKey` and potentially `queryFn`) to initiate a data prefetch, typically used before a component that utilizes `useSuspenseQuery`. The hook itself does not return any value.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/usePrefetchQuery.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nusePrefetchQuery(options)\n```\n```\n\n----------------------------------------\n\nTITLE: Retrieving Cached Query Data Synchronously\nDESCRIPTION: Shows how to synchronously get existing cached query data using queryClient.getQueryData with a query key.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nconst data = queryClient.getQueryData(queryKey)\n```\n\n----------------------------------------\n\nTITLE: Creating an IndexedDB Persister for TanStack Query in TSX\nDESCRIPTION: This function creates a persister for TanStack Query using IndexedDB. It implements the Persister interface with methods to persist, restore, and remove client data. IndexedDB offers advantages over Web Storage API including better performance, storage over 5MB, and native support for JavaScript types like Date and File objects.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/persistQueryClient.md#2025-04-23_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nimport { get, set, del } from 'idb-keyval'\nimport {\n  PersistedClient,\n  Persister,\n} from '@tanstack/react-query-persist-client'\n\n/**\n * Creates an Indexed DB persister\n * @see https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API\n */\nexport function createIDBPersister(idbValidKey: IDBValidKey = 'reactQuery') {\n  return {\n    persistClient: async (client: PersistedClient) => {\n      await set(idbValidKey, client)\n    },\n    restoreClient: async () => {\n      return await get<PersistedClient>(idbValidKey)\n    },\n    removeClient: async () => {\n      await del(idbValidKey)\n    },\n  } satisfies Persister\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Query Hook with Defined Initial Data using Svelte Query (TypeScript)\nDESCRIPTION: This snippet defines a createQuery function overload intended for use when an initial value for the data is always defined. It relies on generic parameters for query data, error, final data, and query key. Dependencies include types like StoreOrVal, DefinedInitialDataOptions, QueryClient, and DefinedCreateQueryResult from Svelte Query. The options parameter expects a StoreOrVal-wrapped DefinedInitialDataOptions object, and the function returns a DefinedCreateQueryResult. Optional queryClient can be supplied to control the caching context. Inputs must comply with the defined types; output is a strongly-typed query result where data is never undefined.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/createquery.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction createQuery<TQueryFnData, TError, TData, TQueryKey>(\n  options,\n  queryClient?,\n): DefinedCreateQueryResult<TData, TError>\n```\n\n----------------------------------------\n\nTITLE: Reversing Infinite Query Pages Order\nDESCRIPTION: Example of using the select option to reverse the order of pages in the query results\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nuseInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  select: (data) => ({\n    pages: [...data.pages].reverse(),\n    pageParams: [...data.pageParams].reverse(),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Prefetching Infinite Queries with usePrefetchInfiniteQuery in TanStack Query (TypeScript/TSX)\nDESCRIPTION: Demonstrates the basic usage of the usePrefetchInfiniteQuery hook from TanStack Query in a React/TypeScript environment. This snippet shows the hook signature and indicates that an options object should be provided, including required fields such as queryKey, queryFn (unless there is a default), initialPageParam, and getNextPageParam. The hook is intended to initiate a prefetch of infinite query data during render, primarily for scenarios involving suspense and pre-render data requirements. No values are returned from this hook; its sole purpose is to trigger prefetching.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/usePrefetchInfiniteQuery.md#2025-04-23_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nusePrefetchInfiniteQuery(options)\n```\n\n----------------------------------------\n\nTITLE: Implementing Mutation State Tracking in Angular with TypeScript\nDESCRIPTION: Function signature for injectMutationState that creates a signal to track the state of all mutations. Takes a mutation state options function and optional Angular injector options, returning a signal array of mutation states.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectmutationstate.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction injectMutationState<TResult>(\n  mutationStateOptionsFn,\n  options?,\n): Signal<TResult[]>\n```\n\n----------------------------------------\n\nTITLE: Canceling Queries with TanStack Query\nDESCRIPTION: Demonstrates how to cancel ongoing queries using queryClient.cancelQueries.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\nawait queryClient.cancelQueries({ queryKey: ['posts'], exact: true })\n```\n\n----------------------------------------\n\nTITLE: Using setQueryDefaults for global query configuration in tests\nDESCRIPTION: Demonstrates how to set default query options specifically for tests using the setQueryDefaults method on the QueryClient.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/testing.md#2025-04-23_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      gcTime: Infinity,\n    },\n  },\n})\n\n// Set defaults for specific queries\nqueryClient.setQueryDefaults(['posts'], { queryFn: fetchPosts })\n```\n\n----------------------------------------\n\nTITLE: Setting up React Query Streaming Providers in Next.js (TypeScript/TSX)\nDESCRIPTION: This TSX snippet demonstrates how to configure providers for TanStack Query's experimental streaming feature in a Next.js application. It defines functions to create and manage `QueryClient` instances for both server and browser environments, ensuring a singleton client on the browser side. The `Providers` component wraps the application children with `QueryClientProvider` and the experimental `ReactQueryStreamedHydration` component to enable data fetching via `useSuspenseQuery` in Client Components to be streamed from the server.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-23_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\n// app/providers.tsx\n'use client'\n\nimport {\n  isServer,\n  QueryClient,\n  QueryClientProvider,\n} from '@tanstack/react-query'\nimport * as React from 'react'\nimport { ReactQueryStreamedHydration } from '@tanstack/react-query-next-experimental'\n\nfunction makeQueryClient() {\n  return new QueryClient({\n    defaultOptions: {\n      queries: {\n        // With SSR, we usually want to set some default staleTime\n        // above 0 to avoid refetching immediately on the client\n        staleTime: 60 * 1000,\n      },\n    },\n  })\n}\n\nlet browserQueryClient: QueryClient | undefined = undefined\n\nfunction getQueryClient() {\n  if (isServer) {\n    // Server: always make a new query client\n    return makeQueryClient()\n  } else {\n    // Browser: make a new query client if we don't already have one\n    // This is very important, so we don't re-make a new client if React\n    // suspends during the initial render. This may not be needed if we\n    // have a suspense boundary BELOW the creation of the query client\n    if (!browserQueryClient) browserQueryClient = makeQueryClient()\n    return browserQueryClient\n  }\n}\n\nexport function Providers(props: { children: React.ReactNode }) {\n  // NOTE: Avoid useState when initializing the query client if you don't\n  //       have a suspense boundary between this and the code that may\n  //       suspend because React will throw away the client on the initial\n  //       render if it suspends and there is no boundary\n  const queryClient = getQueryClient()\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <ReactQueryStreamedHydration>\n        {props.children}\n      </ReactQueryStreamedHydration>\n    </QueryClientProvider>\n  )\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Mutation Retries\nDESCRIPTION: Simple example showing how to configure automatic retries for a mutation. This sets up a mutation that will automatically retry up to 3 times if it fails.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-23_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nmutation = injectMutation(() => ({\n  mutationFn: addTodo,\n  retry: 3,\n}))\n```\n\n----------------------------------------\n\nTITLE: Using Query Client Hook in Svelte Query (TypeScript)\nDESCRIPTION: Defines the useQueryClient function which returns a QueryClient instance, optionally accepting an existing QueryClient as an argument. This hook is intended for use within Svelte components that integrate with the TanStack Query library, allowing components to access or override the current QueryClient. Dependencies include TanStack Query's Svelte adaptation. The primary parameter is queryClient (optional) which, if provided, is used as the client; otherwise, the current context client is returned. The function returns a QueryClient object that acts as the manager for server state caching and fetching. This hook must be used within the relevant provider context and requires proper installation of TanStack Svelte Query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/usequeryclient.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction useQueryClient(queryClient?): QueryClient\n```\n\n----------------------------------------\n\nTITLE: PersistQueryClientOptions Interface Definition - TanStack Query - TypeScript\nDESCRIPTION: This snippet defines the full TypeScript interface for configuring persistent cache operations using PersistQueryClientOptions. Documents available properties: queryClient, persister, maxAge, buster, hydrateOptions, dehydrateOptions, including JSDoc-style comments for each field. Used to type options for the various persistence APIs.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/persistQueryClient.md#2025-04-23_snippet_6\n\nLANGUAGE: TSX\nCODE:\n```\ninterface PersistQueryClientOptions {\n  /** The QueryClient to persist */\n  queryClient: QueryClient\n  /** The Persister interface for storing and restoring the cache\n   * to/from a persisted location */\n  persister: Persister\n  /** The max-allowed age of the cache in milliseconds.\n   * If a persisted cache is found that is older than this\n   * time, it will be **silently** discarded\n   * (defaults to 24 hours) */\n  maxAge?: number\n  /** A unique string that can be used to forcefully\n   * invalidate existing caches if they do not share the same buster string */\n  buster?: string\n  /** The options passed to the hydrate function\n   * Not used on `persistQueryClientSave` or `persistQueryClientSubscribe` */\n  hydrateOptions?: HydrateOptions\n  /** The options passed to the dehydrate function\n   * Not used on `persistQueryClientRestore` */\n  dehydrateOptions?: DehydrateOptions\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Custom React Query Hook\nDESCRIPTION: Example of a simple custom hook using React Query to fetch data.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport function useCustomHook() {\n  return useQuery({ queryKey: ['customHook'], queryFn: () => 'Hello' })\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Type Inference with injectQuery in Angular\nDESCRIPTION: Demonstrates how TypeScript infers the return type of a query function automatically. The query returns a number, which is correctly inferred in the template.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-23_snippet_0\n\nLANGUAGE: angular-ts\nCODE:\n```\n@Component({\n  // ...\n  template: `@let data = query.data();`,\n  //               ^? data: number | undefined\n})\nclass MyComponent {\n  query = injectQuery(() => ({\n    queryKey: ['test'],\n    queryFn: () => Promise.resolve(5),\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Using Typed Fetchers for Queries - Solid Query - TypeScript/TSX\nDESCRIPTION: Demonstrates improved type inference by defining a typed fetch function (fetchGroups) that returns a Promise of Group[]. This function is used as queryFn in useQuery, resulting in a query result whose data property has type Group[] or undefined. Requires axios for HTTP requests and @tanstack/solid-query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/typescript.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst fetchGroups = (): Promise<Group[]> =>\n  axios.get('/groups').then((response) => response.data)\n\nconst query = useQuery(() => ({\n  queryKey: ['groups'],\n  queryFn: fetchGroups,\n}))\n\nquery.data\n//    ^? (property) data: Group[] | undefined\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Server Component Data Prefetching\nDESCRIPTION: Demonstrates how to prefetch data in a Server Component and pass it through hydration boundary\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  dehydrate,\n  HydrationBoundary,\n  QueryClient,\n} from '@tanstack/react-query'\nimport Posts from './posts'\n\nexport default async function PostsPage() {\n  const queryClient = new QueryClient()\n\n  await queryClient.prefetchQuery({\n    queryKey: ['posts'],\n    queryFn: getPosts,\n  })\n\n  return (\n    <HydrationBoundary state={dehydrate(queryClient)}>\n      <Posts />\n    </HydrationBoundary>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Query States in Vue Component using Boolean Flags\nDESCRIPTION: This Vue Single File Component demonstrates fetching data using `useQuery` and handling different states (pending, error, success) using destructured boolean flags (`isPending`, `isError`). The template conditionally renders content based on these flags, displaying a loading message, an error message, or the fetched todo list.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/queries.md#2025-04-23_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { useQuery } from '@tanstack/vue-query'\n\nconst { isPending, isError, data, error } = useQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n})\n</script>\n\n<template>\n  <span v-if=\"isPending\">Loading...</span>\n  <span v-else-if=\"isError\">Error: {{ error.message }}</span>\n  <!-- We can assume by this point that `isSuccess === true` -->\n  <ul v-else-if=\"data\">\n    <li v-for=\"todo in data\" :key=\"todo.id\">{{ todo.title }}</li>\n  </ul>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Prefix Query Matching for Invalidation in TypeScript\nDESCRIPTION: Illustrates how prefix matching works with `invalidateQueries`. By passing `{ queryKey: ['todos'] }`, it invalidates all queries whose keys start with `['todos']`, regardless of subsequent elements in the key array (like variables or pagination info). This requires access to the `queryClient` instance, typically obtained via the `useQueryClient` hook from `@tanstack/react-query`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-invalidation.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQuery, useQueryClient } from '@tanstack/react-query'\n\n// Get QueryClient from the context\nconst queryClient = useQueryClient()\n\nqueryClient.invalidateQueries({ queryKey: ['todos'] })\n\n// Both queries below will be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n})\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { page: 1 }],\n  queryFn: fetchTodoList,\n})\n```\n\n----------------------------------------\n\nTITLE: Query Invalidation After Successful Mutation\nDESCRIPTION: Example demonstrating how to invalidate multiple query keys after a successful mutation using queryClient.invalidateQueries(). This pattern ensures that related queries are refreshed when data changes.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/invalidations-from-mutations.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\n\nconst queryClient = useQueryClient()\n\n// When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key\nconst mutation = useMutation({\n  mutationFn: addTodo,\n  onSuccess: () => {\n    queryClient.invalidateQueries({ queryKey: ['todos'] })\n    queryClient.invalidateQueries({ queryKey: ['reminders'] })\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Creating useRefreshOnFocus Hook\nDESCRIPTION: Custom hook implementation that handles query refetching when a React Native screen comes into focus, while avoiding unnecessary initial fetch.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/react-native.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react'\nimport { useFocusEffect } from '@react-navigation/native'\n\nexport function useRefreshOnFocus<T>(refetch: () => Promise<T>) {\n  const firstTimeRef = React.useRef(true)\n\n  useFocusEffect(\n    React.useCallback(() => {\n      if (firstTimeRef.current) {\n        firstTimeRef.current = false\n        return\n      }\n\n      refetch()\n    }, [refetch]),\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Data Fetching with useQuery in Solid Query (TypeScript/TSX)\nDESCRIPTION: This snippet provides a practical example of using the useQuery primitive to fetch a list of todos from an API endpoint, handling error, loading, and success UI states. The example requires @tanstack/solid-query and relies on standard SolidJS control flow components (Show, For). The queryKey 'todos' identifies the cache entry, and the queryFn asynchronously fetches and parses the data. Returns include tracked query state fields; key dependency is the remote '/api/todos' endpoint.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/reference/useQuery.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQuery } from '@tanstack/solid-query'\n\nfunction App() {\n  const todos = useQuery(() => ({\n    queryKey: 'todos',\n    queryFn: async () => {\n      const response = await fetch('/api/todos')\n      if (!response.ok) {\n        throw new Error('Failed to fetch todos')\n      }\n      return response.json()\n    },\n  }))\n\n  return (\n    <div>\n      <Show when={todos.isError}>\n        <div>Error: {todos.error.message}</div>\n      </Show>\n      <Show when={todos.isLoading}>\n        <div>Loading...</div>\n      </Show>\n      <Show when={todos.isSuccess}>\n        <div>\n          <div>Todos:</div>\n          <ul>\n            <For each={todos.data}>{(todo) => <li>{todo.title}</li>}</For>\n          </ul>\n        </div>\n      </Show>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Prefetching Standard Queries with TanStack Query in TypeScript\nDESCRIPTION: This snippet demonstrates how to prefetch data for a standard query using `queryClient.prefetchQuery`. It fetches data associated with the 'todos' query key using the `fetchTodos` function and stores the result in the cache. The function ensures data isn't refetched if fresh data already exists, respects the `staleTime` if provided, and the prefetched data is subject to garbage collection based on `gcTime` if no active `useQuery` hooks are mounted for it.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/prefetching.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst prefetchTodos = async () => {\n  // The results of this query will be cached like a normal query\n  await queryClient.prefetchQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodos,\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Inferring Query Result Types with useQuery - Solid Query - TypeScript/TSX\nDESCRIPTION: Demonstrates the use of the useQuery hook from @tanstack/solid-query to fetch data (the number 5) with automatic type inference. No explicit type parameter is necessary as the returned type is inferred from the query function. Requires @tanstack/solid-query library and at least TypeScript v4.7. The query returns a result with data of type number or undefined.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/typescript.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQuery } from '@tanstack/solid-query'\n\nconst query = useQuery(() => ({\n  queryKey: ['number'],\n  queryFn: () => Promise.resolve(5),\n}))\n\nquery.data\n//    ^? (property) data: number | undefined\n\n```\n\n----------------------------------------\n\nTITLE: Initializing QueryClient Provider with Server Components\nDESCRIPTION: Sets up the QueryClient provider with specific configurations for server and browser environments, including staleTime defaults and client instance management\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\n\nimport {\n  isServer,\n  QueryClient,\n  QueryClientProvider,\n} from '@tanstack/react-query'\n\nfunction makeQueryClient() {\n  return new QueryClient({\n    defaultOptions: {\n      queries: {\n        staleTime: 60 * 1000,\n      },\n    },\n  })\n}\n\nlet browserQueryClient: QueryClient | undefined = undefined\n\nfunction getQueryClient() {\n  if (isServer) {\n    return makeQueryClient()\n  } else {\n    if (!browserQueryClient) browserQueryClient = makeQueryClient()\n    return browserQueryClient\n  }\n}\n\nexport default function Providers({ children }: { children: React.ReactNode }) {\n  const queryClient = getQueryClient()\n\n  return (\n    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Manually Priming the Query Cache with setQueryData in TanStack Query (TSX)\nDESCRIPTION: Presents how to synchronously insert or update data in the TanStack Query cache using setQueryData. This is useful when data for a query is already available (e.g., after a mutation or external fetch), circumventing the need for a network request. Dependencies are an instantiated queryClient and the target query key. Primary inputs are the query key array and the new data; the output is an updated cache entry. This is a succinct one-liner with no return value and assumes queryClient and todos are defined.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-23_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nqueryClient.setQueryData(['todos'], todos)\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Window Focus Refetching in TanStack Query\nDESCRIPTION: Shows how to disable window focus refetching globally by configuring the QueryClient defaultOptions. This affects all queries in the application unless overridden.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/window-focus-refetching.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      refetchOnWindowFocus: false, // default: true\n    },\n  },\n})\n\nfunction App() {\n  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing QueryClient for SSR in Remix\nDESCRIPTION: Demonstrates initializing `QueryClient` in a Remix application's root component (`app/root.tsx`) for server-side rendering. It utilizes `React.useState` to guarantee a separate cache instance for each request, crucial for SSR. A default `staleTime` is configured to prevent immediate client-side refetches.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n// app/root.tsx\nimport { Outlet } from '@remix-run/react'\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\nimport React from 'react';\n\nexport default function MyApp() {\n  const [queryClient] = React.useState(\n    ()\n      =>\n      new QueryClient({\n        defaultOptions: {\n          queries: {\n            // With SSR, we usually want to set some default staleTime\n            // above 0 to avoid refetching immediately on the client\n            staleTime: 60 * 1000,\n          },\n        },\n      }),\n  )\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Outlet />\n    </QueryClientProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Default Query Function in TanStack Query\nDESCRIPTION: Demonstrates how to set up a default query function using axios for HTTP requests, configure it with QueryClient, and use it in React components. The default function automatically handles API calls based on the provided query keys, simplifying query implementations across the application.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/default-query-function.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// Define a default query function that will receive the query key\nconst defaultQueryFn = async ({ queryKey }) => {\n  const { data } = await axios.get(\n    `https://jsonplaceholder.typicode.com${queryKey[0]}`,\n  )\n  return data\n}\n\n// provide the default query function to your app with defaultOptions\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      queryFn: defaultQueryFn,\n    },\n  },\n})\n\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <YourApp />\n    </QueryClientProvider>\n  )\n}\n\n// All you have to do now is pass a key!\nfunction Posts() {\n  const { status, data, error, isFetching } = useQuery({ queryKey: ['/posts'] })\n\n  // ...\n}\n\n// You can even leave out the queryFn and just go straight into options\nfunction Post({ postId }) {\n  const { status, data, error, isFetching } = useQuery({\n    queryKey: [`/posts/${postId}`],\n    enabled: !!postId,\n  })\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining QueryClient Provider Function in TypeScript\nDESCRIPTION: Function signature for provideQueryClient that accepts either a QueryClient instance or factory function and returns an Angular Provider. Used to configure TanStack Query client instances for specific parts of an Angular application.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/providequeryclient.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction provideQueryClient(value): Provider\n```\n\n----------------------------------------\n\nTITLE: Clearing All Caches with clear\nDESCRIPTION: Demonstrates how to clear all connected caches using the clear method.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_29\n\nLANGUAGE: tsx\nCODE:\n```\nqueryClient.clear()\n```\n\n----------------------------------------\n\nTITLE: Resetting Queries with TanStack Query\nDESCRIPTION: Examples of resetting queries to their initial state using queryClient.resetQueries.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_18\n\nLANGUAGE: tsx\nCODE:\n```\nqueryClient.resetQueries({ queryKey, exact: true })\n```\n\n----------------------------------------\n\nTITLE: Basic Mutation Implementation in Angular Component\nDESCRIPTION: An Angular component that implements a basic mutation with loading, error, and success states. It uses injectMutation to define a mutation function that creates a todo item via a service.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-23_snippet_0\n\nLANGUAGE: angular-ts\nCODE:\n```\n@Component({\n  template: `\n    <div>\n      @if (mutation.isPending()) {\n        <span>Adding todo...</span>\n      } @else if (mutation.isError()) {\n        <div>An error occurred: {{ mutation.error()?.message }}</div>\n      } @else if (mutation.isSuccess()) {\n        <div>Todo added!</div>\n      }\n      <button (click)=\"mutation.mutate(1)\">Create Todo</button>\n    </div>\n  `,\n})\nexport class TodosComponent {\n  todoService = inject(TodoService)\n  mutation = injectMutation(() => ({\n    mutationFn: (todoId: number) =>\n      lastValueFrom(this.todoService.create(todoId)),\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing Cache Persist with persistQueryClientSubscribe - TanStack Query - TypeScript\nDESCRIPTION: This snippet shows how to automatically persist cache changes by subscribing to the QueryClient changes using persistQueryClientSubscribe. The function takes queryClient, persister, buster, and dehydrateOptions, and returns an unsubscribe function. Useful for scenarios like keeping cache in sync for session persistence, such as after a user logs in with 'Remember me'. Running persistQueryClientRestore with a new buster after unsubscribe removes the cache.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/persistQueryClient.md#2025-04-23_snippet_3\n\nLANGUAGE: TSX\nCODE:\n```\npersistQueryClientSubscribe({\n  queryClient,\n  persister,\n  buster = '',\n  dehydrateOptions = undefined,\n})\n```\n\n----------------------------------------\n\nTITLE: Sample Data Fetching Hook\nDESCRIPTION: Example of a custom hook that fetches data from an API endpoint.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nfunction useFetchData() {\n  return useQuery({\n    queryKey: ['fetchData'],\n    queryFn: () => request('/api/data'),\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Query Cancellation with Angular HttpClient in TanStack Query\nDESCRIPTION: This snippet demonstrates how to use Angular's HttpClient with TanStack Query's AbortSignal. It creates a post query that converts the AbortSignal event to an Observable using fromEvent and then uses takeUntil to cancel the HTTP request when the signal is aborted.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-cancellation.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HttpClient } from '@angular/common/http'\nimport { injectQuery } from '@tanstack/angular-query-experimental'\n\npostQuery = injectQuery(() => ({\n  enabled: this.postId() > 0,\n  queryKey: ['post', this.postId()],\n  queryFn: async (context): Promise<Post> => {\n    const abort$ = fromEvent(context.signal, 'abort')\n    return lastValueFrom(this.getPost$(this.postId()).pipe(takeUntil(abort$)))\n  },\n}))\n```\n\n----------------------------------------\n\nTITLE: Retrieving Default Options with getDefaultOptions\nDESCRIPTION: Shows how to retrieve the default options that were set when creating the client or through setDefaultOptions.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_21\n\nLANGUAGE: tsx\nCODE:\n```\nconst defaultOptions = queryClient.getDefaultOptions()\n```\n\n----------------------------------------\n\nTITLE: Using queryOptions Function with Type Safety in TypeScript\nDESCRIPTION: Example showing how to use the queryOptions function to create type-safe query keys that retain the type information from the query function's return value.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/queryoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst { queryKey } = queryOptions({\n  queryKey: ['key'],\n  queryFn: () => Promise.resolve(5),\n  //  ^?  Promise<number>\n})\n\nconst queryClient = new QueryClient()\nconst data = queryClient.getQueryData(queryKey)\n//    ^?  number | undefined\n```\n\n----------------------------------------\n\nTITLE: Passing Parameters via queryKey to useQuery in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates using the `useQuery` hook from TanStack Query. It shows how to include dynamic parameters (`status`, `page`) within the `queryKey` array. The associated query function (`fetchTodoList`) accesses these parameters by destructuring the `queryKey` object automatically passed to it. This allows the query function to fetch data based on these variables. The `fetchTodoList` function itself is expected to return a Promise.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/query-functions.md#2025-04-23_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst result = useQuery({\n  queryKey: ['todos', { status, page }],\n  queryFn: fetchTodoList,\n})\n\n// Access the key, status and page variables in your query function!\nfunction fetchTodoList({ queryKey }) {\n  const [_key, { status, page }] = queryKey\n  return new Promise()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CreateBaseQueryOptions Interface in TypeScript\nDESCRIPTION: This code snippet defines the CreateBaseQueryOptions interface, which extends QueryObserverOptions. It includes five generic type parameters for customizing query-related types.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/createbasequeryoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface CreateBaseQueryOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey> extends QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n```\n\n----------------------------------------\n\nTITLE: injectQuery Function Signature with Defined Result\nDESCRIPTION: Implementation of injectQuery that returns a DefinedCreateQueryResult. This function signature is used when the query is guaranteed to have a defined result. It accepts optional type parameters for query data, error handling, and query keys.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectquery.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction injectQuery<TQueryFnData, TError, TData, TQueryKey>(\n  optionsFn,\n  injector?,\n): DefinedCreateQueryResult<TData, TError>\n```\n\n----------------------------------------\n\nTITLE: Importing Persister Types - TanStack Query - TypeScript\nDESCRIPTION: Shows how to import the Persister and PersistedClient interfaces from @tanstack/react-query-persist-client for use in custom persister implementation. Makes TypeScript type-safety available when creating new persisters for different storage backends.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/persistQueryClient.md#2025-04-23_snippet_10\n\nLANGUAGE: TSX\nCODE:\n```\nimport {\n  PersistedClient,\n  Persister,\n} from '@tanstack/react-query-persist-client'\n```\n\n----------------------------------------\n\nTITLE: Registering a Global Default Error Type in TypeScript\nDESCRIPTION: Shows how to define a global default error type for TanStack Query using TypeScript module augmentation. By extending the `Register` interface, all `useQuery` and `useMutation` calls will infer the specified `defaultError` type (e.g., `AxiosError`) without needing explicit generics, preserving inference for other types.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-23_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@tanstack/react-query'\n\ndeclare module '@tanstack/react-query' {\n  interface Register {\n    defaultError: AxiosError\n  }\n}\n\nconst { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })\n//      ^? const error: AxiosError | null\n```\n\n----------------------------------------\n\nTITLE: Implementing isPending Type Guard in TypeScript\nDESCRIPTION: Type guard method that narrows the query result type to pending state. Takes the current instance as parameter and returns a type predicate indicating if the result represents a pending state.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/basequerynarrowing.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nisPending: (this) => this is CreateBaseQueryResult<TData, TError, CreateStatusBasedQueryResult<\"pending\", TData, TError>>;\n```\n\n----------------------------------------\n\nTITLE: Defining CreateBaseQueryResult Generic Type Alias in TypeScript\nDESCRIPTION: Defines a type alias that combines BaseQueryNarrowing with mapped signals, used for handling query results in TanStack Query. Takes three generic type parameters: TData (defaults to unknown), TError (defaults to DefaultError), and TState (defaults to QueryObserverResult).\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/createbasequeryresult.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype CreateBaseQueryResult<TData, TError, TState>: BaseQueryNarrowing<TData, TError> & MapToSignals<OmitKeyof<TState, keyof BaseQueryNarrowing, \"safely\">>;\n```\n\n----------------------------------------\n\nTITLE: Subscribing to QueryCache Updates in TanStack Query\nDESCRIPTION: Shows how to subscribe to updates in the query cache. The callback function receives notification events whenever the cache is updated through tracked mechanisms.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryCache.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nconst callback = (event) => {\n  console.log(event.type, event.query)\n}\n\nconst unsubscribe = queryCache.subscribe(callback)\n```\n\n----------------------------------------\n\nTITLE: Implementing Manual Parallel Queries with useQuery in TanStack Query\nDESCRIPTION: Demonstrates how to execute multiple queries in parallel using individual useQuery hooks. This approach is suitable when the number of parallel queries is static and known at build time.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/parallel-queries.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction App () {\n  // The following queries will execute in parallel\n  const usersQuery = useQuery({ queryKey: ['users'], queryFn: fetchUsers })\n  const teamsQuery = useQuery({ queryKey: ['teams'], queryFn: fetchTeams })\n  const projectsQuery = useQuery({ queryKey: ['projects'], queryFn: fetchProjects })\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Including Query Function Dependencies in Query Keys (TSX)\nDESCRIPTION: Emphasizes the best practice of including any variable used within the `queryFn` (like `todoId`) directly in the `queryKey` array when using `useQuery`. This ensures that TanStack Query automatically refetches data when the dependency changes and maintains separate cache entries for different variable values. Depends on `useQuery` and assumes a `fetchTodoById` function.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-keys.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nfunction Todos({ todoId }) {\n  const result = useQuery({\n    queryKey: ['todos', todoId],\n    queryFn: () => fetchTodoById(todoId),\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing QueryClient with Default Options in React Query\nDESCRIPTION: Shows how to create a new QueryClient instance with customized default options for queries, setting staleTime to Infinity and demonstrating how to prefetch a query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { QueryClient } from '@tanstack/react-query'\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: Infinity,\n    },\n  },\n})\n\nawait queryClient.prefetchQuery({ queryKey: ['posts'], queryFn: fetchPosts })\n```\n\n----------------------------------------\n\nTITLE: Setting Default Options with setDefaultOptions\nDESCRIPTION: Demonstrates setting default options for the queryClient, which will override previously defined defaults. Example shows setting infinite staleTime for queries.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_22\n\nLANGUAGE: tsx\nCODE:\n```\nqueryClient.setDefaultOptions({\n  queries: {\n    staleTime: Infinity,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Custom Pagination Parameter Logic\nDESCRIPTION: Implementation with custom logic for determining next and previous page parameters based on page content and current page parameter.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/infinite-queries.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ninjectInfiniteQuery(() => ({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, allPages, lastPageParam) => {\n    if (lastPage.length === 0) {\n      return undefined\n    }\n    return lastPageParam + 1\n  },\n  getPreviousPageParam: (firstPage, allPages, firstPageParam) => {\n    if (firstPageParam <= 1) {\n      return undefined\n    }\n    return firstPageParam - 1\n  },\n}))\n```\n\n----------------------------------------\n\nTITLE: Conditionally Using Cached initialData in useQuery (TSX)\nDESCRIPTION: Illustrates conditionally using cached data as `initialData`. It checks the `dataUpdatedAt` timestamp from the source query's state (`queryClient.getQueryState(['todos'])`) and only returns the specific cached item (`state.data.find(...)`) if the data is sufficiently recent (within 10 seconds in this example). Otherwise, it returns `undefined`, forcing the query to fetch data from the server and enter a hard loading state.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-23_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nconst result = useQuery({\n  queryKey: ['todo', todoId],\n  queryFn: () => fetch(`/todos/${todoId}`),\n  initialData: () => {\n    // Get the query state\n    const state = queryClient.getQueryState(['todos'])\n\n    // If the query exists and has data that is no older than 10 seconds...\n    if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {\n      // return the individual todo\n      return state.data.find((d) => d.id === todoId)\n    }\n\n    // Otherwise, return undefined and let it fetch from a hard loading state!\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Converting HttpClient Observables to Promises in TanStack Query\nDESCRIPTION: This example demonstrates how to convert Angular HttpClient observables to promises using RxJS's lastValueFrom function for use in TanStack Query's queryFn. The code shows a component that injects HttpClient and sets up a query to fetch repository data from GitHub's API.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/angular-httpclient-and-other-data-fetching-clients.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n@Component({\n  // ...\n})\nclass ExampleComponent {\n  private readonly http = inject(HttpClient)\n\n  readonly query = injectQuery(() => ({\n    queryKey: ['repoData'],\n    queryFn: () =>\n      lastValueFrom(\n        this.http.get('https://api.github.com/repos/tanstack/query'),\n      ),\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the useIsMutating Hook Signature in Svelte Query (TypeScript)\nDESCRIPTION: This TypeScript function signature defines the `useIsMutating` hook for TanStack Svelte Query. It accepts optional `MutationFilters` and a `QueryClient` instance. It returns a Svelte `Readable` store which emits the number of mutations that match the filters and are currently executing.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/useismutating.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nfunction useIsMutating(filters?, queryClient?): Readable<number>\n```\n\n----------------------------------------\n\nTITLE: Filtering Fetching Status with useIsFetching in React Query (TSX)\nDESCRIPTION: Shows how to use the `useIsFetching` hook in React Query v3 with filters to get the number of currently fetching queries that match specific criteria. This example filters by `queryKey: ['posts']` to specifically count active fetches for posts, useful for showing targeted loading indicators. Requires React Query v3 and the `useIsFetching` hook.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_21\n\nLANGUAGE: tsx\nCODE:\n```\nconst fetches = useIsFetching({ queryKey: ['posts'] })\n```\n\n----------------------------------------\n\nTITLE: Disabling a TanStack Query Initially in Vue\nDESCRIPTION: This snippet demonstrates how to prevent a TanStack Query from automatically running upon component mount by setting the `enabled` option to `false`. The query can then be manually triggered using the `refetch` method returned by `useQuery`. It uses Vue 3 Composition API with `<script setup>` and includes a template to display the query state and data, and a button to initiate the fetch.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/disabling-queries.md#2025-04-23_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { useQuery } from '@tanstack/vue-query'\n\nconst { isLoading, isError, data, error, refetch, isFetching } = useQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n  enabled: false,\n})\n</script>\n\n<template>\n  <button @click=\"refetch()\">Fetch Todos</button>\n  <span v-if=\"isLoading\">Loading...</span>\n  <span v-else-if=\"isError\">Error: {{ error?.message }}</span>\n  <div v-else-if=\"data\">\n    <span v-if=\"isFetching\">Fetching...</span>\n    <ul>\n      <li v-for=\"todo in data\" :key=\"todo.id\">{{ todo.title }}</li>\n    </ul>\n  </div>\n  <span v-else>Not ready...</span>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Manually Setting Focus State in TanStack Query\nDESCRIPTION: Illustrates how to use setFocused to manually control the focus state. It can set focused, unfocused, or revert to the default focus check.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/focusManager.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { focusManager } from '@tanstack/react-query'\n\n// Set focused\nfocusManager.setFocused(true)\n\n// Set unfocused\nfocusManager.setFocused(false)\n\n// Fallback to the default focus check\nfocusManager.setFocused(undefined)\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Query Client in useQuery (TSX)\nDESCRIPTION: This snippet migrates the context prop to the direct queryClient prop in useQuery, enabling framework-agnostic isolation of query state. The custom queryClient instance must be created or imported from your application's configuration, and passed as a property. This is required for advanced, isolated query caches when using features like MicroFrontends.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-23_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nimport { queryClient } from './my-client'\\n\\nconst { data } = useQuery(\\n  {\\n    queryKey: ['users', id],\\n    queryFn: () => fetch(...),\\n-   context: customContext // [!code --]\\n  },\\n+  queryClient, // [!code ++]\\n)\n```\n\n----------------------------------------\n\nTITLE: Basic Query Function Implementation in TanStack Query\nDESCRIPTION: Demonstrates various ways to implement query functions using useQuery hook. Shows different patterns for fetching data including direct function references, arrow functions, and async implementations.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-functions.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nuseQuery({ queryKey: ['todos'], queryFn: fetchAllTodos })\nuseQuery({ queryKey: ['todos', todoId], queryFn: () => fetchTodoById(todoId) })\nuseQuery({\n  queryKey: ['todos', todoId],\n  queryFn: async () => {\n    const data = await fetchTodoById(todoId)\n    return data\n  },\n})\nuseQuery({\n  queryKey: ['todos', todoId],\n  queryFn: ({ queryKey }) => fetchTodoById(queryKey[1]),\n})\n```\n\n----------------------------------------\n\nTITLE: Conceptual Server-Side Rendering Request Waterfall\nDESCRIPTION: Illustrates the reduced network roundtrip sequence with server-side rendering. The initial request returns markup already containing content and initial data, followed only by the JavaScript bundle for interactivity, eliminating the separate client-side data query on initial load.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n```\n1. |-> Markup (with content AND initial data)\n2.   |-> JS\n```\n```\n\n----------------------------------------\n\nTITLE: Calling the queryOptions Utility Function (TSX)\nDESCRIPTION: Demonstrates the basic usage of the `queryOptions` function in TanStack Query. It accepts a required `queryKey` and spreads other options typically passed to `useQuery`. The function returns an options object that can be reused across different query hooks or client methods like `prefetchQuery`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/queryOptions.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nqueryOptions({\n  queryKey,\n  ...options,\n})\n```\n\n----------------------------------------\n\nTITLE: Defining CreateBaseMutationResult Type Alias in TypeScript\nDESCRIPTION: This type alias extends MutationObserverResult with additional properties. It uses four generic type parameters for data, error handling, variables, and context with sensible defaults.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/createbasemutationresult.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype CreateBaseMutationResult<TData, TError, TVariables, TContext>: Override<MutationObserverResult<TData, TError, TVariables, TContext>, object> & object;\n```\n\n----------------------------------------\n\nTITLE: Query Cancellation with Axios v0.22.0+ in TanStack Query\nDESCRIPTION: Shows how to implement query cancellation using Axios version 0.22.0 or higher, which natively supports AbortSignal.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-cancellation.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport axios from 'axios'\n\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: ({ signal }) =>\n    axios.get('/todos', {\n      // Pass the signal to `axios`\n      signal,\n    }),\n})\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Query Options in Angular with TanStack Query\nDESCRIPTION: This snippet demonstrates how to create a QueriesService that defines reusable query options using the queryOptions function from @tanstack/angular-query-experimental. It shows how to create a query for fetching a post, and provides examples of using these options for prefetching and setting query data.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-options.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { queryOptions } from '@tanstack/angular-query-experimental'\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class QueriesService {\n  private http = inject(HttpClient)\n\n  post(postId: number) {\n    return queryOptions({\n      queryKey: ['post', postId],\n      queryFn: () => {\n        return lastValueFrom(\n          this.http.get<Post>(\n            `https://jsonplaceholder.typicode.com/posts/${postId}`,\n          ),\n        )\n      },\n    })\n  }\n}\n\n// usage:\n\npostId = input.required({\n  transform: numberAttribute,\n})\nqueries = inject(QueriesService)\n\npostQuery = injectQuery(() => this.queries.post(this.postId()))\n\nqueryClient.prefetchQuery(this.queries.post(23))\nqueryClient.setQueryData(this.queries.post(42).queryKey, newPost)\n```\n\n----------------------------------------\n\nTITLE: Initial Data from Related Query\nDESCRIPTION: Shows how to populate initial data by accessing data from another query in the cache.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nresult = injectQuery(() => ({\n  queryKey: ['todo', this.todoId()],\n  queryFn: () => fetch('/todos'),\n  initialData: () => {\n    // Use a todo from the 'todos' query as the initial data for this todo query\n    return this.queryClient\n      .getQueryData(['todos'])\n      ?.find((d) => d.id === this.todoId())\n  },\n}))\n```\n\n----------------------------------------\n\nTITLE: Resetting Query Errors with useQueryErrorResetBoundary in React Query - TypeScript TSX\nDESCRIPTION: This snippet demonstrates how to use the useQueryErrorResetBoundary hook from @tanstack/react-query inside a React component to reset error state via an error boundary. It requires @tanstack/react-query and react-error-boundary as dependencies. The reset callback from useQueryErrorResetBoundary is passed to the ErrorBoundary component, which calls it when the user triggers a retry. This approach helps manage and recover from errors thrown by queries rendered within the boundary. Inputs include any React children and the fallback UI; the output is a UI that gracefully recovers from query errors.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useQueryErrorResetBoundary.md#2025-04-23_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useQueryErrorResetBoundary } from '@tanstack/react-query'\nimport { ErrorBoundary } from 'react-error-boundary'\n\nconst App = () => {\n  const { reset } = useQueryErrorResetBoundary()\n  return (\n    <ErrorBoundary\n      onReset={reset}\n      fallbackRender={({ resetErrorBoundary }) => (\n        <div>\n          There was an error!\n          <Button onClick={() => resetErrorBoundary()}>Try again</Button>\n        </div>\n      )}\n    >\n      <Page />\n    </ErrorBoundary>\n  )\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Queries with TanStack Query in TypeScript\nDESCRIPTION: Defines the createQueries generic function for Svelte applications using TanStack Query. It enables users to pass an array of query configurations and an optional QueryClient, returning a Svelte-readable store emitting combined query results. Type parameters T and TCombinedResult resolve the relationship between input query option arrays and output result arrays. Dependencies include TanStack Query for Svelte and the types Readable, QueryObserverOptionsForCreateQueries, and QueryClient. Inputs include a set of query option objects and an optional QueryClient; output is a reactive Readable store of query results arrays. Intended for use in Svelte components to batch-query data with fine-grained type inference.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/createqueries.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction createQueries<T, TCombinedResult>(\n  __namedParameters,\n  queryClient?,\n): Readable<TCombinedResult>\n```\n\n----------------------------------------\n\nTITLE: Implementing isIdle Method for Mutation State Narrowing in TypeScript\nDESCRIPTION: Type guard method that checks if a mutation is in the idle state and narrows the type to include idle-specific properties.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/basemutationnarrowing.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nisIdle: (this) => this is CreateMutationResult<TData, TError, TVariables, TContext, Override<MutationObserverIdleResult<TData, TError, TVariables, TContext>, Object> & Object>;\n```\n\n----------------------------------------\n\nTITLE: Implementing isSuccess Method for Mutation State Narrowing in TypeScript\nDESCRIPTION: Type guard method that checks if a mutation is in the success state and narrows the type to include success-specific properties and data.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/basemutationnarrowing.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nisSuccess: (this) => this is CreateMutationResult<TData, TError, TVariables, TContext, Override<MutationObserverSuccessResult<TData, TError, TVariables, TContext>, Object> & Object>;\n```\n\n----------------------------------------\n\nTITLE: Implementing Online Status Management with NetInfo\nDESCRIPTION: Sets up online status management in React Native using @react-native-community/netinfo to enable auto-refetch on reconnect functionality.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/react-native.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport NetInfo from '@react-native-community/netinfo'\nimport { onlineManager } from '@tanstack/react-query'\n\nonlineManager.setEventListener((setOnline) => {\n  return NetInfo.addEventListener((state) => {\n    setOnline(!!state.isConnected)\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Using queryCache.find Method in TanStack Query\nDESCRIPTION: Shows how to use the find method to retrieve an existing query instance from the cache. This method returns the query object or undefined if not found.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryCache.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst query = queryCache.find(queryKey)\n```\n\n----------------------------------------\n\nTITLE: Executing Parallel Queries with TanStack Query in Vue - TypeScript\nDESCRIPTION: This snippet demonstrates how to execute three parallel queries (users, teams, and projects) using TanStack Query's useQuery hook within a Vue component with script setup and TypeScript enabled. It assumes fetchUsers, fetchTeams, and fetchProjects are predefined asynchronous functions, and requires @tanstack/vue-query and a properly configured provider. Each useQuery is independent and will fetch data concurrently based on their distinct queryKey values. No input parameters are required, and the outputs are query state objects for users, teams, and projects.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/parallel-queries.md#2025-04-23_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\\\"ts\\\">\n// The following queries will execute in parallel\nconst usersQuery = useQuery({ queryKey: ['users'], queryFn: fetchUsers })\nconst teamsQuery = useQuery({ queryKey: ['teams'], queryFn: fetchTeams })\nconst projectsQuery = useQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n})\n<\\/script>\n```\n\n----------------------------------------\n\nTITLE: Using skipToken for TypeScript-safe Query Disabling\nDESCRIPTION: Demonstrates the use of skipToken for type-safe query disabling in TypeScript. The query is disabled when the filter is undefined or empty, providing better type safety than the enabled option.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/disabling-queries.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { skipToken, useQuery } from '@tanstack/react-query'\n\nfunction Todos() {\n  const [filter, setFilter] = React.useState<string | undefined>()\n\n  const { data } = useQuery({\n    queryKey: ['todos', filter],\n    // ‚¨áÔ∏è disabled as long as the filter is undefined or empty\n    queryFn: filter ? () => fetchTodos(filter) : skipToken,\n  })\n\n  return (\n    <div>\n      // üöÄ applying the filter will enable and execute the query\n      <FiltersForm onApply={setFilter} />\n      {data && <TodosTable data={data} />}\n    </div>\n  )\n```\n\n----------------------------------------\n\nTITLE: Using Variables and Objects in Query Keys (TSX)\nDESCRIPTION: Illustrates how to construct more complex query keys by including variables (like an ID) and objects (like filtering or formatting options) within the key array. This pattern is useful for hierarchical data or queries with parameters, ensuring unique caching for different data subsets. Depends on `useQuery`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-keys.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// An individual todo\nuseQuery({ queryKey: ['todo', 5], ... })\n\n// An individual todo in a \"preview\" format\nuseQuery({ queryKey: ['todo', 5, { preview: true }], ...})\n\n// A list of todos that are \"done\"\nuseQuery({ queryKey: ['todos', { type: 'done' }], ... })\n```\n\n----------------------------------------\n\nTITLE: Handling Error States in Optimistic Updates\nDESCRIPTION: Shows how to handle error states in optimistic updates by displaying failed items with retry functionality.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/optimistic-updates.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n{\n  isError && (\n    <li style={{ color: 'red' }}>\n      {variables}\n      <button onClick={() => mutate(variables)}>Retry</button>\n    </li>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling with Error Boundaries\nDESCRIPTION: Example of implementing error boundary reset functionality with QueryErrorResetBoundary component.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/suspense.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { QueryErrorResetBoundary } from '@tanstack/react-query'\nimport { ErrorBoundary } from 'react-error-boundary'\n\nconst App = () => (\n  <QueryErrorResetBoundary>\n    {({ reset }) => (\n      <ErrorBoundary\n        onReset={reset}\n        fallbackRender={({ resetErrorBoundary }) => (\n          <div>\n            There was an error!\n            <Button onClick={() => resetErrorBoundary()}>Try again</Button>\n          </div>\n        )}\n      >\n        <Page />\n      </ErrorBoundary>\n    )}\n  </QueryErrorResetBoundary>\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Infinite Queries with TanStack Query in TypeScript\nDESCRIPTION: This TypeScript function defines createInfiniteQuery, a generic utility for setting up infinite queries in Svelte applications using TanStack Query. It requires type parameters to ensure flexibility over response and error types, as well as a configuration object (options) and an optional QueryClient. The function returns a CreateInfiniteQueryResult that manages infinite data streams (such as paginated API fetching). Required dependencies include TanStack Query's Svelte package and proper typing for options and QueryClient. Inputs are highly generic and determined by user context; the output is a typed query result stream to drive UI updates for infinite lists. Users must ensure that all related type aliases and interfaces are available in their project for it to work correctly.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/createinfinitequery.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction createInfiniteQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam,\n>(options, queryClient?): CreateInfiniteQueryResult<TData, TError>\n```\n\n----------------------------------------\n\nTITLE: Fetching Multiple Queries in Parallel with useQueries - TanStack Query (TypeScript)\nDESCRIPTION: This snippet demonstrates how to fetch data for a dynamic set of items (posts) using the useQueries hook in a TypeScript React application with TanStack Query. It maps an array of IDs to individual query option objects, each specifying a unique queryKey, a fetch function, and staleTime. The hook returns an array of all query results in the same order as the input. Dependencies include React, TanStack Query, and a fetchPost function. The function expects ids as an array of identifiers, and results will contain one entry for each id.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useQueries.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst ids = [1, 2, 3]\nconst results = useQueries({\n  queries: ids.map((id) => ({\n    queryKey: ['post', id],\n    queryFn: () => fetchPost(id),\n    staleTime: Infinity,\n  })),\n})\n```\n\n----------------------------------------\n\nTITLE: Using initialData with Remix Loader\nDESCRIPTION: Demonstrates using the `initialData` option in `useQuery` within a Remix component. Data is fetched in the `loader` function, made available through `useLoaderData`, and then passed to `useQuery`'s `initialData` option for initial population.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQuery } from '@tanstack/react-query';\nimport { json } from '@remix-run/node'; // Assuming usage of node adapter\nimport { useLoaderData } from '@remix-run/react';\n\ndeclare function getPosts(): Promise<any[]>; // Example declaration\n\nexport async function loader() {\n  const posts = await getPosts()\n  return json({ posts })\n}\n\nfunction Posts() {\n  const { posts } = useLoaderData<typeof loader>()\n\n  const { data } = useQuery({\n    queryKey: ['posts'],\n    queryFn: getPosts,\n    initialData: posts,\n  })\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Correct QueryClient implementation using module-level instance\nDESCRIPTION: This example demonstrates creating a QueryClient instance at the module level, outside any component, ensuring a single instance is shared across the application.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/stable-query-client.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst queryClient = new QueryClient()\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Home />\n    </QueryClientProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Query States in Vue Component using Status Property\nDESCRIPTION: This Vue Single File Component illustrates fetching data with `useQuery` and managing UI rendering based on the query's `status` property ('pending', 'error', 'success'). The template uses `v-if` and `v-else-if` directives to check the `status` string and display appropriate content, such as a loading indicator, an error message, or the successfully fetched list of todos.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/queries.md#2025-04-23_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { useQuery } from '@tanstack/vue-query'\n\nconst { status, data, error } = useQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n})\n</script>\n\n<template>\n  <span v-if=\"status === 'pending'\">Loading...</span>\n  <span v-else-if=\"status === 'error'\">Error: {{ error.message }}</span>\n  <!-- also status === 'success', but \"else\" logic works, too -->\n  <ul v-else-if=\"data\">\n    <li v-for=\"todo in data\" :key=\"todo.id\">{{ todo.title }}</li>\n  </ul>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Testing with React Testing Library including a custom wrapper\nDESCRIPTION: Example of how to test a component that uses TanStack Query with React Testing Library, utilizing the custom renderWithClient function.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/testing.md#2025-04-23_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { screen } from '@testing-library/react'\nimport { renderWithClient } from './utils'\nimport { PostsList } from './PostsList'\n\ntest('should render the posts', async () => {\n  renderWithClient(<PostsList />)\n  expect(await screen.findByText('Post title')).toBeInTheDocument()\n})\n```\n\n----------------------------------------\n\nTITLE: Ensuring Query Data Exists with Fetch Fallback\nDESCRIPTION: Demonstrates retrieving cached query data with a fallback to fetching if the data doesn't exist in the cache.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nconst data = await queryClient.ensureQueryData({ queryKey, queryFn })\n```\n\n----------------------------------------\n\nTITLE: Query Cancellation with XMLHttpRequest in TanStack Query\nDESCRIPTION: Shows how to implement cancellable queries using XMLHttpRequest with proper abort handling.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-cancellation.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: ({ signal }) => {\n    return new Promise((resolve, reject) => {\n      var oReq = new XMLHttpRequest()\n      oReq.addEventListener('load', () => {\n        resolve(JSON.parse(oReq.responseText))\n      })\n      signal?.addEventListener('abort', () => {\n        oReq.abort()\n        reject()\n      })\n      oReq.open('GET', '/todos')\n      oReq.send()\n    })\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing MutationCache in React Query\nDESCRIPTION: Creates a new MutationCache instance with optional callbacks for error and success handling. The MutationCache is the central storage for mutations, though typically accessed through the QueryClient rather than directly.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/MutationCache.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { MutationCache } from '@tanstack/react-query'\n\nconst mutationCache = new MutationCache({\n  onError: (error) => {\n    console.log(error)\n  },\n  onSuccess: (data) => {\n    console.log(data)\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using matchQuery Utility in TanStack Query\nDESCRIPTION: Example of using the matchQuery utility function to check if a query matches specific filter criteria.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/filters.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst isMatching = matchQuery(filters, query)\n```\n\n----------------------------------------\n\nTITLE: Setting Specific Retry Attempts for a Vue Query using `useQuery` (TSX)\nDESCRIPTION: This TSX snippet demonstrates how to configure a specific number of retry attempts for a TanStack Vue Query using the `retry` option within the `useQuery` hook. It depends on `@tanstack/vue-query` and an assumed data-fetching function (`fetchTodoListPage`). The query for `['todos', 1]` will retry up to 10 times upon failure before throwing an error.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/query-retries.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport { useQuery } from '@tanstack/vue-query'\n\n// Make a specific query retry a certain number of times\nconst result = useQuery({\n  queryKey: ['todos', 1],\n  queryFn: fetchTodoListPage,\n  retry: 10, // Will retry failed requests 10 times before displaying an error\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Correct Property Order in useInfiniteQuery (TanStack Query)\nDESCRIPTION: This example demonstrates the correct property ordering for useInfiniteQuery. The properties follow the recommended order of queryFn, getPreviousPageParam, getNextPageParam to ensure proper type inference.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/infinite-query-property-order.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n/* eslint \"@tanstack/query/infinite-query-property-order\": \"warn\" */\nimport { useInfiniteQuery } from '@tanstack/react-query'\n\nconst query = useInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: async ({ pageParam }) => {\n    const response = await fetch(`/api/projects?cursor=${pageParam}`)\n    return await response.json()\n  },\n  initialPageParam: 0,\n  getPreviousPageParam: (firstPage) => firstPage.previousId ?? undefined,\n  getNextPageParam: (lastPage) => lastPage.nextId ?? undefined,\n  maxPages: 3,\n})\n```\n\n----------------------------------------\n\nTITLE: Installing TanStack Svelte Query Devtools Package (Bash)\nDESCRIPTION: Provides commands to install the `@tanstack/svelte-query-devtools` package using different JavaScript package managers: npm, pnpm, yarn, and bun. This separate package is required to use the Svelte Query Devtools component.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/devtools.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @tanstack/svelte-query-devtools\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @tanstack/svelte-query-devtools\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @tanstack/svelte-query-devtools\n```\n\nLANGUAGE: bash\nCODE:\n```\nbun add @tanstack/svelte-query-devtools\n```\n\n----------------------------------------\n\nTITLE: Installing ESLint Plugin Query via NPM (Bash)\nDESCRIPTION: Installs the recommended `@tanstack/eslint-plugin-query` as a development dependency using NPM. This plugin helps enforce best practices and catch potential issues in React Query code.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/installation.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nnpm i -D @tanstack/eslint-plugin-query\n```\n\n----------------------------------------\n\nTITLE: Installing React Query v4 Dependencies\nDESCRIPTION: Commands for uninstalling react-query v3 and installing the new @tanstack/react-query packages\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm uninstall react-query\nnpm install @tanstack/react-query\nnpm install @tanstack/react-query-devtools\n```\n\n----------------------------------------\n\nTITLE: Using mutationCache.getAll method in React Query\nDESCRIPTION: Retrieves all mutations stored in the cache. This method is rarely needed in most applications but can be useful when additional information about mutations is required in specific scenarios.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/MutationCache.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst mutations = mutationCache.getAll()\n```\n\n----------------------------------------\n\nTITLE: Persisting and Hydrating Mutations with TanStack Query in TypeScript\nDESCRIPTION: This snippet demonstrates how to persist in-progress or paused mutations in TanStack Query and later resume them, using the hydration functions 'dehydrate' and 'hydrate'. Key steps include setting mutation defaults to provide an optimistic update, handling onSuccess and onError for list synchronization, and serializing the mutation state for offline or paused scenarios. Dependencies include QueryClient from TanStack Query and related hydration helpers, a unique id generator like 'uuid', and an 'addTodo' mutation function. Inputs include mutation variables (e.g., title), and outputs are mutation state changes and UI updates. Limitations include the inability to serialize mutation functions directly, requiring care when hydrating state after application reloads.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-23_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nconst queryClient = new QueryClient()\n\n// Define the \"addTodo\" mutation\nqueryClient.setMutationDefaults(['addTodo'], {\n  mutationFn: addTodo,\n  onMutate: async (variables) => {\n    // Cancel current queries for the todos list\n    await queryClient.cancelQueries({ queryKey: ['todos'] })\n\n    // Create optimistic todo\n    const optimisticTodo = { id: uuid(), title: variables.title }\n\n    // Add optimistic todo to todos list\n    queryClient.setQueryData(['todos'], (old) => [...old, optimisticTodo])\n\n    // Return context with the optimistic todo\n    return { optimisticTodo }\n  },\n  onSuccess: (result, variables, context) => {\n    // Replace optimistic todo in the todos list with the result\n    queryClient.setQueryData(['todos'], (old) =>\n      old.map((todo) =>\n        todo.id === context.optimisticTodo.id ? result : todo,\n      ),\n    )\n  },\n  onError: (error, variables, context) => {\n    // Remove optimistic todo from the todos list\n    queryClient.setQueryData(['todos'], (old) =>\n      old.filter((todo) => todo.id !== context.optimisticTodo.id),\n    )\n  },\n  retry: 3,\n})\n\n// Start mutation in some component:\nconst mutation = useMutation({ mutationKey: ['addTodo'] })\nmutation.mutate({ title: 'title' })\n\n// If the mutation has been paused because the device is for example offline,\n// Then the paused mutation can be dehydrated when the application quits:\nconst state = dehydrate(queryClient)\n\n// The mutation can then be hydrated again when the application is started:\nhydrate(queryClient, state)\n\n// Resume the paused mutations:\nqueryClient.resumePausedMutations()\n```\n\n----------------------------------------\n\nTITLE: Conditionally Enabling a TanStack Query Based on State in Vue\nDESCRIPTION: This example illustrates dynamically enabling a TanStack Query in Vue based on reactive state. It uses a `ref` for a filter input and a `computed` property (`isEnabled`) to determine the `enabled` status of the `useQuery` hook. The query is only active (`enabled: true`) when the `filter` ref has a truthy value. Assumes a `fetchTodos` function that accepts the filter value.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/disabling-queries.md#2025-04-23_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { useQuery } from '@tanstack/vue-query'\n\nconst filter = ref('')\nconst isEnabled = computed(() => !!filter.value)\nconst { data } = useQuery({\n  queryKey: ['todos', filter],\n  queryFn: () => fetchTodos(filter),\n  // ‚¨áÔ∏è disabled as long as the filter is empty\n  enabled: isEnabled,\n})\n</script>\n\n<template>\n  <span v-if=\"data\">Filter was set and data is here!</span>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Combining Query Results with useQueries and combine Option - TanStack Query (TypeScript)\nDESCRIPTION: This snippet illustrates how to use the combine option with useQueries to aggregate multiple query results into a single structured result. Each post is queried, and the combine function merges their data into an array while also tracking if any query is pending. This is useful for handling composite state in components. The dependencies are similar to the first snippet, and the combine function provides an object with combined data and pending status. Note: other properties from the individual queries are omitted in the combined result.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useQueries.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst ids = [1, 2, 3]\nconst combinedQueries = useQueries({\n  queries: ids.map((id) => ({\n    queryKey: ['post', id],\n    queryFn: () => fetchPost(id),\n  })),\n  combine: (results) => {\n    return {\n      data: results.map((result) => result.data),\n      pending: results.some((result) => result.isPending),\n    }\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Providing Placeholder Data with useQuery - TanStack Query (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the useQuery hook in TanStack Query for React with the placeholderData property set to a variable (placeholderTodos). This approach allows the query to start with non-persisted placeholder data, which can render immediately while waiting for the real data fetch to complete. Required dependencies include React, TanStack Query, and a placeholderTodos value; the main parameters are queryKey, queryFn, and placeholderData.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/placeholder-query-data.md#2025-04-23_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nfunction Todos() {\\n  const result = useQuery({\\n    queryKey: ['todos'],\\n    queryFn: () => fetch('/todos'),\\n    placeholderData: placeholderTodos,\\n  })\\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling a TanStack Query Using skipToken in Vue\nDESCRIPTION: This snippet presents an alternative method for disabling a TanStack Query in Vue using `skipToken`. Instead of the `enabled` option, it dynamically sets the `queryFn`. A `computed` property returns `skipToken` (imported from `@tanstack/vue-query`) if a `filter` ref is empty, preventing the query from running. Otherwise, it provides the actual data-fetching function. Assumes `fetchTodos` takes the filter as input.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/disabling-queries.md#2025-04-23_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { useQuery, skipToken } from '@tanstack/vue-query'\n\nconst filter = ref('')\nconst queryFn = computed(() =>\n  !!filter.value ? () => fetchTodos(filter) : skipToken,\n)\nconst { data } = useQuery({\n  queryKey: ['todos', filter],\n  // ‚¨áÔ∏è disabled as long as the filter is undefined or empty\n  queryFn: queryFn,\n})\n</script>\n\n<template>\n  <span v-if=\"data\">Filter was set and data is here!</span>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of injectQuery in Angular Components\nDESCRIPTION: Demonstrates the basic implementation of injectQuery to create a query for fetching data from an API endpoint. The query is tied to a unique key and uses HTTP to retrieve repository data.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectquery.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nclass ServiceOrComponent {\n  query = injectQuery(() => ({\n    queryKey: ['repoData'],\n    queryFn: () =>\n      this.#http.get<Response>('https://api.github.com/repos/tanstack/query'),\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Defining injectQueryClient Function in TypeScript\nDESCRIPTION: This snippet shows the function signature for injectQueryClient without parameters, which returns a QueryClient instance.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectqueryclient.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction injectQueryClient(): QueryClient\n```\n\n----------------------------------------\n\nTITLE: Handling Settled State in Angular Mutations\nDESCRIPTION: This snippet demonstrates how to handle the settled state of a mutation, including both success and error cases. It provides a template for custom logic after mutation completion.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/optimistic-updates.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ninjectMutation({\n  mutationFn: updateTodo,\n  // ...\n  onSettled: (newTodo, error, variables, context) => {\n    if (error) {\n      // do something\n    }\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Embedded Mode for React Query Devtools\nDESCRIPTION: Example of how to implement the embedded mode of React Query Devtools in a React application, including a toggle button.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/devtools.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { ReactQueryDevtoolsPanel } from '@tanstack/react-query-devtools'\n\nfunction App() {\n  const [isOpen, setIsOpen] = React.useState(false)\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      {/* The rest of your application */}\n      <button\n        onClick={() => setIsOpen(!isOpen)}\n      >{`${isOpen ? 'Close' : 'Open'} the devtools panel`}</button>\n      {isOpen && <ReactQueryDevtoolsPanel onClose={() => setIsOpen(false)} />}\n    </QueryClientProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking Paginated API Response\nDESCRIPTION: Helper function to generate mock responses for paginated data testing.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nfunction generateMockedResponse(page) {\n  return {\n    page: page,\n    items: [...]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to MutationCache updates in React Query\nDESCRIPTION: Sets up a subscription to the mutation cache to receive notifications about updates, including state changes or mutations being added, updated, or removed. Returns an unsubscribe function to cancel the subscription.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/MutationCache.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst callback = (event) => {\n  console.log(event.type, event.mutation)\n}\n\nconst unsubscribe = mutationCache.subscribe(callback)\n```\n\n----------------------------------------\n\nTITLE: Combining Restoration and Subscription with persistQueryClient - TanStack Query - TypeScript\nDESCRIPTION: This code demonstrates how to use persistQueryClient to both restore previously persisted cache and begin subscribing to future QueryClient changes. The function configures options for cache persistence: queryClient, persister, maxAge, buster, hydrateOptions, and dehydrateOptions. Returns an unsubscribe function and ensures restored data continues to sync with storage.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/persistQueryClient.md#2025-04-23_snippet_5\n\nLANGUAGE: TSX\nCODE:\n```\npersistQueryClient({\n  queryClient,\n  persister,\n  maxAge = 1000 * 60 * 60 * 24, // 24 hours\n  buster = '',\n  hydrateOptions = undefined,\n  dehydrateOptions = undefined,\n})\n```\n\n----------------------------------------\n\nTITLE: Error Handling in TanStack Query Functions\nDESCRIPTION: Shows how to properly handle and throw errors in query functions. Demonstrates throwing direct errors and returning rejected promises.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-functions.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst { error } = useQuery({\n  queryKey: ['todos', todoId],\n  queryFn: async () => {\n    if (somethingGoesWrong) {\n      throw new Error('Oh no!')\n    }\n    if (somethingElseGoesWrong) {\n      return Promise.reject(new Error('Oh no!'))\n    }\n\n    return data\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Query Cancellation with Axios in TanStack Query\nDESCRIPTION: This snippet demonstrates how to use Axios with TanStack Query's AbortSignal. The signal is passed directly to axios.get() in the configuration object, enabling automatic cancellation when the query becomes inactive.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-cancellation.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport axios from 'axios'\n\nconst query = injectQuery(() => ({\n  queryKey: ['todos'],\n  queryFn: ({ signal }) =>\n    axios.get('/todos', {\n      // Pass the signal to `axios`\n      signal,\n    }),\n}))\n```\n\n----------------------------------------\n\nTITLE: Dependent Query Implementation\nDESCRIPTION: Example of a dependent query pattern where the second query depends on the result of the first query, creating a waterfall effect.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/request-waterfalls.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst { data: user } = useQuery({\n  queryKey: ['user', email],\n  queryFn: getUserByEmail,\n})\n\nconst userId = user?.id\n\nconst {\n  status,\n  fetchStatus,\n  data: projects,\n} = useQuery({\n  queryKey: ['projects', userId],\n  queryFn: getProjectsByUser,\n  // The query will not execute until the userId exists\n  enabled: !!userId,\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Svelte Query Devtools in Floating Mode (Svelte/TypeScript)\nDESCRIPTION: Demonstrates how to integrate the `SvelteQueryDevtools` component in Floating Mode within a Svelte application. The component should be placed inside the `QueryClientProvider` near the application root. This setup mounts the devtools as a fixed, floating element with a toggle button. Configuration options like `initialIsOpen`, `buttonPosition`, `position`, `client`, `errorTypes`, `styleNonce`, and `shadowDOMTarget` can be passed as props to customize its behavior and appearance.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/devtools.md#2025-04-23_snippet_2\n\nLANGUAGE: svelte\nCODE:\n```\n<script>\n  import { QueryClientProvider } from '@tanstack/svelte-query'\n  import { SvelteQueryDevtools } from '@tanstack/svelte-query-devtools'\n</script>\n\n<QueryClientProvider client={queryClient}>\n  {/* The rest of your application */}\n  <SvelteQueryDevtools />\n</QueryClientProvider>\n```\n\n----------------------------------------\n\nTITLE: Injecting Infinite Query in Angular with DefinedCreateInfiniteQueryResult\nDESCRIPTION: This overload of injectInfiniteQuery is similar to the first, but returns a DefinedCreateInfiniteQueryResult. It's used when the query result is guaranteed to be defined.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectinfinitequery.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction injectInfiniteQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam,\n>(optionsFn, injector?): DefinedCreateInfiniteQueryResult<TData, TError>\n```\n\n----------------------------------------\n\nTITLE: Defining CreateInfiniteQueryResult Type Alias in TypeScript\nDESCRIPTION: Declaration of the CreateInfiniteQueryResult type alias that maps InfiniteQueryObserverResult to signals. It accepts two generic type parameters: TData (defaults to unknown) and TError (defaults to DefaultError).\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/createinfinitequeryresult.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype CreateInfiniteQueryResult<TData, TError>: MapToSignals<InfiniteQueryObserverResult<TData, TError>>;\n```\n\n----------------------------------------\n\nTITLE: Visualizing Server-Side Waterfall\nDESCRIPTION: Shows the dependent query waterfall that still exists on the server side, though with less impact due to lower latency.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-23_snippet_15\n\nLANGUAGE: markdown\nCODE:\n```\n1. |> getFeed()\n2.   |> getGraphDataById()\n```\n\n----------------------------------------\n\nTITLE: Implementing QueryErrorResetBoundary with Error Boundary in React\nDESCRIPTION: Demonstrates how to implement QueryErrorResetBoundary component with React Error Boundary to handle query errors and provide retry functionality. The component wraps around the application content and provides a reset function that can be used to clear query errors and retry failed queries.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/QueryErrorResetBoundary.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { QueryErrorResetBoundary } from '@tanstack/react-query'\nimport { ErrorBoundary } from 'react-error-boundary'\n\nconst App = () => (\n  <QueryErrorResetBoundary>\n    {({ reset }) => (\n      <ErrorBoundary\n        onReset={reset}\n        fallbackRender={({ resetErrorBoundary }) => (\n          <div>\n            There was an error!\n            <Button onClick={() => resetErrorBoundary()}>Try again</Button>\n          </div>\n        )}\n      >\n        <Page />\n      </ErrorBoundary>\n    )}\n  </QueryErrorResetBoundary>\n)\n```\n\n----------------------------------------\n\nTITLE: Definition of experimental_createPersister function signature\nDESCRIPTION: Type signature for the experimental_createPersister function, showing that it accepts StoragePersisterOptions as an argument.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/plugins/createPersister.md#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nexperimental_createPersister(options: StoragePersisterOptions)\n```\n\n----------------------------------------\n\nTITLE: Fetching Data with Solid Query useQuery Hook\nDESCRIPTION: This snippet showcases fetching data using the `useQuery` hook from Solid Query (`@tanstack/solid-query`). It demonstrates setting up a `QueryClient` and `QueryClientProvider`, defining a query with a unique `queryKey`, an asynchronous `queryFn`, caching behavior (`staleTime`), and error handling (`throwOnError`). The example integrates seamlessly with SolidJS's `Suspense` and `ErrorBoundary` for managing loading and error states.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/overview.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport { ErrorBoundary, Suspense } from 'solid-js'\nimport {\n  useQuery,\n  QueryClient,\n  QueryClientProvider,\n} from '@tanstack/solid-query'\n\nfunction App() {\n  const repositoryQuery = useQuery(() => ({\n    queryKey: ['TanStack Query'],\n    queryFn: async () => {\n      const result = await fetch('https://api.github.com/repos/TanStack/query')\n      if (!result.ok) throw new Error('Failed to fetch data')\n      return result.json()\n    },\n    staleTime: 1000 * 60 * 5, // 5 minutes\n    throwOnError: true, // Throw an error if the query fails\n  }))\n\n  return (\n    <div>\n      <div>Static Content</div>\n      {/* An error while fetching will be caught by the ErrorBoundary */}\n      <ErrorBoundary fallback={<div>Something went wrong!</div>}>\n        {/* Suspense will trigger a loading state while the data is being fetched */}\n        <Suspense fallback={<div>Loading...</div>}>\n          {/* \n            The `data` property on a query is a SolidJS resource  \n            so it will work with Suspense and transitions out of the box! \n          */}\n          <div>{repositoryQuery.data?.updated_at}</div>\n        </Suspense>\n      </ErrorBoundary>\n    </div>\n  )\n}\n\nconst root = document.getElementById('root')\nconst client = new QueryClient()\n\nrender(\n  () => (\n    <QueryClientProvider client={client}>\n      <App />\n    </QueryClientProvider>\n  ),\n  root!,\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Reduced Global State After Using TanStack Query in TypeScript React\nDESCRIPTION: This code snippet illustrates how the global state is reduced after moving server-state management to TanStack Query, leaving only client-state items.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/does-this-replace-client-state.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst globalState = {\n  themeMode,\n  sidebarStatus,\n}\n```\n\n----------------------------------------\n\nTITLE: Importing React Query Devtools for Modern Bundlers\nDESCRIPTION: Example of how to import React Query Devtools for bundlers that support package exports.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/devtools.md#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nconst ReactQueryDevtoolsProduction = React.lazy(() =>\n  import('@tanstack/react-query-devtools/production').then((d) => ({\n    default: d.ReactQueryDevtools,\n  })),\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Window Focus Event Handler\nDESCRIPTION: Shows how to implement a custom window focus event listener using focusManager.setEventListener. This example implements the default visibility change handler.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/window-focus-refetching.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nfocusManager.setEventListener((handleFocus) => {\n  // Listen to visibilitychange\n  if (typeof window !== 'undefined' && window.addEventListener) {\n    const visibilitychangeHandler = () => {\n      handleFocus(document.visibilityState === 'visible')\n    }\n    window.addEventListener('visibilitychange', visibilitychangeHandler, false)\n    return () => {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener('visibilitychange', visibilitychangeHandler)\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Window Focus Refetching in TanStack Query for Angular\nDESCRIPTION: This snippet shows how to configure the QueryClient to disable window focus refetching globally for all queries in an Angular application using TanStack Query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/window-focus-refetching.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideTanStackQuery(\n      new QueryClient({\n        defaultOptions: {\n          queries: {\n            refetchOnWindowFocus: false, // default: true\n          },\n        },\n      }),\n    ),\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Vue Query with npm\nDESCRIPTION: Command to install Vue Query using npm package manager.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/installation.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @tanstack/vue-query\n```\n\n----------------------------------------\n\nTITLE: Defining Query Options for Svelte TanStack Query in TypeScript\nDESCRIPTION: This function overload enables the creation of query options in TanStack Query when the initial data is defined. It uses generic type parameters for strong typing of query function data, error, return data, and query key. The function expects input matching the DefinedInitialDataOptions interface and returns the same type with an additional object intersection. Dependencies include TypeScript type definitions from TanStack Svelte Query. Inputs should follow the structure of DefinedInitialDataOptions, and the returned object will be type-checked accordingly.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/queryoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction queryOptions<TQueryFnData, TError, TData, TQueryKey>(\n  options,\n): DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & object\n```\n\n----------------------------------------\n\nTITLE: Importing useQueryClient from Vue Query\nDESCRIPTION: Demonstrates how to import the useQueryClient hook from the @tanstack/vue-query package.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/reference/useQueryClient.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useQueryClient } from '@tanstack/vue-query'\n```\n\n----------------------------------------\n\nTITLE: Implementing infiniteQueryOptions with Undefined Initial Data in TypeScript\nDESCRIPTION: Function implementation for infiniteQueryOptions that handles undefined initial data scenarios. It takes type parameters for query function data, error handling, data structure, query key, and page parameters. Returns tagged infinite query options.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/infinitequeryoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction infiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam,\n>(\n  options,\n): UndefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> &\n  object\n```\n\n----------------------------------------\n\nTITLE: Using injectQueries for Dynamic Parallel Queries in Angular\nDESCRIPTION: This example shows how to use injectQueries to dynamically execute multiple queries based on a signal array. Each item in the users array generates a separate query configuration with its own queryKey and queryFn. Note that this feature is marked as under development.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/parallel-queries.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport class AppComponent {\n  users = signal<Array<User>>([])\n\n  // Please note injectQueries is under development and this code does not work yet\n  userQueries = injectQueries(() => ({\n    queries: users().map((user) => {\n      return {\n        queryKey: ['user', user.id],\n        queryFn: () => fetchUserById(user.id),\n      }\n    }),\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Prefetching Data with useQuery Inside a Nuxt 3 Page (TypeScript)\nDESCRIPTION: This example illustrates how to use useQuery with suspense inside a Nuxt 3 page component for server-side prefetching. By placing a call to await suspense() in onServerPrefetch, the query's data is prefetched before rendering, enabling hydrated data display immediately on client load. The snippet depends on Vue's defineComponent, onServerPrefetch, and useQuery, compatible with Nuxt 3's composition API. Required parameters include a unique queryKey and a data-fetching function (fetcher). Inputs include no direct props; outputs are data returned from the query. This method provides instant data display and minimizes client-side loading state.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/ssr.md#2025-04-23_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nexport default defineComponent({\n  setup() {\n    const { data, suspense } = useQuery({\n      queryKey: ['test'],\n      queryFn: fetcher,\n    })\n\n    onServerPrefetch(async () => {\n      await suspense()\n    })\n\n    return { data }\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using Reactive Getters with Queries\nDESCRIPTION: Using reactive getters for derived state instead of computed, providing a more concise syntax without unnecessary memoization overhead.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/reactivity.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// Reacts to changes in props.userId. No `computed` needed!\nconst { data: projects } = useUserProjects(() => props.userId)\n```\n\n----------------------------------------\n\nTITLE: Initializing BroadcastQueryClient with QueryClient in TSX\nDESCRIPTION: Basic example of setting up broadcastQueryClient with a QueryClient instance and custom broadcast channel.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/broadcastQueryClient.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { broadcastQueryClient } from '@tanstack/query-broadcast-client-experimental'\n\nconst queryClient = new QueryClient()\n\nbroadcastQueryClient({\n  queryClient,\n  broadcastChannel: 'my-app',\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Query Client Garbage Collection in Tanstack Query (TSX)\nDESCRIPTION: This snippet shows how to rename the cacheTime option to gcTime when initializing a QueryClient in Tanstack Query. The gcTime parameter determines how long unused query data stays before being garbage collected, and its value is typically specified in milliseconds. The configuration is updated to reflect this new, technically accurate name and must be provided as part of the queries section in defaultOptions.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-23_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nconst MINUTE = 1000 * 60;\\n\\nconst queryClient = new QueryClient({\\n  defaultOptions: {\\n    queries: {\\n-      cacheTime: 10 * MINUTE, // [!code --]\\n+      gcTime: 10 * MINUTE, // [!code ++]\\n    },\\n  },\\n})\n```\n\n----------------------------------------\n\nTITLE: Defining provideAngularQuery Function in TypeScript\nDESCRIPTION: Function signature for provideAngularQuery, which takes a QueryClient instance and returns EnvironmentProviders for setting up TanStack Query in Angular applications.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/provideangularquery.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction provideAngularQuery(queryClient): EnvironmentProviders\n```\n\n----------------------------------------\n\nTITLE: Basic Query Function Implementation in TanStack Query\nDESCRIPTION: Demonstrates various basic patterns for implementing query functions with injectQuery including direct function reference, inline function with parameters, and async functions with explicit return.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-functions.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninjectQuery(() => ({ queryKey: ['todos'], queryFn: fetchAllTodos }))\ninjectQuery(() => ({ queryKey: ['todos', todoId], queryFn: () => fetchTodoById(todoId) }))\ninjectQuery(() => ({\n  queryKey: ['todos', todoId],\n  queryFn: async () => {\n    const data = await fetchTodoById(todoId)\n    return data\n  },\n}))\ninjectQuery(() => ({\n  queryKey: ['todos', todoId],\n  queryFn: ({ queryKey }) => fetchTodoById(queryKey[1]),\n}))\n```\n\n----------------------------------------\n\nTITLE: Updating React Query Import Statements\nDESCRIPTION: Migration of import statements from react-query to @tanstack/react-query namespace\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n- import { useQuery } from 'react-query'\n- import { ReactQueryDevtools } from 'react-query/devtools'\n\n+ import { useQuery } from '@tanstack/react-query'\n+ import { ReactQueryDevtools } from '@tanstack/react-query-devtools'\n```\n\n----------------------------------------\n\nTITLE: Non-Reactive Query Usage with Ref Creation\nDESCRIPTION: Showing the inconvenient pattern of having to create a ref for non-reactive queries when the composable only accepts Ref types.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/reactivity.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst { data: projects } = useUserProjects(ref('1'))\n```\n\n----------------------------------------\n\nTITLE: Injecting Infinite Query in Angular with CreateInfiniteQueryResult\nDESCRIPTION: This function injects an infinite query for asynchronous data loading. It supports additive loading or infinite scrolling. It takes a function returning query options and an optional Angular injector, returning a CreateInfiniteQueryResult.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectinfinitequery.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction injectInfiniteQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam,\n>(optionsFn, injector?): CreateInfiniteQueryResult<TData, TError>\n```\n\n----------------------------------------\n\nTITLE: Using Computed for Derived State in Queries\nDESCRIPTION: Using computed to create reactive derived state from props, ensuring the query updates when props change.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/reactivity.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst userId = computed(() => props.userId)\n\n// Reacts to changes in props.userId.\nconst { data: projects } = useUserProjects(userId)\n```\n\n----------------------------------------\n\nTITLE: Achieving Reactive Query Options with Writable and Derived Stores in Svelte - TypeScript\nDESCRIPTION: This code demonstrates how to make TanStack Query's options reactive by converting a plain interval variable into a Svelte writable store. It uses a derived store to construct the query options, ensuring that any changes in the input field update the query's 'refetchInterval' in real time. Key dependencies are '@tanstack/svelte-query', 'svelte/store', and Svelte's store reactivity. Inputs include a number field bound to the store; output is a reactively refetching query according to the updated interval.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reactivity.md#2025-04-23_snippet_1\n\nLANGUAGE: svelte\nCODE:\n```\n```svelte\\n<script lang=\\\"ts\\\">\\n  import { derived, writable } from 'svelte/store'\\n  import { createQuery } from '@tanstack/svelte-query'\\n\\n  const endpoint = 'http://localhost:5173/api/data'\\n\\n  const intervalMs = writable(1000)\\n\\n  const query = createQuery(\\n    derived(intervalMs, ($intervalMs) => ({\\n      queryKey: ['refetch'],\\n      queryFn: async () => await fetch(endpoint).then((r) => r.json()),\\n      refetchInterval: $intervalMs,\\n    })),\\n  )\\n</script>\\n\\n<input type=\\\"number\\\" bind:value={$intervalMs} />\\n```\n```\n\n----------------------------------------\n\nTITLE: Displaying Query Fetching and Status Indicators with Vue Query in Vue\nDESCRIPTION: This Vue component example exemplifies usage of the useQuery hook from @tanstack/vue-query to fetch 'todos' data. It conditionally displays UI based on query status flags like isPending, isFetching, isError, and leverages the returned error and data objects for detailed feedback. Dependencies include Vue 3 and @tanstack/vue-query. The component supports dynamic loading, error, and refreshing messaging through template logic, with expected outputs as rendered lists or status messages, depending on the data fetch state.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/background-fetching-indicators.md#2025-04-23_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\\nimport { useQuery } from '@tanstack/vue-query'\\n\\nconst { isPending, isFetching, isError, data, error } = useQuery({\\n  queryKey: ['todos'],\\n  queryFn: getTodos,\\n})\\n<\\/script>\\n\\n<template>\\n  <div v-if=\\\"isFetching\\\">Refreshing...<\\/div>\\n  <span v-if=\\\"isPending\\\">Loading...<\\/span>\\n  <span v-else-if=\\\"isError\\\">Error: {{ error.message }}<\\/span>\\n  <!-- We can assume by this point that `isSuccess === true` -->\\n  <ul v-else-if=\\\"data\\\">\\n    <li v-for=\\\"todo in data\\\" :key=\\\"todo.id\\\">{{ todo.title }}<\\/li>\\n  <\\/ul>\\n<\\/template>\n```\n\n----------------------------------------\n\nTITLE: Implementing Code Splitting and Dependent Queries with React.lazy and TanStack Query (TSX)\nDESCRIPTION: Demonstrates using React.lazy for code splitting in conjunction with TanStack Query for conditional fetching of additional data per feed item. This snippet shows a Feed component using useQuery to load initial feed data and dynamically loading the GraphFeedItem component only when necessary based on feedItem type. Dependencies include React, TanStack Query, and the presence of getFeed and getGraphDataById functions. The key inputs are the query key and result mappings; output consists of rendered feed items where certain items fetch additional data. The main limitation is that dependent fetches may cause request waterfalls.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-23_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n// This lazy loads the GraphFeedItem component, meaning\n// it wont start loading until something renders it\nconst GraphFeedItem = React.lazy(() => import('./GraphFeedItem'))\n\nfunction Feed() {\n  const { data, isPending } = useQuery({\n    queryKey: ['feed'],\n    queryFn: getFeed,\n  })\n\n  if (isPending) {\n    return 'Loading feed...'\n  }\n\n  return (\n    <>\n      {data.map((feedItem) => {\n        if (feedItem.type === 'GRAPH') {\n          return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />\n        }\n\n        return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />\n      })}\n    </>\n  )\n}\n\n// GraphFeedItem.tsx\nfunction GraphFeedItem({ feedItem }) {\n  const { data, isPending } = useQuery({\n    queryKey: ['graph', feedItem.id],\n    queryFn: getGraphDataById,\n  })\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Parallel Dependent Queries with useQueries in TanStack Query (TSX)\nDESCRIPTION: This snippet shows how to create dynamic parallel dependent queries using the useQueries hook. It first fetches user IDs, then uses those IDs to fetch messages for each user in parallel.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/dependent-queries.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// Get the users ids\nconst { data: userIds } = useQuery({\n  queryKey: ['users'],\n  queryFn: getUsersData,\n  select: (users) => users.map((user) => user.id),\n})\n\n// Then get the users messages\nconst usersMessages = useQueries({\n  queries: userIds\n    ? userIds.map((id) => {\n        return {\n          queryKey: ['messages', id],\n          queryFn: () => getMessagesByUsers(id),\n        }\n      })\n    : [], // if users is undefined, an empty array will be returned\n})\n```\n\n----------------------------------------\n\nTITLE: Using Enabled Option with Reactive Values\nDESCRIPTION: Using the enabled option with reactive values to conditionally control when a query executes based on derived state.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/reactivity.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport function useUserProjects(userId: MaybeRef<string>) {\n  return useQuery(\n    queryKey: ['userProjects', userId],\n    queryFn: () => api.fetchUserProjects(toValue(userId)),\n    enabled: () => userId.value === activeUserId.value,\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Discriminated Unions - Solid Query - TypeScript/TSX\nDESCRIPTION: Shows how type narrowing can be achieved using discriminated unions with the isSuccess property of the query state. Once isSuccess is true, data is guaranteed to be defined and can be used safely as type number. This is vital for safe result handling in UI logic.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/typescript.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nconst query = useQuery(() => ({\n  queryKey: ['number'],\n  queryFn: () => Promise.resolve(5),\n}))\n\nif (query.isSuccess) {\n  const data = query.data\n  //     ^? const data: number\n}\n\n```\n\n----------------------------------------\n\nTITLE: Batch Parallel User Queries with Computed and TanStack Query in Vue - JavaScript\nDESCRIPTION: This snippet shows how to use Vue's computed properties and TanStack Query's useQueries hook to execute multiple parallel user queries dynamically based on an array of users. The queries array is constructed by mapping over users.value and creating a query object for each user to fetch details by user.id. Dependencies include @tanstack/vue-query and Vue's reactivity system. Inputs are provided by the users array; each output is an object representing a parallel user query. This approach is flexible for scenarios where the number of parallel queries is data-driven.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/parallel-queries.md#2025-04-23_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst users = computed(...)\nconst queries = computed(() => users.value.map(user => {\n    return {\n      queryKey: ['user', user.id],\n      queryFn: () => fetchUserById(user.id),\n    }\n  })\n);\nconst userQueries = useQueries({queries: queries})\n```\n\n----------------------------------------\n\nTITLE: Type-Aware Data Access using Typed queryKey - Solid Query - TypeScript\nDESCRIPTION: Demonstrates that when using queryOptions to generate a queryKey, the types are preserved across uses. Using getQueryData with the typed queryKey yields properly inferred return types, maintaining type safety throughout the API. Without this, types would default to unknown.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/typescript.md#2025-04-23_snippet_10\n\nLANGUAGE: ts\nCODE:\n```\nfunction groupOptions() {\n  return queryOptions({\n    queryKey: ['groups'],\n    queryFn: fetchGroups,\n    staleTime: 5 * 1000,\n  })\n}\n\nconst data = queryClient.getQueryData(groupOptions().queryKey)\n//    ^? const data: Group[] | undefined\n\n```\n\n----------------------------------------\n\nTITLE: Initializing TanStack Query in Standalone Angular App\nDESCRIPTION: Configuration code for setting up TanStack Query in a standalone Angular application using provideTanStackQuery.\nSOURCE: https://github.com/tanstack/query/blob/main/packages/angular-query-experimental/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { provideTanStackQuery } from '@tanstack/angular-query-experimental'\nimport { QueryClient } from '@tanstack/angular-query-experimental'\n\nbootstrapApplication(AppComponent, {\n  providers: [provideTanStackQuery(new QueryClient())],\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Flexible Query Composable with MaybeRef in Vue\nDESCRIPTION: An improved query composable that accepts both plain values and refs using MaybeRef and toValue for better flexibility.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/reactivity.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport function useUserProjects(userId: MaybeRef<string>) {\n  return useQuery(\n    queryKey: ['userProjects', userId],\n    queryFn: () => api.fetchUserProjects(toValue(userId)),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Predicate Functions for Query Invalidation in TanStack Query\nDESCRIPTION: This example demonstrates using a predicate function with invalidateQueries for more granular control over which queries to invalidate. It allows for complex conditions based on query keys and other properties.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-invalidation.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nqueryClient.invalidateQueries({\n  predicate: (query) =>\n    query.queryKey[0] === 'todos' && query.queryKey[1]?.version >= 10,\n})\n\n// The query below will be invalidated\ntodoListQuery = injectQuery(() => ({\n  queryKey: ['todos', { version: 20 }],\n  queryFn: fetchTodoList,\n}))\n\n// The query below will be invalidated\ntodoListQuery = injectQuery(() => ({\n  queryKey: ['todos', { version: 10 }],\n  queryFn: fetchTodoList,\n}))\n\n// However, the following query below will NOT be invalidated\ntodoListQuery = injectQuery(() => ({\n  queryKey: ['todos', { version: 5 }],\n  queryFn: fetchTodoList,\n}))\n```\n\n----------------------------------------\n\nTITLE: Multiple Mutation Callbacks\nDESCRIPTION: Implementation showing how to handle multiple callbacks at both useMutation and mutate levels, demonstrating callback execution order.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nuseMutation({\n  mutationFn: addTodo,\n  onSuccess: (data, variables, context) => {\n    // I will fire first\n  },\n  onError: (error, variables, context) => {\n    // I will fire first\n  },\n  onSettled: (data, error, variables, context) => {\n    // I will fire first\n  },\n})\n\nmutate(todo, {\n  onSuccess: (data, variables, context) => {\n    // I will fire second!\n  },\n  onError: (error, variables, context) => {\n    // I will fire second!\n  },\n  onSettled: (data, error, variables, context) => {\n    // I will fire second!\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Event Listener for Online Status with React Native\nDESCRIPTION: Demonstrates how to use setEventListener to integrate with React Native's NetInfo for online/offline detection. This replaces the default browser-based event listeners with platform-specific connectivity monitoring.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/onlineManager.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport NetInfo from '@react-native-community/netinfo'\nimport { onlineManager } from '@tanstack/react-query'\n\nonlineManager.setEventListener((setOnline) => {\n  return NetInfo.addEventListener((state) => {\n    setOnline(!!state.isConnected)\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Defining CreateMutationOptions Type Alias for TanStack Query in TypeScript\nDESCRIPTION: Defines a generic TypeScript type alias, CreateMutationOptions, as a variant of MutationObserverOptions with the '_defaulted' property omitted, ensuring that consumers can specify options for use with createMutation without internal settings. The four type parameters (TData, TError, TVariables, TContext) make it suitable for different data, error, variable, and context types in mutation workflows. It requires access to the OmitKeyof utility and MutationObserverOptions type from TanStack Query, and is typically used for configuring mutation behavior in the Svelte version of TanStack Query. The alias does not introduce new runtime logic but serves as a type-level contract for mutation options.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/createmutationoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype CreateMutationOptions<TData, TError, TVariables, TContext>: OmitKeyof<MutationObserverOptions<TData, TError, TVariables, TContext>, \"_defaulted\">;\n```\n\n----------------------------------------\n\nTITLE: Data Equality Check Migration\nDESCRIPTION: Shows migration from isDataEqual to structuralSharing for custom data equality checks.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n import { replaceEqualDeep } from '@tanstack/react-query'\n\n- isDataEqual: (oldData, newData) => customCheck(oldData, newData) // [!code --]\n+ structuralSharing: (oldData, newData) => customCheck(oldData, newData) ? oldData : replaceEqualDeep(oldData, newData) // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Consuming Initial Data with createQuery in SvelteKit (Svelte)\nDESCRIPTION: A Svelte component that creates a query for 'posts' and hydrates it with initial data provided through the SvelteKit data contract. Uses createQuery from '@tanstack/svelte-query', and PageData type from SvelteKit. Input: data as PageData prop containing 'posts'; Output: a query object initialized with server-loaded posts, minimizing client fetches when the page is hydrated.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/ssr.md#2025-04-23_snippet_2\n\nLANGUAGE: svelte\nCODE:\n```\n<script>\\n  import { createQuery } from '@tanstack/svelte-query'\\n  import type { PageData } from './$types'\\n\\n  export let data: PageData\\n\\n  const query = createQuery({\\n    queryKey: ['posts'],\\n    queryFn: getPosts,\\n    initialData: data.posts,\\n  })\\n</script>\\n\n```\n\n----------------------------------------\n\nTITLE: Nesting Server Components with React Query\nDESCRIPTION: Demonstrates how to implement nested Server Components with React Query, showing prefetching data at different levels using multiple QueryClient instances.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n// app/posts/page.tsx\nimport {\n  dehydrate,\n  HydrationBoundary,\n  QueryClient,\n} from '@tanstack/react-query'\nimport Posts from './posts'\nimport CommentsServerComponent from './comments-server'\n\nexport default async function PostsPage() {\n  const queryClient = new QueryClient()\n\n  await queryClient.prefetchQuery({\n    queryKey: ['posts'],\n    queryFn: getPosts,\n  })\n\n  return (\n    <HydrationBoundary state={dehydrate(queryClient)}>\n      <Posts />\n      <CommentsServerComponent />\n    </HydrationBoundary>\n  )\n}\n\n// app/posts/comments-server.tsx\nimport {\n  dehydrate,\n  HydrationBoundary,\n  QueryClient,\n} from '@tanstack/react-query'\nimport Comments from './comments'\n\nexport default async function CommentsServerComponent() {\n  const queryClient = new QueryClient()\n\n  await queryClient.prefetchQuery({\n    queryKey: ['posts-comments'],\n    queryFn: getComments,\n  })\n\n  return (\n    <HydrationBoundary state={dehydrate(queryClient)}>\n      <Comments />\n    </HydrationBoundary>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Installing ESLint Plugin Query via Yarn (Bash)\nDESCRIPTION: Installs the recommended `@tanstack/eslint-plugin-query` as a development dependency using Yarn. This plugin helps lint React Query code according to TanStack guidelines.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/installation.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nyarn add -D @tanstack/eslint-plugin-query\n```\n\n----------------------------------------\n\nTITLE: Destructuring Query State Using useQuery in Solid Query (TypeScript/TSX)\nDESCRIPTION: This snippet demonstrates destructuring the data, status, error, and refetch state from the useQuery hook in Solid Query. It illustrates how to provide query options as a function that returns a configuration object, enabling reactive dependencies for the query. Required dependencies include @tanstack/solid-query and a SolidJS-compatible setup; key parameters allow customization of cache, lifecycle, and fetching behavior. Inputs consist of a query configuration object with options like queryKey and queryFn, and outputs provide tracked query status and result fields.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/reference/useQuery.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst {\n  data,\n  dataUpdatedAt,\n  error,\n  errorUpdatedAt,\n  failureCount,\n  failureReason,\n  fetchStatus,\n  isError,\n  isFetched,\n  isFetchedAfterMount,\n  isFetching,\n  isInitialLoading,\n  isLoading,\n  isLoadingError,\n  isPaused,\n  isPending,\n  isPlaceholderData,\n  isRefetchError,\n  isRefetching,\n  isStale,\n  isSuccess,\n  refetch,\n  status,\n} = useQuery(\n  () => ({\n    queryKey,\n    queryFn,\n    enabled,\n    select,\n    placeholderData,\n    deferStream,\n    reconcile,\n    gcTime,\n    networkMode,\n    initialData,\n    initialDataUpdatedAt,\n    meta,\n    queryKeyHashFn,\n    refetchInterval,\n    refetchIntervalInBackground,\n    refetchOnMount,\n    refetchOnReconnect,\n    refetchOnWindowFocus,\n    retry,\n    retryOnMount,\n    retryDelay,\n    staleTime,\n    throwOnError,\n  }),\n  () => queryClient,\n)\n```\n\n----------------------------------------\n\nTITLE: Maximum Pages Configuration\nDESCRIPTION: Configuration showing how to limit the maximum number of pages that can be fetched in an infinite query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/infinite-queries.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ninjectInfiniteQuery(() => ({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,\n  maxPages: 3,\n}))\n```\n\n----------------------------------------\n\nTITLE: Implementing Singleton QueryClient for Server Components\nDESCRIPTION: Shows how to create a single QueryClient instance that can be reused across Server Components using React's cache function.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n// app/getQueryClient.tsx\nimport { QueryClient } from '@tanstack/react-query'\nimport { cache } from 'react'\n\n// cache() is scoped per request, so we don't leak data between requests\nconst getQueryClient = cache(() => new QueryClient())\nexport default getQueryClient\n```\n\n----------------------------------------\n\nTITLE: Installing TanStack Query Storage Persister Dependencies\nDESCRIPTION: Various package manager commands to install the required dependencies for using the storage persister.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/createSyncStoragePersister.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client\n```\n\nLANGUAGE: bash\nCODE:\n```\nbun add @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client\n```\n\n----------------------------------------\n\nTITLE: Todo List Implementation Using Status Enum\nDESCRIPTION: Alternative implementation of Todo list component using status enum instead of boolean flags for state management.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/queries.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nfunction Todos() {\n  const { status, data, error } = useQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodoList,\n  })\n\n  if (status === 'pending') {\n    return <span>Loading...</span>\n  }\n\n  if (status === 'error') {\n    return <span>Error: {error.message}</span>\n  }\n\n  // also status === 'success', but \"else\" logic works, too\n  return (\n    <ul>\n      {data.map((todo) => (\n        <li key={todo.id}>{todo.title}</li>\n      ))}\n    </ul>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Query Remove Method Migration\nDESCRIPTION: Shows how to migrate from the removed query.remove() method to using queryClient.removeQueries().\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nconst queryClient = useQueryClient()\nconst query = useQuery({ queryKey, queryFn })\n\nquery.remove() // [!code --]\nqueryClient.removeQueries({ queryKey }) // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Resuming Paused Mutations\nDESCRIPTION: Shows how to resume mutations that were paused due to network connectivity issues.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_30\n\nLANGUAGE: tsx\nCODE:\n```\nqueryClient.resumePausedMutations()\n```\n\n----------------------------------------\n\nTITLE: Checking Mutation Status with isMutating\nDESCRIPTION: Demonstrates how to check if any mutations are currently fetching using the queryClient.isMutating() method which returns an integer count of active mutations.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_20\n\nLANGUAGE: tsx\nCODE:\n```\nif (queryClient.isMutating()) {\n  console.log('At least one mutation is fetching!')\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Imports for Renamed React Directory in TanStack Query\nDESCRIPTION: Demonstrates how to update import statements for TanStack Query components after the `src/react` directory was renamed to `src/reactjs` in v4 to avoid potential Jest configuration conflicts. The example specifically shows changing the import path for `QueryClientProvider`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_18\n\nLANGUAGE: tsx\nCODE:\n```\n- import { QueryClientProvider } from 'react-query/react'; // [!code --]\n+ import { QueryClientProvider } from '@tanstack/react-query/reactjs'; // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Mutation Callback Execution Order with Inline Callbacks\nDESCRIPTION: Shows the execution order when using both mutation-level callbacks and inline callbacks. Demonstrates how callbacks defined at mutation creation are fired first, followed by callbacks provided when calling mutate().\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-23_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nmutation = injectMutation(() => ({\n  mutationFn: addTodo,\n  onSuccess: (data, variables, context) => {\n    // I will fire first\n  },\n  onError: (error, variables, context) => {\n    // I will fire first\n  },\n  onSettled: (data, error, variables, context) => {\n    // I will fire first\n  },\n}))\n\nmutation.mutate(todo, {\n  onSuccess: (data, variables, context) => {\n    // I will fire second!\n  },\n  onError: (error, variables, context) => {\n    // I will fire second!\n  },\n  onSettled: (data, error, variables, context) => {\n    // I will fire second!\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring ESLint with TanStack Query recommended rules (Flat Config)\nDESCRIPTION: Setting up ESLint with all recommended TanStack Query rules using the modern flat config format in eslint.config.js.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/eslint-plugin-query.md#2025-04-23_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport pluginQuery from '@tanstack/eslint-plugin-query'\n\nexport default [\n  ...pluginQuery.configs['flat/recommended'],\n  // Any other config...\n]\n```\n\n----------------------------------------\n\nTITLE: Nested Component Waterfall Example\nDESCRIPTION: Demonstration of a nested component waterfall pattern and how to optimize it by hoisting queries to the parent component.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/request-waterfalls.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfunction Feed() {\n  const { data, isPending } = useQuery({\n    queryKey: ['feed'],\n    queryFn: getFeed,\n  })\n\n  if (isPending) {\n    return 'Loading feed...'\n  }\n\n  return (\n    <>\n      {data.map((feedItem) => {\n        if (feedItem.type === 'GRAPH') {\n          return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />\n        }\n\n        return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />\n      })}\n    </>\n  )\n}\n\nfunction GraphFeedItem({ feedItem }) {\n  const { data, isPending } = useQuery({\n    queryKey: ['graph', feedItem.id],\n    queryFn: getGraphDataById,\n  })\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Query Cancellation in TanStack Query\nDESCRIPTION: Demonstrates how to manually cancel queries using queryClient.cancelQueries method with a cancel button implementation.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-cancellation.md#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: async ({ signal }) => {\n    const resp = await fetch('/todos', { signal })\n    return resp.json()\n  },\n})\n\nconst queryClient = useQueryClient()\n\nreturn (\n  <button\n    onClick={(e) => {\n      e.preventDefault()\n      queryClient.cancelQueries({ queryKey: ['todos'] })\n    }}\n  >\n    Cancel\n  </button>\n)\n```\n\n----------------------------------------\n\nTITLE: Error Type Handling in Vue Query\nDESCRIPTION: Shows how to handle and narrow the type of the 'error' property. Initially typed as Ref<unknown>, it can be narrowed to Error using an instanceof check.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/typescript.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nconst { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })\n//      ^? const error: Ref<unknown>\n\nif (error.value instanceof Error) {\n  error.value\n  //     ^? const error: Error\n}\n```\n\n----------------------------------------\n\nTITLE: Memoizing Select Functions in useQuery Hooks (React Query, JavaScript)\nDESCRIPTION: These snippets show two techniques to prevent unnecessary select callback re-creation, ensuring that the select function reference remains stable between renders. The first example uses React's useCallback to memoize the callback, while the second extracts it as a standalone constant. Both approaches are important for preventing extra executions of the select logic and for optimizing React Query's performance. Requires react-query and React, as well as proper hook usage context.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/render-optimizations.md#2025-04-23_snippet_1\n\nLANGUAGE: js\nCODE:\n```\n// wrapped in useCallback\nexport const useTodoCount = () => {\n  return useTodos(useCallback((data) => data.length, []))\n}\n\n```\n\nLANGUAGE: js\nCODE:\n```\n// extracted to a stable function reference\nconst selectTodoCount = (data) => data.length\n\nexport const useTodoCount = () => {\n  return useTodos(selectTodoCount)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Lazy Loading and Conditional Querying with React Query in TypeScript\nDESCRIPTION: This TypeScript (TSX) snippet demonstrates how to lazy load a React component (GraphFeedItem) using React.lazy, then render queried data using useQuery from React Query. It fetches feed items and, for items of type 'GRAPH', further lazy loads and renders the GraphFeedItem component. The snippet highlights the performance drawback where queries inside lazily loaded components cause sequential (waterfall) fetching, which degrades rendering speed. It depends on React, React Query, and proper setup for data-fetching functions (getFeed, getGraphDataById, etc.). Props such as feedItem are key for correct per-item queries and rendering. The expected input is a list of feed items, and the output is a rendered feed with potential loading placeholders. The main limitation is the waterfall effect caused by separating data fetching logic into split bundles.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/request-waterfalls.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n// This lazy loads the GraphFeedItem component, meaning\n// it wont start loading until something renders it\nconst GraphFeedItem = React.lazy(() => import('./GraphFeedItem'))\n\nfunction Feed() {\n  const { data, isPending } = useQuery({\n    queryKey: ['feed'],\n    queryFn: getFeed,\n  })\n\n  if (isPending) {\n    return 'Loading feed...'\n  }\n\n  return (\n    <>\n      {data.map((feedItem) => {\n        if (feedItem.type === 'GRAPH') {\n          return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />\n        }\n\n        return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />\n      })}\n    </>\n  )\n}\n\n// GraphFeedItem.tsx\nfunction GraphFeedItem({ feedItem }) {\n  const { data, isPending } = useQuery({\n    queryKey: ['graph', feedItem.id],\n    queryFn: getGraphDataById,\n  })\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using Static Placeholder Data in TanStack Query with TypeScript\nDESCRIPTION: This snippet shows how to use static placeholder data in a TanStack Query. It sets up a query for todos with a static placeholderData property.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/placeholder-query-data.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nclass TodosComponent {\n  result = injectQuery(() => ({\n    queryKey: ['todos'],\n    queryFn: () => fetch('/todos'),\n    placeholderData: placeholderTodos,\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Optional initialData Property with Undefined Type\nDESCRIPTION: Declaration of the optional initialData property that is explicitly typed as undefined within the UndefinedInitialDataInfiniteOptions type.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/undefinedinitialdatainfiniteoptions.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\noptional initialData: undefined;\n```\n\n----------------------------------------\n\nTITLE: Defining initialData Property in DefinedInitialDataInfiniteOptions\nDESCRIPTION: This code defines the initialData property within the DefinedInitialDataInfiniteOptions type. It accepts either a direct non-undefined infinite data value or a function that returns such a value.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/definedinitialdatainfiniteoptions.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninitialData: NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>> | () => NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>;\n```\n\n----------------------------------------\n\nTITLE: Correct QueryClient implementation using useState in React component\nDESCRIPTION: This example shows a correct approach using useState to create a stable QueryClient instance that persists across renders. The initialization function ensures the client is only created once.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/stable-query-client.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nfunction App() {\n  const [queryClient] = useState(() => new QueryClient())\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Home />\n    </QueryClientProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Updated Import Paths for Persistence Plugins in v4\nDESCRIPTION: Illustrates the changes in import paths for `persistQueryClient` and storage persister functions (`createSyncStoragePersister`, `createAsyncStoragePersister`) in v4. This reflects their stable status (no longer experimental) and renaming (WebStorage -> SyncStorage).\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\n- import { persistQueryClient } from 'react-query/persistQueryClient-experimental' // [!code --]\n- import { createWebStoragePersistor } from 'react-query/createWebStoragePersistor-experimental' // [!code --]\n- import { createAsyncStoragePersistor } from 'react-query/createAsyncStoragePersistor-experimental' // [!code --]\n\n+ import { persistQueryClient } from '@tanstack/react-query-persist-client' // [!code ++]\n+ import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister' // [!code ++]\n+ import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'  // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Prefetching Infinite Query Data\nDESCRIPTION: Demonstrates how to prefetch and cache an infinite query using queryClient.prefetchInfiniteQuery.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nawait queryClient.prefetchInfiniteQuery({ queryKey, queryFn })\n```\n\n----------------------------------------\n\nTITLE: Illustrating Deterministic Hashing for Object Keys (TSX)\nDESCRIPTION: Shows that the order of keys within an object used in a query key does not affect the deterministic hash. `useQuery` treats keys with the same object properties (regardless of order, including `undefined` values) as identical for caching purposes. Depends on `useQuery`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-keys.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nuseQuery({ queryKey: ['todos', { status, page }], ... })\nuseQuery({ queryKey: ['todos', { page, status }], ...})\nuseQuery({ queryKey: ['todos', { page, status, other: undefined }], ... })\n```\n\n----------------------------------------\n\nTITLE: Basic Type Inference in Vue Query\nDESCRIPTION: Demonstrates automatic type inference for the 'data' property in a basic Vue Query hook. The TypeScript compiler infers the return type as Ref<number> | Ref<undefined>.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/typescript.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst { data } = useQuery({\n  //    ^? const data: Ref<number> | Ref<undefined>\n  queryKey: ['test'],\n  queryFn: () => Promise.resolve(5),\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a General Query Hook using Svelte Query (TypeScript)\nDESCRIPTION: This function overload provides a generic implementation of createQuery for use with custom query options. It makes use of the StoreOrVal-wrapped CreateQueryOptions type for the options parameter, allowing broad and flexible data fetching strategies. The function returns a CreateQueryResult object which encapsulates reactive query state, including loading, error, and data fields. It optionally depends on QueryClient to specify a caching context, and is suitable for most Svelte Query use cases that don‚Äôt require explicit initial data handling.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/createquery.md#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction createQuery<TQueryFnData, TError, TData, TQueryKey>(\n  options,\n  queryClient?,\n): CreateQueryResult<TData, TError>\n```\n\n----------------------------------------\n\nTITLE: Removing First Page from Infinite Query\nDESCRIPTION: Manual update to remove the first page from infinite query data\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nqueryClient.setQueryData(['projects'], (data) => ({\n  pages: data.pages.slice(1),\n  pageParams: data.pageParams.slice(1),\n}))\n```\n\n----------------------------------------\n\nTITLE: Prefetching Inside Query Function in TanStack Query (TypeScript/TSX)\nDESCRIPTION: Performs prefetching of related query data inside the main query function using `queryClient.prefetchQuery`, ensuring that whenever an article is fetched, its comments are also prefetched. Requires TanStack Query, a valid `useQueryClient` instance, and fetchers for article and comments. Accepts query arguments and passes them both to the prefetch and main query functions. This pattern assumes comments are often needed with articles for optimized UX.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nconst queryClient = useQueryClient()\nconst { data: articleData, isPending } = useQuery({\n  queryKey: ['article', id],\n  queryFn: (...args) => {\n    queryClient.prefetchQuery({\n      queryKey: ['article-comments', id],\n      queryFn: getArticleCommentsById,\n    })\n\n    return getArticleById(...args)\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Default AsyncStoragePersister Options\nDESCRIPTION: Default configuration options for the createAsyncStoragePersister function.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/createAsyncStoragePersister.md#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n{\n  key = `REACT_QUERY_OFFLINE_CACHE`,\n  throttleTime = 1000,\n  serialize = JSON.stringify,\n  deserialize = JSON.parse,\n}\n```\n\n----------------------------------------\n\nTITLE: Persister Options Interface\nDESCRIPTION: TypeScript interface defining the available options for createSyncStoragePersister.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/createSyncStoragePersister.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\ninterface CreateSyncStoragePersisterOptions {\n  /** The storage client used for setting an retrieving items from cache (window.localStorage or window.sessionStorage) */\n  storage: Storage | undefined | null\n  /** The key to use when storing the cache */\n  key?: string\n  /** To avoid spamming,\n   * pass a time in ms to throttle saving the cache to disk */\n  throttleTime?: number\n  /** How to serialize the data to storage */\n  serialize?: (client: PersistedClient) => string\n  /** How to deserialize the data from storage */\n  deserialize?: (cachedString: string) => PersistedClient\n  /** How to retry persistence on error **/\n  retry?: PersistRetryer\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Lazy Queries with Filter Condition\nDESCRIPTION: Shows how to create a lazy query that only executes when a filter value is present. The query is disabled until the filter has a value, demonstrating conditional query execution.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/disabling-queries.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nfunction Todos() {\n  const [filter, setFilter] = React.useState('')\n\n  const { data } = useQuery({\n    queryKey: ['todos', filter],\n    queryFn: () => fetchTodos(filter),\n    // ‚¨áÔ∏è disabled as long as the filter is empty\n    enabled: !!filter,\n  })\n\n  return (\n    <div>\n      // üöÄ applying the filter will enable and execute the query\n      <FiltersForm onApply={setFilter} />\n      {data && <TodosTable data={data} />}\n    </div>\n  )\n```\n\n----------------------------------------\n\nTITLE: Limited Infinite Query Configuration\nDESCRIPTION: Configuration for limiting the number of pages stored in infinite query data\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-23_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nuseInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,\n  maxPages: 3,\n})\n```\n\n----------------------------------------\n\nTITLE: Defining the useIsRestoring Function Signature in Svelte Query (TypeScript)\nDESCRIPTION: This TypeScript function signature defines `useIsRestoring`. It takes no arguments and returns a Svelte `Readable` store containing a boolean value. The boolean indicates whether the QueryClient is currently restoring its state from a persisted cache (e.g., during SSR hydration).\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/useisrestoring.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nfunction useIsRestoring(): Readable<boolean>\n```\n\n----------------------------------------\n\nTITLE: Dynamic Query Implementation with Posts Service\nDESCRIPTION: Advanced example showing dynamic query implementation with a Posts service and HTTP client integration.\nSOURCE: https://github.com/tanstack/query/blob/main/packages/angular-query-experimental/README.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n@Component({})\nexport class PostComponent {\n  #postsService = inject(PostsService)\n  postId = input.required({\n    transform: numberAttribute,\n  })\n\n  postQuery = injectQuery(() => ({\n    queryKey: ['post', this.postId()],\n    queryFn: () => {\n      return lastValueFrom(this.#postsService.postById$(this.postId()))\n    },\n  }))\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class PostsService {\n  #http = inject(HttpClient)\n\n  postById$ = (postId: number) =>\n    this.#http.get<Post>(`https://jsonplaceholder.typicode.com/posts/${postId}`)\n}\n\nexport interface Post {\n  id: number\n  title: string\n  body: string\n}\n```\n\n----------------------------------------\n\nTITLE: Type Inference with QueryClient Methods\nDESCRIPTION: Shows how queryOptions helps preserve type information when using QueryClient methods like getQueryData, which automatically infers the return type based on the query key.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-23_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\ndata = this.queryClient.getQueryData(groupOptions().queryKey)\n// ^? data: Post | undefined\n```\n\n----------------------------------------\n\nTITLE: Implementing Query Cancellation with Fetch API in TanStack Query\nDESCRIPTION: Demonstrates how to use AbortSignal with fetch API for cancellable queries. Shows passing the signal to both single and multiple fetch calls within the same query function.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-cancellation.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: async ({ signal }) => {\n    const todosResponse = await fetch('/todos', {\n      // Pass the signal to one fetch\n      signal,\n    })\n    const todos = await todosResponse.json()\n\n    const todoDetails = todos.map(async ({ details }) => {\n      const response = await fetch(details, {\n        // Or pass it to several\n        signal,\n      })\n      return response.json()\n    })\n\n    return Promise.all(todoDetails)\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using injectQuery with Query Keys for Caching in TanStack Query\nDESCRIPTION: Demonstrates using the injectQuery function with a query key of ['todos'] and a fetchTodos query function. This pattern is used throughout the caching example to illustrate how TanStack Query handles caching and data freshness.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/caching.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\ninjectQuery(() => ({ queryKey: ['todos'], queryFn: fetchTodos }))\n```\n\n----------------------------------------\n\nTITLE: Providing Prefetched QueryClient via Layout in SvelteKit (Svelte)\nDESCRIPTION: A Svelte component that wraps children in a QueryClientProvider, receiving the QueryClient via layout data (populated on the server). It requires the 'LayoutData' type and depends on QueryClientProvider from '@tanstack/svelte-query'. Input: data of type LayoutData with a QueryClient; Output: context is provided to all children for cached query usage.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/ssr.md#2025-04-23_snippet_4\n\nLANGUAGE: svelte\nCODE:\n```\n<script lang=\\\"ts\\\">\\n  import { QueryClientProvider } from '@tanstack/svelte-query'\\n  import type { LayoutData } from './$types'\\n\\n  export let data: LayoutData\\n</script>\\n\\n<QueryClientProvider client={data.queryClient}>\\n  <slot />\\n</QueryClientProvider>\\n\n```\n\n----------------------------------------\n\nTITLE: Basic Query Implementation in Angular\nDESCRIPTION: Shows the basic implementation of a query using injectQuery with a todo list fetch function.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/queries.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { injectQuery } from '@tanstack/angular-query-experimental'\n\nexport class TodosComponent {\n  info = injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchTodoList }))\n}\n```\n\n----------------------------------------\n\nTITLE: Prefetching Data with useQuery in a Vite SSR Component (HTML/JavaScript)\nDESCRIPTION: Shows how to use useQuery for prefetching in a Vite SSR component, leveraging onServerPrefetch to suspend the server-side render until the query resolves. The template includes a refetch button and displays prefetched data. This is written with <script setup> syntax and expects a data fetching function (getTodos). Inputs are useQuery props; outputs are data, refetch function, and seamless SSR-to-client data handoff. Relies on '@tanstack/vue-query' and Vue 3 composition API.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/ssr.md#2025-04-23_snippet_6\n\nLANGUAGE: html\nCODE:\n```\n<!-- MyComponent.vue -->\n<template>\n  <div>\n    <button @click=\"refetch\">Refetch</button>\n    <p>{{ data }}</p>\n  </div>\n</template>\n\n<script setup>\n  import { useQuery } from '@tanstack/vue-query'\n  import { onServerPrefetch } from 'vue'\n\n  // This will be prefetched and sent from the server\n  const { refetch, data, suspense } = useQuery({\n    queryKey: ['todos'],\n    queryFn: getTodos,\n  })\n\n  onServerPrefetch(suspense)\n</script>\n```\n\n----------------------------------------\n\nTITLE: Using useIsFetching Hook with React Query - TypeScript/React\nDESCRIPTION: Demonstrates how to use the useIsFetching hook from @tanstack/react-query in a React component to track the number of queries currently being fetched, both globally and for a specific query key (e.g., 'posts'). Requires installation of @tanstack/react-query and a QueryClientProvider in your app. Key parameter is an optional filters object, supporting fine-grained control of which queries are counted. Input is optional filters and output is a number indicating the current count of fetching queries. Intended for UI features such as global loading indicators.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/useIsFetching.md#2025-04-23_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useIsFetching } from '@tanstack/react-query'\n// How many queries are fetching?\nconst isFetching = useIsFetching()\n// How many queries matching the posts prefix are fetching?\nconst isFetchingPosts = useIsFetching({ queryKey: ['posts'] })\n```\n\n----------------------------------------\n\nTITLE: Implementing Component-level Fetching Indicators in Angular with TanStack Query\nDESCRIPTION: This component demonstrates how to display different states of a query including a background refreshing indicator during fetch operations. It uses TanStack Query's isPending(), isError(), isSuccess(), and isFetching() methods to conditionally render appropriate UI elements.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/background-fetching-indicators.md#2025-04-23_snippet_0\n\nLANGUAGE: angular-ts\nCODE:\n```\n@Component({\n  selector: 'todos',\n  template: `\n    @if (todosQuery.isPending()) {\n      Loading...\n    } @else if (todosQuery.isError()) {\n      An error has occurred: {{ todosQuery.error().message }}\n    } @else if (todosQuery.isSuccess()) {\n      @if (todosQuery.isFetching()) {\n        Refreshing...\n      }\n      @for (todos of todosQuery.data(); track todo.id) {\n        <todo [todo]=\"todo\" />\n      }\n    }\n  `,\n})\nclass TodosComponent {\n  todosQuery = injectQuery(() => ({\n    queryKey: ['todos'],\n    queryFn: fetchTodos,\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Basic React Query Hook\nDESCRIPTION: Example showing how to test a custom React Query hook using testing-library/react with QueryClientProvider wrapper.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { renderHook, waitFor } from '@testing-library/react'\n\nconst queryClient = new QueryClient()\nconst wrapper = ({ children }) => (\n  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n)\n\nconst { result } = renderHook(() => useCustomHook(), { wrapper })\n\nawait waitFor(() => expect(result.current.isSuccess).toBe(true))\n\nexpect(result.current.data).toEqual('Hello')\n```\n\n----------------------------------------\n\nTITLE: Wrapping Components with Suspense in solid-js (TypeScript)\nDESCRIPTION: Wraps a suspendable component with Solid's Suspense component to declaratively manage loading states. Uses the fallback property to render a loading spinner while child components are suspended. Requires solid-js and any referenced components (e.g., LoadingSpinner, SuspendableComponent). Expects child components to trigger suspense when performing async actions; fallback renders until resolved.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/guides/suspense.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Suspense } from 'solid-js'\\n;<Suspense fallback={<LoadingSpinner />}>\\n  <SuspendableComponent />\\n</Suspense>\n```\n\n----------------------------------------\n\nTITLE: Creating a Non-Reactive Query Composable in Vue\nDESCRIPTION: An example of a non-reactive query composable that won't update when referenced values change because it uses the value directly rather than the reactive reference.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/reactivity.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport function useUserProjects(userId: string) {\n  return useQuery(\n    queryKey: ['userProjects', userId],\n    queryFn: () => api.fetchUserProjects(userId),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Importance of Array Order in Query Keys (TSX)\nDESCRIPTION: Contrasts with object key hashing by showing that the order of elements within the top-level query key array *does* matter. Different arrangements of the same variables result in distinct query keys and separate cache entries when using `useQuery`. Depends on `useQuery`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-keys.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nuseQuery({ queryKey: ['todos', status, page], ... })\nuseQuery({ queryKey: ['todos', page, status], ...})\nuseQuery({ queryKey: ['todos', undefined, page, status], ...})\n```\n\n----------------------------------------\n\nTITLE: Type Inference with HttpClient in Angular\nDESCRIPTION: Demonstrates type inference when using HttpClient with injectQuery. The return type from HttpClient.get<Group[]> is properly passed through to the query result type.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-23_snippet_2\n\nLANGUAGE: angular-ts\nCODE:\n```\n@Component({\n  template: `@let data = query.data();`,\n  //               ^? data: Group[] | undefined\n})\nclass MyComponent {\n  http = inject(HttpClient)\n\n  query = injectQuery(() => ({\n    queryKey: ['groups'],\n    queryFn: () => lastValueFrom(this.http.get<Group[]>('/groups')),\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Forcing Devtools in Production Mode\nDESCRIPTION: Configuration to explicitly enable devtools in both development and production modes by setting loadDevtools to true.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/devtools.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nprovideTanStackQuery(\n  new QueryClient(),\n  withDevtools(() => ({ loadDevtools: true })),\n)\n```\n\n----------------------------------------\n\nTITLE: Custom Serialization and Deserialization with QueryClient - React Query - TypeScript\nDESCRIPTION: Modifies the QueryClient factory to enable custom serialization/deserialization for non-JSON data types across the server/client boundary using serialize (for dehydration) and deserialize (for hydration). This ensures consistent handling of custom JavaScript objects (e.g., Temporal datetime) in cached query results. Requires @tanstack/react-query and a transformer module exporting serialize and deserialize. Main parameters are serializeData and deserializeData, passed to dehydrate and hydrate options.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// app/get-query-client.ts\nimport { QueryClient, defaultShouldDehydrateQuery } from '@tanstack/react-query'\nimport { deserialize, serialize } from './transformer'\n\nfunction makeQueryClient() {\n  return new QueryClient({\n    defaultOptions: {\n      // ...\n      hydrate: {\n        deserializeData: deserialize,\n      },\n      dehydrate: {\n        serializeData: serialize,\n      },\n    },\n  })\n}\n\n// ...\n\n```\n\n----------------------------------------\n\nTITLE: Disabling Devtools\nDESCRIPTION: Configuration to completely disable devtools loading regardless of environment by setting loadDevtools to false.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/devtools.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nprovideTanStackQuery(\n  new QueryClient(),\n  withDevtools(() => ({ loadDevtools: false })),\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Query Hook with Dynamic Keys in TanStack Query (JavaScript)\nDESCRIPTION: This JavaScript snippet showcases a custom React hook `useTodos` built using TanStack Query's `useQuery`. It demonstrates how to create dynamic query keys by incorporating a variable (`todoId`) into the key array `['todos', todoId]`. The `queryFn` uses the `todoId.value` to fetch the specific todo item via `fetchTodoById`. This pattern ensures unique caching and refetching based on the `todoId`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/query-keys.md#2025-04-23_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nfunction useTodos(todoId) {\n  const queryKey = ['todos', todoId]\n  return useQuery({\n    queryKey,\n    queryFn: () => fetchTodoById(todoId.value),\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Prefetching of Dependent Queries Using TanStack Query's QueryClient (TSX)\nDESCRIPTION: Shows how to prefetch data for dependent queries inside a parent query function using QueryClient. In this Feed component, after fetching the feed list, it iterates through the results and for each 'GRAPH' feedItem type, prefetches associated graph data. Dependencies include QueryClient, useQuery, useQueryClient, and the required fetch functions. The inputs are the arguments passed to getFeed and the feed data objects; the output is cached data for downstream components. This approach loads code and data in parallel but increases parent bundle size.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-23_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nfunction Feed() {\n  const queryClient = useQueryClient()\n  const { data, isPending } = useQuery({\n    queryKey: ['feed'],\n    queryFn: async (...args) => {\n      const feed = await getFeed(...args)\n\n      for (const feedItem of feed) {\n        if (feedItem.type === 'GRAPH') {\n          queryClient.prefetchQuery({\n            queryKey: ['graph', feedItem.id],\n            queryFn: getGraphDataById,\n          })\n        }\n      }\n\n      return feed\n    }\n  })\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Providing TanStack Query Client in Angular (NgModule-based)\nDESCRIPTION: This snippet shows how to provide the TanStack Query client to an NgModule-based Angular application. It uses the provideTanStackQuery function in the providers array of the NgModule decorator.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/quick-start.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { provideHttpClient } from '@angular/common/http'\nimport {\n  provideTanStackQuery,\n  QueryClient,\n} from '@tanstack/angular-query-experimental'\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [BrowserModule],\n  providers: [provideTanStackQuery(new QueryClient())],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}\n```\n\n----------------------------------------\n\nTITLE: Auto-Loading Devtools Configuration\nDESCRIPTION: Explicitly configuring devtools to load automatically in development mode, which is equivalent to the default behavior when no loadDevtools option is specified.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/devtools.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nprovideTanStackQuery(new QueryClient(), withDevtools())\n\n// which is equivalent to\nprovideTanStackQuery(\n  new QueryClient(),\n  withDevtools(() => ({ loadDevtools: 'auto' })),\n)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Client-Side Request Waterfall\nDESCRIPTION: Shows the sequential waterfall of requests that occur with client-side rendering, where each step must complete before the next begins.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-23_snippet_13\n\nLANGUAGE: markdown\nCODE:\n```\n1. |> Markup (without content)\n2.   |> JS for <Feed>\n3.     |> getFeed()\n4.       |> JS for <GraphFeedItem>\n5.         |> getGraphDataById()\n```\n\n----------------------------------------\n\nTITLE: Using injectIsMutating Function in Angular with TanStack Query\nDESCRIPTION: A TypeScript function that injects a signal tracking the number of mutations currently fetching in an Angular application. It accepts optional filters to limit which mutations to track and an optional injector. Returns a signal with the count of fetching mutations.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectismutating.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction injectIsMutating(filters?, injector?): Signal<number>\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing Errors with axios - Solid Query - TypeScript/TSX\nDESCRIPTION: Demonstrates how to further narrow error types using axios.isAxiosError within type guards. Shows that error defaults to Error | null, but can be checked and cast to AxiosError. Requires both axios and @tanstack/solid-query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/typescript.md#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport axios from 'axios'\n\nconst query = useQuery(() => ({\n  queryKey: ['groups'],\n  queryFn: fetchGroups,\n}))\n\nquery.error\n//    ^? (property) error: Error | null\n\nif (axios.isAxiosError(query.error)) {\n  query.error\n  //    ^? (property) error: AxiosError\n}\n\n```\n\n----------------------------------------\n\nTITLE: Customizing scheduler behavior with setScheduler in Tanstack Query\nDESCRIPTION: The setScheduler method configures a custom callback that schedules when the next batch runs, with examples showing different timing approaches.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/notifyManager.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { notifyManager } from '@tanstack/react-query'\n\n// Schedule batches in the next microtask\nnotifyManager.setScheduler(queueMicrotask)\n\n// Schedule batches before the next frame is rendered\nnotifyManager.setScheduler(requestAnimationFrame)\n\n// Schedule batches some time in the future\nnotifyManager.setScheduler((cb) => setTimeout(cb, 10))\n```\n\n----------------------------------------\n\nTITLE: Defining CreateInfiniteQueryResult Type Alias in TypeScript\nDESCRIPTION: This TypeScript type alias `CreateInfiniteQueryResult` defines the structure of the result obtained from the `createInfiniteQuery` function. It is a generic type taking `TData` (defaulting to `unknown`) and `TError` (defaulting to `DefaultError`) as parameters. The type itself is an alias for `Readable<InfiniteQueryObserverResult<TData, TError>>`, indicating it's a Svelte readable store containing the observer result for an infinite query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/createinfinitequeryresult.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\ntype CreateInfiniteQueryResult<TData, TError>: Readable<InfiniteQueryObserverResult<TData, TError>>;\n```\n\n----------------------------------------\n\nTITLE: Typed Query Options Extraction using queryOptions - Solid Query - TypeScript\nDESCRIPTION: Shows how to use the queryOptions helper to extract query configuration into reusable functions for 'useQuery' and 'prefetchQuery'. This maintains full type inference rather than losing types when options are separated. Requires @tanstack/solid-query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/typescript.md#2025-04-23_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\nimport { queryOptions } from '@tanstack/solid-query'\n\nfunction groupOptions() {\n  return queryOptions({\n    queryKey: ['groups'],\n    queryFn: fetchGroups,\n    staleTime: 5 * 1000,\n  })\n}\n\nuseQuery(groupOptions)\nqueryClient.prefetchQuery(groupOptions())\n\n```\n\n----------------------------------------\n\nTITLE: Installing Angular Query with npm\nDESCRIPTION: Command to install the experimental Angular Query package using npm. This package is compatible with Angular v16 and higher but is currently in experimental stage.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/installation.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @tanstack/angular-query-experimental\n```\n\n----------------------------------------\n\nTITLE: Supplying Placeholder Data via Function - TanStack Query (TypeScript)\nDESCRIPTION: This code demonstrates how to use a function as the placeholderData property in useQuery, allowing access to the previous query's data and metadata for more dynamic placeholder logic. This is especially useful for paginated or dependent queries to maintain previous results as a placeholder during transitions. Dependencies include React, TanStack Query, and presence of previous data; the parameters include queryKey, queryFn, and a placeholderData function using previousData and previousQuery.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/placeholder-query-data.md#2025-04-23_snippet_2\n\nLANGUAGE: TSX\nCODE:\n```\nconst result = useQuery({\\n  queryKey: ['todos', id],\\n  queryFn: () => fetch(`/todos/${id}`),\\n  placeholderData: (previousData, previousQuery) => previousData,\\n})\n```\n\n----------------------------------------\n\nTITLE: useQueries Hook Migration\nDESCRIPTION: Example showing the new API format for useQueries hook\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n-useQueries([\n  { queryKey1, queryFn1, options1 },\n  { queryKey2, queryFn2, options2 },\n])\n+useQueries({\n  queries: [\n    { queryKey1, queryFn1, options1 },\n    { queryKey2, queryFn2, options2 },\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Restoring Persisted Cache with persistQueryClientRestore - TanStack Query - TypeScript\nDESCRIPTION: This function call example demonstrates restoring the cache from a persister using persistQueryClientRestore. Accepts options: queryClient, persister, maxAge (default 24 hours), buster, and hydrateOptions. Restores dehydrated cache as long as it is not older than maxAge and buster matches; otherwise, cache is discarded. Intended for manual cache reload at specific app lifecycle points.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/persistQueryClient.md#2025-04-23_snippet_4\n\nLANGUAGE: TSX\nCODE:\n```\npersistQueryClientRestore({\n  queryClient,\n  persister,\n  maxAge = 1000 * 60 * 60 * 24, // 24 hours\n  buster = '',\n  hydrateOptions = undefined,\n})\n```\n\n----------------------------------------\n\nTITLE: Initial Data with Custom Update Timestamp\nDESCRIPTION: Implements a query with initial data, extended stale time, and a custom timestamp for tracking when the initial data was last updated.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Show initialTodos immediately, but won't refetch until\n// another interaction event is encountered after 1000 ms\nresult = injectQuery(() => ({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n  staleTime: 60 * 1000, // 1 minute\n  // This could be 10 seconds ago or 10 minutes ago\n  initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052\n}))\n```\n\n----------------------------------------\n\nTITLE: Custom Error Typing via Generics - Solid Query - TypeScript/TSX\nDESCRIPTION: Shows how to provide a custom error type (string in this case) to useQuery by specifying it explicitly with a type parameter. Useful for non-Error error values, but disables inference for other generics. This is generally recommended only in special cases.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/typescript.md#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nconst query = useQuery<Group[], string>(() => ({\n  queryKey: ['groups'],\n  queryFn: fetchGroups,\n}))\n\nquery.error\n//    ^? (property) error: string | null\n\n```\n\n----------------------------------------\n\nTITLE: Core Methods of HydrationBoundary Svelte Component - TypeScript\nDESCRIPTION: Lists the key instance methods $capture_state(), $destroy(), $inject_state(), $on(), and $set() found on Svelte components. These methods control component lifecycle, event handling, type checking, and state management. Available for extension or use in Svelte components with TypeScript enabled. Proper usage requires familiarity with the Svelte runtime and its typed APIs.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/classes/hydrationboundary.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n$capture_state(): void\n```\n\nLANGUAGE: typescript\nCODE:\n```\n$destroy(): void\n```\n\nLANGUAGE: typescript\nCODE:\n```\n$inject_state(): void\n```\n\nLANGUAGE: typescript\nCODE:\n```\n$on<K>(type, callback): () => void\n```\n\nLANGUAGE: typescript\nCODE:\n```\n$set(props): void\n```\n\n----------------------------------------\n\nTITLE: Implementing Type-Safe GraphQL Queries with React Query and GraphQL Code Generator\nDESCRIPTION: This snippet demonstrates how to use React Query with graphql-request and GraphQL Code Generator to create fully-typed GraphQL operations. It includes a sample query for fetching film data with type-safe variables and response.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/graphql.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport request from 'graphql-request'\nimport { useQuery } from '@tanstack/react-query'\n\nimport { graphql } from './gql/gql'\n\nconst allFilmsWithVariablesQueryDocument = graphql(/* GraphQL */ `\n  query allFilmsWithVariablesQuery($first: Int!) {\n    allFilms(first: $first) {\n      edges {\n        node {\n          id\n          title\n        }\n      }\n    }\n  }\n`)\n\nfunction App() {\n  // `data` is fully typed!\n  const { data } = useQuery({\n    queryKey: ['films'],\n    queryFn: async () =>\n      request(\n        'https://swapi-graphql.netlify.app/.netlify/functions/index',\n        allFilmsWithVariablesQueryDocument,\n        // variables are type-checked too!\n        { first: 10 },\n      ),\n  })\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing Based on Query Status in TypeScript\nDESCRIPTION: Demonstrates type narrowing using the `isSuccess` status flag returned by `useQuery`. When `isSuccess` is true, TypeScript correctly narrows the type of `data` from `number | undefined` to just `number` within the conditional block.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nconst { data, isSuccess } = useQuery({\n  queryKey: ['test'],\n  queryFn: () => Promise.resolve(5),\n})\n\nif (isSuccess) {\n  data\n  //  ^? const data: number\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Current Online Status in TanStack Query\nDESCRIPTION: Shows how to use isOnline() to get the current online status. This can be used to conditionally render components or trigger behavior based on connectivity.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/onlineManager.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nconst isOnline = onlineManager.isOnline()\n```\n\n----------------------------------------\n\nTITLE: Deprecated Boolean Refetch Flags for invalidateQueries\nDESCRIPTION: Shows the previous boolean flags (`refetchActive`, `refetchInactive`) used in `queryClient.invalidateQueries` to control refetching behavior for active or inactive queries upon invalidation.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nrefetchActive: Boolean\n  - Defaults to true\n  - When set to false, queries that match the refetch predicate and are actively being rendered\n    via useQuery and friends will NOT be refetched in the background, and only marked as invalid.\nrefetchInactive: Boolean\n  - Defaults to false\n  - When set to true, queries that match the refetch predicate and are not being rendered\n    via useQuery and friends will be both marked as invalid and also refetched in the background\n```\n\n----------------------------------------\n\nTITLE: Registering Nuxt 2 Plugin in nuxt.config.js (JavaScript)\nDESCRIPTION: This snippet shows how to register the previously defined Vue Query plugin in a Nuxt 2 project. It adds the plugin file to the Nuxt configuration's plugins array, ensuring proper initialization on app startup. This is a minimal configuration change, has no parameters, and expects '~/plugins/vue-query.js' to exist. There are no outputs; it simply modifies app configuration to load the plugin.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/ssr.md#2025-04-23_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nmodule.exports = {\n  ...\n  plugins: ['~/plugins/vue-query.js'],\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CreateQueryResult Type Alias in TypeScript\nDESCRIPTION: This code defines a type alias named CreateQueryResult that extends CreateBaseQueryResult. It uses two generic type parameters: TData (defaulting to unknown) and TError (defaulting to DefaultError).\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/createqueryresult.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype CreateQueryResult<TData, TError>: CreateBaseQueryResult<TData, TError>;\n```\n\n----------------------------------------\n\nTITLE: Setting Query Defaults with setQueryDefaults\nDESCRIPTION: Demonstrates setting default options for specific queries, including setting a default queryFn.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_24\n\nLANGUAGE: tsx\nCODE:\n```\nqueryClient.setQueryDefaults(['posts'], { queryFn: fetchPosts })\n\nfunction Component() {\n  const { data } = useQuery({ queryKey: ['posts'] })\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Vue Query with yarn\nDESCRIPTION: Command to install Vue Query using yarn package manager.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/installation.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @tanstack/vue-query\n```\n\n----------------------------------------\n\nTITLE: Importing React Query Devtools in TypeScript\nDESCRIPTION: Code snippet showing how to import the ReactQueryDevtools component from the package.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/devtools.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools'\n```\n\n----------------------------------------\n\nTITLE: Consuming a Non-Reactive Query Composable in Vue\nDESCRIPTION: Example showing how a non-reactive query composable fails to update when the referenced value changes, as TanStack Query isn't tracking the ref object.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/reactivity.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Reactive user ID ref.\nconst userId = ref('1')\n// Fetches the user 1's projects.\nconst { data: projects } = useUserProjects(userId.value)\n\nconst onChangeUser = (newUserId: string) => {\n  // Edits the userId, but the query will not re-fetch.\n  userId.value = newUserId\n}\n```\n\n----------------------------------------\n\nTITLE: Using Component Props Directly (Non-Reactive Approach)\nDESCRIPTION: An example showing how directly using props in queries loses reactivity because property access on reactive variables breaks the reactive chain.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/reactivity.md#2025-04-23_snippet_7\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nconst props = defineProps<{\n  userId: string\n}>()\n</script>\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// Won't react to changes in props.userId.\nconst { data: projects } = useUserProjects(props.userId)\n```\n\n----------------------------------------\n\nTITLE: Defining InitialData Property Type in TypeScript\nDESCRIPTION: Specifies the type definition for the initialData property which can be either a direct value or a function returning a value, both ensuring non-undefined results through NonUndefinedGuard.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/definedinitialdataoptions.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninitialData: NonUndefinedGuard<TQueryFnData> | () => NonUndefinedGuard<TQueryFnData>;\n```\n\n----------------------------------------\n\nTITLE: Using SolidJS Signals within useQuery Options\nDESCRIPTION: Demonstrates passing SolidJS signals (created with `createSignal`) directly into the function arguments for `useQuery` options, such as `enabled` and `queryKey`. Solid Query automatically tracks these signals due to SolidJS's fine-grained reactivity. When the signal values change (e.g., toggling `enabled` or setting a `todo` ID), the query automatically updates its state or re-fetches data as needed. This example shows enabling/disabling a query and changing a query key based on signal values.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/quick-start.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  QueryClient,\n  QueryClientProvider,\n  useQuery,\n} from '@tanstack/solid-query'\nimport { createSignal, For } from 'solid-js'\n\nconst queryClient = new QueryClient()\n\nfunction Example() {\n  const [enabled, setEnabled] = createSignal(false)\n  const [todo, setTodo] = createSignal(0)\n\n  // ‚úÖ passing a signal directly is safe and observers update\n  // automatically when the value of a signal changes\n  const todosQuery = useQuery(() => ({\n    queryKey: ['todos'],\n    queryFn: fetchTodos,\n    enabled: enabled(),\n  }))\n\n  const todoDetailsQuery = useQuery(() => ({\n    queryKey: ['todo', todo()],\n    queryFn: fetchTodo,\n    enabled: todo() > 0,\n  }))\n\n  return (\n    <div>\n      <Switch>\n        <Match when={todosQuery.isPending}>\n          <p>Loading...</p>\n        </Match>\n        <Match when={todosQuery.isError}>\n          <p>Error: {todosQuery.error.message}</p>\n        </Match>\n        <Match when={todosQuery.isSuccess}>\n          <For each={todosQuery.data}>\n            {(todo) => (\n              <button onClick={() => setTodo(todo.id)}>{todo.title}</button>\n            )}\n          </For>\n        </Match>\n      </Switch>\n      <button onClick={() => setEnabled(!enabled())}>Toggle enabled</button>\n    </div>\n  )\n}\n\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Example />\n    </QueryClientProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Parallel Queries with useQueries in TanStack Query\nDESCRIPTION: Shows how to handle dynamic parallel queries using the useQueries hook. This approach is necessary when the number of queries changes between renders and allows for mapping over an array of items to create multiple queries.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/parallel-queries.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nfunction App({ users }) {\n  const userQueries = useQueries({\n    queries: users.map((user) => {\n      return {\n        queryKey: ['user', user.id],\n        queryFn: () => fetchUserById(user.id),\n      }\n    }),\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Prefetched Query Cache in SvelteKit Component (Svelte)\nDESCRIPTION: A Svelte component creating a query for 'posts' with a query function fetching from '/api/posts'. Thanks to prefetchQuery having been called server-side, no network request is issued on hydration as the data already exists in the QueryClient's cache. Dependencies: '@tanstack/svelte-query' and browser fetch; Input: none or context; Output: a query object pulling cached data immediately.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/ssr.md#2025-04-23_snippet_6\n\nLANGUAGE: svelte\nCODE:\n```\n<script lang=\\\"ts\\\">\\n  import { createQuery } from '@tanstack/svelte-query'\\n\\n  // This data is cached by prefetchQuery in +page.ts so no fetch actually happens here\\n  const query = createQuery({\\n    queryKey: ['posts'],\\n    queryFn: async () => (await fetch('/api/posts')).json(),\\n  })\\n</script>\\n\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Default Query Function with Axios in Vue (TypeScript)\nDESCRIPTION: This snippet defines an asynchronous default query function (`defaultQueryFn`) using `axios` to fetch data from a placeholder API based on the provided `queryKey`. It then demonstrates how to configure this function globally for all queries within a Vue application using `VueQueryPluginOptions` and `app.use(VueQueryPlugin)`. Finally, it shows how to use the `useQuery` hook by simply providing the `queryKey`, leveraging the configured default function. Dependencies include `axios` and `@tanstack/vue-query`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/default-query-function.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// Define a default query function that will receive the query key\nconst defaultQueryFn = async ({ queryKey }) => {\n  const { data } = await axios.get(\n    `https://jsonplaceholder.typicode.com${queryKey[0]}`,\n  )\n  return data\n}\n\n// provide the default query function to your app with defaultOptions\nconst vueQueryPluginOptions: VueQueryPluginOptions = {\n  queryClientConfig: {\n    defaultOptions: { queries: { queryFn: defaultQueryFn } },\n  },\n}\napp.use(VueQueryPlugin, vueQueryPluginOptions)\n\n// All you have to do now is pass a key!\nconst { status, data, error, isFetching } = useQuery({\n  queryKey: [`/posts/${postId}`],\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Query Implementation in Angular Component\nDESCRIPTION: Example of implementing a basic query in an Angular component using injectQuery.\nSOURCE: https://github.com/tanstack/query/blob/main/packages/angular-query-experimental/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { injectQuery } from '@tanstack/angular-query-experimental'\nimport { Component } from '@angular/core'\n\n@Component({...})\nexport class TodosComponent {\n  info = injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchTodoList }))\n}\n```\n\n----------------------------------------\n\nTITLE: Type Inference with Explicitly Typed queryFn in TypeScript\nDESCRIPTION: Illustrates improved type inference when using an explicitly typed `queryFn`. Defining `fetchGroups` to return `Promise<Group[]>` allows React Query to correctly infer `data` as `Group[] | undefined`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst fetchGroups = (): Promise<Group[]> =>\n  axios.get('/groups').then((response) => response.data)\n\nconst { data } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })\n//      ^? const data: Group[] | undefined\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Query Retry Settings in Angular\nDESCRIPTION: This snippet shows how to set up global retry configurations for all queries in an Angular application using TanStack Query. It demonstrates creating a QueryClient with default options for retry delay, which increases exponentially with each attempt up to a maximum of 30 seconds.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-retries.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  QueryCache,\n  QueryClient,\n  QueryClientProvider,\n} from '@tanstack/angular-query-experimental'\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),\n    },\n  },\n})\n\nbootstrapApplication(AppComponent, {\n  providers: [provideTanStackQuery(queryClient)],\n})\n```\n\n----------------------------------------\n\nTITLE: Fetching and Caching Query Data with Error Handling\nDESCRIPTION: Demonstrates how to use queryClient.fetchQuery to fetch and cache query data with proper error handling using try/catch blocks.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\ntry {\n  const data = await queryClient.fetchQuery({ queryKey, queryFn })\n} catch (error) {\n  console.log(error)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the CreateBaseMutationResult Type Alias (TypeScript)\nDESCRIPTION: This TypeScript type alias `CreateBaseMutationResult` defines the structure for base mutation results in TanStack Svelte Query. It overrides the `MutationObserverResult` from the core library and accepts generic type parameters for data (`TData`), error (`TError`), variables (`TVariables`), and context (`TContext`). This type forms the basis for the object returned by mutation hooks.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/createbasemutationresult.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype CreateBaseMutationResult<TData, TError, TVariables, TContext>: Override<MutationObserverResult<TData, TError, TVariables, TContext>, object> & object;\n```\n\n----------------------------------------\n\nTITLE: Defining CreateBaseQueryOptions Type Alias - TanStack Svelte Query - TypeScript\nDESCRIPTION: This snippet defines the CreateBaseQueryOptions type alias, which extends QueryObserverOptions with generic type parameters for fine-grained type safety in query configuration. It requires the QueryObserverOptions type and is designed for use within the TanStack Query Svelte integration. Parameters like TQueryFnData, TError, TData, TQueryData, and TQueryKey allow extensive customization for query handling, with defaults set for most types. This alias does not execute logic but establishes a typed contract for query option objects.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/createbasequeryoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype CreateBaseQueryOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>;\n```\n\n----------------------------------------\n\nTITLE: BroadcastQueryClient Interface Definition in TSX\nDESCRIPTION: TypeScript interface defining the options available for configuring broadcastQueryClient.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/broadcastQueryClient.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\ninterface BroadcastQueryClientOptions {\n  /** The QueryClient to sync */\n  queryClient: QueryClient\n  /** This is the unique channel name that will be used\n   * to communicate between tabs and windows */\n  broadcastChannel?: string\n  /** Options for the BroadcastChannel API */\n  options?: BroadcastChannelOptions\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Query Function Implementation in TypeScript/React\nDESCRIPTION: Example showing correct implementation where the query function properly returns the fetched data for caching.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/no-void-query-fn.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n/* eslint \"@tanstack/query/no-void-query-fn\": \"error\" */\nuseQuery({\n  queryKey: ['todos'],\n  queryFn: async () => {\n    const todos = await api.todos.fetch()\n    return todos\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Compression Example with lz-string\nDESCRIPTION: Example showing how to implement data compression using lz-string library with the persister.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/createSyncStoragePersister.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { QueryClient } from '@tanstack/react-query'\nimport { persistQueryClient } from '@tanstack/react-query-persist-client'\nimport { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister'\n\nimport { compress, decompress } from 'lz-string'\n\nconst queryClient = new QueryClient({\n  defaultOptions: { queries: { staleTime: Infinity } },\n})\n\npersistQueryClient({\n  queryClient: queryClient,\n  persister: createSyncStoragePersister({\n    storage: window.localStorage,\n    serialize: (data) => compress(JSON.stringify(data)),\n    deserialize: (data) => JSON.parse(decompress(data)),\n  }),\n  maxAge: Infinity,\n})\n```\n\n----------------------------------------\n\nTITLE: Checking Current Focus State in TanStack Query\nDESCRIPTION: Shows how to use the isFocused method to retrieve the current focus state.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/focusManager.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nconst isFocused = focusManager.isFocused()\n```\n\n----------------------------------------\n\nTITLE: Configuring VueQueryPlugin with QueryClientConfig (TypeScript)\nDESCRIPTION: Demonstrates how to configure the VueQueryPlugin using a QueryClientConfig object, allowing the plugin to internally instantiate and provide a QueryClient. This approach is suitable for cases when you don't need to create the QueryClient instance beforehand. The 'defaultOptions' field is used to specify global query configuration, such as query staleness. Required dependencies: Vue, Vue Query, and appropriate TypeScript interfaces. Inputs: a QueryClientConfig object; output: Vue app with a configured QueryClient.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/custom-client.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst vueQueryPluginOptions: VueQueryPluginOptions = {\n  queryClientConfig: {\n    defaultOptions: { queries: { staleTime: 3600 } },\n  },\n}\napp.use(VueQueryPlugin, vueQueryPluginOptions)\n```\n\n----------------------------------------\n\nTITLE: Installing Angular Query with pnpm\nDESCRIPTION: Command to install the experimental Angular Query package using pnpm. This package is compatible with Angular v16 and higher but is currently in experimental stage.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/installation.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @tanstack/angular-query-experimental\n```\n\n----------------------------------------\n\nTITLE: Using QueryClient with Custom Key in useQuery Hook (JavaScript)\nDESCRIPTION: Shows how to use the custom QueryClient key within the useQuery hook. By specifying 'queryClientKey' in the query options, you target a specific QueryClient context, enabling interactions with the intended client instance in scenarios where multiple contexts are present. Dependencies: Vue Query. Parameters include the query key, fetcher function, and custom client key. Input: an options object to useQuery; output: a query result bound to the selected QueryClient.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/custom-client.md#2025-04-23_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nuseQuery({\n  queryKey: ['query1'],\n  queryFn: fetcher,\n  queryClientKey: 'foo',\n})\n```\n\n----------------------------------------\n\nTITLE: JavaScript Codemod Command\nDESCRIPTION: Command to run the migration codemod for JavaScript/JSX files\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpx jscodeshift ./path/to/src/ \\\n  --extensions=js,jsx \\\n  --transform=./node_modules/@tanstack/react-query/codemods/v4/replace-import-specifier.js\n```\n\n----------------------------------------\n\nTITLE: Declaring the Optional 'filters' Property in MutationStateOptions (TypeScript)\nDESCRIPTION: This snippet shows the declaration of the optional `filters` property within the `MutationStateOptions` type. This property allows users to specify `MutationFilters` to narrow down which mutations are considered by `useMutationState`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/mutationstateoptions.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\noptional filters: MutationFilters;\n```\n\n----------------------------------------\n\nTITLE: Default Error Type Inference in useQuery (TypeScript)\nDESCRIPTION: Shows the default type inference for the `error` field returned by `useQuery`. By default, React Query assumes the error will be an instance of `Error`, so `error` is typed as `Error` (or `Error | null` depending on context/version).\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nconst { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })\n//      ^? const error: Error\n```\n\n----------------------------------------\n\nTITLE: Creating a Query Composable with MaybeRefOrGetter Support\nDESCRIPTION: An enhanced query composable that accepts refs, plain values, or reactive getters for maximum flexibility.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/reactivity.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport function useUserProjects(userId: MaybeRefOrGetter<string>) {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: PersistedClient Interface Definition - TanStack Query - TypeScript\nDESCRIPTION: Defines the structure of a persisted client entry as used by persisters. Contains timestamp, buster (for explicit invalidation), and cacheState (arbitrary data representing the cache). Used by the Persister methods for serialization/deserialization of QueryClient states.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/persistQueryClient.md#2025-04-23_snippet_9\n\nLANGUAGE: TSX\nCODE:\n```\nexport interface PersistedClient {\n  timestamp: number\n  buster: string\n  cacheState: any\n}\n```\n\n----------------------------------------\n\nTITLE: Defining injectQueries Function in TypeScript for TanStack Query Angular Integration\nDESCRIPTION: Function signature for injectQueries, which allows handling multiple queries in Angular applications. It accepts parameters for queries and an optional injector, and returns a Signal with the combined results of the queries.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectqueries.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction injectQueries<T, TCombinedResult>(\n  __namedParameters,\n  injector?,\n): Signal<TCombinedResult>\n```\n\n----------------------------------------\n\nTITLE: Querying Fetching State with useIsFetching Hook in TanStack Query - TypeScript\nDESCRIPTION: This TypeScript code defines the useIsFetching function, a hook that returns a Svelte Readable store of the number of currently fetching queries. It optionally accepts QueryFilters to limit the queries to be counted and an optional QueryClient to specify which query manager to use. The function is part of the TanStack Query Svelte integration and is useful for UI components that need to reactively respond to query state changes, such as displaying global loading indicators. It depends on TanStack Query's Svelte bindings and expects optional filters and a query client as input, returning a Readable<number> representing the count of active fetches.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/useisfetching.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction useIsFetching(filters?, queryClient?): Readable<number>\n```\n\n----------------------------------------\n\nTITLE: Defining CreateMutationOptions Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for CreateMutationOptions that extends MutationObserverOptions. It specifies four generic type parameters for handling data, errors, variables, and context in mutations.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/createmutationoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface CreateMutationOptions<TData, TError, TVariables, TContext> extends OmitKeyof<MutationObserverOptions<TData, TError, TVariables, TContext>, \"_defaulted\">\n```\n\n----------------------------------------\n\nTITLE: Overriding notify function with setNotifyFunction for React testing\nDESCRIPTION: The setNotifyFunction method allows overriding the default notify function, useful for test environments like wrapping notifications with React.act.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/notifyManager.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { notifyManager } from '@tanstack/react-query'\nimport { act } from 'react-dom/test-utils'\n\nnotifyManager.setNotifyFunction(act)\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with isSuccess in Vue Query\nDESCRIPTION: Demonstrates type narrowing using the 'isSuccess' flag. When 'isSuccess' is true, TypeScript narrows the 'data' type from Ref<number | undefined> to number.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/typescript.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nconst { data, isSuccess } = reactive(\n  useQuery({\n    queryKey: ['test'],\n    queryFn: () => Promise.resolve(5),\n  }),\n)\n\nif (isSuccess) {\n  data\n  // ^? const data: number\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Type Parameters for CreateBaseQueryOptions in TypeScript\nDESCRIPTION: This code block defines the type parameters for the CreateBaseQueryOptions interface, including default types and constraints for each parameter.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/createbasequeryoptions.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n‚Ä¢ **TQueryFnData** = `unknown`\n\n‚Ä¢ **TError** = `DefaultError`\n\n‚Ä¢ **TData** = `TQueryFnData`\n\n‚Ä¢ **TQueryData** = `TQueryFnData`\n\n‚Ä¢ **TQueryKey** _extends_ `QueryKey` = `QueryKey`\n```\n\n----------------------------------------\n\nTITLE: Invalidating Queries with TanStack Query\nDESCRIPTION: Shows how to invalidate and refetch queries using queryClient.invalidateQueries with various options.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\nawait queryClient.invalidateQueries(\n  {\n    queryKey: ['posts'],\n    exact,\n    refetchType: 'active',\n  },\n  { throwOnError, cancelRefetch },\n)\n```\n\n----------------------------------------\n\nTITLE: Defining React Query to Solid Query Hook Replacements (JavaScript)\nDESCRIPTION: This JavaScript object literal defines find-and-replace rules used to adapt React Query code examples for Solid Query within documentation. It maps the React Query package name and hook invocation patterns (like `useQuery(`, `useInfiniteQuery(`) to their Solid Query equivalents, typically involving wrapping the options argument in a getter function `() =>`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/guides/infinite-queries.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n{\n    '@tanstack/react-query': '@tanstack/solid-query',\n    'useMutationState[(]': 'useMutationState(() => ',\n    'useMutation[(]': 'useMutation(() => ',\n    'useQuery[(]': 'useQuery(() => ',\n    'useQueries[(]': 'useQueries(() => ',\n    'useInfiniteQuery[(]': 'useInfiniteQuery(() => ',\n  }\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using QueryCache in TanStack Query\nDESCRIPTION: Demonstrates how to import, initialize a QueryCache with callback options, and find a query from the cache. This example shows the basic setup including error, success, and settled callbacks.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryCache.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { QueryCache } from '@tanstack/react-query'\n\nconst queryCache = new QueryCache({\n  onError: (error) => {\n    console.log(error)\n  },\n  onSuccess: (data) => {\n    console.log(data)\n  },\n  onSettled: (data, error) => {\n    console.log(data, error)\n  },\n})\n\nconst query = queryCache.find(['posts'])\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Meta Types Globally - Solid Query - TypeScript\nDESCRIPTION: Shows how to register a global Meta type for query and mutation meta fields by augmenting the Register interface in the @tanstack/solid-query module. The custom Meta type (MyMeta) extends Record<string, unknown>, guaranteeing that meta objects remain type-safe and object structured.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/typescript.md#2025-04-23_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nimport '@tanstack/solid-query'\n\ninterface MyMeta extends Record<string, unknown> {\n  // Your meta type definition.\n}\n\ndeclare module '@tanstack/solid-query' {\n  interface Register {\n    queryMeta: MyMeta\n    mutationMeta: MyMeta\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Installing @tanstack/query-persist-client-core with yarn\nDESCRIPTION: Command to install the query-persist-client-core package using yarn package manager.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/plugins/createPersister.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @tanstack/query-persist-client-core\n```\n\n----------------------------------------\n\nTITLE: Creating batched function calls with batchCalls in Tanstack Query\nDESCRIPTION: The batchCalls higher-order function wraps a callback so that all calls to the wrapped function schedule the callback to run on the next batch.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/notifyManager.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype BatchCallsCallback<T extends Array<unknown>> = (...args: T) => void\n\nfunction batchCalls<T extends Array<unknown>>(\n  callback: BatchCallsCallback<T>,\n): BatchCallsCallback<T>\n```\n\n----------------------------------------\n\nTITLE: Type Parameters for CreateMutationOptions Interface\nDESCRIPTION: Definition of type parameters used in the CreateMutationOptions interface. It includes TData (default: unknown), TError (default: DefaultError), TVariables (default: void), and TContext (default: unknown).\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/createmutationoptions.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Type Parameters\n */\nTData = unknown\nTError = DefaultError\nTVariables = void\nTContext = unknown\n```\n\n----------------------------------------\n\nTITLE: Installing TanStack Solid Query via PNPM - Bash\nDESCRIPTION: Adds the @tanstack/solid-query package to your project using PNPM, an alternative JavaScript package manager. Ensure PNPM is installed on your system. The command makes the package available for import and use throughout your application.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/installation.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @tanstack/solid-query\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies and Running the TanStack Query Angular Example\nDESCRIPTION: Instructions for installing dependencies and starting the Angular application with TanStack Query integration. Multiple package manager options are provided including npm, yarn, pnpm, and bun.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/angular/rxjs/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install` or `yarn` or `pnpm i` or `bun i\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm run start` or `yarn start` or `pnpm start` or `bun start\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Logger via QueryClient Constructor in v4\nDESCRIPTION: Demonstrates the v4 approach for configuring a custom logger by passing it as an option (`logger`) to the `QueryClient` constructor. This replaces the removed global `setLogger` function from previous versions.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\n- import { QueryClient, setLogger } from 'react-query'; // [!code --]\n+ import { QueryClient } from '@tanstack/react-query'; // [!code ++]\n\n- setLogger(customLogger) // [!code --]\n- const queryClient = new QueryClient(); // [!code --]\n+ const queryClient = new QueryClient({ logger: customLogger }) // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Basic Query Usage Example\nDESCRIPTION: Demonstrates basic usage of useQuery hook in a Vue component to fetch data.\nSOURCE: https://github.com/tanstack/query/blob/main/packages/vue-query/README.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { defineComponent } from 'vue'\nimport { useQuery } from '@tanstack/vue-query'\n\nexport default defineComponent({\n  name: 'MyComponent',\n  setup() {\n    const query = useQuery({ queryKey: ['todos'], queryFn: getTodos })\n\n    return {\n      query,\n    }\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Registering Custom QueryClient Instance with VueQueryPlugin (TypeScript)\nDESCRIPTION: Shows how to create a QueryClient instance externally with a given configuration and register it with the VueQueryPlugin. This is useful when you need reusability or advanced setup, such as integrating with external tools or sharing the client outside the Vue context. The plugin option 'queryClient' receives the created instance directly. Required dependencies: Vue, Vue Query, QueryClient, and TypeScript types. Inputs: a QueryClient instance; outputs: a Vue app wired to the custom QueryClient.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/custom-client.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst myClient = new QueryClient(queryClientConfig)\nconst vueQueryPluginOptions: VueQueryPluginOptions = {\n  queryClient: myClient,\n}\napp.use(VueQueryPlugin, vueQueryPluginOptions)\n```\n\n----------------------------------------\n\nTITLE: Integrating VueQueryDevtools Component in Vue App (vue)\nDESCRIPTION: This snippet demonstrates how to import and place the VueQueryDevtools component as high as possible within your Vue application tree. It requires @tanstack/vue-query-devtools to be installed and assumes the use of Vue 3 with <script setup>. The devtools will be rendered as a floating UI overlay with persistent toggle state stored in localStorage, and the component can be configured using various props for panel position, open state, and more.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/devtools.md#2025-04-23_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { VueQueryDevtools } from '@tanstack/vue-query-devtools'\n</script>\n\n<template>\n  <h1>The app!</h1>\n  <VueQueryDevtools />\n</template>\n```\n\n----------------------------------------\n\nTITLE: Prefetching Infinite Queries with TanStack Query in TypeScript\nDESCRIPTION: This snippet shows how to prefetch multiple pages of an infinite query using `queryClient.prefetchInfiniteQuery`. It targets the 'projects' query key, uses `fetchProjects` for data fetching, and specifies `initialPageParam` to start. The `getNextPageParam` function determines the parameters for subsequent pages, and the `pages` option dictates how many pages (in this case, 3) should be prefetched sequentially. Prefetching stops if `getNextPageParam` returns `undefined`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/prefetching.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst prefetchProjects = async () => {\n  // The results of this query will be cached like a normal query\n  await queryClient.prefetchInfiniteQuery({\n    queryKey: ['projects'],\n    queryFn: fetchProjects,\n    initialPageParam: 0,\n    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n    pages: 3, // prefetch the first 3 pages\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Prefetching Multiple Pages with Infinite Query in TanStack Query (TypeScript/TSX)\nDESCRIPTION: Shows how to prefetch multiple pages using `queryClient.prefetchInfiniteQuery` with TanStack Query for React. Dependencies include TanStack Query and an active `queryClient`. Key parameters are `queryKey` (the unique identifier), `queryFn` (fetch function), `initialPageParam`, `getNextPageParam` (callback to retrieve the next page), and `pages` (number of pages to prefetch). The function prefetches and caches up to the specified number of pages; only the first page is prefetched by default, and returned output is a `Promise<void>`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst prefetchProjects = async () => {\n  // The results of this query will be cached like a normal query\n  await queryClient.prefetchInfiniteQuery({\n    queryKey: ['projects'],\n    queryFn: fetchProjects,\n    initialPageParam: 0,\n    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n    pages: 3, // prefetch the first 3 pages\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Query Function Variables and Context Usage\nDESCRIPTION: Illustrates how to access query key variables within query functions and handle complex query keys with multiple parameters.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-functions.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nfunction Todos({ status, page }) {\n  const result = useQuery({\n    queryKey: ['todos', { status, page }],\n    queryFn: fetchTodoList,\n  })\n}\n\n// Access the key, status and page variables in your query function!\nfunction fetchTodoList({ queryKey }) {\n  const [_key, { status, page }] = queryKey\n  return new Promise()\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Todo Addition Mutation in Angular with TanStack Query\nDESCRIPTION: This snippet demonstrates how to set up a mutation for adding a todo item using TanStack Query in Angular. It includes the mutation function and query invalidation on settlement.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/optimistic-updates.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\naddTodo = injectMutation(() => ({\n  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),\n  // make sure to _return_ the Promise from the query invalidation\n  // so that the mutation stays in `pending` state until the refetch is finished\n  onSettled: async () => {\n    return await queryClient.invalidateQueries({ queryKey: ['todos'] })\n  },\n}))\n```\n\n----------------------------------------\n\nTITLE: Invalidating Queries After Successful Mutation in TanStack Angular Query\nDESCRIPTION: A more complex example showing how to invalidate specific query keys ('todos' and 'reminders') after a mutation successfully completes using the onSuccess callback.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/invalidations-from-mutations.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  injectMutation,\n  QueryClient,\n} from '@tanstack/angular-query-experimental'\n\nexport class TodosComponent {\n  queryClient = inject(QueryClient)\n\n  // When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key\n  mutation = injectMutation(() => ({\n    mutationFn: addTodo,\n    onSuccess: () => {\n      this.queryClient.invalidateQueries({ queryKey: ['todos'] })\n      this.queryClient.invalidateQueries({ queryKey: ['reminders'] })\n    },\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Queries with TanStack Query\nDESCRIPTION: Shows how to remove queries from the cache using queryClient.removeQueries.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_17\n\nLANGUAGE: tsx\nCODE:\n```\nqueryClient.removeQueries({ queryKey, exact: true })\n```\n\n----------------------------------------\n\nTITLE: Data Ownership Example with React Query\nDESCRIPTION: Illustrates potential issues with data ownership when mixing Server and Client Components with React Query, specifically around data revalidation.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n// app/posts/page.tsx\nimport {\n  dehydrate,\n  HydrationBoundary,\n  QueryClient,\n} from '@tanstack/react-query'\nimport Posts from './posts'\n\nexport default async function PostsPage() {\n  const queryClient = new QueryClient()\n\n  // Note we are now using fetchQuery()\n  const posts = await queryClient.fetchQuery({\n    queryKey: ['posts'],\n    queryFn: getPosts,\n  })\n\n  return (\n    <HydrationBoundary state={dehydrate(queryClient)}>\n      {/* This is the new part */}\n      <div>Nr of posts: {posts.length}</div>\n      <Posts />\n    </HydrationBoundary>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Exact Query Key Matching for Invalidation in TypeScript\nDESCRIPTION: Demonstrates using the `exact: true` option with `invalidateQueries`. This ensures that only the query with the *exact* key `['todos']` is invalidated, excluding any queries that have additional elements in their keys, such as `['todos', { type: 'done' }]`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-invalidation.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nqueryClient.invalidateQueries({\n  queryKey: ['todos'],\n  exact: true,\n})\n\n// The query below will be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n})\n\n// However, the following query below will NOT be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { type: 'done' }],\n  queryFn: fetchTodoList,\n})\n```\n\n----------------------------------------\n\nTITLE: Object-Based Query Keys with Consistent Ordering\nDESCRIPTION: Examples showing how object-based query keys work with TanStack Query. All three queries are considered equivalent because TanStack Query stably stringifies objects in query keys, making the order of properties irrelevant.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-keys.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninjectQuery(() => ({ queryKey: ['todos', { status, page }], ... }))\ninjectQuery(() => ({ queryKey: ['todos', { page, status }], ...}))\ninjectQuery(() => ({ queryKey: ['todos', { page, status, other: undefined }], ... }))\n```\n\n----------------------------------------\n\nTITLE: Setting Multiple Queries Data with TanStack Query\nDESCRIPTION: Example of using queryClient.setQueriesData to update multiple queries simultaneously using filters.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nqueryClient.setQueriesData(filters, updater)\n```\n\n----------------------------------------\n\nTITLE: Leveraging `queryOptions` for Typed `getQueryData` (TypeScript)\nDESCRIPTION: Shows how the `queryKey` returned by `queryOptions` retains type information about the associated `queryFn`. This allows functions like `queryClient.getQueryData` to infer the correct data type (`Group[] | undefined`) without requiring explicit generics.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-23_snippet_11\n\nLANGUAGE: ts\nCODE:\n```\nfunction groupOptions() {\n  return queryOptions({\n    queryKey: ['groups'],\n    queryFn: fetchGroups,\n    staleTime: 5 * 1000,\n  })\n}\n\nconst data = queryClient.getQueryData(groupOptions().queryKey)\n//     ^? const data: Group[] | undefined\n```\n\n----------------------------------------\n\nTITLE: Implementing Focus-Based Query Subscription\nDESCRIPTION: Example component showing how to manage query subscriptions based on screen focus state using React Navigation's useIsFocused hook.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/react-native.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react'\nimport { useIsFocused } from '@react-navigation/native'\nimport { useQuery } from '@tanstack/react-query'\nimport { Text } from 'react-native'\n\nfunction MyComponent() {\n  const isFocused = useIsFocused()\n\n  const { dataUpdatedAt } = useQuery({\n    queryKey: ['key'],\n    queryFn: () => fetch(...),\n    subscribed: isFocused,\n  })\n\n  return <Text>DataUpdatedAt: {dataUpdatedAt}</Text>\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing useQuery Argument Syntax: React Query vs. Solid Query\nDESCRIPTION: Highlights a key difference in how arguments are passed to `useQuery` between React Query and Solid Query. In Solid Query, the options object must be wrapped in a function `() => ({ ... })` to enable SolidJS's reactivity tracking, ensuring that changes to dependencies (like the `todo` variable shown) trigger updates. The example contrasts the direct object passing in React Query (commented out) with the required function wrapper in Solid Query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/quick-start.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// ‚ùå react version\nuseQuery({\n  queryKey: ['todos', todo],\n  queryFn: fetchTodos,\n})\n\n// ‚úÖ solid version\nuseQuery(() => ({\n  queryKey: ['todos', todo],\n  queryFn: fetchTodos,\n}))\n```\n\n----------------------------------------\n\nTITLE: Installing @tanstack/query-persist-client-core with pnpm\nDESCRIPTION: Command to install the query-persist-client-core package using pnpm package manager.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/plugins/createPersister.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @tanstack/query-persist-client-core\n```\n\n----------------------------------------\n\nTITLE: Defining CreateQueryOptions Type Alias in TypeScript\nDESCRIPTION: This TypeScript type alias `CreateQueryOptions` defines the structure for the options object used with the `createQuery` function in `@tanstack/svelte-query`. It extends `CreateBaseQueryOptions` and accepts generics for the query function's return type (`TQueryFnData`), error type (`TError`), the transformed data type (`TData`), and the query key type (`TQueryKey`). Default types are provided for flexibility.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/createqueryoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey>: CreateBaseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>;\n```\n\n----------------------------------------\n\nTITLE: Installing Nuxt 3 Dependencies\nDESCRIPTION: Command to install project dependencies using Yarn package manager.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/vue/nuxt3/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn install\n```\n\n----------------------------------------\n\nTITLE: Using Flexible Query Composable with Different Value Types\nDESCRIPTION: Examples of using a flexible query composable with both plain values for non-reactive queries and refs for reactive queries.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/reactivity.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// Fetches the user 1's projects, userId is not expected to change.\nconst { data: projects } = useUserProjects('1')\n\n// Fetches the user 1's projects, queries will react to changes on userId.\nconst userId = ref('1')\n\n// Make some changes to userId...\n\n// Query re-fetches based on any changes to userId.\nconst { data: projects } = useUserProjects(userId)\n```\n\n----------------------------------------\n\nTITLE: Basic Infinite Query Component Implementation\nDESCRIPTION: Demonstrates a basic infinite query implementation with pagination controls, error handling, and loading states. Uses ProjectsService to fetch data with pagination parameters.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/infinite-queries.md#2025-04-23_snippet_0\n\nLANGUAGE: angular-ts\nCODE:\n```\nimport { Component, computed, inject } from '@angular/core'\nimport { injectInfiniteQuery } from '@tanstack/angular-query-experimental'\nimport { lastValueFrom } from 'rxjs'\nimport { ProjectsService } from './projects-service'\n\n@Component({\n  selector: 'example',\n  templateUrl: './example.component.html',\n})\nexport class Example {\n  projectsService = inject(ProjectsService)\n\n  query = injectInfiniteQuery(() => ({\n    queryKey: ['projects'],\n    queryFn: async ({ pageParam }) => {\n      return lastValueFrom(this.projectsService.getProjects(pageParam))\n    },\n    initialPageParam: 0,\n    getPreviousPageParam: (firstPage) => firstPage.previousId ?? undefined,\n    getNextPageParam: (lastPage) => lastPage.nextId ?? undefined,\n    maxPages: 3,\n  }))\n\n  nextButtonDisabled = computed(\n    () => !this.#hasNextPage() || this.#isFetchingNextPage(),\n  )\n  nextButtonText = computed(() =>\n    this.#isFetchingNextPage()\n      ? 'Loading more...'\n      : this.#hasNextPage()\n        ? 'Load newer'\n        : 'Nothing more to load',\n  )\n\n  #hasNextPage = this.query.hasNextPage\n  #isFetchingNextPage = this.query.isFetchingNextPage\n}\n```\n\n----------------------------------------\n\nTITLE: Defining injectQueryClient Function with Nullable Return in TypeScript\nDESCRIPTION: This snippet shows the function signature for injectQueryClient with InjectOptions parameter, which returns either null or a QueryClient instance.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectqueryclient.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfunction injectQueryClient(injectOptions): null | QueryClient\n```\n\n----------------------------------------\n\nTITLE: Ensuring Infinite Query Data with Parameters\nDESCRIPTION: Shows how to ensure infinite query data exists with parameters for pagination, fetching if necessary.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nconst data = await queryClient.ensureInfiniteQueryData({\n  queryKey,\n  queryFn,\n  initialPageParam,\n  getNextPageParam,\n})\n```\n\n----------------------------------------\n\nTITLE: Installing TanStack Solid Query via Bun - Bash\nDESCRIPTION: Copies the @tanstack/solid-query package into your project using Bun, a fast JavaScript runtime and package manager. Bun must be installed prior to using this command. This installation provides the package for direct import in your application's source code.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/installation.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbun add @tanstack/solid-query\n```\n\n----------------------------------------\n\nTITLE: Creating and Using InfiniteQueryObserver in TanStack Query\nDESCRIPTION: This example demonstrates how to create an InfiniteQueryObserver instance, configure it with query options, and subscribe to results. The observer is initialized with query key, query function, and pagination parameter functions for both forward and backward pagination.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/InfiniteQueryObserver.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst observer = new InfiniteQueryObserver(queryClient, {\n  queryKey: ['posts'],\n  queryFn: fetchPosts,\n  getNextPageParam: (lastPage, allPages) => lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, allPages) => firstPage.prevCursor,\n})\n\nconst unsubscribe = observer.subscribe((result) => {\n  console.log(result)\n  unsubscribe()\n})\n```\n\n----------------------------------------\n\nTITLE: Installing React Query via NPM (Bash)\nDESCRIPTION: Installs the `@tanstack/react-query` package using the Node Package Manager (NPM). This command downloads and adds the library to your project's dependencies.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/installation.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @tanstack/react-query\n```\n\n----------------------------------------\n\nTITLE: Dynamic Query Options Usage\nDESCRIPTION: Shows how to use reactive variables with useQuery for dynamic query updates.\nSOURCE: https://github.com/tanstack/query/blob/main/packages/vue-query/README.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nconst id = ref(1)\nconst enabled = ref(false)\n\nconst query = useQuery({\n  queryKey: ['todos', id],\n  queryFn: () => getTodos(id),\n  enabled,\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Data Package with Context in TanStack Query\nDESCRIPTION: Shows how to define a self-contained data package using TanStack Query v4's custom context feature. It involves creating a React context, a dedicated `QueryClient` instance, a custom hook (`useUser`) that specifies the context, and a provider component (`ContainerDataProvider`) that wraps children with `QueryClientProvider`, passing both the client and the custom context. This pattern isolates this data domain from others in the application.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_20\n\nLANGUAGE: tsx\nCODE:\n```\n// Our first data package: @my-scope/container-data\n\nconst context = React.createContext<QueryClient | undefined>(undefined)\nconst queryClient = new QueryClient()\n\nexport const useUser = () => {\n  return useQuery(USER_KEY, USER_FETCHER, {\n    context,\n  })\n}\n\nexport const ContainerDataProvider = ({\n  children,\n}: {\n  children: React.ReactNode\n}) => {\n  return (\n    <QueryClientProvider client={queryClient} context={context}>\n      {children}\n    </QueryClientProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling in Query Functions\nDESCRIPTION: Shows how to handle errors in query functions by either throwing an Error directly or using Promise.reject to return a rejected promise.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-functions.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntodos = injectQuery(() => ({\n  queryKey: ['todos', todoId()],\n  queryFn: async () => {\n    if (somethingGoesWrong) {\n      throw new Error('Oh no!')\n    }\n    if (somethingElseGoesWrong) {\n      return Promise.reject(new Error('Oh no!'))\n    }\n\n    return data\n  },\n}))\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for TanStack Query Angular Example\nDESCRIPTION: Commands to install project dependencies using different package managers (npm, yarn, pnpm, or bun).\nSOURCE: https://github.com/tanstack/query/blob/main/examples/angular/basic-persister/README.md#2025-04-23_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install\n```\n\nLANGUAGE: Shell\nCODE:\n```\nyarn\n```\n\nLANGUAGE: Shell\nCODE:\n```\npnpm i\n```\n\nLANGUAGE: Shell\nCODE:\n```\nbun i\n```\n\n----------------------------------------\n\nTITLE: injectQueries Development Status for Angular Query\nDESCRIPTION: This snippet indicates that the injectQueries function is currently under development for Angular Query. It suggests that this feature is not yet available or fully implemented in the Angular version of TanStack Query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/dependent-queries.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// injectQueries is under development for Angular Query\n```\n\n----------------------------------------\n\nTITLE: Defining CreateMutationResult Type Alias in TypeScript\nDESCRIPTION: Type alias that combines BaseMutationNarrowing with mapped signals from the state. Used to represent the result of a mutation operation in TanStack Query with appropriate type narrowing.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/createmutationresult.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype CreateMutationResult<TData, TError, TVariables, TContext, TState>: BaseMutationNarrowing<TData, TError, TVariables, TContext> & MapToSignals<OmitKeyof<TState, keyof BaseMutationNarrowing, \"safely\">>;\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Query Retry Delays\nDESCRIPTION: Shows how to set up global retry delay configuration using QueryClient. Implements an exponential backoff strategy with a maximum delay of 30 seconds.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-retries.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// Configure for all queries\nimport {\n  QueryCache,\n  QueryClient,\n  QueryClientProvider,\n} from '@tanstack/react-query'\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),\n    },\n  },\n})\n\nfunction App() {\n  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Mutation Defaults and Persistence with TanStack Query - JavaScript\nDESCRIPTION: This JavaScript example demonstrates how to configure a QueryClient with default mutation and query options using TanStack Query. It sets a default mutation function for 'todos', integrates state persistence using a custom persister backed by localStorage, and defines how to resume paused mutations after reloads. Dependencies include TanStack Query, VueQueryPlugin, and a persistence utility such as createSyncStoragePersister. The inputs are configuration objects and a Vue app instance, with output being an app instance with robust query state management.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/mutations.md#2025-04-23_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nconst client = new QueryClient({\\n  defaultOptions: {\\n    queries: {\\n      gcTime: 1000 * 60 * 60 * 24, // 24 hours\\n    },\\n  },\\n})\\n\\n// we need a default mutation function so that paused mutations can resume after a page reload\\nqueryClient.setMutationDefaults({\\n  mutationKey: ['todos'],\\n  mutationFn: ({ id, data }) => {\\n    return api.updateTodo(id, data)\\n  },\\n})\\n\\nconst vueQueryOptions: VueQueryPluginOptions = {\\n  queryClient: client,\\n  clientPersister: (queryClient) => {\\n    return persistQueryClient({\\n      queryClient,\\n      persister: createSyncStoragePersister({ storage: localStorage }),\\n    })\\n  },\\n  clientPersisterOnSuccess: (queryClient) => {\\n    queryClient.resumePausedMutations()\\n  },\\n}\\n\\ncreateApp(App).use(VueQueryPlugin, vueQueryOptions).mount('#app')\n```\n\n----------------------------------------\n\nTITLE: Using Fetch with AbortSignal in TanStack Query\nDESCRIPTION: This example shows how to use the fetch API with TanStack Query's AbortSignal. The signal is passed to both the initial fetch request and subsequent detail requests, enabling automatic cancellation when the query becomes inactive.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-cancellation.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nquery = injectQuery(() => ({\n  queryKey: ['todos'],\n  queryFn: async ({ signal }) => {\n    const todosResponse = await fetch('/todos', {\n      // Pass the signal to one fetch\n      signal,\n    })\n    const todos = await todosResponse.json()\n\n    const todoDetails = todos.map(async ({ details }) => {\n      const response = await fetch(details, {\n        // Or pass it to several\n        signal,\n      })\n      return response.json()\n    })\n\n    return Promise.all(todoDetails)\n  },\n}))\n```\n\n----------------------------------------\n\nTITLE: Using Cached Data as Placeholder - TanStack Query (TypeScript)\nDESCRIPTION: This example illustrates using cached data from another query as placeholderData within useQuery. By referencing useQueryClient and searching cached data for a preview object, the query can start with meaningful preloaded values pertaining to the specific blogPostId. Dependencies include React, TanStack Query, and a populated query cache; parameters key off blogPostId, and the output is a query result with initial placeholder content if found in the cache.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/placeholder-query-data.md#2025-04-23_snippet_3\n\nLANGUAGE: TSX\nCODE:\n```\nfunction Todo({ blogPostId }) {\\n  const queryClient = useQueryClient()\\n  const result = useQuery({\\n    queryKey: ['blogPost', blogPostId],\\n    queryFn: () => fetch(`/blogPosts/${blogPostId}`),\\n    placeholderData: () => {\\n      // Use the smaller/preview version of the blogPost from the 'blogPosts'\\n      // query as the placeholder data for this blogPost query\\n      return queryClient\\n        .getQueryData(['blogPosts'])\\n        ?.find((d) => d.id === blogPostId)\\n    },\\n  })\\n}\n```\n\n----------------------------------------\n\nTITLE: Parameterized Query Keys in TanStack Query\nDESCRIPTION: Examples of query keys with additional parameters. Shows how to structure keys for querying individual items by ID, applying filters like preview modes, and querying lists with specific criteria.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-keys.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// An individual todo\ninjectQuery(() => ({queryKey: ['todo', 5], ...}))\n\n// An individual todo in a \"preview\" format\ninjectQuery(() => ({queryKey: ['todo', 5, {preview: true}], ...}))\n\n// A list of todos that are \"done\"\ninjectQuery(() => ({queryKey: ['todos', {type: 'done'}], ...}))\n```\n\n----------------------------------------\n\nTITLE: Using Memoized Placeholder Data in TanStack Query with TypeScript\nDESCRIPTION: This example demonstrates using a function for placeholderData to memoize the placeholder based on previous data and query. It's useful for dynamic queries where the ID changes.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/placeholder-query-data.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nclass TodosComponent {\n  result = injectQuery(() => ({\n    queryKey: ['todos', id()],\n    queryFn: () => fetch(`/todos/${id}`),\n    placeholderData: (previousData, previousQuery) => previousData,\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing useQuery with Static Placeholder Data in React Query (TypeScript)\nDESCRIPTION: This snippet demonstrates how to provide a static placeholder value via the placeholderData option when using the useQuery hook from React Query in a TypeScript React application. It depends on having a properly configured React Query setup and assumes that placeholderTodos contains the shape of expected data. The key parameters include queryKey (for cache identity), queryFn (asynchronous function returning data), and placeholderData (the fallback data shown until the actual fetch completes). The output, result, represents the current query state including placeholder content if data loading is in progress.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/placeholder-query-data.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  placeholderData: placeholderTodos,\n})\n```\n\n----------------------------------------\n\nTITLE: Using Query Filters in TanStack Query\nDESCRIPTION: Examples of using QueryFilters for canceling, removing, and refetching queries with different filter conditions. Shows how to filter queries based on query keys and types.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/filters.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// Cancel all queries\nawait queryClient.cancelQueries()\n\n// Remove all inactive queries that begin with `posts` in the key\nqueryClient.removeQueries({ queryKey: ['posts'], type: 'inactive' })\n\n// Refetch all active queries\nawait queryClient.refetchQueries({ type: 'active' })\n\n// Refetch all active queries that begin with `posts` in the key\nawait queryClient.refetchQueries({ queryKey: ['posts'], type: 'active' })\n```\n\n----------------------------------------\n\nTITLE: Configuring Window Focus Refetching in Vue Query\nDESCRIPTION: This snippet shows how to configure the Vue Query plugin to disable automatic refetching of queries when the window regains focus. The setting is applied globally by setting refetchOnWindowFocus to false in the queryClientConfig's defaultOptions.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/window-focus-refetching.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst vueQueryPluginOptions: VueQueryPluginOptions = {\n  queryClientConfig: {\n    defaultOptions: {\n      queries: {\n        refetchOnWindowFocus: false,\n      },\n    },\n  },\n}\napp.use(VueQueryPlugin, vueQueryPluginOptions)\n```\n\n----------------------------------------\n\nTITLE: Implementing App Focus Management\nDESCRIPTION: Sets up app focus management using React Native's AppState to trigger query updates when the app becomes active.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/react-native.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useEffect } from 'react'\nimport { AppState, Platform } from 'react-native'\nimport type { AppStateStatus } from 'react-native'\nimport { focusManager } from '@tanstack/react-query'\n\nfunction onAppStateChange(status: AppStateStatus) {\n  if (Platform.OS !== 'web') {\n    focusManager.setFocused(status === 'active')\n  }\n}\n\nuseEffect(() => {\n  const subscription = AppState.addEventListener('change', onAppStateChange)\n\n  return () => subscription.remove()\n}, [])\n```\n\n----------------------------------------\n\nTITLE: Defining DefinedInitialDataInfiniteOptions Type Alias in TypeScript\nDESCRIPTION: This type alias extends CreateInfiniteQueryOptions to specify options for infinite queries with guaranteed non-undefined initial data. It includes type parameters for query function data, error handling, data structure, query key, and page parameters.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/definedinitialdatainfiniteoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype DefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>: CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey, TPageParam> & object;\n```\n\n----------------------------------------\n\nTITLE: Controlling Re-renders with notifyOnChangeProps in React Query (TSX)\nDESCRIPTION: Shows how to use the `notifyOnChangeProps` option within `useQuery` to specify that the component should only re-render when the `data` or `error` properties of the query result change. This helps optimize performance by avoiding unnecessary re-renders based on other property changes like `isFetching`. Requires React Query v3 and the `useQuery` hook.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQuery } from 'react-query'\n\nfunction User() {\n  const { data } = useQuery(['user'], fetchUser, {\n    notifyOnChangeProps: ['data', 'error'],\n  })\n  return <div>Username: {data.username}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using QueryObserver in TanStack Query\nDESCRIPTION: This example demonstrates how to create a QueryObserver instance, subscribe to query results, and properly unsubscribe. The observer is initialized with a queryClient and options containing a queryKey for 'posts'.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryObserver.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst observer = new QueryObserver(queryClient, { queryKey: ['posts'] })\n\nconst unsubscribe = observer.subscribe((result) => {\n  console.log(result)\n  unsubscribe()\n})\n```\n\n----------------------------------------\n\nTITLE: Importing TanStack Solid Query via CDN (ESM) - HTML\nDESCRIPTION: Demonstrates including the @tanstack/solid-query library directly from an ESM-compatible CDN using a <script type=\\\"module\\\"> tag. No local installation or bundler/packager is necessary. The QueryClient instance is available from the CDN import, suitable for rapid prototyping or embedding in static HTML files. Requires a modern browser supporting ES modules.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/installation.md#2025-04-23_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<script type=\\\"module\\\">\\n  import { QueryClient } from 'https://esm.sh/@tanstack/solid-query'\\n</script>\n```\n\n----------------------------------------\n\nTITLE: Installing Testing Dependencies for React Query\nDESCRIPTION: Command to install required testing libraries for React Query hooks testing with React 17 or earlier.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install @testing-library/react-hooks react-test-renderer --save-dev\n```\n\n----------------------------------------\n\nTITLE: Reactive Query Keys with Signals in TanStack Query\nDESCRIPTION: Example of using reactive signals with query keys. The query is conditionally enabled based on the todoId signal value and uses that same signal as part of the query key and in the queryFn.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-keys.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ntodoId = signal(-1)\n\ninjectQuery(() => ({\n  enabled: todoId() > 0,\n  queryKey: ['todos', todoId()],\n  queryFn: () => fetchTodoById(todoId()),\n}))\n```\n\n----------------------------------------\n\nTITLE: Running Development Server with Package Managers\nDESCRIPTION: Commands for starting the development server using different package managers (npm, yarn, or pnpm).\nSOURCE: https://github.com/tanstack/query/blob/main/examples/vue/2.7-basic/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm run dev\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn dev\n```\n\nLANGUAGE: shell\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Configuring ESLint with TanStack Query recommended rules (Legacy Config)\nDESCRIPTION: Setting up ESLint with all recommended TanStack Query rules using the legacy configuration format in .eslintrc.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/eslint-plugin-query.md#2025-04-23_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"extends\": [\"plugin:@tanstack/query/recommended\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Observing Single Query State with QueryObserver in React Query Core (TSX)\nDESCRIPTION: Shows how to use the `QueryObserver` class from React Query's core library (v3 onwards) to programmatically monitor the state of a single query (identified by `queryKey: 'posts'`). It demonstrates creating an observer instance with a `queryClient`, subscribing to receive updates, logging the result, and unsubscribing to clean up. Requires `QueryObserver` and `QueryClient` from React Query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\nconst observer = new QueryObserver(queryClient, { queryKey: 'posts' })\n\nconst unsubscribe = observer.subscribe((result) => {\n  console.log(result)\n  unsubscribe()\n})\n```\n\n----------------------------------------\n\nTITLE: Importing Svelte Query Devtools Component (TypeScript)\nDESCRIPTION: Shows how to import the `SvelteQueryDevtools` component from the installed `@tanstack/svelte-query-devtools` package. This import is necessary to use the devtools within a Svelte application.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/devtools.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SvelteQueryDevtools } from '@tanstack/svelte-query-devtools'\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Options in QueryClient\nDESCRIPTION: Demonstrates setting default options for queries and mutations in the QueryClient configuration.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      // query options\n    },\n    mutations: {\n      // mutation options\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Default Error Typing in useQuery - Solid Query - TypeScript/TSX\nDESCRIPTION: Illustrates that, by default, the error property in query results from useQuery is typed as Error | null. The snippet references fetchGroups as a dependency and shows how error handling integrates with expected error object conformity.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/typescript.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nconst query = useQuery(() => ({\n  queryKey: ['groups'],\n  queryFn: fetchGroups,\n}))\n\nquery.error\n//    ^? (property) error: Error | null\n\n```\n\n----------------------------------------\n\nTITLE: Testing Network Calls with Nock\nDESCRIPTION: Example of testing React Query network calls using nock for API mocking.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst queryClient = new QueryClient()\nconst wrapper = ({ children }) => (\n  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n)\n\nconst expectation = nock('http://example.com').get('/api/data').reply(200, {\n  answer: 42,\n})\n\nconst { result } = renderHook(() => useFetchData(), { wrapper })\n\nawait waitFor(() => expect(result.current.isSuccess).toBe(true))\n\nexpect(result.current.data).toEqual({ answer: 42 })\n```\n\n----------------------------------------\n\nTITLE: Feature Comparison Table in Markdown\nDESCRIPTION: A markdown table comparing various features and capabilities of React Query, SWR, Apollo Client, RTK-Query, and React Router. The table includes information on platform requirements, query syntax support, caching strategies, bundle sizes, and specific features like queries, cache persistence, and devtools.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/comparison.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| | React Query | SWR [_(Website)_][swr] | Apollo Client [_(Website)_][apollo] | RTK-Query [_(Website)_][rtk-query] | React Router [_(Website)_][react-router] |\n| -------------------------------------------------- | ---------------------------------------- | ---------------------------------------- | ------------------------------------------ | ------------------------------------ | ------------------------------------------------------------------------- |\n| Github Repo / Stars | [![][stars-react-query]][gh-react-query] | [![][stars-swr]][gh-swr] | [![][stars-apollo]][gh-apollo] | [![][stars-rtk-query]][gh-rtk-query] | [![][stars-react-router]][gh-react-router] |\n| Platform Requirements | React | React | React, GraphQL | Redux | React |\n| Their Comparison | | (none) | (none) | [Comparison][rtk-query-comparison] | (none) |\n| Supported Query Syntax | Promise, REST, GraphQL | Promise, REST, GraphQL | GraphQL, Any (Reactive Variables) | Promise, REST, GraphQL | Promise, REST, GraphQL |\n| Supported Frameworks | React | React | React + Others | Any | React |\n| Caching Strategy | Hierarchical Key -> Value | Unique Key -> Value | Normalized Schema | Unique Key -> Value | Nested Route -> value |\n| Cache Key Strategy | JSON | JSON | GraphQL Query | JSON | Route Path |\n| Cache Change Detection | Deep Compare Keys (Stable Serialization) | Deep Compare Keys (Stable Serialization) | Deep Compare Keys (Unstable Serialization) | Key Referential Equality (===) | Route Change |\n| Data Change Detection | Deep Comparison + Structural Sharing | Deep Compare (via `stable-hash`) | Deep Compare (Unstable Serialization) | Key Referential Equality (===) | Loader Run |\n| Data Memoization | Full Structural Sharing | Identity (===) | Normalized Identity | Identity (===) | Identity (===) |\n| Bundle Size | [![][bp-react-query]][bpl-react-query] | [![][bp-swr]][bpl-swr] | [![][bp-apollo]][bpl-apollo] | [![][bp-rtk-query]][bpl-rtk-query] | [![][bp-react-router]][bpl-react-router] + [![][bp-history]][bpl-history] |\n| API Definition Location | Component, External Config | Component | GraphQL Schema | External Config | Route Tree Configuration |\n| Queries | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |\n| Cache Persistence | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | üõë Active Routes Only <sup>8</sup> |\n| Devtools | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | üõë |\n| Polling/Intervals | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | üõë |\n| Parallel Queries | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |\n| Dependent Queries | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |\n| Paginated Queries | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |\n| Infinite Queries | ‚úÖ | ‚úÖ | ‚úÖ | üõë | üõë |\n| Bi-directional Infinite Queries | ‚úÖ | üî∂ | üî∂ | üõë | üõë |\n| Infinite Query Refetching | ‚úÖ | ‚úÖ | üõë | üõë | üõë |\n| Lagged Query Data<sup>1</sup> | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |\n| Selectors | ‚úÖ | üõë | ‚úÖ | ‚úÖ | N/A |\n| Initial Data | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |\n| Scroll Recovery | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |\n| Cache Manipulation | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | üõë |\n| Outdated Query Dismissal | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |\n| Render Batching & Optimization<sup>2</sup> | ‚úÖ | ‚úÖ | üõë | ‚úÖ | ‚úÖ |\n```\n\n----------------------------------------\n\nTITLE: Starting Development Server for TanStack Query Example (Shell)\nDESCRIPTION: Command to start the development server for the TanStack Query example project using npm.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/devtools-panel/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of createSyncStoragePersister\nDESCRIPTION: Example showing how to create and configure a storage persister with QueryClient.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/createSyncStoragePersister.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { persistQueryClient } from '@tanstack/react-query-persist-client'\nimport { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister'\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      gcTime: 1000 * 60 * 60 * 24, // 24 hours\n    },\n  },\n})\n\nconst localStoragePersister = createSyncStoragePersister({\n  storage: window.localStorage,\n})\n// const sessionStoragePersister = createSyncStoragePersister({ storage: window.sessionStorage })\n\npersistQueryClient({\n  queryClient,\n  persister: localStoragePersister,\n})\n```\n\n----------------------------------------\n\nTITLE: Sequential Callback Execution in Mutations\nDESCRIPTION: Example showing the execution order of mutation callbacks. Demonstrates how onSuccess and onSettled will be called in sequence, with onSuccess firing first followed by onSettled.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-23_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nmutation = injectMutation(() => ({\n  mutationFn: addTodo,\n  onSuccess: async () => {\n    console.log(\"I'm first!\")\n  },\n  onSettled: async () => {\n    console.log(\"I'm second!\")\n  },\n}))\n```\n\n----------------------------------------\n\nTITLE: Using infiniteQueryOptions to Define Query Configuration in TypeScript\nDESCRIPTION: This snippet demonstrates the basic usage of the `infiniteQueryOptions` function. It accepts a configuration object where `queryKey` is mandatory, and additional options (`...options`) identical to those used by `useInfiniteQuery` can be included. This function helps create reusable option sets for infinite queries.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/infiniteQueryOptions.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\ninfiniteQueryOptions({\n  queryKey,\n  ...options,\n})\n```\n\n----------------------------------------\n\nTITLE: Reactive Usage of injectQuery with Angular Signals\nDESCRIPTION: Shows how injectQuery works reactively with Angular signals. The query automatically executes when the filter signal changes to a truthy value and disables when it changes back to a falsy value.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectquery.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nclass ServiceOrComponent {\n  filter = signal('')\n\n  todosQuery = injectQuery(() => ({\n    queryKey: ['todos', this.filter()],\n    queryFn: () => fetchTodos(this.filter()),\n    // Signals can be combined with expressions\n    enabled: !!this.filter(),\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Streamed Query in TanStack Query\nDESCRIPTION: This snippet demonstrates how to use the streamedQuery function to create a query that streams data. The query will be in a 'pending' state until the first chunk of data is received, then transition to 'success'. It will remain in 'fetching' status until the stream ends.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/streamedQuery.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst query = queryOptions({\n  queryKey: ['data'],\n  queryFn: streamedQuery({\n    queryFn: fetchDataInChunks,\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing Query Key Parameters in Query Functions\nDESCRIPTION: Shows how to access and destructure parameters from the queryKey in a separate query function. The example demonstrates using an object structure in the queryKey and extracting its values.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-functions.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nresult = injectQuery(() => ({\n  queryKey: ['todos', { status: status(), page: page() }],\n  queryFn: fetchTodoList,\n}))\n\n// Access the key, status and page variables in your query function!\nfunction fetchTodoList({ queryKey }) {\n  const [_key, { status, page }] = queryKey\n  return new Promise()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Paginated Query with TanStack Query in TypeScript\nDESCRIPTION: This snippet shows how to create a basic paginated query using the injectQuery function from TanStack Query. It uses a dynamic queryKey based on the current page and a fetchProjects function as the queryFn.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/paginated-queries.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = injectQuery(() => ({\n  queryKey: ['projects', page()],\n  queryFn: fetchProjects,\n}))\n```\n\n----------------------------------------\n\nTITLE: Basic API Response Structure for Infinite Queries\nDESCRIPTION: Example showing the expected API response format with cursor-based pagination\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfetch('/api/projects?cursor=0')\n// { data: [...], nextCursor: 3}\nfetch('/api/projects?cursor=3')\n// { data: [...], nextCursor: 6}\nfetch('/api/projects?cursor=6')\n// { data: [...], nextCursor: 9}\nfetch('/api/projects?cursor=9')\n// { data: [...] }\n```\n\n----------------------------------------\n\nTITLE: Using skipToken for Fine-Grained Query Control in Angular TanStack Query\nDESCRIPTION: This snippet illustrates the use of 'skipToken' to provide more granular control over query execution. The query function is only defined when the filter is set, otherwise skipToken is used to prevent execution.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/disabling-queries.md#2025-04-23_snippet_2\n\nLANGUAGE: angular-ts\nCODE:\n```\nimport { skipToken, injectQuery } from '@tanstack/query-angular'\n\n@Component({\n  selector: 'todos',\n  template: `\n    <div>\n      // üöÄ applying the filter will enable and execute the query\n      <filters-form onApply=\"filter.set\" />\n      <todos-table data=\"query.data()\" />\n    </div>\n  `,\n})\nexport class TodosComponent {\n  filter = signal('')\n\n  todosQuery = injectQuery(() => ({\n    queryKey: ['todos', this.filter()],\n    queryFn: this.filter() ? () => fetchTodos(this.filter()) : skipToken,\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating keepPreviousData to placeholderData Identity Function with Tanstack Query (TSX)\nDESCRIPTION: This example shows how to migrate from the deprecated keepPreviousData option and isPreviousData property to placeholderData accepting the keepPreviousData function and using isPlaceholderData. This supports continued usage of previous query data as a placeholder in new fetches and is compatible with React and Tanstack Query v5+. Imports must include keepPreviousData from tanstack/react-query, and query key, function, and arguments should be supplied as before.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-23_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\\n   useQuery,\\n+  keepPreviousData // [!code ++]\\n} from \"@tanstack/react-query\";\\n\\nconst {\\n   data,\\n-  isPreviousData, // [!code --]\\n+  isPlaceholderData, // [!code ++]\\n} = useQuery({\\n  queryKey,\\n  queryFn,\\n- keepPreviousData: true, // [!code --]\\n+ placeholderData: keepPreviousData // [!code ++]\\n});\n```\n\n----------------------------------------\n\nTITLE: Using initialDataUpdatedAt with Cached initialData in useQuery (TSX)\nDESCRIPTION: Builds upon retrieving initial data from the cache by also providing `initialDataUpdatedAt`. It fetches the `dataUpdatedAt` timestamp from the source query's state (`queryClient.getQueryState(['todos'])?.dataUpdatedAt`) to accurately reflect the freshness of the cached initial data being used. This helps TanStack Query decide if a refetch is necessary.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nconst result = useQuery({\n  queryKey: ['todos', todoId],\n  queryFn: () => fetch(`/todos/${todoId}`),\n  initialData: () =>\n    queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId),\n  initialDataUpdatedAt: () =>\n    queryClient.getQueryState(['todos'])?.dataUpdatedAt,\n})\n```\n\n----------------------------------------\n\nTITLE: Dehydrating Query Client State in React Query\nDESCRIPTION: Creates a frozen representation of the query cache that can be hydrated later. Used for server-to-client prefetching or local storage persistence. Takes a QueryClient instance and optional configuration options.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/reference/hydration.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { dehydrate } from '@tanstack/react-query'\n\nconst dehydratedState = dehydrate(queryClient, {\n  shouldDehydrateQuery,\n  shouldDehydrateMutation,\n})\n```\n\n----------------------------------------\n\nTITLE: Expensive Initial Data Function\nDESCRIPTION: Demonstrates using a function to compute initial data lazily, useful for expensive calculations.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nresult = injectQuery(() => ({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: () => getExpensiveTodos(),\n}))\n```\n\n----------------------------------------\n\nTITLE: Setting Mutation Defaults with setMutationDefaults\nDESCRIPTION: Demonstrates setting default options for specific mutations, including setting a default mutationFn.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_26\n\nLANGUAGE: tsx\nCODE:\n```\nqueryClient.setMutationDefaults(['addPost'], { mutationFn: addPost })\n\nfunction Component() {\n  const { data } = useMutation({ mutationKey: ['addPost'] })\n}\n```\n\n----------------------------------------\n\nTITLE: Installing and Starting TanStack Query Example\nDESCRIPTION: Commands for installing dependencies and starting the example project using npm. First installs required packages with npm install, then starts the development server.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/solid/basic/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\nnpm run start\n```\n\n----------------------------------------\n\nTITLE: Defining String Replacements for Solid Query Adaptation\nDESCRIPTION: This JavaScript object literal specifies key-value pairs for string replacements. It is used within a build or documentation generation process to automatically convert React Query specific syntax (like hook names and module imports) to their Solid Query equivalents in the 'Request Waterfalls' documentation page.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/guides/request-waterfalls.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n{\n    'React': 'Solid',\n    '@tanstack/react-query': '@tanstack/solid-query',\n    'useMutationState[(]': 'useMutationState(() => ',\n    'useMutation[(]': 'useMutation(() => ',\n    'useQuery[(]': 'useQuery(() => ',\n    'useQueries[(]': 'useQueries(() => ',\n    'useInfiniteQuery[(]': 'useInfiniteQuery(() => ',\n  }\n```\n\n----------------------------------------\n\nTITLE: Installing and Running React Query Next.js Example\nDESCRIPTION: Commands to install dependencies and start the development server for the React Query Next.js integration example.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/nextjs/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies and Running TanStack Query Example\nDESCRIPTION: These commands install the necessary dependencies and start the development server for a TanStack Query example project. First, it installs all required packages using npm, then starts the development server.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/star-wars/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Installing React Query via Bun (Bash)\nDESCRIPTION: Installs the `@tanstack/react-query` package using the Bun toolkit's package manager. This command downloads and adds the library to your project's dependencies.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/installation.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbun add @tanstack/react-query\n```\n\n----------------------------------------\n\nTITLE: Building All Packages\nDESCRIPTION: Command to build all packages in the monorepo.\nSOURCE: https://github.com/tanstack/query/blob/main/CONTRIBUTING.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npnpm build:all\n```\n\n----------------------------------------\n\nTITLE: Retrieving QueryClient from Svelte Context - TypeScript\nDESCRIPTION: This TypeScript function, intended for use in Svelte applications, returns a QueryClient instance from the component context. It depends on Svelte's context system and TanStack Query's QueryClient type. The function provides seamless access to globally managed data within Svelte components. Key parameter: none. Output: an available QueryClient from context, or may throw if none is set.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/getqueryclientcontext.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction getQueryClientContext(): QueryClient\n```\n\n----------------------------------------\n\nTITLE: Installing TanStack Query with Package Managers\nDESCRIPTION: Various package manager commands to install the TanStack Query Angular experimental package.\nSOURCE: https://github.com/tanstack/query/blob/main/packages/angular-query-experimental/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm i @tanstack/angular-query-experimental\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ pnpm add @tanstack/angular-query-experimental\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn add @tanstack/angular-query-experimental\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ bun add @tanstack/angular-query-experimental\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for TanStack Query Example (Bash)\nDESCRIPTION: This command installs all necessary dependencies for the TanStack Query example project using npm.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/load-more-infinite-scroll/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Mocking the network layer for TanStack Query tests with MSW\nDESCRIPTION: Shows how to set up Mock Service Worker (MSW) to intercept and mock API requests in tests of components that use TanStack Query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/testing.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { rest } from 'msw'\nimport { setupServer } from 'msw/node'\n\nconst server = setupServer(\n  rest.get('/api/posts', (req, res, ctx) => {\n    return res(\n      ctx.json([\n        {\n          id: '1',\n          title: 'Post title',\n          body: 'Post body',\n        },\n      ])\n    )\n  })\n)\n\nbeforeAll(() => server.listen())\nafterEach(() => server.resetHandlers())\nafterAll(() => server.close())\n```\n\n----------------------------------------\n\nTITLE: Running TanStack Query Example with npm Commands\nDESCRIPTION: Commands to install dependencies and start the development server for the TanStack Query example project.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/simple/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Installing TanStack Query Persist Client Core Package\nDESCRIPTION: Various package manager commands to install the @tanstack/query-persist-client-core package.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/createPersister.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @tanstack/query-persist-client-core\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @tanstack/query-persist-client-core\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @tanstack/query-persist-client-core\n```\n\nLANGUAGE: bash\nCODE:\n```\nbun add @tanstack/query-persist-client-core\n```\n\n----------------------------------------\n\nTITLE: Starting Svelte Development Server\nDESCRIPTION: Commands for starting the Svelte development server, with an option to automatically open in a browser tab.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/svelte/auto-refetching/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n\n# or start the server and open the app in a new browser tab\nnpm run dev -- --open\n```\n\n----------------------------------------\n\nTITLE: Installing Astro Minimal Template\nDESCRIPTION: Command to create a new Astro project using the minimal template via npm\nSOURCE: https://github.com/tanstack/query/blob/main/examples/solid/astro/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm create astro@latest -- --template minimal\n```\n\n----------------------------------------\n\nTITLE: Initializing QueryClient with Custom gcTime - TanStack Query - TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a TanStack QueryClient with the gcTime (garbage collection time) option configured for 24 hours, which determines how long inactive cache persists during hydration. Properly configuring gcTime is essential when using persistent cache features, and it should be set to at least the value of maxAge to prevent unexpected cache invalidation. Inputs include custom duration in milliseconds; ensures cache persists for user-defined period.\n\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/persistQueryClient.md#2025-04-23_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      gcTime: 1000 * 60 * 60 * 24, // 24 hours\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Extending SvelteComponent for Typed Component Export - TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to create a typed Svelte component by extending the SvelteComponent base class and specifying the props interface. This technique enables IDE features like intellisense, especially when distributing components through packages. To use, ensure you have both TypeScript and the Svelte library as dependencies. 'MyComponent' requires a prop 'foo' of type string. This pattern is most effective in index.d.ts or declaration files to provide consumers with accurate typings.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/classes/hydrationboundary.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SvelteComponent } from 'svelte'\nexport class MyComponent extends SvelteComponent<{ foo: string }> {}\n```\n\n----------------------------------------\n\nTITLE: API Signature Changes for Query Hooks\nDESCRIPTION: Shows the migration from multiple parameter signatures to single object parameter format for various query hooks like useQuery, useInfiniteQuery, and useMutation.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nuseQuery(key, fn, options) // [!code --]\nuseQuery({ queryKey, queryFn, ...options }) // [!code ++]\nuseInfiniteQuery(key, fn, options) // [!code --]\nuseInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]\nuseMutation(fn, options) // [!code --]\nuseMutation({ mutationFn, ...options }) // [!code ++]\nuseIsFetching(key, filters) // [!code --]\nuseIsFetching({ queryKey, ...filters }) // [!code ++]\nuseIsMutating(key, filters) // [!code --]\nuseIsMutating({ mutationKey, ...filters }) // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Hydrating Queries with TanStack Query in Svelte - TypeScript\nDESCRIPTION: This function initializes the hydration process for TanStack Query in a Svelte-based TypeScript environment. It accepts optional parameters: the state to hydrate from (can be any type), optional HydrateOptions to configure the hydration process, and an optional QueryClient instance to target a specific client. The function does not return a value, and is intended to be invoked at the start of a Svelte application's lifecycle to synchronize client-side state with server-fetched queries. External dependencies include TanStack Query and (optionally) types like HydrateOptions and QueryClient. The function is defined in 'packages/svelte-query/src/useHydrate.ts' and does not enforce type constraints, but expects integration within TanStack Query's architecture.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/usehydrate.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction useHydrate(state?, options?, queryClient?): void\n```\n\n----------------------------------------\n\nTITLE: Error Boundary Hook Implementation\nDESCRIPTION: Demonstrates using the useQueryErrorResetBoundary hook for error handling in React Query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/suspense.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQueryErrorResetBoundary } from '@tanstack/react-query'\nimport { ErrorBoundary } from 'react-error-boundary'\n\nconst App = () => {\n  const { reset } = useQueryErrorResetBoundary()\n  return (\n    <ErrorBoundary\n      onReset={reset}\n      fallbackRender={({ resetErrorBoundary }) => (\n        <div>\n          There was an error!\n          <Button onClick={() => resetErrorBoundary()}>Try again</Button>\n        </div>\n      )}\n    >\n      <Page />\n    </ErrorBoundary>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the setQueryClientContext Function Signature in TypeScript\nDESCRIPTION: This TypeScript code snippet defines the function signature for `setQueryClientContext`. It accepts a `QueryClient` instance as a parameter and uses Svelte's context API (implicitly, as indicated by the surrounding documentation) to make this client accessible to child components. The function returns `void`. Requires the `QueryClient` type from TanStack Query and depends on Svelte's context mechanism.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/setqueryclientcontext.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nfunction setQueryClientContext(client): void\n```\n```\n\n----------------------------------------\n\nTITLE: Using initialDataUpdatedAt with useQuery in TanStack Query (TSX)\nDESCRIPTION: Explains how to provide the timestamp of when the `initialData` was last updated using `initialDataUpdatedAt`. This allows `staleTime` to accurately determine data freshness based on the timestamp (`initialTodosUpdatedTimestamp`). The query will only refetch if the initial data is older than the specified `staleTime` (1 minute in this example). Requires a JS timestamp in milliseconds.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n// Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n  staleTime: 60 * 1000, // 1 minute\n  // This could be 10 seconds ago or 10 minutes ago\n  initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052\n})\n```\n\n----------------------------------------\n\nTITLE: Registering a Global Error Type - Solid Query - TypeScript/TSX\nDESCRIPTION: Explains registering a global default error type for all queries by augmenting the @tanstack/solid-query module. The Register interface is extended to set defaultError, automatically updating error inference to AxiosError | null everywhere. Requires TypeScript module declaration merging.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/typescript.md#2025-04-23_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@tanstack/solid-query'\n\ndeclare module '@tanstack/solid-query' {\n  interface Register {\n    defaultError: AxiosError\n  }\n}\n\nconst query = useQuery(() => ({\n  queryKey: ['groups'],\n  queryFn: fetchGroups,\n}))\n\nquery.error\n//    ^? (property) error: AxiosError | null\n\n```\n\n----------------------------------------\n\nTITLE: Installing TanStack Query Async Storage Persister - NPM\nDESCRIPTION: Installation command using npm package manager\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/createAsyncStoragePersister.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @tanstack/query-async-storage-persister @tanstack/react-query-persist-client\n```\n\n----------------------------------------\n\nTITLE: Installing and Running TanStack Query Example\nDESCRIPTION: Commands to install dependencies and start the development server for a TanStack Query example project. Requires npm package manager.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/chat/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Starting TanStack Query Angular Auto-Refetching Example\nDESCRIPTION: Commands for starting the TanStack Query Angular example project using npm, yarn, pnpm, or bun package managers.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/angular/auto-refetching/README.md#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n- `npm run start` or `yarn start` or `pnpm start` or `bun start`\n```\n\n----------------------------------------\n\nTITLE: Building Svelte Project for Production\nDESCRIPTION: Command to create a production-ready version of the Svelte app. Also mentions the ability to preview the production build.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/svelte/load-more-infinite-scroll/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Overriding Logger for React Native in React Query (Pre-v3) (TSX)\nDESCRIPTION: Shows the code previously required in React Query versions before v3 to override the default logger in React Native environments. This involved using `setConsole` to map `error` calls to `console.warn` to avoid triggering native error screens on query failures. This manual override is no longer necessary in v3 as it's handled automatically.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nimport { setConsole } from 'react-query'\n\nsetConsole({\n  log: console.log,\n  warn: console.warn,\n  error: console.warn,\n})\n```\n\n----------------------------------------\n\nTITLE: Visualizing Client Navigation Waterfall\nDESCRIPTION: Illustrates how client-side navigation between pages in an SPA still creates a waterfall even with server rendering enabled.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-23_snippet_16\n\nLANGUAGE: markdown\nCODE:\n```\n1. |> JS for <Feed>\n2.   |> getFeed()\n3.     |> JS for <GraphFeedItem>\n4.       |> getGraphDataById()\n```\n\n----------------------------------------\n\nTITLE: Building Svelte Project for Production\nDESCRIPTION: Command to create a production build of the Svelte application.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/svelte/optimistic-updates/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Configuring Nock for Paginated Responses\nDESCRIPTION: Setup for mocking paginated API responses using nock with query parameters.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst expectation = nock('http://example.com')\n  .persist()\n  .query(true)\n  .get('/api/data')\n  .reply(200, (uri) => {\n    const url = new URL(`http://example.com${uri}`)\n    const { page } = Object.fromEntries(url.searchParams)\n    return generateMockedResponse(page)\n  })\n```\n\n----------------------------------------\n\nTITLE: Defining DefinedInitialDataOptions Type Alias in TypeScript\nDESCRIPTION: Declares a type alias that extends CreateQueryOptions to enforce the presence of initialData. The type is generic and accepts parameters for query function data, error type, transformed data, and query key.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/definedinitialdataoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>: CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & object;\n```\n\n----------------------------------------\n\nTITLE: Running TanStack Query Development Server\nDESCRIPTION: Commands to start the development server using either npm or yarn package manager.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/vue/dependent-queries/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm run dev\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn dev\n```\n\n----------------------------------------\n\nTITLE: Persister Interface Definition - TanStack Query - TypeScript\nDESCRIPTION: This snippet defines the contract every persister must fulfill for use with TanStack Query's persistence mechanism. Includes methods persistClient (saving), restoreClient (loading), and removeClient (deleting). All methods use Promisable values, allowing for both async and sync implementations. The Persister abstraction lets developers use any storage backend.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/persistQueryClient.md#2025-04-23_snippet_8\n\nLANGUAGE: TSX\nCODE:\n```\nexport interface Persister {\n  persistClient(persistClient: PersistedClient): Promisable<void>\n  restoreClient(): Promisable<PersistedClient | undefined>\n  removeClient(): Promisable<void>\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Query Results in TanStack Query (TSX)\nDESCRIPTION: This snippet shows the correct way to use query results in TanStack Query. It demonstrates how to use normal object destructuring, which is acceptable and doesn't cause unnecessary re-renders.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/no-rest-destructuring.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst todosQuery = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => api.getTodos(),\n})\n\n// normal object destructuring is fine\nconst { data: todos } = todosQuery\n```\n\n----------------------------------------\n\nTITLE: Registering Custom QueryClient with Custom Context Key (TypeScript)\nDESCRIPTION: Combines supplying both a custom QueryClient instance and a custom context key during VueQueryPlugin registration. This approach ensures both custom configuration and explicit context separation. Dependent on Vue, Vue Query, and TypeScript. Input: a QueryClient instance and a context key string; output: Vue app using the provided QueryClient under the custom key.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/custom-client.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nconst myClient = new QueryClient(queryClientConfig)\nconst vueQueryPluginOptions: VueQueryPluginOptions = {\n  queryClient: myClient,\n  queryClientKey: 'Foo',\n}\napp.use(VueQueryPlugin, vueQueryPluginOptions)\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Storage Persister with React Query\nDESCRIPTION: Example implementation of AsyncStoragePersister with QueryClient and PersistQueryClientProvider in a React Native application.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/createAsyncStoragePersister.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport AsyncStorage from '@react-native-async-storage/async-storage'\nimport { QueryClient } from '@tanstack/react-query'\nimport { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'\nimport { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      gcTime: 1000 * 60 * 60 * 24, // 24 hours\n    },\n  },\n})\n\nconst asyncStoragePersister = createAsyncStoragePersister({\n  storage: AsyncStorage,\n})\n\nconst Root = () => (\n  <PersistQueryClientProvider\n    client={queryClient}\n    persistOptions={{ persister: asyncStoragePersister }}\n  >\n    <App />\n  </PersistQueryClientProvider>\n)\n\nexport default Root\n```\n\n----------------------------------------\n\nTITLE: Importing and Using a Strongly Typed Svelte Component - Svelte (TypeScript)\nDESCRIPTION: This Svelte code block illustrates how to import a typed component from an external library and include it in a Svelte file with TypeScript support. The imported 'MyComponent' requires a 'foo' prop, which is provided as 'bar'. This usage leverages intellisense from the Svelte extension in VS Code, ensuring type correctness. Dependencies include TypeScript, Svelte, and the referenced 'component-library' with declaration support.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/classes/hydrationboundary.md#2025-04-23_snippet_1\n\nLANGUAGE: svelte\nCODE:\n```\n<script lang=\\\"ts\\\">\n  import { MyComponent } from 'component-library'\n</script>\n\n<MyComponent foo={'bar'} />\n```\n\n----------------------------------------\n\nTITLE: Effect of initialData without staleTime in useQuery (TSX)\nDESCRIPTION: Shows that when `initialData` is provided without a `staleTime` (defaulting to 0), the query immediately refetches data upon mounting, even though the initial data (`initialTodos`) is displayed first. This highlights the default behavior where initial data is considered fresh but immediately stale.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// Will show initialTodos immediately, but also immediately refetch todos after mount\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Query Retries for Individual Queries in Angular\nDESCRIPTION: This snippet demonstrates how to configure retry attempts for a specific query using the injectQuery hook from TanStack Query in an Angular application. It sets the retry option to 10, meaning the query will attempt to fetch data 10 times before displaying an error.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-retries.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { injectQuery } from '@tanstack/angular-query-experimental'\n\n// Make a specific query retry a certain number of times\nconst result = injectQuery(() => ({\n  queryKey: ['todos', 1],\n  queryFn: fetchTodoListPage,\n  retry: 10, // Will retry failed requests 10 times before displaying an error\n}))\n```\n\n----------------------------------------\n\nTITLE: Using queryOptions Helper for Type Inference\nDESCRIPTION: Demonstrates how to use the queryOptions helper function to maintain type inference when extracting query options into a service. This approach enables sharing query configurations between components while preserving type safety.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-23_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\n@Injectable({\n  providedIn: 'root',\n})\nexport class QueriesService {\n  private http = inject(HttpClient)\n\n  post(postId: number) {\n    return queryOptions({\n      queryKey: ['post', postId],\n      queryFn: () => {\n        return lastValueFrom(\n          this.http.get<Post>(\n            `https://jsonplaceholder.typicode.com/posts/${postId}`,\n          ),\n        )\n      },\n    })\n  }\n}\n\n@Component({\n  // ...\n})\nexport class Component {\n  queryClient = inject(QueryClient)\n\n  postId = signal(1)\n\n  queries = inject(QueriesService)\n  optionsSignal = computed(() => this.queries.post(this.postId()))\n\n  postQuery = injectQuery(() => this.queries.post(1))\n  postQuery = injectQuery(() => this.queries.post(this.postId()))\n\n  // You can also pass a signal which returns query options\n  postQuery = injectQuery(this.optionsSignal)\n\n  someMethod() {\n    this.queryClient.prefetchQuery(this.queries.post(23))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Array-Based Query Keys with Variable Elements\nDESCRIPTION: Demonstrates how array-based query keys differ from object-based ones. These examples are NOT equivalent because the order of primitive values in an array matters for query key matching.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-keys.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ninjectQuery(() => ({ queryKey: ['todos', status, page], ... }))\ninjectQuery(() => ({ queryKey: ['todos', page, status], ...}))\ninjectQuery(() => ({ queryKey: ['todos', undefined, page, status], ...}))\n```\n\n----------------------------------------\n\nTITLE: Defining initialPageParam for Infinite Queries in Tanstack Query (TSX)\nDESCRIPTION: This snippet updates useInfiniteQuery to require the explicit initialPageParam property instead of assigning a default to the pageParam within the queryFn. initialPageParam provides the value for the first page and avoids serializing undefined in the query cache. This property must be provided alongside queryKey, queryFn, and getNextPageParam for infinite queries.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-23_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nuseInfiniteQuery({\\n   queryKey,\\n-  queryFn: ({ pageParam = 0 }) => fetchSomething(pageParam), // [!code --]\\n+  queryFn: ({ pageParam }) => fetchSomething(pageParam), // [!code ++]\\n+  initialPageParam: 0, // [!code ++]\\n   getNextPageParam: (lastPage) => lastPage.next,\\n})\n```\n\n----------------------------------------\n\nTITLE: Retry Strategy Implementation\nDESCRIPTION: Example showing how to implement retry strategy with removeOldestQuery.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/createSyncStoragePersister.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst localStoragePersister = createSyncStoragePersister({\n  storage: window.localStorage,\n  retry: removeOldestQuery,\n})\n```\n\n----------------------------------------\n\nTITLE: Using matchMutation Utility in TanStack Query\nDESCRIPTION: Example of using the matchMutation utility function to check if a mutation matches specific filter criteria.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/filters.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nconst isMatching = matchMutation(filters, mutation)\n```\n\n----------------------------------------\n\nTITLE: QueryClient Method Signature Updates\nDESCRIPTION: Demonstrates changes to QueryClient method signatures, moving from multiple parameters to a single object parameter pattern.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nqueryClient.isFetching(key, filters) // [!code --]\nqueryClient.isFetching({ queryKey, ...filters }) // [!code ++]\nqueryClient.ensureQueryData(key, filters) // [!code --]\nqueryClient.ensureQueryData({ queryKey, ...filters }) // [!code ++]\nqueryClient.getQueriesData(key, filters) // [!code --]\nqueryClient.getQueriesData({ queryKey, ...filters }) // [!code ++]\nqueryClient.setQueriesData(key, updater, filters, options) // [!code --]\nqueryClient.setQueriesData({ queryKey, ...filters }, updater, options) // [!code ++]\nqueryClient.removeQueries(key, filters) // [!code --]\nqueryClient.removeQueries({ queryKey, ...filters }) // [!code ++]\nqueryClient.resetQueries(key, filters, options) // [!code --]\nqueryClient.resetQueries({ queryKey, ...filters }, options) // [!code ++]\nqueryClient.cancelQueries(key, filters, options) // [!code --]\nqueryClient.cancelQueries({ queryKey, ...filters }, options) // [!code ++]\nqueryClient.invalidateQueries(key, filters, options) // [!code --]\nqueryClient.invalidateQueries({ queryKey, ...filters }, options) // [!code ++]\nqueryClient.refetchQueries(key, filters, options) // [!code --]\nqueryClient.refetchQueries({ queryKey, ...filters }, options) // [!code ++]\nqueryClient.fetchQuery(key, fn, options) // [!code --]\nqueryClient.fetchQuery({ queryKey, queryFn, ...options }) // [!code ++]\nqueryClient.prefetchQuery(key, fn, options) // [!code --]\nqueryClient.prefetchQuery({ queryKey, queryFn, ...options }) // [!code ++]\nqueryClient.fetchInfiniteQuery(key, fn, options) // [!code --]\nqueryClient.fetchInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]\nqueryClient.prefetchInfiniteQuery(key, fn, options) // [!code --]\nqueryClient.prefetchInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Installing ESLint Plugin Query via Bun (Bash)\nDESCRIPTION: Installs the recommended `@tanstack/eslint-plugin-query` as a development dependency using Bun. This plugin integrates ESLint rules specific to TanStack Query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/installation.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nbun add -D @tanstack/eslint-plugin-query\n```\n\n----------------------------------------\n\nTITLE: Removing Single Value from Infinite Query Page\nDESCRIPTION: Example of filtering out a specific value from any page in the infinite query\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nconst newPagesArray =\n  oldPagesArray?.pages.map((page) =>\n    page.filter((val) => val.id !== updatedId),\n  ) ?? []\n\nqueryClient.setQueryData(['projects'], (data) => ({\n  pages: newPagesArray,\n  pageParams: data.pageParams,\n}))\n```\n\n----------------------------------------\n\nTITLE: Plugin Registration Syntax with Context Key Suffix Notation (TypeScript)\nDESCRIPTION: Clarifies how VueQueryPlugin internally composes the registered key using the provided custom key. The comment indicates that the actual Vue injection key will become 'VUE_QUERY_CLIENT:Foo'. Dependencies: Vue, Vue Query, TypeScript. This demonstrates the final context key and registration step; useful for debugging key collisions or advanced plugin usage.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/custom-client.md#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nconst vueQueryPluginOptions: VueQueryPluginOptions = {\n  queryClientKey: 'Foo',\n}\napp.use(VueQueryPlugin, vueQueryPluginOptions) // -> VUE_QUERY_CLIENT:Foo\n```\n\n----------------------------------------\n\nTITLE: Installing ESLint Plugin Query via PNPM (Bash)\nDESCRIPTION: Installs the recommended `@tanstack/eslint-plugin-query` as a development dependency using PNPM. This plugin aids in maintaining code quality for React Query usage.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/installation.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npnpm add -D @tanstack/eslint-plugin-query\n```\n\n----------------------------------------\n\nTITLE: Building Nuxt 3 for Production\nDESCRIPTION: Command to build the Nuxt application for production deployment.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/vue/nuxt3/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn build\n```\n\n----------------------------------------\n\nTITLE: Starting Angular Development Server\nDESCRIPTION: Command to start the Angular development server which serves the application on localhost:4200 with auto-reload capability.\nSOURCE: https://github.com/tanstack/query/blob/main/integrations/angular-cli-19/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nng serve\n```\n\n----------------------------------------\n\nTITLE: Installing and Running TanStack Query Example in Bash\nDESCRIPTION: Commands for setting up and running a TanStack Query example project. The first command installs all required dependencies, and the second command starts the development server.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/playground/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Configuring Merged Query Defaults with setQueryDefaults in Tanstack Query (TypeScript)\nDESCRIPTION: Shows the updated behavior of `queryClient.setQueryDefaults` in v5, where multiple matching defaults are merged. It demonstrates the required change in ordering: defaults should be set from most generic key to least generic. The example illustrates how a more specific default (`['todo', 'detail']`) might need adjustments (like explicitly setting `retry: true`) because it now inherits properties (`retry: false`) from a more general default (`['todo']`). Requires a `queryClient` instance from `@tanstack/query-core`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n+ queryClient.setQueryDefaults(['todo'], {   // [!code ++]\n+   retry: false,  // [!code ++]\n+   staleTime: 60_000,  // [!code ++]\n+ })  // [!code ++]\nqueryClient.setQueryDefaults(['todo', 'detail'], {\n+   retry: true,  // [!code --] // Note: This line seems incorrect in the original diff, it should likely be ++ or unchanged depending on intent. Assuming it's meant to show overriding the inherited 'false'.\n  retryDelay: 1_000,\n  staleTime: 10_000,\n})\n- queryClient.setQueryDefaults(['todo'], { // [!code --]\n-   retry: false, // [!code --]\n-   staleTime: 60_000, // [!code --]\n- }) // [!code --]\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Node Version with NVM\nDESCRIPTION: Command to use the correct Node.js version specified in .nvmrc using NVM.\nSOURCE: https://github.com/tanstack/query/blob/main/CONTRIBUTING.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnvm use\n```\n\n----------------------------------------\n\nTITLE: Initializing Vue Query Plugin\nDESCRIPTION: Example showing how to initialize the Vue Query plugin in a Vue application using VueQueryPlugin.\nSOURCE: https://github.com/tanstack/query/blob/main/packages/vue-query/README.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createApp } from 'vue'\nimport { VueQueryPlugin } from '@tanstack/vue-query'\n\nimport App from './App.vue'\n\ncreateApp(App).use(VueQueryPlugin).mount('#app')\n```\n\n----------------------------------------\n\nTITLE: Implementing Online Status Management with Expo Network\nDESCRIPTION: Alternative implementation of online status management using expo-network package for Expo-based React Native applications.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/react-native.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { onlineManager } from '@tanstack/react-query'\nimport * as Network from 'expo-network'\n\nonlineManager.setEventListener((setOnline) => {\n  const eventSubscription = Network.addNetworkStateListener((state) => {\n    setOnline(!!state.isConnected)\n  })\n  return eventSubscription.remove\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Query Function with TanStack Query in TypeScript\nDESCRIPTION: Shows how to define a default query function using axios for HTTP requests, configure it with QueryClient, and use it in Angular components. The default function automatically handles API calls based on the provided query key, eliminating the need to specify individual query functions for each component.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/default-query-function.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Define a default query function that will receive the query key\nconst defaultQueryFn: QueryFunction = async ({ queryKey }) => {\n  const { data } = await axios.get(\n    `https://jsonplaceholder.typicode.com${queryKey[0]}`,\n  )\n  return data\n}\n\n// provide the default query function to your app with defaultOptions\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      queryFn: defaultQueryFn,\n    },\n  },\n})\n\nbootstrapApplication(MyAppComponent, {\n  providers: [provideTanStackQuery(queryClient)],\n})\n\nexport class PostsComponent {\n  // All you have to do now is pass a key!\n  postsQuery = injectQuery<Array<Post>>(() => ({\n    queryKey: ['/posts'],\n  }))\n  // ...\n}\n\nexport class PostComponent {\n  // You can even leave out the queryFn and just go straight into options\n  postQuery = injectQuery<Post>(() => ({\n    enabled: this.postIdSignal() > 0,\n    queryKey: [`/posts/${this.postIdSignal()}`],\n  }))\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with Status Checks in Angular\nDESCRIPTION: Shows how to use isSuccess() to narrow types in the template. When isSuccess() is true, data is typed as number instead of number | undefined.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-23_snippet_3\n\nLANGUAGE: angular-ts\nCODE:\n```\n@Component({\n  // ...\n  template: `\n    @if (query.isSuccess()) {\n      @let data = query.data();\n      //    ^? data: number\n    }\n  `,\n})\nclass MyComponent {\n  query = injectQuery(() => ({\n    queryKey: ['test'],\n    queryFn: () => Promise.resolve(5),\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Using createWrapper with renderHook for testing custom hooks\nDESCRIPTION: Shows how to use the createWrapper function with renderHook to test custom hooks that use TanStack Query hooks.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/testing.md#2025-04-23_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { renderHook } from '@testing-library/react-hooks'\nimport { useCustomHook } from './hooks'\n\ntest('should increment counter', async () => {\n  const { result, waitFor } = renderHook(() => useCustomHook(), {\n    wrapper: createWrapper()\n  })\n\n  act(() => {\n    result.current.increment()\n  })\n\n  await waitFor(() => result.current.counter === 1)\n})\n```\n\n----------------------------------------\n\nTITLE: Registering Global Query and Mutation Key Types in TypeScript\nDESCRIPTION: Demonstrates registering structured types for `QueryKey` and `MutationKey` globally using TypeScript module augmentation. This allows defining a specific structure (e.g., ensuring the first element is 'dashboard' or 'marketing') that applies across the library's API surface.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-23_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\nimport '@tanstack/react-query'\n\ntype QueryKey = ['dashboard' | 'marketing', ...ReadonlyArray<unknown>]\n\ndeclare module '@tanstack/react-query' {\n  interface Register {\n    queryKey: QueryKey\n    mutationKey: QueryKey\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Memoizing Placeholder Data for Queries - TanStack Query (TypeScript)\nDESCRIPTION: This snippet shows how to memoize the placeholder data using React's useMemo hook before passing it to useQuery in TanStack Query. Memoizing placeholder data prevents expensive calculations or object creations on every render, improving performance. Required dependencies are React, TanStack Query, and a generateFakeTodos function; main parameters are queryKey, queryFn, and placeholderData, which is memoized.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/placeholder-query-data.md#2025-04-23_snippet_1\n\nLANGUAGE: TSX\nCODE:\n```\nfunction Todos() {\\n  const placeholderData = useMemo(() => generateFakeTodos(), [])\\n  const result = useQuery({\\n    queryKey: ['todos'],\\n    queryFn: () => fetch('/todos'),\\n    placeholderData,\\n  })\\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Window Focus Refetching for Individual Query in TanStack Query for Angular\nDESCRIPTION: This snippet demonstrates how to disable window focus refetching for a specific query using the injectQuery function in an Angular application with TanStack Query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/window-focus-refetching.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninjectQuery(() => ({\n  queryKey: ['todos'],\n  queryFn: fetchTodos,\n  refetchOnWindowFocus: false,\n}))\n```\n\n----------------------------------------\n\nTITLE: Using useMutationState for Cross-Component Updates\nDESCRIPTION: Demonstrates how to access mutation state across different components using useMutationState hook with mutation keys.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/optimistic-updates.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n// somewhere in your app\nconst { mutate } = useMutation({\n  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),\n  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),\n  mutationKey: ['addTodo'],\n})\n\n// access variables somewhere else\nconst variables = useMutationState<string>({\n  filters: { mutationKey: ['addTodo'], status: 'pending' },\n  select: (mutation) => mutation.state.variables,\n})\n```\n\n----------------------------------------\n\nTITLE: Importing useMutation from TanStack Query in React\nDESCRIPTION: This snippet shows how to import the useMutation hook from the TanStack Query library for use in a React application.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/reference/useMutation.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useMutation } from '@tanstack/react-query'\n```\n\n----------------------------------------\n\nTITLE: Initializing Vue Query Plugin\nDESCRIPTION: Code to initialize the Vue Query plugin in a Vue application. This is required before using any Vue Query functionality.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/installation.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { VueQueryPlugin } from '@tanstack/vue-query'\n\napp.use(VueQueryPlugin)\n```\n\n----------------------------------------\n\nTITLE: Installing TanStack Solid Query via NPM - Bash\nDESCRIPTION: Installs the @tanstack/solid-query package using NPM, the Node package manager. This approach requires Node.js and NPM installed on the system. After running this command in your project directory, Solid Query will be available in node_modules and ready to be imported into your project. No specific configuration options need to be provided.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/installation.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @tanstack/solid-query\n```\n\n----------------------------------------\n\nTITLE: Explicit Type Annotations with getQueryData - Solid Query - TypeScript\nDESCRIPTION: Shows how to manually annotate getQueryData with a type parameter to retrieve type-safe results when not leveraging typed queryOptions. This ensures that data returned is typed as Group[] | undefined when passing just a raw query key.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/typescript.md#2025-04-23_snippet_11\n\nLANGUAGE: ts\nCODE:\n```\nconst data = queryClient.getQueryData<Group[]>(['groups'])\n\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for TanStack Query Angular Pagination Example\nDESCRIPTION: Commands to install the project dependencies using various package managers including npm, yarn, pnpm, or bun.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/angular/pagination/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install` or `yarn` or `pnpm i` or `bun i\n```\n\n----------------------------------------\n\nTITLE: Installing and Running TanStack Query Example\nDESCRIPTION: Commands to install project dependencies and start the example application. First installs all required packages using npm, then starts the development server.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/solid/default-query-function/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm run start\n```\n\n----------------------------------------\n\nTITLE: Setting up and running TanStack Query example with npm\nDESCRIPTION: Commands for installing dependencies and starting the development server for a TanStack Query example project.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/offline/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Configuring Documentation Page with Framework-Specific Replacements\nDESCRIPTION: YAML frontmatter configuration for a documentation page about TanStack Query's relationship with global state managers. It includes replacements for React-specific function names to be used in other frameworks.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/does-this-replace-client-state.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nid: does-this-replace-client-state\ntitle: Does TanStack Query replace global state managers?\nref: docs/framework/react/guides/does-this-replace-client-state.md\nreplace:\n  {\n    'useQuery': 'injectQuery',\n    'useMutation': 'injectMutation',\n    'hook': 'function',\n  }\n---\n```\n\n----------------------------------------\n\nTITLE: Building Angular Project\nDESCRIPTION: Command to build the Angular project and output compiled files to the dist directory.\nSOURCE: https://github.com/tanstack/query/blob/main/integrations/angular-cli-19/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nng build\n```\n\n----------------------------------------\n\nTITLE: Creating a Query Hook with Undefined Initial Data using Svelte Query (TypeScript)\nDESCRIPTION: This overload defines the createQuery function for situations where the initial data might be undefined. It uses generic parameters for type safety and expects an options parameter typed as StoreOrVal-wrapped UndefinedInitialDataOptions. The returned result is of type CreateQueryResult, which allows for potential undefined data. It accepts an optional QueryClient for customization. This variant is suitable when initial data may not be guaranteed, enabling use cases that require checking for data presence.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/createquery.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction createQuery<TQueryFnData, TError, TData, TQueryKey>(\n  options,\n  queryClient?,\n): CreateQueryResult<TData, TError>\n```\n\n----------------------------------------\n\nTITLE: Type Inference with Custom Query Function in Vue Query\nDESCRIPTION: Illustrates type inference when using a custom query function that returns a Promise<Group[]>. The 'data' property is correctly typed as Ref<Group[]> | Ref<undefined>.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/typescript.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst fetchGroups = (): Promise<Group[]> =>\n  axios.get('/groups').then((response) => response.data)\n\nconst { data } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })\n//      ^? const data: Ref<Group[]> | Ref<undefined>\n```\n\n----------------------------------------\n\nTITLE: Handling Todo Addition Error in Angular Template\nDESCRIPTION: This Angular component template shows how to handle and display errors during todo addition. It includes a retry button for failed mutations.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/optimistic-updates.md#2025-04-23_snippet_2\n\nLANGUAGE: angular-ts\nCODE:\n```\n@Component({\n  template: `\n    @if (addTodo.isError()) {\n      <li style=\"color: red\">\n        {{ addTodo.variables() }}\n        <button (click)=\"addTodo.mutate(addTodo.variables())\">Retry</button>\n      </li>\n    }\n  `,\n})\nclass TodosComponent {}\n```\n\n----------------------------------------\n\nTITLE: Error Handling and Resetting Mutations with TanStack Vue Query - Vue\nDESCRIPTION: This Vue snippet handles mutation errors by incorporating error feedback and a reset mechanism using useMutation from @tanstack/vue-query. It provides UI elements to display errors and allows users to reset the mutation error state via the reset function. The implementation depends on @tanstack/vue-query and axios, and is structured for Vue 3 syntax with standard mutation patterns for asynchronous data submission.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/mutations.md#2025-04-23_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script>\\nimport { useMutation } from '@tanstack/vue-query'\\n\\nconst { error, mutate, reset } = useMutation({\\n  mutationFn: (newTodo) => axios.post('/todos', newTodo),\\n})\\n\\nfunction addTodo() {\\n  mutate({ id: new Date(), title: 'Do Laundry' })\\n}\\n<\\/script>\\n\\n<template>\\n  <span v-else-if=\\\"error\\\">\\n    <span>An error occurred: {{ error.message }}<\\/span>\\n    <button @click=\\\"reset\\\">Reset error<\\/button>\\n  <\\/span>\\n  <button @click=\\\"addTodo\\\">Create Todo<\\/button>\\n<\\/template>\n```\n\n----------------------------------------\n\nTITLE: Conditionally Updating Cache with setQueryData in TanStack Query\nDESCRIPTION: Illustrates how to use the functional updater form of `setQueryData` in TanStack Query v4 to conditionally skip an update. If the `previousValue` (representing the existing cache entry) is `undefined`, returning `undefined` from the updater function prevents a new cache entry from being created. This is useful for operations like toggling a todo item where you only want to update if the item already exists in the cache.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_19\n\nLANGUAGE: tsx\nCODE:\n```\nqueryClient.setQueryData(['todo', id], (previousTodo) =>\n  previousTodo ? { ...previousTodo, done: true } : undefined,\n)\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests\nDESCRIPTION: Command to execute unit tests using the Karma test runner.\nSOURCE: https://github.com/tanstack/query/blob/main/integrations/angular-cli-19/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nng test\n```\n\n----------------------------------------\n\nTITLE: Accessing Mutation Cache with getMutationCache\nDESCRIPTION: Shows how to access the mutation cache that the client is connected to.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_28\n\nLANGUAGE: tsx\nCODE:\n```\nconst mutationCache = queryClient.getMutationCache()\n```\n\n----------------------------------------\n\nTITLE: Integrating Solid Query Devtools in Floating Mode (TSX)\nDESCRIPTION: Demonstrates how to render the `SolidQueryDevtools` component within a SolidJS application's component tree, typically inside a `QueryClientProvider`. This example uses Floating Mode and sets the devtools to be initially closed (`initialIsOpen={false}`). It's recommended to place this component high in the application tree.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/devtools.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { SolidQueryDevtools } from '@tanstack/solid-query-devtools'\n\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      {/* The rest of your application */}\n      <SolidQueryDevtools initialIsOpen={false} />\n    </QueryClientProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Query State with TanStack Query\nDESCRIPTION: Shows how to retrieve the current state of an existing query using queryClient.getQueryState.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nconst state = queryClient.getQueryState(queryKey)\nconsole.log(state.dataUpdatedAt)\n```\n\n----------------------------------------\n\nTITLE: Global Background Fetch Indicator with Vue Query in Vue\nDESCRIPTION: This Vue component demonstrates the use of useIsFetching from @tanstack/vue-query to show a global background fetch indicator. It exposes the number of queries currently in a fetching state and conditionally renders a status message when there are ongoing background fetches. Designed for use with Vue 3 and @tanstack/vue-query, this pattern is suitable for displaying a site-wide loading indicator that is decoupled from individual queries. The main input is the internal state of query fetches, and the output is a simple status message.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/background-fetching-indicators.md#2025-04-23_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\\nimport { useIsFetching } from '@tanstack/vue-query'\\n\\nconst isFetching = useIsFetching()\\n<\\/script>\\n\\n<template>\\n  <div v-if=\\\"isFetching\\\">Queries are fetching in the background...<\\/div>\\n<\\/template>\n```\n\n----------------------------------------\n\nTITLE: Providing initialData via a Function in useQuery (TSX)\nDESCRIPTION: Demonstrates passing a function (`() => getExpensiveTodos()`) to `initialData`. This function is executed only once when the query is initialized, making it suitable for computationally intensive or side-effect-prone initial data retrieval processes, thus saving resources on subsequent renders.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: () => getExpensiveTodos(),\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic Query Retries in TanStack Query\nDESCRIPTION: Demonstrates how to set up retry attempts for a specific query using useQuery hook. This example shows setting a fixed number of retries for a todo list query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-retries.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQuery } from '@tanstack/react-query'\n\n// Make a specific query retry a certain number of times\nconst result = useQuery({\n  queryKey: ['todos', 1],\n  queryFn: fetchTodoListPage,\n  retry: 10, // Will retry failed requests 10 times before displaying an error\n})\n```\n\n----------------------------------------\n\nTITLE: Specifying Non-Error Types as Thrown Values in useQuery (TypeScript)\nDESCRIPTION: This snippet demonstrates how to explicitly specify a non-Error type for the error generic when using the useQuery hook in TypeScript. By default, errors are typed as Error, but you can set a different type, such as string, if you intend to throw values that are not Error instances. Ensure the first generic argument is the data type, and the second is the error type.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-23_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nuseQuery<number, string>({\\n  queryKey: ['some-query'],\\n  queryFn: async () => {\\n    if (Math.random() > 0.5) {\\n      throw 'some error'\\n    }\\n    return 42\\n  },\\n})\n```\n\n----------------------------------------\n\nTITLE: Importing Solid Query Devtools Component (TSX)\nDESCRIPTION: Imports the `SolidQueryDevtools` component from the installed `@tanstack/solid-query-devtools` package. This component needs to be rendered within the SolidJS application.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/devtools.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { SolidQueryDevtools } from '@tanstack/solid-query-devtools'\n```\n\n----------------------------------------\n\nTITLE: Building Svelte Project for Production\nDESCRIPTION: Command to create a production-ready build of the Svelte application.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/svelte/basic/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Using provideAngularQuery in Standalone Angular Application\nDESCRIPTION: Example of how to use provideAngularQuery function in a standalone Angular application, importing necessary components and bootstrapping the application with the provided QueryClient.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/provideangularquery.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  provideAngularQuery,\n  QueryClient,\n} from '@tanstack/angular-query-experimental'\n\nbootstrapApplication(AppComponent, {\n  providers: [provideAngularQuery(new QueryClient())],\n})\n```\n\n----------------------------------------\n\nTITLE: Registering Global Default Error Types\nDESCRIPTION: Demonstrates how to use module augmentation to set a global default error type (AxiosError) for all queries in the application.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-23_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nimport '@tanstack/angular-query-experimental'\n\ndeclare module '@tanstack/angular-query-experimental' {\n  interface Register {\n    defaultError: AxiosError\n  }\n}\n\nconst query = injectQuery(() => ({\n  queryKey: ['groups'],\n  queryFn: fetchGroups,\n}))\n\ncomputed(() => {\n  const error = query.error()\n  //      ^? error: AxiosError | null\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Background Fetching Indicator for Individual Query in React\nDESCRIPTION: This snippet demonstrates how to use the 'isFetching' boolean from useQuery hook to display a background fetching indicator for a specific query. It also shows how to handle different query states like loading, error, and success.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/background-fetching-indicators.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction Todos() {\n  const {\n    status,\n    data: todos,\n    error,\n    isFetching,\n  } = useQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodos,\n  })\n\n  return status === 'pending' ? (\n    <span>Loading...</span>\n  ) : status === 'error' ? (\n    <span>Error: {error.message}</span>\n  ) : (\n    <>\n      {isFetching ? <div>Refreshing...</div> : null}\n\n      <div>\n        {todos.map((todo) => (\n          <Todo todo={todo} />\n        ))}\n      </div>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Scoping Mutations for Sequential Execution with TanStack Query in TypeScript/React\nDESCRIPTION: This snippet illustrates assigning a scope to TanStack Query mutations to ensure they run sequentially when sharing the same scope id. Mutations with identical scope.id are queued and resume in order, avoiding race conditions in scenarios such as multiple rapid updates to the same resource. Dependencies include useMutation from TanStack Query and a mutation function like addTodo. The key parameter is 'scope', which controls concurrency. Inputs and outputs correspond to the mutation function and queued mutation behavior, and this helps provide consistent state updates in high-concurrency scenarios.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-23_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nconst mutation = useMutation({\n  mutationFn: addTodo,\n  scope: {\n    id: 'todo',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing for Custom Errors (AxiosError) in TypeScript\nDESCRIPTION: Recommends using type narrowing for specific error types (like `AxiosError` from axios) instead of explicit generics. This preserves type inference while allowing safe access to specific error properties after a type check.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport axios from 'axios'\n\nconst { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })\n//      ^? const error: Error | null\n\nif (axios.isAxiosError(error)) {\n  error\n  // ^? const error: AxiosError\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Object Rest Destructuring in TanStack Query (TSX)\nDESCRIPTION: This snippet demonstrates incorrect usage of object rest destructuring on query results, which may cause unnecessary re-renders by subscribing to all fields of the query result.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/no-rest-destructuring.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst useTodos = () => {\n  const { data: todos, ...rest } = useQuery({\n    queryKey: ['todos'],\n    queryFn: () => api.getTodos(),\n  })\n  return { todos, ...rest }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Query Hook Dependencies in React\nDESCRIPTION: Example showing correct usage where the mutation object is destructured and only the stable mutate function is used in the useCallback dependency array.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/no-unstable-deps.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n/* eslint \"@tanstack/query/no-unstable-deps\": \"warn\" */\nimport { useCallback } from 'React'\nimport { useMutation } from '@tanstack/react-query'\n\nfunction Component() {\n  const { mutate } = useMutation({ mutationFn: (value: string) => value })\n  const callback = useCallback(() => {\n    mutate('hello')\n  }, [mutate])\n  return null\n}\n```\n\n----------------------------------------\n\nTITLE: Persisting dataUpdatedAt Timestamp When Using placeholderData in useQuery (TypeScript)\nDESCRIPTION: This code demonstrates a workaround for retaining the last dataUpdatedAt timestamp when using placeholderData with useQuery. By using a React useState variable to persist updatedAt and a useEffect to sync it whenever dataUpdatedAt changes, you can maintain a continuous record of the last fetch. This is useful since placeholderData resets dataUpdatedAt to 0 by default. Requires React's useState and useEffect hooks.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-23_snippet_11\n\nLANGUAGE: ts\nCODE:\n```\nconst [updatedAt, setUpdatedAt] = useState(0)\\n\\nconst { data, dataUpdatedAt } = useQuery({\\n  queryKey: ['projects', page],\\n  queryFn: () => fetchProjects(page),\\n})\\n\\nuseEffect(() => {\\n  if (dataUpdatedAt > updatedAt) {\\n    setUpdatedAt(dataUpdatedAt)\\n  }\\n}, [dataUpdatedAt])\n```\n\n----------------------------------------\n\nTITLE: Initial Data with Immediate Refetch\nDESCRIPTION: Sets up a query that shows initial data immediately while triggering a background refetch when the component or service initializes.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Will show initialTodos immediately, but also immediately refetch todos\n// when an instance of the component or service is created\nresult = injectQuery(() => ({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n}))\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies and Running TanStack Query Example in Bash\nDESCRIPTION: Two commands to set up and run a TanStack Query example project. First install dependencies with npm install, then start the development server with npm run dev.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/rick-morty/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Angular Commit Message Format\nDESCRIPTION: Template showing the required format for commit messages following Angular conventions.\nSOURCE: https://github.com/tanstack/query/blob/main/CONTRIBUTING.md#2025-04-23_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n<type>(<scope>): <subject>\n<BLANK LINE>\n<body>\n<BLANK LINE>\n<footer>\n```\n\n----------------------------------------\n\nTITLE: Enabling Corepack for PNPM\nDESCRIPTION: Commands to enable and prepare corepack for PNPM v9 package management.\nSOURCE: https://github.com/tanstack/query/blob/main/CONTRIBUTING.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncorepack enable && corepack prepare\n```\n\n----------------------------------------\n\nTITLE: Using provideAngularQuery in NgModule-based Angular Application\nDESCRIPTION: Example of how to use provideAngularQuery function in an NgModule-based Angular application, importing necessary components and setting up the module with the provided QueryClient.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/provideangularquery.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  provideAngularQuery,\n  QueryClient,\n} from '@tanstack/angular-query-experimental'\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [BrowserModule],\n  providers: [provideAngularQuery(new QueryClient())],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Event Listener for Focus Management in TanStack Query\nDESCRIPTION: Demonstrates how to use setEventListener to set a custom event listener for focus management. It listens for visibilitychange events and handles focus accordingly.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/focusManager.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { focusManager } from '@tanstack/react-query'\n\nfocusManager.setEventListener((handleFocus) => {\n  // Listen to visibilitychange\n  if (typeof window !== 'undefined' && window.addEventListener) {\n    window.addEventListener('visibilitychange', handleFocus, false)\n  }\n\n  return () => {\n    // Be sure to unsubscribe if a new handler is set\n    window.removeEventListener('visibilitychange', handleFocus)\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing a Suspendable Component with useQuery in Vue\nDESCRIPTION: This snippet demonstrates how to create a Vue component that integrates with Suspense using `@tanstack/vue-query`. It defines an `async setup` function, uses `useQuery` to fetch data (`todoFetcher`), and calls the returned `suspense()` function with `await` to enable suspension. The fetched data is then returned for use in the template. Note the experimental nature of Vue Suspense and associated APIs.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/suspense.md#2025-04-23_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script>\nimport { defineComponent } from 'vue'\nimport { useQuery } from '@tanstack/vue-query'\n\nconst todoFetcher = async () =>\n  await fetch('https://jsonplaceholder.cypress.io/todos').then((response) =>\n    response.json(),\n  )\nexport default defineComponent({\n  name: 'SuspendableComponent',\n  async setup() {\n    const { data, suspense } = useQuery(['todos'], todoFetcher)\n    await suspense()\n\n    return { data }\n  },\n})\n</script>\n```\n\n----------------------------------------\n\nTITLE: Configuring Vue Query Plugin for Nuxt 2 (JavaScript)\nDESCRIPTION: This plugin file demonstrates adding Vue Query to a Nuxt 2 app, initializing a QueryClient with a global staleTime and handling SSR/CSR lifecycle for hydration. On the server, it attaches the QueryClient to the SSR context; on the client, it installs VueQueryPlugin and hydrates queryClient using state from nuxtState. It is designed to be added to the plugins array in nuxt.config.js. Dependencies: '@tanstack/vue-query', Nuxt 2, Vue. Key parameters are the Nuxt context and nuxtState. It provides a ready-to-use plugin for querying and SSR data hydration. No inputs are taken directly; expected output is initialized SSR/CSR query state.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/ssr.md#2025-04-23_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport Vue from 'vue'\nimport { VueQueryPlugin, QueryClient, hydrate } from '@tanstack/vue-query'\n\nexport default (context) => {\n  // Modify your Vue Query global settings here\n  const queryClient = new QueryClient({\n    defaultOptions: { queries: { staleTime: 5000 } },\n  })\n\n  if (process.server) {\n    context.ssrContext.VueQuery = queryClient\n  }\n\n  if (process.client) {\n    Vue.use(VueQueryPlugin, { queryClient })\n\n    if (context.nuxtState && context.nuxtState.vueQueryState) {\n      hydrate(queryClient, context.nuxtState.vueQueryState)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Runtime Error Type Narrowing with Axios\nDESCRIPTION: Shows how to use type guards like axios.isAxiosError to narrow error types at runtime, working with TypeScript's type system.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-23_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport axios from 'axios'\n\nquery = injectQuery(() => ({ queryKey: ['groups'], queryFn: fetchGroups }))\n\ncomputed(() => {\n  const error = query.error()\n  //     ^? error: Error | null\n\n  if (axios.isAxiosError(error)) {\n    error\n    // ^? const error: AxiosError\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Global Loading Indicator in Angular with TanStack Query\nDESCRIPTION: This component shows how to implement a global loading indicator that displays whenever any queries are fetching in the background. It uses the injectIsFetching hook from TanStack Angular Query to monitor the global fetching state.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/background-fetching-indicators.md#2025-04-23_snippet_1\n\nLANGUAGE: angular-ts\nCODE:\n```\nimport { injectIsFetching } from '@tanstack/angular-query-experimental'\n\n@Component({\n  selector: 'global-loading-indicator',\n  template: `\n    @if (isFetching()) {\n      <div>Queries are fetching in the background...</div>\n    }\n  `,\n})\nexport class GlobalLoadingIndicatorComponent {\n  isFetching = injectIsFetching()\n}\n```\n\n----------------------------------------\n\nTITLE: Using queryCache.findAll Method in TanStack Query\nDESCRIPTION: Demonstrates the findAll method which returns multiple query instances that partially match the provided query key. Returns an empty array if no matches are found.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryCache.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst queries = queryCache.findAll(queryKey)\n```\n\n----------------------------------------\n\nTITLE: Setting Up QueryClientProvider\nDESCRIPTION: Shows how to implement the QueryClientProvider to connect a QueryClient to a React application.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { QueryClient, QueryClientProvider } from 'react-query'\n\nconst queryClient = new QueryClient()\n\nfunction App() {\n  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>\n}\n```\n\n----------------------------------------\n\nTITLE: Using Buster Parameter for Cache Invalidation - TanStack Query - TypeScript\nDESCRIPTION: This set of function calls illustrates how to use the buster parameter for forced cache invalidation with TanStack Query's persistence utility functions. When a different buster string is provided, any previously persisted cache with a mismatched buster is discarded. This is useful during deployments or major data schema changes. Functions shown: persistQueryClient, persistQueryClientSave, and persistQueryClientRestore‚Äîall receiving a queryClient, persister, and buster string dependency.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/persistQueryClient.md#2025-04-23_snippet_1\n\nLANGUAGE: TSX\nCODE:\n```\npersistQueryClient({ queryClient, persister, buster: buildHash })\npersistQueryClientSave({ queryClient, persister, buster: buildHash })\npersistQueryClientRestore({ queryClient, persister, buster: buildHash })\n```\n\n----------------------------------------\n\nTITLE: Implementing isError Type Guard in TypeScript\nDESCRIPTION: Type guard method that narrows the query result type to error state. Takes the current instance as parameter and returns a type predicate indicating if the result represents an error state.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/basequerynarrowing.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nisError: (this) => this is CreateBaseQueryResult<TData, TError, CreateStatusBasedQueryResult<\"error\", TData, TError>>;\n```\n\n----------------------------------------\n\nTITLE: Injecting QueryClient in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the injectQueryClient function to inject the QueryClient instance into a component or service.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectqueryclient.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst queryClient = injectQueryClient()\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for TanStack Query Example (Shell)\nDESCRIPTION: Command to install the necessary dependencies for the TanStack Query example project using npm.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/devtools-panel/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Conditional Query Execution with Filter in Angular TanStack Query\nDESCRIPTION: This example shows how to enable a query based on a filter condition. The query is only executed when the filter is set, demonstrating dynamic query enabling.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/disabling-queries.md#2025-04-23_snippet_1\n\nLANGUAGE: angular-ts\nCODE:\n```\n@Component({\n  selector: 'todos',\n  template: `\n    <div>\n      // üöÄ applying the filter will enable and execute the query\n      <filters-form onApply=\"filter.set\" />\n      <todos-table data=\"query.data()\" />\n    </div>\n  `,\n})\nexport class TodosComponent {\n  filter = signal('')\n\n  todosQuery = injectQuery(() => ({\n    queryKey: ['todos', this.filter()],\n    queryFn: () => fetchTodos(this.filter()),\n    enabled: !!this.filter(),\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Running Development Server\nDESCRIPTION: Commands for starting the development server using different package managers.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/vue/2.6-basic/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm run dev\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn dev\n```\n\nLANGUAGE: shell\nCODE:\n```\npnpm dev\n```\n\nLANGUAGE: shell\nCODE:\n```\nbun dev\n```\n\n----------------------------------------\n\nTITLE: Implementing isSuccess Type Guard in TypeScript\nDESCRIPTION: Type guard method that narrows the query result type to success state. Takes the current instance as parameter and returns a type predicate indicating if the result represents a successful query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/basequerynarrowing.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nisSuccess: (this) => this is CreateBaseQueryResult<TData, TError, QueryObserverSuccessResult<TData, TError>>;\n```\n\n----------------------------------------\n\nTITLE: Handling Data Change Side Effects with React.useEffect in v4\nDESCRIPTION: Shows the recommended v4 pattern using `React.useEffect` to trigger side effects when query `data` changes. This replaces the previous behavior where `onSuccess` could be called by `setQueryData`, avoiding potential infinite loops and confusion. React Query's structural sharing ensures the effect only runs on actual data changes.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nconst { data } = useQuery({ queryKey, queryFn })\nReact.useEffect(() => mySideEffectHere(data), [data])\n```\n\n----------------------------------------\n\nTITLE: Configuring QueryClient with No Retries\nDESCRIPTION: Setup for QueryClient with retries disabled to prevent test timeouts on error testing.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      // ‚úÖ turns retries off\n      retry: false,\n    },\n  },\n})\nconst wrapper = ({ children }) => (\n  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n)\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Query Hook Dependencies in React\nDESCRIPTION: Example showing incorrect usage where the full mutation object is placed in a useCallback dependency array. This pattern should be avoided as the mutation object is not referentially stable.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/no-unstable-deps.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n/* eslint \"@tanstack/query/no-unstable-deps\": \"warn\" */\nimport { useCallback } from 'React'\nimport { useMutation } from '@tanstack/react-query'\n\nfunction Component() {\n  const mutation = useMutation({ mutationFn: (value: string) => value })\n  const callback = useCallback(() => {\n    mutation.mutate('hello')\n  }, [mutation])\n  return null\n}\n```\n\n----------------------------------------\n\nTITLE: Using Cached Data as Placeholder in TanStack Query with Angular and TypeScript\nDESCRIPTION: This snippet shows how to use cached data from a related query as placeholder data in an Angular component. It retrieves a preview version of a blog post from a list of posts to use as placeholder data for a single post query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/placeholder-query-data.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport class BlogPostComponent {\n  // Until Angular supports signal-based inputs, we have to set a signal\n  @Input({ required: true, alias: 'postId' })\n  set _postId(value: number) {\n    this.postId.set(value)\n  }\n  postId = signal(0)\n  queryClient = inject(QueryClient)\n\n  result = injectQuery(() => ({\n    queryKey: ['blogPost', this.postId()],\n    queryFn: () => fetch(`/blogPosts/${this.postId()}`),\n    placeholderData: () => {\n      // Use the smaller/preview version of the blogPost from the 'blogPosts'\n      // query as the placeholder data for this blogPost query\n      return queryClient\n        .getQueryData(['blogPosts'])\n        ?.find((d) => d.id === this.postId())\n    },\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: QueryCache Method Updates\nDESCRIPTION: Shows changes to QueryCache method signatures for find and findAll methods.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nqueryCache.find(key, filters) // [!code --]\nqueryCache.find({ queryKey, ...filters }) // [!code ++]\nqueryCache.findAll(key, filters) // [!code --]\nqueryCache.findAll({ queryKey, ...filters }) // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Preventing Re-renders with notifyOnChangePropsExclusions in React Query (TSX)\nDESCRIPTION: Illustrates using the `notifyOnChangePropsExclusions` option in `useQuery` to prevent the component from re-rendering when specific properties, like `isStale`, change. This offers granular control over component updates complementary to `notifyOnChangeProps`. Requires React Query v3 and the `useQuery` hook.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQuery } from 'react-query'\n\nfunction User() {\n  const { data } = useQuery(['user'], fetchUser, {\n    notifyOnChangePropsExclusions: ['isStale'],\n  })\n  return <div>Username: {data.username}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Second Custom Data Package with Context in TanStack Query\nDESCRIPTION: Demonstrates creating another isolated data package using TanStack Query v4's custom context feature, similar to the first example. This package (`@my-scope/my-component-data`) defines its own React context, `QueryClient`, custom hook (`useItems`), and provider component (`MyComponentDataProvider`). This reinforces the pattern for managing multiple, independent data sources within the same application.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_21\n\nLANGUAGE: tsx\nCODE:\n```\n// Our second data package: @my-scope/my-component-data\n\nconst context = React.createContext<QueryClient | undefined>(undefined)\nconst queryClient = new QueryClient()\n\nexport const useItems = () => {\n  return useQuery(ITEMS_KEY, ITEMS_FETCHER, {\n    context,\n  })\n}\n\nexport const MyComponentDataProvider = ({\n  children,\n}: {\n  children: React.ReactNode\n}) => {\n  return (\n    <QueryClientProvider client={queryClient} context={context}>\n      {children}\n    </QueryClientProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing infiniteQueryOptions with Defined Initial Data in TypeScript\nDESCRIPTION: Function implementation for infiniteQueryOptions that handles defined initial data scenarios. Similar to the undefined version but works with DefinedInitialDataInfiniteOptions instead. Takes the same type parameters and returns tagged infinite query options.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/infinitequeryoptions.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction infiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam,\n>(\n  options,\n): DefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> &\n  object\n```\n\n----------------------------------------\n\nTITLE: Updating Hydration API Usage from Hydrate to HydrationBoundary (TSX)\nDESCRIPTION: Illustrates the breaking change in Tanstack Query v5 where the `Hydrate` component is renamed to `HydrationBoundary`. The snippet shows the required update in both the import statement and the JSX usage. This change supports concurrent features and transitions better. The `useHydrate` hook has also been removed. Requires `@tanstack/react-query` v5+.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-23_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\n- import { Hydrate } from '@tanstack/react-query' // [!code --]\n+ import { HydrationBoundary } from '@tanstack/react-query' // [!code ++]\n\n\n- <Hydrate state={dehydratedState}> // [!code --]\n+ <HydrationBoundary state={dehydratedState}> // [!code ++]\n  <App />\n- </Hydrate> // [!code --]\n+ </HydrationBoundary> // [!code ++]\n```\n```\n\n----------------------------------------\n\nTITLE: Installing TanStack Query Async Storage Persister - PNPM\nDESCRIPTION: Installation command using pnpm package manager\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/createAsyncStoragePersister.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @tanstack/query-async-storage-persister @tanstack/react-query-persist-client\n```\n\n----------------------------------------\n\nTITLE: Implementing isError Method for Mutation State Narrowing in TypeScript\nDESCRIPTION: Type guard method that checks if a mutation is in the error state and narrows the type to include error-specific properties and error data.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/basemutationnarrowing.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nisError: (this) => this is CreateMutationResult<TData, TError, TVariables, TContext, Override<MutationObserverErrorResult<TData, TError, TVariables, TContext>, Object> & Object>;\n```\n\n----------------------------------------\n\nTITLE: Correct QueryClient implementation in async server component\nDESCRIPTION: This example shows a valid use case for creating a new QueryClient inside an async function, which is acceptable since the function is only called once on the server.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/stable-query-client.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nasync function App() {\n  const queryClient = new QueryClient()\n  await queryClient.prefetchQuery(options)\n}\n```\n\n----------------------------------------\n\nTITLE: Using mutationOptions Helper for Mutations\nDESCRIPTION: Shows how to use the mutationOptions helper function to extract and type mutation configurations, similar to queryOptions but for mutations.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-23_snippet_11\n\nLANGUAGE: ts\nCODE:\n```\nexport class QueriesService {\n  private http = inject(HttpClient)\n\n  updatePost(id: number) {\n    return mutationOptions({\n      mutationFn: (post: Post) => Promise.resolve(post),\n      mutationKey: ['updatePost', id],\n      onSuccess: (newPost) => {\n        //           ^? newPost: Post\n        this.queryClient.setQueryData(['posts', id], newPost)\n      },\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with PNPM\nDESCRIPTION: Command to install project dependencies using PNPM package manager.\nSOURCE: https://github.com/tanstack/query/blob/main/CONTRIBUTING.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Incorrect QueryClient implementation in React component (TanStack Query)\nDESCRIPTION: This example shows an incorrect approach where a new QueryClient is created on every render, which violates the stable-query-client ESLint rule. This can lead to performance issues and unexpected behavior.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/stable-query-client.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n/* eslint \"@tanstack/query/stable-query-client\": \"error\" */\n\nfunction App() {\n  const queryClient = new QueryClient()\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Home />\n    </QueryClientProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Infinite Query Template Implementation\nDESCRIPTION: Angular template showing how to display infinite query results with loading states, error handling, and pagination controls.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/infinite-queries.md#2025-04-23_snippet_1\n\nLANGUAGE: angular-html\nCODE:\n```\n<div>\n  @if (query.isPending()) {\n  <p>Loading...</p>\n  } @else if (query.isError()) {\n  <span>Error: {{ query?.error().message }}</span>\n  } @else { @for (page of query?.data().pages; track $index) { @for (project of\n  page.data; track project.id) {\n  <p>{{ project.name }} {{ project.id }}</p>\n  } }\n  <div>\n    <button (click)=\"query.fetchNextPage()\" [disabled]=\"nextButtonDisabled()\">\n      {{ nextButtonText() }}\n    </button>\n  </div>\n  }\n</div>\n```\n\n----------------------------------------\n\nTITLE: Initializing QueryClient in React Query v3\nDESCRIPTION: Shows how to create a new QueryClient instance, which replaces the previous QueryCache implementation.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { QueryClient } from 'react-query'\n\nconst queryClient = new QueryClient()\n```\n\n----------------------------------------\n\nTITLE: Registering a Global Meta Type in TypeScript\nDESCRIPTION: Explains how to register a global type for the `meta` property on queries and mutations using TypeScript module augmentation. Defining `queryMeta` and `mutationMeta` within the `Register` interface ensures type safety and consistency for metadata across the application.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-23_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nimport '@tanstack/react-query'\n\ninterface MyMeta extends Record<string, unknown> {\n  // Your meta type definition.\n}\n\ndeclare module '@tanstack/react-query' {\n  interface Register {\n    queryMeta: MyMeta\n    mutationMeta: MyMeta\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: StoragePersisterOptions Interface Definition\nDESCRIPTION: TypeScript interface definition for the options that can be passed to the experimental_createPersister function. It includes properties for storage, serialization methods, cache invalidation, and filtering queries.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/plugins/createPersister.md#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nexport interface StoragePersisterOptions {\n  /** The storage client used for setting and retrieving items from cache.\n   * For SSR pass in `undefined`.\n   */\n  storage: AsyncStorage | Storage | undefined | null\n  /**\n   * How to serialize the data to storage.\n   * @default `JSON.stringify`\n   */\n  serialize?: (persistedQuery: PersistedQuery) => string\n  /**\n   * How to deserialize the data from storage.\n   * @default `JSON.parse`\n   */\n  deserialize?: (cachedString: string) => PersistedQuery\n  /**\n   * A unique string that can be used to forcefully invalidate existing caches,\n   * if they do not share the same buster string\n   */\n  buster?: string\n  /**\n   * The max-allowed age of the cache in milliseconds.\n   * If a persisted cache is found that is older than this\n   * time, it will be discarded\n   * @default 24 hours\n   */\n  maxAge?: number\n  /**\n   * Prefix to be used for storage key.\n   * Storage key is a combination of prefix and query hash in a form of `prefix-queryHash`.\n   */\n  prefix?: string\n  /**\n   * Filters to narrow down which Queries should be persisted.\n   */\n  filters?: QueryFilters\n}\n\ninterface AsyncStorage {\n  getItem: (key: string) => Promise<string | undefined | null>\n  setItem: (key: string, value: string) => Promise<unknown>\n  removeItem: (key: string) => Promise<void>\n}\n```\n\n----------------------------------------\n\nTITLE: Explicitly Typing Error Generic in useQuery (TypeScript)\nDESCRIPTION: Demonstrates specifying a custom error type using generics in `useQuery`. By providing `<Group[], string>`, the `error` field is explicitly typed as `string | null`. However, this approach prevents type inference for other generics.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/typescript.md#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nconst { error } = useQuery<Group[], string>(['groups'], fetchGroups)\n//      ^? const error: string | null\n```\n\n----------------------------------------\n\nTITLE: Incorrect Query Function Implementation in TypeScript/React\nDESCRIPTION: Example showing incorrect implementation where the query function doesn't return the fetched data, leading to potential caching issues.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/no-void-query-fn.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n/* eslint \"@tanstack/query/no-void-query-fn\": \"error\" */\n\nuseQuery({\n  queryKey: ['todos'],\n  queryFn: async () => {\n    await api.todos.fetch() // Function doesn't return the fetched data\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Root Layout with Query Provider\nDESCRIPTION: Sets up the root layout component that wraps the application with the QueryClient provider\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport Providers from './providers'\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <head />\n      <body>\n        <Providers>{children}</Providers>\n      </body>\n    </html>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing QueryClient Context Key in VueQueryPlugin (TypeScript)\nDESCRIPTION: Illustrates assigning a custom key ('queryClientKey') when registering QueryClient in the Vue context. This is essential to avoid naming conflicts, especially for micro-frontend architectures or multiple Vue apps on the same page. The option can be combined with default or custom QueryClient configuration. Dependencies include Vue, Vue Query, and TypeScript. Input: a string defining the custom key; output: QueryClient registered under the specified context key.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/custom-client.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst vueQueryPluginOptions: VueQueryPluginOptions = {\n  queryClientKey: 'Foo',\n}\napp.use(VueQueryPlugin, vueQueryPluginOptions)\n```\n\n----------------------------------------\n\nTITLE: Implementing Query Client with Persister\nDESCRIPTION: Example of creating a QueryClient with experimental_createPersister configuration using AsyncStorage.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/createPersister.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport AsyncStorage from '@react-native-async-storage/async-storage'\nimport { QueryClient } from '@tanstack/react-query'\nimport { experimental_createPersister } from '@tanstack/query-persist-client-core'\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      gcTime: 1000 * 30, // 30 seconds\n      persister: experimental_createPersister({\n        storage: AsyncStorage,\n        maxAge: 1000 * 60 * 60 * 12, // 12 hours\n      }),\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Batching Function in Tanstack Query (TypeScript)\nDESCRIPTION: Demonstrates how to configure a custom batching function for Tanstack Query using `notifyManager.setBatchNotifyFunction`. This is necessary in frameworks like SolidJS, especially since React 18 no longer uses `unstable_batchedUpdates`. The example uses the `batch` function from `solid-js`. Dependencies include `@tanstack/query-core` and the framework's batching mechanism (e.g., `solid-js`).\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { notifyManager } from '@tanstack/query-core'\nimport { batch } from 'solid-js'\n\nnotifyManager.setBatchNotifyFunction(batch)\n```\n```\n\n----------------------------------------\n\nTITLE: Defining CreateInfiniteQueryOptions Type Alias in TypeScript\nDESCRIPTION: This TypeScript type alias, `CreateInfiniteQueryOptions`, defines the structure for the options object passed to the `createInfiniteQuery` function in `@tanstack/svelte-query`. It extends `InfiniteQueryObserverOptions` and uses generic parameters (`TQueryFnData`, `TError`, `TData`, `TQueryData`, `TQueryKey`, `TPageParam`) to provide flexibility in defining data shapes, error handling, query keys, and pagination parameters. Default types are specified for several parameters, such as `unknown` for data and page params, and `DefaultError` for errors.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/createinfinitequeryoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\n```ts\ntype CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey, TPageParam>: InfiniteQueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey, TPageParam>;\n```\n```\n\n----------------------------------------\n\nTITLE: Clearing the MutationCache in React Query\nDESCRIPTION: Clears the entire mutation cache, removing all stored mutations and resetting the cache to a fresh state.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/MutationCache.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nmutationCache.clear()\n```\n\n----------------------------------------\n\nTITLE: Defining DefinedCreateBaseQueryResult Type Alias in TypeScript\nDESCRIPTION: This TypeScript type alias `DefinedCreateBaseQueryResult` defines the return type for `createBaseQuery` in Svelte Query when the `initialData` option is used. It ensures that the result is a Svelte `Readable` store containing a `DefinedQueryObserverResult`, guaranteeing that the `data` property is defined from the start. It accepts generic types `TData` (defaulting to `unknown`) for the data shape and `TError` (defaulting to `DefaultError`) for the error shape.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/definedcreatebasequeryresult.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype DefinedCreateBaseQueryResult<TData, TError>: Readable<DefinedQueryObserverResult<TData, TError>>;\n```\n\n----------------------------------------\n\nTITLE: QueryClient getData/State Updates\nDESCRIPTION: Shows simplified signatures for getQueryData and getQueryState methods.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nqueryClient.getQueryData(queryKey, filters) // [!code --]\nqueryClient.getQueryData(queryKey) // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Using Type Inference with Query Options in Angular\nDESCRIPTION: This snippet shows how to use type inference with query options in Angular. It demonstrates that the query.data will be inferred as the return type of the select function rather than the queryFn. This allows for more precise typing in query results.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-options.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Type inference still works, so query.data will be the return type of select instead of queryFn\nqueries = inject(QueriesService)\n\nquery = injectQuery(() => ({\n  ...groupOptions(1),\n  select: (data) => data.title,\n}))\n```\n\n----------------------------------------\n\nTITLE: Defining the CreateMutateFunction Type Alias in TypeScript\nDESCRIPTION: This TypeScript code defines a type alias `CreateMutateFunction`. It uses generic parameters (`TData`, `TError`, `TVariables`, `TContext`) with default values to represent the types involved in a mutation. The type itself describes a function that accepts the same parameters as TanStack Query's `MutateFunction` (inferred using `Parameters<>`) and returns `void`. This is typically used within Svelte Query to type the function returned by `createMutation` that triggers the actual mutation.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/createmutatefunction.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ntype CreateMutateFunction<TData, TError, TVariables, TContext>: (...args) => void;\n```\n```\n\n----------------------------------------\n\nTITLE: Migrating QueryStatus Enum to String Literals in React Query TypeScript (TSX)\nDESCRIPTION: Demonstrates the required code change in TypeScript projects using React Query v3 due to the `QueryStatus` type changing from an enum to a string literal union type (`'idle' | 'loading' | 'error' | 'success'`). Code examples show updating status checks from `status === QueryStatus.Loading` to `status === 'loading'`. Requires React Query v3 and TypeScript.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\n- import { useQuery, QueryStatus } from 'react-query'; // [!code --]\n+ import { useQuery } from 'react-query'; // [!code ++]\n\nconst { data, status } = useQuery(['post', id], () => fetchPost(id))\n\n- if (status === QueryStatus.Loading) { // [!code --]\n+ if (status === 'loading') { // [!code ++]\n  ...\n}\n\n- if (status === QueryStatus.Error) { // [!code --]\n+ if (status === 'error') { // [!code ++]\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Initial Data Property Signature in TanStack Query Options (TypeScript)\nDESCRIPTION: This code declares the initialData property for use within DefinedInitialDataOptions, specifying that it must be either a NonUndefinedGuard<TQueryFnData> or a function returning such a value. This approach ensures that initial data is always defined, preventing runtime errors due to undefined values and supporting lazy evaluation. Used as part of type constraints in advanced TypeScript type modeling, this pattern is common in data fetching libraries for state initialization.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/definedinitialdataoptions.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ninitialData: NonUndefinedGuard<TQueryFnData> | () => NonUndefinedGuard<TQueryFnData>;\n```\n\n----------------------------------------\n\nTITLE: Selecting/Transforming Data with useQuery's select Option in React Query (TSX)\nDESCRIPTION: Introduces the `select` option available in `useQuery` (and `useInfiniteQuery`) hooks in React Query v3. This example shows how to use `select` to efficiently extract or transform data (e.g., getting the `username` from a user object) directly within the hook configuration, potentially reducing re-renders if combined with `notifyOnChangeProps`. Requires React Query v3 and the `useQuery` hook.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQuery } from 'react-query'\n\nfunction User() {\n  const { data } = useQuery(['user'], fetchUser, {\n    select: (user) => user.username,\n  })\n  return <div>Username: {data}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Keeping Only First Page in Infinite Query\nDESCRIPTION: Manual update to keep only the first page in infinite query data\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-23_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nqueryClient.setQueryData(['projects'], (data) => ({\n  pages: data.pages.slice(0, 1),\n  pageParams: data.pageParams.slice(0, 1),\n}))\n```\n\n----------------------------------------\n\nTITLE: Setting Default Mutation Options with setMutationDefaults in React Query (TSX)\nDESCRIPTION: Illustrates using the `QueryClient.setMutationDefaults` method (introduced in v3) to define default options, like a `mutationFn`, for mutations identified by a specific mutation key (e.g., `['addPost']`). This allows subsequent `useMutation` hooks using that key to inherit the defaults, reducing boilerplate. Requires `QueryClient` and `useMutation` from React Query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_20\n\nLANGUAGE: tsx\nCODE:\n```\nqueryClient.setMutationDefaults(['addPost'], { mutationFn: addPost })\n\nfunction Component() {\n  const { mutate } = useMutation({ mutationKey: ['addPost'] })\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Query Options with Undefined Initial Data for Svelte TanStack Query in TypeScript\nDESCRIPTION: This function overload provides a way to define query options where initial data may be undefined, supporting advanced scenarios in TanStack Query. It uses generics for customizable typing of query data, error, output data, and query key. The input must conform to the UndefinedInitialDataOptions interface, and the return value is an object that merges this type structure. Dependencies include the type aliases UndefinedInitialDataOptions and related type definitions. The main limitation is that initial data may be absent, and consumers should handle this possibility.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/queryoptions.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction queryOptions<TQueryFnData, TError, TData, TQueryKey>(\n  options,\n): UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & object\n```\n\n----------------------------------------\n\nTITLE: Initializing TanStack Query in NgModule-based Angular App\nDESCRIPTION: Configuration code for setting up TanStack Query in a traditional NgModule-based Angular application.\nSOURCE: https://github.com/tanstack/query/blob/main/packages/angular-query-experimental/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { provideHttpClient } from '@angular/common/http'\nimport {\n  provideTanStackQuery,\n  QueryClient,\n} from '@tanstack/angular-query-experimental'\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [BrowserModule],\n  providers: [provideTanStackQuery(new QueryClient())],\n  bootstrap: [AppComponent],\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Fixed Retry Delays for Individual Queries\nDESCRIPTION: Demonstrates how to configure a fixed retry delay for a specific query, overriding the default exponential backoff behavior.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/query-retries.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n  retryDelay: 1000, // Will always wait 1000ms to retry, regardless of how many retries\n})\n```\n\n----------------------------------------\n\nTITLE: Setting up a test provider for TanStack Query\nDESCRIPTION: Demonstrates how to create a wrapper component for tests that provides a fresh QueryClient instance for each test, preventing shared state between tests.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/testing.md#2025-04-23_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\nimport { render } from '@testing-library/react'\nimport { renderHook } from '@testing-library/react-hooks'\n\nconst createTestQueryClient = () =>\n  new QueryClient({\n    defaultOptions: {\n      queries: {\n        retry: false,\n      },\n    },\n    logger: {\n      log: console.log,\n      warn: console.warn,\n      error: process.env.NODE_ENV === 'test' ? () => {} : console.error,\n    },\n  })\n\nexport function renderWithClient(ui: React.ReactElement) {\n  const testQueryClient = createTestQueryClient()\n  const { rerender, ...result } = render(\n    <QueryClientProvider client={testQueryClient}>{ui}</QueryClientProvider>\n  )\n  return {\n    ...result,\n    rerender: (rerenderUi: React.ReactElement) =>\n      rerender(\n        <QueryClientProvider client={testQueryClient}>\n          {rerenderUi}\n        </QueryClientProvider>\n      ),\n  }\n}\n\nexport function createWrapper() {\n  const testQueryClient = createTestQueryClient()\n  return ({ children }: { children: React.ReactNode }) => (\n    <QueryClientProvider client={testQueryClient}>\n      {children}\n    </QueryClientProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Type Annotation with QueryClient Methods\nDESCRIPTION: Demonstrates how to manually specify types with QueryClient methods when not using queryOptions.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-23_snippet_10\n\nLANGUAGE: ts\nCODE:\n```\ndata = queryClient.getQueryData<Post>(['post', 1])\n```\n\n----------------------------------------\n\nTITLE: Implementing Floating Mode for React Query Devtools\nDESCRIPTION: Example of how to implement the floating mode of React Query Devtools in a React application.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/devtools.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools'\n\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      {/* The rest of your application */}\n      <ReactQueryDevtools initialIsOpen={false} />\n    </QueryClientProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using QueriesObserver in TanStack Query\nDESCRIPTION: This example demonstrates how to create a QueriesObserver instance to observe multiple queries and subscribe to their results. The observer is initialized with a queryClient and an array of query configurations, each containing a queryKey and queryFn. The subscribe method returns an unsubscribe function that can be called to clean up the subscription.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueriesObserver.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst observer = new QueriesObserver(queryClient, [\n  { queryKey: ['post', 1], queryFn: fetchPost },\n  { queryKey: ['post', 2], queryFn: fetchPost },\n])\n\nconst unsubscribe = observer.subscribe((result) => {\n  console.log(result)\n  unsubscribe()\n})\n```\n\n----------------------------------------\n\nTITLE: Defining the mutateAsync Property Type within CreateBaseMutationResult (TypeScript)\nDESCRIPTION: This snippet defines the type for the `mutateAsync` property within the `CreateBaseMutationResult`. It uses the `CreateMutateAsyncFunction` type, which takes the same generic parameters (`TData`, `TError`, `TVariables`, `TContext`) as the parent type, representing the function used to trigger the mutation asynchronously and receive a promise.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/createbasemutationresult.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nmutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TContext>\n```\n\n----------------------------------------\n\nTITLE: Multiple Mutations with Conflicting Callbacks\nDESCRIPTION: Illustrates how callbacks behave when multiple mutations are triggered in sequence. Shows how inline callbacks only fire for the last mutation while mutation-level callbacks fire for each mutation.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-23_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nexport class Example {\n  mutation = injectMutation(() => ({\n    mutationFn: addTodo,\n    onSuccess: (data, variables, context) => {\n      // Will be called 3 times\n    },\n  }))\n\n  doMutations() {\n    ;['Todo 1', 'Todo 2', 'Todo 3'].forEach((todo) => {\n      this.mutation.mutate(todo, {\n        onSuccess: (data, variables, context) => {\n          // Will execute only once, for the last mutation (Todo 3),\n          // regardless which mutation resolves first\n        },\n      })\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: HydrationBoundary Constructor and Key Type Definitions - TypeScript\nDESCRIPTION: This snippet shows the constructor signature and type parameter usage for HydrationBoundary. It details how to initialize a new HydrationBoundary with optional typed props, events, and slots by accepting ComponentConstructorOptions. Requires Svelte's type definitions, and proper generic parameters for Props, Events, and Slots. Available in the Svelte types package ('svelte').\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/classes/hydrationboundary.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nnew HydrationBoundary<Props, Events, Slots>(options): HydrationBoundary<Props, Events, Slots>\n```\n\n----------------------------------------\n\nTITLE: Using Query Client Methods\nDESCRIPTION: Demonstrates the new async prefetchQuery and fetchQuery methods in QueryClient.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n// Prefetch a query:\nawait queryClient.prefetchQuery('posts', fetchPosts)\n\n// Fetch a query:\ntry {\n  const data = await queryClient.fetchQuery('posts', fetchPosts)\n} catch (error) {\n  // Error handling\n}\n```\n\n----------------------------------------\n\nTITLE: Using an Identity Function for placeholderData in useQuery (TypeScript)\nDESCRIPTION: This TypeScript snippet shows how to pass an inlined identity function to the placeholderData option in useQuery. The function receives previousData and previousQuery, and it simply returns previousData, mimicking the legacy keepPreviousData behavior. Input parameters must match the new function signature, and the identity function maintains the previous data during refetch transitions.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-23_snippet_10\n\nLANGUAGE: ts\nCODE:\n```\nuseQuery({\\n  queryKey,\\n  queryFn,\\n  placeholderData: (previousData, previousQuery) => previousData, // identity function with the same behaviour as `keepPreviousData`\\n})\n```\n\n----------------------------------------\n\nTITLE: Defining QueriesOptions Type Alias in TypeScript\nDESCRIPTION: A complex recursive type definition that unwraps function arguments to infer and enforce type parameters. It handles various edge cases and recursively processes arrays of query options with depth limitation checks.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/queriesoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype QueriesOptions<T, TResult, TDepth>: TDepth[\"length\"] extends MAXIMUM_DEPTH ? QueryObserverOptionsForCreateQueries[] : T extends [] ? [] : T extends [infer Head] ? [...TResult, GetOptions<Head>] : T extends [infer Head, ...(infer Tail)] ? QueriesOptions<[...Tail], [...TResult, GetOptions<Head>], [...TDepth, 1]> : ReadonlyArray<unknown> extends T ? T : T extends QueryObserverOptionsForCreateQueries<infer TQueryFnData, infer TError, infer TData, infer TQueryKey>[] ? QueryObserverOptionsForCreateQueries<TQueryFnData, TError, TData, TQueryKey>[] : QueryObserverOptionsForCreateQueries[];\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Online Status Changes in TanStack Query\nDESCRIPTION: Shows how to subscribe to changes in the online state using onlineManager.subscribe(). The method returns an unsubscribe function that can be used to clean up the subscription.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/onlineManager.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { onlineManager } from '@tanstack/react-query'\n\nconst unsubscribe = onlineManager.subscribe((isOnline) => {\n  console.log('isOnline', isOnline)\n})\n```\n\n----------------------------------------\n\nTITLE: Declaring the Optional 'select' Function in MutationStateOptions (TypeScript)\nDESCRIPTION: This snippet declares the optional `select` function within the `MutationStateOptions` type. This function takes a `Mutation` object (with specific generic types shown in the surrounding context) as input and allows users to transform or select specific parts of the mutation state, returning a value of type `TResult`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/mutationstateoptions.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\noptional select: (mutation) => TResult;\n```\n\n----------------------------------------\n\nTITLE: Wrapping a Component with Vue Suspense\nDESCRIPTION: This snippet shows how to use the built-in Vue `<Suspense>` component to manage loading states. It wraps a custom `SuspendableComponent` and provides a fallback template (`<div>Loading...</div>`) to display while the suspendable component is resolving its asynchronous dependencies.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/suspense.md#2025-04-23_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport SuspendableComponent from './SuspendableComponent.vue'\n</script>\n\n<template>\n  <Suspense>\n    <template #default>\n      <SuspendableComponent />\n    </template>\n    <template #fallback>\n      <div>Loading...</div>\n    </template>\n  </Suspense>\n</template>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Interface Definition for CreateInfiniteQueryOptions\nDESCRIPTION: This interface defines the configuration options for creating infinite queries in TanStack Query. It extends InfiniteQueryObserverOptions while omitting the 'suspense' property, and accepts multiple type parameters for customizing query data types, error handling, and pagination.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/createinfinitequeryoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey, TPageParam> extends OmitKeyof<InfiniteQueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey, TPageParam>, \"suspense\">\n```\n\n----------------------------------------\n\nTITLE: Safe List End Reached Handler\nDESCRIPTION: Example of safely handling list end reached events to prevent concurrent fetches\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-23_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<List onEndReached={() => !isFetchingNextPage && fetchNextPage()} />\n```\n\n----------------------------------------\n\nTITLE: CreateQueryOptions Interface Definition in TypeScript\nDESCRIPTION: Defines the CreateQueryOptions interface that extends OmitKeyof<CreateBaseQueryOptions> while omitting the 'suspense' property. It includes type parameters for query function data, error handling, transformed data, and query keys.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/createqueryoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n# Interface: CreateQueryOptions\\<TQueryFnData, TError, TData, TQueryKey\\>\n\n## Extends\n\n- `OmitKeyof`\\<[`CreateBaseQueryOptions`](createbasequeryoptions.md)\\<`TQueryFnData`, `TError`, `TData`, `TQueryFnData`, `TQueryKey`\\>, `\"suspense\"`\\>\n\n## Type Parameters\n\n‚Ä¢ **TQueryFnData** = `unknown`\n\n‚Ä¢ **TError** = `DefaultError`\n\n‚Ä¢ **TData** = `TQueryFnData`\n\n‚Ä¢ **TQueryKey** _extends_ `QueryKey` = `QueryKey`\n```\n\n----------------------------------------\n\nTITLE: Incorrect Query Key Usage in TanStack Query (TSX)\nDESCRIPTION: These examples demonstrate incorrect usage of query keys where not all dependencies are included. This can lead to improper caching and refetching behavior.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/exhaustive-deps.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nuseQuery({\n  queryKey: ['todo'],\n  queryFn: () => api.getTodo(todoId),\n})\n\nconst todoQueries = {\n  detail: (id) => ({ queryKey: ['todo'], queryFn: () => api.getTodo(id) }),\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Property Order in useInfiniteQuery (TanStack Query)\nDESCRIPTION: This example demonstrates the incorrect property ordering for useInfiniteQuery, which can lead to type inference issues. The properties are not arranged in the recommended order of queryFn, getPreviousPageParam, getNextPageParam.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/infinite-query-property-order.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n/* eslint \"@tanstack/query/infinite-query-property-order\": \"warn\" */\nimport { useInfiniteQuery } from '@tanstack/react-query'\n\nconst query = useInfiniteQuery({\n  queryKey: ['projects'],\n  getNextPageParam: (lastPage) => lastPage.nextId ?? undefined,\n  queryFn: async ({ pageParam }) => {\n    const response = await fetch(`/api/projects?cursor=${pageParam}`)\n    return await response.json()\n  },\n  initialPageParam: 0,\n  getPreviousPageParam: (firstPage) => firstPage.previousId ?? undefined,\n  maxPages: 3,\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Strict Query Result Type with TanStack Query (TypeScript)\nDESCRIPTION: This snippet defines a TypeScript type alias Named DefinedCreateQueryResult, which extends DefinedCreateBaseQueryResult and specifies generic type parameters for the result data and error types. It is designed for use with the createQuery function in TanStack Query when initialData is provided, ensuring result types are explicitly known. Dependencies include TanStack Query and an existing type DefinedCreateBaseQueryResult, with main parameters being TData (the expected data type, defaulting to unknown) and TError (the error type, defaulting to DefaultError). The output of this type alias is a strongly typed query result object, improving code maintainability and type safety.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/definedcreatequeryresult.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype DefinedCreateQueryResult<TData, TError>: DefinedCreateBaseQueryResult<TData, TError>;\n```\n\n----------------------------------------\n\nTITLE: Defining Initial Data Options Type Alias in TanStack Query (TypeScript)\nDESCRIPTION: This snippet defines the DefinedInitialDataOptions type alias, which extends CreateQueryOptions to specify additional constraints for providing initial data in TanStack Query (Svelte-Query). It leverages TypeScript generics‚ÄîTQueryFnData, TError, TData, and TQueryKey‚Äîto allow flexible configuration while enforcing type safety. Intended for internal use within query options, it requires that initial data be explicitly non-undefined.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/definedinitialdataoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>: CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & object;\n```\n\n----------------------------------------\n\nTITLE: Streamlined QueryCacheNotifyEvent Type Names in v4\nDESCRIPTION: Shows the updated, simpler type names ('added', 'removed', 'updated') for `QueryCacheNotifyEvent` used when manually subscribing to `queryCache` events in v4. This aligns them with `MutationCacheNotifyEvent` types.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\n- type: 'queryAdded' // [!code --]\n+ type: 'added' // [!code ++]\n- type: 'queryRemoved' // [!code --]\n+ type: 'removed' // [!code ++]\n- type: 'queryUpdated' // [!code --]\n+ type: 'updated' // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Retrieving isRestoring Context Value in Svelte Query TypeScript\nDESCRIPTION: This function provides a way to retrieve the 'isRestoring' status from Svelte's context within a Svelte application. It returns a Svelte-readable store of boolean type, allowing reactive components to monitor if the restoration process is ongoing. Requires 'svelte-query' and assumes usage within a Svelte context-aware component; returns a Readable<boolean> and should be invoked in a context where the provider has set up the restoring context.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/getisrestoringcontext.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction getIsRestoringContext(): Readable<boolean>\n```\n\n----------------------------------------\n\nTITLE: React.use() with Query Promise Implementation\nDESCRIPTION: Example of using React.use() with Query promises for experimental prefetch functionality.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/suspense.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { fetchTodos, type Todo } from './api'\n\nfunction TodoList({ query }: { query: UseQueryResult<Todo[]> }) {\n  const data = React.use(query.promise)\n\n  return (\n    <ul>\n      {data.map((todo) => (\n        <li key={todo.id}>{todo.title}</li>\n      ))}\n    </ul>\n  )\n}\n\nexport function App() {\n  const query = useQuery({ queryKey: ['todos'], queryFn: fetchTodos })\n\n  return (\n    <>\n      <h1>Todos</h1>\n      <React.Suspense fallback={<div>Loading...</div>}>\n        <TodoList query={query} />\n      </React.Suspense>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Focus State Management\nDESCRIPTION: Shows how to manually control the focus state using focusManager.setFocused method.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/window-focus-refetching.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { focusManager } from '@tanstack/react-query'\n\n// Override the default focus state\nfocusManager.setFocused(true)\n\n// Fallback to the default focus check\nfocusManager.setFocused(undefined)\n```\n\n----------------------------------------\n\nTITLE: Getting Query Defaults with getQueryDefaults\nDESCRIPTION: Shows how to retrieve default options for specific queries using their query key.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_23\n\nLANGUAGE: tsx\nCODE:\n```\nconst defaultOptions = queryClient.getQueryDefaults(['posts'])\n```\n\n----------------------------------------\n\nTITLE: Browser Compatibility Requirements Listing - Plain Text\nDESCRIPTION: Lists minimum browser versions compatible with Solid Query. This is a non-code snippet intended as a reference for required environments. Custom polyfills or transpilation may be necessary for unsupported browsers.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/installation.md#2025-04-23_snippet_5\n\nLANGUAGE: \nCODE:\n```\nChrome >= 91\\nFirefox >= 90\\nEdge >= 91\\nSafari >= 15\\niOS >= 15\\nOpera >= 77\n```\n\n----------------------------------------\n\nTITLE: Defining setIsRestoringContext Function Signature in TypeScript\nDESCRIPTION: This TypeScript code snippet defines the function signature for `setIsRestoringContext`. It takes a single parameter `isRestoring`, which must be a Svelte `Readable<boolean>`, and returns `void`. The function's purpose is to set this restoring status within the Svelte context for TanStack Query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/setisrestoringcontext.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nfunction setIsRestoringContext(isRestoring): void\n```\n\n----------------------------------------\n\nTITLE: Query with Switch Statement Rendering\nDESCRIPTION: Demonstrates using a switch statement to handle different query states in the template, providing an alternative to boolean conditions.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/queries.md#2025-04-23_snippet_3\n\nLANGUAGE: angular-ts\nCODE:\n```\n@Component({\n  selector: 'todos',\n  standalone: true,\n  template: `\n    @switch (todos.status()) {\n      @case ('pending') {\n        <span>Loading...</span>\n      }\n      @case ('error') {\n        <span>Error: {{ todos.error()?.message }}</span>\n      }\n      <!-- also status === 'success', but \"else\" logic works, too -->\n      @default {\n        <ul>\n          @for (todo of todos.data(); track todo.id) {\n            <li>{{ todo.title }}</li>\n          } @empty {\n            <li>No todos found</li>\n          }\n        </ul>\n      }\n    }\n  `,\n})\nclass TodosComponent {}\n```\n\n----------------------------------------\n\nTITLE: Getting Mutation Defaults with getMutationDefaults\nDESCRIPTION: Shows how to retrieve default options for specific mutations using their mutation key.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_25\n\nLANGUAGE: tsx\nCODE:\n```\nconst defaultOptions = queryClient.getMutationDefaults(['addPost'])\n```\n\n----------------------------------------\n\nTITLE: Manual Query Cancellation in Angular Component with TanStack Query\nDESCRIPTION: This snippet shows how to manually cancel a query using queryClient.cancelQueries(). It implements a button in an Angular component that, when clicked, cancels the 'todos' query. The fetch request in the queryFn properly consumes the AbortSignal, allowing the request to be canceled.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-cancellation.md#2025-04-23_snippet_3\n\nLANGUAGE: angular-ts\nCODE:\n```\n@Component({\n  standalone: true,\n  template: `<button (click)=\"onCancel()\">Cancel</button>`,\n})\nexport class TodosComponent {\n  query = injectQuery(() => ({\n    queryKey: ['todos'],\n    queryFn: async ({ signal }) => {\n      const resp = await fetch('/todos', { signal })\n      return resp.json()\n    },\n  }))\n\n  queryClient = inject(QueryClient)\n\n  onCancel() {\n    this.queryClient.cancelQueries(['todos'])\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing and running the TanStack Query Angular example\nDESCRIPTION: Instructions for setting up and running the example application. It shows commands for installing dependencies and starting the application using npm, yarn, pnpm, or bun package managers.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/angular/query-options-from-a-service/README.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# TanStack Query Angular query options from a service example\n\nTo run this example:\n\n- `npm install` or `yarn` or `pnpm i` or `bun i`\n- `npm run start` or `yarn start` or `pnpm start` or `bun start`\n```\n\n----------------------------------------\n\nTITLE: Default Error Type Inference in Angular Queries\nDESCRIPTION: Shows the default error type (Error | null) when no specific error type is provided to injectQuery.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/typescript.md#2025-04-23_snippet_4\n\nLANGUAGE: angular-ts\nCODE:\n```\n@Component({\n  // ...\n  template: `@let error = query.error();`,\n  //                ^? error: Error | null\n})\nclass MyComponent {\n  query = injectQuery(() => ({\n    queryKey: ['groups'],\n    queryFn: fetchGroups\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Mutation Retry Configuration\nDESCRIPTION: Shows how to configure retry behavior for failed mutations using the retry option.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-23_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nconst mutation = useMutation({\n  mutationFn: addTodo,\n  retry: 3,\n})\n```\n\n----------------------------------------\n\nTITLE: Enabling Angular Query Devtools\nDESCRIPTION: Basic setup to enable TanStack Query devtools in an Angular application by adding withDevtools to provideTanStackQuery. The devtools are automatically enabled in development mode and excluded from production builds.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/devtools.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  QueryClient,\n  provideTanStackQuery,\n  withDevtools,\n} from '@tanstack/angular-query-experimental'\n\nexport const appConfig: ApplicationConfig = {\n  providers: [provideTanStackQuery(new QueryClient(), withDevtools())],\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CreateMutateAsyncFunction Type Alias in TypeScript\nDESCRIPTION: This snippet defines a type alias for CreateMutateAsyncFunction, which is equivalent to MutateFunction. It uses generic type parameters for data, error, variables, and context, with default types provided.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/createmutateasyncfunction.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype CreateMutateAsyncFunction<TData, TError, TVariables, TContext>: MutateFunction<TData, TError, TVariables, TContext>;\n```\n\n----------------------------------------\n\nTITLE: Default options for StoragePersisterOptions\nDESCRIPTION: Default configuration values for the experimental_createPersister function. Sets prefix to 'tanstack-query', maxAge to 24 hours, and uses JSON.stringify/parse for serialization.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/plugins/createPersister.md#2025-04-23_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n{\n  prefix = 'tanstack-query',\n  maxAge = 1000 * 60 * 60 * 24,\n  serialize = JSON.stringify,\n  deserialize = JSON.parse,\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Fixed Retry Delay for Individual Queries in Angular\nDESCRIPTION: This example illustrates how to set a fixed retry delay for an individual query using TanStack Query in Angular. It sets the retryDelay option to a constant value of 1000ms, which will be used for all retry attempts regardless of the number of retries.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/query-retries.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = injectQuery(() => ({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n  retryDelay: 1000, // Will always wait 1000ms to retry, regardless of how many retries\n}))\n```\n\n----------------------------------------\n\nTITLE: Managing Focus State in React Native\nDESCRIPTION: Demonstrates how to handle focus state changes in React Native using AppState module and focusManager.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/window-focus-refetching.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AppState } from 'react-native'\nimport { focusManager } from '@tanstack/react-query'\n\nfunction onAppStateChange(status: AppStateStatus) {\n  if (Platform.OS !== 'web') {\n    focusManager.setFocused(status === 'active')\n  }\n}\n\nuseEffect(() => {\n  const subscription = AppState.addEventListener('change', onAppStateChange)\n\n  return () => subscription.remove()\n}, [])\n```\n\n----------------------------------------\n\nTITLE: AsyncStoragePersister Interface Definition\nDESCRIPTION: TypeScript interface definition for CreateAsyncStoragePersisterOptions and AsyncStorage, showing all available configuration options.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/createAsyncStoragePersister.md#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\ninterface CreateAsyncStoragePersisterOptions {\n  /** The storage client used for setting an retrieving items from cache */\n  storage: AsyncStorage | undefined | null\n  /** The key to use when storing the cache to localStorage */\n  key?: string\n  /** To avoid localStorage spamming,\n   * pass a time in ms to throttle saving the cache to disk */\n  throttleTime?: number\n  /** How to serialize the data to storage */\n  serialize?: (client: PersistedClient) => string\n  /** How to deserialize the data from storage */\n  deserialize?: (cachedString: string) => PersistedClient\n  /** How to retry persistence on error **/\n  retry?: AsyncPersistRetryer\n}\n\ninterface AsyncStorage {\n  getItem: (key: string) => Promise<string | null>\n  setItem: (key: string, value: string) => Promise<unknown>\n  removeItem: (key: string) => Promise<void>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Svelte Project using npm\nDESCRIPTION: Commands to create a new Svelte project either in the current directory or in a specified folder. Uses the create-svelte package to set up the project structure.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/svelte/load-more-infinite-scroll/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# create a new project in the current directory\nnpm create svelte@latest\n\n# create a new project in my-app\nnpm create svelte@latest my-app\n```\n\n----------------------------------------\n\nTITLE: Configuring Static Query Options with TanStack Query in Svelte - TypeScript\nDESCRIPTION: This snippet demonstrates initializing a Svelte component with TanStack Query where the query's 'refetchInterval' is set from a plain TypeScript variable bound to an input field. The main limitation is that changes to the input are not reactive in the query since 'intervalMs' is not a Svelte store. Dependencies include '@tanstack/svelte-query' and Svelte's built-in reactivity. Inputs include a number field for 'intervalMs'; output is the query result, refreshed at a static interval unless manually updated.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reactivity.md#2025-04-23_snippet_0\n\nLANGUAGE: svelte\nCODE:\n```\n```svelte\\n<script lang=\\\"ts\\\">\\n  import { createQuery } from '@tanstack/svelte-query'\\n\\n  const endpoint = 'http://localhost:5173/api/data'\\n\\n  let intervalMs = 1000\\n\\n  const query = createQuery({\\n    queryKey: ['refetch'],\\n    queryFn: async () => await fetch(endpoint).then((r) => r.json()),\\n    refetchInterval: intervalMs,\\n  })\\n</script>\\n\\n<input type=\\\"number\\\" bind:value={intervalMs} />\\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring ESLint with custom TanStack Query rules (Flat Config)\nDESCRIPTION: Setting up ESLint with custom TanStack Query rules using the modern flat config format in eslint.config.js.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/eslint-plugin-query.md#2025-04-23_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport pluginQuery from '@tanstack/eslint-plugin-query'\n\nexport default [\n  {\n    plugins: {\n      '@tanstack/query': pluginQuery,\n    },\n    rules: {\n      '@tanstack/query/exhaustive-deps': 'error',\n    },\n  },\n  // Any other config...\n]\n```\n\n----------------------------------------\n\nTITLE: Defining `infiniteQueryOptions` Function Signature (TypeScript)\nDESCRIPTION: This TypeScript function signature defines `infiniteQueryOptions`. It accepts an `options` object of type `CreateInfiniteQueryOptions` and returns the same options object, ensuring type safety for infinite query configurations in TanStack Svelte Query. It uses several generic type parameters (`TQueryFnData`, `TError`, `TData`, `TQueryKey`, `TPageParam`) to provide flexibility and strong typing.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/infinitequeryoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nfunction infiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam,\n>(\n  options,\n): CreateInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryFnData,\n  TQueryKey,\n  TPageParam\n>\n```\n\n----------------------------------------\n\nTITLE: Defining createMutation Function Signature (TypeScript)\nDESCRIPTION: Defines the TypeScript signature for the `createMutation` function in @tanstack/svelte-query. It accepts generic types for data (TData), error (TError), variables (TVariables), and context (TContext). The function takes mutation options (`options`) which can be a store or a direct value, and an optional `queryClient` instance. It returns a `CreateMutationResult` object containing the mutation state and methods.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/createmutation.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction createMutation<TData, TError, TVariables, TContext>(\n  options,\n  queryClient?,\n): CreateMutationResult<TData, TError, TVariables, TContext>\n```\n\n----------------------------------------\n\nTITLE: injectQuery Function Signature with Standard Result\nDESCRIPTION: Implementation of injectQuery that returns a CreateQueryResult. This is the standard function signature used for most query operations. It supports the same type parameters as the defined result version.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectquery.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfunction injectQuery<TQueryFnData, TError, TData, TQueryKey>(\n  optionsFn,\n  injector?,\n): CreateQueryResult<TData, TError>\n```\n\n----------------------------------------\n\nTITLE: Defining the useMutationState Function Signature in TypeScript\nDESCRIPTION: This TypeScript function signature defines `useMutationState`. It accepts an optional `options` object (of type `MutationStateOptions`) for filtering mutations and an optional `queryClient` instance. It returns a Svelte `Readable` store containing an array of mutation states (`TResult[]`), which defaults to `MutationState<unknown, Error, unknown, unknown>`. This function is used to subscribe to the state of multiple mutations.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/functions/usemutationstate.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nfunction useMutationState<TResult>(options, queryClient?): Readable<TResult[]>\n```\n```\n\n----------------------------------------\n\nTITLE: Defining injectMutation Function in TypeScript for TanStack Query Angular Integration\nDESCRIPTION: Function signature for injectMutation which creates a mutation operation in Angular applications using TanStack Query. The function accepts an options function and an optional injector, returning a CreateMutationResult object.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectmutation.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction injectMutation<TData, TError, TVariables, TContext>(\n  optionsFn,\n  injector?,\n): CreateMutationResult<TData, TError, TVariables, TContext>\n```\n\n----------------------------------------\n\nTITLE: Async Data Fetching with solid-query Suspense in Vue (JavaScript)\nDESCRIPTION: Implements a Vue component that uses solid-query's useQuery hook with the async suspense pattern for data fetching. Requires vue, @tanstack/solid-query, and a compatible fetch API. Demonstrates defining an asynchronous fetcher, destructuring data and suspense from useQuery, and suspending component setup until the query resolves. Input parameters include the query key ['todos'] and the fetcher function; outputs resolved data; constraints include use within a setup-compatible context and async-await support.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/guides/suspense.md#2025-04-23_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script>\\nimport { defineComponent } from 'vue'\\nimport { useQuery } from '@tanstack/solid-query'\\n\\nconst todoFetcher = async () =>\\n  await fetch('https://jsonplaceholder.cypress.io/todos').then((response) =>\\n    response.json(),\\n  )\\nexport default defineComponent({\\n  name: 'SuspendableComponent',\\n  async setup() {\\n    const { data, suspense } = useQuery(() => ['todos'], todoFetcher)\\n    await suspense()\\n\\n    return { data }\\n  },\\n})\\n</script>\n```\n\n----------------------------------------\n\nTITLE: Defining the StoreOrVal Generic Type Alias in TypeScript\nDESCRIPTION: This TypeScript type alias `StoreOrVal<T>` defines a generic type that represents either a direct value of type `T` or a Svelte `Readable` store containing a value of type `T`. This utility type is part of the TanStack Query library for Svelte, enabling functions or components to accept both static values and reactive Svelte stores. The type parameter `T` specifies the underlying data type.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/storeorval.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype StoreOrVal<T>: T | Readable<T>;\n```\n\n----------------------------------------\n\nTITLE: Cursor-based Pagination Configuration\nDESCRIPTION: Configuration for cursor-based pagination using next and previous cursor parameters.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/infinite-queries.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nquery = injectInfiniteQuery(() => ({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,\n}))\n```\n\n----------------------------------------\n\nTITLE: Async Mutation Example\nDESCRIPTION: Shows how to use the new mutateAsync function with async/await syntax.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nconst { mutateAsync } = useMutation({ mutationFn: addTodo })\n\ntry {\n  const data = await mutateAsync('todo')\n  console.log(data)\n} catch (error) {\n  console.error(error)\n} finally {\n  console.log('settled')\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Vue Query Devtools via Plugin Options (typescript)\nDESCRIPTION: This code enables native Vue Query integration with the official Vue devtools by setting enableDevtoolsV6Plugin to true in the plugin configuration. Requires VueQueryPlugin and works with both v6 and v7 versions of devtools. Typically used in your main application setup file alongside other app.use invocations.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/devtools.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\napp.use(VueQueryPlugin, {\n  enableDevtoolsV6Plugin: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Base Query Result Type Alias in Svelte Query - TypeScript\nDESCRIPTION: This snippet defines the CreateBaseQueryResult type alias, representing a Svelte Readable store containing a QueryObserverResult with generic parameters TData and TError. It is intended for use as the result type when invoking createBaseQuery in the Svelte Query implementation of TanStack Query. Usage requires TypeScript and dependencies include Svelte types such as Readable, as well as QueryObserverResult from TanStack Query. The generic parameters allow flexibility: TData (defaulting to unknown) specifies the data type, and TError (defaulting to DefaultError) specifies the error type returned by queries.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/createbasequeryresult.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype CreateBaseQueryResult<TData, TError>: Readable<QueryObserverResult<TData, TError>>;\n```\n\n----------------------------------------\n\nTITLE: Unified Refetch Type Field for invalidateQueries in v4\nDESCRIPTION: Presents the v4 update replacing separate boolean refetch flags (`refetchActive`, `refetchInactive`) with a unified `refetchType` property ('active', 'inactive', 'all', 'none') for `invalidateQueries`. This simplifies configuration and adds a 'none' option to prevent refetching altogether.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\n- refetchActive?: boolean // [!code --]\n- refetchInactive?: boolean // [!code --]\n+ refetchType?: 'active' | 'inactive' | 'all' | 'none' // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Unified Query Filter Type Field in TanStack Query v4\nDESCRIPTION: Illustrates the v4 update where boolean filter flags (`active`, `inactive`) are replaced by a single `type` property ('active', 'inactive', 'all') for clearer intent when filtering queries. This resolves the ambiguity of the previous boolean flags.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\n- active?: boolean // [!code --]\n- inactive?: boolean // [!code --]\n+ type?: 'active' | 'inactive' | 'all' // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Defining CreateQueryResult Type Alias in TypeScript\nDESCRIPTION: This TypeScript type alias `CreateQueryResult` defines the structure for results returned by the `createQuery` function in Svelte Query. It inherits from `CreateBaseQueryResult` and accepts two generic type parameters: `TData` for the query's data type (defaulting to `unknown`) and `TError` for the potential error type (defaulting to `DefaultError`).\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/createqueryresult.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\ntype CreateQueryResult<TData, TError>: CreateBaseQueryResult<TData, TError>;\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Focus State Changes in TanStack Query\nDESCRIPTION: Shows how to use the subscribe method to listen for changes in the visibility state. It returns an unsubscribe function for cleanup.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/focusManager.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { focusManager } from '@tanstack/react-query'\n\nconst unsubscribe = focusManager.subscribe((isVisible) => {\n  console.log('isVisible', isVisible)\n})\n```\n\n----------------------------------------\n\nTITLE: queryOptions Implementation for Defined Initial Data\nDESCRIPTION: Function signature for the queryOptions implementation handling defined initial data. Similar to the undefined variant but uses DefinedInitialDataOptions as the parameter and return type.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/queryoptions.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction queryOptions<TQueryFnData, TError, TData, TQueryKey>(\n  options,\n): DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & object\n```\n\n----------------------------------------\n\nTITLE: Basic Mutation Setup in TanStack Angular Query\nDESCRIPTION: A simple example of setting up a mutation using injectMutation with a mutation function for posting a todo item.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/guides/invalidations-from-mutations.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nmutation = injectMutation(() => ({\n  mutationFn: postTodo,\n}))\n```\n\n----------------------------------------\n\nTITLE: Prefetching Query Data with Explicit QueryFn\nDESCRIPTION: Demonstrates prefetching a query before it's needed in the UI by using queryClient.prefetchQuery with explicit query key and function.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nawait queryClient.prefetchQuery({ queryKey, queryFn })\n```\n\n----------------------------------------\n\nTITLE: queryOptions Implementation for Undefined Initial Data\nDESCRIPTION: Function signature for the queryOptions implementation handling undefined initial data. It accepts options with type parameters for query function data, error, data, and query key.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/queryoptions.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction queryOptions<TQueryFnData, TError, TData, TQueryKey>(\n  options,\n): UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & object\n```\n\n----------------------------------------\n\nTITLE: Configuring ESLint with custom TanStack Query rules (Legacy Config)\nDESCRIPTION: Setting up ESLint with custom TanStack Query rules using the legacy configuration format in .eslintrc.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/eslint-plugin-query.md#2025-04-23_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"plugins\": [\"@tanstack/query\"],\n  \"rules\": {\n    \"@tanstack/query/exhaustive-deps\": \"error\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing isPending Method for Mutation State Narrowing in TypeScript\nDESCRIPTION: Type guard method that checks if a mutation is in the pending (loading) state and narrows the type to include pending-specific properties.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/basemutationnarrowing.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nisPending: (this) => this is CreateMutationResult<TData, TError, TVariables, TContext, Override<MutationObserverLoadingResult<TData, TError, TVariables, TContext>, Object> & Object>;\n```\n\n----------------------------------------\n\nTITLE: Clearing the QueryCache in TanStack Query\nDESCRIPTION: Demonstrates how to clear the entire query cache, removing all stored queries and their data.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryCache.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nqueryCache.clear()\n```\n\n----------------------------------------\n\nTITLE: Starting TanStack Query Angular Example Application\nDESCRIPTION: Commands to start the example application using different package managers (npm, yarn, pnpm, or bun).\nSOURCE: https://github.com/tanstack/query/blob/main/examples/angular/basic-persister/README.md#2025-04-23_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nnpm run start\n```\n\nLANGUAGE: Shell\nCODE:\n```\nyarn start\n```\n\nLANGUAGE: Shell\nCODE:\n```\npnpm start\n```\n\nLANGUAGE: Shell\nCODE:\n```\nbun start\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for TanStack Query Angular Example\nDESCRIPTION: Commands to install project dependencies using different package managers before running the example.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/angular/infinite-query-with-max-pages/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm i\n```\n\nLANGUAGE: bash\nCODE:\n```\nbun i\n```\n\n----------------------------------------\n\nTITLE: Accessing Query Cache with getQueryCache\nDESCRIPTION: Shows how to access the query cache that the client is connected to.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/QueryClient.md#2025-04-23_snippet_27\n\nLANGUAGE: tsx\nCODE:\n```\nconst queryCache = queryClient.getQueryCache()\n```\n\n----------------------------------------\n\nTITLE: Installing TanStack Query Async Storage Persister - Yarn\nDESCRIPTION: Installation command using yarn package manager\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/createAsyncStoragePersister.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @tanstack/query-async-storage-persister @tanstack/react-query-persist-client\n```\n\n----------------------------------------\n\nTITLE: Creating an External Store in Svelte with TypeScript\nDESCRIPTION: This snippet demonstrates how to create a simple external store in Svelte using TypeScript. External stores are useful for retaining state that should not be replaced during Hot Module Replacement (HMR).\nSOURCE: https://github.com/tanstack/query/blob/main/examples/svelte/simple/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// store.ts\n// An extremely simple external store\nimport { writable } from 'svelte/store'\nexport default writable(0)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Global State Before Using TanStack Query in TypeScript React\nDESCRIPTION: This code snippet shows a example of global state structure before using TanStack Query, including both server-state and client-state items.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/does-this-replace-client-state.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst globalState = {\n  projects,\n  teams,\n  tasks,\n  users,\n  themeMode,\n  sidebarStatus,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the CreateMutateAsyncFunction Type Alias in TypeScript\nDESCRIPTION: This TypeScript code defines a type alias named `CreateMutateAsyncFunction`. It is generic over `TData` (defaulting to `unknown`), `TError` (defaulting to `DefaultError`), `TVariables` (defaulting to `void`), and `TContext` (defaulting to `unknown`). The alias points to the `MutateFunction` type, providing a specific name for this type configuration, likely used for asynchronous mutation operations within TanStack Query's Svelte integration.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/createmutateasyncfunction.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype CreateMutateAsyncFunction<TData, TError, TVariables, TContext>: MutateFunction<TData, TError, TVariables, TContext>;\n```\n\n----------------------------------------\n\nTITLE: Visualizing Server Rendering Request Pattern\nDESCRIPTION: Demonstrates how server rendering improves the request pattern by including content and initial data in the markup and loading JavaScript in parallel.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-23_snippet_14\n\nLANGUAGE: markdown\nCODE:\n```\n1. |> Markup (with content AND initial data)\n2.   |> JS for <Feed>\n2.   |> JS for <GraphFeedItem>\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Custom Context Providers in a TanStack Query Application\nDESCRIPTION: Illustrates how to structure a React application using multiple custom TanStack Query data providers created in previous examples. By nesting providers like `ContainerDataProvider` and `MyComponentDataProvider`, different parts of the component tree are served by distinct `QueryClient` instances. Custom hooks like `useUser` and `useItems` automatically connect to the correct provider because they were defined with a specific context, ensuring data isolation.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_22\n\nLANGUAGE: tsx\nCODE:\n```\n// Our application\n\nimport { ContainerDataProvider, useUser } from \"@my-scope/container-data\";\nimport { AppDataProvider } from \"@my-scope/app-data\";\nimport { MyComponentDataProvider, useItems } from \"@my-scope/my-component-data\";\n\n<ContainerDataProvider> // <-- Provides container data (like \"user\") using its own React Query provider\n  ...\n  <AppDataProvider> // <-- Provides app data using its own React Query provider (unused in this example)\n    ...\n      <MyComponentDataProvider> // <-- Provides component data (like \"items\") using its own React Query provider\n        <MyComponent />\n      </MyComponentDataProvider>\n    ...\n  </AppDataProvider>\n  ...\n</ContainerDataProvider>\n\n// Example of hooks provided by the \"DataProvider\" components above:\nconst MyComponent = () => {\n  const user = useUser() // <-- Uses the context specified in ContainerDataProvider.\n  const items = useItems() // <-- Uses the context specified in MyComponentDataProvider\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Automatic Retries for Mutations in React Query (TSX)\nDESCRIPTION: Demonstrates how to configure automatic retries for failed mutations using the `retry` option within the `useMutation` hook configuration in React Query v3. By default, mutations do not retry on error. This example explicitly sets the retry count to 3 attempts. Requires React Query v3 and the `useMutation` hook.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\nconst mutation = useMutation({\n  mutationFn: addTodo,\n  retry: 3,\n})\n```\n\n----------------------------------------\n\nTITLE: Defining injectQueryClient Function with InjectOptions in TypeScript\nDESCRIPTION: This snippet shows the function signature for injectQueryClient with InjectOptions parameter, which returns a QueryClient instance.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectqueryclient.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction injectQueryClient(injectOptions): QueryClient\n```\n\n----------------------------------------\n\nTITLE: Creating TanStack Directory\nDESCRIPTION: Command to create a new directory for TanStack projects.\nSOURCE: https://github.com/tanstack/query/blob/main/CONTRIBUTING.md#2025-04-23_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nmkdir tanstack\n```\n\n----------------------------------------\n\nTITLE: Defining Recursive Type QueriesResults in TypeScript\nDESCRIPTION: This TypeScript type alias `QueriesResults` recursively maps an array of query options (`T`) to an array of corresponding `QueryObserverResult` types. It uses conditional types and tuple manipulation to process the input array `T`, accumulating results in `TResults`. A depth parameter `TDepth` prevents infinite recursion, stopping at `MAXIMUM_DEPTH`. It handles empty arrays, single-element arrays, multi-element arrays recursively, and falls back to a general array of `QueryObserverResult` if the input matches a specific array of `QueryObserverOptionsForCreateQueries` or as a final default.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/queriesresults.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\ntype QueriesResults<T, TResults, TDepth>: TDepth[\"length\"] extends MAXIMUM_DEPTH ? QueryObserverResult[] : T extends [] ? [] : T extends [infer Head] ? [...TResults, GetCreateQueryResult<Head>] : T extends [infer Head, ...(infer Tails)] ? QueriesResults<[...Tails], [...TResults, GetCreateQueryResult<Head>], [...TDepth, 1]> : T extends QueryObserverOptionsForCreateQueries<infer TQueryFnData, infer TError, infer TData, any>[] ? QueryObserverResult<unknown extends TData ? TQueryFnData : TData, unknown extends TError ? DefaultError : TError>[] : QueryObserverResult[];\n```\n\n----------------------------------------\n\nTITLE: Installing @tanstack/query-persist-client-core with npm\nDESCRIPTION: Command to install the query-persist-client-core package using npm package manager.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/plugins/createPersister.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @tanstack/query-persist-client-core\n```\n\n----------------------------------------\n\nTITLE: Injecting Infinite Query in Angular (Third Overload)\nDESCRIPTION: This is another overload of the injectInfiniteQuery function, identical to the first one in signature and return type. It's likely used for different internal implementations or type inference scenarios.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/functions/injectinfinitequery.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction injectInfiniteQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam,\n>(optionsFn, injector?): CreateInfiniteQueryResult<TData, TError>\n```\n\n----------------------------------------\n\nTITLE: Declaring Optional InitialData Property in TypeScript\nDESCRIPTION: This snippet shows the type declaration for the optional initialData property within the UndefinedInitialDataOptions type. The property is explicitly typed as undefined.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/undefinedinitialdataoptions.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\noptional initialData: undefined;\n```\n\n----------------------------------------\n\nTITLE: Defining DefinedCreateInfiniteQueryResult Type Alias in TypeScript\nDESCRIPTION: This code snippet defines a generic type alias DefinedCreateInfiniteQueryResult that maps the results of a defined infinite query observer to signals. It takes three type parameters: TData (defaulting to unknown), TError (defaulting to DefaultError), and TDefinedInfiniteQueryObserver (defaulting to DefinedInfiniteQueryObserverResult<TData, TError>).\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/definedcreateinfinitequeryresult.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype DefinedCreateInfiniteQueryResult<TData, TError, TDefinedInfiniteQueryObserver>: MapToSignals<TDefinedInfiniteQueryObserver>;\n```\n\n----------------------------------------\n\nTITLE: Defining UndefinedInitialDataInfiniteOptions Type Alias in TypeScript\nDESCRIPTION: Type alias that extends CreateInfiniteQueryOptions with initialData explicitly set to undefined. It supports generic parameters for query function data, error type, data type, query key, and page parameter.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/undefinedinitialdatainfiniteoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype UndefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>: CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey, TPageParam> & object;\n```\n\n----------------------------------------\n\nTITLE: Storage Persister Options Interface\nDESCRIPTION: TypeScript interface definition for the StoragePersisterOptions configuration object.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/createPersister.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nexport interface StoragePersisterOptions {\n  /** The storage client used for setting and retrieving items from cache.\n   * For SSR pass in `undefined`.\n   */\n  storage: AsyncStorage | Storage | undefined | null\n  /**\n   * How to serialize the data to storage.\n   * @default `JSON.stringify`\n   */\n  serialize?: (persistedQuery: PersistedQuery) => string\n  /**\n   * How to deserialize the data from storage.\n   * @default `JSON.parse`\n   */\n  deserialize?: (cachedString: string) => PersistedQuery\n  /**\n   * A unique string that can be used to forcefully invalidate existing caches,\n   * if they do not share the same buster string\n   */\n  buster?: string\n  /**\n   * The max-allowed age of the cache in milliseconds.\n   * If a persisted cache is found that is older than this\n   * time, it will be discarded\n   * @default 24 hours\n   */\n  maxAge?: number\n  /**\n   * Prefix to be used for storage key.\n   * Storage key is a combination of prefix and query hash in a form of `prefix-queryHash`.\n   */\n  prefix?: string\n  /**\n   * Filters to narrow down which Queries should be persisted.\n   */\n  filters?: QueryFilters\n}\n```\n\n----------------------------------------\n\nTITLE: Network Mode Type Definition in TypeScript\nDESCRIPTION: Type signature for the networkMode configuration option in TanStack Query, which can be set to 'online', 'always', or 'offlineFirst'. Defaults to 'online' mode.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/network-mode.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nnetworkMode: 'online' | 'always' | 'offlineFirst'\n```\n\n----------------------------------------\n\nTITLE: Defining QueriesResults Type Alias in TypeScript\nDESCRIPTION: This complex type alias recursively maps query options to their results. It handles variable-length arrays and has safeguards against excessive recursion depth. The type is used in the context of TanStack Query to type the results of multiple queries.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/queriesresults.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype QueriesResults<T, TResult, TDepth>: TDepth[\"length\"] extends MAXIMUM_DEPTH ? QueryObserverResult[] : T extends [] ? [] : T extends [infer Head] ? [...TResult, GetResults<Head>] : T extends [infer Head, ...(infer Tail)] ? QueriesResults<[...Tail], [...TResult, GetResults<Head>], [...TDepth, 1]> : T extends QueryObserverOptionsForCreateQueries<infer TQueryFnData, infer TError, infer TData, any>[] ? QueryObserverResult<unknown extends TData ? TQueryFnData : TData, unknown extends TError ? DefaultError : TError>[] : QueryObserverResult[];\n```\n\n----------------------------------------\n\nTITLE: Fetching Multiple Queries in Parallel with useQueries in React Query (TSX)\nDESCRIPTION: Introduces the `useQueries` hook in React Query v3, designed for fetching a variable number of queries concurrently. This overcomes the limitation of calling `useQuery` inside loops or conditionals. The example shows fetching two different posts by providing an array of query configuration objects. Requires React Query v3.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQueries } from 'react-query'\n\nfunction Overview() {\n  const results = useQueries([\n    { queryKey: ['post', 1], queryFn: fetchPost },\n    { queryKey: ['post', 2], queryFn: fetchPost },\n  ])\n  return (\n    <ul>\n      {results.map(({ data }) => data && <li key={data.id}>{data.title})</li>)}\n    </ul>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Core Functionality Separately in React Query (TSX)\nDESCRIPTION: Demonstrates how to import non-React-specific parts of the React Query library (v3 onwards), such as `QueryClient`, directly from the `react-query/core` entry point. This facilitates using the core data-fetching and caching logic in non-React environments or for building custom integrations outside of React hooks. Requires React Query v3.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_22\n\nLANGUAGE: tsx\nCODE:\n```\nimport { QueryClient } from 'react-query/core'\n```\n\n----------------------------------------\n\nTITLE: BroadcastQueryClient Function Signature in TSX\nDESCRIPTION: Function signature showing the basic usage of broadcastQueryClient with its parameters.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/broadcastQueryClient.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nbroadcastQueryClient({ queryClient, broadcastChannel })\n```\n\n----------------------------------------\n\nTITLE: Dynamic Devtools Loading with Keyboard Shortcut\nDESCRIPTION: Advanced setup that enables on-demand loading of devtools via a keyboard shortcut (Meta+Ctrl+Shift+D) even in production, using RxJS observables and Angular signals to trigger lazy loading.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/devtools.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n@Injectable({ providedIn: 'root' })\nclass DevtoolsOptionsManager {\n  loadDevtools = toSignal(\n    fromEvent<KeyboardEvent>(document, 'keydown').pipe(\n      map(\n        (event): boolean =>\n          event.metaKey && event.ctrlKey && event.shiftKey && event.key === 'D',\n      ),\n      scan((acc, curr) => acc || curr, false),\n    ),\n    {\n      initialValue: false,\n    },\n  )\n}\n\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideHttpClient(),\n    provideTanStackQuery(\n      new QueryClient(),\n      withDevtools(() => ({\n        initialIsOpen: true,\n        loadDevtools: inject(DevtoolsOptionsManager).loadDevtools(),\n      })),\n    ),\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Installing ESLint Plugin for TanStack Query with pnpm\nDESCRIPTION: Command to install the TanStack Query ESLint plugin as a development dependency using pnpm.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/eslint-plugin-query.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm add -D @tanstack/eslint-plugin-query\n```\n\n----------------------------------------\n\nTITLE: Defining InjectMutationStateOptions Interface in TypeScript for Angular Query\nDESCRIPTION: This code snippet defines the InjectMutationStateOptions interface with an optional injector property of type Injector. This interface is used in the inject-mutation-state functionality of the TanStack Angular Query experimental package.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/interfaces/injectmutationstateoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\noptional injector: Injector;\n```\n\n----------------------------------------\n\nTITLE: Declaring mutateAsync Property in CreateBaseMutationResult\nDESCRIPTION: Defines the mutateAsync property within CreateBaseMutationResult, which is typed as CreateMutateAsyncFunction with the same generic parameters as its parent type.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/createbasemutationresult.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nmutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TContext>\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Logging with setLogger in React Query (TSX)\nDESCRIPTION: Demonstrates replacing the deprecated `setConsole` with the `setLogger` function in React Query v3 for custom logging integration. Examples show integrating with external logging libraries like Sentry or Winston by providing an object adhering to the expected logger interface (`log`, `warn`, `error`). Requires React Query v3.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nimport { setLogger } from 'react-query'\n\n// Log with Sentry\nsetLogger({\n  error: (error) => {\n    Sentry.captureException(error)\n  },\n})\n\n// Log with Winston\nsetLogger(winston.createLogger())\n```\n\n----------------------------------------\n\nTITLE: Fetching Data with SolidJS createResource\nDESCRIPTION: This snippet demonstrates fetching data from a remote API using SolidJS's built-in `createResource` primitive. It shows how to handle loading states with `Suspense` and error states with `ErrorBoundary` when fetching data asynchronously within a SolidJS component.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/overview.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport { createResource, ErrorBoundary, Suspense } from 'solid-js'\nimport { render } from 'solid-js/web'\n\nfunction App() {\n  const [repository] = createResource(async () => {\n    const result = await fetch('https://api.github.com/repos/TanStack/query')\n    if (!result.ok) throw new Error('Failed to fetch data')\n    return result.json()\n  })\n\n  return (\n    <div>\n      <div>Static Content</div>\n      {/* An error while fetching will be caught by the ErrorBoundary */}\n      <ErrorBoundary fallback={<div>Something went wrong!</div>}>\n        {/* Suspense will trigger a loading state while the data is being fetched */}\n        <Suspense fallback={<div>Loading...</div>}>\n          <div>{repository()?.updated_at}</div>\n        </Suspense>\n      </ErrorBoundary>\n    </div>\n  )\n}\n\nconst root = document.getElementById('root')\n\nrender(() => <App />, root!)\n```\n```\n\n----------------------------------------\n\nTITLE: Installing and Running TanStack Query Example - NPM Commands\nDESCRIPTION: Basic npm commands to install dependencies and start the development server for a TanStack Query example project.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/optimistic-updates-ui/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Running TanStack Query Example with npm\nDESCRIPTION: Commands for setting up and running a TanStack Query example project. First install dependencies with npm install, then start the development server with npm run dev.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/auto-refetching/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Creating New Svelte Project using NPM\nDESCRIPTION: Commands for creating a new Svelte project either in the current directory or in a specified directory using create-svelte.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/svelte/auto-refetching/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# create a new project in the current directory\nnpm create svelte@latest\n\n# create a new project in my-app\nnpm create svelte@latest my-app\n```\n\n----------------------------------------\n\nTITLE: Installing and Running TanStack Query Example Project with npm\nDESCRIPTION: Commands for setting up and running a TanStack Query example project. First installs all necessary dependencies using npm install, then starts the development server using npm run dev.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/default-query-function/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Starting Next.js Development Server\nDESCRIPTION: Commands to run the Next.js development server using different package managers (npm, yarn, or pnpm). The server will start on localhost:3000 by default.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/nextjs-app-prefetching/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n# or\nyarn dev\n# or\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Starting Svelte Development Server\nDESCRIPTION: Commands for starting the development server, with an option to automatically open the app in a new browser tab.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/svelte/basic/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n\n# or start the server and open the app in a new browser tab\nnpm run dev -- --open\n```\n\n----------------------------------------\n\nTITLE: Using React Query via CDN (HTML)\nDESCRIPTION: Includes React Query directly in an HTML file using an ESM-compatible CDN (esm.sh). This method is suitable for projects without a build system or package manager. It imports React, ReactDOM, and the `QueryClient` from React Query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/installation.md#2025-04-23_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<script type=\"module\">\n  import React from 'https://esm.sh/react@18.2.0'\n  import ReactDOM from 'https://esm.sh/react-dom@18.2.0'\n  import { QueryClient } from 'https://esm.sh/@tanstack/react-query'\n</script>\n```\n\n----------------------------------------\n\nTITLE: Scheduling functions with notifyManager.schedule in Tanstack Query\nDESCRIPTION: The schedule method schedules a function to run on the next batch, which by default uses setTimeout but can be configured.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/notifyManager.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction schedule(callback: () => void): void\n```\n\n----------------------------------------\n\nTITLE: Defining NonUndefinedGuard Conditional Type in TypeScript\nDESCRIPTION: A utility type that prevents a type from being undefined. It uses a conditional type to return 'never' if the type extends undefined, otherwise it returns the original type.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/nonundefinedguard.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype NonUndefinedGuard<T>: T extends undefined ? never : T;\n```\n\n----------------------------------------\n\nTITLE: Manually Setting Online Status in TanStack Query\nDESCRIPTION: Demonstrates how to manually control the online state using setOnline(). This can be useful for testing or for applications with custom connectivity requirements.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/onlineManager.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { onlineManager } from '@tanstack/react-query'\n\n// Set to online\nonlineManager.setOnline(true)\n\n// Set to offline\nonlineManager.setOnline(false)\n```\n\n----------------------------------------\n\nTITLE: Using batch method for optimizing updates in Tanstack Query\nDESCRIPTION: The batch method allows batching all updates scheduled inside the passed callback, primarily used internally to optimize queryClient updates.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/notifyManager.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction batch<T>(callback: () => T): T\n```\n\n----------------------------------------\n\nTITLE: Setting batch function with setBatchNotifyFunction for SolidJS integration\nDESCRIPTION: The setBatchNotifyFunction sets the function to use for batched updates, allowing framework-specific optimizations like the SolidJS batch function.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/reference/notifyManager.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { notifyManager } from '@tanstack/query-core'\nimport { batch } from 'solid-js'\n\nnotifyManager.setBatchNotifyFunction(batch)\n```\n\n----------------------------------------\n\nTITLE: Updated Import Paths for Hydration Utilities in v4\nDESCRIPTION: Illustrates the change in v4 where hydration utilities (`dehydrate`, `hydrate`, `useHydrate`, `Hydrate`) are imported directly from the core `@tanstack/react-query` package. The separate `react-query/hydration` entry point has been removed.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\n- import { dehydrate, hydrate, useHydrate, Hydrate } from 'react-query/hydration' // [!code --]\n+ import { dehydrate, hydrate, useHydrate, Hydrate } from '@tanstack/react-query' // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Loading State Migration Example\nDESCRIPTION: Example showing migration from isLoading to isInitialLoading\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n-isLoading\n+isInitialLoading\n```\n\n----------------------------------------\n\nTITLE: Simplifying useQuery Configuration in React Query v3 (TSX)\nDESCRIPTION: Compares the old nested `config` object syntax for `useQuery` options (like `staleTime`) with the new flattened structure in React Query v3. Demonstrates moving options directly into the main configuration object, simplifying the hook usage. Requires React Query v3.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n// Old:\nuseQuery({\n  queryKey: 'posts',\n  queryFn: fetchPosts,\n  config: { staleTime: Infinity },\n})\n\n// New:\nuseQuery({\n  queryKey: 'posts',\n  queryFn: fetchPosts,\n  staleTime: Infinity,\n})\n```\n\n----------------------------------------\n\nTITLE: Query State Changes Example\nDESCRIPTION: Example showing changes to query states with the removal of idle state\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n- status: 'idle'\n+ status: 'loading' \n+ fetchStatus: 'idle'\n```\n\n----------------------------------------\n\nTITLE: Updated Infinite Query Implementation\nDESCRIPTION: Shows the new bi-directional infinite query implementation with updated parameter handling.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nconst {\n  data,\n  fetchNextPage,\n  fetchPreviousPage,\n  hasNextPage,\n  hasPreviousPage,\n  isFetchingNextPage,\n  isFetchingPreviousPage,\n} = useInfiniteQuery(\n  'projects',\n  ({ pageParam = 0 }) => fetchProjects(pageParam),\n  {\n    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n    getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Defining UndefinedInitialDataOptions Type Alias in TypeScript\nDESCRIPTION: Defines the UndefinedInitialDataOptions generic type alias as a composition of CreateQueryOptions and an object type, parameterized to control types for query data, error, and key. This allows the user to explicitly set initialData to undefined for queries that should have no preset value. Prerequisites include importing dependent types like CreateQueryOptions, DefaultError, and QueryKey from the TanStack Svelte-Query library. Usage requires familiarity with generics and TanStack Query's type system.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/undefinedinitialdataoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>: CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & object;\n```\n\n----------------------------------------\n\nTITLE: Query Key Migration Example\nDESCRIPTION: Example showing migration from string query keys to array query keys\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n-useQuery('todos', fetchTodos)\n+useQuery(['todos'], fetchTodos)\n```\n\n----------------------------------------\n\nTITLE: Mutation Usage Examples\nDESCRIPTION: Demonstrates the new mutation patterns using both callback and async/await approaches.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nconst { mutate } = useMutation({ mutationFn: addTodo })\n\nmutate('todo', {\n  onSuccess: (data) => {\n    console.log(data)\n  },\n  onError: (error) => {\n    console.error(error)\n  },\n  onSettled: () => {\n    console.log('settled')\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: BroadcastQueryClient Default Options in TSX\nDESCRIPTION: Default configuration options for broadcastQueryClient showing the default broadcast channel name.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/broadcastQueryClient.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n{\n  broadcastChannel = 'tanstack-query',\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Vue Query with bun\nDESCRIPTION: Command to install Vue Query using bun package manager.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/installation.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbun add @tanstack/vue-query\n```\n\n----------------------------------------\n\nTITLE: Installing @tanstack/query-persist-client-core with bun\nDESCRIPTION: Command to install the query-persist-client-core package using bun package manager.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/plugins/createPersister.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbun add @tanstack/query-persist-client-core\n```\n\n----------------------------------------\n\nTITLE: Deprecated Boolean Query Filter Flags\nDESCRIPTION: Shows the deprecated boolean flags `active?` and `inactive?` used in earlier versions of TanStack Query for filtering queries. This approach could lead to ambiguous or impossible states when flags were combined.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nactive?: boolean\n  - When set to true it will match active queries.\n  - When set to false it will match inactive queries.\ninactive?: boolean\n  - When set to true it will match inactive queries.\n  - When set to false it will match active queries.\n```\n\n----------------------------------------\n\nTITLE: Observing Infinite Query State with InfiniteQueryObserver in React Query Core (TSX)\nDESCRIPTION: Illustrates the usage of `InfiniteQueryObserver` from React Query's core library (v3 onwards) for monitoring the state of an infinite query. It shows configuring the observer with `queryKey`, `queryFn`, and pagination logic (`getNextPageParam`, `getPreviousPageParam`), then subscribing to state changes, logging results, and unsubscribing. Requires `InfiniteQueryObserver` and `QueryClient` from React Query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_17\n\nLANGUAGE: tsx\nCODE:\n```\nconst observer = new InfiniteQueryObserver(queryClient, {\n  queryKey: 'posts',\n  queryFn: fetchPosts,\n  getNextPageParam: (lastPage, allPages) => lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, allPages) => firstPage.prevCursor,\n})\n\nconst unsubscribe = observer.subscribe((result) => {\n  console.log(result)\n  unsubscribe()\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Recursive QueriesOptions Type Alias in TanStack Query (TypeScript)\nDESCRIPTION: This type alias provides a recursive utility for unwrapping and inferring type parameters for query observer options arrays in TanStack Query's Svelte adapter. It accepts generic parameters for input query types, accumulates results, and tracks recursion depth, returning appropriate observer options based on tuple structure. This enables strongly-typed support for multiple queries while preventing excessive recursion with a maximum depth check. Dependencies include other type utilities such as QueryObserverOptionsForCreateQueries and GetQueryObserverOptionsForCreateQueries.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/queriesoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype QueriesOptions<T, TResults, TDepth>: TDepth[\"length\"] extends MAXIMUM_DEPTH ? QueryObserverOptionsForCreateQueries[] : T extends [] ? [] : T extends [infer Head] ? [...TResults, GetQueryObserverOptionsForCreateQueries<Head>] : T extends [infer Head, ...(infer Tails)] ? QueriesOptions<[...Tails], [...TResults, GetQueryObserverOptionsForCreateQueries<Head>], [...TDepth, 1]> : ReadonlyArray<unknown> extends T ? T : T extends QueryObserverOptionsForCreateQueries<infer TQueryFnData, infer TError, infer TData, infer TQueryKey>[] ? QueryObserverOptionsForCreateQueries<TQueryFnData, TError, TData, TQueryKey>[] : QueryObserverOptionsForCreateQueries[];\n```\n\n----------------------------------------\n\nTITLE: Defining CreateMutateFunction Type Alias in TypeScript\nDESCRIPTION: Defines a type alias for creating mutation functions with generic type parameters. The function takes variable arguments matching MutateFunction parameters and returns void. Default type parameters are unknown for TData and TContext, DefaultError for TError, and void for TVariables.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/createmutatefunction.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype CreateMutateFunction<TData, TError, TVariables, TContext>: (...args) => void;\n```\n\n----------------------------------------\n\nTITLE: Property Definitions for HydrationBoundary - TypeScript\nDESCRIPTION: Defines key properties such as $$, $$events_def, $$prop_def, $$set, and $$slot_def used internally or for type checking in the HydrationBoundary Svelte class. These properties are largely for advanced type support or internal Svelte behavior and are not intended for public use. Requires Svelte with TypeScript and should be used only as indicated in Svelte type definitions.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/classes/hydrationboundary.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n$$: any\n```\n\nLANGUAGE: typescript\nCODE:\n```\n$$events_def: Events\n```\n\nLANGUAGE: typescript\nCODE:\n```\n$$prop_def: Props\n```\n\nLANGUAGE: typescript\nCODE:\n```\n$$set: any\n```\n\nLANGUAGE: typescript\nCODE:\n```\n$$slot_def: Slots\n```\n\n----------------------------------------\n\nTITLE: Observing Multiple Queries State with QueriesObserver in React Query Core (TSX)\nDESCRIPTION: Shows how to use the `QueriesObserver` class from React Query's core library (v3 onwards) to monitor the combined state of multiple queries simultaneously. It demonstrates creating the observer with an array of query configuration objects, subscribing to receive an array of results, logging them, and unsubscribing. Requires `QueriesObserver` and `QueryClient` from React Query.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-23_snippet_18\n\nLANGUAGE: tsx\nCODE:\n```\nconst observer = new QueriesObserver(queryClient, [\n  { queryKey: ['post', 1], queryFn: fetchPost },\n  { queryKey: ['post', 2], queryFn: fetchPost },\n])\n\nconst unsubscribe = observer.subscribe((result) => {\n  console.log(result)\n  unsubscribe()\n})\n```\n\n----------------------------------------\n\nTITLE: Setting initialData to undefined in TypeScript Option Shape\nDESCRIPTION: Specifies the shape of the initialData property within UndefinedInitialDataOptions, explicitly typing it as optional and only allowing undefined. This ensures that consumers of the type cannot provide any initial data, reinforcing the behavior of queries starting with no preset value. This snippet depends on its embedding within an appropriate options object in the TanStack Svelte-Query library.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/undefinedinitialdataoptions.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\noptional initialData: undefined;\n```\n\n----------------------------------------\n\nTITLE: Installing Angular Query with bun\nDESCRIPTION: Command to install the experimental Angular Query package using bun. This package is compatible with Angular v16 and higher but is currently in experimental stage.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/installation.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbun add @tanstack/angular-query-experimental\n```\n\n----------------------------------------\n\nTITLE: Installing ESLint Plugin for TanStack Query with bun\nDESCRIPTION: Command to install the TanStack Query ESLint plugin as a development dependency using bun.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/eslint-plugin-query.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbun add -D @tanstack/eslint-plugin-query\n```\n\n----------------------------------------\n\nTITLE: Persister Function Definition\nDESCRIPTION: Function signature and type definition for the experimental_createPersister utility.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/createPersister.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nexperimental_createPersister(options: StoragePersisterOptions)\n```\n\n----------------------------------------\n\nTITLE: Defining UndefinedInitialDataOptions Type Alias in TypeScript\nDESCRIPTION: This snippet defines a type alias for UndefinedInitialDataOptions, which extends CreateQueryOptions and includes an optional undefined initialData property. It uses generic type parameters for query function data, error, data, and query key.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/undefinedinitialdataoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>: CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & object;\n```\n\n----------------------------------------\n\nTITLE: Installing Solid Query Devtools via Package Managers (Bash)\nDESCRIPTION: Installs the `@tanstack/solid-query-devtools` package using common JavaScript package managers (npm, pnpm, yarn, bun). This package is required to use the Solid Query Devtools component.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/devtools.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @tanstack/solid-query-devtools\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @tanstack/solid-query-devtools\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @tanstack/solid-query-devtools\n```\n\nLANGUAGE: bash\nCODE:\n```\nbun add @tanstack/solid-query-devtools\n```\n\n----------------------------------------\n\nTITLE: Running TanStack Query Angular Example Commands\nDESCRIPTION: Terminal commands for installing dependencies and starting the TanStack Query Angular example. Multiple package manager options are provided including npm, yarn, pnpm, and bun.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/angular/basic/README.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- `npm install` or `yarn` or `pnpm i` or `bun i`\n- `npm run start` or `yarn start` or `pnpm start` or `bun start`\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Package Managers\nDESCRIPTION: Commands for installing project dependencies using npm, yarn, pnpm, or bun package managers.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/vue/simple/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\nyarn\npnpm i\nbun i\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Package Managers\nDESCRIPTION: Commands for installing project dependencies using different package managers (npm, yarn, pnpm, or bun).\nSOURCE: https://github.com/tanstack/query/blob/main/examples/angular/devtools-panel/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm i\n```\n\nLANGUAGE: bash\nCODE:\n```\nbun i\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Package Managers\nDESCRIPTION: Commands for installing project dependencies using npm, yarn, pnpm, or bun package managers.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/vue/2.6-basic/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn\n```\n\nLANGUAGE: shell\nCODE:\n```\npnpm i\n```\n\nLANGUAGE: shell\nCODE:\n```\nbun i\n```\n\n----------------------------------------\n\nTITLE: Defining DefinedCreateQueryResult Type Alias in TypeScript\nDESCRIPTION: Type alias that maps a query observer result to Angular signals. Takes three generic type parameters: TData for the data type, TError for error handling (defaults to DefaultError), and TDefinedQueryObserver for the query observer result type.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/reference/type-aliases/definedcreatequeryresult.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype DefinedCreateQueryResult<TData, TError, TDefinedQueryObserver>: MapToSignals<TDefinedQueryObserver>;\n```\n\n----------------------------------------\n\nTITLE: Defining the MutationStateOptions Type Alias in TypeScript\nDESCRIPTION: This snippet defines the `MutationStateOptions` type alias in TypeScript. It's a generic type used to specify options for the `useMutationState` hook in Svelte Query, allowing customization through filters and a select function. The generic parameter `TResult` defaults to `MutationState`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/reference/type-aliases/mutationstateoptions.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype MutationStateOptions<TResult>: object;\n```\n\n----------------------------------------\n\nTITLE: Installing and Running TanStack Query Star Wars Example\nDESCRIPTION: Commands for setting up and running the TanStack Query Star Wars example project. First installs dependencies, then starts the development server.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/svelte/star-wars/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies and Running TanStack Query Example\nDESCRIPTION: Commands to install the project dependencies and start the development server using pnpm. The first command installs all required packages, and the second command starts the development server.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/shadow-dom/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm install\n```\n\nLANGUAGE: shell\nCODE:\n```\npnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Installing and Running TanStack Query Example\nDESCRIPTION: Commands for installing dependencies and starting the development server using either npm or yarn package managers\nSOURCE: https://github.com/tanstack/query/blob/main/examples/vue/persister/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\nnpm run dev\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn\nyarn dev\n```\n\n----------------------------------------\n\nTITLE: Installing and Running TanStack Query Example Project\nDESCRIPTION: Commands for setting up and running the TanStack Query example. The first command installs all required dependencies, and the second starts the development server.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/optimistic-updates-cache/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Installing and Running Tanstack Query Example in Shell\nDESCRIPTION: Terminal commands for setting up and running the Tanstack Query example project. First installs dependencies with pnpm, then starts the development server.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/suspense/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm install\n```\n\nLANGUAGE: shell\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Package Managers\nDESCRIPTION: Commands to install project dependencies using different package managers including npm, yarn, pnpm, and bun.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/angular/simple/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm i\n```\n\nLANGUAGE: bash\nCODE:\n```\nbun i\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for TanStack Query Example\nDESCRIPTION: Command to install all required dependencies for the TanStack Query example project using npm.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/basic/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Package Managers\nDESCRIPTION: Commands for installing project dependencies using different package managers (npm, yarn, or pnpm).\nSOURCE: https://github.com/tanstack/query/blob/main/examples/vue/2.7-basic/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn\n```\n\nLANGUAGE: shell\nCODE:\n```\npnpm i\n```\n\n----------------------------------------\n\nTITLE: Creating SolidStart Projects with NPM\nDESCRIPTION: Commands for initializing a new SolidStart project either in the current directory or in a new specified directory.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/solid/solid-start-streaming/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# create a new project in the current directory\nnpm init solid@latest\n\n# create a new project in my-app\nnpm init solid@latest my-app\n```\n\n----------------------------------------\n\nTITLE: Installing and Running TanStack Query Example\nDESCRIPTION: Commands to install dependencies and start the development server for a TanStack Query example project\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/prefetching/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Installing and Running React Router Example with TanStack Query\nDESCRIPTION: Instructions for setting up and running the React Router integration example with TanStack Query. It requires installing dependencies using npm and then starting the development server.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/react-router/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for TanStack Query Example\nDESCRIPTION: Commands to install project dependencies using either npm or yarn package manager.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/vue/dependent-queries/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn\n```\n\n----------------------------------------\n\nTITLE: Installing and Running TanStack Query Example in bash\nDESCRIPTION: Commands to install dependencies and start the development server for a TanStack Query example project. First installs all required packages with npm install, then runs the development server with npm run dev.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/basic-graphql-request/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Creating New Svelte Projects\nDESCRIPTION: Commands for creating new Svelte projects either in the current directory or in a specified folder using npm create svelte.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/svelte/optimistic-updates/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# create a new project in the current directory\nnpm create svelte@latest\n\n# create a new project in my-app\nnpm create svelte@latest my-app\n```\n\n----------------------------------------\n\nTITLE: Installing and Running TanStack Query Example\nDESCRIPTION: Commands to install project dependencies and start the example application using npm.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/solid/basic-graphql-request/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm run start\n```\n\n----------------------------------------\n\nTITLE: Starting the TanStack Query Angular Example\nDESCRIPTION: Commands to start the TanStack Query Angular optimistic updates example application using various package managers (npm, yarn, pnpm, or bun).\nSOURCE: https://github.com/tanstack/query/blob/main/examples/angular/optimistic-updates/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run start\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn start\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm start\n```\n\nLANGUAGE: bash\nCODE:\n```\nbun start\n```\n\n----------------------------------------\n\nTITLE: Installing ESLint Plugin for TanStack Query with npm\nDESCRIPTION: Command to install the TanStack Query ESLint plugin as a development dependency using npm.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/eslint-plugin-query.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i -D @tanstack/eslint-plugin-query\n```\n\n----------------------------------------\n\nTITLE: Creating New Svelte Project with create-svelte\nDESCRIPTION: Commands for initializing a new Svelte project either in the current directory or in a specified directory using create-svelte.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/svelte/basic/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# create a new project in the current directory\nnpm create svelte@latest\n\n# create a new project in my-app\nnpm create svelte@latest my-app\n```\n\n----------------------------------------\n\nTITLE: Running TanStack Query Example in Development Mode (Bash)\nDESCRIPTION: This command starts the TanStack Query example project in development mode using npm.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/load-more-infinite-scroll/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Starting a SvelteKit Development Server\nDESCRIPTION: Commands for launching a development server after installing project dependencies. Includes an option to automatically open the app in a new browser tab.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/svelte/ssr/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n\n# or start the server and open the app in a new browser tab\nnpm run dev -- --open\n```\n\n----------------------------------------\n\nTITLE: Starting Development Server for TanStack Query Example\nDESCRIPTION: Command to start the development server for the TanStack Query example project.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/basic/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Building a SvelteKit Project for Production\nDESCRIPTION: Command for creating a production-ready build of a SvelteKit application. This prepares the app for deployment to a live environment.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/svelte/ssr/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Starting the Expo Project with pnpm\nDESCRIPTION: This command starts the Expo development server for the TanStack Query example project using pnpm.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/react-native/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm start\n```\n\n----------------------------------------\n\nTITLE: Installing and Running TanStack Query Example (npm)\nDESCRIPTION: Commands to install dependencies and start the TanStack Query example project using npm. Requires npm to be installed on the system.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/solid/simple/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\n```\n\nLANGUAGE: shell\nCODE:\n```\nnpm run start\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies and Running TanStack Query Example\nDESCRIPTION: These commands install the necessary dependencies and start the development server for the TanStack Query example project. Run them in sequence in the project directory.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/algolia/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Installing and Running TanStack Query Example\nDESCRIPTION: Command line instructions for installing dependencies and starting the development server for a TanStack Query example project.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/svelte/playground/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Installing and Running TanStack Query Example\nDESCRIPTION: Basic npm commands to install dependencies and start the development server for a TanStack Query example project.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/pagination/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Starting the TanStack Query Angular Example\nDESCRIPTION: Commands to start the application after installing dependencies, using different package managers.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/angular/infinite-query-with-max-pages/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run start\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn start\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm start\n```\n\nLANGUAGE: bash\nCODE:\n```\nbun start\n```\n\n----------------------------------------\n\nTITLE: Installing TanStack Solid Query via Yarn - Bash\nDESCRIPTION: Installs the @tanstack/solid-query package with Yarn, offering another package manager choice in the Node.js ecosystem. Yarn must be previously installed. After running this command, Solid Query can be required or imported in your code.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/installation.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @tanstack/solid-query\n```\n\n----------------------------------------\n\nTITLE: Installing Vue Query Package\nDESCRIPTION: Different package manager commands to install the @tanstack/vue-query package. Includes options for npm, pnpm, yarn, and bun.\nSOURCE: https://github.com/tanstack/query/blob/main/packages/vue-query/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm i @tanstack/vue-query\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ pnpm add @tanstack/vue-query\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn add @tanstack/vue-query\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ bun add @tanstack/vue-query\n```\n\n----------------------------------------\n\nTITLE: Starting Next.js Development Server\nDESCRIPTION: Commands to start the Next.js development server using different package managers. The server can be started using npm, yarn, or pnpm.\nSOURCE: https://github.com/tanstack/query/blob/main/integrations/react-next-14/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n# or\nyarn dev\n# or\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Installing React Query Devtools via Package Manager\nDESCRIPTION: Commands for installing the React Query Devtools package using npm, pnpm, yarn, or bun.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/devtools.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @tanstack/react-query-devtools\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @tanstack/react-query-devtools\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @tanstack/react-query-devtools\n```\n\nLANGUAGE: bash\nCODE:\n```\nbun add @tanstack/react-query-devtools\n```\n\n----------------------------------------\n\nTITLE: Running End-to-End Tests\nDESCRIPTION: Command to run end-to-end tests using the configured testing platform.\nSOURCE: https://github.com/tanstack/query/blob/main/integrations/angular-cli-19/README.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nng e2e\n```\n\n----------------------------------------\n\nTITLE: Starting Svelte Development Server\nDESCRIPTION: Commands to start the Svelte development server. Includes an option to automatically open the app in a new browser tab.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/svelte/load-more-infinite-scroll/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n\n# or start the server and open the app in a new browser tab\nnpm run dev -- --open\n```\n\n----------------------------------------\n\nTITLE: Running Development Server\nDESCRIPTION: Commands for starting the development server using different package managers.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/vue/simple/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm run dev\nyarn dev\npnpm dev\nbun dev\n```\n\n----------------------------------------\n\nTITLE: Starting Nuxt 3 Development Server\nDESCRIPTION: Command to start the development server which runs on localhost:3000.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/vue/nuxt3/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn dev\n```\n\n----------------------------------------\n\nTITLE: Installing @tanstack/svelte-query via Package Managers (Bash)\nDESCRIPTION: These commands demonstrate how to install the `@tanstack/svelte-query` library using different package managers: npm, pnpm, yarn, and bun. Choose the command corresponding to the package manager used in your project.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/svelte/installation.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @tanstack/svelte-query\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @tanstack/svelte-query\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @tanstack/svelte-query\n```\n\nLANGUAGE: bash\nCODE:\n```\nbun add @tanstack/svelte-query\n```\n\n----------------------------------------\n\nTITLE: TypeScript Codemod Command\nDESCRIPTION: Command to run the migration codemod for TypeScript/TSX files\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpx jscodeshift ./path/to/src/ \\\n  --extensions=ts,tsx \\\n  --parser=tsx \\\n  --transform=./node_modules/@tanstack/react-query/codemods/v4/replace-import-specifier.js\n```\n\n----------------------------------------\n\nTITLE: Starting the Application with Package Managers\nDESCRIPTION: Commands for starting the Angular application using different package managers (npm, yarn, pnpm, or bun).\nSOURCE: https://github.com/tanstack/query/blob/main/examples/angular/devtools-panel/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run start\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn start\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm start\n```\n\nLANGUAGE: bash\nCODE:\n```\nbun start\n```\n\n----------------------------------------\n\nTITLE: Installing and Running TanStack Query Example\nDESCRIPTION: Commands for installing dependencies and starting the TanStack Query example application in development mode.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/infinite-query-with-max-pages/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Creating a New SvelteKit Project with create-svelte\nDESCRIPTION: Commands for initializing a new SvelteKit project either in the current directory or in a specified folder. Uses the create-svelte package to scaffold a new project.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/svelte/ssr/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# create a new project in the current directory\nnpm create svelte@latest\n\n# create a new project in my-app\nnpm create svelte@latest my-app\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Package Managers\nDESCRIPTION: Commands to install project dependencies using npm, yarn, pnpm, or bun package managers.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/vue/basic/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n# or\nyarn\n# or\npnpm i\n# or\nbun i\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for TanStack Query Angular Example\nDESCRIPTION: Commands for installing project dependencies using npm, yarn, pnpm, or bun package managers.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/angular/auto-refetching/README.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- `npm install` or `yarn` or `pnpm i` or `bun i`\n```\n\n----------------------------------------\n\nTITLE: Installing and Starting the TanStack Query Angular Router Example\nDESCRIPTION: Instructions for installing dependencies and starting the example application. Multiple package manager options are provided including npm, yarn, pnpm, and bun.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/angular/router/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install # or yarn or pnpm i or bun i\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm run start # or yarn start or pnpm start or bun start\n```\n\n----------------------------------------\n\nTITLE: Building Svelte Project for Production\nDESCRIPTION: Command to create a production build of the Svelte application.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/svelte/auto-refetching/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Astro Project Structure Overview\nDESCRIPTION: Directory structure showing the basic layout of an Astro minimal project including public directory, src/pages directory, and package.json\nSOURCE: https://github.com/tanstack/query/blob/main/examples/solid/astro/README.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n/\n‚îú‚îÄ‚îÄ public/\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îî‚îÄ‚îÄ pages/\n‚îÇ       ‚îî‚îÄ‚îÄ index.astro\n‚îî‚îÄ‚îÄ package.json\n```\n\n----------------------------------------\n\nTITLE: Removed Undocumented executeMutation Method from QueryClient\nDESCRIPTION: Displays the signature of the undocumented `executeMutation` method, which has been removed from the `QueryClient` in v4 as it was unused internally and merely wrapped a `mutationCache` method. The underlying functionality remains accessible via the `mutationCache`.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-23_snippet_17\n\nLANGUAGE: tsx\nCODE:\n```\n- executeMutation< // [!code --]\n-   TData = unknown, // [!code --]\n-   TError = unknown, // [!code --]\n-   TVariables = void, // [!code --]\n-   TContext = unknown // [!code --]\n- >( // [!code --]\n-   options: MutationOptions<TData, TError, TVariables, TContext> // [!code --]\n- ): Promise<TData> { // [!code --]\n-   return this.mutationCache.build(this, options).execute() // [!code --]\n- } // [!code --]\n```\n\n----------------------------------------\n\nTITLE: Running Package-Specific Tests with Nx\nDESCRIPTION: Command pattern for running tests for a specific package in the TanStack Query monorepo using Nx. This ensures proper dependency resolution and test environment setup.\nSOURCE: https://github.com/tanstack/query/blob/main/CONTRIBUTING.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx run @tanstack/{package-name}:test:lib\n```\n\n----------------------------------------\n\nTITLE: Generating Angular Components\nDESCRIPTION: Angular CLI command for scaffolding new components and other Angular artifacts including directives, pipes, services, classes, guards, interfaces, enums, and modules.\nSOURCE: https://github.com/tanstack/query/blob/main/integrations/angular-cli-19/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nng generate component component-name\n```\n\n----------------------------------------\n\nTITLE: Defining Documentation Page Metadata and Replacements in YAML\nDESCRIPTION: This YAML block defines configuration for a documentation page. It sets the page `id` ('query-keys'), `title` ('Query Keys'), and a `ref` pointing to the source markdown file. The `replace` section specifies key-value pairs for string substitution, primarily adapting TanStack Query hook syntax from React Query (`@tanstack/react-query`) to Solid Query (`@tanstack/solid-query`) by adding arrow function wrappers (`() =>`).\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/guides/query-keys.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nid: query-keys\ntitle: Query Keys\nref: docs/framework/react/guides/query-keys.md\nreplace:\n  {\n    '@tanstack/react-query': '@tanstack/solid-query',\n    'useMutationState[(]': 'useMutationState(() => ',\n    'useMutation[(]': 'useMutation(() => ',\n    'useQuery[(]': 'useQuery(() => ',\n    'useQueries[(]': 'useQueries(() => ',\n    'useInfiniteQuery[(]': 'useInfiniteQuery(() => ',\n  }\n---\n```\n\n----------------------------------------\n\nTITLE: Configuring React Query to Solid Query Syntax Replacements\nDESCRIPTION: This JSON-like configuration block defines rules for replacing React Query hook syntax with Solid Query syntax. It targets specific hook calls (`useMutationState`, `useMutation`, `useQuery`, `useQueries`, `useInfiniteQuery`) and wraps their arguments in functions (`() => ...`) as required by Solid Query. This ensures code examples originally written for React Query are correctly presented for Solid Query users.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/guides/paginated-queries.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    '@tanstack/react-query': '@tanstack/solid-query',\n    'useMutationState[(]': 'useMutationState(() => ',\n    'useMutation[(]': 'useMutation(() => ',\n    'useQuery[(]': 'useQuery(() => ',\n    'useQueries[(]': 'useQueries(() => ',\n    'useInfiniteQuery[(]': 'useInfiniteQuery(() => ',\n  }\n```\n\n----------------------------------------\n\nTITLE: Installing Vue Query with pnpm\nDESCRIPTION: Command to install Vue Query using pnpm package manager.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/installation.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @tanstack/vue-query\n```\n\n----------------------------------------\n\nTITLE: Installing TanStack Query Async Storage Persister - Bun\nDESCRIPTION: Installation command using bun package manager\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/plugins/createAsyncStoragePersister.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbun add @tanstack/query-async-storage-persister @tanstack/react-query-persist-client\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies with pnpm\nDESCRIPTION: This command uses pnpm to install all the necessary dependencies for the TanStack Query example project.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/react-native/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for TanStack Query Angular Example\nDESCRIPTION: Commands to install the required dependencies for the TanStack Query Angular optimistic updates example using different package managers (npm, yarn, pnpm, or bun).\nSOURCE: https://github.com/tanstack/query/blob/main/examples/angular/optimistic-updates/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm i\n```\n\nLANGUAGE: bash\nCODE:\n```\nbun i\n```\n\n----------------------------------------\n\nTITLE: Installing Vue Query Devtools Package in Vue (bash)\nDESCRIPTION: These commands demonstrate how to install the component-based Vue Query devtools package using popular package managers including npm, pnpm, yarn, and bun. This installation is required to access the VueQueryDevtools component in your project. No additional configuration or dependencies beyond a compatible Vue project are necessary.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/devtools.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @tanstack/vue-query-devtools\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @tanstack/vue-query-devtools\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @tanstack/vue-query-devtools\n```\n\nLANGUAGE: bash\nCODE:\n```\nbun add @tanstack/vue-query-devtools\n```\n\n----------------------------------------\n\nTITLE: Installing Angular Query with yarn\nDESCRIPTION: Command to install the experimental Angular Query package using yarn. This package is compatible with Angular v16 and higher but is currently in experimental stage.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/angular/installation.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @tanstack/angular-query-experimental\n```\n\n----------------------------------------\n\nTITLE: Installing ESLint Plugin for TanStack Query with yarn\nDESCRIPTION: Command to install the TanStack Query ESLint plugin as a development dependency using yarn.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/eslint/eslint-plugin-query.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn add -D @tanstack/eslint-plugin-query\n```\n\n----------------------------------------\n\nTITLE: Defining Text Replacements for Solid Query Documentation Generation (JSON)\nDESCRIPTION: This JSON object specifies text replacement rules used during documentation generation. It maps strings or patterns from the source (React Query) documentation to their equivalents in the target (Solid Query) documentation, specifically changing the import path from '@tanstack/react-query' to '@tanstack/solid-query' and adapting the `useQueries` hook call signature by wrapping the argument in an arrow function.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/reference/useQueries.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    '@tanstack/react-query': '@tanstack/solid-query',\n    'useQueries[(]': 'useQueries(() => ',\n  }\n```\n\n----------------------------------------\n\nTITLE: Conceptual Client-Side Rendering Request Waterfall\nDESCRIPTION: Illustrates the typical network roundtrip sequence for a client-rendered application. It shows that separate requests are needed for the initial markup (without content), the JavaScript bundle, and finally the data query before content is displayed.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n```\n1. |-> Markup (without content)\n2.   |-> JS\n3.     |-> Query\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Replacement Rules for Solid Query Documentation Adaptation (YAML)\nDESCRIPTION: This YAML configuration block specifies key-value pairs for string replacements. It's used by a documentation generation process to automatically convert React Query specific terms, imports, and hook syntaxes (like 'React', '@tanstack/react-query', 'useQuery[()]', 'useMemo') into their corresponding Solid Query equivalents ('Solid', '@tanstack/solid-query', 'useQuery(() => ', 'createMemo'). This ensures the final documentation reflects the correct usage for the Solid framework.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/guides/placeholder-query-data.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nreplace:\n  {\n    'React': 'Solid',\n    '@tanstack/react-query': '@tanstack/solid-query',\n    'useMutationState[(]': 'useMutationState(() => ',\n    'useMutation[(]': 'useMutation(() => ',\n    'useQuery[(]': 'useQuery(() => ',\n    'useQueries[(]': 'useQueries(() => ',\n    'useInfiniteQuery[(]': 'useInfiniteQuery(() => ',\n    'useMemo': 'createMemo',\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining Page Metadata using YAML Frontmatter\nDESCRIPTION: This YAML snippet, typically found at the beginning of a Markdown file (frontmatter), defines metadata for a documentation page within the TanStack Query project. It sets the unique identifier (`id`) to `filters`, the display title (`title`) to `Filters`, and specifies the source content file path (`ref`) as `docs/framework/react/guides/filters.md`. This metadata is used by documentation frameworks (like Docusaurus) to organize, link, and render the page content correctly.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/vue/guides/filters.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nid: filters\ntitle: Filters\nref: docs/framework/react/guides/filters.md\n---\n```\n\n----------------------------------------\n\nTITLE: Starting Development Server\nDESCRIPTION: Commands to start the development server using npm, yarn, pnpm, or bun package managers.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/vue/basic/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n# or\nyarn dev\n# or\npnpm dev\n# or\nbun dev\n```\n\n----------------------------------------\n\nTITLE: Starting the TanStack Query Angular Pagination Example\nDESCRIPTION: Commands to start the application using various package managers including npm, yarn, pnpm, or bun.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/angular/pagination/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run start` or `yarn start` or `pnpm start` or `bun start\n```\n\n----------------------------------------\n\nTITLE: Starting Next.js Development Server\nDESCRIPTION: Commands to start the Next.js development server using different package managers (npm, yarn, or pnpm). The server will run on localhost:3000 by default.\nSOURCE: https://github.com/tanstack/query/blob/main/integrations/react-next-15/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n# or\nyarn dev\n# or\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Starting the Application with Package Managers\nDESCRIPTION: Commands to start the application using different package managers including npm, yarn, pnpm, and bun.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/angular/simple/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run start\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn start\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm start\n```\n\nLANGUAGE: bash\nCODE:\n```\nbun start\n```\n\n----------------------------------------\n\nTITLE: Starting SolidStart Development Server\nDESCRIPTION: Commands for starting the development server, with an option to automatically open the app in a new browser tab.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/solid/solid-start-streaming/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n\n# or start the server and open the app in a new browser tab\nnpm run dev -- --open\n```\n\n----------------------------------------\n\nTITLE: Cloning TanStack Repositories\nDESCRIPTION: Commands to clone TanStack Query and TanStack.com repositories.\nSOURCE: https://github.com/tanstack/query/blob/main/CONTRIBUTING.md#2025-04-23_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\ncd tanstack\ngit clone git@github.com:TanStack/query.git\ngit clone git@github.com:TanStack/tanstack.com.git --depth=1 --single-branch --branch=main\n```\n\n----------------------------------------\n\nTITLE: Running Development Server\nDESCRIPTION: Command to start the development server in watch mode.\nSOURCE: https://github.com/tanstack/query/blob/main/CONTRIBUTING.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npnpm run watch\n```\n\n----------------------------------------\n\nTITLE: Installing Expo CLI Globally with npm\nDESCRIPTION: This command installs the Expo CLI globally on the system, which is a prerequisite for running Expo projects.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/react/react-native/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --global expo-cli\n```\n\n----------------------------------------\n\nTITLE: Visualizing Modern Framework Request Pattern\nDESCRIPTION: Shows how modern frameworks like Next.js or Remix with prefetching can improve the client navigation experience by fetching code and data in parallel.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-23_snippet_17\n\nLANGUAGE: markdown\nCODE:\n```\n1. |> JS for <Feed>\n1. |> getFeed() + getGraphDataById()\n2.   |> JS for <GraphFeedItem>\n```\n\n----------------------------------------\n\nTITLE: Markdown Badges and Links\nDESCRIPTION: Markdown syntax for displaying project badges including build status, npm downloads, bundle size, and social media links.\nSOURCE: https://github.com/tanstack/query/blob/main/packages/react-query/README.md#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n![TanStack Query Header](https://github.com/TanStack/query/raw/main/media/repo-header.png)\n```\n\n----------------------------------------\n\nTITLE: Basic Request Waterfall Pattern\nDESCRIPTION: Illustration of a basic request waterfall pattern showing sequential loading of markup, CSS, JS, and images.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/guides/request-waterfalls.md#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n1. |-> Markup\n2.   |-> CSS\n2.   |-> JS\n2.   |-> Image\n```\n\n----------------------------------------\n\nTITLE: Example Test Command for React Query\nDESCRIPTION: Specific example showing how to run tests for the React Query package using the Nx command pattern.\nSOURCE: https://github.com/tanstack/query/blob/main/CONTRIBUTING.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nnpx nx run @tanstack/react-query:test:lib\n```\n\n----------------------------------------\n\nTITLE: Starting Svelte Development Server\nDESCRIPTION: Commands for starting the development server, with an option to automatically open in a browser tab.\nSOURCE: https://github.com/tanstack/query/blob/main/examples/svelte/optimistic-updates/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n\n# or start the server and open the app in a new browser tab\nnpm run dev -- --open\n```\n\n----------------------------------------\n\nTITLE: Defining Hook Replacements for Solid Query Adaptation\nDESCRIPTION: This configuration object specifies string replacements used during documentation processing. It maps TanStack React Query hook patterns (like '@tanstack/react-query', 'useQuery[(') to their corresponding TanStack Solid Query equivalents (like '@tanstack/solid-query', 'useQuery(() => ') to adapt content for the Solid framework.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/guides/initial-query-data.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    '@tanstack/react-query': '@tanstack/solid-query',\n    'useMutationState[(]': 'useMutationState(() => ',\n    'useMutation[(]': 'useMutation(() => ',\n    'useQuery[(]': 'useQuery(() => ',\n    'useQueries[(]': 'useQueries(() => ',\n    'useInfiniteQuery[(]': 'useInfiniteQuery(() => ',\n  }\n```\n\n----------------------------------------\n\nTITLE: HTML Link Badge Group\nDESCRIPTION: A collection of HTML badges and links showing project statistics, social media links, and community resources for TanStack Query.\nSOURCE: https://github.com/tanstack/query/blob/main/packages/react-query/README.md#2025-04-23_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<img src=\"https://static.scarf.sh/a.png?x-pxid=be2d8a11-9712-4c1d-9963-580b2d4fb133\" />\n```\n\n----------------------------------------\n\nTITLE: Defining Replacement Rules for Solid Query Documentation\nDESCRIPTION: This JSON object defines key-value pairs for replacing React Query specific strings and function call patterns with their Solid Query equivalents. This is used to automatically adapt documentation content.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/guides/invalidations-from-mutations.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    'React': 'Solid',\n    '@tanstack/react-query': '@tanstack/solid-query',\n    'useMutationState[(]': 'useMutationState(() => ',\n    'useMutation[(]': 'useMutation(() => ',\n    'useQuery[(]': 'useQuery(() => ',\n    'useQueries[(]': 'useQueries(() => ',\n    'useInfiniteQuery[(]': 'useInfiniteQuery(() => ',\n  }\n```\n\n----------------------------------------\n\nTITLE: Accessing Angular CLI Help\nDESCRIPTION: Command to display Angular CLI help information and documentation.\nSOURCE: https://github.com/tanstack/query/blob/main/integrations/angular-cli-19/README.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nng help\n```\n\n----------------------------------------\n\nTITLE: Defining Text Replacement Rules in JSON\nDESCRIPTION: This JSON object defines key-value pairs for text replacement. Keys represent the text patterns to find (e.g., '@tanstack/react-query', 'useInfiniteQuery(', 'useMutation('), and values represent the replacement text (e.g., '@tanstack/solid-query', 'useInfiniteQuery(() => ', 'useMutation(() => '). This structure is used to automatically adapt documentation content, likely transforming React Query examples to Solid Query syntax.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/solid/reference/useInfiniteQuery.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    '@tanstack/react-query': '@tanstack/solid-query',\n    'useInfiniteQuery[(]': 'useInfiniteQuery(() => ',\n    'useMutation[(]': 'useMutation(() => ',\n  }\n```\n\n----------------------------------------\n\nTITLE: Browser Compatibility Requirements (Text)\nDESCRIPTION: Specifies the minimum browser versions supported by React Query. Compatibility is ensured for recent versions of major browsers including Chrome, Firefox, Edge, Safari, iOS, and Opera. Polyfills may be required for older browser support.\nSOURCE: https://github.com/tanstack/query/blob/main/docs/framework/react/installation.md#2025-04-23_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nChrome >= 91\nFirefox >= 90\nEdge >= 91\nSafari >= 15\niOS >= 15\nOpera >= 77\n```"
  }
]