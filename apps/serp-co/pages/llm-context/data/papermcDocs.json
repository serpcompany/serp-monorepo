[
  {
    "owner": "papermc",
    "repo": "docs",
    "content": "TITLE: Registering the /flyspeed Command with Executor Lambda (Java)\nDESCRIPTION: This snippet demonstrates how to register a \"/flyspeed\" command using PaperMC Command API and Brigadier, attaching an executor lambda for execution logic. It parses a float argument ('speed'), retrieves the command sender and executor, checks for Player type, sets fly speed, and sends messaging responses according to the originating sender. Dependencies include org.bukkit.command.CommandSender, Entity, Player, and Brigadier's FloatArgumentType. Key parameters include the speed argument (float; 0-1) and the command context. Inputs are user-issued commands; outputs are feedback messages and mutation of player fly speed. Limitations: only applicable to Player entities; non-player issuers receive an error message.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/executors.md#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\nCommands.literal(\"flyspeed\")\n    .then(Commands.argument(\"speed\", FloatArgumentType.floatArg(0, 1.0f))\n        .executes(ctx -> {\n            float speed = FloatArgumentType.getFloat(ctx, \"speed\"); // Retrieve the speed argument\n            CommandSender sender = ctx.getSource().getSender(); // Retrieve the command sender\n            Entity executor = ctx.getSource().getExecutor(); // Retrieve the command executor, which may or may not be the same as the sender\n\n            // Check whether the executor is a player, as you can only set a player's flight speed\n            if (!(executor instanceof Player player)) {\n                // If a non-player tried to set their own flight speed\n                sender.sendPlainMessage(\"Only players can fly!\");\n                return Command.SINGLE_SUCCESS;\n            }\n\n            // Set the player's speed\n            player.setFlySpeed(speed);\n\n            if (sender == executor) {\n                // If the player executed the command themselves\n                player.sendPlainMessage(\"Successfully set your flight speed to \" + speed);\n                return Command.SINGLE_SUCCESS;\n            }\n\n            // If the speed was set by a different sender (Like using /execute)\n            sender.sendRichMessage(\"Successfully set <playername>'s flight speed to \" + speed, Placeholder.component(\"playername\", player.name()));\n            player.sendPlainMessage(\"Your flight speed has been set to \" + speed);\n            return Command.SINGLE_SUCCESS;\n        })\n    );\n```\n\n----------------------------------------\n\nTITLE: Separating Command Logic via Method Reference in PaperMC (Java)\nDESCRIPTION: This snippet encapsulates the command logic for the \"/flyspeed\" command into a reusable static method, improving code readability and maintainability. The createCommand() method builds the Brigadier command tree and connects execution logic using a method reference (FlightSpeedCommand::runFlySpeedLogic). runFlySpeedLogic parses the command context, validates the executor as a player, sets fly speed, and issues context-aware messages. Dependencies are the same as the lambda version, including CommandSender, Player, Brigadier, and Placeholder APIs. Inputs are command invocations with a float speed argument; outputs are side effects (player speed mutation) and confirmation/error messaging. This approach is ideal for complex commands needing modular logic.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/executors.md#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\npublic class FlightSpeedCommand {\n\n    public static LiteralArgumentBuilder<CommandSourceStack> createCommand() {\n        return Commands.literal(\"flyspeed\")\n            .then(Commands.argument(\"speed\", FloatArgumentType.floatArg(0, 1.0f))\n                .executes(FlightSpeedCommand::runFlySpeedLogic)\n            );\n    }\n\n    private static int runFlySpeedLogic(CommandContext<CommandSourceStack> ctx) {\n        float speed = FloatArgumentType.getFloat(ctx, \"speed\"); // Retrieve the speed argument\n        CommandSender sender = ctx.getSource().getSender(); // Retrieve the command sender\n        Entity executor = ctx.getSource().getExecutor(); // Retrieve the command executor, which may or may not be the same as the sender\n\n        // Check whether the executor is a player, as you can only set a player's flight speed\n        if (!(executor instanceof Player player)) {\n            // If a non-player tried to set their own flight speed\n            sender.sendPlainMessage(\"Only players can fly!\");\n            return Command.SINGLE_SUCCESS;\n        }\n\n        // Set the player's speed\n        player.setFlySpeed(speed);\n\n        if (sender == executor) {\n            // If the player executed the command themselves\n            player.sendPlainMessage(\"Successfully set your flight speed to \" + speed);\n            return Command.SINGLE_SUCCESS;\n        }\n\n        // If the speed was set by a different sender (Like using /execute)\n        sender.sendRichMessage(\"Successfully set <playername>'s flight speed to \" + speed, Placeholder.component(\"playername\", player.name()));\n        player.sendPlainMessage(\"Your flight speed has been set to \" + speed);\n        return Command.SINGLE_SUCCESS;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Adventure Components using Builders in Java\nDESCRIPTION: Demonstrates two methods for constructing Adventure `Component` objects in Java. The first example shows a sub-optimal approach where each modification creates a new immutable instance. The second, preferred method utilizes the builder pattern for efficient construction and highlights the use of static imports for conciseness.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/component-api/intro.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n// This is a sub-optimal construction of the\n// component as each change creates a new component\nfinal Component component = Component.text(\"Hello\")\n    .color(TextColor.color(0x13f832))\n    .append(Component.text(\" world!\", NamedTextColor.GREEN));\n\n/* This is an optimal use of the builder to create\n   the same component. Also note that Adventure\n   Components are designed for use with static method imports\n   to make code less verbose */\nfinal Component component = text()\n    .content(\"Hello\").color(color(0x13f832))\n    .append(text(\" world!\", GREEN))\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Configuring Gradle Repository: papermc\nDESCRIPTION: This snippet sets up the papermc Maven repository using Gradle's Groovy DSL. It defines the name and the URL of the repository. This repository hosts the necessary artifacts required for building Velocity plugins.  It allows Gradle to resolve and download project dependencies.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/getting-started/creating-your-first-plugin.mdx#_snippet_4\n\nLANGUAGE: groovy\nCODE:\n```\n    repositories {\n      maven {\n        name = 'papermc'\n        url = 'https://repo.papermc.io/repository/maven-public/'\n      }\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Registering Command Handler in PluginBootstrap (Java)\nDESCRIPTION: Demonstrates obtaining the `LifecycleEventManager` from the `BootstrapContext` within a `PluginBootstrap` class and registering an event handler for `LifecycleEvents.COMMANDS`. The provided lambda is where command registration logic should be placed. This method ensures commands are handled correctly across server reloads and is the preferred approach when using `paper-plugin.yml`.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/registration.md#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\npublic class CustomPluginBootstrap implements PluginBootstrap {\n\n    @Override\n    public void bootstrap(BootstrapContext context) {\n        context.getLifecycleManager().registerEventHandler(LifecycleEvents.COMMANDS, commands -> {\n            // register your commands here ...\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the ChatRenderer interface in a class\nDESCRIPTION: Defines a class `ChatListener` that implements both `Listener` and `ChatRenderer` interfaces. The class registers itself as a chat renderer within an event handler for `AsyncChatEvent`, allowing customized message rendering by overriding the `render` method. It emphasizes the singleton pattern for renderer instances to avoid unnecessary instantiations.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/event-api/chat-event.md#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\npublic class ChatListener implements Listener, ChatRenderer { // Implement the ChatRenderer and Listener interface\n\n    // Listen for the AsyncChatEvent\n    @EventHandler\n    public void onChat(AsyncChatEvent event) {\n        event.renderer(this); // Tell the event to use our renderer\n    }\n\n    // Override the render method\n    @Override\n    public Component render(Player source, Component sourceDisplayName, Component message, Audience viewer) {\n        // ... custom rendering logic ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Location from Paper Plugin Configuration\nDESCRIPTION: Demonstrates how to retrieve a `Location` object, a built-in Bukkit serializable type, from the plugin's main configuration file using `getConfig().getLocation(\"key\")`. This illustrates fetching complex types directly supported by the configuration API. Remember that changes made via `set` must be saved explicitly using `FileConfiguration#save`.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/plugin-configs.mdx#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npublic class TestPlugin extends JavaPlugin {\n\n    public void teleportPlayer(Player player) {\n        Location to = getConfig().getLocation(\"target_location\");\n        player.teleport(to);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cancelling a Cancellable Event in Paper API Using Java\nDESCRIPTION: Shows how to cancel an event that implements the Cancellable interface by calling setCancelled(true) inside the event handler method. This example prevents player movement by cancelling the PlayerMoveEvent. Developers must consider that other plugins could have already modified or cancelled the event, and to check for cancellation if needed. Cancelling an event typically stops the default action from occurring.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/event-api/event-listeners.md#_snippet_4\n\nLANGUAGE: Java\nCODE:\n```\npublic class ExampleListener implements Listener {\n\n    @EventHandler\n    public void onPlayerMove(PlayerMoveEvent event) {\n        event.setCancelled(true);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Define ItemStack Command Argument (Paper/Java)\nDESCRIPTION: Shows how to define a command argument for `ItemStack` using `ArgumentTypes.itemStack()`. It parses input similar to the vanilla `/give` command and allows specifying components. The parsed value is retrieved as an `ItemStack` object, which is added to the executor's inventory if they are a player. Requires Paper API, Brigadier, and Adventure API for rich messages.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/paper.mdx#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> itemStackArgument() {\n    return Commands.literal(\"itemstack\")\n        .then(Commands.argument(\"stack\", ArgumentTypes.itemStack())\n            .executes(ctx -> {\n                final ItemStack itemStack = ctx.getArgument(\"stack\", ItemStack.class);\n\n                if (ctx.getSource().getExecutor() instanceof Player player) {\n                    player.getInventory().addItem(itemStack);\n                    ctx.getSource().getSender().sendRichMessage(\"<green>Successfully gave <player> a <item>\",\n                        Placeholder.component(\"player\", player.name()),\n                        Placeholder.component(\"item\", Component.translatable(itemStack))\n                    );\n                    return Command.SINGLE_SUCCESS;\n                }\n\n                ctx.getSource().getSender().sendRichMessage(\"<red>This argument requires a player!\");\n                return Command.SINGLE_SUCCESS;\n            }))\n        .build();\n}\n```\n\n----------------------------------------\n\nTITLE: Building a LiteralCommandNode Concisely (Java)\nDESCRIPTION: Presents a more compact, chained approach to building a `LiteralCommandNode` using `Commands.literal()`, `then()`, and `build()` in a single statement. This is the common way to construct Brigadier command nodes.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/registration.md#_snippet_4\n\nLANGUAGE: Java\nCODE:\n```\nLiteralCommandNode<CommandSourceStack> buildCommand = Commands.literal(\"testcmd\")\n    .then(Commands.literal(\"argument_one\"))\n    .then(Commands.literal(\"argument_two\"))\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Implementing BasicCommand Interface - Java\nDESCRIPTION: Demonstrates the minimal structure for creating a command by implementing the `io.papermc.paper.command.brigadier.BasicCommand` interface in Java. It includes necessary imports and shows the required `execute` method override with its signature.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/misc/basic-command.md#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\npackage your.package.name;\n\nimport io.papermc.paper.command.brigadier.BasicCommand;\nimport io.papermc.paper.command.brigadier.CommandSourceStack;\nimport org.jspecify.annotations.NullMarked;\n\n@NullMarked\npublic class YourCommand implements BasicCommand {\n\n    @Override\n    public void execute(CommandSourceStack commandSourceStack, String[] args) {\n\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and setting data in the PDC on an ItemStack (Java)\nDESCRIPTION: Demonstrates creating a NamespacedKey, retrieving ItemMeta from an ItemStack, and storing a string value in the item's persistent data container. It introduces the concept of ensuring reusability of NamespacedKeys and accessing the PDC via ItemMeta.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/pdc.md#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\n// Create a NamespacedKey\nNamespacedKey key = new NamespacedKey(pluginInstance, \"example-key\");\n\nItemStack item = ItemStack.of(Material.DIAMOND);\n// ItemMeta implements PersistentDataHolder, so we can get the PDC from it\nitem.editMeta(meta -> {\n    meta.getPersistentDataContainer().set(key, PersistentDataType.STRING, \"I love Tacos!\");\n});\n```\n\n----------------------------------------\n\nTITLE: Registering an Event Listener in the Plugin Main Class Using Java\nDESCRIPTION: Shows how to register the listener class instance with the Bukkit event system in the plugin's onEnable() lifecycle method. It uses getServer().getPluginManager().registerEvents(), passing the listener and plugin instance. This setup is essential to ensure the listener methods receive event callbacks when the server runs.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/event-api/event-listeners.md#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\npublic class ExamplePlugin extends JavaPlugin {\n\n    @Override\n    public void onEnable() {\n        getServer().getPluginManager().registerEvents(new ExampleListener(), this);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Command Source Name - Java\nDESCRIPTION: Provides a Java snippet for use within the `execute` method of a `BasicCommand`. It demonstrates how to retrieve the most appropriate name for the command sender, checking for an executor entity (like in `/execute as`) before falling back to the direct sender.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/misc/basic-command.md#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\nfinal Component name = commandSourceStack.getExecutor() != null\n    ? commandSourceStack.getExecutor().name()\n    : commandSourceStack.getSender().name();\n```\n\n----------------------------------------\n\nTITLE: Defining Plugin Permissions in YAML\nDESCRIPTION: Example of how to define permission nodes for a plugin, including descriptions, default values, and hierarchical structure with child permissions.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/plugin-yml.mdx#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\npermissions:\n  permission.node:\n    description: \"This is a permission node\"\n    default: op\n    children:\n      permission.node.child: true\n  another.permission.node:\n    description: \"This is another permission node\"\n    default: notop\n```\n\n----------------------------------------\n\nTITLE: Validating and Joining Command Arguments - Java\nDESCRIPTION: Shows Java code for processing command arguments within the `execute` method. It checks if any arguments were provided, sends an error message if not, and otherwise joins all arguments into a single string using spaces.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/misc/basic-command.md#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\nif (args.length == 0) {\n    commandSourceStack.getSender().sendRichMessage(\"<red>You cannot send an empty broadcast!\");\n    return;\n}\n\nfinal String message = String.join(\" \", args);\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Players Command Argument (Java)\nDESCRIPTION: This Java snippet defines a Brigadier command `players` using the `ArgumentTypes.players()` argument type, which accepts one or more players. It resolves the `PlayerSelectorArgumentResolver` to a `List<Player>` and iterates through the list, applying a velocity change (\"yeet\") and sending messages for each target player. Dependencies include PaperMC API components like `Commands`, `ArgumentTypes`, `PlayerSelectorArgumentResolver`, `Player`, `CommandSourceStack`, `Command`, `Placeholder`, `Vector`, and `CommandSender`.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/entity-player.mdx#_snippet_4\n\nLANGUAGE: java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> playersArgument() {\n    return Commands.literal(\"players\")\n        .then(Commands.argument(\"targets\", ArgumentTypes.players())\n            .executes(ctx -> {\n                final PlayerSelectorArgumentResolver targetResolver = ctx.getArgument(\"targets\", PlayerSelectorArgumentResolver.class);\n                final List<Player> targets = targetResolver.resolve(ctx.getSource());\n                final CommandSender sender = ctx.getSource().getSender();\n\n                for (final Player target : targets) {\n                    target.setVelocity(new Vector(0, 100, 0));\n                    target.sendRichMessage(\"<rainbow>Yeeeeeeeeeet\");\n\n                    sender.sendRichMessage(\"Yeeted <target>!\",\n                        Placeholder.component(\"target\", target.name())\n                    );\n                }\n                return Command.SINGLE_SUCCESS;\n            }))\n        .build();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a giveitem command with amount suggestions in Minecraft/Java\nDESCRIPTION: Complete implementation of a /giveitem command that suggests common item amounts (1, 16, 32, 64) to players. The command validates that the executor is a player, checks for inventory space, and gives the specified item in the requested amount.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/argument-suggestions.mdx#_snippet_4\n\nLANGUAGE: java\nCODE:\n```\n@NullMarked\npublic class SuggestionsTest {\n\n    public static LiteralCommandNode<CommandSourceStack> constructGiveItemCommand() {\n        // Create new command: /giveitem\n        return Commands.literal(\"giveitem\")\n\n            // Require a player to execute the command\n            .requires(ctx -> ctx.getExecutor() instanceof Player)\n\n            // Declare a new ItemStack argument\n            .then(Commands.argument(\"item\", ArgumentTypes.itemStack())\n\n                // Declare a new integer argument with the bounds of 1 to 99\n                .then(Commands.argument(\"amount\", IntegerArgumentType.integer(1, 99))\n\n                    // Here, we use method references, since otherwise, our command definition would grow too big\n                    .suggests(SuggestionsTest::getAmountSuggestions)\n                    .executes(SuggestionsTest::executeCommandLogic)\n\n                )\n            )\n            .build();\n    }\n\n    private static CompletableFuture<Suggestions> getAmountSuggestions(final CommandContext<CommandSourceStack> ctx, final SuggestionsBuilder builder) {\n        // Suggest 1, 16, 32, and 64 to the user when they reach the 'amount' argument\n        builder.suggest(1);\n        builder.suggest(16);\n        builder.suggest(32);\n        builder.suggest(64);\n        return builder.buildFuture();\n    }\n\n    private static int executeCommandLogic(final CommandContext<CommandSourceStack> ctx) {\n        // We know that the executor will be a player, so we can just silently return\n        if (!(ctx.getSource().getExecutor() instanceof Player player)) {\n            return Command.SINGLE_SUCCESS;\n        }\n\n        // If the player has no empty slot, we tell the player that they have no free inventory space\n        final int firstEmptySlot = player.getInventory().firstEmpty();\n        if (firstEmptySlot == -1) {\n            player.sendRichMessage(\"<light_purple>You do not have enough space in your inventory!\");\n            return Command.SINGLE_SUCCESS;\n        }\n\n        // Retrieve our argument values\n        final ItemStack item = ctx.getArgument(\"item\", ItemStack.class);\n        final int amount = IntegerArgumentType.getInteger(ctx, \"amount\");\n\n        // Set the item's amount and give it to the player\n        item.setAmount(amount);\n        player.getInventory().setItem(firstEmptySlot, item);\n\n        // Send a confirmation message\n        player.sendRichMessage(\"<light_purple>You have been given <white><amount>x</white> <aqua><item></aqua>!\",\n            Placeholder.component(\"amount\", Component.text(amount)),\n            Placeholder.component(\"item\", Component.translatable(item).hoverEvent(item))\n        );\n        return Command.SINGLE_SUCCESS;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PluginBootstrap in Java\nDESCRIPTION: Shows a Java class implementing the `PluginBootstrap` interface. This allows custom logic during the early plugin loading phase via the `bootstrap` method and enables customized plugin instantiation, potentially passing arguments to the constructor, through the `createPlugin` method.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/paper-plugins.md#_snippet_4\n\nLANGUAGE: java\nCODE:\n```\npublic class TestPluginBootstrap implements PluginBootstrap {\n\n  @Override\n  public void bootstrap(BootstrapContext context) {\n\n  }\n\n  @Override\n  public JavaPlugin createPlugin(PluginProviderContext context) {\n    return new TestPlugin(\"My custom parameter\");\n  }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring the executes Method in Brigadier ArgumentBuilder (Java)\nDESCRIPTION: This code snippet shows the method signature for the executes method on ArgumentBuilder in Brigadier. It accepts a Command<S> functional interface, allowing you to define custom logic for when a command is executed. The type parameter S enables flexibility for different source contexts. No external dependencies are required beyond Brigadier. Expected inputs are implementing or passing a Command<S>; outputs are integer result codes for command success or failure.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/executors.md#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\npublic T executes(Command<S> command);\n```\n\n----------------------------------------\n\nTITLE: Specifying Event Priority for Listener Methods in Paper API Using Java\nDESCRIPTION: Illustrates setting the priority of an event listener method using the priority parameter in the @EventHandler annotation. In this example, EventPriority.HIGH indicates the listener should be called later in the event dispatch sequence, after lower priority listeners. The priority affects the order in which multiple plugins handle the same event.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/event-api/event-listeners.md#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\npublic class ExampleListener implements Listener {\n\n    @EventHandler(priority = EventPriority.HIGH)\n    public void onPlayerMove(PlayerMoveEvent event) {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a custom BukkitRunnable for scheduled tasks\nDESCRIPTION: Shows how to subclass BukkitRunnable to create a reusable, cancellable task that manages its own BukkitTask reference, simplifying task management and cancellation once the task's objective is fulfilled or entity is invalid.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/scheduler.md#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\n```java title=\"CustomRunnable.java\"\npublic class CustomRunnable extends BukkitRunnable {\n\n    private final UUID entityId;\n\n    public CustomRunnable(UUID uuid) {\n        this.entityId = uuid;\n    }\n\n    @Override\n    public void run() {\n        Entity entity = Bukkit.getServer().getEntity(this.entityId);\n\n        if (entity instanceof LivingEntity livingEntity) {\n            livingEntity.addPotionEffect(new PotionEffect(PotionEffectType.SPEED, 20, 1));\n            return;\n        }\n\n        this.cancel(); // Cancel if entity no longer exists\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Listener Class in Paper API Using Java\nDESCRIPTION: This snippet shows how to declare a listener class that implements the Listener interface from the Paper API. The Listener interface marks the class as able to listen to events. No methods are required yet; this serves as the foundational step for event listening in a plugin.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/event-api/event-listeners.md#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\npublic class ExampleListener implements Listener {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Obtaining BukkitScheduler instance from Server in Java\nDESCRIPTION: Demonstrates how to acquire the BukkitScheduler object from the Server class within your plugin's onEnable method to schedule tasks. This is a necessary step before scheduling any tasks.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/scheduler.md#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\n```java\n@Override\npublic void onEnable() {\n    BukkitScheduler scheduler = this.getServer().getScheduler();\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Formatted Message - Java\nDESCRIPTION: Demonstrates how to construct and send a formatted message using Adventure's MiniMessage library in Java. It creates a broadcast message with placeholders for the sender's name and the message text, then sends it to all online players via `Bukkit.broadcast`.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/misc/basic-command.md#_snippet_4\n\nLANGUAGE: Java\nCODE:\n```\nfinal Component broadcastMessage = MiniMessage.miniMessage().deserialize(\n    \"<red><bold>BROADCAST</red> <name> <dark_gray>»</dark_gray> <message>\",\n    Placeholder.component(\"name\", name),\n    Placeholder.unparsed(\"message\", message)\n);\n\nBukkit.broadcast(broadcastMessage);\n```\n\n----------------------------------------\n\nTITLE: Modifying Existing Enchantment Entry's Max Level Using Paper Registry Event in Java\nDESCRIPTION: Demonstrates modifying an existing registry entry—the Sharpness enchantment—to increase its maximum level using the entryAdd lifecycle event. It registers an event handler via LifecycleEventManager that filters for the Sharpness key and changes the builder's maxLevel property. This code runs during plugin bootstrap and affects Vanilla entries just before registry freezing. It expects a valid registry context and safely targets only specified entries.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/registries.md#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\n@Override\npublic void bootstrap(BootstrapContext context) {\n    context.getLifecycleManager().registerEventHandler(RegistryEvents.ENCHANTMENT.entryAdd()\n        // Increase the max level to 20\n        .newHandler(event -> event.builder().maxLevel(20))\n        // Configure the handler to only be called for the Vanilla sharpness enchantment.\n        .filter(EnchantmentKeys.SHARPNESS)\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Scheduling a task with Consumer<BukkitTask> for repeated or cancellable tasks\nDESCRIPTION: Illustrates how to schedule a task using the Consumer interface which provides the BukkitTask instance inside the task. Useful for tasks that need to cancel themselves, such as based on game conditions, and for creating repeating tasks with runTaskTimer.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/scheduler.md#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\n```java title=\"MyConsumerTask.java\"\npublic class MyConsumerTask implements Consumer<BukkitTask> {\n\n    private final UUID entityId;\n\n    public MyConsumerTask(UUID uuid) {\n        this.entityId = uuid;\n    }\n\n    @Override\n    public void accept(BukkitTask task) {\n        Entity entity = Bukkit.getServer().getEntity(this.entityId);\n\n        if (entity instanceof LivingEntity livingEntity) {\n            livingEntity.addPotionEffect(new PotionEffect(PotionEffectType.SPEED, 20, 1));\n            return;\n        }\n\n        task.cancel(); // Cancel if entity is no longer valid\n    }\n}\n```\n\nand\n\n```java\nscheduler.runTaskTimer(plugin, new MyConsumerTask(someEntityId), 0, 20);\n```\n\nOr with lambda:\n\n```java\nscheduler.runTaskTimer(plugin, task -> {\n    Entity entity = Bukkit.getServer().getEntity(entityId);\n\n    if (entity instanceof LivingEntity livingEntity) {\n        livingEntity.addPotionEffect(new PotionEffect(PotionEffectType.SPEED, 20, 1));\n        return;\n    }\n\n    task.cancel();\n}, 0, 20);\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Scoreboard DisplaySlot Argument in PaperMC Command API (Java)\nDESCRIPTION: Illustrates how to set up a command argument for org.bukkit.scoreboard.DisplaySlot using PaperMC's Command API. Retrieves the user's selected slot as a DisplaySlot enum and sends a plain message showing the slot's ID. Depends on proper integration of ArgumentTypes.scoreboardDisplaySlot and assumes sender can display plain text messages.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/enums.mdx#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> scoreboardDisplaySlotArgument() {\n    return Commands.literal(\"scoreboarddisplayslot\")\n        .then(Commands.argument(\"slot\", ArgumentTypes.scoreboardDisplaySlot())\n            .executes(ctx -> {\n                final DisplaySlot slot = ctx.getArgument(\"slot\", DisplaySlot.class);\n\n                ctx.getSource().getSender().sendPlainMessage(\"You selected: \" + slot.getId());\n\n                return Command.SINGLE_SUCCESS;\n            })\n        ).build();\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a BasicCommand (Java)\nDESCRIPTION: Explains how to register a `BasicCommand` object within the command event handler lambda. It uses the `commands.registrar().register()` overload that takes the command name (as a string) and the `BasicCommand` instance. This approach is simpler for commands that don't require complex argument parsing, similar to traditional Bukkit commands.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/registration.md#_snippet_6\n\nLANGUAGE: Java\nCODE:\n```\nfinal BasicCommand basicCommand = ...;\n\nthis.getLifecycleManager().registerEventHandler(LifecycleEvents.COMMANDS, commands -> {\n    commands.registrar().register(\"commandname\", basicCommand);\n});\n```\n\n----------------------------------------\n\nTITLE: Define Time Command Argument (Paper/Java)\nDESCRIPTION: Demonstrates defining a command argument for time using `ArgumentTypes.time()`, which parses inputs with 't', 's', or 'd' suffixes into ticks. The parsed integer value (in ticks) is retrieved using `IntegerArgumentType.getInteger()`. The example uses this value to advance the in-game time for a player. Requires Paper API, Brigadier, and `IntegerArgumentType`. An overload `ArgumentTypes.time(int mintime)` allows setting a minimum tick value.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/paper.mdx#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> timeArgument() {\n    return Commands.literal(\"timearg\")\n        .then(Commands.argument(\"time\", ArgumentTypes.time())\n            .executes(ctx -> {\n                final int timeInTicks = IntegerArgumentType.getInteger(ctx, \"time\");\n\n                if (ctx.getSource().getExecutor() instanceof Player player) {\n                    player.getWorld().setFullTime(player.getWorld().getFullTime() + timeInTicks);\n                    player.sendRichMessage(\"Moved time forward by \" + timeInTicks + \" ticks!\");\n                    return Command.SINGLE_SUCCESS;\n                }\n\n                ctx.getSource().getSender().sendPlainMessage(\"This argument requires a player!\");\n                return Command.SINGLE_SUCCESS;\n            })\n        ).build();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Argument Type in Java\nDESCRIPTION: Implements the `CustomArgumentType.Converted` interface to create a custom argument that converts a string input into an `IceCreamFlavor` enum. It handles conversion errors using a `DynamicCommandExceptionType` and provides tab completion suggestions based on the enum values.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/custom-arguments.md#_snippet_6\n\nLANGUAGE: java\nCODE:\n```\npackage io.papermc.commands.icecream;\n\nimport com.mojang.brigadier.arguments.ArgumentType;\nimport com.mojang.brigadier.arguments.StringArgumentType;\nimport com.mojang.brigadier.context.CommandContext;\nimport com.mojang.brigadier.exceptions.CommandSyntaxException;\nimport com.mojang.brigadier.exceptions.DynamicCommandExceptionType;\nimport com.mojang.brigadier.suggestion.Suggestions;\nimport com.mojang.brigadier.suggestion.SuggestionsBuilder;\nimport io.papermc.paper.commands.ArgumentConverters.CustomArgumentType;\nimport net.kyori.adventure.text.Component;\nimport net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;\nimport net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;\nimport net.kyori.adventure.text.serializer.plain.PlainTextComponentSerializer;\nimport net.kyori.adventure.text.serializer.ComponentSerializer;\nimport net.kyori.adventure.text.serializer.message.MessageComponentSerializer; // Assuming this exists or replace with above\nimport org.jspecify.annotations.NullMarked;\n\nimport java.util.Locale;\nimport java.util.concurrent.CompletableFuture;\n\n@NullMarked\npublic class IceCreamArgument implements CustomArgumentType.Converted<IceCreamFlavor, String> {\n\n    private static final DynamicCommandExceptionType ERROR_INVALID_FLAVOR = new DynamicCommandExceptionType(flavor -> {\n        // Using MessageComponentSerializer which is non-standard, assuming it serializes for messages\n        // Standard alternatives: GsonComponentSerializer, LegacyComponentSerializer, PlainTextComponentSerializer\n        return MessageComponentSerializer.message().serialize(Component.text(flavor + \" is not a valid flavor!\"));\n    });\n\n    @Override\n    public IceCreamFlavor convert(String nativeType) throws CommandSyntaxException {\n        try {\n            return IceCreamFlavor.valueOf(nativeType.toUpperCase(Locale.ROOT));\n        } catch (IllegalArgumentException ignored) {\n            throw ERROR_INVALID_FLAVOR.create(nativeType);\n        }\n    }\n\n    @Override\n    public <S> CompletableFuture<Suggestions> listSuggestions(CommandContext<S> context, SuggestionsBuilder builder) {\n        for (IceCreamFlavor flavor : IceCreamFlavor.values()) {\n            String name = flavor.toString();\n\n            // Only suggest if the flavor name matches the user input\n            if (name.startsWith(builder.getRemainingLowerCase())) {\n                builder.suggest(flavor.toString());\n            }\n        }\n\n        return builder.buildFuture();\n    }\n\n    @Override\n    public ArgumentType<String> getNativeType() {\n        return StringArgumentType.word();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Synchronous and Asynchronous Entity Teleportation - Java\nDESCRIPTION: This snippet demonstrates teleporting an entity to a given location both synchronously and asynchronously. The synchronous method blocks the main thread while loading chunks, while the asynchronous method avoids this, potentially improving performance.  The asynchronous method uses a `Future` to handle the completion of the teleport operation. Dependencies: PaperMC API. Inputs: `entity` (Entity object), `location` (Location object). Output: The entity is teleported. Constraints: Avoid calling `.get()` or `.join()` on the `teleportAsync` `Future` on the main thread to prevent deadlocks.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/entity-api/entity-teleport.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nentity.teleport(location); // loads chunks synchronously and teleports the entity\n\nentity.teleportAsync(location).thenAccept(success -> { // loads chunks asynchronously and teleports the entity\n    // this code is ran when the teleport completes\n    // the Future is completed on the main thread, so it is safe to use the API here\n\n    if (success) {\n        // the entity was teleported successfully!\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Scheduling a task with Runnable using BukkitScheduler\nDESCRIPTION: Shows how to schedule a simple task with a Runnable implementation, either as a separate class or using a lambda expression, to run after a specific delay in ticks. Suitable for tasks that do not require tracking their BukkitTask instance.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/scheduler.md#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\n```java title=\"MyRunnableTask.java\"\npublic class MyRunnableTask implements Runnable {\n\n    private final MyPlugin plugin;\n\n    public MyRunnableTask(MyPlugin plugin) {\n        this.plugin = plugin;\n    }\n\n    @Override\n    public void run() {\n        this.plugin.getServer().broadcast(Component.text(\"Hello, World!\"));\n    }\n}\n```\n\nand\n\n```java\nscheduler.runTaskLater(plugin, new MyRunnableTask(plugin), 20);\n```\n\nOr using a lambda:\n\n```java\nscheduler.runTaskLater(plugin, () -> {\n    this.plugin.getServer().broadcast(Component.text(\"Hello, World!\"));\n}, 20);\n```\n```\n\n----------------------------------------\n\nTITLE: Registering Command with Custom Argument in Java\nDESCRIPTION: Demonstrates how to register a command using the PaperMC command API, incorporating the custom `IceCreamArgument` type. The `executes` method shows how to retrieve the converted `IceCreamFlavor` object directly from the command context and use it.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/custom-arguments.md#_snippet_7\n\nLANGUAGE: java\nCODE:\n```\nCommands.literal(\"icecream\")\n    .then(Commands.argument(\"flavor\", new IceCreamArgument())\n        .executes(ctx -> {\n            final IceCreamFlavor flavor = ctx.getArgument(\"flavor\", IceCreamFlavor.class);\n\n            ctx.getSource().getSender().sendRichMessage(\"<b><red>Y<green>U<aqua>M<light_purple>!</b> You just had a scoop of <flavor>!\",\n                Placeholder.unparsed(\"flavor\", flavor.toString())\n            );\n            return Command.SINGLE_SUCCESS;\n        })\n    )\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Defining EntityAnchor Argument in PaperMC Command API (Java)\nDESCRIPTION: Demonstrates how to add an entity anchor argument to a command using the PaperMC Command API in Java. Requires the io.papermc.paper.entity.LookAnchor class, the PaperMC API, and relevant command framework dependencies. The snippet defines a command that accepts either \"feet\" or \"eyes\" as input and informs the command sender of their selection using LookAnchor.name(). Only valid in contexts where a CommandSourceStack provides access to a sender component.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/enums.mdx#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> entityAnchorArgument() {\n    return Commands.literal(\"entityanchor\")\n        .then(Commands.argument(\"arg\", ArgumentTypes.entityAnchor())\n            .executes(ctx -> {\n                final LookAnchor lookAnchor = ctx.getArgument(\"arg\", LookAnchor.class);\n\n                ctx.getSource().getSender().sendRichMessage(\"You chose <aqua><anchor></aqua>!\",\n                    Placeholder.unparsed(\"anchor\", lookAnchor.name())\n                );\n                return Command.SINGLE_SUCCESS;\n            }))\n        .build();\n}\n```\n\n----------------------------------------\n\nTITLE: Define UUID Command Argument (Paper/Java)\nDESCRIPTION: Shows how to define a command argument that parses a `UUID` using `ArgumentTypes.uuid()`. The parsed value is retrieved as a `UUID` object, which can be used with methods like `Bukkit.getOfflinePlayer()`. The example checks if the player associated with the UUID has played before and sends a rich message. Notes that this argument is typically for moderation/debug due to poor user-friendliness; the player profiles argument is preferred for general player lookup. Requires Paper API, Brigadier, and Adventure API.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/paper.mdx#_snippet_4\n\nLANGUAGE: java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> uuidArgument() {\n    return Commands.literal(\"uuid-lookup\")\n        .then(Commands.argument(\"uuid\", ArgumentTypes.uuid())\n            .executes(ctx -> {\n                final UUID uuid = ctx.getArgument(\"uuid\", UUID.class);\n                final OfflinePlayer result = Bukkit.getOfflinePlayer(uuid);\n\n                ctx.getSource().getSender().sendRichMessage(\"Has <aqua><uuid></aqua> played before: <result>\",\n                    Placeholder.unparsed(\"uuid\", uuid.toString()),\n                    Placeholder.parsed(\"result\", result.hasPlayedBefore() ? \"<green>true</green>\" : \"<red>false</red>\")\n                );\n\n                return Command.SINGLE_SUCCESS;\n            })\n        ).build();\n}\n```\n\n----------------------------------------\n\nTITLE: Making a Custom Event Cancellable in Paper (Java)\nDESCRIPTION: This snippet shows how to make the custom event cancellable by implementing org.bukkit.event.Cancellable. The class adds a boolean cancelled field and overrides the isCancelled and setCancelled methods. This allows listeners to prevent default event processing by calling setCancelled(true). Dependencies: org.bukkit.event.Event, org.bukkit.event.HandlerList, org.bukkit.event.Cancellable, and Component.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/event-api/custom-events.md#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\npublic class PaperIsCoolEvent extends Event implements Cancellable {\n\n    private static final HandlerList HANDLER_LIST = new HandlerList();\n    private Component message;\n    private boolean cancelled;\n\n    // ...\n\n    @Override\n    public boolean isCancelled() {\n        return this.cancelled;\n    }\n\n    @Override\n    public void setCancelled(boolean cancelled) {\n        this.cancelled = cancelled;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Enchantment Registry Command\nDESCRIPTION: This Java code snippet demonstrates how to define a command that uses a registry key for enchantments. It retrieves the selected enchantment and applies it to the player's held item at level 10, sending a success message.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/registry.mdx#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> enchantmentRegistry() {\n    return Commands.literal(\"enchants-registry\")\n        .then(Commands.argument(\"enchantment\", ArgumentTypes.resource(RegistryKey.ENCHANTMENT))\n            .executes(ctx -> {\n                final Enchantment enchantment = ctx.getArgument(\"enchantment\", Enchantment.class);\n\n                if (ctx.getSource().getExecutor() instanceof Player player) {\n                    final ItemStack stack = player.getInventory().getItemInMainHand();\n                    stack.addUnsafeEnchantment(enchantment, 10);\n                    ctx.getSource().getSender().sendRichMessage(\"Enchanted <player>'s <item> with <enchantment>!\",\n                        Placeholder.component(\"player\", player.name()),\n                        Placeholder.component(\"item\", Component.translatable(stack)),\n                        Placeholder.component(\"enchantment\", enchantment.displayName(10))\n                    );\n                    return Command.SINGLE_SUCCESS;\n                }\n\n                ctx.getSource().getSender().sendRichMessage(\"<red>This command requires a player!\");\n                return Command.SINGLE_SUCCESS;\n            }))\n        .build();\n}\n```\n\n----------------------------------------\n\nTITLE: Using RegistryAccess with TypedKey to Retrieve Registry Values in Java\nDESCRIPTION: This snippet describes how to obtain a registry from RegistryAccess using a RegistryKey. It explains how to initialize RegistryAccess via the static method, retrieve specific registry keys with TypedKey, and access registry values with Registry#get(Key). This setup is essential for querying game data resources reliably. Dependencies include the registry classes in the modding API, with methods used for registry retrieval and key management.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/registry.mdx#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\nRegistryAccess registryAccess = RegistryAccess.registryAccess();\nRegistryKey<Registry<T>> registryKey = TypedKey#registryKey();\nRegistry<T> registry = registryAccess.getRegistry(registryKey);\nT value = registry.get(TypedKey#key());\n```\n\n----------------------------------------\n\nTITLE: Adding a Plugin Dependency in Velocity\nDESCRIPTION: This code snippet demonstrates how to add a dependency on another Velocity plugin using the `@Plugin` annotation's `dependencies` parameter and the `@Dependency` annotation. The `id` attribute of `@Dependency` specifies the ID of the required plugin. This ensures the plugin loads after its dependencies.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/how-to/dependencies.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\n@Plugin(\n  id = \"myfirstplugin\",\n  name = \"My Plugin\",\n  version = \"0.1.0\",\n  dependencies = {\n    @Dependency(id = \"wonderplugin\")\n  }\n)\npublic class VelocityTest {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Component Argument in Paper Command API\nDESCRIPTION: Demonstrates how to create a command that uses the component argument to accept JSON-formatted text components. The example shows how to access the Adventure Component object and display it back to the sender.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/adventure.mdx#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> componentArgument() {\n    return Commands.literal(\"componentargument\")\n        .then(Commands.argument(\"arg\", ArgumentTypes.component())\n            .executes(ctx -> {\n                final Component component = ctx.getArgument(\"arg\", Component.class);\n\n                ctx.getSource().getSender().sendRichMessage(\n                    \"Your message: <input>\",\n                    Placeholder.component(\"input\", component)\n                );\n                return Command.SINGLE_SUCCESS;\n            }))\n        .build();\n}\n```\n\n----------------------------------------\n\nTITLE: Registering BasicCommand in Plugin - Java\nDESCRIPTION: Illustrates how to register a custom `BasicCommand` implementation with the Paper API within a plugin's main class using Java. It leverages the `LifecycleManager` and the `COMMANDS` event to register the command \"broadcast\" when the plugin enables.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/misc/basic-command.md#_snippet_6\n\nLANGUAGE: Java\nCODE:\n```\n@Override\npublic void onEnable() {\n    this.getLifecycleManager().registerEventHandler(LifecycleEvents.COMMANDS,\n        event -> event.registrar().register(\"broadcast\", new BroadcastCommand())\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing World Argument and Teleporting Player in PaperMC Commands with Java\nDESCRIPTION: Defines a command node \"teleport-to-world\" that accepts a World argument, retrieves the Bukkit World object, and teleports the executing player to that world's spawn location. It checks if the executor is a player before teleporting and sends rich messages indicating success or errors. Dependencies include Bukkit World API, PlayerTeleportEvent, and placeholder support. Input is a loaded world; output is player teleportation and confirmation messages.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/location.mdx#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> worldArgument() {\n    return Commands.literal(\"teleport-to-world\")\n        .then(Commands.argument(\"world\", ArgumentTypes.world())\n            .executes(ctx -> {\n                final World world = ctx.getArgument(\"world\", World.class);\n\n                if (ctx.getSource().getExecutor() instanceof Player player) {\n                    player.teleport(world.getSpawnLocation(), PlayerTeleportEvent.TeleportCause.COMMAND);\n                    ctx.getSource().getSender().sendRichMessage(\"Successfully teleported <player> to <aqua><world></aqua>\",\n                        Placeholder.component(\"player\", player.name()),\n                        Placeholder.unparsed(\"world\", world.getName())\n                    );\n                    return Command.SINGLE_SUCCESS;\n                }\n\n                ctx.getSource().getSender().sendRichMessage(\"<red>This command requires a player!\");\n                return Command.SINGLE_SUCCESS;\n            })\n        ).build();\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Event Listener on Proxy Initialization in Velocity Plugin Java\nDESCRIPTION: Demonstrates how to delay API access until the plugin initialization phase in Velocity by listening to the ProxyInitializeEvent. This snippet shows the usage of the @Subscribe annotation to listen for the initialization event, within which plugin event listeners are registered. Dependencies include the Velocity API and appropriate event listener classes. This approach avoids unsafe API calls during plugin construction and ensures the plugin is fully registered before interaction.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/getting-started/pitfalls.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n@Subscribe\npublic void onProxyInitialization(ProxyInitializeEvent event) {\n    // Do some operation demanding access to the Velocity API here.\n    // For instance, we could register an event:\n    server.getEventManager().register(this, new PluginListener());\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing an Advanced Brigadier Command Tree in Java\nDESCRIPTION: Builds a multi-layered command tree with nested subcommands. Starts by defining leaf nodes as LiteralArgumentBuilders, then their immediate parents, and finally the root. Demonstrates the explicit tree hierarchy and the addition of child nodes via the .then() method. Requires Brigadier API and Java environment. Input literals correspond to command branches; output is a complex LiteralArgumentBuilder command tree object.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/command-tree.mdx#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nLiteralArgumentBuilder<CommandSourceStack> entities = Commands.literal(\"entities\");\nLiteralArgumentBuilder<CommandSourceStack> players = Commands.literal(\"players\");\nLiteralArgumentBuilder<CommandSourceStack> zombies = Commands.literal(\"zombies\");\n\nLiteralArgumentBuilder<CommandSourceStack> iceCream = Commands.literal(\"ice-cream\");\nLiteralArgumentBuilder<CommandSourceStack> mainDish = Commands.literal(\"main-dish\");\n```\n\nLANGUAGE: java\nCODE:\n```\nLiteralArgumentBuilder<CommandSourceStack> killall = Commands.literal(\"killall\");\nLiteralArgumentBuilder<CommandSourceStack> eat = Commands.literal(\"eat\");\n```\n\nLANGUAGE: java\nCODE:\n```\nkillall.then(entities);\nkillall.then(players);\nkillall.then(zombies);\n\neat.then(iceCream);\neat.then(mainDish);\n```\n\nLANGUAGE: java\nCODE:\n```\nLiteralArgumentBuilder<CommandSourceStack> advancedCommandRoot = Commands.literal(\"advanced\");\nadvancedCommandRoot.then(killall);\nadvancedCommandRoot.then(eat);\n```\n\n----------------------------------------\n\nTITLE: Handling BungeeCord PlayerCount Response (Java)\nDESCRIPTION: Illustrates how to register both outgoing and incoming 'BungeeCord' channels and implement the PluginMessageListener interface. The `onPluginMessageReceived` method parses incoming messages, specifically demonstrating how to read and interpret a 'PlayerCount' response from the proxy.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/plugin-messaging.md#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npublic class MyPlugin extends JavaPlugin implements PluginMessageListener {\n\n    @Override\n    public void onEnable() {\n        this.getServer().getMessenger().registerOutgoingPluginChannel(this, \"BungeeCord\");\n        this.getServer().getMessenger().registerIncomingPluginChannel(this, \"BungeeCord\", this);\n\n        Player player = ...;\n        ByteArrayDataOutput out = ByteStreams.newDataOutput();\n        out.writeUTF(\"PlayerCount\");\n        out.writeUTF(\"lobby\");\n        player.sendPluginMessage(this, \"BungeeCord\", out.toByteArray());\n        // The response will be handled in onPluginMessageReceived\n    }\n\n    @Override\n    public void onPluginMessageReceived(String channel, Player player, byte[] message) {\n        if (!channel.equals(\"BungeeCord\")) {\n            return;\n        }\n        ByteArrayDataInput in = ByteStreams.newDataInput(message);\n        String subchannel = in.readUTF();\n        if (subchannel.equals(\"PlayerCount\")) {\n            // This is our response to the PlayerCount request\n            String server = in.readUTF();\n            int playerCount = in.readInt();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Single Player Command Argument (Java)\nDESCRIPTION: This Java snippet demonstrates defining a Brigadier command `player` with a single player argument (`ArgumentTypes.player()`). It resolves the `PlayerSelectorArgumentResolver` to get a `List<Player>` and then retrieves the first player (`getFirst()`). The example code then sets the target player's velocity to \"yeet\" them and sends messages to the player and the sender. This argument requires exactly one target player. Dependencies include PaperMC API components like `Commands`, `ArgumentTypes`, `PlayerSelectorArgumentResolver`, `Player`, `CommandSourceStack`, `Command`, `Placeholder`, and `Vector`.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/entity-player.mdx#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> playerArgument() {\n    return Commands.literal(\"player\")\n        .then(Commands.argument(\"target\", ArgumentTypes.player())\n            .executes(ctx -> {\n                final PlayerSelectorArgumentResolver targetResolver = ctx.getArgument(\"target\", PlayerSelectorArgumentResolver.class);\n                final Player target = targetResolver.resolve(ctx.getSource()).getFirst();\n\n                target.setVelocity(new Vector(0, 100, 0));\n                target.sendRichMessage(\"<rainbow>Yeeeeeeeeeet\");\n\n                ctx.getSource().getSender().sendRichMessage(\"Yeeted <target>!\",\n                    Placeholder.component(\"target\", target.name())\n                );\n                return Command.SINGLE_SUCCESS;\n            }))\n        .build();\n}\n```\n\n----------------------------------------\n\nTITLE: Building Nested Command Trees Inline Using Chained Literals in Java\nDESCRIPTION: Illustrates combining chained .then() calls directly on literal creations, eliminating the need for intermediate variables and improving brevity. This pattern applies to both leaf nodes and the root node, allowing defining the entire command tree inline in a fluent builder pattern. Inputs are string command literals; output is a complete LiteralArgumentBuilder command tree structure.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/command-tree.mdx#_snippet_7\n\nLANGUAGE: java\nCODE:\n```\nLiteralArgumentBuilder<CommandSourceStack> eat = Commands.literal(\"eat\")\n    .then(Commands.literal(\"ice-cream\"))\n    .then(Commands.literal(\"main-dish\"));\n\nLiteralArgumentBuilder<CommandSourceStack> killall = Commands.literal(\"killall\")\n    .then(Commands.literal(\"entities\"))\n    .then(Commands.literal(\"players\"))\n    .then(Commands.literal(\"zombies\"));\n```\n\nLANGUAGE: java\nCODE:\n```\nLiteralArgumentBuilder<CommandSourceStack> advancedCommandRoot = Commands.literal(\"advanced\")\n    .then(Commands.literal(\"eat\")\n        .then(Commands.literal(\"ice-cream\"))\n        .then(Commands.literal(\"main-dish\"))\n    )\n    .then(Commands.literal(\"killall\")\n        .then(Commands.literal(\"entities\"))\n        .then(Commands.literal(\"players\"))\n        .then(Commands.literal(\"zombies\"))\n    );\n```\n\n----------------------------------------\n\nTITLE: Registering Command Handler in Plugin Main Class (Java)\nDESCRIPTION: Shows how to retrieve the `LifecycleManager` directly within a class extending `JavaPlugin` using `this.getLifecycleManager()` and register an event handler for `LifecycleEvents.COMMANDS` inside the `onEnable` method. This is an alternative registration method, typically used if not using `paper-plugin.yml`.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/registration.md#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\npublic final class PluginMainClass extends JavaPlugin {\n\n    @Override\n    public void onEnable() {\n        this.getLifecycleManager().registerEventHandler(LifecycleEvents.COMMANDS, commands -> {\n            // register your commands here ...\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom InventoryHolder with Stored State and Item Interaction Handling in Java\nDESCRIPTION: An enhanced custom InventoryHolder class that contains a click counter and manages item states within its inventory. Initializes an inventory with 9 slots, placing a stone ItemStack at slot 0. Provides an addClick method to increment the counter and update a bedrock ItemStack in slot 8 representing the click count. Accompanied by an InventoryClickEvent listener that checks clicks on the stone item in the custom inventory, cancels the event, and increments the stored click count accordingly. Useful for tracking user interactions per-inventory instance. Requires Paper API and event registration.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/custom-inventory-holder.md#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\npublic class MyInventory implements InventoryHolder {\n\n    private final Inventory inventory;\n\n    private int clicks = 0; // Store the amount of clicks.\n\n    public MyInventory(MyPlugin plugin) {\n        this.inventory = plugin.getServer().createInventory(this, 9);\n\n        // Set the stone that we're going to be clicking.\n        this.inventory.setItem(0, ItemStack.of(Material.STONE));\n    }\n\n    // A method we will call in the listener whenever the player clicks the stone.\n    public void addClick() {\n        this.clicks++;\n        this.updateCounter();\n    }\n\n    // A method that will update the counter item.\n    private void updateCounter() {\n        this.inventory.setItem(8, ItemStack.of(Material.BEDROCK, this.clicks));\n    }\n\n    @Override\n    public Inventory getInventory() {\n        return this.inventory;\n    }\n\n}\n```\n\nLANGUAGE: java\nCODE:\n```\n@EventHandler\npublic void onInventoryClick(InventoryClickEvent event) {\n    // We're getting the clicked inventory to avoid situations where the player\n    // already has a stone in their inventory and clicks that one.\n    Inventory inventory = event.getClickedInventory();\n    // Add a null check in case the player clicked outside the window.\n    if (inventory == null || !(inventory.getHolder(false) instanceof MyInventory myInventory)) {\n        return;\n    }\n\n    event.setCancelled(true);\n\n    ItemStack clicked = event.getCurrentItem();\n    // Check if the player clicked the stone.\n    if (clicked != null && clicked.getType() == Material.STONE) {\n        // Use the method we have on MyInventory to increment the field\n        // and update the counter.\n        myInventory.addClick();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous event handling with EventTask in Velocity\nDESCRIPTION: Shows how to handle events asynchronously by returning an EventTask. This approach allows plugins to perform background work without blocking the event dispatch thread.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/event.md#_snippet_6\n\nLANGUAGE: java\nCODE:\n```\n@Subscribe(priority = 100, order = PostOrder.CUSTOM)\npublic EventTask onPlayerChat(PlayerChatEvent event) {\n  if (mustFurtherProcess(event)) {\n    return EventTask.async(() => ...);\n  }\n  return null;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Command Literals with Brigadier - Java\nDESCRIPTION: This snippet demonstrates how to construct a command with two literal branches ('tree' and 'grass') using Brigadier's Command API in Java for PaperMC. It showcases the usage of Commands.literal to define each branch and attaches an execution handler to each leaf. No additional dependencies are required apart from Brigadier and PaperMC. The 'ctx' parameter in executes provides command context, but no arguments are passed in these branches.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/arguments-and-literals.md#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\nCommands.literal(\"plant\")\n    .then(Commands.literal(\"tree\")\n        .executes(ctx -> {\n            /* Here we are on /plant tree */\n        })\n    )\n    .then(Commands.literal(\"grass\")\n        .executes(ctx -> {\n             /* Here we are on /plant grass */\n        }));\n```\n\n----------------------------------------\n\nTITLE: Implementing Broadcast Command using PaperMC and MiniMessage (Java)\nDESCRIPTION: This Java snippet implements a broadcast command for a PaperMC server. It utilizes the PaperMC API for command handling, MiniMessage for rich text formatting, and Brigadier for argument suggestions. The command takes a message as input, formats it with the sender's name and the message content, and broadcasts it to all online players. It requires PaperMC and Adventure dependencies.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/misc/basic-command.md#_snippet_10\n\nLANGUAGE: java\nCODE:\n```\n```java\npackage your.package.name;\n\nimport io.papermc.paper.command.brigadier.BasicCommand;\nimport io.papermc.paper.command.brigadier.CommandSourceStack;\nimport net.kyori.adventure.text.Component;\nimport net.kyori.adventure.text.minimessage.MiniMessage;\nimport net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;\nimport org.bukkit.Bukkit;\nimport org.bukkit.entity.Player;\nimport org.jspecify.annotations.NullMarked;\nimport org.jspecify.annotations.Nullable;\n\nimport java.util.Collection;\n\n@NullMarked\npublic class BroadcastCommand implements BasicCommand {\n\n    @Override\n    public void execute(CommandSourceStack commandSourceStack, String[] args) {\n        final Component name = commandSourceStack.getExecutor() != null\n            ? commandSourceStack.getExecutor().name()\n            : commandSourceStack.getSender().name();\n\n        if (args.length == 0) {\n            commandSourceStack.getSender().sendRichMessage(\"<red>You cannot send an empty broadcast!\");\n            return;\n        }\n\n        final String message = String.join(\" \", args);\n        final Component broadcastMessage = MiniMessage.miniMessage().deserialize(\n            \"<red><bold>BROADCAST</red> <name> <dark_gray>»</dark_gray> <message>\",\n            Placeholder.component(\"name\", name),\n            Placeholder.unparsed(\"message\", message)\n        );\n\n        Bukkit.broadcast(broadcastMessage);\n    }\n\n    @Override\n    public @Nullable String permission() {\n        return \"example.broadcast.use\";\n    }\n\n    @Override\n    public Collection<String> suggest(CommandSourceStack commandSourceStack, String[] args) {\n        if (args.length == 0) {\n            return Bukkit.getOnlinePlayers().stream().map(Player::getName).toList();\n        }\n\n        return Bukkit.getOnlinePlayers().stream()\n            .map(Player::getName)\n            .filter(name -> name.toLowerCase().startsWith(args[args.length - 1].toLowerCase()))\n            .toList();\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Brigadier Command Roots and Branches in Java\nDESCRIPTION: Defines a simple command root using Brigadier's Commands.literal method returning a LiteralArgumentBuilder for CommandSourceStack. Uses the .then() method to attach subcommand literals as branches to the root node, laying the foundation for building command trees. Prerequisites include importing Brigadier command classes and understanding literal command nodes. Inputs are string names of commands; output is a hierarchical LiteralArgumentBuilder structure.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/command-tree.mdx#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nLiteralArgumentBuilder<CommandSourceStack> root = Commands.literal(\"customplugin\");\nroot.then(Commands.literal(\"reload\"));\nroot.then(Commands.literal(\"tphere\"));\nroot.then(Commands.literal(\"killall\"));\n```\n\n----------------------------------------\n\nTITLE: Using Global Scheduler in Paper and Folia\nDESCRIPTION: This snippet demonstrates how to obtain a global region scheduler, which executes tasks across the entire server globally regardless of regions. It is suitable for operations not specific to any region, ensuring compatibility across Paper and Folia environments.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/folia-support.md#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\nGlobalRegionScheduler globalScheduler = server.getGlobalRegionScheduler();\n```\n\n----------------------------------------\n\nTITLE: Requiring a Specific Permission for a Command (Java)\nDESCRIPTION: This snippet demonstrates how to define a command `testcmd` that requires the sender to have the `permission.test` permission node. It uses the `requires` method with a lambda expression checking `sender.getSender().hasPermission()`. If the requirement is met, a success message is sent.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/requirements.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nCommands.literal(\"testcmd\")\n    .requires(sender -> sender.getSender().hasPermission(\"permission.test\"))\n    .executes(ctx -> {\n        ctx.getSource().getSender().sendRichMessage(\"<gold>You have permission to run this command!\");\n        return Command.SINGLE_SUCCESS;\n    });\n```\n\n----------------------------------------\n\nTITLE: Requiring Specific Player Inventory State (Java)\nDESCRIPTION: This snippet illustrates a more advanced requirement for the `givesword` command. It checks if the command executor is a `Player` and if they *do not* already have a `DIAMOND_SWORD` in their inventory using a predicate in the `requires` method. If the condition is met, the command gives the player a diamond sword. Note that this type of dynamic requirement might cause client-server desynchronization.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/requirements.md#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nCommands.literal(\"givesword\")\n    .requires(sender -> sender.getExecutor() instanceof Player player && !player.getInventory().contains(Material.DIAMOND_SWORD))\n    .executes(ctx -> {\n        if (ctx.getSource().getExecutor() instanceof Player player) {\n            player.getInventory().addItem(ItemType.DIAMOND_SWORD.createItemStack());\n        }\n\n        return Command.SINGLE_SUCCESS;\n    });\n```\n\n----------------------------------------\n\nTITLE: Adding Paper Repository and Dependency with Gradle Kotlin DSL - build.gradle.kts - Kotlin\nDESCRIPTION: Defines the PaperMC Maven repository and adds the Paper API as a compile-only dependency using the Gradle Kotlin DSL in build.gradle.kts. This configuration is necessary for resolving PaperMC API artifacts and should be placed in a new or existing Gradle project. The Java language version is explicitly set to 21 via the Java toolchain configuration. Parameters include the Maven repository URL and the dynamic LATEST_PAPER_RELEASE version placeholder. Ensure that Gradle is installed and project is opened in IntelliJ IDEA or another compatible IDE. Output is a build script that fetches the required dependencies during project build; possible limitations include needing to substitute LATEST_PAPER_RELEASE with the most recent release number.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/project-setup.mdx#_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nrepositories {\n  maven {\n    name = \"papermc\"\n    url = uri(\"https://repo.papermc.io/repository/maven-public/\")\n  }\n}\n\ndependencies {\n  compileOnly(\"io.papermc.paper:paper-api:{LATEST_PAPER_RELEASE}-R0.1-SNAPSHOT\")\n}\n\njava {\n  toolchain.languageVersion.set(JavaLanguageVersion.of(21))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Loading and Saving Custom Paper Configuration Files\nDESCRIPTION: Illustrates how to manage configuration files other than the default `config.yml`. It shows how to create a `File` object pointing to the custom file (`items.yml`) in the plugin's data folder and then load its content into a `YamlConfiguration` object. Changes made to the `config` object must be saved back to the file explicitly using `config.save(file)`. Note that the file must exist for loading, and blocking I/O operations on the main thread should be avoided.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/plugin-configs.mdx#_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nFile file = new File(plugin.getDataFolder(), \"items.yml\");\nYamlConfiguration config = YamlConfiguration.loadConfiguration(file);\n// Work with config here\nconfig.save(file);\n```\n\n----------------------------------------\n\nTITLE: D2 Diagram for Advanced Command Tree Visualization\nDESCRIPTION: Represents an advanced hierarchical command tree graph where 'advanced' is root with subcommands 'killall' and 'eat', which in turn have their own subbranches. Useful for clarifying command invocation patterns before coding. Represents a directed acyclic graph using D2 notation.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/command-tree.mdx#_snippet_4\n\nLANGUAGE: d2\nCODE:\n```\nstyle.fill: transparent\ndirection: down\n\nadvanced -> killall\nadvanced -> eat\nkillall -> entities\nkillall -> players\nkillall -> zombies\neat -> \"ice cream\"\neat -> \"main dish\"\n```\n\n----------------------------------------\n\nTITLE: Parsing FinePosition Argument in PaperMC Commands with Java\nDESCRIPTION: Creates a command node \"fineposition\" taking a FinePosition argument with integer centering enabled for x and z coordinates. It resolves the FinePosition via FinePositionResolver and sends a rich message with colored coordinate values to the sender. Requires PaperMC command API, FinePositionResolver, and Placeholder classes. Inputs are decimal-precision position arguments; output is a formatted message showing precise x, y, and z coordinates.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/location.mdx#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> finePositionArgument() {\n    return Commands.literal(\"fineposition\")\n        .then(Commands.argument(\"arg\", ArgumentTypes.finePosition(true))\n            .executes(ctx -> {\n                final FinePositionResolver resolver = ctx.getArgument(\"arg\", FinePositionResolver.class);\n                final FinePosition finePosition = resolver.resolve(ctx.getSource());\n\n                ctx.getSource().getSender().sendRichMessage(\"Position: <red><x></red> <green><y></green> <blue><z></blue>\",\n                    Placeholder.unparsed(\"x\", Double.toString(finePosition.x())),\n                    Placeholder.unparsed(\"y\", Double.toString(finePosition.y())),\n                    Placeholder.unparsed(\"z\", Double.toString(finePosition.z()))\n                );\n                return Command.SINGLE_SUCCESS;\n            }))\n        .build();\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Permission Requirement to Brigadier Command Node (Java)\nDESCRIPTION: This Java snippet shows how to add a permission requirement (`minecraft.command.selector`) to a Brigadier command node using PaperMC's `requires` method. It checks if the command sender (`ctx.getSender()`) has the specified permission before allowing the command execution. This is particularly useful when commands accept entity selectors which require this permission.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/entity-player.mdx#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n.requires(ctx -> ctx.getSender().hasPermission(\"minecraft.command.selector\"))\n```\n\n----------------------------------------\n\nTITLE: Creating a Brigadier Command Using PaperMC in Java\nDESCRIPTION: Creates a root command node for Brigadier using the Commands.literal method, adds an argument for a target player, and defines an executor that retrieves both sender and target, sends messages, and returns a success indicator. Requires PaperMC Brigadier API, CommandSourceStack, PlayerSelectorArgumentResolver, and Command classes as dependencies. The method accepts a command name and returns a LiteralCommandNode instance. Expected to be called when building the command tree for registration.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/misc/comparison-bukkit-brigadier.md#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> createCommand(final String commandName) {\n    return Commands.literal(commandName)\n        .then(Commands.argument(\"target\", ArgumentTypes.player())\n            .executes(ctx -> {\n                final PlayerSelectorArgumentResolver playerSelector = ctx.getArgument(\"target\", PlayerSelectorArgumentResolver.class);\n                final Player targetPlayer = playerSelector.resolve(ctx.getSource()).getFirst();\n                final CommandSender sender = ctx.getSource().getSender();\n\n                targetPlayer.sendPlainMessage(sender.getName() + \" started partying with you!\");\n                sender.sendPlainMessage(\"You are now partying with \" + targetPlayer.getName() + \"!\");\n\n                return Command.SINGLE_SUCCESS;\n            }))\n        .build();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining GameMode Argument in PaperMC Command API (Java)\nDESCRIPTION: Shows how to instantiate a command with a GameMode enum argument, following the style of the Vanilla /gamemode command. Depends on org.bukkit.GameMode, PaperMC API, and command framework. When executed by a player, changes their game mode and sends a translatable message using Placeholder and Component. Handles non-player sources by issuing a notification. Accepts one of four valid game modes and expects player context for setGameMode to succeed.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/enums.mdx#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> gameModeArgument() {\n    return Commands.literal(\"gamemodearg\")\n        .then(Commands.argument(\"arg\", ArgumentTypes.gameMode())\n            .executes(ctx -> {\n                final GameMode gamemode = ctx.getArgument(\"arg\", GameMode.class);\n\n                if (ctx.getSource().getExecutor() instanceof Player player) {\n                    player.setGameMode(gamemode);\n                    player.sendRichMessage(\"Your gamemode has been set to <red><gamemode></red>!\",\n                        Placeholder.component(\"gamemode\", Component.translatable(gamemode))\n                    );\n                    return Command.SINGLE_SUCCESS;\n                }\n\n                ctx.getSource().getSender().sendPlainMessage(\"This command requires a player!\");\n                return Command.SINGLE_SUCCESS;\n            }))\n        .build();\n}\n```\n\n----------------------------------------\n\nTITLE: Using a lambda expression to set the chat renderer\nDESCRIPTION: Provides an example of setting the chat message renderer directly with a lambda expression within an event handler for `AsyncChatEvent`. This method offers a succinct approach for simple renderers without creating separate classes, suitable for less complex customization needs.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/event-api/chat-event.md#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\npublic class ChatListener implements Listener {\n\n    @EventHandler\n    public void onChat(AsyncChatEvent event) {\n        event.renderer((source, sourceDisplayName, message, viewer) -> {\n            // ... custom rendering logic ...\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Spawning and Customizing TextDisplay Entities with PaperMC in Java\nDESCRIPTION: Demonstrates how to spawn a TextDisplay entity at a given world location with custom text content, color, billboard behavior, and background color. This snippet requires access to the PaperMC API with classes such as TextDisplay, Component, NamedTextColor, and Display. The entity parameter allows setting text and display properties to control visual appearance. Input is the spawn location and customization parameters. The output is a visible, customized TextDisplay entity in the world.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/entity-api/display-entities.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nTextDisplay display = world.spawn(location, TextDisplay.class, entity -> {\n    // customize the entity!\n    entity.text(Component.text(\"Some awesome content\", NamedTextColor.BLACK));\n    entity.setBillboard(Display.Billboard.VERTICAL); // pivot only around the vertical axis\n    entity.setBackgroundColor(Color.RED); // make the background red\n\n    // see the Display and TextDisplay Javadoc, there are many more options\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a ForwardingAudience from the Server\nDESCRIPTION: This snippet demonstrates how to get a `ForwardingAudience` instance from the Bukkit server. The server represents all online players and the console. It also shows how to create an audience from a collection of `Audience` objects.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/component-api/audiences.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n// Server is a ForwardingAudience which includes all online players and the console\nForwardingAudience audience = Bukkit.getServer();\n\n// To construct an audience from a collection of players, use:\nAudience audience = Audience.audience(Audience...);\n// If you pass in a single Audience, it will be returned as-is. If you pass in a collection of Audiences, they will be\n// wrapped in a ForwardingAudience.\n```\n\n----------------------------------------\n\nTITLE: Adding Paper Repository and Dependency with Gradle Groovy DSL - build.gradle - Groovy\nDESCRIPTION: Configures the PaperMC Maven repository and adds the Paper API as a compileOnly dependency using the Groovy DSL syntax in the build.gradle file. This script must be placed in the Gradle root build.gradle of the plugin project to resolve PaperMC artifacts. The dependency version dynamically references LATEST_PAPER_RELEASE, which should be replaced by an actual Paper version string. Requires Gradle and is compatible with IDEs like IntelliJ IDEA. Output is a configured build system ready to fetch the specified library; limitation: does not specify Java version or compatibility explicitly.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/project-setup.mdx#_snippet_1\n\nLANGUAGE: groovy\nCODE:\n```\nrepositories {\n  maven {\n    name = 'papermc'\n    url = 'https://repo.papermc.io/repository/maven-public/'\n  }\n}\n\ndependencies {\n  compileOnly 'io.papermc.paper:paper-api:{LATEST_PAPER_RELEASE}-R0.1-SNAPSHOT'\n}\n\n```\n\n----------------------------------------\n\nTITLE: Firing a Custom Event and Broadcasting Data in Paper Plugin (Java)\nDESCRIPTION: This snippet demonstrates how to instantiate and fire the custom event (PaperIsCoolEvent) from a JavaPlugin class. It shows constructing the event with a Component message, calling the event using callEvent(), and then broadcasting the possibly-modified message. Dependencies: org.bukkit.plugin.java.JavaPlugin, PaperIsCoolEvent, org.bukkit.Bukkit, and Component. Inputs include the event data to share; the output is a server-side broadcast. Listeners may intercept and modify the message before it's broadcast.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/event-api/custom-events.md#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\npublic class ExamplePlugin extends JavaPlugin {\n\n    // ...\n\n    public void callCoolPaperEvent() {\n        PaperIsCoolEvent coolEvent = new PaperIsCoolEvent(Component.text(\"Paper is cool!\"));\n        coolEvent.callEvent();\n        // Plugins could have changed the message from inside their listeners here. So we need to get the message again.\n        // This event structure allows for other plugins to change the message to their taste.\n        // Like, for example, a plugin that adds a prefix to all messages.\n        Bukkit.broadcast(coolEvent.getMessage());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building a LiteralCommandNode Step-by-Step (Java)\nDESCRIPTION: Illustrates the process of creating a command structure using `Commands.literal()` and `then()`, and finally calling `build()` on the `LiteralArgumentBuilder` to obtain the `LiteralCommandNode` needed for registration. This example shows intermediate steps for clarity.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/registration.md#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\nLiteralArgumentBuilder<CommandSourceStack> command = Commands.literal(\"testcmd\")\n    .then(Commands.literal(\"argument_one\"))\n    .then(Commands.literal(\"argument_two\"));\n\nLiteralCommandNode<CommandSourceStack> buildCommand = command.build();\n```\n\n----------------------------------------\n\nTITLE: Retrieving Minecraft Registry Entries Using Paper API in Java\nDESCRIPTION: Demonstrates various methods for retrieving entries from the enchantment registry using distinct registry key abstractions such as TypedKey and generated keys. It depends on the RegistryAccess class to fetch the registry and uses methods like getOrThrow for lookup. Input parameters include the unique registry keys identifying the enchantment, while output is the corresponding Enchantment instance. This snippet assumes the enchantment registry is present and may throw exceptions if keys are missing.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/registries.md#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\n// Fetch the enchantment registry from the registry access\nfinal Registry<Enchantment> enchantmentRegistry = RegistryAccess\n    .registryAccess()\n    .getRegistry(RegistryKey.ENCHANTMENT);\n\n// Get the sharpness enchantment using its key.\n// getOrThrow may be replaced with get if the registry may not contain said value\nfinal Enchantment enchantment = enchantmentRegistry.getOrThrow(TypedKey.create(\n    RegistryKey.ENCHANTMENT, Key.key(\"minecraft:sharpness\"))\n);\n\n// Same as above, but using the instance's method\nfinal Enchantment enchantment = enchantmentRegistry.getOrThrow(\n    RegistryKey.ENCHANTMENT.typedKey(Key.key(\"minecraft:sharpness\"))\n);\n\n// Same as above, but using generated create method\n// available for data-driven registries or \"writable\" ones\n// (those bound to a lifecycle event in RegistryEvents).\nfinal Enchantment enchantment = enchantmentRegistry.getOrThrow(\n    EnchantmentKeys.create(Key.key(\"minecraft:sharpness\"))\n);\n\n// Same as above too, but using generated typed keys.\n// Only Vanilla entries have generated keys, for custom entries, the above method must be used.\nfinal Enchantment enchantment = enchantmentRegistry.getOrThrow(EnchantmentKeys.SHARPNESS);\n```\n\n----------------------------------------\n\nTITLE: Converting Legacy Text to MiniMessage using Serializers in Java\nDESCRIPTION: Illustrates how to convert a legacy formatted string (using `ChatColor` constants or section/ampersand symbols) to the MiniMessage format. This involves deserializing the legacy string into a `Component` using `LegacyComponentSerializer.legacySection()` and then serializing that `Component` into a MiniMessage string using `MiniMessage.miniMessage().serialize()`. Useful for migrating from older formats.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/component-api/intro.md#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nfinal String legacyString = ChatColor.RED + \"This is a legacy \" + ChatColor.GOLD + \"string\";\n\n// runs the legacy string through two serializers to convert legacy -> MiniMessage\nfinal String miniMessageString = MiniMessage.miniMessage().serialize(\n    LegacyComponentSerializer.legacySection().deserialize(legacyString)\n);\n```\n\n----------------------------------------\n\nTITLE: Requiring Operator Status for a Command (Java)\nDESCRIPTION: This example shows how to restrict the `testcmd` command to server operators only. The `requires` method checks if the command sender `isOp()`. If the sender is an operator, a confirmation message is sent.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/requirements.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nCommands.literal(\"testcmd\")\n    .requires(sender -> sender.getSender().isOp())\n    .executes(ctx -> {\n        ctx.getSource().getSender().sendRichMessage(\"<gold>You are a server operator!\");\n        return Command.SINGLE_SUCCESS;\n    });\n```\n\n----------------------------------------\n\nTITLE: Player LookAt Implementation - Java\nDESCRIPTION: This code shows how to make a player look at a certain position or entity. The `lookAt` API takes a position or entity as the target and a `LookAnchor` to specify the point on the player that should face the target. Dependencies: PaperMC API. Inputs: `player` (Player object), `position` (Location object), `entity` (Entity object), and `LookAnchor` (Enum). Output: The player's view direction changes. Constraints: The `LookAnchor` enum provides options for where on the player to focus the look direction.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/entity-api/entity-teleport.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nplayer.lookAt(\n    position,\n    LookAnchor.EYES // the player's eyes will be facing the position\n);\n\nplayer.lookAt(\n    entity,\n    LookAnchor.EYES // the player's eyes will be facing the entity\n    LookAnchor.FEET // the player will be facing the entity's feet\n);\n```\n\n----------------------------------------\n\nTITLE: Teleporting with Passenger Retention - Java\nDESCRIPTION: This code shows how to teleport an entity and retain its passengers using a `TeleportFlag`. This keeps entities riding the original entity from being removed. Dependencies: PaperMC API. Inputs: `entity` (Entity object), `location` (Location object). Output: The entity is teleported along with its passengers. Constraints: Uses the `RETAIN_PASSENGERS` flag from `TeleportFlag.EntityState` to retain passengers during teleportation.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/entity-api/entity-teleport.md#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nentity.teleport(location, TeleportFlag.EntityState.RETAIN_PASSENGERS);\n```\n\n----------------------------------------\n\nTITLE: Sending a Plugin Message to a Specific Player's Connection in Velocity\nDESCRIPTION: Sends a plugin message directly to a specific player's current server connection, after checking the connection's presence, enabling targeted communication like giving items or commands.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/plugin-messaging.md#_snippet_4\n\nLANGUAGE: Java\nCODE:\n```\npublic boolean sendPluginMessageToBackendUsingPlayer(Player player, ChannelIdentifier identifier, byte[] data) {\n    Optional<ServerConnection> connection = player.getCurrentServer();\n    if (connection.isPresent()) {\n        return connection.get().sendPluginMessage(identifier, data);\n    }\n    return false;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Sword in Java\nDESCRIPTION: Shows how to create a custom sword with lore, enchantments, and other modifications including component removal.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/data-component-api.md#_snippet_8\n\nLANGUAGE: java\nCODE:\n```\nItemStack sword = ItemStack.of(Material.DIAMOND_SWORD);\nsword.setData(DataComponentTypes.LORE, ItemLore.lore().addLine(Component.text(\"Cool sword!\")).build());\nsword.setData(DataComponentTypes.ENCHANTMENTS, ItemEnchantments.itemEnchantments().add(Enchantment.SHARPNESS, 10).build());\nsword.setData(DataComponentTypes.RARITY, ItemRarity.RARE);\n\nsword.unsetData(DataComponentTypes.TOOL); // Remove the tool component\n\nsword.setData(DataComponentTypes.MAX_DAMAGE, 10);\nsword.setData(DataComponentTypes.ENCHANTMENT_GLINT_OVERRIDE, true); // Make it glow!\n```\n\n----------------------------------------\n\nTITLE: Sending a Plugin Message to a Backend Server Using a Server Object in Velocity\nDESCRIPTION: Sends a plugin message to a specified backend server using the server object, returning true if successful. Useful for triggering server-wide actions like shutdown.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/plugin-messaging.md#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\npublic boolean sendPluginMessageToBackend(RegisteredServer server, ChannelIdentifier identifier, byte[] data) {\n    return server.sendPluginMessage(identifier, data);\n}\n```\n\n----------------------------------------\n\nTITLE: Checking for a Data Component in Java\nDESCRIPTION: Demonstrates how to check if an ItemStack has a specific data component (custom name).\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/data-component-api.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\n// Check if this item has a custom name data component\nboolean hasCustomName = stack.hasData(DataComponentTypes.CUSTOM_NAME);\nlogger.info(\"Has custom name? \" + hasCustomName);\n```\n\n----------------------------------------\n\nTITLE: Running an immediate task without delay or repeat with Velocity Scheduler API in Java\nDESCRIPTION: This example illustrates how to execute a task immediately, leveraging the scheduler's thread pool by omitting delay and repeat settings. Ideal for instant asynchronous operations within a plugin context.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/scheduler.md#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\nserver.getScheduler()\n  .buildTask(plugin, () -> {\n    // do stuff here\n  })\n  .schedule();\n```\n\n----------------------------------------\n\nTITLE: Retrieving a Prototype Value in Java\nDESCRIPTION: Shows how to retrieve the default durability value of a diamond sword from its prototype.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/data-component-api.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n// Get the default durability of diamond sword\nint defaultDurability = Material.DIAMOND_SWORD.getDefaultData(DataComponentTypes.MAX_DAMAGE)\n```\n\n----------------------------------------\n\nTITLE: Spawning and Customizing ItemDisplay Entities with PaperMC in Java\nDESCRIPTION: Shows spawning an ItemDisplay entity at a given location and assigning it an ItemStack representing the displayed item or block. Despite the name, ItemDisplay can display blocks positioned centered on the model. This snippet requires PaperMC API classes ItemDisplay, ItemStack, and Material. The input includes location and the ItemStack to be displayed, resulting in an item/block visual display entity.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/entity-api/display-entities.md#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nItemDisplay display = world.spawn(location, ItemDisplay.class, entity -> {\n    // customize the entity!\n    entity.setItemStack(ItemStack.of(Material.SKELETON_SKULL));\n});\n```\n\n----------------------------------------\n\nTITLE: Spawning and Customizing BlockDisplay Entities with PaperMC in Java\nDESCRIPTION: Illustrates spawning a BlockDisplay entity at a specified location and setting its displayed block type using Material block data. Requires PaperMC API with BlockDisplay, Material, and BlockData classes. The block data defines the displayed block, allowing visual representation of blocks as display entities. The input is spawn location and desired block material, producing a display showing that block at the location.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/entity-api/display-entities.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nBlockDisplay display = world.spawn(location, BlockDisplay.class, entity -> {\n    // customize the entity!\n    entity.setBlock(Material.GRASS_BLOCK.createBlockData());\n});\n```\n\n----------------------------------------\n\nTITLE: Modifying Prototype Component Values in Java\nDESCRIPTION: Shows how to modify a prototype value using a builder to create a diamond helmet that looks like netherite and plays a custom sound.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/data-component-api.md#_snippet_6\n\nLANGUAGE: java\nCODE:\n```\nItemStack helmet = ItemStack.of(Material.DIAMOND_HELMET);\n// Get the equippable component for this item, and make it a builder.\n// Note: Not all types have .toBuilder() methods\n// This is the prototype value of the diamond helmet.\nEquippable.Builder builder = helmet.getData(DataComponentTypes.EQUIPPABLE).toBuilder();\n\n// Make the helmet look like netherite\n// We get the prototype equippable value from NETHERITE_HELMET\nbuilder.assetId(Material.NETHERITE_HELMET.getDefaultData(DataComponentTypes.EQUIPPABLE).assetId());\n// And give it a spooky sound when putting it on\nbuilder.equipSound(SoundEventKeys.ENTITY_GHAST_HURT);\n\n// Set our new item\nhelmet.setData(DataComponentTypes.EQUIPPABLE, builder);\n```\n\n----------------------------------------\n\nTITLE: Handling Plugin Message from Backend Server in Velocity\nDESCRIPTION: Receives plugin messages from backend servers, matching the message identifier and marking the message as handled to prevent forwarding. Ensures events originate from backend servers before processing.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/plugin-messaging.md#_snippet_5\n\nLANGUAGE: Java\nCODE:\n```\npublic void onPluginMessageFromBackend(PluginMessageEvent event) {\n    if (!IDENTIFIER.equals(event.getIdentifier())) {\n        return;\n    }\n    event.setResult(PluginMessageEvent.ForwardResult.handled());\n    if (!(event.getSource() instanceof ServerConnection backend)) {\n        return;\n    }\n    ByteArrayDataInput in = ByteStreams.newDataInput(event.getData());\n    // handle packet data\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Empty Argument Tab Suggestion Check - Java\nDESCRIPTION: Refines the Java `suggest` method for `BasicCommand` by adding a check for empty arguments. If the user hasn't typed any part of the argument yet, it returns the full list of online player names immediately.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/misc/basic-command.md#_snippet_8\n\nLANGUAGE: Java\nCODE:\n```\nif (args.length == 0) {\n    return Bukkit.getOnlinePlayers().stream().map(Player::getName).toList();\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving data from PDC on an ItemStack (Java)\nDESCRIPTION: Shows how to create a NamespacedKey, access an ItemStack's ItemMeta, and retrieve stored string data from its PersistentDataContainer if available. It also demonstrates checking for data existence before retrieval.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/pdc.md#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\n// Create a NamespacedKey\nNamespacedKey key = new NamespacedKey(pluginInstance, \"example-key\");\n\nItemStack item = ...; // Retrieve the item from before\n// Get the data from the PDC\nPersistentDataContainer container = item.getItemMeta().getPersistentDataContainer();\nif (container.has(key, PersistentDataType.STRING)) {\n    String value = container.get(key, PersistentDataType.STRING);\n    // Do something with the value\n    player.sendMessage(Component.text(value));\n}\n```\n\n----------------------------------------\n\nTITLE: Example `paper-plugin.yml` Configuration\nDESCRIPTION: Provides a basic example structure for the `paper-plugin.yml` file. This configuration defines essential plugin metadata like name, version, main class, description, target API version, and specifies custom bootstrapper and loader classes.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/paper-plugins.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nname: Paper-Test-Plugin\nversion: '1.0'\nmain: io.papermc.testplugin.TestPlugin\ndescription: Paper Test Plugin\napi-version: '\\{LATEST_PAPER_RELEASE}'\nbootstrapper: io.papermc.testplugin.TestPluginBootstrap\nloader: io.papermc.testplugin.TestPluginLoader\n```\n\n----------------------------------------\n\nTITLE: Defining HeightMap Argument in PaperMC Command API (Java)\nDESCRIPTION: Provides an implementation of a command that accepts a HeightMap argument, matching inputs such as 'motion_blocking', 'ocean_floor', etc. Utilizes org.bukkit.HeightMap and assumes availability of Placeholder and messaging functionality in the sender. Used for commands or datapacks needing relative Y-coordinates. Valid HeightMap inputs should be documented elsewhere or validated externally.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/enums.mdx#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> heightMapArgument() {\n    return Commands.literal(\"heightmap\")\n        .then(Commands.argument(\"arg\", ArgumentTypes.heightMap())\n            .executes(ctx -> {\n                final HeightMap heightMap = ctx.getArgument(\"arg\", HeightMap.class);\n\n                ctx.getSource().getSender().sendRichMessage(\"You selected <gold><selection></gold>\",\n                    Placeholder.unparsed(\"selection\", heightMap.name())\n                );\n\n                return Command.SINGLE_SUCCESS;\n            }))\n        .build();\n}\n```\n\n----------------------------------------\n\nTITLE: Synchronous vs asynchronous suggestion building in Java\nDESCRIPTION: Comparison of two approaches to building suggestions: synchronously with buildFuture() and asynchronously with CompletableFuture.supplyAsync(). The asynchronous approach has limitations with accessing the Paper API.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/argument-suggestions.mdx#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\n// Here, you are safe to use all Paper API\nCommands.argument(\"name\", StringArgumentType.word())\n    .suggests((ctx, builder) -> {\n        builder.suggest(\"first\");\n        builder.suggest(\"second\");\n\n        return builder.buildFuture();\n    });\n\n// Here, most Paper API is not usable\nCommands.argument(\"name\", StringArgumentType.word())\n    .suggests((ctx, builder) -> CompletableFuture.supplyAsync(() -> {\n        builder.suggest(\"first\");\n        builder.suggest(\"second\");\n\n        return builder.build();\n    }));\n```\n\n----------------------------------------\n\nTITLE: Adding Data Fields to a Custom Event in Paper (Java)\nDESCRIPTION: This snippet expands the custom event by adding a Component message field, enabling data transport with the event. Accessors (get/set methods) are provided for the message, and the constructor requires a Component parameter. Required dependencies: org.bukkit.event.Event, org.bukkit.event.HandlerList, and net.kyori.adventure.text.Component (for the message data). This design allows plugins listening to the event to inspect or modify the message.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/event-api/custom-events.md#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\npublic class PaperIsCoolEvent extends Event {\n\n    private static final HandlerList HANDLER_LIST = new HandlerList();\n    private Component message;\n\n    public PaperIsCoolEvent(Component message) {\n        this.message = message;\n    }\n\n    public Component getMessage() {\n        return this.message;\n    }\n\n    public void setMessage(Component message) {\n        this.message = message;\n    }\n\n    public static HandlerList getHandlerList() {\n        return HANDLER_LIST;\n    }\n\n    @Override\n    public HandlerList getHandlers() {\n        return HANDLER_LIST;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Template Rotation Argument in PaperMC Command API (Java)\nDESCRIPTION: Demonstrates implementing a command argument for StructureRotation enums, with accepted values including '180', 'clockwise_90', etc. Upon execution, communicates the selected rotation to the sender. Relies on org.bukkit.block.structure.StructureRotation and appropriate command parsing configuration. Intended for plugins manipulating structure orientation.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/enums.mdx#_snippet_5\n\nLANGUAGE: Java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> templateRotationArgument() {\n    return Commands.literal(\"templaterotation\")\n        .then(Commands.argument(\"rotation\", ArgumentTypes.templateRotation())\n            .executes(ctx -> {\n                final StructureRotation rotation = ctx.getArgument(\"rotation\", StructureRotation.class);\n\n                ctx.getSource().getSender().sendPlainMessage(\"You selected: \" + rotation.name());\n\n                return Command.SINGLE_SUCCESS;\n            })\n        ).build();\n}\n```\n\n----------------------------------------\n\nTITLE: Removing or Resetting a Data Component in Java\nDESCRIPTION: Demonstrates how to remove a data component or reset it to its prototype value.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/data-component-api.md#_snippet_4\n\nLANGUAGE: java\nCODE:\n```\n// Remove an existing component (e.g. tool)\nstack.unsetData(DataComponentTypes.TOOL);\n\n// Reset a component to the default (prototype) value for its item type (e.g. max stack size)\nstack.resetData(DataComponentTypes.MAX_STACK_SIZE);\n```\n\n----------------------------------------\n\nTITLE: Implementing a SimpleCommand for Basic Command Functionality\nDESCRIPTION: This snippet illustrates how to create a simple command in Velocity using the SimpleCommand interface. It includes methods to handle command execution, permission checks, and command suggestions, providing a straightforward way to define commands with minimal complexity.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/command.md#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\npackage com.example.velocityplugin;\n\nimport com.velocitypowered.api.command.CommandSource;\nimport com.velocitypowered.api.command.SimpleCommand;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.List;\nimport net.kyori.adventure.text.Component;\nimport net.kyori.adventure.text.format.NamedTextColor;\n\npublic final class TestCommand implements SimpleCommand {\n\n    @Override\n    public void execute(final Invocation invocation) {\n        CommandSource source = invocation.source();\n        String[] args = invocation.arguments();\n        source.sendMessage(Component.text(\"Hello World!\", NamedTextColor.AQUA));\n    }\n\n    @Override\n    public boolean hasPermission(final Invocation invocation) {\n        return invocation.source().hasPermission(\"command.test\");\n    }\n\n    @Override\n    public List<String> suggest(final Invocation invocation) {\n        return List.of();\n    }\n\n    @Override\n    public CompletableFuture<List<String>> suggestAsync(final Invocation invocation) {\n        return CompletableFuture.completedFuture(List.of());\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining BasicCommand with Permission - Java\nDESCRIPTION: Shows the initial setup for a Paper command using `BasicCommand` including overriding the optional `permission` method. This specifies the required permission string (`example.broadcast.use`) that a command sender must have to execute the command.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/misc/basic-command.md#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\npackage your.package.name;\n\nimport io.papermc.paper.command.brigadier.BasicCommand;\nimport io.papermc.paper.command.brigadier.CommandSourceStack;\nimport org.jspecify.annotations.NullMarked;\nimport org.jspecify.annotations.Nullable;\n\n@NullMarked\npublic class BroadcastCommand implements BasicCommand {\n\n    @Override\n    public void execute(CommandSourceStack commandSourceStack, String[] args) {\n\n    }\n\n    @Override\n    public @Nullable String permission() {\n        return \"example.broadcast.use\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example Cyclic Plugin Loading Error Log\nDESCRIPTION: Displays a sample error message generated by the server when a cyclic loading dependency is detected among Paper plugins. The log identifies the plugins involved in the loop (e.g., Paper-Test-Plugin1 -> Paper-Test-Plugin -> Paper-Test-Plugin1) and their load order constraints.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/paper-plugins.md#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n[ERROR]: [LoadOrderTree] =================================\n[ERROR]: [LoadOrderTree] Circular plugin loading detected:\n[ERROR]: [LoadOrderTree] 1) Paper-Test-Plugin1 -> Paper-Test-Plugin -> Paper-Test-Plugin1\n[ERROR]: [LoadOrderTree]    Paper-Test-Plugin1 loadbefore: [Paper-Test-Plugin]\n[ERROR]: [LoadOrderTree]    Paper-Test-Plugin loadbefore: [Paper-Test-Plugin1]\n[ERROR]: [LoadOrderTree] Please report this to the plugin authors of the first plugin of each loop or join the PaperMC Discord server for further help.\n[ERROR]: [LoadOrderTree] =================================\n```\n\n----------------------------------------\n\nTITLE: Defining Player Profiles Command Argument (Java)\nDESCRIPTION: This Java snippet defines a Brigadier command `lookup` using the `ArgumentTypes.playerProfiles()` argument type. It resolves the `PlayerProfileListResolver` to a `Collection<PlayerProfile>`, which can include both online and offline players. The example iterates through the found profiles and prints each profile's name. Note that resolving offline players involves external API calls, which can take time and should ideally be handled asynchronously. Dependencies include PaperMC API components like `Commands`, `ArgumentTypes`, `PlayerProfileListResolver`, `PlayerProfile`, `CommandSourceStack`, `Command`, and `Collection`.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/entity-player.mdx#_snippet_5\n\nLANGUAGE: java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> playerProfilesArgument() {\n    return Commands.literal(\"lookup\")\n        .then(Commands.argument(\"profile\", ArgumentTypes.playerProfiles())\n            .executes(ctx -> {\n                final PlayerProfileListResolver profilesResolver = ctx.getArgument(\"profile\", PlayerProfileListResolver.class);\n                final Collection<PlayerProfile> foundProfiles = profilesResolver.resolve(ctx.getSource());\n\n                for (final PlayerProfile profile : foundProfiles) {\n                    ctx.getSource().getSender().sendPlainMessage(\"Found \" + profile.getName());\n                }\n\n                return Command.SINGLE_SUCCESS;\n            }))\n        .build();\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Event Cancellation Status After Firing in Paper Plugin (Java)\nDESCRIPTION: This snippet illustrates handling cancellation: after calling the event, the plugin checks whether it was cancelled before broadcasting the message. If not cancelled, the broadcast proceeds. Dependencies: org.bukkit.plugin.java.JavaPlugin, PaperIsCoolEvent, org.bukkit.Bukkit, Component. Listeners can dynamically prevent the broadcast by cancelling the event.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/event-api/custom-events.md#_snippet_4\n\nLANGUAGE: Java\nCODE:\n```\npublic class ExamplePlugin extends JavaPlugin {\n\n    // ...\n\n    public void callCoolPaperEvent() {\n        PaperIsCoolEvent coolEvent = new PaperIsCoolEvent(Component.text(\"Paper is cool!\"));\n        coolEvent.callEvent();\n        if (!coolEvent.isCancelled()) {\n            Bukkit.broadcast(coolEvent.getMessage());\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Tab Suggestions by Input - Java\nDESCRIPTION: Further refines the Java `suggest` method to filter suggestions based on the user's current input. It streams online player names and filters the list to only include names that start (case-insensitively) with the text the user has currently typed for the last argument.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/misc/basic-command.md#_snippet_9\n\nLANGUAGE: Java\nCODE:\n```\nreturn Bukkit.getOnlinePlayers().stream()\n    .map(Player::getName)\n    .filter(name -> name.toLowerCase().startsWith(args[args.length - 1].toLowerCase()))\n    .toList();\n```\n\n----------------------------------------\n\nTITLE: Detecting Folia Server in Java\nDESCRIPTION: This method checks whether the current server is running Folia by attempting to load a specific class unique to Folia. It returns true if Folia is detected, false otherwise. This is useful for plugin compatibility adjustments based on server type.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/folia-support.md#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\nprivate static boolean isFolia() {\n    try {\n        Class.forName(\"io.papermc.paper.threadedregions.RegionizedServer\");\n        return true;\n    } catch (ClassNotFoundException e) {\n        return false;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Animating ItemDisplay Rotation via Transformation Interpolation with PaperMC Scheduler API in Java\nDESCRIPTION: This snippet creates an ItemDisplay entity and uses the Bukkit Scheduler API to animate a smooth continuous rotation by updating the transformation matrix every fixed duration (5 seconds). It scales the item down by 0.5x and applies a rotating Y-axis transform. Interpolation delay and duration are set to control the animation timing. The snippet relies on Bukkit Scheduler, Matrix4f for transformations, and the PaperMC display API. It handles entity validity to cancel the task when the display is removed. Inputs include spawn location, item type, animation duration, and plugin reference. Output is a smoothly rotating item display in-place.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/entity-api/display-entities.md#_snippet_6\n\nLANGUAGE: java\nCODE:\n```\nItemDisplay display = location.getWorld().spawn(location, ItemDisplay.class, entity -> {\n    entity.setItemStack(ItemStack.of(Material.GOLDEN_SWORD));\n});\n\nint duration = 5 * 20; // duration of half a revolution (5 * 20 ticks = 5 seconds)\n\nMatrix4f mat = new Matrix4f().scale(0.5F); // scale to 0.5x - smaller item\nBukkit.getScheduler().runTaskTimer(plugin, task -> {\n    if (!display.isValid()) { // display was removed from the world, abort task\n        task.cancel();\n        return;\n    }\n\n    display.setTransformationMatrix(mat.rotateY(((float) Math.toRadians(180)) + 0.1F /* prevent the client from interpolating in reverse */));\n    display.setInterpolationDelay(0); // no delay to the interpolation\n    display.setInterpolationDuration(duration); // set the duration of the interpolated rotation\n}, 1 /* delay the initial transformation by one tick from display creation */, duration);\n```\n\n----------------------------------------\n\nTITLE: Creating an Event Listener Method with @EventHandler Annotation in Java\nDESCRIPTION: Demonstrates defining a listener method annotated with @EventHandler to react to a specific event, PlayerMoveEvent. The method accepts the event as a parameter and returns void since it does not produce a return value. This method will be called automatically when a player moves in the game. It requires importing the appropriate event class and annotation from the Paper/Bukkit API.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/event-api/event-listeners.md#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\npublic class ExampleListener implements Listener {\n\n    @EventHandler\n    public void onPlayerMove(PlayerMoveEvent event) {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PluginLoader in Java\nDESCRIPTION: Provides a Java class example implementing the `PluginLoader` interface. The `classloader` method demonstrates how to modify the plugin's classpath using `PluginClasspathBuilder`, allowing the addition of local JAR libraries (`JarLibrary`) or dependencies resolved from Maven repositories (`MavenLibraryResolver`).\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/paper-plugins.md#_snippet_5\n\nLANGUAGE: java\nCODE:\n```\npublic class TestPluginLoader implements PluginLoader {\n\n  @Override\n  public void classloader(PluginClasspathBuilder classpathBuilder) {\n    classpathBuilder.addLibrary(new JarLibrary(Path.of(\"dependency.jar\")));\n\n    MavenLibraryResolver resolver = new MavenLibraryResolver();\n    resolver.addDependency(new Dependency(new DefaultArtifact(\"com.example:example:version\"), null));\n    resolver.addRepository(new RemoteRepository.Builder(\"paper\", \"default\", \"https://repo.papermc.io/repository/maven-public/\").build());\n\n    classpathBuilder.addLibrary(resolver);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring a Lifecycle Event Handler with Priority\nDESCRIPTION: This snippet shows how to configure a lifecycle event handler by setting its priority or marking it as a monitor, which affects when it will be executed relative to other handlers.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/lifecycle.md#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\n@Override\npublic void onEnable() {\n    final LifecycleEventManager<Plugin> lifecycleManager = this.getLifecycleManager();\n    PrioritizedLifecycleEventHandlerConfiguration<LifecycleEventOwner> config = LifecycleEvents.SOME_EVENT.newHandler((event) -> {\n        // Handler for the event\n    });\n    config.priority(10); // sets a priority of 10\n    // or\n    config.monitor(); // marks the handler as a monitor\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Tasks on a Region Scheduler\nDESCRIPTION: This example shows how to use the region scheduler to run a task that modifies a block at a specific location. The location is passed to the scheduler which determines the appropriate region to execute within, making it suitable for region-specific operations.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/folia-support.md#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\nLocation locationToChange = ...;\nRegionScheduler scheduler = server.getRegionScheduler();\n\nscheduler.execute(plugin, locationToChange, () -> {\n    locationToChange.getBlock().setType(Material.BEEHIVE);\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Double Range Predicate Argument with PaperMC Command API (Java)\nDESCRIPTION: This snippet defines a command node for the literal 'doublerange' that accepts a double range argument in PaperMC using Java. It evaluates whether integers in the range 0-4 are within the bounds specified by user input, and sends the result for each check to the command sender via rich messages with placeholders. Dependencies include the PaperMC Command API, Placeholder API, and appropriate DoubleRangeProvider implementations. The argument expects a double range selector, and outputs success if the command executes correctly. Input and output types are strongly typed via the CommandSourceStack and CommandContext.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/predicate.mdx#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> doubleRangeArgument() {\n    return Commands.literal(\"doublerange\")\n        .then(Commands.argument(\"arg\", ArgumentTypes.doubleRange())\n            .executes(ctx -> {\n                final DoubleRangeProvider doubleRangeProvider = ctx.getArgument(\"arg\", DoubleRangeProvider.class);\n                final CommandSender sender = ctx.getSource().getSender();\n\n                for (int i = 0; i < 5; i++) {\n                    sender.sendRichMessage(\"Is <index> in bounds? <result>\",\n                        Placeholder.unparsed(\"index\", Integer.toString(i)),\n                        Placeholder.unparsed(\"result\", Boolean.toString(doubleRangeProvider.range().test((double) i)))\n                    );\n                }\n                return Command.SINGLE_SUCCESS;\n            }))\n        .build();\n}\n```\n\n----------------------------------------\n\nTITLE: Forwarding Plugin Messages to BungeeCord (Paper)\nDESCRIPTION: This snippet demonstrates how to forward a plugin message to another server in a BungeeCord network.  It uses the 'Forward' subchannel and constructs a message with a target server, channel, and data. This involves registering outgoing and incoming plugin channels with the server's messenger and sending the message to BungeeCord.  The response is handled in `onPluginMessageReceived`.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/plugin-messaging.md#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\npublic class MyPlugin extends JavaPlugin implements PluginMessageListener {\n\n    @Override\n    public void onEnable() {\n        this.getServer().getMessenger().registerOutgoingPluginChannel(this, \"BungeeCord\");\n        this.getServer().getMessenger().registerIncomingPluginChannel(this, \"BungeeCord\", this);\n\n        Player player = ...;\n        ByteArrayDataOutput out = ByteStreams.newDataOutput();\n        out.writeUTF(\"Forward\");\n        out.writeUTF(\"ALL\"); // This is the target server. \"ALL\" will message all servers apart from the one sending the message\n        out.writeUTF(\"SecretInternalChannel\"); // This is the channel.\n\n        ByteArrayOutputStream msgbytes = new ByteArrayOutputStream();\n        DataOutputStream msgout = new DataOutputStream(msgbytes);\n        msgout.writeUTF(\"Paper is the meaning of life\"); // You can do anything you want with msgout\n        msgout.writeShort(42); // Writing a random short\n\n        out.writeShort(msgbytes.toByteArray().length); // This is the length.\n        out.write(msgbytes.toByteArray()); // This is the message.\n\n        player.sendPluginMessage(this, \"BungeeCord\", out.toByteArray());\n        // The response will be handled in onPluginMessageReceived\n    }\n\n    @Override\n    public void onPluginMessageReceived(String channel, Player player, byte[] message) {\n        if (!channel.equals(\"BungeeCord\")) {\n            return;\n        }\n        ByteArrayDataInput in = ByteStreams.newDataInput(message);\n        String subchannel = in.readUTF();\n        if (subchannel.equals(\"SecretInternalChannel\")) {\n            short len = in.readShort();\n            byte[] msgbytes = new byte[len];\n            in.readFully(msgbytes);\n\n            DataInputStream msgIn = new DataInputStream(new ByteArrayInputStream(msgbytes));\n            String secretMessage = msgIn.readUTF(); // Read the data in the same way you wrote it\n            short meaningofLife = msgIn.readShort();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Plugin Message Channel during Proxy Initialization\nDESCRIPTION: Subscribes to the proxy initialization event to register the custom plugin channel identifier with Velocity's channel registrar, enabling message handling for that channel.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/plugin-messaging.md#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\n@Subscribe\npublic void onProxyInitialization(ProxyInitializeEvent event) {\n    proxyServer.getChannelRegistrar().register(IDENTIFIER);\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Proxy Initialization Event\nDESCRIPTION: This snippet shows how to listen for the `ProxyInitializeEvent` to perform actions during the initialization phase of a Velocity plugin. This ensures that the Velocity API is fully available before the plugin attempts to register event listeners or perform other operations requiring access to the API.  The `@Subscribe` annotation marks the method to be invoked when the event is fired.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/getting-started/api-basics.md#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\n@Subscribe\npublic void onProxyInitialization(ProxyInitializeEvent event) {\n    // Do some operation demanding access to the Velocity API here.\n    // For instance, we could register an event:\n    server.getEventManager().register(this, new PluginListener());\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring assemble Task Dependency on reobfJar (Kotlin)\nDESCRIPTION: This code snippet demonstrates how to make the `reobfJar` task run when the default `build` (assemble) task is executed.  This will produce a re-obfuscated jar when building the project, making it usable in standard Paper servers.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/userdev.md#_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\ntasks.assemble {\n  dependsOn(tasks.reobfJar)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Key Argument in Paper Command API\nDESCRIPTION: Shows how to create a command that uses the key argument to accept and validate a namespaced key input. The example demonstrates retrieving the Key object and displaying its string representation back to the sender.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/adventure.mdx#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> keyArgument() {\n    return Commands.literal(\"key\")\n        .then(Commands.argument(\"key_input\", ArgumentTypes.key())\n            .executes(ctx -> {\n                final Key key = ctx.getArgument(\"key_input\", Key.class);\n\n                ctx.getSource().getSender().sendRichMessage(\"You put in <aqua><key></aqua>!\",\n                    Placeholder.unparsed(\"key\", key.asString())\n                );\n\n                return Command.SINGLE_SUCCESS;\n            }))\n        .build();\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a BrigadierCommand to Send 'Hello World' in Blue Text\nDESCRIPTION: This snippet demonstrates how to define a command using Velocity's BrigadierCommand wrapper. It registers a command '/test' that responds with a 'Hello World' message in aqua color and includes an example of handling subcommands with argument suggestions and execution logic.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/command.md#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\npackage com.example.velocityplugin;\n\nimport com.mojang.brigadier.arguments.StringArgumentType;\nimport com.mojang.brigadier.Command;\nimport com.mojang.brigadier.tree.LiteralCommandNode;\nimport com.velocitypowered.api.command.BrigadierCommand;\nimport com.velocitypowered.api.command.CommandSource;\nimport com.velocitypowered.api.command.VelocityBrigadierMessage;\nimport com.velocitypowered.api.proxy.ProxyServer;\nimport net.kyori.adventure.text.Component;\nimport net.kyori.adventure.text.format.NamedTextColor;\n\npublic final class TestBrigadierCommand {\n\n    public static BrigadierCommand createBrigadierCommand(final ProxyServer proxy) {\n        LiteralCommandNode<CommandSource> helloNode = BrigadierCommand.literalArgumentBuilder(\"test\")\n            // Permission requirement for execution\n            .requires(source -> source.hasPermission(\"test.permission\"))\n            // Main command action\n            .executes(context -> {\n                CommandSource source = context.getSource();\n                Component message = Component.text(\"Hello World\", NamedTextColor.AQUA);\n                source.sendMessage(message);\n                return Command.SINGLE_SUCCESS;\n            })\n            // Subcommand with arguments\n            .then(BrigadierCommand.requiredArgumentBuilder(\"argument\", StringArgumentType.word())\n                // Suggestions for argument input\n                .suggests((ctx, builder) -> {\n                    proxy.getAllPlayers().forEach(player -> builder.suggest(\n                            player.getUsername(),\n                            VelocityBrigadierMessage.tooltip(\n                                    MiniMessage.miniMessage().deserialize(\"<rainbow>\" + player.getUsername())\n                            )\n                    ));\n                    builder.suggest(\"all\");\n                    return builder.buildFuture();\n                })\n                // Execution logic for subcommand\n                .executes(context -> {\n                    String argumentProvided = context.getArgument(\"argument\", String.class);\n                    proxy.getPlayer(argumentProvided).ifPresent(player ->\n                        player.sendMessage(Component.text(\"Hello!\"))\n                    );\n                    return Command.SINGLE_SUCCESS;\n                })\n            )\n            .build();\n\n        return new BrigadierCommand(helloNode);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Argument for Operator Players\nDESCRIPTION: This Java snippet demonstrates the creation of a custom argument for selecting online operators.  It utilizes existing argument types, custom suggestions, and exception handling to ensure only operators are selected. It shows the initial implementation using an anonymous argument builder. Requires Bukkit API for server interaction and Brigadier for command parsing.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/custom-arguments.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nCommands.argument(\"player\", ArgumentTypes.player())\n    .suggests((ctx, builder) -> {\n        Bukkit.getOnlinePlayers().stream()\n            .filter(ServerOperator::isOp)\n            .map(Player::getName)\n            .filter(name -> name.toLowerCase(Locale.ROOT).startsWith(builder.getRemainingLowerCase()))\n            .forEach(builder::suggest);\n        return builder.buildFuture();\n    })\n    .executes(ctx -> {\n        final Player player = ctx.getArgument(\"player\", PlayerSelectorArgumentResolver.class).resolve(ctx.getSource()).getFirst();\n        if (!player.isOp()) {\n            final Message message = MessageComponentSerializer.message().serialize(text(player.getName() + \" is not a server operator!\"));\n            throw new SimpleCommandExceptionType(message).create();\n        }\n\n        ctx.getSource().getSender().sendRichMessage(\"Player <player> is an operator!\",\n            Placeholder.component(\"player\", player.displayName())\n        );\n        return Command.SINGLE_SUCCESS;\n    })\n```\n\n----------------------------------------\n\nTITLE: Scheduling Tasks on an Entity\nDESCRIPTION: This example demonstrates how to execute tasks directly associated with a specific entity using its internal scheduler. These tasks follow the entity's movement, making it suitable for entity-specific behaviors or modifications.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/folia-support.md#_snippet_4\n\nLANGUAGE: Java\nCODE:\n```\nEntityScheduler scheduler = entity.getScheduler();\n```\n\n----------------------------------------\n\nTITLE: Adding Paper Repository and Dependency with Maven - pom.xml - XML\nDESCRIPTION: Includes the PaperMC Maven repository and Paper API as a provided-scoped dependency in a Maven pom.xml configuration. To use, insert into the project's pom.xml. The repository enables Maven to resolve the PaperMC API packages when building the plugin. Dependency version uses a LATEST_PAPER_RELEASE placeholder, which must be replaced with the actual version string. Requires Maven as the build tool; output is a Maven-configured project capable of resolving Paper API on build. A limitation is that this static XML setup does not set Java version or other build settings.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/project-setup.mdx#_snippet_2\n\nLANGUAGE: xml\nCODE:\n```\n<project>\n  <repositories>\n    <repository>\n      <id>papermc</id>\n      <url>https://repo.papermc.io/repository/maven-public/</url>\n    </repository>\n  </repositories>\n\n  <dependencies>\n    <dependency>\n      <groupId>io.papermc.paper</groupId>\n      <artifactId>paper-api</artifactId>\n      <version>{LATEST_PAPER_RELEASE}-R0.1-SNAPSHOT</version>\n      <scope>provided</scope>\n    </dependency>\n  </dependencies>\n</project>\n\n```\n\n----------------------------------------\n\nTITLE: Basic plugin.yml Structure in YAML\nDESCRIPTION: An example of a minimal plugin.yml file with essential configuration fields. This includes required fields like name, version, and main class, as well as optional fields like description, author, and API version.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/plugin-yml.mdx#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nname: ExamplePlugin\nversion: 1.0.0\nmain: io.papermc.testplugin.ExamplePlugin\ndescription: An example plugin\nauthor: PaperMC\nwebsite: https://papermc.io\napi-version: '\\{LATEST_PAPER_RELEASE}'\n```\n\n----------------------------------------\n\nTITLE: Scheduling a delayed task with Velocity Scheduler API in Java\nDESCRIPTION: This snippet demonstrates how to schedule a task to execute after a delay of 2 seconds using Velocity's Scheduler API. It involves creating a TaskBuilder, configuring the delay with TimeUnit, and scheduling the task. Requires a plugin instance for task context.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/scheduler.md#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\nserver.getScheduler()\n  .buildTask(plugin, () -> {\n    // do stuff here\n  })\n  .delay(2L, TimeUnit.SECONDS)\n  .schedule();\n```\n\n----------------------------------------\n\nTITLE: Define NamespacedKey Command Argument (Paper/Java)\nDESCRIPTION: Illustrates how to define a command argument that parses a `NamespacedKey` using `ArgumentTypes.namespacedKey()`. The parsed value is retrieved as a `NamespacedKey` object, useful for interacting with Bukkit API components. The example sends a rich message displaying the parsed key string. Requires Paper API, Brigadier, and Adventure API.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/paper.mdx#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> namespacedKeyArgument() {\n    return Commands.literal(\"namespacedkey\")\n        .then(Commands.argument(\"key\", ArgumentTypes.namespacedKey())\n            .executes(ctx -> {\n                final NamespacedKey key = ctx.getArgument(\"key\", NamespacedKey.class);\n\n                ctx.getSource().getSender().sendRichMessage(\"You put in <aqua><key></aqua>!\",\n                    Placeholder.unparsed(\"key\", key.toString())\n                );\n                return Command.SINGLE_SUCCESS;\n            }))\n        .build();\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining Multiple .then() Calls for Subcommands in Java\nDESCRIPTION: Demonstrates chaining .then() calls to add multiple child command literals in a more readable and concise way. Also shows the recommended practice of placing each .then() on a new line for clarity. Inputs are command literal names; output is a LiteralArgumentBuilder node with multiple branches.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/command-tree.mdx#_snippet_6\n\nLANGUAGE: java\nCODE:\n```\nkillall\n    .then(entities)\n    .then(players)\n    .then(zombies);\n```\n\nLANGUAGE: java\nCODE:\n```\nkillall\n    .then(Commands.literal(\"entities\"))\n    .then(Commands.literal(\"players\"))\n    .then(Commands.literal(\"zombies\"));\n```\n\nLANGUAGE: java\nCODE:\n```\neat\n    .then(Commands.literal(\"ice-cream\"))\n    .then(Commands.literal(\"main-dish\"));\n```\n\n----------------------------------------\n\nTITLE: Velocity Plugin Annotation Example\nDESCRIPTION: This code shows the `@Plugin` annotation used to define plugin metadata such as id, name, version, URL, description, and authors. This annotation is crucial for Velocity to recognize and load the plugin. The `id` is particularly important for dependency management.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/getting-started/api-basics.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\n@Plugin(id = \"myfirstplugin\", name = \"My First Plugin\", version = \"0.1.0-SNAPSHOT\",\n        url = \"awesome.org\", description = \"I did it!\", authors = {\"Me\"})\npublic class VelocityTest {\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Entities Command Argument (Java)\nDESCRIPTION: This Java snippet defines a Brigadier command `entitiesarg` using the `ArgumentTypes.entities()` argument type. It retrieves the `EntitySelectorArgumentResolver`, resolves it to a `List<Entity>`, and joins the names of all found entities into a comma-separated list for display. This argument accepts one or more target entities. Dependencies include PaperMC API components like `Commands`, `ArgumentTypes`, `EntitySelectorArgumentResolver`, `Entity`, `CommandSourceStack`, `Command`, `Placeholder`, `Component`, and `JoinConfiguration`.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/entity-player.mdx#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> entitiesArgument() {\n    return Commands.literal(\"entitiesarg\")\n        .then(Commands.argument(\"arg\", ArgumentTypes.entities())\n            .executes(ctx -> {\n                final EntitySelectorArgumentResolver entitySelectorArgumentResolver = ctx.getArgument(\"arg\", EntitySelectorArgumentResolver.class);\n                final List<Entity> entities = entitySelectorArgumentResolver.resolve(ctx.getSource());\n\n                final Component foundEntities = Component.join(JoinConfiguration.commas(true), entities.stream().map(Entity::name).toList());\n\n                ctx.getSource().getSender().sendRichMessage(\"Found <green><entitynames>\",\n                    Placeholder.component(\"entitynames\", foundEntities)\n                );\n\n                return Command.SINGLE_SUCCESS;\n            }))\n        .build();\n}\n```\n\n----------------------------------------\n\nTITLE: Define BlockState Command Argument (Paper/Java)\nDESCRIPTION: Demonstrates how to define a command argument that parses a BlockState using `ArgumentTypes.blockState()`. The parsed value is retrieved as a `BlockState` object and used to send a message containing the block's type. Requires Paper API and the Brigadier command library.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/paper.mdx#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> blockStateArgument() {\n    return Commands.literal(\"blockstateargument\")\n        .then(Commands.argument(\"arg\", ArgumentTypes.blockState())\n            .executes(ctx -> {\n                final BlockState blockState = ctx.getArgument(\"arg\", BlockState.class);\n\n                ctx.getSource().getSender().sendPlainMessage(\"You specified a \" + blockState.getType() + \"!\");\n                return Command.SINGLE_SUCCESS;\n            }))\n        .build();\n}\n```\n\n----------------------------------------\n\nTITLE: Relative Teleportation with Flags - Java\nDESCRIPTION: This snippet demonstrates relative teleportation for a player, using `TeleportFlag` to prevent velocity reset on specific axes.  Dependencies: PaperMC API. Inputs: `player` (Player object), `location` (Location object), and a variable number of `TeleportFlag` objects. Output: The player is teleported to the specified location. Constraints:  Relative flags allow for teleportation without changing the entity's momentum along specified axes.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/entity-api/entity-teleport.md#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nplayer.teleport(\n    location,\n    TeleportFlag.Relative.VELOCITY_X,\n    TeleportFlag.Relative.VELOCITY_Y,\n    TeleportFlag.Relative.VELOCITY_Z\n);\n```\n\n----------------------------------------\n\nTITLE: Parsing BlockPosition Argument in PaperMC Commands with Java\nDESCRIPTION: Defines a command node \"blockpositionargument\" that accepts a BlockPosition argument, resolves it using the BlockPositionResolver, and sends the block coordinates as a plain text message to the command sender. Dependencies include PaperMC's command API and the BlockPositionResolver class. The input is a position argument, the output is a confirmation message showing the x, y, and z coordinates of the block position.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/location.mdx#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> blockPositionArgument() {\n    return Commands.literal(\"blockpositionargument\")\n        .then(Commands.argument(\"arg\", ArgumentTypes.blockPosition())\n            .executes(ctx -> {\n                final BlockPositionResolver blockPositionResolver = ctx.getArgument(\"arg\", BlockPositionResolver.class);\n                final BlockPosition blockPosition = blockPositionResolver.resolve(ctx.getSource());\n\n                ctx.getSource().getSender().sendPlainMessage(\"Put in \" + blockPosition.x() + \" \" + blockPosition.y() + \" \" + blockPosition.z());\n                return Command.SINGLE_SUCCESS;\n            }))\n        .build();\n}\n```\n\n----------------------------------------\n\nTITLE: Ignoring Cancelled Events in Listener Methods with @EventHandler in Java\nDESCRIPTION: Demonstrates how to instruct an event listener method to ignore events that have already been cancelled by other plugins by setting ignoreCancelled = true in the @EventHandler annotation. This ensures the listener method is only called if the event is not cancelled, preventing redundant or undesired processing on cancelled events.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/event-api/event-listeners.md#_snippet_5\n\nLANGUAGE: Java\nCODE:\n```\npublic class ExampleListener implements Listener {\n\n    @EventHandler(ignoreCancelled = true)\n    public void onPlayerMove(PlayerMoveEvent event) {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a New Enchantment Entry During Registry Freeze Event in Paper Plugin Bootstrap Java\nDESCRIPTION: Shows how to register a new enchantment entry during the freeze lifecycle event of the enchantment registry in a Paper plugin. It requires implementing PluginBootstrap and using LifecycleEventManager to register an event handler that adds the new enchantment with custom properties such as description, supported items, costs, and active slots. Inputs include the plugin bootstrap context; the output updates the registry with the new enchantment during server startup. This must be done during server bootstrap to avoid shutdown errors.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/registries.md#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\npublic class TestPluginBootstrap implements PluginBootstrap {\n\n    @Override\n    public void bootstrap(BootstrapContext context) {\n        // Register a new handler for the freeze lifecycle event on the enchantment registry\n        context.getLifecycleManager().registerEventHandler(RegistryEvents.ENCHANTMENT.freeze().newHandler(event -> {\n            event.registry().register(\n                // The key of the registry\n                // Plugins should use their own namespace instead of minecraft or papermc\n                EnchantmentKeys.create(Key.key(\"papermc:pointy\")),\n                b -> b.description(Component.text(\"Pointy\"))\n                    .supportedItems(event.getOrCreateTag(ItemTypeTagKeys.SWORDS))\n                    .anvilCost(1)\n                    .maxLevel(25)\n                    .weight(10)\n                    .minimumCost(EnchantmentRegistryEntry.EnchantmentCost.of(1, 1))\n                    .maximumCost(EnchantmentRegistryEntry.EnchantmentCost.of(3, 1))\n                    .activeSlots(EquipmentSlotGroup.ANY)\n            );\n        }));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: LifecycleEventHandler Functional Interface Definition (Java)\nDESCRIPTION: Defines the `LifecycleEventHandler` functional interface, which accepts a single method `run` taking a `LifecycleEvent` subtype. Its `@FunctionalInterface` annotation allows it to be implemented using a lambda expression, simplifying event handler registration for lifecycle events like command loading.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/registration.md#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\n@FunctionalInterface\npublic interface LifecycleEventHandler<E extends LifecycleEvent> {\n    void run(E event);\n}\n```\n\n----------------------------------------\n\nTITLE: Importing spigot.yml Configuration - Astro\nDESCRIPTION: This code snippet imports the `spigot.yml` file as a raw text using the `?raw` query parameter and then parses it using the `yaml` package. It is used to access the configuration data for rendering it into a user-friendly format on a webpage. No dependencies are explicitly stated, however the presence of the YAML import statement means the YAML package is used to interpret the contents of the yml file. The main input is a raw YAML file, and the output is a JavaScript object representing the parsed YAML data.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/reference/configuration/spigot-configuration.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport SpigotYML from \"/src/config/paper/spigot.yml?raw\";\nimport { parse } from \"yaml\";\n```\n\n----------------------------------------\n\nTITLE: Rendering Minecraft Server Banned Players Data as JSON Using Astro and YAML in JavaScript\nDESCRIPTION: This snippet imports banned players data represented in YAML format, parses it into a JavaScript object, and uses the ConfigNode component to render it as JSON. It documents that banned-players.json serves as a server-managed data repository for banned players and advises using server commands for modifications. Dependencies include the `yaml` parser for decoding and Astro's ConfigNode for UI rendering. The input is the banned players' raw YAML content, and the output is a visual representation of the banned-players.json data.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/reference/configuration/vanilla-data-files.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport ConfigNode from \"/src/components/ConfigNode.astro\";\nimport { parse } from \"yaml\";\nimport BannedPlayersYML from \"/src/config/paper/banned-players-single.yml?raw\";\n\n<ConfigNode data={parse(BannedPlayersYML)} lang=\"json\" path={[\"banned_players\"]} />\n```\n\n----------------------------------------\n\nTITLE: Setting a Bounded Float Argument for Flight Speed in Brigadier - Java\nDESCRIPTION: This Java snippet configures a '/flyspeed' command in PaperMC using Brigadier, where the 'speed' float argument must be between 0 and 1. It demonstrates argument range restriction via FloatArgumentType.floatArg(0, 1.0f) and argument retrieval through ctx.getArgument. The command returns Command.SINGLE_SUCCESS if executed. Dependencies are Brigadier, PaperMC, and any command registration setup.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/arguments-and-literals.md#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\nCommands.literal(\"flyspeed\")\n    .then(Commands.argument(\"speed\", FloatArgumentType.floatArg(0, 1.0f))\n        .executes(ctx -> {\n            float speed = ctx.getArgument(\"speed\", float.class);\n            /* Set player's flight speed */\n            return Command.SINGLE_SUCCESS;\n        })\n    );\n```\n\n----------------------------------------\n\nTITLE: Creating an Item Predicate Argument with PaperMC Command API (Java)\nDESCRIPTION: This snippet shows how to create a command 'itempredicate' in Java using the PaperMC Command API, which accepts an item predicate argument and applies it to a default wooden sword item. It reports to the command sender whether the predicate includes the default item, using color-coded output via rich messages and placeholders. Dependencies include the PaperMC Command API, ItemStackPredicate, ItemType, and Placeholder API. The main parameter is a predicate argument, and the output is a message confirming the filter result for the sample item. The command expects valid predicate arguments and assumes registered item types.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/predicate.mdx#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> itemPredicateArgument() {\n    return Commands.literal(\"itempredicate\")\n        .then(Commands.argument(\"predicate\", ArgumentTypes.itemPredicate())\n            .executes(ctx -> {\n                final ItemStackPredicate predicate = ctx.getArgument(\"predicate\", ItemStackPredicate.class);\n                final ItemStack defaultWoodenSword = ItemType.WOODEN_SWORD.createItemStack();\n\n                ctx.getSource().getSender().sendRichMessage(\"Does predicate include a default wooden sword? <result>\",\n                    Placeholder.parsed(\"result\", predicate.test(defaultWoodenSword) ? \"<green>true</green>\" : \"<red>false</red>\")\n                );\n                return Command.SINGLE_SUCCESS;\n            }))\n        .build();\n}\n```\n\n----------------------------------------\n\nTITLE: GitHub Actions Workflow for Automated Hangar Publishing\nDESCRIPTION: This YAML configuration sets up a GitHub Actions workflow that automatically publishes plugin builds to Hangar when changes are pushed to specified branches. It handles checkout, validation, and uses the HANGAR_API_TOKEN secret for authentication.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/misc/hangar-publishing.md#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nname: Publish to Hangar\non:\n  push:\n    branches:\n      # Add any additional branches you want to automatically publish from\n      - main # Assuming your main branch is called 'main'\n\njobs:\n  publish:\n    # TODO: Optional, make sure the task only runs on pushes to your repository and doesn't fail on forks. Uncomment the line below and put the repo owner into the quotes\n    # if: github.repository_owner == '<YOUR USER/ORG NAME>'\n    runs-on: ubuntu-22.04\n    steps:\n      - name: Checkout Repository\n        uses: actions/checkout@v3\n      - name: Validate Gradle Wrapper\n        uses: gradle/wrapper-validation-action@v1\n      - name: Set up JDK 17\n        uses: actions/setup-java@v3\n        with:\n          distribution: 'temurin'\n          java-version: 17\n      - name: Publish\n        env:\n          # Make sure you have added a repository secret in the repository's settings\n          HANGAR_API_TOKEN: ${{ secrets.HANGAR_API_TOKEN }}\n        run: ./gradlew build publishPluginPublicationToHangar --stacktrace\n```\n\n----------------------------------------\n\nTITLE: Implementing the Main Paper Plugin Class - ExamplePlugin.java - Java\nDESCRIPTION: Demonstrates a minimal main plugin class for a Paper Minecraft plugin, extending JavaPlugin and implementing Listener. Registers the class as an event listener in onEnable and sends a welcome message to players on join using the Adventure Component API. Intended for placement in package io.papermc.testplugin. Dependencies required include Paper API and Kyori Adventure components; imports depend on these. Receives PlayerJoinEvent as input and issues a text message as side effect. Limitations: must be in a plugin project with a valid plugin.yml and correct package structure.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/project-setup.mdx#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\npackage io.papermc.testplugin;\n\nimport net.kyori.adventure.text.Component;\nimport org.bukkit.Bukkit;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.PlayerJoinEvent;\nimport org.bukkit.plugin.java.JavaPlugin;\n\npublic class ExamplePlugin extends JavaPlugin implements Listener {\n  @Override\n  public void onEnable() {\n    Bukkit.getPluginManager().registerEvents(this, this);\n  }\n\n  @EventHandler\n  public void onPlayerJoin(PlayerJoinEvent event) {\n    event.getPlayer().sendMessage(Component.text(\"Hello, \" + event.getPlayer().getName() + \"!\"));\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Accessing the Plugin's Data Directory\nDESCRIPTION: This code snippet demonstrates how to inject the plugin's data directory as a `Path` using the `@DataDirectory` annotation.  This allows the plugin to store and retrieve data within its own dedicated directory. The `Path` object provides a platform-independent way to access files and directories.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/getting-started/api-basics.md#_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nprivate final Path dataDirectory;\n\n@Inject\npublic VelocityTest(ProxyServer server, Logger logger, @DataDirectory Path dataDirectory) {\n    this.server = server;\n    this.logger = logger;\n    this.dataDirectory = dataDirectory;\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Minecraft Server Ops Data JSON Using Astro Components and YAML Parsing in JavaScript\nDESCRIPTION: This snippet imports operator status data from a YAML source representing the ops.json file, parses it with the YAML parser, and renders it as JSON via the ConfigNode component. It explains that ops.json contains operator permissions information critical for server administration and bypassing player limits, advising management through server commands. The snippet depends explicitly on YAML parsing for data transformation, and Astro's ConfigNode for structured rendering. Inputs are raw YAML data for ops, and outputs are structured JSON display nodes.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/reference/configuration/vanilla-data-files.mdx#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport ConfigNode from \"/src/components/ConfigNode.astro\";\nimport { parse } from \"yaml\";\nimport OpsYML from \"/src/config/paper/ops-single.yml?raw\";\n\n<ConfigNode data={parse(OpsYML)} lang=\"json\" path={[\"ops\"]} />\n```\n\n----------------------------------------\n\nTITLE: Registering a Built LiteralCommandNode (Java)\nDESCRIPTION: Demonstrates the final step of registering a pre-built `LiteralCommandNode` within the command event handler lambda (obtained via `LifecycleEvents.COMMANDS`). It uses the `registrar()` method from the event object and calls `register()` with the command node. Optional overloads exist to add aliases and descriptions.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/registration.md#_snippet_5\n\nLANGUAGE: Java\nCODE:\n```\nthis.getLifecycleManager().registerEventHandler(LifecycleEvents.COMMANDS, commands -> {\n    commands.registrar().register(buildCommand);\n});\n```\n\n----------------------------------------\n\nTITLE: Registering a functional-style event listener in Velocity\nDESCRIPTION: Shows how to use the functional EventHandler interface to register an event listener without creating a dedicated listener class. Useful for simple or one-off event handling.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/event.md#_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nserver.getEventManager().register(this, PlayerChatEvent.class, event -> {\n    // do something here\n});\n```\n\n----------------------------------------\n\nTITLE: Addressing Plugin Errors Modifying Signed Chat Messages in Velocity\nDESCRIPTION: Shows an error message indicating a plugin attempted to cancel or modify a signed chat message, an action not fully supported natively by Velocity for Minecraft 1.19.1+. Installing the SignedVelocity plugin is recommended as a workaround.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/admin/getting-started/faq.md#_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\nA plugin tried to cancel a signed chat message. This is no longer possible in 1.19.1 and newer. Disconnecting player <player>\n```\n\n----------------------------------------\n\nTITLE: Importing and Parsing help.yml in Astro with JavaScript\nDESCRIPTION: This snippet demonstrates importing a YAML file (`help.yml`) into an Astro component, parsing its content with the `yaml` library, and rendering it using a `ConfigNode` component. It shows how YAML data is integrated into the Astro framework for dynamic documentation rendering. Dependencies include the `yaml` library and Astro components. The process involves importing the YAML as raw text, parsing it into a JavaScript object, and passing it to a component for structured display.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/reference/configuration/bukkit-help-configuration.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport ConfigNode from \"/src/components/ConfigNode.astro\";\nimport HelpYML from \"/src/config/paper/help.yml?raw\";\nimport { parse } from \"yaml\";\n\n:::note\n\nThe below YAML shows you the structure for `help.yml`.\n\nClick on a leaf node to view the description for that setting.\n\n:::\n\n<ConfigNode data={parse(HelpYML)} />\n```\n\n----------------------------------------\n\nTITLE: Sending BungeeCord Connect Message on Event (Java)\nDESCRIPTION: Demonstrates registering an outgoing 'BungeeCord' channel and sending a 'Connect' message to the proxy when a player jumps. The message, formatted as a byte array using ByteStreams, instructs the proxy to send the player to the 'hub2' server.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/plugin-messaging.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\npublic final class PluginMessagingSample extends JavaPlugin implements Listener {\n\n    @Override\n    public void onEnable() {\n        getServer().getPluginManager().registerEvents(this, this);\n        getServer().getMessenger().registerOutgoingPluginChannel(this, \"BungeeCord\");\n    }\n\n    @EventHandler\n    public void onPlayerJump(PlayerJumpEvent event) {\n        Player player = event.getPlayer();\n\n        ByteArrayDataOutput out = ByteStreams.newDataOutput();\n        out.writeUTF(\"Connect\");\n        out.writeUTF(\"hub2\");\n        player.sendPluginMessage(this, \"BungeeCord\", out.toByteArray());\n    }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Custom Argument Implementation\nDESCRIPTION: This Java code illustrates a basic implementation of the `CustomArgumentType` interface.  It creates a custom argument that accepts a string.  The `parse` method reads an unquoted string, while `getNativeType` defines the underlying type. Requires Brigadier.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/custom-arguments.md#_snippet_4\n\nLANGUAGE: java\nCODE:\n```\npackage io.papermc.commands;\n\nimport com.mojang.brigadier.StringReader;\nimport com.mojang.brigadier.arguments.ArgumentType;\nimport com.mojang.brigadier.arguments.StringArgumentType;\nimport io.papermc.paper.command.brigadier.argument.CustomArgumentType;\nimport org.jspecify.annotations.NullMarked;\n\n@NullMarked\npublic class BasicImplementation implements CustomArgumentType<String, String> {\n\n    @Override\n    public String parse(StringReader reader) {\n        return reader.readUnquotedString();\n    }\n\n    @Override\n    public ArgumentType<String> getNativeType() {\n        return StringArgumentType.word();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Spigot Mappings in Maven POM XML\nDESCRIPTION: Defines the Maven POM plugin configuration to set the 'paperweight-mappings-namespace' manifest entry to 'spigot' using the maven-jar-plugin. This signals to the server that the plugin uses Spigot mappings, triggering remapping during plugin load. Requires Maven 3.4.1 or higher and appropriate plugin configuration within the POM.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/project-setup.mdx#_snippet_7\n\nLANGUAGE: xml\nCODE:\n```\n<plugin>\n  <groupId>org.apache.maven.plugins</groupId>\n  <artifactId>maven-jar-plugin</artifactId>\n  <version>3.4.1</version>\n  <configuration>\n    <archive>\n      <manifestEntries>\n        <paperweight-mappings-namespace>spigot</paperweight-mappings-namespace>\n      </manifestEntries>\n    </archive>\n  </configuration>\n</plugin>\n```\n\n----------------------------------------\n\nTITLE: Configuring Gradle Properties for Hangar Platform Versions\nDESCRIPTION: This snippet demonstrates how to set up the gradle.properties file with platform version specifications for different Minecraft server implementations that your plugin supports. It allows specifying version ranges and wildcards.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/misc/hangar-publishing.md#_snippet_0\n\nLANGUAGE: properties\nCODE:\n```\n# Specify the platform versions for Paper and Velocity.\n# Hangar also allows version ranges (such as 1.19-1.20.2) and wildcards (such as 1.20.x).\n# TODO: Remove the platforms you don't need and put in the correct versions.\npaperVersion=1.12.2, 1.16.5, 1.19-1.20.2\nvelocityVersion=3.2\nwaterfallVersion=1.20\n```\n\n----------------------------------------\n\nTITLE: Defining Example YAML Configuration Structure\nDESCRIPTION: This snippet illustrates the basic structure of a YAML configuration file using key-value pairs and nested elements. Nested keys are accessed using dot notation, demonstrating how to represent hierarchical data.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/plugin-configs.mdx#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nroot:\n  one-key: 10\n  another-key: David\n```\n\n----------------------------------------\n\nTITLE: Applying Translation, Rotation, and Scale Transformations to BlockDisplay Entities with PaperMC in Java\nDESCRIPTION: Illustrates composing a transformation that includes translation (offset), rotation, and scaling applied to a BlockDisplay entity. The translation offsets the display by half a block on all axes. The example uses JOML's Transformation, Vector3f, and AxisAngle4f classes to construct the composite 3D affine transform. Alternate raw matrix transformation is shown in comments. Inputs include offset coordinates, rotation angles, and scale factor. The output is a positioned, rotated, and scaled block display entity.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/entity-api/display-entities.md#_snippet_5\n\nLANGUAGE: java\nCODE:\n```\nworld.spawn(location, BlockDisplay.class, entity -> {\n    entity.setBlock(Material.GRASS_BLOCK.createBlockData());\n    entity.setTransformation(\n        new Transformation(\n                new Vector3f(0.5F, 0.5F, 0.5F), // offset by half a block on all axes\n                new AxisAngle4f((float) -Math.toRadians(45), 1, 0, 0), // rotate -45 degrees on the X axis\n                new Vector3f(2, 2, 2), // scale up by a factor of 2 on all axes\n                new AxisAngle4f((float) Math.toRadians(45), 0, 0, 1) // rotate +45 degrees on the Z axis\n        )\n    );\n    // or set a raw transformation matrix from JOML\n    // entity.setTransformationMatrix(\n    //         new Matrix4f()\n    //                 .translate(0.5F, 0.5F, 0.5F) // offset by half a block on all axes\n    //                 .scale(2) // scale up by a factor of 2 on all axes\n    //                 .rotateXYZ(\n    //                         (float) Math.toRadians(360 - 45), // rotate -45 degrees on the X axis\n    //                         0,\n    //                         (float) Math.toRadians(45) // rotate +45 degrees on the Z axis\n    //                 )\n    // );\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Anti-Xray with engine-mode 2 in paper-world-defaults.yml (Overworld)\nDESCRIPTION: This snippet configures Anti-Xray with engine-mode 2 in the default world configuration. It enables Anti-Xray, sets the engine mode to 2, defines a list of hidden blocks, disables lava obscuring, sets the maximum block height, defines the replacement blocks list, sets the update radius, and disables permission usage. This configuration is recommended for the overworld.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/anti-xray.mdx#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nanticheat:\n  anti-xray:\n    enabled: true\n    engine-mode: 2\n    hidden-blocks:\n    # You can add air here such that many holes are generated.\n    # This works well against cave finders but may cause client FPS drops for all players.\n    - air\n    - copper_ore\n    - deepslate_copper_ore\n    - raw_copper_block\n    - diamond_ore\n    - deepslate_diamond_ore\n    - gold_ore\n    - deepslate_gold_ore\n    - iron_ore\n    - deepslate_iron_ore\n    - raw_iron_block\n    - lapis_ore\n    - deepslate_lapis_ore\n    - redstone_ore\n    - deepslate_redstone_ore\n    lava-obscures: false\n    # As of 1.18 some ores are generated much higher.\n    # Please adjust the max-block-height setting at your own discretion.\n    # https://minecraft.wiki/w/Ore might be helpful.\n    max-block-height: 64\n    replacement-blocks:\n    # Chest is a tile entity and can't be added to hidden-blocks in engine-mode: 2.\n    # But adding chest here will hide buried treasures, if max-block-height is increased.\n    - chest\n    - amethyst_block\n    - andesite\n    - budding_amethyst\n    - calcite\n    - coal_ore\n    - deepslate_coal_ore\n    - deepslate\n    - diorite\n    - dirt\n    - emerald_ore\n    - deepslate_emerald_ore\n    - granite\n    - gravel\n    - oak_planks\n    - smooth_basalt\n    - stone\n    - tuff\n    update-radius: 2\n    use-permission: false\n```\n\n----------------------------------------\n\nTITLE: Applying Scale Transformation to BlockDisplay Entities with PaperMC in Java\nDESCRIPTION: Demonstrates scaling a BlockDisplay entity by applying a Transformation with no translation or rotation, but a scale vector enlarging all axes by factor 2. It uses classes Transformation, Vector3f, and AxisAngle4f (from JOML). The snippet shows both setting a transformation and an alternative raw matrix approach (commented). The inputs are spawn location and scale factor. Output is a block display scaled up visually.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/entity-api/display-entities.md#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nworld.spawn(location, BlockDisplay.class, entity -> {\n    entity.setBlock(Material.GRASS_BLOCK.createBlockData());\n    entity.setTransformation(\n        new Transformation(\n                new Vector3f(), // no translation\n                new AxisAngle4f(), // no left rotation\n                new Vector3f(2, 2, 2), // scale up by a factor of 2 on all axes\n                new AxisAngle4f() // no right rotation\n        )\n    );\n    // or set a raw transformation matrix from JOML\n    // entity.setTransformationMatrix(\n    //         new Matrix4f()\n    //                 .scale(2) // scale up by a factor of 2 on all axes\n    // );\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Paper Server System Properties via JVM Flags - Bash\nDESCRIPTION: Demonstrates how to set system properties at server start time using JVM command-line flags, specifically for the Paper Minecraft server. The example shows a bash command that passes the system property `paper.log-level` with value `FINE` to configure logging verbosity. It includes a note for PowerShell users about quoting properties containing dots to prevent parsing issues. This snippet requires a working Java installation and access to the Paper server jar file. The input is the startup command, and the output is the Paper server configured with the specified properties at runtime. Limitations are that improper property values or misunderstandings can cause undesired behavior, so caution is advised when setting these flags.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/reference/system-properties.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\njava -Dpaper.log-level=FINE -jar paper.jar\n```\n\n----------------------------------------\n\nTITLE: Complete plugin example with event listener registration\nDESCRIPTION: A comprehensive example showing a main plugin class that initializes and registers a separate listener class. Demonstrates dependency injection and proper event registration patterns.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/event.md#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\n@Plugin(id = \"myfirstplugin\", name = \"My Plugin\", version = \"0.1.0\", dependencies = {@Dependency(id = \"wonderplugin\")})\npublic class VelocityTest {\n\n  private final ProxyServer server;\n  private final Logger logger;\n\n  @Inject\n  public VelocityTest(ProxyServer server, Logger logger) {\n    this.server = server;\n    this.logger = logger;\n  }\n\n  @Subscribe\n  public void onInitialize(ProxyInitializeEvent event) {\n    server.getEventManager().register(this, new MyListener());\n  }\n}\n\npublic class MyListener {\n\n  @Subscribe(order = PostOrder.EARLY)\n  public void onPlayerChat(PlayerChatEvent event) {\n    // do something here\n  }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Java 21 and Dependencies - Debian\nDESCRIPTION: This command installs Java 21 from the Amazon Corretto repository along with necessary dependencies using `apt-get`. The `-y` flag automatically answers yes to any prompts. The specified packages are related to the graphical interface and may be required by some Java applications or libraries.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/misc/java-install.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get update\nsudo apt-get install -y java-21-amazon-corretto-jdk libxi6 libxtst6 libxrender1\n```\n\n----------------------------------------\n\nTITLE: Creating and Registering a ResourceBundle for Translations in Java\nDESCRIPTION: This Java code snippet demonstrates creating a TranslationStore with a message format, loading translations from a ResourceBundle located in the classpath for the US English locale, and registering it with the GlobalTranslator. This setup makes translations accessible server-side for components such as chat messages, entity names, or scoreboards, facilitating internationalization.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/component-api/i18n.md#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\nTranslationStore.StringBased<MessageFormat> store = TranslationStore.messageFormat(Key.key(\"namespace:value\"));\n\nResourceBundle bundle = ResourceBundle.getBundle(\"your.plugin.Bundle\", Locale.US, UTF8ResourceBundleControl.get());\nstore.registerAll(Locale.US, bundle, true);\nGlobalTranslator.translator().addSource(store);\n```\n\nLANGUAGE: Java\nCODE:\n```\nComponent.translatable(\"some.translation.key\", Component.text(\"The Argument\"))\n```\n\n----------------------------------------\n\nTITLE: Enabling TNT Duplication Bug in Paper - YAML\nDESCRIPTION: This YAML snippet enables the restoration of the TNT duplication bug in Paper by setting 'allow-piston-duplication' to true under 'unsupported-settings'. This also re-enables carpet and rail duplication due to shared underlying mechanics. Use this configuration carefully, as it may allow automated mining through duplication, potentially impacting server gameplay balance.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/misc/paper-bug-fixes.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nunsupported-settings:\n  allow-piston-duplication: true\n```\n\n----------------------------------------\n\nTITLE: Getting Data using Pointers from an Audience\nDESCRIPTION: This snippet demonstrates how to retrieve arbitrary information, like UUID or display name, from an `Audience` using the pointer system. It uses `Identity.UUID` and `Identity.DISPLAY_NAME` as pointers.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/component-api/audiences.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\n// Get the uuid from an audience member, returning an Optional<UUID>\nOptional<UUID> uuid = audience.get(Identity.UUID);\n\n// Get the display name, returning a default\nComponent name = audience.getOrDefault(Identity.DISPLAY_NAME, Component.text(\"no display name!\"));\n```\n\n----------------------------------------\n\nTITLE: Configuring Hangar Publish Task in Gradle\nDESCRIPTION: This snippet shows the basic configuration for the hangarPublish task, including setting the project ID, version, channel, and platform details. It demonstrates how to reference platform versions from gradle.properties and configure plugin dependencies.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/misc/hangar-publishing.md#_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nimport io.papermc.hangarpublishplugin.model.Platforms\n\n// ...\n\nhangarPublish {\n    publications.register(\"plugin\") {\n        version.set(project.version as String)\n        channel.set(\"Snapshot\") // We're using the 'Snapshot' channel\n        // TODO: Edit the project name to match your Hangar project\n        id.set(\"hangar-project\")\n        apiKey.set(System.getenv(\"HANGAR_API_TOKEN\"))\n        platforms {\n            // TODO: Use the correct platform(s) for your plugin\n            register(Platforms.PAPER) {\n                // TODO: If you're using ShadowJar, replace the jar lines with the appropriate task:\n                //   jar.set(tasks.shadowJar.flatMap { it.archiveFile })\n                // Set the JAR file to upload\n                jar.set(tasks.jar.flatMap { it.archiveFile })\n\n                // Set platform versions from gradle.properties file\n                val versions: List<String> = (property(\"paperVersion\") as String)\n                        .split(\",\")\n                        .map { it.trim() }\n                platformVersions.set(versions)\n\n                // TODO: Configure your plugin dependencies, if any\n                dependencies {\n                    // Example for a dependency found on Hangar\n                    hangar(\"Maintenance\") {\n                        required.set(false)\n                    }\n                    // Example for an external dependency\n                    url(\"Debuggery\", \"https://github.com/PaperMC/Debuggery\") {\n                        required.set(true)\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Boolean Argument Command with Brigadier - Java\nDESCRIPTION: This snippet defines a command '/serverflight' that accepts a Boolean argument using PaperMC's Command API and Brigadier in Java. It uses Commands.argument with BoolArgumentType.bool() to declare the argument and retrieves its value via ctx.getArgument. 'allow' is the argument name, mapped to a boolean input ('true' or 'false'). This snippet requires Brigadier integrated into the command system.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/arguments-and-literals.md#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\nCommands.literal(\"serverflight\")\n    .then(Commands.argument(\"allow\", BoolArgumentType.bool())\n        .executes(ctx -> {\n            boolean allowed = ctx.getArgument(\"allow\", boolean.class);\n            /* Toggle server flying */\n        })\n    );\n```\n\n----------------------------------------\n\nTITLE: Unregistering Event Listeners using HandlerList in Bukkit/Paper (Java)\nDESCRIPTION: Shows how to unregister the current listener (`this`) from an event's HandlerList in Java for Bukkit/Paper plugins. It illustrates retrieving the HandlerList using both the instance method `event.getHandlerList()` inside an event handler and the static method `PlayerJoinEvent.getHandlerList()` within the listener's constructor, followed by calling `unregister(this)` on the obtained list. The document also notes that listeners can be unregistered based on Listener or Plugin, and all listeners for an event can be unregistered using `unregisterAll()`.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/event-api/handler-lists.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\npublic class ExampleListener implements Listener {\n\n    @EventHandler\n    public void onPlayerJoin(PlayerJoinEvent event) {\n        HandlerList handlerList = event.getHandlerList();\n        handlerList.unregister(this);\n        // ...\n    }\n\n    // Or:\n\n    public ExampleListener() {\n        // Access the handler list through the static getter\n        HandlerList handlerList = PlayerJoinEvent.getHandlerList();\n        handlerList.unregister(this);\n        // Granted this is a pretty stupid example...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing LifecycleEventManager from a Plugin\nDESCRIPTION: This snippet demonstrates how to obtain the LifecycleEventManager instance from within a plugin's main class using the getLifecycleManager() method.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/lifecycle.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n@Override\npublic void onEnable() {\n    final LifecycleEventManager<Plugin> lifecycleManager = this.getLifecycleManager();\n}\n```\n\n----------------------------------------\n\nTITLE: Registering ShapedRecipe in PaperMC (Java)\nDESCRIPTION: This snippet demonstrates how to create and register a shaped crafting recipe using the PaperMC API. It requires creating a unique NamespacedKey for the recipe, defining the resulting ItemStack, setting the 3x3 shape using a pattern string array, mapping characters in the pattern to specific ingredient materials, and adding the recipe to the server. Note that Air cannot be used as an ingredient.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/recipes.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\npublic class TestPlugin extends JavaPlugin {\n\n    @Override\n    public void onEnable() {\n        NamespacedKey key = new NamespacedKey(this, \"WarriorSword\");\n        ItemStack item = ItemStack.of(Material.DIAMOND_SWORD);\n\n        ShapedRecipe recipe = new ShapedRecipe(key, item);\n        recipe.shape(\" A \", \"AAA\", \" B \");\n        recipe.setIngredient('A', Material.DIAMOND);\n        recipe.setIngredient('B', Material.STICK);\n\n        getServer().addRecipe(recipe);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Anti-Xray with engine-mode 1 in paper-world.yml (Nether)\nDESCRIPTION: This snippet configures Anti-Xray with engine-mode 1 for the Nether dimension in `paper-world.yml`.  It includes settings for enabled, engine-mode, hidden-blocks, lava-obscures, max-block-height, replacement-blocks (empty), update-radius and use-permission. The hidden blocks are specific to the Nether dimension.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/anti-xray.mdx#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nanticheat:\n  anti-xray:\n    enabled: true\n    engine-mode: 1\n    hidden-blocks:\n    - ancient_debris\n    - nether_gold_ore\n    - nether_quartz_ore\n    lava-obscures: false\n    max-block-height: 128\n    # The replacement-blocks list is not used in engine-mode: 1. Changing this will have no effect.\n    replacement-blocks: []\n    update-radius: 2\n    use-permission: false\n```\n\n----------------------------------------\n\nTITLE: Representing Components in JSON Format\nDESCRIPTION: Provides an example of the standard Minecraft raw JSON text format used to represent components. This structure includes text content, styling attributes (color, bold, underlined), and nested components within the `extra` array. It also demonstrates a `keybind` component type.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/component-api/intro.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"text\": \"This is the parent component; its style is applied to all children.\\n\",\n  \"color\": \"#438df2\",\n  \"bold\": true,\n  \"extra\": [\n    {\n      \"text\": \"This is this first child, which is rendered after the parent\",\n      \"underlined\": true,\n      // This overrides the parent's \"bold\" value just for this component\n      \"bold\": false\n    },\n    {\n      // This is a keybind component which will display the client's keybind for that action\n      \"keybind\": \"key.inventory\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Channel Identifier in Java\nDESCRIPTION: Defines a constant for the custom plugin channel identifier used for registering and identifying plugin messages in Velocity.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/plugin-messaging.md#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\npublic static final MinecraftChannelIdentifier IDENTIFIER = MinecraftChannelIdentifier.from(\"custom:main\");\n```\n\n----------------------------------------\n\nTITLE: Accessing LifecycleEventManager from a Bootstrapper\nDESCRIPTION: This snippet shows how to access the LifecycleEventManager from a plugin bootstrapper by using the BootstrapContext.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/lifecycle.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\n@Override\npublic void bootstrap(BootstrapContext context) {\n    final LifecycleEventManager<BootstrapContext> lifecycleManager = context.getLifecycleManager();\n}\n```\n\n----------------------------------------\n\nTITLE: Registering ShapelessRecipe in PaperMC (Java)\nDESCRIPTION: This snippet illustrates how to create and register a shapeless crafting recipe using the PaperMC API. It involves creating a unique NamespacedKey and the resulting ItemStack, then adding ingredients using the addIngredient method which specifies the required quantity of a particular Material. The order or position of ingredients in the crafting grid does not matter for this recipe type.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/recipes.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\npublic class TestPlugin extends JavaPlugin {\n\n    @Override\n    public void onEnable() {\n        NamespacedKey key = new NamespacedKey(this, \"WarriorSword\");\n        ItemStack item = ItemStack.of(Material.DIAMOND_SWORD);\n\n        ShapelessRecipe recipe = new ShapelessRecipe(key, item);\n        recipe.addIngredient(3, Material.DIAMOND);\n        recipe.addIngredient(2, Material.STICK);\n\n        getServer().addRecipe(recipe);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring paper-global.yml for Vanilla Parity\nDESCRIPTION: Displays relevant settings within paper-global.yml that may need adjustment to align PaperMC global behavior closer to Vanilla Minecraft. The specific settings shown are filtered by the `filterVanilla` function to highlight those impacting Vanilla parity.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/vanilla.mdx#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n# Example structure from paper-global.yml - Actual content dynamically loaded\n# section:\n#   subsection:\n#     setting: value\n```\n\n----------------------------------------\n\nTITLE: Implementing ConfigurationSerializable for Custom Types in Paper\nDESCRIPTION: Provides an example of creating a custom Java class (`TeleportOptions`) that can be serialized to and deserialized from Bukkit configurations by implementing `ConfigurationSerializable`. It requires an instance `serialize` method returning a `Map<String, Object>` and a static `deserialize` method taking the map and returning an instance of the class. The class must also be registered with `ConfigurationSerialization.registerClass()`.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/plugin-configs.mdx#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\npublic class TeleportOptions implements ConfigurationSerializable {\n\n    private int chunkX;\n    private int chunkZ;\n    private String name;\n\n    public TeleportOptions(int chunkX, int chunkZ, String name) {\n        // Set the values\n    }\n\n    public Map<String, Object> serialize() {\n        Map<String, Object> data = new HashMap<>();\n\n        data.put(\"chunk-x\", this.chunkX);\n        data.put(\"chunk-z\", this.chunkZ);\n        data.put(\"name\", this.name);\n\n        return data;\n    }\n\n    public static TeleportOptions deserialize(Map<String, Object> args) {\n        return new TeleportOptions(\n                (int) args.get(\"chunk-x\"),\n                (int) args.get(\"chunk-z\"),\n                (String) args.get(\"name\")\n        );\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting PaperMC server with remote JVM debugger enabled using shell\nDESCRIPTION: This shell command shows how to start a PaperMC server with JVM arguments to enable remote debugging over a socket. It uses the Java Debug Wire Protocol (JDWP) agent to allow an IDE debugger to attach at runtime. Key parameters include transport method (dt_socket), server mode (server=y), suspend mode (suspend=n), and the listening port (5005). Replace \\{LATEST_PAPER_RELEASE} with the actual server jar version. This enables developers to connect remotely from their IDE to pause and inspect plugin execution without stopping the server.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/misc/debugging.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\njava -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005 -jar paper-\\{LATEST_PAPER_RELEASE}.jar nogui\n```\n\n----------------------------------------\n\nTITLE: Configuring Gradle Repository: papermc\nDESCRIPTION: This snippet sets up the papermc Maven repository using Gradle's Kotlin DSL. It defines the name and the URL of the repository. This repository hosts the necessary artifacts required for building Velocity plugins.  It allows Gradle to resolve and download project dependencies.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/getting-started/creating-your-first-plugin.mdx#_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\n    repositories {\n      maven {\n        name = \"papermc\"\n        url = uri(\"https://repo.papermc.io/repository/maven-public/\")\n      }\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Rendering a custom chat message combining display name and message\nDESCRIPTION: Implements the `render` method from `ChatRenderer` to create a chat message that prefixes the source display name followed by the message content. Demonstrates how to construct a `Component` that formats the chat message as desired, enabling visual customization of chat output.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/event-api/chat-event.md#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\npublic class ChatListener implements Listener, ChatRenderer {\n\n    // Listener logic\n\n    @Override\n    public Component render(Player source, Component sourceDisplayName, Component message, Audience viewer) {\n        return sourceDisplayName\n                .append(Component.text(\": \"))\n                .append(message);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Paperweight Plugin (Kotlin DSL)\nDESCRIPTION: This code snippet demonstrates how to add the paperweight-userdev plugin to your Gradle build file using the Kotlin DSL. It specifies the plugin ID and version.  The version should be replaced with the latest available version. This plugin allows access to internal server code during development.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/userdev.md#_snippet_0\n\nLANGUAGE: kotlin\nCODE:\n```\nplugins {\n  id(\"io.papermc.paperweight.userdev\") version \"\\{LATEST_USERDEV_RELEASE}\"\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Rotation and Scale Transformations to BlockDisplay Entities with PaperMC in Java\nDESCRIPTION: Shows how to apply combined rotation and scale transformations to a BlockDisplay entity using the Transformation class. The example uses specified left and right rotations around X and Z axes respectively (in radians) along with scaling by factor 2 on all axes. It also demonstrates an alternative raw JOML matrix transformation commented out. Inputs are spawn location and rotation/scale parameters. Output is a rotated and scaled block display.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/entity-api/display-entities.md#_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nworld.spawn(location, BlockDisplay.class, entity -> {\n    entity.setBlock(Material.GRASS_BLOCK.createBlockData());\n    entity.setTransformation(\n        new Transformation(\n                new Vector3f(), // no translation\n                new AxisAngle4f((float) -Math.toRadians(45), 1, 0, 0), // rotate -45 degrees on the X axis\n                new Vector3f(2, 2, 2), // scale up by a factor of 2 on all axes\n                new AxisAngle4f((float) Math.toRadians(45), 0, 0, 1) // rotate +45 degrees on the Z axis\n        )\n    );\n    // or set a raw transformation matrix from JOML\n    // entity.setTransformationMatrix(\n    //         new Matrix4f()\n    //                 .scale(2) // scale up by a factor of 2 on all axes\n    //                 .rotateXYZ(\n    //                         (float) Math.toRadians(360 - 45), // rotate -45 degrees on the X axis\n    //                         0,\n    //                         (float) Math.toRadians(45) // rotate +45 degrees on the Z axis\n    //                 )\n    // );\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Tab Suggestions - Java\nDESCRIPTION: Shows a simple Java implementation of the optional `suggest` method for a `BasicCommand`. It provides a basic tab completion suggestion list containing the names of all players currently online, irrespective of the user's input.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/misc/basic-command.md#_snippet_7\n\nLANGUAGE: Java\nCODE:\n```\n@Override\npublic Collection<String> suggest(CommandSourceStack commandSourceStack, String[] args) {\n    return Bukkit.getOnlinePlayers().stream().map(Player::getName).toList();\n}\n```\n\n----------------------------------------\n\nTITLE: Handling InventoryClickEvent to Detect Custom Inventory in Java\nDESCRIPTION: Provides an event handler method for InventoryClickEvent that safely checks if the clicked inventory's InventoryHolder is an instance of the custom MyInventory class. Utilizes Java's instanceof pattern matching to cast the holder if matched, allowing targeted event handling for the plugin's inventory only. If the holder is not the custom type, the event is ignored. Requires registering this event handler and depends on the Paper API event system.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/custom-inventory-holder.md#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\n@EventHandler\npublic void onInventoryClick(InventoryClickEvent event) {\n    Inventory inventory = event.getInventory();\n    // Check if the holder is our MyInventory,\n    // if yes, use instanceof pattern matching to store it in a variable immediately.\n    if (!(inventory.getHolder(false) instanceof MyInventory myInventory)) {\n        // It's not our inventory, ignore it.\n        return;\n    }\n\n    // Do what we need in the event.\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ResultedEvent with GenericResult in a PrivateMessageEvent class\nDESCRIPTION: This example demonstrates how to implement the ResultedEvent interface for a PrivateMessageEvent class using GenericResult as the result type. The implementation includes storing sender, recipient, and message data, along with properly managing the event result following Velocity conventions.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/event.md#_snippet_10\n\nLANGUAGE: java\nCODE:\n```\npublic class PrivateMessageEvent implements ResultedEvent<GenericResult> {\n\n  private final Player sender;\n  private final Player recipient;\n  private final String message;\n\n  private GenericResult result = GenericResult.allowed(); // Allowed by default\n\n  public PrivateMessageEvent(Player sender, Player recipient, String message) {\n    this.sender = sender;\n    this.recipient = recipient;\n    this.message = message;\n  }\n\n  public Player sender() {\n    return sender;\n  }\n\n  public Player recipient() {\n    return recipient;\n  }\n\n  public String message() {\n    return message;\n  }\n\n  @Override\n  public GenericResult result() {\n    return result;\n  }\n\n  @Override\n  public void setResult(GenericResult result) {\n    this.result = Objects.requireNonNull(result);\n  }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Opening Custom Inventory for Player in Java\nDESCRIPTION: Demonstrates how to instantiate the custom InventoryHolder and open its inventory for a player. Requires a Player instance and the plugin instance passed to the custom InventoryHolder constructor. The player.openInventory method is called with the inventory obtained from the custom holder. This snippet assumes correct instantiation and context within plugin code such as commands or event handlers.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/custom-inventory-holder.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nPlayer player; // Assume we have a Player instance.\n               // This can be a command, another event or anywhere else you have a Player.\n\nMyInventory myInventory = new MyInventory(myPlugin);\nplayer.openInventory(myInventory.getInventory());\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Velocity Plugin Class\nDESCRIPTION: This snippet demonstrates the basic structure of a Velocity plugin class using the `@Plugin` annotation. It includes dependency injection of `ProxyServer` and `Logger` instances. The `id`, `name`, `version`, `url`, `description`, and `authors` parameters are set in the `@Plugin` annotation to provide metadata for the plugin.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/getting-started/api-basics.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\npackage com.example.velocityplugin;\n\nimport com.google.inject.Inject;\nimport com.velocitypowered.api.plugin.Plugin;\nimport com.velocitypowered.api.proxy.ProxyServer;\nimport org.slf4j.Logger;\n\n@Plugin(id = \"myfirstplugin\", name = \"My First Plugin\", version = \"0.1.0-SNAPSHOT\",\n        url = \"https://example.org\", description = \"I did it!\", authors = {\"Me\"})\npublic class VelocityTest {\n\n    private final ProxyServer server;\n    private final Logger logger;\n\n    @Inject\n    public VelocityTest(ProxyServer server, Logger logger) {\n        this.server = server;\n        this.logger = logger;\n\n        logger.info(\"Hello there! I made my first plugin with Velocity.\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting to SQLite Database using JDBC in Java\nDESCRIPTION: This Java snippet demonstrates how to initialize and connect to a SQLite database using the built-in JDBC driver bundled with Paper. It includes loading the SQLite JDBC driver via Class.forName and establishing a connection to a local SQLite database file using DriverManager.getConnection. The Connection object obtained can be used to execute SQL statements. No external dependencies are required beyond the standard Java SQL package and the bundled SQLite JDBC driver.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/misc/databases.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\npublic class DatabaseManager {\n\n  public void connect() {\n    Class.forName(\"org.sqlite.JDBC\");\n    Connection connection = DriverManager.getConnection(\"jdbc:sqlite:plugins/TestPlugin/database.db\");\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding velocity-api Dependency: Maven\nDESCRIPTION: This snippet adds the `velocity-api` dependency to the Maven project. This dependency provides the necessary classes and interfaces for interacting with the Velocity proxy.  The scope is set to `provided`, indicating that Velocity will provide the dependency at runtime. The version uses a placeholder for the latest release, which is important for up-to-date builds.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/getting-started/creating-your-first-plugin.mdx#_snippet_1\n\nLANGUAGE: xml\nCODE:\n```\n      <dependencies>\n        <dependency>\n          <groupId>com.velocitypowered</groupId>\n          <artifactId>velocity-api</artifactId>\n          <version>\\{LATEST_VELOCITY_RELEASE}</version>\n          <scope>provided</scope>\n        </dependency>\n      </dependencies>\n\n```\n\n----------------------------------------\n\nTITLE: Creating Custom InventoryHolder Implementation in Java\nDESCRIPTION: Defines a custom class implementing the InventoryHolder interface to create and manage a plugin-specific inventory with 9 slots. The constructor accepts the main plugin instance to create the inventory via the server, associating the InventoryHolder ('this') with it. This allows reliable identification of plugin inventories during events. The getInventory method returns the constructed Inventory instance. Requires the Paper API and Bukkit server context.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/custom-inventory-holder.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\npublic class MyInventory implements InventoryHolder {\n\n    private final Inventory inventory;\n\n    public MyInventory(MyPlugin plugin) {\n        // Create an Inventory with 9 slots, `this` here is our InventoryHolder.\n        this.inventory = plugin.getServer().createInventory(this, 9);\n    }\n\n    @Override\n    public Inventory getInventory() {\n        return this.inventory;\n    }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Configuration Data - Astro\nDESCRIPTION: This snippet renders the configuration data parsed from `spigot.yml` using a custom Astro component called `ConfigNode`. The `parse` function from the `yaml` library is used to convert the raw YAML data into a JavaScript object that the component then uses to display the spigot.yml configuration. The `data` prop of the `ConfigNode` component is populated with the output from parse(SpigotYML).\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/reference/configuration/spigot-configuration.mdx#_snippet_1\n\nLANGUAGE: Astro\nCODE:\n```\n<ConfigNode data={parse(SpigotYML)} />\n```\n\n----------------------------------------\n\nTITLE: Importing Components and Configuration for Server Properties Documentation\nDESCRIPTION: Imports required components and YAML configuration data for rendering the server.properties documentation. It uses Astro components and the YAML parser to process and display the configuration properties in an interactive format.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/reference/configuration/server-properties.mdx#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport ConfigNode from \"/src/components/ConfigNode.astro\";\nimport ServerPropertiesYML from \"/src/config/paper/server-properties.yml?raw\";\nimport { parse } from \"yaml\";\n```\n\n----------------------------------------\n\nTITLE: Cancelling a scheduled task and checking its status in Velocity Scheduler API in Java\nDESCRIPTION: This snippet covers how to cancel a scheduled task via the ScheduledTask object and how to retrieve its current status. Essential for managing task lifecycle and debugging in plugin development.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/scheduler.md#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\nScheduledTask task = server.getScheduler()\n  .buildTask(plugin, () -> {\n    // do stuff here\n  })\n  .repeat(5L, TimeUnit.MINUTES)\n  .schedule();\n// ...\ntask.cancel();\n// ...\nSystem.out.println(task.status());\n```\n\n----------------------------------------\n\nTITLE: Installing Java 21 - DNF\nDESCRIPTION: This command installs the Java 21 Development Kit (JDK) from the Amazon Corretto repository using DNF. The `-y` flag automatically answers yes to all prompts.  It's the final step for installing Java 21 on DNF based systems.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/misc/java-install.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsudo dnf -y install java-21-amazon-corretto-devel\n```\n\n----------------------------------------\n\nTITLE: Disabling Channel Limit on Paper Servers for Velocity Compatibility\nDESCRIPTION: Provides the Java system property startup flag required for Paper servers (version 1.12.2 or higher) to prevent the 'Invalid payload REGISTER' error when players with modded clients connect through Velocity. This flag disables the channel limit enforcement.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/admin/getting-started/faq.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n-Dpaper.disableChannelLimit=true\n```\n\n----------------------------------------\n\nTITLE: Parsing and Displaying EULA Properties File Using Astro and YAML in JavaScript\nDESCRIPTION: This snippet imports the EULA properties file as raw YAML and parses it for rendering with the ConfigNode Astro component. It demonstrates handling a simple key-value file ('eula.txt') specifying user agreement acceptance, with dependencies on the `yaml` parser and the Astro ConfigNode component. The input is raw YAML content representing the EULA acceptance, and the output is a rendered, parseable properties data node. This usage showcases integration of server agreement config display within the website framework.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/reference/configuration/vanilla-data-files.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport ConfigNode from \"/src/components/ConfigNode.astro\";\nimport { parse } from \"yaml\";\nimport EulaYML from \"/src/config/paper/eula.yml?raw\";\n\n<ConfigNode data={parse(EulaYML)} lang=\"properties\" path={[\"eula\"]} />\n```\n\n----------------------------------------\n\nTITLE: Matching Items Without Certain Data Components in Java\nDESCRIPTION: Demonstrates how to compare items while ignoring specific data components like durability.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/data-component-api.md#_snippet_9\n\nLANGUAGE: java\nCODE:\n```\nItemStack originalSword = ItemStack.of(Material.DIAMOND_SWORD);\nItemStack damagedSword = ItemStack.of(Material.DIAMOND_SWORD);\ndamagedSword.setData(DataComponentTypes.DAMAGE, 100);\n\nboolean match = damagedSword.matchesWithoutData(originalSword, Set.of(DataComponentTypes.DAMAGE), false);\nlogger.info(\"Do the sword match? \" + match); // -> true\n```\n\n----------------------------------------\n\nTITLE: Creating tooltips for command suggestions in Java\nDESCRIPTION: Example of adding a suggestion with a tooltip using MessageComponentSerializer. This code adds a suggestion with formatted green text as a tooltip that appears when hovering over the suggestion.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/argument-suggestions.mdx#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nbuilder.suggest(\"suggestion\", MessageComponentSerializer.message().serialize(\n    MiniMessage.miniMessage().deserialize(\"<green>Suggestion tooltip\")\n));\n```\n\n----------------------------------------\n\nTITLE: Creating a RegistryKeySet of Enchantments with Paper API in Java\nDESCRIPTION: Illustrates creating a RegistryKeySet that holds multiple enchantment keys, providing a stable reference to entries in the enchantment registry. It uses the RegistrySet factory method to build the key set and includes both vanilla and custom enchantment keys. Inputs are registry keys representing each enchantment; output is a RegistryKeySet collection that remains valid despite registry value changes.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/registries.md#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\n// Create a new registry key set that holds a collection enchantments\nfinal RegistryKeySet<Enchantment> bestEnchantments = RegistrySet.keySet(\n    RegistryKey.ENCHANTMENT,\n    // Arbitrary keys of enchantments to store in the key set.\n    EnchantmentKeys.CHANNELING,\n    EnchantmentKeys.create(Key.key(\"papermc:softspoon\"))\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring MySQL Connection Pooling using HikariCP in Java\nDESCRIPTION: This Java snippet shows how to configure and establish a connection to a MySQL standalone database using the HikariCP connection pool library. It covers creating a HikariConfig object, setting the JDBC URL, username, password, and maximum pool size, and creating a HikariDataSource from the config. It demonstrates obtaining a Connection from the pool with try-with-resources, preparing an SQL statement, and handling exceptions. Dependencies include HikariCP (version 4.0.3), which must be added via Maven or Gradle, and requires a running MySQL database instance. Note that the Hikari library is not bundled with Paper and should be shaded or loaded properly.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/misc/databases.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\npublic class DatabaseManager {\n\n  public void connect() {\n    HikariConfig config = new HikariConfig();\n    config.setJdbcUrl(\"jdbc:mysql://localhost:3306/mydatabase\"); // Address of your running MySQL database\n    config.setUsername(\"username\"); // Username\n    config.setPassword(\"password\"); // Password\n    config.setMaximumPoolSize(10); // Pool size defaults to 10\n\n    config.addDataSourceProperty(\"\", \"\"); // MISC settings to add\n    HikariDataSource dataSource = new HikariDataSource(config);\n\n    try (Connection connection = dataSource.getConnection()) {\n      // Use a try-with-resources here to autoclose the connection.\n      PreparedStatement sql = connection.prepareStatement(\"SQL\");\n      // Execute statement\n    } catch (Exception e) {\n      // Handle any exceptions that arise from getting / handing the exception.\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Signed Message Argument in Paper Command API\nDESCRIPTION: Demonstrates how to create a command that uses the signed message argument to handle cryptographically signed player messages. The example shows how to resolve and send SignedMessage objects to target players while preserving message authenticity.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/adventure.mdx#_snippet_4\n\nLANGUAGE: java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> signedMessageArgument() {\n    return Commands.literal(\"signedmessage\")\n        .then(Commands.argument(\"target\", ArgumentTypes.player())\n            .then(Commands.argument(\"message\", ArgumentTypes.signedMessage())\n                .executes(MinecraftArguments::executeSignedMessageCommand)))\n        .build();\n}\n\nprivate static int executeSignedMessageCommand(final CommandContext<CommandSourceStack> ctx) throws CommandSyntaxException {\n    final Player target = ctx.getArgument(\"target\", PlayerSelectorArgumentResolver.class).resolve(ctx.getSource()).getFirst();\n    final SignedMessageResolver messageResolver = ctx.getArgument(\"message\", SignedMessageResolver.class);\n\n    messageResolver.resolveSignedMessage(\"message\", ctx).thenAccept(msg -> {\n        target.sendMessage(msg, ChatType.CHAT.bind(ctx.getSource().getSender().name()));\n    });\n\n\n    return Command.SINGLE_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing Cyclic Plugin Loading with D2\nDESCRIPTION: A D2 diagram illustrating a cyclic dependency chain among four plugins (A -> B -> C -> D -> A). This represents an unresolvable loading order scenario that Paper plugins will detect and report as an error.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/paper-plugins.md#_snippet_7\n\nLANGUAGE: d2\nCODE:\n```\nstyle.fill: transparent\ndirection: right\n\nA -> B\nB -> C\nC -> D\nD -> A\n```\n\n----------------------------------------\n\nTITLE: Checking Startup Script for Jarfile Access Error - Windows\nDESCRIPTION: This snippet illustrates how to address the 'Error: Unable to access jarfile server.jar' issue in a Windows startup script. The solution involves ensuring the .jar filename matches the downloaded file, including extensions, and using 'pause' to prevent terminal closure.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/basic-troubleshooting.md#_snippet_0\n\nLANGUAGE: Batch\nCODE:\n```\npause\n```\n\n----------------------------------------\n\nTITLE: Defining Single Entity Command Argument (Java)\nDESCRIPTION: This Java snippet demonstrates how to define a Brigadier command `entityarg` that uses the `ArgumentTypes.entity()` argument. It retrieves the `EntitySelectorArgumentResolver`, resolves it to a `List<Entity>`, and then prints the name of the single found entity. This argument requires exactly one target entity. Dependencies include PaperMC API components like `Commands`, `ArgumentTypes`, `EntitySelectorArgumentResolver`, `Entity`, `CommandSourceStack`, `Command`, and `Placeholder`.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/entity-player.mdx#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> entityArgument() {\n    return Commands.literal(\"entityarg\")\n        .then(Commands.argument(\"arg\", ArgumentTypes.entity())\n            .executes(ctx -> {\n                final EntitySelectorArgumentResolver entitySelectorArgumentResolver = ctx.getArgument(\"arg\", EntitySelectorArgumentResolver.class);\n                final List<Entity> entities = entitySelectorArgumentResolver.resolve(ctx.getSource());\n\n                ctx.getSource().getSender().sendRichMessage(\"Found <green><entityname>\",\n                    Placeholder.component(\"entityname\", entities.getFirst().name())\n                );\n\n                return Command.SINGLE_SUCCESS;\n            }))\n        .build();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Custom Event Class in Paper (Java)\nDESCRIPTION: This snippet defines a minimal custom event class, PaperIsCoolEvent, that extends the Paper API's Event class. It includes a static HandlerList and the required static getHandlerList() and instance-level getHandlers() methods, allowing listeners to register for this event. Dependencies: org.bukkit.event.Event and org.bukkit.event.HandlerList. No extra parameters; the event currently carries no additional data and cannot be listened to unless properly instantiated.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/event-api/custom-events.md#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\npublic class PaperIsCoolEvent extends Event {\n\n    private static final HandlerList HANDLER_LIST = new HandlerList();\n\n    public static HandlerList getHandlerList() {\n        return HANDLER_LIST;\n    }\n\n    @Override\n    public HandlerList getHandlers() {\n        return HANDLER_LIST;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: JVM Command to Enable Full Stacktrace Output\nDESCRIPTION: This code snippet demonstrates how to configure the Java Virtual Machine (JVM) to include complete stacktraces for NullPointerExceptions that are otherwise optimized out in fast throw mode. Including this flag ensures debugging information is comprehensive, assisting developers in diagnosing issues.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/misc/reading-stacktraces.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\njava -XX:-OmitStackTraceInFastThrow -jar paper.jar\n```\n\n----------------------------------------\n\nTITLE: Handling player move events with debug-appropriate structure in Java\nDESCRIPTION: This Java snippet is an example Bukkit event handler method demonstrating plugin logic that can be debugged with breakpoints. It listens for PlayerMoveEvent, obtains the player and their location, and then checks if the player is in the Nether world. If so, it sends a message to the player. The snippet shows safe null handling for the world reference and a simple conditional action, making it suitable for inspecting runtime behavior and variable values during debugging sessions with an IDE.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/misc/debugging.md#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\n@EventHandler\npublic void onPlayerMove(PlayerMoveEvent event) {\n  Player player = event.getPlayer();\n  Location location = player.getLocation();\n\n  if (location.getWorld() == null)\n    return;\n\n  if (location.getWorld().getEnvironment() == World.Environment.NETHER) {\n    player.sendMessage(\"You are in the nether!\");\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Hangar Publish Plugin to Gradle Build Script\nDESCRIPTION: This code shows how to add the Hangar publish plugin to your Gradle build script's plugins block. This plugin enables publishing functionality for Hangar.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/misc/hangar-publishing.md#_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\nplugins {\n    id(\"io.papermc.hangar-publish-plugin\") version \"0.1.2\"\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Corretto Key and Adding Repository - Debian\nDESCRIPTION: This code imports the Amazon Corretto public key and adds the Corretto apt repository to a Debian-based Linux system. It uses `wget` to download the key, `gpg --dearmor` to convert the key, and `tee` to add the repository to the sources list.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/misc/java-install.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwget -O - https://apt.corretto.aws/corretto.key | sudo gpg --dearmor -o /usr/share/keyrings/corretto-keyring.gpg && \\\necho \"deb [signed-by=/usr/share/keyrings/corretto-keyring.gpg] https://apt.corretto.aws stable main\" | sudo tee /etc/apt/sources.list.d/corretto.list\n```\n\n----------------------------------------\n\nTITLE: Declaring Dependencies in `paper-plugin.yml`\nDESCRIPTION: Demonstrates how to declare dependencies within the `paper-plugin.yml` file, separating them into `bootstrap` and `server` sections. It shows how to specify load order (`BEFORE`, `AFTER`, `OMIT`), requirement status (`required`), and classpath access (`join-classpath`).\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/paper-plugins.md#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\ndependencies:\n  bootstrap:\n    # Let's say that RegistryPlugin registers some data that your plugin needs to use\n    # We don't need this during runtime, so it's not required in the server section.\n    # However, can be added to both if needed\n    RegistryPlugin:\n      load: BEFORE\n      required: true\n      join-classpath: true # Defaults to true\n  server:\n    # Add a required \"RequiredPlugin\" dependency, which will load AFTER your plugin.\n    RequiredPlugin:\n      load: AFTER\n      required: true\n      # This means that your plugin will not have access to their classpath\n      join-classpath: false\n```\n\n----------------------------------------\n\nTITLE: Troubleshooting Player Information Forwarding Errors in Velocity\nDESCRIPTION: Displays common error messages encountered when player information forwarding between Velocity and backend servers is misconfigured. These errors indicate issues with forwarding settings either on the proxy or the backend server. Refer to the Player Information Forwarding documentation for correct setup.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/admin/getting-started/faq.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nCan't connect to server lobby: If you wish to use IP forwarding, please enable it in your Bungeecord config as well!\n```\n\nLANGUAGE: plaintext\nCODE:\n```\nCan't connect to server lobby: Your server did not send a forwarding request to the proxy. Is it set up correctly?\n```\n\nLANGUAGE: plaintext\nCODE:\n```\nCan't connect to server lobby: This server requires you to connect with Velocity.\n```\n\n----------------------------------------\n\nTITLE: Retrieving and cancelling all tasks scheduled by a plugin in Velocity Scheduler API in Java\nDESCRIPTION: This snippet shows how to obtain all scheduled tasks associated with a specific plugin and cancel each one, facilitating plugin-wide task management and cleanup.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/scheduler.md#_snippet_5\n\nLANGUAGE: Java\nCODE:\n```\nCollection<ScheduledTask> tasks = server.getScheduler().tasksByPlugin(plugin);\n// then you can control them, for example, cancel all task scheduled by a plugin\nfor (ScheduledTask task : tasks) {\n  task.cancel();\n}\n```\n\n----------------------------------------\n\nTITLE: Tuning JVM Startup Flags for Velocity (Java)\nDESCRIPTION: This snippet shows the recommended JVM startup flags for optimizing Velocity's performance. These flags primarily tune the G1 garbage collector for Velocity's workload and improve general performance. The flags are added after the `java` command but before the `-jar` parameter. These configurations aim to reduce GC pauses and improve overall responsiveness.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/admin/how-to/tuning.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n-XX:+UseG1GC -XX:G1HeapRegionSize=4M -XX:+UnlockExperimentalVMOptions -XX:+ParallelRefProcEnabled -XX:+AlwaysPreTouch -XX:MaxInlineLevel=15\n```\n\n----------------------------------------\n\nTITLE: Define Objective Criteria Command Argument (Paper/Java)\nDESCRIPTION: Illustrates defining a command argument that parses a `Criteria` enum value using `ArgumentTypes.objectiveCriteria()`. The parsed value is retrieved as a `Criteria` object, usable with `Scoreboard` objects. The example sends a rich message showing the criteria's name and its default render type. Requires Paper API, Brigadier, and Adventure API.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/paper.mdx#_snippet_5\n\nLANGUAGE: java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> objectiveCriteriaArgument() {\n    return Commands.literal(\"objectivecriteria\")\n        .then(Commands.argument(\"criteria\", ArgumentTypes.objectiveCriteria())\n            .executes(ctx -> {\n                final Criteria criteria = ctx.getArgument(\"criteria\", Criteria.class);\n\n                ctx.getSource().getSender().sendRichMessage(\"Default render type for <criteria>: <rendertype>\",\n                    Placeholder.unparsed(\"criteria\", criteria.getName()),\n                    Placeholder.unparsed(\"rendertype\", criteria.getDefaultRenderType().name())\n                );\n                return Command.SINGLE_SUCCESS;\n            }))\n        .build();\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning the PaperMC Docs Repository using Git\nDESCRIPTION: This command uses Git to download the PaperMC documentation source code from the specified GitHub repository into a local directory named 'docs'. This is the first step in setting up the project locally.\nSOURCE: https://github.com/papermc/docs/blob/main/README.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\n$ git clone https://github.com/PaperMC/docs\n```\n\n----------------------------------------\n\nTITLE: Deserializing MiniMessage Strings to Components in Java\nDESCRIPTION: Shows how to parse a MiniMessage-formatted string into an Adventure `Component` object using `MiniMessage.miniMessage().deserialize()`. It also includes an example of a helper method (`mm`) to simplify the deserialization process within the codebase. Depends on the MiniMessage library.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/component-api/intro.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nfinal Component component = MiniMessage.miniMessage().deserialize(\n    \"<#438df2><b>This is the parent component; its style is \" +\n    \"applied to all children.\\n<u><!b>This is the first child, \" +\n    \"which is rendered after the parent</!b></u><key:key.inventory></b></#438df2>\"\n);\n\n\n// if the syntax above is too verbose for you, create a helper method!\n\npublic final class Components {\n    public static Component mm(String miniMessageString) { // mm, short for MiniMessage\n        return MiniMessage.miniMessage().deserialize(miniMessageString);\n    }\n}\n\n// ...\n\nimport static io.papermc.docs.util.Components.mm; // replace with your own package\n\nfinal Component component = mm(\"<blue>Hello <red>World!\");\n```\n\n----------------------------------------\n\nTITLE: Dependency Injection in Velocity Plugins\nDESCRIPTION: This snippet demonstrates dependency injection using the `@Inject` annotation in the plugin's constructor. Velocity automatically injects instances of `ProxyServer` and `Logger` which can be used to interact with the Velocity proxy and log messages, respectively. This simplifies access to core Velocity services.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/getting-started/api-basics.md#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\n@Inject\npublic VelocityTest(ProxyServer server, Logger logger) {\n    this.server = server;\n    this.logger = logger;\n\n    logger.info(\"Hello there, it's a test plugin I made!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Examining the SuggestionProvider interface structure in Java\nDESCRIPTION: Definition of the SuggestionProvider functional interface that is used to provide command argument suggestions. It takes a generic parameter S (usually CommandSourceStack in Paper) and requires implementing a method that returns completable future suggestions.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/argument-suggestions.mdx#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n@FunctionalInterface\npublic interface SuggestionProvider<S> {\n    CompletableFuture<Suggestions> getSuggestions(final CommandContext<S> context, final SuggestionsBuilder builder) throws CommandSyntaxException;\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Non-valued Data Components in Java\nDESCRIPTION: Explains how to work with flag-type data components that don't have values.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/data-component-api.md#_snippet_5\n\nLANGUAGE: java\nCODE:\n```\n// Make the item a glider to be used like elytra (combined with the equippable component)\nstack.setData(DataComponentTypes.GLIDER);\n\n// Remove the glider flag\nstack.unsetData(DataComponentTypes.GLIDER);\n```\n\n----------------------------------------\n\nTITLE: Analyzing PaperMC Watchdog Thread Dump (Server Log)\nDESCRIPTION: This log output is generated by the PaperMC watchdog thread when the server's main thread becomes unresponsive for a significant duration (e.g., 10 seconds). It indicates severe server lag, not a crash or bug in Paper itself, and includes a thread dump to help diagnose where the main thread is stuck, often pointing to plugin issues.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/basic-troubleshooting.md#_snippet_4\n\nLANGUAGE: Log\nCODE:\n```\n[02:04:00] [Paper Watchdog Thread/ERROR]: --- DO NOT REPORT THIS TO PAPER - THIS IS NOT A BUG OR A CRASH  - 1.21.3-66-afb5b13 (MC: 1.21.3) ---\n[02:04:00] [Paper Watchdog Thread/ERROR]: The server has not responded for 10 seconds! Creating thread dump\n[02:04:00] [Paper Watchdog Thread/ERROR]: ------------------------------\n[02:04:00] [Paper Watchdog Thread/ERROR]: Server thread dump (Look for plugins here before reporting to Paper!):\n[02:04:00] [Paper Watchdog Thread/ERROR]: ------------------------------\n[02:04:00] [Paper Watchdog Thread/ERROR]: Current Thread: Server thread\n[02:04:00] [Paper Watchdog Thread/ERROR]: PID: 129 | Suspended: false | Native: true | State: RUNNABLE\n[02:04:00] [Paper Watchdog Thread/ERROR]: Stack:\n[02:04:00] [Paper Watchdog Thread/ERROR]: java.base@21.0.5/sun.nio.ch.UnixFileDispatcherImpl.write0(Native Method)\n[02:04:00] [Paper Watchdog Thread/ERROR]: java.base@21.0.5/sun.nio.ch.UnixFileDispatcherImpl.write(UnixFileDispatcherImpl.java:65)\n[02:04:00] [Paper Watchdog Thread/ERROR]: java.base@21.0.5/sun.nio.ch.IOUtil.writeFromNativeBuffer(IOUtil.java:137)\n[02:04:00] [Paper Watchdog Thread/ERROR]: java.base@21.0.5/sun.nio.ch.IOUtil.write(IOUtil.java:102)\n[02:04:00] [Paper Watchdog Thread/ERROR]: java.base@21.0.5/sun.nio.ch.IOUtil.write(IOUtil.java:72)\n[02:04:00] [Paper Watchdog Thread/ERROR]: java.base@21.0.5/sun.nio.ch.FileChannelImpl.write(FileChannelImpl.java:300)\n[02:04:00] [Paper Watchdog Thread/ERROR]: java.base@21.0.5/sun.nio.ch.ChannelOutputStream.writeFully(ChannelOutputStream.java:68)\n[02:04:00] [Paper Watchdog Thread/ERROR]: java.base@21.0.5/sun.nio.ch.ChannelOutputStream.write(ChannelOutputStream.java:105)\n[02:04:00] [Paper Watchdog Thread/ERROR]: java.base@21.0.5/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:125)\n[02:04:00] [Paper Watchdog Thread/ERROR]: java.base@21.0.5/java.io.BufferedOutputStream.implFlush(BufferedOutputStream.java:252)\n[02:04:00] [Paper Watchdog Thread/ERROR]: java.base@21.0.5/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:240)\n[02:04:00] [Paper Watchdog Thread/ERROR]: java.base@21.0.5/java.io.FilterOutputStream.close(FilterOutputStream.java:184)\n```\n\n----------------------------------------\n\nTITLE: Configuring paper-world-defaults.yml for Vanilla Parity\nDESCRIPTION: Displays relevant settings within paper-world-defaults.yml that may need adjustment to align PaperMC world-specific behavior closer to Vanilla Minecraft. The specific settings shown are filtered by the `filterVanilla` function to highlight those impacting Vanilla parity.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/vanilla.mdx#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n# Example structure from paper-world-defaults.yml - Actual content dynamically loaded\n# section:\n#   setting: value\n```\n\n----------------------------------------\n\nTITLE: Defining CustomArgumentType Interface\nDESCRIPTION: This code presents the interface definition for `CustomArgumentType`. It outlines the generic types, methods, and default implementations that custom argument types must adhere to.  Key methods include `parse`, `getNativeType`, and `listSuggestions`. Requires the Brigadier library.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/custom-arguments.md#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\npackage io.papermc.paper.command.brigadier.argument;\n\n@NullMarked\npublic interface CustomArgumentType<T, N> extends ArgumentType<T> {\n\n    @Override\n    T parse(final StringReader reader) throws CommandSyntaxException;\n\n    @Override\n    default <S> T parse(final StringReader reader, final S source) throws CommandSyntaxException {\n        return ArgumentType.super.parse(reader, source);\n    }\n\n    ArgumentType<N> getNativeType();\n\n    @Override\n    @ApiStatus.NonExtendable\n    default Collection<String> getExamples() {\n        return this.getNativeType().getExamples();\n    }\n\n    @Override\n    default <S> CompletableFuture<Suggestions> listSuggestions(final CommandContext<S> context, final SuggestionsBuilder builder) {\n        return ArgumentType.super.listSuggestions(context, builder);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Lifecycle Event Handler with Shorthand Syntax\nDESCRIPTION: This snippet shows a simplified approach to register an event handler without additional configuration, using a more concise syntax.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/lifecycle.md#_snippet_5\n\nLANGUAGE: java\nCODE:\n```\n@Override\npublic void onEnable() {\n    final LifecycleEventManager<Plugin> lifecycleManager = this.getLifecycleManager();\n    lifecycleManager.registerEventHandler(LifecycleEvents.COMMANDS, (event) -> {\n        // Handler for the event\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Setting System Properties in Bash\nDESCRIPTION: Demonstrates how to set system properties when starting a Velocity server using a .bat or .sh file. The example uses the `-D` flag to define the `velocity.packet-decode-logging` property and set its value to `true`. This allows for detailed logging of packet decoding errors.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/admin/reference/system-properties.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\njava -Dvelocity.packet-decode-logging=true -jar velocity.jar\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Argument for Operator Players\nDESCRIPTION: This Java code defines a custom argument type, `OppedPlayerArgument`, for selecting online operators. The argument implements the `CustomArgumentType` interface to provide parsing, suggestion, and validation logic.  It uses the `PlayerSelectorArgumentResolver` as the underlying argument and throws exceptions if the source is invalid or the selected player isn't an operator. Requires PaperMC's command API, Bukkit API, and Brigadier for command parsing.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/custom-arguments.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\n@NullMarked\npublic final class OppedPlayerArgument implements CustomArgumentType<Player, PlayerSelectorArgumentResolver> {\n\n    private static final SimpleCommandExceptionType ERROR_BAD_SOURCE = new SimpleCommandExceptionType(\n        MessageComponentSerializer.message().serialize(Component.text(\"The source needs to be a CommandSourceStack!\"))\n    );\n\n    private static final DynamicCommandExceptionType ERROR_NOT_OPERATOR = new DynamicCommandExceptionType(name -> {\n        return MessageComponentSerializer.message().serialize(Component.text(name + \" is not a server operator!\"));\n    });\n\n    @Override\n    public Player parse(StringReader reader) {\n        throw new UnsupportedOperationException(\"This method will never be called.\");\n    }\n\n    @Override\n    public <S> Player parse(StringReader reader, S source) throws CommandSyntaxException {\n        if (!(source instanceof CommandSourceStack stack)) {\n            throw ERROR_BAD_SOURCE.create();\n        }\n\n        final Player player = getNativeType().parse(reader).resolve(stack).getFirst();\n        if (!player.isOp()) {\n            throw ERROR_NOT_OPERATOR.create(player.getName());\n        }\n\n        return player;\n    }\n\n    @Override\n    public ArgumentType<PlayerSelectorArgumentResolver> getNativeType() {\n        return ArgumentTypes.player();\n    }\n\n    @Override\n    public <S> CompletableFuture<Suggestions> listSuggestions(CommandContext<S> ctx, SuggestionsBuilder builder) {\n        Bukkit.getOnlinePlayers().stream()\n            .filter(ServerOperator::isOp)\n            .map(Player::getName)\n            .filter(name -> name.toLowerCase(Locale.ROOT).startsWith(builder.getRemainingLowerCase()))\n            .forEach(builder::suggest);\n        return builder.buildFuture();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Navigation Links Using AstroJS Components in JSX\nDESCRIPTION: This snippet imports CardGrid and LinkCard components from the AstroJS Starlight library to create a grid of clickable links directing users to various sections of the Paper server documentation. It visually organizes the links for administration, development, and contribution resources.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/index.mdx#_snippet_0\n\nLANGUAGE: JSX\nCODE:\n```\n<CardGrid>\n  <LinkCard\n    title=\"Administration\"\n    description=\"Information and tutorials regarding the administration of a Paper server.\"\n    href=\"/paper/admin\"\n  />\n  <LinkCard\n    title=\"Development\"\n    description=\"Information and tutorials for developers on how to create and expand on Paper plugins.\"\n    href=\"/paper/dev\"\n  />\n  <LinkCard\n    title=\"Contributing\"\n    description=\"Information and tutorials for developers wishing to contribute to the Paper project.\"\n    href=\"/paper/contributing\"\n  />\n</CardGrid>\n```\n\n----------------------------------------\n\nTITLE: Creating an Integer Range Predicate Argument with PaperMC Command API (Java)\nDESCRIPTION: This code defines a command 'integerrange' for the PaperMC API that accepts an integer range argument, then a tested integer, and executes a provided method to check if the tested integer falls within the range. The logic sends feedback to the command sender using formatted rich messages. Dependencies include PaperMC Command API, integer range providers, and Placeholder API. Expected inputs are properly registered integer range and tested integer arguments; outputs are confirmations if the integer is within the given range. The example demonstrates both registration and command execution method.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/predicate.mdx#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> integerRangeArgument() {\n    return Commands.literal(\"integerrange\")\n        .then(Commands.argument(\"range\", ArgumentTypes.integerRange())\n            .then(Commands.argument(\"tested_integer\", IntegerArgumentType.integer())\n                .executes(MinecraftArguments::runIntegerRangeCommand)))\n        .build();\n}\n\nprivate static int runIntegerRangeCommand(final CommandContext<CommandSourceStack> ctx) {\n    final IntegerRangeProvider integerRangeProvider = ctx.getArgument(\"range\", IntegerRangeProvider.class);\n    final int integerToTest = IntegerArgumentType.getInteger(ctx, \"tested_integer\");\n\n    if (integerRangeProvider.range().contains(integerToTest)) {\n        ctx.getSource().getSender().sendRichMessage(\"<aqua><input></aqua> <green>is</green> inside the specified range!\",\n            Placeholder.unparsed(\"input\", Integer.toString(integerToTest))\n        );\n        return Command.SINGLE_SUCCESS;\n    }\n\n    ctx.getSource().getSender().sendRichMessage(\"<aqua><input></aqua> <red>is not</red> inside the specified range!\",\n        Placeholder.unparsed(\"input\", Integer.toString(integerToTest))\n    );\n\n    return Command.SINGLE_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing a Velocity Plugin\nDESCRIPTION: This code snippet shows the basic structure of a Velocity plugin, using the `@Plugin` annotation to define the plugin's ID, name, and version. It serves as the foundation for adding plugin dependencies.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/how-to/dependencies.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n@Plugin(\n  id = \"myfirstplugin\",\n  name = \"My Plugin\",\n  version = \"0.1.0\"\n)\npublic class VelocityTest {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Written Book in Java\nDESCRIPTION: Demonstrates creating a written book with pages, filtered content, and generation settings using the data component API.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/data-component-api.md#_snippet_7\n\nLANGUAGE: java\nCODE:\n```\nItemStack book = ItemStack.of(Material.WRITTEN_BOOK);\nWrittenBookContent.Builder builder = WrittenBookContent.writtenBookContent(\"My Book\", \"AuthorName\");\n\n// Add a page\nbuilder.addPage(Component.text(\"This is a new page!\"));\n\n// Add a page that shows differently for people who have swear filtering on\n// Players who have disabled filtering, will see \"I hate Paper!\", while those with filtering on will see the \"I love Paper!\".\nbuilder.addFilteredPage(\n    Filtered.of(Component.text(\"I hate Paper!\"), Component.text(\"I love Paper!\"))\n);\n\n// Change generation\nbuilder.generation(1);\n\n// Apply changes\nbook.setData(DataComponentTypes.WRITTEN_BOOK_CONTENT, builder.build());\n```\n\n----------------------------------------\n\nTITLE: Implementing Named Color Argument in Paper Command API\nDESCRIPTION: Demonstrates creating a command that uses the named color argument to select from 16 built-in text colors. The example shows applying the selected NamedTextColor to a text component to send colored messages.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/adventure.mdx#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> namedColorArgument() {\n    return Commands.literal(\"namedcolor\")\n        .then(Commands.argument(\"color\", ArgumentTypes.namedColor())\n            .then(Commands.argument(\"message\", StringArgumentType.greedyString())\n                .executes(ctx -> {\n                    final NamedTextColor color = ctx.getArgument(\"color\", NamedTextColor.class);\n                    final String msg = StringArgumentType.getString(ctx, \"message\");\n\n                    ctx.getSource().getSender().sendMessage(\n                        Component.text(msg).color(color)\n                    );\n                    return Command.SINGLE_SUCCESS;\n                })))\n        .build();\n}\n```\n\n----------------------------------------\n\nTITLE: Firing a custom event in Velocity\nDESCRIPTION: Shows how to fire a custom event using the EventManager and handle the CompletableFuture result. The example demonstrates firing a PrivateMessageEvent and handling post-event logic.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/event.md#_snippet_9\n\nLANGUAGE: java\nCODE:\n```\nserver.getEventManager().fire(new PrivateMessageEvent(sender, recipient, message)).thenAccept((event) -> {\n  // event has finished firing\n  // do some logic dependent on the result\n});\n```\n\n----------------------------------------\n\nTITLE: Using PageCards Component in Astro\nDESCRIPTION: This snippet demonstrates the usage of the imported 'PageCards' component within the Astro template. It renders the component, which presumably handles the display logic for page cards.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/entity-api/index.mdx#_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<PageCards />\n```\n\n----------------------------------------\n\nTITLE: Setting Spigot Mappings in Gradle Kotlin DSL\nDESCRIPTION: Configures the Gradle build script to explicitly mark the plugin as Spigot-mapped by adding the 'paperweight-mappings-namespace' attribute with value 'spigot' to the JAR manifest. This instructs the Paper server to handle the plugin as Spigot-mapped requiring remapping on load. Includes similar configuration for shadowJar tasks if present. Requires a Gradle build environment with Kotlin DSL.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/project-setup.mdx#_snippet_6\n\nLANGUAGE: kotlin\nCODE:\n```\ntasks.jar {\n  manifest {\n    attributes[\"paperweight-mappings-namespace\"] = \"spigot\"\n  }\n}\n// if you have shadowJar configured\ntasks.shadowJar {\n  manifest {\n    attributes[\"paperweight-mappings-namespace\"] = \"spigot\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Functional asynchronous event handling in Velocity\nDESCRIPTION: Example of using AwaitingEventExecutor for functional-style asynchronous event handling. This allows for async processing with lambda expressions instead of dedicated listener classes.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/event.md#_snippet_7\n\nLANGUAGE: java\nCODE:\n```\nserver.getEventManager().register(this, PlayerChatEvent.class, (AwaitingEventExecutor) event -> {\n  if (mustFurtherProcess(event)) {\n    return EventTask.async(() => ...);\n  }\n  return null;\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Complete Broadcast Command - Java\nDESCRIPTION: Presents the full Java source code for the `BroadcastCommand` class, implementing the `BasicCommand` interface. This includes the complete logic for handling command execution (getting sender, processing arguments, broadcasting) and defining the required permission.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/misc/basic-command.md#_snippet_5\n\nLANGUAGE: Java\nCODE:\n```\npackage your.package.name;\n\nimport io.papermc.paper.command.brigadier.BasicCommand;\nimport io.papermc.paper.command.brigadier.CommandSourceStack;\nimport net.kyori.adventure.text.Component;\nimport net.kyori.adventure.text.minimessage.MiniMessage;\nimport net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;\nimport org.bukkit.Bukkit;\nimport org.jspecify.annotations.NullMarked;\nimport org.jspecify.annotations.Nullable;\n\n@NullMarked\npublic class BroadcastCommand implements BasicCommand {\n\n    @Override\n    public void execute(CommandSourceStack commandSourceStack, String[] args) {\n        final Component name = commandSourceStack.getExecutor() != null\n            ? commandSourceStack.getExecutor().name()\n            : commandSourceStack.getSender().name();\n\n        if (args.length == 0) {\n            commandSourceStack.getSender().sendRichMessage(\"<red>You cannot send an empty broadcast!\");\n            return;\n        }\n\n        final String message = String.join(\" \", args);\n        final Component broadcastMessage = MiniMessage.miniMessage().deserialize(\n            \"<red><bold>BROADCAST</red> <name> <dark_gray>»</dark_gray> <message>\",\n            Placeholder.component(\"name\", name),\n            Placeholder.unparsed(\"message\", message)\n        );\n\n        Bukkit.broadcast(broadcastMessage);\n    }\n\n    @Override\n    public @Nullable String permission() {\n        return \"example.broadcast.use\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Paper Server JAR (Bash)\nDESCRIPTION: This command executes the Paper server JAR using Java. It allocates minimum (-Xms) and maximum (-Xmx) heap memory, specifies the executable JAR file, and disables the default server GUI (--nogui). Requires Java installed and the server JAR in the current directory.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/getting-started/getting-started.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\njava -Xms4G -Xmx4G -jar paper.jar --nogui\n```\n\n----------------------------------------\n\nTITLE: Implementing PageCards Component in Astro Markdown\nDESCRIPTION: This snippet shows how to use the imported PageCards component to render navigation cards for the getting started guides on the page.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/getting-started/index.mdx#_snippet_1\n\nLANGUAGE: astro\nCODE:\n```\n<PageCards />\n```\n\n----------------------------------------\n\nTITLE: Registering a Configured Lifecycle Event Handler\nDESCRIPTION: This snippet demonstrates how to register a fully configured lifecycle event handler with the lifecycle manager.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/lifecycle.md#_snippet_4\n\nLANGUAGE: java\nCODE:\n```\n@Override\npublic void onEnable() {\n    final LifecycleEventManager<Plugin> lifecycleManager = this.getLifecycleManager();\n    PrioritizedLifecycleEventHandlerConfiguration<LifecycleEventOwner> config = LifecycleEvents.SOME_EVENT.newHandler((event) -> {\n        // Handler for the event\n    }).priority(10);\n    lifecycleManager.registerEventHandler(config);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Anti-Xray with engine-mode 1 in paper-world-defaults.yml (Overworld)\nDESCRIPTION: This snippet configures Anti-Xray with engine-mode 1 in the default world configuration. It enables Anti-Xray, sets the engine mode to 1, defines a list of hidden blocks, disables lava obscuring, sets the maximum block height, defines an empty replacement blocks list, sets the update radius, and disables permission usage. This configuration is used for the overworld.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/anti-xray.mdx#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nanticheat:\n  anti-xray:\n    enabled: true\n    engine-mode: 1\n    hidden-blocks:\n    # There's no chance to hide dungeon chests as they are entirely surrounded by air, but buried treasures will be hidden.\n    - chest\n    - coal_ore\n    - deepslate_coal_ore\n    - copper_ore\n    - deepslate_copper_ore\n    - raw_copper_block\n    - diamond_ore\n    - deepslate_diamond_ore\n    - emerald_ore\n    - deepslate_emerald_ore\n    - gold_ore\n    - deepslate_gold_ore\n    - iron_ore\n    - deepslate_iron_ore\n    - raw_iron_block\n    - lapis_ore\n    - deepslate_lapis_ore\n    - redstone_ore\n    - deepslate_redstone_ore\n    lava-obscures: false\n    # As of 1.18 some ores are generated much higher.\n    # Please adjust the max-block-height setting at your own discretion.\n    # https://minecraft.wiki/w/Ore might be helpful.\n    max-block-height: 64\n    # The replacement-blocks list is not used in engine-mode: 1. Changing this will have no effect.\n    replacement-blocks: []\n    update-radius: 2\n    use-permission: false\n```\n\n----------------------------------------\n\nTITLE: Defining Template Mirror Argument in PaperMC Command API (Java)\nDESCRIPTION: Shows how to create a command that takes a Mirror enum argument, supporting inputs 'front_back', 'left_right', or 'none'. Outputs to the command sender the user's selection. Utilizes org.bukkit.block.structure.Mirror and requires correct argument parsing setup. Suitable for plugin commands involving structure mirroring options.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/enums.mdx#_snippet_4\n\nLANGUAGE: Java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> templateMirrorArgument() {\n    return Commands.literal(\"templatemirror\")\n        .then(Commands.argument(\"mirror\", ArgumentTypes.templateMirror())\n            .executes(ctx -> {\n                final Mirror mirror = ctx.getArgument(\"mirror\", Mirror.class);\n\n                ctx.getSource().getSender().sendPlainMessage(\"You selected: \" + mirror.name());\n\n                return Command.SINGLE_SUCCESS;\n            })\n        ).build();\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Brigadier Argument Value Using Type Parser - Java\nDESCRIPTION: This Java snippet shows how to retrieve the value of a 'speed' float argument in a command context using FloatArgumentType.getFloat. It requires Brigadier and a valid CommandContext with the 'speed' argument present. The method parses and returns the float value of the argument named 'speed'.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/arguments-and-literals.md#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\nfloat speed = FloatArgumentType.getFloat(ctx, \"speed\");\n```\n\n----------------------------------------\n\nTITLE: Running Waterfall with Default Memory - bash\nDESCRIPTION: This command executes the Waterfall proxy JAR using Java with basic memory configuration. It sets both the initial (`-Xms`) and maximum (`-Xmx`) heap size to 512MB. This is a standard way to start a Java application from the terminal.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/waterfall/getting-started.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\njava -Xms512M -Xmx512M -jar waterfall-###.jar\n```\n\n----------------------------------------\n\nTITLE: Importing PageCards Component in Astro\nDESCRIPTION: This snippet demonstrates importing a React or Astro component named PageCards from the specified path. It is typically used within an Astro page or component to include interactive or informational UI elements related to API documentation.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/index.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport PageCards from \"/src/components/PageCards.astro\";\n```\n\n----------------------------------------\n\nTITLE: Creating a self-cancelling scheduled task with Velocity Scheduler API in Java\nDESCRIPTION: This example demonstrates how to implement a task that cancels itself after a certain number of executions using an AtomicInteger counter. It employs a Consumer<ScheduledTask> to access the task within its execution context.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/scheduler.md#_snippet_4\n\nLANGUAGE: Java\nCODE:\n```\nAtomicInteger integer = new AtomicInteger(0);\n\nScheduledTask task = server.getScheduler()\n  .buildTask(plugin, (selfTask) -> {\n    // do stuff here, for example...\n    if (integer.addAndGet(1) > 10) {\n      selfTask.cancel();\n    }\n  })\n  .repeat(Duration.ofSeconds(4L))\n  .schedule();\n```\n\n----------------------------------------\n\nTITLE: Demonstrating SQL Injection Vulnerability in Java\nDESCRIPTION: This Java snippet provides an example of vulnerable code that concatenates user input directly into an SQL query string, leading to SQL injection risks. The method constructs a SQL SELECT statement using raw username and password inputs without sanitization or prepared statements, making it susceptible to malicious input that can manipulate or bypass authentication. The snippet highlights the security flaw rather than a proper implementation.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/misc/databases.md#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npublic void login(String username, String password) {\n    String sql = \"SELECT * FROM users WHERE username = '\" + username + \"' AND password = '\" + password + \"'\";\n    // Execute SQL\n}\n```\n\n----------------------------------------\n\nTITLE: End World Anti-Xray Disabled Configuration\nDESCRIPTION: This YAML configuration disables Anti-Xray in the 'paper-world.yml' for the end dimension, effectively turning off ore hiding protections in the end world to allow normal visibility. It should be placed within the end world folder's configuration files.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/anti-xray.mdx#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\nanticheat:\n  anti-xray:\n    enabled: false\n```\n\n----------------------------------------\n\nTITLE: Registering a Brigadier Command with Paper Plugin Lifecycle Events in Java\nDESCRIPTION: Uses the plugin's LifecycleEventManager to register a Brigadier command so it remains active across server reloads. Invokes createCommand to build the command node and registers it with relevant metadata like a description. This approach requires Paper's LifecycleEvents framework and assumes the plugin's command creation method follows the Brigadier pattern. Inputs include the plugin context and command node. Output is a registered Brigadier command node available for users.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/misc/comparison-bukkit-brigadier.md#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\nthis.getLifecycleManager().registerEventHandler(LifecycleEvents.COMMANDS, commands -> {\n    commands.registrar().register(PaperPartyCommand.createCommand(\"paperparty\"), \"Have a nice party\");\n});\n\n```\n\n----------------------------------------\n\nTITLE: Using Custom Argument in Command Tree\nDESCRIPTION: This Java snippet demonstrates how to use the `OppedPlayerArgument` defined in the previous example. The code shows how to declare the custom argument within the command tree and retrieve the player object. Requires the `OppedPlayerArgument` class, PaperMC's command API, and Brigadier.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/custom-arguments.md#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nCommands.argument(\"player\", new OppedPlayerArgument())\n    .executes(ctx -> {\n        final Player player = ctx.getArgument(\"player\", Player.class);\n\n        ctx.getSource().getSender().sendRichMessage(\"Player <player> is an operator!\",\n            Placeholder.component(\"player\", player.displayName())\n        );\n        return Command.SINGLE_SUCCESS;\n    })\n```\n\n----------------------------------------\n\nTITLE: Diagnosing Circular Plugin Loading Error (Server Log)\nDESCRIPTION: This server log output indicates a circular dependency issue between installed plugins, where plugins require each other to load first, creating an impossible loop. The message identifies the problematic plugins and suggests reporting the issue to the plugin authors or using a legacy loading flag as a temporary workaround.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/basic-troubleshooting.md#_snippet_2\n\nLANGUAGE: Log\nCODE:\n```\n[15:01:04] [Server thread/ERROR]: [SimpleProviderStorage] Circular plugin loading detected!\n[15:01:04] [Server thread/ERROR]: [SimpleProviderStorage] Circular load order:\n[15:01:04] [Server thread/ERROR]: [SimpleProviderStorage]   Plugin1 -> Plugin2 -> Plugin3 -> Plugin4 -> Plugin1\n[15:01:04] [Server thread/ERROR]: [SimpleProviderStorage] Please report this to the plugin authors of the first plugin of each loop or join the PaperMC Discord server for further help.\n[15:01:04] [Server thread/ERROR]: [SimpleProviderStorage] If you would like to still load these plugins, acknowledging that there may be unexpected plugin loading issues, run the server with -Dpaper.useLegacyPluginLoading=true\n```\n\n----------------------------------------\n\nTITLE: Disabling Anti-Xray in paper-world.yml (End)\nDESCRIPTION: This snippet disables Anti-Xray in the End dimension's `paper-world.yml` configuration file.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/anti-xray.mdx#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nanticheat:\n  anti-xray:\n    enabled: false\n```\n\n----------------------------------------\n\nTITLE: Configuring GC Logging for Java 11+ (JVM Flags)\nDESCRIPTION: This single JVM flag utilizes the unified logging framework introduced in Java 9 to enable comprehensive garbage collection logging for Java versions 11 and later. It specifies the log file path (logs/gc.log), includes relevant details like time and uptime in the log entries, and configures log file rotation. The log file count and size parameters ensure that logging remains manageable, providing valuable data for diagnosing GC issues with minimal performance impact.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/aikars-flags.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n-Xlog:gc*:logs/gc.log:time,uptime:filecount=5,filesize=1M\n```\n\n----------------------------------------\n\nTITLE: Parsing and Rendering Minecraft Server Banned IPs JSON Data Using Astro and YAML in JavaScript\nDESCRIPTION: This snippet loads a banned IPs list stored in a YAML file representing JSON data, parses it with the YAML parser, and passes it to the ConfigNode component for display as JSON. It emphasizes that banned-ips.json is a server-managed data file (not recommended to edit directly) and is managed via server commands. The snippet depends on the YAML parser for format conversion and Astro's ConfigNode for rendering the data structure in a JSON context. Input is raw YAML data mirroring banned IPs JSON, and output is the structured display of this data file's contents.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/reference/configuration/vanilla-data-files.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport ConfigNode from \"/src/components/ConfigNode.astro\";\nimport { parse } from \"yaml\";\nimport BannedIpsYML from \"/src/config/paper/banned-ips-single.yml?raw\";\n\n<ConfigNode data={parse(BannedIpsYML)} lang=\"json\" path={[\"banned_ips\"]} />\n```\n\n----------------------------------------\n\nTITLE: Rendering Interactive Server Properties Configuration Component\nDESCRIPTION: Renders the ConfigNode component that displays server.properties configuration options as interactive elements. It parses the YAML data and passes it to the component with properties language set to 'properties'.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/reference/configuration/server-properties.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<ConfigNode data={parse(ServerPropertiesYML)} lang=\"properties\" />\n```\n\n----------------------------------------\n\nTITLE: Adding velocity-api Dependency: Gradle Groovy DSL\nDESCRIPTION: This snippet configures the `velocity-api` dependency within a Gradle project using the Groovy DSL.  It adds `compileOnly` and `annotationProcessor` configurations for the dependency.  `compileOnly` ensures the dependency is available during compilation, while `annotationProcessor` enables annotation processing features. The version uses a placeholder for the latest release.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/getting-started/creating-your-first-plugin.mdx#_snippet_5\n\nLANGUAGE: groovy\nCODE:\n```\n    dependencies {\n      compileOnly 'com.velocitypowered:velocity-api:\\\\{LATEST_VELOCITY_RELEASE}'\n      annotationProcessor 'com.velocitypowered:velocity-api:\\\\{LATEST_VELOCITY_RELEASE}'\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Dynamically Registering Bukkit Commands With Plugin Class in Java\nDESCRIPTION: Registers a BukkitPartyCommand directly to the server's CommandMap from the plugin's main class. Assumes access to this.getServer().getCommandMap(), and requires a constructed BukkitPartyCommand instance specifying command name, description, usage, and aliases. Command registration should occur during plugin initialization with the correct Bukkit/Spigot API. Input is the server and plugin reference, and output is a registered command accessible by users.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/misc/comparison-bukkit-brigadier.md#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\nthis.getServer().getCommandMap().register(\n    this.getName().toLowerCase(),\n    new BukkitPartyCommand(\"bukkitparty\", \"Have a party\", \"/bukkitparty <player>\", List.of())\n);\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a custom PersistentDataType for UUID (Java)\nDESCRIPTION: Provides an example implementation of a custom PersistentDataType for UUID objects, converting them to and from byte arrays for storage in the PDC. This enables storing complex data types not natively supported by the API.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/pdc.md#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\npublic class UUIDDataType implements PersistentDataType<byte[], UUID> {\n    @Override\n    public Class<byte[]> getPrimitiveType() {\n        return byte[].class;\n    }\n\n    @Override\n    public Class<UUID> getComplexType() {\n        return UUID.class;\n    }\n\n    @Override\n    public byte[] toPrimitive(UUID complex, PersistentDataAdapterContext context) {\n        ByteBuffer bb = ByteBuffer.allocate(Long.BYTES * 2);\n        bb.putLong(complex.getMostSignificantBits());\n        bb.putLong(complex.getLeastSignificantBits());\n        return bb.array();\n    }\n\n    @Override\n    public UUID fromPrimitive(byte[] primitive, PersistentDataAdapterContext context) {\n        ByteBuffer bb = ByteBuffer.wrap(primitive);\n        long firstLong = bb.getLong();\n        long secondLong = bb.getLong();\n        return new UUID(firstLong, secondLong);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Resource Argument for Item Retrieval\nDESCRIPTION: This Java code shows how to use the `resource` argument to retrieve an item from the registry. It adds the item to the player's inventory upon successful retrieval.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/registry.mdx#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nCommands.argument(\"item\", ArgumentTypes.resource(RegistryKey.ITEM))\n    .executes(ctx -> {\n        final ItemType item = ctx.getArgument(\"item\", ItemType.class);\n\n        if (ctx.getSource().getExecutor() instanceof Player player) {\n            player.getInventory().addItem(item.createItemStack());\n        }\n\n        return Command.SINGLE_SUCCESS;\n    });\n```\n\n----------------------------------------\n\nTITLE: Importing and Rendering PageCards in Astro Markdown\nDESCRIPTION: This snippet demonstrates how to import a custom PageCards component within an Astro Markdown file and render it on the page. The import uses Astro's component syntax, and requires that the PageCards component exists at the specified source path. No props or parameters are passed, so the component must be self-contained or use internal state. The file assumes the Astro build system is in use and that integration between Markdown and Astro components is properly configured.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/misc/index.mdx#_snippet_0\n\nLANGUAGE: Astro\nCODE:\n```\nimport PageCards from \"/src/components/PageCards.astro\";\n\n<PageCards />\n```\n\n----------------------------------------\n\nTITLE: Using Event#callEvent Return Value for Cancellation in Paper Plugin (Java)\nDESCRIPTION: This snippet leverages the return value of Event#callEvent() (false if cancelled) in the if-statement. This pattern simplifies checking for cancellation in event-handling logic. Dependencies: org.bukkit.plugin.java.JavaPlugin, PaperIsCoolEvent, org.bukkit.Bukkit, Component. Inputs: event instance; Outputs: broadcast execution only if the event was not cancelled.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/event-api/custom-events.md#_snippet_5\n\nLANGUAGE: Java\nCODE:\n```\npublic class ExamplePlugin extends JavaPlugin {\n\n    // ...\n\n    public void callCoolPaperEvent() {\n        PaperIsCoolEvent coolEvent = new PaperIsCoolEvent(Component.text(\"Paper is cool!\"));\n        if (coolEvent.callEvent()) { // Directly get the output from callEvent\n            Bukkit.broadcast(coolEvent.getMessage());\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Spigot Mappings for Production (Kotlin DSL)\nDESCRIPTION: This code snippet configures the paperweight plugin to compile the plugin using Spigot mappings. This is useful for plugins that need to be compatible with both Spigot and Paper servers. It adds the `REOBF_PRODUCTION` configuration.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/userdev.md#_snippet_5\n\nLANGUAGE: kotlin\nCODE:\n```\npaperweight.reobfArtifactConfiguration = io.papermc.paperweight.userdev.ReobfArtifactConfiguration.REOBF_PRODUCTION\n```\n\n----------------------------------------\n\nTITLE: Restoring Gravity Block Duplication via End Portals in Paper - YAML\nDESCRIPTION: This YAML snippet provides a configuration option to restore the duplication of gravity-affected blocks like sand when teleported through end portals by setting 'allow-unsafe-end-portal-teleportation' to true. While this replicates a known Vanilla duplication exploit, it is not recommended due to potential server instability and unexpected behavior.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/misc/paper-bug-fixes.md#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nunsupported-settings:\n  allow-unsafe-end-portal-teleportation: true\n```\n\n----------------------------------------\n\nTITLE: Storing and Retrieving User Input Keys with TypedKey for Resource Management\nDESCRIPTION: This snippet explains how to store the user-selected resource key using TypedKey#key(), facilitating retrieval of the exact resource instance later. This pattern enables tracking user input without losing reference, making it easier to access game resources based on specific user selections or inputs. Dependencies involve the TypedKey class in the API, used for key management and storage.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/registry.mdx#_snippet_4\n\nLANGUAGE: Java\nCODE:\n```\nResourceKey<?> userInputKey = TypedKey#key();\n// Store the key for later use\n// Retrieve the resource by querying the registry with this key\n```\n\n----------------------------------------\n\nTITLE: Allowing Bedrock and End Portal Frame Breaking Exploits in Paper - YAML\nDESCRIPTION: This YAML snippet allows breaking of Bedrock and End Portal frames, normally fixed by Paper, by enabling 'allow-permanent-block-break-exploits' under 'unsupported-settings'. This override is discouraged as it re-enables exploits that can negatively affect server integrity and gameplay. Enabling this may cause unsupported side effects and is not guaranteed to be stable across future updates.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/misc/paper-bug-fixes.md#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nunsupported-settings:\n  allow-permanent-block-break-exploits: true\n```\n\n----------------------------------------\n\nTITLE: Adding Dev Bundle Dependency (Kotlin DSL)\nDESCRIPTION: This code snippet demonstrates how to add the Paper dev bundle dependency to your Gradle build file using the Kotlin DSL. It allows accessing Paper's API during development. The version should be replaced with the latest available version. This replaces the need to depend directly on the Paper API.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/userdev.md#_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\ndependencies {\n  // Other Dependencies\n  paperweight.paperDevBundle(\"\\{LATEST_PAPER_RELEASE}-R0.1-SNAPSHOT\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using `replace` meta property to replace constants in code blocks\nDESCRIPTION: This snippet demonstrates the use of the `replace` meta property within Markdown code blocks to automatically replace constants.  This allows for dynamically updating values within code examples.\nSOURCE: https://github.com/papermc/docs/blob/main/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n```yaml replace\nname: Paper-Test-Plugin\nversion: \"1.0\"\nmain: io.papermc.testplugin.TestPlugin\ndescription: Paper Test Plugin\napi-version: '\\{LATEST_PAPER_RELEASE}'\nbootstrapper: io.papermc.testplugin.TestPluginBootstrap\nloader: io.papermc.testplugin.TestPluginLoader\n```\n```\n\n----------------------------------------\n\nTITLE: Example Dependency Configurations in `paper-plugin.yml`\nDESCRIPTION: Provides practical examples of dependency declarations for common scenarios: ensuring a required dependency (ProtocolLib) loads before the plugin, loading the plugin before an optional dependency (SuperShopsXUnlimited), and enabling access to another plugin's classpath (SuperDuperTacoParty).\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/paper-plugins.md#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n# Suppose we require ProtocolLib to be loaded for our plugin\nProtocolLib:\n  load: BEFORE\n  required: true\n\n# Now, we are going to register some details for a shop plugin\n# So the shop plugin should load after our plugin\nSuperShopsXUnlimited:\n  load: AFTER\n  required: false\n\n# Now, we are going to need to access a plugins classpath\n# So that we can properly interact with it.\nSuperDuperTacoParty:\n  required: true\n  join-classpath: true\n```\n\n----------------------------------------\n\nTITLE: Creating a Lifecycle Event Handler\nDESCRIPTION: This snippet demonstrates how to create an event handler for a lifecycle event by using the LifecycleEvents class to select an event type.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/lifecycle.md#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\n@Override\npublic void onEnable() {\n    final LifecycleEventManager<Plugin> lifecycleManager = this.getLifecycleManager();\n    PrioritizedLifecycleEventHandlerConfiguration<LifecycleEventOwner> config = LifecycleEvents.SOME_EVENT.newHandler((event) -> {\n        // Handler for the event\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing user input filtering for command suggestions in Minecraft/Java\nDESCRIPTION: Implementation of a name selection command that filters suggestions based on what the user has already typed. It takes a list of names and only suggests those that start with the user's current input, making the suggestion experience more intuitive.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/argument-suggestions.mdx#_snippet_5\n\nLANGUAGE: java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> constructStringSuggestionsCommand() {\n    final List<String> names = List.of(\"Alex\", \"Andreas\", \"Stephanie\", \"Sophie\", \"Emily\");\n\n    return Commands.literal(\"selectname\")\n        .then(Commands.argument(\"name\", StringArgumentType.word())\n\n            .suggests((ctx, builder) -> {\n                names.stream()\n                    .filter(entry -> entry.toLowerCase().startsWith(builder.getRemainingLowerCase()))\n                    .forEach(builder::suggest);\n                return builder.buildFuture();\n            })\n\n        ).build();\n}\n```\n\n----------------------------------------\n\nTITLE: Manually Updating Player Commands (Java)\nDESCRIPTION: This code defines a command `reloadcommands` that allows players to manually trigger a command update. When executed by a player, it calls `player.updateCommands()`, which resends the command graph to the client, potentially resolving synchronization issues caused by dynamic requirements changing after the initial connection.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/requirements.md#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nCommands.literal(\"reloadcommands\")\n    .executes(ctx -> {\n        if (ctx.getSource().getExecutor() instanceof Player player) {\n            player.updateCommands();\n            player.sendRichMessage(\"<gold>Successfully updated your commands!\");\n        }\n\n        return Command.SINGLE_SUCCESS;\n    });\n```\n\n----------------------------------------\n\nTITLE: Defining the Command FunctionalInterface for Brigadier (Java)\nDESCRIPTION: This snippet declares the Command<S> interface, designed as a functional interface for defining command logic in Brigadier. It specifies the SINGLE_SUCCESS constant and a run method that receives a CommandContext<S> and returns an int status code. Dependencies include Brigadier's CommandContext and CommandSyntaxException classes. The run method's input is a context object carrying arguments and execution metadata; output is an integer status, typically SINGLE_SUCCESS (1) or other status codes.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/executors.md#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\n@FunctionalInterface\npublic interface Command<S> {\n    int SINGLE_SUCCESS = 1;\n\n    int run(CommandContext<S> ctx) throws CommandSyntaxException;\n}\n```\n\n----------------------------------------\n\nTITLE: Using ResourceKey Argument for Item Retrieval with Null Check\nDESCRIPTION: This Java code provides an example of retrieving an item using the `resourceKey` argument. It retrieves the TypedKey, uses it to access the registry, and includes a null check for safety to handle cases where an invalid item is provided.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/registry.mdx#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nCommands.argument(\"item\", ArgumentTypes.resourceKey(RegistryKey.ITEM))\n    .executes(ctx -> {\n        final TypedKey<ItemType> itemKey = RegistryArgumentExtractor.getTypedKey(ctx, RegistryKey.ITEM, \"item\");\n        ItemType item = RegistryAccess.registryAccess().getRegistry(itemKey.registryKey()).get(itemKey.key());\n\n        if (item == null) {\n            ctx.getSource().getSender().sendRichMessage(\"<red>Please provide a valid item!\");\n            return Command.SINGLE_SUCCESS;\n        }\n\n        if (ctx.getSource().getExecutor() instanceof Player player) {\n            player.getInventory().addItem(item.createItemStack());\n        }\n\n        return Command.SINGLE_SUCCESS;\n    })\n```\n\n----------------------------------------\n\nTITLE: Handling Incoming Plugin Message from Player in Velocity\nDESCRIPTION: Processes plugin messages received from players, ensuring messages with matching identifiers are handled exclusively, preventing forwarding. Sets the message as handled or forwarded based on the logic, and extracts packet data for further processing.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/plugin-messaging.md#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\npublic void onPluginMessageFromPlayer(PluginMessageEvent event) {\n    if (!IDENTIFIER.equals(event.getIdentifier())) {\n        return;\n    }\n    event.setResult(PluginMessageEvent.ForwardResult.handled());\n    if (!(event.getSource() instanceof Player player)) {\n        return;\n    }\n    ByteArrayDataInput in = ByteStreams.newDataInput(event.getData());\n    // handle packet data\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring GC Logging for Java 8-10 (JVM Flags)\nDESCRIPTION: These JVM flags are used to enable detailed garbage collection logging specifically for Java versions 8 through 10. They configure the log file path (-Xloggc), verbosity levels (-verbose:gc, +PrintGCDetails), and include timestamps (+PrintGCDateStamps, +PrintGCTimeStamps). Additionally, they set up log file rotation (+UseGCLogFileRotation) with a specified number of files and maximum size per file, which is useful for monitoring GC behavior over time without consuming excessive disk space.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/aikars-flags.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n-Xloggc:gc.log -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps\n-XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=1M\n```\n\n----------------------------------------\n\nTITLE: Demonstrating .then() Method Return Behavior in Java\nDESCRIPTION: Validates that the .then() method returns the current node object, which allows chaining calls without losing context. Shows that the return value is the same as the caller node, enabling fluent interface style command building. Input is two LiteralArgumentBuilder objects; output is a boolean comparison, used here for logging confirmation.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/command-tree.mdx#_snippet_5\n\nLANGUAGE: java\nCODE:\n```\nLiteralArgumentBuilder<CommandSourceStack> value = killall.then(entities);\nif (value == killall) {\n    logger.info(\"The return value is the same as killall\");\n}\n```\n\n----------------------------------------\n\nTITLE: Registry Keys Listing for Various Minecraft Elements\nDESCRIPTION: This section provides an overview of existing registry keys for game elements such as attributes, biomes, blocks, entities, items, effects, and visual resources. Each registry key is associated with its return value type and a preview video link demonstrating its content. This listing helps developers understand available registries and how to access the resource types programmatically.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/registry.mdx#_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: Adding Paperweight Snapshot Repository (Kotlin DSL)\nDESCRIPTION: This code snippet shows how to add Paper's Maven repository to your Gradle settings file to access SNAPSHOT (pre-release) versions of the paperweight-userdev plugin. It configures the pluginManagement block to include the PaperMC Maven repository.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/userdev.md#_snippet_1\n\nLANGUAGE: kotlin\nCODE:\n```\npluginManagement {\n  repositories {\n    gradlePluginPortal()\n    maven(\"https://repo.papermc.io/repository/maven-public/\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Linking to Javadocs using Markdown link shortcut\nDESCRIPTION: This snippet demonstrates how to create links to Javadocs using a custom Markdown link shortcut. This shortcut allows for easy linking to Javadocs for different projects (Paper, Velocity, Java) and specific classes or members.\nSOURCE: https://github.com/papermc/docs/blob/main/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n[my `Event` link](jd:paper:org.bukkit.event.Event)\n[`ProxyInitializeEvent`](jd:velocity:com.velocitypowered.api.event.proxy.ProxyInitializeEvent)\n[`repeat(long, TimeUnit)`](jd:velocity:com.velocitypowered.api.scheduler.Scheduler$TaskBuilder#repeat(long,java.util.concurrent.TimeUnit))\n[java.base's List](jd:java:java.util.List)\n[java.sql's Connection](jd:java:java.sql:java.sql.Connection)\n```\n\n----------------------------------------\n\nTITLE: Sample Velocity Console Output After Launch\nDESCRIPTION: Example log output showing what to expect when Velocity starts successfully, including version information and listening port.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/admin/getting-started/getting-started.md#_snippet_2\n\nLANGUAGE: log\nCODE:\n```\n[05:41:13 INFO]: Booting up Velocity \\{LATEST_VELOCITY_RELEASE} (git-74c932e5-b363)...\n[05:41:13 INFO]: Loading localizations...\n[05:41:13 INFO]: Connections will use epoll channels, libdeflate (Linux aarch64) compression, OpenSSL (Linux aarch64) ciphers\n[05:41:13 INFO]: Loading plugins...\n[05:41:13 INFO]: Loaded 0 plugins\n[05:41:13 INFO]: Listening on /[0:0:0:0:0:0:0:0%0]:25565\n[05:41:13 INFO]: Done (0.36s)!\n```\n\n----------------------------------------\n\nTITLE: Setting Mojang Mappings in Gradle Kotlin DSL\nDESCRIPTION: Configures the Gradle build script to specify that the plugin is Mojang-mapped by adding the 'paperweight-mappings-namespace' attribute with value 'mojang' to the JAR manifest. This ensures the server treats the plugin with Mojang mappings, which Paper assumes by default. It also includes configuration for shadowJar tasks if applicable. Requires a Gradle project and the Kotlin DSL syntax.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/project-setup.mdx#_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\ntasks.jar {\n  manifest {\n    attributes[\"paperweight-mappings-namespace\"] = \"mojang\"\n  }\n}\n// if you have shadowJar configured\ntasks.shadowJar {\n  manifest {\n    attributes[\"paperweight-mappings-namespace\"] = \"mojang\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Single Dependency Entry in `paper-plugin.yml`\nDESCRIPTION: Illustrates the configuration structure for a single dependency entry within the `dependencies` section of `paper-plugin.yml`. It details the optional `load`, `required`, and `join-classpath` attributes and their default values.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/paper-plugins.md#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nRegistryPlugin:\n  load: BEFORE # Defaults to OMIT\n  required: true # Defaults to true\n  join-classpath: true # Defaults to true\n```\n\n----------------------------------------\n\nTITLE: Retrieving Event HandlerList in Bukkit/Paper (Java)\nDESCRIPTION: Demonstrates two ways to obtain the HandlerList for a specific event (PlayerJoinEvent) in Java for Bukkit/Paper plugins. The first method gets it from an event instance within an @EventHandler method using `event.getHandlerList()`. The second uses the static `getHandlerList()` method directly on the event class (`PlayerJoinEvent.getHandlerList()`) within the listener's constructor. This list manages all registered listeners for that event type.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/event-api/handler-lists.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\npublic class ExampleListener implements Listener {\n\n    @EventHandler\n    public void onPlayerJoin(PlayerJoinEvent event) {\n        HandlerList handlerList = event.getHandlerList();\n        // ...\n    }\n\n    // Or:\n\n    public ExampleListener() {\n        // Access the handler list through the static getter\n        HandlerList handlerList = PlayerJoinEvent.getHandlerList();\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Page Cards in Astro\nDESCRIPTION: This snippet imports and renders a `PageCards` component within an Astro file. The `PageCards` component is likely responsible for displaying a set of cards, possibly related to the documentation's content, such as links to other relevant pages. This component is a dependency for displaying certain elements on the page.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/admin/reference/index.mdx#_snippet_0\n\nLANGUAGE: astro\nCODE:\n```\nimport PageCards from \"/src/components/PageCards.astro\";\n```\n\nLANGUAGE: astro\nCODE:\n```\n<PageCards />\n```\n\n----------------------------------------\n\nTITLE: Registering an object as an event listener in Velocity\nDESCRIPTION: Example of registering a listener object with the EventManager. Shows the basic pattern used to register any class that contains @Subscribe methods as an event listener.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/event.md#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nserver.getEventManager().register(plugin, listener);\n```\n\n----------------------------------------\n\nTITLE: Registering a command with Velocity's CommandManager in Java\nDESCRIPTION: This snippet illustrates how to register a command within a Velocity plugin using the CommandManager. It demonstrates building command metadata with aliases, setting the plugin context, and registering a BrigadierCommand instance to make it available via proxy commands.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/command.md#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\npackage com.example.velocityplugin;\n\nimport com.google.inject.Inject;\nimport com.velocitypowered.api.command.BrigadierCommand;\nimport com.velocitypowered.api.event.Subscribe;\nimport com.velocitypowered.api.event.proxy.ProxyInitializeEvent;\nimport com.velocitypowered.api.plugin.Plugin;\nimport com.velocitypowered.api.proxy.ProxyServer;\n\n@Plugin(id = \"helloworld\")\npublic final class HelloWorldPlugin {\n    private final ProxyServer proxy;\n\n    @Inject\n    public HelloWorldPlugin(ProxyServer proxy) {\n        this.proxy = proxy;\n    }\n\n    @Subscribe\n    public void onProxyInitialize(ProxyInitializeEvent event) {\n        CommandManager commandManager = proxy.getCommandManager();\n        // Metadata for the command with aliases and plugin info\n        CommandMeta commandMeta = commandManager.metaBuilder(\"test\")\n            // Creating aliases for the command\n            .aliases(\"otherAlias\", \"anotherAlias\")\n            .plugin(this)\n            .build();\n\n        // Creating a BrigadierCommand instance to register\n        BrigadierCommand commandToRegister = TestBrigadierCommand.createBrigadierCommand(proxy);\n\n        // Register the command with the command manager\n        commandManager.register(commandMeta, commandToRegister);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Scheduling a repeating task every 5 minutes with Velocity Scheduler API in Java\nDESCRIPTION: This snippet shows how to schedule a recurring task that repeats every 5 minutes. It utilizes the repeat() method with a specified interval and scheduled execution. Suitable for periodic background tasks within plugins.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/scheduler.md#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\nserver.getScheduler()\n  .buildTask(plugin, () -> {\n    // do stuff here\n  })\n  .repeat(5L, TimeUnit.MINUTES)\n  .schedule();\n```\n\n----------------------------------------\n\nTITLE: Handling 'Argument type identifier unknown' Error in Velocity\nDESCRIPTION: Displays the 'Argument type identifier unknown' error message. This can occur with modded Fabric servers (1.16+) or potentially Vanilla servers. Solutions involve updating Velocity and installing CrossStitch for Fabric, or reporting a bug for Vanilla.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/admin/getting-started/faq.md#_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nArgument type identifier <namespace>:<name> unknown.\n```\n\n----------------------------------------\n\nTITLE: Implementing a RawCommand in Java for Velocity Proxy\nDESCRIPTION: This snippet demonstrates how to implement a RawCommand in Java for Velocity proxy, allowing direct command pass-through without argument processing. The example creates an EchoCommand that sends the received arguments back to the source and checks permissions.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/command.md#_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\npackage com.example.velocityplugin;\n\nimport com.velocitypowered.api.command.RawCommand;\nimport net.kyori.adventure.text.Component;\n\npublic final class EchoCommand implements RawCommand {\n\n    @Override\n    public void execute(final Invocation invocation) {\n        invocation.source().sendMessage(Component.text(invocation.arguments()));\n    }\n\n    @Override\n    public boolean hasPermission(final Invocation invocation) {\n        return invocation.source().hasPermission(\"command.echo\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating and Installing Java Prerequisites - Debian\nDESCRIPTION: This snippet updates the package lists and installs necessary tools for installing Java 21 on Debian-based Linux systems. Dependencies include `ca-certificates`, `apt-transport-https`, `gnupg`, and `wget`, which enable secure package downloads and installations.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/misc/java-install.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get update && sudo apt-get upgrade\nsudo apt-get install ca-certificates apt-transport-https gnupg wget\n```\n\n----------------------------------------\n\nTITLE: Creating macOS/Linux Start Script for Velocity\nDESCRIPTION: A shell script for launching Velocity proxy on Unix-based systems with optimized JVM arguments for performance.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/admin/getting-started/getting-started.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n#!/bin/sh\n\njava -Xms1G -Xmx1G -XX:+UseG1GC -XX:G1HeapRegionSize=4M -XX:+UnlockExperimentalVMOptions -XX:+ParallelRefProcEnabled -XX:+AlwaysPreTouch -XX:MaxInlineLevel=15 -jar velocity*.jar\n```\n\n----------------------------------------\n\nTITLE: Building the Production Site using pnpm\nDESCRIPTION: This command executes the 'build' script defined in the project's package.json. It compiles and bundles the project's source code and assets into a static format suitable for deployment, typically placing the output in a 'build' directory.\nSOURCE: https://github.com/papermc/docs/blob/main/README.md#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\n$ pnpm run build\n```\n\n----------------------------------------\n\nTITLE: Using Async Scheduler for Independent Tasks\nDESCRIPTION: This snippet retrieves the asynchronous scheduler, which allows running tasks independently of the server tick. It is useful for performing background operations or I/O without blocking main server processes.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/folia-support.md#_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\nAsyncScheduler asyncScheduler = server.getAsyncScheduler();\n```\n\n----------------------------------------\n\nTITLE: Setting Mojang Mappings in Maven POM XML\nDESCRIPTION: Configures the Maven POM file to mark the plugin as Mojang-mapped by setting the 'paperweight-mappings-namespace' manifest entry to 'mojang' within the maven-jar-plugin configuration. This instructs the server to recognize the plugin uses Mojang mappings. Requires Maven version 3.4.1 or compatible and the 'maven-jar-plugin' plugin configuration in the POM file.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/project-setup.mdx#_snippet_5\n\nLANGUAGE: xml\nCODE:\n```\n<plugin>\n  <groupId>org.apache.maven.plugins</groupId>\n  <artifactId>maven-jar-plugin</artifactId>\n  <version>3.4.1</version>\n  <configuration>\n    <archive>\n      <manifestEntries>\n        <paperweight-mappings-namespace>mojang</paperweight-mappings-namespace>\n      </manifestEntries>\n    </archive>\n  </configuration>\n</plugin>\n```\n\n----------------------------------------\n\nTITLE: Importing PageCards Component in Astro\nDESCRIPTION: This snippet shows how to import the 'PageCards' component from a local path within an Astro file. This component is likely used to dynamically generate content cards or links on the page.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/entity-api/index.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport PageCards from \"/src/components/PageCards.astro\";\n```\n\n----------------------------------------\n\nTITLE: Running Waterfall with Aikar's Recommended Flags - bash\nDESCRIPTION: This command runs the Waterfall proxy with a set of performance-oriented JVM flags recommended by Aikar. These flags tune the garbage collector (using G1GC) and other experimental options to optimize performance for server workloads. Memory limits (`-Xms`, `-Xmx`) should be adjusted based on available resources.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/waterfall/getting-started.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\njava -Xms512M -Xmx512M -XX:+UseG1GC -XX:G1HeapRegionSize=4M -XX:+UnlockExperimentalVMOptions -XX:+ParallelRefProcEnabled -XX:+AlwaysPreTouch -jar waterfall-###.jar\n```\n\n----------------------------------------\n\nTITLE: Reading a Valued Data Component in Java\nDESCRIPTION: Shows how to read a data component value from an ItemStack, with proper null checking and handling different component types.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/data-component-api.md#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\n// The damage of an item can be null, so we require a null check\nInteger damageValue = stack.getData(DataComponentTypes.DAMAGE);\nif (damageValue != null) {\n    logger.info(\"Current damage: \" + damageValue);\n} else {\n    logger.info(\"This item doesn't have a damage component set.\");\n}\n\n// Certain components, like the max stack size, will always be present on an item\nInteger maxStackSize = stack.getData(DataComponentTypes.MAX_STACK_SIZE);\n```\n\n----------------------------------------\n\nTITLE: Defining Enum for Custom Argument in Java\nDESCRIPTION: Defines a simple Java enum representing different ice cream flavors. This enum serves as the target type for a custom command argument, demonstrating how basic Java types or custom objects can be used.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/custom-arguments.md#_snippet_5\n\nLANGUAGE: java\nCODE:\n```\npackage io.papermc.commands.icecream;\n\nimport org.jspecify.annotations.NullMarked;\n\n@NullMarked\npublic enum IceCreamFlavor {\n    VANILLA,\n    CHOCOLATE,\n    STRAWBERRY;\n\n    @Override\n    public String toString() {\n        return name().toLowerCase();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Astro Component for Page Navigation\nDESCRIPTION: This JavaScript/Astro code imports the `PageCards` component from a local path. This component is likely used to render navigational cards or links to other reference pages within the documentation site.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/folia/admin/reference/index.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport PageCards from \"/src/components/PageCards.astro\";\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies using pnpm\nDESCRIPTION: This command uses the pnpm package manager to install all project dependencies listed in the project's configuration files (like package.json and pnpm-lock.yaml). Node.js and pnpm must be installed beforehand.\nSOURCE: https://github.com/papermc/docs/blob/main/README.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\n$ pnpm install\n```\n\n----------------------------------------\n\nTITLE: Identifying Outdated Java Version Error (Java Stack Trace)\nDESCRIPTION: This Java stack trace, specifically the `UnsupportedClassVersionError`, indicates that the Java Runtime Environment (JRE) being used is older than the Java Development Kit (JDK) version used to compile the server software or its components (like CraftBukkit Main). This requires updating the Java version on the server to resolve the issue.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/basic-troubleshooting.md#_snippet_3\n\nLANGUAGE: Java Stack Trace\nCODE:\n```\nException in thread \"ServerMain\" java.lang.UnsupportedClassVersionError: org/bukkit/craftbukkit/Main has been compiled by a more recent version of the Java Runtime (class file version 65.0), this version of the Java Runtime only recognizes class file versions up to 61.0\n        at java.base/java.lang.ClassLoader.defineClass1(Native Method)\n        at java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:1017)\n        at java.base/java.security.SecureClassLoader.defineClass(SecureClassLoader.java:150)\n        at java.base/java.net.URLClassLoader.defineClass(URLClassLoader.java:524)\n        at java.base/java.net.URLClassLoader$1.run(URLClassLoader.java:427)\n        at java.base/java.net.URLClassLoader$1.run(URLClassLoader.java:421)\n        at java.base/java.security.AccessController.doPrivileged(AccessController.java:712)\n        at java.base/java.net.URLClassLoader.findClass(URLClassLoader.java:420)\n        at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:592)\n        at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:525)\n        at java.base/java.lang.Class.forName0(Native Method)\n        at java.base/java.lang.Class.forName(Class.java:467)\n        at io.papermc.paperclip.Paperclip.lambda$main$0(Paperclip.java:38)\n        at java.base/java.lang.Thread.run(Thread.java:842)\n```\n\n----------------------------------------\n\nTITLE: Registering Outgoing BungeeCord Channel (Java)\nDESCRIPTION: Registers an outgoing plugin channel named 'BungeeCord' during plugin startup. This tells the server that the plugin intends to send messages on this channel.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/plugin-messaging.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\npublic final class PluginMessagingSample extends JavaPlugin {\n\n    @Override\n    public void onEnable() {\n        getServer().getMessenger().registerOutgoingPluginChannel(this, \"BungeeCord\");\n        // Blah blah blah...\n    }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying priority order for Velocity event listeners\nDESCRIPTION: Example of setting custom priority for an event listener using the priority parameter and PostOrder.CUSTOM. This determines the order in which listeners are invoked when events are fired.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/event.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\n@Subscribe(priority = 0, order = PostOrder.CUSTOM)\npublic void onPlayerChat(PlayerChatEvent event) {\n\t// do stuff\n}\n```\n\n----------------------------------------\n\nTITLE: Using Astro Component for Page Navigation\nDESCRIPTION: This snippet shows the usage of the imported `PageCards` Astro component within the Markdown/Astro file. It renders the component, which is responsible for displaying the navigational elements on the reference index page.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/folia/admin/reference/index.mdx#_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<PageCards />\n```\n\n----------------------------------------\n\nTITLE: Importing PageCards Component in Astro\nDESCRIPTION: This snippet imports the 'PageCards' component from a relative path within the project's source directory. This component is likely used to render a collection of cards or links on the page.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/index.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport PageCards from \"/src/components/PageCards.astro\";\n```\n\n----------------------------------------\n\nTITLE: Rendering PageCards Component in Astro\nDESCRIPTION: This snippet shows the usage of the imported 'PageCards' component within the Astro template. It renders the component, which will likely display a set of cards related to basic topics.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/index.mdx#_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<PageCards />\n```\n\n----------------------------------------\n\nTITLE: Creating Windows Start Script for Velocity\nDESCRIPTION: A batch script for launching Velocity proxy on Windows systems with optimized JVM arguments for performance.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/admin/getting-started/getting-started.md#_snippet_0\n\nLANGUAGE: batch\nCODE:\n```\n@echo off\njava -Xms1G -Xmx1G -XX:+UseG1GC -XX:G1HeapRegionSize=4M -XX:+UnlockExperimentalVMOptions -XX:+ParallelRefProcEnabled -XX:+AlwaysPreTouch -XX:MaxInlineLevel=15 -jar velocity.jar\npause\n```\n\n----------------------------------------\n\nTITLE: Setting Mojang Mappings for Production (Kotlin DSL)\nDESCRIPTION: This code snippet configures the paperweight plugin to compile the plugin using Mojang mappings. This is the preferred option for Paper plugins as of Minecraft 1.20.5, as it skips the one-time plugin remapping process on server startup.  This configuration makes the plugin incompatible with Spigot servers.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/userdev.md#_snippet_4\n\nLANGUAGE: kotlin\nCODE:\n```\npaperweight.reobfArtifactConfiguration = io.papermc.paperweight.userdev.ReobfArtifactConfiguration.MOJANG_PRODUCTION\n```\n\n----------------------------------------\n\nTITLE: Adding velocity-api Dependency: Gradle Kotlin DSL\nDESCRIPTION: This snippet configures the `velocity-api` dependency within a Gradle project using the Kotlin DSL.  It adds `compileOnly` and `annotationProcessor` configurations for the dependency.  `compileOnly` ensures the dependency is available during compilation, while `annotationProcessor` enables annotation processing features.  The version uses a placeholder for the latest release.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/getting-started/creating-your-first-plugin.mdx#_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\n    dependencies {\n      compileOnly(\"com.velocitypowered:velocity-api:\\\\{LATEST_VELOCITY_RELEASE}\")\n      annotationProcessor(\"com.velocitypowered:velocity-api:\\\\{LATEST_VELOCITY_RELEASE}\")\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Disabling Anti-Xray in paper-world.yml (End) - engine-mode 2\nDESCRIPTION: This snippet disables Anti-Xray in the End dimension's `paper-world.yml` configuration file when using engine-mode 2.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/anti-xray.mdx#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nanticheat:\n  anti-xray:\n    enabled: false\n```\n\n----------------------------------------\n\nTITLE: Enabling Classpath Joining via `paper-plugin.yml`\nDESCRIPTION: Shows the specific YAML configuration `join-classpath: true` within a dependency declaration in `paper-plugin.yml`. Setting this option to true grants the current plugin access to the specified dependency plugin's classpath.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/paper-plugins.md#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nPlugin:\n  join-classpath: true # Means you have access to their classpath\n```\n\n----------------------------------------\n\nTITLE: Frontmatter Configuration for Reference Page\nDESCRIPTION: This YAML frontmatter block sets metadata for the documentation page. It defines the page title as 'Reference' and disables the automatic table of contents.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/folia/admin/reference/index.mdx#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\ntitle: Reference\ntableOfContents: false\n---\n```\n\n----------------------------------------\n\nTITLE: Velocity Shutdown Console Output\nDESCRIPTION: Example log output showing what to expect when properly shutting down the Velocity proxy using the 'end' command.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/admin/getting-started/getting-started.md#_snippet_3\n\nLANGUAGE: log\nCODE:\n```\n> end\n[05:42:10 INFO]: Shutting down the proxy...\n[05:42:10 INFO]: Closing endpoint /0.0.0.0:25565\n```\n\n----------------------------------------\n\nTITLE: Implementing a basic suggestion lambda in Java\nDESCRIPTION: A simple example showing the structure of a lambda function for command suggestions that doesn't add any actual suggestions. This demonstrates the basic pattern used with the suggests() method.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/argument-suggestions.mdx#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nCommands.argument(\"name\", StringArgumentType.word())\n    .suggests((ctx, builder) -> builder.buildFuture());\n```\n\n----------------------------------------\n\nTITLE: Setting a Valued Data Component in Java\nDESCRIPTION: Shows how to set a complex custom model data component on an ItemStack using a builder pattern.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/data-component-api.md#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\n// Set a custom model data value on this item\nstack.setData(DataComponentTypes.CUSTOM_MODEL_DATA, CustomModelData.customModelData()\n    .addFloat(0.5f)\n    .addFlag(true)\n    .build()\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a custom event class in Velocity\nDESCRIPTION: Example of creating a custom event class for a private messaging system. Shows the basic pattern for event classes including constructor, getters, and properties.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/event.md#_snippet_8\n\nLANGUAGE: java\nCODE:\n```\npublic class PrivateMessageEvent {\n\n  private final Player sender;\n  private final Player recipient;\n  private final String message;\n\n  public PrivateMessageEvent(Player sender, Player recipient, String message) {\n    this.sender = sender;\n    this.recipient = recipient;\n    this.message = message;\n  }\n\n  public Player sender() {\n    return sender;\n  }\n\n  public Player recipient() {\n    return recipient;\n  }\n\n  public String message() {\n    return message;\n  }\n\n  // toString, equals, and hashCode may be added as needed\n\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving 'Invalid payload REGISTER' Kick Error in Velocity\nDESCRIPTION: Shows the 'Invalid payload REGISTER' error message, which typically occurs on Spigot-based servers when a player connects using a modded client via Velocity. A potential fix involves using a specific startup flag on Paper servers.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/admin/getting-started/faq.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n[server connection] player1 -> hub has connected\n[connected player] player1 (/localhost:58943): kicked from server hub: Invalid payload REGISTER!\n```\n\n----------------------------------------\n\nTITLE: Logging debug messages using PaperMC plugin logger in Java\nDESCRIPTION: This snippet demonstrates how to print debug messages to the console using the PaperMC plugin's component logger instead of standard output. Using the plugin logger simplifies identifying the source of logs and managing their verbosity. The code requires access to the plugin instance and the Adventure Component API for text formatting. It accepts a message string wrapped in a Component and outputs it at the debug log level. Using logging levels like warning can improve visibility in some console environments.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/misc/debugging.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nplugin.getComponentLogger().debug(Component.text(\"SuperDuperBad Thing has happened\"));\n```\n\n----------------------------------------\n\nTITLE: Asynchronous event handling with Continuation in Velocity\nDESCRIPTION: Demonstrates handling events asynchronously using the Continuation parameter. This allows plugins to pause event processing, perform async operations, and then resume when complete.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/event.md#_snippet_5\n\nLANGUAGE: java\nCODE:\n```\n@Subscribe(priority = 100, order = PostOrder.CUSTOM)\npublic void onLogin(LoginEvent event, Continuation continuation) {\n  doSomeAsyncProcessing().addListener(continuation::resume, continuation::resumeWithException);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Style Argument in Paper Command API\nDESCRIPTION: Shows how to create a command that uses the style argument to accept JSON-formatted style definitions. The example demonstrates applying the parsed Style object to a text component to format messages with complex styling.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/arguments/adventure.mdx#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\npublic static LiteralCommandNode<CommandSourceStack> styleArgument() {\n    return Commands.literal(\"style\")\n        .then(Commands.argument(\"style\", ArgumentTypes.style())\n            .then(Commands.argument(\"message\", StringArgumentType.greedyString())\n                .executes(ctx -> {\n                    final Style style = ctx.getArgument(\"style\", Style.class);\n                    final String msg = StringArgumentType.getString(ctx, \"message\");\n\n                    ctx.getSource().getSender().sendRichMessage(\"Your input: <input>\",\n                        Placeholder.component(\"input\", Component.text(message).style(style))\n                    );\n                    return Command.SINGLE_SUCCESS;\n                })))\n        .build();\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a basic event listener method in Velocity\nDESCRIPTION: Shows how to create a basic event listener method using the @Subscribe annotation to capture player chat events. The method signature demonstrates the correct parameter format for event handlers.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/event.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n@Subscribe\npublic void onPlayerChat(PlayerChatEvent event) {\n\t// do stuff\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Commands in plugin.yml\nDESCRIPTION: Example showing how to register commands in the plugin.yml file. The configuration includes command description, usage instructions, aliases, and permission requirements.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/plugin-yml.mdx#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\ncommands:\n  command:\n    description: \"This is a command\"\n    usage: \"/command <arg>\"\n    aliases: [cmd, command]\n    permission: permission.node\n    permission-message: \"You do not have permission to use this command\"\n```\n\n----------------------------------------\n\nTITLE: Sending a Plugin Message to a Player in Velocity\nDESCRIPTION: Sends a plugin message directly to a player's connection, useful mainly for client-side mods, allowing server-to-client communication.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/plugin-messaging.md#_snippet_6\n\nLANGUAGE: Java\nCODE:\n```\npublic boolean sendPluginMessageToPlayer(Player player, ChannelIdentifier identifier, byte[] data) {\n    return player.sendPluginMessage(identifier, data);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Maven Repository: papermc\nDESCRIPTION: This snippet configures the Maven repository for PaperMC.  It specifies the repository's name and URL. The repository is used to fetch the velocity-api dependency, which is essential for developing Velocity plugins. This configuration is needed to download dependencies and build the project successfully.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/getting-started/creating-your-first-plugin.mdx#_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n      <repositories>\n        <repository>\n          <id>papermc</id>\n          <url>https://repo.papermc.io/repository/maven-public/</url>\n        </repository>\n      </repositories>\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Anti-Xray with engine-mode 2 in paper-world.yml (Nether)\nDESCRIPTION: This snippet configures Anti-Xray with engine-mode 2 for the Nether dimension in `paper-world.yml`. It includes settings for enabled, engine-mode, hidden-blocks, lava-obscures, max-block-height, replacement-blocks, update-radius, and use-permission. The hidden and replacement blocks are specific to the Nether.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/anti-xray.mdx#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nanticheat:\n  anti-xray:\n    enabled: true\n    engine-mode: 2\n    hidden-blocks:\n    # See note about air and possible client performance issues above.\n    - air\n    - ancient_debris\n    - bone_block\n    - glowstone\n    - magma_block\n    - nether_bricks\n    - nether_gold_ore\n    - nether_quartz_ore\n    - polished_blackstone_bricks\n    lava-obscures: false\n    max-block-height: 128\n    replacement-blocks:\n    - basalt\n    - blackstone\n    - gravel\n    - netherrack\n    - soul_sand\n    - soul_soil\n    update-radius: 2\n    use-permission: false\n```\n\n----------------------------------------\n\nTITLE: Saving Default Plugin Configuration in Paper\nDESCRIPTION: Shows how to save the default `config.yml` file embedded in the plugin's resources directory to the plugin's data folder. The `saveResource` method copies the file, while `saveDefaultConfig` is a convenience method that only saves if the config file doesn't already exist. The boolean parameter in `saveResource` controls whether an existing file is replaced.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/plugin-configs.mdx#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\npublic class TestPlugin extends JavaPlugin {\n\n    @Override\n    public void onEnable() {\n        saveResource(\"config.yml\", /* replace */ false);\n\n        // You can also use this for configuration files:\n        saveDefaultConfig();\n        // Where the default config.yml will be saved if it does not already exist\n\n        // getConfig()...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Nether World Anti-Xray Configuration\nDESCRIPTION: This YAML snippet configures Anti-Xray for the nether dimension in 'paper-world.yml'. It sets engine-mode 3, defines hidden and replacement blocks, and adjusts protection parameters specific to the nether environment. It requires placement within the nether world folder and server restart to apply.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/anti-xray.mdx#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\nanticheat:\n  anti-xray:\n    enabled: true\n    engine-mode: 3\n    hidden-blocks:\n    # See note about air and possible client performance issues above.\n    - air\n    - ancient_debris\n    - bone_block\n    - glowstone\n    - magma_block\n    - nether_bricks\n    - nether_gold_ore\n    - nether_quartz_ore\n    - polished_blackstone_bricks\n    lava-obscures: false\n    max-block-height: 128\n    replacement-blocks:\n    - basalt\n    - blackstone\n    - gravel\n    - netherrack\n    - soul_sand\n    - soul_soil\n    update-radius: 2\n    use-permission: false\n```\n\n----------------------------------------\n\nTITLE: Using reflection to access CraftBukkit classes at runtime in Java\nDESCRIPTION: This code snippet demonstrates how to dynamically construct class names in order to reflectively access specific CraftBukkit classes based on the server version. It addresses the challenge of version-dependent class locations in Minecraft server implementations prior to 1.20.5, allowing for flexible runtime class loading with reflection.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/misc/internal-code.md#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\nprivate static final String CRAFTBUKKIT_PACKAGE = Bukkit.getServer().getClass().getPackageName();\n\npublic static String cbClass(String clazz) {\n  return CRAFTBUKKIT_PACKAGE + \".\" + clazz;\n}\n\n// Use this method to get the CraftBukkit class:\nClass.forName(cbClass(\"entity.CraftBee\"));\n```\n\n----------------------------------------\n\nTITLE: Configuring Corretto Repository - Zypper\nDESCRIPTION: This command adds the Amazon Corretto repository to a system using Zypper (openSUSE, SLES). It uses `zypper addrepo` to add the repository, and the `zypper refresh` to update the package metadata.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/misc/java-install.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nsudo zypper addrepo https://yum.corretto.aws/corretto.repo\nsudo zypper refresh\n```\n\n----------------------------------------\n\nTITLE: Adding an Optional Plugin Dependency in Velocity\nDESCRIPTION: This code snippet illustrates how to make a plugin dependency optional by setting the `optional` attribute of the `@Dependency` annotation to `true`. This allows the plugin to load even if the dependency is not present.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/how-to/dependencies.md#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\n@Plugin(\n  id = \"myfirstplugin\",\n  name = \"My Plugin\",\n  version = \"0.1.0\",\n  dependencies = {\n    @Dependency(id = \"wonderplugin\", optional = true)\n  }\n)\npublic class VelocityTest {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Java 21 - YUM\nDESCRIPTION: This command installs the Java 21 Development Kit (JDK) from the Amazon Corretto repository using YUM. The `-y` flag automatically answers yes to all prompts.  It's the final step for installing Java 21 on YUM based systems.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/misc/java-install.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nsudo yum -y install java-21-amazon-corretto-devel\n```\n\n----------------------------------------\n\nTITLE: Specifying Plugin Libraries in YAML\nDESCRIPTION: Example of how to specify external libraries that your plugin depends on. These will be automatically downloaded from Maven Central and added to the classpath.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/getting-started/plugin-yml.mdx#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nlibraries:\n  - com.google.guava:guava:30.1.1-jre\n  - com.google.code.gson:gson:2.8.6\n```\n\n----------------------------------------\n\nTITLE: Importing Corretto Key - RPM-based\nDESCRIPTION: This bash command imports the Amazon Corretto public key into the RPM database on an RPM-based Linux system.  The key is necessary to verify the integrity of the packages from the Corretto repository.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/misc/java-install.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo rpm --import https://yum.corretto.aws/corretto.key\n```\n\n----------------------------------------\n\nTITLE: Verifying Java Installation\nDESCRIPTION: This command checks if Java 21 has been installed correctly. It runs the `java -version` command, which outputs the installed Java version, the runtime environment, and the Java Virtual Machine information. Successful installation is indicated by the output containing `openjdk 21` and `64-Bit`.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/misc/java-install.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\njava -version\n```\n\n----------------------------------------\n\nTITLE: Installing Java 21 - Zypper\nDESCRIPTION: This command installs the Java 21 Development Kit (JDK) from the Amazon Corretto repository using Zypper. This command installs the actual Java packages,  completing the Java 21 installation on Zypper based systems.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/misc/java-install.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nsudo zypper install java-21-amazon-corretto-devel\n```\n\n----------------------------------------\n\nTITLE: Mounting a TextDisplay Entity as a Passenger on an Entity and Managing Visibility with PaperMC in Java\nDESCRIPTION: Demonstrates spawning a temporary and hidden TextDisplay, disabling its persistence, mounting it on top of another entity (e.g., to use as a styled nametag), and controlling player visibility via Player API methods showEntity and hideEntity. Also illustrates cleanup by removing the display when done. Dependencies include PaperMC entity API, Player, and plugin context. Inputs are spawn location, entity to mount on, and plugin/player references. Outputs a display entity mounted and shown only to selected players.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/entity-api/display-entities.md#_snippet_7\n\nLANGUAGE: java\nCODE:\n```\nTextDisplay display = world.spawn(location, TextDisplay.class, entity -> {\n    // ...\n\n    entity.setVisibleByDefault(false); // hide it for everyone\n    entity.setPersistent(false); // don't save the display, it's temporary\n});\n\nentity.addPassenger(display); // mount it on top of an entity's head\nplayer.showEntity(plugin, display); // show it to a player\n// ...\ndisplay.remove(); // done with the display\n```\n\n----------------------------------------\n\nTITLE: Registering Bukkit Commands in Java\nDESCRIPTION: Defines a Bukkit command by extending the BukkitCommand class and implementing execute and tabComplete methods. Requires the Bukkit API as a dependency, and utilizes Player and CommandSender classes to handle user input and command suggestions. The constructor takes the command name, description, usage message, and aliases, while the execute method expects player arguments, checks validity, notifies users, and returns execution status. The tabComplete method suggests player names based on online players and command arguments. Input is a CommandSender, command label, and arguments array. Outputs are success/failure boolean and a list of autocompletion options.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/misc/comparison-bukkit-brigadier.md#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\npackage your.package.name;\n\nimport org.bukkit.Bukkit;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.command.defaults.BukkitCommand;\nimport org.bukkit.entity.Player;\nimport org.jspecify.annotations.NullMarked;\n\nimport java.util.List;\n\n@NullMarked\npublic class BukkitPartyCommand extends BukkitCommand {\n    public BukkitPartyCommand(String name, String description, String usageMessage, List<String> aliases) {\n        super(name, description, usageMessage, aliases);\n    }\n\n    @Override\n    public boolean execute(CommandSender sender, String commandLabel, String[] args) {\n        if (args.length == 0) {\n            sender.sendPlainMessage(\"Please provide a player!\");\n            return false;\n        }\n\n        final Player targetPlayer = Bukkit.getPlayer(args[0]);\n        if (targetPlayer == null) {\n            sender.sendPlainMessage(\"Please provide a valid player!\");\n            return false;\n        }\n\n        targetPlayer.sendPlainMessage(sender.getName() + \" started partying with you!\");\n        sender.sendPlainMessage(\"You are now partying with \" + targetPlayer.getName() + \"!\");\n        return true;\n    }\n\n    @Override\n    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {\n        if (args.length == 1) {\n            return Bukkit.getOnlinePlayers().stream().map(Player::getName).toList();\n        }\n\n        return List.of();\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring spigot.yml for Vanilla Parity\nDESCRIPTION: Displays relevant settings within spigot.yml that may need adjustment to align Spigot/PaperMC behavior closer to Vanilla Minecraft. The specific settings shown are filtered by the `filterVanilla` function to highlight those impacting Vanilla parity.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/vanilla.mdx#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n# Example structure from spigot.yml - Actual content dynamically loaded\n# settings:\n#   setting: value\n# world-settings:\n#   default:\n#     section:\n#       setting: value\n```\n\n----------------------------------------\n\nTITLE: Sending Raw Chat Component to Player via BungeeCord (Paper)\nDESCRIPTION: This snippet illustrates sending a raw chat component to a player using the 'MessageRaw' subchannel of the BungeeCord plugin channel. It utilizes GsonComponentSerializer to serialize a component containing clickable text.  The outgoing plugin channel 'BungeeCord' must be registered. The 'MessageRaw' message sends a serialized JSON chat component to the specified player or all players ('ALL').\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/plugin-messaging.md#_snippet_4\n\nLANGUAGE: java\nCODE:\n```\npublic class MyPlugin extends JavaPlugin {\n\n    @Override\n    public void onEnable() {\n        this.getServer().getMessenger().registerOutgoingPluginChannel(this, \"BungeeCord\");\n\n        Player player = ...;\n        ByteArrayDataOutput out = ByteStreams.newDataOutput();\n        out.writeUTF(\"MessageRaw\");\n        out.writeUTF(\"ALL\");\n        out.writeUTF(GsonComponentSerializer.gson().serialize(\n                Component.text(\"Click Me!\").clickEvent(ClickEvent.openUrl(\"https://papermc.io\"))\n        ));\n        player.sendPluginMessage(this, \"BungeeCord\", out.toByteArray());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing PageCards Component in Astro\nDESCRIPTION: Imports the `PageCards` component from its specified path within the project's source directory. This makes the component available for use within the Astro page.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/reference/index.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport PageCards from \"/src/components/PageCards.astro\";\n```\n\n----------------------------------------\n\nTITLE: Starting the Development Server using pnpm\nDESCRIPTION: This command executes the 'dev' script defined in the project's package.json, typically starting a local web server. This server usually provides features like hot-reloading, allowing developers to see changes live in their browser without manual refreshes.\nSOURCE: https://github.com/papermc/docs/blob/main/README.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\n$ pnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Embedding ItemCommandConverter component in Svelte application\nDESCRIPTION: This snippet loads and renders the 'ItemCommandConverter' component in the Svelte app, using the client:load directive to ensure client-side rendering. This allows users to interact with the conversion tool within user interface pages.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/misc/tools/item-command-converter.mdx#_snippet_1\n\nLANGUAGE: Svelte\nCODE:\n```\n<ItemCommandConverter client:load />\n```\n\n----------------------------------------\n\nTITLE: Installing Java 21 on macOS\nDESCRIPTION: This command uses Homebrew, a package manager for macOS, to install Java 21.  It installs the `openjdk@21` package, providing the Java Development Kit.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/misc/java-install.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nbrew install openjdk@21\n```\n\n----------------------------------------\n\nTITLE: Default World Anti-Xray Configuration\nDESCRIPTION: This YAML configuration modifies the 'paper-world-defaults.yml' to enable Anti-Xray with engine-mode 3. It defines hidden blocks, replacement blocks, maximum block height, and other related parameters to disguise ores and protect the world from X-ray cheats. Dependencies include the PaperMC server and proper configuration placement.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/anti-xray.mdx#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nanticheat:\n  anti-xray:\n    enabled: true\n    engine-mode: 3\n    hidden-blocks:\n    # You can add air here such that many holes are generated.\n    # This works well against cave finders but may cause client FPS drops for all players.\n    - air\n    - copper_ore\n    - deepslate_copper_ore\n    - raw_copper_block\n    - diamond_ore\n    - deepslate_diamond_ore\n    - gold_ore\n    - deepslate_gold_ore\n    - iron_ore\n    - deepslate_iron_ore\n    - raw_iron_block\n    - lapis_ore\n    - deepslate_lapis_ore\n    - redstone_ore\n    - deepslate_redstone_ore\n    lava-obscures: false\n    # As of 1.18 some ores are generated much higher.\n    # Please adjust the max-block-height setting at your own discretion.\n    # https://minecraft.wiki/w/Ore might be helpful.\n    max-block-height: 64\n    replacement-blocks:\n    # Chest is a tile entity and can't be added to hidden-blocks in engine-mode: 2.\n    # But adding chest here will hide buried treasures, if max-block-height is increased.\n    - chest\n    - amethyst_block\n    - andesite\n    - budding_amethyst\n    - calcite\n    - coal_ore\n    - deepslate_coal_ore\n    - deepslate\n    - diorite\n    - dirt\n    - emerald_ore\n    - deepslate_emerald_ore\n    - granite\n    - gravel\n    - oak_planks\n    - smooth_basalt\n    - stone\n    - tuff\n    update-radius: 2\n    use-permission: false\n```\n\n----------------------------------------\n\nTITLE: Configuring Velocity Servers in TOML Configuration\nDESCRIPTION: Example configuration for the servers section in velocity.toml showing how to define server connections and the connection attempt order.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/admin/getting-started/getting-started.md#_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[servers]\n# Configure your servers here. Each key represents the server's name, and the value\n# represents the IP address of the server to connect to.\nlobby = \"127.0.0.1:30066\"\nfactions = \"127.0.0.1:30067\"\nminigames = \"127.0.0.1:30068\"\n\n# In what order we should try servers when a player logs in or is kicked from a server.\ntry = [\n  \"lobby\",\n  \"factions\"\n]\n```\n\n----------------------------------------\n\nTITLE: Configuring Forge Server Read Timeout for Velocity\nDESCRIPTION: Provides the Java startup flag `-Dfml.readTimeout` used to increase the read timeout on Forge servers, particularly those with large modpacks, to prevent disconnections when players switch servers via Velocity. This value (in seconds) should correspond to the `read-timeout` setting (in milliseconds) in `velocity.toml`.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/admin/getting-started/faq.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n-Dfml.readTimeout=120\n```\n\n----------------------------------------\n\nTITLE: Starting spark Profiler - Server Command\nDESCRIPTION: This command initiates a performance profiling session on the Paper server using the bundled `spark` profiler. The `--timeout 600` argument specifies that the profiling should run for 600 seconds (10 minutes) before automatically stopping. This command is essential for collecting data needed to diagnose active performance issues.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/profiling.md#_snippet_0\n\nLANGUAGE: Server Command\nCODE:\n```\n/spark profiler start --timeout 600\n```\n\n----------------------------------------\n\nTITLE: Applying Aikar's Recommended JVM Flags via Bash Startup Script\nDESCRIPTION: This bash snippet demonstrates the full command line for starting a PaperMC server with Aikar's recommended JVM flags. It configures initial (-Xms) and maximum (-Xmx) heap size, enables and tunes the G1 Garbage Collector for performance, and includes flags for specific JVM behaviors like AlwaysPreTouch and DisableExplicitGC. These flags are crucial for minimizing GC pauses and optimizing memory usage for a stable Minecraft server.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/aikars-flags.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\njava -Xms10G -Xmx10G -XX:+UseG1GC -XX:+ParallelRefProcEnabled -XX:MaxGCPauseMillis=200 -XX:+UnlockExperimentalVMOptions -XX:+DisableExplicitGC -XX:+AlwaysPreTouch -XX:G1NewSizePercent=30 -XX:G1MaxNewSizePercent=40 -XX:G1HeapRegionSize=8M -XX:G1ReservePercent=20 -XX:G1HeapWastePercent=5 -XX:G1MixedGCCountTarget=4 -XX:InitiatingHeapOccupancyPercent=15 -XX:G1MixedGCLiveThresholdPercent=90 -XX:G1RSetUpdatingPauseTimePercent=5 -XX:SurvivorRatio=32 -XX:+PerfDisableSharedMem -XX:MaxTenuringThreshold=1 -Dusing.aikars.flags=https://mcflags.emc.gs -Daikars.new.flags=true -jar paper.jar --nogui\n```\n\n----------------------------------------\n\nTITLE: Handling Chunk Version Mismatch with JVM Flag\nDESCRIPTION: This snippet demonstrates using a JVM flag to bypass world data version checks. Note that this approach is strongly discouraged due to the high risk of world corruption and lack of support.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/basic-troubleshooting.md#_snippet_1\n\nLANGUAGE: JVM\nCODE:\n```\n-DPaper.ignoreWorldDataVersion=true\n```\n\n----------------------------------------\n\nTITLE: Configuring server.properties for Vanilla Parity\nDESCRIPTION: Displays relevant settings within server.properties that may need adjustment to align PaperMC behavior closer to Vanilla Minecraft. The specific settings shown are filtered by the `filterVanilla` function to highlight those impacting Vanilla parity.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/how-to/vanilla.mdx#_snippet_0\n\nLANGUAGE: properties\nCODE:\n```\n# Example structure from server.properties - Actual content dynamically loaded\n# setting=value\n```\n\n----------------------------------------\n\nTITLE: Parsing Bukkit.yml Configuration - JavaScript\nDESCRIPTION: This JavaScript snippet parses the raw YAML content of the `bukkit.yml` configuration file. It uses the `yaml` library to parse the YAML string into a JavaScript object. This object is then used as input for another component that displays the config nodes.  This snippet is dependent on the `yaml` library and the `bukkit.yml` file containing valid YAML.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/reference/configuration/bukkit-configuration.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport BukkitYML from \"/src/config/paper/bukkit.yml?raw\";\nimport { parse } from \"yaml\";\n\n// Parses the YAML data from bukkit.yml. The parsed object is then passed to the ConfigNode component.\n```\n\n----------------------------------------\n\nTITLE: YAML Representation of Simple Commands\nDESCRIPTION: Shows a simple list syntax in YAML representing the commands under a plugin command root. It is used here purely for human-readable display and explanation purposes, not executable code. Inputs are command strings; output is a structured list illustrating command invocation examples.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/command-tree.mdx#_snippet_1\n\nLANGUAGE: yml\nCODE:\n```\n/customplugin reload\n/customplugin tphere\n/customplugin killall\n```\n\n----------------------------------------\n\nTITLE: Rendering Minecraft Server Whitelist JSON Data Using Astro Component with YAML Parsing in JavaScript\nDESCRIPTION: This snippet loads whitelist player data from a YAML file, parses it to a JavaScript object, and renders it as JSON using the ConfigNode component within Astro. whitelist.json is a server-managed data file controlling which players can connect, linked with whitelist server properties. The snippet depends on the YAML parser for data reading and Astro ConfigNode for rendering. Expected input is the raw YAML whitelist content, and output is a structured display highlighting allowed players.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/reference/configuration/vanilla-data-files.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport ConfigNode from \"/src/components/ConfigNode.astro\";\nimport { parse } from \"yaml\";\nimport WhitelistYML from \"/src/config/paper/whitelist-single.yml?raw\";\n\n<ConfigNode data={parse(WhitelistYML)} lang=\"json\" path={[\"whitelist\"]} />\n```\n\n----------------------------------------\n\nTITLE: Advanced Hangar Publishing Configuration with Git Integration\nDESCRIPTION: This advanced configuration shows how to enhance the Hangar publishing task with Git integration to dynamically set version numbers and changelogs based on commit messages. It determines whether to publish to Release or Snapshot channels based on version format.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/misc/hangar-publishing.md#_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\nimport java.io.ByteArrayOutputStream\n\n// ...\n\n// Helper methods\nfun executeGitCommand(vararg command: String): String {\n    val byteOut = ByteArrayOutputStream()\n    exec {\n        commandLine = listOf(\"git\", *command)\n        standardOutput = byteOut\n    }\n    return byteOut.toString(Charsets.UTF_8.name()).trim()\n}\n\nfun latestCommitMessage(): String {\n    return executeGitCommand(\"log\", \"-1\", \"--pretty=%B\")\n}\n\nval versionString: String = version as String\nval isRelease: Boolean = !versionString.contains('-')\n\nval suffixedVersion: String = if (isRelease) {\n    versionString\n} else {\n    // Give the version a unique name by using the GitHub Actions run number\n    versionString + \"+\" + System.getenv(\"GITHUB_RUN_NUMBER\")\n}\n\n// Use the commit description for the changelog\nval changelogContent: String = latestCommitMessage()\n\n// If you would like to publish releases with their proper changelogs manually, simply add an if statement with the `isRelease` variable here.\nhangarPublish {\n    publications.register(\"plugin\") {\n        version.set(suffixedVersion)\n        channel.set(if (isRelease) \"Release\" else \"Snapshot\")\n        changelog.set(changelogContent)\n        // ... (see above)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using PageCards Component in Astro\nDESCRIPTION: Renders the imported `PageCards` component within the Astro page structure. This component is responsible for displaying the actual reference links or summaries on the page.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/reference/index.mdx#_snippet_1\n\nLANGUAGE: Astro\nCODE:\n```\n<PageCards />\n```\n\n----------------------------------------\n\nTITLE: Using PageCards Component in Astro\nDESCRIPTION: This snippet renders the imported PageCards component within an Astro page, providing a UI element that likely displays cards with API guide content. It requires the PageCards component to be defined and available at the specified import path.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/velocity/dev/api/index.mdx#_snippet_1\n\nLANGUAGE: Astro\nCODE:\n```\n<PageCards />\n```\n\n----------------------------------------\n\nTITLE: Importing PageCards Component in Astro Markdown\nDESCRIPTION: This snippet imports the PageCards component from the src/components directory to display navigation cards for the getting started guides.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/admin/getting-started/index.mdx#_snippet_0\n\nLANGUAGE: astro\nCODE:\n```\nimport PageCards from \"/src/components/PageCards.astro\";\n```\n\n----------------------------------------\n\nTITLE: Importing PageCards component in Astro\nDESCRIPTION: This snippet demonstrates importing the PageCards component from the specified path within an Astro file. It facilitates the inclusion of pre-built UI components into the webpage, enabling modular and maintainable code. Dependencies include the PageCards component located at /src/components/PageCards.astro.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/event-api/index.mdx#_snippet_0\n\nLANGUAGE: Astro\nCODE:\n```\nimport PageCards from \"/src/components/PageCards.astro\";\n\n<PageCards />\n```\n\n----------------------------------------\n\nTITLE: Visualizing Command Nodes using D2 Diagram Syntax\nDESCRIPTION: Utilizes the D2 diagram language to graphically represent command trees by defining directed edges between nodes. This visualizes parent-child relationships between command literals, helping to understand hierarchical command structure. Input is a D2 script defining nodes and directional edges; output is a rendered tree diagram.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/paper/dev/api/command-api/basics/command-tree.mdx#_snippet_2\n\nLANGUAGE: d2\nCODE:\n```\nstyle.fill: transparent\ndirection: down\n\ncustomplugin -> reload\ncustomplugin -> tphere\ncustomplugin -> killall\n```\n\n----------------------------------------\n\nTITLE: Importing Astro UI Components in JavaScript\nDESCRIPTION: This snippet imports 'CardGrid' and 'LinkCard' components from the '@astrojs/starlight/components' library. These components facilitate the creation of a responsive grid with card links, used for organizing navigational items in the documentation.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/folia/index.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { CardGrid, LinkCard } from \"@astrojs/starlight/components\";\n```\n\n----------------------------------------\n\nTITLE: Adding a page with slug and title in Markdown\nDESCRIPTION: This snippet shows how to add a new page to the PaperMC documentation, including the required frontmatter (title and slug). It also mentions where the file should be placed in the folder structure.\nSOURCE: https://github.com/papermc/docs/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\ntitle: Paper plugins\nslug: paper/reference/paper-plugins\n---\n\nThis documentation page serves to explain all the new semantics and possible confusions that Paper plugins may introduce.\n```\n\n----------------------------------------\n\nTITLE: Tagging documentation with version metadata in Markdown\nDESCRIPTION: This snippet demonstrates how to add version tags to documentation pages using the `version` front matter property. This allows users to identify the software version the documentation pertains to.\nSOURCE: https://github.com/papermc/docs/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n---\ntitle: My awesome page\ndescription: My awesome page about my awesome topic for 1.20.\nslug: paper/my-awesome-page\nversion: \"1.20\"\n---\n```\n\n----------------------------------------\n\nTITLE: Configuring Corretto Repository - YUM\nDESCRIPTION: This command configures the Amazon Corretto repository on a system that uses YUM. It downloads the repository configuration file and places it in the `/etc/yum.repos.d/` directory. This makes the Corretto packages available for installation.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/misc/java-install.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nsudo curl -Lo /etc/yum.repos.d/corretto.repo https://yum.corretto.aws/corretto.repo\n```\n\n----------------------------------------\n\nTITLE: Configuring Corretto Repository - DNF\nDESCRIPTION: This command configures the Amazon Corretto repository on a system that uses DNF (Fedora, CentOS/RHEL 7+). It downloads the repository configuration file (`corretto.repo`) and places it in the `/etc/yum.repos.d/` directory, making the Corretto packages available for installation.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/misc/java-install.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsudo curl -Lo /etc/yum.repos.d/corretto.repo https://yum.corretto.aws/corretto.repo\n```\n\n----------------------------------------\n\nTITLE: Using constants in MDX\nDESCRIPTION: This snippet demonstrates how to import and use predefined constants (e.g., latest Paper/Velocity/Minecraft version) within MDX documentation pages.\nSOURCE: https://github.com/papermc/docs/blob/main/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: mdxjs\nCODE:\n```\nimport {\n  LATEST_MC_RELEASE,\n  LATEST_PAPER_RELEASE,\n  LATEST_VELOCITY_RELEASE,\n  LATEST_FOLIA_RELEASE,\n  LATEST_WATERFALL_RELEASE,\n  LATEST_USERDEV_RELEASE,\n} from \"/src/utils/versions\";\n\nLatest Paper version is {LATEST_PAPER_RELEASE}.\nLatest Velocity version is {LATEST_VELOCITY_RELEASE}.\nLatest Minecraft version is {LATEST_MC_RELEASE}.\nLatest Folia version is {LATEST_FOLIA_RELEASE}.\nLatest Waterfall version is {LATEST_WATERFALL_RELEASE}.\nLatest `paperweight-userdev` version is {LATEST_USERDEV_RELEASE}.\n```\n\n----------------------------------------\n\nTITLE: Rendering Project Cards Using Astro and Starlight Components - Astro\nDESCRIPTION: This snippet uses Astro's component syntax to render a grid of project link cards. It imports CardGrid, ContributorList, and a custom LinkCard component to display clickable cards describing various PaperMC projects. Each LinkCard includes a title, hyperlink, and an icon, with optional flags such as 'destructive' for styling. The snippet effectively creates a responsive UI block for navigation to project documentation.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/index.mdx#_snippet_0\n\nLANGUAGE: astro\nCODE:\n```\nimport { CardGrid } from \"@astrojs/starlight/components\";\nimport { ContributorList } from \"starlight-contributor-list\";\nimport LinkCard from \"/src/components/LinkCard.astro\";\n\n<CardGrid>\n  <LinkCard title=\"Paper\" href=\"/paper\" icon=\"paper\">\n    High performance Minecraft server that aims to fix gameplay and mechanics inconsistencies.\n  </LinkCard>\n  <LinkCard title=\"Velocity\" href=\"/velocity\" icon=\"velocity\">\n    The modern, next-generation Minecraft server proxy.\n  </LinkCard>\n  <LinkCard title=\"Folia\" href=\"/folia\" icon=\"folia\">\n    A fork of Paper which adds regionized multithreading to the dedicated server.\n  </LinkCard>\n  <LinkCard title=\"Waterfall\" href=\"/waterfall\" destructive icon=\"waterfall\">\n    A discontinued BungeeCord proxy fork that aimed to improve performance and stability.\n  </LinkCard>\n  <LinkCard title=\"Adventure\" href=\"https://docs.advntr.dev/\" icon=\"adventure\">\n    A Java library for server-controllable user interface elements in Minecraft: Java Edition.\n  </LinkCard>\n  <LinkCard title=\"Miscellaneous\" href=\"/misc\" icon=\"random\">\n    Various other documentation and tools.\n  </LinkCard>\n</CardGrid>\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor List Component with GitHub Repo Reference - Astro\nDESCRIPTION: This snippet integrates a ContributorList component from the starlight-contributor-list package to dynamically display a list of contributors based on the specified GitHub repository. The component fetches contributor data associated with 'PaperMC/docs' and renders it within the page, providing community recognition. It requires an active internet connection and GitHub API access for up-to-date contributor information.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/index.mdx#_snippet_1\n\nLANGUAGE: astro\nCODE:\n```\n<ContributorList githubRepo=\"PaperMC/docs\" />\n```\n\n----------------------------------------\n\nTITLE: Creating a Card Grid with an Administrative Link Card\nDESCRIPTION: This snippet renders a 'CardGrid' component containing a 'LinkCard' that links to the 'Administration' section. The 'LinkCard' displays a title and description, guiding users to tutorials and info related to Folia server administration.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/folia/index.mdx#_snippet_1\n\nLANGUAGE: JSX\nCODE:\n```\n<CardGrid>\n  <LinkCard\n    title=\"Administration\"\n    description=\"Information and tutorials regarding the administration of a Folia server.\"\n    href=\"/folia/admin\"\n  />\n</CardGrid>\n```\n\n----------------------------------------\n\nTITLE: Importing ItemCommandConverter component in Svelte\nDESCRIPTION: This code snippet involves importing the 'ItemCommandConverter' Svelte component from its file path, enabling inclusion of the converter UI in a Svelte application. It assumes dependencies on Svelte framework and the component file located at '/src/components/tools/ItemCommandConverter.svelte'.\nSOURCE: https://github.com/papermc/docs/blob/main/src/content/docs/misc/tools/item-command-converter.mdx#_snippet_0\n\nLANGUAGE: Svelte\nCODE:\n```\nimport ItemCommandConverter from \"/src/components/tools/ItemCommandConverter.svelte\";\n```"
  }
]