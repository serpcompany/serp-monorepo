[
  {
    "owner": "nanostores",
    "repo": "nanostores",
    "content": "TITLE: React Integration with useStore (TypeScript)\nDESCRIPTION: This TypeScript/JSX snippet demonstrates how to integrate Nano Stores with React using the `@nanostores/react` package and the `useStore()` hook. It retrieves the value of the `$profile` store and re-renders the component whenever the store changes.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_27\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useStore } from '@nanostores/react' // or '@nanostores/preact'\nimport { $profile } from '../stores/profile.js'\n\nexport const Header = ({ postId }) => {\n  const profile = useStore($profile)\n  return <header>Hi, {profile.name}</header>\n}\n```\n\n----------------------------------------\n\nTITLE: Using Store with React Hook\nDESCRIPTION: This snippet shows how to integrate a Nano Store with a React component using the `useStore` hook from `@nanostores/react`. The hook subscribes the component to the store, causing it to re-render whenever the store's value changes. It imports the `$admins` store and renders a list of admins using the `UserItem` component.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useStore } from '@nanostores/react'\nimport { $admins } from '../stores/admins.js'\n\nexport const Admins = () => {\n  const admins = useStore($admins)\n  return (\n    <ul>\n      {admins.map(user => <UserItem user={user} />)}\n    </ul>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Solid Integration with useStore (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates how to integrate Nano Stores with Solid using the `@nanostores/solid` package and the `useStore()` composable function. It retrieves the value of the `$profile` store and re-renders the component whenever the store changes. Note the need to call `profile()` to access the value.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_30\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useStore } from '@nanostores/solid'\nimport { $profile } from '../stores/profile.js'\n\nexport function Header({ postId }) {\n  const profile = useStore($profile)\n  return <header>Hi, {profile().name}</header>\n}\n```\n\n----------------------------------------\n\nTITLE: Vue Integration with useStore (Vue)\nDESCRIPTION: This Vue snippet demonstrates how to integrate Nano Stores with Vue using the `@nanostores/vue` package and the `useStore()` composable function.  It retrieves the value of the `$profile` store and re-renders the component whenever the store changes. The template displays the profile name.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_28\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { useStore } from '@nanostores/vue'\nimport { $profile } from '../stores/profile.js'\n\nconst props = defineProps(['postId'])\n\nconst profile = useStore($profile)\n</script>\n\n<template>\n  <header>Hi, {{ profile.name }}</header>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Lit Integration with StoreController (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to integrate Nano Stores with Lit using the `@nanostores/lit` package and the `StoreController` reactive controller. It retrieves the value of the `$profile` store and re-renders the component whenever the store changes.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nimport { StoreController } from '@nanostores/lit'\nimport { $profile } from '../stores/profile.js'\n\n@customElement('my-header')\nclass MyElement extends LitElement {\n  @property()\n\n  private profileController = new StoreController(this, $profile)\n\n  render() {\n    return html`<header>Hi, ${profileController.value.name}</header>`\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Svelte Integration with Store Contract (Svelte)\nDESCRIPTION: This Svelte snippet demonstrates how to integrate Nano Stores with Svelte using Svelte's store contract. It uses the `$` prefix to access the store's value and automatically subscribe to changes.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_29\n\nLANGUAGE: svelte\nCODE:\n```\n<script>\n  import { profile } from '../stores/profile.js'\n</script>\n\n<header>Hi, {$profile.name}</header>\n```\n\n----------------------------------------\n\nTITLE: Creating a Computed Store in TypeScript\nDESCRIPTION: This snippet illustrates how to create a computed store using the `computed` function. Computed stores derive their value from one or more other stores. The provided function is executed whenever the source store(s) change, and the result becomes the new value of the computed store. Here, `$admins` is computed from `$users`.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { computed } from 'nanostores'\nimport { $users } from './users.js'\n\nexport const $admins = computed($users, users => users.filter(i => i.isAdmin))\n```\n\n----------------------------------------\n\nTITLE: Creating a Computed Store with TypeScript\nDESCRIPTION: This snippet demonstrates how to create a computed store in Nano Stores using the `computed` function. It filters a list of users based on the `isAdmin` property, updating whenever the `$users` store changes. The `$users` store is imported from a separate file.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { computed } from 'nanostores'\nimport { $users } from './users.js'\n\nexport const $admins = computed($users, users => {\n  // This callback will be called on every `users` changes\n  return users.filter(user => user.isAdmin)\n})\n```\n\n----------------------------------------\n\nTITLE: Computed Store with Async Task in JavaScript\nDESCRIPTION: This JavaScript snippet shows how to use `computed` with an asynchronous function using `task()`. It fetches user data from an API based on a user ID stored in `$userId`.  The `task` function ensures proper handling of the asynchronous operation within the computed store.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\nimport { computed, task } from 'nanostores'\n\nimport { $userId } from './users.js'\n\nexport const $user = computed($userId, userId => task(async () => {\n  const response = await fetch(`https://my-api/users/${userId}`)\n  return response.json()\n}))\n```\n\n----------------------------------------\n\nTITLE: Reducing `get()` Usage in UI (Diff)\nDESCRIPTION: This code snippet shows how to reduce the usage of `get()` in UI components when working with Nano Stores. It replaces direct access to the store's value using `get()` with the `useStore()` hook, which subscribes to the store and triggers re-renders when the store's value changes. This ensures that the UI always displays the actual data.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_41\n\nLANGUAGE: diff\nCODE:\n```\n- const { userId } = $profile.get()\n+ const { userId } = useStore($profile)\n```\n\n----------------------------------------\n\nTITLE: Computed Store from Multiple Stores (TypeScript)\nDESCRIPTION: This TypeScript snippet showcases how to create a computed store that depends on multiple stores. It calculates `$newPosts` based on `$lastVisit` and `$posts`, filtering posts published after the last visit. This provides a way to create derived data based on changes in several source stores.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport { $lastVisit } from './lastVisit.js'\nimport { $posts } from './posts.js'\n\nexport const $newPosts = computed([$lastVisit, $posts], (lastVisit, posts) => {\n  return posts.filter(post => post.publishedAt > lastVisit)\n})\n```\n\n----------------------------------------\n\nTITLE: Batched Store Update in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates the usage of `batched` to update a store only at the end of the current tick, even if its dependencies change multiple times during the tick. It creates a `$link` store that depends on `$sortBy` and `$categoryId`. The `resetFilters` function shows how multiple stores can be updated without triggering multiple updates to the `batched` store.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport { batched } from 'nanostores'\n\nconst $sortBy = atom('id')\nconst $categoryId = atom('')\n\nexport const $link = batched([$sortBy, $categoryId], (sortBy, categoryId) => {\n  return `/api/entities?sortBy=${sortBy}&categoryId=${categoryId}`\n})\n\n// `batched` will update only once even you changed two stores\nexport function resetFilters () {\n  $sortBy.set('date')\n  $categoryIdFilter.set('1')\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Effect with JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to use `effect` to subscribe to multiple atoms at once. It sets up an interval based on `$enabled` and `$interval`, sending a ping at the specified interval when enabled. The effect returns a cleanup function to clear the interval when the effect is cancelled or the dependencies change.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\nconst $enabled = atom(true)\nconst $interval = atom(1000)\n\nconst cancelPing = effect([$enabled, $interval], (enabled, interval) => {\n  if (!enabled) return\n\n  const intervalId = setInterval(() => {\n    sendPing()\n  }, interval)\n\n  return () => {\n    clearInterval(intervalId)\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Deep Map Usage Example\nDESCRIPTION: This snippet demonstrates the usage of `deepMap` for managing deeply nested objects and arrays with fine-grained reactivity. It also showcases `listenKeys` for subscribing to specific nested properties.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { deepMap, listenKeys } from 'nanostores'\n\nexport const $profile = deepMap({\n  hobbies: [\n    {\n      name: 'woodworking',\n      friends: [{ id: 123, name: 'Ron Swanson' }]\n    }\n  ],\n  skills: [\n    [\n      'Carpentry',\n      'Sanding'\n    ],\n    [\n      'Varnishing'\n    ]\n  ]\n})\n\nlistenKeys($profile, ['hobbies[0].friends[0].name', 'skills[0][0]'])\n\n// Won't fire subscription\n$profile.setKey('hobbies[0].name', 'Scrapbooking')\n$profile.setKey('skills[0][1]', 'Staining')\n\n// But those will fire subscription\n$profile.setKey('hobbies[0].friends[0].name', 'Leslie Knope')\n$profile.setKey('skills[0][0]', 'Whittling')\n```\n\n----------------------------------------\n\nTITLE: Using Tasks with onMount in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to use `task` within the `onMount` lifecycle event to perform an asynchronous operation during store initialization.  It loads a post when the `$post` store is mounted.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nimport { task } from 'nanostores'\n\nonMount($post, () => {\n  task(async () => {\n    $post.set(await loadPost())\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Separating Store Changes and Reactions (Diff)\nDESCRIPTION: This code snippet illustrates the recommended practice of separating store changes from reactions in Nano Stores. It contrasts directly calling a side effect function (`printCounter`) after setting a new value in the store with using the `listen` method to react to store changes. This separation makes the UI ready for any source of store changes.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_40\n\nLANGUAGE: diff\nCODE:\n```\n  function increase() {\n    $counter.set($counter.get() + 1)\n-   printCounter(store.get())\n  }\n\n+ $counter.listen(counter => {\n+   printCounter(counter)\n+ })\n```\n\n----------------------------------------\n\nTITLE: Initializing Atom Store with Current Time (TypeScript)\nDESCRIPTION: This code snippet initializes an atom store `$currentTime` in Nano Stores with the current timestamp. It uses `onMount` to start an interval that updates the store with the current time every second, providing a reactive time source. The interval is cleared on unmount to prevent memory leaks.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom, onMount } from 'nanostores'\n\nexport const $currentTime = atom<number>(Date.now())\n\nonMount($currentTime, () => {\n  $currentTime.set(Date.now())\n  const updating = setInterval(() => {\n    $currentTime.set(Date.now())\n  }, 1000)\n  return () => {\n    clearInterval(updating)\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Lazy Store with onMount\nDESCRIPTION: This snippet demonstrates how to create a lazy store using `onMount`. The callback is executed when the store is mounted (i.e., has one or more listeners). The returned function is executed when the store is disabled (i.e., has no listeners).\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { onMount } from 'nanostores'\n\nonMount($profile, () => {\n  // Mount mode\n  return () => {\n    // Disabled mode\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Using onSet to Validate Store Updates (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to use the `onSet` event to validate new values before they are applied to the store. If the new value fails validation, the `abort()` function is called to prevent the update.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nimport { onSet } from 'nanostores'\n\nonSet($store, ({ newValue, abort }) => {\n  if (!validate(newValue)) {\n    abort()\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Atom Store Changes\nDESCRIPTION: This snippet demonstrates subscribing to changes in an atom store using the `subscribe` method. The provided callback function is executed whenever the store's value changes. The callback receives the new value and the old value as arguments. `store.subscribe(cb)` in contrast with `store.listen(cb)` also call listeners immediately during the subscription.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst unbindListener = $counter.subscribe((value, oldValue) => {\n  console.log(`counter value changed from ${oldValue} to ${value}`)\n})\n```\n\n----------------------------------------\n\nTITLE: Listening to Map Store Key Changes\nDESCRIPTION: This TypeScript snippet illustrates how to listen for changes to specific keys within a map store using the `listen` method.  Store’s listeners will receive third argument with changed key.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n$profile.listen((profile, oldProfile, changed) => {\n  console.log(`${changed} new value ${profile[changed]}`)\n})\n```\n\n----------------------------------------\n\nTITLE: Listening to Specific Map Store Keys\nDESCRIPTION: This snippet shows how to listen for changes to a specific set of keys in a map store using `listenKeys`. The callback is only executed when one of the specified keys changes.  You can also listen for specific keys of the store being changed, using `listenKeys` and `subscribeKeys`.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nlistenKeys($profile, ['name'], (value, oldValue, changed) => {\n  console.log(`$profile.Name new value ${value.name}`)\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing an Atom Store in TypeScript\nDESCRIPTION: This snippet demonstrates how to create an atom store using the `atom` function from the `nanostores` library. An atom store holds a single value and is suitable for simple data types like strings, numbers, or arrays. The initial value is passed as an argument to the `atom` function.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from 'nanostores'\n\nexport const $users = atom<User[]>([])\n\nexport function addUser(user: User) {\n  $users.set([...$users.get(), user]);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Typed Atom Store\nDESCRIPTION: This snippet shows how to create a typed atom store in TypeScript. By specifying the type parameter when calling `atom`, you ensure that the store only holds values of that specific type. This improves type safety and helps prevent errors.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport type LoadingStateValue = 'empty' | 'loading' | 'loaded'\n\nexport const $loadingState = atom<LoadingStateValue>('empty')\n```\n\n----------------------------------------\n\nTITLE: Creating Map Store\nDESCRIPTION: This TypeScript snippet showcases how to create a map store using the `map` function. A map store is designed to hold objects with key-value pairs. The initial object is passed as the argument during store creation.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { map } from 'nanostores'\n\nexport const $profile = map({\n  name: 'anonymous'\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Typed Map Store\nDESCRIPTION: This TypeScript snippet demonstrates creating a map store with a specific type. This ensures type safety by enforcing that the store only holds objects conforming to the defined interface.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ProfileValue {\n  name: string,\n  email?: string\n}\n\nexport const $profile = map<ProfileValue>({\n  name: 'anonymous'\n})\n```\n\n----------------------------------------\n\nTITLE: Creating an Atom Store with Initial Value\nDESCRIPTION: This TypeScript snippet demonstrates initializing an atom store with a default value. The `atom` function creates the store, and passing the initial value sets its starting state. The type can be optionally defined using generics.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from 'nanostores'\n\nexport const $counter = atom(0)\n```\n\n----------------------------------------\n\nTITLE: Updating Atom Store Value\nDESCRIPTION: This snippet shows how to update the value of an atom store using the `set` method. The new value is passed as an argument. You can retrieve the current value using `get` method and manipulate it.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n$counter.set($counter.get() + 1)\n```\n\n----------------------------------------\n\nTITLE: Updating Map Store Key\nDESCRIPTION: This TypeScript snippet shows how to update a specific key-value pair within a map store using the `setKey` method. The key and the new value are passed as arguments.  `store.set(object)` or `store.setKey(key, value)` methods will change the store.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n$profile.setKey('name', 'Kazimir Malevich')\n```\n\n----------------------------------------\n\nTITLE: Removing Optional Key from Map Store\nDESCRIPTION: This TypeScript snippet demonstrates how to remove an optional key from a map store by setting its value to `undefined`.  Setting `undefined` will remove optional key:\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n$profile.setKey('email', undefined)\n```\n\n----------------------------------------\n\nTITLE: Vanilla JS Subscription with Store#subscribe() (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates how to use `Store#subscribe()` to subscribe to changes in a store and receive its value immediately. The callback function is called initially and on every subsequent change.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_33\n\nLANGUAGE: javascript\nCODE:\n```\nimport { $profile } from '../stores/profile.js'\n\n$profile.subscribe(profile => {\n  console.log(`Hi, ${profile.name}`)\n})\n```\n\n----------------------------------------\n\nTITLE: Vanilla JS Listen with Store#listen() (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates how to use `Store#listen()` to listen for changes in a store.  Unlike `subscribe`, the callback is only called on *subsequent* changes, not initially.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_34\n\nLANGUAGE: javascript\nCODE:\n```\nfunction render () {\n  console.log(`${$post.get().title} for ${$profile.get().name}`)\n}\n\n$profile.listen(render)\n$post.listen(render)\nrender()\n```\n\n----------------------------------------\n\nTITLE: Map Creator Example in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates the usage of `mapCreator` to create multiple similar stores, acting like a class in OOP. Each `User` instance gets its own store with initial loading state and then fetches user data based on the provided ID.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_23\n\nLANGUAGE: javascript\nCODE:\n```\nconst User = mapCreator((store, id) => {\n  store.set({ id, isLoading: true })\n  fetchUser(id).then(data => {\n    store.set({ id, isLoading: false, data })\n  })\n})\n\nlet user1 = User('1')\n```\n\n----------------------------------------\n\nTITLE: Using StoreValue Utility Type\nDESCRIPTION: This TypeScript snippet demonstrates how to use the `StoreValue` utility type to extract the type of a store's value. This is helpful when you need to refer to the store's value type elsewhere in your code.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { StoreValue } from 'nanostores'\n\ntype Value = StoreValue<typeof $loadingState> //=> LoadingStateValue\n```\n\n----------------------------------------\n\nTITLE: Server-Side Rendering Example (JavaScript)\nDESCRIPTION: This JavaScript snippet illustrates how to handle server-side rendering with Nano Stores. It sets initial settings and opens a route if the code is running on the server. It also shows how to wait for async operations using `allTasks()` before rendering the page.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_35\n\nLANGUAGE: javascript\nCODE:\n```\nif (isServer) {\n  $settings.set(initialSettings)\n  $router.open(renderingPageURL)\n}\n\n```\n\nLANGUAGE: jsx\nCODE:\n```\nimport { allTasks } from 'nanostores'\n\n$post.listen(() => {}) // Move store to active mode to start data loading\nawait allTasks()\n\nconst html = ReactDOMServer.renderToString(<App />)\n```\n\n----------------------------------------\n\nTITLE: Testing with cleanStores and keepMount (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to use `cleanStores` and `keepMount` for testing Nano Stores. `cleanStores` resets the stores after each test, and `keepMount` keeps the store active during the test.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nimport { cleanStores, keepMount } from 'nanostores'\nimport { $profile } from './profile.js'\n\nafterEach(() => {\n  cleanStores($profile)\n})\n\nit('is anonymous from the beginning', () => {\n  keepMount($profile)\n  expect($profile.get()).toEqual({ name: 'anonymous' })\n})\n```\n\n----------------------------------------\n\nTITLE: Testing Lazy Store with keepMount and cleanStores\nDESCRIPTION: This snippet shows how to test a lazy store using `keepMount` and `cleanStores`. `keepMount` prevents the store from being disabled during the test. `cleanStores` unmounts the store after the test. Call `keepMount()` to test store’s lazy initializer in tests and `cleanStores`\nto unmount them after test.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nimport { cleanStores, keepMount } from 'nanostores'\nimport { $profile } from './profile.js'\n\nafterEach(() => {\n  cleanStores($profile)\n})\n\nit('is anonymous from the beginning', () => {\n  keepMount($profile)\n  // Checks\n})\n```\n\n----------------------------------------\n\nTITLE: Testing with allTasks (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to use `allTasks()` in tests to wait for all asynchronous operations in stores to complete before making assertions.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nimport { allTasks } from 'nanostores'\n\nit('saves user', async () => {\n  saveUser()\n  await allTasks()\n  expect(analyticsEvents.get()).toEqual(['user:save'])\n})\n```\n\n----------------------------------------\n\nTITLE: Waiting for All Tasks in JSX\nDESCRIPTION: This JSX snippet demonstrates how to use `allTasks()` to wait for all ongoing asynchronous operations to complete before rendering a component, typically during server-side rendering or testing. An empty listener is added to move the store to active mode.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_25\n\nLANGUAGE: jsx\nCODE:\n```\nimport { allTasks } from 'nanostores'\n\n$post.listen(() => {}) // Move store to active mode to start data loading\nawait allTasks()\n\nconst html = ReactDOMServer.renderToString(<App />)\n```\n\n----------------------------------------\n\nTITLE: Angular Integration with NanostoresService (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to integrate Nano Stores with Angular using the `@nanostores/angular` package and the `NanostoresService`. It uses `useStore()` to get an Observable from the `$profile` store, switching to the `User` store based on the user ID. The template displays the user's name.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\n// Component:\nimport { Component } from '@angular/core'\nimport { NanostoresService } from '@nanostores/angular'\nimport { Observable, switchMap } from 'rxjs'\n\nimport { profile } from '../stores/profile'\nimport { IUser, User } from '../stores/user'\n\n@Component({\n  selector: \"app-root\",\n  template: '<p *ngIf=\"(currentUser$ | async) as user\">{{ user.name }}</p>'\n})\nexport class AppComponent {\n  currentUser$: Observable<IUser> = this.nanostores.useStore(profile)\n    .pipe(switchMap(userId => this.nanostores.useStore(User(userId))))\n\n  constructor(private nanostores: NanostoresService) { }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Computed Store for User In-App Time (TypeScript)\nDESCRIPTION: This code creates a computed store `$userInApp` in Nano Stores, derived from the `$currentTime` store. It calculates the time a user has been in the application by subtracting the application start time from the current time. This provides a reactive value that updates automatically as the current time changes.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nimport { computed } from 'nanostores'\nimport { $currentTime } from './currentTime.js'\n\nconst appStarted = Date.now()\n\nexport const $userInApp = computed($currentTime, currentTime => {\n  return currentTime - appStarted\n})\n```\n\n----------------------------------------\n\nTITLE: Installing Nano Stores via npm\nDESCRIPTION: This snippet provides the command to install the `nanostores` package using npm. This is a prerequisite for using Nano Stores in your project.\nSOURCE: https://github.com/nanostores/nanostores/blob/main/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nnpm install nanostores\n```"
  }
]