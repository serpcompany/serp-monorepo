[
  {
    "owner": "dfinity",
    "repo": "stable-structures",
    "content": "TITLE: Complete Internet Computer Canister Using Stable Structures\nDESCRIPTION: A fully working canister example that implements a persistent key-value store using StableBTreeMap. It demonstrates thread_local initialization of the memory manager and map, along with query and update methods for interacting with the data.\nSOURCE: https://github.com/dfinity/stable-structures/blob/main/README.md#2025-04-20_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_stable_structures::memory_manager::{MemoryId, MemoryManager, VirtualMemory};\nuse ic_stable_structures::{DefaultMemoryImpl, StableBTreeMap};\nuse std::cell::RefCell;\n\ntype Memory = VirtualMemory<DefaultMemoryImpl>;\n\nthread_local! {\n    // The memory manager is used for simulating multiple memories. Given a `MemoryId` it can\n    // return a memory that can be used by stable structures.\n    static MEMORY_MANAGER: RefCell<MemoryManager<DefaultMemoryImpl>> =\n        RefCell::new(MemoryManager::init(DefaultMemoryImpl::default()));\n\n    // Initialize a `StableBTreeMap` with `MemoryId(0)`.\n    static MAP: RefCell<StableBTreeMap<u128, u128, Memory>> = RefCell::new(\n        StableBTreeMap::init(\n            MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(0))),\n        )\n    );\n}\n\n// Retrieves the value associated with the given key if it exists.\n#[ic_cdk_macros::query]\nfn get(key: u128) -> Option<u128> {\n    MAP.with(|p| p.borrow().get(&key))\n}\n\n// Inserts an entry into the map and returns the previous value of the key if it exists.\n#[ic_cdk_macros::update]\nfn insert(key: u128, value: u128) -> Option<u128> {\n    MAP.with(|p| p.borrow_mut().insert(key, value))\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StableBTreeMap with Custom Types in DFINITY\nDESCRIPTION: This example demonstrates how to use StableBTreeMap with custom struct types. It defines a UserProfile struct with age and name fields, inserts data, upgrades the canister, and retrieves the custom type data after the upgrade.\nSOURCE: https://github.com/dfinity/stable-structures/blob/main/examples/README.md#2025-04-20_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Insert some data into the basic_example canister.\ndfx canister call custom_types_example insert '(1, record { age = 32; name = \"Some Name\"})'\ndfx canister call custom_types_example insert '(2, record { age = 48; name = \"Other Name\"})'\n\n# Upgrade the canister, which clears all the data in the heap.\ndfx deploy --upgrade-unchanged custom_types_example\n\n# Even though the canister has been upgraded and its heap is cleared,\n# querying the canister should still return the data stored prior to\n# the upgrade.\n$ dfx canister call custom_types_example get '(1)'\n> (opt record { age = 32 : nat8; name = \"Some Name\" })\n\ndfx canister call custom_types_example get '(2)'\n> (opt record { age = 48 : nat8; name = \"Other Name\" })\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using StableBTreeMap with Primitive Types in DFINITY\nDESCRIPTION: This example demonstrates how to initialize a StableBTreeMap with primitive types (natural numbers), insert data, upgrade the canister, and retrieve data after the upgrade. It showcases the persistence of data across canister upgrades.\nSOURCE: https://github.com/dfinity/stable-structures/blob/main/examples/README.md#2025-04-20_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Start the replica, running in the background\ndfx start --background\n\n# Deploys the examples.\ndfx deploy\n\n# Insert some data into the basic_example canister.\ndfx canister call basic_example insert '(1:nat, 2:nat)'\ndfx canister call basic_example insert '(3:nat, 4:nat)'\n\n# Upgrade the canister, which clears all the data in the heap.\ndfx deploy --upgrade-unchanged basic_example\n\n# Even though the canister has been upgraded and its heap is cleared,\n# querying the canister should still return the data stored prior to\n# the upgrade.\ndfx canister call basic_example get '(1:nat)'\n> (opt (2 : nat))\n\ndfx canister call basic_example get '(3:nat)'\n> (opt (4 : nat))\n```\n\n----------------------------------------\n\nTITLE: Using Stable Structures in Dfinity Canisters with Terminal Commands\nDESCRIPTION: A sequence of terminal commands demonstrating how to use stable structures to maintain data across canister upgrades. The example shows inserting data into a stable structure, setting heap data, upgrading the canister, and then retrieving the data to verify persistence.\nSOURCE: https://github.com/dfinity/stable-structures/blob/main/examples/src/quick_start/README.md#2025-04-20_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndfx start --background --clean\n\n# Insert some data into the quick_start canister.\ndfx canister call quick_start stable_insert '(1:nat, 2:nat)'\ndfx canister call quick_start stable_insert '(3:nat, 4:nat)'\ndfx canister call quick_start set_heap_data '(vec {1:nat8; 2:nat8; 3:nat8})'\n\n# Upgrade the canister, which clears all the data in the heap.\ndfx deploy --upgrade-unchanged quick_start\n\n# Even though the canister has been upgraded and its heap is cleared,\n# querying the canister should still return the data stored prior to\n# the upgrade.\ndfx canister call quick_start stable_get '(1:nat)'\n> (opt (2 : nat))\n\ndfx canister call quick_start stable_get '(3:nat)'\n> (opt (4 : nat))\n\ndfx canister call quick_start get_heap_data\n> (blob \"\\01\\02\\03\")\n```\n\n----------------------------------------\n\nTITLE: Using MemoryManager to Create Multiple Virtual Memories\nDESCRIPTION: This corrected example shows how to use MemoryManager to create separate virtual memories from a single underlying memory. This allows multiple stable structures to coexist without corrupting each other's data.\nSOURCE: https://github.com/dfinity/stable-structures/blob/main/README.md#2025-04-20_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_stable_structures:{\n   memory_manager::{MemoryId, MemoryManager},\n   BTreeMap, DefaultMemoryImpl,\n};\nlet mem_mgr = MemoryManager::init(DefaultMemoryImpl::default());\nlet mut map_1: BTreeMap<u64, u64, _> = BTreeMap::init(mem_mgr.get(MemoryId::new(0)));\nlet mut map_2: BTreeMap<u64, u64, _> = BTreeMap::init(mem_mgr.get(MemoryId::new(1)));\n\nmap_1.insert(1, 2);\nmap_2.insert(1, 3);\nassert_eq!(map_1.get(&1), Some(2)); // Succeeds, as expected.\n```\n\n----------------------------------------\n\nTITLE: Using StableBTreeMap with Vectors and Strings in DFINITY\nDESCRIPTION: This example shows how to use StableBTreeMap with strings as keys and vectors (blobs) as values. It demonstrates inserting data, upgrading the canister, and retrieving data after the upgrade, highlighting the persistence of complex data types.\nSOURCE: https://github.com/dfinity/stable-structures/blob/main/examples/README.md#2025-04-20_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Start the replica, running in the background\ndfx start --background\n\n# Deploys the examples.\ndfx deploy\n\n# Insert some data.\ndfx canister call vecs_and_strings insert '(\"alice\", blob \"12341234\")'\ndfx canister call vecs_and_strings insert '(\"bob\", blob \"789789789\")'\n\n# Upgrade the canister, which clears all the data in the heap.\ndfx deploy --upgrade-unchanged vecs_and_strings\n\n# Even though the canister has been upgraded and its heap is cleared,\n# querying the canister should still return the data stored prior to\n# the upgrade.\ndfx canister call vecs_and_strings get '(\"alice\")'\n> (opt blob \"12341234\") \n\ndfx canister call vecs_and_strings get '(\"bob\")'\n> (opt blob \"789789789\")\n```\n\n----------------------------------------\n\nTITLE: Initializing BTreeMap with DefaultMemoryImpl in Rust\nDESCRIPTION: A basic example showing how to initialize a BTreeMap stable structure using DefaultMemoryImpl. This demonstrates inserting a key-value pair and retrieving it, showcasing the fundamental usage pattern.\nSOURCE: https://github.com/dfinity/stable-structures/blob/main/README.md#2025-04-20_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_stable_structures::{BTreeMap, DefaultMemoryImpl};\nlet mut map: BTreeMap<u64, u64, _> = BTreeMap::init(DefaultMemoryImpl::default());\n\nmap.insert(1, 2);\nassert_eq!(map.get(&1), Some(2));\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Asset Structure with CBOR Serialization\nDESCRIPTION: Defines a basic Asset structure with CBOR serialization implementation using the Storable trait. The structure contains binary contents and implements serialization/deserialization methods for stable storage.\nSOURCE: https://github.com/dfinity/stable-structures/blob/main/docs/schema-upgrades.md#2025-04-20_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Serialize, Deserialize, CandidType)]\nstruct Asset {\n    // The contents of the asset.\n    contents: Vec<u8>,\n}\n\nimpl Storable for Asset {\n    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {\n        let mut bytes = vec![];\n        ciborium::ser::into_writer(&self, &mut bytes).unwrap();\n        Cow::Owned(bytes)\n    }\n\n    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {\n        ciborium::de::from_reader(&*bytes).expect(\"deserialization must succeed.\")\n    }\n\n    const BOUND: Bound = Bound::Unbounded;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Optional Fields to Asset Structure\nDESCRIPTION: Shows how to add optional fields to the Asset structure using Option<T>, combining both the timestamp and a new uploaded_by field for tracking asset ownership.\nSOURCE: https://github.com/dfinity/stable-structures/blob/main/docs/schema-upgrades.md#2025-04-20_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Serialize, Deserialize, CandidType)]\nstruct Asset {\n    // The contents of the asset.\n    contents: Vec<u8>,\n\n    // The timestamp the asset was created at.\n    #[serde(default)]\n    created_at: u64,\n\n    // The username of the uploader.\n    uploaded_by: Option<String>,\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Default Timestamp Field to Asset Structure\nDESCRIPTION: Demonstrates adding a new created_at timestamp field to the Asset structure with a default value using serde attributes for backward compatibility.\nSOURCE: https://github.com/dfinity/stable-structures/blob/main/docs/schema-upgrades.md#2025-04-20_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Serialize, Deserialize)]\nstruct Asset {\n    // The contents of the asset.\n    contents: Vec<u8>,\n\n    // The timestamp the asset was created at.\n    #[serde(default)]\n    created_at: u64,\n}\n```\n\n----------------------------------------\n\nTITLE: Failing Example of Shared Memory in Stable Structures\nDESCRIPTION: This example demonstrates why stable structures cannot share memories. When two BTreeMaps use the same memory implementation, they corrupt each other's data as they both write to the same underlying storage.\nSOURCE: https://github.com/dfinity/stable-structures/blob/main/README.md#2025-04-20_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_stable_structures::{BTreeMap, DefaultMemoryImpl};\nlet mut map_1: BTreeMap<u64, u64, _> = BTreeMap::init(DefaultMemoryImpl::default());\nlet mut map_2: BTreeMap<u64, u64, _> = BTreeMap::init(DefaultMemoryImpl::default());\n\nmap_1.insert(1, 2);\nmap_2.insert(1, 3);\nassert_eq!(map_1.get(&1), Some(2)); // This assertion fails.\n```\n\n----------------------------------------\n\nTITLE: Cargo Dependencies for a Stable Structures Canister\nDESCRIPTION: TOML configuration showing the required dependencies for implementing a canister using stable structures. This includes the Internet Computer SDK and the stable structures library.\nSOURCE: https://github.com/dfinity/stable-structures/blob/main/README.md#2025-04-20_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nic-cdk = \"0.6.8\"\nic-cdk-macros = \"0.6.8\"\nic-stable-structures = \"0.5.6\"\n```\n\n----------------------------------------\n\nTITLE: Storing Proptest Failure Case Seed\nDESCRIPTION: This snippet shows a stored seed for a specific failure case in proptest. It includes the seed value and a comment describing the minimal input that caused the failure.\nSOURCE: https://github.com/dfinity/stable-structures/blob/main/proptest-regressions/writer/tests.txt#2025-04-20_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\ncc 69402fe19e656efe27db18876b751c19df35fc37ff22c942310579cc7b81862d\n# shrinks to buffer_size = None, bytes = [], offset = 1\n```\n\n----------------------------------------\n\nTITLE: Committing Changes with Descriptive Message\nDESCRIPTION: Command to commit staged changes to the local Git repository with a meaningful message describing the fix or feature being implemented.\nSOURCE: https://github.com/dfinity/stable-structures/blob/main/Contributing.md#2025-04-20_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit commit -m \"Description of the fix being committed.\"\n```\n\n----------------------------------------\n\nTITLE: Creating a Branch for Fixes in Git\nDESCRIPTION: Command to create a new Git branch for implementing fixes or features. This is part of the contribution workflow and precedes making changes to repository files.\nSOURCE: https://github.com/dfinity/stable-structures/blob/main/Contributing.md#2025-04-20_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout -b my-branch-name-here\n```\n\n----------------------------------------\n\nTITLE: Pushing Changes to Remote Repository\nDESCRIPTION: Command to push the committed changes to the remote GitHub repository, which is necessary before creating a pull request.\nSOURCE: https://github.com/dfinity/stable-structures/blob/main/Contributing.md#2025-04-20_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit push origin my-branch-name-here\n```\n\n----------------------------------------\n\nTITLE: Adding Changed Files to Git Index\nDESCRIPTION: Command to stage modified files to the Git index. This prepares the changes for commit as part of the pull request process.\nSOURCE: https://github.com/dfinity/stable-structures/blob/main/Contributing.md#2025-04-20_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit add path-to-changed-file\n```"
  }
]