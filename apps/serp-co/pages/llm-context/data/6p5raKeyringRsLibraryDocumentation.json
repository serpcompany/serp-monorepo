[
  {
    "owner": "6p5ra",
    "repo": "keyring-rs-library-documentation",
    "content": "TITLE: Demonstrating Password and Secret Handling with keyring::Entry in Rust\nDESCRIPTION: This Rust code snippet illustrates how to use the `keyring::Entry` struct from the `keyring` crate to manage both text passwords and arbitrary binary data (secrets) in the system's secure credential store. It demonstrates creating an entry for a specific service and user, storing/retrieving/deleting a text password, and then storing/retrieving/deleting a binary secret (byte slice). The code utilizes `set_password`, `get_password`, `set_secret`, `get_secret`, and `delete_credential` methods, and is structured within a `main` function returning a `Result<(), keyring::Error>` to handle potential errors.\nSOURCE: https://github.com/6p5ra/keyring-rs-library-documentation/blob/main/keyring-rs.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse keyring::Entry;\n\nfn main() -> Result<(), keyring::Error> {\n    // Create the same Entry as before\n    let entry = Entry::new(\"Super Productive App\", \"alice\")?;\n\n    // -- Password Handling (Text) --\n    println!(\"Handling password (text)...\");\n    let my_password = \"super-secret-text-password\";\n    entry.set_password(my_password)?;\n    println!(\"Password stored.\");\n\n    let retrieved_password = entry.get_password()?;\n    println!(\"Retrieved password: {}\", retrieved_password);\n    assert_eq!(my_password, retrieved_password);\n    println!(\"Password matches!\");\n\n    // Clean up the password entry before trying the secret\n    entry.delete_credential()?;\n    println!(\"Password deleted.\");\n\n    // -- Secret Handling (Binary Data) --\n    println!(\"\\nHandling secret (binary data)...\");\n    // Let's imagine this is some non-text token or key\n    let my_secret_data: &[u8] = &[0xDE, 0xAD, 0xBE, 0xEF, 0x12, 0x34];\n    entry.set_secret(my_secret_data)?;\n    println!(\"Secret stored.\");\n\n    let retrieved_secret: Vec<u8> = entry.get_secret()?;\n    // We print the bytes as hex for readability\n    println!(\"Retrieved secret (bytes): {:X?}\", retrieved_secret);\n    assert_eq!(my_secret_data, retrieved_secret.as_slice());\n    println!(\"Secret matches!\");\n\n    // Clean up the secret entry\n    entry.delete_credential()?;\n    println!(\"Secret deleted.\");\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Storing, Retrieving, and Deleting Credentials with keyring-rs in Rust\nDESCRIPTION: This Rust snippet demonstrates how to use the keyring-rs library's Entry API to securely store, retrieve, and delete a user's password associated with a service and username. It requires the `keyring` crate and handles errors using Rust's Result type. The snippet shows creating an Entry instance, saving a password, retrieving it for verification, and deleting the stored credential. This example is portable and works identically across supported platforms without platform-specific code.\nSOURCE: https://github.com/6p5ra/keyring-rs-library-documentation/blob/main/keyring-rs.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse keyring::Entry;\n\nfn main() -> Result<(), keyring::Error> {\n    // 1. Create an Entry\n    println!(\"Creating an Entry for service='MyWebApp', user='testuser'\");\n    let entry = Entry::new(\"MyWebApp\", \"testuser\")?;\n\n    // 2. Store a password\n    let my_secret = \"SuperSecure123\";\n    println!(\"Storing the password...\");\n    entry.set_password(my_secret)?; // Uses keyring-rs 'button'\n    println!(\"Password stored!\");\n\n    // 3. Retrieve the password\n    println!(\"Retrieving the password...\");\n    let retrieved = entry.get_password()?; // Uses keyring-rs 'button'\n    println!(\"Retrieved: {}\", retrieved);\n    assert_eq!(my_secret, retrieved);\n\n    // 4. Delete the password\n    println!(\"Deleting the password...\");\n    entry.delete_credential()?; // Uses keyring-rs 'button'\n    println!(\"Password deleted.\");\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit error handling with keyring-rs in Rust using match\nDESCRIPTION: Demonstrates explicit error handling in Rust when calling `entry.get_password()`. It matches on the `Result` to differentiate between a successful password retrieval (`Ok`) and various error scenarios (`Err`) distinguished by the `keyring::Error` variants like `NoCredentialFound` and `BackendNotAvailable`. This method provides granular control over error responses, allowing specific application flows based on error type.\nSOURCE: https://github.com/6p5ra/keyring-rs-library-documentation/blob/main/keyring-rs.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse keyring::{Entry, Error}; // Import Error too!\n\nfn main() -> Result<(), Error> {\n    // Create an Entry for something we KNOW doesn't exist yet\n    let entry = Entry::new(\"NonExistentService\", \"no_user\")?;\n    println!(\"Attempting to get a password that doesn't exist...\");\n\n    // Try to get the password\n    match entry.get_password() {\n        Ok(password) => {\n            // This part likely won't run in this example\n            println!(\"Unexpectedly found a password: {}\", password);\n        }\n        Err(error) => {\n            // An error occurred! Let's check which kind.\n            println!(\"Got an error, as expected: {}\", error);\n\n            // We can check the specific error variant\n            match error {\n                Error::NoCredentialFound => {\n                    println!(\"Specific Error: No credential found. Perfect!\");\n                    // Here you might prompt the user to enter the password for the first time.\n                }\n                // Handle other specific errors if needed\n                Error::BackendNotAvailable => {\n                     println!(\"Specific Error: The system's credential store isn't running.\");\n                     // Maybe show an error message and exit.\n                }\n                // Use a catch-all for other errors\n                _ => {\n                    println!(\"Specific Error: An unexpected keyring error occurred.\");\n                    // Log the error or show a generic failure message.\n                }\n            }\n        }\n    }\n\n    // Note: We return Ok(()) because we successfully *handled* the error situation.\n    // If the error was unrecoverable, we might have returned the Err itself.\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Storing a Password Using keyring-rs in Rust\nDESCRIPTION: Demonstrates a basic usage of the keyring-rs Rust library to securely store a password for a given application and user. No platform-specific code is needed: the library automatically selects the right backend for your OS. The example requires the keyring crate and expects the main function to handle Result, printing a confirmation on success. Credentials for service \"MyCoolApp\" and user \"user@example.com\" are stored with the password \"my-secret-password\".\nSOURCE: https://github.com/6p5ra/keyring-rs-library-documentation/blob/main/keyring-rs.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse keyring::Entry;\n\nfn main() -> Result<(), keyring::Error> {\n    let entry = Entry::new(\"MyCoolApp\", \"user@example.com\")?;\n    entry.set_password(\"my-secret-password\")?; // <--- This line!\n    println!(\"Password stored!\");\n    // ... retrieve and delete ...\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: keyring-rs Platform Dispatching and Windows Backend Example in Rust\nDESCRIPTION: Illustrates the conceptual internal structure of keyring-rs: the dispatch_set_password function uses conditional compilation to route credential storage to the right backend depending on the target OS (macOS, Windows, Linux, or unimplemented). Shows a highly simplified Windows backend module that prepares to call Windows Credential Manager APIs. Key dependencies include Rust's cfg attributes for platform selection and the keyring-rs error and backend modules. Actual storage uses OS-specific APIs (e.g., CredWriteW on Windows) which must be available at build time.\nSOURCE: https://github.com/6p5ra/keyring-rs-library-documentation/blob/main/keyring-rs.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n// Conceptual structure within keyring-rs\n\n// This function figures out which backend to call\nfn dispatch_set_password(entry: &Entry, password: &str) -> Result<(), Error> {\n    // Conditional compilation checks the OS when the code is built\n    #[cfg(target_os = \"macos\")]\n    {\n        // If building for macOS, call the macOS backend function\n        backends::macos::store_credential(entry.service(), entry.username(), password)\n    }\n    #[cfg(target_os = \"windows\")]\n    {\n        // If building for Windows, call the Windows backend function\n        backends::windows::store_credential(entry.service(), entry.username(), password)\n    }\n    #[cfg(all(unix, not(target_os = \"macos\")))] // Simplified Linux check\n    {\n        // If building for Linux, call the Secret Service backend function\n        backends::secretservice::store_credential(entry.service(), entry.username(), password)\n    }\n    #[cfg(not(any(target_os = \"macos\", target_os = \"windows\", all(unix, not(target_os = \"macos\")))))]\n    {\n        // If no backend is implemented for the current OS\n        Err(Error::BackendNotAvailable)\n    }\n}\n\n// --- Example backend module for Windows (highly simplified concept) ---\n#[cfg(target_os = \"windows\")]\nmod windows {\n    use crate::{Error, /* other internal types */};\n\n    // This function contains Windows-specific logic\n    pub(crate) fn store_credential(service: &str, user: &str, password: &str) -> Result<(), Error> {\n        // 1. Prepare data structures needed by Windows Credential Manager API.\n        // 2. Call Windows functions like `CredWriteW`.\n        // 3. Check the result returned by Windows.\n        // 4. If Windows reported an error, translate it to a `keyring::Error`.\n        // 5. Return `Ok(())` or `Err(translated_error)`.\n        println!(\"Conceptual: Storing credential using Windows backend\");\n        // In real code, this would interact with winapi or similar crates.\n        Ok(()) // Placeholder for success\n    }\n    // ... other functions for get, delete specific to Windows ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Conceptual CredentialStore Trait in Rust\nDESCRIPTION: This Rust trait defines the core methods required for any secure credential storage implementation compatible with `keyring-rs`. It acts as a contract specifying the `set_credential`, `get_credential`, and `delete_credential` functions that concrete types must provide. The trait methods handle operations using service name, username, and secret data (as byte slices or vectors), returning `Result` for error handling using the `keyring::Error` type. Note: This is a conceptual representation of the actual internal traits.\nSOURCE: https://github.com/6p5ra/keyring-rs-library-documentation/blob/main/keyring-rs.md#_snippet_15\n\nLANGUAGE: Rust\nCODE:\n```\n// Conceptual representation of the core trait\n\n/// Represents the required capabilities of any secure credential storage.\npub trait CredentialStore {\n    /// Stores a credential (either password or binary secret).\n    /// Needs the service name, username, and the data itself.\n    fn set_credential(&self, service: &str, username: &str, secret: &[u8]) -> Result<(), keyring::Error>;\n\n    /// Retrieves a credential's secret data (as bytes).\n    /// Needs the service name and username to find the correct one.\n    fn get_credential(&self, service: &str, username: &str) -> Result<Vec<u8>, keyring::Error>;\n\n    /// Deletes a credential from the store.\n    /// Needs the service name and username to identify it.\n    fn delete_credential(&self, service: &str, username: &str) -> Result<(), keyring::Error>;\n\n    // There might be other methods for listing, etc., but these are the core.\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CredentialStore Trait for Custom Store in Rust\nDESCRIPTION: This Rust code implements the conceptual `CredentialStore` trait for the `MyInsecureFileStore` struct. It provides concrete implementations for `set_credential`, `get_credential`, and `delete_credential` using the struct's in-memory `HashMap` (accessing it via a mutex lock). The methods use the `make_key` helper and return `Result<(), keyring::Error>` or `Result<Vec<u8>, keyring::Error>`, handling key existence using `HashMap` methods and returning `Error::NoCredentialFound` when appropriate, mimicking the behavior of standard backends. This implementation is insecure and omits actual file I/O for demonstration purposes only.\nSOURCE: https://github.com/6p5ra/keyring-rs-library-documentation/blob/main/keyring-rs.md#_snippet_17\n\nLANGUAGE: Rust\nCODE:\n```\n// Implementing the trait for our custom store\n\n// Assume CredentialStore trait exists as defined conceptually above\nimpl CredentialStore for MyInsecureFileStore {\n    fn set_credential(&self, service: &str, username: &str, secret: &[u8]) -> Result<(), Error> {\n        let key = make_key(service, username);\n        let mut data = self.data.lock().unwrap(); // Lock the data for access\n        println!(\"(Custom Store) Storing secret for key: {}\", key);\n        data.insert(key, secret.to_vec());\n        // In a real implementation, we would now serialize `data` and write it\n        // securely to self.file_path. We'll skip that here.\n        Ok(())\n    }\n\n    fn get_credential(&self, service: &str, username: &str) -> Result<Vec<u8>, Error> {\n        let key = make_key(service, username);\n        let data = self.data.lock().unwrap(); // Lock the data for read access\n        println!(\"(Custom Store) Getting secret for key: {}\", key);\n        match data.get(&key) {\n            Some(secret) => Ok(secret.clone()), // Found it! Return a copy.\n            None => Err(Error::NoCredentialFound), // Not found. Return standard error.\n        }\n        // A real implementation would read from self.file_path first.\n    }\n\n    fn delete_credential(&self, service: &str, username: &str) -> Result<(), Error> {\n        let key = make_key(service, username);\n        let mut data = self.data.lock().unwrap(); // Lock for modification\n        println!(\"(Custom Store) Deleting secret for key: {}\", key);\n        if data.remove(&key).is_some() {\n            // In a real implementation, write the updated `data` back to the file.\n            Ok(())\n        } else {\n            Err(Error::NoCredentialFound) // Nothing to delete.\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conceptual OS-Specific Password Retrieval Backend Dispatch in Rust\nDESCRIPTION: This conceptual Rust code snippet illustrates how keyring-rs uses Rust's conditional compilation attributes (`#[cfg(...)]`) to select and delegate password retrieval calls to platform-specific backend modules (macos_backend, windows_backend, linux_backend). Each backend implements functions to interact with the native credential store APIs. The public `get_password` function acts as a unified entry point, returning the stored password or a platform-agnostic error. This design ensures that only relevant platform code is compiled and simplifies cross-platform support.\nSOURCE: https://github.com/6p5ra/keyring-rs-library-documentation/blob/main/keyring-rs.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n// In keyring-rs library (conceptual)\n\n// The public function you call\npub fn get_password(service: &str, user: &str) -> Result<String, keyring::Error> {\n    // Check which OS we are on\n    #[cfg(target_os = \"macos\")]\n    {\n        // Call the macOS specific implementation\n        macos_backend::get_password_from_keychain(service, user)\n    }\n    #[cfg(target_os = \"windows\")]\n    {\n        // Call the Windows specific implementation\n        windows_backend::get_password_from_credmanager(service, user)\n    }\n    #[cfg(all(unix, not(target_os = \"macos\")))] // Simplified Linux check\n    {\n        // Call the Linux specific implementation\n        linux_backend::get_password_from_secretservice(service, user)\n    }\n    #[cfg(not(any(target_os = \"macos\", target_os = \"windows\", all(unix, not(target_os = \"macos\")))))]\n    {\n        // If no backend is available for this OS\n        Err(keyring::Error::BackendNotAvailable)\n    }\n}\n\n// --- In a separate file: macos_backend.rs ---\n#[cfg(target_os = \"macos\")]\nmod macos_backend {\n    pub fn get_password_from_keychain(service: &str, user: &str) -> Result<String, keyring::Error> {\n        // ... code talking to macOS Keychain APIs ...\n        // ... translate results/errors to keyring::Error ...\n    }\n}\n\n// --- Similarly for windows_backend.rs and linux_backend.rs ---\n```\n\n----------------------------------------\n\nTITLE: Defining main function with Result error handling in Rust\nDESCRIPTION: Shows a Rust `main` function signature that returns a `Result<(), keyring::Error>`. This indicates the function can complete successfully with no value or return a keyring error. This pattern enables propagating errors using the `?` operator for concise error handling.\nSOURCE: https://github.com/6p5ra/keyring-rs-library-documentation/blob/main/keyring-rs.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() -> Result<(), keyring::Error> {\n    // ... keyring operations ...\n    Ok(()) // Indicates success\n}\n```\n\n----------------------------------------\n\nTITLE: Hypothetical macOS backend error translation in Rust\nDESCRIPTION: Illustrates an internal macOS keychain backend function that interacts with OS APIs to retrieve a password. Demonstrates how different OS error codes like `-25300` and `-25291` are mapped to corresponding `keyring::Error` variants. This abstraction layer hides platform complexity by standardizing error reporting through the library.\nSOURCE: https://github.com/6p5ra/keyring-rs-library-documentation/blob/main/keyring-rs.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// Hypothetical internal function in the macOS backend\nfn get_password_from_keychain(service: &str, user: &str) -> Result<String, keyring::Error> {\n    // ... code to prepare the query for macOS Keychain ...\n\n    let result_code = call_macos_security_api(service, user /* ... */);\n\n    match result_code {\n        0 => { // 0 often means success on macOS/unix\n            // ... code to retrieve and decode the password ...\n            Ok(\"retrieved_password\".to_string())\n        }\n        -25300 => { // errSecItemNotFound code\n            Err(keyring::Error::NoCredentialFound) // Translate!\n        }\n        -25291 => { // errSecAuthFailed code (example)\n            Err(keyring::Error::AccessDenied) // Translate!\n        }\n        // ... other macOS error codes mapped to keyring::Error variants ...\n        other_os_code => {\n            // If we don't have a specific mapping, use a general platform error\n            Err(keyring::Error::PlatformFailure(\n                format!(\"Unknown macOS Keychain error: {}\", other_os_code),\n                Some(other_os_code.into()) // Include original code if possible\n            ))\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Credential Dispatch Flow with keyring-rs: Sequence Diagram (Mermaid)\nDESCRIPTION: Provides a visual sequence diagram using the Mermaid format to show the step-by-step flow of a call to entry.set_password in keyring-rs. It details interactions from the user's application down through the core library, Windows backend, OS vault APIs, and the eventual propagation of results and errors back up to user code. Useful for understanding the logical architecture and flow without specific implementation code.\nSOURCE: https://github.com/6p5ra/keyring-rs-library-documentation/blob/main/keyring-rs.md#_snippet_10\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant YourApp as Your Application\n    participant KeyringLib as keyring-rs (Core)\n    participant MacBackend as macOS Keychain Backend\n    participant WinBackend as Windows Credential Manager Backend\n    participant LinBackend as Linux Secret Service Backend\n    participant OS_Vault as OS Secure Vault\n\n    YourApp->>KeyringLib: entry.set_password(\"pwd\") for (svc, usr)\n    KeyringLib->>KeyringLib: Detect OS (e.g., Windows)\n    KeyringLib->>WinBackend: Use Windows Backend to store password\n    WinBackend->>OS_Vault: Call Windows API (e.g., CredWriteW)\n    OS_Vault-->>WinBackend: Confirm storage (or OS Error)\n    WinBackend-->>KeyringLib: Translate to Ok(()) or keyring::Error\n    KeyringLib-->>YourApp: Return Result<(), keyring::Error>\n```\n\n----------------------------------------\n\nTITLE: OS Credential Retrieval Sequence Diagram using Mermaid\nDESCRIPTION: This Mermaid sequence diagram conceptually illustrates the flow of retrieving a password through keyring-rs. When the application calls `entry.get_password()`, the keyring-rs core detects the operating system and forwards the request to the corresponding backend (macOS, Windows, or Linux). The backend calls the native OS store API to retrieve the password, then returns the result back up through keyring-rs to the application. Alternative flows demonstrate how Windows OS is handled similarly. This visualization highlights the abstraction and delegation process.\nSOURCE: https://github.com/6p5ra/keyring-rs-library-documentation/blob/main/keyring-rs.md#_snippet_7\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant YourApp as Your Application\n    participant KeyringLib as keyring-rs (Core)\n    participant MacBackend as macOS Backend\n    participant WinBackend as Windows Backend\n    participant LinuxBackend as Linux Backend\n    participant OS_Store as Actual OS Store\n\n    YourApp->>KeyringLib: entry.get_password()?\n    KeyringLib->>KeyringLib: Detect OS (e.g., macOS)\n    KeyringLib->>MacBackend: Forward get_password request\n    MacBackend->>OS_Store: Call macOS Keychain API\n    OS_Store-->>MacBackend: Return password data (or OS error)\n    MacBackend-->>KeyringLib: Return Ok(password) (or translated Err)\n    KeyringLib-->>YourApp: Return Ok(password) (or translated Err)\n\n    %% Example if running on Windows instead %%\n    <<alt OS is Windows>>\n        KeyringLib->>KeyringLib: Detect OS (e.g., Windows)\n        KeyringLib->>WinBackend: Forward get_password request\n        WinBackend->>OS_Store: Call Windows Credential Manager API\n        OS_Store-->>WinBackend: Return password data (or OS error)\n        WinBackend-->>KeyringLib: Return Ok(password) (or translated Err)\n        KeyringLib-->>YourApp: Return Ok(password) (or translated Err)\n    <</alt>>\n\n```\n\n----------------------------------------\n\nTITLE: Sequence diagram illustrating keyring-rs error translation\nDESCRIPTION: A Mermaid sequence diagram showing the flow from an application request for a password through multiple layers of keyring-rs and OS-specific backends. It illustrates how a platform-specific error is captured and translated into a unified `keyring::Error` variant returned to the application, facilitating consistent error handling regardless of OS.\nSOURCE: https://github.com/6p5ra/keyring-rs-library-documentation/blob/main/keyring-rs.md#_snippet_3\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant YourApp as Your Application\n    participant Entry as Entry Object\n    participant KeyringLib as keyring-rs Library\n    participant OS_Backend as OS Credential Store Backend\n    participant OS_Store as Actual OS Store (e.g., Keychain)\n\n    YourApp->>Entry: entry.get_password()?\n    Entry->>KeyringLib: Request password for (service, user)\n    KeyringLib->>OS_Backend: Find password for (service, user)\n    OS_Backend->>OS_Store: Read credential matching service/user\n    OS_Store-->>OS_Backend: Fail (e.g., macOS Error -25300 Item Not Found)\n    OS_Backend-->>OS_Backend: Translate -25300 to keyring::Error::NoCredentialFound\n    OS_Backend-->>KeyringLib: Return Err(keyring::Error::NoCredentialFound)\n    KeyringLib-->>Entry: Return Err(keyring::Error::NoCredentialFound)\n    Entry-->>YourApp: Return Err(keyring::Error::NoCredentialFound)\n    YourApp->>YourApp: Handle the specific error (e.g., match Err(Error::NoCredentialFound))\n```\n\n----------------------------------------\n\nTITLE: Conceptual Flowchart of keyring-rs Components\nDESCRIPTION: A Mermaid flowchart diagram outlining the key concepts and components of the keyring-rs library and their interrelationships. It visualizes how concepts like `Entry`, `Credential Store Backend`, `Platform Abstraction`, `Error Handling`, `Feature Flags`, `Secret vs. Password Handling`, and `Extensibility (Traits)` connect within the library's architecture.\nSOURCE: https://github.com/6p5ra/keyring-rs-library-documentation/blob/main/keyring-rs.md#_snippet_19\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TD\n    A0[\"Entry\n\"]\n    A1[\"Credential Store Backend\n\"]\n    A2[\"Platform Abstraction\n\"]\n    A3[\"Error Handling (`keyring::Error`)\n\"]\n    A4[\"Feature Flags\n\"]\n    A5[\"Secret vs. Password Handling\n\"]\n    A6[\"Extensibility (Traits)\n\"]\n    A0 -- \"Uses for operations\" --> A2\n    A2 -- \"Selects and uses\" --> A1\n    A0 -- \"Returns errors via\" --> A3\n    A1 -- \"Generates errors wrapped by\" --> A3\n    A0 -- \"Implements methods for\" --> A5\n    A2 -- \"Handles data types via\" --> A5\n    A4 -- \"Configure available\" --> A1\n    A6 -- \"Defines interface for\" --> A1\n```\n\n----------------------------------------\n\nTITLE: Visualizing Dynamic Dispatch Sequence in keyring-rs\nDESCRIPTION: A Mermaid sequence diagram illustrating the dynamic dispatch process when setting a password using the keyring-rs library. It shows the interaction flow from the application code, through the Entry object and core library logic, to the dynamically dispatched backend (represented as a trait object `dyn CredentialStore`), and finally to the underlying OS vault.\nSOURCE: https://github.com/6p5ra/keyring-rs-library-documentation/blob/main/keyring-rs.md#_snippet_18\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant YourApp as Your Application\n    participant Entry as Entry Object\n    participant KeyringCore as keyring-rs Core Logic\n    participant ActiveBackend as Active Backend <br> (Trait Object: dyn CredentialStore)\n    participant ActualStore as OS Vault (e.g., Keychain)\n\n    YourApp->>Entry: entry.set_password(\"secret\") for (svc, usr)\n    Entry->>KeyringCore: Request store \"secret\" for (svc, usr)\n    KeyringCore->>ActiveBackend: backend.set_credential(svc, usr, \"secret\")\n    Note right of ActiveBackend: Rust uses dynamic dispatch <br/> to call the *correct* backend's <br/> implementation (e.g., Keychain's).\n    ActiveBackend->>ActualStore: Call native OS API (e.g., SecItemAdd)\n    ActualStore-->>ActiveBackend: Return OS Result\n    ActiveBackend-->>KeyringCore: Return translated Result<(), keyring::Error>\n    KeyringCore-->>Entry: Return Result\n    Entry-->>YourApp: Return Result\n```\n\n----------------------------------------\n\nTITLE: Specifying keyring-rs dependency in Cargo.toml\nDESCRIPTION: This code snippet shows the basic way to declare keyring-rs as a dependency in your Cargo.toml file. This minimal declaration includes the default feature set.\nSOURCE: https://github.com/6p5ra/keyring-rs-library-documentation/blob/main/keyring-rs.md#_snippet_11\n\nLANGUAGE: toml\nCODE:\n```\n# In your Cargo.toml file\n[dependencies]\nkeyring = \"4\" # Or the latest version\n```\n\n----------------------------------------\n\nTITLE: Enabling vendored feature in Cargo.toml\nDESCRIPTION: This code snippet demonstrates how to enable the `vendored` feature flag for the keyring-rs library in your Cargo.toml file. This feature bundles the libdbus library into the application, which avoids the need to have it pre-installed on the system.\nSOURCE: https://github.com/6p5ra/keyring-rs-library-documentation/blob/main/keyring-rs.md#_snippet_12\n\nLANGUAGE: toml\nCODE:\n```\n# In your Cargo.toml file\n[dependencies]\n# Use the expanded format to specify features\nkeyring = { version = \"4\", features = [\"vendored\"] }\n```\n\n----------------------------------------\n\nTITLE: Enabling encrypted feature in Cargo.toml\nDESCRIPTION: This code snippet shows how to enable the `encrypted` feature flag for keyring-rs. This feature ensures that the communication between the application and the Linux Secret Service (over D-Bus) is encrypted.\nSOURCE: https://github.com/6p5ra/keyring-rs-library-documentation/blob/main/keyring-rs.md#_snippet_13\n\nLANGUAGE: toml\nCODE:\n```\n# In your Cargo.toml file\n[dependencies]\n# You can list multiple features\nkeyring = { version = \"4\", features = [\"encrypted\"] }\n# Or combine them if needed, e.g.:\n# keyring = { version = \"4\", features = [\"vendored\", \"encrypted\"] }\n```\n\n----------------------------------------\n\nTITLE: Conditional compilation example with vendored feature\nDESCRIPTION: This Rust code snippet illustrates how conditional compilation is used within the keyring-rs library to include or exclude code based on the presence of a feature flag (in this case, `vendored`). The `#[cfg(feature = \"vendored\")]` and `#[cfg(not(feature = \"vendored\")]` attributes determine which code block is compiled.\nSOURCE: https://github.com/6p5ra/keyring-rs-library-documentation/blob/main/keyring-rs.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n// Conceptual code inside keyring-rs's Linux backend\n\n// This function is always defined\nfn connect_to_dbus() {\n    println!(\"Trying to connect to D-Bus...\");\n\n    // Check if the 'vendored' feature is enabled AT COMPILE TIME\n    #[cfg(feature = \"vendored\")]\n    {\n        // This code block is ONLY included if 'vendored' feature is enabled\n        println!(\"Using bundled (vendored) libdbus library.\");\n        // ... code to initialize the bundled libdbus ...\n    }\n\n    // Check if the 'vendored' feature is NOT enabled AT COMPILE TIME\n    #[cfg(not(feature = \"vendored\"))]\n    {\n        // This code block is ONLY included if 'vendored' feature is NOT enabled\n        println!(\"Using system's libdbus library (dynamic linking).\");\n        // ... code to find and load the system libdbus ...\n    }\n\n    // ... rest of the connection logic ...\n}\n\nfn main() {\n    connect_to_dbus();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Insecure File Store Structure in Rust\nDESCRIPTION: This Rust code defines a struct `MyInsecureFileStore` intended as a *conceptual* example of a custom credential store. It holds a file path and an in-memory `HashMap` (protected by a `Mutex`) to simulate storage, although actual file I/O is omitted in the trait implementation for simplicity. The `make_key` helper function generates a unique identifier string from a service name and username for use within the storage structure. Required imports include standard library components (`collections::HashMap`, `fs`, `io`, `path::PathBuf`, `sync::Mutex`) and `keyring::Error`.\nSOURCE: https://github.com/6p5ra/keyring-rs-library-documentation/blob/main/keyring-rs.md#_snippet_16\n\nLANGUAGE: Rust\nCODE:\n```\n// In your own code\n\nuse std::collections::HashMap;\nuse std::fs;\nuse std::io;\nuse std::path::PathBuf;\nuse keyring::Error; // Use the standard error type\n\n// Our custom store structure - holds the path to the file\nstruct MyInsecureFileStore {\n    file_path: PathBuf,\n    // We'll use a HashMap in memory as a simple cache/representation\n    // In a real scenario, you'd handle file I/O more directly & securely.\n    data: std::sync::Mutex<HashMap<String, Vec<u8>>>,\n}\n\n// Helper method to create a unique key for our map/file\nfn make_key(service: &str, username: &str) -> String {\n    format!(\"{}::{}\", service, username)\n}\n```"
  }
]