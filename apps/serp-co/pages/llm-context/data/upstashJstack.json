[
  {
    "owner": "upstash",
    "repo": "jstack",
    "content": "TITLE: Setting Up the Main App Router in JStack\nDESCRIPTION: Configuration for the main application router that serves as the entry point for the Next.js backend. It sets up the base API path, CORS handling, and error handling.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/getting-started/first-steps.mdx#2025-04-10_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { j } from \"./jstack\"\n\n/**\n * This is your base API.\n * Here, you can handle errors, not-found responses, cors and more.\n */\nconst api = j\n  .router()\n  .basePath(\"/api\")\n  .use(j.defaults.cors)\n  .onError(j.defaults.errorHandler)\n\n/**\n * This is the main router for your server.\n * All routers in /server/routers should be added here manually.\n */\nconst appRouter = j.mergeRouters(api, {\n  // ...\n})\n\nexport type AppRouter = typeof appRouter\n\nexport default appRouter\n```\n\n----------------------------------------\n\nTITLE: Initializing JStack with TypeScript\nDESCRIPTION: Code to initialize JStack with TypeScript type safety. This creates the JStack instance with environment variable typing and establishes the public procedure base for creating API endpoints.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/getting-started/first-steps.mdx#2025-04-10_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { jstack } from \"jstack\"\n\ninterface Env {\n  Bindings: { DATABASE_URL: string }\n}\n\nexport const j = jstack.init<Env>()\n\n/**\n * Public (unauthenticated) procedures\n * This is the base part you use to create new procedures.\n */\nexport const publicProcedure = j.procedure\n```\n\n----------------------------------------\n\nTITLE: Registering a Router with the Main App Router in JStack\nDESCRIPTION: Shows how to integrate a custom router into the main application router in JStack. This example registers the post router and sets up error handling and CORS.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/routers.mdx#2025-04-10_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { j } from \"./jstack\"\nimport { postRouter } from \"./routers/post-router\" \n\nconst api = j \n  .router() \n  .basePath(\"/api\") \n  .use(j.defaults.cors) \n  .onError(j.defaults.errorHandler) \n\nconst appRouter = j.mergeRouters(api, {\n  post: postRouter, \n})\n\nexport type AppType = typeof appRouter\n\nexport default appRouter\n```\n\n----------------------------------------\n\nTITLE: Creating a JStack AppRouter with Feature Routers\nDESCRIPTION: Shows how to create an AppRouter by first defining a base API with global configuration and then merging it with feature-specific routers. Includes type export for the router.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/app-router.mdx#2025-04-10_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { j } from \"./jstack\"\nimport { postRouter } from \"./routers/post-router\"\n\n// 1Ô∏è‚É£ Creating the base API with global configuration\nconst api = j\n  .router()\n  .basePath(\"/api\")\n  .use(j.defaults.cors)\n  .onError(j.defaults.errorHandler)\n\n// 2Ô∏è‚É£ Merging with feature routers\nconst appRouter = j.mergeRouters(api, {\n  post: postRouter,\n})\n\nexport type AppRouter = typeof appRouter\nexport default appRouter\n```\n\n----------------------------------------\n\nTITLE: Setting up Public Procedures in JStack\nDESCRIPTION: Demonstrates initialization of JStack and creation of public procedures that don't require authentication.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/procedures.mdx#2025-04-10_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { jstack } from \"jstack\"\n\ninterface Env {\n  Bindings: { DATABASE_URL: string }\n}\n\nexport const j = jstack.init<Env>()\n\n/**\n * Public (unauthenticated) procedures\n * This is the base part you use to create new procedures.\n */\nexport const publicProcedure = j.procedure\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication Middleware in JStack\nDESCRIPTION: Shows how to create an authentication middleware that checks if a user is authenticated and attaches user data to the context. It also demonstrates how to use this middleware with public and private procedures.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/middleware.mdx#2025-04-10_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HTTPException } from \"hono/http-exception\"\nimport { jstack } from \"jstack\"\n\ninterface Env {\n  Bindings: { DATABASE_URL: string }\n}\n\nexport const j = jstack.init<Env>()\n\nconst authMiddleware = j.middleware(async ({ c, next }) => {\n  // Mocked user authentication check...\n  const isAuthenticated = true\n\n  if (!isAuthenticated) {\n    throw new HTTPException(401, {\n      message: \"Unauthorized, sign in to continue.\",\n    })\n  }\n\n  // üëá Attach user to `ctx` object\n  return await next({ user: { name: \"John Doe\" } })\n})\n\n/**\n * Public (unauthenticated) procedures\n * This is the base piece you use to build new procedures.\n */\nexport const publicProcedure = j.procedure\nexport const privateProcedure = publicProcedure.use(authMiddleware)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Catch-All API Route in Next.js\nDESCRIPTION: Implementation of a catch-all API route in Next.js that handles all incoming API requests and forwards them to the JStack app router. Supports both GET and POST methods.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/getting-started/first-steps.mdx#2025-04-10_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport appRouter from \"@/server\"\nimport { handle } from \"hono/vercel\"\n\nexport const GET = handle(appRouter.handler)\nexport const POST = handle(appRouter.handler)\n```\n\n----------------------------------------\n\nTITLE: Initializing Type-Safe API Client in TypeScript\nDESCRIPTION: Sets up a type-safe API client using JStack's createClient function. Includes dynamic base URL configuration for different deployment environments.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/api-client.mdx#2025-04-10_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createClient } from \"jstack\"\nimport type { AppRouter } from \"@/server\"\n\nexport const client = createClient<AppRouter>({\n  baseUrl: `${getBaseUrl()}/api`,\n})\n\nfunction getBaseUrl() {\n  // üëá Adjust for wherever you deploy\n  if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`\n  return `http://localhost:3000`\n}\n```\n\n----------------------------------------\n\nTITLE: Type Inference for JStack Router Inputs and Outputs\nDESCRIPTION: Demonstrates how to use TypeScript utility types to infer the input and output types of router procedures, enhancing type safety in application code.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/app-router.mdx#2025-04-10_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nimport type { AppRouter } from \"./jstack\"\nimport type { InferRouterInputs, InferRouterOutputs } from \"jstack\"\n\ntype InferInput = InferRouterInputs<AppRouter>\ntype InferOutput = InferRouterOutputs<AppRouter>\n\n// üëá Usage: InferInput[<router>][<procedure>]\ntype Input = InferInput[\"post\"][\"example\"]\ntype Output = InferOutput[\"post\"][\"example\"]\n```\n\n----------------------------------------\n\nTITLE: Implementing GET Procedures\nDESCRIPTION: Example of creating a GET procedure for retrieving data with context and input handling.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/procedures.mdx#2025-04-10_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { j, publicProcedure } from \"../jstack\"\n\nexport const postRouter = j.router({\n  recent: publicProcedure.get(({ c, ctx, input }) => {\n    const post = {\n      id: 1,\n      title: \"My first post\",\n    }\n\n    return c.json({ post })\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing POST Procedures\nDESCRIPTION: Example of creating a POST procedure for data modification with context and input handling.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/procedures.mdx#2025-04-10_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { j, publicProcedure } from \"../jstack\"\n\nexport const postRouter = j.router({\n  create: publicProcedure.post(({ c, ctx, input }) => {\n    return c.json({ message: \"Post created successfully!\" })\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Input Validation with Zod\nDESCRIPTION: Demonstrates input validation for procedures using Zod schema validation.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/procedures.mdx#2025-04-10_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from \"zod\"\nimport { j, publicProcedure } from \"../jstack\"\n\nexport const postRouter = j.router({\n  create: publicProcedure\n    .input(z.object({ title: z.string() }))\n    .post(({ c, ctx, input }) => {\n      // üëá Guaranteed to exist & automatically typed\n      const { title } = input\n\n      return c.json({ message: `Created post: \"${title}\"` })\n    }),\n})\n```\n\n----------------------------------------\n\nTITLE: Using Private Procedures in Router\nDESCRIPTION: Example of implementing a protected route using privateProcedure in a router.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/procedures.mdx#2025-04-10_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { j, privateProcedure } from \"../jstack\"\n\nexport const postRouter = j.router({\n  list: privateProcedure.get(({ c }) => {\n    return c.json({ posts: [] })\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Procedures to a JStack Router\nDESCRIPTION: Demonstrates how to add procedures (endpoints) to a JStack router. This example adds 'list' and 'create' procedures to the post router.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/routers.mdx#2025-04-10_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { j, publicProcedure } from \"../jstack\"\n\nexport const postRouter = j.router({\n  list: publicProcedure.get(({ c }) => {\n    return c.json({ posts: [] })\n  }),\n\n  create: publicProcedure.post(({ c }) => {\n    return c.json({ success: true })\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Chaining Multiple Middlewares in JStack\nDESCRIPTION: Demonstrates how to chain multiple middlewares using the .use() method in JStack, creating an enhanced procedure with authentication, logging, and rate limiting.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/middleware.mdx#2025-04-10_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst enhancedProcedure = publicProcedure\n  .use(authMiddleware)\n  .use(loggingMiddleware)\n  .use(rateLimitMiddleware)\n```\n\n----------------------------------------\n\nTITLE: Initializing WebSocket Router in JStack\nDESCRIPTION: This snippet demonstrates how to create a WebSocket router in JStack. It shows the basic structure of a WebSocket procedure, including the context and connection manager objects received by the handler.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/websockets.mdx#2025-04-10_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { j } from \"../jstack\"\n\nexport const postRouter = j.router({\n  chat: j.procedure.ws(({ c, io, ctx }) => ({\n    async onConnect({ socket }) {\n      // ...\n    },\n  })),\n})\n```\n\n----------------------------------------\n\nTITLE: Connecting a Router to the App Router\nDESCRIPTION: Code showing how to connect a feature router to the main app router, making its procedures available through the API. The feature router is merged with specific naming.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/getting-started/first-steps.mdx#2025-04-10_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nimport { j } from \"./jstack\"\nimport { postRouter } from \"./routers/post-router\"\n\nconst api = j\n  .router()\n  .basePath(\"/api\")\n  .use(j.defaults.cors)\n  .onError(j.defaults.errorHandler)\n\nconst appRouter = j.mergeRouters(api, {\n  post: postRouter,\n})\n\nexport type AppRouter = typeof appRouter\nexport default appRouter\n```\n\n----------------------------------------\n\nTITLE: Customizing CORS Settings in JStack\nDESCRIPTION: Shows how to configure custom CORS settings using Hono's built-in middleware, with special attention to requirements for JStack's superjson functionality.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/app-router.mdx#2025-04-10_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nimport { cors } from \"hono/cors\"\n\ncors({\n  allowHeaders: [\"x-is-superjson\"],\n  exposeHeaders: [\"x-is-superjson\"],\n  origin: (origin) => origin, // default: allow any origin\n  credentials: true, // default: allow credentials\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Default CORS Middleware in JStack\nDESCRIPTION: Demonstrates how to add JStack's default CORS middleware to the router for handling Cross-Origin Resource Sharing.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/app-router.mdx#2025-04-10_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport { InferRouterInputs, InferRouterOutputs } from \"jstack\"\nimport { j } from \"./jstack\"\nimport { postRouter } from \"./routers/post-router\"\n\nconst api = j\n  .router()\n  .basePath(\"/api\")\n  .use(j.defaults.cors)\n  .onError(j.defaults.errorHandler)\n```\n\n----------------------------------------\n\nTITLE: Implementing Chat WebSocket Router in JStack\nDESCRIPTION: This code snippet shows a more complex WebSocket router implementation for a chat system. It includes message validation using Zod, and demonstrates how to handle incoming messages and broadcast them to clients in a specific room.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/websockets.mdx#2025-04-10_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from \"zod\"\nimport { j } from \"jstack\"\n\nconst chatValidator = z.object({\n  message: z.object({\n    roomId: z.string(),\n    message: z.string(),\n    author: z.string(),\n  }),\n})\n\nexport const chatRouter = j.router({\n  chat: j.procedure\n    .incoming(chatValidator)\n    .outgoing(chatValidator)\n    .ws(({ c, io, ctx }) => ({\n      async onConnect({ socket }) {\n        socket.on(\"message\", async (message) => {\n          // Optional: Implement message persistence\n          // Example: await db.messages.create({ data: message })\n\n          // Broadcast the message to all clients in the room\n          await io.to(message.roomId).emit(\"message\", message)\n        })\n      },\n    })),\n})\n```\n\n----------------------------------------\n\nTITLE: Using WebSockets in React Client with JStack\nDESCRIPTION: This React component demonstrates how to use WebSockets on the client-side with JStack. It shows how to connect to a WebSocket, listen for incoming events, and emit events to the server.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/websockets.mdx#2025-04-10_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n\"use client\"\n\nimport { client } from \"@/lib/client\"\nimport { useWebSocket } from \"jstack/client\"\n\n/**\n * Connect socket above component to avoid mixing\n * component & connection lifecycle\n */\nconst socket = client.post.chat.$ws()\n\nexport default function Page() {\n  // üëá Listening for incoming real-time events\n  useWebSocket(socket, {\n    message: ({ roomId, author, message }) => {\n      console.log({ roomId, author, message })\n    },\n  })\n\n  return (\n    <button\n      onClick={() => {\n        // üëá Send an event to the server\n        socket.emit(\"message\", {\n          author: \"John Doe\",\n          message: \"Hello world\",\n          roomId: \"general\",\n        })\n      }}\n    >\n      Emit Chat Message\n    </button>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Router Loading in JStack\nDESCRIPTION: Demonstrates how to dynamically load routers using the dynamic() function to reduce initial bundle size and improve cold starts. The code shows configuration of a base API router with CORS and error handling, then merging it with dynamically loaded user and post routers.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/performance.mdx#2025-04-10_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { j } from \"./jstack\"\nimport { dynamic } from \"jstack\"\n\nconst api = j\n  .router()\n  .basePath(\"/api\")\n  .use(j.defaults.cors)\n  .onError(j.defaults.errorHandler)\n\nconst appRouter = j.mergeRouters(api, {\n  users: dynamic(() => import(\"./routers/user-router\")),\n  posts: dynamic(() => import(\"./routers/post-router\")),\n})\n\nexport type AppRouter = typeof appRouter\nexport default appRouter\n```\n\n----------------------------------------\n\nTITLE: Basic API Client Usage in TypeScript\nDESCRIPTION: Demonstrates basic usage of the type-safe client for making API calls with full type inference for response data.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/api-client.mdx#2025-04-10_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { client } from \"@/lib/client\"\n\nconst res = await client.post.recent.$get()\nconst post = await res.json()\n// ^ TypeScript knows this route's return type\n```\n\n----------------------------------------\n\nTITLE: Integrating JStack Client with React Query\nDESCRIPTION: Shows how to integrate the JStack client with React Query for state management, demonstrating type-safe data fetching in a React component.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/api-client.mdx#2025-04-10_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n\"use client\"\n\nimport { client } from \"@/lib/client\"\nimport { useQuery } from \"@tanstack/react-query\"\n\nexport default function Page() {\n  const { data, isLoading } = useQuery({\n    queryKey: [\"get-recent-post\"],\n    queryFn: async () => {\n      const res = await client.post.recent.$get()\n      return await res.json()\n    },\n  })\n\n  if (isLoading) return <p>Loading...</p>\n\n  return <h1>{data.title}</h1> // TypeScript knows this is safe!\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Default Error Handling in JStack\nDESCRIPTION: Shows how to add JStack's default error handler to the router, which standardizes error responses for easier frontend handling.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/app-router.mdx#2025-04-10_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { j } from \"../jstack\"\n\nconst api = j\n  .router()\n  .basePath(\"/api\")\n  .use(j.defaults.cors)\n  .onError(j.defaults.errorHandler)\n```\n\n----------------------------------------\n\nTITLE: Configuring Client URL for Vercel Deployment in TypeScript\nDESCRIPTION: This code snippet shows how to update the client configuration to properly use the Vercel URL in production. It includes a getBaseUrl function that prioritizes the browser URL for client-side execution, falls back to the Vercel URL in production, and defaults to localhost for development.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/deploy/vercel.mdx#2025-04-10_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { AppRouter } from \"@/server\"\nimport { createClient } from \"jstack\"\n\nexport const client = createClient<AppRouter>({\n  baseUrl: `${getBaseUrl()}/api`,\n})\n\nfunction getBaseUrl() {\n  // üëá Use browser URL if client-side\n  if (typeof window !== \"undefined\") {\n    return window.location.origin\n  }\n\n  // üëá Use Vercel URL in production\n  if (process.env.VERCEL_URL) {\n    return `https://${process.env.VERCEL_URL}`\n  }\n\n  // üëá Default to localhost\n  return `http://localhost:3000`\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring CORS Middleware in JStack API Router\nDESCRIPTION: This snippet shows how to configure CORS middleware in a JStack application to prevent cross-origin resource sharing issues during deployment. It adds CORS middleware to the base API router configuration.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/deploy/vercel.mdx#2025-04-10_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { InferRouterInputs, InferRouterOutputs } from \"jstack\"\nimport { postRouter } from \"./routers/post-router\"\nimport { j } from \"./jstack\"\n\nconst api = j\n  .router()\n  .basePath(\"/api\")\n  .use(j.defaults.cors)\n  .onError(j.defaults.errorHandler)\n\nconst appRouter = j.mergeRouters(api, {\n  post: postRouter,\n})\n\nexport type AppRouter = typeof appRouter\n\nexport default appRouter\n```\n\n----------------------------------------\n\nTITLE: Client-side GET Request\nDESCRIPTION: Shows how to call a GET procedure from the client side using the client.$get method.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/procedures.mdx#2025-04-10_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { client } from \"@/lib/client\"\n\nconst res = await client.post.recent.$get()\n```\n\n----------------------------------------\n\nTITLE: Client-side POST Request\nDESCRIPTION: Shows how to call a POST procedure from the client side using the client.$post method.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/procedures.mdx#2025-04-10_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { client } from \"@/lib/client\"\n\nconst res = await client.post.create.$post()\n```\n\n----------------------------------------\n\nTITLE: Client-side Validated POST Request\nDESCRIPTION: Shows how to make a POST request with validated input from the client side.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/procedures.mdx#2025-04-10_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { client } from \"@/lib/client\"\n\n// ‚úÖ Client knows that `title` is expected input\nawait client.post.create.$post({ title: \"My new post\" })\n```\n\n----------------------------------------\n\nTITLE: JStack File Structure Overview\nDESCRIPTION: Demonstrates the typical directory structure for a JStack application, highlighting the location of the main appRouter file and related components.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/app-router.mdx#2025-04-10_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\napp/\n  ‚îî‚îÄ‚îÄ server/\n      ‚îú‚îÄ‚îÄ jstack.ts        # Initialize JStack\n      ‚îú‚îÄ‚îÄ index.ts         # Main appRouter\n      ‚îî‚îÄ‚îÄ routers/         # Router directory\n          ‚îú‚îÄ‚îÄ user-router.ts\n          ‚îú‚îÄ‚îÄ post-router.ts\n          ‚îî‚îÄ‚îÄ ...\n```\n\n----------------------------------------\n\nTITLE: Configuring JStack API Base Path\nDESCRIPTION: Shows how to set the base path for the API, which determines the URL prefix for all routes in the application.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/app-router.mdx#2025-04-10_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\n// üëá Serve all routes under /api/*\nconst api = j\n  .router()\n  .basePath(\"/api\")\n  .use(j.defaults.cors)\n  .onError(j.defaults.errorHandler)\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Middleware Structure in JStack\nDESCRIPTION: Demonstrates the basic structure of a middleware function in JStack. The middleware can execute code before the handler and pass data to the next middleware or handler.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/middleware.mdx#2025-04-10_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst myMiddleware = j.middleware(async ({ c, next }) => {\n  // 1Ô∏è‚É£ Code that runs before the handler\n  // ...\n\n  // 2Ô∏è‚É£ Pass data to the next middleware/handler\n  return await next({ customData: \"value\" })\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing Middleware Data in JStack Router\nDESCRIPTION: Illustrates how to access middleware data (in this case, user information) within a router procedure that uses the authentication middleware.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/middleware.mdx#2025-04-10_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { j, privateProcedure } from \"../jstack\"\n\nexport const postRouter = j.router({\n  list: privateProcedure.get(({ c, ctx }) => {\n    // üëá Access middleware data through ctx\n    const { user } = ctx\n\n    return c.json({ posts: [] })\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Router in JStack\nDESCRIPTION: Shows how to create a new router file in JStack. This example creates a post router with an empty configuration.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/routers.mdx#2025-04-10_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { j } from \"../jstack\"\n\nexport const postRouter = j.router({\n  // Procedures go here...\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Feature Router in JStack\nDESCRIPTION: Example of creating a feature-specific router for blog posts. It defines a 'recent' procedure that returns mock data as a JSON response.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/getting-started/first-steps.mdx#2025-04-10_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { j, publicProcedure } from \"../jstack\"\n\nexport const postRouter = j.router({\n  recent: publicProcedure.get(({ c }) => {\n    return c.json({ title: \"first post\" })\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing JStack with Type-Safe Environment Variables in TypeScript\nDESCRIPTION: This snippet demonstrates how to initialize JStack with full environment variable type-safety. It defines an interface for environment bindings and creates a typed JStack instance.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/getting-started/environment-variables.mdx#2025-04-10_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { jstack } from \"jstack\"\n\ninterface Env {\n  Bindings: { DATABASE_URL: string }\n}\n\nexport const j = jstack.init<Env>()\n\n/**\n * Public (unauthenticated) procedures\n * This is the base part you use to create new procedures.\n */\nexport const publicProcedure = j.procedure\n```\n\n----------------------------------------\n\nTITLE: JStack Recommended File Structure\nDESCRIPTION: The recommended file structure for a JStack application, showing the organization of server components including the initialization file, main app router, and router directory.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/getting-started/first-steps.mdx#2025-04-10_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\napp/\n  ‚îî‚îÄ‚îÄ server/\n      ‚îú‚îÄ‚îÄ jstack.ts        # Initialize JStack\n      ‚îú‚îÄ‚îÄ index.ts         # Main appRouter\n      ‚îî‚îÄ‚îÄ routers/         # Router directory\n          ‚îú‚îÄ‚îÄ user-router.ts\n          ‚îú‚îÄ‚îÄ post-router.ts\n          ‚îî‚îÄ‚îÄ ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication Middleware in JStack\nDESCRIPTION: Shows how to create authenticated procedures using middleware for protected routes.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/procedures.mdx#2025-04-10_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HTTPException } from \"hono/http-exception\"\nimport { jstack } from \"jstack\"\n\ninterface Env {\n  Bindings: { DATABASE_URL: string }\n}\n\nexport const j = jstack.init<Env>()\n\nconst authMiddleware = j.middleware(async ({ c, next }) => {\n  // Mocked user authentication check...\n  const isAuthenticated = true\n\n  if (!isAuthenticated) {\n    throw new HTTPException(401, {\n      message: \"Unauthorized, sign in to continue.\",\n    })\n  }\n\n  // üëá Attach user to `ctx` object\n  await next({ user: { id: \"123\", name: \"John Doe\" } })\n})\n\n/**\n * Public (unauthenticated) procedures\n * This is the base part you use to create new procedures.\n */\nexport const publicProcedure = j.procedure\nexport const privateProcedure = publicProcedure.use(authMiddleware)\n```\n\n----------------------------------------\n\nTITLE: WebSocket Procedures Implementation\nDESCRIPTION: Shows how to implement real-time WebSocket procedures with incoming and outgoing event schemas.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/procedures.mdx#2025-04-10_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { j, publicProcedure } from \"../jstack\"\nimport { z } from \"zod\"\n\nconst incomingEvents = z.object({\n  like: z.object({ username: z.string(), postId: z.string() }),\n})\n\nconst outgoingEvents = z.object({\n  like: z.object({ username: z.string() }),\n})\n\nexport const postRouter = j.router({\n  likes: publicProcedure\n    .incoming(incomingEvents)\n    .outgoing(outgoingEvents)\n    .ws(({ c, ctx, io }) => {\n      return {\n        onConnect({ socket }) {\n          socket.on(\"like\", ({ username, postId }) => {\n            console.log(`User \"${username}\" liked post with id \"${postId}\"`)\n\n            // üëá Send event to all connected clients\n            io.to(postId).emit(\"like\", { username })\n          })\n        },\n        onDisconnect({ socket }) {\n          console.log(\"User disconnected\")\n        },\n        onError({ socket, error }) {\n          console.log(\"Socket error:\", error)\n        },\n      }\n    }),\n})\n```\n\n----------------------------------------\n\nTITLE: Custom Error Handling in JStack\nDESCRIPTION: Shows how to implement a custom error handler that overrides the default behavior, providing personalized error responses.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/app-router.mdx#2025-04-10_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\napi.onError((err, c) => {\n  console.error(`${err}`)\n  return c.text(\"Custom Error Message\", 500)\n})\n```\n\n----------------------------------------\n\nTITLE: Handling JStack Errors on the Frontend\nDESCRIPTION: Demonstrates how to handle errors from a JStack backend in a React component using TanStack Query and the Hono HTTPException type.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/app-router.mdx#2025-04-10_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n\"use client\"\n\nimport { useMutation } from \"@tanstack/react-query\"\nimport { HTTPException } from \"hono/http-exception\"\nimport { client } from \"@/lib/client\"\n\nexport default function Page() {\n  const { mutate: createPost } = useMutation({\n    mutationFn: async () => {\n      const res = await client.post.create.$post()\n      return await res.json()\n    },\n    onError: (err: HTTPException) => {\n      console.log(err.message)\n    },\n  })\n\n  return <button onClick={() => createPost()}>Create Post</button>\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing JStack File Structure\nDESCRIPTION: Shows the recommended file structure for a JStack application with router organization.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/procedures.mdx#2025-04-10_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\napp/\n  ‚îî‚îÄ‚îÄ server/\n      ‚îú‚îÄ‚îÄ jstack.ts        # Initialize JStack\n      ‚îú‚îÄ‚îÄ index.ts         # Main appRouter\n      ‚îî‚îÄ‚îÄ routers/         # Router directory\n          ‚îú‚îÄ‚îÄ user-router.ts\n          ‚îú‚îÄ‚îÄ post-router.ts\n          ‚îî‚îÄ‚îÄ payment-router.ts\n```\n\n----------------------------------------\n\nTITLE: Adapting Hono Middleware for JStack\nDESCRIPTION: Demonstrates how to use Hono middleware with JStack using the fromHono adapter, specifically showing how to apply CORS middleware to a procedure.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/middleware.mdx#2025-04-10_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { j } from \"./jstack\"\nimport { cors } from \"hono/cors\"\n\nconst corsMiddleware = j.fromHono(cors())\nconst procedureWithCors = publicProcedure.use(corsMiddleware)\n```\n\n----------------------------------------\n\nTITLE: Using Type Inference for Dependent Middlewares in JStack\nDESCRIPTION: Shows how to use type inference utility when working with multiple middlewares that depend on each other, ensuring proper type safety and inference across middleware chain.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/middleware.mdx#2025-04-10_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { InferMiddlewareOutput, jstack } from \"jstack\"\n\ninterface Env {\n  Bindings: { DATABASE_URL: string }\n}\n\nexport const j = jstack.init<Env>()\n\n// 1Ô∏è‚É£ Auth middleware runs first\nconst authMiddleware = j.middleware(async ({ c, next }) => {\n  return await next({ user: { name: \"John Doe\" } })\n})\n\ntype AuthMiddlewareOutput = InferMiddlewareOutput<typeof authMiddleware>\n\n// 2Ô∏è‚É£ Logging middleware runs second\nconst loggingMiddleware = j.middleware(async ({ c, ctx, next }) => {\n  const { user } = ctx as AuthMiddlewareOutput\n\n  const start = performance.now()\n  await next()\n  const end = performance.now()\n\n  console.log(`${user.name}'s request took ${end - start}ms`)\n})\n\n/**\n * Public (unauthenticated) procedures\n * This is the base piece you use to build new procedures.\n */\nexport const publicProcedure = j.procedure\nexport const privateProcedure = publicProcedure\n  .use(authMiddleware)\n  .use(loggingMiddleware)\n```\n\n----------------------------------------\n\nTITLE: Dynamic Imports in JStack Procedures\nDESCRIPTION: Shows how to implement dynamic imports within JStack procedures for code splitting at the procedure level. The example demonstrates lazy loading of PDF generation and data processing utilities within a user router endpoint.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/performance.mdx#2025-04-10_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { j, publicProcedure } from \"../jstack\"\n\nexport const userRouter = j.router({\n  generateReport: publicProcedure.get(async ({ c }) => {\n      // üëá Dynamically import heavy dependencies\n      const { generatePDF } = await import(\"./utils/pdf-generator\")\n      const { processData } = await import(\"./utils/data-processor\")\n\n      const data = await processData(c.req.query())\n      const pdf = await generatePDF(data)\n\n      return c.json({ pdf })\n    })\n})\n```\n\n----------------------------------------\n\nTITLE: Project Structure for JStack Routers\nDESCRIPTION: Illustrates the typical file structure for a JStack project, highlighting the location of router files.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/routers.mdx#2025-04-10_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\napp/\n  ‚îî‚îÄ‚îÄ server/\n      ‚îú‚îÄ‚îÄ jstack.ts        # Initializing JStack\n      ‚îú‚îÄ‚îÄ index.ts         # Main appRouter\n      ‚îî‚îÄ‚îÄ routers/         # Router directory\n          ‚îú‚îÄ‚îÄ user-router.ts\n          ‚îú‚îÄ‚îÄ post-router.ts\n          ‚îî‚îÄ‚îÄ payment-router.ts\n```\n\n----------------------------------------\n\nTITLE: Configuring JStack Client with Cloudflare Workers URL\nDESCRIPTION: TypeScript code for setting up a JStack client that connects to the appropriate backend URL based on the environment (production or development).\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/deploy/cloudflare.mdx#2025-04-10_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { AppRouter } from \"@/server\"\nimport { createClient } from \"jstack\"\n\nexport const client = createClient<AppRouter>({\n  baseUrl: `${getBaseUrl()}/api`,\n})\n\nfunction getBaseUrl() {\n  // üëá In production, use the production worker\n  if (process.env.NODE_ENV === \"production\") {\n    return \"https://<YOUR_DEPLOYMENT>.workers.dev\"\n  }\n\n  // üëá Locally, use wrangler backend\n  return `http://localhost:8080`\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring CORS for JStack on Cloudflare Workers\nDESCRIPTION: TypeScript code showing how to properly configure CORS settings in a JStack application deployed to Cloudflare Workers to resolve cross-origin issues.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/deploy/cloudflare.mdx#2025-04-10_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { InferRouterInputs, InferRouterOutputs } from \"jstack\"\nimport { postRouter } from \"./routers/post-router\"\nimport { j } from \"./jstack\"\n\nconst api = j\n  .router()\n  .basePath(\"/api\")\n  .use(j.defaults.cors)\n  .onError(j.defaults.errorHandler)\n\nconst appRouter = j.mergeRouters(api, {\n  post: postRouter,\n})\n\nexport type AppRouter = typeof appRouter\n\nexport default appRouter\n```\n\n----------------------------------------\n\nTITLE: Configuring JStack Client for Separate Backend URL\nDESCRIPTION: TypeScript code to configure the JStack client to connect to a backend running on a different port. This example sets up the client to communicate with a Cloudflare Worker backend running on port 8080.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/getting-started/local-development.mdx#2025-04-10_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { AppRouter } from \"@/server\"\nimport { createClient } from \"jstack\"\n\nexport const client = createClient<AppRouter>({\n  // üëá Add our port 8080 cloudflare URL\n  baseUrl: \"http://localhost:8080/api\",\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring JStack Client for WebSockets\nDESCRIPTION: This TypeScript snippet shows how to configure the JStack client to use WebSockets, pointing to the Cloudflare backend on port 8080 for local development.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/websockets.mdx#2025-04-10_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { AppRouter } from \"@/server\"\nimport { createClient } from \"jstack\"\n\nexport const client = createClient<AppRouter>({\n  // üëá Point to Cloudflare Worker API\n  baseUrl: \"http://localhost:8080/api\",\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring JStack Client for Production WebSockets\nDESCRIPTION: This TypeScript code demonstrates how to configure the JStack client to use the appropriate WebSocket URL for both development and production environments.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/websockets.mdx#2025-04-10_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { AppRouter } from \"@/server\"\nimport { createClient } from \"jstack\"\n\nexport const client = createClient<AppRouter>({\n  baseUrl: `${getBaseUrl()}/api`,\n})\n\nfunction getBaseUrl() {\n  // üëá In production, use the production worker\n  if (process.env.NODE_ENV === \"production\") {\n    return \"https://<YOUR_DEPLOYMENT>.workers.dev/api\"\n  }\n\n  // üëá Locally, use wrangler backend\n  return `http://localhost:8080`\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Posts with Type-Safe Client in JStack with TypeScript\nDESCRIPTION: This snippet demonstrates how to use JStack's type-safe client to fetch recent posts. The response is automatically typed, providing type safety without being coupled to React Query hooks.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/introduction/key-features.mdx#2025-04-10_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst res = await client.post.recent.$get()\nconst post = await res.json()\n// ^ automatically type-safe: { post: Post }\n```\n\n----------------------------------------\n\nTITLE: Accessing Environment Variables in Node.js Environments\nDESCRIPTION: This code demonstrates how to access environment variables in Node.js environments, which works for both frontend and backend in platforms like Vercel and Netlify.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/getting-started/environment-variables.mdx#2025-04-10_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Works everywhere (frontend & backend)\nconst DATABASE_URL = process.env.DATABASE_URL\n```\n\n----------------------------------------\n\nTITLE: Accessing Environment Variables in Cloudflare Workers Frontend\nDESCRIPTION: This code shows how to access environment variables in the frontend (client and server components) when using Cloudflare Workers.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/getting-started/environment-variables.mdx#2025-04-10_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Frontend (client & server components)\nconst DATABASE_URL = process.env.DATABASE_URL\n```\n\n----------------------------------------\n\nTITLE: Accessing Environment Variables in Cloudflare Workers Backend API\nDESCRIPTION: This snippet demonstrates how to access environment variables in the backend API when using Cloudflare Workers, utilizing the Hono adapter.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/getting-started/environment-variables.mdx#2025-04-10_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Backend (API)\nimport { env } from \"hono/adapter\"\nimport { j } from \"jstack\"\n\nexport const postRouter = j.router({\n  recent: j.procedure.get(({ c }) => {\n    const { DATABASE_URL } = env(c)\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Deploying JStack Application to Cloudflare Workers\nDESCRIPTION: Command to deploy a JStack application to Cloudflare Workers using the Wrangler CLI, specifying the path to the server index file.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/deploy/cloudflare.mdx#2025-04-10_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwrangler deploy src/server/index.ts\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables in Cloudflare Workers\nDESCRIPTION: Command to set secret environment variables in a Cloudflare Worker using the Wrangler CLI.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/deploy/cloudflare.mdx#2025-04-10_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nwrangler secret put <KEY>\n```\n\n----------------------------------------\n\nTITLE: Setting Up Environment Variables for Local Node.js Development\nDESCRIPTION: This snippet shows how to set up environment variables in a .env file for local Node.js development, which is applicable for platforms like Vercel and Netlify.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/getting-started/environment-variables.mdx#2025-04-10_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nDATABASE_URL=your-database-url\n```\n\n----------------------------------------\n\nTITLE: Setting Up Environment Variables for Cloudflare Workers Local Development\nDESCRIPTION: This snippet illustrates how to set up environment variables in a .dev.vars file for local development with Cloudflare Workers using wrangler.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/getting-started/environment-variables.mdx#2025-04-10_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nDATABASE_URL=your-database-url\n```\n\n----------------------------------------\n\nTITLE: Installing JStack Using CLI\nDESCRIPTION: Command to create a new JStack project using the CLI tool, which automatically sets up a Next.js project with JStack following best practices.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/getting-started/first-steps.mdx#2025-04-10_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-jstack-app@latest\n```\n\n----------------------------------------\n\nTITLE: Running Next.js Development Server with JStack\nDESCRIPTION: Command to start the Next.js development server for JStack projects. This runs the application at http://localhost:3000 and is sufficient for deployments to Vercel, Netlify, or similar platforms.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/getting-started/local-development.mdx#2025-04-10_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Running Separate Frontend and Backend for Cloudflare Workers\nDESCRIPTION: Commands to start both the frontend (Next.js) and backend (Cloudflare Workers) services in separate terminals. This configuration runs the frontend on port 3000 and the backend on port 8080.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/getting-started/local-development.mdx#2025-04-10_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Terminal 1: Frontend\nnpm run dev     # Available on http://localhost:3000\n\n# Terminal 2: Backend\nwrangler dev    # Available on http://localhost:8080\n```\n\n----------------------------------------\n\nTITLE: Installing Wrangler CLI for Cloudflare Workers Deployment\nDESCRIPTION: Command to install the Wrangler CLI globally using npm, which is required for deploying to Cloudflare Workers.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/deploy/cloudflare.mdx#2025-04-10_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install wrangler@latest -g\n```\n\n----------------------------------------\n\nTITLE: Adding Environment Variables via Vercel CLI\nDESCRIPTION: This command demonstrates how to add environment variables to a Vercel project using the Vercel CLI. It's an alternative to setting them through the Vercel dashboard.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/deploy/vercel.mdx#2025-04-10_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvercel env add <KEY>\n```\n\n----------------------------------------\n\nTITLE: Deploying JStack Server to Cloudflare Workers Using Wrangler CLI\nDESCRIPTION: This command shows how to deploy a JStack backend to Cloudflare Workers using the Wrangler CLI tool. This enables cost-effective serverless deployment separate from the frontend.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/introduction/key-features.mdx#2025-04-10_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx wrangler deploy server/index.ts\n```\n\n----------------------------------------\n\nTITLE: Deploying JStack WebSockets to Cloudflare Workers\nDESCRIPTION: This command deploys the JStack backend to Cloudflare Workers using Wrangler, which is necessary for supporting long-lived WebSocket connections.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/websockets.mdx#2025-04-10_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nwrangler deploy src/server/index.ts\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables for JStack WebSockets\nDESCRIPTION: This snippet shows the content of a .dev.vars file used to store Upstash Redis environment variables for local development of JStack WebSockets.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/websockets.mdx#2025-04-10_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nUPSTASH_REDIS_REST_URL=\nUPSTASH_REDIS_REST_TOKEN=\n```\n\n----------------------------------------\n\nTITLE: Starting Cloudflare Backend for JStack WebSockets\nDESCRIPTION: This command is used to start the Cloudflare backend for local development of JStack WebSockets using Wrangler.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/websockets.mdx#2025-04-10_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nwrangler dev\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for JStack WebSockets in Cloudflare Workers\nDESCRIPTION: These commands use Wrangler to set the necessary Upstash Redis environment variables in Cloudflare Workers for JStack WebSockets in production.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/src/docs/backend/websockets.mdx#2025-04-10_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# Create UPSTASH_REDIS_REST_URL environment variable\nwrangler secret put UPSTASH_REDIS_REST_URL\n\n# Create UPSTASH_REDIS_REST_TOKEN environment variable\nwrangler secret put UPSTASH_REDIS_REST_TOKEN\n```\n\n----------------------------------------\n\nTITLE: Defining JStack Project Overview in Markdown\nDESCRIPTION: This snippet provides a markdown header and brief description of the JStack project, emphasizing its goal of enabling high-performance Next.js apps at a low cost.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/README.md#2025-04-10_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n## JStack\n\nShip high-performance Next.js apps for extremely cheap\n```\n\n----------------------------------------\n\nTITLE: Listing JStack Improvement Tasks in Markdown\nDESCRIPTION: This markdown snippet outlines areas for improvement in the JStack project, including UI enhancements and additional documentation topics to be covered.\nSOURCE: https://github.com/upstash/jstack/blob/main/www/README.md#2025-04-10_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\nStuff to improve\n- footer padding\n- docs \"on this page\" visual bug\n- add docs for:\n    - procedures\n    - cloudflare deployment\n    - vercel deployment\n```"
  }
]