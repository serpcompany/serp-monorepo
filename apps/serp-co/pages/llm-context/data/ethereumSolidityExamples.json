[
  {
    "owner": "ethereum",
    "repo": "solidity-examples",
    "content": "TITLE: Defining ERC20TokenFace Interface in Solidity\nDESCRIPTION: This code snippet defines the ERC20TokenFace interface, which includes all the required functions and events for an ERC-20 compliant token. It serves as a contract template for implementing ERC-20 tokens.\nSOURCE: https://github.com/ethereum/solidity-examples/blob/master/docs/tokens/ERC20TokenFace.md#2025-04-23_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\ninterface ERC20TokenFace {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address who) public view returns (uint256);\n    function transfer(address to, uint256 value) public returns (bool);\n    function allowance(address owner, address spender) public view returns (uint256);\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\n    function approve(address spender, uint256 value) public returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n```\n\n----------------------------------------\n\nTITLE: Solidity ExactMath Library Reference\nDESCRIPTION: Library implementation for exact arithmetic operations in Solidity smart contracts. Based on OpenZeppelin's SafeMath library, providing protection against under/overflow conditions.\nSOURCE: https://github.com/ethereum/solidity-examples/blob/master/docs/math/ExactMath.md#2025-04-23_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\n// ExactMath.sol\n// TODO: Implementation details are not shown in the provided text\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Solidity String Library\nDESCRIPTION: Library reference and example files for string validation functionality in Solidity. The library enables runtime validation of UTF-8 strings according to Unicode 10.0 standards.\nSOURCE: https://github.com/ethereum/solidity-examples/blob/master/docs/strings/Strings.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nPackage: strings\nContract type: Static library\nSource file: Strings.sol\nExample usage: StringsExamples.sol\nTests source file: strings_tests.sol\nPerf (gas usage) source file: strings_perfs.sol\n```\n\n----------------------------------------\n\nTITLE: Implementing Base STLTest Contract in Solidity\nDESCRIPTION: The base STLTest contract that all test contracts extend. It provides a standardized 'test' method and requires implementation of an internal 'testImpl' method where the actual test logic resides.\nSOURCE: https://github.com/ethereum/solidity-examples/blob/master/docs/testing.md#2025-04-23_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\ncontract STLTest {\n\n    function test() public payable returns (bool ret) {\n        ret = true;\n        testImpl();\n    }\n\n    function testImpl() internal;\n\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Base Performance Contract Interface in Solidity\nDESCRIPTION: Base contract interface 'STLPerf' that defines the standard performance testing method. All performance test contracts must implement this interface with the 'perf' function that returns gas usage.\nSOURCE: https://github.com/ethereum/solidity-examples/blob/master/docs/perf.md#2025-04-23_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\ncontract STLPerf {\n    function perf() public payable returns (uint);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Bytes Padding with Literals in Solidity\nDESCRIPTION: Shows how number and string literals are padded differently when assigned to bytes32 variables. Number literals are left-padded while string literals are right-padded.\nSOURCE: https://github.com/ethereum/solidity-examples/blob/master/docs/bytes/Bytes.md#2025-04-23_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\n// 0x0000000000000000000000000000000000000000000000000000000001020304\nvar numLit = bytes32(0x01020304);\n\n// 0x3031303230333034000000000000000000000000000000000000000000000000\nvar strLit = bytes32(\"01020304\");\n```\n\n----------------------------------------\n\nTITLE: Accessing Individual Bytes by Index in Solidity\nDESCRIPTION: Demonstrates how to access individual bytes within bytes32 variables using array index notation. The highest order byte is at index 0.\nSOURCE: https://github.com/ethereum/solidity-examples/blob/master/docs/bytes/Bytes.md#2025-04-23_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\nvar numLit_0 = numLit[0]; // 0\nvar numLit_31 = numLit[31]; // 0x04\n\nvar strLit_0 = strLit[0]; // 0x30\nvar strLit_31 = strLit[31]; // 0\n```\n\n----------------------------------------\n\nTITLE: Implementing Bytes Comparison Performance Test in Solidity\nDESCRIPTION: Example performance test contract that measures gas usage for the Bytes.equals function when comparing byte arrays of different lengths. It demonstrates how to measure gas consumption by calculating the difference between pre and post execution gas values.\nSOURCE: https://github.com/ethereum/solidity-examples/blob/master/docs/perf.md#2025-04-23_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\ncontract PerfBytesEqualsDifferentLengthFail is BytesPerf {\n    function perf() public payable returns (uint) {\n        bytes memory bts1 = new bytes(0);\n        bytes memory bts2 = new bytes(1);\n        uint gasPre = msg.gas;\n        Bytes.equals(bts1, bts2);\n        uint gasPost = msg.gas;\n        return gasPre - gasPost;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Base Test Contract for Bits Library in Solidity\nDESCRIPTION: The BitsTest contract is an abstract contract that extends STLTest and provides common constants and utilities for testing the Bits library. It uses Solidity's 'using for' directive to bind the Bits library to uint types.\nSOURCE: https://github.com/ethereum/solidity-examples/blob/master/docs/testing.md#2025-04-23_snippet_2\n\nLANGUAGE: solidity\nCODE:\n```\ncontract BitsTest is STLTest {\n    using Bits for uint;\n\n    uint constant ZERO = uint(0);\n    uint constant ONE = uint(1);\n    uint constant ONES = uint(~0);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Memory Static Library in Solidity\nDESCRIPTION: Declaration of the Memory static library in Solidity. This library is part of the 'unsafe' package and provides methods for direct memory operations, which are potentially unsafe but useful for low-level manipulations.\nSOURCE: https://github.com/ethereum/solidity-examples/blob/master/docs/unsafe/Memory.md#2025-04-23_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\n// Memory.sol\n\npackage unsafe\n\ncontract Memory {\n    // Library methods would be defined here\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Bits.bitXor Test in Solidity\nDESCRIPTION: A test contract for the bitXor function of the Bits library. It verifies that XOR operations work correctly by testing various combinations of bit values.\nSOURCE: https://github.com/ethereum/solidity-examples/blob/master/docs/testing.md#2025-04-23_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\ncontract TestBitsBitXor is BitsTest {\n    function testImpl() internal {\n        for (uint8 i = 0; i < 12; i++) {\n            assert(ONES.bitXor(ONES, i*20) == 0);\n            assert(ONES.bitXor(ZERO, i*20) == 1);\n            assert(ZERO.bitXor(ONES, i*20) == 1);\n            assert(ZERO.bitXor(ZERO, i*20) == 0);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using byte Instruction in Solidity Assembly\nDESCRIPTION: Shows how to use inline assembly to access individual bytes using the byte instruction. The instruction takes an index and data parameter.\nSOURCE: https://github.com/ethereum/solidity-examples/blob/master/docs/bytes/Bytes.md#2025-04-23_snippet_2\n\nLANGUAGE: solidity\nCODE:\n```\nuint numLit_0;\nuint numLit_31;\nassembly {\n    numLit_0 := byte(0, numLit)\n    numLit_31 := byte(31, numLit)\n}\n// numLit_0 == 0\n// numLit_31 == 4\n```\n\n----------------------------------------\n\nTITLE: Type Conversion with Assembly in Solidity\nDESCRIPTION: Demonstrates type conversion between bytes32 and byte using inline assembly, showing potential issues with value representation.\nSOURCE: https://github.com/ethereum/solidity-examples/blob/master/docs/bytes/Bytes.md#2025-04-23_snippet_4\n\nLANGUAGE: solidity\nCODE:\n```\nbytes32 b32 = \"Terry A. Davis\";\nbyte b;\nassembly {\n    b := byte(0, b32)\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing byte and uint8 Type Representations\nDESCRIPTION: Illustrates the difference between byte and uint8 internal representations when storing the same value.\nSOURCE: https://github.com/ethereum/solidity-examples/blob/master/docs/bytes/Bytes.md#2025-04-23_snippet_3\n\nLANGUAGE: solidity\nCODE:\n```\n// 0x0000000000000000000000000000000000000000000000000000000000000001\nuint8 u8 = 1;\n\n// 0x0100000000000000000000000000000000000000000000000000000000000000\nbyte b = 1;\n```"
  }
]