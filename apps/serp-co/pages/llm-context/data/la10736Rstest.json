[
  {
    "owner": "la10736",
    "repo": "rstest",
    "content": "TITLE: Complete RSTest Example with Multiple Features\nDESCRIPTION: Comprehensive example showing fixture usage, case naming, panic testing, and value parameters in combination.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::*;\n\n#[fixture]\nfn repository() -> InMemoryRepository {\n    let mut r = InMemoryRepository::default();\n    // fill repository with some data\n    r\n}\n\n#[fixture]\nfn alice() -> User {\n    User::logged(\"Alice\", \"2001-10-04\", \"London\", \"UK\")\n}\n\n#[rstest]\n#[case::authorized_user(alice())] // We can use `fixture` also as standard function\n#[case::guest(User::Guest)]   // We can give a name to every case : `guest` in this case\n// and `authorized_user`\n#[should_panic(expected = \"Invalid query error\")] // We would test a panic\nfn should_be_invalid_query_error(\n    repository: impl Repository,\n    #[case] user: User,\n    #[values(\"     \", \"^%$some#@invalid!chars\", \".n.o.d.o.t.s.\")] query: &str,\n) {\n    repository.find_items(&user, query).unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Example with Multiple Features\nDESCRIPTION: Comprehensive example showing multiple RSTest features including fixtures, case attributes, and parameterized testing with different user scenarios.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::*;\n\n#[fixture]\nfn repository() -> InMemoryRepository {\n    let mut r = InMemoryRepository::default();\n    // fill repository with some data\n    r\n}\n\n#[fixture]\nfn alice() -> User {\n    User::logged(\"Alice\", \"2001-10-04\", \"London\", \"UK\")\n}\n\n#[rstest]\n#[case::authorized_user(alice())] // We can use `fixture` also as standard function\n#[case::guest(User::Guest)]   // We can give a name to every case : `guest` in this case\n// and `authorized_user`\n#[should_panic(expected = \"Invalid query error\")] // We would test a panic\nfn should_be_invalid_query_error(\n    repository: impl Repository,\n    #[case] user: User,\n    #[values(\"     \", \"^%$some#@invalid!chars\", \".n.o.d.o.t.s.\")] query: &str,\n) {\n    repository.find_items(&user, query).unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Using Values Attribute for Multiple Test Cases\nDESCRIPTION: Demonstrates how to provide a list of values to test using the #[values] attribute, which will generate a test for each value in the list.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::rstest;\n\n#[rstest]\nfn should_be_invalid(\n    #[values(None, Some(\"\"), Some(\"    \"))]\n    value: Option<&str>\n) {\n    assert!(!valid(value))\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Fixture Definition and Usage in Rust Tests\nDESCRIPTION: Demonstrates how to define a fixture that returns a u32 value and use it in two test functions. One test expects the fixture value to match 42, while the other expects it not to match.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::*;\n\n#[fixture]\npub fn fixture() -> u32 { 42 }\n\n#[rstest]\nfn should_success(fixture: u32) {\n        assert_eq!(fixture, 42);\n}\n\n#[rstest]\nfn should_fail(fixture: u32) {\n        assert_ne!(fixture, 42);\n}\n```\n\n----------------------------------------\n\nTITLE: Parametrized Test for Fibonacci Function\nDESCRIPTION: Shows how to create multiple test cases for a fibonacci function using the #[case] attribute to provide different input and expected output values.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::rstest;\n\n#[rstest]\n#[case(0, 0)]\n#[case(1, 1)]\n#[case(2, 1)]\n#[case(3, 2)]\n#[case(4, 3)]\nfn fibonacci_test(#[case] input: u32, #[case] expected: u32) {\n    assert_eq!(expected, fibonacci(input))\n}\n```\n\n----------------------------------------\n\nTITLE: Parameterized Testing with Case Values\nDESCRIPTION: Shows how to create parameterized tests using the #[case] attribute to specify input and expected values for multiple test cases, which generates a separate test for each case.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::rstest;\n\n#[rstest]\n#[case(0, 0)]\n#[case(1, 1)]\n#[case(2, 1)]\n#[case(3, 2)]\n#[case(4, 3)]\nfn fibonacci_test(#[case] input: u32, #[case] expected: u32) {\n    assert_eq!(expected, fibonacci(input))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Once-Initialized Fixtures\nDESCRIPTION: Shows how to use the #[once] attribute to create fixtures that are initialized only once and shared across all tests, returning a reference to the same value.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n#[fixture]\n#[once]\nfn once_fixture() -> i32 { 42 }\n\n#[rstest]\nfn single(once_fixture: &i32) {\n    // All tests that use once_fixture will share the same reference to once_fixture() \n    // function result.\n    assert_eq!(&42, once_fixture)\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced Fixture Injection and Default Values\nDESCRIPTION: Shows how fixtures can be injected by other fixtures and use default values, demonstrating various injection patterns.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\n#[fixture]\nfn user(#[default(\"Alice\")] name: &str, #[default(22)] age: u8) -> User {\n    User::new(name, age)\n}\n\n#[rstest]\nfn is_alice(user: User) {\n    assert_eq!(user.name(), \"Alice\")\n}\n\n#[rstest]\nfn is_22(user: User) {\n    assert_eq!(user.age(), 22)\n}\n\n#[rstest]\nfn is_bob(#[with(\"Bob\")] user: User) {\n    assert_eq!(user.name(), \"Bob\")\n}\n\n#[rstest]\nfn is_42(#[with(\"\", 42)] user: User) {\n    assert_eq!(user.age(), 42)\n}\n```\n\n----------------------------------------\n\nTITLE: Fixture Injection and Default Values\nDESCRIPTION: Shows how fixtures can be injected by other fixtures and how to use default values with partial argument overrides.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\n#[fixture]\nfn user(#[default(\"Alice\")] name: &str, #[default(22)] age: u8) -> User {\n    User::new(name, age)\n}\n\n#[rstest]\nfn is_alice(user: User) {\n    assert_eq!(user.name(), \"Alice\")\n}\n\n#[rstest]\nfn is_22(user: User) {\n    assert_eq!(user.age(), 22)\n}\n\n#[rstest]\nfn is_bob(#[with(\"Bob\")] user: User) {\n    assert_eq!(user.name(), \"Bob\")\n}\n\n#[rstest]\nfn is_42(#[with(\"\", 42)] user: User) {\n    assert_eq!(user.age(), 42)\n}\n```\n\n----------------------------------------\n\nTITLE: Adding rstest to Cargo.toml Dependencies\nDESCRIPTION: Shows how to include rstest as a development dependency in a Rust project's Cargo.toml file, specifying the version number.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dev-dependencies]\nrstest = \"0.25.0\"\n```\n\n----------------------------------------\n\nTITLE: Async Test Support with Case Attributes\nDESCRIPTION: Shows how to create asynchronous tests with rstest, including support for should_panic and case-specific parameters.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::*;\n\n#[rstest]\n#[case(5, 2, 3)]\n#[should_panic]\n#[case(42, 40, 1)]\nasync fn my_async_test(#[case] expected: u32, #[case] a: u32, #[case] b: u32) {\n    assert_eq!(expected, async_sum(a, b).await);\n}\n```\n\n----------------------------------------\n\nTITLE: Async Testing Support\nDESCRIPTION: Shows how to write async tests with rstest, using the built-in async-std integration. Demonstrates parameterized async testing and should_panic attribute.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::*;\n\n#[rstest]\n#[case(5, 2, 3)]\n#[should_panic]\n#[case(42, 40, 1)]\nasync fn my_async_test(#[case] expected: u32, #[case] a: u32, #[case] b: u32) {\n    assert_eq!(expected, async_sum(a, b).await);\n}\n```\n\n----------------------------------------\n\nTITLE: Test Tracing with RSTest\nDESCRIPTION: Demonstrates the trace attribute usage for debugging test inputs and showing variable values during test execution.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\n#[rstest]\n#[case(42, \"FortyTwo\", (\"minus twelve\", -12))]\n#[case(24, \"TwentyFour\", (\"minus twentyfour\", -24))]\n#[trace] //This attribute enable tracing\nfn should_fail(#[case] number: u32, #[case] name: &str, #[case] tuple: (&str, i32)) {\n    assert!(false); // <- stdout come out just for failed tests\n}\n```\n\n----------------------------------------\n\nTITLE: Once-Initialized Fixtures with #[once]\nDESCRIPTION: Demonstrates how to create a fixture that is initialized only once and shared across all tests that use it.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n#[fixture]\n#[once]\nfn once_fixture() -> i32 { 42 }\n\n#[rstest]\nfn single(once_fixture: &i32) {\n    // All tests that use once_fixture will share the same reference to once_fixture() \n    // function result.\n    assert_eq!(&42, once_fixture)\n}\n```\n\n----------------------------------------\n\nTITLE: Using Test Context Object in RSTest\nDESCRIPTION: Shows how to access test context information using the Context object, including test name, description, case number and execution timing.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::{rstest, Context};\n\n#[rstest]\n#[case::a_description(42)]\nfn my_test(#[context] ctx: Context, #[case] _c: u32) {\n    assert_eq!(\"my_test\", ctx.name);\n    assert_eq!(Some(\"a_description\"), ctx.description);\n    assert_eq!(Some(0), ctx.case);\n\n    std::thread::sleep(std::time::Duration::from_millis(100));\n    assert!(ctx.start.elapsed() >= std::time::Duration::from_millis(100));\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Test Timeouts\nDESCRIPTION: Demonstrates how to set execution timeouts for tests using the #[timeout] attribute, which works for both synchronous and asynchronous tests.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::*;\nuse std::time::Duration;\n\nasync fn delayed_sum(a: u32, b: u32, delay: Duration) -> u32 {\n    async_std::task::sleep(delay).await;\n    a + b\n}\n\n#[rstest]\n#[timeout(Duration::from_millis(80))]\nasync fn single_pass() {\n    assert_eq!(4, delayed_sum(2, 2, ms(10)).await);\n}\n```\n\n----------------------------------------\n\nTITLE: Async Test with Actix Runtime in Rust\nDESCRIPTION: Demonstrates how to use RSTest with async functions and the actix_rt test attribute. Shows parameterized testing with async results and future values.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::*;\nuse actix_rt;\nuse std::future::Future;\n\n#[rstest]\n#[case(2, async { 4 })]\n#[case(21, async { 42 })]\n#[actix_rt::test]\nasync fn my_async_test(#[case] a: u32, #[case]\n#[future] result: u32) {\n    assert_eq!(2 * a, result.await);\n}\n```\n\n----------------------------------------\n\nTITLE: Test Timeout with Case-Specific Overrides\nDESCRIPTION: Demonstrates how to set different timeouts for different test cases, overriding a global timeout setting.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nfn ms(ms: u32) -> Duration {\n    Duration::from_millis(ms.into())\n}\n\n#[rstest]\n#[case::pass(ms(1), 4)]\n#[timeout(ms(10))]\n#[case::fail_timeout(ms(60), 4)]\n#[case::fail_value(ms(1), 5)]\n#[timeout(ms(100))]\nasync fn group_one_timeout_override(#[case] delay: Duration, #[case] expected: u32) {\n    assert_eq!(expected, delayed_sum(2, 2, delay).await);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Value Lists in Tests\nDESCRIPTION: Demonstrates using the #[values] attribute to provide multiple test values for a single parameter, generating a test for each value in the list.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::rstest;\n\n#[rstest]\nfn should_be_invalid(\n    #[values(None, Some(\"\"), Some(\"    \"))]\n    value: Option<&str>\n) {\n    assert!(!valid(value))\n}\n```\n\n----------------------------------------\n\nTITLE: Reusing Test Cases with rstest_reuse\nDESCRIPTION: Shows how to define test case templates with rstest_reuse that can be applied to multiple test functions to avoid duplication.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::rstest;\nuse rstest_reuse::{self, *};\n\n#[template]\n#[rstest]\n#[case(2, 2)]\n#[case(4/2, 2)]\nfn two_simple_cases(#[case] a: u32, #[case] b: u32) {}\n\n#[apply(two_simple_cases)]\nfn it_works(#[case] a: u32, #[case] b: u32) {\n    assert!(a == b);\n}\n```\n\n----------------------------------------\n\nTITLE: Local Lifetime and By-Ref Attribute Usage\nDESCRIPTION: Demonstrates using local lifetimes with the #[by_ref] attribute for handling references in test functions and fixtures.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nenum E<'a> {\n    A(bool),\n    B(&'a Cell<E<'a>>),\n}\n\nfn make_e_from_bool<'a>(_bump: &'a (), b: bool) -> E<'a> {\n    E::A(b)\n}\n\n#[fixture]\nfn bump() -> () {}\n\n#[rstest]\n#[case(true, E::A(true))]\nfn it_works<'a>(#[by_ref] bump: &'a (), #[case] b: bool, #[case] expected: E<'a>) {\n    let actual = make_e_from_bool(&bump, b);\n    assert_eq!(actual, expected);\n}\n```\n\n----------------------------------------\n\nTITLE: Testing with File Paths using #[files]\nDESCRIPTION: Shows how to generate tests for files that match a glob pattern, with options to exclude certain files or include dot files.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n#[rstest]\nfn for_each_file(#[files(\"src/**/*.rs\")]\n                 #[exclude(\"test\")] path: PathBuf) {\n    assert!(check_file(&path))\n}\n```\n\n----------------------------------------\n\nTITLE: Simplifying Async Test Code with #[awt]\nDESCRIPTION: Shows how to use the #[awt] attribute to automatically await future values in test functions, reducing boilerplate code.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::*;\n# #[fixture]\n# async fn base() -> u32 { 42 }\n#[rstest]\n#[case(21, async { 2 })]\n#[case(6, async { 7 })]\n#[awt]\nasync fn global(#[future] base: u32, #[case] expected: u32, #[future]\n#[case] div: u32) {\n    assert_eq!(expected, base / div);\n}\n#[rstest]\n#[case(21, async { 2 })]\n#[case(6, async { 7 })]\nasync fn single(#[future] base: u32, #[case] expected: u32, #[future(awt)]\n#[case] div: u32) {\n    assert_eq!(expected, base.await / div);\n}\n```\n\n----------------------------------------\n\nTITLE: Local Lifetime Management with by_ref Attribute\nDESCRIPTION: Demonstrates using the #[by_ref] attribute for handling local lifetimes in test arguments, showing usage with enums and fixture references.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nenum E<'a> {\n    A(bool),\n    B(&'a Cell<E<'a>>),\n}\n\nfn make_e_from_bool<'a>(_bump: &'a (), b: bool) -> E<'a> {\n    E::A(b)\n}\n\n#[fixture]\nfn bump() -> () {}\n\n#[rstest]\n#[case(true, E::A(true))]\nfn it_works<'a>(#[by_ref] bump: &'a (), #[case] b: bool, #[case] expected: E<'a>) {\n    let actual = make_e_from_bool(&bump, b);\n    assert_eq!(actual, expected);\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Templates Across Crates in Rust\nDESCRIPTION: Shows how to export test templates across crates using the #[export] attribute. Includes the necessary setup for making templates accessible from other crates by re-exporting the template and making rstest_reuse public.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest_reuse/README.md#2025-04-20_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub use my::modules::path::of::my::template::my_template;\n```\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(test)]\npub use rstest_reuse;\n```\n\n----------------------------------------\n\nTITLE: Test Timeout Configuration\nDESCRIPTION: Shows how to set execution timeouts for tests using the #[timeout] attribute with a Duration value.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::*;\nuse std::time::Duration;\n\nasync fn delayed_sum(a: u32, b: u32, delay: Duration) -> u32 {\n    async_std::task::sleep(delay).await;\n    a + b\n}\n\n#[rstest]\n#[timeout(Duration::from_millis(80))]\nasync fn single_pass() {\n    assert_eq!(4, delayed_sum(2, 2, ms(10)).await);\n}\n```\n\n----------------------------------------\n\nTITLE: Running Parametrized Tests with Cargo\nDESCRIPTION: Shows the output of running the parametrized test cases with cargo test, demonstrating how each case becomes a separate test.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nrunning 5 tests\ntest fibonacci_test::case_1 ... ok\ntest fibonacci_test::case_2 ... ok\ntest fibonacci_test::case_3 ... ok\ntest fibonacci_test::case_4 ... ok\ntest fibonacci_test::case_5 ... ok\n\ntest result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```\n\n----------------------------------------\n\nTITLE: Auto-Awaiting Future Values with #[awt]\nDESCRIPTION: Shows how to use the #[awt] attribute to automatically await future values, either globally for all test inputs or individually for specific parameters.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::*;\n# #[fixture]\n# async fn base() -> u32 { 42 }\n#[rstest]\n#[case(21, async { 2 })]\n#[case(6, async { 7 })]\n#[awt]\nasync fn global(#[future] base: u32, #[case] expected: u32, #[future]\n#[case] div: u32) {\n    assert_eq!(expected, base / div);\n}\n#[rstest]\n#[case(21, async { 2 })]\n#[case(6, async { 7 })]\nasync fn single(#[future] base: u32, #[case] expected: u32, #[future(awt)]\n#[case] div: u32) {\n    assert_eq!(expected, base.await / div);\n}\n```\n\n----------------------------------------\n\nTITLE: Type Conversion from String Literals\nDESCRIPTION: Shows how to use string literals that will be automatically converted to types that implement FromStr, such as SocketAddr.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n# use rstest::rstest;\n# use std::net::SocketAddr;\n#[rstest]\n#[case(\"1.2.3.4:8080\", 8080)]\n#[case(\"127.0.0.1:9000\", 9000)]\nfn check_port(#[case] addr: SocketAddr, #[case] expected: u16) {\n    assert_eq!(expected, addr.port());\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Async Inputs Using #[future]\nDESCRIPTION: Demonstrates how to handle async input values in tests using the #[future] attribute to simplify the syntax.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::*;\n#[fixture]\nasync fn base() -> u32 { 42 }\n\n#[rstest]\n#[case(21, async { 2 })]\n#[case(6, async { 7 })]\nasync fn my_async_test(#[future] base: u32, #[case] expected: u32, #[future]\n#[case] div: u32) {\n    assert_eq!(expected, base.await / div.await);\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling async-std for Async Tests\nDESCRIPTION: Shows how to configure the async-std dependency with the attributes feature to support async testing.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_9\n\nLANGUAGE: toml\nCODE:\n```\nasync-std = { version = \"1.13\", features = [\"attributes\"] }\n```\n\n----------------------------------------\n\nTITLE: Test Output for Parameterized Tests\nDESCRIPTION: Shows the console output when running parametrized tests with cargo test, demonstrating how each case is executed as a separate test.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nrunning 5 tests\ntest fibonacci_test::case_1 ... ok\ntest fibonacci_test::case_2 ... ok\ntest fibonacci_test::case_3 ... ok\ntest fibonacci_test::case_4 ... ok\ntest fibonacci_test::case_5 ... ok\n\ntest result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```\n\n----------------------------------------\n\nTITLE: Running Tests on Stable Rust Channel\nDESCRIPTION: This command runs all tests for the rstest project using the stable Rust channel. It sets the RSTEST_TEST_CHANNEL environment variable and uses cargo to execute the tests.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest_test/checkoutlist.md#2025-04-20_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nRSTEST_TEST_CHANNEL=stable cargo +${RSTEST_TEST_CHANNEL} test\n```\n\n----------------------------------------\n\nTITLE: Using Templates with Fixtures and Values in Rust Tests\nDESCRIPTION: Demonstrates using templates with fixtures and values parameters. The example defines a base template with a fixture and values that is then applied to two different test functions, one using the fixture and one without it.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest_reuse/README.md#2025-04-20_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[template]\n#[rstest]\nfn base(#[with(42)] fix: u32, #[values(1,2,3)] v: u32) {}\n\n#[fixture]\nfn fix(#[default(0)] inner: u32) -> u32 {\n    inner\n}\n\n#[apply(base)]\nfn use_it_with_fixture(fix: u32, v: u32) {\n    assert!(fix%v == 0);\n}\n\n#[apply(base)]\nfn use_it_without_fixture(v: u32) {\n    assert!(24 % v == 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests on Rust Nightly Channel\nDESCRIPTION: Command to run tests using the nightly Rust channel for the rstest project.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest_reuse/checkoutlist.md#2025-04-20_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nRSTEST_TEST_CHANNEL=nightly cargo +${RSTEST_TEST_CHANNEL} test\n```\n\n----------------------------------------\n\nTITLE: Composing Templates with Additional Cases and Values in Rust Testing\nDESCRIPTION: Shows how to compose test templates by adding new test cases and value lists when applying a template. This example extends a base template with an additional case and a values parameter.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest_reuse/README.md#2025-04-20_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[template]\n#[rstest]\n#[case(2, 2)]\n#[case(4/2, 2)]\nfn base(#[case] a: u32, #[case] b: u32) {}\n\n// Here we add a new case and an argument in a value list:\n#[apply(base)]\n#[case(9/3, 3)]\nfn it_works(a: u32, b: u32, #[values(\"a\", \"b\")] t: &str) {\n    assert!(a == b);\n    assert!(\"abcd\".contains(t))\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Cargo Package\nDESCRIPTION: Command to publish the rstest package to crates.io.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest_reuse/checkoutlist.md#2025-04-20_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncargo publish\n```\n\n----------------------------------------\n\nTITLE: Defining and Applying Test Templates in Rust with rstest_reuse\nDESCRIPTION: Demonstrates how to define a template with test cases using #[template] and apply it to different test functions using #[apply]. The example creates two test functions that use the same test cases but with different assertions.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest_reuse/README.md#2025-04-20_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::rstest;\nuse rstest_reuse::{self, *};\n\n// Here we define the template. This defines\n// * The test list name to `two_simple_cases`\n// * cases: here two cases\n#[template]\n#[rstest]\n#[case(2, 2)]\n#[case(4/2, 2)]\n// Define a and b as cases arguments\nfn two_simple_cases(#[case] a: u32, #[case] b: u32) {}\n\n// Here we apply the `two_simple_cases` template.\n// This is expanded into:\n// #[template]\n// #[rstest]\n// #[case(2, 2)]\n// #[case(4/2, 2)]\n// fn it_works(#[case] a: u32,#[case] b: u32) {\n//     assert!(a == b);\n// }\n#[apply(two_simple_cases)]\nfn it_works(a: u32, b: u32) {\n    assert!(a == b);\n}\n\n// Here we reuse the `two_simple_cases` template to create two \n// other tests:\n#[apply(two_simple_cases)]\nfn it_fail(a: u32, b: u32) {\n    assert!(a != b);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TempFile for Resource Management in Rust\nDESCRIPTION: This snippet introduces a TempFile struct that wraps PathBuf and implements Drop and AsRef<Path> traits. It ensures proper cleanup of temporary files and demonstrates advanced resource management in Rust.\nSOURCE: https://github.com/la10736/rstest/blob/master/notes.md#2025-04-20_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::path::{PathBuf, Path};\n\nuse rstest::*;\n\nstruct TempFile(PathBuf);\n\nimpl Drop for TempFile {fn drop(&mut self) {\n         std::fs::remove_file(&self.0).unwrap();\n     }\n}\n\nimpl AsRef<Path> for TempFile {\n    fn as_ref(&self) -> &Path {\n        &self.0\n    }\n}\n\n#[fixture]\nfn empty() -> TempFile {\n     let path = \"empty_file\".into();\n     std::fs::File::create(&path).expect(\"Cannot open\");\n     TempFile(path)\n}\n```\n\n----------------------------------------\n\nTITLE: Generalizing Matrix Parsing Test in Rust\nDESCRIPTION: This snippet further generalizes the test by making it work with any type that implements AsRef<Path>. It demonstrates how to write more flexible and reusable tests.\nSOURCE: https://github.com/la10736/rstest/blob/master/notes.md#2025-04-20_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::path::{PathBuf, Path};\n\nuse rstest::*;\n\n#[derive(Default, Debug, PartialEq)]\nstruct Matrix { rows: usize, cols: usize, data: Vec<i32> }\n\nimpl<P: AsRef<Path>> From<P> for Matrix { fn from(_: P) -> Self { Default::default() } }\n\n#[rstest]\nfn should_parse_empty_file<P>(empty: P)\n     where P: AsRef<Path>\n{\n     let matrix: Matrix = Matrix::from(empty);\n\n     assert_eq!(matrix, Default::default())\n}\n```\n\n----------------------------------------\n\nTITLE: Refactoring Matrix Parsing Test with rstest in Rust\nDESCRIPTION: This snippet refactors the previous test using rstest. It introduces a fixture for creating an empty file and demonstrates how to use it in a test function.\nSOURCE: https://github.com/la10736/rstest/blob/master/notes.md#2025-04-20_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::path::{PathBuf, Path};\n\nuse rstest::*;\n\n#[derive(Default, Debug, PartialEq)]\nstruct Matrix { rows: usize, cols: usize, data: Vec<i32> }\nimpl<P: AsRef<Path>> From<P> for Matrix { fn from(_: P) -> Self { Default::default() } }\n\n#[fixture]\nfn empty() -> PathBuf {\n     let path = \"empty_file\".into();\n     std::fs::File::create(&path).expect(\"Cannot open\");\n     path\n}\n\n#[rstest]\nfn should_parse_empty_file(empty: PathBuf) {\n     let matrix: Matrix = Matrix::from(empty);\n\n     assert_eq!(matrix, Default::default())\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Matrix Struct and File Parsing in Rust\nDESCRIPTION: This snippet defines a Matrix struct with a From trait implementation for file parsing. It includes a simple test function to parse an empty file.\nSOURCE: https://github.com/la10736/rstest/blob/master/notes.md#2025-04-20_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::path::{PathBuf, Path};\n\n#[derive(Default, Debug, PartialEq)]\nstruct Matrix { rows: usize, cols: usize, data: Vec<i32> }\n\nimpl<P: AsRef<Path>> From<P> for Matrix { fn from(_: P) -> Self { Default::default() } }\n\nfn create_empty_file() -> PathBuf { \"\".into() }\n\n#[test]\nfn should_parse_empty_file() {\n     let empty = create_empty_file();\n\n     let matrix: Matrix = Matrix::from(empty);\n\n     assert_eq!(matrix, Default::default())\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling async-std for Async Tests\nDESCRIPTION: Cargo.toml configuration needed to enable async-std with attributes feature, which is required for async test support in rstest.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_9\n\nLANGUAGE: toml\nCODE:\n```\nasync-std = { version = \"1.13\", features = [\"attributes\"] }\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Timeouts per Test Case\nDESCRIPTION: Shows how to use different timeout values for specific test cases, overriding the group timeout for individual cases. Uses helper functions to generate Duration values.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nfn ms(ms: u32) -> Duration {\n    Duration::from_millis(ms.into())\n}\n\n#[rstest]\n#[case::pass(ms(1), 4)]\n#[timeout(ms(10))]\n#[case::fail_timeout(ms(60), 4)]\n#[case::fail_value(ms(1), 5)]\n#[timeout(ms(100))]\nasync fn group_one_timeout_override(#[case] delay: Duration, #[case] expected: u32) {\n    assert_eq!(expected, delayed_sum(2, 2, delay).await);\n}\n```\n\n----------------------------------------\n\nTITLE: Testing with File Paths Using #[files]\nDESCRIPTION: Demonstrates how to generate tests for each file matching a glob pattern using the #[files] attribute, with support for exclusion rules and environment variables.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n#[rstest]\nfn for_each_file(#[files(\"src/**/*.rs\")]\n                 #[exclude(\"test\")] path: PathBuf) {\n    assert!(check_file(&path))\n}\n```\n\n----------------------------------------\n\nTITLE: Test Context Object Usage in Rust\nDESCRIPTION: Shows how to use the Context object in RSTest to access test metadata like name, description, case number and execution timing information.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::{rstest, Context};\n\n#[rstest]\n#[case::a_description(42)]\nfn my_test(#[context] ctx: Context, #[case] _c: u32) {\n    assert_eq!(\"my_test\", ctx.name);\n    assert_eq!(Some(\"a_description\"), ctx.description);\n    assert_eq!(Some(0), ctx.case);\n\n    std::thread::sleep(std::time::Duration::from_millis(100));\n    assert!(ctx.start.elapsed() >= std::time::Duration::from_millis(100));\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Fixture Example in Rust\nDESCRIPTION: Demonstrates how to define and use a fixture in rstest. The fixture returns a value of 42 that is then injected into test functions as an argument.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::*;\n\n#[fixture]\npub fn fixture() -> u32 { 42 }\n\n#[rstest]\nfn should_success(fixture: u32) {\n        assert_eq!(fixture, 42);\n}\n\n#[rstest]\nfn should_fail(fixture: u32) {\n        assert_ne!(fixture, 42);\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests on Beta Rust Channel\nDESCRIPTION: This command runs all tests for the rstest project using the beta Rust channel. It sets the RSTEST_TEST_CHANNEL environment variable and uses cargo to execute the tests.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest_test/checkoutlist.md#2025-04-20_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nRSTEST_TEST_CHANNEL=beta cargo +${RSTEST_TEST_CHANNEL} test\n```\n\n----------------------------------------\n\nTITLE: Publishing rstest_macros crate (dry run)\nDESCRIPTION: Command to perform a dry run of publishing the rstest_macros crate to crates.io to verify package metadata and contents.\nSOURCE: https://github.com/la10736/rstest/blob/master/checkoutlist.md#2025-04-20_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo publish -p rstest_macros --dry-run\n```\n\n----------------------------------------\n\nTITLE: Testing across multiple Rust channels\nDESCRIPTION: Shell loop to run tests on stable, beta, and nightly Rust channels using an environment variable to track the test channel.\nSOURCE: https://github.com/la10736/rstest/blob/master/checkoutlist.md#2025-04-20_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nfor channel in stable beta nightly; do RSTEST_TEST_CHANNEL=${channel} cargo +${channel} test; done\n```\n\n----------------------------------------\n\nTITLE: Deploying the Project\nDESCRIPTION: This command publishes the rstest project to crates.io, making the new version available for other Rust developers to use as a dependency.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest_test/checkoutlist.md#2025-04-20_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncargo publish\n```\n\n----------------------------------------\n\nTITLE: Testing MSRV compatibility with cargo hack\nDESCRIPTION: Command to run tests for the minimum supported Rust version across the workspace, excluding the rstest_reuse crate and skipping specific tests.\nSOURCE: https://github.com/la10736/rstest/blob/master/checkoutlist.md#2025-04-20_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo hack test --rust-version --workspace --exclude rstest_reuse --ignore-private -- --skip rstest::ignore_args_not_fixtures\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Tests with RSTest and Actix\nDESCRIPTION: Demonstrates how to use RSTest with async functions using the actix_rt::test attribute. Shows parameterized testing with async results and future handling.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::*;\nuse actix_rt;\nuse std::future::Future;\n\n#[rstest]\n#[case(2, async { 4 })]\n#[case(21, async { 42 })]\n#[actix_rt::test]\nasync fn my_async_test(#[case] a: u32, #[case]\n#[future] result: u32) {\n    assert_eq!(2 * a, result.await);\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests on Nightly Rust Channel\nDESCRIPTION: This command runs all tests for the rstest project using the nightly Rust channel. It sets the RSTEST_TEST_CHANNEL environment variable and uses cargo to execute the tests.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest_test/checkoutlist.md#2025-04-20_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nRSTEST_TEST_CHANNEL=nightly cargo +${RSTEST_TEST_CHANNEL} test\n```\n\n----------------------------------------\n\nTITLE: Publishing rstest crate (dry run)\nDESCRIPTION: Command to perform a dry run of publishing the main rstest crate to crates.io to verify package metadata and contents.\nSOURCE: https://github.com/la10736/rstest/blob/master/checkoutlist.md#2025-04-20_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncargo publish -p rstest --dry-run\n```\n\n----------------------------------------\n\nTITLE: Running Tests on Rust Stable Channel\nDESCRIPTION: Command to run tests using the stable Rust channel for the rstest project.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest_reuse/checkoutlist.md#2025-04-20_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nRSTEST_TEST_CHANNEL=stable cargo +${RSTEST_TEST_CHANNEL} test\n```\n\n----------------------------------------\n\nTITLE: Test Tracing with Debug Output\nDESCRIPTION: Demonstrates how to use the trace attribute to debug test inputs and view detailed test execution information.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\n#[rstest]\n#[case(42, \"FortyTwo\", (\"minus twelve\", -12))]\n#[case(24, \"TwentyFour\", (\"minus twentyfour\", -24))]\n#[trace] //This attribute enable tracing\nfn should_fail(#[case] number: u32, #[case] name: &str, #[case] tuple: (&str, i32)) {\n    assert!(false); // <- stdout come out just for failed tests\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests on Rust Beta Channel\nDESCRIPTION: Command to run tests using the beta Rust channel for the rstest project.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest_reuse/checkoutlist.md#2025-04-20_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nRSTEST_TEST_CHANNEL=beta cargo +${RSTEST_TEST_CHANNEL} test\n```\n\n----------------------------------------\n\nTITLE: Updating Dependencies with Cargo\nDESCRIPTION: Command to update project dependencies using cargo-upgrade.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest_reuse/checkoutlist.md#2025-04-20_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo upgrade\n```\n\n----------------------------------------\n\nTITLE: Creating Reusable Test Templates\nDESCRIPTION: Shows how to use rstest_reuse to define a template of test cases that can be applied to multiple test functions, reducing duplication of test case definitions.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::rstest;\nuse rstest_reuse::{self, *};\n\n#[template]\n#[rstest]\n#[case(2, 2)]\n#[case(4/2, 2)]\nfn two_simple_cases(#[case] a: u32, #[case] b: u32) {}\n\n#[apply(two_simple_cases)]\nfn it_works(#[case] a: u32, #[case] b: u32) {\n    assert!(a == b);\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing rstest_macros crate\nDESCRIPTION: Command to publish the rstest_macros crate to crates.io.\nSOURCE: https://github.com/la10736/rstest/blob/master/checkoutlist.md#2025-04-20_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncargo publish -p rstest_macros\n```\n\n----------------------------------------\n\nTITLE: Magic Type Conversion with FromStr\nDESCRIPTION: Illustrates automatic conversion from string literals to types that implement FromStr trait, making it easier to define test cases with complex types like SocketAddr.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n# use rstest::rstest;\n# use std::net::SocketAddr;\n#[rstest]\n#[case(\"1.2.3.4:8080\", 8080)]\n#[case(\"127.0.0.1:9000\", 9000)]\nfn check_port(#[case] addr: SocketAddr, #[case] expected: u16) {\n    assert_eq!(expected, addr.port());\n}\n```\n\n----------------------------------------\n\nTITLE: Dry-Running Cargo Package Publication\nDESCRIPTION: Command to test the package publication process without actually publishing.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest_reuse/checkoutlist.md#2025-04-20_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncargo publish --dry-run\n```\n\n----------------------------------------\n\nTITLE: Using Future Values in Tests with #[future]\nDESCRIPTION: Demonstrates how to use the #[future] attribute to simplify working with async values in tests, avoiding the need to deal with Future types directly.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::*;\n#[fixture]\nasync fn base() -> u32 { 42 }\n\n#[rstest]\n#[case(21, async { 2 })]\n#[case(6, async { 7 })]\nasync fn my_async_test(#[future] base: u32, #[case] expected: u32, #[future]\n#[case] div: u32) {\n    assert_eq!(expected, base.await / div.await);\n}\n```\n\n----------------------------------------\n\nTITLE: Preparing for Deployment with Dry Run\nDESCRIPTION: This command performs a dry run of the cargo publish process, which checks if the package is ready for publishing without actually publishing it.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest_test/checkoutlist.md#2025-04-20_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncargo publish --dry-run\n```\n\n----------------------------------------\n\nTITLE: Checking MSRV with cargo hack\nDESCRIPTION: Command to verify minimum supported Rust version across the workspace while ignoring private crates.\nSOURCE: https://github.com/la10736/rstest/blob/master/checkoutlist.md#2025-04-20_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo hack check --rust-version --workspace --ignore-private\n```\n\n----------------------------------------\n\nTITLE: Adding rstest to Cargo.toml\nDESCRIPTION: Configuration for adding rstest as a development dependency in a Rust project's Cargo.toml file. Specifies the current version of the package.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dev-dependencies]\nrstest = \"0.25.0\"\n```\n\n----------------------------------------\n\nTITLE: Feature-Flagged Test Cases\nDESCRIPTION: Demonstrates how to conditionally include test cases based on feature flags using cfg_attr, allowing for tests that only run when specific features are enabled.\nSOURCE: https://github.com/la10736/rstest/blob/master/README.md#2025-04-20_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::rstest;\n\n#[rstest]\n#[case(2, 2)]\n#[cfg_attr(feature = \"frac\", case(4/2, 2))]\nfn it_works(#[case] a: u32, #[case] b: u32) {\n    assert!(a == b);\n}\n```\n\n----------------------------------------\n\nTITLE: Feature-Flagged Test Cases\nDESCRIPTION: Demonstrates how to conditionally include test cases based on cargo features using cfg_attr.\nSOURCE: https://github.com/la10736/rstest/blob/master/rstest/README.md#2025-04-20_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse rstest::rstest;\n\n#[rstest]\n#[case(2, 2)]\n#[cfg_attr(feature = \"frac\", case(4/2, 2))]\nfn it_works(#[case] a: u32, #[case] b: u32) {\n    assert!(a == b);\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing rstest crate\nDESCRIPTION: Command to publish the main rstest crate to crates.io.\nSOURCE: https://github.com/la10736/rstest/blob/master/checkoutlist.md#2025-04-20_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncargo publish -p rstest\n```"
  }
]