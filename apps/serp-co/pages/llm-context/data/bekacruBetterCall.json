[
  {
    "owner": "bekacru",
    "repo": "better-call",
    "content": "TITLE: Creating an Endpoint with createEndpoint in TypeScript\nDESCRIPTION: Defines an endpoint at path \"/item\" with POST method, validating request body using zod schema, and returning the item ID from the context. Demonstrates creation of a typed endpoint that can be called as a function or mounted on a router.\nSOURCE: https://github.com/bekacru/better-call/blob/main/README.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createEndpoint } from \"better-call\";\nimport { z } from \"zod\";\n\nconst createItem = createEndpoint(\"/item\", {\n    method: \"POST\",\n    body: z.object({\n        id: z.string()\n    })\n}, async (ctx) => {\n    return {\n        item: {\n            id: ctx.body.id\n        }\n    }\n})\n\n// Call as a function\nconst item = await createItem({\n    body: {\n        id: \"123\"\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Validation of request body and query with schemas in TypeScript\nDESCRIPTION: Uses schema validation for request body and query parameters via zod objects. Ensures incoming requests match expected data structures, returning errors otherwise.\nSOURCE: https://github.com/bekacru/better-call/blob/main/README.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst createItemBodySchema = createEndpoint(\"/item\", {\n    method: \"POST\",\n    body: z.object({ id: z.string() })\n}, async (ctx) => {\n    return { item: { id: ctx.body.id } };\n});\nconst getItemQuerySchema = createEndpoint(\"/item\", {\n    method: \"GET\",\n    query: z.object({ id: z.string() })\n}, async (ctx) => {\n    return { item: { id: ctx.query.id } };\n});\n```\n\n----------------------------------------\n\nTITLE: Mounting Endpoints to a Router with createRouter in TypeScript\nDESCRIPTION: Creates a router by including endpoints like createItem, enabling them to be served via a standard web server using the routerâ€™s handler method. Example shows integration with Bun server for handling incoming requests.\nSOURCE: https://github.com/bekacru/better-call/blob/main/README.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst router = createRouter({\n    createItem\n});\n\nBun.serve({\n    fetch: router.handler\n});\n```\n\n----------------------------------------\n\nTITLE: Defining various endpoint paths in TypeScript\nDESCRIPTION: Demonstrates creating endpoints with static paths, parameterized paths, and wildcard paths, allowing flexible URL matching and parameter extraction, such as extracting \"id\" from path parameters.\nSOURCE: https://github.com/bekacru/better-call/blob/main/README.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Direct path\nconst endpoint1 = createEndpoint(\"/item\", { method: \"GET\" }, async (ctx) => {});\n// Path with parameter\nconst endpoint2 = createEndpoint(\"/item/:id\", { method: \"GET\" }, async (ctx) => {\n    return { item: { id: ctx.params.id } };\n});\n// Path with wildcard\nconst endpoint3 = createEndpoint(\"/item/**:name\", { method: \"GET\" }, async (ctx) => {\n    // remaining path is stored in name\n    ctx.params.name;\n});\n```\n\n----------------------------------------\n\nTITLE: Using endpoint handler and middleware in TypeScript\nDESCRIPTION: Defines an endpoint with a handler function that accesses request context data, and demonstrates the creation of middleware to extend endpoint context with additional data.\nSOURCE: https://github.com/bekacru/better-call/blob/main/README.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Endpoint handler\nconst endpoint = createEndpoint(\"/\", { method: \"GET\" }, async (ctx) => {\n    // access ctx.request, ctx.headers, ctx.body, etc.\n    return { message: \"Hello\" };\n});\n// Middleware creation\nimport { createMiddleware } from \"better-call\";\nconst middleware = createMiddleware(async (ctx) => {\n    return { name: \"hello\" };\n});\n// Using middleware with endpoint\nconst endpointWithMiddleware = createEndpoint(\"/\", {\n    method: \"GET\",\n    use: [middleware]\n}, async (ctx) => {\n    // ctx.context includes middleware output\n});\n```\n\n----------------------------------------\n\nTITLE: Using better-call/client to interact with endpoints in TypeScript\nDESCRIPTION: Initializes a typed RPC client with a base URL to call server endpoints safely from the client. Demonstrates calling an endpoint with request data and receiving a response, ensuring type safety with the router type.\nSOURCE: https://github.com/bekacru/better-call/blob/main/README.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createClient } from \"better-call/client\";\nimport { router } from \"./router\";\n\nconst client = createClient<typeof router>({\n    baseURL: \"http://localhost:3000\"\n});\nconst items = await client(\"/item\", {\n    body: {\n        id: \"123\"\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring router options including middleware, error handling, and base path in TypeScript\nDESCRIPTION: Specifies settings for router behavior such as route middleware, base URL path, and error handling functions. Enhances route management and error processing.\nSOURCE: https://github.com/bekacru/better-call/blob/main/README.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Example of router with middleware and error handling\nconst routeMiddleware = createEndpoint(\"/api/**\", { method: \"GET\" }, async (ctx) => {\n    return { name: \"hello\" };\n});\nconst router = createRouter({}, {\n    routerMiddleware: [{ path: \"/api/**\", middleware: routeMiddleware }],\n    basePath: \"/v1\",\n    onError: (err) => { console.error(err); },\n    throwError: false\n});\n```\n\n----------------------------------------\n\nTITLE: Handling non-200 responses using APIError in TypeScript\nDESCRIPTION: Shows how to throw Better Call's APIError within endpoint handlers to return custom HTTP status codes and messages when certain conditions are met, such as validation failures or business logic errors.\nSOURCE: https://github.com/bekacru/better-call/blob/main/README.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst createItem = createEndpoint(\"/item\", {\n    method: \"POST\",\n    body: z.object({\n        id: z.string()\n    })\n}, async (ctx) => {\n    if (ctx.body.id === \"123\") {\n        throw ctx.error(400, { message: \"Id is not allowed\" });\n    }\n    return {\n        item: {\n            id: ctx.body.id\n        }\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a router with createRouter in TypeScript\nDESCRIPTION: Assembles multiple endpoints into a router object, providing a handler function to serve all the registered endpoints. Utilizes rou3 for path matching and invocation.\nSOURCE: https://github.com/bekacru/better-call/blob/main/README.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createRouter } from \"better-call\";\nimport { createItem } from \"./item\";\n\nconst router = createRouter({\n    createItem\n});\n\nBun.serve({\n    fetch: router.handler\n});\n```\n\n----------------------------------------\n\nTITLE: Generating OpenAPI Schema with Better Call - TypeScript\nDESCRIPTION: This snippet demonstrates generating an OpenAPI schema for endpoints using Better Call, leveraging `zod` for schema definition. The example defines a GET endpoint and auto-generates an OpenAPI definition for the query parameters. This requires Better Call, zod, and related configuration.\nSOURCE: https://github.com/bekacru/better-call/blob/main/README.md#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createEndpoint, createRouter } from \"better-call\"\n\nconst createItem = createEndpoint(\"/item/:id\", {\n    method: \"GET\",\n    query: z.object({\n        id: z.string({\n            description: \"The id of the item\"\n        })\n    })\n}, async (ctx) => {\n    return {\n        item: {\n            id: ctx.query.id\n        }\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring OpenAPI with Better Call Router - TypeScript\nDESCRIPTION: This snippet shows how to configure the OpenAPI schema generation within a Better Call router. Options include disabling the schema, setting the path, and configuring the appearance using the scalar options. Dependencies are the Better Call framework and related routing configuration.\nSOURCE: https://github.com/bekacru/better-call/blob/main/README.md#_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst router = createRouter({\n    createItem\n}, {\n    openapi: {\n        disabled: false, //default false\n        path: \"/api/reference\", //default /api/reference\n        scalar: {\n            title: \"My API\",\n            version: \"1.0.0\",\n            description: \"My API Description\",\n            theme: \"dark\" //default saturn\n        }\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Creating an Endpoint Creator with Better Call - TypeScript\nDESCRIPTION: This snippet illustrates how to create an endpoint creator using `createEndpoint.create` to apply middleware to multiple endpoints. The `dbMiddleware` adds database access to the context. Dependencies include the Better Call framework and a `Database` class along with related middleware setup.\nSOURCE: https://github.com/bekacru/better-call/blob/main/README.md#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst dbMiddleware = createMiddleware(async (ctx) => {\n   return {\n    db: new Database()\n   }\n})\nconst create = createEndpoint.create({\n    use: [dbMiddleware]\n})\n\nconst createItem = create(\"/item\", {\n    method: \"POST\",\n    body: z.object({\n        id: z.string()\n    })\n}, async (ctx) => {\n    await ctx.context.db.save(ctx.body)\n})\n```\n\n----------------------------------------\n\nTITLE: Requiring headers and request objects in endpoint in TypeScript\nDESCRIPTION: Configures endpoints to require specific headers or the request object. If missing, the endpoint throws validation errors, useful for authenticating or validating incoming requests.\nSOURCE: https://github.com/bekacru/better-call/blob/main/README.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Require headers\nconst createItemRequireHeaders = createEndpoint(\"/item\", {\n    method: \"GET\",\n    requireHeaders: true\n}, async (ctx) => {\n    return { id: ctx.headers.get(\"id\") };\n});\n// Use when calling endpoint\ncreateItemRequireHeaders({ headers: new Headers() });\n\n// Require request object\nconst createItemRequireRequest = createEndpoint(\"/item\", {\n    method: \"GET\",\n    requireRequest: true\n}, async (ctx) => {\n    return { id: ctx.request.id };\n});\n// Call with a request instance\ncreateItemRequireRequest({ request: new Request() });\n```\n\n----------------------------------------\n\nTITLE: Serving router with Node.js http server adapter in TypeScript\nDESCRIPTION: Uses the toNodeHandler function to adapt the router handler for Node's http server, enabling HTTP request handling in a standard environment.\nSOURCE: https://github.com/bekacru/better-call/blob/main/README.md#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createRouter } from \"better-call\";\nimport { toNodeHandler } from \"better-call/node\";\nimport http from \"http\";\nimport { createItem } from \"./item\";\n\nconst router = createRouter({ createItem });\nconst server = http.createServer(toNodeHandler(router.handler));\n```\n\n----------------------------------------\n\nTITLE: Setting Headers and Cookies with Better Call - TypeScript\nDESCRIPTION: This snippet demonstrates how to set custom headers and cookies within an endpoint using the `ctx` object. The `setHeader` and `setCookie` methods are used to modify the response headers and set a cookie, respectively. Dependencies include the Better Call framework and any necessary type definitions.\nSOURCE: https://github.com/bekacru/better-call/blob/main/README.md#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst createItem = createEndpoint(\"/item\", {\n    method: \"POST\",\n    body: z.object({\n        id: z.string()\n    })\n}, async (ctx) => {\n    ctx.setHeader(\"X-Custom-Header\", \"Hello World\")\n    ctx.setCookie(\"my-cookie\", \"hello world\")\n    return {\n        item: {\n            id: ctx.body.id\n        }\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Getting Cookies from Context with Better Call - TypeScript\nDESCRIPTION: This code shows how to retrieve cookies from the context object within an endpoint.  The `getCookie` method is used to access the value of a specific cookie. Dependencies include the Better Call framework and any necessary type definitions related to cookies and the context object.\nSOURCE: https://github.com/bekacru/better-call/blob/main/README.md#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst createItem = createEndpoint(\"/item\", {\n    method: \"POST\",\n    body: z.object({\n        id: z.string()\n    })\n}, async (ctx) => {\n    const cookie = ctx.getCookie(\"my-cookie\")\n    return {\n        item: {\n            id: ctx.body.id\n        }\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Custom OpenAPI Schema Definition with Better Call - TypeScript\nDESCRIPTION: This snippet showcases how to define custom OpenAPI schema using the `metadata` option, allowing for fine-grained control over the generated API documentation. This overrides the default schema generation. Dependencies include Better Call, zod and appropriate type definitions related to the openapi spec.\nSOURCE: https://github.com/bekacru/better-call/blob/main/README.md#_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createEndpoint, createRouter } from \"better-call\"\n\nconst createItem = createEndpoint(\"/item/:id\", {\n    method: \"GET\",\n    query: z.object({\n        id: z.string({\n            description: \"The id of the item\"\n        })\n    }),\n    metadata: {\n    openapi: {\n        requestBody: {\n            content: {\n                \"application/json\": {\n                    schema: {\n                        type: \"object\",\n                        properties: {\n                            id: {\n                                type: \"string\",\n                                description: \"The id of the item\"\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n   }\n}, async (ctx) => {\n    return {\n        item: {\n            id: ctx.query.id\n        }\n    }\n})\n```"
  }
]