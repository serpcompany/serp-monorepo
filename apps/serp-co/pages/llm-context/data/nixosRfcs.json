[
  {
    "owner": "nixos",
    "repo": "rfcs",
    "content": "TITLE: Defining Nixpkgs Attribute via callPackage - Nix Expression\nDESCRIPTION: Demonstrates the automatic definition of `pkgs.${name}` using `callPackage` by referencing a `package.nix` file located in a sharded directory structure. This approach requires the `pkgs` set, a valid `package.nix` file for the package, and assumes that the directory structure and naming conventions prescribed in the RFC are followed. It takes no additional arguments and the output is a Nix derivation. Limitations include strict path and naming requirements.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0140-simple-package-paths.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\npkgs.callPackage pkgs/by-name/${shard}/${name}/package.nix { }\n```\n\n----------------------------------------\n\nTITLE: Overriding Nixpkgs Attribute with Arguments - Nix Expression\nDESCRIPTION: Illustrates how `pkgs.${name}` can be overridden in `all-packages.nix` by supplying specific arguments (`args`) to `callPackage` for the referenced package. This pattern requires the presence of the appropriate directory and `package.nix`, as well as a set of override arguments. The output is a derivation with custom parameters. Overriding is optional and may be used for special cases needing explicit inputs.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0140-simple-package-paths.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\npkgs.callPackage pkgs/by-name/${shard}/${name}/package.nix args\n```\n\n----------------------------------------\n\nTITLE: Defining Package Attribute Assignment with Optional Args File - Nix - Nix Language\nDESCRIPTION: This snippet demonstrates how Nixpkgs could automatically generate package attribute assignments by detecting the presence of an optional `args.nix` file in package directories. If `args.nix` exists, its return value is used as an argument set for `callPackage`, otherwise an empty attribute set is provided. This pattern is used to add optional per-package configuration while standardizing the way packages are invoked. Dependencies include Nix and the presence of certain files (`package.nix`, `args.nix`), and the key output is a standard package attribute accessible under `pkgs.${name}`.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0140-simple-package-paths.md#_snippet_7\n\nLANGUAGE: Nix\nCODE:\n```\n# If args.nix doesn't exist\npkgs.${name} = pkgs.callPackage ${packageDir}/package.nix {}\n# If args.nix does exists\npkgs.${name} = pkgs.callPackage ${packageDir}/package.nix (import ${packageDir}/args.nix pkgs);\n```\n\n----------------------------------------\n\nTITLE: Declaring and Using Flexible Service Settings with pkgs.formats - Nix\nDESCRIPTION: This NixOS module snippet demonstrates how to define a flexible `settings` option for a NixOS service using `pkgs.formats` (specifically JSON format) and freeform modules. The code component shows the declaration of settings with type enforcement, defaulting, descriptive documentation, and an example config that creates a settings file and user from specified values. Dependencies include the Nixpkgs library (`pkgs`, `lib`), particularly `pkgs.formats.json`, and relies on established NixOS module patterns. Inputs include a set of configuration options, and outputs are NixOS module attributes such as generated config files and system users. Limitation: this pattern applies well only to configurations that can be serially represented as Nix values (e.g., JSON, not arbitrary bash or Python).\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0042-config-option.md#_snippet_1\n\nLANGUAGE: Nix\nCODE:\n```\n{ options, config, lib, pkgs, ... }:\nlet\n  cfg = config.services.foo;\n  # Define the settings format used for this program\n  settingsFormat = pkgs.formats.json {};\nin {\n\n  options.services.foo = {\n    enable = lib.mkEnableOption \"foo service\";\n\n    settings = lib.mkOption {\n      type = lib.types.submodule {\n\n        # Declare that the settings option supports arbitrary format values, json here\n        freeformType = settingsFormat.type;\n\n        # Declare an option for the port such that the type is checked and this option\n        # is shown in the manual.\n        options.port = lib.mkOption {\n          type = lib.types.port;\n          default = 8080;\n          description = ''\n            Which port this service should listen on.\n          '';\n        };\n\n      };\n      default = {};\n      # Add upstream documentation to the settings description\n      description = ''\n        Configuration for Foo, see\n        <link xlink:href=\"https://example.com/docs/foo\"/>\n        for supported values.\n      '';\n    };\n  };\n\n  config = lib.mkIf cfg.enable {\n    # We can assign some default settings here to make the service work by just\n    # enabling it. We use `mkDefault` for values that can be changed without\n    # problems\n    services.foo.settings = {\n      # Fails at runtime without any value set\n      log_level = lib.mkDefault \"WARN\";\n\n      # We assume systemd's `StateDirectory` is used, so this value is required\n      # therefore no mkDefault, forcing the user to use mkForce to override it\n      data_path = \"/var/lib/foo\";\n\n      # Since we use this to create a user we need to know the default value at\n      # eval time\n      user = lib.mkDefault \"foo\";\n    };\n\n    environment.etc.\"foo.json\".source =\n      # The formats generator function takes a filename and the Nix value\n      # representing the format value and produces a filepath with that value\n      # rendered in the format\n      settingsFormat.generate \"foo-config.json\" cfg.settings;\n\n    # We know that the `user` attribute exists because we set a default value\n    # for it above, allowing us to use it without worries here\n    users.users.${cfg.settings.user} = {};\n\n    # ...\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Package Variant Using CallPackage in Nix\nDESCRIPTION: Shows the recommended pattern of duplicating the callPackage call with custom arguments to create package variants without recursion issues.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0140-simple-package-paths.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  graphviz_nox = callPackage ../tools/graphics/graphviz { withXorg = false; };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Package Variant Using Override in Nix\nDESCRIPTION: Example showing how to create a package variant using the .override method, specifically creating a graphviz_nox variant without X.org support.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0140-simple-package-paths.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  graphviz_nox = graphviz.override { withXorg = false; };\n}\n```\n\n----------------------------------------\n\nTITLE: Building Content-Addressed Derivations - Pseudo-Python\nDESCRIPTION: Updates the build logic to support content-addressed derivations in Nix, handling cases where output paths are unknown prior to building. This recursive algorithm builds required inputs, resolves symbolic references to actual paths, checks for existing builds, assigns temporary paths, runs the build script, and finally moves built outputs to content-addressed locations. Input parameters include the derivation and a list of outputs to build; output is a map of DrvOutput to Realisation. This code assumes the existence of helper functions (e.g., 'resolved', 'isBuilt', 'assignScratchOutputPaths') and does not include real-world error or transaction management.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0062-content-addressed-paths.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef build_derivation(derivation : Derivation, outputsToBuild: [str]) -> Map[DrvOutput, Realisation]:\n    inputRealisations : Map[DrvOutput, Realisation] = {}\n    # Build all the inputs, and store the newly built realisations\n    for (inputDrv, requiredOutputs) in derivation.inputDrvs:\n        inputRealisations += build_derivation(inputDrv, requiredOutputs)\n\n    # We now need to “resolve” our realisation to replace all the symbolic\n    # references to its inputs by their actual store path\n    derivationToBuild : BasicDerivation = resolved(inputDrv, inputRealisations)\n\n    # At that point, we might realise that the resolved derivation is actually\n    # something that we have already built. In that case we just return\n    # the existing result.\n    if (isBuilt(derivationToBuild)):\n        return queryOutputs(derivationToBuild, outputsToBuild)\n\n    # The build script needs to know where to install stuff (so that for\n    # example `make install` can work properly).\n    # We obviously don’t know the final path yet, but we can assign some\n    # temporary output paths to the derivation that will be used during the\n    # build.\n    assignScratchOutputPaths(derivationToBuild)\n\n    # Run the build script on the new resolved derivation\n    runBuildScript(derivationToBuild)\n\n    # Move the newly built outputs to their final (content-addressed) paths,\n    # and return the corresponding realisations.\n    return moveToCAPaths(derivationToBuild.outputs)\n\n```\n\n----------------------------------------\n\nTITLE: Package Variant Definition Using New Directory Structure\nDESCRIPTION: Demonstrates how to define package variants using the new by-name directory structure while maintaining CI compatibility.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0140-simple-package-paths.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  graphviz_nox = callPackage ../by-name/gr/graphviz/package.nix { withXorg = false; };\n}\n```\n\n----------------------------------------\n\nTITLE: Nixpkgs by-name Directory Structure - Directory Tree (Text)\nDESCRIPTION: Provides an example of the new `pkgs/by-name` directory structure as text, showing how package directories are organized by their sharded prefix (`shard`), and each contains a subdirectory named after the package, which holds the `package.nix` file. This structure helps ensure uniqueness, scalability, and easier maintenance. This is a text diagram meant to visualize the migration target structure rather than being executable code.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0140-simple-package-paths.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\npkgs\n└── by-name\n   ├── _0\n   │  ├── _0verkill\n   │  └── _0x\n   ┊\n   ├── ch\n   │  ├── ChowPhaser\n   │  ├── CHOWTapeModel\n   │  ├── chroma\n   │  ┊\n   ┊\n   ├── t\n   │  └── t\n   ┊\n```\n\n----------------------------------------\n\nTITLE: Defining Package Categories - Nix - Nix\nDESCRIPTION: Defines a set of category objects in the lib.categories attribute set for use in package metadata. Each category includes a name and a description, enabling detailed classification of packages. Dependencies: core Nix language, no external libraries. Input: attribute set with category keys; Output: named category objects for reference in meta attributes. This structure must be kept updated as categories evolve, and descriptions should remain concise and relevant.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0146-meta-categories.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  assembler = {\n    name = \"Assembler\";\n    description = ''\n      A program that converts text written in assembly language to binary code.\n    '';\n  };\n\n  compiler = {\n    name = \"Compiler\";\n    description = ''\n      A program that converts a source from a language to another, usually from\n      a higher, human-readable level to a lower, machine level.\n    '';\n  };\n\n  font = {\n    name = \"Font\";\n    description = ''\n      A set of files that defines a set of graphically-related glyphs.\n    '';\n  };\n\n  game = {\n    name = \"Game\";\n    description = ''\n      A program developed with entertainment in mind.\n    '';\n  };\n\n  interpreter = {\n    name = \"Interpreter\";\n    description = ''\n      A program that directly executes instructions written in a programming\n      language, without requiring compilation into the native machine language.\n    '';\n  };\n\n```\n\n----------------------------------------\n\nTITLE: Assigning Categories to Packages - Nix - Nix\nDESCRIPTION: Illustrates how to assign one or more category objects from lib.categories to a package's meta attribute using the Nix language. The example shows usage within a stdenv.mkDerivation declaration, making categories discoverable in Nixpkgs metadata. Prerequisites: the lib.categories set must be available in scope; input is an array of category references. Output: the meta.categories attribute as a list of category objects. Maintain category order for priority; ensure categories exist in lib.categories.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0146-meta-categories.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation {\n\n. . .\n\n  meta = {\n    . . .\n    categories = with lib.categories; [ emulator debugger ];\n    . . .\n    };\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Querying Package Categories in nix repl - Nix - Nix\nDESCRIPTION: Demonstrates how to interactively query a package's category metadata within the nix repl environment. The example loads Nixpkgs, accesses the meta.categories attribute of a package, and maps category objects to their name. No dependencies beyond Nixpkgs are required. Input: package expression; Output: list of category objects and their names. Useful for inspecting category assignments, but outputs may depend on current Nixpkgs state.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0146-meta-categories.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nnix-repl> :l <nixpkgs>\nAdded XXXXXX variables.\n\nnix-repl> pkgs.bochs.meta.categories\n[ { ... } ]\n\nnix-repl> map (z: z.name) pkgs.bochs.meta.categories\n[ \"debugger\" \"emulator\" ]\n\n```\n\n----------------------------------------\n\nTITLE: Creating Singleton Lists with lib.singleton (Nix Language)\nDESCRIPTION: Illustrates the more idiomatic way of creating singleton lists in Nix using the lib.singleton function. This removes an unnecessary level of indentation and relies on the Nix standard library ('lib'). The singleton item is defined as an attribute set ('foo' and 'bar') passed as an argument to lib.singleton, which returns a one-element list. Requires access to the Nixpkgs lib module.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  list = lib.singleton {\\n    foo = 10;\\n    bar = 20;\\n  };\\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Problems in Package Metadata - Nix\nDESCRIPTION: This snippet demonstrates how to annotate a package in Nixpkgs with one or more problems using the new 'meta.problems' attribute. Each problem is defined as an attribute set keyed by a problem name, containing fields like 'kind', 'message', and optional 'urls'. These declarations inform the Nixpkgs infrastructure and downstream users of issues such as deprecation, removal, or upstream abandonment. No external dependencies are required, but proper keys and message formatting are expected. Expected input is a Nix attribute set, output is an augmented package metadata record.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0127-issues-warnings.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nmeta.problems = {\n  # This one will have the name \"python2-eol\"\n  python2-eol = {\n    kind = \"deprecated\";\n    message = \"This package depends on Python 2, which has reached end of life.\";\n    urls = [ \"https://github.com/NixOS/nixpkgs/issues/148779\" ];\n  };\n  # This one will have the name \"removal\"\n  removal = {\n    # kind = \"removal\"; # Inferred from attribute key\n    message = \"The application has been abandoned upstream, use libfoo instead.\";\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Declaring Multiple Problems and Deprecations with meta.problems Variants - Nix Language\nDESCRIPTION: These Nix code snippets demonstrate approaches for specifying multiple problems within the meta.problems attribute, including deprecations with names and URLs, and removals. The first example uses a problem name as an attribute key, while the second groups multiple issues of the same kind as a list. Both enforce unique naming for problems of the same kind and facilitate user and tooling awareness of deprecations and removals.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0127-issues-warnings.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nmeta.problems = {\n  \"deprecated/python2-eol\" = {\n    message = \"This package depends on Python 2, which has reached end of life.\";\n    urls = [ \"https://github.com/NixOS/nixpkgs/issues/148779\" ];\n  };\n  removal = {\n    message = \"The application has been abandoned upstream, use libfoo instead\";\n  };\n};\n\nmeta.problems = {\n  \"deprecated\" = [{\n    name = \"python2-eol\";\n    message = \"This package depends on Python 2, which has reached end of life.\";\n    urls = [ \"https://github.com/NixOS/nixpkgs/issues/148779\" ];\n  }];\n  removal = {\n    message = \"The application has been abandoned upstream, use libfoo instead\";\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Writing Matcher-Based Problem Handlers for Package Sets - Nix\nDESCRIPTION: This snippet illustrates use of the 'config.problems.matchers' option in Nixpkgs, letting users define matchers based on package name, problem name, or kind to associate with handlers ('error', 'warn', 'ignore'). The configuration is a list of attribute sets, supporting wildcards and prioritization logic. It is intended for users who need to set policies affecting multiple packages or types of problems. Expected input is a list of matchers in a Nix attribute set, output is merged handling rules affecting problem evaluation. Precedence is enforced to ensure sensible defaults.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0127-issues-warnings.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nconfig.problems.matchers = [\n  { # Wildcard matcher for everything\n    handler = \"warn\";\n  }\n  { # Match all security warnings on \"hello\"\n    package = \"hello\";\n    kind = \"insecure\";\n    handler = \"error\";\n  }\n  { # Match all packages affected by the python2 deprecation\n    name = \"python2-eol\";\n    handler = \"error\";\n  }\n  { # Has no effect: the default value is higher\n    kind = \"insecure\";\n    handler = \"ignore\";\n  }\n  { # Disallowed: Non-wildcards are better handled by using `problems.handlers` instead\n    # The equivalent would be: `config.problem.handlers.hello.CVE1234 = \"error\";\n    package = \"hello\";\n    name = \"CVE1234\";\n    handler = \"error\";\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Declaring Removal Problems with meta.problems - Nix Language\nDESCRIPTION: This Nix snippet demonstrates how to annotate a package slated for removal by defining a meta.problems attribute. The removal attribute signals that the package will be removed from Nixpkgs, typically because of unresolved issues. Additional problems may be included alongside removal. This annotation warns users and tooling prior to the actual removal, which should not occur until after at least one full release cycle.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0127-issues-warnings.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nmeta.problems = {\n  removal = {\n    message = \"This package will be removed from Nixpkgs.\";\n  };\n  # Probably some more problems here\n};\n```\n\n----------------------------------------\n\nTITLE: Overriding Post Hook for Build Phase - Nix\nDESCRIPTION: This snippet demonstrates how to override postBuild in a derivation using the overrideAttrs pattern. It appends additional shell script code to postBuild, preserving any existing logic. Dependencies include the package's attribute set and Nixpkgs. Inputs: attribute function. Outputs: a modified derivation with enhanced postBuild behavior.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0032-run-phase-changes-for-better-nix-shell-use.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nfoo-package.overrideAttrs (attrs: {\n    postBuild = (attrs.postBuild or \"\") + ''\n        # whatever\n    '';\n})\n```\n\n----------------------------------------\n\nTITLE: Evaluating Phase Variables for Manual Phase Invocation - Shell Script\nDESCRIPTION: This snippet demonstrates the current method to invoke a build phase inside nix-shell by evaluating either the buildPhase variable or function. It ensures that the phase is called correctly, regardless of whether it is overridden as a variable or a function. No external dependencies are required, and it assumes Bash as the shell environment. The input is a bash command, and the output is the execution of the appropriate build phase.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0032-run-phase-changes-for-better-nix-shell-use.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\neval \"${buildPhase:-buildPhase}\"\n```\n\n----------------------------------------\n\nTITLE: Defining Service Configuration with Settings and ExtraConfig (Nix)\nDESCRIPTION: This Nix code snippet provides an example of configuring a `services.foo` module using both the legacy stringly-typed `extraConfig` approach and the newer structural `settings` attribute. The `extraConfig` section demonstrates how configuration directives are defined as raw strings, which cannot be easily merged or overridden, while the `settings` approach uses Nix attributes for strong typing, better merging, and composability. Prerequisites for the structural approach include knowledge of Nix attribute sets and the use of functions like `mkIf` and `optionalString`; key parameters include lists, booleans, and conditional expressions. The expected output is a declarative service configuration that is easier to manage and less error-prone than the string-based variant.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0042-config-option.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # Old way\n  services.foo.extraConfig = ''\n    # Can't be set in multiple files because string concatenation doesn't merge such lists\n    listen-ports = 456, 457, 458 \n    \n    # Can't override this setting because the module hardcodes it\n    # bootstrap-ips = 172.22.68.74\n\n    enable-ipv6 = 0\n    ${optionalString isServer \"check-interval = 3600\"}\n  '';\n  \n  # New way\n  services.foo.settings = {\n    listen-ports = [ 456 457 458 ];\n    bootstrap-ips = [ \"172.22.68.74\" ];\n    enable-ipv6 = false;\n    check-interval = mkIf isServer 3600;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Extending the Realisation Object Model in Nix - Python\nDESCRIPTION: Defines a Python-like class 'Realisation' used to represent build realisations in Nix. The class captures an identifier, output path, and an explicit mapping of dependencies from DrvOutputs to StorePaths, allowing the system to enforce that all dependencies are realised and present. Dependencies should be present in the store as per the dependency map. This model is essential for reproducing builds and avoiding duplication. Requires basic Python class syntax; inputs are build references, and outputs are the realisation records.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0062-content-addressed-paths.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclass Realisation:\n    id : DrvOutput\n    outputPath : StorePath\n    dependencies : Map[DrvOutput, StorePath]\n```\n\n----------------------------------------\n\nTITLE: Querying Realisations from the Store Interface - Python\nDESCRIPTION: This snippet defines a function to retrieve a realisation object from the Nix store based on a derivation output. The function returns the associated realisation or None if unknown. Dependency: the existence and contract of the DrvOutput and Realisation types, and a backend store system. Input parameter is the derivation output; output is maybe the realisation. This is relevant for extended remote caching and realization workflows.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0062-content-addressed-paths.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef queryRealisation(output : DrvOutput) -> Maybe Realisation\n```\n\n----------------------------------------\n\nTITLE: New Build Phase Implementation Using commonPhaseImpl - Shell Script\nDESCRIPTION: This snippet presents the concise new-style buildPhase function using a helper, commonPhaseImpl, for handling hooks and default logic. It delegates all control to an external implementation function, specifying which hooks to run and what default implementation to use. This pattern enhances maintainability and consistency for phase execution. Requires that commonPhaseImpl be defined elsewhere in the stdenv environment.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0032-run-phase-changes-for-better-nix-shell-use.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nbuildPhase() {\n    commonPhaseImpl buildPhase --default defaultBuildPhase --pre-hook preBuild --post-hook postBuild\n}\n```\n\n----------------------------------------\n\nTITLE: Grouping Containers in a Networking Zone - Nix/NixOS\nDESCRIPTION: This Nix snippet shows how to group multiple containers into a named networking zone, which aggregates their network interfaces into a shared interface (vz-<zone>). It sets a zone under nixos.containers.zones and assigns it to container instances by configuring test1 and test2. Dependencies are the NixOS module system and the new container networking support, requiring zone support within systemd-nspawn. Parameters include zone name assignment and instance configuration; output is that containers share the grouped interface. Further configuration may be required for routing or isolation.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0108-nixos-containers.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nixos.containers.zones.demo = {};\n  nixos.containers.instances = {\n    test1.network.zone = \"demo\";\n    test2.network.zone = \"demo\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Signature Validation to Realisation Records with Signing/Verification - Python\nDESCRIPTION: Extends the Python-like 'Realisation' class by adding a set of digital signatures and associated signing and verification methods. These signatures are used to assure the authenticity and integrity of content-addressed realisations, since content hashes alone cannot always express trust. The methods include 'sign' (using a private key) and 'verify_signature' (using a public key). Prerequisites include cryptographic key handling within Python. Inputs are cryptographic keys and the realisation object; outputs are signed or verified status for a realisation.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0062-content-addressed-paths.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nclass Realisation:\n    ...\n\n    signatures : Set[str]\n\n    def sign(key : PrivateKey):\n        ...\n    def verify_signature(key : PublicKey):\n        ...\n```\n\n----------------------------------------\n\nTITLE: Defining the Realisation Table in the Store Database - SQL\nDESCRIPTION: This SQL statement creates a table 'Realisation' in the underlying persistence layer of the Nix store. The table includes columns for the derivation hash, output name, and output path, ensuring each output realisation is uniquely tracked. It is designed to be used as part of migration or initialization scripts, and must run in a SQL environment compatible with Nix's database features. The table is created only if it doesn't exist to prevent duplication.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0062-content-addressed-paths.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\ncreate table if not exists Realisation (\n    drvHash integer not null,\n    outputName text not null,\n    outputPath integer not null,\n)\n\n```\n\n----------------------------------------\n\nTITLE: Absorption and Indentation in Nix Bindings (Nix Language)\nDESCRIPTION: This example demonstrates the absorption feature and default indentation in Nix bindings. It shows both absorbed and non-absorbed right-hand side expressions, where expressions after operators or keywords may stay on the same line to avoid excessive indentation. Code includes usage of 'with', 'let', and argument lists, with both absorbed and non-absorbed multi-line attribute sets. No external dependencies are required.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  # The right-hand side of bindings is an example of a situation where absorption improves the style.\\n  absorbed = with bar; [\\n    1\\n    2\\n    3\\n  ];\\n  notAbsorbed =\\n    with bar; # Placing a comment here will force the non-absorbed, multiline layout.\\n    [\\n      1\\n      2\\n      3\\n    ];\\n\\n  # In this case, absorption does not reduce the indentation level of the set.\\n  absorbed' =\\n    let\\n      qux = 1;\\n    in\\n    # { is absorbed\\n    bar: baz: {\\n      # <-- same level\\n    };\\n\\n  notAbsorbed' =\\n    let\\n      qux = 1;\\n    in\\n    way:\\n    too:\\n    many:\\n    arguments:\\n    {\\n      # <-- same level\\n    };\\n}\n```\n\n----------------------------------------\n\nTITLE: Expanding Nix Expressions: Lists, Sets, Inherit, and Multiline Formatting (Nix)\nDESCRIPTION: This snippet demonstrates how to consistently format lists, attribute sets, and inherit statements in Nix according to line-length and item-count conventions discussed in the guidelines. Lists with several elements, attribute sets, and inherit statements are all structured so that each item is on its own line if expanded. There are no dependencies beyond standard Nix syntax. Inputs are various Nix expressions, outputs are their formatted counterparts. There are no specific limitations except those given in the rules.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_11\n\nLANGUAGE: nix\nCODE:\n```\n{\n  buildInputs = [\n    foo\n    bar\n    baz\n\n    somethingElse\n  ];\n\n  systemd.services = {\n    foo = { };\n    bar = { };\n  };\n\n  inherit\n    lib\n    foo\n    bar\n    baz\n    ;\n}\n```\n\n----------------------------------------\n\nTITLE: Non-Chainable and Chainable Operator Formatting - Nix - Nix Language\nDESCRIPTION: These code examples demonstrate how to format both non-chainable and chainable binary operators in Nix. They cover proper operator placement, multiline formatting, compact forms within bindings, and handling of complex expressions involving operators and function applications. The snippets emphasize consistent indentation and absorption rules to improve operator chain readability. No external dependencies are required, and the focus is on operator context; input and outputs are Nix expressions combining values using operators.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_19\n\nLANGUAGE: nix\nCODE:\n```\nshortVariable == 42\n\nstringLength (drvName (toString oldDependency))\n== stringLength (drvName (toString newDependency))\n\nsome complicated calculation {\n  # arguments\n} == other stuff {\n  # which may be multiline\n}\n\nsome complicated calculation {\n  # arguments\n}\n== \"some very long string\"\n```\n\nLANGUAGE: nix\nCODE:\n```\n# These chained associative operators have increasing precedence, so they're _not_ treated the same\nfoo\n-> # <- The operator starts on a new line, but right operand is all of the below lines, they don't fit here, so indent\n  bar\n  ||\n    baz\n    && qux # <- The operand fits on this line\n\n# These chained associative operators have decreasing precedence, so they're treated the same\nfoo\n&& bar # <- All of these operands are just identifiers, they fit on the same line\n|| baz # <- We shouldn't indent these lines, because it misleads into thinking that || binds stronger than &&\n-> qux\n\n[\n  some\n  flags\n]\n++ ( # <- Parenthesized expressions get absorbed\n  foo\n)\n++ optionals condition [ # <- As are some multiline function applications\n  more\n  items\n]\n++\n  runCommand name # <- Function application which cannot be absorbed start on a new line with indentation\n    ''\n      echo hi\n    ''\n    test\n\n# In bindings we can use a more compact form as long as all in-between lines are indented.\n{\n  foo = bar // {\n    x = 10;\n    y = 20;\n  } // baz;\n}\n\n# Bad, we can't use the more compact form because an intermediate line is not indented.\n{\n  foo = {\n    x = 10;\n    y = 20;\n  } // bar // {\n    z = 30;\n    w = 40;\n  };\n}\n\n# Good, this is the non-compact operator form\n{\n  foo =\n    {\n      x = 10;\n      y = 20;\n    }\n    // bar\n    // {\n      z = 30;\n      w = 40;\n    };\n}\n\n# Good\n{\n  postPatch =\n    ''\n      patchShebangs .\n    ''\n    + lib.optionalString withFrei0r ''\n      substituteInPlace libavfilter/vf_frei0r.c \\\n        --replace /usr/local/lib/frei0r-1 ${frei0r}/lib/frei0r-1\n      substituteInPlace doc/filters.texi \\\n        --replace /usr/local/lib/frei0r-1 ${frei0r}/lib/frei0r-1\n    '';\n\n  configureFlags =\n    [\n      # *  Program flags\n      (enableFeature buildFfmpeg \"ffmpeg\")\n      (enableFeature buildFfplay \"ffplay\")\n      (enableFeature buildFfprobe \"ffprobe\")\n    ]\n    ++ optionals withBin [ \"--bindir=${placeholder \\\"bin\\\"}/bin\" ]\n    ++ [\n      # ...\n    ];\n}\n```\n\n----------------------------------------\n\nTITLE: Function Declaration Formatting - Nix - Nix Language\nDESCRIPTION: These snippets illustrate several ways to declare functions in Nix, demonstrating the handling of argument placement, body indentation, attribute set arguments, default values, argument patterns, and over-the-limit chained arguments. Examples include both identifier and attribute set arguments, while also showcasing multi-parameter cases and pattern matching. No external dependencies are required. Inputs and outputs vary by function body, but all follow the structural rules discussed in the documentation.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_17\n\nLANGUAGE: nix\nCODE:\n```\n#1\nname: value: name ++ value\n```\n\nLANGUAGE: nix\nCODE:\n```\n#2 absorption\nname: value: ''\n  ${name} = ${value};\n''\n```\n\nLANGUAGE: nix\nCODE:\n```\n#3\nname: value:\nname\n++ value\n++ more stuff making the line too long\n```\n\nLANGUAGE: nix\nCODE:\n```\n#4\n{ pkgs }: pkgs.hello\n```\n\nLANGUAGE: nix\nCODE:\n```\n#5\nargs@{\n  some,\n  argument,\n  default ? value,\n  ...\n}:\n{\n  # body\n}\n```\n\nLANGUAGE: nix\nCODE:\n```\n#6\n{ pkgs }:\nname: value: \n{\n  # body\n}\n```\n\nLANGUAGE: nix\nCODE:\n```\n#7: These would be over the line length limit on a single line\naaaa:\nbbbb:\ncccc: \ndddd:\neeee:\nnull\n```\n\nLANGUAGE: nix\nCODE:\n```\n#8: @ patterns can also come afterwards\n{ pkgs }@args: pkgs.hello\n```\n\n----------------------------------------\n\nTITLE: Formatting 'if-then-else' Chains as Sequences (Nix Language)\nDESCRIPTION: Demonstrates how 'if-then-else' chains should be formatted to avoid excessive indentation and improve readability. The preferred format places chained 'else if' statements at the same indentation level. Snippet does not require external dependencies and exemplifies behavior for control flow constructs.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n# This is treated as a sequence of if-then-else chains, instead of indenting the second if as part of the else body\\nif cond1 then\\n  foo\\nelse if cond2 then\\n  bar\\nelse\\n  baz\n```\n\n----------------------------------------\n\nTITLE: Notifying Insufficient Shepherds with Markdown Message - Markdown - English\nDESCRIPTION: This markdown snippet is intended for posting in an RFC pull request when insufficient shepherds have volunteered after one month of the RFC being open. It provides explicit directions for how contributors can raise interest, includes guidance links to official resources, and clarifies the process for closing and potentially reopening the RFC. No external dependencies are required, but contextually assumes it's used by the NixOS RFC Steering Committee within a GitHub PR comment. Inputs are not required; the output is a formatted message. The message should be posted by committee members or automation within relevant RFC PR threads.\nSOURCE: https://github.com/nixos/rfcs/blob/master/README.md#_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\nRFCSC:\n\nThis RFC has not acquired enough shepherds. This typically shows lack of interest from the community. In order to progress [a full shepherd team is required](https://github.com/NixOS/rfcs/#shepherd-team). Consider trying to raise interest by [posting in Discourse](https://discourse.nixos.org/), [talking in Matrix](https://matrix.to/#/#community:nixos.org) or reaching out to people that you know.\n\nIf not enough shepherds can be found in the next month we will close this RFC until we can find enough interested participants. The PR can be reopened at any time if more shepherd nominations are made.\n\n[See more info on the Nix RFC process here](https://github.com/NixOS/rfcs/blob/master/README.md)\n```\n\n----------------------------------------\n\nTITLE: Nix inherit and inherit-from Statement Formatting\nDESCRIPTION: Demonstrates recommended formatting and style for Nix inherit and inherit-from expressions, including aligning all attributes on the same or separate indented lines and proper semicolon placement. Also covers cases for long attribute lists and sources, illustrating expanded formatting for readability. No dependencies; inputs are variables and sources from which to inherit.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_29\n\nLANGUAGE: nix\nCODE:\n```\ninherit foo bar baz;\ninherit\n  foo'\n  bar'\n  baz'\n  ;\n```\n\nLANGUAGE: nix\nCODE:\n```\ninherit (pkgs) ap1 ap2 ap3;\ninherit (pkgs)\n  app1\n  app2\n  # ...\n  app42\n  ;\ninherit\n  (pkgs.callPackage ./foo.nix {\n    arg = \"val\";\n  })\n  attr1\n  attr2\n  ;\n```\n\n----------------------------------------\n\nTITLE: Leading Comma Attribute Sets - Nix - Nix Language\nDESCRIPTION: This snippet illustrates the alternative style for attribute set argument formatting in Nix, using leading commas and optional comments. It demonstrates the impact on readability and manipulation of argument list entries. No external dependencies are needed. The expected input is an attribute set argument declaration; the output follows the proposed style, but the snippet notes existing limitations with this form.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_18\n\nLANGUAGE: nix\nCODE:\n```\n{ some\n, arg\n}:\n\nargs@{\n  some\n, argument\n    # Single line comment\n, commentedArgument\n, # Comment on the value\n  # multiline comment\n  default ? value\n, ...\n}:\n# ...\n```\n\n----------------------------------------\n\nTITLE: Multi-Line Function Calls in Nix Bindings\nDESCRIPTION: Demonstrates multi-line function call assignments in Nix, illustrating alternatives to the standard semicolon placement. These illustrate how function calls or let-expressions can optionally have semicolons placed on new lines or use parentheses to wrap multi-line expressions, impacting readability and style. No dependencies are needed; inputs and outputs are function call expressions and their results.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_27\n\nLANGUAGE: nix\nCODE:\n```\nsome.very.long.attr = callFunction\n  arg1\n  arg2\n  arg3;\n```\n\nLANGUAGE: nix\nCODE:\n```\nsuff = let\n   foo = \"bar\"; # <-- double-indentation\n  in\n  foo;\n```\n\nLANGUAGE: nix\nCODE:\n```\nattr3 =\n  function call\n    many\n    arguments\n;\n```\n\nLANGUAGE: nix\nCODE:\n```\nattr3 =\n  let\n    foo = \"bar\";\n  in\n  some statements\n;\n```\n\nLANGUAGE: nix\nCODE:\n```\nattr3 =\n  function call\n    many\n    arguments\n  ;\n```\n\nLANGUAGE: nix\nCODE:\n```\n{\n  attr3 = (\n    function call\n      many\n      arguments\n  );\n  attr3 = (\n    let\n      foo = \"bar\";\n    in\n    some statements\n  );\n  attr3 = (\n    if foo == \"bar\" then\n      function call\n    else\n      some statements\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Inactive GitHub Committers for Nixpkgs - Python\nDESCRIPTION: This Python script identifies committers in the 'nixpkgs-committers' GitHub team who have not contributed to the Nixpkgs repository for the past calendar year, automating part of the annual review process described in the RFC. It requires a personal GitHub API token with 'read:org' scope exposed as 'GITHUB_TOKEN' in the environment, and depends on the PyGithub Python library. The script fetches the prior year, enumerates all current committers, and prints links for those without commits during the interval. Inputs include repository and organization details; output is a list of inactive user logins and links, with error handling for API limitations. Limitations include API rate limits, efficiency trade-offs when counting commits, and the need for user permission to run this script using nix-shell.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0055-retired-committers.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n#! /usr/bin/env nix-shell\\n#! nix-shell -I nixpkgs=https://github.com/nixos/nixpkgs-channels/archive/1412af4b2cfae71d447164097d960d426e9752c0.tar.gz -i python3 -p \\\"python3.withPackages (p: [ p.PyGithub ])\\\"\\n\\n# nixpkgs-inactive-committers expects an API token passed in the environment as GITHUB_TOKEN\\n# Such a token can be created at https://github.com/settings/tokens\\n# Make sure to enable the read:org scope\\n\\nfrom sys import stderr\\nfrom github import Github\\nfrom datetime import date, time, datetime\\nimport os\\n\\nyear = date.today().year - 1\\nstart_of_year = datetime.combine(date(year, 1, 1), time.min)\\n\\nprint(f'Reporting from {start_of_year}')\\n\\ngh = Github(os.environ['GITHUB_TOKEN'],\\n        user_agent='nixpkgs-inactive-committers',\\n        per_page=100, timeout=90, retry=5)\\nprint(gh.get_rate_limit(), file=stderr)\\n\\norg = gh.get_organization('nixos')\\nnixpkgs = org.get_repo('nixpkgs')\\ncommitters = org.get_team_by_slug('nixpkgs-committers').get_members()\\nsorted_committers = sorted(list(committers), key=lambda c: c.login.lower())\\n\\ndef hasCommit(commits):\\n    # totalCount is borked, len(list(...)) eats too many API calls\\n    try:\\n        c = commits[0]\\n        return True\\n    except IndexError:\\n        return False\\n\\nfor member in sorted_committers:\\n    commits = nixpkgs.get_commits(author=member, since=start_of_year)\\n\\n    if not hasCommit(commits):\\n        print(f'{member.login:<20} https://github.com/NixOS/nixpkgs/commits?author={member.login}')\n```\n\n----------------------------------------\n\nTITLE: Defining Bootspec Format v1 Schema in JSON5\nDESCRIPTION: JSON5 schema for the Bootspec Format v1, including required and optional fields for system boot configuration, kernel parameters, and specializations. This format aims to provide a standardized structure for bootloader configuration in NixOS.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0125-bootspec.md#_snippet_0\n\nLANGUAGE: json5\nCODE:\n```\n{\n  // Toplevel key describing the version of the specification used in the document\n  \"org.nixos.bootspec.v1\": {\n    // (Required) System type the bootspec is intended for (e.g. `x86_64-linux`, `aarch64-linux`)\n    \"system\": \"x86_64-linux\",\n\n    // (Required) Path to the stage-2 init, executed by the initrd (if present)\n    \"init\": \"/nix/store/xxx-nixos-system-xxx/init\",\n\n    // (Optional) Path to the initrd\n    \"initrd\": \"/nix/store/xxx-initrd-linux/initrd\",\n\n    // (Optional) Path to a tool to dynamically add secrets to an initrd.\n    // Consumers of a bootspec document should copy the file referenced by the \"initrd\" key to a writable location, ensure that the file is writable, invoke this tool with the path to the initrd as its only argument, and use the initrd as modified by the tool for booting.\n    // This may be used to add files from outside the Nix store to the initrd.\n    // This tool is expected to run on the system whose boot specification is being set up, and may thus fail if used on a system where the expected stateful files are not in place or whose CPU does not support the instruction set of the system to be booted.\n    // If this field is present and the tool fails, no boot configuration should be generated for the system.\n    \"initrdSecrets\": \"/nix/store/xxx-append-secrets/bin/append-initrd-secrets\",\n\n    // (Required) Path to the kernel image\n    \"kernel\": \"/nix/store/xxx-linux/bzImage\",\n\n    // (Required) Kernel commandline options\n    \"kernelParams\": [\n      \"amd_iommu=on\",\n      \"amd_iommu=pt\",\n      \"iommu=pt\",\n      \"kvm.ignore_msrs=1\",\n      \"kvm.report_ignored_msrs=0\",\n      \"udev.log_priority=3\",\n      \"systemd.unified_cgroup_hierarchy=1\",\n      \"loglevel=4\"\n    ],\n\n    // (Required) The label of the system. It should contain the operating system, kernel version,\n    // and other user-relevant information to identify the system. This corresponds\n    // loosely to `config.system.nixos.label`.\n    \"label\": \"NixOS 21.11.20210810.dirty (Linux 5.15.30)\",\n\n    // (Required) Top level path of the closure, in case some spelunking is required\n    \"toplevel\": \"/nix/store/xxx-nixos-system-xxx\",\n  },\n  // The top-level object may contain arbitrary further keys (\"extensions\"), whose semantics may be defined by third parties.\n  // The use of reverse-domain-name namespacing is recommended in order to avoid name collisions.\n\n  // (Optional) Specialisations are an extension to the specification which allows bundling multiple variants of a NixOS configuration with a single parent.\n  // These are shaped like the top level; to be precise:\n  //  - Each entry in the toplevel \"org.nixos.specialisation.v1\" object represents a specialisation.\n  //  - In order for the top-level document to be a valid v1 bootspec, each specialisation must have a valid \"org.nixos.bootspec.v1\" key whose value conforms to the same schema as the toplevel \"org.nixos.bootspec.v1\" object.\n  //  - The behaviour of nested specialisations (i.e. entries in \"org.nixos.specialisation.v1\" which themselves contain the \"org.nixos.specialisation.v1\" key) is not defined.\n  //  - In particular, there is no expectation that such nested specialisations will be handled by consumers of bootspec documents.\n  //  - Each specialisation document may contain arbitrary further keys (extensions), like the top-level document.\n  //  - The semantics of these should be the same as when these keys are used at the top level, but only apply for the given specialisation.\n  \"org.nixos.specialisation.v1\": {\n    // Each key in this object corresponds to a specialisation as defined by the `specialisation.<name>` NixOS option.\n    \"<name>\": {\n      \"org.nixos.bootspec.v1\": {\n        // See above\n      }\n    }\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Maintainer List in Nix\nDESCRIPTION: Changes proposed for the maintainer-list.nix file to include GitHub user IDs alongside handles for better identification and management of maintainers.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0039-unprivileged-maintainer-teams.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n# Example of proposed change to maintainer-list.nix\n{\n  alice = {\n    email = \"alice@example.com\";\n    github = \"alice123\";\n    githubId = 12345678; # New field for GitHub user ID\n    name = \"Alice Developer\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Store Permissions Using NixOS Module (Nix)\nDESCRIPTION: This Nix snippet demonstrates how to set custom permissions for the /nix/store directory by specifying the 'nix.store-perms' option in a NixOS configuration. The value assigned (represented as 'xxxx' in the example) should be a valid permission string (e.g., '1735') that determines the access control for the directory. To use this, you must be editing your NixOS configuration file (e.g., configuration.nix) and have an understanding of Unix permission modes. The option will only affect the initial setup of /nix/store if it does not already exist, and has no retroactive enforcement for subsequent permission changes.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0097-no-read-store-dir.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nnix.store-perms = \"xxxx\";\n```\n\n----------------------------------------\n\nTITLE: Example Nixdoc Format in Nixpkgs Library\nDESCRIPTION: Demonstrates the current format understood by the nixdoc tool, showing how to document a constant function in Nix with type signature and example usage.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0145-doc-strings.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n  /* The constant function\n\n     Ignores the second argument. If called with only one argument,\n     constructs a function that always returns a static value.\n\n     Type: const :: a -> b -> a\n     Example:\n       let f = const 5; in f 10\n       => 5\n  */\n  const =\n    # Value to return\n    x:\n    # Value to ignore\n    y: x;\n```\n\n----------------------------------------\n\nTITLE: Modern Doc-Commented Function for Filtering Attribute Sets Using CommonMark - Nix\nDESCRIPTION: This updated Nix snippet applies the standardized /** ... */ doc-comment format with embedded CommonMark for the 'filterAttrs' function. The comment details function behavior, provides code examples in Markdown code blocks, and documents arguments in a substitutive markdown list. All dependencies and usages remain as per standard Nix libraries, including 'listToAttrs', 'concatMap', 'nameValuePair', and 'attrNames'. The function takes a predicate 'pred' and an attribute set 'set', returning a new attribute set filtered accordingly. The format maximizes compatibility with documentation tooling and supports explicit argument documentation.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0145-doc-strings.md#_snippet_12\n\nLANGUAGE: nix\nCODE:\n```\n/**\n  Filter an attribute set by removing all attributes for which the\n  given predicate return false.\n\n  # Example\n\n  ```nix\n  filterAttrs (n: v: n == \"foo\") { foo = 1; bar = 2; }\n  => { foo = 1; }\n  ```\n\n  # Type\n\n  ```\n  filterAttrs :: (String -> Any -> Bool) -> AttrSet -> AttrSet\n  ```\n\n  # Arguments\n\n  - [pred] Predicate taking an attribute name and an attribute value, which returns `true` to include the attribute, or `false` to exclude the attribute.\n  - [set] The attribute set to filter\n*/\nfilterAttrs =\n  pred:\n  set:\n  listToAttrs (concatMap (name: let v = set.${name}; in if pred name v then [(nameValuePair name v)] else []) (attrNames set));\n```\n\n----------------------------------------\n\nTITLE: Doc-Comments for Lambda and its Formal Parameters\nDESCRIPTION: Shows how to document both a lambda function and its formal parameters using the proposed doc-comment format.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0145-doc-strings.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\n/**Doc for the whole lambda function*/\n{\n /**Doc for formal 'a'*/\n a\n}:\n a              \n```\n\n----------------------------------------\n\nTITLE: Doc-Comment in Let Binding\nDESCRIPTION: Demonstrates documentation for a function defined in a let binding, showing that the doc-comment is still retrievable.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0145-doc-strings.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\nlet\n /** Documentation for the id function*/\n     ↓\n a = x: x;\nin\n a\n\n# Documentation can still be retrieved.\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Linebreaking and Empty Line Collapsing in Nix Lists (Nix Language)\nDESCRIPTION: Shows how the Nix formatter may introduce or remove line breaks and collapse multiple consecutive empty lines in list expressions. The first code block represents pre-formatting with extra whitespaces, while the second demonstrates the formatter's compact result. Output format ensures no new empty lines and at most one consecutive empty line.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n[\\n  0 10\\n\\n  (\\n    20 + 1\\n  )\\n\\n\\n  30\\n]\n```\n\nLANGUAGE: nix\nCODE:\n```\n[\\n  0  # Line break added\\n  10\\n\\n  (20 + 1) # Line breaks removed\\n           # Consecutive empty lines turned into a single empty line\\n  30\\n]\n```\n\n----------------------------------------\n\nTITLE: Doc-Comment in List Expression\nDESCRIPTION: Demonstrates how to document a value within a list expression using the proposed doc-comment format.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0145-doc-strings.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nlistToAttrs [\n  { name = \"foo\"; value = /**Documentation for '1'*/1; }\n]\n```\n\n----------------------------------------\n\nTITLE: Configuring Stale Issue Management with GitHub Stale - YAML\nDESCRIPTION: This YAML snippet provides a configuration file for the GitHub Stale bot, specifying how and when issues and pull requests should be marked as stale in the Nixpkgs repository. Dependencies include the Stale GitHub application and appropriate repository permissions. Key parameters include the number of inactive days before tagging issues as stale, the label to use, exempt labels, and the message shown to users. The configuration disables automatic issue closure and customizes user guidance when an issue is marked as stale. Inputs are issue/pull request activity; outputs are automatic labels and comments managed via GitHub actions.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0051-mark-stale-issues.md#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\n# Number of days of inactivity before an issue becomes stale\\ndaysUntilStale: 180\\n# Number of days of inactivity before a stale issue is closed\\ndaysUntilClose: false\\n# Issues with these labels will never be considered stale\\nexemptLabels:\\n  - 1.severity: security\\n# Label to use when marking an issue as stale\\nstaleLabel: 2.status: stale\\n# Comment to post when marking an issue as stale. Set to `false` to disable\\nmarkComment: >\\n  Thank you for your contributions.\\n\\n  This has been automatically marked as stale because it has had no\\n  activity for 180 days.\\n\\n  If this is still important to you, we ask that you leave a\\n  comment below. Your comment can be as simple as \\\"still important\\n  to me\\\". This lets people see that at least one person still cares\\n  about this. Someone will have to do this at most twice a year if\\n  there is no other activity.\\n\\n  Here are suggestions that might help resolve this more quickly:\\n\\n  1. Search for maintainers and people that previously touched the\\n     related code and @ mention them in a comment.\\n  2. Ask on the [NixOS Discourse](https://discourse.nixos.org/).\\n  3. Ask on the [#nixos channel](irc://irc.freenode.net/#nixos) on\\n     [irc.freenode.net](https://freenode.net).\\n\\n# Comment to post when closing a stale issue. Set to `false` to disable\\ncloseComment: false\n```\n\n----------------------------------------\n\nTITLE: Configuring MACVLAN and Networkd for Advanced Container Networking - Nix/NixOS\nDESCRIPTION: This complex Nix example configures systemd-networkd and systemd-nspawn to provide a container with a MACVLAN-based sub-interface, demonstrating how to assign multiple interfaces with unique MAC addresses. It covers physical and virtual network configurations using systemd .netdev and .network units, ensuring both host and container sides are properly set up. Dependencies include NixOS, systemd-networkd, and systemd-nspawn. Inputs are physical NICs, addresses, and netdev kinds; outputs are multiple reachable addresses and properly isolated MACVLAN interfaces on both host and container. Special care should be taken to match naming/ordering and to force addresses as shown ('lib.mkForce') to avoid config conflict.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0108-nixos-containers.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # Config for the physical interface itself with DHCP enabled and associated to a MACVLAN.\n  systemd.network.networks.\"40-eth1\" = {\n    matchConfig.Name = \"eth1\";\n    networkConfig.DHCP = \"yes\";\n    dhcpConfig.UseDNS = \"no\";\n    networkConfig.MACVLAN = \"mv-eth1-host\";\n    linkConfig.RequiredForOnline = \"no\";\n    address = lib.mkForce [];\n    addresses = lib.mkForce [];\n  };\n\n  # The host-side sub-interface of the MACVLAN. This means that the host is reachable\n  # at `192.168.2.2`, both on the physical interface and from the container.\n  systemd.network.networks.\"20-mv-eth1-host\" = {\n    matchConfig.Name = \"mv-eth1-host\";\n    networkConfig.IPForward = \"yes\";\n    dhcpV4Config.ClientIdentifier = \"mac\";\n    address = lib.mkForce [\n      \"192.168.2.2/24\"\n    ];\n  };\n  systemd.network.netdevs.\"20-mv-eth1-host\" = {\n    netdevConfig = {\n      Name = \"mv-eth1-host\";\n      Kind = \"macvlan\";\n    };\n    extraConfig = ''\n      [MACVLAN]\n      Mode=bridge\n    '';\n  };\n\n  # Assign a MACVLAN to a container. This is done by pure nspawn.\n  systemd.nspawn.vlandemo.networkConfig.MACVLAN = \"eth1\";\n  nixos.containers = {\n    instances.vlandemo.system-config = {\n      systemd.network = {\n        networks.\"10-mv-eth1\" = {\n          matchConfig.Name = \"mv-eth1\";\n          address = [ \"192.168.2.5/24\" ];\n        };\n        netdevs.\"10-mv-eth1\" = {\n          netdevConfig.Name = \"mv-eth1\";\n          netdevConfig.Kind = \"veth\";\n        };\n      };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Declaratively Defining an Imperative Container with Pinned nixpkgs and Networking - Nix/NixOS\nDESCRIPTION: This Nix snippet serves as an input config for building an imperative, systemd-nspawn-based container with a fixed nixpkgs source, specific system configuration (nginx enabled, firewall open for port 80), custom network setup, and an explicit port-forwarding map (from host port 8080 to container port 80). The config is used by nixos-nspawn commands to create/update containers. Prerequisites include a suitable systemd-nspawn/nixos-nspawn environment, nixpkgs channel/button, and networking support; output is a running container with nginx accessible at the desired ports and automatic port forwarding active. Only core attributes are set, so extending the config supports further customization.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0108-nixos-containers.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nixpkgs = <nixpkgs>;\n  system-config = { pkgs, ... }: {\n    services.nginx.enable = true;\n    networking.firewall.allowedTCPPorts = [ 80 ];\n  };\n\n  # This implies that the \"default\" networking mode (i.e. DHCPv4) is used\n  # and not the host's network (which is the default for imperative containers).\n  network = {};\n  forwardPorts = [ { hostPort = 8080; containerPort = 80; } ];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Container Instance with Network and Packages - Nix/NixOS\nDESCRIPTION: This NixOS module-based Nix expression demonstrates the declarative configuration of a container under nixos.containers.instances, assigning both network configuration and a set of system packages (here 'hello') to the container. Dependencies include a working NixOS host, Nix modules, and systemd-nspawn support. The input defines key sections: network (uses defaults) and system-config (provides environment setup), and expects as inputs the pkgs argument for package selection; output is a running container instance reachable by the configured name. Limitations include needing to handle low-level network differences from the older implementation.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0108-nixos-containers.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nixos.containers.instances.demo = {\n    network = {};\n    system-config = { pkgs, ... }: {\n      environment.systemPackages = [ pkgs.hello ];\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unicode Quote Issues with Bash Variable Interpolation\nDESCRIPTION: This example shows how Unicode quotes interact poorly with bash variable interpolation. When a variable is followed by a Unicode quote character, bash incorrectly treats the first UTF-8 byte of the quote as part of the variable name, resulting in unexpected behavior.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0004-replace-unicode-quotes.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ x=y\n$ echo \"$x\"\ny\n$ echo \"$x'\" # WTF is going on here!?\n??\n```\n\n----------------------------------------\n\nTITLE: Doc-Comment for Dynamic Attribute\nDESCRIPTION: Shows how to document a value bound to a dynamically generated attribute name.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0145-doc-strings.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n    /** Documentation for '2' */\n                                   ↓\n    ${let name = \"bar\"; in name} = 2;\n}\n# Dynamic attribute\n```\n\n----------------------------------------\n\nTITLE: Closing RFC for Insufficient Shepherd Interest - Markdown - English\nDESCRIPTION: This markdown snippet is posted when an RFC has still failed to attract a complete shepherd team after an additional month, prompting closure of the pull request with an appropriate label. It informs contributors of the closure reason and provides a method for reopening the discussion, including a reference to the RFC Steering Committee's issue tracker. Intended for use within GitHub PRs by official maintainers or bots, it requires no dependencies and outputs a formatted notice. Its clear structure aids in automated or manual community communications within the NixOS RFC process.\nSOURCE: https://github.com/nixos/rfcs/blob/master/README.md#_snippet_2\n\nLANGUAGE: Markdown\nCODE:\n```\nRFCSC: This RFC is being closed due to lack interest. If enough shepherds are found this issue can be reopened. If you don\\'t have permission to reopen please [open an issue for the NixOS RFC Steering Committee](https://github.com/NixOS/rfc-steering-committee/issues/new) linking to this PR.\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Inline Code and Escaping in reStructuredText - reStructuredText\nDESCRIPTION: This snippet demonstrates the peculiarities and limitations of inline code and escaping mechanisms required in reStructuredText (RST) syntax. It shows how backslashes are needed to represent commonly-used constructs like trailing 's' on inline code and creating italicized sections within text. Understanding this syntax is crucial for correctly authoring documentation in RST, as minor mistakes can cause content to render incorrectly without explicit build errors.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0072-commonmark-docs.md#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\nPython ``list``\\s use square bracket syntax.\nThis is a long\\ *ish* paragraph\n```\n\n----------------------------------------\n\nTITLE: Diff for Modifying Stale Bot Configuration in Nix\nDESCRIPTION: Proposed changes to the .github/stale.yml file to align Nix's stale issue policy with Nixpkgs. This includes disabling auto-closing, adjusting exempt labels, and removing close/mark comments.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0124-nix-mark-stale-issues.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/.github/stale.yml b/.github/stale.yml\nindex fe24942f4..539720b6d 100644\n--- a/.github/stale.yml\n+++ b/.github/stale.yml\n@@ -1,10 +1,8 @@\n # Configuration for probot-stale - https://github.com/probot/stale\n daysUntilStale: 180\n-daysUntilClose: 365\n+daysUntilClose: false\n exemptLabels:\n   - \"critical\"\n+  - \"never-stale\"\n staleLabel: \"stale\"\n-markComment: |\n-  I marked this as stale due to inactivity. &rarr; [More info](https://github.com/NixOS/nix/blob/master/.github/STALE-BOT.md)\n-closeComment: |\n-  I closed this issue due to inactivity. &rarr; [More info](https://github.com/NixOS/nix/blob/master/.github/STALE-BOT.md)\n+markComment: false\n+closeComment: false\n```\n\n----------------------------------------\n\nTITLE: YAML Frontmatter for Nix RFC\nDESCRIPTION: YAML frontmatter defining metadata for the RFC, including feature name, start date, author, co-authors, shepherd team, and related issues.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0124-nix-mark-stale-issues.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nfeature: nix-mark-stale-issues\nstart-date: 2022-04-18\nauthor: John Ericson (@Ericson2314)\nco-authors: (find a buddy later to help out with the RFC)\nshepherd-team: @ryantm, @nh2, @infinisil\nshepherd-leader: @ryantm\nrelated-issues: (will contain links to implementation PRs)\n---\n```\n\n----------------------------------------\n\nTITLE: Visualizing RFC Process Flow with Mermaid Diagram\nDESCRIPTION: A mermaid flowchart diagram showing the updated RFC process including the new 'On Hold' and 'Lacking Interest' states. The diagram illustrates all possible transitions between states from draft to final outcomes.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0130-stalled-rfcs.md#_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph TD\n    Start((Start)) --> Draft\n    Draft -->|Ready for Review| Discuss\n    style Draft fill:#008,color:#FFF\n\n    Discuss[Discuss and Refine]\n    Discuss ---> |On Hold| Draft\n    Discuss --> |Can't Find Shepherds| NoShepherds\n    Discuss --> |Motion for FCP| FCP\n\n    NoShepherds[Closed - Lack of Interest]:::closed\n    NoShepherds --> |Renewed Interest| Discuss\n\n    FCP[Final Coment Phase]\n    FCP --> |FCP Canceled| Discuss\n    FCP --> |Accept| Merged\n    FCP --> |Reject| Rejected\n    \n    Merged\n    style Merged fill:#080,color:#FFF\n    \n    Rejected[Closed - Rejected]:::closed\n\n    Withdrawn[Closed - Withdrawn]:::closed\n    Discuss & Draft --->|Author Withdraws| Withdrawn\n\n    classDef closed fill:#800,color:#FFF\n```\n\n----------------------------------------\n\nTITLE: String Interpolation and Absorption: Multiline and Simple Expressions (Nix)\nDESCRIPTION: This set of examples illustrates the rules for formatting string interpolations in Nix, covering simple and complex (multiline) cases, as well as how and when interpolation absorption is allowed based on string position. There are no dependencies, and all code assumes standard Nix processing. Inputs are strings and interpolations; outputs are their formatted representations with proper absorption or expansion of interpolations as per defined rules.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_13\n\nLANGUAGE: nix\nCODE:\n```\n# Short and simple\n\"foo \\n\\t ${bar} baz\"\n\n# Interpolation of simple or short code\n# Good\nthrow ''Some very long error messages containing ${variables} and stuff''\n# Bad\nthrow ''Some very long error messages containing ${\n  variables\n} and stuff''\n\n''\n  # Don't absorb interpolations if they don't start the line\n  # Good\n  some longer line ${\n    some function [\n      1\n      2\n    ]\n  } baz\n  # Bad\n  some longer line ${some function [\n    1\n    2\n  ]} baz\n\n  # However, absorption is allowed here, since the interpolation starts a line\n  ${other function (\n    # with stuff\n  )}\n''\n```\n\n----------------------------------------\n\nTITLE: Establishing Participation and Inclusiveness Statement - Markdown\nDESCRIPTION: This markdown block states the NixOS Foundation's commitment to participation, inclusiveness, and a welcoming community. There are no dependencies or technical parameters; it is purely a declaration reproduced for policy guidance. The block is intended for reference by the moderation team and linked to wider community documentation. Inputs/outputs are not applicable; it is static text, and no code execution or processing is involved.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0102-moderation-team.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```\nThe NixOS Foundation aims to promote participation without regard to gender,\nsexual orientation, disability, ethnicity, age, or similar personal\ncharacteristics. We want to strive to create and foster community by providing\nan intentionally welcoming and safe environment where all feel valued and cared\nfor, and where all are given opportunity to participate meaningfully. The\nFoundation will work with the community in service of this goal.\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nix Command Compatibility\nDESCRIPTION: Shows that the maximal Nix interface remains unchanged, allowing lower-level commands to be used with higher-level 'installables' (arguments).\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0134-nix-store-layer.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnix show-derivation flake#bar\n```\n\n----------------------------------------\n\nTITLE: Overriding Build Phase in mkDerivation - Nix\nDESCRIPTION: This snippet shows how to override the buildPhase in a Nix expression for a package. A shell script is provided to the buildPhase attribute, which replaces the default build logic. Dependencies include Nixpkgs' stdenv.mkDerivation. The attribute can be set to any valid bash code. Inputs: an attribute set for mkDerivation. Output: a derivation with a custom build phase.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0032-run-phase-changes-for-better-nix-shell-use.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation {\n    # ...\n    \n    buildPhase = ''\n        ./my-funky-build-script.sh\n    '';\n    \n    # ...\n}\n```\n\n----------------------------------------\n\nTITLE: Problematic Package Variant Override in Nix\nDESCRIPTION: Demonstrates an incorrect way to override a package variant that leads to infinite recursion when trying to make the variant the default package.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0140-simple-package-paths.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nself: super: {\n  # Oops, infinite recursion!\n  graphviz = self.graphviz_nox;\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Statement Formatting - If-Then-Else - Nix Language\nDESCRIPTION: These code snippets show proper formatting for `if-then-else` conditional expressions in Nix, including single-line and multiline conditions, chains of else-if, and alternative formatting options. They demonstrate indentation requirements and consistent vertical alignment. No dependencies are required. Inputs are boolean conditions; outputs are branch values—often attribute sets, lists, or function calls.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_20\n\nLANGUAGE: nix\nCODE:\n```\n# Condition fits on one line\nif builtins.length matches != 0 then\n  { inherit path matches; }\nelse if path == /. then\n  [\n    1\n    2\n  ]\nelse\n  go (dirOf path);\n\n# Condition doesn't fit onto one line\nif\n  matches != null\n  && builtins.length matches != 0\nthen\n  { inherit path matches; }\nelse if path == /. then\n  null\nelse\n  go (dirOf path);\n```\n\nLANGUAGE: nix\nCODE:\n```\n#1a\nif builtins.length matches != 0 then {\n  inherit path matches;\n} else if path == /. then [\n  1\n  2\n] else\n  go (dirOf path);\n```\n\nLANGUAGE: nix\nCODE:\n```\n#1b\nif builtins.length matches != 0\n  then { inherit path matches; }\nelse if path == /.\n  then [\n    1\n    2\n  ]\nelse go (dirOf path);\n```\n\nLANGUAGE: nix\nCODE:\n```\n#1c\nif builtins.length matches != 0\nthen { inherit path matches; }\nelse if path == /.\nthen [\n  1\n  2\n]\nelse go (dirOf path);\n```\n\n----------------------------------------\n\nTITLE: Binding Styles and Semicolon Placement in Nix\nDESCRIPTION: These Nix snippets illustrate various binding styles depending on value complexity and length, enforcing rules like expansion of attribute sets and proper semicolon placement. They show both single-line and multi-line values, nested attribute sets, absorbed and non-absorbed bodies, and the use of with expressions. The examples require only the Nix language and, for with, a reference library. Inputs include attribute names and expressions, and outputs are constructed attribute sets.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_26\n\nLANGUAGE: nix\nCODE:\n```\n#1 The entire binding fits onto a single line\nfoo = \"bar\";\n```\n\nLANGUAGE: nix\nCODE:\n```\n#2 The body fits onto a single line, but the binding is too long\nlength limit\nvery.long.foo =\n  function arg1 arg2 arg3;\n```\n\nLANGUAGE: nix\nCODE:\n```\n#3 Where possible, the body should be absorbed\nfoo = function {\n  # args\n};\nadd = x: y: {\n  result = x + y;\n};\n```\n\nLANGUAGE: nix\nCODE:\n```\n#4 If neither single-line nor absorbable, start on a new line with indentation\nfoo =\n  function\n    arg1\n    arg2\n    arg3;\n\n# There is non-indented line between the first and last line, so this can't use the absorbed style\nbar =\n  if baz == null then\n    10\n  else\n    20;\n```\n\nLANGUAGE: nix\nCODE:\n```\n{\n  foo.bar.baz = \"qux\";\n  foo' = {\n    bar.baz = \"qux\";\n  };\n}\n```\n\nLANGUAGE: nix\nCODE:\n```\n# Force-expand short attrset\nmeta = with lib; {\n  maintainers = [];\n};\n# Don't absorb since the body of `with pkgs;` is `with pyPkgs; ...`, which is not absorbable.\nbuildInputs =\n  with pkgs;\n  with pyPkgs;\n  [\n    some\n    dependencies\n  ];\n```\n\n----------------------------------------\n\nTITLE: Compact Singleton List Style in Nix\nDESCRIPTION: This snippet proposes a compact way to write singleton lists or attribute sets, reducing indentation and line usage. The example wraps the value in brackets directly after the assignment. Inputs and outputs are assignment of a list with a single attribute set; no dependencies are required.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_25\n\nLANGUAGE: nix\nCODE:\n```\nfoo = [ {\n  # content\n} ];\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Good and Bad Indentation in Nix Attribute Sets (Nix Language)\nDESCRIPTION: Illustrates both poor and preferred indentation practices when formatting nested attribute sets and conditional expressions in Nix. The 'bad' example highlights misleading indentation, while the 'good' example enforces structure-reflecting indentation. These snippets are instructive for designing code formatters and require no external dependencies.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n# Bad, the indentation misleads the user\\n{\\n  foo = {\\n  bar = if\\n  baz == null then 10\\n    else 20\\n  ;\\n}; }\\n\n```\n\nLANGUAGE: nix\nCODE:\n```\n# Good\\n{\\n  foo = {\\n    bar =\\n      if baz == null then\\n        10\\n      else\\n        20;\\n  };\\n}\n```\n\n----------------------------------------\n\nTITLE: Assertion Formatting and Usage - Nix - Nix Language\nDESCRIPTION: These snippets exhibit the correct and incorrect ways to format assert expressions and assertions within attribute sets and `let` bindings. The code covers multiline conditions, nested assertions, and assertion messages. Snippets directly illustrate indentation rules for `assert` and how they interact with value binding. Inputs are typically boolean conditions or expressions, with the output being either a value or an error if the assertion fails. No external dependencies are necessary.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_21\n\nLANGUAGE: nix\nCODE:\n```\n# Good\nassert foo;\n[\n  bar\n  baz\n]\n\n# Bad\nassert foo; [\n  bar\n  baz\n]\n\n# Good\n{\n  vendor ?\n    assert false;\n    null,\n    \n  vendor ? null,\n}:\nnull\n\nlet\n  # Good\n  x =\n    assert foo;\n    bar;\n   \n  # Bad\n  y = assert foo;\n    bar;\nin\nx\n\n# Multiline condition\nassert\n  let\n    x = true;\n  in x;\n  true\n\n# Function call condition with absorbed last argument, same formatting as bindings\nassert assertMsg (isPath path) ''\n  lib.path.append:\n    The first argument is of type ${builtins.typeOf path}, but a path was expected\n'';\ntrue\n```\n\n----------------------------------------\n\nTITLE: Handling Strings and Interpolations (Nix)\nDESCRIPTION: These snippets show how strings and interpolated expressions should be formatted and preserved in Nix according to the outlined requirements. Quoting style, non-interpolated parts, escapes, and the structural layout of interpolations (simple vs multiline) are demonstrated. No dependencies beyond standard Nix evaluation. Inputs are various strings and their interpolations, outputs are the same strings, unmodified except where the rules explicitly allow format changes. The rules emphasize not changing quote types or interpreting escape codes.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_12\n\nLANGUAGE: nix\nCODE:\n```\n# Kept as is\n\"foo \\n\\t ${bar} baz\"\n# This one too\n''\n  foo \\n\\t ${bar} baz\n''\n\n# Even if strings exceed the line length limit, no attempt to make it smaller is made\n''\n  This is a really long string that would not fit within the line length limit\n''\n```\n\n----------------------------------------\n\nTITLE: Building Derivations with Content- and Input-Addressed Paths - Python\nDESCRIPTION: This snippet implements a function to build a derivation, supporting both content-addressed and input-addressed modes. It leverages methods like 'assignScratchOutputPaths', 'runBuildScript', and 'moveToCAPaths' for CA derivations and directly uses the outputs for IA derivations. Dependencies: requires all the referenced helper functions and types (Derivation, DrvOutput, etc). Inputs are the derivation and a list of outputs to build; output is a mapping of outputs to their realizations. Only one build algorithm for both CA and IA is shown, with CA-specific logic in an if-else branch.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0062-content-addressed-paths.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef build_derivation(derivation : Derivation, outputsToBuild: [str]) -> Map[DrvOutput, Realisation]:\n    # Build the dependencies and resolve the derivation like before\n    derivationToBuild = ...\n\n    if (derivationToBuild.isContentAddressed()):\n        assignScratchOutputPaths(derivationToBuild)\n        runBuildScript(derivationToBuild)\n        return moveToCAPaths(derivationToBuild.outputs)\n    else:\n        runBuildScript(derivationToBuild)\n        # If the derivation isn\\u2019t content-addressed, then it already knows its\n        # own output paths\n        return derivationToBuild.outputs\n```\n\n----------------------------------------\n\nTITLE: Nix Package Testing Pattern Reference\nDESCRIPTION: Demonstrates the standardized pattern for package tests using tests.<name> commonly set with passthru.tests.<name> in mkDerivation. This pattern is used for expensive automatic testing and downstream dependency verification.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0119-testing-conventions.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\ntests.<name>\n```\n\n----------------------------------------\n\nTITLE: Building Derivations with Strict Input-Addressed Handling - Python\nDESCRIPTION: This snippet provides an enhanced derivation build function that explicitly handles strictly input-addressed derivations by bypassing resolution. It recursively builds input derivations, potentially resolves them, and dispatches to either content-addressed or input-addressed build logic accordingly. Dependencies: expects all build helper functions and derivation/realisation data structures to be available. Inputs are a derivation and target outputs; output is a mapping of DrvOutput to Realisation. The implementation ensures backward compatibility and correct path determination when mixing CA and IA derivations.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0062-content-addressed-paths.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef build_derivation(derivation : Derivation, outputsToBuild: [str]) -> Map[DrvOutput, Realisation]:\n    inputRealisations : Map[DrvOutput, Realisation] = {}\n    # Build all the inputs, and store the newly built realisations\n    for (inputDrv, requiredOutputs) in derivation.inputDrvs:\n        inputRealisations += build_derivation(inputDrv, requiredOutputs)\n\n    derivationToBuild =\n        derivation if derivation.isStrictlyInputAddressed()\n        else resolved(derivation, inputRealisations)\n\n    if (derivationToBuild.isContentAddressed()):\n        assignScratchOutputPaths(derivationToBuild)\n        runBuildScript(derivationToBuild)\n        return moveToCAPaths(derivationToBuild.outputs)\n    else:\n        runBuildScript(derivationToBuild)\n        # If the derivation isn\\u2019t content-addressed, then it already knows its\n        # own output paths\n        return derivationToBuild.outputs\n```\n\n----------------------------------------\n\nTITLE: Defining Attribute Sets and Lists in Nix\nDESCRIPTION: These snippets exemplify best practices for formatting attribute sets and lists in Nix files. Brackets and braces have spaces or line breaks inside, empty sets/lists use [ ] or { }, and longer/nested structures are expanded across multiple lines for readability. Inputs and outputs vary by content; use cases include singleton and nested attribute sets/lists. No dependencies required.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_24\n\nLANGUAGE: nix\nCODE:\n```\n[\n  { }\n  { foo = \"bar\"; }\n  {\n    foo = {\n      bar = \"baz\";\n    };\n  }\n  { foo.bar = \"baz\"; }\n]\n```\n\nLANGUAGE: nix\nCODE:\n```\n[\n  [ 1 ]\n  [\n    2\n    3\n  ]\n]\n```\n\nLANGUAGE: nix\nCODE:\n```\n[\n  [\n    1\n    2\n    3\n  ]\n]\n```\n\nLANGUAGE: nix\nCODE:\n```\n[\n  {\n    mySingletons = [\n      [\n        ({\n          # stuff in there\n        })\n      ]\n    ];\n  \n    mySingletons' = [\n      [\n        (function call)\n      ]\n    ];\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Declaring Issues with meta.issues Variants - Nix Language\nDESCRIPTION: This set of Nix code sketches shows four alternative approaches for expressing package issues using the meta.issues attribute. Approaches demonstrated include an attribute list (with kind, name, message), referencing global issues by name, a unified attribute set (name-mapped messages), and transitive issue inheritance from another package. These patterns allow both ad-hoc and cross-package issue declarations, enabling granular and reusable problem specification.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0127-issues-warnings.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # Using a list instead of attribute set. Slightly less complexity, but also slightly more verbose.\n  meta.issues = [{\n    kind = \"deprecated\";\n    name = \"python2-eol\";\n    message = \"deprecation: Python 2 is EOL. #12345\";\n    # (Other fields omitted for brevity)\n  }];\n\n  # Issues are defined elsewhere in some nixpkgs-global table, only get referenced in packages\n  meta.issues = [ \"1234-python-deprecation\" ];\n\n  # Attempt to unify both approaches to allow both ad-hoc and cross-package declaration\n  meta.issues = {\n    \"1234-python-deprecation\" = {\n      message = \"deprecation: Python 2 is deprecated #12345\";\n    };\n  };\n\n  # Proposal by @matthiasbeyer\n  meta.issues = [\n    { transitive = pkgs.python2.issues }\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Attribute Set Bindings and Conditionals in Nix\nDESCRIPTION: Shows diverse attribute set binding styles including function call with arguments, if-else assignments, let-in assignments, and multi-line operator usages. Each binding demonstrates appropriate indentation and semicolon placement for clarity. Dependencies are intrinsic to Nix; outputs depend on the logic per each attribute.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_28\n\nLANGUAGE: nix\nCODE:\n```\n{\n  attr1 = bar;\n  attr2 = function call {\n    # stuff\n  };\n  attr3 =\n    function call\n      many\n      arguments;\n  attr4 =\n    let\n      foo = \"bar\";\n    in\n    some statement;\n  attr5 =\n    if foo then\n      \"bar\"\n    else\n      \"baz\";\n  attr6 =\n    let\n      foo = false;\n    in\n    if foo then \"bar\" else \"baz\";\n  attr7 = function (\n    if foo then\n      \"bar\"\n    else\n      \"baz\"\n  );\n  attr8 =\n    cond1\n    || cond2\n    ||\n      some function call\n      && cond3;\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Incompatible Realisations and Substituting Dependencies in Nix - Python\nDESCRIPTION: Provides Python functions for detecting incompatible realisations (i.e., when the same derivation output has a different store path than expected) and for recursively substituting realisations while enforcing dependency closure invariants. 'is_incompatible' warns and returns True if an incompatibility is found. 'substitute_realisation' ensures that each realisation and its dependencies are consistently substituted, aborting if any incompatibility is encountered. Requires access to local and remote store interfaces. Inputs include derivation outputs and store references; outputs are the substituted realisation or None if incompatible.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0062-content-addressed-paths.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Returns true (and warns) iff we already have a realisation for the given\n# derivation output, and that realisation has a different output path\n# than the expected one.\ndef is_incompatible(drvOutput, expectedStorePath):\n    maybeLocalRealisation = localStore.queryRealisation(drvOutput)\n    if (maybeLocalRealisation and maybeLocalRealisation.outputPath != expectedStorePath):\n        warn(f\"The substituter {substituter} has an incompatible realisation for {dependentDrvOutput}\")\n        return True\n    return False\n\n\ndef substitute_realisation(substituter : Store, wantedOutput : DrvOutput) -> Maybe Realisation:\n    maybeRealisation = substituter.queryRealisation(wantedOutput)\n    if maybeRealisation is None:\n        return None\n\n    # Try substituting the derivations we depend on\n    for (dependentDrvOutput, expectedStorePath) in maybeRealisation.dependencies:\n        if is_incompatible(dependentDrvOutput, expectedStorePath)\n            return None\n        else:\n            substitute_realisation(substituter, wantedOutput)\n\n    # Finally substitute the store path itself\n    substitute_path(substituter, maybeRealisation.outputPath)\n    return maybeRealisation\n```\n\n----------------------------------------\n\nTITLE: Documenting Nix Attribute Set with Identity Function - Nix\nDESCRIPTION: This snippet demonstrates a Nix attribute set where a function ('id') is annotated with a doc-comment using the /** ... */ format in combination with CommonMark content. The comment block provides detailed function documentation, usage examples, and expected outputs, styled in Markdown for readability and compatibility with documentation tools. Dependencies are standard Nix language facilities; no additional packages are necessary. The 'id' function accepts one argument and returns it unmodified ('identity').\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0145-doc-strings.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\n{\n  /**\n  The identity function\n\n  Describes in every detail why \n  this function is important and how to use it.\n\n  # Examples\n\n  ```\n  id \"foo\"\n  ->\n  \"foo\"\n  ```\n\n  */\n  id = x: x; \n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing the Nix RFC Process State Machine - Mermaid - Markdown\nDESCRIPTION: This Mermaid code block renders a flowchart graph describing each stage of the Nix RFC process, including draft, discuss, hold, shepherd assignment, FCP, merge, rejection, and withdrawal. Dependencies include a Markdown renderer (such as GitHub or Obsidian) with Mermaid support, and users are expected to have basic familiarity with Mermaid syntax. The inputs and outputs are the flowchart nodes and transitions, designed to aid understanding of the RFC submission and decision process; it does not represent executable program logic.\nSOURCE: https://github.com/nixos/rfcs/blob/master/README.md#_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph TD\\n    Start((Start)) --> Draft\\n    Draft -->|Ready for Review| Discuss\\n    style Draft fill:#008,color:#FFF\\n\\n    Discuss[Discuss and Refine]\\n    Discuss ---> |On Hold| Draft\\n    Discuss --> |Can't Find Shepherds| NoShepherds\\n    Discuss --> |Motion for FCP| FCP\\n\\n    NoShepherds[Closed - Lack of Interest]:::closed\\n    NoShepherds --> |Renewed Interest| Discuss\\n\\n    FCP[Final Coment Phase]\\n    FCP --> |FCP Canceled| Discuss\\n    FCP --> |Accept| Merged\\n    FCP --> |Reject| Rejected\\n\\n    Merged\\n    style Merged fill:#080,color:#FFF\\n\\n    Rejected[Closed - Rejected]:::closed\\n\\n    Withdrawn[Closed - Withdrawn]:::closed\\n    Discuss & Draft --->|Author Withdraws| Withdrawn\\n\\n    classDef closed fill:#800,color:#FFF\n```\n\n----------------------------------------\n\nTITLE: Substituting Realisations via a Remote Store - Python\nDESCRIPTION: This snippet outlines a function for the substitution loop in Nix, interacting with a remote store. It queries the remote store for a realisation, then substitutes and registers the output path if available. Dependencies include the Store interface, substitute_path function, and data types for derivations and realisations. Inputs are the substituter (store) and the desired output; output is Maybe Realisation. The approach ensures atomic registration of retrieved realisations in the local cache.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0062-content-addressed-paths.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef substitute_realisation(substituter : Store, wantedOutput : DrvOutput) -> Maybe Realisation:\n    maybeRealisation = substituter.queryRealisation(wantedOutput)\n    if maybeRealisation is None:\n        return None\n    substitute_path(substituter, maybeRealisation.outputPath)\n    return maybeRealisation\n```\n\n----------------------------------------\n\nTITLE: Formatting Function Applications and Argument Absorption Rules (Nix)\nDESCRIPTION: This collection of examples explains the function application formatting rules in Nix, covering various situations: single- and multi-line arguments, argument absorption, parenthesized last arguments, and cases that require higher indentation or allow more concise representations. The samples showcase the structural layout with and without line absorption, reflecting the guidelines discussed earlier. All examples assume standard Nix code and have no dependencies; they are illustrative of format, not computational output.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_16\n\nLANGUAGE: nix\nCODE:\n```\n# All arguments fit onto the first line\nfunction arg1 arg2\n\n# The line length limit is reached, so the remaining arguments need to be on their own lines\nfunction arg1 arg2 arg3\n  arg4\n  arg5\n\n# The last argument is a multiline expression, so it doesn't fit on the first line,\n# but it can still start on the first line\nfunction arg1 arg2 {\n  more = \"things\";\n}\n\n# The second argument doesn't fit on the first line, but it's not the last argument,\n# so it needs to start on a new line\nfunction arg1 {\n  more = \"things\";\n} arg3\n\n# In this case, the remaining arguments after the second one woulnd't fit onto the line anymore, therefore start all of them on a new line\nfunction arg1\n  {\n    more = \"things\";\n  }\n  arg3\n  many\n  long\n  args\n\n# Same with multiple multiline arguments\nfunction\n  {\n    a = 1;\n    b = 2;\n  }\n  {\n    c = 1;\n    d = 2;\n  }\n\n# Assume that the line length limit is here   ↓\n# Good\nconcatMapString (s: \"short string: ${s}\") (\n  attrsToList foo\n)\n# Good, this is also allowed\nconcatMapString (s: \"short string: ${s}\")\n  (attrsToList foo)\n\n# Bad: The first argument would have fit onto the first line\nconcatMapString (\n  s: \"short string: ${s}\"\n) (attrsToList foo)\n\n# Good: The body of the last argument starts on a new line with indentation\npkgs.nixosTest (\n  { pkgs }:\n  {\n    config = { };\n  }\n)\n\n# Good: The last argument is parenthesised and contains a function declaration, the exception makes this have less lines\nstdenv.mkDerivation (finalAttrs: {\n  name = \"...\";\n})\n```\n\n----------------------------------------\n\nTITLE: Comment Formatting and Transformation (Nix)\nDESCRIPTION: This snippet covers the allowed conversions and formatting changes for single-line, multiline, and doc comments in Nix code. It demonstrates conversion of C-style block comments and alignment with formatter-driven requirements, including the preservation or stripping of indentation and comment delimiters. There are no dependencies; the snippet is concerned with comment style more than functionality. Inputs are code with diverse comments; outputs are the transformed or preserved versions, with rules as described in the documentation.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_14\n\nLANGUAGE: nix\nCODE:\n```\n/* foo */\n↓\n# foo\n\n/*bar    */\n↓\n# bar\n\nfunction call ( # trailing comment\n  body\n)\n↓\nfunction call (\n  # trailing comment\n  body\n)\n\nif /* inline comment */ cond then\n  true\nelse\n  false\n↓\n# inline comment\nif cond then\n  true\nelse\n  false\n\nif cond /* inline comment */ then\n  true\nthen\n  false\n↓\nif\n  cond # inline comment\nthen\n  true\nelse\n  false\n  \n/* foo */ ''\n  bar\n''\n↓\n# foo\n''\n  bar\n''\n\n/* Foo\n   bar\n   baz */\n↓\n/*\n  Foo\n  bar\n  baz\n*/\n\n/* Foo\n  bar\n  baz\n\n*/\n↓\n/*\n  Foo\n  bar\n  baz\n*/\n\n/* Foo\n * bar\n */\n↓\n/*\n  Foo\n  bar\n*/\n\n# Some comment\n#   Some preserved indentation\n#This also stays as is\n```\n\n----------------------------------------\n\nTITLE: Doc-Comment for Named Function\nDESCRIPTION: Shows documentation for a lambda function bound to a variable, placing the doc-comment before the attribute name.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0145-doc-strings.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n/**Doc for lambda function bound to a variable*/\n           ↓\nassigned = x: x;\n```\n\n----------------------------------------\n\nTITLE: Testing Container Network Connectivity with ping/machinectl - Shell\nDESCRIPTION: This shell snippet illustrates verifying a demo container's network presence and basic connectivity by pinging its hostname (resolved using systemd's mymachines NSS module) and demonstrates usage of machinectl for rebooting and shell access. Dependencies include systemd with mymachines configured and a running 'demo' container. It requires appropriate permissions (root for ping, user or root for machinectl) and outputs standard ping statistics and shell session start/stop results.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0108-nixos-containers.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n[root@server:~]# ping demo -c1\nPING demo(fdd1:98a7:f71:61f0:900e:81ff:fe78:e9d6 (fdd1:98a7:f71:61f0:900e:81ff:fe78:e9d6)) 56 data bytes\n64 bytes from fdd1:98a7:f71:61f0:900e:81ff:fe78:e9d6 (fdd1:98a7:f71:61f0:900e:81ff:fe78:e9d6): icmp_seq=1 ttl=64 time=0.292 ms\n\n--- demo ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.214/0.214/0.214/0.000 ms\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ machinectl reboot demo\n$ machinectl shell demo\ndemo$ ...\n```\n\n----------------------------------------\n\nTITLE: Defining Dynamic User and Group for NixOS Service in Nix\nDESCRIPTION: This code snippet shows how to define a user and group for a NixOS service without specifying static IDs. It sets the user as a system user, allowing NixOS to dynamically allocate IDs below 1000 for the service.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0052-dynamic-ids.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  users = {\n    users.myservice = {\n      description = \"My service user\";\n      group = \"myservice\";\n      isSystemUser = true;\n    };\n    groups.myservice = {};\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Commenting Command Arguments Using Nix String Concatenation and Interpolation (Nix, Bash)\nDESCRIPTION: These examples contrast bash and Nix methods for adding comments between long command arguments, using either string concatenation or interpolation in Nix. They highlight the difference in allowed and discouraged practices, and demonstrate how Nix enables more flexible commenting than traditional shell scripts. The bash snippet has no dependencies beyond shell syntax; the Nix snippets assume standard evaluation and string processing.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nsome-command \\ # Some comment\n  some-arg \\ # Some comment\n  another-arg\n```\n\nLANGUAGE: nix\nCODE:\n```\n''\n  some-command \\\n'' + /* Some comment */ ''\n  some-arg \\\n'' + /* Some comment */ ''\n  another-arg\n''\n```\n\nLANGUAGE: nix\nCODE:\n```\nsome-command \\ ${\"\"/* Some comment */}\n  some-arg \\ ${\"\" /* Some comment */}\n  another-arg\n```\n\n----------------------------------------\n\nTITLE: Doc-Comment for Anonymous Lambda Function\nDESCRIPTION: Shows the placement of a doc-comment before an anonymous lambda function with only whitespace allowed between the comment and the code.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0145-doc-strings.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n/**Doc for anonymous lambda function*/\n↓\nx: x;\n```\n\n----------------------------------------\n\nTITLE: With Statement Formatting and Usage - Nix - Nix Language\nDESCRIPTION: This set of snippets demonstrates recommended and discouraged formats for the Nix `with` statement, especially within attribute bindings. Examples address correct multi-line absorption, sequential `with`, and improper formatting patterns. Inputs are attribute sets or values extended in scope by `with`; outputs are usually new bindings or lists. There are no external dependencies.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_22\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # Good\n  foo = with bar; [\n    # multiline\n    baz\n  ];\n  \n  # Good\n  foo =\n    with foo;\n    with bar;\n    [\n      # multiline\n      baz\n    ];\n  \n  # Good\n  foo =\n    with bar;\n    baz foo {\n      # multiline\n      qux = 10;\n    };\n\n  # Good\n  foo =\n    with bar;\n    if cond then\n      foo\n    else\n      bar;\n  \n  # Bad\n  foo = assert qux; with bar; [\n    # multiline\n    baz\n  ];\n  \n  # Bad\n  foo = with bar;\n    [\n      # multiline\n      baz\n    ];\n\n  # Bad\n  foo =\n    with bar; [\n      # multiline\n      baz\n    ];\n    \n  # Good\n  [\n    qux\n    quux\n  ]\n  ++ (with pkgs; [\n    baz\n    blorp\n  ]);\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Phase Runner Function - Shell Script\nDESCRIPTION: This snippet defines a generic shell function runPhase that takes the phase name as an argument and evaluates it, supporting both function and variable invocation. Useful for more generalized phase execution. The function requires Bash, and uses bash variable indirection for evaluation. The input is the phase function/variable name; it executes the corresponding logic.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0032-run-phase-changes-for-better-nix-shell-use.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nrunPhase() {\n    local phase=\"$1\"\n    eval \"${!phase:-$phase}\"\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Problem Handlers for Specific Packages - Nix\nDESCRIPTION: This snippet configures the 'config.problems.handlers' option in Nixpkgs, allowing users to specify how to handle problems for individual packages and problem names. Handlers can be set to 'error', 'warn', or 'ignore' for granular control over build evaluation and notifications. The configuration is a doubly-nested attribute set keyed by package and problem name, with input as a Nix expression and no external runtime dependencies. It directly affects package evaluation and output behavior depending on problem metadata.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0127-issues-warnings.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nconfig.problems.handlers = {\n  # If \"myPackage\" is used (evaluated) somewhere and has a problem named \"maintainerless\", print a warning\n  myPackage.maintainerless = \"warn\";\n  # This was added because \"otherPackage\" has a problem \"CVE1234\" which prevents evaluation, which needs to be ignored to use it nevertheless (\"warn\" would work too of course)\n  otherPackage.CVE1234 = \"ignore\";\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring DynamicUser for NixOS Service in Nix\nDESCRIPTION: This snippet demonstrates how to enable the DynamicUser feature for a NixOS service using the systemd configuration. It allows the service to use dynamically allocated user IDs without requiring persistent storage.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0052-dynamic-ids.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  systemd.services.myservice.serviceConfig.DynamicUser = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Vertically Aligned Attribute Sets and Arguments (Nix Language)\nDESCRIPTION: Presents before-and-after formatting examples that show how a Nix formatter removes vertical alignment for attribute assignments and applies consistent indentation and line-breaking. Also covers formatting function applications and long argument groups. No external dependencies required. Demonstrates that vertical alignment is not preserved by the formatter.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  # Vertically aligned input like this..\\n  foo  = 10; # Foo\\n  b    = 10; # - b\\n  baz  = 10; #   - baz\\n  more = 10; #   - more\\n\\n  # ..will get formatted like this.\\n  # The vertical alignment is not preserved.\\n  foo = 10; # Foo\\n  b = 10; # - b\\n  baz = 10; #   - baz\\n  more = 10; #   - more\\n\\n\\n  # Vertically aligned input like this..\\n  netbsd   = { execFormat = elf;     families = { inherit bsd; }; };\\n  none     = { execFormat = unknown; families = {              }; };\\n\\n  # ..will get formatted like this.\\n  netbsd = {\\n    execFormat = elf;\\n    families = {\\n      inherit bsd;\\n    };\\n  };\\n  none = {\\n    execFormat = unknown;\\n    families = { };\\n  };\\n\\n\\n  # Vertically aligned input like this..\\n  optExecFormat =\\n    lib.optionalString (kernel.name == \"netbsd\" &&\\n                        gnuNetBSDDefaultExecFormat cpu != kernel.execFormat\\n                       )\\n                       kernel.execFormat.name;\\n\\n  # ..will get formatted like this.\\n  optExecFormat = lib.optionalString (\\n    kernel.name == \"netbsd\" && gnuNetBSDDefaultExecFormat cpu != kernel.execFormat\\n  ) kernel.execFormat.name;\\n}\n```\n\n----------------------------------------\n\nTITLE: Doc-Comment for Function in Attribute Set\nDESCRIPTION: Illustrates documentation for a specialized function within an attribute set.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0145-doc-strings.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n    /**This documents the specialisation `map (x: x)` */\n          ↓\n    foo = map (x: x);          \n}\n```\n\n----------------------------------------\n\nTITLE: Legacy Multiline Function Documentation for Filtering Attribute Sets - Nix\nDESCRIPTION: This legacy Nix code documents and implements a 'filterAttrs' function using a classic /* ... */ multiline comment. The comment describes the function's behavior, provides usage examples, and specifies its type signature, while the function itself filters an attribute set based on a predicate. Dependencies include standard Nix library functions such as 'listToAttrs', 'concatMap', and 'attrNames'. Parameters 'pred' and 'set' must be provided: 'pred' is a predicate (name and value), 'set' is the attribute set to filter. Output is a filtered attribute set.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0145-doc-strings.md#_snippet_11\n\nLANGUAGE: nix\nCODE:\n```\n/* Filter an attribute set by removing all attributes for which the\n   given predicate return false.\n\n   Example:\n     filterAttrs (n: v: n == \"foo\") { foo = 1; bar = 2; }\n     => { foo = 1; }\n\n   Type:\n     filterAttrs :: (String -> Any -> Bool) -> AttrSet -> AttrSet\n*/\nfilterAttrs =\n  # Predicate taking an attribute name and an attribute value, which returns `true` to include the attribute or `false` to exclude the attribute.\n  pred:\n  # The attribute set to filter\n  set:\n  listToAttrs (concatMap (name: let v = set.${name}; in if pred name v then [(nameValuePair name v)] else []) (attrNames set));\n```\n\n----------------------------------------\n\nTITLE: Direct Function Call for Build Phase - Shell Script\nDESCRIPTION: This snippet illustrates the desired, simplified way to invoke the buildPhase in nix-shell after the RFC changes: simply calling the function directly. No arguments or special handling are needed; the function will execute the appropriate build phase logic. This approach relies on implementing the new consistent phase logic, as proposed in the RFC.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0032-run-phase-changes-for-better-nix-shell-use.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nbuildPhase\n```\n\n----------------------------------------\n\nTITLE: Recursively Calling Build Phase in Overridden Phase Script - Nix\nDESCRIPTION: This snippet demonstrates a problematic use case where the buildPhase attribute of a derivation calls itself, potentially leading to infinite recursion under the new phase framework. The pattern is shown as a warning of what can break, highlighting an edge-case in backward compatibility. It is a Nix expression with a shell script for the buildPhase attribute.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0032-run-phase-changes-for-better-nix-shell-use.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation {\n    # ...\n    \n    buildPhase = ''\n        buildPhase\n        (cd foo; buildPhase)\n        (cd bar; buildPhase)\n    '';\n    \n    # ...\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Output Realisations in the Nix Store - Pseudo-Python\nDESCRIPTION: Provides a placeholder for the core function 'registerRealisation', which will record realisation information (such as derivation hash, output names, and paths) in the Nix store's database. The function signature indicates that it will write or update records relating a 'Realisation' to the underlying store, though implementation details are abstracted. The key dependencies are on types 'Store' and 'Realisation'. Required input is the store instance and a realisation object; expected effect is database persistence of the mapping. As a stub, it is meant for further expansion.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0062-content-addressed-paths.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef registerRealisation(store : Store, realisation : Realisation):\n    ...\n\n```\n\n----------------------------------------\n\nTITLE: mkDerivation Phase Pattern Reference\nDESCRIPTION: Shows the standard testing phase patterns in mkDerivation - checkPhase for quick unit tests and installCheckPhase for post-installation verification.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0119-testing-conventions.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nmkDerivation.checkPhase\nmkDerivation.installCheckPhase\n```\n\n----------------------------------------\n\nTITLE: Doc-Comment for Nested Attribute\nDESCRIPTION: Shows how to document a value in a nested attribute path, clarifying that the documentation applies only to the final attribute.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0145-doc-strings.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  /** Doc 1 bound to 'c' */\n      ↓   ↓\n  a.b.c = 1;\n}\n\n# Documents only the expression bound to 'c'. NOT the attribute set bound to 'a' or 'b'.\n```\n\n----------------------------------------\n\nTITLE: Ambiguous Doc-Comment Placement Resolution\nDESCRIPTION: Demonstrates precedence rules for doc-comments when multiple comments could apply to the same node.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0145-doc-strings.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n/**Doc B*/\nint = /**Doc A*/1;\n\n# Documentation is 'Doc A' because it is directly next to the documentable body.\n```\n\n----------------------------------------\n\nTITLE: Using Structured Helper for Improved CLI Flag Formatting in Nix\nDESCRIPTION: This snippet demonstrates a more structured approach to passing CLI flags using a helper function, which results in better formatting and readability.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nlib.cli.toGNUCommandLine { } {\n  some-flag = \"some-value\";\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning Static IP Addresses to NixOS Containers - Nix/NixOS\nDESCRIPTION: This Nix expression assigns static IPv4 and IPv6 addresses to a container by specifying 'containerPool' arrays in the network.v4.static and network.v6.static attributes under nixos.containers.instances. It requires that the NixOS host and container modules support static assignment and integrates with netdev units under systemd. Inputs include the IPv4/IPv6 subnet configurations, and output is a container instance whose interfaces are brought up statically. The config uses empty system-config for demonstration, showing focus on networking. Limitations include adherence to the chosen subnet's validity and conflicts.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0108-nixos-containers.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nixos.containers.instances.static = {\n    network = {\n      v4.static.containerPool = [ \"10.237.1.3/16\" ];\n      v6.static.containerPool = [ \"2a01:4f9:4b:1659:3aa3:cafe::3/96\" ];\n    };\n    system-config = {};\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Container Lifecycle via machinectl - Shell\nDESCRIPTION: This shell snippet includes common administrative commands for systemd-nspawn containers executed with machinectl. Users can reboot the container, open an interactive shell session, and perform actions as root within the container. Dependencies are systemd >= 219, the machinectl command-line tool, and permissions to the container being managed. Outputs include container state change and (optionally) an interactive shell prompt; errors occur if the container is not running or not available. The demonstration uses an 'imperative' container as an example.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0108-nixos-containers.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ machinectl reboot imperative\n$ machinectl shell imperative\n[root@imperative:~]$ …\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Good and Bad Indentation Practices (Nix Language)\nDESCRIPTION: Shows various examples of acceptable and unacceptable indentation changes between lines in Nix attribute assignments, function application, and 'let...in' expressions. Emphasizes that increases in indentation between consecutive lines should not exceed one level, while decreases can be larger. Code includes both 'bad' and 'okay' indentation patterns for buildInputs, attributes, arguments, and nested sets. No dependencies required.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\n# Bad indentation\\nbuildInputs = [\\n    foo # <-- Not okay, increase by 2 levels\\n  ] ++ lib.optionals cond [\\n    bar\\n  ];\\n\\n# Okay indentation, subsequent lines at most one more level\\nbuildInputs =\\n  [\\n    foo \\n  ] ++ lib.optionals cond [\\n    bar\\n  ];\\n\\n# Bad indentation\\nattribute = { args }: let\\n    foo = \"bar\"; # <-- Not okay, increase by 2 levels\\n  in\\n    foo;\\n\\n# Okay indentation\\nattribute = { args }:\\n  let\\n    foo = \"bar\";\\n  in\\n    foo;\\n\\n# Bad indentation\\n(callFunction {\\n    foo = \"bar\"; # <-- Not okay, increase by 2 levels\\n  }\\n  arg\\n)\\n# Okay indentation\\n(callFunction\\n  {\\n    foo = \"bar\";\\n  }\\n  arg\\n)\\n\\n# Okay indentation\\nlet\\n  x = {\\n    a = foo\\n      bar\\n      baz;\\n  }; # <-- The decrease by two levels here is okay, only increases are limited to one level\\nin\\nnull\n```\n\n----------------------------------------\n\nTITLE: Refactoring Build Phase Logic for Consistency - Shell/Diff\nDESCRIPTION: This diff shows the changes required to refactor the buildPhase implementation: the default phase logic is moved into defaultBuildPhase; buildPhase now runs pre and post hooks, and conditionally invokes the custom or default implementation. This pattern ensures hooks always run and phase logic is consistent. Dependencies: Bash shell. Inputs: function and variable definitions. Output: consistent phase execution with support for hooks in overridden phases.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0032-run-phase-changes-for-better-nix-shell-use.md#_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\n-buildPhase() {\n+defaultBuildPhase() {\n-    runHook preBuild\n-\n    # set to empty if unset\n    : ${makeFlags=}\n \n@@ -1008,14 +1104,14 @@ buildPhase() {\n        make ${makefile:+-f $makefile} \"${flagsArray[@]}\"\n        unset flagsArray\n    fi\n-\n-    runHook postBuild\n }\n+\n+buildPhase() {\n+    runHook preBuild\n+\n+    if [ -n \"$buildPhase\" ]; then\n+        eval \"$buildPhase\"\n+    else\n+        defaultBuildPhase\n+    fi\n+\n+    runHook postBuild\n+}\n\n```\n\n----------------------------------------\n\nTITLE: Building Input-Addressed Derivations - Pseudo-Python\nDESCRIPTION: This snippet models the input-addressed build process using pseudo-Python, reflecting how Nix evaluates and builds derivations recursively. The code establishes the relationship between evaluating an expression and recursively building all required derivations and their outputs using 'eval', 'build_derivation', and 'runBuildScript'. No external dependencies are required as it is an algorithmic illustration, and primary parameters are the Nix expression (expr) and derivation objects. Outputs represent paths of built store outputs. This code may omit real-world error handling or Nix-specific edge cases due to its illustrative intent.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0062-content-addressed-paths.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef nix_build(expr : NixExpr) -> [StorePath] :\n    resulting_derivation = eval(expr)\n    build_derivation(\n        resulting_derivation,\n        resulting_derivation.all_outputs(),\n    )\n    return resulting_derivation.all_output_paths()\n\ndef build_derivation(derivation : Derivation, outputsToBuild: [str]) -> ():\n    # Build all the inputs\n    for (inputDrv, requiredOutputs) in derivation.inputDrvs:\n        build_derivation(inputDrv, requiredOutputs)\n    # Run the build script, now that all the inputs are here\n    runBuildScript(derivation)\n\n```\n\n----------------------------------------\n\nTITLE: Using let-in Constructs in Nix\nDESCRIPTION: These snippets demonstrate proper usage of multiline let-in bindings in Nix, ensuring that each binding starts on a new line and that the body of the let expression is not indented and always starts on a new line after 'in'. They showcase simple variable assignment, attribute set construction, and conditional expressions within the let-in structure. No external dependencies are required; inputs include variable names and values, and outputs depend on the body expression.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_23\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  foo = \"bar\";\nin\nfunc foo;\n```\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  foo = \"bar\";\nin\n{\n  inherit foo;\n  baz = \"smth\";\n}\n```\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  foo = \"bar\";\nin\nif foo == \"bar\" then\n  \"hello\"\nelse\n  \"world\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Sub-Optimal CLI Flag Formatting in Nix\nDESCRIPTION: This snippet shows how CLI flags passed as a list can result in sub-optimal formatting when auto-formatted. The formatter splits the flag and its value onto separate lines.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n[\n  \"--some-flag\"\n  \"some-value\"\n]\n```\n\n----------------------------------------\n\nTITLE: Modeling Derivation Outputs and Realisation Structures - Pseudo-Python\nDESCRIPTION: Defines supporting data classes 'DrvOutput' and 'Realisation' needed for content-addressed storage modeling in Nix. 'DrvOutput' uniquely identifies an output with a derivation hash and output name, while 'Realisation' maps this ID to a concrete store path. No external libraries or requirements are referenced—these structures underpin the RFC's resolution logic. Parameters include derivation hashes (Hash), output names (str), and store paths (StorePath), and these abstractions do not directly produce output but provide necessary structure for subsequent algorithms.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0062-content-addressed-paths.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass DrvOutput:\n    derivationHash : Hash\n    outputName : str\n\nclass Realisation:\n    id : DrvOutput\n    outputPath : StorePath\n\n```\n\n----------------------------------------\n\nTITLE: Initial EditorConfig for Nix Files (EditorConfig Language)\nDESCRIPTION: Specifies the recommended editor settings for handling Nix files, such as Unix line endings, UTF-8 encoding, final newlines, trimming trailing whitespace, and space-based indentation. Useful for enforcing consistency across editors regarding file formatting and structure. This snippet requires editors supporting EditorConfig and does not affect code execution.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_5\n\nLANGUAGE: editorconfig\nCODE:\n```\nend_of_line = lf\\ninsert_final_newline = true\\ntrim_trailing_whitespace = true\\ncharset = utf-8\\nindent_style = space\n```\n\n----------------------------------------\n\nTITLE: Creating Singleton Lists in Nix (Nix Language)\nDESCRIPTION: Demonstrates how to create a list with a single attribute set as an element using a direct array. This approach explicitly declares the list using bracket syntax. The 'foo' and 'bar' attributes are set as integers inside the set. This achieves a singleton list without using the Nix standard library.\nSOURCE: https://github.com/nixos/rfcs/blob/master/rfcs/0166-nix-formatting.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  list = [\\n    {\\n      foo = 10;\\n      bar = 20;\\n    }\\n  ];\\n}\n```"
  }
]