[
  {
    "owner": "learnopengl-cn",
    "repo": "learnopengl-cn",
    "content": "TITLE: Basic GLSL Shader Structure\nDESCRIPTION: Demonstrates the typical structure of a GLSL shader, including version declaration, input/output variables, uniforms, and the main function.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/old/01/05 Shaders.md#2025-04-22_snippet_0\n\nLANGUAGE: GLSL\nCODE:\n```\n#version version_number\n\nin type in_variable_name;\nin type in_variable_name;\n\nout type out_variable_name;\n\nuniform type uniform_name;\n\nint main()\n{\n  // Process input(s) and do some weird graphics stuff\n  ...\n  // Output processed stuff to output variable\n  out_variable_name = weird_stuff_we_processed;\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Custom Shader Class in OpenGL Applications\nDESCRIPTION: Demonstrates how to use the custom Shader class in an OpenGL application, including creation, activation, and setting uniform values.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/05 Shaders.md#2025-04-22_snippet_16\n\nLANGUAGE: C++\nCODE:\n```\nShader ourShader(\"path/to/shaders/shader.vs\", \"path/to/shaders/shader.fs\");\n...\nwhile(...)\n{\n    ourShader.use();\n    ourShader.setFloat(\"someUniform\", 1.0f);\n    DrawStuff();\n}\n```\n\n----------------------------------------\n\nTITLE: Vertex Shader with Transformation Matrix in GLSL\nDESCRIPTION: Modifies a vertex shader to accept a transformation matrix as a uniform and apply it to the vertex position.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/07 Transformations.md#2025-04-22_snippet_8\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (location = 0) in vec3 aPos;\nlayout (location = 1) in vec2 aTexCoord;\n\nout vec2 TexCoord;\n\nuniform mat4 transform;\n\nvoid main()\n{\n    gl_Position = transform * vec4(aPos, 1.0f);\n    TexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);\n}\n```\n\n----------------------------------------\n\nTITLE: Color Reflection Calculation in C++\nDESCRIPTION: Demonstrates how to calculate the reflected color of an object by multiplying the light color with the object color.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/01 Colors.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nglm::vec3 lightColor(1.0f, 1.0f, 1.0f);\nglm::vec3 toyColor(1.0f, 0.5f, 0.31f);\nglm::vec3 result = lightColor * toyColor; // = (1.0f, 0.5f, 0.31f);\n```\n\n----------------------------------------\n\nTITLE: Passing Transformation Matrix to Shader in C++\nDESCRIPTION: Demonstrates how to pass a GLM transformation matrix to a shader program using OpenGL functions.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/07 Transformations.md#2025-04-22_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nunsigned int transformLoc = glGetUniformLocation(ourShader.ID, \"transform\");\nglUniformMatrix4fv(transformLoc, 1, GL_FALSE, glm::value_ptr(trans));\n```\n\n----------------------------------------\n\nTITLE: Basic PBR Light Radiance Calculation in GLSL\nDESCRIPTION: This code snippet shows how to calculate the radiance value for a direct light source in a physically-based rendering system. It computes the normalized direction, attenuation based on distance, and scales the light color to produce the radiance value for the light source.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/02 Lighting.md#2025-04-22_snippet_0\n\nLANGUAGE: GLSL\nCODE:\n```\nvec3  lightColor  = vec3(23.47, 21.31, 20.79);\nvec3  wi          = normalize(lightPos - fragPos);\nfloat cosTheta    = max(dot(N, Wi), 0.0);\nfloat attenuation = calculateAttenuation(fragPos, lightPos);\nfloat radiance    = lightColor * attenuation * cosTheta;\n```\n\n----------------------------------------\n\nTITLE: Complete PBR Direct Lighting Fragment Shader in GLSL\nDESCRIPTION: This complete fragment shader implements physically-based rendering with direct lighting. It calculates the Cook-Torrance BRDF for multiple light sources, combines diffuse and specular components, applies tone mapping and gamma correction for the final color output.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/02 Lighting.md#2025-04-22_snippet_14\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\nin vec2 TexCoords;\nin vec3 WorldPos;\nin vec3 Normal;\n\n// material parameters\nuniform vec3  albedo;\nuniform float metallic;\nuniform float roughness;\nuniform float ao;\n\n// lights\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\n\nuniform vec3 camPos;\n\nconst float PI = 3.14159265359;\n  \nfloat DistributionGGX(vec3 N, vec3 H, float roughness);\nfloat GeometrySchlickGGX(float NdotV, float roughness);\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness);\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness);\n\nvoid main()\n{\t\t\n    vec3 N = normalize(Normal);\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, albedo, metallic);\n\t           \n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for(int i = 0; i < 4; ++i) \n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - WorldPos);\n        vec3 H = normalize(V + L);\n        float distance    = length(lightPositions[i] - WorldPos);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance     = lightColors[i] * attenuation;        \n        \n        // cook-torrance brdf\n        float NDF = DistributionGGX(N, H, roughness);        \n        float G   = GeometrySmith(N, V, L, roughness);      \n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n        \n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        kD *= 1.0 - metallic;\t  \n        \n        vec3 nominator    = NDF * G * F;\n        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n        vec3 specular     = nominator / denominator;\n            \n        // add to outgoing radiance Lo\n        float NdotL = max(dot(N, L), 0.0);                \n        Lo += (kD * albedo / PI + specular) * radiance * NdotL; \n    }   \n  \n    vec3 ambient = vec3(0.03) * albedo * ao;\n    vec3 color = ambient + Lo;\n\t\n    color = color / (color + vec3(1.0));\n    color = pow(color, vec3(1.0/2.2));  \n   \n    FragColor = vec4(color, 1.0);\n}  \n```\n\n----------------------------------------\n\nTITLE: Fresnel-Schlick Approximation Implementation in GLSL\nDESCRIPTION: This function implements the Fresnel-Schlick approximation which calculates the reflection ratio at different angles. It takes the cosine of the angle between vectors and the base reflectivity at 0° incidence (F0) as inputs.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/02 Lighting.md#2025-04-22_snippet_4\n\nLANGUAGE: GLSL\nCODE:\n```\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}  \n```\n\n----------------------------------------\n\nTITLE: Implementing Debug Output Callback for OpenGL in C++\nDESCRIPTION: Implements a callback function for OpenGL debug output. This function is called when OpenGL generates debug messages, allowing for custom error handling and logging.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/01 Debugging.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvoid APIENTRY glDebugOutput(GLenum source, \n                            GLenum type, \n                            unsigned int id, \n                            GLenum severity, \n                            GLsizei length, \n                            const char *message, \n                            void *userParam)\n{\n    // 忽略一些不重要的错误/警告代码\n    if(id == 131169 || id == 131185 || id == 131218 || id == 131204) return; \n\n    std::cout << \"---------------\" << std::endl;\n    std::cout << \"Debug message (\" << id << \"): \" <<  message << std::endl;\n\n    switch (source)\n    {\n        case GL_DEBUG_SOURCE_API:             std::cout << \"Source: API\"; break;\n        case GL_DEBUG_SOURCE_WINDOW_SYSTEM:   std::cout << \"Source: Window System\"; break;\n        case GL_DEBUG_SOURCE_SHADER_COMPILER: std::cout << \"Source: Shader Compiler\"; break;\n        case GL_DEBUG_SOURCE_THIRD_PARTY:     std::cout << \"Source: Third Party\"; break;\n        case GL_DEBUG_SOURCE_APPLICATION:     std::cout << \"Source: Application\"; break;\n        case GL_DEBUG_SOURCE_OTHER:           std::cout << \"Source: Other\"; break;\n    } std::cout << std::endl;\n\n    switch (type)\n    {\n        case GL_DEBUG_TYPE_ERROR:               std::cout << \"Type: Error\"; break;\n        case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: std::cout << \"Type: Deprecated Behaviour\"; break;\n        case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR:  std::cout << \"Type: Undefined Behaviour\"; break; \n        case GL_DEBUG_TYPE_PORTABILITY:         std::cout << \"Type: Portability\"; break;\n        case GL_DEBUG_TYPE_PERFORMANCE:         std::cout << \"Type: Performance\"; break;\n        case GL_DEBUG_TYPE_MARKER:              std::cout << \"Type: Marker\"; break;\n        case GL_DEBUG_TYPE_PUSH_GROUP:          std::cout << \"Type: Push Group\"; break;\n        case GL_DEBUG_TYPE_POP_GROUP:           std::cout << \"Type: Pop Group\"; break;\n        case GL_DEBUG_TYPE_OTHER:               std::cout << \"Type: Other\"; break;\n    } std::cout << std::endl;\n    \n    switch (severity)\n    {\n        case GL_DEBUG_SEVERITY_HIGH:         std::cout << \"Severity: high\"; break;\n        case GL_DEBUG_SEVERITY_MEDIUM:       std::cout << \"Severity: medium\"; break;\n        case GL_DEBUG_SEVERITY_LOW:          std::cout << \"Severity: low\"; break;\n        case GL_DEBUG_SEVERITY_NOTIFICATION: std::cout << \"Severity: notification\"; break;\n    } std::cout << std::endl;\n    std::cout << std::endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Computing World Space Position in Vertex Shader\nDESCRIPTION: Vertex shader code that calculates the fragment position in world space by multiplying the vertex position with the model matrix. This world position is needed for lighting calculations in the fragment shader.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/02 Basic Lighting.md#2025-04-22_snippet_2\n\nLANGUAGE: glsl\nCODE:\n```\nout vec3 FragPos;  \nout vec3 Normal;\n  \nvoid main()\n{\n    gl_Position = projection * view * model * vec4(aPos, 1.0);\n    FragPos = vec3(model * vec4(aPos, 1.0));\n    Normal = aNormal;\n}\n```\n\n----------------------------------------\n\nTITLE: Updating View Matrix in Uniform Buffer Object in C++\nDESCRIPTION: Demonstrates how to update the view matrix in a Uniform Buffer Object during each rendering iteration using glBufferSubData function in C++.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/08 Advanced GLSL.md#2025-04-22_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nglm::mat4 view = camera.GetViewMatrix();\t       \nglBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);\nglBufferSubData(GL_UNIFORM_BUFFER, sizeof(glm::mat4), sizeof(glm::mat4), glm::value_ptr(view));\nglBindBuffer(GL_UNIFORM_BUFFER, 0);\n```\n\n----------------------------------------\n\nTITLE: Basic GLSL Shader Structure\nDESCRIPTION: Demonstrates the typical structure of a GLSL shader, including version declaration, input/output variables, uniforms, and the main function.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/05 Shaders.md#2025-04-22_snippet_0\n\nLANGUAGE: GLSL\nCODE:\n```\n#version version_number\nin type in_variable_name;\nin type in_variable_name;\n\nout type out_variable_name;\n\nuniform type uniform_name;\n\nvoid main()\n{\n  // 处理输入并进行一些图形操作\n  ...\n  // 输出处理过的结果到输出变量\n  out_variable_name = weird_stuff_we_processed;\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Specular Lighting in GLSL\nDESCRIPTION: Fragment shader code that computes specular highlights by determining the reflection of light off the surface relative to the viewer's position. This creates bright spots on shiny objects where light reflects directly toward the camera.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/02 Basic Lighting.md#2025-04-22_snippet_5\n\nLANGUAGE: glsl\nCODE:\n```\nfloat specularStrength = 0.5;\nvec3 viewDir = normalize(viewPos - FragPos);\nvec3 reflectDir = reflect(-lightDir, norm);\n\nfloat spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);\nvec3 specular = specularStrength * spec * lightColor;\n```\n\n----------------------------------------\n\nTITLE: Helper Function for Checking OpenGL Errors with glGetError() in C++\nDESCRIPTION: Implements a helper function to check for OpenGL errors using glGetError(). Prints more descriptive error messages and includes file and line information.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/01 Debugging.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nGLenum glCheckError_(const char *file, int line)\n{\n    GLenum errorCode;\n    while ((errorCode = glGetError()) != GL_NO_ERROR)\n    {\n        std::string error;\n        switch (errorCode)\n        {\n            case GL_INVALID_ENUM:                  error = \"INVALID_ENUM\"; break;\n            case GL_INVALID_VALUE:                 error = \"INVALID_VALUE\"; break;\n            case GL_INVALID_OPERATION:             error = \"INVALID_OPERATION\"; break;\n            case GL_STACK_OVERFLOW:                error = \"STACK_OVERFLOW\"; break;\n            case GL_STACK_UNDERFLOW:               error = \"STACK_UNDERFLOW\"; break;\n            case GL_OUT_OF_MEMORY:                 error = \"OUT_OF_MEMORY\"; break;\n            case GL_INVALID_FRAMEBUFFER_OPERATION: error = \"INVALID_FRAMEBUFFER_OPERATION\"; break;\n        }\n        std::cout << error << \" | \" << file << \" (\" << line << \")\" << std::endl;\n    }\n    return errorCode;\n}\n#define glCheckError() glCheckError_(__FILE__, __LINE__) \n```\n\n----------------------------------------\n\nTITLE: Creating LookAt View Matrix\nDESCRIPTION: Creates a view matrix using GLM's lookAt function with camera position, target, and up vector.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/09 Camera.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nglm::mat4 view;\nview = glm::lookAt(glm::vec3(0.0f, 0.0f, 3.0f),\n                      glm::vec3(0.0f, 0.0f, 0.0f),\n                      glm::vec3(0.0f, 1.0f, 0.0f));\n```\n\n----------------------------------------\n\nTITLE: Geometry Shader Compilation in C++\nDESCRIPTION: C++ code snippet demonstrating how to compile and link a geometry shader in OpenGL.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/09 Geometry Shader.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\ngeometryShader = glCreateShader(GL_GEOMETRY_SHADER);\nglShaderSource(geometryShader, 1, &gShaderCode, NULL);\nglCompileShader(geometryShader);  \n...\nglAttachShader(program, geometryShader);\nglLinkProgram(program);\n```\n\n----------------------------------------\n\nTITLE: Computing Specular Component with Blinn-Phong Model in GLSL\nDESCRIPTION: Calculates the specular lighting component using the Blinn-Phong model by measuring the angle between the surface normal and the halfway vector, then applying the shininess factor.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/01 Advanced Lighting.md#2025-04-22_snippet_1\n\nLANGUAGE: GLSL\nCODE:\n```\nfloat spec = pow(max(dot(normal, halfwayDir), 0.0), shininess);\nvec3 specular = lightColor * spec;\n```\n\n----------------------------------------\n\nTITLE: Using glGetError() to Check for OpenGL Errors in C++\nDESCRIPTION: Demonstrates how to use glGetError() to check for OpenGL errors after various operations. Shows example error codes that may be returned.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/01 Debugging.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nglBindTexture(GL_TEXTURE_2D, tex);\nstd::cout << glGetError() << std::endl; // 返回 0 (无错误)\n\nglTexImage2D(GL_TEXTURE_3D, 0, GL_RGB, 512, 512, 0, GL_RGB, GL_UNSIGNED_BYTE, data);\nstd::cout << glGetError() << std::endl; // 返回 1280 (非法枚举)\n\nglGenTextures(-5, textures);\nstd::cout << glGetError() << std::endl; // 返回 1281 (非法值)\n\nstd::cout << glGetError() << std::endl; // 返回 0 (无错误)\n```\n\n----------------------------------------\n\nTITLE: Processing a Mesh from Assimp Data in C++\nDESCRIPTION: Implementation of the processMesh method that converts an Assimp mesh into the application's own Mesh object, gathering vertex data, indices, and material information.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/03 Model Loading/03 Model.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nMesh processMesh(aiMesh *mesh, const aiScene *scene)\n{\n    vector<Vertex> vertices;\n    vector<unsigned int> indices;\n    vector<Texture> textures;\n\n    for(unsigned int i = 0; i < mesh->mNumVertices; i++)\n    {\n        Vertex vertex;\n        // 处理顶点位置、法线和纹理坐标\n        ...\n        vertices.push_back(vertex);\n    }\n    // 处理索引\n    ...\n    // 处理材质\n    if(mesh->mMaterialIndex >= 0)\n    {\n        ...\n    }\n\n    return Mesh(vertices, indices, textures);\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Cubemap Loading Function\nDESCRIPTION: This function loads six images into a cubemap texture and sets appropriate texture parameters. It handles file loading, texture creation, and error checking for each cubemap face.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/06 Cubemaps.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nunsigned int loadCubemap(vector<std::string> faces)\n{\n    unsigned int textureID;\n    glGenTextures(1, &textureID);\n    glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);\n\n    int width, height, nrChannels;\n    for (unsigned int i = 0; i < faces.size(); i++)\n    {\n        unsigned char *data = stbi_load(faces[i].c_str(), &width, &height, &nrChannels, 0);\n        if (data)\n        {\n            glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, \n                         0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data\n            );\n            stbi_image_free(data);\n        }\n        else\n        {\n            std::cout << \"Cubemap texture failed to load at path: \" << faces[i] << std::endl;\n            stbi_image_free(data);\n        }\n    }\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);\n\n    return textureID;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Directional Light in GLSL Fragment Shader\nDESCRIPTION: This code snippet shows the structure for implementing directional light in GLSL, where light comes from a single direction rather than a specific position. Light direction is used directly instead of calculating from position.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/05 Light casters.md#2025-04-22_snippet_0\n\nLANGUAGE: GLSL\nCODE:\n```\nstruct Light {\n    // vec3 position; // 使用定向光就不再需要了\n    vec3 direction;\n  \n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\n...\nvoid main()\n{\n  vec3 lightDir = normalize(-light.direction);\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Explosion Effect Geometry Shader (GLSL)\nDESCRIPTION: This geometry shader implements the full explosion effect for a 3D model, displacing each vertex of input triangles along their normals.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/09 Geometry Shader.md#2025-04-22_snippet_9\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (triangles) in;\nlayout (triangle_strip, max_vertices = 3) out;\n\nin VS_OUT {\n    vec2 texCoords;\n} gs_in[];\n\nout vec2 TexCoords; \n\nuniform float time;\n\nvec4 explode(vec4 position, vec3 normal) { ... }\n\nvec3 GetNormal() { ... }\n\nvoid main() {    \n    vec3 normal = GetNormal();\n\n    gl_Position = explode(gl_in[0].gl_Position, normal);\n    TexCoords = gs_in[0].texCoords;\n    EmitVertex();\n    gl_Position = explode(gl_in[1].gl_Position, normal);\n    TexCoords = gs_in[1].texCoords;\n    EmitVertex();\n    gl_Position = explode(gl_in[2].gl_Position, normal);\n    TexCoords = gs_in[2].texCoords;\n    EmitVertex();\n    EndPrimitive();\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Light Sources in GLSL Main Function\nDESCRIPTION: Main fragment shader function that combines contributions from directional lights and multiple point lights. It calculates surface properties once and then passes them to specialized lighting functions for each light type.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/06 Multiple lights.md#2025-04-22_snippet_5\n\nLANGUAGE: GLSL\nCODE:\n```\nvoid main()\n{\n    // 属性\n    vec3 norm = normalize(Normal);\n    vec3 viewDir = normalize(viewPos - FragPos);\n\n    // 第一阶段：定向光照\n    vec3 result = CalcDirLight(dirLight, norm, viewDir);\n    // 第二阶段：点光源\n    for(int i = 0; i < NR_POINT_LIGHTS; i++)\n        result += CalcPointLight(pointLights[i], norm, FragPos, viewDir);    \n    // 第三阶段：聚光\n    //result += CalcSpotLight(spotLight, norm, FragPos, viewDir);    \n    \n    FragColor = vec4(result, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Sampling PBR Textures in GLSL Fragment Shader\nDESCRIPTION: This GLSL code snippet shows how to sample various PBR textures (albedo, normal, metallic, roughness, and ambient occlusion) in a fragment shader. It demonstrates the proper way to retrieve and process each texture type, including gamma correction for albedo.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/02 Lighting.md#2025-04-22_snippet_15\n\nLANGUAGE: GLSL\nCODE:\n```\n[...]\nuniform sampler2D albedoMap;\nuniform sampler2D normalMap;\nuniform sampler2D metallicMap;\nuniform sampler2D roughnessMap;\nuniform sampler2D aoMap;\n  \nvoid main()\n{\n    vec3 albedo     = pow(texture(albedoMap, TexCoords).rgb, 2.2);\n    vec3 normal     = getNormalFromNormalMap();\n    float metallic  = texture(metallicMap, TexCoords).r;\n    float roughness = texture(roughnessMap, TexCoords).r;\n    float ao        = texture(aoMap, TexCoords).r;\n    [...]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple Light Sources in GLSL Fragment Shader\nDESCRIPTION: Basic structure for calculating the effects of multiple light sources in a fragment shader. It demonstrates how to accumulate contributions from directional lights, point lights, and spotlights into a final output color.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/06 Multiple lights.md#2025-04-22_snippet_0\n\nLANGUAGE: GLSL\nCODE:\n```\nout vec4 FragColor;\n  \nvoid main()\n{\n  // 定义一个输出颜色值\n  vec3 output;\n  // 将定向光的贡献加到输出中\n  output += someFunctionToCalculateDirectionalLight();\n  // 对所有的点光源也做相同的事情\n  for(int i = 0; i < nr_of_point_lights; i++)\n  \toutput += someFunctionToCalculatePointLight();\n  // 也加上其它的光源（比如聚光）\n  output += someFunctionToCalculateSpotLight();\n  \n  FragColor = vec4(output, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting Custom Debug Messages in OpenGL using C++\nDESCRIPTION: Shows how to insert custom debug messages into the OpenGL debug output system using glDebugMessageInsert().\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/01 Debugging.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nglDebugMessageInsert(GL_DEBUG_SOURCE_APPLICATION, GL_DEBUG_TYPE_ERROR, 0,                       \n                     GL_DEBUG_SEVERITY_MEDIUM, -1, \"error message here\"); \n```\n\n----------------------------------------\n\nTITLE: Defining Point Light Structure in GLSL\nDESCRIPTION: Declaration of a point light structure in GLSL with properties for position, attenuation factors (constant, linear, quadratic), and light components (ambient, diffuse, specular). Also includes defining an array of point lights.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/06 Multiple lights.md#2025-04-22_snippet_3\n\nLANGUAGE: GLSL\nCODE:\n```\nstruct PointLight {\n    vec3 position;\n    \n    float constant;\n    float linear;\n    float quadratic;\n\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};  \n#define NR_POINT_LIGHTS 4\nuniform PointLight pointLights[NR_POINT_LIGHTS];\n```\n\n----------------------------------------\n\nTITLE: Geometry Shader for Cubemap-based Shadow Mapping\nDESCRIPTION: A geometry shader that transforms vertices to all six cubemap face perspectives in one pass. It uses gl_Layer to specify which cubemap face each primitive is rendered to, allowing efficient generation of the entire depth cubemap.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/02 Point Shadows.md#2025-04-22_snippet_9\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (triangles) in;\nlayout (triangle_strip, max_vertices=18) out;\n \nuniform mat4 shadowMatrices[6];\n \nout vec4 FragPos; // FragPos from GS (output per emitvertex)\n \nvoid main()\n{\n    for(int face = 0; face < 6; ++face)\n    {\n        gl_Layer = face; // built-in variable that specifies to which face we render.\n        for(int i = 0; i < 3; ++i) // for each triangle's vertices\n        {\n            FragPos = gl_in[i].gl_Position;\n            gl_Position = shadowMatrices[face] * FragPos;\n            EmitVertex();\n        }    \n        EndPrimitive();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Computing Cook-Torrance BRDF Components in GLSL\nDESCRIPTION: This code calculates the Cook-Torrance BRDF components for PBR. It computes the Normal Distribution Function (NDF) and Geometry term (G), which are then combined with the Fresnel term (F) to produce the specular reflection component.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/02 Lighting.md#2025-04-22_snippet_8\n\nLANGUAGE: GLSL\nCODE:\n```\nfloat NDF = DistributionGGX(N, H, roughness);       \nfloat G   = GeometrySmith(N, V, L, roughness);       \n```\n\n----------------------------------------\n\nTITLE: Creating and Binding a Cubemap Texture in OpenGL\nDESCRIPTION: This code snippet demonstrates how to generate, bind, and set up a cubemap texture in OpenGL. It shows the process of creating a texture object and binding it to the GL_TEXTURE_CUBE_MAP target.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/06 Cubemaps.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nunsigned int textureID;\nglGenTextures(1, &textureID);\nglBindTexture(GL_TEXTURE_CUBE_MAP, textureID);\n```\n\n----------------------------------------\n\nTITLE: Cook-Torrance BRDF Calculation in GLSL\nDESCRIPTION: This code calculates the complete Cook-Torrance BRDF equation for specular reflection in a PBR shader. It combines the NDF, Geometry, and Fresnel terms and divides by the denominator term, adding a small constant to prevent division by zero.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/02 Lighting.md#2025-04-22_snippet_9\n\nLANGUAGE: GLSL\nCODE:\n```\nvec3 nominator    = NDF * G * F;\nfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \nvec3 specular     = nominator / denominator;  \n```\n\n----------------------------------------\n\nTITLE: Fragment Shader with Blinn-Phong Lighting and Shadow Mapping\nDESCRIPTION: Fragment shader that implements Blinn-Phong lighting model with shadow mapping. It calculates diffuse, specular and ambient lighting components and applies shadows from the shadow map.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/01 Shadow Mapping.md#2025-04-22_snippet_1\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\n \nin VS_OUT {\n    vec3 FragPos;\n    vec3 Normal;\n    vec2 TexCoords;\n    vec4 FragPosLightSpace;\n} fs_in;\n \nuniform sampler2D diffuseTexture;\nuniform sampler2D shadowMap;\n \nuniform vec3 lightPos;\nuniform vec3 viewPos;\n \nfloat ShadowCalculation(vec4 fragPosLightSpace)\n{\n    [...]\n}\n \nvoid main()\n{           \n    vec3 color = texture(diffuseTexture, fs_in.TexCoords).rgb;\n    vec3 normal = normalize(fs_in.Normal);\n    vec3 lightColor = vec3(1.0);\n    // Ambient\n    vec3 ambient = 0.15 * color;\n    // Diffuse\n    vec3 lightDir = normalize(lightPos - fs_in.FragPos);\n    float diff = max(dot(lightDir, normal), 0.0);\n    vec3 diffuse = diff * lightColor;\n    // Specular\n    vec3 viewDir = normalize(viewPos - fs_in.FragPos);\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = 0.0;\n    vec3 halfwayDir = normalize(lightDir + viewDir);  \n    spec = pow(max(dot(normal, halfwayDir), 0.0), 64.0);\n    vec3 specular = spec * lightColor;    \n    // 计算阴影\n    float shadow = ShadowCalculation(fs_in.FragPosLightSpace);       \n    vec3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * color;    \n    \n    FragColor = vec4(lighting, 1.0f);\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling and Linking OpenGL Shaders in C++\nDESCRIPTION: Demonstrates the process of compiling vertex and fragment shaders, linking them into a shader program, and performing error checking in OpenGL using C++.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/05 Shaders.md#2025-04-22_snippet_14\n\nLANGUAGE: C++\nCODE:\n```\n// 2. 编译着色器\nunsigned int vertex, fragment;\nint success;\nchar infoLog[512];\n   \n// 顶点着色器\nvertex = glCreateShader(GL_VERTEX_SHADER);\nglShaderSource(vertex, 1, &vShaderCode, NULL);\nglCompileShader(vertex);\n// 打印编译错误（如果有的话）\nglGetShaderiv(vertex, GL_COMPILE_STATUS, &success);\nif(!success)\n{\n    glGetShaderInfoLog(vertex, 512, NULL, infoLog);\n    std::cout << \"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\" << infoLog << std::endl;\n};\n  \n// 片段着色器也类似\n[...]\n  \n// 着色器程序\nID = glCreateProgram();\nglAttachShader(ID, vertex);\nglAttachShader(ID, fragment);\nglLinkProgram(ID);\n// 打印连接错误（如果有的话）\nglGetProgramiv(ID, GL_LINK_STATUS, &success);\nif(!success)\n{\n    glGetProgramInfoLog(ID, 512, NULL, infoLog);\n    std::cout << \"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\" << infoLog << std::endl;\n}\n  \n// 删除着色器，它们已经链接到我们的程序中了，已经不再需要了\nglDeleteShader(vertex);\nglDeleteShader(fragment);\n```\n\n----------------------------------------\n\nTITLE: Setting up a Flashlight (Camera-based Spotlight) in OpenGL\nDESCRIPTION: Code that configures a spotlight to behave like a flashlight attached to the camera. The light's position and direction follow the camera, with a cutoff angle determining the spotlight's cone width.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/05 Light casters.md#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nlightingShader.setVec3(\"light.position\",  camera.Position);\nlightingShader.setVec3(\"light.direction\", camera.Front);\nlightingShader.setFloat(\"light.cutOff\",   glm::cos(glm::radians(12.5f)));\n```\n\n----------------------------------------\n\nTITLE: Implementing Model Class Structure in C++\nDESCRIPTION: Definition of the Model class with its members and method declarations. This class will be responsible for loading and managing 3D models using Assimp.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/03 Model Loading/03 Model.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nclass Model \n{\n    public:\n        /*  函数   */\n        Model(char *path)\n        {\n            loadModel(path);\n        }\n        void Draw(Shader shader);\t\n    private:\n        /*  模型数据  */\n        vector<Mesh> meshes;\n        string directory;\n        /*  函数   */\n        void loadModel(string path);\n        void processNode(aiNode *node, const aiScene *scene);\n        Mesh processMesh(aiMesh *mesh, const aiScene *scene);\n        vector<Texture> loadMaterialTextures(aiMaterial *mat, aiTextureType type, \n                                             string typeName);\n};\n```\n\n----------------------------------------\n\nTITLE: Final Bloom Combination Fragment Shader (GLSL)\nDESCRIPTION: Fragment shader that combines the original HDR scene with the blurred bright areas to create the final bloom effect.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/07 Bloom.md#2025-04-22_snippet_4\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\nin vec2 TexCoords;\n\nuniform sampler2D scene;\nuniform sampler2D bloomBlur;\nuniform float exposure;\n\nvoid main()\n{             \n    const float gamma = 2.2;\n    vec3 hdrColor = texture(scene, TexCoords).rgb;      \n    vec3 bloomColor = texture(bloomBlur, TexCoords).rgb;\n    hdrColor += bloomColor; // additive blending\n    // tone mapping\n    vec3 result = vec3(1.0) - exp(-hdrColor * exposure);\n    // also gamma correct while we're at it       \n    result = pow(result, vec3(1.0 / gamma));\n    FragColor = vec4(result, 1.0f);\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Cubemap Faces for Shadow Mapping\nDESCRIPTION: Creating the six faces of a cubemap as 2D depth textures for shadow mapping. The code initializes each face with the same resolution and format, configuring them to store depth values for the shadow map.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/02 Point Shadows.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nconst GLuint SHADOW_WIDTH = 1024, SHADOW_HEIGHT = 1024;\nglBindTexture(GL_TEXTURE_CUBE_MAP, depthCubemap);\nfor (GLuint i = 0; i < 6; ++i)\n        glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_DEPTH_COMPONENT, \n                     SHADOW_WIDTH, SHADOW_HEIGHT, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);\n```\n\n----------------------------------------\n\nTITLE: Creating and Binding OpenGL Objects in C++\nDESCRIPTION: Demonstrates the typical workflow of creating an OpenGL object, binding it to a target, setting options, and unbinding it.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/01 OpenGL.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n// 创建对象\nunsigned int objectId = 0;\nglGenObject(1, &objectId);\n// 绑定对象至上下文\nglBindObject(GL_WINDOW_TARGET, objectId);\n// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项\nglSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, 800);\nglSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);\n// 将上下文对象设回默认\nglBindObject(GL_WINDOW_TARGET, 0);\n```\n\n----------------------------------------\n\nTITLE: Implementing Shader Use and Uniform Setter Functions in C++\nDESCRIPTION: Provides implementations for the use() function to activate the shader program and setter functions for various uniform types in OpenGL using C++.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/05 Shaders.md#2025-04-22_snippet_15\n\nLANGUAGE: C++\nCODE:\n```\nvoid use() \n{ \n    glUseProgram(ID);\n}\n\nvoid setBool(const std::string &name, bool value) const\n{\n    glUniform1i(glGetUniformLocation(ID, name.c_str()), (int)value); \n}\nvoid setInt(const std::string &name, int value) const\n{ \n    glUniform1i(glGetUniformLocation(ID, name.c_str()), value); \n}\nvoid setFloat(const std::string &name, float value) const\n{ \n    glUniform1f(glGetUniformLocation(ID, name.c_str()), value); \n}\n```\n\n----------------------------------------\n\nTITLE: Updated Lighting Calculation with Material and Light Properties\nDESCRIPTION: Modifies the lighting calculation to consider both material properties and light properties. Each lighting component (ambient, diffuse, specular) is calculated by multiplying the corresponding material and light properties.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/03 Materials.md#2025-04-22_snippet_4\n\nLANGUAGE: glsl\nCODE:\n```\nvec3 ambient  = light.ambient * material.ambient;\nvec3 diffuse  = light.diffuse * (diff * material.diffuse);\nvec3 specular = light.specular * (spec * material.specular);\n```\n\n----------------------------------------\n\nTITLE: Base Reflectivity Calculation for PBR in GLSL\nDESCRIPTION: This code calculates the base reflectivity (F0) for the Fresnel equation in a PBR shader. It uses a standard value of 0.04 for dielectrics (non-metals) and interpolates between this value and the albedo color based on metalness for metallic surfaces.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/02 Lighting.md#2025-04-22_snippet_5\n\nLANGUAGE: GLSL\nCODE:\n```\nvec3 F0 = vec3(0.04); \nF0      = mix(F0, albedo, metallic);\nvec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);\n```\n\n----------------------------------------\n\nTITLE: Keyboard Input Processing for Camera Movement\nDESCRIPTION: Handles keyboard input for camera movement including forward, backward, left and right strafe.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/09 Camera.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nvoid processInput(GLFWwindow *window)\n{\n    float cameraSpeed = 0.05f;\n    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)\n        cameraPos += cameraSpeed * cameraFront;\n    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)\n        cameraPos -= cameraSpeed * cameraFront;\n    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)\n        cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;\n    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)\n        cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Diffuse and Specular Contribution Factors in PBR\nDESCRIPTION: This code calculates the ratio between diffuse and specular reflection in a PBR shader. The specular factor (kS) comes directly from the Fresnel term, while the diffuse factor (kD) is calculated as the remaining energy, which is further scaled to zero for metallic surfaces.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/02 Lighting.md#2025-04-22_snippet_10\n\nLANGUAGE: GLSL\nCODE:\n```\nvec3 kS = F;\nvec3 kD = vec3(1.0) - kS;\n  \nkD *= 1.0 - metallic;\n```\n\n----------------------------------------\n\nTITLE: Processing Nodes in a 3D Model Hierarchy in C++\nDESCRIPTION: Recursive implementation of the processNode method that traverses the scene hierarchy, processing each mesh at the current node, then continuing to process child nodes.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/03 Model Loading/03 Model.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvoid processNode(aiNode *node, const aiScene *scene)\n{\n    // 处理节点所有的网格（如果有的话）\n    for(unsigned int i = 0; i < node->mNumMeshes; i++)\n    {\n        aiMesh *mesh = scene->mMeshes[node->mMeshes[i]]; \n        meshes.push_back(processMesh(mesh, scene));\t\t\t\n    }\n    // 接下来对它的子节点重复这一过程\n    for(unsigned int i = 0; i < node->mNumChildren; i++)\n    {\n        processNode(node->mChildren[i], scene);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Game Class Structure for OpenGL 2D Game in C++\nDESCRIPTION: Core Game class definition that encapsulates game state, input processing, update logic, and rendering functionality. The class provides a framework for managing the game's lifecycle with initialization, processing input, updating game state, and rendering.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/02 Setting up.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nclass Game\n{\n    public:\n        // 游戏状态\n        GameState  State;\t\n        GLboolean  Keys[1024];\n        GLuint\t   Width, Height;\n        // 构造函数/析构函数\n        Game(GLuint width, GLuint height);\n        ~Game();\n        // 初始化游戏状态（加载所有的着色器/纹理/关卡）\n        void Init();\n        // 游戏循环\n        void ProcessInput(GLfloat dt);\n        void Update(GLfloat dt);\n        void Render();\n};\n```\n\n----------------------------------------\n\nTITLE: Calculating Diffuse Lighting in GLSL\nDESCRIPTION: Fragment shader code that computes diffuse lighting by determining the angle between the light direction and the normal vector. The greater the angle, the less intense the light effect.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/02 Basic Lighting.md#2025-04-22_snippet_3\n\nLANGUAGE: glsl\nCODE:\n```\nvec3 norm = normalize(Normal);\nvec3 lightDir = normalize(lightPos - FragPos);\n\nfloat diff = max(dot(norm, lightDir), 0.0);\nvec3 diffuse = diff * lightColor;\n```\n\n----------------------------------------\n\nTITLE: Reading Shader Source from Files in C++\nDESCRIPTION: Implements the constructor of the Shader class, reading vertex and fragment shader source code from files using C++ file streams and string manipulation.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/05 Shaders.md#2025-04-22_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nShader(const char* vertexPath, const char* fragmentPath)\n{\n    // 1. 从文件路径中获取顶点/片段着色器\n    std::string vertexCode;\n    std::string fragmentCode;\n    std::ifstream vShaderFile;\n    std::ifstream fShaderFile;\n    // 保证ifstream对象可以抛出异常：\n    vShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit);\n    fShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit);\n    try \n    {\n        // 打开文件\n        vShaderFile.open(vertexPath);\n        fShaderFile.open(fragmentPath);\n        std::stringstream vShaderStream, fShaderStream;\n        // 读取文件的缓冲内容到数据流中\n        vShaderStream << vShaderFile.rdbuf();\n        fShaderStream << fShaderFile.rdbuf();\t\t\n        // 关闭文件处理器\n        vShaderFile.close();\n        fShaderFile.close();\n        // 转换数据流到string\n        vertexCode   = vShaderStream.str();\n        fragmentCode = fShaderStream.str();\t\t\n    }\n    catch(std::ifstream::failure e)\n    {\n        std::cout << \"ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ\" << std::endl;\n    }\n    const char* vShaderCode = vertexCode.c_str();\n    const char* fShaderCode = fragmentCode.c_str();\n    [...]\n```\n\n----------------------------------------\n\nTITLE: Generating Pre-filtered Environment Cubemap in C++\nDESCRIPTION: C++ code to generate and set up a cubemap texture for storing the pre-filtered environment map, including mipmap generation for different roughness levels.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/03 IBL/02 Specular IBL.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nunsigned int prefilterMap;\nglGenTextures(1, &prefilterMap);\nglBindTexture(GL_TEXTURE_CUBE_MAP, prefilterMap);\nfor (unsigned int i = 0; i < 6; ++i)\n{\n    glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB16F, 128, 128, 0, GL_RGB, GL_FLOAT, nullptr);\n}\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); \nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\nglGenerateMipmap(GL_TEXTURE_CUBE_MAP);\n```\n\n----------------------------------------\n\nTITLE: SSAO Rendering Process in C++\nDESCRIPTION: This snippet demonstrates the complete SSAO rendering process, including geometry pass, SSAO texture generation, and final lighting pass.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/09 SSAO.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n// 几何处理阶段: 渲染到G缓冲中\nglBindFramebuffer(GL_FRAMEBUFFER, gBuffer);\n    [...]\nglBindFramebuffer(GL_FRAMEBUFFER, 0);  \n  \n// 使用G缓冲渲染SSAO纹理\nglBindFramebuffer(GL_FRAMEBUFFER, ssaoFBO);\n    glClear(GL_COLOR_BUFFER_BIT);\n    shaderSSAO.Use();\n    glActiveTexture(GL_TEXTURE0);\n    glBindTexture(GL_TEXTURE_2D, gPositionDepth);\n    glActiveTexture(GL_TEXTURE1);\n    glBindTexture(GL_TEXTURE_2D, gNormal);\n    glActiveTexture(GL_TEXTURE2);\n    glBindTexture(GL_TEXTURE_2D, noiseTexture);\n    SendKernelSamplesToShader();\n    glUniformMatrix4fv(projLocation, 1, GL_FALSE, glm::value_ptr(projection));\n    RenderQuad();\nglBindFramebuffer(GL_FRAMEBUFFER, 0);\n  \n// 光照处理阶段: 渲染场景光照\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\nshaderLightingPass.Use();\n[...]\nglActiveTexture(GL_TEXTURE3);\nglBindTexture(GL_TEXTURE_2D, ssaoColorBuffer);\n[...]\nRenderQuad();\n```\n\n----------------------------------------\n\nTITLE: Front Face Culling for Shadow Mapping in OpenGL\nDESCRIPTION: Technique to fix Peter panning (shadow offset) artifacts by enabling front face culling when rendering the depth map. This prevents incorrect shadow offsets for solid objects.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/01 Shadow Mapping.md#2025-04-22_snippet_5\n\nLANGUAGE: c++\nCODE:\n```\nglCullFace(GL_FRONT);\nRenderSceneToDepthMap();\nglCullFace(GL_BACK); // 不要忘记设回原先的culling face\n```\n\n----------------------------------------\n\nTITLE: Hemisphere Sampling for Irradiance Convolution in GLSL\nDESCRIPTION: GLSL code snippet for sampling the hemisphere around a direction vector to compute the diffuse irradiance. It uses spherical coordinates to generate sample directions.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/03 IBL/01 Diffuse irradiance.md#2025-04-22_snippet_9\n\nLANGUAGE: GLSL\nCODE:\n```\nvec3 irradiance = vec3(0.0);  \n\nvec3 up    = vec3(0.0, 1.0, 0.0);\nvec3 right = normalize(cross(up, normal));\nup         = normalize(cross(normal, right));\n\nfloat sampleDelta = 0.025;\nfloat nrSamples = 0.0; \nfor(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)\n{\n    for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)\n    {\n        // spherical to cartesian (in tangent space)\n        vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\n        // tangent space to world\n        vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N; \n\n        irradiance += texture(environmentMap, sampleVec).rgb * cos(theta) * sin(theta);\n        nrSamples++;\n    }\n}\nirradiance = PI * irradiance * (1.0 / float(nrSamples));\n```\n\n----------------------------------------\n\nTITLE: Percentage-Closer Filtering (PCF) for Soft Shadows in GLSL\nDESCRIPTION: Implementation of PCF technique to create soft shadows by sampling the shadow map multiple times with slightly different texture coordinates and averaging the results to reduce shadow aliasing.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/01 Shadow Mapping.md#2025-04-22_snippet_8\n\nLANGUAGE: GLSL\nCODE:\n```\nfloat shadow = 0.0;\nvec2 texelSize = 1.0 / textureSize(shadowMap, 0);\nfor(int x = -1; x <= 1; ++x)\n{\n    for(int y = -1; y <= 1; ++y)\n    {\n        float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r; \n        shadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;        \n    }    \n}\nshadow /= 9.0;\n```\n\n----------------------------------------\n\nTITLE: Gaussian Blur Fragment Shader (GLSL)\nDESCRIPTION: Fragment shader implementing a two-pass Gaussian blur. It can perform either horizontal or vertical blur based on a uniform variable.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/07 Bloom.md#2025-04-22_snippet_2\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\nin vec2 TexCoords;\n\nuniform sampler2D image;\nuniform bool horizontal;\nuniform float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\n\nvoid main()\n{             \n    vec2 tex_offset = 1.0 / textureSize(image, 0); // gets size of single texel\n    vec3 result = texture(image, TexCoords).rgb * weight[0]; // current fragment's contribution\n    if(horizontal)\n    {\n        for(int i = 1; i < 5; ++i)\n        {\n            result += texture(image, TexCoords + vec2(tex_offset.x * i, 0.0)).rgb * weight[i];\n            result += texture(image, TexCoords - vec2(tex_offset.x * i, 0.0)).rgb * weight[i];\n        }\n    }\n    else\n    {\n        for(int i = 1; i < 5; ++i)\n        {\n            result += texture(image, TexCoords + vec2(0.0, tex_offset.y * i)).rgb * weight[i];\n            result += texture(image, TexCoords - vec2(0.0, tex_offset.y * i)).rgb * weight[i];\n        }\n    }\n    FragColor = vec4(result, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Lighting Components in Fragment Shader\nDESCRIPTION: Code that combines ambient, diffuse, and specular lighting components to create the final fragment color. This completes the Phong lighting model implementation.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/02 Basic Lighting.md#2025-04-22_snippet_6\n\nLANGUAGE: glsl\nCODE:\n```\nvec3 result = (ambient + diffuse + specular) * objectColor;\nFragColor = vec4(result, 1.0);\n```\n\n----------------------------------------\n\nTITLE: Sampling from a Cubemap in Fragment Shader\nDESCRIPTION: This GLSL fragment shader demonstrates how to sample from a cubemap texture using a 3D direction vector. It uses the samplerCube sampler type and the texture function for cubemap sampling.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/06 Cubemaps.md#2025-04-22_snippet_3\n\nLANGUAGE: GLSL\nCODE:\n```\nin vec3 textureDir; // 代表3D纹理坐标的方向向量\nuniform samplerCube cubemap; // 立方体贴图的纹理采样器\n\nvoid main()\n{             \n    FragColor = texture(cubemap, textureDir);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Draw Method for Model Class in C++\nDESCRIPTION: Implementation of the Draw method that iterates through all meshes in the model and calls their respective Draw functions.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/03 Model Loading/03 Model.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nvoid Draw(Shader &shader)\n{\n    for(unsigned int i = 0; i < meshes.size(); i++)\n        meshes[i].Draw(shader);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Light Colors in C++ Application Code\nDESCRIPTION: Creates time-varying light colors using sine functions to generate interesting visual effects. The light's ambient and diffuse colors are calculated based on the current time and then sent to the shader.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/03 Materials.md#2025-04-22_snippet_6\n\nLANGUAGE: c++\nCODE:\n```\nglm::vec3 lightColor;\nlightColor.x = sin(glfwGetTime() * 2.0f);\nlightColor.y = sin(glfwGetTime() * 0.7f);\nlightColor.z = sin(glfwGetTime() * 1.3f);\n  \nglm::vec3 diffuseColor = lightColor   * glm::vec3(0.5f); // 降低影响\nglm::vec3 ambientColor = diffuseColor * glm::vec3(0.2f); // 很低的影响\n  \nlightingShader.setVec3(\"light.ambient\", ambientColor);\nlightingShader.setVec3(\"light.diffuse\", diffuseColor);\n```\n\n----------------------------------------\n\nTITLE: Defining a Matrices Uniform Block in GLSL\nDESCRIPTION: Demonstrates how to define a Uniform Block for storing projection and view matrices in a vertex shader using GLSL.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/08 Advanced GLSL.md#2025-04-22_snippet_5\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (location = 0) in vec3 aPos;\n\nlayout (std140) uniform Matrices\n{\n    mat4 projection;\n    mat4 view;\n};\nuniform mat4 model;\n\nvoid main()\n{\n    gl_Position = projection * view * model * vec4(aPos, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Stencil Operations in OpenGL\nDESCRIPTION: Configuration of what actions to take when stencil tests pass or fail. Here the stencil buffer is only updated when both stencil and depth tests pass.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/02 Stencil testing.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nglStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);\n```\n\n----------------------------------------\n\nTITLE: Implementing Kernel-Based Image Processing in GLSL\nDESCRIPTION: A fragment shader that applies a 3x3 convolution kernel to the image. This example implements a sharpen filter, but the kernel values can be changed to create different effects. The shader samples 9 pixels around the current coordinate and applies weighted values.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/05 Framebuffers.md#2025-04-22_snippet_2\n\nLANGUAGE: GLSL\nCODE:\n```\nconst float offset = 1.0 / 300.0;  \n\nvoid main()\n{\n    vec2 offsets[9] = vec2[](\n        vec2(-offset,  offset), // 左上\n        vec2( 0.0f,    offset), // 正上\n        vec2( offset,  offset), // 右上\n        vec2(-offset,  0.0f),   // 左\n        vec2( 0.0f,    0.0f),   // 中\n        vec2( offset,  0.0f),   // 右\n        vec2(-offset, -offset), // 左下\n        vec2( 0.0f,   -offset), // 正下\n        vec2( offset, -offset)  // 右下\n    );\n\n    float kernel[9] = float[](\n        -1, -1, -1,\n        -1,  9, -1,\n        -1, -1, -1\n    );\n    \n    vec3 sampleTex[9];\n    for(int i = 0; i < 9; i++)\n    {\n        sampleTex[i] = vec3(texture(screenTexture, TexCoords.st + offsets[i]));\n    }\n    vec3 col = vec3(0.0);\n    for(int i = 0; i < 9; i++)\n        col += sampleTex[i] * kernel[i];\n    \n    FragColor = vec4(col, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Perspective Projection Matrix for Cubemap Faces\nDESCRIPTION: Setting up a perspective projection matrix for point light shadow mapping. Using a 90-degree field of view ensures that each face of the cubemap aligns perfectly with adjacent faces, covering the entire surroundings of the light source.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/02 Point Shadows.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nGLfloat aspect = (GLfloat)SHADOW_WIDTH/(GLfloat)SHADOW_HEIGHT;\nGLfloat near = 1.0f;\nGLfloat far = 25.0f;\nglm::mat4 shadowProj = glm::perspective(glm::radians(90.0f), aspect, near, far);\n```\n\n----------------------------------------\n\nTITLE: Calculating Halfway Vector in GLSL\nDESCRIPTION: Computes the halfway vector between the light direction and view direction for use in the Blinn-Phong lighting model. This vector is normalized to ensure it has unit length.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/01 Advanced Lighting.md#2025-04-22_snippet_0\n\nLANGUAGE: GLSL\nCODE:\n```\nvec3 lightDir   = normalize(lightPos - FragPos);\nvec3 viewDir    = normalize(viewPos - FragPos);\nvec3 halfwayDir = normalize(lightDir + viewDir);\n```\n\n----------------------------------------\n\nTITLE: Implementing Refraction in Fragment Shader (GLSL)\nDESCRIPTION: This shader calculates the refraction vector using the view direction, surface normal, and refractive index ratio, then samples the skybox cubemap to create a refractive effect.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/06 Cubemaps.md#2025-04-22_snippet_14\n\nLANGUAGE: GLSL\nCODE:\n```\nvoid main()\n{             \n    float ratio = 1.00 / 1.52;\n    vec3 I = normalize(Position - cameraPos);\n    vec3 R = refract(I, normalize(Normal), ratio);\n    FragColor = vec4(texture(skybox, R).rgb, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Irradiance Map to Cubemap in OpenGL\nDESCRIPTION: C++ code for rendering the convolved irradiance map to a cubemap texture using OpenGL. It sets up the framebuffer and renders each face of the cubemap.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/03 IBL/01 Diffuse irradiance.md#2025-04-22_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nirradianceShader.use();\nirradianceShader.setInt(\"environmentMap\", 0);\nirradianceShader.setMat4(\"projection\", captureProjection);\nglActiveTexture(GL_TEXTURE0);\nglBindTexture(GL_TEXTURE_CUBE_MAP, envCubemap);\n\nglViewport(0, 0, 32, 32); // don't forget to configure the viewport to the capture dimensions.\nglBindFramebuffer(GL_FRAMEBUFFER, captureFBO);\nfor (unsigned int i = 0; i < 6; ++i)\n{\n    irradianceShader.setMat4(\"view\", captureViews[i]);\n    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, \n                           GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, irradianceMap, 0);\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n    renderCube();\n}\nglBindFramebuffer(GL_FRAMEBUFFER, 0);\n```\n\n----------------------------------------\n\nTITLE: Basic Geometry Shader Example in GLSL\nDESCRIPTION: A simple geometry shader that takes points as input and outputs a line strip. It demonstrates the basic structure and syntax of a geometry shader.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/09 Geometry Shader.md#2025-04-22_snippet_0\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (points) in;\nlayout (line_strip, max_vertices = 2) out;\n\nvoid main() {    \n    gl_Position = gl_in[0].gl_Position + vec4(-0.1, 0.0, 0.0, 0.0); \n    EmitVertex();\n\n    gl_Position = gl_in[0].gl_Position + vec4( 0.1, 0.0, 0.0, 0.0);\n    EmitVertex();\n    \n    EndPrimitive();\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Uniform Block Bindings for Multiple Shaders in C++\nDESCRIPTION: Shows how to set up Uniform Block bindings for multiple shader programs using glGetUniformBlockIndex and glUniformBlockBinding functions in C++.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/08 Advanced GLSL.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nunsigned int uniformBlockIndexRed    = glGetUniformBlockIndex(shaderRed.ID, \"Matrices\");\nunsigned int uniformBlockIndexGreen  = glGetUniformBlockIndex(shaderGreen.ID, \"Matrices\");\nunsigned int uniformBlockIndexBlue   = glGetUniformBlockIndex(shaderBlue.ID, \"Matrices\");\nunsigned int uniformBlockIndexYellow = glGetUniformBlockIndex(shaderYellow.ID, \"Matrices\");  \n  \nglUniformBlockBinding(shaderRed.ID,    uniformBlockIndexRed, 0);\nglUniformBlockBinding(shaderGreen.ID,  uniformBlockIndexGreen, 0);\nglUniformBlockBinding(shaderBlue.ID,   uniformBlockIndexBlue, 0);\nglUniformBlockBinding(shaderYellow.ID, uniformBlockIndexYellow, 0);\n```\n\n----------------------------------------\n\nTITLE: Vertex Shader Input Layout Definition\nDESCRIPTION: Defines the vertex shader input attributes including position, normal, texture coordinates, tangent and bitangent vectors.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/04 Normal Mapping.md#2025-04-22_snippet_5\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoords;\nlayout (location = 3) in vec3 tangent;\nlayout (location = 4) in vec3 bitangent;\n```\n\n----------------------------------------\n\nTITLE: Direct Memory Access with glMapBuffer in OpenGL\nDESCRIPTION: Shows how to directly manipulate buffer memory by obtaining a pointer with glMapBuffer, copying data to the buffer memory, and releasing the pointer with glUnmapBuffer.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/07 Advanced Data.md#2025-04-22_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nfloat data[] = {\n  0.5f, 1.0f, -0.35f\n  ...\n};\nglBindBuffer(GL_ARRAY_BUFFER, buffer);\n// 获取指针\nvoid *ptr = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);\n// 复制数据到内存\nmemcpy(ptr, data, sizeof(data));\n// 记得告诉OpenGL我们不再需要这个指针了\nglUnmapBuffer(GL_ARRAY_BUFFER);\n```\n\n----------------------------------------\n\nTITLE: Geometry Function Implementation for PBR in GLSL\nDESCRIPTION: This code implements the geometry function for PBR, which accounts for self-shadowing of microfacets. It includes both the Schlick-GGX approximation for a single vector and the Smith model that combines shadowing from both view and light directions.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/02 Lighting.md#2025-04-22_snippet_7\n\nLANGUAGE: GLSL\nCODE:\n```\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Light Properties Structure in GLSL\nDESCRIPTION: Creates a light structure in GLSL that contains position and color properties for ambient, diffuse, and specular lighting components. This allows for fine-grained control over each lighting component's intensity and color.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/03 Materials.md#2025-04-22_snippet_3\n\nLANGUAGE: glsl\nCODE:\n```\nstruct Light {\n    vec3 position;\n  \n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\n\nuniform Light light;\n```\n\n----------------------------------------\n\nTITLE: PBR Fragment Shader Input Variables in GLSL\nDESCRIPTION: This snippet defines the input variables for a PBR fragment shader including texture coordinates, world position, normal vector, camera position, and material properties like albedo, metallic, roughness, and ambient occlusion.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/02 Lighting.md#2025-04-22_snippet_1\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\nin vec2 TexCoords;\nin vec3 WorldPos;\nin vec3 Normal;\n  \nuniform vec3 camPos;\n  \nuniform vec3  albedo;\nuniform float metallic;\nuniform float roughness;\nuniform float ao;\n```\n\n----------------------------------------\n\nTITLE: Calculating Light Attenuation in GLSL Fragment Shader\nDESCRIPTION: GLSL code snippet that calculates light attenuation based on distance from light source, using the standard inverse square formula with constant, linear, and quadratic components.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/05 Light casters.md#2025-04-22_snippet_5\n\nLANGUAGE: GLSL\nCODE:\n```\nfloat distance    = length(light.position - FragPos);\nfloat attenuation = 1.0 / (light.constant + light.linear * distance + \n    \t\t    light.quadratic * (distance * distance));\n```\n\n----------------------------------------\n\nTITLE: Implementing Mesh Class Structure in C++\nDESCRIPTION: Defines the Mesh class with member variables for vertices, indices, and textures, along with functions for construction, setup, and drawing.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/03 Model Loading/02 Mesh.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nclass Mesh {\n    public:\n        /*  网格数据  */\n        vector<Vertex> vertices;\n        vector<unsigned int> indices;\n        vector<Texture> textures;\n        /*  函数  */\n        Mesh(vector<Vertex> vertices, vector<unsigned int> indices, vector<Texture> textures);\n        void Draw(Shader &shader);\n    private:\n        /*  渲染数据  */\n        unsigned int VAO, VBO, EBO;\n        /*  函数  */\n        void setupMesh();\n};\n```\n\n----------------------------------------\n\nTITLE: Processing Material Textures from Assimp in C++\nDESCRIPTION: Code snippet for extracting diffuse and specular textures from an Assimp material, adding them to the mesh's texture collection.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/03 Model Loading/03 Model.md#2025-04-22_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nif(mesh->mMaterialIndex >= 0)\n{\n    aiMaterial *material = scene->mMaterials[mesh->mMaterialIndex];\n    vector<Texture> diffuseMaps = loadMaterialTextures(material, \n                                        aiTextureType_DIFFUSE, \"texture_diffuse\");\n    textures.insert(textures.end(), diffuseMaps.begin(), diffuseMaps.end());\n    vector<Texture> specularMaps = loadMaterialTextures(material, \n                                        aiTextureType_SPECULAR, \"texture_specular\");\n    textures.insert(textures.end(), specularMaps.begin(), specularMaps.end());\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Schlick-GGX Geometry Function\nDESCRIPTION: GLSL implementation of the Geometry Function using Smith's method with Schlick-GGX approximation. Calculates geometric shadowing and occlusion between microfacets.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/01 Theory.md#2025-04-22_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\nfloat GeometrySchlickGGX(float NdotV, float k)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float k)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = GeometrySchlickGGX(NdotV, k);\n    float ggx2 = GeometrySchlickGGX(NdotL, k);\n\n    return ggx1 * ggx2;\n}\n```\n\n----------------------------------------\n\nTITLE: SSAO Shader Implementation in GLSL\nDESCRIPTION: This snippet shows the SSAO shader implementation in GLSL, including the main function that calculates the occlusion factor for each fragment.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/09 SSAO.md#2025-04-22_snippet_2\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout float FragColor;\nin vec2 TexCoords;\n\nuniform sampler2D gPositionDepth;\nuniform sampler2D gNormal;\nuniform sampler2D texNoise;\n\nuniform vec3 samples[64];\nuniform mat4 projection;\n\n// 屏幕的平铺噪声纹理会根据屏幕分辨率除以噪声大小的值来决定\nconst vec2 noiseScale = vec2(800.0/4.0, 600.0/4.0); // 屏幕 = 800x600\n\nvoid main()\n{\n    [...]\n}\n```\n\n----------------------------------------\n\nTITLE: Exposure-Based Tone Mapping in GLSL\nDESCRIPTION: A fragment shader implementing exposure-based tone mapping for HDR rendering. The exposure parameter allows emphasizing either dark or bright areas, similar to how human eyes or cameras adjust to different lighting conditions.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/06 HDR.md#2025-04-22_snippet_5\n\nLANGUAGE: glsl\nCODE:\n```\nuniform float exposure;\n\nvoid main()\n{             \n    const float gamma = 2.2;\n    vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb;\n  \n    // 曝光色调映射\n    vec3 mapped = vec3(1.0) - exp(-hdrColor * exposure);\n    // Gamma校正 \n    mapped = pow(mapped, vec3(1.0 / gamma));\n  \n    color = vec4(mapped, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Toggling Between Phong and Blinn-Phong Reflection Models in GLSL\nDESCRIPTION: Fragment shader code that allows switching between traditional Phong reflection and Blinn-Phong reflection models. Note that the Blinn-Phong model uses a higher shininess value (16.0 vs 8.0) to achieve similar results.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/01 Advanced Lighting.md#2025-04-22_snippet_2\n\nLANGUAGE: GLSL\nCODE:\n```\nvoid main()\n{\n    [...]\n    float spec = 0.0;\n    if(blinn)\n    {\n        vec3 halfwayDir = normalize(lightDir + viewDir);  \n        spec = pow(max(dot(normal, halfwayDir), 0.0), 16.0);\n    }\n    else\n    {\n        vec3 reflectDir = reflect(-lightDir, normal);\n        spec = pow(max(dot(viewDir, reflectDir), 0.0), 8.0);\n    }\n```\n\n----------------------------------------\n\nTITLE: Calculating Tangent and Bitangent Vectors for Normal Mapping in C++\nDESCRIPTION: Code that implements the mathematical formula to calculate tangent and bitangent vectors from triangle edges and texture coordinate differences. These vectors are normalized to create the TBN matrix for normal mapping.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/04 Normal Mapping.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nGLfloat f = 1.0f / (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);\n \ntangent1.x = f * (deltaUV2.y * edge1.x - deltaUV1.y * edge2.x);\ntangent1.y = f * (deltaUV2.y * edge1.y - deltaUV1.y * edge2.y);\ntangent1.z = f * (deltaUV2.y * edge1.z - deltaUV1.y * edge2.z);\ntangent1 = glm::normalize(tangent1);\n \nbitangent1.x = f * (-deltaUV2.x * edge1.x + deltaUV1.x * edge2.x);\nbitangent1.y = f * (-deltaUV2.x * edge1.y + deltaUV1.x * edge2.y);\nbitangent1.z = f * (-deltaUV2.x * edge1.z + deltaUV1.x * edge2.z);\nbitangent1 = glm::normalize(bitangent1);  \n  \n[...] // 对平面的第二个三角形采用类似步骤计算切线和副切线\n```\n\n----------------------------------------\n\nTITLE: Sampling Normal Map in Fragment Shader in C++\nDESCRIPTION: Fragment shader code for retrieving normal vectors from a normal map texture. The shader first samples the normal from the texture in [0,1] range, then transforms it back to [-1,1] range for use in lighting calculations.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/04 Normal Mapping.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nuniform sampler2D normalMap;  \n \nvoid main()\n{           \n    // 从法线贴图范围[0,1]获取法线\n    normal = texture(normalMap, fs_in.TexCoords).rgb;\n    // 将法线向量转换为范围[-1,1]\n    normal = normalize(normal * 2.0 - 1.0);   \n  \n    [...]\n    // 像往常那样处理光照\n}\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader for Equirectangular to Cubemap Conversion in GLSL\nDESCRIPTION: This fragment shader samples the equirectangular map using the local position and converts it to the cubemap format.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/03 IBL/01 Diffuse irradiance.md#2025-04-22_snippet_1\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\nin vec3 localPos;\n\nuniform sampler2D equirectangularMap;\n\nconst vec2 invAtan = vec2(0.1591, 0.3183);\nvec2 SampleSphericalMap(vec3 v)\n{\n    vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\n    uv *= invAtan;\n    uv += 0.5;\n    return uv;\n}\n\nvoid main()\n{       \n    vec2 uv = SampleSphericalMap(normalize(localPos)); // make sure to normalize localPos\n    vec3 color = texture(equirectangularMap, uv).rgb;\n    \n    FragColor = vec4(color, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Depth Cubemap Texture in OpenGL\nDESCRIPTION: Code for generating and initializing a depth cubemap texture in OpenGL. It creates a texture object and configures each of the six faces as 2D depth component textures with the specified dimensions.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/02 Point Shadows.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nGLuint depthCubemap;\nglGenTextures(1, &depthCubemap);\n```\n\n----------------------------------------\n\nTITLE: Defining Directional Light Structure in GLSL\nDESCRIPTION: Declaration of a directional light structure in GLSL that stores properties such as direction, ambient, diffuse, and specular components, which are necessary for calculating directional lighting.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/06 Multiple lights.md#2025-04-22_snippet_1\n\nLANGUAGE: GLSL\nCODE:\n```\nstruct DirLight {\n    vec3 direction;\n  \n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};  \nuniform DirLight dirLight;\n```\n\n----------------------------------------\n\nTITLE: Instanced Rendering Vertex Shader in GLSL\nDESCRIPTION: Vertex shader modified to support instanced rendering by accepting instance matrices as vertex attributes.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/10 Instancing.md#2025-04-22_snippet_8\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (location = 0) in vec3 aPos;\nlayout (location = 2) in vec2 aTexCoords;\nlayout (location = 3) in mat4 instanceMatrix;\n\nout vec2 TexCoords;\n\nuniform mat4 projection;\nuniform mat4 view;\n\nvoid main()\n{\n    gl_Position = projection * view * instanceMatrix * vec4(aPos, 1.0); \n    TexCoords = aTexCoords;\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Bright Areas in Fragment Shader (GLSL)\nDESCRIPTION: Fragment shader code to extract bright areas from the rendered scene using multiple render targets. It outputs the normal scene color and a separate bright color if above a threshold.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/07 Bloom.md#2025-04-22_snippet_0\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (location = 0) out vec4 FragColor;\nlayout (location = 1) out vec4 BrightColor;\n\n[...]\n\nvoid main()\n{            \n    [...] // first do normal lighting calculations and output results\n    FragColor = vec4(lighting, 1.0f);\n    // Check whether fragment output is higher than threshold, if so output as brightness color\n    float brightness = dot(FragColor.rgb, vec3(0.2126, 0.7152, 0.0722));\n    if(brightness > 1.0)\n        BrightColor = vec4(FragColor.rgb, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Directional Light Contribution in GLSL\nDESCRIPTION: Function to calculate the contribution of a directional light source to the fragment color. It processes ambient, diffuse, and specular lighting components based on the material properties and surface normal.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/06 Multiple lights.md#2025-04-22_snippet_2\n\nLANGUAGE: GLSL\nCODE:\n```\nvec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir)\n{\n    vec3 lightDir = normalize(-light.direction);\n    // 漫反射着色\n    float diff = max(dot(normal, lightDir), 0.0);\n    // 镜面光着色\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n    // 合并结果\n    vec3 ambient  = light.ambient  * vec3(texture(material.diffuse, TexCoords));\n    vec3 diffuse  = light.diffuse  * diff * vec3(texture(material.diffuse, TexCoords));\n    vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));\n    return (ambient + diffuse + specular);\n}\n```\n\n----------------------------------------\n\nTITLE: Skybox Fragment Shader in GLSL\nDESCRIPTION: This fragment shader for rendering a skybox samples from a cubemap texture using 3D texture coordinates. It applies the sampled color directly as the output color.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/06 Cubemaps.md#2025-04-22_snippet_7\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\n\nin vec3 TexCoords;\n\nuniform samplerCube skybox;\n\nvoid main()\n{    \n    FragColor = texture(skybox, TexCoords);\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Animation Class in C++\nDESCRIPTION: Defines the Animation class constructor and methods to load animation data from an Assimp scene. It reads bone hierarchy, calculates transformations, and stores animation information.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/08 Guest Articles/2020/01 Skeletal Animation.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvoid ReadHeirarchyData(AssimpNodeData& dest, const aiNode* src)\n{\n    assert(src);\n\n    dest.name = src->mName.data;\n    dest.transformation = AssimpGLMHelpers::ConvertMatrixToGLMFormat(src->mTransformation);\n    dest.childrenCount = src->mNumChildren;\n\n    for (int i = 0; i < src->mNumChildren; i++)\n    {\n        AssimpNodeData newData;\n        ReadHeirarchyData(newData, src->mChildren[i]);\n        dest.children.push_back(newData);\n    }\n}\nfloat m_Duration;\nint m_TicksPerSecond;\nstd::vector<Bone> m_Bones;\nAssimpNodeData m_RootNode;\nstd::map<std::string, BoneInfo> m_BoneInfoMap;\n```\n\n----------------------------------------\n\nTITLE: Tone Mapping and Gamma Correction for PBR Rendering\nDESCRIPTION: This code performs tone mapping using the Reinhard operator to map HDR values to LDR, followed by gamma correction to ensure proper display. This is essential in PBR to preserve lighting details and ensure correct visual appearance.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/02 Lighting.md#2025-04-22_snippet_13\n\nLANGUAGE: GLSL\nCODE:\n```\ncolor = color / (color + vec3(1.0));\ncolor = pow(color, vec3(1.0/2.2)); \n```\n\n----------------------------------------\n\nTITLE: Combining Pre-filtered Environment Map and BRDF Integration Map in GLSL\nDESCRIPTION: Shader code snippet demonstrating how to combine the pre-filtered environment map and BRDF integration map to calculate the indirect specular lighting contribution.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/03 IBL/02 Specular IBL.md#2025-04-22_snippet_0\n\nLANGUAGE: GLSL\nCODE:\n```\nfloat lod             = getMipLevelFromRoughness(roughness);\nvec3 prefilteredColor = textureCubeLod(PrefilteredEnvMap, refVec, lod);\nvec2 envBRDF          = texture2D(BRDFIntegrationMap, vec2(NdotV, roughness)).xy;\nvec3 indirectSpecular = prefilteredColor * (F * envBRDF.x + envBRDF.y)\n```\n\n----------------------------------------\n\nTITLE: Complete Object Outlining Implementation in OpenGL\nDESCRIPTION: The full sequence of steps to implement object outlining using the stencil buffer. This includes drawing the floor without modifying the stencil buffer, drawing objects while writing to the stencil buffer, and finally drawing larger versions of the objects only where they don't overlap with the originals.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/02 Stencil testing.md#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nglEnable(GL_DEPTH_TEST);\nglStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);  \n  \nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); \n\nglStencilMask(0x00); // 记得保证我们在绘制地板的时候不会更新模板缓冲\nnormalShader.use();\nDrawFloor()  \n  \nglStencilFunc(GL_ALWAYS, 1, 0xFF); \nglStencilMask(0xFF); \nDrawTwoContainers();\n  \nglStencilFunc(GL_NOTEQUAL, 1, 0xFF);\nglStencilMask(0x00); \nglDisable(GL_DEPTH_TEST);\nshaderSingleColor.use(); \nDrawTwoScaledUpContainers();\nglStencilMask(0xFF);\nglEnable(GL_DEPTH_TEST);  \n```\n\n----------------------------------------\n\nTITLE: GGX Normal Distribution Function Implementation for PBR\nDESCRIPTION: This function implements the GGX normal distribution function (NDF) for PBR. It calculates the microfacet distribution based on the surface normal, half vector, and roughness, which is used in the specular BRDF calculation.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/02 Lighting.md#2025-04-22_snippet_6\n\nLANGUAGE: GLSL\nCODE:\n```\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Blur Kernel in GLSL\nDESCRIPTION: A kernel array for implementing Gaussian blur effect in fragment shaders. The kernel values are weighted to give the center pixel more importance, and all weights are normalized by dividing by 16 to maintain proper brightness levels.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/05 Framebuffers.md#2025-04-22_snippet_3\n\nLANGUAGE: GLSL\nCODE:\n```\nfloat kernel[9] = float[](\n    1.0 / 16, 2.0 / 16, 1.0 / 16,\n    2.0 / 16, 4.0 / 16, 2.0 / 16,\n    1.0 / 16, 2.0 / 16, 1.0 / 16  \n);\n```\n\n----------------------------------------\n\nTITLE: Drawing Scaled Object Outlines Using Stencil Test\nDESCRIPTION: Configuration to draw only where the stencil buffer is not equal to 1, creating outlines around previously drawn objects. Depth testing is disabled to prevent the floor from obscuring the outlines.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/02 Stencil testing.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nglStencilFunc(GL_NOTEQUAL, 1, 0xFF);\nglStencilMask(0x00); // 禁止模板缓冲的写入\nglDisable(GL_DEPTH_TEST);\nshaderSingleColor.use(); \nDrawTwoScaledUpContainers();\n```\n\n----------------------------------------\n\nTITLE: Initializing irrKlang Sound Engine and Adding Background Music in C++\nDESCRIPTION: Code snippet that shows how to include irrKlang, initialize a sound engine, and play a background music track with looping enabled. The sound engine is created and the music begins playing during game initialization.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/09 Audio.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <irrklang/irrKlang.h>\nusing namespace irrklang;\n\nISoundEngine *SoundEngine = createIrrKlangDevice();\n  \nvoid Game::Init()\n{\n    [...]\n    SoundEngine->play2D(\"audio/breakout.mp3\", GL_TRUE);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Ambient Lighting in GLSL Fragment Shader\nDESCRIPTION: Code to calculate ambient lighting by multiplying the light color with an ambient strength factor and then with the object color. This creates a minimum level of illumination even without direct lighting.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/02 Basic Lighting.md#2025-04-22_snippet_0\n\nLANGUAGE: glsl\nCODE:\n```\nvoid main()\n{\n    float ambientStrength = 0.1;\n    vec3 ambient = ambientStrength * lightColor;\n\n    vec3 result = ambient * objectColor;\n    FragColor = vec4(result, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Multiple Faces of a Cubemap in OpenGL\nDESCRIPTION: This code shows how to load the six faces of a cubemap texture from image files. It iterates through texture paths and loads each face, associating it with the corresponding cubemap face target.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/06 Cubemaps.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nint width, height, nrChannels;\nunsigned char *data;  \nfor(unsigned int i = 0; i < textures_faces.size(); i++)\n{\n    data = stbi_load(textures_faces[i].c_str(), &width, &height, &nrChannels, 0);\n    glTexImage2D(\n        GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, \n        0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Applying SSAO in Lighting Shader (GLSL)\nDESCRIPTION: This snippet demonstrates how to apply the SSAO factor in the final lighting calculation within a Blinn-Phong lighting model.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/09 SSAO.md#2025-04-22_snippet_4\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\nin vec2 TexCoords;\n\nuniform sampler2D gPositionDepth;\nuniform sampler2D gNormal;\nuniform sampler2D gAlbedo;\nuniform sampler2D ssao;\n\nstruct Light {\n    vec3 Position;\n    vec3 Color;\n    \n    float Linear;\n    float Quadratic;\n    float Radius;\n};\nuniform Light light;\n\nvoid main()\n{             \n    // 从G缓冲中提取数据\n    vec3 FragPos = texture(gPositionDepth, TexCoords).rgb;\n    vec3 Normal = texture(gNormal, TexCoords).rgb;\n    vec3 Diffuse = texture(gAlbedo, TexCoords).rgb;\n    float AmbientOcclusion = texture(ssao, TexCoords).r;\n    \n    // Blinn-Phong (观察空间中)\n    vec3 ambient = vec3(0.3 * AmbientOcclusion); // 这里我们加上遮蔽因子\n    vec3 lighting  = ambient; \n    vec3 viewDir  = normalize(-FragPos); // Viewpos 为 (0.0.0)，在观察空间中\n    // 漫反射\n    vec3 lightDir = normalize(light.Position - FragPos);\n    vec3 diffuse = max(dot(Normal, lightDir), 0.0) * Diffuse * light.Color;\n    // 镜面\n    vec3 halfwayDir = normalize(lightDir + viewDir);  \n    float spec = pow(max(dot(Normal, halfwayDir), 0.0), 8.0);\n    vec3 specular = light.Color * spec;\n    // 衰减\n    float dist = length(light.Position - FragPos);\n    float attenuation = 1.0 / (1.0 + light.Linear * dist + light.Quadratic * dist * dist);\n    diffuse  *= attenuation;\n    specular *= attenuation;\n    lighting += diffuse + specular;\n\n    FragColor = vec4(lighting, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Textures for Glyphs in C++\nDESCRIPTION: Loops through ASCII characters, generates textures for each glyph, and stores the character data in the Characters map.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/02 Text Rendering.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nglPixelStorei(GL_UNPACK_ALIGNMENT, 1); //禁用字节对齐限制\nfor (GLubyte c = 0; c < 128; c++)\n{\n    // 加载字符的字形 \n    if (FT_Load_Char(face, c, FT_LOAD_RENDER))\n    {\n        std::cout << \"ERROR::FREETYTPE: Failed to load Glyph\" << std::endl;\n        continue;\n    }\n    // 生成纹理\n    GLuint texture;\n    glGenTextures(1, &texture);\n    glBindTexture(GL_TEXTURE_2D, texture);\n    glTexImage2D(\n        GL_TEXTURE_2D,\n        0,\n        GL_RED,\n        face->glyph->bitmap.width,\n        face->glyph->bitmap.rows,\n        0,\n        GL_RED,\n        GL_UNSIGNED_BYTE,\n        face->glyph->bitmap.buffer\n    );\n    // 设置纹理选项\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    // 储存字符供之后使用\n    Character character = {\n        texture, \n        glm::ivec2(face->glyph->bitmap.width, face->glyph->bitmap.rows),\n        glm::ivec2(face->glyph->bitmap_left, face->glyph->bitmap_top),\n        face->glyph->advance.x\n    };\n    Characters.insert(std::pair<GLchar, Character>(c, character));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Reflection in Fragment Shader (GLSL)\nDESCRIPTION: This shader calculates the reflection vector using the view direction and surface normal, then samples the skybox cubemap texture to create a reflective effect.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/06 Cubemaps.md#2025-04-22_snippet_11\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\n\nin vec3 Normal;\nin vec3 Position;\n\nuniform vec3 cameraPos;\nuniform samplerCube skybox;\n\nvoid main()\n{             \n    vec3 I = normalize(Position - cameraPos);\n    vec3 R = reflect(I, normalize(Normal));\n    FragColor = vec4(texture(skybox, R).rgb, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Vertex Shader with Color Output\nDESCRIPTION: A vertex shader that sets the vertex position and outputs a color to the fragment shader.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/05 Shaders.md#2025-04-22_snippet_4\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (location = 0) in vec3 aPos; // 位置变量的属性位置值为0\n\nout vec4 vertexColor; // 为片段着色器指定一个颜色输出\n\nvoid main()\n{\n    gl_Position = vec4(aPos, 1.0); // 注意我们如何把一个vec3作为vec4的构造器的参数\n    vertexColor = vec4(0.5, 0.0, 0.0, 1.0); // 把输出变量设置为暗红色\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Indirect Diffuse Lighting in GLSL Fragment Shader\nDESCRIPTION: GLSL code for calculating indirect diffuse lighting using the precomputed irradiance map and Fresnel-Schlick approximation with roughness.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/03 IBL/01 Diffuse irradiance.md#2025-04-22_snippet_12\n\nLANGUAGE: GLSL\nCODE:\n```\nvec3 kS = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness); \nvec3 kD = 1.0 - kS;\nvec3 irradiance = texture(irradianceMap, N).rgb;\nvec3 diffuse    = irradiance * albedo;\nvec3 ambient    = (kD * diffuse) * ao; \n```\n\n----------------------------------------\n\nTITLE: Initializing Mesh Buffers in OpenGL\nDESCRIPTION: Sets up vertex buffer objects (VBO), element buffer objects (EBO), and vertex array objects (VAO) for the mesh, including attribute pointers for vertex data.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/03 Model Loading/02 Mesh.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvoid setupMesh()\n{\n    glGenVertexArrays(1, &VAO);\n    glGenBuffers(1, &VBO);\n    glGenBuffers(1, &EBO);\n  \n    glBindVertexArray(VAO);\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);\n\n    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), &vertices[0], GL_STATIC_DRAW);  \n\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), \n                 &indices[0], GL_STATIC_DRAW);\n\n    // 顶点位置\n    glEnableVertexAttribArray(0);\t\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);\n    // 顶点法线\n    glEnableVertexAttribArray(1);\t\n    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Normal));\n    // 顶点纹理坐标\n    glEnableVertexAttribArray(2);\t\n    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, TexCoords));\n\n    glBindVertexArray(0);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Allocating Memory for a Uniform Buffer Object in C++\nDESCRIPTION: Demonstrates how to create a Uniform Buffer Object in OpenGL using C++. It generates a buffer, binds it to the GL_UNIFORM_BUFFER target, and allocates memory for it.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/08 Advanced GLSL.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nunsigned int uboExampleBlock;\nglGenBuffers(1, &uboExampleBlock);\nglBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock);\nglBufferData(GL_UNIFORM_BUFFER, 152, NULL, GL_STATIC_DRAW); // 分配152字节的内存\nglBindBuffer(GL_UNIFORM_BUFFER, 0);\n```\n\n----------------------------------------\n\nTITLE: Updating Vertex Shader to Handle Normal Vectors\nDESCRIPTION: Vertex shader code that processes vertex position and normal data, transforming the position to clip space and passing the normal vector to the fragment shader for lighting calculations.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/02 Basic Lighting.md#2025-04-22_snippet_1\n\nLANGUAGE: glsl\nCODE:\n```\nout vec3 Normal;\n\nvoid main()\n{\n    gl_Position = projection * view * model * vec4(aPos, 1.0);\n    Normal = aNormal;\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Projection Matrix in Uniform Buffer Object in C++\nDESCRIPTION: Shows how to update the projection matrix in a Uniform Buffer Object using glBufferSubData function in C++.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/08 Advanced GLSL.md#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nglm::mat4 projection = glm::perspective(glm::radians(45.0f), (float)width/(float)height, 0.1f, 100.0f);\nglBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);\nglBufferSubData(GL_UNIFORM_BUFFER, 0, sizeof(glm::mat4), glm::value_ptr(projection));\nglBindBuffer(GL_UNIFORM_BUFFER, 0);\n```\n\n----------------------------------------\n\nTITLE: Spotlight Structure in GLSL Fragment Shader\nDESCRIPTION: GLSL structure for a spotlight that includes position, direction, and cutoff angle. This enables creation of a cone-shaped light that only illuminates objects within a specific angle.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/05 Light casters.md#2025-04-22_snippet_7\n\nLANGUAGE: GLSL\nCODE:\n```\nstruct Light {\n    vec3  position;\n    vec3  direction;\n    float cutOff;\n    ...\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering a Skybox in OpenGL\nDESCRIPTION: This code demonstrates the rendering process for a skybox. It disables depth writing before rendering, uses the skybox shader, binds the cubemap texture, and draws the skybox cube.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/06 Cubemaps.md#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nglDepthMask(GL_FALSE);\nskyboxShader.use();\n// ... 设置观察和投影矩阵\nglBindVertexArray(skyboxVAO);\nglBindTexture(GL_TEXTURE_CUBE_MAP, cubemapTexture);\nglDrawArrays(GL_TRIANGLES, 0, 36);\nglDepthMask(GL_TRUE);\n// ... 绘制剩下的场景\n```\n\n----------------------------------------\n\nTITLE: Implementing Spotlight Effect in GLSL Fragment Shader\nDESCRIPTION: GLSL code that implements a spotlight by calculating the angle between the light direction and the fragment-to-light vector, applying lighting only when the fragment is within the spotlight's cone.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/05 Light casters.md#2025-04-22_snippet_9\n\nLANGUAGE: GLSL\nCODE:\n```\nfloat theta = dot(lightDir, normalize(-light.direction));\n    \nif(theta > light.cutOff) \n{       \n  // 执行光照计算\n}\nelse  // 否则，使用环境光，让场景在聚光之外时不至于完全黑暗\n  color = vec4(light.ambient * vec3(texture(material.diffuse, TexCoords)), 1.0);\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader with Color Input\nDESCRIPTION: A fragment shader that receives a color input from the vertex shader and uses it as the output color.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/05 Shaders.md#2025-04-22_snippet_10\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout vec4 FragColor;  \nin vec3 ourColor;\n  \nvoid main()\n{\n    FragColor = vec4(ourColor, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: HDR Rendering Pipeline in OpenGL\nDESCRIPTION: This code shows the two-pass rendering technique for HDR. First rendering the scene to a floating-point framebuffer, then rendering that buffer to a screen-filling quad for tone mapping.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/06 HDR.md#2025-04-22_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nglBindFramebuffer(GL_FRAMEBUFFER, hdrFBO);\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  \n    // [...] 渲染(光照的)场景\nglBindFramebuffer(GL_FRAMEBUFFER, 0);\n\n// 现在使用一个不同的着色器将HDR颜色缓冲渲染至2D铺屏四边形上\nhdrShader.Use();\nglActiveTexture(GL_TEXTURE0);\nglBindTexture(GL_TEXTURE_2D, hdrColorBufferTexture);\nRenderQuad();\n```\n\n----------------------------------------\n\nTITLE: Vertex Shader for Point Shadow Mapping\nDESCRIPTION: A simple vertex shader for point shadow mapping that transforms vertices to world space. The vertices will later be transformed to different light spaces by the geometry shader.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/02 Point Shadows.md#2025-04-22_snippet_8\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (location = 0) in vec3 position;\n \nuniform mat4 model;\n \nvoid main()\n{\n    gl_Position = model * vec4(position, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Binding UBO to a Binding Point in C++\nDESCRIPTION: Demonstrates how to bind a Uniform Buffer Object to a specific binding point using either glBindBufferBase or glBindBufferRange functions in C++.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/08 Advanced GLSL.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nglBindBufferBase(GL_UNIFORM_BUFFER, 2, uboExampleBlock); \n// 或\nglBindBufferRange(GL_UNIFORM_BUFFER, 2, uboExampleBlock, 0, 152);\n```\n\n----------------------------------------\n\nTITLE: Drawing Mesh with Textures in OpenGL\nDESCRIPTION: Implements the Draw function for rendering the mesh, including texture binding and uniform setting based on a naming convention for diffuse and specular textures.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/03 Model Loading/02 Mesh.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvoid Draw(Shader shader) \n{\n    unsigned int diffuseNr = 1;\n    unsigned int specularNr = 1;\n    for(unsigned int i = 0; i < textures.size(); i++)\n    {\n        glActiveTexture(GL_TEXTURE0 + i); // 在绑定之前激活相应的纹理单元\n        // 获取纹理序号（diffuse_textureN 中的 N）\n        string number;\n        string name = textures[i].type;\n        if(name == \"texture_diffuse\")\n            number = std::to_string(diffuseNr++);\n        else if(name == \"texture_specular\")\n            number = std::to_string(specularNr++);\n\n        shader.setInt((\"material.\" + name + number).c_str(), i);\n        glBindTexture(GL_TEXTURE_2D, textures[i].id);\n    }\n    glActiveTexture(GL_TEXTURE0);\n\n    // 绘制网格\n    glBindVertexArray(VAO);\n    glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, 0);\n    glBindVertexArray(0);\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Point Light Contribution in GLSL\nDESCRIPTION: Function to calculate the contribution of a point light source including attenuation. It processes the light's position relative to the fragment, calculates attenuation based on distance, and combines ambient, diffuse, and specular components.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/06 Multiple lights.md#2025-04-22_snippet_4\n\nLANGUAGE: GLSL\nCODE:\n```\nvec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)\n{\n    vec3 lightDir = normalize(light.position - fragPos);\n    // 漫反射着色\n    float diff = max(dot(normal, lightDir), 0.0);\n    // 镜面光着色\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n    // 衰减\n    float distance    = length(light.position - fragPos);\n    float attenuation = 1.0 / (light.constant + light.linear * distance + \n  \t\t\t     light.quadratic * (distance * distance));    \n    // 合并结果\n    vec3 ambient  = light.ambient  * vec3(texture(material.diffuse, TexCoords));\n    vec3 diffuse  = light.diffuse  * diff * vec3(texture(material.diffuse, TexCoords));\n    vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));\n    ambient  *= attenuation;\n    diffuse  *= attenuation;\n    specular *= attenuation;\n    return (ambient + diffuse + specular);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Van Der Corput Sequence in GLSL\nDESCRIPTION: GLSL function to generate the Van Der Corput sequence, used as part of the Hammersley sequence for low-discrepancy sampling.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/03 IBL/02 Specular IBL.md#2025-04-22_snippet_2\n\nLANGUAGE: GLSL\nCODE:\n```\nfloat RadicalInverse_VdC(uint bits) \n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Trowbridge-Reitz GGX Normal Distribution Function\nDESCRIPTION: GLSL implementation of the Normal Distribution Function (NDF) using Trowbridge-Reitz GGX model. Takes normal vector, half vector and roughness as inputs to calculate microfacet distribution.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/01 Theory.md#2025-04-22_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\nfloat D_GGX_TR(vec3 N, vec3 H, float a)\n{\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom        = PI * denom * denom;\n\n    return nom / denom;\n}\n```\n\n----------------------------------------\n\nTITLE: Ping-Pong Blurring Implementation (C++)\nDESCRIPTION: C++ code implementing ping-pong rendering to apply multiple passes of Gaussian blur to the extracted bright areas.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/07 Bloom.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nGLboolean horizontal = true, first_iteration = true;\nGLuint amount = 10;\nshaderBlur.Use();\nfor (GLuint i = 0; i < amount; i++)\n{\n    glBindFramebuffer(GL_FRAMEBUFFER, pingpongFBO[horizontal]); \n    glUniform1i(glGetUniformLocation(shaderBlur.Program, \"horizontal\"), horizontal);\n    glBindTexture(\n        GL_TEXTURE_2D, first_iteration ? colorBuffers[1] : pingpongBuffers[!horizontal]\n    ); \n    RenderQuad();\n    horizontal = !horizontal;\n    if (first_iteration)\n        first_iteration = false;\n}\nglBindFramebuffer(GL_FRAMEBUFFER, 0);\n```\n\n----------------------------------------\n\nTITLE: Calculating Camera Direction Vector\nDESCRIPTION: Calculates the camera's direction vector by normalizing the difference between camera position and target position.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/09 Camera.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nglm::vec3 cameraTarget = glm::vec3(0.0f, 0.0f, 0.0f);\nglm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget);\n```\n\n----------------------------------------\n\nTITLE: Basic Shadow Calculation Function in GLSL\nDESCRIPTION: Function for shadow calculation that performs perspective division, transforms coordinates to texture space, and compares current depth with the depth from shadow map to determine if a fragment is in shadow.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/01 Shadow Mapping.md#2025-04-22_snippet_2\n\nLANGUAGE: GLSL\nCODE:\n```\nfloat ShadowCalculation(vec4 fragPosLightSpace)\n{\n    // 执行透视除法\n    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;\n    // 变换到[0,1]的范围\n    projCoords = projCoords * 0.5 + 0.5;\n    // 取得最近点的深度(使用[0,1]范围下的fragPosLight当坐标)\n    float closestDepth = texture(shadowMap, projCoords.xy).r; \n    // 取得当前片段在光源视角下的深度\n    float currentDepth = projCoords.z;\n    // 检查当前片段是否在阴影中\n    float shadow = currentDepth > closestDepth  ? 1.0 : 0.0;\n \n    return shadow;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Time-based Rotation and Translation in C++\nDESCRIPTION: Shows how to create a transformation matrix that combines rotation based on time and translation, updated each frame.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/07 Transformations.md#2025-04-22_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nglm::mat4 trans;\ntrans = glm::translate(trans, glm::vec3(0.5f, -0.5f, 0.0f));\ntrans = glm::rotate(trans, (float)glfwGetTime(), glm::vec3(0.0f, 0.0f, 1.0f));\n```\n\n----------------------------------------\n\nTITLE: Instanced Rendering Draw Call in C++\nDESCRIPTION: Performs instanced rendering of asteroids using glDrawElementsInstanced for improved performance.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/10 Instancing.md#2025-04-22_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\n// 绘制小行星\ninstanceShader.use();\nfor(unsigned int i = 0; i < rock.meshes.size(); i++)\n{\n    glBindVertexArray(rock.meshes[i].VAO);\n    glDrawElementsInstanced(\n        GL_TRIANGLES, rock.meshes[i].indices.size(), GL_UNSIGNED_INT, 0, amount\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Calculation of Tangent and Bitangent Vectors in C++\nDESCRIPTION: Code that demonstrates how to manually calculate tangent and bitangent vectors for a triangle using vertex positions and texture coordinates. These vectors are essential for constructing the TBN matrix used in normal mapping.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/04 Normal Mapping.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n// positions\nglm::vec3 pos1(-1.0,  1.0, 0.0);\nglm::vec3 pos2(-1.0, -1.0, 0.0);\nglm::vec3 pos3(1.0, -1.0, 0.0);\nglm::vec3 pos4(1.0, 1.0, 0.0);\n// texture coordinates\nglm::vec2 uv1(0.0, 1.0);\nglm::vec2 uv2(0.0, 0.0);\nglm::vec2 uv3(1.0, 0.0);\nglm::vec2 uv4(1.0, 1.0);\n// normal vector\nglm::vec3 nm(0.0, 0.0, 1.0);\n```\n\n----------------------------------------\n\nTITLE: Instanced Rendering Setup in C++\nDESCRIPTION: Configures vertex attributes and buffers for instanced rendering of asteroids using instance matrices.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/10 Instancing.md#2025-04-22_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nunsigned int buffer;\nglGenBuffers(1, &buffer);\nglBindBuffer(GL_ARRAY_BUFFER, buffer);\nglBufferData(GL_ARRAY_BUFFER, amount * sizeof(glm::mat4), &modelMatrices[0], GL_STATIC_DRAW);\n  \nfor(unsigned int i = 0; i < rock.meshes.size(); i++)\n{\n    unsigned int VAO = rock.meshes[i].VAO;\n    glBindVertexArray(VAO);\n    // 顶点属性\n    GLsizei vec4Size = sizeof(glm::vec4);\n    glEnableVertexAttribArray(3); \n    glVertexAttribPointer(3, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)0);\n    glEnableVertexAttribArray(4); \n    glVertexAttribPointer(4, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)(1 * vec4Size));\n    glEnableVertexAttribArray(5); \n    glVertexAttribPointer(5, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)(2 * vec4Size));\n    glEnableVertexAttribArray(6); \n    glVertexAttribPointer(6, 4, GL_FLOAT, GL_FALSE, 4 * vec4Size, (void*)(3 * vec4Size));\n\n    glVertexAttribDivisor(3, 1);\n    glVertexAttribDivisor(4, 1);\n    glVertexAttribDivisor(5, 1);\n    glVertexAttribDivisor(6, 1);\n\n    glBindVertexArray(0);\n}\n```\n\n----------------------------------------\n\nTITLE: Instanced Vertex Shader with Uniform Offsets\nDESCRIPTION: Vertex shader that uses gl_InstanceID to offset instances using a uniform array\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/10 Instancing.md#2025-04-22_snippet_3\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (location = 0) in vec2 aPos;\nlayout (location = 1) in vec3 aColor;\n\nout vec3 fColor;\n\nuniform vec2 offsets[100];\n\nvoid main()\n{\n    vec2 offset = offsets[gl_InstanceID];\n    gl_Position = vec4(aPos + offset, 0.0, 1.0);\n    fColor = aColor;\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Skeletal Animation in OpenGL Rendering Loop\nDESCRIPTION: Demonstrates how to use the Animation and Animator classes in the main rendering loop. It loads the model and animation, updates the animation each frame, and passes bone matrices to the shader for rendering.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/08 Guest Articles/2020/01 Skeletal Animation.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nint main()\n{\n    ...\n\t\n    Model ourModel(FileSystem::getPath(\"resources/objects/vampire/dancing_vampire.dae\"));\n    Animation danceAnimation(FileSystem::getPath(\"resources/objects/vampire/dancing_vampire.dae\"),\n        &ourModel);\n    Animator animator(&danceAnimation);\n\n    // draw in wireframe\n    //glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);\n\n    // render loop\n    // -----------\n    while (!glfwWindowShouldClose(window))\n    {\n        // per-frame time logic\n        // --------------------\n        float currentFrame = glfwGetTime();\n        deltaTime = currentFrame - lastFrame;\n        lastFrame = currentFrame;\n\n        // input\n        // -----\n        processInput(window);\n        animator.UpdateAnimation(deltaTime);\n\t\t\n        // render\n        // ------\n        glClearColor(0.05f, 0.05f, 0.05f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n        // don't forget to enable shader before setting uniforms\n        ourShader.use();\n\n        // view/projection transformations\n        glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), \n            (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);\n        glm::mat4 view = camera.GetViewMatrix();\n        ourShader.setMat4(\"projection\", projection);\n        ourShader.setMat4(\"view\", view);\n\n        auto transforms = animator.GetFinalBoneMatrices();\n        for (int i = 0; i < transforms.size(); ++i)\n            ourShader.setMat4(\"finalBonesMatrices[\" + std::to_string(i) + \"]\", transforms[i]);\n\n        // render the loaded model\n        glm::mat4 model = glm::mat4(1.0f);\n        // translate it down so it's at the center of the scene\n        model = glm::translate(model, glm::vec3(0.0f, -0.4f, 0.0f)); \n        // it's a bit too big for our scene, so scale it down\n        model = glm::scale(model, glm::vec3(.5f, .5f, .5f));\t\n        ourShader.setMat4(\"model\", model);\n        ourModel.Draw(ourShader);\n\n        // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)\n        // -------------------------------------------------------------------------------\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n    }\n\n    // glfw: terminate, clearing all previously allocated GLFW resources.\n    // ------------------------------------------------------------------\n    glfwTerminate();\n    return 0;\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader for Colored Object in GLSL\nDESCRIPTION: Implements a fragment shader that calculates the final color of an object based on its color and the light color.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/01 Colors.md#2025-04-22_snippet_4\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\n  \nuniform vec3 objectColor;\nuniform vec3 lightColor;\n\nvoid main()\n{\n    FragColor = vec4(lightColor * objectColor, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Weighted Grayscale Effect in GLSL\nDESCRIPTION: A more perceptually accurate grayscale implementation that uses weighted color channels to account for human eye sensitivity to different colors. Green contributes most to perceived brightness, while blue contributes least.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/05 Framebuffers.md#2025-04-22_snippet_1\n\nLANGUAGE: GLSL\nCODE:\n```\nvoid main()\n{\n    FragColor = texture(screenTexture, TexCoords);\n    float average = 0.2126 * FragColor.r + 0.7152 * FragColor.g + 0.0722 * FragColor.b;\n    FragColor = vec4(average, average, average, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Framebuffer Texture in C++ OpenGL\nDESCRIPTION: This code demonstrates how to display a framebuffer texture in the top-right corner of the screen for debugging purposes. It includes vertex and fragment shaders for rendering the texture.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/01 Debugging.md#2025-04-22_snippet_9\n\nLANGUAGE: GLSL\nCODE:\n```\n// Vertex shader\n#version 330 core\nlayout (location = 0) in vec2 position;\nlayout (location = 1) in vec2 texCoords;\n\nout vec2 TexCoords;\n\nvoid main()\n{\n    gl_Position = vec4(position, 0.0f, 1.0f);\n    TexCoords = texCoords;\n}\n\n// Fragment shader\n#version 330 core\nout vec4 FragColor;\nin  vec2 TexCoords;\n\nuniform sampler2D fboAttachment;\n\nvoid main()\n{\n    FragColor = texture(fboAttachment, TexCoords);\n}\n```\n\nLANGUAGE: C++\nCODE:\n```\nvoid DisplayFramebufferTexture(GLuint textureID)\n{\n    if(!notInitialized)\n    {\n        // Initialize shader and VAO with NDC vertices in top-right corner\n        [...]\n    }\n\n    glActiveTexture(GL_TEXTURE0);  \t\n    glUseProgram(shaderDisplayFBOOutput);\n        glBindTexture(GL_TEXTURE_2D, textureID);\n        glBindVertexArray(vaoDebugTexturedRect);\n            glDrawArrays(GL_TRIANGLES, 0, 6);\n        glBindVertexArray(0);\n    glUseProgram(0);\n}\n\nint main()\n{\n    [...]\n    while (!glfwWindowShouldClose(window))\n    {\n        [...]\n        DisplayFramebufferTexture(fboAttachment0);\n\n        glfwSwapBuffers(window);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Processing Vertex Normals from Assimp in C++\nDESCRIPTION: Code snippet for extracting vertex normal data from an Assimp mesh and converting it to the application's vector format.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/03 Model Loading/03 Model.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nvector.x = mesh->mNormals[i].x;\nvector.y = mesh->mNormals[i].y;\nvector.z = mesh->mNormals[i].z;\nvertex.Normal = vector;\n```\n\n----------------------------------------\n\nTITLE: Implementing Fresnel-Schlick Approximation\nDESCRIPTION: GLSL implementation of the Fresnel equation using Schlick's approximation. Calculates surface reflection ratio based on viewing angle and base reflectivity.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/01 Theory.md#2025-04-22_snippet_5\n\nLANGUAGE: c++\nCODE:\n```\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Skybox Vertex Shader in GLSL\nDESCRIPTION: This vertex shader for rendering a skybox passes the vertex position as texture coordinates and transforms the position with view and projection matrices. The position is used directly for cubemap sampling.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/06 Cubemaps.md#2025-04-22_snippet_6\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (location = 0) in vec3 aPos;\n\nout vec3 TexCoords;\n\nuniform mat4 projection;\nuniform mat4 view;\n\nvoid main()\n{\n    TexCoords = aPos;\n    gl_Position = projection * view * vec4(aPos, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Two-Phase Rendering for Point Light Shadows\nDESCRIPTION: The complete rendering process for point light shadows, consisting of two phases: first rendering the scene to the depth cubemap from the light's perspective, then rendering the scene normally using the depth cubemap for shadow calculations.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/02 Point Shadows.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\n// 1. first render to depth cubemap\nglViewport(0, 0, SHADOW_WIDTH, SHADOW_HEIGHT);\nglBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);\nglClear(GL_DEPTH_BUFFER_BIT);\nConfigureShaderAndMatrices();\nRenderScene();\nglBindFramebuffer(GL_FRAMEBUFFER, 0);\n// 2. then render scene as normal with shadow mapping (using depth cubemap)\nglViewport(0, 0, SCR_WIDTH, SCR_HEIGHT);\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\nConfigureShaderAndMatrices();\nglBindTexture(GL_TEXTURE_CUBE_MAP, depthCubemap);\nRenderScene();\n```\n\n----------------------------------------\n\nTITLE: Setting Material Properties in C++ Application Code\nDESCRIPTION: Sets the material properties for an object by setting uniform values in the shader. This example creates a material with a copper-like appearance by specifying appropriate ambient, diffuse, specular colors and shininess.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/03 Materials.md#2025-04-22_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\nlightingShader.setVec3(\"material.ambient\",  1.0f, 0.5f, 0.31f);\nlightingShader.setVec3(\"material.diffuse\",  1.0f, 0.5f, 0.31f);\nlightingShader.setVec3(\"material.specular\", 0.5f, 0.5f, 0.5f);\nlightingShader.setFloat(\"material.shininess\", 32.0f);\n```\n\n----------------------------------------\n\nTITLE: Calculating Specular and Diffuse Components in GLSL\nDESCRIPTION: Demonstrates how to calculate the specular and diffuse components of light reflection while preserving energy conservation.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/01 Theory.md#2025-04-22_snippet_0\n\nLANGUAGE: GLSL\nCODE:\n```\nfloat kS = calculateSpecularComponent(...); // 反射/镜面 部分\nfloat kD = 1.0 - ks;                        // 折射/漫反射 部分\n```\n\n----------------------------------------\n\nTITLE: Creating and Configuring Cubemap Texture in C++\nDESCRIPTION: This C++ code generates and sets up the cubemap texture for storing the converted environment map.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/03 IBL/01 Diffuse irradiance.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nunsigned int envCubemap;\nglGenTextures(1, &envCubemap);\nglBindTexture(GL_TEXTURE_CUBE_MAP, envCubemap);\nfor (unsigned int i = 0; i < 6; ++i)\n{\n    // note that we store each face with 16 bit floating point values\n    glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB16F, \n                 512, 512, 0, GL_RGB, GL_FLOAT, nullptr);\n}\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n```\n\n----------------------------------------\n\nTITLE: Processing Face Indices from Assimp in C++\nDESCRIPTION: Code snippet for extracting triangle indices from an Assimp mesh, where each face represents a triangle (due to the aiProcess_Triangulate option used during loading).\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/03 Model Loading/03 Model.md#2025-04-22_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nfor(unsigned int i = 0; i < mesh->mNumFaces; i++)\n{\n    aiFace face = mesh->mFaces[i];\n    for(unsigned int j = 0; j < face.mNumIndices; j++)\n        indices.push_back(face.mIndices[j]);\n}\n```\n\n----------------------------------------\n\nTITLE: Normal and View Vector Calculation in PBR Shader\nDESCRIPTION: This code calculates the normalized normal vector from the interpolated vertex normal, and the view vector from the camera position to the fragment position, which are essential inputs for PBR lighting calculations.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/02 Lighting.md#2025-04-22_snippet_2\n\nLANGUAGE: GLSL\nCODE:\n```\nvoid main()\n{\n    vec3 N = normalize(Normal); \n    vec3 V = normalize(camPos - WorldPos);\n    [...]\n}\n```\n\n----------------------------------------\n\nTITLE: Generating View Matrices for Each Cubemap Face\nDESCRIPTION: Creating six different view matrices for rendering to each face of a cubemap for point light shadows. Each matrix looks in one of the six cardinal directions (right, left, up, down, forward, backward) from the light position.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/02 Point Shadows.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nstd::vector<glm::mat4> shadowTransforms;\nshadowTransforms.push_back(shadowProj * \n                 glm::lookAt(lightPos, lightPos + glm::vec3(1.0,0.0,0.0), glm::vec3(0.0,-1.0,0.0)));\nshadowTransforms.push_back(shadowProj * \n                 glm::lookAt(lightPos, lightPos + glm::vec3(-1.0,0.0,0.0), glm::vec3(0.0,-1.0,0.0)));\nshadowTransforms.push_back(shadowProj * \n                 glm::lookAt(lightPos, lightPos + glm::vec3(0.0,1.0,0.0), glm::vec3(0.0,0.0,1.0)));\nshadowTransforms.push_back(shadowProj * \n                 glm::lookAt(lightPos, lightPos + glm::vec3(0.0,-1.0,0.0), glm::vec3(0.0,0.0,-1.0)));\nshadowTransforms.push_back(shadowProj * \n                 glm::lookAt(lightPos, lightPos + glm::vec3(0.0,0.0,1.0), glm::vec3(0.0,-1.0,0.0)));\nshadowTransforms.push_back(shadowProj * \n                 glm::lookAt(lightPos, lightPos + glm::vec3(0.0,0.0,-1.0), glm::vec3(0.0,-1.0,0.0)));\n```\n\n----------------------------------------\n\nTITLE: Setting Up Light Colors with High Intensity Values in OpenGL\nDESCRIPTION: This snippet shows how to define light colors with intensity values beyond 1.0, which is possible in HDR rendering. The first light has a very high intensity of 200.0 for each color component.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/06 HDR.md#2025-04-22_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\nstd::vector<glm::vec3> lightColors;\nlightColors.push_back(glm::vec3(200.0f, 200.0f, 200.0f));\nlightColors.push_back(glm::vec3(0.1f, 0.0f, 0.0f));\nlightColors.push_back(glm::vec3(0.0f, 0.0f, 0.2f));\nlightColors.push_back(glm::vec3(0.0f, 0.1f, 0.0f));\n```\n\n----------------------------------------\n\nTITLE: Setting Blend Function for Standard Alpha Blending\nDESCRIPTION: Configures the blend function to use source alpha for the source factor and one minus source alpha for the destination factor, which produces standard transparent blending effects.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/03 Blending.md#2025-04-22_snippet_6\n\nLANGUAGE: c++\nCODE:\n```\nglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n```\n\n----------------------------------------\n\nTITLE: Loading a 3D Model with Assimp in C++\nDESCRIPTION: Implementation of the loadModel method that uses Assimp to load a 3D model from a file, with post-processing options to triangulate the model and flip UV coordinates.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/03 Model Loading/03 Model.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvoid loadModel(string path)\n{\n    Assimp::Importer import;\n    const aiScene *scene = import.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs);\t\n\n    if(!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode) \n    {\n        cout << \"ERROR::ASSIMP::\" << import.GetErrorString() << endl;\n        return;\n    }\n    directory = path.substr(0, path.find_last_of('/'));\n\n    processNode(scene->mRootNode, scene);\n}\n```\n\n----------------------------------------\n\nTITLE: Shadow Bias Implementation in GLSL\nDESCRIPTION: Implementation of shadow bias to fix shadow acne artifacts. Applies a small depth offset to prevent incorrect shadow determination caused by depth map resolution limitations.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/01 Shadow Mapping.md#2025-04-22_snippet_3\n\nLANGUAGE: GLSL\nCODE:\n```\nfloat bias = 0.005;\nfloat shadow = currentDepth - bias > closestDepth  ? 1.0 : 0.0;\n```\n\n----------------------------------------\n\nTITLE: Filtering OpenGL Debug Output in C++\nDESCRIPTION: Demonstrates how to filter OpenGL debug output to only show specific types of messages, such as high severity errors from the API.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/01 Debugging.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nglDebugMessageControl(GL_DEBUG_SOURCE_API, \n                      GL_DEBUG_TYPE_ERROR, \n                      GL_DEBUG_SEVERITY_HIGH,\n                      0, nullptr, GL_TRUE); \n```\n\n----------------------------------------\n\nTITLE: Implementing Simple Grayscale Effect in GLSL\nDESCRIPTION: A fragment shader implementation that converts a colored image to grayscale by averaging the RGB color components. This provides a basic grayscale effect but doesn't account for human eye sensitivity to different colors.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/05 Framebuffers.md#2025-04-22_snippet_0\n\nLANGUAGE: GLSL\nCODE:\n```\nvoid main()\n{\n    FragColor = texture(screenTexture, TexCoords);\n    float average = (FragColor.r + FragColor.g + FragColor.b) / 3.0;\n    FragColor = vec4(average, average, average, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Multiple Color Attachments (C++)\nDESCRIPTION: C++ code to set up a framebuffer with two color attachments for rendering the scene and extracting bright areas simultaneously.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/07 Bloom.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nGLuint hdrFBO;\nglGenFramebuffers(1, &hdrFBO);\nglBindFramebuffer(GL_FRAMEBUFFER, hdrFBO);\nGLuint colorBuffers[2];\nglGenTextures(2, colorBuffers);\nfor (GLuint i = 0; i < 2; i++)\n{\n    glBindTexture(GL_TEXTURE_2D, colorBuffers[i]);\n    glTexImage2D(\n        GL_TEXTURE_2D, 0, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_FLOAT, NULL\n    );\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n    // attach texture to framebuffer\n    glFramebufferTexture2D(\n        GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + i, GL_TEXTURE_2D, colorBuffers[i], 0\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Reflection in Vertex Shader (GLSL)\nDESCRIPTION: This vertex shader calculates the world-space normal and position for use in the fragment shader's reflection calculations.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/06 Cubemaps.md#2025-04-22_snippet_12\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (location = 0) in vec3 aPos;\nlayout (location = 1) in vec3 aNormal;\n\nout vec3 Normal;\nout vec3 Position;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\n\nvoid main()\n{\n    Normal = mat3(transpose(inverse(model))) * aNormal;\n    Position = vec3(model * vec4(aPos, 1.0));\n    gl_Position = projection * view * model * vec4(aPos, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Light Position Uniform in C++\nDESCRIPTION: C++ code for passing the light source position to the shader program as a uniform variable. This allows the shader to calculate the light direction for each fragment.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/02 Basic Lighting.md#2025-04-22_snippet_7\n\nLANGUAGE: c++\nCODE:\n```\nlightingShader.setVec3(\"lightPos\", lightPos);\n```\n\n----------------------------------------\n\nTITLE: Resource Manager Usage Example in C++\nDESCRIPTION: Demonstration of how to use the ResourceManager class to load and access shader resources. The example shows both direct usage after loading and retrieval of previously loaded resources by name.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/02 Setting up.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nShader shader = ResourceManager::LoadShader(\"vertex.vs\", \"fragment.vs\", nullptr, \"test\");\n// 接下来使用它\nshader.Use();\n// 或者\nResourceManager::GetShader(\"test\").Use();\n```\n\n----------------------------------------\n\nTITLE: Point Light Structure with Attenuation Parameters in GLSL\nDESCRIPTION: GLSL structure for a point light that includes position, color components (ambient, diffuse, specular), and attenuation parameters (constant, linear, quadratic) to calculate light falloff with distance.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/05 Light casters.md#2025-04-22_snippet_3\n\nLANGUAGE: GLSL\nCODE:\n```\nstruct Light {\n    vec3 position;  \n  \n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n\t\n    float constant;\n    float linear;\n    float quadratic;\n};\n```\n\n----------------------------------------\n\nTITLE: Processing Vertex Positions from Assimp in C++\nDESCRIPTION: Code snippet for extracting vertex position data from an Assimp mesh and converting it to the application's vector format.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/03 Model Loading/03 Model.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nglm::vec3 vector; \nvector.x = mesh->mVertices[i].x;\nvector.y = mesh->mVertices[i].y;\nvector.z = mesh->mVertices[i].z; \nvertex.Position = vector;\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader with Blinn-Phong Lighting and Shadow Calculation\nDESCRIPTION: Fragment shader implementing Blinn-Phong lighting model with omnidirectional shadow mapping.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/02 Point Shadows.md#2025-04-22_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\n\nin VS_OUT {\n    vec3 FragPos;\n    vec3 Normal;\n    vec2 TexCoords;\n} fs_in;\n\nuniform sampler2D diffuseTexture;\nuniform samplerCube depthMap;\n\nuniform vec3 lightPos;\nuniform vec3 viewPos;\n\nuniform float far_plane;\n\nfloat ShadowCalculation(vec3 fragPos)\n{\n    [...]\n}\n\nvoid main()\n{           \n    vec3 color = texture(diffuseTexture, fs_in.TexCoords).rgb;\n    vec3 normal = normalize(fs_in.Normal);\n    vec3 lightColor = vec3(0.3);\n    // Ambient\n    vec3 ambient = 0.3 * color;\n    // Diffuse\n    vec3 lightDir = normalize(lightPos - fs_in.FragPos);\n    float diff = max(dot(lightDir, normal), 0.0);\n    vec3 diffuse = diff * lightColor;\n    // Specular\n    vec3 viewDir = normalize(viewPos - fs_in.FragPos);\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = 0.0;\n    vec3 halfwayDir = normalize(lightDir + viewDir);  \n    spec = pow(max(dot(normal, halfwayDir), 0.0), 64.0);\n    vec3 specular = spec * lightColor;    \n    // Calculate shadow\n    float shadow = ShadowCalculation(fs_in.FragPos);                      \n    vec3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * color;    \n    \n    FragColor = vec4(lighting, 1.0f);\n}\n```\n\n----------------------------------------\n\nTITLE: Computing Camera Right Vector\nDESCRIPTION: Calculates the camera's right vector using cross product between a temporary up vector and the camera direction.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/09 Camera.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nglm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f);\nglm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));\n```\n\n----------------------------------------\n\nTITLE: Removing Translation from View Matrix for Skybox\nDESCRIPTION: This code removes the translation component from the view matrix to ensure the skybox remains centered around the viewer, creating the illusion of infinite distance.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/06 Cubemaps.md#2025-04-22_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nglm::mat4 view = glm::mat4(glm::mat3(camera.GetViewMatrix()));\n```\n\n----------------------------------------\n\nTITLE: Setting Attenuation Parameters for Point Light in OpenGL\nDESCRIPTION: Code that sets the constant, linear, and quadratic attenuation parameters for a point light in OpenGL. These values control how light intensity decreases with distance from the light source.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/05 Light casters.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nlightingShader.setFloat(\"light.constant\",  1.0f);\nlightingShader.setFloat(\"light.linear\",    0.09f);\nlightingShader.setFloat(\"light.quadratic\", 0.032f);\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader for Depth Calculation in Point Shadow Mapping\nDESCRIPTION: A fragment shader that calculates custom depth values for point shadow mapping. It computes the linear distance between each fragment and the light source, normalizing it by the far plane distance to fit within the [0,1] range for depth values.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/02 Point Shadows.md#2025-04-22_snippet_10\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nin vec4 FragPos;\n\nuniform vec3 lightPos;\nuniform float far_plane;\n\nvoid main()\n{\n    // get distance between fragment and light source\n    float lightDistance = length(FragPos.xyz - lightPos);\n    \n    // map to [0;1] range by dividing by far_plane\n    lightDistance = lightDistance / far_plane;\n    \n    // write this as modified depth\n    gl_FragDepth = lightDistance;\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Surface Normal in Geometry Shader (GLSL)\nDESCRIPTION: This function calculates the surface normal of a triangle using cross product of two edge vectors.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/09 Geometry Shader.md#2025-04-22_snippet_7\n\nLANGUAGE: GLSL\nCODE:\n```\nvec3 GetNormal()\n{\n   vec3 a = vec3(gl_in[0].gl_Position) - vec3(gl_in[1].gl_Position);\n   vec3 b = vec3(gl_in[2].gl_Position) - vec3(gl_in[1].gl_Position);\n   return normalize(cross(a, b));\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Vegetation Quads with Textures\nDESCRIPTION: Renders a series of textured quads at predefined positions to create vegetation in the scene. This code binds the VAO and grass texture, then creates and applies a model matrix for each position.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/03 Blending.md#2025-04-22_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\nglBindVertexArray(vegetationVAO);\nglBindTexture(GL_TEXTURE_2D, grassTexture);  \nfor(unsigned int i = 0; i < vegetation.size(); i++) \n{\n    model = glm::mat4(1.0f);\n    model = glm::translate(model, vegetation[i]);\t\t\t\t\n    shader.setMat4(\"model\", model);\n    glDrawArrays(GL_TRIANGLES, 0, 6);\n}\n```\n\n----------------------------------------\n\nTITLE: Normal Mapping Transformation\nDESCRIPTION: Transforms the sampled normal from tangent space to world space.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/04 Normal Mapping.md#2025-04-22_snippet_9\n\nLANGUAGE: GLSL\nCODE:\n```\nnormal = texture(normalMap, fs_in.TexCoords).rgb;\nnormal = normalize(normal * 2.0 - 1.0);   \nnormal = normalize(fs_in.TBN * normal);\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader Using Texture Alpha Channel\nDESCRIPTION: A simple fragment shader that samples a texture and uses all four color components (including alpha) as the output color. This is required when working with textures that have transparency.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/03 Blending.md#2025-04-22_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nvoid main()\n{\n    // FragColor = vec4(vec3(texture(texture1, TexCoords)), 1.0);\n    FragColor = texture(texture1, TexCoords);\n}\n```\n\n----------------------------------------\n\nTITLE: Vertex Shader with Position and Color Attributes\nDESCRIPTION: A vertex shader that accepts both position and color as vertex attributes and passes the color to the fragment shader.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/05 Shaders.md#2025-04-22_snippet_9\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (location = 0) in vec3 aPos;   // 位置变量的属性位置值为 0 \nlayout (location = 1) in vec3 aColor; // 颜色变量的属性位置值为 1\n  \nout vec3 ourColor; // 向片段着色器输出一个颜色\n\nvoid main()\n{\n    gl_Position = vec4(aPos, 1.0);\n    ourColor = aColor; // 将ourColor设置为我们从顶点数据那里得到的输入颜色\n}\n```\n\n----------------------------------------\n\nTITLE: Positioning Light Source in OpenGL\nDESCRIPTION: Sets the position of the light source in the 3D scene and scales it down.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/01 Colors.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nglm::vec3 lightPos(1.2f, 1.0f, 2.0f);\n\nmodel = glm::mat4();\nmodel = glm::translate(model, lightPos);\nmodel = glm::scale(model, glm::vec3(0.2f));\n```\n\n----------------------------------------\n\nTITLE: Determining Collision Direction in C++\nDESCRIPTION: Function to determine the direction of collision between two vectors using dot product calculations.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/05 Collisions/03 Collision resolution.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nDirection VectorDirection(glm::vec2 target)\n{\n    glm::vec2 compass[] = {\n        glm::vec2(0.0f, 1.0f),\t// 上\n        glm::vec2(1.0f, 0.0f),\t// 右\n        glm::vec2(0.0f, -1.0f),\t// 下\n        glm::vec2(-1.0f, 0.0f)\t// 左\n    };\n    GLfloat max = 0.0f;\n    GLuint best_match = -1;\n    for (GLuint i = 0; i < 4; i++)\n    {\n        GLfloat dot_product = glm::dot(glm::normalize(target), compass[i]);\n        if (dot_product > max)\n        {\n            max = dot_product;\n            best_match = i;\n        }\n    }\n    return (Direction)best_match;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Floating-Point Framebuffer Texture for HDR in OpenGL\nDESCRIPTION: This snippet demonstrates how to create a floating-point texture for a framebuffer to store HDR color values. Using GL_RGB16F format allows storing color values beyond the traditional 0.0-1.0 range.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/06 HDR.md#2025-04-22_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\nglBindTexture(GL_TEXTURE_2D, colorBuffer);\nglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_FLOAT, NULL);\n```\n\n----------------------------------------\n\nTITLE: Complete Transparency Setup with Blending\nDESCRIPTION: Enables blending and sets up the standard blend function for rendering semi-transparent textures. This is the initialization code needed before rendering transparent objects.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/03 Blending.md#2025-04-22_snippet_8\n\nLANGUAGE: c++\nCODE:\n```\nglEnable(GL_BLEND);\nglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n```\n\n----------------------------------------\n\nTITLE: Defining Vertex and Texture Structures in C++\nDESCRIPTION: Defines structures for vertex data (position, normal, texture coordinates) and texture information (ID and type) used in the Mesh class.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/03 Model Loading/02 Mesh.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nstruct Vertex {\n    glm::vec3 Position;\n    glm::vec3 Normal;\n    glm::vec2 TexCoords;\n};\n\nstruct Texture {\n    unsigned int id;\n    string type;\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing OpenGL Debug Output in C++\nDESCRIPTION: Shows how to initialize OpenGL debug output after confirming debug context support. Enables debug output, sets the callback function, and configures message control.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/01 Debugging.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nif (flags & GL_CONTEXT_FLAG_DEBUG_BIT)\n{\n    glEnable(GL_DEBUG_OUTPUT);\n    glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS); \n    glDebugMessageCallback(glDebugOutput, nullptr);\n    glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, 0, nullptr, GL_TRUE);\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Skybox Texture Paths\nDESCRIPTION: This code snippet shows how to set up the texture paths for the six faces of a skybox cubemap in the correct order. The order matches the OpenGL cubemap face enum values.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/06 Cubemaps.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nvector<std::string> faces\n{\n    \"right.jpg\",\n    \"left.jpg\",\n    \"top.jpg\",\n    \"bottom.jpg\",\n    \"front.jpg\",\n    \"back.jpg\"\n};\nunsigned int cubemapTexture = loadCubemap(faces);\n```\n\n----------------------------------------\n\nTITLE: AABB-Circle Collision Detection in C++\nDESCRIPTION: Function to check collision between a ball object and a game object, returning a Collision tuple.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/05 Collisions/03 Collision resolution.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nCollision CheckCollision(BallObject &one, GameObject &two) // AABB - AABB 碰撞\n{\n    [...]\n    if (glm::length(difference) <= one.Radius)\n        return std::make_tuple(GL_TRUE, VectorDirection(difference), difference);\n    else\n        return std::make_tuple(GL_FALSE, UP, glm::vec2(0, 0));\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Collisions and Activating PowerUps in C++\nDESCRIPTION: Updates the DoCollisions function to check for collisions between the player paddle and powerups, activating them when a collision occurs.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/08 Powerups.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvoid Game::DoCollisions()\n{\n    for (GameObject &box : this->Levels[this->Level].Bricks)\n    {\n        if (!box.Destroyed)\n        {\n            Collision collision = CheckCollision(*Ball, box);\n            if (std::get<0>(collision))\n            {\n                if (!box.IsSolid)\n                {\n                    box.Destroyed = GL_TRUE;\n                    this->SpawnPowerUps(box);\n                }\n                [...]\n            }\n        }\n    }        \n    [...] \n    for (PowerUp &powerUp : this->PowerUps)\n    {\n        if (!powerUp.Destroyed)\n        {\n            if (powerUp.Position.y >= this->Height)\n                powerUp.Destroyed = GL_TRUE;\n            if (CheckCollision(*Player, powerUp))\n            {   // 道具与挡板接触，激活它！\n                ActivatePowerUp(powerUp);\n                powerUp.Destroyed = GL_TRUE;\n                powerUp.Activated = GL_TRUE;\n            }\n        }\n    }  \n}\n```\n\n----------------------------------------\n\nTITLE: Light Volume Check in Fragment Shader for Deferred Rendering\nDESCRIPTION: Fragment shader code implementing light volume optimization in deferred rendering. This code demonstrates how to check if a fragment is within a light's influence radius before performing expensive lighting calculations.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/08 Deferred Shading.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nstruct Light {\n    [...]\n    float Radius;\n}; \n  \nvoid main()\n{\n    [...]\n    for(int i = 0; i < NR_LIGHTS; ++i)\n    {\n        // 计算光源和该片段间距离\n        float distance = length(lights[i].Position - FragPos);\n        if(distance < lights[i].Radius)\n        {\n            // 执行大开销光照\n            [...]\n        }\n    }   \n}\n```\n\n----------------------------------------\n\nTITLE: Final Outgoing Radiance Calculation in PBR\nDESCRIPTION: This code calculates the final outgoing radiance (Lo) for each light source in a PBR shader. It combines the diffuse and specular components, scales them by the light's radiance and the dot product of the normal and light direction.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/02 Lighting.md#2025-04-22_snippet_11\n\nLANGUAGE: GLSL\nCODE:\n```\n    const float PI = 3.14159265359;\n  \n    float NdotL = max(dot(N, L), 0.0);        \n    Lo += (kD * albedo / PI + specular) * radiance * NdotL;\n}\n```\n\n----------------------------------------\n\nTITLE: PBR Direct Lighting Loop Setup in GLSL\nDESCRIPTION: This code sets up the direct lighting calculation loop for a PBR shader. It initializes the outgoing radiance value, calculates the light direction, half vector, distance, attenuation, and radiance for each light source.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/02 Lighting.md#2025-04-22_snippet_3\n\nLANGUAGE: GLSL\nCODE:\n```\nvec3 Lo = vec3(0.0);\nfor(int i = 0; i < 4; ++i) \n{\n    vec3 L = normalize(lightPositions[i] - WorldPos);\n    vec3 H = normalize(V + L);\n  \n    float distance    = length(lightPositions[i] - WorldPos);\n    float attenuation = 1.0 / (distance * distance);\n    vec3 radiance     = lightColors[i] * attenuation; \n    [...]  \n```\n\n----------------------------------------\n\nTITLE: Vertex Shader with Color Output\nDESCRIPTION: A simple vertex shader that sets the vertex position and outputs a color to the fragment shader.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/old/01/05 Shaders.md#2025-04-22_snippet_4\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (location = 0) in vec3 position; // The position variable has attribute position 0\n\nout vec4 vertexColor; // Specify a color output to the fragment shader\n\nvoid main()\n{\n    gl_Position = vec4(position, 1.0); // See how we directly give a vec3 to vec4's constructor\n    vertexColor = vec4(0.5f, 0.0f, 0.0f, 1.0f); // Set the output variable to a dark-red color\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Cubemap Texture for Reflection (C++)\nDESCRIPTION: This C++ code binds the skybox cubemap texture before rendering the reflective object.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/06 Cubemaps.md#2025-04-22_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nglBindVertexArray(cubeVAO);\nglBindTexture(GL_TEXTURE_CUBE_MAP, skyboxTexture);  \t\t\nglDrawArrays(GL_TRIANGLES, 0, 36);\n```\n\n----------------------------------------\n\nTITLE: Geometry Shader for Drawing Houses in GLSL\nDESCRIPTION: A geometry shader that takes points as input and generates house shapes using triangle strips.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/09 Geometry Shader.md#2025-04-22_snippet_4\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (points) in;\nlayout (triangle_strip, max_vertices = 5) out;\n\nvoid build_house(vec4 position)\n{    \n    gl_Position = position + vec4(-0.2, -0.2, 0.0, 0.0);    // 1:左下\n    EmitVertex();   \n    gl_Position = position + vec4( 0.2, -0.2, 0.0, 0.0);    // 2:右下\n    EmitVertex();\n    gl_Position = position + vec4(-0.2,  0.2, 0.0, 0.0);    // 3:左上\n    EmitVertex();\n    gl_Position = position + vec4( 0.2,  0.2, 0.0, 0.0);    // 4:右上\n    EmitVertex();\n    gl_Position = position + vec4( 0.0,  0.4, 0.0, 0.0);    // 5:顶部\n    EmitVertex();\n    EndPrimitive();\n}\n\nvoid main() {    \n    build_house(gl_in[0].gl_Position);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Uniform Values in OpenGL\nDESCRIPTION: Demonstrates how to set the value of a uniform variable in a shader from the CPU side using OpenGL functions.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/old/01/05 Shaders.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nGLfloat timeValue = glfwGetTime();\nGLfloat greenValue = (sin(timeValue) / 2) + 0.5;\nGLint vertexColorLocation = glGetUniformLocation(shaderProgram, \"ourColor\");\nglUseProgram(shaderProgram);\nglUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);\n```\n\n----------------------------------------\n\nTITLE: Calculating Light Volume Radius for Optimized Rendering\nDESCRIPTION: Code for calculating the radius of a light volume based on attenuation parameters. This optimization allows for more efficient rendering of scenes with many light sources by only processing fragments that are within a light's influence area.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/08 Deferred Shading.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nGLfloat constant  = 1.0; \nGLfloat linear    = 0.7;\nGLfloat quadratic = 1.8;\nGLfloat lightMax  = std::fmaxf(std::fmaxf(lightColor.r, lightColor.g), lightColor.b);\nGLfloat radius    = \n  (-linear +  std::sqrtf(linear * linear - 4 * quadratic * (constant - (256.0 / 5.0) * lightMax))) \n  / (2 * quadratic);  \n```\n\n----------------------------------------\n\nTITLE: Main Fragment Shader Setup\nDESCRIPTION: Initial fragment shader setup defining output, inputs, light and material structures, and LUT sampling constants.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/08 Guest Articles/2022/03 Area Lights.md#2025-04-22_snippet_0\n\nLANGUAGE: glsl\nCODE:\n```\n#version 330 core\n\nout vec4 fragColor;\n\nin vec3 worldPosition;\nin vec3 worldNormal;\nin vec2 texcoord;\n\nstruct Light {\n    float intensity;\n    vec3 color;\n    vec3 points[4];\n    bool twoSided;\n};\n\nuniform Light areaLight;\nuniform vec3 areaLightTranslate;\n\nstruct Material {\n    sampler2D diffuse;\n    vec4 albedoRoughness;\n};\nuniform Material material;\n\nuniform vec3 viewPosition;\nuniform sampler2D LTC1;\nuniform sampler2D LTC2;\n\nconst float LUT_SIZE = 64.0;\nconst float LUT_SCALE = (LUT_SIZE - 1.0)/LUT_SIZE;\nconst float LUT_BIAS = 0.5/LUT_SIZE;\n```\n\n----------------------------------------\n\nTITLE: Setting Uniform Values in OpenGL\nDESCRIPTION: Demonstrates how to set the value of a uniform variable in the OpenGL application code.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/05 Shaders.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nfloat timeValue = glfwGetTime();\nfloat greenValue = (sin(timeValue) / 2.0f) + 0.5f;\nint vertexColorLocation = glGetUniformLocation(shaderProgram, \"ourColor\");\nglUseProgram(shaderProgram);\nglUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);\n```\n\n----------------------------------------\n\nTITLE: Setting Uniform Colors in OpenGL\nDESCRIPTION: Sets the uniform values for object color and light color in the shader program.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/01 Colors.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\n// 在此之前不要忘记首先 use 对应的着色器程序（来设定uniform）\nlightingShader.use();\nlightingShader.setVec3(\"objectColor\", 1.0f, 0.5f, 0.31f);\nlightingShader.setVec3(\"lightColor\",  1.0f, 1.0f, 1.0f);\n```\n\n----------------------------------------\n\nTITLE: Collision Resolution in Game Class\nDESCRIPTION: Method to handle collisions between the ball and bricks, updating ball position and velocity based on collision direction.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/05 Collisions/03 Collision resolution.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvoid Game::DoCollisions()\n{\n    for (GameObject &box : this->Levels[this->Level].Bricks)\n    {\n        if (!box.Destroyed)\n        {\n            Collision collision = CheckCollision(*Ball, box);\n            if (std::get<0>(collision)) // 如果collision 是 true\n            {\n                // 如果砖块不是实心就销毁砖块\n                if (!box.IsSolid)\n                    box.Destroyed = GL_TRUE;\n                // 碰撞处理\n                Direction dir = std::get<1>(collision);\n                glm::vec2 diff_vector = std::get<2>(collision);\n                if (dir == LEFT || dir == RIGHT) // 水平方向碰撞\n                {\n                    Ball->Velocity.x = -Ball->Velocity.x; // 反转水平速度\n                    // 重定位\n                    GLfloat penetration = Ball->Radius - std::abs(diff_vector.x);\n                    if (dir == LEFT)\n                        Ball->Position.x += penetration; // 将球右移\n                    else\n                        Ball->Position.x -= penetration; // 将球左移\n                }\n                else // 垂直方向碰撞\n                {\n                    Ball->Velocity.y = -Ball->Velocity.y; // 反转垂直速度\n                    // 重定位\n                    GLfloat penetration = Ball->Radius - std::abs(diff_vector.y);\n                    if (dir == UP)\n                        Ball->Position.y -= penetration; // 将球上移\n                    else\n                        Ball->Position.y += penetration; // 将球下移\n                }\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Texture Parameters for a Depth Cubemap\nDESCRIPTION: Configuring the texture parameters for a depth cubemap to ensure proper sampling and filtering. These settings define how the depth values are interpolated and handle edge cases when sampling near cubemap boundaries.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/02 Point Shadows.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);\n```\n\n----------------------------------------\n\nTITLE: Exploding Vertex Position in Geometry Shader (GLSL)\nDESCRIPTION: This function displaces a vertex position along its normal vector, creating an explosion effect that varies with time.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/09 Geometry Shader.md#2025-04-22_snippet_8\n\nLANGUAGE: GLSL\nCODE:\n```\nvec4 explode(vec4 position, vec3 normal)\n{\n    float magnitude = 2.0;\n    vec3 direction = normal * ((sin(time) + 1.0) / 2.0) * magnitude; \n    return position + vec4(direction, 0.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Texture Generation Process in OpenGL\nDESCRIPTION: Demonstrates the complete process of generating a texture, including loading the image, setting parameters, and creating the texture.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/06 Textures.md#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nunsigned int texture;\nglGenTextures(1, &texture);\nglBindTexture(GL_TEXTURE_2D, texture);\n// 为当前绑定的纹理对象设置环绕、过滤方式\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\t\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n// 加载并生成纹理\nint width, height, nrChannels;\nunsigned char *data = stbi_load(\"container.jpg\", &width, &height, &nrChannels, 0);\nif (data)\n{\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);\n    glGenerateMipmap(GL_TEXTURE_2D);\n}\nelse\n{\n    std::cout << \"Failed to load texture\" << std::endl;\n}\nstbi_image_free(data);\n```\n\n----------------------------------------\n\nTITLE: Basic Pass-Through Fragment Shader for HDR Buffer\nDESCRIPTION: A simple fragment shader that samples the HDR buffer and outputs the color without any tone mapping. This will cause bright areas to be clamped to 1.0, losing detail in those regions.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/06 HDR.md#2025-04-22_snippet_3\n\nLANGUAGE: glsl\nCODE:\n```\n#version 330 core\nout vec4 color;\nin vec2 TexCoords;\n\nuniform sampler2D hdrBuffer;\n\nvoid main()\n{             \n    vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb;\n    color = vec4(hdrColor, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Final Color with Ambient Term in PBR\nDESCRIPTION: This code adds an ambient lighting term to the calculated outgoing radiance to account for indirect lighting. It multiplies a small constant, the albedo color, and the ambient occlusion value to produce the ambient contribution.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/02 Lighting.md#2025-04-22_snippet_12\n\nLANGUAGE: GLSL\nCODE:\n```\nvec3 ambient = vec3(0.03) * albedo * ao;\nvec3 color   = ambient + Lo;  \n```\n\n----------------------------------------\n\nTITLE: Binding Uniform Blocks to Binding Points in C++\nDESCRIPTION: Shows how to bind a Uniform Block in a shader to a specific binding point using glGetUniformBlockIndex and glUniformBlockBinding functions in C++.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/08 Advanced GLSL.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nunsigned int lights_index = glGetUniformBlockIndex(shaderA.ID, \"Lights\");   \nglUniformBlockBinding(shaderA.ID, lights_index, 2);\n```\n\n----------------------------------------\n\nTITLE: Setting Texture Parameters for Cubemaps in OpenGL\nDESCRIPTION: This code configures the filtering and wrapping parameters for a cubemap texture. It sets linear filtering for minification and magnification, and clamps the texture coordinates to the edge.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/06 Cubemaps.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);\n```\n\n----------------------------------------\n\nTITLE: Creating Rotation and Scale Transformations in C++\nDESCRIPTION: Shows how to create a transformation matrix that combines rotation and scaling using GLM functions.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/07 Transformations.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nglm::mat4 trans;\ntrans = glm::rotate(trans, glm::radians(90.0f), glm::vec3(0.0, 0.0, 1.0));\ntrans = glm::scale(trans, glm::vec3(0.5, 0.5, 0.5));\n```\n\n----------------------------------------\n\nTITLE: Implementing RenderText Method for OpenGL Text Rendering\nDESCRIPTION: A method that renders text to the screen using OpenGL. It calculates the position of each character glyph with special handling for the orthographic projection where y-values increase from top to bottom, unlike traditional text rendering where y-values increase from bottom to top.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/10 Render Text.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvoid TextRenderer::RenderText(std::string text, GLfloat x, GLfloat y, GLfloat scale,glm::vec3 color)\n{\n    [...]\n    for (c = text.begin(); c != text.end(); c++)\n    {\n        GLfloat xpos = x + ch.Bearing.x * scale;\n        GLfloat ypos = y + (this->Characters['H'].Bearing.y - ch.Bearing.y) * scale;\n\n        GLfloat w = ch.Size.x * scale;\n        GLfloat h = ch.Size.y * scale;\n        // 为每个字符更新VBO\n        GLfloat vertices[6][4] = {\n            { xpos,     ypos + h,   0.0, 1.0 },\n            { xpos + w, ypos,       1.0, 0.0 },\n            { xpos,     ypos,       0.0, 0.0 },\n\n            { xpos,     ypos + h,   0.0, 1.0 },\n            { xpos + w, ypos + h,   1.0, 1.0 },\n            { xpos + w, ypos,       1.0, 0.0 }\n        };\n        [...]\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Traditional Asteroid Rendering Loop in C++\nDESCRIPTION: Renders a planet and multiple asteroids using traditional rendering approach with individual draw calls for each asteroid.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/10 Instancing.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\n// 绘制行星\nshader.use();\nglm::mat4 model;\nmodel = glm::translate(model, glm::vec3(0.0f, -3.0f, 0.0f));\nmodel = glm::scale(model, glm::vec3(4.0f, 4.0f, 4.0f));\nshader.setMat4(\"model\", model);\nplanet.Draw(shader);\n  \n// 绘制小行星\nfor(unsigned int i = 0; i < amount; i++)\n{\n    shader.setMat4(\"model\", modelMatrices[i]);\n    rock.Draw(shader);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Multisampled Renderbuffer Object\nDESCRIPTION: Code that sets up a multisampled renderbuffer storage which can be used for depth and stencil attachments in an MSAA framebuffer. This example uses 4 samples per pixel.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/11 Anti Aliasing.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nglRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_DEPTH24_STENCIL8, width, height);\n```\n\n----------------------------------------\n\nTITLE: Setting Time Uniform for Explosion Effect (C++)\nDESCRIPTION: This C++ snippet shows how to set the time uniform in the OpenGL shader program for the explosion effect.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/09 Geometry Shader.md#2025-04-22_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nshader.setFloat(\"time\", glfwGetTime());\n```\n\n----------------------------------------\n\nTITLE: Combining Deferred and Forward Rendering for Light Cubes in OpenGL\nDESCRIPTION: Code that demonstrates rendering light cubes with forward rendering after completing the deferred rendering phase. This shows how to render 3D cubes at light source positions to represent light emitters.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/08 Deferred Shading.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n// 延迟渲染光照渲染阶段\n[...]\nRenderQuad();\n  \n// 现在像正常情况一样正向渲染所有光立方体\nshaderLightBox.Use();\nglUniformMatrix4fv(locProjection, 1, GL_FALSE, glm::value_ptr(projection));\nglUniformMatrix4fv(locView, 1, GL_FALSE, glm::value_ptr(view));\nfor (GLuint i = 0; i < lightPositions.size(); i++)\n{\n    model = glm::mat4();\n    model = glm::translate(model, lightPositions[i]);\n    model = glm::scale(model, glm::vec3(0.25f));\n    glUniformMatrix4fv(locModel, 1, GL_FALSE, glm::value_ptr(model));\n    glUniform3fv(locLightcolor, 1, &lightColors[i][0]);\n    RenderCube();\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Normal Matrix Transformation\nDESCRIPTION: Code that transforms normal vectors using the normal matrix, which is the transpose of the inverse of the model matrix. This ensures normals remain perpendicular to surfaces even with non-uniform scaling.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/02 Basic Lighting.md#2025-04-22_snippet_4\n\nLANGUAGE: glsl\nCODE:\n```\nNormal = mat3(transpose(inverse(model))) * aNormal;\n```\n\n----------------------------------------\n\nTITLE: Attaching a Cubemap as Framebuffer Depth Attachment\nDESCRIPTION: Setting up a framebuffer with a cubemap as its depth attachment for geometry shader-based rendering. This approach allows rendering to all six faces of the cubemap in a single pass when used with an appropriate geometry shader.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/02 Point Shadows.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nglBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);\nglFramebufferTexture(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, depthCubemap, 0);\nglDrawBuffer(GL_NONE);\nglReadBuffer(GL_NONE);\nglBindFramebuffer(GL_FRAMEBUFFER, 0);\n```\n\n----------------------------------------\n\nTITLE: Setting up Light Source VAO in OpenGL\nDESCRIPTION: Creates and configures a Vertex Array Object (VAO) for the light source cube, reusing the existing VBO data.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/01 Colors.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nunsigned int lightVAO;\nglGenVertexArrays(1, &lightVAO);\nglBindVertexArray(lightVAO);\n// 只需要绑定VBO不用再次设置VBO的数据，因为箱子的VBO数据中已经包含了正确的立方体顶点数据\nglBindBuffer(GL_ARRAY_BUFFER, VBO);\n// 设置灯立方体的顶点属性（对我们的灯来说仅仅只有位置数据）\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\nglEnableVertexAttribArray(0);\n```\n\n----------------------------------------\n\nTITLE: Implementing Hammersley Sequence in GLSL\nDESCRIPTION: GLSL function to generate the Hammersley sequence for low-discrepancy sampling, used in importance sampling for specular IBL.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/03 IBL/02 Specular IBL.md#2025-04-22_snippet_3\n\nLANGUAGE: GLSL\nCODE:\n```\nvec2 Hammersley(uint i, uint N)\n{\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling MSAA with GLFW in OpenGL\nDESCRIPTION: Code to enable Multisample Anti-aliasing (MSAA) by configuring GLFW to use a multisample buffer with 4 samples per pixel. The final line enables the GL_MULTISAMPLE feature in OpenGL.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/11 Anti Aliasing.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nglfwWindowHint(GLFW_SAMPLES, 4);\n\n// Later, after window creation\nglEnable(GL_MULTISAMPLE);\n```\n\n----------------------------------------\n\nTITLE: Geometry Shader for Normal Visualization (GLSL)\nDESCRIPTION: This geometry shader generates line segments to visualize surface normals for each vertex of input triangles.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/09 Geometry Shader.md#2025-04-22_snippet_12\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (triangles) in;\nlayout (line_strip, max_vertices = 6) out;\n\nin VS_OUT {\n    vec3 normal;\n} gs_in[];\n\nconst float MAGNITUDE = 0.4;\n  \nuniform mat4 projection;\n\nvoid GenerateLine(int index)\n{\n    gl_Position = projection * gl_in[index].gl_Position;\n    EmitVertex();\n    gl_Position = projection * (gl_in[index].gl_Position + \n                                vec4(gs_in[index].normal, 0.0) * MAGNITUDE);\n    EmitVertex();\n    EndPrimitive();\n}\n\nvoid main()\n{\n    GenerateLine(0); // 第一个顶点法线\n    GenerateLine(1); // 第二个顶点法线\n    GenerateLine(2); // 第三个顶点法线\n}\n```\n\n----------------------------------------\n\nTITLE: Drawing Light Source Cube in OpenGL\nDESCRIPTION: Renders the light source cube using its shader and VAO.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/01 Colors.md#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nlampShader.use();\n// 设置模型、视图和投影矩阵uniform\n...\n// 绘制灯立方体对象\nglBindVertexArray(lightVAO);\nglDrawArrays(GL_TRIANGLES, 0, 36);\n```\n\n----------------------------------------\n\nTITLE: Drawing Objects with Stencil Writing Enabled\nDESCRIPTION: Code to set up the stencil buffer for writing while rendering the main objects. This creates a \"mask\" in the stencil buffer representing where objects are drawn.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/02 Stencil testing.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nglStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);\nglStencilFunc(GL_ALWAYS, 1, 0xFF); // 所有的片段都应该更新模板缓冲\nglStencilMask(0xFF); // 启用模板缓冲写入\nnormalShader.use();\nDrawTwoContainers();\n```\n\n----------------------------------------\n\nTITLE: Implementing Van Der Corpus Sequence without Bit Operations in GLSL\nDESCRIPTION: Alternative GLSL implementation of the Van Der Corpus sequence that doesn't use bit operations, for compatibility with platforms that don't support them.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/03 IBL/02 Specular IBL.md#2025-04-22_snippet_4\n\nLANGUAGE: GLSL\nCODE:\n```\nfloat VanDerCorpus(uint n, uint base)\n{\n    float invBase = 1.0 / float(base);\n    float denom   = 1.0;\n    float result  = 0.0;\n\n    for(uint i = 0u; i < 32u; ++i)\n    {\n        if(n > 0u)\n        {\n            denom   = mod(float(n), 2.0);\n            result += denom * invBase;\n            invBase = invBase / 2.0;\n            n       = uint(float(n) / 2.0);\n        }\n    }\n\n    return result;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Fragments Beyond Far Plane in Shadow Mapping\nDESCRIPTION: Shadow calculation modification to handle fragments that are beyond the light's far plane, preventing them from being incorrectly shadowed when outside the light's view frustum.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/01 Shadow Mapping.md#2025-04-22_snippet_7\n\nLANGUAGE: GLSL\nCODE:\n```\nfloat ShadowCalculation(vec4 fragPosLightSpace)\n{\n    [...]\n    if(projCoords.z > 1.0)\n        shadow = 0.0;\n    \n    return shadow;\n}\n```\n\n----------------------------------------\n\nTITLE: Computing Triangle Edges and Texture Coordinate Deltas in C++\nDESCRIPTION: Code for calculating the edges of a triangle and the differences in texture coordinates, which are needed to compute tangent and bitangent vectors for normal mapping.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/04 Normal Mapping.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nglm::vec3 edge1 = pos2 - pos1;\nglm::vec3 edge2 = pos3 - pos1;\nglm::vec2 deltaUV1 = uv2 - uv1;\nglm::vec2 deltaUV2 = uv3 - uv1;\n```\n\n----------------------------------------\n\nTITLE: Resolving a Multisampled Framebuffer to a Regular Framebuffer\nDESCRIPTION: Code that resolves (downsamples) a multisampled framebuffer to a regular non-multisampled framebuffer using glBlitFramebuffer. This is necessary to use the result for post-processing or display.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/11 Anti Aliasing.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nglBindFramebuffer(GL_READ_FRAMEBUFFER, multisampledFBO);\nglBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);\nglBlitFramebuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);\n```\n\n----------------------------------------\n\nTITLE: Vertex Shader for Shadow Mapping in OpenGL\nDESCRIPTION: Vertex shader that transforms coordinates for shadow mapping. It calculates both standard position coordinates and light space position coordinates that will be used later to determine shadows.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/01 Shadow Mapping.md#2025-04-22_snippet_0\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoords;\n \nout vec2 TexCoords;\n \nout VS_OUT {\n    vec3 FragPos;\n    vec3 Normal;\n    vec2 TexCoords;\n    vec4 FragPosLightSpace;\n} vs_out;\n \nuniform mat4 projection;\nuniform mat4 view;\nuniform mat4 model;\nuniform mat4 lightSpaceMatrix;\n \nvoid main()\n{\n    gl_Position = projection * view * model * vec4(position, 1.0f);\n    vs_out.FragPos = vec3(model * vec4(position, 1.0));\n    vs_out.Normal = transpose(inverse(mat3(model))) * normal;\n    vs_out.TexCoords = texCoords;\n    vs_out.FragPosLightSpace = lightSpaceMatrix * vec4(vs_out.FragPos, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Menu Text for Level Selection\nDESCRIPTION: Code that renders instructional text in the game menu, guiding the player on how to select a level and start the game. It displays text at specific positions on the screen.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/10 Render Text.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nvoid Game::Render()\n{\n    if (this->State == GAME_ACTIVE || this->State == GAME_MENU)\n    {\n        [...] // 游戏状态渲染代码\n    }\n    if (this->State == GAME_MENU)\n    {\n        Text->RenderText(\"Press ENTER to start\", 250.0f, Height / 2, 1.0f);\n        Text->RenderText(\"Press W or S to select level\", 245.0f, Height / 2 + 20.0f, 0.75f);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Shadow Rendering Setup with Cube Map\nDESCRIPTION: Initial setup code for rendering omnidirectional shadows using a cube map depth buffer. Includes viewport setup, texture binding and scene rendering.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/02 Point Shadows.md#2025-04-22_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nglViewport(0, 0, SCR_WIDTH, SCR_HEIGHT);\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\nshader.Use();  \n// ... send uniforms to shader (including light's far_plane value)\nglActiveTexture(GL_TEXTURE0);\nglBindTexture(GL_TEXTURE_CUBE_MAP, depthCubemap);\n// ... bind other textures\nRenderScene();\n```\n\n----------------------------------------\n\nTITLE: Creating SSAO Frame Buffer Object in C++\nDESCRIPTION: This snippet creates a frame buffer object for the SSAO stage, including a color buffer texture to store the SSAO result.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/09 SSAO.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nGLuint ssaoFBO;\nglGenFramebuffers(1, &ssaoFBO);  \nglBindFramebuffer(GL_FRAMEBUFFER, ssaoFBO);\nGLuint ssaoColorBuffer;\n\nglGenTextures(1, &ssaoColorBuffer);\nglBindTexture(GL_TEXTURE_2D, ssaoColorBuffer);\nglTexImage2D(GL_TEXTURE_2D, 0, GL_RED, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_FLOAT, NULL);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\nglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, ssaoColorBuffer, 0);\n```\n\n----------------------------------------\n\nTITLE: Defining Shader Class Structure in C++\nDESCRIPTION: Defines the structure of the Shader class, including constructor, use function, and uniform setter methods. It also includes necessary headers and preprocessor directives.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/05 Shaders.md#2025-04-22_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\n#ifndef SHADER_H\n#define SHADER_H\n\n#include <glad/glad.h>; // 包含glad来获取所有的必须OpenGL头文件\n  \n#include <string>\n#include <fstream>\n#include <sstream>\n#include <iostream>\n  \n\nclass Shader\n{\npublic:\n    // 程序ID\n    unsigned int ID;\n  \n    // 构造器读取并构建着色器\n    Shader(const char* vertexPath, const char* fragmentPath);\n    // 使用/激活程序\n    void use();\n    // uniform工具函数\n    void setBool(const std::string &name, bool value) const;  \n    void setInt(const std::string &name, int value) const;   \n    void setFloat(const std::string &name, float value) const;\n};\n  \n#endif\n```\n\n----------------------------------------\n\nTITLE: Implementing Player Lives System in Game Class\nDESCRIPTION: Code for adding a player lives system to the Game class. It defines a Lives property and updates the game logic to decrement lives when the ball hits the bottom boundary, resetting the game only when lives reach zero.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/10 Render Text.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nclass Game\n{\n    [...]\n    public:\n        GLuint Lives;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Menu Controls with Key Processing\nDESCRIPTION: Code that handles menu navigation while tracking which keys have been processed to prevent multiple inputs from a single keypress. Each key only triggers once until released, making menu navigation smoother.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/10 Render Text.md#2025-04-22_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nvoid Game::ProcessInput(GLfloat dt)\n{\n    if (this->State == GAME_MENU)\n    {\n        if (this->Keys[GLFW_KEY_ENTER] && !this->KeysProcessed[GLFW_KEY_ENTER])\n        {\n            this->State = GAME_ACTIVE;\n            this->KeysProcessed[GLFW_KEY_ENTER] = GL_TRUE;\n        }\n        if (this->Keys[GLFW_KEY_W] && !this->KeysProcessed[GLFW_KEY_W])\n        {\n            this->Level = (this->Level + 1) % 4;\n            this->KeysProcessed[GLFW_KEY_W] = GL_TRUE;\n        }\n        if (this->Keys[GLFW_KEY_S] && !this->KeysProcessed[GLFW_KEY_S])\n        {\n            if (this->Level > 0)\n                --this->Level;\n            else\n                this->Level = 3;\n            this->KeysProcessed[GLFW_KEY_S] = GL_TRUE;\n        }\n    }\n    [...]\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Shadow Bias Calculation in GLSL\nDESCRIPTION: Advanced shadow bias implementation that adjusts the bias amount based on the surface normal orientation relative to the light direction, providing better results for surfaces at different angles.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/01 Shadow Mapping.md#2025-04-22_snippet_4\n\nLANGUAGE: GLSL\nCODE:\n```\nfloat bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);\n```\n\n----------------------------------------\n\nTITLE: Creating and Binding a Uniform Buffer Object for Matrices in C++\nDESCRIPTION: Demonstrates how to create a Uniform Buffer Object for storing matrices, allocate memory for it, and bind it to a specific binding point in C++.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/08 Advanced GLSL.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nunsigned int uboMatrices\nglGenBuffers(1, &uboMatrices);\n  \nglBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);\nglBufferData(GL_UNIFORM_BUFFER, 2 * sizeof(glm::mat4), NULL, GL_STATIC_DRAW);\nglBindBuffer(GL_UNIFORM_BUFFER, 0);\n  \nglBindBufferRange(GL_UNIFORM_BUFFER, 0, uboMatrices, 0, 2 * sizeof(glm::mat4));\n```\n\n----------------------------------------\n\nTITLE: Rendering Win State Text\nDESCRIPTION: Code that renders congratulatory text and instructions when the player wins the game. It displays colored text at specific positions, informing the player they can retry or quit.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/10 Render Text.md#2025-04-22_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nvoid Game::Render()\n{\n    [...]\n    if (this->State == GAME_WIN)\n    {\n        Text->RenderText(\n            \"You WON!!!\", 320.0, Height / 2 - 20.0, 1.0, glm::vec3(0.0, 1.0, 0.0)\n        );\n        Text->RenderText(\n            \"Press ENTER to retry or ESC to quit\", 130.0, Height / 2, 1.0, glm::vec3(1.0, 1.0, 0.0)\n        );\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Stencil Function for Testing\nDESCRIPTION: Example of setting the stencil test function to compare stencil values. This function allows fragments to pass or fail based on the current stencil buffer values.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/02 Stencil testing.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nglStencilFunc(GL_EQUAL, 1, 0xFF)\n```\n\n----------------------------------------\n\nTITLE: Calculating Camera Up Vector\nDESCRIPTION: Computes the camera's up vector through cross product of direction and right vectors.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/09 Camera.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nglm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);\n```\n\n----------------------------------------\n\nTITLE: Linearizing Depth Values for Shadow Mapping in GLSL\nDESCRIPTION: This GLSL shader snippet demonstrates how to linearize depth values from a depth map, particularly useful for visualizing depth in perspective projection. It includes a function to convert non-linear depth to linear depth and outputs the result as a color.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/01 Shadow Mapping.md#2025-04-22_snippet_9\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout vec4 color;\nin vec2 TexCoords;\n\nuniform sampler2D depthMap;\nuniform float near_plane;\nuniform float far_plane;\n\nfloat LinearizeDepth(float depth)\n{\n    float z = depth * 2.0 - 1.0; // Back to NDC \n    return (2.0 * near_plane * far_plane) / (far_plane + near_plane - z * (far_plane - near_plane));\n}\n\nvoid main()\n{             \n    float depthValue = texture(depthMap, TexCoords).r;\n    color = vec4(vec3(LinearizeDepth(depthValue) / far_plane), 1.0); // perspective\n    // color = vec4(vec3(depthValue), 1.0); // orthographic\n}\n```\n\n----------------------------------------\n\nTITLE: GLSL Vector Construction Examples\nDESCRIPTION: Shows how to construct vectors in GLSL using different methods, including combining smaller vectors.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/old/01/05 Shaders.md#2025-04-22_snippet_3\n\nLANGUAGE: GLSL\nCODE:\n```\nvec2 vect = vec2(0.5f, 0.7f);\nvec4 result = vec4(vect, 0.0f, 0.0f);\nvec4 otherResult = vec4(result.xyz, 1.0f);\n```\n\n----------------------------------------\n\nTITLE: Vertex Shader Output Structure\nDESCRIPTION: Defines the output structure for passing TBN matrix to fragment shader.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/04 Normal Mapping.md#2025-04-22_snippet_7\n\nLANGUAGE: GLSL\nCODE:\n```\nout VS_OUT {\n    vec3 FragPos;\n    vec2 TexCoords;\n    mat3 TBN;\n} vs_out;  \n\nvoid main()\n{\n    [...]\n    vs_out.TBN = mat3(T, B, N);\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Texture Cache for OpenGL Model Loading\nDESCRIPTION: Declares a vector to store loaded textures for caching and reuse across multiple meshes.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/03 Model Loading/03 Model.md#2025-04-22_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nvector<Texture> textures_loaded;\n```\n\n----------------------------------------\n\nTITLE: Setting Border Color for Shadow Map Sampling in OpenGL\nDESCRIPTION: Configuration for shadow map texture parameters to handle sampling outside the depth map. Sets the border texture wrapping mode and defines a border color to ensure correct shadow behavior.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/01 Shadow Mapping.md#2025-04-22_snippet_6\n\nLANGUAGE: c++\nCODE:\n```\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);\nGLfloat borderColor[] = { 1.0, 1.0, 1.0, 1.0 };\nglTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);\n```\n\n----------------------------------------\n\nTITLE: Creating Texture from Image Data in OpenGL\nDESCRIPTION: Creates a texture from loaded image data and generates mipmaps.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/06 Textures.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);\nglGenerateMipmap(GL_TEXTURE_2D);\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader for Green Color Output in GLSL\nDESCRIPTION: A simple fragment shader that outputs a constant green color for all fragments.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/09 Geometry Shader.md#2025-04-22_snippet_2\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\n\nvoid main()\n{\n    FragColor = vec4(0.0, 1.0, 0.0, 1.0);   \n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Blending in OpenGL\nDESCRIPTION: Enables OpenGL's blending functionality, which is required for rendering semi-transparent objects. This simple command activates the blending feature.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/03 Blending.md#2025-04-22_snippet_5\n\nLANGUAGE: c++\nCODE:\n```\nglEnable(GL_BLEND);\n```\n\n----------------------------------------\n\nTITLE: Camera Movement Configuration\nDESCRIPTION: Sets up basic camera movement variables including position, front direction and up vector.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/09 Camera.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nglm::vec3 cameraPos   = glm::vec3(0.0f, 0.0f,  3.0f);\nglm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, -1.0f);\nglm::vec3 cameraUp    = glm::vec3(0.0f, 1.0f,  0.0f);\n```\n\n----------------------------------------\n\nTITLE: Vertex Shader for Omnidirectional Shadows\nDESCRIPTION: Vertex shader implementation for omnidirectional shadow mapping. Handles position transformation and normal/texture coordinate passing.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/02 Point Shadows.md#2025-04-22_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\n#version 330 core\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 texCoords;\n\nout vec2 TexCoords;\n\nout VS_OUT {\n    vec3 FragPos;\n    vec3 Normal;\n    vec2 TexCoords;\n} vs_out;\n\nuniform mat4 projection;\nuniform mat4 view;\nuniform mat4 model;\n\nvoid main()\n{\n    gl_Position = projection * view * model * vec4(position, 1.0f);\n    vs_out.FragPos = vec3(model * vec4(position, 1.0));\n    vs_out.Normal = transpose(inverse(mat3(model))) * normal;\n    vs_out.TexCoords = texCoords;\n}\n```\n\n----------------------------------------\n\nTITLE: Vertex Shader for 3D Object in GLSL\nDESCRIPTION: Defines a basic vertex shader for transforming 3D object vertices using model, view, and projection matrices.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/01 Colors.md#2025-04-22_snippet_2\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (location = 0) in vec3 aPos;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\n\nvoid main()\n{\n    gl_Position = projection * view * model * vec4(aPos, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Uniform Block with std140 Layout in GLSL\nDESCRIPTION: Shows how to define a Uniform Block in GLSL using the std140 layout qualifier. This block contains various types of uniforms including scalars, vectors, matrices and arrays.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/08 Advanced GLSL.md#2025-04-22_snippet_0\n\nLANGUAGE: GLSL\nCODE:\n```\nlayout (std140) uniform ExampleBlock\n{\n    float value;\n    vec3  vector;\n    mat4  matrix;\n    float values[3];\n    bool  boolean;\n    int   integer;\n};\n```\n\n----------------------------------------\n\nTITLE: Converting Normal Vectors from [-1,1] to [0,1] Range in C++\nDESCRIPTION: Code for transforming a normal vector from the range of [-1,1] to [0,1], which is necessary for storing normals in RGB textures where each component is restricted to 0-1 range.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/04 Normal Mapping.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvec3 rgb_normal = normal * 0.5 + 0.5; // 从 [-1,1] 转换至 [0,1]\n```\n\n----------------------------------------\n\nTITLE: Accessing Individual Sample Values in GLSL\nDESCRIPTION: GLSL code snippet showing how to declare a multisampled texture sampler and access individual sample values. This enables the creation of custom anti-aliasing algorithms in shaders.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/11 Anti Aliasing.md#2025-04-22_snippet_5\n\nLANGUAGE: GLSL\nCODE:\n```\nuniform sampler2DMS screenTextureMS;\n\n// In fragment shader\nvec4 colorSample = texelFetch(screenTextureMS, TexCoords, 3);  // 第4个子样本\n```\n\n----------------------------------------\n\nTITLE: Initializing Color Vector in C++\nDESCRIPTION: Creates a vec3 color vector representing coral color using RGB values.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/01 Colors.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nglm::vec3 coral(1.0f, 0.5f, 0.31f);\n```\n\n----------------------------------------\n\nTITLE: Convolving Environment Map in GLSL Fragment Shader\nDESCRIPTION: GLSL fragment shader code for convolving an environment cubemap to create a diffuse irradiance map. It samples the hemisphere around each direction and averages the results.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/03 IBL/01 Diffuse irradiance.md#2025-04-22_snippet_8\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\nin vec3 localPos;\n\nuniform samplerCube environmentMap;\n\nconst float PI = 3.14159265359;\n\nvoid main()\n{\t\t\n    // the sample direction equals the hemisphere's orientation \n    vec3 normal = normalize(localPos);\n  \n    vec3 irradiance = vec3(0.0);\n  \n    [...] // convolution code\n  \n    FragColor = vec4(irradiance, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Equirectangular Map to Cubemap Faces in C++\nDESCRIPTION: This C++ code sets up the view matrices for each cubemap face and renders the equirectangular map to the cubemap texture.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/03 IBL/01 Diffuse irradiance.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nglm::mat4 captureProjection = glm::perspective(glm::radians(90.0f), 1.0f, 0.1f, 10.0f);\nglm::mat4 captureViews[] = \n{\n   glm::lookAt(glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3( 1.0f,  0.0f,  0.0f), glm::vec3(0.0f, -1.0f,  0.0f)),\n   glm::lookAt(glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(-1.0f,  0.0f,  0.0f), glm::vec3(0.0f, -1.0f,  0.0f)),\n   glm::lookAt(glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3( 0.0f,  1.0f,  0.0f), glm::vec3(0.0f,  0.0f,  1.0f)),\n   glm::lookAt(glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3( 0.0f, -1.0f,  0.0f), glm::vec3(0.0f,  0.0f, -1.0f)),\n   glm::lookAt(glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3( 0.0f,  0.0f,  1.0f), glm::vec3(0.0f, -1.0f,  0.0f)),\n   glm::lookAt(glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3( 0.0f,  0.0f, -1.0f), glm::vec3(0.0f, -1.0f,  0.0f))\n};\n\n// convert HDR equirectangular environment map to cubemap equivalent\nequirectangularToCubemapShader.use();\nequirectangularToCubemapShader.setInt(\"equirectangularMap\", 0);\nequirectangularToCubemapShader.setMat4(\"projection\", captureProjection);\nglActiveTexture(GL_TEXTURE0);\nglBindTexture(GL_TEXTURE_2D, hdrTexture);\n\nglViewport(0, 0, 512, 512); // don't forget to configure the viewport to the capture dimensions.\nglBindFramebuffer(GL_FRAMEBUFFER, captureFBO);\nfor (unsigned int i = 0; i < 6; ++i)\n{\n    equirectangularToCubemapShader.setMat4(\"view\", captureViews[i]);\n    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, \n                           GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, envCubemap, 0);\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n    renderCube(); // renders a 1x1 cube\n}\nglBindFramebuffer(GL_FRAMEBUFFER, 0);\n```\n\n----------------------------------------\n\nTITLE: Vertex Shader for Normal Visualization (GLSL)\nDESCRIPTION: This vertex shader transforms vertex positions and normals to prepare for normal visualization in the geometry shader.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/09 Geometry Shader.md#2025-04-22_snippet_11\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (location = 0) in vec3 aPos;\nlayout (location = 1) in vec3 aNormal;\n\nout VS_OUT {\n    vec3 normal;\n} vs_out;\n\nuniform mat4 view;\nuniform mat4 model;\n\nvoid main()\n{\n    gl_Position = view * model * vec4(aPos, 1.0); \n    mat3 normalMatrix = mat3(transpose(inverse(view * model)));\n    vs_out.normal = normalize(vec3(vec4(normalMatrix * aNormal, 0.0)));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Key Callback for Key State Management\nDESCRIPTION: Code for the GLFW key callback function that tracks key press and release events. It resets the key processing state when keys are released, allowing for proper key repeat handling in menus.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/10 Render Text.md#2025-04-22_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)\n{\n    [...]\n    if (key >= 0 && key < 1024)\n    {\n        if (action == GLFW_PRESS)\n            Breakout.Keys[key] = GL_TRUE;\n        else if (action == GLFW_RELEASE)\n        {\n            Breakout.Keys[key] = GL_FALSE;\n            Breakout.KeysProcessed[key] = GL_FALSE;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Stencil Testing in OpenGL\nDESCRIPTION: Basic code to enable the stencil test and clear the stencil buffer. This is the first step to using the stencil buffer for effects like object outlining.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/02 Stencil testing.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nglEnable(GL_STENCIL_TEST);\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader Input Structure\nDESCRIPTION: Defines the input structure in fragment shader matching the vertex shader output.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/04 Normal Mapping.md#2025-04-22_snippet_8\n\nLANGUAGE: GLSL\nCODE:\n```\nin VS_OUT {\n    vec3 FragPos;\n    vec2 TexCoords;\n    mat3 TBN;\n} fs_in;\n```\n\n----------------------------------------\n\nTITLE: Optimized Skybox Vertex Shader for Depth Testing\nDESCRIPTION: This optimized vertex shader for a skybox forces the z-coordinate to equal the w-coordinate, ensuring the skybox has a depth value of 1.0 after perspective division for proper depth testing.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/06 Cubemaps.md#2025-04-22_snippet_10\n\nLANGUAGE: GLSL\nCODE:\n```\nvoid main()\n{\n    TexCoords = aPos;\n    vec4 pos = projection * view * vec4(aPos, 1.0);\n    gl_Position = pos.xyww;\n}\n```\n\n----------------------------------------\n\nTITLE: Fresnel-Schlick Approximation with Roughness in GLSL\nDESCRIPTION: GLSL function for calculating the Fresnel-Schlick approximation with added roughness term, as proposed by Sébastien Lagarde.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/03 IBL/01 Diffuse irradiance.md#2025-04-22_snippet_13\n\nLANGUAGE: GLSL\nCODE:\n```\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}   \n```\n\n----------------------------------------\n\nTITLE: Fragment Shader for Transparent Textures with Blending\nDESCRIPTION: A simple fragment shader that outputs the texture color with its alpha component for use with OpenGL's blending. This shader doesn't discard fragments, relying on the blending mechanism instead.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/03 Blending.md#2025-04-22_snippet_9\n\nLANGUAGE: c++\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\n\nin vec2 TexCoords;\n\nuniform sampler2D texture1;\n\nvoid main()\n{             \n    FragColor = texture(texture1, TexCoords);\n}\n```\n\n----------------------------------------\n\nTITLE: Sampling Irradiance from Cubemap in GLSL Fragment Shader\nDESCRIPTION: Demonstrates how to sample the precomputed irradiance map using a surface normal vector in a GLSL fragment shader.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/03 IBL/01 Diffuse irradiance.md#2025-04-22_snippet_7\n\nLANGUAGE: GLSL\nCODE:\n```\nvec3 irradiance = texture(irradianceMap, N);\n```\n\n----------------------------------------\n\nTITLE: TBN Matrix Construction\nDESCRIPTION: Creates the TBN (Tangent-Bitangent-Normal) matrix by normalizing the transformed vectors.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/04 Normal Mapping.md#2025-04-22_snippet_6\n\nLANGUAGE: GLSL\nCODE:\n```\nvoid main()\n{\n   [...]\n   vec3 T = normalize(vec3(model * vec4(tangent,   0.0)));\n   vec3 B = normalize(vec3(model * vec4(bitangent, 0.0)));\n   vec3 N = normalize(vec3(model * vec4(normal,    0.0)));\n   mat3 TBN = mat3(T, B, N)\n}\n```\n\n----------------------------------------\n\nTITLE: Reinhard Tone Mapping with Gamma Correction in GLSL\nDESCRIPTION: A fragment shader implementing Reinhard tone mapping which evenly distributes HDR values to the LDR range. Includes gamma correction to ensure proper color representation on displays.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/06 HDR.md#2025-04-22_snippet_4\n\nLANGUAGE: glsl\nCODE:\n```\nvoid main()\n{             \n    const float gamma = 2.2;\n    vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb;\n  \n    // Reinhard色调映射\n    vec3 mapped = hdrColor / (hdrColor + vec3(1.0));\n    // Gamma校正\n    mapped = pow(mapped, vec3(1.0 / gamma));\n  \n    color = vec4(mapped, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up OpenGL for Text Rendering in C++\nDESCRIPTION: Enables blending, sets up orthographic projection, and initializes VAO and VBO for rendering text quads.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/02 Text Rendering.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nglEnable(GL_BLEND);\nglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\nglm::mat4 projection = glm::ortho(0.0f, 800.0f, 0.0f, 600.0f);\n\nGLuint VAO, VBO;\nglGenVertexArrays(1, &VAO);\nglGenBuffers(1, &VBO);\nglBindVertexArray(VAO);\nglBindBuffer(GL_ARRAY_BUFFER, VBO);\nglBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * 6 * 4, NULL, GL_DYNAMIC_DRAW);\nglEnableVertexAttribArray(0);\nglVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(GLfloat), 0);\nglBindBuffer(GL_ARRAY_BUFFER, 0);\nglBindVertexArray(0);\n```\n\n----------------------------------------\n\nTITLE: Vertex Shader for Cubemap Conversion in GLSL\nDESCRIPTION: This vertex shader passes the local position of the cube vertices to the fragment shader for sampling the equirectangular map.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/03 IBL/01 Diffuse irradiance.md#2025-04-22_snippet_0\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (location = 0) in vec3 aPos;\n\nout vec3 localPos;\n\nuniform mat4 projection;\nuniform mat4 view;\n\nvoid main()\n{\n    localPos = aPos;  \n    gl_Position =  projection * view * vec4(localPos, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Material Structure in GLSL Fragment Shader\nDESCRIPTION: Creates a material structure in GLSL that stores ambient, diffuse, specular colors and shininess properties. This struct allows for precise control over how a surface reacts to different lighting components.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/03 Materials.md#2025-04-22_snippet_0\n\nLANGUAGE: glsl\nCODE:\n```\n#version 330 core\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n}; \n  \nuniform Material material;\n```\n\n----------------------------------------\n\nTITLE: Vertex Shader with Color Output in GLSL\nDESCRIPTION: A vertex shader that passes both position and color data to the geometry shader using an interface block.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/09 Geometry Shader.md#2025-04-22_snippet_5\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (location = 0) in vec2 aPos;\nlayout (location = 1) in vec3 aColor;\n\nout VS_OUT {\n    vec3 color;\n} vs_out;\n\nvoid main()\n{\n    gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0); \n    vs_out.color = aColor;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Bottom Boundary Collision in C++\nDESCRIPTION: Code snippet to check if the ball has hit the bottom boundary and reset the game if true.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/05 Collisions/03 Collision resolution.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nvoid Game::Update(GLfloat dt)\n{\n    [...]\n    if (Ball->Position.y >= this->Height) // 球是否接触底部边界？\n    {\n        this->ResetLevel();\n        this->ResetPlayer();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Scene to Depth Cubemap Using Framebuffer Iteration\nDESCRIPTION: A loop that iterates through each face of a cubemap, attaching each face to the framebuffer, binding the appropriate view matrix, and rendering the scene from that perspective. This approach renders the scene six times for a complete cubemap.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/02 Point Shadows.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nfor(int i = 0; i < 6; i++)\n{\n    GLuint face = GL_TEXTURE_CUBE_MAP_POSITIVE_X + i;\n    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, face, depthCubemap, 0);\n    BindViewMatrix(lightViewMatrices[i]);\n    RenderScene();  \n}\n```\n\n----------------------------------------\n\nTITLE: Initializing FreeType and Loading a Font Face in C++\nDESCRIPTION: Initializes the FreeType library and loads a TrueType font file as a font face. It also sets the font size and loads a glyph.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/02 Text Rendering.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nFT_Library ft;\nif (FT_Init_FreeType(&ft))\n    std::cout << \"ERROR::FREETYPE: Could not init FreeType Library\" << std::endl;\n\nFT_Face face;\nif (FT_New_Face(ft, \"fonts/arial.ttf\", 0, &face))\n    std::cout << \"ERROR::FREETYPE: Failed to load font\" << std::endl;\n\nFT_Set_Pixel_Sizes(face, 0, 48);\n\nif (FT_Load_Char(face, 'X', FT_LOAD_RENDER))\n    std::cout << \"ERROR::FREETYTPE: Failed to load Glyph\" << std::endl;\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader with Uniform\nDESCRIPTION: A fragment shader that uses a uniform variable to set the output color.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/05 Shaders.md#2025-04-22_snippet_6\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\n  \nuniform vec4 ourColor; // 在OpenGL程序代码中设定这个变量\n\nvoid main()\n{\n    FragColor = ourColor;\n}\n```\n\n----------------------------------------\n\nTITLE: Skybox Fragment Shader for Displaying Cubemap in GLSL\nDESCRIPTION: This fragment shader samples the environment cubemap and applies tone mapping and gamma correction for display.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/03 IBL/01 Diffuse irradiance.md#2025-04-22_snippet_6\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\n\nin vec3 localPos;\n  \nuniform samplerCube environmentMap;\n  \nvoid main()\n{\n    vec3 envColor = texture(environmentMap, localPos).rgb;\n    \n    envColor = envColor / (envColor + vec3(1.0));\n    envColor = pow(envColor, vec3(1.0/2.2)); \n  \n    FragColor = vec4(envColor, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Material Properties in Fragment Shader Lighting Calculation\nDESCRIPTION: Modifies the lighting calculation in the fragment shader to use material properties from the material struct. The ambient, diffuse, and specular components are calculated using the corresponding material properties.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/03 Materials.md#2025-04-22_snippet_1\n\nLANGUAGE: glsl\nCODE:\n```\nvoid main()\n{    \n    // 环境光\n    vec3 ambient = lightColor * material.ambient;\n  \t\n    // 漫反射 \n    vec3 norm = normalize(Normal);\n    vec3 lightDir = normalize(lightPos - FragPos);\n    float diff = max(dot(norm, lightDir), 0.0);\n    vec3 diffuse = lightColor * (diff * material.diffuse);\n    \n    // 镜面光\n    vec3 viewDir = normalize(viewPos - FragPos);\n    vec3 reflectDir = reflect(-lightDir, norm);  \n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n    vec3 specular = lightColor * (spec * material.specular);  \n        \n    vec3 result = ambient + diffuse + specular;\n    FragColor = vec4(result, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader with Color Input\nDESCRIPTION: A fragment shader that receives a color input from the vertex shader and sets it as the output color.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/05 Shaders.md#2025-04-22_snippet_5\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\n  \nin vec4 vertexColor; // 从顶点着色器传来的输入变量（名称相同、类型相同）\n\nvoid main()\n{\n    FragColor = vertexColor;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Point Light Positions in C++\nDESCRIPTION: Creation of an array containing position vectors for multiple point lights in a 3D scene using the GLM library.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/06 Multiple lights.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nglm::vec3 pointLightPositions[] = {\n\tglm::vec3( 0.7f,  0.2f,  2.0f),\n\tglm::vec3( 2.3f, -3.3f, -4.0f),\n\tglm::vec3(-4.0f,  2.0f, -12.0f),\n\tglm::vec3( 0.0f,  0.0f, -3.0f)\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Character Structure and Map in C++\nDESCRIPTION: Defines a Character structure to store glyph metrics and texture ID, and creates a map to store Character objects for each ASCII character.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/02 Text Rendering.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nstruct Character {\n    GLuint     TextureID;  // 字形纹理的ID\n    glm::ivec2 Size;       // 字形大小\n    glm::ivec2 Bearing;    // 从基准线到字形左部/顶部的偏移值\n    GLuint     Advance;    // 原点距下一个字形原点的距离\n};\n\nstd::map<GLchar, Character> Characters;\n```\n\n----------------------------------------\n\nTITLE: Generating and Binding Texture in OpenGL\nDESCRIPTION: Generates a texture ID and binds it to GL_TEXTURE_2D target.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/06 Textures.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nunsigned int texture;\nglGenTextures(1, &texture);\nglBindTexture(GL_TEXTURE_2D, texture);\n```\n\n----------------------------------------\n\nTITLE: Setting Light Properties in C++ Application Code\nDESCRIPTION: Sets the light properties by setting uniform values in the shader. This example creates a soft white light by specifying appropriate ambient, diffuse, and specular intensity values.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/03 Materials.md#2025-04-22_snippet_5\n\nLANGUAGE: c++\nCODE:\n```\nlightingShader.setVec3(\"light.ambient\",  0.2f, 0.2f, 0.2f);\nlightingShader.setVec3(\"light.diffuse\",  0.5f, 0.5f, 0.5f); // 将光照调暗了一些以搭配场景\nlightingShader.setVec3(\"light.specular\", 1.0f, 1.0f, 1.0f);\n```\n\n----------------------------------------\n\nTITLE: Processing Texture Coordinates from Assimp in C++\nDESCRIPTION: Code snippet for extracting texture coordinates from an Assimp mesh, handling the case where the mesh might not have texture coordinates.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/03 Model Loading/03 Model.md#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nif(mesh->mTextureCoords[0]) // 网格是否有纹理坐标？\n{\n    glm::vec2 vec;\n    vec.x = mesh->mTextureCoords[0][i].x; \n    vec.y = mesh->mTextureCoords[0][i].y;\n    vertex.TexCoords = vec;\n}\nelse\n    vertex.TexCoords = glm::vec2(0.0f, 0.0f);\n```\n\n----------------------------------------\n\nTITLE: Implementing Hammersley Sequence without Bit Operations in GLSL\nDESCRIPTION: Alternative GLSL implementation of the Hammersley sequence that doesn't use bit operations, using the non-bitwise Van Der Corpus function.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/03 IBL/02 Specular IBL.md#2025-04-22_snippet_5\n\nLANGUAGE: GLSL\nCODE:\n```\nvec2 HammersleyNoBitOps(uint i, uint N)\n{\n    return vec2(float(i)/float(N), VanDerCorpus(i, 2u));\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Collision Tuple in C++\nDESCRIPTION: Typedef for a tuple containing collision information including boolean, direction, and vector.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/05 Collisions/03 Collision resolution.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\ntypedef std::tuple<GLboolean, Direction, glm::vec2> Collision;\n```\n\n----------------------------------------\n\nTITLE: Fixing Sticky Paddle Issue in C++\nDESCRIPTION: Code modification to fix the sticky paddle issue by always returning a positive y velocity.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/05 Collisions/03 Collision resolution.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\n//Ball->Velocity.y = -Ball->Velocity.y;\nBall->Velocity.y = -1 * abs(Ball->Velocity.y);\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader for Text Rendering in GLSL\nDESCRIPTION: Fragment shader that samples the glyph texture and applies color to render text with transparency.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/02 Text Rendering.md#2025-04-22_snippet_4\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nin vec2 TexCoords;\nout vec4 color;\n\nuniform sampler2D text;\nuniform vec3 textColor;\n\nvoid main()\n{    \n    vec4 sampled = vec4(1.0, 1.0, 1.0, texture(text, TexCoords).r);\n    color = vec4(textColor, 1.0) * sampled;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic OpenGL Instancing Loop\nDESCRIPTION: Shows the traditional approach of rendering multiple instances without instancing optimization\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/10 Instancing.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nfor(unsigned int i = 0; i < amount_of_models_to_draw; i++)\n{\n    DoSomePreparations(); // 绑定VAO，绑定纹理，设置uniform等\n    glDrawArrays(GL_TRIANGLES, 0, amount_of_vertices);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Uniform Values for Light Properties in C++\nDESCRIPTION: Example of how to set uniform values for a light struct array in OpenGL using C++. Shows how to access individual elements in a struct array.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/06 Multiple lights.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nlightingShader.setFloat(\"pointLights[0].constant\", 1.0f);\n```\n\n----------------------------------------\n\nTITLE: Configuring Vertex Attribute Pointers for Batched Attributes in OpenGL\nDESCRIPTION: Shows how to configure vertex attribute pointers when using a batched attribute layout, specifying the correct stride and offset parameters for each attribute.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/07 Advanced Data.md#2025-04-22_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), 0);  \nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)(sizeof(positions)));  \nglVertexAttribPointer(\n  2, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)(sizeof(positions) + sizeof(normals)));\n```\n\n----------------------------------------\n\nTITLE: Setting Camera Position Uniform in C++\nDESCRIPTION: C++ code for passing the camera position to the shader program as a uniform variable. This is needed for calculating the view direction in specular lighting.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/02 Basic Lighting.md#2025-04-22_snippet_8\n\nLANGUAGE: c++\nCODE:\n```\nlightingShader.setVec3(\"viewPos\", camera.Position);\n```\n\n----------------------------------------\n\nTITLE: Drawing Multiple Cubes with Different Shaders in C++\nDESCRIPTION: Shows how to draw multiple cubes using different shaders while sharing the same projection and view matrices through a Uniform Buffer Object in C++.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/08 Advanced GLSL.md#2025-04-22_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nglBindVertexArray(cubeVAO);\nshaderRed.use();\nglm::mat4 model;\nmodel = glm::translate(model, glm::vec3(-0.75f, 0.75f, 0.0f));\t// 移动到左上角\nshaderRed.setMat4(\"model\", model);\nglDrawArrays(GL_TRIANGLES, 0, 36);        \n// ... 绘制绿色立方体\n// ... 绘制蓝色立方体\n// ... 绘制黄色立方体 \n```\n\n----------------------------------------\n\nTITLE: Activating PowerUp Effects in C++\nDESCRIPTION: Implements the ActivatePowerUp function to apply different effects based on the powerup type, such as increasing ball speed, activating sticky paddle, or enabling pass-through.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/08 Powerups.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvoid ActivatePowerUp(PowerUp &powerUp)\n{\n    // 根据道具类型发动道具\n    if (powerUp.Type == \"speed\")\n    {\n        Ball->Velocity *= 1.2;\n    }\n    else if (powerUp.Type == \"sticky\")\n    {\n        Ball->Sticky = GL_TRUE;\n        Player->Color = glm::vec3(1.0f, 0.5f, 1.0f);\n    }\n    else if (powerUp.Type == \"pass-through\")\n    {\n        Ball->PassThrough = GL_TRUE;\n        Ball->Color = glm::vec3(1.0f, 0.5f, 0.5f);\n    }\n    else if (powerUp.Type == \"pad-size-increase\")\n    {\n        Player->Size.x += 50;\n    }\n    else if (powerUp.Type == \"confuse\")\n    {\n        if (!Effects->Chaos)\n            Effects->Confuse = GL_TRUE; // 只在chaos未激活时生效，chaos同理\n    }\n    else if (powerUp.Type == \"chaos\")\n    {\n        if (!Effects->Confuse)\n            Effects->Chaos = GL_TRUE;\n    }\n} \n```\n\n----------------------------------------\n\nTITLE: Loading Material Textures from Assimp in C++\nDESCRIPTION: Implementation of the loadMaterialTextures method that loads all textures of a specific type from an Assimp material, creating Texture objects for each.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/03 Model Loading/03 Model.md#2025-04-22_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nvector<Texture> loadMaterialTextures(aiMaterial *mat, aiTextureType type, string typeName)\n{\n    vector<Texture> textures;\n    for(unsigned int i = 0; i < mat->GetTextureCount(type); i++)\n    {\n        aiString str;\n        mat->GetTexture(type, i, &str);\n        Texture texture;\n        texture.id = TextureFromFile(str.C_Str(), directory);\n        texture.type = typeName;\n        texture.path = str;\n        textures.push_back(texture);\n    }\n    return textures;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Asteroid Transform Matrices in C++\nDESCRIPTION: Creates transformation matrices for multiple asteroids, positioning them in a ring around a planet with random offsets, scales, and rotations.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/10 Instancing.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nunsigned int amount = 1000;\nglm::mat4 *modelMatrices;\nmodelMatrices = new glm::mat4[amount];\nsrand(glfwGetTime()); // 初始化随机种子\t\nfloat radius = 50.0;\nfloat offset = 2.5f;\nfor(unsigned int i = 0; i < amount; i++)\n{\n    glm::mat4 model;\n    // 1. 位移：分布在半径为 'radius' 的圆形上，偏移的范围是 [-offset, offset]\n    float angle = (float)i / (float)amount * 360.0f;\n    float displacement = (rand() % (int)(2 * offset * 100)) / 100.0f - offset;\n    float x = sin(angle) * radius + displacement;\n    displacement = (rand() % (int)(2 * offset * 100)) / 100.0f - offset;\n    float y = displacement * 0.4f; // 让行星带的高度比x和z的宽度要小\n    displacement = (rand() % (int)(2 * offset * 100)) / 100.0f - offset;\n    float z = cos(angle) * radius + displacement;\n    model = glm::translate(model, glm::vec3(x, y, z));\n\n    // 2. 缩放：在 0.05 和 0.25f 之间缩放\n    float scale = (rand() % 20) / 100.0f + 0.05;\n    model = glm::scale(model, glm::vec3(scale));\n\n    // 3. 旋转：绕着一个（半）随机选择的旋转轴向量进行随机的旋转\n    float rotAngle = (rand() % 360);\n    model = glm::rotate(model, rotAngle, glm::vec3(0.4f, 0.6f, 0.8f));\n\n    // 4. 添加到矩阵的数组中\n    modelMatrices[i] = model;\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Multiple Objects with Transform Matrices in OpenGL\nDESCRIPTION: Code for rendering multiple cube objects at different positions in the scene. Each cube has a unique model matrix with translation and rotation applied to position it in the world space.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/05 Light casters.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nfor(unsigned int i = 0; i < 10; i++)\n{\n    glm::mat4 model;\n    model = glm::translate(model, cubePositions[i]);\n    float angle = 20.0f * i;\n    model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f));\n    lightingShader.setMat4(\"model\", model);\n\n    glDrawArrays(GL_TRIANGLES, 0, 36);\n}\n```\n\n----------------------------------------\n\nTITLE: Using OpenGL Extensions in C++\nDESCRIPTION: Demonstrates how to conditionally use OpenGL extensions by checking if they are supported by the hardware.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/01 OpenGL.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nif(GL_ARB_extension_name)\n{\n    // 使用硬件支持的全新的现代特性\n}\nelse\n{\n    // 不支持此扩展: 用旧的方式去做\n}\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader with Uniform Variable\nDESCRIPTION: A fragment shader that uses a uniform variable to set the output color, allowing the color to be changed from the CPU side.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/old/01/05 Shaders.md#2025-04-22_snippet_6\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\n\nout vec4 color;\n\nuniform vec4 ourColor; // We set this variable in the OpenGL code.\n\nvoid main()\n{\n    color = ourColor;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing TextRenderer in Game Class\nDESCRIPTION: Code for initializing the TextRenderer in the Game class. It creates a new TextRenderer instance with the game's width and height, then loads a specific font at a given size for rendering text in the game.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/10 Render Text.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nTextRenderer  *Text;\n\nvoid Game::Init()\n{\n    [...]\n    Text = new TextRenderer(this->Width, this->Height);\n    Text->Load(\"fonts/ocraext.TTF\", 24);\n}\n```\n\n----------------------------------------\n\nTITLE: Using glBufferSubData for Partial Buffer Updates in OpenGL\nDESCRIPTION: Demonstrates how to update a specific portion of a buffer using glBufferSubData, which takes a buffer target, offset, size of data, and the data itself as parameters.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/07 Advanced Data.md#2025-04-22_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\nglBufferSubData(GL_ARRAY_BUFFER, 24, sizeof(data), &data); // 范围： [24, 24 + sizeof(data)]\n```\n\n----------------------------------------\n\nTITLE: Instanced Vertex Shader with Attribute Arrays\nDESCRIPTION: Vertex shader implementation using instanced arrays instead of uniform arrays\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/10 Instancing.md#2025-04-22_snippet_5\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (location = 0) in vec2 aPos;\nlayout (location = 1) in vec3 aColor;\nlayout (location = 2) in vec2 aOffset;\n\nout vec3 fColor;\n\nvoid main()\n{\n    gl_Position = vec4(aPos + aOffset, 0.0, 1.0);\n    fColor = aColor;\n}\n```\n\n----------------------------------------\n\nTITLE: Copying Buffer Data with glCopyBufferSubData in OpenGL\nDESCRIPTION: Demonstrates how to copy data between buffers using dedicated copy buffer targets (GL_COPY_READ_BUFFER and GL_COPY_WRITE_BUFFER) to avoid binding conflicts.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/07 Advanced Data.md#2025-04-22_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\nglBindBuffer(GL_COPY_READ_BUFFER, vbo1);\nglBindBuffer(GL_COPY_WRITE_BUFFER, vbo2);\nglCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, sizeof(vertexData));\n```\n\n----------------------------------------\n\nTITLE: Updating Data in a Uniform Buffer Object in C++\nDESCRIPTION: Shows how to update data in a Uniform Buffer Object using glBufferSubData function in C++. This example updates a boolean value in the buffer.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/08 Advanced GLSL.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nglBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock);\nint b = true; // GLSL中的bool是4字节的，所以我们将它存为一个integer\nglBufferSubData(GL_UNIFORM_BUFFER, 144, 4, &b); \nglBindBuffer(GL_UNIFORM_BUFFER, 0);\n```\n\n----------------------------------------\n\nTITLE: Setting Stencil Mask in OpenGL\nDESCRIPTION: Function to control which bits of the stencil buffer can be written to. Similar to glDepthMask for depth testing, this allows selective updating of the stencil buffer.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/02 Stencil testing.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nglStencilMask(0xFF); // 每一位写入模板缓冲时都保持原样\nglStencilMask(0x00); // 每一位在写入模板缓冲时都会变成0（禁用写入）\n```\n\n----------------------------------------\n\nTITLE: Rendering Player Lives Text\nDESCRIPTION: Code for rendering the player's current number of lives as text in the top-left corner of the screen during active gameplay, providing visual feedback to the player about their remaining lives.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/10 Render Text.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nvoid Game::Render()\n{\n    if (this->State == GAME_ACTIVE)\n    {\n        [...]\n        std::stringstream ss; ss << this->Lives;\n        Text->RenderText(\"Lives:\" + ss.str(), 5.0f, 5.0f, 1.0f);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader with Alpha Discard for Transparent Textures\nDESCRIPTION: A fragment shader that discards fragments when their alpha value is below a threshold (0.1). This creates binary transparency (fully visible or invisible) without requiring alpha blending.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/03 Blending.md#2025-04-22_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\n\nin vec2 TexCoords;\n\nuniform sampler2D texture1;\n\nvoid main()\n{             \n    vec4 texColor = texture(texture1, TexCoords);\n    if(texColor.a < 0.1)\n        discard;\n    FragColor = texColor;\n}\n```\n\n----------------------------------------\n\nTITLE: Batched Vertex Attributes Using glBufferSubData in OpenGL\nDESCRIPTION: Demonstrates how to organize vertex attributes in a batched layout (all positions, then all normals, then all texture coordinates) using glBufferSubData to fill different sections of the buffer.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/07 Advanced Data.md#2025-04-22_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\nfloat positions[] = { ... };\nfloat normals[] = { ... };\nfloat tex[] = { ... };\n// 填充缓冲\nglBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(positions), &positions);\nglBufferSubData(GL_ARRAY_BUFFER, sizeof(positions), sizeof(normals), &normals);\nglBufferSubData(GL_ARRAY_BUFFER, sizeof(positions) + sizeof(normals), sizeof(tex), &tex);\n```\n\n----------------------------------------\n\nTITLE: Implementing Animator Class in C++\nDESCRIPTION: Defines the Animator class to manage and update skeletal animations. It handles playing animations, updating bone transformations, and calculating final bone matrices for rendering.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/08 Guest Articles/2020/01 Skeletal Animation.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nclass Animator\n{\t\npublic:\n    Animator::Animator(Animation* Animation)\n    {\n        m_CurrentTime = 0.0;\n        m_CurrentAnimation = currentAnimation;\n\n        m_FinalBoneMatrices.reserve(100);\n\n        for (int i = 0; i < 100; i++)\n            m_FinalBoneMatrices.push_back(glm::mat4(1.0f));\n    }\n\t\n    void Animator::UpdateAnimation(float dt)\n    {\n        m_DeltaTime = dt;\n        if (m_CurrentAnimation)\n        {\n            m_CurrentTime += m_CurrentAnimation->GetTicksPerSecond() * dt;\n            m_CurrentTime = fmod(m_CurrentTime, m_CurrentAnimation->GetDuration());\n            CalculateBoneTransform(&m_CurrentAnimation->GetRootNode(), glm::mat4(1.0f));\n        }\n    }\n\t\n    void Animator::PlayAnimation(Animation* pAnimation)\n    {\n        m_CurrentAnimation = pAnimation;\n        m_CurrentTime = 0.0f;\n    }\n\t\n    void Animator::CalculateBoneTransform(const AssimpNodeData* node, glm::mat4 parentTransform)\n    {\n        std::string nodeName = node->name;\n        glm::mat4 nodeTransform = node->transformation;\n\t\n        Bone* Bone = m_CurrentAnimation->FindBone(nodeName);\n\t\n        if (Bone)\n        {\n            Bone->Update(m_CurrentTime);\n            nodeTransform = Bone->GetLocalTransform();\n        }\n\t\n        glm::mat4 globalTransformation = parentTransform * nodeTransform;\n\t\n        auto boneInfoMap = m_CurrentAnimation->GetBoneIDMap();\n        if (boneInfoMap.find(nodeName) != boneInfoMap.end())\n        {\n            int index = boneInfoMap[nodeName].id;\n            glm::mat4 offset = boneInfoMap[nodeName].offset;\n            m_FinalBoneMatrices[index] = globalTransformation * offset;\n        }\n\t\n        for (int i = 0; i < node->childrenCount; i++)\n            CalculateBoneTransform(&node->children[i], globalTransformation);\n    }\n\t\n    std::vector<glm::mat4> GetFinalBoneMatrices() \n    { \n        return m_FinalBoneMatrices;  \n    }\n\t\t\nprivate:\n    std::vector<glm::mat4> m_FinalBoneMatrices;\n    Animation* m_CurrentAnimation;\n    float m_CurrentTime;\n    float m_DeltaTime;\t\n};\n```\n\n----------------------------------------\n\nTITLE: Setting Separate Blend Functions for RGB and Alpha\nDESCRIPTION: Configures different blend functions for RGB components and alpha component separately. This allows for more precise control over the blending operation.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/03 Blending.md#2025-04-22_snippet_7\n\nLANGUAGE: c++\nCODE:\n```\nglBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);\n```\n\n----------------------------------------\n\nTITLE: Defining Texture Struct for OpenGL Model Loading\nDESCRIPTION: Defines a Texture struct to store texture information including ID, type, and file path for comparison and caching.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/03 Model Loading/03 Model.md#2025-04-22_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\nstruct Texture {\n    unsigned int id;\n    string type;\n    aiString path;  // 我们储存纹理的路径用于与其它纹理进行比较\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Level Selection Controls\nDESCRIPTION: Code that handles level selection in the menu state. When the player presses W or S keys, the game cycles through available levels. The Enter key starts the game with the selected level.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/10 Render Text.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nif (this->State == GAME_MENU)\n{\n    if (this->Keys[GLFW_KEY_ENTER])\n        this->State = GAME_ACTIVE;\n    if (this->Keys[GLFW_KEY_W])\n        this->Level = (this->Level + 1) % 4;\n    if (this->Keys[GLFW_KEY_S])\n    {\n        if (this->Level > 0)\n            --this->Level;\n        else\n            this->Level = 3;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Multisampled Texture Attachment for Offscreen MSAA\nDESCRIPTION: Code that creates a multisampled texture to be used as an attachment for a framebuffer object. This allows for offscreen MSAA rendering, where the texture will store multiple samples per pixel.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/11 Anti Aliasing.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nglBindTexture(GL_TEXTURE_2D_MULTISAMPLE, tex);\nglTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, samples, GL_RGB, width, height, GL_TRUE);\nglBindTexture(GL_TEXTURE_2D_MULTISAMPLE, 0);\n```\n\n----------------------------------------\n\nTITLE: Setting Texture Wrapping Parameters in OpenGL\nDESCRIPTION: Sets texture wrapping parameters for S and T coordinates using glTexParameteri.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/06 Textures.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);\n```\n\n----------------------------------------\n\nTITLE: Player-Ball Collision Handling in C++\nDESCRIPTION: Code snippet to handle collisions between the player paddle and the ball, adjusting ball velocity based on impact point.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/05 Collisions/03 Collision resolution.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nvoid Game::DoCollisions()\n{\n    [...]\n    Collision result = CheckCollision(*Ball, *Player);\n    if (!Ball->Stuck && std::get<0>(result))\n    {\n        // 检查碰到了挡板的哪个位置，并根据碰到哪个位置来改变速度\n        GLfloat centerBoard = Player->Position.x + Player->Size.x / 2;\n        GLfloat distance = (Ball->Position.x + Ball->Radius) - centerBoard;\n        GLfloat percentage = distance / (Player->Size.x / 2);\n        // 依据结果移动\n        GLfloat strength = 2.0f;\n        glm::vec2 oldVelocity = Ball->Velocity;\n        Ball->Velocity.x = INITIAL_BALL_VELOCITY.x * percentage * strength; \n        Ball->Velocity.y = -Ball->Velocity.y;\n        Ball->Velocity = glm::normalize(Ball->Velocity) * glm::length(oldVelocity);\n    } \n}\n```\n\n----------------------------------------\n\nTITLE: GLSL Vector Construction Examples\nDESCRIPTION: Shows how to construct vectors in GLSL using other vectors and individual components.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/05 Shaders.md#2025-04-22_snippet_3\n\nLANGUAGE: GLSL\nCODE:\n```\nvec2 vect = vec2(0.5, 0.7);\nvec4 result = vec4(vect, 0.0, 0.0);\nvec4 otherResult = vec4(result.xyz, 1.0);\n```\n\n----------------------------------------\n\nTITLE: Initializing Camera Position in OpenGL\nDESCRIPTION: Sets up the initial camera position vector in world space coordinates, positioned along the positive z-axis.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/09 Camera.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nglm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f);\n```\n\n----------------------------------------\n\nTITLE: Processing Input in Win State\nDESCRIPTION: Code for handling player input in the win state. When the player presses Enter after winning, it disables special effects and returns to the menu screen for a new game.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/10 Render Text.md#2025-04-22_snippet_14\n\nLANGUAGE: C++\nCODE:\n```\nvoid Game::ProcessInput(GLfloat dt)\n{\n    [...]\n    if (this->State == GAME_WIN)\n    {\n        if (this->Keys[GLFW_KEY_ENTER])\n        {\n            this->KeysProcessed[GLFW_KEY_ENTER] = GL_TRUE;\n            Effects->Chaos = GL_FALSE;\n            this->State = GAME_MENU;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Textures with Alpha Channel in OpenGL C++\nDESCRIPTION: Sets up OpenGL texture generation with RGBA format to support alpha channel for transparency in textures. This ensures the alpha component is properly loaded from the image data.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/03 Blending.md#2025-04-22_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\nglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);\n```\n\n----------------------------------------\n\nTITLE: Setting Mipmap Filtering in OpenGL\nDESCRIPTION: Sets mipmap filtering options for minification and magnification using glTexParameteri.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/06 Textures.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n```\n\n----------------------------------------\n\nTITLE: Vertex Shader for Text Rendering in GLSL\nDESCRIPTION: Vertex shader that takes position and texture coordinates, applies a projection matrix, and passes texture coordinates to the fragment shader.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/02 Text Rendering.md#2025-04-22_snippet_3\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (location = 0) in vec4 vertex; // <vec2 pos, vec2 tex>\nout vec2 TexCoords;\n\nuniform mat4 projection;\n\nvoid main()\n{\n    gl_Position = projection * vec4(vertex.xy, 0.0, 1.0);\n    TexCoords = vertex.zw;\n}\n```\n\n----------------------------------------\n\nTITLE: GLSL Vector Swizzling Examples\nDESCRIPTION: Demonstrates various ways to use vector swizzling in GLSL to select and combine vector components.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/05 Shaders.md#2025-04-22_snippet_2\n\nLANGUAGE: GLSL\nCODE:\n```\nvec2 someVec;\nvec4 differentVec = someVec.xyxx;\nvec3 anotherVec = differentVec.zyw;\nvec4 otherVec = someVec.xxxx + anotherVec.yxzy;\n```\n\n----------------------------------------\n\nTITLE: SSAO Blur Shader in GLSL\nDESCRIPTION: This snippet shows the implementation of a simple blur shader used to smooth the SSAO texture and reduce noise artifacts.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/09 SSAO.md#2025-04-22_snippet_3\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nin vec2 TexCoords;\nout float fragColor;\n\nuniform sampler2D ssaoInput;\n\nvoid main() {\n    vec2 texelSize = 1.0 / vec2(textureSize(ssaoInput, 0));\n    float result = 0.0;\n    for (int x = -2; x < 2; ++x) \n    {\n        for (int y = -2; y < 2; ++y) \n        {\n            vec2 offset = vec2(float(x), float(y)) * texelSize;\n            result += texture(ssaoInput, TexCoords + offset).r;\n        }\n    }\n    fragColor = result / (4.0 * 4.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Framebuffer and Renderbuffer for Cubemap Capture in C++\nDESCRIPTION: This C++ code creates and configures a framebuffer and renderbuffer for capturing the cubemap faces.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/03 IBL/01 Diffuse irradiance.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nunsigned int captureFBO, captureRBO;\nglGenFramebuffers(1, &captureFBO);\nglGenRenderbuffers(1, &captureRBO);\n\nglBindFramebuffer(GL_FRAMEBUFFER, captureFBO);\nglBindRenderbuffer(GL_RENDERBUFFER, captureRBO);\nglRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, 512, 512);\nglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, captureRBO);\n```\n\n----------------------------------------\n\nTITLE: Spawning PowerUps in C++\nDESCRIPTION: Implements a function to spawn powerups with a certain probability when a brick is destroyed, setting various properties like type, color, and duration.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/08 Powerups.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nGLboolean ShouldSpawn(GLuint chance)\n{\n    GLuint random = rand() % chance;\n    return random == 0;\n}\nvoid Game::SpawnPowerUps(GameObject &block)\n{\n    if (ShouldSpawn(75)) // 1/75的几率\n        this->PowerUps.push_back(\n             PowerUp(\"speed\", glm::vec3(0.5f, 0.5f, 1.0f), 0.0f, block.Position, tex_speed\n         ));\n    if (ShouldSpawn(75))\n        this->PowerUps.push_back(\n            PowerUp(\"sticky\", glm::vec3(1.0f, 0.5f, 1.0f), 20.0f, block.Position, tex_sticky \n        );\n    if (ShouldSpawn(75))\n        this->PowerUps.push_back(\n            PowerUp(\"pass-through\", glm::vec3(0.5f, 1.0f, 0.5f), 10.0f, block.Position, tex_pass\n        ));\n    if (ShouldSpawn(75))\n        this->PowerUps.push_back(\n            PowerUp(\"pad-size-increase\", glm::vec3(1.0f, 0.6f, 0.4), 0.0f, block.Position, tex_size    \n        ));\n    if (ShouldSpawn(15)) // 负面道具被更频繁地生成\n        this->PowerUps.push_back(\n            PowerUp(\"confuse\", glm::vec3(1.0f, 0.3f, 0.3f), 15.0f, block.Position, tex_confuse\n        ));\n    if (ShouldSpawn(15))\n        this->PowerUps.push_back(\n            PowerUp(\"chaos\", glm::vec3(0.9f, 0.25f, 0.25f), 15.0f, block.Position, tex_chaos\n        ));\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Buffer Copying with Mixed Target Types in OpenGL\nDESCRIPTION: Shows an alternative approach to buffer copying where only one buffer uses a special copy target while the other uses a standard buffer target.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/07 Advanced Data.md#2025-04-22_snippet_5\n\nLANGUAGE: c++\nCODE:\n```\nfloat vertexData[] = { ... };\nglBindBuffer(GL_ARRAY_BUFFER, vbo1);\nglBindBuffer(GL_COPY_WRITE_BUFFER, vbo2);\nglCopyBufferSubData(GL_ARRAY_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, sizeof(vertexData));\n```\n\n----------------------------------------\n\nTITLE: Pass-through Geometry Shader in GLSL\nDESCRIPTION: A geometry shader that simply passes the input point through without modification.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/09 Geometry Shader.md#2025-04-22_snippet_3\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (points) in;\nlayout (points, max_vertices = 1) out;\n\nvoid main() {    \n    gl_Position = gl_in[0].gl_Position; \n    EmitVertex();\n    EndPrimitive();\n}\n```\n\n----------------------------------------\n\nTITLE: Copying Depth Buffer Between Framebuffers in OpenGL\nDESCRIPTION: Code that uses glBlitFramebuffer to copy the depth information from the geometry pass framebuffer to the default framebuffer, allowing proper depth testing for light cubes rendered with forward rendering.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/08 Deferred Shading.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nglBindFramebuffer(GL_READ_FRAMEBUFFER, gBuffer);\nglBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0); // 写入到默认帧缓冲\nglBlitFramebuffer(\n  0, 0, SCR_WIDTH, SCR_HEIGHT, 0, 0, SCR_WIDTH, SCR_HEIGHT, GL_DEPTH_BUFFER_BIT, GL_NEAREST\n);\nglBindFramebuffer(GL_FRAMEBUFFER, 0);\n// 现在像之前一样渲染光立方体\n[...]  \n```\n\n----------------------------------------\n\nTITLE: Adding Key Processing State to Game Class\nDESCRIPTION: Code that adds a property to track which keys have been processed to prevent rapid key repeating. This improves menu navigation by ensuring each keypress only registers once until the key is released.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/10 Render Text.md#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nclass Game\n{\n    [...]\n    public:\n        GLboolean KeysProcessed[1024];\n}\n```\n\n----------------------------------------\n\nTITLE: Skybox Vertex Shader for Displaying Cubemap in GLSL\nDESCRIPTION: This vertex shader prepares the coordinates for sampling the environment cubemap in the fragment shader.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/03 IBL/01 Diffuse irradiance.md#2025-04-22_snippet_5\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (location = 0) in vec3 aPos;\n\nuniform mat4 projection;\nuniform mat4 view;\n\nout vec3 localPos;\n\nvoid main()\n{\n    localPos = aPos;\n\n    mat4 rotView = mat4(mat3(view)); // remove translation from the view matrix\n    vec4 clipPos = projection * rotView * vec4(localPos, 1.0);\n\n    gl_Position = clipPos.xyww;\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Image with stb_image in C++\nDESCRIPTION: Loads an image file using the stb_image library and stores its properties.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/06 Textures.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nint width, height, nrChannels;\nunsigned char *data = stbi_load(\"container.jpg\", &width, &height, &nrChannels, 0);\n```\n\n----------------------------------------\n\nTITLE: OpenGL Rendering Loop with Uniform Updates\nDESCRIPTION: Shows a basic OpenGL rendering loop that updates a uniform variable each frame to create an animated effect.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/old/01/05 Shaders.md#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nwhile(!glfwWindowShouldClose(window))\n{\n    // Check and call events\n    glfwPollEvents();\n\n    // Render\n    // Clear the colorbuffer\n    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    // Be sure to activate the shader\n    glUseProgram(shaderProgram);\n\n    // Update the uniform color\n    GLfloat timeValue = glfwGetTime();\n    GLfloat greenValue = (sin(timeValue) / 2) + 0.5;\n    GLint vertexColorLocation = glGetUniformLocation(shaderProgram, \"ourColor\");\n    glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);\n\n    // Now draw the triangle\n    glBindVertexArray(VAO);\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n    glBindVertexArray(0);\n}\n```\n\n----------------------------------------\n\nTITLE: Vertex Shader for Point Rendering in GLSL\nDESCRIPTION: A basic vertex shader that sets the position of points in 2D space.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/09 Geometry Shader.md#2025-04-22_snippet_1\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nlayout (location = 0) in vec2 aPos;\n\nvoid main()\n{\n    gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0); \n}\n```\n\n----------------------------------------\n\nTITLE: Scaling Matrix in LaTeX\nDESCRIPTION: Defines a 4x4 scaling matrix for 3D transformations. Shows how scaling factors are applied to x, y, and z components of a vector.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/07 Transformations.md#2025-04-22_snippet_3\n\nLANGUAGE: latex\nCODE:\n```\n$$\n\\begin{bmatrix} \\color{red}{S_1} & \\color{red}0 & \\color{red}0 & \\color{red}0 \\\\ \\color{green}0 & \\color{green}{S_2} & \\color{green}0 & \\color{green}0 \\\\ \\color{blue}0 & \\color{blue}0 & \\color{blue}{S_3} & \\color{blue}0 \\\\ \\color{purple}0 & \\color{purple}0 & \\color{purple}0 & \\color{purple}1 \\end{bmatrix} \\cdot \\begin{pmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} \\color{red}{S_1} \\cdot x \\\\ \\color{green}{S_2} \\cdot y \\\\ \\color{blue}{S_3} \\cdot z \\\\ 1 \\end{pmatrix}\n$$\n```\n\n----------------------------------------\n\nTITLE: Setting Light Direction in OpenGL\nDESCRIPTION: Code that sets the direction of a directional light source in OpenGL. The direction is defined as a 3D vector pointing from where the light is coming from.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/05 Light casters.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nlightingShader.setVec3(\"light.direction\", -0.2f, -1.0f, -0.3f);\n```\n\n----------------------------------------\n\nTITLE: Creating Irradiance Cubemap Texture in OpenGL\nDESCRIPTION: C++ code for creating an OpenGL cubemap texture to store the precomputed irradiance map. It sets up a 32x32 floating-point RGB cubemap.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/03 IBL/01 Diffuse irradiance.md#2025-04-22_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nunsigned int irradianceMap;\nglGenTextures(1, &irradianceMap);\nglBindTexture(GL_TEXTURE_CUBE_MAP, irradianceMap);\nfor (unsigned int i = 0; i < 6; ++i)\n{\n    glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB16F, 32, 32, 0, \n                 GL_RGB, GL_FLOAT, nullptr);\n}\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n```\n\n----------------------------------------\n\nTITLE: Vertex Data with Position and Color\nDESCRIPTION: Defines vertex data that includes both position and color information for each vertex.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/05 Shaders.md#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nfloat vertices[] = {\n    // 位置              // 颜色\n     0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f,   // 右下\n    -0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,   // 左下\n     0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f    // 顶部\n};\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader with Color Input\nDESCRIPTION: A simple fragment shader that receives a color input from the vertex shader and uses it as the output color.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/old/01/05 Shaders.md#2025-04-22_snippet_5\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nin vec4 vertexColor; // The input variable from the vertex shader (same name and same type)\n\nout vec4 color;\n\nvoid main()\n{\n    color = vertexColor;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PowerUp Class in C++\nDESCRIPTION: Defines a PowerUp class that inherits from GameObject, with additional properties for type, duration, and activation status.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/08 Powerups.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nconst glm::vec2 SIZE(60, 20);\nconst glm::vec2 VELOCITY(0.0f, 150.0f);\n\nclass PowerUp : public GameObject \n{\npublic:\n    // 道具类型\n    std::string Type;\n    GLfloat     Duration;   \n    GLboolean   Activated;\n    // 构造函数\n    PowerUp(std::string type, glm::vec3 color, GLfloat duration, \n            glm::vec2 position, Texture2D texture) \n        : GameObject(position, SIZE, texture, color, VELOCITY), \n          Type(type), Duration(duration), Activated() \n    { }\n}; \n```\n\n----------------------------------------\n\nTITLE: Calculating Cosine Theta in GLSL\nDESCRIPTION: Shows how to calculate the cosine of the angle between the light direction and surface normal.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/01 Theory.md#2025-04-22_snippet_1\n\nLANGUAGE: GLSL\nCODE:\n```\nfloat cosTheta = dot(lightDir, N);\n```\n\n----------------------------------------\n\nTITLE: Attaching a Multisampled Texture to a Framebuffer\nDESCRIPTION: Code that attaches a previously created multisampled texture to a framebuffer as a color attachment, enabling offscreen MSAA rendering to a texture.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/11 Anti Aliasing.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, tex, 0);\n```\n\n----------------------------------------\n\nTITLE: OpenGL Performance Query Setup\nDESCRIPTION: C++ code for setting up OpenGL query objects to measure rendering performance.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/08 Guest Articles/2022/03 Area Lights.md#2025-04-22_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\nGLuint timeQuery;\nglGenQueries(1, &timeQuery);\n\nGLuint64 totalQueryTimeNs = 0;\nGLuint64 numQueries = 0;\n\nwhile (!glfwWindowShouldClose(window))\n{\n    [...]\n\n    glBeginQuery(GL_TIME_ELAPSED, timeQuery);\n    renderPlane();\n    glEndQuery(GL_TIME_ELAPSED);\n\n    GLuint64 elapsed = 0;\n    glGetQueryObjectui64v(timeQuery, GL_QUERY_RESULT, &elapsed);\n    numQueries++;\n    totalQueryTimeNs += elapsed;\n}\n\ndouble measuredAverageNs = (double)totalQueryTimeNs / (double)numQueries;\ndouble measuredAverageMs = measuredAverageNs * 1.0e-6;\nstd::cout << \"Total average time(ms) = \" << measuredAverageMs << '\\n';\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader for Normal Visualization (GLSL)\nDESCRIPTION: This simple fragment shader colors the normal visualization lines with a solid color for easy visibility.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/09 Geometry Shader.md#2025-04-22_snippet_13\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\n\nvoid main()\n{\n    FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Maximum Vertex Attributes in OpenGL\nDESCRIPTION: Shows how to query the maximum number of vertex attributes supported by the OpenGL implementation using glGetIntegerv.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/old/01/05 Shaders.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nGLint nrAttributes;\nglGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &nrAttributes);\nstd::cout << \"Maximum nr of vertex attributes supported: \" << nrAttributes << std::endl;\n```\n\n----------------------------------------\n\nTITLE: Defining GameState Enum for Game State Management in C++\nDESCRIPTION: Enumeration that defines possible game states (active gameplay, menu screen, and win state) to track the current state and determine appropriate rendering and processing of game elements.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/02 Setting up.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n// 代表了游戏的当前状态\nenum GameState {\n    GAME_ACTIVE,\n    GAME_MENU,\n    GAME_WIN\n}; \n```\n\n----------------------------------------\n\nTITLE: Defining Texture Coordinates in C++\nDESCRIPTION: Defines an array of texture coordinates for a triangle.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/06 Textures.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nfloat texCoords[] = {\n    0.0f, 0.0f, // 左下角\n    1.0f, 0.0f, // 右下角\n    0.5f, 1.0f  // 上中\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Texture Loading with Caching in OpenGL\nDESCRIPTION: Updates the loadMaterialTextures function to check for previously loaded textures before loading new ones, optimizing texture loading performance.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/03 Model Loading/03 Model.md#2025-04-22_snippet_14\n\nLANGUAGE: C++\nCODE:\n```\nvector<Texture> loadMaterialTextures(aiMaterial *mat, aiTextureType type, string typeName)\n{\n    vector<Texture> textures;\n    for(unsigned int i = 0; i < mat->GetTextureCount(type); i++)\n    {\n        aiString str;\n        mat->GetTexture(type, i, &str);\n        bool skip = false;\n        for(unsigned int j = 0; j < textures_loaded.size(); j++)\n        {\n            if(std::strcmp(textures_loaded[j].path.data(), str.C_Str()) == 0)\n            {\n                textures.push_back(textures_loaded[j]);\n                skip = true; \n                break;\n            }\n        }\n        if(!skip)\n        {   // 如果纹理还没有被加载，则加载它\n            Texture texture;\n            texture.id = TextureFromFile(str.C_Str(), directory);\n            texture.type = typeName;\n            texture.path = str.C_Str();\n            textures.push_back(texture);\n            textures_loaded.push_back(texture); // 添加到已加载的纹理中\n        }\n    }\n    return textures;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Vertex Attribute Pointers\nDESCRIPTION: Shows how to configure vertex attribute pointers for both position and color data in the vertex buffer.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/05 Shaders.md#2025-04-22_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\n// 位置属性\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);\nglEnableVertexAttribArray(0);\n// 颜色属性\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3* sizeof(float)));\nglEnableVertexAttribArray(1);\n```\n\n----------------------------------------\n\nTITLE: Setting Texture Filtering Parameters in OpenGL\nDESCRIPTION: Sets texture filtering parameters for minification and magnification using glTexParameteri.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/06 Textures.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n```\n\n----------------------------------------\n\nTITLE: Assimp Model Loading Configuration\nDESCRIPTION: Configures Assimp to calculate tangent space during model loading.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/04 Normal Mapping.md#2025-04-22_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nconst aiScene* scene = importer.ReadFile(\n    path, aiProcess_Triangulate | aiProcess_FlipUVs | aiProcess_CalcTangentSpace\n);\n```\n\n----------------------------------------\n\nTITLE: Updating Game State Based on Lives\nDESCRIPTION: Code that handles decreasing player lives when the ball hits the bottom boundary. If the player runs out of lives, the game is reset and the state is changed to GAME_MENU.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/10 Render Text.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvoid Game::Update(GLfloat dt)\n{\n    [...]\n    if (Ball->Position.y >= this->Height) // 球是否接触到底部边界?\n    {\n        --this->Lives;\n        // 玩家是否已失去所有生命值? : 游戏结束\n        if (this->Lives == 0)\n        {\n            this->ResetLevel();\n            this->State = GAME_MENU;\n        }\n        this->ResetPlayer();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Maximum Vertex Attributes in OpenGL\nDESCRIPTION: Shows how to query the maximum number of vertex attributes supported by the hardware using OpenGL.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/05 Shaders.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nint nrAttributes;\nglGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &nrAttributes);\nstd::cout << \"Maximum nr of vertex attributes supported: \" << nrAttributes << std::endl;\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader for Light Source in GLSL\nDESCRIPTION: Defines a simple fragment shader that sets a constant white color for the light source cube.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/01 Colors.md#2025-04-22_snippet_6\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\n\nvoid main()\n{\n    FragColor = vec4(1.0); // 将向量的四个分量全部设置为1.0\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Translation to a Vector using GLM in C++\nDESCRIPTION: Demonstrates how to create a translation matrix and apply it to a vector using GLM functions.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/07 Transformations.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nglm::vec4 vec(1.0f, 0.0f, 0.0f, 1.0f);\nglm::mat4 trans;\ntrans = glm::translate(trans, glm::vec3(1.0f, 1.0f, 0.0f));\nvec = trans * vec;\nstd::cout << vec.x << vec.y << vec.z << std::endl;\n```\n\n----------------------------------------\n\nTITLE: Setting Texture Border Color in OpenGL\nDESCRIPTION: Sets the border color for GL_CLAMP_TO_BORDER wrapping mode using glTexParameterfv.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/06 Textures.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nfloat borderColor[] = { 1.0f, 1.0f, 0.0f, 1.0f };\nglTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);\n```\n\n----------------------------------------\n\nTITLE: Resetting Player Lives When Resetting Level\nDESCRIPTION: Code that resets the player's lives to 3 when resetting the game level, ensuring the player starts with full lives at the beginning of each game session.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/10 Render Text.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvoid Game::ResetLevel()\n{\n    [...]\n    this->Lives = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Manually Loading OpenGL Function Pointers in C++\nDESCRIPTION: Shows the manual process of loading OpenGL function pointers at runtime, which is platform-specific and cumbersome. This is what GLAD aims to simplify.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/02 Creating a window.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n// 定义函数原型\ntypedef void (*GL_GENBUFFERS) (GLsizei, GLuint*);\n// 找到正确的函数并赋值给函数指针\nGL_GENBUFFERS glGenBuffers  = (GL_GENBUFFERS)wglGetProcAddress(\"glGenBuffers\");\n// 现在函数可以被正常调用了\nGLuint buffer;\nglGenBuffers(1, &buffer);\n```\n\n----------------------------------------\n\nTITLE: Applying Attenuation to Light Components in GLSL\nDESCRIPTION: GLSL code snippet that applies the calculated attenuation factor to ambient, diffuse, and specular light components to create distance-based light falloff effect.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/02 Lighting/05 Light casters.md#2025-04-22_snippet_6\n\nLANGUAGE: GLSL\nCODE:\n```\nambient  *= attenuation; \ndiffuse  *= attenuation;\nspecular *= attenuation;\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader for Object Outline Effect\nDESCRIPTION: A simple fragment shader that outputs a solid color, used for rendering object outlines. This shader is applied to the scaled-up versions of objects to create a border effect.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/02 Stencil testing.md#2025-04-22_snippet_4\n\nLANGUAGE: GLSL\nCODE:\n```\nvoid main()\n{\n    FragColor = vec4(0.04, 0.28, 0.26, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: Clearing Stencil Buffer with Other Buffers\nDESCRIPTION: Code to clear the stencil buffer along with color and depth buffers at the beginning of each frame.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/02 Stencil testing.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader Implementation\nDESCRIPTION: Basic fragment shader that outputs color received from vertex shader\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/10 Instancing.md#2025-04-22_snippet_2\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\n  \nin vec3 fColor;\n\nvoid main()\n{\n    FragColor = vec4(fColor, 1.0);\n}\n```\n\n----------------------------------------\n\nTITLE: LUT Matrix Construction\nDESCRIPTION: Code for preparing LUT parameters and constructing the transformation matrix using view and normal vectors.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/08 Guest Articles/2022/03 Area Lights.md#2025-04-22_snippet_1\n\nLANGUAGE: glsl\nCODE:\n```\nvec3 N = normalize(worldNormal);\nvec3 V = normalize(viewPosition - worldPosition);\nvec3 P = worldPosition;\nfloat dotNV = clamp(dot(N, V), 0.0f, 1.0f);\n\nvec2 uv = vec2(material.albedoRoughness.w, sqrt(1.0f - dotNV));\nuv = uv*LUT_SCALE + LUT_BIAS;\n\nvec4 t1 = texture(LTC1, uv);\nvec4 t2 = texture(LTC2, uv);\n\nmat3 Minv = mat3(\n    vec3(t1.x, 0, t1.y),\n    vec3(   0, 1,    0),\n    vec3(t1.z, 0, t1.w)\n);\n```\n\n----------------------------------------\n\nTITLE: Translation Array Generation\nDESCRIPTION: Generates translation vectors for instance positioning in a grid\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/10 Instancing.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nglm::vec2 translations[100];\nint index = 0;\nfloat offset = 0.1f;\nfor(int y = -10; y < 10; y += 2)\n{\n    for(int x = -10; x < 10; x += 2)\n    {\n        glm::vec2 translation;\n        translation.x = (float)x / 10.0f + offset;\n        translation.y = (float)y / 10.0f + offset;\n        translations[index++] = translation;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Development Image in Markdown\nDESCRIPTION: This snippet shows how to embed an image in Markdown, specifically a development placeholder image. The image is given a 'clean' class for styling purposes.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/05 Advanced Lighting/03 Shadows/03 CSM.md#2025-04-22_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n<img src=\"../../../img/development.png\" class=\"clean\">\n```\n\n----------------------------------------\n\nTITLE: Including Assimp Headers for 3D Model Loading in C++\nDESCRIPTION: Including the necessary Assimp headers to access the functionality needed for loading 3D models.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/03 Model Loading/03 Model.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n#include <assimp/Importer.hpp>\n#include <assimp/scene.h>\n#include <assimp/postprocess.h>\n```\n\n----------------------------------------\n\nTITLE: Translation Matrix in LaTeX\nDESCRIPTION: Defines a 4x4 translation matrix for 3D transformations. Demonstrates how translation values are added to x, y, and z components of a vector.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/07 Transformations.md#2025-04-22_snippet_4\n\nLANGUAGE: latex\nCODE:\n```\n$$\n\\begin{bmatrix}  \\color{red}1 & \\color{red}0 & \\color{red}0 & \\color{red}{T_x} \\\\ \\color{green}0 & \\color{green}1 & \\color{green}0 & \\color{green}{T_y} \\\\ \\color{blue}0 & \\color{blue}0 & \\color{blue}1 & \\color{blue}{T_z} \\\\ \\color{purple}0 & \\color{purple}0 & \\color{purple}0 & \\color{purple}1 \\end{bmatrix} \\cdot \\begin{pmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} x + \\color{red}{T_x} \\\\ y + \\color{green}{T_y} \\\\ z + \\color{blue}{T_z} \\\\ 1 \\end{pmatrix}\n$$\n```\n\n----------------------------------------\n\nTITLE: Approximating the Reflectance Equation with Riemann Sum in C++\nDESCRIPTION: Demonstrates how to approximate the reflectance equation integral using a Riemann sum in C++.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/07 PBR/01 Theory.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nint steps = 100;\nfloat sum = 0.0f;\nvec3 P    = ...;\nvec3 Wo   = ...;\nvec3 N    = ...;\nfloat dW  = 1.0f / steps;\nfor(int i = 0; i < steps; ++i)\n{\n    vec3 Wi = getNextIncomingLightDir(i);\n    sum += Fr(p, Wi, Wo) * L(p, Wi) * dot(N, Wi) * dW;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Level Completion Check Method\nDESCRIPTION: A method in the GameLevel class that checks if the current level is completed by verifying that all non-solid bricks have been destroyed. Returns true only when all destructible bricks are gone.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/10 Render Text.md#2025-04-22_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nGLboolean GameLevel::IsCompleted()\n{\n    for (GameObject &tile : this->Bricks)\n        if (!tile.IsSolid && !tile.Destroyed)\n            return GL_FALSE;\n    return GL_TRUE;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Vegetation Positions for Scene Setup\nDESCRIPTION: Initializes a vector of 3D positions where vegetation (grass) objects will be placed in the scene. These coordinates are used when rendering the grass textures on quads.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/03 Blending.md#2025-04-22_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\nvector<glm::vec3> vegetation;\nvegetation.push_back(glm::vec3(-1.5f,  0.0f, -0.48f));\nvegetation.push_back(glm::vec3( 1.5f,  0.0f,  0.51f));\nvegetation.push_back(glm::vec3( 0.0f,  0.0f,  0.7f));\nvegetation.push_back(glm::vec3(-0.3f,  0.0f, -2.3f));\nvegetation.push_back(glm::vec3( 0.5f,  0.0f, -0.6f));\n```\n\n----------------------------------------\n\nTITLE: Defining Direction Enum in C++\nDESCRIPTION: Enum definition for collision directions in the Game class header file.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/05 Collisions/03 Collision resolution.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nenum Direction {\n\tUP,\n\tRIGHT,\n\tDOWN,\n\tLEFT\n};\n```\n\n----------------------------------------\n\nTITLE: Matrix Multiplication Example in LaTeX\nDESCRIPTION: Demonstrates the multiplication of two 2x2 matrices using LaTeX notation. Shows the step-by-step process of multiplying corresponding elements and summing the results.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/07 Transformations.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n$$\n\\begin{bmatrix} \\color{red}1 & \\color{red}2 \\\\ \\color{green}3 & \\color{green}4 \\end{bmatrix} \\cdot \\begin{bmatrix} \\color{blue}5 & \\color{purple}6 \\\\ \\color{blue}7 & \\color{purple}8 \\end{bmatrix} = \\begin{bmatrix} \\color{red}1 \\cdot \\color{blue}5 + \\color{red}2 \\cdot \\color{blue}7 & \\color{red}1 \\cdot \\color{purple}6 + \\color{red}2 \\cdot \\color{purple}8 \\\\ \\color{green}3 \\cdot \\color{blue}5 + \\color{green}4 \\cdot \\color{blue}7 & \\color{green}3 \\cdot \\color{purple}6 + \\color{green}4 \\cdot \\color{purple}8 \\end{bmatrix} = \\begin{bmatrix} 19 & 22 \\\\ 43 & 50 \\end{bmatrix}\n$$\n```\n\n----------------------------------------\n\nTITLE: Debugging Shader Output in GLSL Fragment Shader\nDESCRIPTION: This snippet shows how to output shader variables directly to the color output for debugging purposes. It demonstrates outputting the Normal vector to visualize its correctness.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/01 Debugging.md#2025-04-22_snippet_8\n\nLANGUAGE: GLSL\nCODE:\n```\n#version 330 core\nout vec4 FragColor;\nin vec3 Normal;\n[...]\n  \nvoid main()\n{\n    [...]\n    FragColor.rgb = Normal;\n    FragColor.a = 1.0f;\n}\n```\n\n----------------------------------------\n\nTITLE: Quad Vertex Data Definition\nDESCRIPTION: Defines vertex data for a quad including position and color attributes\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/04 Advanced OpenGL/10 Instancing.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nfloat quadVertices[] = {\n    // 位置          // 颜色\n    -0.05f,  0.05f,  1.0f, 0.0f, 0.0f,\n     0.05f, -0.05f,  0.0f, 1.0f, 0.0f,\n    -0.05f, -0.05f,  0.0f, 0.0f, 1.0f,\n\n    -0.05f,  0.05f,  1.0f, 0.0f, 0.0f,\n     0.05f, -0.05f,  0.0f, 1.0f, 0.0f,   \n     0.05f,  0.05f,  0.0f, 1.0f, 1.0f\t\t    \t\t\n};\n```\n\n----------------------------------------\n\nTITLE: Including GLAD Header in C++\nDESCRIPTION: Shows how to include the GLAD header after setting it up, which simplifies loading OpenGL functions.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/02 Creating a window.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n#include <glad/glad.h>\n```\n\n----------------------------------------\n\nTITLE: Identity Matrix Multiplication in LaTeX\nDESCRIPTION: Illustrates the multiplication of a 4x4 identity matrix with a 4x1 vector. Demonstrates that multiplying by an identity matrix does not change the vector.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/07 Transformations.md#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\n$$\n\\begin{bmatrix} \\color{red}1 & \\color{red}0 & \\color{red}0 & \\color{red}0 \\\\ \\color{green}0 & \\color{green}1 & \\color{green}0 & \\color{green}0 \\\\ \\color{blue}0 & \\color{blue}0 & \\color{blue}1 & \\color{blue}0 \\\\ \\color{purple}0 & \\color{purple}0 & \\color{purple}0 & \\color{purple}1 \\end{bmatrix} \\cdot \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\end{bmatrix} = \\begin{bmatrix} \\color{red}1 \\cdot 1 \\\\ \\color{green}1 \\cdot 2 \\\\ \\color{blue}1 \\cdot 3 \\\\ \\color{purple}1 \\cdot 4 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\end{bmatrix}\n$$\n```\n\n----------------------------------------\n\nTITLE: Checking for Debug Context Support in OpenGL using C++\nDESCRIPTION: Demonstrates how to check if a debug context was successfully initialized for OpenGL after GLFW initialization.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/01 Debugging.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nGLint flags; glGetIntegerv(GL_CONTEXT_FLAGS, &flags);\nif (flags & GL_CONTEXT_FLAG_DEBUG_BIT)\n{\n    // 初始化调试输出 \n}\n```\n\n----------------------------------------\n\nTITLE: Including GLFW Header in C++\nDESCRIPTION: Demonstrates how to include the GLFW header file after configuring the include directories.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/02 Creating a window.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <GLFW\\glfw3.h>\n```\n\n----------------------------------------\n\nTITLE: Including GLM Headers in C++\nDESCRIPTION: Include necessary GLM headers for matrix operations and transformations.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/07 Transformations.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n```\n\n----------------------------------------\n\nTITLE: Edge Integration Function\nDESCRIPTION: Function for calculating single edge integration using cross products and arc length.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/08 Guest Articles/2022/03 Area Lights.md#2025-04-22_snippet_2\n\nLANGUAGE: glsl\nCODE:\n```\nvec3 IntegrateEdge(vec3 v1, vec3 v2, vec3 N) {\n    float x = dot(v1, v2);\n    float y = abs(x);\n    float a = 0.8543985 + (0.4965155 + 0.0145206*y)*y;\n    float b = 3.4175940 + (4.1616724 + y)*y;\n    float v = a / b;\n    float theta_sintheta = (x > 0.0) ? v : 0.5*inversesqrt(max(1.0 - x*x, 1e-7)) - v;\n    return cross(v1, v2)*theta_sintheta;\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Output Context in GLFW for OpenGL in C++\nDESCRIPTION: Shows how to enable a debug output context when initializing GLFW for OpenGL. This allows for more detailed error reporting.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/01 Debugging.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nglfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, true);\n```\n\n----------------------------------------\n\nTITLE: Updating Game State for Win Condition\nDESCRIPTION: Code that checks if the current level is completed during gameplay. When all breakable bricks are destroyed, it transitions to the game win state and activates a special visual effect.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/2D-Game/10 Render Text.md#2025-04-22_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\nvoid Game::Update(GLfloat dt)\n{\n    [...]\n    if (this->State == GAME_ACTIVE && this->Levels[this->Level].IsCompleted())\n    {\n        this->ResetLevel();\n        this->ResetPlayer();\n        Effects->Chaos = GL_TRUE;\n        this->State = GAME_WIN;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: GLSL Vector Swizzling Examples\nDESCRIPTION: Demonstrates various ways to access and combine vector components in GLSL using swizzling.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/old/01/05 Shaders.md#2025-04-22_snippet_2\n\nLANGUAGE: GLSL\nCODE:\n```\nvec2 someVec;\nvec4 differentVec = someVec.xyxx;\nvec3 anotherVec = differentVec.zyw;\nvec4 otherVec = someVec.xxxx + anotherVec.yxzy;\n```\n\n----------------------------------------\n\nTITLE: OpenGL Object Structure Definition in C++\nDESCRIPTION: Shows a hypothetical C-style struct representing an OpenGL object with various options.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/01 OpenGL.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nstruct object_name {\n    float  option1;\n    int    option2;\n    char[] name;\n};\n```\n\n----------------------------------------\n\nTITLE: Using GLSL Reference Compiler in Bash\nDESCRIPTION: This command demonstrates how to use the GLSL reference compiler (glsllangvalidator) to validate a vertex shader file. It helps ensure cross-platform compatibility of shaders.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/06 In Practice/01 Debugging.md#2025-04-22_snippet_10\n\nLANGUAGE: Bash\nCODE:\n```\nglsllangvalidator shaderFile.vert\n```\n\n----------------------------------------\n\nTITLE: OpenGL Context Structure Definition in C++\nDESCRIPTION: Illustrates a simplified representation of the OpenGL context as a C++ struct containing object pointers.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/01 OpenGL.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n// OpenGL的状态\nstruct OpenGL_Context {\n  \t...\n  \tobject* object_Window_Target;\n  \t...  \t\n};\n```\n\n----------------------------------------\n\nTITLE: Larger Matrix Multiplication Example in LaTeX\nDESCRIPTION: Shows a more complex example of multiplying two 3x3 matrices. Uses color coding to highlight the pattern of element multiplication and summation.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/docs/01 Getting started/07 Transformations.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n$$\n\\begin{bmatrix} \\color{red}4 & \\color{red}2 & \\color{red}0 \\\\ \\color{green}0 & \\color{green}8 & \\color{green}1 \\\\ \\color{blue}0 & \\color{blue}1 & \\color{blue}0 \\end{bmatrix} \\cdot \\begin{bmatrix} \\color{red}4 & \\color{green}2 & \\color{blue}1 \\\\ \\color{red}2 & \\color{green}0 & \\color{blue}4 \\\\ \\color{red}9 & \\color{green}4 & \\color{blue}2 \\end{bmatrix} = \\begin{bmatrix} \\color{red}4 \\cdot \\color{red}4 + \\color{red}2 \\cdot \\color{red}2 + \\color{red}0 \\cdot \\color{red}9 & \\color{red}4 \\cdot \\color{green}2 + \\color{red}2 \\cdot \\color{green}0 + \\color{red}0 \\cdot \\color{green}4 & \\color{red}4 \\cdot \\color{blue}1 + \\color{red}2 \\cdot \\color{blue}4 + \\color{red}0 \\cdot \\color{blue}2 \\\\ \\color{green}0 \\cdot \\color{red}4 + \\color{green}8 \\cdot \\color{red}2 + \\color{green}1 \\cdot \\color{red}9 & \\color{green}0 \\cdot \\color{green}2 + \\color{green}8 \\cdot \\color{green}0 + \\color{green}1 \\cdot \\color{green}4 & \\color{green}0 \\cdot \\color{blue}1 + \\color{green}8 \\cdot \\color{blue}4 + \\color{green}1 \\cdot \\color{blue}2 \\\\ \\color{blue}0 \\cdot \\color{red}4 + \\color{blue}1 \\cdot \\color{red}2 + \\color{blue}0 \\cdot \\color{red}9 & \\color{blue}0 \\cdot \\color{green}2 + \\color{blue}1 \\cdot \\color{green}0 + \\color{blue}0 \\cdot \\color{green}4 & \\color{blue}0 \\cdot \\color{blue}1 + \\color{blue}1 \\cdot \\color{blue}4 + \\color{blue}0 \\cdot \\color{blue}2 \\end{bmatrix}\n \\\\ = \\begin{bmatrix} 20 & 8 & 12 \\\\ 25 & 4 & 34 \\\\ 2 & 0 & 4 \\end{bmatrix}\n$$\n```\n\n----------------------------------------\n\nTITLE: Building Documentation with MkDocs\nDESCRIPTION: Bash command for building the documentation site. The built files will be placed in the 'site' folder.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/README.md#2025-04-22_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\n$ mkdocs build\n```\n\n----------------------------------------\n\nTITLE: Running MkDocs Development Server\nDESCRIPTION: Bash command for running the MkDocs development server to test the documentation locally. The site will be accessible at 127.0.0.1:8000.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/README.md#2025-04-22_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\n$ mkdocs serve\n```\n\n----------------------------------------\n\nTITLE: Installing Python Dependencies for Build Environment\nDESCRIPTION: Bash command for installing the required Python packages (mkdocs and python-markdown-math) needed to build the documentation website.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/README.md#2025-04-22_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\n$ pip install mkdocs==1.4.2 python-markdown-math==0.8\n```\n\n----------------------------------------\n\nTITLE: Creating Translation Claim Template in Markdown\nDESCRIPTION: Template for contributors to claim translation tasks. The template includes fields for the original article title, source link, author, translator, and proofreader information.\nSOURCE: https://github.com/learnopengl-cn/learnopengl-cn/blob/new-theme/README.md#2025-04-22_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n原文     | [英文标题](原文地址)\n      ---|---\n作者     | JoeyDeVries\n翻译     | [翻译]\n校对     | 暂无\n```"
  }
]