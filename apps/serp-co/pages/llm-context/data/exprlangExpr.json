[
  {
    "owner": "expr-lang",
    "repo": "expr",
    "content": "TITLE: Defining a Function with expr.Function (Go)\nDESCRIPTION: This snippet shows how to define a function using the `expr.Function` option. This provides more control over the function's behavior and type safety. In this example, it defines a function named 'atoi' that converts a string to an integer using `strconv.Atoi`.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/functions.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\natoi := expr.Function(\n    \"atoi\",\n    func(params ...any) (any, error) {\n        return strconv.Atoi(params[0].(string))\n    },\n)\n\nprogram, err := expr.Compile(`atoi(\"42\")`, atoi)\n```\n\n----------------------------------------\n\nTITLE: Get Element By Index Using get() in Expr\nDESCRIPTION: The `get()` function retrieves the element at the specified index from an array or map. If the index is out of range, or the key does not exist, it returns `nil`.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_89\n\nLANGUAGE: expr\nCODE:\n```\nget([1, 2, 3], 1) == 2\nget({\"name\": \"John\", \"age\": 30}, \"name\") == \"John\"\n```\n\n----------------------------------------\n\nTITLE: Get Length Using len() in Expr\nDESCRIPTION: The `len()` function returns the length of an array, a map, or a string. It provides a unified way to determine the size of different data structures.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_88\n\nLANGUAGE: expr\nCODE:\n```\nlen([1, 2, 3]) == 3\nlen({\"name\": \"John\", \"age\": 30}) == 2\nlen(\"Hello\") == 5\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Signatures for a Function with expr.Function (Go)\nDESCRIPTION: This snippet demonstrates how to define multiple signatures for a single function using `expr.Function`. This allows the function to handle different input types. The `toInt` function can accept either a `float64` or a `string` as input.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/functions.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\ntoInt := expr.Function(\n    \"toInt\",\n    func(params ...any) (any, error) {\n        switch params[0].(type) {\n        case float64:\n            return int(params[0].(float64)), nil\n        case string:\n            return strconv.Atoi(params[0].(string))\n        }\n        return nil, fmt.Errorf(\"invalid type\")\n    },\n    // highlight-start\n    new(func(float64) int),\n    new(func(string) int),\n    // highlight-end\n)\n```\n\n----------------------------------------\n\nTITLE: Compile and Run Simple Expression in Expr (Go)\nDESCRIPTION: This snippet demonstrates how to compile and run a simple arithmetic expression using the Expr library in Go. It showcases the basic usage of `expr.Compile` to create a bytecode program and `expr.Run` to execute it, printing the result to the console. The example uses a simple addition operation without any external environment.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/getting-started.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nprogram, err := expr.Compile(`2 + 2`)\nif err != nil {\n    panic(err)\n}\n\noutput, err := expr.Run(program, nil)\nif err != nil {\n    panic(err)\n}\n\nfmt.Print(output) // 4\n```\n\n----------------------------------------\n\nTITLE: Defining a Function on a Struct (Go)\nDESCRIPTION: This snippet demonstrates how to define a custom function as a method on a struct.  The Expr language can then use this method as a function. The `Add` method takes two integers as input and returns their sum.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/functions.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype Env struct{}\n\nfunc (Env) Add(a, b int) int {\n    return a + b\n}\n```\n\n----------------------------------------\n\nTITLE: Sorting List with Various Keys in Expr\nDESCRIPTION: This snippet presents different ways to sort a list using the `sortBy` function in Expr. The sorting keys include field access (both optional and non-optional), literals, function calls, and more complex expressions. These examples demonstrate the flexibility of `sortBy` for ordering lists based on various criteria.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_173\n\nLANGUAGE: Expr\nCODE:\n```\nlist | sortBy(#.Bar)\nlist | sortBy(#.String())\nlist | sortBy(#?.Bar)\nlist | sortBy($env?.i)\nlist | sortBy(.Bar)\nlist | sortBy(0)\nlist | sortBy(1)\nlist | sortBy(1) | map(str)\nlist | sortBy(1.0 ** 0)\nlist | sortBy(1.0)\nlist | sortBy(1.0) | filter(false)\nlist | sortBy(1.0) | groupBy(true)\nlist | sortBy(1.0) | map(.String)\nlist | sortBy(1.0) | reduce($env)\nlist | sortBy(f64 ** 0)\nlist | sortBy(f64)\nlist | sortBy(f64) == array\nlist | sortBy(float(1))\nlist | sortBy(greet(.Bar))\nlist | sortBy(i)\nlist | sortBy(i) | groupBy(0)\nlist | sortBy(last(array))\nlist | sortBy(str)\nlist | sortBy(str) | count(ok)\n```\n\n----------------------------------------\n\nTITLE: $env Variable Usage in Expr\nDESCRIPTION: Demonstrates accessing environment variables using the `$env` variable, which is a map of all variables passed to the expression.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_16\n\nLANGUAGE: expr\nCODE:\n```\nfoo.Name == $env[\"foo\"].Name\n```\n\nLANGUAGE: expr\nCODE:\n```\n$env[\"var with spaces\"]\n```\n\n----------------------------------------\n\nTITLE: Pass Context to User-Defined Functions in Expr\nDESCRIPTION: This code demonstrates how to use the `expr.WithContext()` option to pass a context to user-defined functions within an expression. The `WithContext` option modifies function calls to include the context as the first argument, provided the function signature accepts a context.  The context variable must be defined in the environment.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/configuration.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nenv := map[string]any{\n    \"ctx\": context.Background(),\n    \"customFunc\": func(ctx context.Context, a int) int {\n        return a\n    },\n}\n\nprogram, err := expr.Compile(code, expr.Env(env), expr.WithContext(\"ctx\"))\n```\n\n----------------------------------------\n\nTITLE: Calculate Mean of Array Elements Using mean() in Expr\nDESCRIPTION: The `mean()` function calculates and returns the average value of all numbers present in the array.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_68\n\nLANGUAGE: expr\nCODE:\n```\nmean([1, 2, 3]) == 2.0\n```\n\n----------------------------------------\n\nTITLE: Find Index of First Element Matching Predicate in Expr\nDESCRIPTION: The `findIndex()` function returns the index of the first element in an array that satisfies the given predicate. If no element satisfies the predicate, the function returns -1.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_57\n\nLANGUAGE: expr\nCODE:\n```\nfindIndex([1, 2, 3, 4], # > 2) == 2\n```\n\n----------------------------------------\n\nTITLE: Expr Compilation with Environment Variables (Go)\nDESCRIPTION: This snippet demonstrates how to compile and run an Expr expression with environment variables in Go. It defines a map containing variables `foo` and `bar`, compiles the expression `foo + bar` using `expr.Compile` and the `expr.Env` option, then executes it with `expr.Run` using the same environment, printing the result to the console.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/getting-started.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nenv := map[string]any{\n    \"foo\": 100,\n    \"bar\": 200,\n}\n\nprogram, err := expr.Compile(`foo + bar`, expr.Env(env))\nif err != nil {\n    panic(err)\n}\n\noutput, err := expr.Run(program, env)\nif err != nil {\n    panic(err)\n}\n\nfmt.Print(output) // 300\n```\n\n----------------------------------------\n\nTITLE: Convert Pairs to Map Using fromPairs() in Expr\nDESCRIPTION: The `fromPairs()` function converts an array of key-value pairs (represented as nested arrays) to a map.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_87\n\nLANGUAGE: expr\nCODE:\n```\nfromPairs([[\"name\", \"John\"], [\"age\", 30]]) == {\"name\": \"John\", \"age\": 30}\n```\n\n----------------------------------------\n\nTITLE: Convert from JSON Using fromJSON() in Expr\nDESCRIPTION: The `fromJSON()` function parses a given JSON string and returns the corresponding value, allowing for easy deserialization of JSON data into Expr values.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_83\n\nLANGUAGE: expr\nCODE:\n```\nfromJSON('{\"name\": \"John\", \"age\": 30}')\n```\n\n----------------------------------------\n\nTITLE: Find Index of Last Element Matching Predicate in Expr\nDESCRIPTION: The `findLastIndex()` function returns the index of the last element in an array that satisfies the given predicate. If no element satisfies the predicate, the function returns -1.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_59\n\nLANGUAGE: expr\nCODE:\n```\nfindLastIndex([1, 2, 3, 4], # > 2) == 3\n```\n\n----------------------------------------\n\nTITLE: Expr Type Safety Example (Go)\nDESCRIPTION: This snippet illustrates Expr's type safety feature in Go. It defines an environment with a string and an integer and attempts to compile an expression that adds them together. Due to type mismatch (string + int), the `expr.Compile` function will return an error, causing the program to panic, highlighting Expr's ability to detect type-related issues at compile time.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/getting-started.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nenv := map[string]any{\n    \"name\": \"Anton\",\n    \"age\": 35,\n}\n\nprogram, err := expr.Compile(`name + age`, expr.Env(env))\nif err != nil {\n    // highlight-next-line\n    panic(err) // Will panic with \"invalid operation: string + int\"\n}\n```\n\n----------------------------------------\n\nTITLE: Expr with Struct Environment and Method (Go)\nDESCRIPTION: This snippet showcases Expr's ability to use a struct as an environment and call methods defined on that struct. It defines a struct `Env` with a `Posts` field and a `Format` method. The expression compiles with `Env{}` to set the environment. It then compiles and runs an expression that maps over the `Posts` field, formats the `Date` field of each post using the `Format` method, and concatenates it with the `Body` field. The output shows the formatted dates and bodies of the posts.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/getting-started.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\ntype Env struct {\n    Posts []Post `expr:\"posts\"`\n}\n\nfunc (Env) Format(t time.Time) string { // Methods defined on the struct become functions. \n    return t.Format(time.RFC822) \n}\n\ntype Post struct {\n    Body string\n    Date time.Time\n}\n\nfunc main() {\n    code := `map(posts, Format(.Date) + \": \" + .Body)`\n    \n    program, err := expr.Compile(code, expr.Env(Env{})) // Pass the struct as an environment.\n    if err != nil {\n        panic(err)\n    }\n\n    env := Env{\n        Posts: []Post{\n            {\"Oh My God!\", time.Now()}, \n            {\"How you doin?\", time.Now()}, \n            {\"Could I be wearing any more clothes?\", time.Now()},\n        },\n    }\n\n    output, err := expr.Run(program, env)\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Print(output)\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Predicates with Optional Chaining in Expr\nDESCRIPTION: This example uses nested predicates and optional chaining to filter users based on the content length of their posts. It checks if any user has a post with content longer than 10 characters, handling cases where a user might not have any posts (nil).\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/examples.md#_snippet_4\n\nLANGUAGE: Expr\nCODE:\n```\nlet users = [\n  {id: 1, name: \"Alice\", posts: [{title: \"Hello World\", content: \"Short post\"}, {title: \"Another Post\", content: \"This is a bit longer post\"}]},\n  {id: 2, name: \"Bob\", posts: nil},\n  {id: 3, name: \"Charlie\", posts: [{title: \"Quick Update\", content: \"Update content\"}]}\n];\n\nusers\n| filter(\n    // Check if any post has content length greater than 10.\n    any(.posts ?? [], len(.content) > 10)\n  )\n| map({{name: .name, postCount: len(.posts ?? [])}})\n```\n\n----------------------------------------\n\nTITLE: Phone number filtering in Expr\nDESCRIPTION: This snippet filters a string to extract a 10-digit phone number and formats it with parentheses and hyphens.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/examples.md#_snippet_7\n\nLANGUAGE: Expr\nCODE:\n```\nlet phone = filter(split(\"123-456-78901\", \"\"), # in map(0..9, string(#)))[:10];\njoin(concat([\"(\"], phone[:3], [\")\"], phone[3:6], [\"-\"], phone[6:]))\n```\n\n----------------------------------------\n\nTITLE: Reusing Compiled Expr Program (Go)\nDESCRIPTION: This snippet demonstrates how to reuse a compiled Expr program in Go for different inputs. It defines a struct `Env` with `X` and `Y` integer fields. It compiles the expression `X + Y` once. Then, it runs the compiled program multiple times with different `Env` instances, showcasing that the compiled program is safe for concurrent use and reusable.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/getting-started.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\ntype Env struct {\n    X int\n    Y int\n}\n\nprogram, err := expr.Compile(`X + Y`, expr.Env(Env{}))\nif err != nil {\n    panic(err)\n}\n\noutput, err := expr.Run(program, Env{1, 2})\nif err != nil {\n    panic(err)\n}\n\nfmt.Print(output) // 3\n\noutput, err = expr.Run(program, Env{3, 4})\nif err != nil {\n    panic(err)\n}\n\nfmt.Print(output) // 7\n```\n\n----------------------------------------\n\nTITLE: Sort Array by Predicate Using sortBy() in Expr\nDESCRIPTION: The `sortBy()` function sorts an array based on the result of a predicate applied to each element. It allows sorting by properties or computed values. An optional `order` argument (`asc` or `desc`) can specify the sorting order.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_75\n\nLANGUAGE: expr\nCODE:\n```\nsortBy(users, .Age)\nsortBy(users, .Age, \"desc\")\n```\n\n----------------------------------------\n\nTITLE: Decode from Base64 Using fromBase64() in Expr\nDESCRIPTION: The `fromBase64()` function decodes a Base64 encoded string back to its original form.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_85\n\nLANGUAGE: expr\nCODE:\n```\nfromBase64(\"SGVsbG8gV29ybGQ=\") == \"Hello World\"\n```\n\n----------------------------------------\n\nTITLE: Optional Chaining Equivalent in Expr\nDESCRIPTION: Demonstrates the equivalent of the `?.` operator using a ternary expression to check for nil before accessing the field.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_6\n\nLANGUAGE: expr\nCODE:\n```\nauthor.User != nil ? author.User.Name : nil\n```\n\n----------------------------------------\n\nTITLE: Financial Data Analysis in Expr\nDESCRIPTION: This example performs financial data analysis, calculating total balance, average balance, and total transactions across multiple accounts. It also calculates the final balance after transactions for each account and provides the transaction count.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/examples.md#_snippet_2\n\nLANGUAGE: Expr\nCODE:\n```\nlet accounts = [\n  {name: \"Alice\", balance: 1234.56, transactions: [100, -50, 200]},\n  {name: \"Bob\", balance: 2345.67, transactions: [-200, 300, -150]},\n  {name: \"Charlie\", balance: 3456.78, transactions: [400, -100, 50]}\n];\n\n{\n  totalBalance: sum(accounts, .balance),\n  averageBalance: mean(map(accounts, .balance)),\n  totalTransactions: reduce(accounts, #acc + len(.transactions), 0),\n  accounts: map(accounts, {{\n      name: .name,\n      final: .balance + sum(.transactions),\n      transactionCount: len(.transactions)\n  }})\n}\n```\n\n----------------------------------------\n\nTITLE: Transform Array Elements Using map() in Expr\nDESCRIPTION: The `map()` function creates a new array by applying a given predicate to each element of the input array. The predicate transforms each element, and the results are collected into a new array.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_54\n\nLANGUAGE: expr\nCODE:\n```\nmap(tweets, {.Size})\n```\n\n----------------------------------------\n\nTITLE: Filter Array Elements Using filter() in Expr\nDESCRIPTION: The `filter()` function creates a new array containing only the elements of the input array that satisfy a given predicate. The predicate is a boolean expression evaluated for each element.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_55\n\nLANGUAGE: expr\nCODE:\n```\nfilter(users, .Name startsWith \"J\")\n```\n\n----------------------------------------\n\nTITLE: Defining a Function in the Environment (Go)\nDESCRIPTION: This snippet shows how to define a custom function named 'add' directly within the environment map. This allows the Expr language to access and execute the defined function during expression evaluation. The function takes two integers as input and returns their sum.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/functions.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nenv := map[string]any{\n    \"add\": func(a, b int) int {\n        return a + b\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Variable Declaration in Expr\nDESCRIPTION: Demonstrates variable declaration using the `let` keyword followed by variable assignment and usage in an expression.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_13\n\nLANGUAGE: expr\nCODE:\n```\nlet x = 42; x * 2\n```\n\n----------------------------------------\n\nTITLE: trim Function in Expr\nDESCRIPTION: Examples demonstrating the use of the trim function to remove leading and trailing whitespace from strings. It's utilized with variable access, conditional expressions, function outputs, and string conversions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_244\n\nLANGUAGE: Expr\nCODE:\n```\ntrim($env.str)\ntrim($env?.[str])\ntrim($env?.[str], str)\ntrim($env?.str)\ntrim(false ? foo : str)\ntrim(foo.Bar)\ntrim(foo.String())\ntrim(foo?.Bar)\ntrim(foo?.String())\ntrim(greet(foo?.Bar))\ntrim(greet(str))\ntrim(list | reduce(.Bar))\ntrim(lower(str))\ntrim(reduce($env, str, greet))\ntrim(str | greet())\ntrim(str)\ntrim(str) >= str\ntrim(str) matches str\ntrim(str) not endsWith $env?.[str]\ntrim(str) not in list?.[i]\ntrim(str) not matches foo.String()\ntrim(str) | greet()\ntrim(str, foo.Bar)\ntrim(str, str)\ntrim(str, toJSON(ok))\ntrim(str[0:])\ntrim(string($env))\ntrim(string($env.ok))\ntrim(string($env?.Bar))\ntrim(string(0))\ntrim(string(1.0))\ntrim(string(array))\ntrim(string(f64))\ntrim(string(false))\ntrim(string(foo))\ntrim(string(list))\ntrim(string(nil))\ntrim(string(ok))\ntrim(string(str))\ntrim(string(true))\ntrim(string(upper(str)))\ntrim(toBase64(str))\ntrim(toJSON($env.list))\ntrim(toJSON(0))\ntrim(toJSON(1))\ntrim(toJSON(1.0))\ntrim(toJSON(array))\ntrim(toJSON(f64))\ntrim(toJSON(foo))\ntrim(toJSON(list))\ntrim(toJSON(nil))\ntrim(toJSON(ok))\ntrim(toJSON(true))\ntrim(trim(str))\ntrim(trimPrefix(str))\ntrim(trimSuffix(str))\ntrim(type($env))\ntrim(type(1.0))\ntrim(type(array))\ntrim(type(false))\ntrim(type(foo))\ntrim(type(greet))\ntrim(type(i))\ntrim(type(nil))\ntrim(type(str))\n```\n\n----------------------------------------\n\nTITLE: Convert to JSON Using toJSON() in Expr\nDESCRIPTION: The `toJSON()` function converts a given value to its JSON string representation, making it suitable for data serialization and exchange.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_82\n\nLANGUAGE: expr\nCODE:\n```\ntoJSON({\"name\": \"John\", \"age\": 30})\n```\n\n----------------------------------------\n\nTITLE: Take First N Elements of Array Using take() in Expr\nDESCRIPTION: The `take()` function returns the first `n` elements of an array. If the array contains less than `n` elements, it returns the entire array.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_72\n\nLANGUAGE: expr\nCODE:\n```\ntake([1, 2, 3, 4], 2) == [1, 2]\n```\n\n----------------------------------------\n\nTITLE: Check if All Array Elements Match Predicate in Expr\nDESCRIPTION: The `all()` function tests whether all elements in an array satisfy a provided predicate. It returns `true` if all elements satisfy the predicate or if the array is empty, otherwise returns `false`.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_50\n\nLANGUAGE: expr\nCODE:\n```\nall(tweets, {.Size < 280})\n```\n\n----------------------------------------\n\nTITLE: split Function in Expr\nDESCRIPTION: Demonstrates the use of the `split` function to split a string into an array of substrings based on a delimiter.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_27\n\nLANGUAGE: expr\nCODE:\n```\nsplit(\"apple,orange,grape\", \",\") == [\"apple\", \"orange\", \"grape\"]\n```\n\nLANGUAGE: expr\nCODE:\n```\nsplit(\"apple,orange,grape\", \",\", 2) == [\"apple\", \"orange,grape\"]\n```\n\n----------------------------------------\n\nTITLE: Specifying Function Signature with expr.Function (Go)\nDESCRIPTION: This snippet demonstrates how to specify the function signature for the `atoi` function using `expr.Function`. This helps the type checker understand the expected input and output types. It uses `new(func(string) int)` to define the signature.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/functions.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\natoi := expr.Function(\n    \"atoi\",\n    func(params ...any) (any, error) {\n        return strconv.Atoi(params[0].(string))\n    },\n    // highlight-next-line\n    new(func(string) int),\n)\n```\n\n----------------------------------------\n\nTITLE: Membership Check with 'in' Operator in Expr\nDESCRIPTION: Shows how to use the `in` operator to check for the presence of an item within an array or a map.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_4\n\nLANGUAGE: expr\nCODE:\n```\n\"John\" in [\"John\", \"Jane\"]\n```\n\nLANGUAGE: expr\nCODE:\n```\n\"name\" in {\"name\": \"John\", \"age\": 30}\n```\n\n----------------------------------------\n\nTITLE: Nil Coalescing Operator in Expr\nDESCRIPTION: Illustrates the use of the `??` operator to provide a default value if the left-hand side is nil.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_7\n\nLANGUAGE: expr\nCODE:\n```\nauthor.User?.Name ?? \"Anonymous\"\n```\n\n----------------------------------------\n\nTITLE: Get Map Keys Using keys() in Expr\nDESCRIPTION: The `keys()` function retrieves all the keys from a given map and returns them as an array of strings.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_76\n\nLANGUAGE: expr\nCODE:\n```\nkeys({\"name\": \"John\", \"age\": 30}) == [\"name\", \"age\"]\n```\n\n----------------------------------------\n\nTITLE: Sorting Lists in Expr\nDESCRIPTION: This snippet demonstrates the use of the `sortBy` function in the Expr language. The `sortBy` function takes a list and a function as input, and sorts the list based on the result of applying the function to each element. The expressions showcase various ways to define the sorting criteria, including using environment variables, object properties, and built-in functions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_211\n\nLANGUAGE: Expr\nCODE:\n```\nsortBy(list, $env.i)\nsortBy(list, $env?.i)\nsortBy(list, .Bar)\nsortBy(list, .Bar) | sum(f64)\nsortBy(list, 0)?.[i]\nsortBy(list, 1)?.[i]\nsortBy(list, 1.0 ** f64)\nsortBy(list, 1.0)?.[$env?.i]\nsortBy(list, abs(0))\nsortBy(list, bitnand(0, 1))\nsortBy(list, bitnot(1))\nsortBy(list, f64)\nsortBy(list, f64) | filter(true)\nsortBy(list, f64) | map($env)\nsortBy(list, f64) | reduce(#)\nsortBy(list, f64) | sum(0)\nsortBy(list, f64)?.[i]\nsortBy(list, greet(#.Bar))\nsortBy(list, greet(.Bar))\nsortBy(list, greet(str))\nsortBy(list, i)\nsortBy(list, i) == list\nsortBy(list, i) | reduce($env)\nsortBy(list, len(#.Bar))\nsortBy(list, reduce(array, i))\nsortBy(list, str)\nsortBy(list, str) | reduce(true)\nsortBy(list, str)?.[i]\nsortBy(list, string(1.0))\nsortBy(list, string(greet))\nsortBy(list, string(ok))\nsortBy(list, toBase64(str))\nsortBy(list, toJSON(#.Bar))\nsortBy(list, toJSON(i))\nsortBy(list, type(add))\nsortBy(list, type(false))\nsortBy(list, type(list))\nsortBy(map($env, greet), type(f64))\nsortBy(sort($env), #)\nsortBy(sort($env), #.array .. .f64)\nsortBy(sort($env), map(#.list, array))\nsortBy(sortBy(array, i), #)\nsortBy(take(list, 1), #)\n```\n\n----------------------------------------\n\nTITLE: trimSuffix Function in Expr\nDESCRIPTION: Demonstrates the use of the `trimSuffix` function to remove a specified suffix from a string.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_24\n\nLANGUAGE: expr\nCODE:\n```\ntrimSuffix(\"HelloWorld\", \"World\") == \"Hello\"\n```\n\n----------------------------------------\n\nTITLE: Sort Array Using sort() in Expr\nDESCRIPTION: The `sort()` function sorts the elements of an array in ascending order by default. An optional `order` argument can be used to specify the sorting order as either `asc` (ascending) or `desc` (descending).\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_74\n\nLANGUAGE: expr\nCODE:\n```\nsort([3, 1, 4]) == [1, 3, 4]\nsort([3, 1, 4], \"desc\") == [4, 3, 1]\n```\n\n----------------------------------------\n\nTITLE: Accessing Fields in Expr Language\nDESCRIPTION: This snippet shows examples of accessing fields within an expr expression. It demonstrates accessing fields of a map (`object`) and a struct (`struct`), including accessing non-existent fields and the behavior of the engine in such cases.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/environment.md#_snippet_7\n\nLANGUAGE: expr\nCODE:\n```\nobject.field   // 42\nobject.unknown // nil (no error)\n\nstruct.field   // 42\nstruct.unknown // error (unknown field)\n\nfoobar         // error (unknown variable)\n```\n\n----------------------------------------\n\nTITLE: Nil Coalescing Equivalent in Expr\nDESCRIPTION: Demonstrates the equivalent of the `??` operator using a ternary expression to check for nil before returning the value or the default.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_8\n\nLANGUAGE: expr\nCODE:\n```\nauthor.User != nil ? author.User.Name : \"Anonymous\"\n```\n\n----------------------------------------\n\nTITLE: Compile Expr with Return Type Validation\nDESCRIPTION: This code snippet demonstrates how to compile an expression using `expr.Compile` with a specified return type. The `expr.AsBool()` option ensures that the expression's return type is a boolean. If the expression returns a different type, the compiler will return an error. The compiled program is then executed with an environment, and the output is asserted to be a boolean.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/configuration.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nprogram, err := expr.Compile(code, expr.AsBool())\nif err != nil {\n    panic(err)\n}\n\noutput, err := expr.Run(program, env)\nif err != nil {\n    panic(err)\n}\n\nok := output.(bool) // It is safe to assert the output to bool, if the expression is type checked as bool.\n```\n\n----------------------------------------\n\nTITLE: Array Element Access in Expr\nDESCRIPTION: Demonstrates accessing elements of an array using bracket notation, including support for negative indices to access elements from the end of the array.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_3\n\nLANGUAGE: expr\nCODE:\n```\narray[0] // first element\n```\n\nLANGUAGE: expr\nCODE:\n```\narray[-1] // last element\n```\n\n----------------------------------------\n\nTITLE: Evaluate Expression at Compile Time with ConstExpr\nDESCRIPTION: This snippet illustrates how to use the `expr.ConstExpr` option to evaluate a user-defined function at compile time. If all arguments of the function are constants, the function will be evaluated during compilation, and the result will be used as a constant in the expression.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/configuration.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc fib(n int) int {\n    if n <= 1 {\n        return n\n    }\n    return fib(n-1) + fib(n-2)\n}\n\nenv := map[string]any{\n    \"fib\": fib,\n}\n\nprogram, err := expr.Compile(`fib(10)`, expr.Env(env), expr.ConstExpr(\"fib\"))\n```\n\n----------------------------------------\n\nTITLE: Reusing strconv.Atoi Function as Type with expr.Function (Go)\nDESCRIPTION: This snippet shows how to reuse the `strconv.Atoi` function directly as a type signature within `expr.Function`. This provides a concise way to define the expected input and output types for the custom function.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/functions.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\natoi := expr.Function(\n    \"atoi\",\n    func(params ...any) (any, error) {\n        return strconv.Atoi(params[0].(string))\n    },\n    // highlight-next-line\n    strconv.Atoi,\n)\n```\n\n----------------------------------------\n\nTITLE: Struct Field Access in Expr\nDESCRIPTION: Illustrates accessing a field of a struct using both dot notation and bracket notation, demonstrating their equivalence.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_2\n\nLANGUAGE: expr\nCODE:\n```\nuser.Name\n```\n\nLANGUAGE: expr\nCODE:\n```\nuser[\"Name\"]\n```\n\n----------------------------------------\n\nTITLE: Object Literal Definitions\nDESCRIPTION: Shows various object literal definitions with different key-value pairs. The keys are typically strings, and the values can be variables, literals, or other expressions. The purpose is to validate the parsing and creation of object literals.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_30\n\nLANGUAGE: Expr\nCODE:\n```\n[{foo: $env, foo: nil}]\n[{foo: $env}]\n[{foo: 0, foo: 1.0}]\n[{foo: 0, foo: nil}]\n[{foo: 0, foo: true}]\n[{foo: 0}]\n[{foo: 1.0}.add]\n[{foo: 1.0}]\n[{foo: 1}]\n[{foo: add, foo: i}]\n[{foo: add, foo: str}]\n[{foo: add}]\n[{foo: array}]\n[{foo: f64}]\n[{foo: false, foo: 0}]\n[{foo: false}]\n[{foo: foo, foo: false}]\n[{foo: foo}]\n[{foo: greet, foo: f64, foo: 0}]\n[{foo: greet}]\n[{foo: i, foo: $env}]\n[{foo: i}]\n[{foo: list, foo: foo}]\n[{foo: list}]\n[{foo: nil, foo: 1.0}]\n[{foo: nil, foo: i}]\n[{foo: nil, foo: str}]\n[{foo: nil}]\n[{foo: ok}?.foo]\n[{foo: ok}]\n[{foo: str}]\n[{foo: true}]\n```\n\n----------------------------------------\n\nTITLE: Set Timezone for Date and Time Functions in Expr\nDESCRIPTION: This example shows how to use the `expr.Timezone` option to set the timezone for date and time functions within an expression. The specified timezone will be used when parsing dates and times using functions like `date()` and `now()`.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/configuration.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nprogram, err := expr.Compile(code, expr.Timezone(time.UTC))\n```\n\n----------------------------------------\n\nTITLE: Defining Map as Expr Environment in Go\nDESCRIPTION: This snippet demonstrates defining a Go map to be used as an environment for expr. The keys of the map represent variable names, and the values represent their corresponding values. The `fmt` package is used for `fmt.Sprintf`.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/environment.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nenv := map[string]any{\n    \"UpdatedAt\": time.Time{},\n    \"Posts\":     []Post{},\n    \"tags\":      map[string]string{},\n    \"sprintf\":   fmt.Sprintf,\n}\n\nprogram, err := expr.Compile(code, expr.Env(env))\n```\n\n----------------------------------------\n\nTITLE: Using 'in' Operator in Expr\nDESCRIPTION: This snippet demonstrates the usage of the `in` operator in the Expr language. It covers various examples of checking if a variable (`foo`) exists within different data structures like lists, maps, and environment variables. It also illustrates the use of functions like `flatten`, `keys`, `toPairs`, and `uniq` in conjunction with the `in` operator.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_105\n\nLANGUAGE: Expr\nCODE:\n```\nfoo in $env.list\nfoo in $env?.Bar\nfoo in $env?.Bar?.[add]?.[str]\nfoo in $env?.String\nfoo in $env?.String?.[ok]\nfoo in $env?.[Bar]\nfoo in $env?.[Bar]?.[i]\nfoo in $env?.[String]\nfoo in $env?.[String]?.[array]\nfoo in $env?.[String]?.[foo]\nfoo in $env?.[foobar?.foo]\nfoo in $env?.[foobar]\nfoo in $env?.[foobar]?.list\nfoo in $env?.foobar\nfoo in $env?.foobar?.list()\nfoo in $env?.list\nfoo in $env?.true?.[greet]\nfoo in [nil]\nfoo in flatten(array)\nfoo in keys($env)\nfoo in list\nfoo in list != nil && $env\nfoo in list != ok\nfoo in list == $env?.ok\nfoo in list || false\nfoo in list[0:]\nfoo in map(list, foo)\nfoo in toPairs($env)\nfoo in uniq(list)\n```\n\n----------------------------------------\n\nTITLE: Expr f64 Pipe with Max, Mean, and Median Operations\nDESCRIPTION: This snippet uses the pipe operator (|) to apply several functions to an initial f64 value. The examples include using max, mean, and median functions with varying argument types such as f64 literals, environment variables, and arrays. It highlights how to chain operations and combine the initial f64 value with other computations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_90\n\nLANGUAGE: Expr\nCODE:\n```\nf64 | max(0)\nf64 | max(0, 1)\nf64 | max(1)\nf64 | max(1.0)\nf64 | max(array)\nf64 | max(array, 1)\nf64 | max(bitnot(1))\nf64 | max(f64)\nf64 | max(i)\nf64 | max(i, 1.0)\nf64 | mean(0)\nf64 | mean(0, 0)\nf64 | mean(0, 1.0)\nf64 | mean(0, array)\nf64 | mean(1)\nf64 | mean(1.0)\nf64 | mean(1.0, 1.0)\nf64 | mean(1.0, array)\nf64 | mean(array)\nf64 | mean(array, 0)\nf64 | mean(f64)\nf64 | mean(f64, array) != add\nf64 | mean(f64, f64)\nf64 | mean(i)\nf64 | median(0)\nf64 | median(0, 0)\nf64 | median(0, array)\nf64 | median(0, i)\nf64 | median(1)\nf64 | median(1.0)\nf64 | median(array)\nf64 | median(array) >= f64\nf64 | median(array, 1.0)\nf64 | median(f64)\nf64 | median(i)\nf64 | min($env?.array)\nf64 | min($env?.f64)\nf64 | min(0)\nf64 | min(0, i)\nf64 | min(1)\nf64 | min(1, f64)\nf64 | min(1.0)\nf64 | min(1.0, 0)\nf64 | min(array)\nf64 | min(array, 1)\nf64 | min(array, i)\nf64 | min(f64)\nf64 | min(f64, 1.0)\nf64 | min(i)\n```\n\n----------------------------------------\n\nTITLE: Converting Dates to Different Timezones in Expr\nDESCRIPTION: The `In()` method of a date object can be used to convert the date to a different timezone. It requires the timezone to be specified as an argument, typically obtained using the `timezone()` function.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_43\n\nLANGUAGE: expr\nCODE:\n```\ndate(\"2023-08-14 00:00:00\").In(timezone(\"Europe/Zurich\"))\n```\n\n----------------------------------------\n\nTITLE: Pipe Operator in Expr\nDESCRIPTION: Demonstrates the use of the pipe operator `|` to chain function calls, passing the result of one expression as an argument to the next.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_10\n\nLANGUAGE: expr\nCODE:\n```\nuser.Name | lower() | split(\" \")\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Map and Property Access Tests\nDESCRIPTION: Provides a comprehensive set of tests for maps and property access, covering arithmetic, comparisons, conditional property access, and various data type combinations. These tests aim to ensure correct evaluation and error handling in the language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_135\n\nLANGUAGE: expr-lang\nCODE:\n```\n{\"bar\": f32}?.list\n{\"bar\": f64 + 1}\n{\"bar\": f64 == i32}\n{\"bar\": f64 > 0.5}\n{\"bar\": f64 ^ i32}\n{\"bar\": f64, \"bar\": \"bar\"}.i\n{\"bar\": f64, \"bar\": foo}?.i\n{\"bar\": f64, \"bar\": i64}?.i64\n{\"bar\": f64, \"bar\": i}.f64\n{\"bar\": f64, \"bar\": true}?.i\n{\"bar\": f64, \"foo\": 0.5, \"foo\": score}.ok\n{\"bar\": f64, \"foo\": 1}.f32\n{\"bar\": f64, \"foo\": f64}?.score\n{\"bar\": f64, \"foo\": i}?.Qux?.f64\n{\"bar\": f64}\n{\"bar\": f64}.array\n{\"bar\": f64}.f32?.Bar\n{\"bar\": f64}.f64\n{\"bar\": f64}.foo\n{\"bar\": f64}.i\n{\"bar\": f64}.i32\n{\"bar\": f64}.ok\n{\"bar\": f64}?.Bar\n{\"bar\": f64}?.Bar?.Qux\n{\"bar\": f64}?.add\n{\"bar\": f64}?.div\n{\"bar\": f64}?.f32\n{\"bar\": f64}?.foo\n{\"bar\": f64}?.i\n{\"bar\": f64}?.i64\n{\"bar\": f64}?.list\n{\"bar\": f64}?.ok\n{\"bar\": false, \"bar\": array}?.list\n{\"bar\": false, \"bar\": i32}?.div\n{\"bar\": false, \"bar\": i}?.i64\n{\"bar\": false, \"bar\": nil}.ok\n{\"bar\": false}.Bar\n{\"bar\": false}.Qux\n{\"bar\": false}.array\n{\"bar\": false}.f32\n```\n\n----------------------------------------\n\nTITLE: Mapping arrays with transformations in Expr\nDESCRIPTION: Illustrates how to transform the elements within an array using the `map` function. The example shows several different transformations, including using a range of data types and operations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_183\n\nLANGUAGE: Expr\nCODE:\n```\nmap(array, # ** 1.0)\nmap(array, # + 1)\nmap(array, # .. #)\nmap(array, # <= #)\nmap(array, # <= 1.0)\nmap(array, # == #)\nmap(array, # > 0)\nmap(array, # >= #)\nmap(array, # ^ #)\nmap(array, # ^ 1.0)\nmap(array, #)\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Map/Struct as Expr Environment in Go\nDESCRIPTION: This example demonstrates how to create a nested environment using maps and structs. The `object` variable is a map, and the `struct` variable is a struct with a field renamed using the `expr` tag.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/environment.md#_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nenv := map[string]any{\n    \"object\": map[string]any{\n        \"field\": 42,\n    },\n    \"struct\": struct {\n        Field int `expr:\"field\"`\n    }{42},\n}\n```\n\n----------------------------------------\n\nTITLE: Pair Conversion and List Access - Expr\nDESCRIPTION: This snippet focuses on the `fromPairs` function, which converts a list of key-value pairs into a map. It also demonstrates accessing elements in arrays and lists using the `get` function with various index types (integers, expressions, function results). Negative indices, ranges, and conditional expressions are used as indices, illustrating the flexibility of the Expr language in data access.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_59\n\nLANGUAGE: Expr\nCODE:\n```\nfromPairs(filter(array, false))\nfromPairs(filter(list, false))\nfromPairs(groupBy(array, #).String)\nget([\"foo\"], i32)\nget(array, -1)\nget(array, -i32)\nget(array, -i64)\nget(array, -score(1))\nget(array, 1 * 1)\nget(array, 1 * i)\nget(array, 1) ** f32\nget(array, 1) < f32\nget(array, 1) > i32\nget(array, 1) > i64\nget(array, bitnot(1))\nget(array, count(array, ok))\nget(array, false ? \"foo\" : 0.5)\nget(array, i)\nget(array, i) != f32\nget(array, i) != i32\nget(array, i) * i32\nget(array, i) - i\nget(array, i) / i64\nget(array, i) > f64\nget(array, i) >= f64\nget(array, i) >= i64\nget(array, i) ^ half(0.5)\nget(array, i32 % i32)\nget(array, i32)\nget(array, i32) / f64\nget(array, i32) < i\nget(array, i64 - 1)\nget(array, i64)\nget(array, i64) > f64\nget(array, last(array))\nget(array, min(i))\nget(array, reduce(array, #))\nget(array, reduce(list, i64))\nget(array, score(1))\nget(array, score(abs(1)))\nget(array, score(i))\nget(array, sum(array))\n```\n\n----------------------------------------\n\nTITLE: Concat Function Usage in Expr\nDESCRIPTION: Demonstrates the usage of the 'concat' function in the Expr language with various data types and operations, including arrays, lists, and environment variables. The 'concat' function is used for concatenating arrays and lists.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_77\n\nLANGUAGE: Expr\nCODE:\n```\nconcat($env | map(1.0))\nconcat($env | map(1.0))[:i]\nconcat($env | map(add))\nconcat($env | map(array))\nconcat($env | map(foo))\nconcat($env.array)\nconcat($env.list)\nconcat($env?.array)\nconcat($env?.list)\nconcat(0 .. i)\nconcat(1 .. 0)\nconcat(1 .. 1)\nconcat(1..i)\nconcat([$env, 1])\nconcat([$env, nil])\nconcat([$env])\nconcat([0])\nconcat([1, foo])\nconcat([1.0 - 1.0])\nconcat([1.0, $env])\nconcat([1.0])\nconcat([1])\nconcat([array])\nconcat([f64, foo])\nconcat([false, $env])\nconcat([false])\nconcat([foo, array])\nconcat([foo])\nconcat([greet, 0])\nconcat([greet])\nconcat([i, 1.0])\nconcat([list])\nconcat([nil])\nconcat([ok, $env])\nconcat([ok])\nconcat([str])\nconcat([true])\nconcat([true], array)\nconcat(array | map(#))\nconcat(array | map(foo))\nconcat(array | sortBy(#))\nconcat(array | sortBy(f64))\nconcat(array | sortBy(i))\nconcat(array | take(0))\nconcat(array)\nconcat(array) | groupBy(1.0)\nconcat(array) | map(list)\nconcat(array) | reduce(#)\nconcat(array) | reduce(str)\nconcat(array) | sortBy(f64)\nconcat(array)?.[i]\nconcat(array, [greet])\nconcat(array, array)\nconcat(array, array)?.[i]\nconcat(array, list)\nconcat(array[0:])\nconcat(array[:1])\nconcat(array[:])\nconcat(array[i:])\nconcat(concat(array))\nconcat(concat(array, array))\nconcat(false ?: array)\nconcat(false ?: list)\nconcat(filter($env, false))\nconcat(flatten(array))\nconcat(flatten(list))\nconcat(keys($env))\nconcat(list | filter(ok))\nconcat(list | map(#))\nconcat(list | map(1))\nconcat(list | map(1.0))\nconcat(list)\nconcat(list) | count(false)\nconcat(list) | groupBy(#)\nconcat(list) | groupBy(1.0)\nconcat(list) | map(0)\nconcat(list) | map(add)\nconcat(list) | map(foo)\nconcat(list) | none(ok)\nconcat(list) | reduce(#)\nconcat(list) | reduce(1.0, foo)\nconcat(list) | reduce(i, str)\nconcat(list) | sum(1)\nconcat(list) | sum(i)\nconcat(list)?.[i]\nconcat(list, array)\nconcat(list, list | sortBy(i))\nconcat(list, list)\nconcat(list, list) | any(true)\nconcat(map($env, #index))\nconcat(map($env, $env))\nconcat(map($env, array), list)\nconcat(map($env, foo))\nconcat(map(array, #))\nconcat(map(array, $env))\nconcat(map(array, 1))\nconcat(map(array, 1.0))\nconcat(map(array, f64))\nconcat(map(list, #))\nconcat(map(list, $env))\nconcat(map(list, 0))\nconcat(map(list, 1.0))\nconcat(map(list, greet))\nconcat(map(list, i))\nconcat(reduce(list, array))\nconcat(reverse(array))\nconcat(reverse(list))\nconcat(sort($env))\nconcat(sort(array))\nconcat(sortBy(array, #))\nconcat(toPairs($env))\nconcat(toPairs({foo: false, foo: add}))\nconcat(uniq(array))\nconcat(values($env))\n```\n\n----------------------------------------\n\nTITLE: String Containment Checks in Expr\nDESCRIPTION: This snippet demonstrates the use of `contains` and `not contains` operators in the Expr language to check if a string `str` contains a substring or not. The expressions cover different scenarios, including checking against environment variables, object properties, function calls, and other strings.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_215\n\nLANGUAGE: Expr\nCODE:\n```\nstr contains $env.str\nstr contains $env?.Bar\nstr contains $env?.String\nstr contains $env?.String?.list\nstr contains $env?.[Bar]\nstr contains $env?.[Bar]?.foo\nstr contains $env?.[String]\nstr contains $env?.[String]?.[i]\nstr contains $env?.[foobar]\nstr contains $env?.[str]\nstr contains $env?.false\nstr contains $env?.foobar\nstr contains $env?.str\nstr contains foo.Bar\nstr contains foo.String()\nstr contains foo?.Bar\nstr contains foo?.String()\nstr contains greet(str)\nstr contains str\nstr contains string(ok)\nstr contains string(str)\nstr contains toJSON(f64)\nstr contains toJSON(ok)\nstr contains type(foo)\nstr contains type(nil)\nstr contains type(ok)\nstr not contains $env.str\nstr not contains $env?.Bar\nstr not contains $env?.Bar?.[f64]\nstr not contains $env?.String\nstr not contains $env?.String?.String\nstr not contains $env?.[Bar]\nstr not contains $env?.[Bar]?.Bar()\nstr not contains $env?.[String]\nstr not contains $env?.[foobar]\nstr not contains $env?.[str]\nstr not contains $env?.foobar\nstr not contains $env?.nil\nstr not contains $env?.str\nstr not contains foo.Bar\nstr not contains foo.String()\nstr not contains foo?.Bar\nstr not contains foo?.String()\nstr not contains greet(str)\nstr not contains last($env)?.add\nstr not contains str\nstr not contains str + str\nstr not contains str[:1]\nstr not contains string(str)\nstr not contains toJSON(0)\nstr not contains type(0)\nstr not contains type(foo)\nstr not contains type(list)\nstr not contains type(str)\nstr not contains upper(str)\nstr not contains {foo: foo}.String\n```\n\n----------------------------------------\n\nTITLE: Reverse Array Using reverse() in Expr\nDESCRIPTION: The `reverse()` function returns a new array that is a reversed copy of the input array, without modifying the original array.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_73\n\nLANGUAGE: expr\nCODE:\n```\nreverse([3, 1, 4]) == [4, 1, 3]\nreverse(reverse([3, 1, 4])) == [3, 1, 4]\n```\n\n----------------------------------------\n\nTITLE: Date Comparison in Expr\nDESCRIPTION: Shows how to compare two dates using comparison operators such as `>`.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_39\n\nLANGUAGE: expr\nCODE:\n```\ncreatedAt > now() - duration(\"1h\")\n```\n\n----------------------------------------\n\nTITLE: Finding the Minimum of Two Numbers in Expr\nDESCRIPTION: The `min()` function returns the smaller of the two numbers passed as arguments. Both arguments must be numerical values.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_45\n\nLANGUAGE: expr\nCODE:\n```\nmin(5, 7) == 5\n```\n\n----------------------------------------\n\nTITLE: JavaScript Expression Example 3\nDESCRIPTION: This JavaScript snippet shows how to ensure all tweets are less than 240 characters using the `all` function in Expr. It iterates through the `tweets` array and checks if the length of each tweet's `Content` is less than or equal to 240.\nSOURCE: https://github.com/expr-lang/expr/blob/master/README.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Ensure all tweets are less than 240 characters.\nall(tweets, len(.Content) <= 240)\n```\n\n----------------------------------------\n\nTITLE: Compiling an Expression\nDESCRIPTION: Compiles a simple expression string using the `expr.Compile` function. This is the starting point for patching or evaluating an expression.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/patch.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nprogram, err := expr.Compile(`foo + bar`)\n```\n\n----------------------------------------\n\nTITLE: Membership Checks on Fields - Expr\nDESCRIPTION: Illustrates the use of 'in' and 'not in' operators to check for membership of a field within different data structures.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_113\n\nLANGUAGE: Expr\nCODE:\n```\nfoo.Bar in $env\nfoo.Bar in foo\nfoo.Bar not in foo\nfoo.Bar not in {foo: nil, foo: 1}\nfoo?.Bar in foo\nfoo?.Bar in {foo: array}\nfoo?.Bar in {foo: str}\nfoo?.Bar not in $env\nfoo?.Bar not in $env?.[Bar]\nfoo?.Bar not in foo\nfoo.String() not in foo\nfoo?.String() in foo\nfoo?.String() not in foo\n```\n\n----------------------------------------\n\nTITLE: Reverse Function Usage in Expr\nDESCRIPTION: Demonstrates the usage of the `reverse` function with different data types and expressions involving map, reduce, sort, and uniq functions.  It covers various input types and chained operations. The reverse function takes a list as an argument and returns a new list with the elements in reverse order.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_207\n\nLANGUAGE: Expr\nCODE:\n```\nreverse(map($env, 1.0))\nreverse(map($env, array))\nreverse(map($env, f64))\nreverse(map($env, list))\nreverse(map($env, str))\nreverse(map(array, #))\nreverse(map(array, #index))\nreverse(map(array, foo))\nreverse(map(list, #))\nreverse(map(list, #.Bar))\nreverse(map(list, $env))\nreverse(reduce(array, list))\nreverse(reverse(list))\nreverse(sort($env))\nreverse(sort(array))\nreverse(sortBy(array, #))\nreverse(sortBy(array, 1.0))\nreverse(sortBy(array, str))\nreverse(sortBy(list, 1.0))\nreverse(toPairs($env))\nreverse(uniq(array))\nreverse(uniq(list))\n```\n\n----------------------------------------\n\nTITLE: Expr groupBy with properties of properties\nDESCRIPTION: Illustrates accessing properties of properties using chained access and safe navigation.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_137\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(list, #.Bar)\ngroupBy(list, #.Bar).Bar\ngroupBy(list, #.Bar).array\ngroupBy(list, #.Bar).f64\ngroupBy(list, #.Bar).foo\ngroupBy(list, #.Bar).ok\ngroupBy(list, #.Bar).str\ngroupBy(list, #.Bar)?.String\ngroupBy(list, #.Bar)?.[f64]\ngroupBy(list, #.Bar)?.[ok]\ngroupBy(list, #.Bar)?.array\ngroupBy(list, #.Bar)?.f64\ngroupBy(list, #.Bar)?.foo\ngroupBy(list, #.Bar)?.i\ngroupBy(list, #?.Bar)\ngroupBy(list, #?.Bar)?.[f64]\ngroupBy(list, #?.String())\n```\n\n----------------------------------------\n\nTITLE: replace Function in Expr\nDESCRIPTION: Demonstrates the use of the `replace` function to replace all occurrences of a substring within a string.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_29\n\nLANGUAGE: expr\nCODE:\n```\nreplace(\"Hello World\", \"World\", \"Universe\") == \"Hello Universe\"\n```\n\n----------------------------------------\n\nTITLE: Slice Operator Examples in Expr\nDESCRIPTION: Presents various examples of using the slice operator `[:]` to extract portions of an array.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_9\n\nLANGUAGE: expr\nCODE:\n```\narray[1:4] == [2, 3, 4]\n```\n\nLANGUAGE: expr\nCODE:\n```\narray[1:-1] == [2, 3, 4]\n```\n\nLANGUAGE: expr\nCODE:\n```\narray[:3] == [1, 2, 3]\n```\n\nLANGUAGE: expr\nCODE:\n```\narray[3:] == [4, 5]\n```\n\nLANGUAGE: expr\nCODE:\n```\narray[:] == array\n```\n\n----------------------------------------\n\nTITLE: Get Last Element of Array Using last() in Expr\nDESCRIPTION: The `last()` function retrieves and returns the last element from an array. If the array is empty, it returns `nil`.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_71\n\nLANGUAGE: expr\nCODE:\n```\nlast([1, 2, 3]) == 3\n```\n\n----------------------------------------\n\nTITLE: Membership Operator Tests\nDESCRIPTION: This snippet tests the `in` and `not in` operators within the Expr language. It covers various scenarios including range checks, array membership, and checks within the results of `groupBy` and `map` functions. These expressions ensure that the interpreter correctly handles different data structures when determining membership.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_67\n\nLANGUAGE: expr\nCODE:\n```\ni64 in array\ni64 in array == ok\ni64 in groupBy(array, 0.5)\ni64 in groupBy(array, foo)\ni64 in groupBy(list, \"bar\")\ni64 in groupBy(list, i)\ni64 in i64 .. i32\ni64 in map(array, #)\ni64 in map(list, 1)\ni64 in map(list, i)\ni64 not in 1 .. i\ni64 not in array\ni64 not in array ? f32 : i32\ni64 not in array ? ok : f32\ni64 not in map(array, #)\ni64 not in map(list, 0.5)\n```\n\n----------------------------------------\n\nTITLE: Pipeline Operations\nDESCRIPTION: Examples using pipeline operators, for operations like all, any, count, filter, find, findIndex, findLast, findLastIndex, groupBy, hasPrefix, indexOf, map, none, one, reduce, repeat and sortBy.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_10\n\nLANGUAGE: Expr\nCODE:\n```\n$env?.[str] | all(false)\n$env?.[str] | all(ok)\n$env?.[str] | all(true)\n$env?.[str] | any(any(list, true))\n$env?.[str] | any(true)\n$env?.[str] | count(false)\n$env?.[str] | count(i != 0)\n$env?.[str] | count(ok)\n$env?.[str] | filter(false)\n$env?.[str] | find(0 >= #)\n$env?.[str] | find(false)\n$env?.[str] | find(ok)\n$env?.[str] | find(true)\n$env?.[str] | findIndex(1 != 0)\n$env?.[str] | findIndex(add != #)\n$env?.[str] | findIndex(false)\n$env?.[str] | findIndex(ok)\n$env?.[str] | findIndex(true)\n$env?.[str] | findLast(false)\n$env?.[str] | findLast(ok)\n$env?.[str] | findLastIndex(false)\n$env?.[str] | findLastIndex(true)\n$env?.[str] | greet()\n$env?.[str] | groupBy(#)\n$env?.[str] | groupBy(0)\n$env?.[str] | groupBy(1.0)\n$env?.[str] | groupBy(f64)\n$env?.[str] | groupBy(false)\n$env?.[str] | groupBy(foo)\n$env?.[str] | groupBy(i)\n$env?.[str] | groupBy(ok)\n$env?.[str] | groupBy(str)\n$env?.[str] | groupBy(true)\n$env?.[str] | hasPrefix(str)\n$env?.[str] | indexOf(str)\n$env?.[str] | map(#)\n$env?.[str] | map(1)\n$env?.[str] | map(1.0)\n$env?.[str] | map(add)\n$env?.[str] | map(foo)\n$env?.[str] | map(greet)\n$env?.[str] | map(i)\n$env?.[str] | map(str)\n$env?.[str] | map(true)\n$env?.[str] | none(false)\n$env?.[str] | none(ok)\n$env?.[str] | none(true)\n$env?.[str] | one(false)\n$env?.[str] | one(true)\n$env?.[str] | reduce(#)\n$env?.[str] | reduce(#, array)\n$env?.[str] | reduce(#, false)\n$env?.[str] | reduce(#, ok)\n$env?.[str] | reduce($env)\n$env?.[str] | reduce(0)\n$env?.[str] | reduce(0, nil)\n$env?.[str] | reduce(1, 1.0)\n$env?.[str] | reduce(1.0)\n$env?.[str] | reduce(1.0, $env)\n$env?.[str] | reduce(1.0, nil)\n$env?.[str] | reduce(add)\n$env?.[str] | reduce(add, nil)\n$env?.[str] | reduce(array)\n$env?.[str] | reduce(f64)\n$env?.[str] | reduce(false)\n$env?.[str] | reduce(false, greet)\n$env?.[str] | reduce(foo)\n$env?.[str] | reduce(foo, true)\n$env?.[str] | reduce(greet)\n$env?.[str] | reduce(greet, foo)\n$env?.[str] | reduce(i)\n$env?.[str] | reduce(ok)\n$env?.[str] | reduce(ok, $env)\n$env?.[str] | reduce(str)\n$env?.[str] | reduce(true)\n$env?.[str] | reduce(true, f64)\n$env?.[str] | repeat(1)\n$env?.[str] | sortBy(#)\n$env?.[str] | sortBy(0)\n$env?.[str] | sortBy(1)\n$env?.[str] | sortBy(1.0)\n$env?.[str] | sortBy(f64)\n$env?.[str] | sortBy(i)\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running with Decimal Patcher\nDESCRIPTION: Sets up an environment with `Decimal` variables and an `add` function, compiles the expression `a + b + c` using `expr.Compile` with the `DecimalPatcher` and then runs the compiled program.  The `expr.Env` option is used to pass the environment to the compiler and runtime.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/patch.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nenv := map[string]interface{}{\n    \"a\": Decimal{1},\n    \"b\": Decimal{2},\n    \"c\": Decimal{3},\n    \"add\": func(x, y Decimal) Decimal {\n        return Decimal{x.Value + y.Value}\n    },\n}\n\ncode := `a + b + c`\n\n// highlight-next-line\nprogram, err := expr.Compile(code, expr.Env(env), expr.Patch(DecimalPatcher{}))\nif err != nil {\n    panic(err)\n}\n\noutput, err := expr.Run(program, env)\nif err != nil {\n    panic(err)\n}\n\nfmt.Println(output) // Decimal{6}\n```\n\n----------------------------------------\n\nTITLE: Calculate Sum of Array Elements Using sum() in Expr\nDESCRIPTION: The `sum()` function returns the sum of all numbers in the array. An optional predicate can be applied to each element before summing.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_67\n\nLANGUAGE: expr\nCODE:\n```\nsum([1, 2, 3]) == 6\n```\n\nLANGUAGE: expr\nCODE:\n```\nsum(accounts, .Balance)\n```\n\nLANGUAGE: expr\nCODE:\n```\nreduce(accounts, #acc + .Balance, 0)\n```\n\nLANGUAGE: expr\nCODE:\n```\nsum(map(accounts, .Balance))\n```\n\n----------------------------------------\n\nTITLE: String Methods on Fields - Expr\nDESCRIPTION: Demonstrates usage of string methods on fields, including greeting, checking prefixes/suffixes, and slicing.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_114\n\nLANGUAGE: Expr\nCODE:\n```\nfoo.Bar | greet()\nfoo.Bar | hasPrefix(str)\nfoo.Bar | indexOf(str)\nfoo.Bar | repeat(0)\nfoo.Bar | split($env?.str)\nfoo.Bar | trimSuffix(str)\nfoo.Bar[:]\nfoo.Bar[:i]\nfoo.Bar[i:]\nfoo?.Bar | greet()\nfoo?.Bar | hasSuffix(str)\nfoo?.Bar[:]\nfoo?.String() | greet()\nfoo?.String() | hasSuffix(str)\nfoo?.String()[:]\nfoo.String() | greet()\n```\n\n----------------------------------------\n\nTITLE: Floor Function Application with Various Types - Expr\nDESCRIPTION: This snippet demonstrates the usage of the `floor` function with different data types as input. It shows the interactions of `floor` with float types (f32, f64), integers (i, i32, i64), boolean values, arrays, lists, and the results of other functions like `find`, `findIndex`, `float`, `half`, `int`, `len`, `max`, `min`, `reduce`, `round`, and `score`. It highlights the type conversion rules and operator overloading within the Expr language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_55\n\nLANGUAGE: Expr\nCODE:\n```\nfloor(f32 ^ f64)\nfloor(f32 ^ i)\nfloor(f32)\nfloor(f32) != -i32\nfloor(f32) * i32\nfloor(f32) + f32\nfloor(f32) / f32\nfloor(f32) / f64\nfloor(f32) == i64\nfloor(f32) > i32\nfloor(f32) >= f32\nfloor(f32) >= i\nfloor(f32) ^ f32\nfloor(f64 * f32)\nfloor(f64 ** 0.5)\nfloor(f64 ** 1)\nfloor(f64 ** i32)\nfloor(f64 + 0.5)\nfloor(f64 + 1)\nfloor(f64 + i32)\nfloor(f64 - 0.5)\nfloor(f64 - i32)\nfloor(f64 / 0.5)\nfloor(f64 / 1)\nfloor(f64 / f32)\nfloor(f64 / f64)\nfloor(f64 / i)\nfloor(f64 ^ 1)\nfloor(f64)\nfloor(f64) * i32\nfloor(f64) ** f64\nfloor(f64) / f32\nfloor(f64) < i32\nfloor(f64) <= f64\nfloor(f64) <= i64\nfloor(f64) == f64 ** i\nfloor(f64) == i\nfloor(f64) > i32\nfloor(f64) >= 1 * 1\nfloor(f64) >= f32\nfloor(false ? div : 0.5)\nfloor(find(array, true))\nfloor(findIndex(array, ok))\nfloor(findLastIndex(array, ok))\nfloor(float(0.5))\nfloor(float(1))\nfloor(float(f64))\nfloor(float(i32))\nfloor(floor(0.5))\nfloor(floor(1))\nfloor(floor(f32))\nfloor(floor(f64))\nfloor(floor(i))\nfloor(floor(i32))\nfloor(floor(i64))\nfloor(get(array, 1))\nfloor(get(array, i))\nfloor(get(array, i64))\nfloor(half(0.5))\nfloor(half(1))\nfloor(half(f64))\nfloor(i % 1)\nfloor(i % i)\nfloor(i % i32)\nfloor(i % i64)\nfloor(i * 1)\nfloor(i * f64)\nfloor(i ** 0.5)\nfloor(i ** f32)\nfloor(i ** i32)\nfloor(i ** i64)\nfloor(i + 0.5)\nfloor(i + f64)\nfloor(i - 0.5)\nfloor(i - f32)\nfloor(i - i32)\nfloor(i / 0.5)\nfloor(i / 1)\nfloor(i / f64)\nfloor(i ^ i32)\nfloor(i)\nfloor(i) != i\nfloor(i) * f64\nfloor(i) ^ i\nfloor(i32 % i32)\nfloor(i32 * 1)\nfloor(i32 * f32)\nfloor(i32 * f64)\nfloor(i32 * i32)\nfloor(i32 ** i)\nfloor(i32 ** i64)\nfloor(i32 + 0.5)\nfloor(i32 + f64)\nfloor(i32 - 1)\nfloor(i32 - f32)\nfloor(i32 - i)\nfloor(i32 - i32)\nfloor(i32 - i64)\nfloor(i32 ^ 0.5)\nfloor(i32 ^ 1)\nfloor(i32 ^ f64)\nfloor(i32 ^ i)\nfloor(i32 ^ i32)\nfloor(i32 ^ i64)\nfloor(i32)\nfloor(i32) != f32\nfloor(i32) * f64\nfloor(i32) * i\nfloor(i32) * i64\nfloor(i32) > i32\nfloor(i32) > i64\nfloor(i32) >= i32\nfloor(i32) ^ i32\nfloor(i64 % i)\nfloor(i64 * 0.5)\nfloor(i64 * f32)\nfloor(i64 * i)\nfloor(i64 ** 0.5)\nfloor(i64 ** 1)\nfloor(i64 ** i)\nfloor(i64 ** i32)\nfloor(i64 + 0.5)\nfloor(i64 + f64)\nfloor(i64 + i64)\nfloor(i64 - f64)\nfloor(i64 - i)\nfloor(i64 / f32)\nfloor(i64 ^ 0.5)\nfloor(i64 ^ f32)\nfloor(i64 ^ i64)\nfloor(i64)\nfloor(i64) * i64\nfloor(i64) / (i64 - i)\nfloor(i64) / f64\nfloor(i64) / i32\nfloor(i64) < f32\nfloor(i64) <= i64\nfloor(i64) ^ f32\nfloor(int(0.5))\nfloor(int(1))\nfloor(int(i32))\nfloor(int(i64))\nfloor(len(\"foo\"))\nfloor(len(array))\nfloor(len(list))\nfloor(max(0.5))\nfloor(max(1))\nfloor(max(f32))\nfloor(max(f64))\nfloor(max(i32))\nfloor(min(0.5))\nfloor(min(f64) ^ i64)\nfloor(min(i, i64))\nfloor(min(i32))\nfloor(ok ? 1 : 1)\nfloor(ok ? f32 : \"foo\")\nfloor(ok ? i64 : f64)\nfloor(reduce(array, #))\nfloor(reduce(array, i))\nfloor(reduce(array, i64))\nfloor(reduce(list, 1))\nfloor(reduce(list, f32))\nfloor(reduce(list, i64))\nfloor(round(0.5))\nfloor(round(f32))\nfloor(round(f64))\nfloor(round(i))\nfloor(round(i32))\nfloor(score(1))\nfloor(score(1, 1))\nfloor(score(i))\nfloor(true ? 0.5 : false)\nfloor(true ? 1 : true)\nfloor(true ? f64 : 0.5)\nfloor(true ? f64 : array)\n```\n\n----------------------------------------\n\nTITLE: Array Comparisons and Access in Expr\nDESCRIPTION: Illustrates various ways to compare arrays with other data types (arrays, lists, maps, nil) and to access array elements using different index types (integer literals, variables, expressions). Also covers array indexing and mathematical operations on the array elements.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_15\n\nLANGUAGE: Expr\nCODE:\n```\narray\narray != array\narray != array ? 1 : false\narray != array ? score : i32\narray != list\narray != list ? list : f64\narray != map(array, #)\narray != map(array, 1)\narray != map(list, #)\narray != map(list, true)\narray != nil ? add : 0.5\narray == array\narray == array ? half : false\narray == list\narray == map(array, score)\narray == map(list, #)\narray == nil ? list : float(f32)\narray not in sort(array)\narray[-i32]\narray[-i64]\narray[-i]\narray[1 % i64]\narray[1 + 1]\narray[1] * i32\narray[1] * i64\narray[1] - f64\narray[1] / i32\narray[1] == -i\narray[1] > i\narray[1] ^ i\narray[abs(1)]\narray[array[i32]]\narray[bitnot(1)]\narray[bitor(1, i)]\narray[count(list, ok)]\narray[get(array, 1)]\narray[i32 * 1]\narray[i32:i]\narray[i32]\narray[i32] != i\narray[i32] % i32\narray[i32] * f64\narray[i32] ** i32\narray[i32] + i64\narray[i32] - f64\narray[i32] / f32\narray[i32] == i32\narray[i32] == i64\narray[i32] > f64\narray[i32] >= f32\narray[i64:i64]\narray[i64]\narray[i64] .. i32\narray[i64] == floor(0.5)\narray[i64] == i\narray[i64] > half(f64)\narray[i64] ^ f64\narray[i:i32]\narray[i:i64]\narray[i]\narray[i] * f64\narray[i] + f32\narray[i] - f32\narray[i] / f64\narray[i] < round(i)\narray[i] == i32\narray[i] > f64\narray[i] >= 0.5 ** i\narray[max(1)]\narray[reduce(list, 1)]\narray[score(1):i]\narray[score(1)]\narray[score(i)]\n```\n\n----------------------------------------\n\nTITLE: Length Function Tests\nDESCRIPTION: This snippet focuses on testing the `len` function and its ability to handle various data types including strings, ranges, arrays, filtered and grouped lists, and types. These expressions validate that the `len` function accurately determines the size or length of different data structures within the Expr language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_72\n\nLANGUAGE: expr\nCODE:\n```\nlen(\"bar\") ** i64\nlen(\"bar\") + i64 - i64\nlen(\"bar\") / i64\nlen(\"bar\") >= i\nlen(\"bar\") in array\nlen(\"foo\") ** i32\nlen(\"foo\") ** i64\nlen(\"foo\") - i\nlen(\"foo\") - i32\nlen(\"foo\") >= i\nlen(1 .. 1)\nlen([f32])\nlen([foo])\nlen([half])\nlen(array)\nlen(array) != f32\nlen(array) + i64\nlen(array) < f64\nlen(array) <= i32\nlen(array) == f32\nlen(array) >= f64\nlen(array) ^ i32\nlen(array) not in array\nlen(filter(list, false))\nlen(filter(list, ok))\nlen(foo.Bar)\nlen(foo.String())\nlen(foo?.Bar)\nlen(foo?.Qux(\"bar\"))\nlen(foo?.String())\nlen(greet(\"bar\"))\nlen(greet(\"foo\"))\nlen(groupBy(array, #))\nlen(groupBy(array, 0.5))\nlen(groupBy(array, f32))\nlen(groupBy(array, false))\nlen(groupBy(array, i64))\nlen(groupBy(array, true))\nlen(groupBy(list, #))\nlen(groupBy(list, #).ok)\nlen(groupBy(list, 0.5))\nlen(groupBy(list, false))\nlen(groupBy(list, foo).list)\nlen(groupBy(list, i32))\nlen(groupBy(list, i64))\nlen(i64 .. 1)\nlen(i64 .. i)\nlen(list)\nlen(list) % i32\nlen(list) % i64\nlen(list) .. i64\nlen(list) / i32\nlen(list) <= i\nlen(list) > i\nlen(list) ^ f64\nlen(list[1:i])\nlen(lower(\"bar\"))\nlen(lower(\"foo\"))\nlen(map(array, \"bar\"))\nlen(map(array, #))\nlen(map(array, add))\nlen(map(array, f32))\nlen(map(array, greet))\nlen(map(array, i))\nlen(map(array, list)[i64])\nlen(map(array, score))\nlen(map(list, #))\nlen(map(list, 1))\nlen(map(list, f32))\nlen(map(list, f64))\nlen(map(list, foo))\nlen(map(list, i64))\nlen(map(list, ok))\nlen(map(list, true))\nlen(ok ? list : score)\nlen(sort(array))\nlen(string(\"bar\"))\nlen(string(\"foo\"))\nlen(string(0.5))\nlen(string(1))\nlen(string(add))\nlen(string(f64))\nlen(string(foo))\nlen(string(half))\nlen(string(i))\nlen(string(i32))\nlen(string(i64))\nlen(string(list))\nlen(string(nil))\nlen(string(score))\nlen(string(string(list)))\nlen(toJSON(\"bar\"))\nlen(toJSON(\"foo\"))\nlen(toJSON(0.5))\nlen(toJSON(1))\nlen(toJSON(array))\nlen(toJSON(f32))\nlen(toJSON(false))\nlen(toJSON(i))\nlen(toJSON(i32))\nlen(toJSON(list))\nlen(toJSON(nil))\nlen(toJSON(ok))\nlen(toJSON(true))\nlen(trim(\"foo\"))\nlen(trimPrefix(\"foo\"))\nlen(trimSuffix(\"bar\"))\nlen(type(\"foo\"))\nlen(type(0.5))\nlen(type(1))\nlen(type(add))\nlen(type(array))\nlen(type(div))\nlen(type(half))\nlen(type(i))\nlen(type(i32))\nlen(type(i64))\nlen(type(list))\nlen(type(nil))\nlen(type(ok))\nlen(type(score))\nlen(upper(\"bar\"))\nlen(upper(\"foo\"))\nlen({\"bar\": array})\nlen({\"bar\": f64})\nlen({\"bar\": score})\n```\n\n----------------------------------------\n\nTITLE: Defining Embedded Struct for Expr Environment in Go\nDESCRIPTION: This example demonstrates how to embed another struct into the Env struct. Methods defined on the embedded struct are also accessible from within the expr language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/environment.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype Env struct {\n    Helpers\n}\n\ntype Helpers struct{}\n\nfunc (Helpers) Format(t time.Time) string {\n    return t.Format(time.RFC822)\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Environment Variables with Optional Chaining in Expr\nDESCRIPTION: These snippets demonstrate accessing environment variables and their nested properties using optional chaining (?.) in Expr. This allows for safe access to properties that might be nil or undefined, preventing errors.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_269\n\nLANGUAGE: Expr\nCODE:\n```\n{foo: $env?.Bar, foo: ok}\n{foo: $env?.Bar?.Bar}\n{foo: $env?.Bar?.[greet]}\n{foo: $env?.Bar?.list}\n{foo: $env?.Bar}\n{foo: $env?.Bar}?.list\n{foo: $env?.[Bar], foo: i}\n{foo: $env?.[Bar], foo: str}\n{foo: $env?.[Bar]?.Bar}\n{foo: $env?.[Bar]?.[add]}\n{foo: $env?.[Bar]}\n{foo: $env?.[Bar]}?.greet\n{foo: $env?.[Bar]}?.ok\n{foo: $env?.[String], foo: ok}\n{foo: $env?.[String]?.array}\n{foo: $env?.[String]}\n{foo: $env?.[foobar]?.add}\n{foo: $env?.[foobar]}\n{foo: $env?.[nil]}\n{foo: $env?.[str]}\n{foo: $env?.[str]}?.add\n{foo: $env?.add, foo: add}\n{foo: $env?.add}?.foo\n{foo: $env?.array, foo: add}\n{foo: $env?.array}.ok\n{foo: $env?.f64}?.greet\n{foo: $env?.foobar, foo: greet}\n{foo: $env?.foo}\n{foo: $env?.greet}.foo\n{foo: $env?.greet}?.add\n{foo: $env?.i, foo: string(i)}\n{foo: $env?.i, foo: str}\n{foo: $env?.i}?.f64\n{foo: $env?.i}?.greet\n{foo: $env?.list, foo: [1.0]}\n{foo: $env?.nil?.[add]}\n{foo: $env?.nil?.[i]}\n{foo: $env?.ok}?.foo\n{foo: $env?.ok}?.list\n{foo: $env?.str, foo: $env?.ok}\n{foo: $env?.str, foo: array}\n{foo: $env?.str}?.Bar\n```\n\n----------------------------------------\n\nTITLE: Using the reverse function with various types\nDESCRIPTION: Demonstrates the use of the `reverse` function to reverse the order of elements in various data structures, including arrays, lists, maps, and ranges.  It highlights how `reverse` works with different data types and expressions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_205\n\nLANGUAGE: Expr\nCODE:\n```\nreverse($env | filter(false))\nreverse($env | map($env))\nreverse($env | map(0))\nreverse($env | map(1.0))\nreverse($env | map(false))\nreverse($env | map(true))\nreverse($env.array)\nreverse($env.list)\nreverse($env?.array)\nreverse($env?.list)\nreverse(0 .. 1)\nreverse(0 .. i)\nreverse(1 .. 1)\nreverse([$env, 0])\nreverse([$env, f64])\nreverse([$env])\nreverse([0, $env, foo])\nreverse([0])\nreverse([1 .. 1])\nreverse([1, true])\nreverse([1.0, list])\nreverse([1.0])\nreverse([1])\nreverse([add, list])\nreverse([array, array])\nreverse([array, greet])\nreverse([array])\nreverse([f64, nil])\nreverse([f64])\nreverse([false])\nreverse([foo, 1.0])\nreverse([foo, str])\nreverse([foo])\nreverse([greet])\nreverse([i, 1])\nreverse([i])\nreverse([list])\nreverse([nil, list])\nreverse([nil, nil])\nreverse([nil])\nreverse([ok])\nreverse([str, ok])\nreverse([str])\nreverse([true])\nreverse(array | map($env))\nreverse(array | map(ok))\nreverse(array | map(str))\nreverse(array | reduce(array, foo))\nreverse(array | sortBy(1))\nreverse(array)\nreverse(array) | findIndex(ok)\nreverse(array) | findLastIndex(false)\nreverse(array) | map(#)\nreverse(array) | one(ok)\nreverse(array) | reduce(#)\nreverse(array) | reduce(#, greet)\nreverse(array) | reduce($env)\nreverse(array) | reduce(foo)\nreverse(array) | reduce(str)\nreverse(array) | sortBy(1)\nreverse(array) | sortBy(i)\nreverse(array) | sum(#)\nreverse(array)?.[i]\nreverse(array[i:1])\nreverse(concat(array))\nreverse(concat(list))\nreverse(filter($env, false))\nreverse(flatten(list))\nreverse(if false { $env } else { array })\nreverse(keys($env))\nreverse(let foobar = array; foobar)\nreverse(let foobar = list; foobar)\nreverse(list | filter(true))\nreverse(list | map(#))\nreverse(list | map(i))\nreverse(list | map(str))\nreverse(list | map(true))\nreverse(list | sortBy(1.0))\nreverse(list)\nreverse(list) != list\nreverse(list) == array\nreverse(list) | any(true)\nreverse(list) | count(true)\nreverse(list) | groupBy(#)\nreverse(list) | groupBy(foo)\nreverse(list) | reduce(0)\nreverse(list) | reduce(f64)\nreverse(list) | reduce(foo)\nreverse(list) | reduce(greet)\nreverse(list) | reduce(true)\nreverse(list)?.[i]\nreverse(map($env, 0))\n```\n\n----------------------------------------\n\nTITLE: Evaluating findLastIndex with Various Conditions - Expr\nDESCRIPTION: This snippet showcases the usage of `findLastIndex` function with various conditional expressions as its second argument. It covers different operators, data types, and checks for 'in' and 'not in' operations on lists and arrays. The conditions range from simple comparisons to more complex logical evaluations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_51\n\nLANGUAGE: Expr\nCODE:\n```\nfindLastIndex(list, \"bar\" not matches \"bar\")\nfindLastIndex(list, \"foo\" <= \"bar\")\nfindLastIndex(list, \"foo\" not in #)\nfindLastIndex(list, # != #)\nfindLastIndex(list, # != foo)\nfindLastIndex(list, # == #)\nfindLastIndex(list, # == foo)\nfindLastIndex(list, # == nil)\nfindLastIndex(list, # in list)\nfindLastIndex(list, # not in list)\nfindLastIndex(list, 1 != f32)\nfindLastIndex(list, 1 != nil)\nfindLastIndex(list, 1 > 1)\nfindLastIndex(list, 1 >= 0.5)\nfindLastIndex(list, array != nil)\nfindLastIndex(list, div != nil)\nfindLastIndex(list, f32 != 1)\nfindLastIndex(list, f32 != f64)\nfindLastIndex(list, f64 > 0.5)\nfindLastIndex(list, foo == #)\nfindLastIndex(list, i <= 1)\nfindLastIndex(list, i32 > 1)\nfindLastIndex(list, i32 > f32)\nfindLastIndex(list, i64 == i64)\nfindLastIndex(list, i64 >= 0.5)\nfindLastIndex(list, i64 not in array)\nfindLastIndex(list, nil != \"bar\")\nfindLastIndex(list, nil != #)\nfindLastIndex(list, nil != f64)\nfindLastIndex(list, nil == #)\nfindLastIndex(list, nil == 1)\nfindLastIndex(list, nil == half)\nfindLastIndex(list, not false)\nfindLastIndex(list, not true)\nfindLastIndex(list, ok ? ok : 0.5)\nfindLastIndex(list, ok and false)\nfindLastIndex(list, ok)\nfindLastIndex(list, ok) != i64\nfindLastIndex(list, ok) > f32\nfindLastIndex(list, ok) > i64\nfindLastIndex(list, one(array, true))\nfindLastIndex(list, true && ok)\nfindLastIndex(list, true) * i32\nfindLastIndex(list, true) - i32\nfindLastIndex(list, true) < i64\nfindLastIndex(list, true) > i64\nfindLastIndex(list, true) ^ f64\nfindLastIndex(map(array, \"bar\"), # not endsWith #)\nfindLastIndex(map(array, #), # < f64)\nfindLastIndex(map(array, #), # <= #)\nfindLastIndex(map(array, #), ok)\nfindLastIndex(map(array, div), 0.5 <= 0.5)\nfindLastIndex(map(array, f32), nil == nil)\nfindLastIndex(map(array, list), ok)\nfindLastIndex(map(array, ok), # and #)\nfindLastIndex(map(list, \"bar\"), # >= #)\nfindLastIndex(map(list, #), !true)\nfindLastIndex(map(list, #), nil == 0.5)\nfindLastIndex(map(list, false), #)\nfindLastIndex(map(list, foo), ok)\nfindLastIndex(map(list, i32), # >= #)\nfindLastIndex(map(list, i64), ok)\n```\n\n----------------------------------------\n\nTITLE: Collection Predicate Functions (all, any, none, one)\nDESCRIPTION: These snippets demonstrate the usage of collection predicate functions such as `all`, `any`, `none`, and `one` with arrays and lists. These functions evaluate a boolean condition against each element of the collection and return a boolean result based on the condition's outcome for all, any, none, or exactly one element, respectively. The `#` represents the current element being evaluated in the lambda expression.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_90\n\nLANGUAGE: Expr\nCODE:\n```\nnot all(array, false)\nnot all(array, ok)\nnot all(array, true)\nnot all(list, nil == #)\nnot all(list, ok)\nnot all(list, true)\nnot any(array, false)\nnot any(array, ok)\nnot any(array, true)\nnot any(list, false)\nnot any(list, ok)\nnot any(list, true)\nnot none(array, # > f32)\nnot none(array, false)\nnot none(array, ok)\nnot none(array, true)\nnot none(list, false)\nnot none(list, ok)\nnot none(list, true)\nnot one(array, false)\nnot one(array, ok)\nnot one(array, true)\nnot one(list, false)\nnot one(list, ok)\nnot one(list, true)\n```\n\n----------------------------------------\n\nTITLE: Encode to Base64 Using toBase64() in Expr\nDESCRIPTION: The `toBase64()` function encodes the input string to its Base64 representation.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_84\n\nLANGUAGE: expr\nCODE:\n```\ntoBase64(\"Hello World\") == \"SGVsbG8gV29ybGQ=\" \n```\n\n----------------------------------------\n\nTITLE: Check if Any Array Element Matches Predicate in Expr\nDESCRIPTION: The `any()` function tests whether at least one element in an array satisfies a provided predicate. It returns `true` if any element satisfies the predicate, otherwise returns `false`. If the array is empty, returns `false`.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_51\n\nLANGUAGE: expr\nCODE:\n```\nany(tweets, {.Size > 280})\n```\n\n----------------------------------------\n\nTITLE: Join Array of Strings Using join() in Expr\nDESCRIPTION: The `join()` function joins an array of strings into a single string, using an optional delimiter. If no delimiter is provided, an empty string is used as the delimiter.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_65\n\nLANGUAGE: expr\nCODE:\n```\njoin([\"apple\", \"orange\", \"grape\"], \",\") == \"apple,orange,grape\"\njoin([\"apple\", \"orange\", \"grape\"]) == \"appleorangegrape\"\n```\n\n----------------------------------------\n\nTITLE: Concatenate Arrays Using concat() in Expr\nDESCRIPTION: The `concat()` function concatenates two or more arrays into a single array. It returns a new array containing all the elements from the input arrays, in the order they were given.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_62\n\nLANGUAGE: expr\nCODE:\n```\nconcat([1, 2], [3, 4]) == [1, 2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Taking Elements from List in Expr\nDESCRIPTION: This snippet demonstrates the `take` function, which retrieves a specified number of elements from the beginning of a list. The example includes using integer literals and variables to determine the number of elements to take and chains the result with the `sum` function.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_175\n\nLANGUAGE: Expr\nCODE:\n```\nlist | take(0)\nlist | take(1)\nlist | take(1) | sum(0)\nlist | take(i)\n```\n\n----------------------------------------\n\nTITLE: Compiling Expression with Struct Environment in Go\nDESCRIPTION: This snippet shows how to compile an expression using `expr.Compile` with a struct as the environment. The `expr.Env` function is used to pass the environment configuration to the compiler. The `code` variable represents the expression string to be compiled.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/environment.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nprogram, err := expr.Compile(code, expr.Env(Env{}))\n```\n\n----------------------------------------\n\nTITLE: Expr Safe Navigation with Null Propagation\nDESCRIPTION: Illustrates safe navigation using the `?.` operator to prevent errors when accessing properties of potentially null or undefined objects.  If the object or any intermediate property is null, the entire expression evaluates to null, avoiding a runtime error.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_144\n\nLANGUAGE: expr\nCODE:\n```\n{\"foo\": ok}?.Qux\n```\n\n----------------------------------------\n\nTITLE: Value Operations with values function\nDESCRIPTION: These examples show the usage of `values` function in the Expr language. This function extracts all the values from a map or dictionary. The snippets also showcase how to use `values` in combination with other functions like `findIndex`, `groupBy`, `map`, `reduce`, `sortBy`, `sum`, `max`, and `min`.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_267\n\nLANGUAGE: Expr\nCODE:\n```\nvalues($env) | findIndex(true)\nvalues($env) | findLast(ok)\nvalues($env) | findLastIndex(ok)\nvalues($env) | groupBy(f64)\nvalues($env) | groupBy(foo)\nvalues($env) | groupBy(str)\nvalues($env) | map(add)\nvalues($env) | map(f64)\nvalues($env) | map(greet)\nvalues($env) | one(true)\nvalues($env) | reduce(#)\nvalues($env) | reduce(#index)\nvalues($env) | reduce(1)\nvalues($env) | reduce(add, nil)\nvalues($env) | reduce(array)\nvalues($env) | reduce(foo, nil)\nvalues($env) | reduce(i)\nvalues($env) | sortBy(i)\nvalues($env) | sum(1)\nvalues($env)?.[i]\nvalues(array | groupBy(#))\nvalues(array | groupBy(0))\nvalues(array | groupBy(1))\nvalues(array | groupBy(false))\nvalues(groupBy(array, 0))\nvalues(groupBy(array, foo))\nvalues(groupBy(list, ok))\nvalues(if ok { $env } else { str })\nvalues(list | groupBy(false))\nvalues(max($env))\nvalues(min($env))\nvalues(ok ? $env : nil)\nvalues(reduce(array, $env))\nvalues(reduce(list, $env))\nvalues({foo: $env})\nvalues({foo: $env}?.foo)\nvalues({foo: 0, foo: 0})\nvalues({foo: 0})\nvalues({foo: 1, foo: 0})\nvalues({foo: 1.0})\nvalues({foo: 1})\nvalues({foo: array, foo: foo})\nvalues({foo: array})\nvalues({foo: f64})\nvalues({foo: false, foo: false})\nvalues({foo: false})\nvalues({foo: foo, foo: list})\nvalues({foo: foo})\nvalues({foo: greet, foo: 0})\nvalues({foo: greet, foo: foo})\nvalues({foo: greet})\nvalues({foo: i})\nvalues({foo: list})\nvalues({foo: nil, foo: ok})\nvalues({foo: nil})\nvalues({foo: ok, foo: $env})\nvalues({foo: ok, foo: 1.0})\nvalues({foo: ok, foo: list})\nvalues({foo: ok})\nvalues({foo: str})\n```\n\n----------------------------------------\n\nTITLE: Chained Property Access in Expr\nDESCRIPTION: These examples show how properties of different types (String, Bar, add, array, foo, f64, greet, i, list, ok, str) are accessed from literals or environment variables within more complex Expr expressions using dot notation.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_277\n\nLANGUAGE: Expr\nCODE:\n```\n{foo: $env?.add}.greet\n{foo: $env?.add}.greet\n{foo: $env?.add}.greet\n{foo: 1, foo: 0}.add\n{foo: 1, foo: 0}.foo\n{foo: 1, foo: 0}.list\n{foo: 1, foo: 1.0}.String\n{foo: 1, foo: 1}.f64\n{foo: 1, foo: 1}.greet\n{foo: 1, foo: add}.array\n{foo: 1, foo: add}.greet\n{foo: 1, foo: f64}.f64\n{foo: 1, foo: false}.f64\n{foo: 1, foo: false}.foo\n{foo: 1, foo: greet}.String\n{foo: 1, foo: greet}.greet\n{foo: 1, foo: greet}.i\n{foo: 1, foo: greet}.ok?.String\n{foo: 1, foo: list}.f64\n{foo: 1, foo: nil}.i\n{foo: 1, foo: nil}.ok\n{foo: 1, foo: ok}.foo\n{foo: 1, foo: ok}.list\n{foo: 1, foo: str}.f64\n{foo: 1, foo: str}.list\n{foo: 1, foo: true}.String\n{foo: 1, foo: true}.ok\n{foo: 1.0, foo: 0}.Bar\n{foo: 1.0, foo: 0}.String\n{foo: 1.0, foo: 0}.String?.String\n{foo: 1.0, foo: 0}.i\n{foo: 1.0, foo: 0}.list\n{foo: 1.0, foo: 1.0}.Bar\n{foo: 1.0, foo: 1.0}.add\n{foo: 1.0, foo: 1.0}.array\n{foo: 1.0, foo: 1.0}.foo\n{foo: 1.0, foo: 1.0}.greet\n{foo: 1.0, foo: 1.0}.list\n{foo: 1.0, foo: 1.0}.ok\n{foo: 1.0, foo: 1.0}.str\n{foo: 1.0, foo: 1}.foo\n{foo: 1.0, foo: add}.Bar\n{foo: 1.0, foo: array}.foo\n{foo: 1.0, foo: array}.str\n{foo: 1.0, foo: f64}.add\n{foo: 1.0, foo: f64}.greet\n{foo: 0, foo: nil}.String?.i()\n{foo: 0, foo: nil}.Bar\n{foo: 0, foo: nil}.array\n{foo: 0, foo: nil}.greet\n{foo: 0, foo: nil}.ok\n{foo: 0, foo: ok}.f64\n{foo: 0, foo: ok}.ok\n{foo: 0, foo: str}.Bar\n{foo: 0}.Bar\n{foo: 0}.String\n{foo: 0}.add\n{foo: 0}.array\n{foo: 0}.f64\n{foo: 0}.foo\n{foo: 0}.greet\n{foo: 0}.i\n{foo: 0}.list\n{foo: 0}.ok\n{foo: 0}.str\n```\n\n----------------------------------------\n\nTITLE: Method Calls with Parameters\nDESCRIPTION: These examples demonstrate calling methods with different types of parameters, including variables, literals, and even other method calls. The examples cover a range of methods like `add`, `all`, `any`, `array`, `f64`, `filter`, `foo`, `greet`, `i`, `lastIndexOf`, `list`, `max`, `none`, `now`, `ok`, `str`, `sum`, and `trimSuffix`.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_5\n\nLANGUAGE: Expr\nCODE:\n```\n$env?.[foobar]?.add\n$env?.[foobar]?.add()\n$env?.[foobar]?.add()?.[array]\n$env?.[foobar]?.add(foobar)\n$env?.[foobar]?.add?.greet\n$env?.[foobar]?.add?.i\n$env?.[foobar]?.all(foobar, greet, $env)\n$env?.[foobar]?.any(1, foobar)\n$env?.[foobar]?.any(f64, nil)\n$env?.[foobar]?.any(i).f64\n$env?.[foobar]?.array\n$env?.[foobar]?.array()\n$env?.[foobar]?.array.f64\n$env?.[foobar]?.array?.[i]\n$env?.[foobar]?.array?.add()\n$env?.[foobar]?.array?.i\n$env?.[foobar]?.f64\n$env?.[foobar]?.f64()\n$env?.[foobar]?.f64()?.[ok]\n$env?.[foobar]?.f64()?.array\n$env?.[foobar]?.f64(String)\n$env?.[foobar]?.f64.ok\n$env?.[foobar]?.f64?.Bar\n$env?.[foobar]?.f64?.ok\n$env?.[foobar]?.filter(foo)\n$env?.[foobar]?.foo\n$env?.[foobar]?.foo()\n$env?.[foobar]?.foo()?.array\n$env?.[foobar]?.foo()?.f64\n$env?.[foobar]?.foo(foobar)\n$env?.[foobar]?.foo(foobar, foobar)\n$env?.[foobar]?.foo.foobar\n$env?.[foobar]?.foo?.[array]\n$env?.[foobar]?.foo?.[foo]\n$env?.[foobar]?.foo?.[i]\n$env?.[foobar]?.foo?.foo\n$env?.[foobar]?.foo?.foo?.array\n$env?.[foobar]?.foobar\n$env?.[foobar]?.foobar.str\n$env?.[foobar]?.greet\n$env?.[foobar]?.greet()\n$env?.[foobar]?.greet()?.String\n$env?.[foobar]?.greet(Bar)\n$env?.[foobar]?.greet(String)\n$env?.[foobar]?.greet(foobar, foo)\n$env?.[foobar]?.greet(greet)\n$env?.[foobar]?.greet.foo\n$env?.[foobar]?.greet.i\n$env?.[foobar]?.i\n$env?.[foobar]?.i()\n$env?.[foobar]?.i()?.greet\n$env?.[foobar]?.i(Bar)\n$env?.[foobar]?.i(foo)\n$env?.[foobar]?.i(foobar)\n$env?.[foobar]?.i.array\n$env?.[foobar]?.i.foo\n$env?.[foobar]?.i?.[array]\n$env?.[foobar]?.i?.[greet]\n$env?.[foobar]?.i?.f64\n$env?.[foobar]?.lastIndexOf(nil, foobar)\n$env?.[foobar]?.list\n$env?.[foobar]?.list()\n$env?.[foobar]?.list(f64)\n$env?.[foobar]?.list(foobar)\n$env?.[foobar]?.list.list\n$env?.[foobar]?.list?.[array]\n$env?.[foobar]?.list?.[i]\n$env?.[foobar]?.list?.[list]\n$env?.[foobar]?.max(foo)\n$env?.[foobar]?.nil?.[foo]\n$env?.[foobar]?.none(foobar)\n$env?.[foobar]?.none(nil, foobar)\n$env?.[foobar]?.now(1)\n$env?.[foobar]?.ok\n$env?.[foobar]?.ok()\n$env?.[foobar]?.ok(Bar?.[greet])?.greet\n$env?.[foobar]?.ok(list)\n$env?.[foobar]?.ok.add()\n$env?.[foobar]?.ok.i\n$env?.[foobar]?.ok?.i\n$env?.[foobar]?.str\n$env?.[foobar]?.str($env)\n$env?.[foobar]?.str()\n$env?.[foobar]?.str()?.str\n$env?.[foobar]?.str(foobar)\n$env?.[foobar]?.str(foobar?.greet(nil))\n$env?.[foobar]?.str.ok\n$env?.[foobar]?.str?.[list]\n$env?.[foobar]?.str?.foo\n$env?.[foobar]?.str?.i()\n$env?.[foobar]?.str?.list\n$env?.[foobar]?.sum($env)\n$env?.[foobar]?.trimSuffix(f64, foobar)\n```\n\n----------------------------------------\n\nTITLE: Equality and Inequality Checks in Expr\nDESCRIPTION: These snippets demonstrate equality and inequality comparisons involving environment variables, numeric literals, and other data types (nil, f64, i) within the Expr language. The examples cover different combinations of data types and variables to illustrate comparison behavior.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_272\n\nLANGUAGE: Expr\nCODE:\n```\n{foo: $env} == nil or false\n{foo: 0 != $env.i}\n{foo: 0 != $env}\n{foo: 1 != $env}\n{foo: 1 != 1.0}\n{foo: 1 != 1}\n{foo: 1 != f64}\n{foo: 1 != f64}.f64\n{foo: 1 != i}\n{foo: 1 != nil}\n{foo: 1 == $env}\n{foo: 1 == 0}\n{foo: 1 == 1.0}\n{foo: 1 == 1}\n{foo: 1 == nil}\n{foo: 1.0 == $env}\n{foo: 1.0 == 0}\n{foo: 1.0 == 1.0}\n{foo: 1.0 == 1}\n{foo: 1.0 == f64}.foo\n{foo: 1.0 == i}\n{foo: 1.0 == nil}\n{foo: 1.0 == nil}?.String\n```\n\n----------------------------------------\n\nTITLE: Date Subtraction in Expr\nDESCRIPTION: Illustrates subtracting two dates to calculate the duration between them.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_37\n\nLANGUAGE: expr\nCODE:\n```\ncreatedAt - now()\n```\n\n----------------------------------------\n\nTITLE: Find First Element Matching Predicate in Expr\nDESCRIPTION: The `find()` function returns the first element in an array that satisfies the given predicate. If no element satisfies the predicate, the function returns `nil`.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_56\n\nLANGUAGE: expr\nCODE:\n```\nfind([1, 2, 3, 4], # > 2) == 3\n```\n\n----------------------------------------\n\nTITLE: Evaluating Types with the type function - Expr\nDESCRIPTION: These expressions exclusively use the `type` function to determine the data type of various literals, variables, expressions, and function calls. The expressions cover a broad range of data types, operators, and built-in functions available within the Expr language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_126\n\nLANGUAGE: expr\nCODE:\n```\ntype(!false)\ntype(!ok)\ntype(!true)\ntype(\"bar\" != \"bar\")\ntype(\"bar\" < \"foo\")\ntype(\"bar\" <= \"bar\")\ntype(\"bar\" == \"foo\")\ntype(\"bar\" >= \"bar\")\ntype(\"bar\" not endsWith \"foo\")\ntype(\"bar\" startsWith \"bar\")\ntype(\"bar\") startsWith greet(\"bar\")\ntype(\"foo\" != nil)\ntype(\"foo\" + \"bar\")\ntype(\"foo\" not startsWith \"bar\")\ntype(\"foo\") not in foo\ntype(-0.5)\ntype(-1)\ntype(-f32)\ntype(-f64)\ntype(-i)\ntype(-i32)\ntype(-i64)\ntype(-int(f64))\ntype(0.5 != f64)\ntype(0.5 != i32)\ntype(0.5 != nil)\ntype(0.5 * 0.5)\ntype(0.5 * f32)\ntype(0.5 * f64)\ntype(0.5 * i64)\ntype(0.5 ** 0.5)\ntype(0.5 ** 1)\ntype(0.5 ** f32)\ntype(0.5 ** f64)\ntype(0.5 ** i)\ntype(0.5 ** i32)\ntype(0.5 + 0.5)\ntype(0.5 + 1)\ntype(0.5 + f32)\ntype(0.5 + f64)\ntype(0.5 + i)\ntype(0.5 + i64)\ntype(0.5 - 1)\ntype(0.5 - f64)\ntype(0.5 - i32)\ntype(0.5 / 1)\ntype(0.5 / f32)\ntype(0.5 / i)\ntype(0.5 / i32)\ntype(0.5 / i64)\ntype(0.5 < 1)\ntype(0.5 < f32)\ntype(0.5 < i32)\ntype(0.5 < i64)\ntype(0.5 <= 1)\ntype(0.5 <= f32)\ntype(0.5 <= i64)\ntype(0.5 == 0.5)\ntype(0.5 == f32)\ntype(0.5 == f64)\ntype(0.5 == i32)\ntype(0.5 > 0.5)\ntype(0.5 > f32)\ntype(0.5 > i)\ntype(0.5 > i32)\ntype(0.5 > i64)\ntype(0.5 >= 0.5)\ntype(0.5 >= i)\ntype(0.5 >= i32)\ntype(0.5 ^ 0.5)\ntype(0.5 ^ i)\ntype(0.5 ^ i32)\ntype(0.5 ^ i64)\ntype(0.5 not in array)\ntype(0.5) in foo\ntype(1 != i32)\ntype(1 != nil)\ntype(1 % 1)\ntype(1 % i)\ntype(1 * 0.5)\ntype(1 * f32)\ntype(1 * i)\ntype(1 * i32)\ntype(1 ** 0.5)\ntype(1 ** f64)\ntype(1 ** i)\ntype(1 ** i64)\ntype(1 + 0.5)\ntype(1 + 1)\ntype(1 + f32)\ntype(1 + i64)\ntype(1 - 0.5)\ntype(1 - 1)\ntype(1 - i64)\ntype(1 .. 1)\ntype(1 .. i64)\ntype(1 / f64)\ntype(1 / i)\ntype(1 < i32)\ntype(1 < i64)\ntype(1 <= 0.5)\ntype(1 <= 1)\ntype(1 <= f64)\ntype(1 <= i)\ntype(1 == f32)\ntype(1 == f64)\ntype(1 == i)\ntype(1 == i32)\ntype(1 == i64)\ntype(1 > i)\ntype(1 >= 0.5)\ntype(1 >= i)\ntype(1 >= i64)\ntype(1 ^ 1)\ntype(1 ^ i)\ntype(1 ^ i64)\ntype(1) endsWith foo.Bar\ntype(1) in reduce(list, #)\ntype(1) not endsWith \"bar\" ? i64 : nil\ntype(1) not startsWith string(0.5))\ntype([div])\ntype([f32])\ntype(abs(0.5))\ntype(abs(f32))\ntype(abs(f64))\ntype(abs(i))\ntype(abs(i32))\ntype(abs(i64))\ntype(add)\ntype(all(array, ok))\ntype(all(list, ok))\ntype(all(list, true))\ntype(any(array, false))\ntype(any(array, ok))\ntype(any(list, false))\ntype(array != list)\ntype(array != nil)\ntype(array == array)\ntype(array)\ntype(array) >= trimPrefix(\"foo\")\ntype(array[1])\ntype(array[i32])\ntype(array[i])\ntype(bitand(1, i))\ntype(bitnot(i))\ntype(bitnot(i32))\ntype(bitnot(i64))\ntype(bitxor(i64, 1))\ntype(ceil(0.5))\ntype(ceil(f32))\ntype(ceil(f64))\ntype(ceil(i64))\ntype(count(array, true))\ntype(div != div)\ntype(div == div)\ntype(div)\ntype(f32 != 0.5)\ntype(f32 != 1)\ntype(f32 * 1)\ntype(f32 * i)\ntype(f32 * i32)\ntype(f32 ** f32)\ntype(f32 + 1)\ntype(f32 + i)\ntype(f32 - f32)\ntype(f32 - i32)\ntype(f32 / 1)\ntype(f32 / f32)\ntype(f32 < 1)\ntype(f32 < f32)\ntype(f32 <= f64)\ntype(f32 == 0.5)\ntype(f32 == f64)\ntype(f32 == i)\ntype(f32 == i32)\ntype(f32 == i64)\ntype(f32 > 1)\ntype(f32 >= f32)\ntype(f32 >= i)\ntype(f32 >= i32)\ntype(f32 ^ i64)\ntype(f32 not in array)\ntype(f32)\ntype(f64 != 0.5)\ntype(f64 != i)\ntype(f64 * 0.5)\ntype(f64 * 1)\ntype(f64 * f32)\ntype(f64 ** 1)\ntype(f64 + f32)\ntype(f64 + i32)\ntype(f64 - 0.5)\ntype(f64 - 1)\ntype(f64 - f64)\ntype(f64 - i)\ntype(f64 / 1)\ntype(f64 / f32)\ntype(f64 / i64)\ntype(f64 < 0.5)\ntype(f64 < f32)\ntype(f64 < f64)\ntype(f64 < i32)\ntype(f64 < i64)\ntype(f64 <= 0.5)\ntype(f64 <= f64)\ntype(f64 <= i64)\ntype(f64 == 0.5)\ntype(f64 == f32)\ntype(f64 == i64)\ntype(f64 == nil)\ntype(f64 > i)\ntype(f64 > i32)\ntype(f64 >= 0.5)\ntype(f64 >= i)\ntype(f64 ^ 0.5)\ntype(f64 not in array)\ntype(f64)\ntype(false != nil)\ntype(false != ok)\ntype(false && true)\ntype(false ? \"bar\" : score)\ntype(false ? div : f64)\ntype(false ? half : greet)\ntype(false ? true : foo)\ntype(false || true)\ntype(false) startsWith \"bar\" ? ok : f32\ntype(find(array, false))\ntype(find(array, true))\ntype(find(list, true))\ntype(findIndex(array, ok))\ntype(findLast(array, false))\ntype(findLast(array, ok))\ntype(findLastIndex(array, false))\ntype(findLastIndex(list, false))\ntype(findLastIndex(list, ok))\ntype(findLastIndex(list, true))\ntype(first(list))\ntype(float(f32))\ntype(float(i32))\ntype(floor(0.5))\ntype(floor(1))\ntype(floor(f64))\ntype(floor(i64))\ntype(foo != foo)\ntype(foo != nil)\ntype(foo in list)\ntype(foo)\ntype(foo.Bar)\ntype(foo.Qux)\ntype(foo.String())\ntype(foo.String)\ntype(foo?.Bar)\ntype(foo?.Qux)\ntype(foo?.String())\ntype(foo?.String)\ntype(get(array, 1))\ntype(get(array, i64))\ntype(get(list, 1))\ntype(get(list, i))\ntype(get(list, i32))\ntype(get(list, i64))\ntype(greet(\"bar\"))\ntype(greet(\"foo\"))\ntype(greet)\ntype(groupBy(array, #))\ntype(groupBy(array, #).score)\ntype(groupBy(array, 0.5))\ntype(groupBy(array, false)?.add)\ntype(groupBy(array, i))\ntype(groupBy(array, i32))\ntype(groupBy(array, i64))\ntype(groupBy(list, \"bar\"))\ntype(groupBy(list, #))\ntype(groupBy(list, #)?.Bar)\ntype(groupBy(list, 1))\ntype(groupBy(list, i64))\ntype(groupBy(list, true))\ntype(half(0.5))\ntype(half(1))\ntype(half(f64))\ntype(half)\ntype(half) not in foo\ntype(i % 1)\ntype(i % i32)\ntype(i * 0.5)\ntype(i * i32)\ntype(i ** f32)\ntype(i ** f64)\ntype(i ** i)\ntype(i + i32)\ntype(i - 0.5)\ntype(i - 1)\ntype(i - i)\ntype(i - i64)\ntype(i .. i)\ntype(i / 0.5)\ntype(i / i32)\ntype(i < 0.5)\ntype(i < 1)\ntype(i <= 0.5)\ntype(i <= 1)\ntype(i == 1)\ntype(i > 0.5)\ntype(i > 1)\ntype(i > f32)\ntype(i > i64)\ntype(i >= i32)\ntype(i ^ 1)\ntype(i ^ i)\ntype(i ^ i32)\ntype(i ^ i64)\ntype(i)\ntype(i) + foo.Bar\ntype(i32 != 1)\ntype(i32 != f64)\ntype(i32 * 0.5)\ntype(i32 * i)\ntype(i32 ** 0.5)\ntype(i32 ** f64)\ntype(i32 ** i)\ntype(i32 + 1)\ntype(i32 - 1)\ntype(i32 .. i32)\ntype(i32 / 0.5)\ntype(i32 / f64)\ntype(i32 < 0.5)\ntype(i32 <= 0.5)\ntype(i32 <= f64)\ntype(i32 <= i32)\ntype(i32 == 1)\ntype(i32 == nil)\ntype(i32 > 0.5)\ntype(i32 > f64)\ntype(i32 > i64)\ntype(i32 >= 1)\ntype(i32 >= f32)\ntype(i32 >= i64)\ntype(i32 ^ 1)\ntype(i32 ^ f32)\ntype(i32 ^ f64)\ntype(i32 ^ i)\ntype(i32 not in array)\ntype(i32)\ntype(i32) in foo\ntype(i32) not matches trim(\"foo\")\ntype(i64 != 1)\ntype(i64 != f64)\ntype(i64 % 1)\ntype(i64 * f32)\ntype(i64 * i64)\ntype(i64 ** 0.5)\ntype(i64 ** f64)\ntype(i64 ** i32)\ntype(i64 + 0.5)\ntype(i64 + 1)\ntype(i64 + i64)\ntype(i64 - 0.5)\ntype(i64 - f32)\ntype(i64 - f64)\ntype(i64 - i32)\ntype(i64 .. i32)\ntype(i64 / 0.5)\ntype(i64 / f32)\ntype(i64 / i64)\ntype(i64 < 0.5)\ntype(i64 < f32)\ntype(i64 < f64)\ntype(i64 < i)\ntype(i64 < i64)\ntype(i64 <= 0.5)\ntype(i64 <= 1)\ntype(i64 <= f32)\ntype(i64 <= i)\ntype(i64 == 1)\ntype(i64 == f64)\ntype(i64 > i64)\ntype(i64 >= 1)\ntype(i64 ^ f64)\ntype(i64 ^ i)\ntype(i64 not in array)\ntype(i64)\ntype(int(0.5))\ntype(int(f32))\ntype(int(f64))\ntype(int(i))\ntype(int(i32))\ntype(int(i64))\ntype(last(array))\ntype(last(list))\ntype(len(array))\ntype(len(list))\ntype(list != nil)\ntype(list == array)\ntype(list == nil)\ntype(list)\ntype(list[1])\ntype(list[i32])\ntype(list[i64])\ntype(list[i])\ntype(map(array, \"bar\"))\ntype(map(array, \"foo\"))\ntype(map(array, #))\ntype(map(array, 1))\ntype(map(array, div))\ntype(map(array, f32))\ntype(map(array, foo))\ntype(map(array, greet))\ntype(map(array, ok))\ntype(map(array, true))\ntype(map(list, \"bar\"))\ntype(map(list, #))\ntype(map(list, array))\ntype(map(list, greet))\ntype(map(list, i64))\ntype(map(list, list))\n```\n\n----------------------------------------\n\nTITLE: Accessing Array Elements Safely\nDESCRIPTION: Demonstrates how to safely access array elements using the ?. operator to avoid errors when the index is out of bounds or the array is nil.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_13\n\nLANGUAGE: EXPR\nCODE:\n```\n1 - array?.[i]\n1 / $env.array?.[i]\n1 / array?.[i]\n1 < 1.0 > $env?.[false]\n1 <= array?.[i]\n1 == $env?.[Bar]\n1 == $env?.[String]\n1 == $env?.[foobar]\n1 == $env?.[str]\n1 == array?.[i]\n1 > array?.[i]\n1 >= array?.[i]\n1 ^ array?.[i]\n1.0 != $env?.Bar\n1.0 != $env?.String\n1.0 != $env?.[Bar]\n1.0 != $env?.[String]\n1.0 != $env?.[foobar]\n1.0 != $env?.[str]\n1.0 != array?.[i]\n1.0 * array?.[i]\n1.0 ** array?.[i]\n1.0 + array?.[i]\n1.0 - array?.[i]\n1.0 / array?.[i]\n1.0 < array?.[i]\n1.0 <= array?.[i]\n1.0 == $env?.[Bar]\n1.0 == $env?.[String]\n1.0 == $env?.[str]\n1.0 == array?.[i]\n1.0 > array?.[i]\n1.0 >= array?.[i]\n1.0 ^ array?.[i]\n```\n\n----------------------------------------\n\nTITLE: Built-in Function Calls\nDESCRIPTION: Examples of calling built-in functions like len, last, groupBy, map, int, sum and all, demonstrating how they are used within object contexts.  These functions operate on collections or other data and provide common utility operations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_140\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": len(list)}\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": last(list)}\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": groupBy(array, 1)}\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": map(array, #)}\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": int(i)}\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": f64, \"bar\": sum(array)}\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": list, \"bar\": all(list, false)}\n```\n\n----------------------------------------\n\nTITLE: Advanced Map Operations with Diverse Data Types\nDESCRIPTION: Demonstrates advanced map operations, focusing on complex interactions between various data types and potential edge cases during evaluation. This includes combinations of arithmetic operations, function calls, and property access.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_134\n\nLANGUAGE: expr-lang\nCODE:\n```\n{\"bar\": div, \"bar\": array, \"bar\": 0.5}.i64\n{\"bar\": div, \"bar\": div}?.f32\n{\"bar\": div, \"bar\": foo}.foo\n{\"bar\": div, \"bar\": ok}\n{\"bar\": div, \"foo\": 1, \"bar\": ok}.Qux\n{\"bar\": div, \"foo\": false}?.String\n{\"bar\": div, \"foo\": foo, \"foo\": score}.Bar\n{\"bar\": div, \"foo\": greet}.i\n{\"bar\": div, \"foo\": greet}?.ok\n{\"bar\": div, \"foo\": score}\n{\"bar\": div}\n{\"bar\": div}.array\n{\"bar\": div}.f32\n{\"bar\": div}.f64\n{\"bar\": div}.i64?.Qux\n{\"bar\": div}.list\n{\"bar\": div}.ok\n{\"bar\": div}?.Bar\n{\"bar\": div}?.array\n{\"bar\": div}?.f64\n{\"bar\": div}?.greet\n{\"bar\": div}?.half\n{\"bar\": div}?.list\n{\"bar\": div}?.ok\n{\"bar\": div}?.score\n{\"bar\": f32 ** i}\n{\"bar\": f32 - 0.5}\n{\"bar\": f32 >= 0.5}\n{\"bar\": f32 ^ 1}\n{\"bar\": f32, \"bar\": \"foo\"}.add\n{\"bar\": f32, \"bar\": false}?.Bar\n{\"bar\": f32, \"bar\": true}?.String\n{\"bar\": f32, \"foo\": add, \"foo\": false}?.String\n{\"bar\": f32, \"foo\": f32}.ok\n{\"bar\": f32, \"foo\": f64}\n{\"bar\": f32, \"foo\": half, \"foo\": ok}\n{\"bar\": f32, \"foo\": half}\n{\"bar\": f32, \"foo\": list}?.f32\n{\"bar\": f32, \"foo\": nil}?.f64?.foo\n{\"bar\": f32}\n{\"bar\": f32}.Qux\n{\"bar\": f32}.div\n{\"bar\": f32}.f64\n{\"bar\": f32}.greet\n{\"bar\": f32}.i\n{\"bar\": f32}.i32\n{\"bar\": f32}.i64\n{\"bar\": f32}?.Bar\n{\"bar\": f32}?.String\n{\"bar\": f32}?.array\n{\"bar\": f32}?.f64\n{\"bar\": f32}?.half\n{\"bar\": f32}?.list\n```\n\n----------------------------------------\n\nTITLE: Base64 and JSON Conversion - Expr\nDESCRIPTION: This snippet showcases the `fromBase64` and `fromJSON` functions, demonstrating conversions from Base64 encoded strings and JSON strings back to their original data types. It uses functions like `toBase64`, `toJSON`, `string`, and `type` to generate the input strings for these conversions, showcasing the type system and data serialization capabilities of the Expr language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_58\n\nLANGUAGE: Expr\nCODE:\n```\nfromBase64(string(ok))\nfromBase64(toBase64(\"bar\"))\nfromBase64(type(1 == 0.5))\nfromBase64(type(add))\nfromBase64(type(div))\nfromBase64(type(false))\nfromBase64(type(greet))\nfromBase64(type(half))\nfromBase64(type(ok))\nfromBase64(type(score))\nfromBase64(type(true))\nfromJSON(string(1))\nfromJSON(string(f32))\nfromJSON(string(f64))\nfromJSON(string(i))\nfromJSON(string(i32))\nfromJSON(string(i64))\nfromJSON(string(ok))\nfromJSON(string(true))\nfromJSON(toJSON(\"bar\"))\nfromJSON(toJSON(0.5))\nfromJSON(toJSON(array))\nfromJSON(toJSON(f64))\nfromJSON(toJSON(false))\nfromJSON(toJSON(foo))\nfromJSON(toJSON(i))\nfromJSON(toJSON(i32))\nfromJSON(toJSON(list))\nfromJSON(toJSON(nil))\nfromJSON(toJSON(true))\n```\n\n----------------------------------------\n\nTITLE: Running Expression with Struct Environment in Go\nDESCRIPTION: This code demonstrates how to run a compiled expression using `expr.Run` with a populated struct environment. It initializes the `UpdatedAt`, `Posts`, and `Map` fields with specific values.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/environment.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\noutput, err := expr.Run(program, Env{\n    UpdatedAt: time.Now(),\n    Posts:     []Post{{Title: \"Hello, World!\"}},\n    Map:       map[string]string{\"tag1\": \"value1\"},\n})\n```\n\n----------------------------------------\n\nTITLE: Conditional Statements in Expr\nDESCRIPTION: Illustrates the use of `if` statements in the Expr language. The examples show various conditions and expressions to be evaluated, including comparisons, boolean operations, function calls, and ternary operators. It shows a range of possible values assigned based on different conditional expressions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_162\n\nLANGUAGE: Expr\nCODE:\n```\nif $env != f64 { add } else { foo }\nif $env != foo { greet } else { str }\nif $env == 1.0 { list } else { add }\nif $env?.ok { foo?.String } else { greet }\nif 0 > 1 { list } else { false ? ok : ok }\nif 1.0 >= 0 { foo } else { ok }\nif f64 not in array { map(list, list) } else { add }\nif i > $env?.i { greet } else { list }\nif nil != str { greet } else { array }\nif ok or false { str } else { greet }\nif ok { $env.foo } else { foo.Bar }\nif ok { 0 != i } else { ok }\nif ok { 1 > 1.0 } else { f64 }\nif ok { add } else { add }\nif ok { add } else { f64 }\nif ok { add } else { foo }\nif ok { add } else { greet }\nif ok { add } else { i }\nif ok { add } else { ok }\nif ok { array } else { foo }\nif ok { array } else { foo?.Bar }\nif ok { f64 } else { f64 }\nif ok { f64 } else { findLastIndex($env, $env) }\nif ok { f64 } else { foo }\nif ok { f64 } else { ok }\nif ok { false && true } else { false == nil }\nif ok { foo } else { $env ?: f64 }\nif ok { foo } else { $env?.str }\nif ok { foo } else { f64 }\nif ok { foo } else { foo }\nif ok { foo } else { greet }\nif ok { foo } else { ok }\nif ok { foo.Bar } else { 1 == 1.0 }\nif ok { greet } else { array }\nif ok { greet } else { f64 }\nif ok { greet } else { i }\nif ok { greet } else { str }\nif ok { i } else { date($env) }\nif ok { i } else { type(nil) }\nif ok { list } else { i }\nif ok { list } else { nil == true }\nif ok { list } else { ok }\nif ok { list } else { str }\nif ok { nil == false } else { greet }\nif ok { ok } else { $env.add }\nif ok { ok } else { array }\nif ok { ok } else { foo }\nif ok { ok } else { greet }\nif ok { str } else { array }\nif ok { str } else { i }\nif ok { str } else { ok }\nif ok { type(f64) } else { foo }\nif str == $env { foo?.String() } else { $env.foo }\nif str > str { str } else { find(array, ok) }\nif true && ok { array } else { greet }\n```\n\n----------------------------------------\n\nTITLE: Using flatten function in Expr\nDESCRIPTION: This snippet demonstrates the usage of the `flatten` function in the Expr language. It showcases various examples of flattening different data structures like lists, maps, and arrays. The purpose of the `flatten` function is to reduce the dimensionality of a data structure by combining nested elements into a single level.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_100\n\nLANGUAGE: Expr\nCODE:\n```\nflatten(list) | sortBy(str)\nflatten(list)?.[i]\nflatten(list)[:]\nflatten(map($env, $env))\nflatten(map($env, 0))\nflatten(map($env, 1.0))\nflatten(map(array, true))\nflatten(map(list, #))\nflatten(map(list, $env))\nflatten(map(list, .Bar))\nflatten(map(list, ok))\nflatten(reduce(array, array))\nflatten(reverse(array))\nflatten(reverse(list))\nflatten(sort(array))\nflatten(sortBy(array, #))\nflatten(sortBy(array, 1))\nflatten(sortBy(array, 1.0))\nflatten(sortBy(array, f64))\nflatten(toPairs($env))\nflatten(uniq(array))\nflatten(uniq(list))\nflatten(values($env))\n```\n\n----------------------------------------\n\nTITLE: Chained Operations in Expr\nDESCRIPTION: Demonstrates using semicolons to chain multiple expressions and operations in the Expr language. The examples illustrate combining different types of expressions and function calls.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_161\n\nLANGUAGE: Expr\nCODE:\n```\ni; 1.0; $env.foo\ni; ceil(1.0)\ni; f64\ni; greet\ni; i; greet(str)\ni; list\ni; str\ni; {foo: false}\n```\n\n----------------------------------------\n\nTITLE: String Comparisons\nDESCRIPTION: Examples for string comparisons using !=, +, <, <=, ==, >, >=, contains, endsWith, in, matches, not endsWith, not in, not matches, startsWith\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_9\n\nLANGUAGE: Expr\nCODE:\n```\n$env?.[str] != add\n$env?.[str] != f64\n$env?.[str] != greet\n$env?.[str] != i\n$env?.[str] != ok\n$env?.[str] != str\n$env?.[str] + str\n$env?.[str] < str\n$env?.[str] <= str\n$env?.[str] == 1.0 == $env\n$env?.[str] == array\n$env?.[str] == foo\n$env?.[str] == greet\n$env?.[str] == i\n$env?.[str] == ok\n$env?.[str] == str\n$env?.[str] > str\n$env?.[str] >= str\n$env?.[str] contains str\n$env?.[str] endsWith $env?.str\n$env?.[str] endsWith str\n$env?.[str] in list\n$env?.[str] matches str\n$env?.[str] not endsWith str\n$env?.[str] not in $env == ok\n$env?.[str] not in $env.list\n$env?.[str] not in $env?.[Bar]\n$env?.[str] not in $env?.array\n$env?.[str] not in array\n$env?.[str] not matches foo?.String()\n$env?.[str] not matches str\n$env?.[str] not startsWith str\n$env?.[str] startsWith $env?.[String]\n$env?.[str] startsWith foo?.Bar\n$env?.[str] startsWith str\n```\n\n----------------------------------------\n\nTITLE: Compile Expr with WarnOnAny Option\nDESCRIPTION: This snippet shows how to use the `expr.WarnOnAny()` option to instruct the type checker to issue a warning if the return type of an expression is `any`. This is useful for ensuring that expressions return a specific type when working with arrays or other data structures that might contain values of type `any`.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/configuration.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nprogram, err := expr.Compile(code, expr.AsInt(), expr.WarnOnAny())\n```\n\n----------------------------------------\n\nTITLE: Reduce Array to Single Value Using reduce() in Expr\nDESCRIPTION: The `reduce()` function applies a predicate to each element in the array, reducing the array to a single value. An optional `initialValue` argument can be specified.  Within the predicate, `#` represents the current element, `#acc` the accumulator, and `#index` the element index.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_66\n\nLANGUAGE: expr\nCODE:\n```\nreduce(1..9, #acc + #)\nreduce(1..9, #acc + #, 0)\n```\n\n----------------------------------------\n\nTITLE: Array Summation Operations in Expr\nDESCRIPTION: Demonstrates the use of the `sum` function in Expr to calculate the sum of elements in an array based on different expressions. The function computes the sum based on the provided element transformation.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_63\n\nLANGUAGE: Expr\nCODE:\n```\narray | sum(# ** #)\narray | sum(# - #)\narray | sum(# ^ 1)\narray | sum(# ^ i)\narray | sum(#)\narray | sum(#) < 1.0 ^ 1.0\narray | sum(0)\narray | sum(0.1)\narray | sum(1 + 1.0)\narray | sum(1)\narray | sum(1.0 * #)\narray | sum(1.0 ** #)\narray | sum(1.0 - 1.0)\narray | sum(1.0)\narray | sum(bitshl(#, #))\narray | sum(f64)\narray | sum(float(f64))\narray | sum(i + 0)\narray | sum(i)\narray | sum(int(#))\narray | sum(max(#, 1))\narray | sum(median(#))\narray | sum(round(1.0))\n```\n\n----------------------------------------\n\nTITLE: Calculate Median of Array Elements Using median() in Expr\nDESCRIPTION: The `median()` function calculates and returns the median value of all numbers present in the array.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_69\n\nLANGUAGE: expr\nCODE:\n```\nmedian([1, 2, 3]) == 2.0\n```\n\n----------------------------------------\n\nTITLE: Array Slicing in Expr\nDESCRIPTION: Illustrates various array slicing operations in Expr using different indices and expressions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_66\n\nLANGUAGE: Expr\nCODE:\n```\narray[$env?.i:]\narray[0:] | reduce(#)\narray[0:] | reduce(str)\narray[0:] | sortBy(#)\narray[0:]?.[i]\narray[1:] == list\narray[1:] | any(ok)\narray[1:] | findLast(false)\narray[1:] | reduce(foo)\narray[1:] | sum(#)\narray[1:]?.[i]\narray[:$env.i]\narray[:0] | sortBy(#)\narray[:0] | sum(str)\narray[:1] | findLastIndex(false)\narray[:1] | sum(#)\narray[:]\narray[:] | reduce(f64)\narray[:]?.[i]\narray[:i]\narray[:i] | map(f64)\narray[:i] | reduce($env)\narray[:i] | sortBy(array)\narray[:int(1.0)]\narray[:reduce(array, 1)]\narray[array?.[i]:]\narray[bitnot(1):]\narray[i % 1:]\narray[i:]\narray[i:] | findIndex(false)\narray[i:] | groupBy(1)\narray[len($env):]\narray[sum(array):]\n```\n\n----------------------------------------\n\nTITLE: String Manipulation and Validation in Expr\nDESCRIPTION: This snippet demonstrates common string manipulation techniques, including trimming whitespace, splitting a string by a delimiter, converting to lowercase, removing duplicates, sorting, and joining the elements back into a string. This example manipulates a comma separated string to return a sorted, unique, and trimmed list of words.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/examples.md#_snippet_5\n\nLANGUAGE: Expr\nCODE:\n```\n\"  Apple, banana, Apple, orange, banana, kiwi \"\n| trim()\n| split(\",\")\n| map(trim(#))\n| map(lower(#))\n| uniq()\n| sort()\n| join(\", \")\n```\n\n----------------------------------------\n\nTITLE: Convert to String Using string() in Expr\nDESCRIPTION: The `string()` function converts a given value into its string representation. It handles different data types and returns the string equivalent.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_81\n\nLANGUAGE: expr\nCODE:\n```\nstring(123) == \"123\"\n```\n\n----------------------------------------\n\nTITLE: Array Group By\nDESCRIPTION: Groups the elements of the array based on whether they are not equal to each other. It is used to categorize items. The keys of the returned map will be the results of evaluating the grouping expression, and the values will be lists of elements that produced that value.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_54\n\nLANGUAGE: Expr\nCODE:\n```\narray | groupBy(# != #)\n```\n\n----------------------------------------\n\nTITLE: String Conversion\nDESCRIPTION: Converts different types and expressions to strings using the `string()` function. Demonstrates converting integers, floats, booleans, arrays, and function results into strings.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_113\n\nLANGUAGE: Expr\nCODE:\n```\nstring(i32 == f32)\nstring(i32 == i64)\nstring(i32 == nil)\nstring(i32 > 1)\nstring(i32 > i)\nstring(i32 >= 0.5)\nstring(i32 >= 1)\nstring(i32 >= i)\nstring(i32 ^ f32)\nstring(i32 ^ f64)\nstring(i32 ^ i32)\nstring(i32 in array)\nstring(i32 not in array)\nstring(i32)\nstring(i32) not startsWith trimSuffix(\"foo\")\nstring(i64 != 1)\nstring(i64 != i)\nstring(i64 != i32)\nstring(i64 != i64)\nstring(i64 % i32)\nstring(i64 * 1)\nstring(i64 * f32)\nstring(i64 * i)\nstring(i64 ** 0.5)\nstring(i64 + i64)\nstring(i64 - i)\nstring(i64 - i32)\nstring(i64 - i64)\nstring(i64 .. 1)\nstring(i64 .. i)\nstring(i64 .. i32)\nstring(i64 / f64)\nstring(i64 / i)\nstring(i64 / i64)\nstring(i64 < 0.5)\nstring(i64 < i)\nstring(i64 <= i64)\nstring(i64 == 0.5)\nstring(i64 == i)\nstring(i64 > 0.5)\nstring(i64 > i64)\nstring(i64 >= 0.5)\nstring(i64 >= 1)\nstring(i64 ^ 0.5)\nstring(i64 ^ f64)\nstring(i64 in array)\nstring(i64)\nstring(i64) matches greet(\"bar\")\nstring(i64) not in foo\nstring(int(0.5))\nstring(int(1))\nstring(int(i32))\nstring(int(i64))\nstring(last(array))\nstring(last(list).String())\nstring(len(\"bar\"))\nstring(len(array))\nstring(len(list))\nstring(list != nil)\nstring(list == array)\nstring(list == list)\nstring(list == nil)\nstring(list)\nstring(list[1])\nstring(list[i32])\nstring(list[i64])\nstring(list[i])\nstring(map(array, #))\nstring(map(array, 0.5))\nstring(map(array, add))\nstring(map(array, div))\nstring(map(array, i))\nstring(map(array, i32))\nstring(map(array, true))\nstring(map(list, \"bar\"))\nstring(map(list, \"foo\"))\nstring(map(list, #))\nstring(map(list, 0.5))\nstring(map(list, 1))\nstring(map(list, array))\nstring(map(list, half))\nstring(map(list, i32))\nstring(map(list, i64))\nstring(max(0.5))\nstring(max(0.5, f32))\nstring(max(1))\nstring(max(f32))\nstring(max(f64))\nstring(max(i))\nstring(max(i64))\nstring(mean(array))\nstring(min(0.5))\nstring(min(f32))\nstring(min(i))\nstring(min(i32))\nstring(min(i64))\nstring(nil != \"bar\")\nstring(nil != div)\nstring(nil != false)\nstring(nil != greet)\nstring(nil != half)\nstring(nil != i)\nstring(nil != ok)\nstring(nil == \"bar\")\nstring(nil == 0.5)\nstring(nil == 1)\nstring(nil == div)\nstring(nil == foo)\nstring(nil == list)\nstring(nil == nil)\nstring(nil == ok)\nstring(nil == score)\nstring(nil in list)\nstring(nil not in list)\nstring(nil) <= list[i].Bar\nstring(none(array, ok))\nstring(none(list, false))\nstring(none(list, ok))\nstring(not !false)\nstring(not (i64 == 0.5))\nstring(not false)\nstring(not ok)\nstring(not true)\nstring(ok != nil)\nstring(ok != true)\nstring(ok ? 0.5 : nil)\nstring(ok ? 0.5 : true)\nstring(ok ? 1 : array)\nstring(ok ? 1 : f32)\nstring(ok ? array : add)\nstring(ok ? div : array)\nstring(ok ? half : score)\nstring(ok ? i : 1)\nstring(ok ? nil : half)\nstring(ok ? nil : list)\nstring(ok or false)\nstring(ok || false)\nstring(ok)\nstring(one(array, true))\nstring(one(list, true))\nstring(reduce(array, #))\nstring(reduce(array, 0.5))\nstring(reduce(array, 1))\nstring(reduce(array, f64))\nstring(reduce(array, greet))\nstring(reduce(array, half))\nstring(reduce(array, i64))\nstring(reduce(array, list))\nstring(reduce(array, score))\nstring(reduce(list, \"bar\"))\nstring(reduce(list, #))\nstring(reduce(list, 1))\nstring(reduce(list, add))\nstring(reduce(list, div))\nstring(reduce(list, foo))\nstring(reduce(list, i))\nstring(reduce(list, i64))\nstring(reduce(list, list))\nstring(round(0.5))\nstring(round(1))\nstring(round(ceil(i32)))\nstring(round(f64))\nstring(round(i64))\nstring(score != nil)\nstring(score == nil)\nstring(score(1 % 1))\nstring(score(1))\nstring(score(i))\nstring(score)\nstring(sort(array))\nstring(sortBy(array, \"foo\"))\nstring(string(\"bar\"))\nstring(string(\"foo\"))\nstring(string(0.5))\nstring(string(1))\nstring(string(array))\nstring(string(div))\nstring(string(f32))\nstring(string(f64))\nstring(string(false))\nstring(string(greet))\nstring(string(half))\nstring(string(i))\nstring(string(i64))\nstring(string(nil))\nstring(string(ok))\nstring(string(score))\nstring(sum(array))\nstring(toBase64(\"foo\"))\nstring(toJSON(\"bar\"))\nstring(toJSON(0.5))\nstring(toJSON(1))\nstring(toJSON(array))\nstring(toJSON(f32))\nstring(toJSON(f64))\nstring(toJSON(false))\nstring(toJSON(i))\nstring(toJSON(i32))\nstring(toJSON(i64))\nstring(toJSON(list))\nstring(toJSON(nil))\nstring(toJSON(ok))\nstring(toJSON(true))\nstring(trim(\"bar\"))\nstring(trim(type(nil)))\nstring(trimPrefix(\"foo\"))\nstring(trimSuffix(\"foo\"))\nstring(true != false)\nstring(true && ok)\nstring(true == nil)\nstring(true ? 0.5 : true)\nstring(true ? f64 : score)\nstring(true ? false : nil)\nstring(true ? greet : i)\nstring(true ? list : ok)\nstring(true and false)\nstring(true or false)\nstring(true or ok)\nstring(true || true)\nstring(type(\"bar\"))\nstring(type(\"foo\"))\nstring(type(-i64))\nstring(type(0.5))\nstring(type(1))\nstring(type(array))\nstring(type(f32))\nstring(type(f64))\nstring(type(foo))\nstring(type(greet))\nstring(type(half))\nstring(type(i))\nstring(type(i32))\nstring(type(i64))\nstring(type(list))\nstring(type(nil))\nstring(type(ok))\nstring(type(score))\nstring(upper(\"foo\"))\nstring({\"bar\": \"foo\", \"foo\": half})\nstring({\"bar\": f32, \"foo\": i32})\nstring({\"bar\": f32})\nstring({\"bar\": true})\nstring({\"foo\": add})\nstring({\"foo\": array, \"foo\": list})\n```\n\n----------------------------------------\n\nTITLE: All Function with Range and Array Conditions\nDESCRIPTION: Evaluates the `all` function with range and array inputs, testing boolean logic, comparison operators, membership tests, and function calls within the condition. It includes checks against various data types, including numerical values, strings, and nil.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_12\n\nLANGUAGE: Expr\nCODE:\n```\nall(1 .. i64, ok)\nall([\"bar\"], # >= #)\nall([\"foo\"], # not matches #)\nall([false], # && false)\nall([false], #)\nall(array, !(# >= f64))\nall(array, !ok)\nall(array, !true)\nall(array, \"foo\" < \"bar\")\nall(array, # != #)\nall(array, # != 1)\nall(array, # != f32)\nall(array, # != f64)\nall(array, # != i32)\nall(array, # != nil)\nall(array, # < #)\nall(array, # < 0.5)\nall(array, # < 1)\nall(array, # < f64)\nall(array, # < i)\nall(array, # < i64)\nall(array, # <= #)\nall(array, # <= 0.5)\nall(array, # <= i)\nall(array, # == # + #)\nall(array, # == #)\nall(array, # == 0.5)\nall(array, # == 1)\nall(array, # == f64)\nall(array, # == i)\nall(array, # == i32)\nall(array, # == i64)\nall(array, # > #)\nall(array, # > 0.5)\nall(array, # > 1)\nall(array, # > f64)\nall(array, # > i)\nall(array, # > i32)\nall(array, # > i64)\nall(array, # >= #)\nall(array, # >= 0.5)\nall(array, # >= f32)\nall(array, # >= f64)\nall(array, # >= i32)\nall(array, # >= i64)\nall(array, # in array)\nall(array, 0.5 != #)\nall(array, 0.5 < #)\nall(array, 0.5 < f32)\nall(array, 0.5 <= #)\nall(array, 0.5 <= f32)\nall(array, 0.5 <= i)\nall(array, 0.5 > f32)\nall(array, 0.5 > f64)\nall(array, 0.5 > i32)\nall(array, 0.5 >= #)\nall(array, 0.5 >= 0.5)\nall(array, 0.5 in array)\nall(array, 1 != #)\nall(array, 1 != f32)\nall(array, 1 < #)\nall(array, 1 < f32)\nall(array, 1 == #)\nall(array, 1 > #)\nall(array, 1 > i64)\nall(array, 1 >= #)\nall(array, 1 >= 1)\nall(array, 1 >= i64)\nall(array, f32 < #)\nall(array, f32 <= #)\nall(array, f32 <= f32)\nall(array, f32 > i)\nall(array, f32 >= #)\nall(array, f64 != #)\nall(array, f64 <= #)\nall(array, f64 <= f32)\nall(array, f64 == #)\nall(array, f64 == 0.5)\nall(array, f64 == i64)\nall(array, f64 >= i64)\nall(array, false && true)\nall(array, false ? 1 : true)\nall(array, i != 0.5)\nall(array, i <= 0.5)\nall(array, i <= f32)\nall(array, i <= i32)\nall(array, i == #)\nall(array, i32 != #)\nall(array, i32 != i64)\nall(array, i32 < i)\nall(array, i32 >= #)\nall(array, i64 != #)\nall(array, i64 != i64)\nall(array, i64 == i32)\nall(array, i64 > #)\nall(array, i64 > 0.5)\nall(array, i64 >= #)\nall(array, nil != \"bar\")\nall(array, nil != #)\nall(array, nil != list)\nall(array, nil != ok)\nall(array, nil == \"foo\")\nall(array, nil == i32)\nall(array, nil == list)\nall(array, none(list, true))\nall(array, not false)\nall(array, not true)\nall(array, ok)\nall(false ? add : \"bar\", ok)\nall(filter(array, true), ok)\nall(groupBy(array, f32).score, 0.5 in #?.f64)\nall(groupBy(list, #).i, #?.half() not in # + #)\nall(i32 .. 1, ok)\nall(list, !false)\nall(list, \"bar\" in #)\nall(list, \"bar\" not in #)\nall(list, \"foo\" > \"foo\")\nall(list, # != #)\nall(list, # != nil)\nall(list, # == # || f64 != i64)\nall(list, # == #)\nall(list, # == foo)\nall(list, # in list)\nall(list, # not in list)\nall(list, 0.5 < f64)\nall(list, 0.5 < i64)\nall(list, 0.5 <= i64)\nall(list, 0.5 >= i)\nall(list, 0.5 >= i32)\nall(list, 1 != 1)\nall(list, 1 <= 1)\nall(list, 1 > i32)\nall(list, 1 >= f64)\nall(list, add == div)\nall(list, all(array, ok))\nall(list, div != nil)\nall(list, f64 != 0.5)\nall(list, f64 != f32)\nall(list, f64 < i32)\nall(list, f64 > i64)\nall(list, false ? i : true)\nall(list, i < f32)\nall(list, i <= 1)\nall(list, i <= i32)\nall(list, i > f64)\nall(list, i > i32)\nall(list, i >= 1)\nall(list, i32 < 1)\nall(list, i32 <= 0.5)\nall(list, i32 == f32)\nall(list, i64 != nil)\nall(list, i64 <= 0.5)\nall(list, i64 > 1)\nall(list, list != nil)\nall(list, nil != 1)\nall(list, nil != i64)\nall(list, nil != nil)\nall(list, nil != score)\nall(list, nil == #)\nall(list, nil == score)\nall(list, nil in array)\nall(list, none(array, 1 > #))\nall(list, not true)\nall(list, ok)\nall(list, reduce(array, true))\nall(list, type(i) not endsWith .Bar)\nall(map(array, #), ok && false)\nall(map(array, #), ok)\nall(map(array, f32), !ok)\nall(map(array, false), #)\nall(map(array, score), # != #)\nall(map(array, score), ok)\nall(map(list, \"bar\" not in #), #)\nall(map(list, 0.5), 0.5 <= #)\nall(map(list, i), # == 0.5)\nall(map(list, list), 1 == 0.5)\nall(map(list, ok), #)\nall(reduce(array, array), # > #)\nall(reduce(array, list), ok)\nall(true ? list : false, not true)\n```\n\n----------------------------------------\n\nTITLE: Check if Exactly One Array Element Matches Predicate in Expr\nDESCRIPTION: The `one()` function tests whether exactly one element in an array satisfies a provided predicate. It returns `true` if only one element satisfies the predicate, otherwise returns `false`. If the array is empty, returns `false`.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_52\n\nLANGUAGE: expr\nCODE:\n```\none(participants, {.Winner})\n```\n\n----------------------------------------\n\nTITLE: Filtering Arrays in Expr\nDESCRIPTION: Demonstrates filtering an array based on a given condition. The `filter` function takes an array and a boolean expression as input. It returns a new array containing only the elements that satisfy the specified condition.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_37\n\nLANGUAGE: Expr\nCODE:\n```\nfilter(array, i32 != i64)\nfilter(array, i32 < 0.5)\nfilter(array, i32 > #)\nfilter(array, i64 < #)\nfilter(array, i64 < i64)\nfilter(array, i64 == #)\nfilter(array, i64 == i32)\nfilter(array, i64 >= #)\nfilter(array, nil != #)\nfilter(array, nil != greet)\nfilter(array, nil == #)\nfilter(array, nil == 1)\nfilter(array, nil == i32)\nfilter(array, not false)\nfilter(array, not ok)\nfilter(array, not true)\nfilter(array, ok && true)\nfilter(array, ok)\nfilter(array, ok)[i64]\nfilter(array, score == nil)\nfilter(array, true == true)\nfilter(array, true and true)\nfilter(false ? ok : array, # == nil)\nfilter(filter(list, true), ok)\nfilter(groupBy(list, #).f64, # not matches #?.foo)\nfilter(i .. i64, ok)\nfilter(list, !ok)\nfilter(list, !true)\nfilter(list, \"bar\" < \"foo\")\nfilter(list, \"bar\" not matches \"foo\")\nfilter(list, \"foo\" == \"foo\")\nfilter(list, \"foo\" in #)\nfilter(list, \"foo\" not endsWith \"bar\")\nfilter(list, \"foo\" startsWith \"bar\")\nfilter(list, # != #)\nfilter(list, # != foo)\nfilter(list, # != nil)\nfilter(list, # == #)\nfilter(list, # == foo)\nfilter(list, # in list)\nfilter(list, 0.5 < 1)\nfilter(list, 0.5 <= 0.5)\nfilter(list, 0.5 >= 1)\nfilter(list, 0.5 >= i)\nfilter(list, 0.5 >= i64)\nfilter(list, 1 < 1)\nfilter(list, 1 <= f32)\nfilter(list, any(array, ok))\nfilter(list, any(list, true))\nfilter(list, div != div)\nfilter(list, f32 <= 1)\nfilter(list, f32 == f64)\nfilter(list, f32 > i)\nfilter(list, f64 <= 1)\nfilter(list, f64 == 0.5)\nfilter(list, false != false)\nfilter(list, false or ok)\nfilter(list, foo == #)\nfilter(list, i < 0.5)\nfilter(list, i < f32)\nfilter(list, i >= 0.5)\nfilter(list, i64 > 0.5)\nfilter(list, nil != \"foo\")\nfilter(list, nil != #)\nfilter(list, nil != #?.Bar)\nfilter(list, nil != add)\nfilter(list, nil != greet)\nfilter(list, nil != i64)\nfilter(list, nil == #)\nfilter(list, nil == 0.5)\nfilter(list, nil == f32)\nfilter(list, nil == half)\nfilter(list, nil == i32)\nfilter(list, nil == score)\nfilter(list, ok == nil)\nfilter(list, ok and false)\nfilter(list, ok)\nfilter(list, ok)[i]\nfilter(list, true == ok)\nfilter(list, true || true)\nfilter(list, true) == list\nfilter(map(array, #), # == 1)\nfilter(map(array, #), # > #)\nfilter(map(array, 1), ok)\nfilter(map(array, greet), ok)\nfilter(map(array, i32), ok)\nfilter(map(array, i64), nil == div)\nfilter(map(array, ok), true || ok)\nfilter(map(array, score), # != nil)\nfilter(map(list, #), # == #)\nfilter(map(list, #), half != nil)\nfilter(map(list, #), ok)\nfilter(map(list, array), # == #)\nfilter(map(list, f32), # == #)\nfilter(map(list, f32), ok)\nfilter(map(list, false), #)\nfilter(map(list, i32), i64 <= i32)\nfilter(map(list, ok), #)\nfilter(map(list, true), #)\nfilter(ok ? \"foo\" : 0.5, # <= i64)\nfilter(true ? list : score, # != #)\n```\n\n----------------------------------------\n\nTITLE: Range Operations and Collection Processing\nDESCRIPTION: Examples of using range operators (..) to create number sequences and collection processing functions such as groupBy, sortBy, filter, reduce, map, sum, any, all, one, find, findLast, findLastIndex, and none.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_14\n\nLANGUAGE: EXPR\nCODE:\n```\n1 + f64 | max(array)\n1 + f64 | median(array)\n1 - f64 | min(array)\n1 .. $env.i\n1 .. $env?.i\n1 .. 0 | groupBy(#)\n1 .. 0 | groupBy(foo)\n1 .. 0 | one($env)\n1 .. 0 | sortBy($env)\n1 .. 0 | sortBy(str)\n1 .. 0 | sum(greet)\n1 .. 1 | filter(ok)\n1 .. array?.[i]\n1 .. i - i\n1 .. i | groupBy(#)\n1 .. i | groupBy(foo)\n1 .. i | groupBy(ok)\n1 .. i | reduce(foo)\n1 | bitshl(0) != f64\n1 | bitxor(1) >= i\n1 | min(1.0) + i\n1..array?.[i]\n1..i | map(#)\n1..i | map(0)\n1..i | reduce(array)\n1.0 * 1.0 | mean(array)\n1.0 ** 0 | median(1)\n1.0 ** 1.0 | median(1.0)\n1.0 ** f64 | median(i)\n1.0 ** f64 | min(1)\n1.0 + 1 | median(1.0)\n1.0 + 1.0 | mean(1)\n1.0 + 1.0 | median(1.0)\n1.0 - 1 - min(1.0)\n1.0 / f64 <= f64 || true\n1.0 | max(1.0, f64) < f64\n1.0 | max(array) <= i\n1.0 | mean(f64) != i\n1.0 | median(0) ^ i\n1.0 | median(array) | get(foo)\n1.0 | min(1.0) ** i\n[$env, 0] | any(.ok)\n[$env, 1.0] | find(true)\n[$env, 1.0] | map(true)\n[$env, 1] | reduce(i, nil)\n[$env, false] | reduce(#)\n[$env, foo] | groupBy(f64)\n[$env, foo] | reduce($env)\n[$env, true] | groupBy(foo)\n[$env, true] | map(foo)\n[$env | all(false)]\n[$env | all(true)]\n[$env | any(false)]\n[$env | any(ok)]\n[$env | any(true)]\n[$env | filter(false), f64]\n[$env | findLast(false)]\n[$env | findLastIndex(false)]\n[$env | map(1.0)]\n[$env | map(add)]\n[$env | map(array)]\n[$env | map(false)]\n[$env | map(foo)]\n[$env | map(greet)]\n[$env | map(i)]\n[$env | map(list)]\n[$env | map(ok)]\n[$env | map(str)]\n[$env | none(false)]\n[$env | one(false)]\n[$env | one(ok)]\n[$env | sum(0)]\n[$env | sum(1)]\n[$env | sum(1.0)]\n[$env | sum(f64)]\n```\n\n----------------------------------------\n\nTITLE: Using the reduce function with arrays and maps\nDESCRIPTION: Illustrates the use of the `reduce` function to aggregate values within an array or map, applying different operations like summing, filtering, and mapping.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_204\n\nLANGUAGE: Expr\nCODE:\n```\nreduce(array | map(#), foo)\nreduce(array | map($env), #index)\nreduce(array | map(foo), f64)\nreduce(array | sortBy(#), ok)\nreduce(array | sortBy(1), #acc)\nreduce(array, # != #)\nreduce(array, # % i)\nreduce(array, # * #)\nreduce(array, # + 0)\nreduce(array, # / #)\nreduce(array, # <= #)\nreduce(array, # == #)\nreduce(array, # > i)\nreduce(array, # >= #)\nreduce(array, # ^ #)\nreduce(array, # in array)\nreduce(array, #)\nreduce(array, #) * f64\nreduce(array, #, add)\nreduce(array, #, array)\nreduce(array, #, i) | mean(array)\nreduce(array, #, ok)\nreduce(array, #acc)\nreduce(array, #acc, nil)?.list\nreduce(array, #index != f64)\nreduce(array, #index ** 1.0)\nreduce(array, #index ** f64)\nreduce(array, #index)\nreduce(array, $env != foo)\nreduce(array, $env == #)\nreduce(array, $env) | count(false)\nreduce(array, $env).Bar\nreduce(array, $env).String\nreduce(array, $env).add\nreduce(array, $env).array\nreduce(array, $env).f64\nreduce(array, $env).foobar\nreduce(array, $env).greet\nreduce(array, $env).i\nreduce(array, $env).list\nreduce(array, $env).str\nreduce(array, $env)?.Bar\nreduce(array, $env)?.String\nreduce(array, $env)?.[str]\nreduce(array, $env)?.add\nreduce(array, $env)?.array\nreduce(array, $env)?.f64\nreduce(array, $env)?.foo\nreduce(array, $env)?.greet\nreduce(array, $env)?.i\nreduce(array, $env)?.list\nreduce(array, $env)?.ok\nreduce(array, $env)?.str\nreduce(array, $env, $env)?.str\nreduce(array, $env, 0)?.String\nreduce(array, $env, f64)?.[str]\nreduce(array, $env, foo)?.ok\nreduce(array, $env, str)?.greet\nreduce(array, $env, true).array\nreduce(array, $env.array)\nreduce(array, $env.greet)\nreduce(array, $env.i)\nreduce(array, $env.str)\nreduce(array, $env?.add)\nreduce(array, $env?.f64)\nreduce(array, $env?.foo)\nreduce(array, $env?.greet)\nreduce(array, $env?.list, greet)\nreduce(array, $env?.str)\nreduce(array, 0) | min(1.0)\nreduce(array, 1 != $env)\nreduce(array, 1 != nil)\nreduce(array, 1.0 != #)\nreduce(array, 1.0 != 1)\nreduce(array, 1.0 * #)\nreduce(array, 1.0 ** #)\nreduce(array, 1.0 ** #index)\nreduce(array, 1.0 ** 1.0)\nreduce(array, 1.0 - #acc)\nreduce(array, 1.0 - i)\nreduce(array, 1.0 / #)\nreduce(array, 1.0 < #)\nreduce(array, 1.0 == i)\nreduce(array, 1.0 ^ #)\nreduce(array, 1.0) / $env?.i\nreduce(array, 1.0) == $env?.[str]\nreduce(array, 1.0) ^ $env?.f64\nreduce(array, [1.0])\nreduce(array, [flatten(list)])\nreduce(array, [foo])\nreduce(array, add)\nreduce(array, add, f64)\nreduce(array, array)\nreduce(array, array) | mean(1, i)\nreduce(array, array)?.[i]\nreduce(array, array[1:])\nreduce(array, bitnand(1, #acc))\nreduce(array, bitnot(#))\nreduce(array, bitnot(#)) % i\nreduce(array, bitor(i, #))\nreduce(array, ceil(#))\nreduce(array, concat(list))\nreduce(array, f64)\nreduce(array, false) == $env?.String\nreduce(array, float(i))\nreduce(array, foo == $env)\nreduce(array, foo)\nreduce(array, foo).Bar\nreduce(array, foo).String\nreduce(array, foo)?.Bar\nreduce(array, foo)?.String\nreduce(array, foo)?.String()\nreduce(array, foo, 1.0).Bar\nreduce(array, foo, greet)?.String()\nreduce(array, foo, i).Bar\nreduce(array, foo, list).Bar\nreduce(array, foo.Bar)\nreduce(array, foo.String)\nreduce(array, foo?.Bar)\nreduce(array, foo?.String)\nreduce(array, greet(str))\nreduce(array, greet)\nreduce(array, greet, foo)\nreduce(array, i .. #, greet)\nreduce(array, i <= #)\nreduce(array, i ^ #acc)\nreduce(array, i)\nreduce(array, i, array) % i\nreduce(array, i, f64) not in $env?.array\nreduce(array, keys($env))\nreduce(array, list)\nreduce(array, list[:#])\nreduce(array, mean(#))\nreduce(array, median(#))\nreduce(array, ok ? ok : #index)\nreduce(array, ok)\nreduce(array, ok, $env.ok)\nreduce(array, reduce(array, #))\nreduce(array, reduce(array, #, i))\nreduce(array, round(#))\nreduce(array, round(1))\nreduce(array, str not in foo)\nreduce(array, str)\nreduce(array, str) | greet()\nreduce(array, string(#))\nreduce(array, sum(array, 1.0))\nreduce(array, toJSON(#))\nreduce(array, toJSON(1.0))\nreduce(array, true and ok)\nreduce(array, type(#))\nreduce(array, uniq(list))\nreduce(array[0:], list)\nreduce(flatten(array), array)\nreduce(flatten(array), foo)\nreduce(flatten(list), #)\nreduce(keys($env), sum(#))\nreduce(let foobar = array; foobar, #)\nreduce(list | map(1), $env?.f64)\nreduce(list | sortBy(1.0), greet)\nreduce(list, # == #)\nreduce(list, #)\nreduce(list, #).Bar\nreduce(list, #).String\nreduce(list, #).String()\nreduce(list, #)?.Bar\nreduce(list, #)?.String\nreduce(list, #)?.String()\nreduce(list, #, 1.0)?.Bar\nreduce(list, #, array)?.String\nreduce(list, #, f64).String\nreduce(list, #, nil).String\nreduce(list, #, ok)?.Bar\nreduce(list, #.Bar != nil)\nreduce(list, #.Bar)\nreduce(list, #.String)\nreduce(list, #?.String)\nreduce(list, #acc == 0)\nreduce(list, #acc)\nreduce(list, #acc)?.Bar\nreduce(list, #acc, foo).String\nreduce(list, #index)\nreduce(list, $env && true)\nreduce(list, $env).Bar\nreduce(list, $env).String\nreduce(list, $env).add\nreduce(list, $env).array\nreduce(list, $env).array?.[i]\nreduce(list, $env).f64\nreduce(list, $env).foo\nreduce(list, $env).greet\nreduce(list, $env).i\nreduce(list, $env).list\nreduce(list, $env).ok\nreduce(list, $env).str\nreduce(list, $env)?.Bar\nreduce(list, $env)?.String\nreduce(list, $env)?.[str]\nreduce(list, $env)?.add\nreduce(list, $env)?.f64\nreduce(list, $env)?.foobar\nreduce(list, $env)?.greet\nreduce(list, $env)?.i\nreduce(list, $env)?.list\nreduce(list, $env)?.ok\nreduce(list, $env)?.str\nreduce(list, $env, $env)?.i\nreduce(list, $env, add).array\nreduce(list, $env, add).foo\nreduce(list, $env, add)?.list\nreduce(list, $env, foo).ok\nreduce(list, $env, greet)?.Bar?.str\nreduce(list, $env, nil)?.greet\nreduce(list, $env.f64)\nreduce(list, $env.list)\nreduce(list, $env?.[#.Bar])\nreduce(list, $env?.[foobar])\nreduce(list, $env?.add)\nreduce(list, $env?.f64)\nreduce(list, $env?.foo)\nreduce(list, $env?.list)\nreduce(list, $env?.ok)\nreduce(list, $env?.str)\nreduce(list, .Bar not in foo, {foo: str})\nreduce(list, .Bar)\nreduce(list, .String)\nreduce(list, 0) != i\nreduce(list, 1) * i\nreduce(list, 1) / i\nreduce(list, 1.0 * f64)\nreduce(list, 1.0 + 1)\nreduce(list, 1.0) * i\nreduce(list, 1.0) == i\nreduce(list, [$env, 0])\nreduce(list, [f64, false])\nreduce(list, [add == $env])\nreduce(list, add)\nreduce(list, array)\nreduce(list, array) | map(foo)\nreduce(list, array) | sum(#)\nreduce(list, array)?.[i]\nreduce(list, array, add)\nreduce(list, bitnot(1))\nreduce(list, f64 != $env)\nreduce(list, f64 * f64)\nreduce(list, f64 / f64)\nreduce(list, f64)\nreduce(list, f64, f64)\nreduce(list, false ?: foo)\nreduce(list, false) ? f64 : [false]\nreduce(list, first(#acc))\nreduce(list, foo)\nreduce(list, foo).Bar\nreduce(list, foo).String\nreduce(list, foo)?.Bar\nreduce(list, foo)?.String\nreduce(list, foo, foo)\nreduce(list, foo, i)?.String\nreduce(list, foo, str)\nreduce(list, foo.Bar, list)\nreduce(list, foo.String)\nreduce(list, foo?.String())\nreduce(list, foo?.String)\nreduce(list, greet(#.Bar))\nreduce(list, greet)\nreduce(list, greet, greet)\nreduce(list, i ^ 0)\nreduce(list, i)\nreduce(list, i, $env?.list[:])\nreduce(list, i, 1.0) == i\nreduce(list, i, list)\nreduce(list, int(#index))\nreduce(list, int(0))\nreduce(list, list | any(ok))\nreduce(list, list | map($env))\nreduce(list, list)\nreduce(list, list)?.[i]\nreduce(list, list, i)\nreduce(list, nil != $env)\nreduce(list, ok)\nreduce(list, ok, f64)\nreduce(list, reduce(array, greet, foo))\nreduce(list, str)\nreduce(list, str) == str\nreduce(list, string(ok))\nreduce(list, toBase64(#.Bar))\nreduce(list, true != $env)\nreduce(list, true != ok)\nreduce(list, true || false)\nreduce(list, true || true)\nreduce(list, type(i))\nreduce(list, type(list))\nreduce(list[:1], [$env])\nreduce(map($env, 1.0), #)\nreduce(map($env, foo), str)\nreduce(map(array, foo), foo?.Bar)\nreduce(map(array, list), list)\nreduce(map(list, #), $env?.add)\nreduce(map(list, i), #)\nreduce(reduce(array, list), #index)\n```\n\n----------------------------------------\n\nTITLE: Expr f64 Less Than or Equal Operations\nDESCRIPTION: This code demonstrates the usage of the less than or equal to operator (<=) with f64 numbers. It showcases different scenarios involving f64 numbers, environment variables, and function calls, evaluating conditions where an f64 value is less than or equal to other values or expressions. It covers various cases like comparing against constants, variables, and results of function calls.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_83\n\nLANGUAGE: Expr\nCODE:\n```\nf64 <= $env.f64\nf64 <= $env.i\nf64 <= $env?.f64\nf64 <= $env?.i\nf64 <= 0 ** 1.0\nf64 <= 0 > i\nf64 <= 0.1\nf64 <= 1 - i\nf64 <= 1 / f64\nf64 <= 1 >= f64\nf64 <= 1 ^ 0\nf64 <= 1 or true\nf64 <= 1 || $env\nf64 <= 1.0 != nil\nf64 <= 1.0 && $env\nf64 <= 1.0 && true\nf64 <= 1.0 * $env?.i\nf64 <= 1.0 * min(i)\nf64 <= 1.0 <= f64\nf64 <= 1.0 <= mean(1.0)\nf64 <= 1.0 > 1\nf64 <= 1.0 ^ 1.0\nf64 <= 1.0 and $env\nf64 <= 1.0 and ok\nf64 <= 1.1 <= 1\nf64 <= abs(0)\nf64 <= abs(f64)\nf64 <= add(i, i)\nf64 <= array?.[i]\nf64 <= bitnand(i, 1)\nf64 <= f64\nf64 <= f64 && $env\nf64 <= f64 - 0\nf64 <= f64 and $env\nf64 <= floor(1.0)\nf64 <= i\nf64 <= i + f64\nf64 <= i == $env?.Bar\nf64 <= i > i\nf64 <= int(1.0)\nf64 <= len(list)\nf64 <= mean(i)\nf64 <= median(1.0)\nf64 <= min(f64)\nf64 <= sum(array)\nf64 <= sum(array, #)\n```\n\n----------------------------------------\n\nTITLE: ToJson Serialization\nDESCRIPTION: Illustrates the `toJSON` function for serializing various data types, operations, and expressions into JSON format.  Demonstrates serialization of literals, comparisons, function calls, arithmetic, logical operations, arrays, and more. Includes null values and type information.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_117\n\nLANGUAGE: Expr\nCODE:\n```\ntoJSON(!false)\ntoJSON(!ok)\ntoJSON(!true)\ntoJSON(\"bar\" < \"foo\")\ntoJSON(\"bar\" >= \"bar\")\ntoJSON(\"bar\" endsWith \"bar\")\ntoJSON(\"bar\" matches \"foo\")\ntoJSON(\"bar\" not in foo)\ntoJSON(\"bar\" not matches \"bar\")\ntoJSON(\"bar\" not startsWith \"foo\")\ntoJSON(\"bar\" startsWith \"bar\")\ntoJSON(\"bar\") not in foo\ntoJSON(\"foo\" != \"bar\")\ntoJSON(\"foo\" != \"foo\")\ntoJSON(\"foo\" < \"foo\")\ntoJSON(\"foo\" == \"bar\")\ntoJSON(\"foo\" > \"foo\")\ntoJSON(\"foo\" >= \"foo\")\ntoJSON(\"foo\" startsWith \"bar\")\ntoJSON(-0.5)\ntoJSON(-1)\ntoJSON(-f32)\ntoJSON(-f64)\ntoJSON(-i)\ntoJSON(-i32)\ntoJSON(-i64)\ntoJSON(0.5 != 1)\ntoJSON(0.5 != f64)\ntoJSON(0.5 != nil)\ntoJSON(0.5 * i)\ntoJSON(0.5 * i32)\ntoJSON(0.5 * i64)\ntoJSON(0.5 ** 0.5)\ntoJSON(0.5 ** 1)\ntoJSON(0.5 ** f32)\ntoJSON(0.5 ** f64)\ntoJSON(0.5 ** i)\ntoJSON(0.5 ** i32)\ntoJSON(0.5 + 0.5)\ntoJSON(0.5 + 1)\ntoJSON(0.5 + f32)\ntoJSON(0.5 - 0.5)\ntoJSON(0.5 - 1)\ntoJSON(0.5 - f32)\ntoJSON(0.5 - f64)\ntoJSON(0.5 - i)\ntoJSON(0.5 - i32)\ntoJSON(0.5 / 1)\ntoJSON(0.5 / f32)\ntoJSON(0.5 / f64)\ntoJSON(0.5 / i32)\ntoJSON(0.5 < 1)\ntoJSON(0.5 < f32)\ntoJSON(0.5 < f64)\ntoJSON(0.5 < i)\ntoJSON(0.5 <= 0.5)\ntoJSON(0.5 <= 1)\ntoJSON(0.5 <= f32)\ntoJSON(0.5 <= i64)\ntoJSON(0.5 == 0.5)\ntoJSON(0.5 == f64)\ntoJSON(0.5 == i)\ntoJSON(0.5 == i32)\ntoJSON(0.5 == i64)\ntoJSON(0.5 >= 0.5)\ntoJSON(0.5 >= 1)\ntoJSON(0.5 >= f32)\ntoJSON(0.5 ^ f32)\ntoJSON(0.5 ^ i32)\ntoJSON(0.5 ^ i64)\ntoJSON(0.5) not in foo\ntoJSON(1 != 0.5)\ntoJSON(1 != f32)\ntoJSON(1 != nil)\ntoJSON(1 % 1)\ntoJSON(1 % i)\ntoJSON(1 % i32)\ntoJSON(1 * f64)\ntoJSON(1 * i32)\ntoJSON(1 * i64)\ntoJSON(1 ** 0.5)\ntoJSON(1 ** 1)\ntoJSON(1 ** i32)\ntoJSON(1 + 0.5)\ntoJSON(1 + 1)\ntoJSON(1 + f64)\ntoJSON(1 + i)\ntoJSON(1 + i32)\ntoJSON(1 - i)\ntoJSON(1 - i32)\ntoJSON(1 .. i32)\ntoJSON(1 .. i64)\ntoJSON(1 / 1)\ntoJSON(1 / f64)\ntoJSON(1 / i64)\ntoJSON(1 < 0.5)\ntoJSON(1 < 1)\ntoJSON(1 < f64)\ntoJSON(1 < i)\ntoJSON(1 <= 0.5)\ntoJSON(1 <= f32)\ntoJSON(1 <= f64)\ntoJSON(1 == 0.5)\ntoJSON(1 == 1)\ntoJSON(1 == f64)\ntoJSON(1 == i)\ntoJSON(1 == i32)\ntoJSON(1 == nil)\ntoJSON(1 > f32)\ntoJSON(1 > i)\ntoJSON(1 >= 1)\ntoJSON(1 >= f32)\ntoJSON(1 >= i32)\ntoJSON(1 ^ 1)\ntoJSON(1 ^ f32)\ntoJSON(1 ^ i32)\ntoJSON(1 ^ i64)\ntoJSON(1) > reduce(list, \"bar\")\ntoJSON(1) not contains string(true)\ntoJSON([f64])\ntoJSON([false])\ntoJSON([foo])\ntoJSON([nil])\ntoJSON([true])\ntoJSON(abs(0.5))\ntoJSON(abs(1))\ntoJSON(abs(f32))\ntoJSON(abs(f64))\ntoJSON(abs(i))\ntoJSON(abs(i32))\ntoJSON(abs(i64))\ntoJSON(add == add)\ntoJSON(any(array, false))\ntoJSON(array == array)\ntoJSON(array == list)\ntoJSON(array == nil)\ntoJSON(array)\ntoJSON(array[1:i64])\ntoJSON(array[1])\ntoJSON(array[i])\ntoJSON(bitnot(1))\ntoJSON(bitnot(i))\ntoJSON(bitnot(i32))\ntoJSON(bitnot(i64))\ntoJSON(bitshl(i, i32))\ntoJSON(ceil(1))\ntoJSON(ceil(f64))\ntoJSON(ceil(i))\ntoJSON(ceil(i32))\ntoJSON(ceil(i64))\ntoJSON(count(array, ok))\ntoJSON(div != div)\ntoJSON(div == div)\ntoJSON(f32 != 0.5)\ntoJSON(f32 != 1 || ok)\ntoJSON(f32 != f32)\ntoJSON(f32 != i32)\ntoJSON(f32 * f32)\ntoJSON(f32 ** 0.5)\ntoJSON(f32 ** 1)\ntoJSON(f32 ** f64)\n```\n\n----------------------------------------\n\nTITLE: String Concatenation in Expr\nDESCRIPTION: This snippet demonstrates string concatenation in the Expr language using the `+` operator. It shows concatenation with various data types, including environment variables, object properties, function calls, and other strings. The expressions showcase the Expr language's ability to handle implicit type conversions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_214\n\nLANGUAGE: Expr\nCODE:\n```\nstr + $env not endsWith $env and false\nstr + $env.str\nstr + $env?.[str]\nstr + $env?.str\nstr + foo.Bar\nstr + foo.String()\nstr + foo?.Bar\nstr + foo?.String()\nstr + greet(str)\nstr + str\nstr + str != $env\nstr + string($env)\nstr + string(add)\nstr + string(f64)\nstr + string(str)\nstr + toBase64(str)\nstr + toJSON(i)\nstr + toJSON(list)\nstr + toJSON(nil)\nstr + toJSON(str)\nstr + type($env)\n```\n\n----------------------------------------\n\nTITLE: Using findIndex with map and conditional operators\nDESCRIPTION: Shows the utilization of `findIndex` in conjunction with the `map` function and various conditional operators to filter elements from arrays and lists.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_41\n\nLANGUAGE: expr\nCODE:\n```\nfindIndex(map(array, #), # < #)\nfindIndex(map(array, #), # >= #)\nfindIndex(map(array, #), i > #)\nfindIndex(map(array, f32), i32 == #)\nfindIndex(map(array, i), # != #)\nfindIndex(map(array, i), ok)\nfindIndex(map(list, #), # != #)\nfindIndex(map(list, #), # == #)\nfindIndex(map(list, i64), # == 0.5)\nfindIndex(map(list, i64), i64 < #)\nfindIndex(map(list, true), #)\nfindIndex(map(list, true), ok)\nfindIndex(ok ? \"foo\" : greet, !ok)\nfindIndex(ok ? \"foo\" : i, # == #)\nfindIndex(sort(array), i32 == #)\nfindIndex(true ? \"foo\" : ok, # == greet)\n```\n\n----------------------------------------\n\nTITLE: Expr Eval Function Example (Go)\nDESCRIPTION: This snippet demonstrates the usage of the `expr.Eval` function in Go, which combines the compilation and execution steps into a single call. It evaluates the expression `2 + 2` with an environment `env` (which is not used in this example but included for demonstration purposes). This is useful for one-off expressions where the compiled program does not need to be reused.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/getting-started.md#_snippet_6\n\nLANGUAGE: go\nCODE:\n```\noutput, err := expr.Eval(`2 + 2`, env)\n```\n\n----------------------------------------\n\nTITLE: Summing List with Various Expressions in Expr\nDESCRIPTION: This example showcases the `sum` function in Expr with a variety of expressions as input. These expressions involve environment variables, literals, arithmetic operations, function calls, and list access. This illustrates how to calculate the sum of different types of values extracted from a list or derived from other data.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_174\n\nLANGUAGE: Expr\nCODE:\n```\nlist | sum($env.i)\nlist | sum(0 - 1.0)\nlist | sum(0)\nlist | sum(0) != i\nlist | sum(0) >= 1.0 == false\nlist | sum(1)\nlist | sum(1) / 0 ** 1\nlist | sum(1) | median(array)\nlist | sum(1.0)\nlist | sum(array | findLastIndex(true))\nlist | sum(f64 * 1.0)\nlist | sum(f64)\nlist | sum(f64) in array\nlist | sum(i)\nlist | sum(int(i))\n```\n\n----------------------------------------\n\nTITLE: GroupBy Function Usage - Expr\nDESCRIPTION: Examples showcasing the `groupBy` function in Expr with different keys including field access, arithmetic expressions, and conditionals.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_121\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy($env | map(i), ok)\ngroupBy($env.array, #)\ngroupBy($env.array, 0 * 1.0)\ngroupBy($env.array, foo)\ngroupBy($env.array, i / #)\ngroupBy($env.list, #)\ngroupBy($env.list, foo)\ngroupBy($env.list, nil != #.String)\ngroupBy($env?.[str], #)\ngroupBy($env?.[str], 1.0 <= i)\ngroupBy($env?.[str], f64)\ngroupBy($env?.[str], i)\ngroupBy($env?.[str], mean(#))\ngroupBy($env?.[str], ok)\ngroupBy($env?.[str], ok)?.add\ngroupBy($env?.array, #)\ngroupBy($env?.array, $env?.i)\ngroupBy($env?.array, f64)\ngroupBy($env?.array, i)\ngroupBy($env?.array, str)\ngroupBy($env?.list, $env?.i)\ngroupBy($env?.list, 0 == $env)\ngroupBy(1 .. 1, ok)\ngroupBy([1.0], # / f64)\ngroupBy([1.0], foo)\ngroupBy([1], #)\ngroupBy([false, str], ok)\ngroupBy([false], #)\ngroupBy([foo], 0 >= i)\ngroupBy([foo], i)\ngroupBy([i], foo)\ngroupBy([list], abs(1.0))\ngroupBy([str], str)\ngroupBy(array | filter(false), greet)\ngroupBy(array | map($env), #.ok)\ngroupBy(array, # != 1.0)\ngroupBy(array, # % #)\ngroupBy(array, # * i)\ngroupBy(array, # + #)\ngroupBy(array, # / #)\n```\n\n----------------------------------------\n\nTITLE: String Splitting in Expr\nDESCRIPTION: This snippet shows the use of `split` and `splitAfter` functions in the Expr language for string manipulation. The `split` function splits a string into a list of substrings based on a separator. The `splitAfter` function splits a string after the provided seperator.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_212\n\nLANGUAGE: Expr\nCODE:\n```\nsplit(str, $env?.[str])\nsplit(str, str)\nsplit(str, string($env))\nsplit(str, toBase64(str))\nsplitAfter(foo?.Bar, str)\nsplitAfter(str, foo?.String())\nsplitAfter(str, str)\nsplitAfter(str, toJSON(nil))\n```\n\n----------------------------------------\n\nTITLE: Any Function with Array and Range Conditions\nDESCRIPTION: Tests the `any` function with various conditions on arrays and ranges, checking for the existence of elements that satisfy the given predicate. Includes boolean operations, string comparisons, membership tests, and checks against nil and other data types.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_13\n\nLANGUAGE: Expr\nCODE:\n```\nany([\"bar\"], # not endsWith #)\nany([greet], ok)\nany(array, !(i32 <= #))\nany(array, \"foo\" >= \"foo\")\nany(array, \"foo\" not endsWith \"bar\")\nany(array, # != # or # > #)\nany(array, # != #)\nany(array, # != 0.5)\nany(array, # != f32)\nany(array, # != f64)\nany(array, # != i32)\nany(array, # != i64)\nany(array, # != nil)\nany(array, # < #)\nany(array, # < 0.5)\nany(array, # < 1)\nany(array, # < f32)\nany(array, # < f64)\nany(array, # < i)\nany(array, # < i32)\nany(array, # <= #)\nany(array, # <= 0.5)\nany(array, # <= 1)\nany(array, # <= f32)\nany(array, # <= i)\nany(array, # <= i32)\nany(array, # <= i64)\nany(array, # == #)\nany(array, # == 0.5)\nany(array, # == 1)\nany(array, # == i32)\nany(array, # == i64)\nany(array, # > #)\nany(array, # > 0.5)\nany(array, # > 1)\nany(array, # > f64)\nany(array, # > i32)\nany(array, # >= #)\nany(array, # >= 0.5)\nany(array, # >= 1)\nany(array, # >= f32)\nany(array, # >= i32)\nany(array, # >= i64)\nany(array, # in array)\nany(array, 0.5 != #)\nany(array, 0.5 == #)\nany(array, 0.5 == i32)\nany(array, 0.5 > #)\nany(array, 0.5 > f64)\nany(array, 0.5 >= #)\nany(array, 1 != i64)\nany(array, 1 < #)\nany(array, 1 < 0.5)\nany(array, 1 <= #)\nany(array, 1 == #)\nany(array, 1 > #)\nany(array, 1 > 1)\nany(array, 1 >= #)\nany(array, 1 >= f64)\nany(array, all(list, false))\nany(array, f32 < i)\nany(array, f32 > #)\nany(array, f32 > 0.5)\nany(array, f32 >= #)\nany(array, f64 != #)\nany(array, f64 < i)\nany(array, f64 <= #)\nany(array, f64 == #)\nany(array, f64 > #)\nany(array, f64 > 0.5)\nany(array, false && false)\nany(array, greet == greet)\nany(array, i != #)\nany(array, i < #)\nany(array, i > #)\nany(array, i >= #)\nany(array, i32 > i64)\nany(array, i64 < #)\nany(array, i64 == f64)\nany(array, i64 >= #)\nany(array, nil != #)\nany(array, nil != 1)\nany(array, nil != i)\nany(array, nil != ok)\nany(array, nil == \"foo\")\nany(array, nil == #)\nany(array, nil == 1)\nany(array, ok != true)\nany(array, ok)\nany(array, one(array, # <= 0.5))\nany(array, one(array, ok))\nany(array, score == nil)\nany(i32 .. i, half == half)\nany(list, !ok)\nany(list, !true)\nany(list, \"bar\" < \"foo\")\nany(list, \"bar\" not in #)\nany(list, \"bar\" not startsWith \"foo\")\nany(list, \"foo\" not in foo)\nany(list, # != #)\nany(list, # == #)\nany(list, # == foo)\nany(list, # == nil)\nany(list, 0.5 != 1)\nany(list, 0.5 < 1)\nany(list, 0.5 < f64)\nany(list, 0.5 == i64)\nany(list, 1 >= f64)\nany(list, 1 >= i32)\nany(list, any(list, false))\nany(list, any(list, ok))\nany(list, array == nil)\nany(list, f32 < 1)\nany(list, f32 <= i64)\nany(list, f32 > 1)\nany(list, f32 > i64)\nany(list, f32 >= i32)\nany(list, f64 != i64)\nany(list, f64 >= 1)\nany(list, false) == (foo not in list)\nany(list, false) || false ? nil : add\nany(list, i > i64)\nany(list, i >= 0.5)\nany(list, i32 != 0.5)\nany(list, i64 <= 1)\nany(list, i64 == 0.5)\nany(list, i64 == i)\nany(list, i64 >= i32)\nany(list, i64 not in array)\nany(list, nil == false)\nany(list, nil == nil)\nany(list, none(array, false))\nany(list, not ok)\nany(list, ok || # == #)\nany(list, ok)\nany(list, reduce(list, true))\nany(list, true ? false : f64)\nany(map(array, #), # >= #)\nany(map(array, #), ok)\nany(map(array, false), #)\nany(map(array, ok), # and #)\nany(map(array, ok), #)\nany(map(list, #), nil == #)\nany(map(list, false), nil == i32)\n```\n\n----------------------------------------\n\nTITLE: Using Expr with Structs in Go\nDESCRIPTION: This Go example demonstrates how to use Expr with structs. It defines a `Tweet` struct with a `Len` field and an `Env` struct containing a slice of `Tweet`.  It compiles and runs an expression that checks if all tweets in the `Tweets` slice have a `Len` less than or equal to 240, using the `all` function.\nSOURCE: https://github.com/expr-lang/expr/blob/master/README.md#_snippet_6\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/expr-lang/expr\"\n)\n\ntype Tweet struct {\n\tLen int\n}\n\ntype Env struct {\n\tTweets []Tweet\n}\n\nfunc main() {\n\tcode := `all(Tweets, {.Len <= 240})`\n\n\tprogram, err := expr.Compile(code, expr.Env(Env{}))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tenv := Env{\n\t\tTweets: []Tweet{{42}, {98}, {69}},\n\t}\n\toutput, err := expr.Run(program, env)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(output)\n}\n```\n\n----------------------------------------\n\nTITLE: Expr Example: Date Parsing\nDESCRIPTION: Demonstrates the use of the `date` function within an expression, highlighting how the timezone setting affects date parsing.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/configuration.md#_snippet_9\n\nLANGUAGE: expr\nCODE:\n```\ndate(\"2024-11-23 12:00:00\") // parses the date in the specified timezone\nnow() // returns the current time in the specified timezone\n```\n\n----------------------------------------\n\nTITLE: String Functions in Expr\nDESCRIPTION: Demonstrates the use of string-related functions such as `indexOf`, `join`, `keys`, `string`, `toJSON` and `toPairs` in the Expr language. The snippets illustrate various ways to use these functions with different data types, variables, and expressions.  These examples cover string manipulation, object key retrieval, and data conversion.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_163\n\nLANGUAGE: Expr\nCODE:\n```\nindexOf($env?.[str], str)\nindexOf(str, str)\nindexOf(toJSON(1.0), toJSON(true))\njoin([str])\njoin(array | map(str))\njoin(keys($env))\njoin(map(list, #.Bar))\njoin(sort($env))\nstring(0)\nstring(1.0)\ntoJSON(0)\ntoJSON(1)\ntoJSON(1.0)\ntoPairs($env) | reduce(i)\nkeys($env) != array\nkeys($env) == nil && true\nkeys($env) | count(true)\nkeys($env) | find(false)\nkeys($env) | groupBy(#)\nkeys($env) | groupBy($env?.i)\nkeys($env) | map(#)\nkeys($env) | map(1)\nkeys($env) | map(1.0)\nkeys($env) | map(add)\nkeys($env) | map(f64)\nkeys($env) | map(str)\nkeys($env) | reduce(#)\nkeys($env) | reduce(1.0)\nkeys($env) | reduce(ok)\nkeys($env) | sortBy(str)\nkeys($env)?.[i]\nkeys(array | reduce($env))\n```\n\n----------------------------------------\n\nTITLE: Log Filtering and Aggregation in Expr\nDESCRIPTION: This example demonstrates filtering and aggregating log data based on severity levels. It filters log entries with the level 'error', extracts the timestamp and message, and sorts the results by time.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/examples.md#_snippet_1\n\nLANGUAGE: Expr\nCODE:\n```\nlet logs = [\n  {timestamp: date(\"2023-08-14 08:30:00\"), message: \"User logged in\", level: \"info\"},\n  {timestamp: date(\"2023-08-14 09:00:00\"), message: \"Error processing payment\", level: \"error\"},\n  {timestamp: date(\"2023-08-14 10:15:00\"), message: \"User logged out\", level: \"info\"},\n  {timestamp: date(\"2023-08-14 11:00:00\"), message: \"Error connecting to database\", level: \"error\"}\n];\n\nlogs\n| filter(.level == \"error\")\n| map({{\n    time: string(.timestamp),\n    detail: .message\n }})\n| sortBy(.time)\n```\n\n----------------------------------------\n\nTITLE: Parsing Dates with date() in Expr\nDESCRIPTION: The `date()` function parses a string into a date representation. It supports various formats, including ISO 8601, RFC formats, and custom formats specified using Go's time package formatting rules. The function can optionally accept a format string and a timezone string.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_40\n\nLANGUAGE: expr\nCODE:\n```\ndate(\"2023-08-14\")\ndate(\"15:04:05\")\ndate(\"2023-08-14T00:00:00Z\")\ndate(\"2023-08-14 00:00:00\", \"2006-01-02 15:04:05\", \"Europe/Zurich\")\n```\n\n----------------------------------------\n\nTITLE: Bitwise Shift Left Operations in Expr\nDESCRIPTION: Illustrates the `bitshl` function with various types (integer literals, variables, function calls), showing potential type conversions and precedence in Expr.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_20\n\nLANGUAGE: Expr\nCODE:\n```\nbitshl(bitnot(i), i)\nbitshl(i, i)\nbitshl(i, i32)\nbitshl(i, i64)\nbitshl(i32, i)\nbitshl(i32, i32)\nbitshl(i32, i64)\nbitshl(i64, i32)\nbitshl(i64, i64)\nbitshl(len(array), i)\nbitshl(score(i), i32)\n```\n\n----------------------------------------\n\nTITLE: Join Function Test\nDESCRIPTION: This snippet focuses on calls to the `join` function with `map` as input. This test case is designed to evaluate the interaction between collection processing and string manipulation within the Expr language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_69\n\nLANGUAGE: expr\nCODE:\n```\njoin(map(array, \"foo\"))\njoin(map(list, \"foo\"))\n```\n\n----------------------------------------\n\nTITLE: Compiling with Operator Overloading\nDESCRIPTION: Demonstrates the `Operator` option which simplifies operator overloading.  It compiles the expression `code` using the `expr.Compile` function, applying the `expr.Operator` option to replace the `+` operator with calls to the `add` function. Requires pre-defined environment and code.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/patch.md#_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nprogram, err := expr.Compile(code, expr.Env(env), expr.Operator(\"+\", \"add\"))\n```\n\n----------------------------------------\n\nTITLE: Array Access and Method Chaining\nDESCRIPTION: Examples of array access using the `?.[i]` syntax, and method chaining with the `|` operator. It includes accessing array elements, filtering, reducing, and searching within arrays. Different combinations of variables and literals are used to validate the array access and method chaining.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_24\n\nLANGUAGE: Expr\nCODE:\n```\n[true, 1] == $env?.array\n[true, add] | findLast(true)\n[true, add] | reduce(array, greet)\n[true, add]?.[i]\n[true, foo] | find(#)\n[true, foo]?.[i]\n[true, list]?.[i]\n[true, nil]?.[i]\n[true, ok] | find(true)\n[true, ok]?.[i]\n```\n\n----------------------------------------\n\nTITLE: Evaluating Types with trimSuffix and type function - Expr\nDESCRIPTION: These expressions use the `trimSuffix` function in conjunction with the `type` function to determine the data type of various values and expressions after a suffix is potentially removed. The `type` function returns the data type as a string, and `trimSuffix` removes a specified suffix from the input string if it exists.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_124\n\nLANGUAGE: expr\nCODE:\n```\ntrimSuffix(type(1))\ntrimSuffix(type(add))\ntrimSuffix(type(array))\ntrimSuffix(type(div))\ntrimSuffix(type(f32))\ntrimSuffix(type(foo))\ntrimSuffix(type(greet))\ntrimSuffix(type(half))\ntrimSuffix(type(i32))\ntrimSuffix(type(list))\ntrimSuffix(type(nil))\ntrimSuffix(type(ok))\ntrimSuffix(upper(\"foo\"))\n```\n\n----------------------------------------\n\nTITLE: String 'matches' checks in Expr\nDESCRIPTION: This snippet demonstrates the use of `matches` and `not matches` operators in the Expr language to check if a string `str` matches a regular expression or pattern. The expressions cover various scenarios, including checking against environment variables, object properties, function calls, and literal strings.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_218\n\nLANGUAGE: Expr\nCODE:\n```\nstr matches $env and false\nstr matches $env.str\nstr matches $env?.Bar\nstr matches $env?.String\nstr matches $env?.String?.list\nstr matches $env?.[Bar]\nstr matches $env?.[Bar]?.f64\nstr matches $env?.[String]\nstr matches $env?.[foobar]\nstr matches $env?.[foobar]?.str\nstr matches $env?.[str]\nstr matches $env?.foobar?.[ok]\nstr matches $env?.str\nstr matches foo.Bar\nstr matches foo.String()\nstr matches foo?.Bar\nstr matches foo?.String()\nstr matches str\nstr matches string($env?.[String])\nstr matches string(1)\nstr matches string(1.0)\nstr matches string(add)\nstr matches toJSON(nil)\nstr matches type(0)\nstr matches type(foo)\nstr matches type(i)\nstr matches type(str)\nstr matches type(true)\nstr not matches $env.str\nstr not matches $env?.Bar\nstr not matches $env?.String\nstr not matches $env?.[Bar]\nstr not matches $env?.[String]\nstr not matches $env?.[foobar]\nstr not matches $env?.[str]\nstr not matches $env?.foobar\nstr not matches $env?.str\nstr not matches foo.Bar\nstr not matches foo.String()\nstr not matches foo?.Bar\nstr not matches foo?.String()\nstr not matches str\nstr not matches str || ok\nstr not matches string(foo)\nstr not matches toJSON(1.0)\nstr not matches toJSON(f64)\nstr not matches toJSON(i)\nstr not matches toJSON(nil)\nstr not matches type(false)\n```\n\n----------------------------------------\n\nTITLE: Using the `last` Function in Expr\nDESCRIPTION: This snippet demonstrates the usage of the `last` function in the Expr language. It shows how to extract the last element from various data structures including arrays, maps, results of pipeline operations using `map` and different conditional expressions. It covers many cases of using optional chaining.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_166\n\nLANGUAGE: Expr\nCODE:\n```\nlast($env | map(#index))\nlast($env | map(1))\nlast($env | map(add))\nlast($env | map(foo))\nlast($env | map(greet))\nlast($env) == i\nlast($env) == ok\nlast($env) contains foo.Bar\nlast($env) in array\nlast($env) not contains foo.Bar\nlast($env) not in array\nlast($env) startsWith str\nlast($env)?.Bar\nlast($env)?.Bar()\nlast($env)?.Bar()?.foo\nlast($env)?.Bar(foobar)\nlast($env)?.Bar?.[i]\nlast($env)?.Bar?.greet\nlast($env)?.String\nlast($env)?.String()\nlast($env)?.String().add\nlast($env)?.[add]\nlast($env)?.[array]\nlast($env)?.[array].i\nlast($env)?.[f64]\nlast($env)?.[f64]?.f64(foobar, greet)\nlast($env)?.[f64]?.foo()\nlast($env)?.[foo]\nlast($env)?.[foo].Bar\nlast($env)?.[foo]?.foo\nlast($env)?.[greet]\nlast($env)?.[greet]?.[i]\nlast($env)?.[greet]?.[ok]\nlast($env)?.[i]\nlast($env)?.[list]\nlast($env)?.[list].greet\nlast($env)?.[ok]\nlast($env)?.[ok] != i\nlast($env)?.[ok].ok()\nlast($env)?.[str]\nlast($env)?.[str]?.[foo]\nlast($env)?.[str]?.i\nlast($env)?.add\nlast($env)?.add()\nlast($env)?.add(f64)\nlast($env)?.add.add()\nlast($env)?.add.i\nlast($env)?.add?.[ok]\nlast($env)?.array\nlast($env)?.array()\nlast($env)?.array.list()\nlast($env)?.f64\nlast($env)?.f64()\nlast($env)?.f64(greet(foobar))\nlast($env)?.f64(list)\nlast($env)?.f64?.[list]\nlast($env)?.findLast(foo, foobar)\nlast($env)?.foo\nlast($env)?.foo()\nlast($env)?.foo(String, foobar?.greet)\nlast($env)?.foo?.[foo]\nlast($env)?.foo?.[greet]\nlast($env)?.greet\nlast($env)?.greet()\nlast($env)?.greet?.i\nlast($env)?.i\nlast($env)?.i()\nlast($env)?.i.foo\nlast($env)?.i?.greet\nlast($env)?.i?.i\nlast($env)?.list\nlast($env)?.list()\nlast($env)?.list.array\nlast($env)?.none(foobar)?.String()\nlast($env)?.ok\nlast($env)?.ok()\nlast($env)?.str\nlast($env)?.str()\nlast($env)?.str(foobar)\nlast($env)?.str?.[list]\nlast($env)?.toJSON(str)\nlast($env.array)\nlast($env.list)\nlast($env?.$env)\nlast($env?.Bar)\nlast($env?.Bar)?.[add]\nlast($env?.Bar)?.[f64]\nlast($env?.Bar)?.[ok]\nlast($env?.Bar)?.add()\nlast($env?.Bar?.String)\nlast($env?.Bar?.[list])\nlast($env?.Bar?.[ok])\nlast($env?.String)\nlast($env?.String?.[add])\nlast($env?.[Bar])\nlast($env?.[Bar]?.[str])\nlast($env?.[Bar]?.array)\nlast($env?.[String])\nlast($env?.[String])?.Bar\nlast($env?.[String])?.[add]\nlast($env?.[String])?.[foo]\nlast($env?.[String]?.[foo])\nlast($env?.[foobar])\nlast($env?.[foobar])?.[f64]\nlast($env?.[foobar])?.f64()\nlast($env?.[foobar]?.str)\nlast($env?.[nil])\nlast($env?.[str])\nlast($env?.array)\nlast($env?.false)\nlast($env?.foobar)\nlast($env?.foobar)?.ok\nlast($env?.foobar?.[greet])\nlast($env?.list)\nlast($env?.nil)\nlast($env?.true)\nlast(0 .. 0)\nlast(0 .. 1)\nlast(1 .. 0)\nlast(1 .. 1)\nlast(1 .. i)\nlast([$env, true])\nlast([$env])\nlast([$env]).i\nlast([0])\nlast([1, 0])\nlast([1, nil])\nlast([1.0])\nlast([1])\nlast([add])\nlast([array, 0])\nlast([array])\nlast([f64])\nlast([false, 0])\nlast([false])\nlast([foo, str])\nlast([foo])\nlast([greet])\nlast([i])\nlast([list])\nlast([nil])\nlast([ok])\nlast([str])\nlast(array | map(f64))\nlast(array | map(false))\nlast(array | reduce(#acc))\nlast(array)\nlast(array) != i\nlast(array) % i\nlast(array) >= i\nlast(false ? $env : $env)\nlast(false ? $env : greet)\nlast(false ? add : greet)\nlast(false ? false : 1)\nlast(false ? foo : greet)\nlast(false ?: $env)\nlast(false ?: add)\nlast(filter($env, false))\nlast(filter(array, true))\nlast(filter(list, true))\nlast(first($env))\nlast(flatten(array))\nlast(flatten(list))\nlast(groupBy(list, f64)?.[ok])\nlast(if ok { false } else { $env })\nlast(if ok { foo } else { true })\nlast(if ok { list } else { $env })\nlast(if true { $env } else { 1.0 })\nlast(if true { 1.0 } else { 1 })\nlast(if true { add } else { ok })\nlast(if true { list } else { array })\nlast(keys($env))\nlast(last($env))\nlast(last($env)?.[list])\nlast(list | map(foo))\nlast(list | map(greet))\nlast(list | map(ok))\nlast(list | map(str))\nlast(list | reduce(array))\nlast(list | sortBy(0))\nlast(list)\nlast(list) == foo\nlast(list).Bar\nlast(list).String\nlast(list).String()\nlast(list)?.Bar\nlast(list)?.String\nlast(list)?.String()\nlast(list[1:])\nlast(map($env, $env))\nlast(map($env, f64))\nlast(map($env, foo))\nlast(map(array, #))\nlast(map(array, false))\nlast(map(list, #))\nlast(map(list, 1.0))\nlast(map(list, i))\nlast(max($env))\nlast(max($env?.Bar))\nlast(max(0, array))\nlast(max(array))\nlast(mean(array))\nlast(median(array))\nlast(median(i, array))\nlast(min($env))\nlast(min(array))\nlast(min(array, 1.0))\nlast(min(if true { $env } else { f64 }))\nlast(reduce(list, #acc))\nlast(reduce(list, list, foo))\nlast(reverse(array))\nlast(reverse(list))\nlast(sort($env))\nlast(sort(array))\nlast(sortBy(array, 0))\nlast(toPairs($env))\nlast(true ? 1.0 : greet)\nlast(true ? array : 0)\nlast(true ? foo : array)\nlast(true ? list : 1)\nlast(true ? str : 1.0)\nlast(uniq(array))\nlast(uniq(list))\nlast(values($env))\n```\n\n----------------------------------------\n\nTITLE: Array Sorting Operations in Expr\nDESCRIPTION: Demonstrates the usage of the `sortBy` function in Expr to sort arrays based on different criteria. The function sorts the array based on the expression provided as input.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_62\n\nLANGUAGE: Expr\nCODE:\n```\narray | sortBy(# + #)\narray | sortBy(# + i)\narray | sortBy(# / #)\narray | sortBy(# ^ 1.0)\narray | sortBy(# ^ f64)\narray | sortBy(#)\narray | sortBy(#) | all(ok)\narray | sortBy(#) | map(#)\narray | sortBy(#) | map(foo)\narray | sortBy($env?.[str])\narray | sortBy($env?.i)\narray | sortBy(0 ^ #)\narray | sortBy(0)\narray | sortBy(0) | median(1.0)\narray | sortBy(1)\narray | sortBy(1.0)\narray | sortBy(1.0) != list\narray | sortBy(1.0) | one(true)\narray | sortBy(1.0) | sortBy(#)\narray | sortBy(array | reduce(1.0))\narray | sortBy(array?.[i])\narray | sortBy(bitnot(i))\narray | sortBy(f64)\narray | sortBy(f64) | map(#)\narray | sortBy(f64) | sortBy(1.0)\narray | sortBy(f64) | sortBy(i)\narray | sortBy(floor(#))\narray | sortBy(foo.String())\narray | sortBy(i)\narray | sortBy(i) | sortBy(#)\narray | sortBy(reduce(array, str, foo))\narray | sortBy(str + str)\narray | sortBy(str)\n```\n\n----------------------------------------\n\nTITLE: Using the `len` Function in Expr\nDESCRIPTION: This snippet showcases the use of the `len` function to get the length of different data types such as strings, arrays, maps, and the results of various operations like filtering and mapping. It also shows some arithmetic and comparison operations with the results of the len function.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_169\n\nLANGUAGE: Expr\nCODE:\n```\nlen($env | filter(ok))\nlen($env | map(1.0))\nlen($env | map(foo))\nlen($env | map(i))\nlen($env | map(true))\nlen($env) != f64\nlen($env) ** int(f64)\nlen($env) + i\nlen($env) ^ 1.0 < f64\nlen($env) ^ max(f64)\nlen($env) ^ min(f64)\nlen($env.array)\nlen($env.list)\nlen($env.str)\nlen($env?.[str])\nlen($env?.array)\nlen($env?.list)\nlen($env?.str)\nlen(0 .. 0)\nlen(0 .. i)\nlen(1 .. 0)\nlen([$env, 1.0])\nlen([$env])\nlen([0, str])\nlen([1.0])\nlen([1])\nlen([add, i])\nlen([add])\nlen([f64, 0])\nlen([f64])\nlen([false])\nlen([foo, 1])\nlen([foo, foo])\nlen([foo, i])\nlen([foo])\nlen([greet])\nlen([list, f64])\nlen([list])\nlen([nil, foo, add])\nlen([nil, nil])\nlen([nil])\nlen([ok])\nlen([str])\nlen([true])\nlen(array | filter(false))\nlen(array | groupBy(1))\nlen(array | groupBy(true))\nlen(array | map(#))\nlen(array | sortBy(#))\nlen(array)\nlen(array) * i\nlen(array) - i\nlen(array) == nil && false\nlen(array) > findIndex(list, true)\nlen(array[1:])\nlen(array[:0])\nlen(array[:1])\nlen(array[:i])\nlen(concat(array))\nlen(concat(list))\nlen(filter($env, ok))\nlen(flatten(array))\nlen(flatten(list))\nlen(flatten(map($env, $env)))\nlen(foo.Bar)\nlen(foo.String())\nlen(foo?.Bar)\nlen(foo?.String())\nlen(greet(greet(str)))\nlen(greet(str))\nlen(groupBy(array, 1.0))\nlen(groupBy(array, f64))\nlen(groupBy(array, foo))\nlen(groupBy(array, i))\nlen(groupBy(list, #))\nlen(groupBy(list, foo))\nlen(if true { str } else { nil })\nlen(keys($env))\nlen(list | filter(false))\nlen(list | filter(true))\nlen(list | groupBy(#))\nlen(list | groupBy(str))\nlen(list | map(#.String))\nlen(list | map($env))\nlen(list | map(1))\nlen(list | map(1.0))\nlen(list | map(str))\nlen(list | reduce(#.Bar))\nlen(list)\nlen(list) % i\nlen(list) ** i\nlen(list) == f64\nlen(list) > i\nlen(list) ^ f64\nlen(list)..i\nlen(list[:])\nlen(lower(str))\nlen(map($env, 1))\nlen(map($env, 1.0))\nlen(map($env, array))\nlen(map($env, f64))\nlen(map($env, foo))\nlen(map($env, str))\nlen(map(array, #))\nlen(map(array, $env))\nlen(map(array, 1))\nlen(map(array, foo))\nlen(map(list, #))\nlen(map(list, f64))\nlen(max($env))\nlen(min($env))\nlen(reduce(array, $env))\nlen(reduce(array, array))\nlen(reduce(list, $env, foo))\nlen(reverse(array))\nlen(sort($env))\nlen(sortBy(list, #.Bar))\nlen(sortBy(list, .Bar))\nlen(sortBy(list, 1))\nlen(str)\nlen(str) + 1.0 - i\nlen(str) .. 0 | find($env)\nlen(str) .. i\nlen(str) == i\nlen(str) >= f64\nlen(str) | bitnand(1)\nlen(str) | bitor(1)\nlen(str) | mean(i)\nlen(str) | median(1.0)\nlen(str) | min(1.0)\nlen(str[0:])\nlen(str[1:])\nlen(str[:1])\nlen(string($env))\nlen(string(1))\nlen(string(1.0))\nlen(string(array))\nlen(string(false))\nlen(string(foo))\nlen(string(greet))\nlen(string(i))\nlen(string(list))\nlen(string(nil))\nlen(string(ok))\nlen(toBase64(str))\nlen(toJSON(0))\nlen(toJSON(1))\nlen(toJSON(false))\nlen(toJSON(foo))\nlen(toJSON(list))\nlen(toJSON(nil))\nlen(toJSON(ok))\nlen(toJSON(str))\nlen(toJSON(true))\nlen(toPairs($env))\nlen(trim(str))\nlen(trimPrefix(str))\nlen(trimSuffix(str))\nlen(type($env))\nlen(type(0))\nlen(type(1))\nlen(type(1.0))\nlen(type(add))\nlen(type(array))\nlen(type(foo))\nlen(type(greet))\nlen(type(i))\nlen(type(list))\nlen(type(nil))\nlen(type(str))\nlen(type(true))\nlen(uniq(array))\nlen(uniq(list))\nlen(upper(str))\nlen(values($env))\n```\n\n----------------------------------------\n\nTITLE: Using findLast with lists and conditional operators\nDESCRIPTION: Shows the implementation of `findLast` with lists and diverse conditional operators, including logical negation and membership tests.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_45\n\nLANGUAGE: expr\nCODE:\n```\nfindLast(list, !false)\nfindLast(list, !ok)\nfindLast(list, \"foo\" in #)\nfindLast(list, # != #)\nfindLast(list, # != nil)\nfindLast(list, # == #)\nfindLast(list, # == foo)\nfindLast(list, # in list)\nfindLast(list, # not in list)\nfindLast(list, 0.5 != i64)\nfindLast(list, 0.5 <= 1)\nfindLast(list, 0.5 == i64)\nfindLast(list, 1 != f32)\nfindLast(list, 1 != nil)\nfindLast(list, 1 <= 1)\nfindLast(list, 1 > f32)\nfindLast(list, 1 >= f64)\nfindLast(list, f32 != i)\nfindLast(list, f32 > f32)\nfindLast(list, f32 >= 1)\nfindLast(list, f64 <= i)\nfindLast(list, f64 in array)\nfindLast(list, false)?.Bar\nfindLast(list, foo != #)\nfindLast(list, foo in list)\nfindLast(list, i != i)\nfindLast(list, i <= 1)\nfindLast(list, i <= i)\nfindLast(list, i == i32)\nfindLast(list, i >= i)\nfindLast(list, i32 != f32)\nfindLast(list, i64 > f32)\nfindLast(list, i64 > i)\nfindLast(list, i64 >= 1)\nfindLast(list, nil != #)\nfindLast(list, nil not in array)\nfindLast(list, nil not in list)\nfindLast(list, none(array, ok))\nfindLast(list, not false)\nfindLast(list, not true)\nfindLast(list, ok or true)\nfindLast(list, ok)\nfindLast(list, ok) not in list\nfindLast(list, ok).Bar\nfindLast(list, ok).Qux\nfindLast(list, ok).String\nfindLast(list, ok)?.Bar\nfindLast(list, ok)?.Qux\nfindLast(list, ok)?.String\nfindLast(list, true or ok)\nfindLast(list, true).Bar\nfindLast(list, true).Qux\nfindLast(list, true).String\nfindLast(list, true)?.Bar\nfindLast(list, true)?.Qux\nfindLast(list, true)?.String\n```\n\n----------------------------------------\n\nTITLE: Using first Function in Expr\nDESCRIPTION: This snippet demonstrates the usage of the `first` function in the Expr language. It includes accessing nested properties, calling methods, conditional expressions, and working with different data types. It attempts to retrieve the first element from a collection or the result of an expression.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_98\n\nLANGUAGE: Expr\nCODE:\n```\nfirst($env | findLast(false))\nfirst($env | map($env))\nfirst($env | map($env))?.foo\nfirst($env) != foo\nfirst($env) != i\nfirst($env) == str\nfirst($env) not contains str\nfirst($env) not in array\nfirst($env) not matches str\nfirst($env) not startsWith str\nfirst($env) startsWith str\nfirst($env)?.$env?.array()\nfirst($env)?.Bar\nfirst($env)?.Bar()\nfirst($env)?.Bar(add)\nfirst($env)?.String\nfirst($env)?.String()\nfirst($env)?.String?.array\nfirst($env)?.[add]\nfirst($env)?.[add]?.[foo]\nfirst($env)?.[array]\nfirst($env)?.[f64]\nfirst($env)?.[f64]?.String\nfirst($env)?.[foo]\nfirst($env)?.[foo]?.[greet].String\nfirst($env)?.[greet]\nfirst($env)?.[greet]?.[greet]\nfirst($env)?.[greet]?.str\nfirst($env)?.[i]\nfirst($env)?.[i]?.add\nfirst($env)?.[i]?.str\nfirst($env)?.[list]\nfirst($env)?.[ok]\nfirst($env)?.[ok].add()\nfirst($env)?.[str]\nfirst($env)?.[str]?.f64\nfirst($env)?.[str]?.ok\nfirst($env)?.add\nfirst($env)?.add()\nfirst($env)?.add?.[greet]\nfirst($env)?.array\nfirst($env)?.array()\nfirst($env)?.array(foobar)\nfirst($env)?.f64\nfirst($env)?.f64()\nfirst($env)?.f64(f64)\nfirst($env)?.f64(foobar)\nfirst($env)?.f64.String\nfirst($env)?.findIndex(add)\nfirst($env)?.foo\nfirst($env)?.foo()\nfirst($env)?.foo(foobar not contains foobar)\nfirst($env)?.foo(foobar)\nfirst($env)?.foo?.[greet]\nfirst($env)?.foobar not in $env\nfirst($env)?.foobar.greet\nfirst($env)?.foobar?.[greet]\nfirst($env)?.greet\nfirst($env)?.greet()\nfirst($env)?.greet(foobar not startsWith foobar)\nfirst($env)?.greet(foobar, foobar)\nfirst($env)?.greet(true)\nfirst($env)?.greet?.[i]\nfirst($env)?.greet?.str\nfirst($env)?.i\nfirst($env)?.i()\nfirst($env)?.i?.add\nfirst($env)?.list\nfirst($env)?.list()\nfirst($env)?.list(foo)\nfirst($env)?.list(foobar?.[Bar])\nfirst($env)?.list.str\nfirst($env)?.list?.add\nfirst($env)?.map(add)\nfirst($env)?.ok\nfirst($env)?.ok()\nfirst($env)?.ok(foobar)\nfirst($env)?.str\nfirst($env)?.str()\nfirst($env)?.str(f64)\nfirst($env.array)\nfirst($env.list)\nfirst($env?.$env)\nfirst($env?.Bar)\nfirst($env?.Bar)?.array\nfirst($env?.Bar?.[array])\nfirst($env?.Bar?.f64)\nfirst($env?.String)\nfirst($env?.String)?.String()\nfirst($env?.[Bar])\nfirst($env?.[Bar])?.[i]\nfirst($env?.[Bar])?.str\nfirst($env?.[Bar]?.String)\nfirst($env?.[Bar]?.f64)\nfirst($env?.[String])\nfirst($env?.[String]?.foo)\nfirst($env?.[foobar])\nfirst($env?.[foobar])?.Bar\nfirst($env?.[nil]?.ok)\nfirst($env?.[str])\nfirst($env?.array)\nfirst($env?.false)\nfirst($env?.foobar)\nfirst($env?.foobar)?.Bar()\nfirst($env?.foobar)?.i()\nfirst($env?.list)\nfirst($env?.nil)\nfirst($env?.nil)?.f64\nfirst(0..i)\nfirst(1 .. i)\nfirst(1 | median(array))\nfirst(1.0 | min(array))\nfirst([$env?.array])\nfirst([$env])\nfirst([0])\nfirst([1.0])\nfirst([1])\nfirst([add, $env, greet])\nfirst([add])\nfirst([array])\nfirst([f64])\nfirst([false])\nfirst([foo])\nfirst([greet])\nfirst([i])\nfirst([list])\nfirst([nil])\nfirst([ok])\nfirst([str])\nfirst([true])\nfirst(array | map($env))\nfirst(array | map(0))\nfirst(array | map(foo))\nfirst(array | sortBy(#))\nfirst(array | sortBy(1.0))\nfirst(array | take(1))\nfirst(array)\nfirst(array) != i\nfirst(array) == i\nfirst(array) > 1.0 > $env\nfirst(array) | bitand(1)\nfirst(array[:0])\nfirst(array[:1])\nfirst(concat(array))\nfirst(concat(list))\nfirst(filter(list, ok))\nfirst(first($env))\nfirst(flatten(array))\nfirst(flatten(list))\nfirst(i .. 1)\nfirst(i..i)\nfirst(if false { 0 } else { foo })\nfirst(if true { 0 } else { foo })?.add\nfirst(if true { ok } else { 1 })\nfirst(if true { ok } else { 1.0 })\nfirst(keys($env))\nfirst(last($env))\nfirst(let foobar = list; foobar)\nfirst(list | map(#))\nfirst(list | map(0))\nfirst(list | map(add))\nfirst(list | map(true))\nfirst(list | reduce(list))\nfirst(list | sortBy(#.Bar))\nfirst(list)\nfirst(list) == $env?.String\nfirst(list).Bar\nfirst(list).String\nfirst(list).String()\nfirst(list)?.Bar\nfirst(list)?.String\nfirst(list)?.String()\nfirst(list[:i])\nfirst(map($env, $env))\nfirst(map($env, 0))\nfirst(map($env, array))\nfirst(map($env, f64))\nfirst(map($env, i))\nfirst(map(array, #))\nfirst(map(array, 0))\nfirst(map(array, 1.0))\nfirst(map(array, false))\nfirst(map(array, greet))\nfirst(map(array, str))\nfirst(map(array, true))\nfirst(map(list, #))\nfirst(map(list, 0))\nfirst(map(list, foo))\nfirst(max($env))\nfirst(max(array))\nfirst(mean(array))\nfirst(median(array))\nfirst(min($env))\nfirst(min(array))\nfirst(ok ? 0 : 1.0)\nfirst(ok ?: $env)\nfirst(ok ?: add)\nfirst(ok ?: list)\nfirst(reduce(array, $env))\nfirst(reverse(list))\nfirst(sort($env))\nfirst(sortBy(array, #))\nfirst(sortBy(array, f64))\nfirst(sortBy(list, .Bar))\nfirst(toPairs($env))\nfirst(true ? 1.0 : foo)\nfirst(true ?: 1.0)?.str\nfirst(uniq(array))\nfirst(uniq(list))\nfirst(values($env))\nfirst({foo: 1.0}.f64)\nfirst({foo: greet, foo: nil}.ok)\n```\n\n----------------------------------------\n\nTITLE: Casting to float in Expr\nDESCRIPTION: This snippet shows how to cast different expressions to a float type in the Expr language using the `float()` function. It demonstrates the conversion of various data types, mathematical operations, conditional statements, and function calls to their floating-point representation. The snippets also illustrate interactions with environment variables and list processing functions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_101\n\nLANGUAGE: Expr\nCODE:\n```\nfloat($env | findLastIndex(ok))\nfloat($env | findLastIndex(true))\nfloat($env | sum(1.0))\nfloat($env | sum(f64))\nfloat($env.f64)\nfloat($env.i)\nfloat($env?.f64)\nfloat($env?.i)\nfloat(0 % 1)\nfloat(0 % i)\nfloat(0 * 1)\nfloat(0 * 1.0)\nfloat(0 * f64)\nfloat(0 ** 1.0)\nfloat(0 ** f64)\nfloat(0 ** i)\nfloat(0 + 1)\nfloat(0 + i)\nfloat(0 - 1.0)\nfloat(0 - i)\nfloat(0 / 0)\nfloat(0 / 1.0)\nfloat(0 / i)\nfloat(0 ^ 1.0)\nfloat(0 ^ i)\nfloat(0) > f64\nfloat(0) > i\nfloat(0) ^ f64\nfloat(1 % i)\nfloat(1 * 1.0)\nfloat(1 ** 1)\nfloat(1 ** f64)\nfloat(1 ** i)\nfloat(1 + 1)\nfloat(1 + 1.0)\nfloat(1 + i)\nfloat(1 - 1.0)\nfloat(1 - f64)\nfloat(1 / 1)\nfloat(1 / 1.0)\nfloat(1 ^ 0)\nfloat(1 ^ 1.0)\nfloat(1 ^ i)\nfloat(1) - f64\nfloat(1) < f64\nfloat(1) == i\nfloat(1) in [add, true]\nfloat(1.0 * 0)\nfloat(1.0 * 1)\nfloat(1.0 * 1.0)\nfloat(1.0 * f64)\nfloat(1.0 * i)\nfloat(1.0 ** 1)\nfloat(1.0 ** 1.0)\nfloat(1.0 ** f64)\nfloat(1.0 + 0)\nfloat(1.0 + 1.0)\nfloat(1.0 + f64)\nfloat(1.0 + i)\nfloat(1.0 - 0)\nfloat(1.0 - 1)\nfloat(1.0 - 1.0)\nfloat(1.0 - f64)\nfloat(1.0 - i)\nfloat(1.0 / 1.0)\nfloat(1.0 / f64)\nfloat(1.0 / i)\nfloat(1.0 ^ 1)\nfloat(1.0 ^ 1.0)\nfloat(1.0 ^ f64)\nfloat(1.0 ^ i)\nfloat(1.0 | min(f64))\nfloat(1.0) != $env?.[str]\nfloat(1.0) * max(f64)\nfloat(1.0) - f64\nfloat(1.0) / i\nfloat(1.0) == 0 % 1\nfloat(1.0) == i\nfloat(1.0) == i != false\nfloat(1.0) > f64\nfloat(1.0) >= last(array)\nfloat(abs(0))\nfloat(abs(1.0))\nfloat(abs(f64))\nfloat(abs(i))\nfloat(add(0, i))\nfloat(array | max(1))\nfloat(array | reduce(#index, 1.0))\nfloat(array | sum(#))\nfloat(array | sum(1.0))\nfloat(array?.[i])\nfloat(bitand(0, i))\nfloat(bitnot(0))\nfloat(bitnot(i))\nfloat(bitor(0, i))\nfloat(bitshl(i, 0))\nfloat(bitshr(0, 0))\nfloat(bitshr(i, 1))\nfloat(ceil(0))\nfloat(ceil(1))\nfloat(ceil(1.0))\nfloat(ceil(f64))\nfloat(ceil(i))\nfloat(count($env, false))\nfloat(count(list, false))\nfloat(count(list, ok))\nfloat(f64 * 1.0)\nfloat(f64 ** 0)\nfloat(f64 ** 1)\nfloat(f64 ** 1.0)\nfloat(f64 + f64)\nfloat(f64 + i)\nfloat(f64 - 1.0)\nfloat(f64 / 1.0)\nfloat(f64 / i)\nfloat(f64 ^ 0)\nfloat(f64 ^ 1.0)\nfloat(f64)\nfloat(f64) != f64\nfloat(f64) == i\nfloat(false ? i : 1.0)\nfloat(false ? str : 1.0)\nfloat(false ?: 1.0)\nfloat(false ?: i)\nfloat(findIndex($env, ok))\nfloat(findIndex(array, true))\nfloat(findLastIndex($env, true))\nfloat(float(1))\nfloat(float(f64))\nfloat(floor(1))\nfloat(floor(1.0))\nfloat(floor(f64))\nfloat(i % 1)\nfloat(i * 1.0)\nfloat(i ** 1.0)\nfloat(i + 1)\nfloat(i - 0)\nfloat(i - 1)\nfloat(i - f64)\nfloat(i - i)\nfloat(i / 1)\nfloat(i / 1.0)\nfloat(i)\nfloat(i) + first(array)\nfloat(if false { 1.0 } else { 1 })\nfloat(if false { greet } else { 1 })\nfloat(if false { greet } else { 1.0 })\nfloat(if true { 0 } else { $env })\nfloat(int(0))\nfloat(int(1))\nfloat(int(1.0))\nfloat(int(f64))\nfloat(int(i))\nfloat(lastIndexOf(str, str))\nfloat(len($env))\nfloat(len(array))\nfloat(len(list))\nfloat(len(str))\nfloat(let foobar = i; foobar)\nfloat(list | findIndex(ok))\nfloat(list | reduce(i))\nfloat(list | sum(f64))\nfloat(max(0))\nfloat(max(1.0))\nfloat(max(i))\nfloat(mean(0))\nfloat(mean(1))\nfloat(mean(1.0 - 1.0))\nfloat(mean(1.0))\nfloat(mean(array))\nfloat(mean(f64))\nfloat(mean(i))\nfloat(median(0))\nfloat(median(1.0))\nfloat(median(1.0, 0, 0))\nfloat(median(1.0, i))\nfloat(median(f64))\nfloat(median(i))\nfloat(min($env?.array))\nfloat(min(0))\nfloat(min(1.0))\nfloat(min(array))\nfloat(min(i))\nfloat(reduce($env, 1.0, 1.0))\nfloat(reduce(list, 0))\nfloat(reduce(list, 1))\nfloat(reduce(list, i))\nfloat(round(1))\nfloat(round(1.0))\nfloat(round(f64))\nfloat(round(i))\nfloat(string(0))\nfloat(string(1))\nfloat(string(1.0))\nfloat(string(f64))\nfloat(sum($env, 0))\nfloat(sum($env, 1))\nfloat(sum($env?.array))\nfloat(sum(array))\nfloat(sum(array, #))\nfloat(sum(array, 1))\nfloat(sum(array, i))\nfloat(sum(list, 1))\nfloat(toJSON(1))\nfloat(toJSON(i))\nfloat(toJSON(min(1.0)))\nfloat(true ? 1.0 : ok)\nfloat(true ? f64 : foo)\nfloat(true ? f64 : str)\n```\n\n----------------------------------------\n\nTITLE: Count Array Elements Matching Predicate in Expr\nDESCRIPTION: The `count()` function returns the number of elements in an array that satisfy the given predicate. If no predicate is given, it counts the number of `true` values in the array, assuming it is an array of booleans.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_61\n\nLANGUAGE: expr\nCODE:\n```\ncount(users, .Age > 18)\n```\n\nLANGUAGE: expr\nCODE:\n```\nlen(filter(users, .Age > 18))\n```\n\nLANGUAGE: expr\nCODE:\n```\ncount([true, false, true]) == 2\n```\n\n----------------------------------------\n\nTITLE: Mapping Lists with Transformations and Conditional Access in Expr\nDESCRIPTION: Illustrates mapping over a list and extracting values, providing a way to modify a list of values through expressions. The examples use properties, strings, and numeric indexing.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_188\n\nLANGUAGE: Expr\nCODE:\n```\nmap(list, #.String)\nmap(list, #.String)?.[i]\nmap(list, #?.String)\n```\n\n----------------------------------------\n\nTITLE: String Operations on Fields - Expr\nDESCRIPTION: Demonstrates string operations like 'contains', 'endsWith', 'startsWith', and 'matches' on fields, including optional chaining and different data types.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_111\n\nLANGUAGE: Expr\nCODE:\n```\nfoo.Bar contains $env?.String\nfoo.Bar contains str\nfoo.Bar endsWith str\nfoo.Bar matches str\nfoo?.Bar contains $env?.Bar\nfoo?.Bar contains $env?.[Bar]\nfoo?.Bar endsWith $env?.String\nfoo?.Bar endsWith first($env)\nfoo?.Bar endsWith str\nfoo?.Bar matches str\nfoo?.Bar matches toJSON(array)\nfoo.String() contains str\nfoo.String() endsWith str\nfoo?.String() matches str\n\n```\n\n----------------------------------------\n\nTITLE: Diverse Property Access Scenarios within Maps\nDESCRIPTION: Showcases a diverse set of property access scenarios within maps, encompassing combinations of functions, operators, and varying data types. Focuses on complex interactions and potential edge cases during evaluation.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_133\n\nLANGUAGE: expr-lang\nCODE:\n```\n{\"bar\": add, \"bar\": half}.div\n{\"bar\": add, \"bar\": i, \"bar\": ok}?.foo\n{\"bar\": add, \"bar\": list}\n{\"bar\": add, \"bar\": ok, \"foo\": 1}?.ok\n{\"bar\": add, \"foo\": \"foo\"}?.f64\n{\"bar\": add}\n{\"bar\": add}.Qux\n{\"bar\": add}.String\n{\"bar\": add}.add\n{\"bar\": add}.array\n{\"bar\": add}.div\n{\"bar\": add}.half\n{\"bar\": add}?.Qux\n{\"bar\": add}?.String\n{\"bar\": add}?.add\n{\"bar\": add}?.array\n{\"bar\": add}?.div\n{\"bar\": add}?.f64\n{\"bar\": add}?.f64 != half\n{\"bar\": add}?.half\n{\"bar\": add}?.ok\n{\"bar\": add}?.score?.div\n{\"bar\": array, \"bar\": \"bar\"}?.i\n{\"bar\": array, \"bar\": array}?.foo\n{\"bar\": array, \"bar\": f32}\n{\"bar\": array, \"bar\": nil}.i64\n{\"bar\": array, \"foo\": f32}?.String\n{\"bar\": array, \"foo\": f64}\n{\"bar\": array, \"foo\": half}?.add\n{\"bar\": array, \"foo\": i32}\n{\"bar\": array, \"foo\": score}\n{\"bar\": array}\n{\"bar\": array}.Bar\n{\"bar\": array}.div\n{\"bar\": array}.div?.Qux\n{\"bar\": array}.greet\n{\"bar\": array}.i\n{\"bar\": array}.i64\n{\"bar\": array}.list\n{\"bar\": array}.score\n{\"bar\": array}?.add?.ok\n{\"bar\": array}?.div\n{\"bar\": array}?.f64\n{\"bar\": array}?.greet\n{\"bar\": array}?.half\n{\"bar\": array}?.i64\n{\"bar\": array}?.ok\n```\n\n----------------------------------------\n\nTITLE: String Comparisons in Expr\nDESCRIPTION: This snippet contains various expressions that compare a string `str` with different values and expressions using operators like `!=`, `==`, `<`, `<=`, `>`, and `>=`. It showcases comparisons with environment variables, object properties, function calls, and other strings. The expressions demonstrate the Expr language's ability to handle different data types and null-safe access.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_213\n\nLANGUAGE: Expr\nCODE:\n```\nstr != $env == $env\nstr != $env ? 1.0 : $env\nstr != $env and ok\nstr != $env or $env\nstr != $env.str\nstr != $env?.Bar\nstr != $env?.String\nstr != $env?.[Bar]\nstr != $env?.[String]\nstr != $env?.[nil]\nstr != $env?.[str]\nstr != $env?.str\nstr != foo.Bar\nstr != foo.String()\nstr != foo?.Bar\nstr != foo?.String()\nstr != greet(str)\nstr != median(array)\nstr != min(array, array)\nstr != nil && $env\nstr != nil ? foo : f64\nstr != nil or $env\nstr != nil or $env?.[Bar]\nstr != nil or ok\nstr != nil || $env\nstr != reduce(array, #acc, foo)\nstr != reduce(list, .Bar, false)\nstr != str\nstr != str && $env?.String.i()\nstr != str && true\nstr != str ? 0 : 1.0\nstr != str ? foo : true\nstr != string(f64)\nstr != string(list)\nstr != toJSON(false)\nstr != toJSON(foo)\nstr != trim(str)\nstr != type(foo)\nstr != type(str)\nstr == $env or $env\nstr == $env || $env?.[Bar]\nstr == $env.str\nstr == $env?.Bar\nstr == $env?.String\nstr == $env?.[Bar]\nstr == $env?.[Bar]?.[array]\nstr == $env?.[String]\nstr == $env?.[String]?.array\nstr == $env?.[foobar]\nstr == $env?.[str]\nstr == $env?.foo.Bar\nstr == $env?.foobar\nstr == $env?.not\nstr == $env?.str\nstr == $env?.true\nstr == first($env)\nstr == foo.Bar\nstr == foo.String()\nstr == foo?.Bar\nstr == foo?.String()\nstr == greet(str)\nstr == max($env)\nstr == nil or true || $env\nstr == reduce(array, str)\nstr == str\nstr == str || true\nstr == string(add)\nstr == string(foo)\nstr == toBase64(str | repeat(0))\nstr == toJSON(0)\nstr == toJSON(1.0)\nstr == trim(str)\nstr == type(add)\nstr == type(foo)\nstr == type(greet)\nstr == {foo: 1}.array\nstr < $env && false\nstr < $env.str\nstr < $env?.[str]\nstr < $env?.str\nstr < foo.Bar\nstr < foo.String()\nstr < foo?.Bar\nstr < foo?.String()\nstr < greet(str)\nstr < str\nstr < str && false\nstr < str || ok\nstr < string(add)\nstr < string(foo)\nstr < type(array)\nstr < type(nil)\nstr < type(true)\nstr <= $env.str\nstr <= $env?.[str]\nstr <= $env?.foobar and false\nstr <= $env?.str\nstr <= foo.Bar\nstr <= foo.String()\nstr <= foo?.Bar\nstr <= foo?.String()\nstr <= greet(str)\nstr <= str\nstr <= str ?: str\nstr <= str[:i]\nstr <= string($env)\nstr <= string(0)\nstr <= string(list)\nstr <= string(nil)\nstr <= toJSON(nil)\nstr <= type(1.0)\nstr <= type(true)\nstr > $env or true\nstr > $env || true\nstr > $env.str\nstr > $env?.[str]\nstr > $env?.str\nstr > foo.Bar\nstr > foo.String()\nstr > foo?.Bar\nstr > foo?.String()\nstr > str\nstr > str + str\nstr > str ?: 1\nstr > str and true\nstr > str[1:]\nstr > string($env)\nstr > toJSON(ok)\nstr > trimSuffix(str)\nstr > type(1)\nstr > type(1.0)\nstr > type(add)\nstr > type(nil)\nstr >= $env && false\nstr >= $env or true\nstr >= $env.str\nstr >= $env?.[str]\nstr >= $env?.str\nstr >= foo.Bar\nstr >= foo.String()\nstr >= foo?.Bar\nstr >= foo?.String()\nstr >= greet(str)\nstr >= str\nstr >= string(1)\nstr >= string(1.0)\nstr >= toJSON(false)\nstr >= type(list)\n```\n\n----------------------------------------\n\nTITLE: Array `take` Function in Expr\nDESCRIPTION: Illustrates the use of the `take` function in Expr to retrieve a specified number of elements from an array.  The parameter dictates how many elements from the beginning are taken.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_64\n\nLANGUAGE: Expr\nCODE:\n```\narray | take(0)\narray | take(1)\narray | take(i)\n```\n\n----------------------------------------\n\nTITLE: trim Function in Expr\nDESCRIPTION: Demonstrates the use of the `trim` function to remove whitespace or specified characters from both ends of a string.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_22\n\nLANGUAGE: expr\nCODE:\n```\ntrim(\"  Hello  \") == \"Hello\"\n```\n\nLANGUAGE: expr\nCODE:\n```\ntrim(\"__Hello__\", \"_\") == \"Hello\"\n```\n\n----------------------------------------\n\nTITLE: Expr with Go Types and sprintf (Go)\nDESCRIPTION: This snippet demonstrates Expr's ability to work with various Go types and built-in functions like `fmt.Sprintf`. It defines an environment containing a format string, a string slice, and the `fmt.Sprintf` function itself. It compiles an expression that formats a string using `sprintf` with the format string and the first element of the string slice. The result is then printed to the console.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/getting-started.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nenv := map[string]any{\n    \"greet\":   \"Hello, %v!\",\n    \"names\":   []string{\"world\", \"you\"},\n    \"sprintf\": fmt.Sprintf,\n}\n\nprogram, err := expr.Compile(`sprintf(greet, names[0])`, expr.Env(env))\nif err != nil {\n    panic(err)\n}\n\noutput, err := expr.Run(program, env)\nif err != nil {\n    panic(err)\n}\n\nfmt.Print(output) // Hello, world!\n```\n\n----------------------------------------\n\nTITLE: Find Max with various conditionals and mappings in Expr\nDESCRIPTION: Demonstrates various expressions within `max`, from simple comparisons to calls of `find`, `findIndex`, `map` and `sum`.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_191\n\nLANGUAGE: Expr\nCODE:\n```\nmax($env | find(false))\nmax($env | findIndex(ok))\nmax($env | findLastIndex(ok))\nmax($env | map(#index))\nmax($env | map(0))\nmax($env | sum(i))\nmax($env) != $env?.array\nmax($env) != greet\nmax($env) == $env?.foo\nmax($env) == list\nmax($env) == ok\n```\n\n----------------------------------------\n\nTITLE: Using 'not in' Operator in Expr\nDESCRIPTION: This snippet shows how to use the `not in` operator in the Expr language. The examples provided demonstrate checking the non-existence of a variable (`foo`) within different data structures such as lists, maps, and environment variables. It highlights interactions with nested properties and conditional statements.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_106\n\nLANGUAGE: Expr\nCODE:\n```\nfoo not in $env.list\nfoo not in $env?.Bar\nfoo not in $env?.String\nfoo not in $env?.[Bar]\nfoo not in $env?.[Bar]?.String\nfoo not in $env?.[String]\n```\n\n----------------------------------------\n\nTITLE: Date Difference Calculation in Expr\nDESCRIPTION: This example calculates the difference between two dates and extracts the number of days and hours between them.  It uses the date function to create dates and then subtracts them to determine the duration.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/examples.md#_snippet_6\n\nLANGUAGE: Expr\nCODE:\n```\nlet startDate = date(\"2023-01-01\");\nlet endDate = date(\"2023-12-31\");\nlet diff = endDate - startDate;\n{\n  daysBetween: diff.Hours() / 24,\n  hoursBetween: diff.Hours()\n}\n```\n\n----------------------------------------\n\nTITLE: Expr Safe Navigation with Chained Access\nDESCRIPTION: Demonstrates chained safe navigation. If any property in the chain is null, the whole expression evaluates to null without errors. This shows how the `?.` operator handles multi-level property access.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_145\n\nLANGUAGE: expr\nCODE:\n```\n{\"foo\": ok}?.String?.Bar\n```\n\n----------------------------------------\n\nTITLE: Boolean Negation Examples (not)\nDESCRIPTION: This snippet demonstrates the use of the `not` operator in the Expr language with various data types and comparison expressions. It showcases the negation of comparison operations involving integers (i64, i32, i), floats (f64, f32), nil, arrays, and lists.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_89\n\nLANGUAGE: Expr\nCODE:\n```\nnot (i64 <= f64)\nnot (i64 <= i)\nnot (i64 <= i32)\nnot (i64 <= i64)\nnot (i64 == 0.5)\nnot (i64 == 1)\nnot (i64 == f32)\nnot (i64 == f64)\nnot (i64 == i)\nnot (i64 == i32)\nnot (i64 == i64)\nnot (i64 == nil)\nnot (i64 > 0.5)\nnot (i64 > 1)\nnot (i64 > f32)\nnot (i64 > f64)\nnot (i64 > i)\nnot (i64 > i32)\nnot (i64 > i64)\nnot (i64 >= 0.5)\nnot (i64 >= 1)\nnot (i64 >= f32)\nnot (i64 >= f64)\nnot (i64 >= i)\nnot (i64 >= i32)\nnot (i64 >= i64)\nnot (i64 not in array)\nnot (list != array)\nnot (list != list)\nnot (list != nil)\nnot (list == array)\nnot (list == list)\nnot (list == nil)\nnot (nil != \"bar\")\nnot (nil != \"foo\")\nnot (nil != 0.5)\nnot (nil != 1)\nnot (nil != add)\nnot (nil != array)\nnot (nil != div)\nnot (nil != f32)\nnot (nil != f64)\nnot (nil != false)\nnot (nil != foo)\nnot (nil != half)\nnot (nil != i)\nnot (nil != i32)\nnot (nil != i64)\nnot (nil != list)\nnot (nil != nil)\nnot (nil != ok)\nnot (nil != score)\nnot (nil != true)\nnot (nil == \"bar\")\nnot (nil == \"foo\")\nnot (nil == 0.5)\nnot (nil == 1)\nnot (nil == add)\nnot (nil == array)\nnot (nil == div)\nnot (nil == f32)\nnot (nil == f64)\nnot (nil == false)\nnot (nil == foo)\nnot (nil == greet)\nnot (nil == half)\nnot (nil == i)\nnot (nil == i32)\nnot (nil == i64)\nnot (nil == list)\nnot (nil == nil)\nnot (nil == ok)\nnot (nil == score)\nnot (nil == true)\nnot (nil in array)\nnot (nil in list)\nnot (nil not in array)\nnot (nil not in list)\nnot (ok != nil)\nnot (ok != ok)\nnot (ok != true)\nnot (ok && false)\nnot (ok && ok)\nnot (ok && true)\nnot (ok == false)\nnot (ok == nil)\nnot (ok == ok)\nnot (ok == true)\nnot (ok and false)\nnot (ok and ok)\nnot (ok and true)\nnot (ok or false)\nnot (ok or ok)\nnot (ok or true)\nnot (ok || ok)\nnot (ok || true)\nnot (score != nil)\nnot (score != score)\nnot (score == nil)\nnot (score == score)\nnot (true != false)\nnot (true != nil)\nnot (true != ok)\nnot (true != true)\nnot (true && false)\nnot (true && true)\nnot (true == false)\nnot (true == nil)\nnot (true == ok)\nnot (true == true)\nnot (true and false)\nnot (true and ok)\nnot (true and true)\nnot (true or false)\nnot (true or ok)\nnot (true or true)\nnot (true || false)\nnot (true || ok)\nnot (true || true)\n```\n\n----------------------------------------\n\nTITLE: SortBy Function Usage in Expr\nDESCRIPTION: Demonstrates the use of the `sortBy` function for sorting arrays based on different criteria. Includes examples with properties, nested structures, conditional expressions, and different data types. The sortBy function takes a list and a comparison function as arguments and returns a new list with the elements sorted based on the result of comparison function applied to each element. This function is crucial for custom sorting logic.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_210\n\nLANGUAGE: Expr\nCODE:\n```\nsortBy($env.array, #)\nsortBy($env.array, f64)\nsortBy($env.list, #.Bar)\nsortBy($env.list, f64)\nsortBy($env?.[str], $env?.i)\nsortBy($env?.[str], f64)\nsortBy($env?.array, #)\nsortBy($env?.list, f64)\nsortBy(0 .. 0, #)\nsortBy(0 .. 1, #)\nsortBy(0 .. i, # ^ i)\nsortBy([$env], #)\nsortBy([$env], #?.add)\nsortBy([$env], .list)\nsortBy([0], $env.ok)\nsortBy([0], $env?.Bar)\nsortBy([0], add)\nsortBy([0], greet)\nsortBy([1.0], $env?.ok)\nsortBy([1.0], f64)\nsortBy([1], 0 >= #)\nsortBy([array], f64)\nsortBy([f64], add)\nsortBy([false], list)\nsortBy([foo], #)\nsortBy([foo], add)\nsortBy([foo], array)\nsortBy([foo], foo)\nsortBy([list], #)\nsortBy([nil], array)\nsortBy([true], f64)\nsortBy([true], i)\nsortBy(array, # * #)\nsortBy(array, # ** #)\nsortBy(array, # + #)\nsortBy(array, # ^ #)\nsortBy(array, #)\nsortBy(array, #) | findIndex(false)\nsortBy(array, #) | groupBy(true)\nsortBy(array, #) | map(0)\nsortBy(array, #) | reduce(#)\nsortBy(array, #) | reduce($env)\nsortBy(array, #)?.[i]\nsortBy(array, $env.i)\nsortBy(array, $env?.[str])\nsortBy(array, $env?.i)\nsortBy(array, 0 * #)\nsortBy(array, 0 - 1)\nsortBy(array, 0) | map(#)\nsortBy(array, 0)?.[i]\nsortBy(array, 1 ** f64)\nsortBy(array, 1 / #)\nsortBy(array, 1 ^ #)\nsortBy(array, 1) | groupBy(#)\nsortBy(array, 1) | reduce($env)\nsortBy(array, 1)?.[i]\nsortBy(array, 1.0 ^ #)\nsortBy(array, 1.0)?.[i]\nsortBy(array, abs(#))\nsortBy(array, bitnot(#))\nsortBy(array, f64 ** #)\nsortBy(array, f64)\nsortBy(array, f64)?.[i]\nsortBy(array, findLast(array, ok))\nsortBy(array, findLastIndex($env, ok))\nsortBy(array, float(1))\nsortBy(array, i ** #)\nsortBy(array, i)\nsortBy(array, i)?.[i]\nsortBy(array, max(#))\nsortBy(array, mean(#))\nsortBy(array, round(#))\nsortBy(array, round(i))\nsortBy(array, str)\nsortBy(array, str) | map(list)\nsortBy(array, str) | none(ok)\nsortBy(array, str)?.[i]\nsortBy(array, toJSON(foo))\nsortBy(array, toJSON(nil))\nsortBy(array[:i], str)\nsortBy(concat(array), #)\nsortBy(concat(array), round(i))\nsortBy(filter($env, false), #.foo)\nsortBy(flatten(list), f64)\nsortBy(let foobar = array; foobar, # * 1.0)\nsortBy(list | map(i), # ^ #)\nsortBy(list, #.Bar)\nsortBy(list, #.Bar)?.[i]\nsortBy(list, #.String())\nsortBy(list, #?.Bar)\nsortBy(list, $env.f64)\n```\n\n----------------------------------------\n\nTITLE: Rounding a Number in Expr\nDESCRIPTION: The `round()` function returns the nearest integer to the input number, rounding half away from zero. The input number must be a numerical value.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_49\n\nLANGUAGE: expr\nCODE:\n```\nround(1.5) == 2.0\n```\n\n----------------------------------------\n\nTITLE: Direct Environment Variable Access and Property Retrieval in Expr\nDESCRIPTION: These expressions demonstrate directly accessing environment variables and retrieving properties using dot notation. They showcase different scenarios, including accessing String properties, methods, and nested attributes.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_270\n\nLANGUAGE: Expr\nCODE:\n```\n{foo: $env?.String}\n{foo: $env?.add}\n{foo: $env?.array}\n{foo: $env?.f64}\n{foo: $env?.foo.String()}\n{foo: $env?.greet}\n{foo: $env?.list}\n{foo: $env?.ok}\n{foo: $env?.str}\n{foo: $env}.Bar\n{foo: $env}.String\n{foo: $env}.add\n{foo: $env}.array\n{foo: $env}.f64\n{foo: $env}.foo\n{foo: $env}.foobar\n{foo: $env}.greet\n{foo: $env}.i\n{foo: $env}.list\n{foo: $env}.ok\n{foo: $env}.str\n{foo: 0, foo: $env}.String\n{foo: 0, foo: $env}.foo\n{foo: 0, foo: $env}.list\n{foo: 0, foo: $env}.str\n{foo: 1, foo: $env}.String\n{foo: 1, foo: $env}.array\n{foo: 1, foo: $env}.greet\n{foo: 1, foo: $env}.str\n{foo: 1.0, foo: $env}.array\n{foo: 1.0, foo: $env}.foobar\n{foo: 1.0, foo: $env}.greet\n```\n\n----------------------------------------\n\nTITLE: List Indexing in Expr\nDESCRIPTION: This snippet shows different methods of accessing list elements using indexing in Expr. These methods include using environment variables, integer literals, arithmetic expressions, and optional chaining. This illustrates the various ways to retrieve specific elements from a list, even when dealing with potentially null values.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_176\n\nLANGUAGE: Expr\nCODE:\n```\nlist; $env.i\nlist?.[$env.i]\nlist?.[0 % 1]\nlist?.[0]\nlist?.[0].Bar\nlist?.[0].String\nlist?.[0]?.Bar\nlist?.[0]?.String\nlist?.[1 + 0]\nlist?.[1]\nlist?.[1].Bar\nlist?.[1].String\nlist?.[1].String()\nlist?.[1]?.Bar\nlist?.[array?.[0]]\nlist?.[i]\nlist?.[i] != foo && $env\nlist?.[i] == foo\nlist?.[i] == nil && $env\nlist?.[i] not in list\nlist?.[i].Bar\nlist?.[i].String\nlist?.[i].String()\nlist?.[i]?.Bar\nlist?.[i]?.String\nlist?.[i]?.String()\nlist?.[max(i)]\nlist[$env.i:]\nlist[$env?.i:]\nlist[0:] | reduce(1.0)\nlist[0:] | reduce(str)\nlist[0:]?.[i]\nlist[1 + 0:]\nlist[:$env?.i]\nlist[:0 * 0]\nlist[:0] | findIndex(nil != foo)\nlist[:]?.[i]\nlist[:bitnot(1)]\nlist[:i]\nlist[add(1, 0):]\nlist[array?.[i]:]\nlist[i:]\nlist[i:i]\nlist[int(1.0):]\nlist[min(array):]\n```\n\n----------------------------------------\n\nTITLE: Array Reduction\nDESCRIPTION: Reduces the array to a single value using a given accumulator and an initial value. The function returns the accumulated value after processing all elements of the array.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_41\n\nLANGUAGE: Expr\nCODE:\n```\narray | reduce(#, 0)\n```\n\n----------------------------------------\n\nTITLE: toJSON Function in Expr\nDESCRIPTION: Examples using the toJSON function to convert different data types and expressions to JSON representation. This function is used to serialize various Expr values for output or debugging purposes.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_242\n\nLANGUAGE: Expr\nCODE:\n```\ntoJSON(map($env, list))\ntoJSON(map(array, #))\ntoJSON(map(array, 0))\ntoJSON(map(list, #))\ntoJSON(map(list, .Bar))\ntoJSON(map(list, f64))\ntoJSON(max(0))\ntoJSON(max(1))\ntoJSON(max(1.0))\ntoJSON(max(1.0, 0))\ntoJSON(max(1.0, 1))\ntoJSON(max(f64))\ntoJSON(max(i))\ntoJSON(mean(0))\ntoJSON(mean(1))\ntoJSON(mean(1.0))\ntoJSON(mean(f64))\ntoJSON(mean(i))\ntoJSON(median(0))\ntoJSON(median(1))\ntoJSON(median(1, 0))\ntoJSON(median(1.0))\ntoJSON(median(array))\ntoJSON(median(array, array))\ntoJSON(median(f64))\ntoJSON(median(i))\ntoJSON(min(0))\ntoJSON(min(1))\ntoJSON(min(1.0))\ntoJSON(min(array))\ntoJSON(min(f64))\ntoJSON(nil != $env)\ntoJSON(nil != 0)\ntoJSON(nil != 1)\ntoJSON(nil != 1.0)\ntoJSON(nil != add)\ntoJSON(nil != array)\ntoJSON(nil != false)\ntoJSON(nil != greet)\ntoJSON(nil != i)\ntoJSON(nil != nil)\ntoJSON(nil != true)\ntoJSON(nil == $env)\ntoJSON(nil == 0)\ntoJSON(nil == 1.0)\ntoJSON(nil == array)\ntoJSON(nil == foo)\ntoJSON(nil == greet)\ntoJSON(nil == i)\ntoJSON(nil == list)\ntoJSON(nil == nil)\ntoJSON(nil == ok)\ntoJSON(nil in array)\ntoJSON(nil in list)\ntoJSON(nil not in $env)\ntoJSON(nil not in list)\ntoJSON(nil) < str\ntoJSON(nil) <= str\ntoJSON(nil) not matches foo?.Bar\ntoJSON(nil) not startsWith str\ntoJSON(nil) | greet()\ntoJSON(none($env, true))\ntoJSON(none(list, false))\ntoJSON(ok != nil)\ntoJSON(ok != ok)\ntoJSON(ok && ok)\ntoJSON(ok && true)\ntoJSON(ok == false)\ntoJSON(ok ? foo : ok)\ntoJSON(ok ?: foo)\ntoJSON(ok or false)\ntoJSON(ok)\ntoJSON(ok) not startsWith str\ntoJSON(one($env, true))\ntoJSON(one(list, ok))\ntoJSON(reduce($env, 1.0, 0))\ntoJSON(reduce(array, #index))\ntoJSON(reduce(array, 0))\ntoJSON(reduce(array, f64))\ntoJSON(reduce(list, #))\ntoJSON(reduce(list, #.Bar))\ntoJSON(reduce(list, 1.0))\ntoJSON(reduce(list, foo))\ntoJSON(reduce(list, ok))\ntoJSON(reverse(array))\ntoJSON(reverse(list))\ntoJSON(round(0))\ntoJSON(round(1))\ntoJSON(round(1.0))\ntoJSON(round(f64))\ntoJSON(round(i))\ntoJSON(sort($env))\ntoJSON(sort(array))\ntoJSON(sortBy(array, #))\ntoJSON(sortBy(array, f64))\ntoJSON(sortBy(list, 0))\ntoJSON(sortBy(list, i))\ntoJSON(str != nil)\ntoJSON(str <= str)\ntoJSON(str == nil)\ntoJSON(str > str)\ntoJSON(str contains str)\ntoJSON(str in $env)\ntoJSON(str in foo)\ntoJSON(str not endsWith str)\ntoJSON(str not in $env)\ntoJSON(str not in [add, array, foo])\ntoJSON(str not in foo)\ntoJSON(str)\ntoJSON(str) | greet()\ntoJSON(str[0:])\ntoJSON(str[:0])\ntoJSON(string($env | one(true)))\ntoJSON(string($env))\ntoJSON(string($env?.[str]))\ntoJSON(string(0))\ntoJSON(string(1))\ntoJSON(string(1.0))\ntoJSON(string(add))\ntoJSON(string(array))\ntoJSON(string(f64))\ntoJSON(string(false))\ntoJSON(string(foo))\ntoJSON(string(list))\ntoJSON(string(nil))\ntoJSON(string(str))\ntoJSON(string(true))\ntoJSON(string(values($env)))\ntoJSON(sum($env, 1.0))\ntoJSON(sum(array))\ntoJSON(sum(array, #))\ntoJSON(toBase64(str))\ntoJSON(toJSON(1))\ntoJSON(toJSON(1.0))\ntoJSON(toJSON(array))\ntoJSON(toJSON(f64))\ntoJSON(toJSON(false))\ntoJSON(toJSON(foo))\ntoJSON(toJSON(i))\ntoJSON(toJSON(list))\ntoJSON(toJSON(nil))\ntoJSON(toJSON(ok))\ntoJSON(toJSON(str))\ntoJSON(toJSON(true))\ntoJSON(trim(str))\ntoJSON(trimPrefix($env?.[str]))\ntoJSON(trimSuffix($env?.str))\ntoJSON(trimSuffix(str))\ntoJSON(true != $env)\ntoJSON(true != nil)\ntoJSON(true && false)\ntoJSON(true && ok)\ntoJSON(true ? foo : 1.0)\ntoJSON(true ? foo : f64)\ntoJSON(true ? nil : false)\ntoJSON(true ?: nil)\ntoJSON(true and true)\ntoJSON(true or $env)\ntoJSON(true or ok)\ntoJSON(true || ok)\ntoJSON(true || true)\ntoJSON(true) + str | trimPrefix(str)\ntoJSON(true) < str\ntoJSON(true) > str\ntoJSON(true) not endsWith greet(str)\ntoJSON(true) not startsWith str\ntoJSON(true) | greet()\ntoJSON(true) | repeat(i)\ntoJSON(true); f64\ntoJSON(type($env))\ntoJSON(type(0))\ntoJSON(type(1.0))\ntoJSON(type(add))\ntoJSON(type(array))\ntoJSON(type(f64))\ntoJSON(type(false))\ntoJSON(type(foo))\ntoJSON(type(greet))\ntoJSON(type(i))\ntoJSON(type(list))\ntoJSON(type(nil))\ntoJSON(type(ok))\ntoJSON(type(str))\ntoJSON(uniq(array))\ntoJSON(uniq(list))\ntoJSON(upper(str))\ntoJSON({foo: 0, foo: f64}.i)\ntoJSON({foo: 1, foo: true})\ntoJSON({foo: 1.0})\ntoJSON({foo: 1.0}.f64)\ntoJSON({foo: 1})\ntoJSON({foo: false})\ntoJSON({foo: foo, foo: str})\ntoJSON({foo: foo, foo: true})\ntoJSON({foo: foo})\ntoJSON({foo: i, foo: foo})\ntoJSON({foo: i})\ntoJSON({foo: list})\ntoJSON({foo: nil, foo: 1.0})\ntoJSON({foo: nil, foo: i})\ntoJSON({foo: nil})\ntoJSON({foo: ok})\ntoJSON({foo: str})\ntoJSON({foo: true})\n```\n\n----------------------------------------\n\nTITLE: Integer Conversion Function Tests\nDESCRIPTION: This snippet tests the `int()` function, focusing on converting various types (float, integer, other integer types) to integers. It includes negative and positive values, arithmetic expressions, and function calls, and tests the handling of edge cases. The expressions aim to validate the integer conversion logic within the Expr interpreter.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_68\n\nLANGUAGE: expr\nCODE:\n```\nint(-0.5)\nint(-1)\nint(-f32)\nint(-f64)\nint(-i)\nint(-i32)\nint(-i64)\nint(0.5 * 0.5)\nint(0.5 * f32)\nint(0.5 * f64)\nint(0.5 * i32)\nint(0.5 ** 0.5)\nint(0.5 ** 1)\nint(0.5 ** f32)\nint(0.5 ** f64)\nint(0.5 ** i32)\nint(0.5 + 0.5)\nint(0.5 + 1)\nint(0.5 + f64)\nint(0.5 + i32)\nint(0.5 + i64)\nint(0.5 - f32)\nint(0.5 - i)\nint(0.5 - i32)\nint(0.5 - i64)\nint(0.5 / i)\nint(0.5 / i64)\nint(0.5 ^ i)\nint(0.5 ^ i64)\nint(0.5) * -i\nint(0.5) ** f64\nint(0.5) ** i32\nint(0.5) + i\nint(0.5) / i32\nint(0.5) < 0.5 * f64\nint(0.5) <= i\nint(0.5) <= i32\nint(0.5) == f32\nint(0.5) > -i64\nint(0.5) > i\nint(0.5) >= f32\nint(0.5) >= i32\nint(0.5) >= max(0.5)\nint(0.5) ^ i32\nint(1 % i)\nint(1 * f32)\nint(1 * i)\nint(1 * i32)\nint(1 ** i)\nint(1 + 1)\nint(1 + f32)\nint(1 + f64)\nint(1 + i32)\nint(1 - 0.5)\nint(1 - f32)\nint(1 - f64)\nint(1 - i32)\nint(1 - i64)\nint(1 / 0.5)\nint(1 / 1)\nint(1 ^ 0.5)\nint(1 ^ i64)\nint(1) != i64\nint(1) ** f32\nint(1) ** i32\nint(1) + f32\nint(1) + i64\nint(1) + reduce(array, #)\nint(1) - i\nint(1) < f64\nint(1) < i64 * 0.5\nint(1) == i32\nint(1) ^ f64\nint(abs(0.5))\nint(abs(1))\nint(abs(f64))\nint(abs(i))\nint(abs(i32))\nint(abs(i64))\nint(add(1, 1))\nint(array[i64])\nint(bitnot(1))\nint(bitnot(i32))\nint(bitnot(i64))\nint(bitshl(1, i))\nint(bitxor(1, i32) + i)\nint(bitxor(i32, i))\nint(ceil(0.5))\nint(ceil(1))\nint(ceil(f32))\nint(ceil(half(1)))\nint(ceil(i))\nint(ceil(i32))\nint(count(array, ok))\nint(count(list, false))\nint(f32 * 1)\nint(f32 * i)\nint(f32 ** 0.5)\nint(f32 ** i64)\nint(f32 + f32)\nint(f32 - 0.5)\nint(f32 - i64)\nint(f32 / 0.5)\nint(f32 / 1)\nint(f32 / f64)\nint(f32 / i32)\nint(f32 / i64)\nint(f32 ^ f32)\nint(f32 ^ i32)\nint(f32)\nint(f32) != i\nint(f32) != i64\nint(f32) ** f64\nint(f32) + i32\nint(f32) - f32\nint(f32) < i\nint(f32) <= i32\nint(f32) == i ? list : add\nint(f64 * 0.5)\nint(f64 ** 1)\nint(f64 ** i)\nint(f64 ** i32)\nint(f64 + 0.5)\nint(f64 + 1)\nint(f64 + i)\nint(f64 - 0.5)\nint(f64 - f32)\nint(f64 / 0.5)\nint(f64 / i64)\nint(f64 ^ 0.5)\nint(f64 ^ 1)\nint(f64 ^ f64)\nint(f64 ^ i64)\nint(f64)\nint(f64) % i64\nint(f64) * f64\nint(f64) + f64\nint(f64) < i32\nint(f64) == f32\nint(f64) == f64\nint(f64) > i\nint(f64) > i64\nint(false ? 0.5 : 0.5)\nint(false ? i : 0.5)\nint(findIndex(list, ok))\nint(findLastIndex(list, ok))\nint(first(array))\nint(float(0.5))\nint(float(1))\nint(float(f32))\nint(float(f64))\nint(float(i32 ** i))\nint(float(i32))\nint(floor(f64))\nint(floor(i))\nint(floor(i32))\nint(get(array, i64))\nint(half(0.5))\nint(half(1))\nint(half(f64))\nint(i % 1)\nint(i % i32)\nint(i % i64)\nint(i * 0.5)\nint(i * 1)\nint(i * f64)\nint(i ** f32)\nint(i ** f64)\nint(i ** i64)\nint(i + f32)\nint(i + f64)\nint(i + i)\nint(i - 0.5)\nint(i - f32)\nint(i - i32)\nint(i - i64)\nint(i / 0.5)\nint(i / 1)\nint(i / i)\nint(i / i32)\nint(i ^ 0.5)\nint(i ^ 1)\nint(i ^ i32)\nint(i)\nint(i) != i32\nint(i) * f64\nint(i) * i64\nint(i) - i\nint(i) .. i64\nint(i32 * 0.5)\nint(i32 * 1)\nint(i32 * i64)\nint(i32 ** 0.5)\nint(i32 ** 1)\nint(i32 + 0.5)\nint(i32 + 1)\nint(i32 + f64)\nint(i32 + i64)\nint(i32 - 1)\nint(i32 - i)\nint(i32 / 0.5)\nint(i32 / 1)\nint(i32 / f64)\nint(i32 ^ 0.5)\nint(i32 ^ f64)\nint(i32 ^ i32)\nint(i32)\nint(i32) != f32\nint(i32) - i\nint(i32) / f32\nint(i32) / i\nint(i32) / i64\nint(i32) < i64\nint(i32) > half(0.5)\nint(i64 * 1)\nint(i64 ** 0.5)\nint(i64 ** f64)\nint(i64 ** i64)\nint(i64 + i)\nint(i64 + i32)\nint(i64 - 0.5)\nint(i64 - f32)\nint(i64 - i)\nint(i64 - i64)\nint(i64 / 1)\nint(i64 ^ f64)\nint(i64 ^ i32)\nint(i64 ^ i64)\nint(i64)\nint(i64) != i64\nint(i64) - i64\nint(i64) .. i32\nint(i64) / i\nint(i64) <= i\nint(i64) == f32\nint(i64) > i64\nint(i64) ^ i\nint(int(0.5))\nint(int(1))\nint(int(f64))\nint(len(\"bar\"))\nint(len(array))\nint(max(0.5))\nint(max(0.5, i64))\nint(max(1))\nint(max(f32))\nint(max(f64))\nint(max(i))\nint(max(i64))\nint(mean(array))\nint(min(0.5))\nint(min(1))\nint(min(1, i64))\nint(min(f32))\nint(min(i))\nint(min(i32))\nint(min(i64))\nint(ok ? i : div)\nint(ok ? i : i64)\nint(ok ? i64 : list)\nint(reduce(array, #))\nint(reduce(array, f32))\nint(reduce(array, i32))\nint(reduce(list, 0.5))\nint(reduce(list, 1))\nint(reduce(list, i64))\nint(round(0.5))\nint(round(1))\nint(round(f32))\nint(round(f64))\nint(round(i))\nint(score(1))\nint(score(1, i))\nint(score(i))\nint(string(1))\nint(string(i))\nint(string(i32))\nint(string(i64))\nint(sum(array))\nint(toJSON(i))\nint(toJSON(i32))\nint(toJSON(i64))\nint(true ? 1 : foo)\nint(true ? f64 : greet)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Decimal Patcher\nDESCRIPTION: Defines a `DecimalPatcher` that implements the `Visit` method to transform binary operations on `Decimal` types into function calls. It checks if both operands of a binary node with the \"+\" operator are assignable to the `Decimal` type. If so, it replaces the binary node with a `CallNode` to the `add` function.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/patch.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\ntype DecimalPatcher struct{}\n\nvar decimalType = reflect.TypeOf(Decimal{})\n\nfunc (DecimalPatcher) Visit(node *ast.Node) {\n    if n, ok := (*node).(*ast.BinaryNode); ok && n.Operator == \"+\" {\n        \n        if !n.Left.Type().AssignableTo(decimalType) {\n            return // skip, left side is not a Decimal\n        }\n\t\t\n        if !n.Right.Type().AssignableTo(decimalType) {\n            return // skip, right side is not a Decimal\n        }\n\t\t\n        // highlight-start\n        callNode := &ast.CallNode{\n            Callee:    &ast.IdentifierNode{Value: \"add\"},\n            Arguments: []ast.Node{n.Left, n.Right},\n        }\n        ast.Patch(node, callNode)\n        // highlight-end\n\t\t\n        (*node).SetType(decimalType) // set the type, so the patcher can be applied recursively\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping with environment variables and optional properties in Expr\nDESCRIPTION: Shows how to map an array and extract information from the environment variable using properties and optional chaining. This is useful for accessing specific attributes in the environment data.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_186\n\nLANGUAGE: Expr\nCODE:\n```\nmap(array, $env?.[foobar])\n```\n\n----------------------------------------\n\nTITLE: Calculating the Ceiling of a Number in Expr\nDESCRIPTION: The `ceil()` function returns the smallest integer value greater than or equal to the input number. The input number must be a numerical value.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_47\n\nLANGUAGE: expr\nCODE:\n```\nceil(1.5) == 2.0\n```\n\n----------------------------------------\n\nTITLE: Using nil comparison in Expr\nDESCRIPTION: This snippet showcases different ways to compare values with `nil` in the Expr language, using equality, inequality, logical AND, logical OR, and conditional expressions. It includes property access, function calls, and built-in functions like `toBase64` to illustrate various scenarios.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_85\n\nLANGUAGE: expr\nCODE:\n```\nnil != array != nil ? add : half\nnil != array && ok\nnil != div == reduce(array, ok)\nnil != f64 || ok || false\nnil != false && ok\nnil != false or i == nil\nnil != foo and ok\nnil != foo.Bar\nnil != foo.Qux\nnil != foo.String\nnil != foo.String()\nnil != foo?.Bar\nnil != foo?.Qux\nnil != foo?.String\nnil != foo?.String()\nnil != nil ? score : div\nnil != true || i < 1\nnil == \"foo\" != ok\nnil == \"foo\" && 0.5 < f64\nnil == 0.5 and reduce(list, true)\nnil == add && 0.5 >= 0.5\nnil == add || f32 >= i64\nnil == array and ok\nnil == array or ok\nnil == array[i64]\nnil == div ? f64 : ok\nnil == false && nil != true\nnil == false ? i64 : toBase64(\"bar\")\nnil == foo.Bar\nnil == foo.Qux\nnil == foo.String\nnil == foo.String()\nnil == foo?.Bar\nnil == foo?.Qux\nnil == foo?.String\nnil == greet ? i : greet(\"bar\")\nnil == list || f32 == i\nnil == list[i32]\nnil == nil and ok\nnil in array || score == nil\nnil in list != not false\n```\n\n----------------------------------------\n\nTITLE: Method Calls\nDESCRIPTION: Illustrates calling methods on objects. The methods may be built-in or defined elsewhere in the environment. Optional chaining is also tested to handle cases where the object or method might be null.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_137\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": 1}.add\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": 1}?.add\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": add}.array\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": greet}.String\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": i64}.greet\n```\n\n----------------------------------------\n\nTITLE: Expr Reduce Function with Method Call and Safe Navigation\nDESCRIPTION: Illustrates using `reduce` on a `list` and safely navigating through its properties. It sums the values of the list and calls `String()` on the result. The final property access uses the safe navigation operator.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_148\n\nLANGUAGE: expr\nCODE:\n```\n{\"foo\": reduce(list, #).String()}\n```\n\n----------------------------------------\n\nTITLE: fromPairs and get Functions - Expr\nDESCRIPTION: Demonstrates usage of `fromPairs` for converting a list of key-value pairs to a map, and `get` for retrieving values from maps.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_116\n\nLANGUAGE: Expr\nCODE:\n```\nfromPairs([list])\nfromPairs(list[:0])\nfromPairs(sort($env))\nfromPairs(toPairs($env))\nfromPairs(toPairs($env)).ok\nget($env, nil) != array\nget($env, nil)?.[add]\nget($env, nil)?.[add].add\nget($env, nil)?.[f64]\nget($env, nil)?.[i]\nget($env, nil)?.[ok]\nget($env, nil)?.add\nget($env, nil)?.f64\nget($env, nil)?.foo\nget($env, nil)?.greet().add\nget($env, str) | reduce($env)\nget($env, str)?.[f64]\nget(array, $env.i)\nget(array, i)\nget(if ok { i } else { array }, list)\nget(list, i)\nget(list, i).String\nget(median(array), true && $env)\n```\n\n----------------------------------------\n\nTITLE: Uniqueness Check using uniq function\nDESCRIPTION: These examples demonstrate the usage of `uniq` function in the Expr language. The function is used to extract the unique elements from an array, list, or the results of other functions like `filter`, `map`, `sortBy`, `groupBy`, and `reduce`.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_265\n\nLANGUAGE: Expr\nCODE:\n```\nuniq($env | filter(false))\nuniq($env | map(#index))\nuniq($env | map(0))\nuniq($env | map(1.0))\nuniq($env | map(f64))\nuniq($env | map(ok))\nuniq($env | map(str))\nuniq($env.array)\nuniq($env.list)\nuniq($env?.array)\nuniq($env?.list)\nuniq($env?.list[i:])\nuniq(0 .. 0)\nuniq(0 .. i)\nuniq(1 .. 0)\nuniq([$env])\nuniq([0])\nuniq([1.0, ok])\nuniq([1.0])\nuniq([1])\nuniq([add, 1.0])\nuniq([add])\nuniq([array, true])\nuniq([array])\nuniq([f64])\nuniq([false, str])\nuniq([false, true])\nuniq([false])\nuniq([foo, foo])\nuniq([foo])\nuniq([i])\nuniq([list])\nuniq([nil])\nuniq([ok])\nuniq([str, 1.0])\nuniq([str, true])\nuniq([str])\nuniq([true])\nuniq(array | filter(ok))\nuniq(array | map(#))\nuniq(array | sortBy(1))\nuniq(array)\nuniq(array) == array\nuniq(array) | count(false)\nuniq(array) | groupBy(1)\nuniq(array) | groupBy(1.0))\nuniq(array) | groupBy(ok))\nuniq(array) | map(1)\nuniq(array) | map(true))\nuniq(array) | min(i))\nuniq(array) | reduce(1.0))\nuniq(array) | reduce(false))\nuniq(array) | reduce(greet))\nuniq(array) | reduce(i))\nuniq(array) | sortBy(#))\nuniq(array) | sortBy(1))\nuniq(array); str\nuniq(array)?.[i]\nuniq(array)[:i]\nuniq(array)[i:]\nuniq(array[1:i])\nuniq(array[:1])\nuniq(concat(list))\nuniq(false ? 0 : array)\nuniq(filter(array, true))\nuniq(filter(list, false))\nuniq(flatten(array))\nuniq(keys($env))\nuniq(list | map(1.0))\nuniq(list | map(add))\nuniq(list | sortBy(#.Bar))\nuniq(list | sortBy(1.0))\nuniq(list)\nuniq(list) != array\nuniq(list) | all(false))\nuniq(list) | all(true))\nuniq(list) | findIndex(false))\nuniq(list) | groupBy(ok))\nuniq(list) | map(#))\nuniq(list) | map(.String))\nuniq(list) | map(greet))\nuniq(list) | reduce(ok))\nuniq(list) | reduce(true, 1.0))\nuniq(list) | sortBy(0))\nuniq(list)?.[i]\nuniq(list)[$env.i:]\nuniq(list[i:])\nuniq(map($env, array))\nuniq(map($env, list))\nuniq(map($env, ok))\nuniq(map($env, str))\nuniq(map($env, true))\nuniq(map(array, #))\nuniq(map(array, 1.0))\nuniq(map(array, greet))\nuniq(map(array, ok))\nuniq(map(list, #))\nuniq(reverse(array))\nuniq(reverse(list))\nuniq(sort($env))\nuniq(sort(array))\nuniq(sortBy(array, #))\nuniq(sortBy(array, 0))\nuniq(sortBy(list, 1.0))\nuniq(toPairs($env))\nuniq(uniq(array))\nuniq(values($env))\n```\n\n----------------------------------------\n\nTITLE: Safe Navigation and Property Access\nDESCRIPTION: These examples focus on safe navigation using the `?.` operator to avoid null pointer exceptions when accessing nested properties or calling methods. They demonstrate various combinations of property access and method calls.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_4\n\nLANGUAGE: Expr\nCODE:\n```\n$env?.[foobar]?.$env == nil\n$env?.[foobar]?.Bar\n$env?.[foobar]?.Bar()\n$env?.[foobar]?.Bar()?.foobar\n$env?.[foobar]?.Bar(foobar)\n$env?.[foobar]?.Bar(list)\n$env?.[foobar]?.Bar.foo()\n$env?.[foobar]?.Bar.str(foobar)\n$env?.[foobar]?.Bar?.[str]\n$env?.[foobar]?.Bar?.f64\n$env?.[foobar]?.Bar?.foo\n$env?.[foobar]?.String\n$env?.[foobar]?.String()\n$env?.[foobar]?.String(Bar)\n$env?.[foobar]?.String(add).String\n$env?.[foobar]?.String.ok\n$env?.[foobar]?.String?.[i]\n$env?.[foobar]?.String?.[str]?.[f64]?.ok\n$env?.[foobar]?.String?.array\n$env?.[foobar]?.String?.i\n$env?.[foobar]?.[add]\n$env?.[foobar]?.[add].f64\n$env?.[foobar]?.[add].greet\n$env?.[foobar]?.[add]?.[foo]\n$env?.[foobar]?.[add]?.[greet]\n$env?.[foobar]?.[array]\n$env?.[foobar]?.[array]?.Bar\n$env?.[foobar]?.[array]?.f64\n$env?.[foobar]?.[array]?.list()?.[add]\n$env?.[foobar]?.[f64]\n$env?.[foobar]?.[f64].f64\n$env?.[foobar]?.[f64].f64()\n$env?.[foobar]?.[f64].greet\n$env?.[foobar]?.[f64].ok()\n$env?.[foobar]?.[foo]\n$env?.[foobar]?.[foo].Bar\n$env?.[foobar]?.[foo].String()\n$env?.[foobar]?.[foo]?.[str]\n$env?.[foobar]?.[foo]?.i\n$env?.[foobar]?.[greet]\n$env?.[foobar]?.[greet].array.array\n$env?.[foobar]?.[greet].f64\n$env?.[foobar]?.[greet]?.[i].array\n$env?.[foobar]?.[greet]?.[ok]\n$env?.[foobar]?.[greet]?.str\n$env?.[foobar]?.[i]\n$env?.[foobar]?.[i].Bar\n$env?.[foobar]?.[i].greet\n$env?.[foobar]?.[i].str\n$env?.[foobar]?.[i]?.[list]\n$env?.[foobar]?.[i]?.[ok]\n$env?.[foobar]?.[i]?.ok\n$env?.[foobar]?.[list]\n$env?.[foobar]?.[list].foo\n$env?.[foobar]?.[list]?.[f64]\n$env?.[foobar]?.[list]?.[str]\n$env?.[foobar]?.[list]?.f64()\n$env?.[foobar]?.[list]?.ok\n$env?.[foobar]?.[ok]\n$env?.[foobar]?.[ok].Bar\n$env?.[foobar]?.[ok]?.[add]\n$env?.[foobar]?.[ok]?.[f64]\n$env?.[foobar]?.[ok]?.ok\n$env?.[foobar]?.[sortBy($env, f64)]\n$env?.[foobar]?.[str]\n$env?.[foobar]?.[str].i\n$env?.[foobar]?.[str]?.[f64]\n```\n\n----------------------------------------\n\nTITLE: Get Type of Value Using type() in Expr\nDESCRIPTION: The `type()` function determines the type of a given value and returns a string representing the type, such as \"nil\", \"bool\", \"int\", \"uint\", \"float\", \"string\", \"array\", or \"map\". For named types and structs, the type name is returned.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_78\n\nLANGUAGE: expr\nCODE:\n```\ntype(42) == \"int\"\ntype(\"hello\") == \"string\"\ntype(now()) == \"time.Time\"\n```\n\n----------------------------------------\n\nTITLE: Ternary Operator with 'ok'\nDESCRIPTION: This code snippet demonstrates the ternary operator in conjunction with the 'ok' variable.  It includes various scenarios such as conditional access, function calls, and fallback expressions. Includes optional chaining and different data types.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_202\n\nLANGUAGE: Expr\nCODE:\n```\nok ? $env : $env >= 1.0 | date(ok, true)\nok ? $env : $env | find(.f64)\nok ? $env : $env?.Bar\nok ? $env : $env?.String()\nok ? $env : $env?.[String]\nok ? $env : $env?.[str]\nok ? $env : $env?.array\nok ? $env : $env?.ok\nok ? $env : foo.Bar\nok ? $env : foo?.Bar\nok ? 0 : $env.list\nok ? 0 : foo?.Bar\nok ? 1 : $env.add\nok ? 1 : $env?.[f64]\nok ? 1 : $env[timezone(array):]\nok ? 1.0 : $env | groupBy(#.str)\nok ? 1.0 : $env.array\nok ? 1.0 : $env.list\nok ? 1.0 : $env?.Bar\nok ? 1.0 : $env?.[array]\nok ? 1.0 : $env?.greet\nok ? 1.0 : $env?.list\nok ? 1.0 : list | groupBy($env)\nok ? add : $env | groupBy(#.list)\nok ? add : $env | map(foo)\nok ? add : $env | none(#)\nok ? add : $env.array\nok ? add : $env.f64\nok ? add : $env.greet\nok ? add : $env?.[greet]\nok ? add : $env?.ok\nok ? add : add\nok ? add : f64\nok ? add : list | reduce(#)\nok ? add : str\nok ? array : $env | sum(#)\nok ? array : add\nok ? array : foo\nok ? array : list | min(i)\nok ? array : ok\nok ? array : sum(array)\nok ? f64 : $env.foo\nok ? f64 : $env.i\nok ? f64 : $env.ok\nok ? f64 : $env[bitxor(foobar):]\nok ? f64 : f64\nok ? f64 : foo\nok ? f64 : foo?.String()\nok ? f64 : uniq($env)\nok ? false : $env.foo\nok ? false : $env?.[add]\nok ? false : $env?.list\nok ? false : foo.Bar\nok ? false : list?.[i]\nok ? foo : $env not endsWith $env?.true\nok ? foo : $env | groupBy(.list)\nok ? foo : $env | groupBy(i)\nok ? foo : $env.add\nok ? foo : $env.greet\nok ? foo : $env?.[f64]\nok ? foo : $env?.[find(foobar, .f64)]\nok ? foo : $env?.add\nok ? foo : $env?.array\nok ? foo : $env?.foobar?.String()\nok ? foo : $env?.greet\nok ? foo : add\nok ? foo : array?.[i]\nok ? foo : foo\nok ? foo : foo?.Bar\nok ? foo : foo?.String\nok ? foo : list\nok ? foo not in list : array\nok ? greet : array\nok ? greet : f64\nok ? greet : foo\nok ? greet : groupBy($env, greet)?.[i]\nok ? greet : i\nok ? greet : list | mean(nil)\nok ? greet : sortBy($env, 1)\nok ? greet : str\nok ? greet : {foo: true}\nok ? i : $env?.[greet]\nok ? i : foo\nok ? i : list\nok ? i : list?.[i]\nok ? list : $env.i\nok ? list : f64\nok ? list : foo\nok ? list : str\nok ? nil : $env not matches $env?.[i]\nok ? nil : $env.foo\nok ? nil : $env?.String\nok ? nil : $env?.[String]\nok ? nil : $env?.[greet]\nok ? nil : $env?.[ok]\nok ? nil : $env?.i\nok ? nil : $env?.ok\nok ? nil : $env?.str\nok ? nil : foo.String\nok ? ok : $env | filter(one(array, ok))\nok ? ok : $env.list\nok ? ok : $env?.[array]\nok ? ok : false and ok\nok ? ok : foo\nok ? ok : foo | date(list)\nok ? reduce($env, $env, true) : foo?.Bar\nok ? str : $env?.String(i)?.ok\nok ? str : $env?.foo\nok ? str : $env?.ok\nok ? str : f64\nok ? str : foo\nok ? str : ok\nok ? true : foo?.String\nok ? true ?: 0 : str\nok ?: $env not endsWith str\nok ?: $env | any(.Bar)\nok ?: $env | filter(.Bar)\nok ?: $env | find(#.str)\nok ?: $env | one(#.Bar)\nok ?: $env | reduce(#)\nok ?: $env | sortBy(.i != #)\nok ?: $env | sortBy(foo)\nok ?: $env.add\nok ?: $env.array\nok ?: $env.f64\nok ?: $env.foo\nok ?: $env.ok\nok ?: $env.str\nok ?: $env?.[Bar]\nok ?: $env?.[Bar]?.str\nok ?: $env?.[String]\nok ?: $env?.[add]\nok ?: $env?.[array]\nok ?: $env?.[greet]\nok ?: $env?.[i]\nok ?: $env?.[ok]\nok ?: $env?.[str]\nok ?: $env?.array\nok ?: $env?.f64\nok ?: $env?.foo\nok ?: $env?.greet\nok ?: $env?.i\nok ?: $env?.list\nok ?: $env[foobar not in list:]\nok ?: $env[foobar:]\nok ?: 1 % 1\nok ?: 1.0 | date($env)\nok ?: add\nok ?: array\nok ?: array | sum(greet)\nok ?: array?.[i]\nok ?: ceil(f64)\nok ?: count($env)\nok ?: count(array)\nok ?: count(list)\nok ?: date(false)\nok ?: f64\nok ?: foo\nok ?: foo not in $env\nok ?: foo?.Bar\nok ?: foo?.String\nok ?: foo?.String()\nok ?: fromJSON(str)\nok ?: greet\nok ?: greet($env)\nok ?: i\nok ?: i == 1\nok ?: i >= i\nok ?: int(1.0)\nok ?: list\nok ?: list | findIndex($env)\nok ?: max(list)\nok ?: nil in $env\nok ?: ok\nok ?: str\nok ?: str startsWith $env\nok ?: sum($env)\n```\n\n----------------------------------------\n\nTITLE: Comparison Expressions in Expr\nDESCRIPTION: Demonstrates various comparison operators (==, >, >=, in, not in) in the Expr language.  The examples cover comparisons between different data types, including integers, floats, strings, booleans, and variables, as well as checking for membership in arrays and objects. The variable 'i' and environment variable '$env' are used extensively in these examples.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_157\n\nLANGUAGE: Expr\nCODE:\n```\ni == 1.0 + 1.0\ni == 1.0 - 1\ni == 1.0 == true\ni == 1.0 ^ 1.0\ni == 1.0 || max($env)\ni == abs(i)\ni == array?.[i]\ni == ceil(1.0)\ni == f64\ni == f64 != $env\ni == f64 && $env\ni == f64 * 0\ni == f64 * f64\ni == f64 / f64\ni == f64 ? f64 : foo\ni == f64 ?: array\ni == float(1.0)\ni == i\ni == i == $env\ni == i ^ 0\ni == int(i)\ni == max(array)\ni == max(i)\ni == median(f64)\ni == min($env)\ni == min(f64)\ni == nil == $env\ni == nil ? $env?.[i] : list\ni == nil ?: foo\ni == sum(array)\ni > $env.f64\ni > $env.i\ni > $env?.f64\ni > $env?.i\ni > 0 + 1\ni > 0 + i\ni > 0 / f64\ni > 0 <= 1.0\ni > 0 == nil\ni > 0 ?: ok\ni > 0.0\ni > 1 && ok\ni > 1 - 0\ni > 1 - 1.0\ni > 1 < 1.0\ni > 1 or ok\ni > 1.0 ** f64\ni > 1.0 / 1\ni > 1.0 == $env\ni > 1.0 > $env\ni > 1.0 > 1.0\ni > 1.0 >= 1.0\ni > 1.0 or $env\ni > array?.[i]\ni > ceil(1.0)\ni > f64\ni > f64 != nil\ni > f64 != ok\ni > f64 && $env\ni > f64 ** i\ni > f64 + 1\ni > f64 >= 1\ni > f64 >= 1.0\ni > find(array, ok)\ni > floor(1.0)\ni > i\ni > i ** f64\ni > i + 0\ni > i and $env\ni > last(array)\ni > len($env)\ni > max(1.0)\ni > mean(1.0)\ni > median(f64)\ni > sum(array)\ni >= $env or true\ni >= $env.f64\ni >= $env.i\ni >= $env?.f64\ni >= $env?.i\ni >= 0 / max(1.0)\ni >= 0 <= i\ni >= 0 >= 1\ni >= 0 ^ 1\ni >= 0 or $env\ni >= 0 || $env\ni >= 0.0\ni >= 1 && ok\ni >= 1 ** f64\ni >= 1 - 1.0\ni >= 1 < f64\ni >= 1 > 1.0\ni >= 1 and $env\ni >= 1 and $env?.[str]\ni >= 1.0 && true\ni >= 1.0 * 0\ni >= 1.0 ** i\ni >= 1.0 + 1.0\ni >= 1.0 ^ i\ni >= 1.0 and $env\ni >= 1.0 or $env\ni >= array?.[i]\ni >= ceil(0)\ni >= f64\ni >= f64 * 0\ni >= f64 ** f64\ni >= f64 ** i\ni >= f64 + 1\ni >= f64 < i\ni >= f64 > 1.0\ni >= f64 || $env\ni >= float(1)\ni >= floor(i)\ni >= i\ni >= i ** 0\ni >= i - i\ni >= i / 1.0\ni >= int(1.0)\ni >= min(1.0)\ni >= reduce($env, 0, 0)\ni >= round(i)\ni in $env and false\ni in $env.array\ni in $env?.Bar\ni in $env?.String\ni in $env?.[Bar]\ni in $env?.[String]\ni in $env?.array\ni in array\ni in array and $env\ni in array or ok\ni in concat(array)\ni in concat(list, list)\ni in flatten(list)\ni in groupBy(list, #)?.i\ni in last($env)\ni in {foo: 1.0}.greet\ni not in $env.array\ni not in $env?.Bar\ni not in $env?.String\ni not in $env?.[Bar]\ni not in $env?.[Bar]?.array\ni not in $env?.[String]\ni not in $env?.[String]?.[list]\ni not in $env?.array\ni not in 1 .. i\ni not in [1.0]\ni not in [1]\ni not in [true, nil]\ni not in array\ni not in array == true\ni not in flatten(array)\ni not in flatten(list)\ni not in map(list, 1)\n```\n\n----------------------------------------\n\nTITLE: Variable 'foo' Usage and Comparisons - Expr\nDESCRIPTION: This snippet focuses on the usage of a variable named `foo` within the Expr language. It shows comparisons of `foo` with itself, `nil`, and results of function calls like `reduce` and `get`. It also demonstrates the `in` and `not in` operators for checking membership in arrays and lists, as well as accessing properties of `foo` (e.g., `foo.Bar`, `foo.Qux`, `foo.String`). The code illustrates object property access and membership testing.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_56\n\nLANGUAGE: Expr\nCODE:\n```\nfoo\nfoo != foo\nfoo != nil != nil\nfoo != reduce(list, #)\nfoo == foo\nfoo == foo and 0.5 != f64\nfoo == get(list, 1)\nfoo == list[i]\nfoo == nil ? i : i32\nfoo == nil ? i64 : i\nfoo == reduce(list, #)\nfoo in filter(list, false)\nfoo in groupBy(array, #)\nfoo in groupBy(list, #)\nfoo in list\nfoo in list != ok\nfoo not in groupBy(array, #)\nfoo not in groupBy(array, f64).foo\nfoo not in groupBy(list, #).i\nfoo not in groupBy(list, f32)\nfoo not in groupBy(list, ok)\nfoo not in list\nfoo not in list and ok\nfoo not in list or false\nfoo not in map(list, #)\nfoo.Bar\nfoo.Bar <= foo.Bar\nfoo.Bar matches foo.Bar\nfoo.Bar matches trimPrefix(\"foo\")\nfoo.Qux\nfoo.Qux(\"foo\" + \"foo\")\nfoo.Qux(foo.Bar)\nfoo.Qux(foo.String())\nfoo.Qux(greet(\"foo\"))\nfoo.Qux(string(\"foo\"))\nfoo.Qux(toJSON(i))\nfoo.Qux(type(\"bar\"))\nfoo.Qux(type(f64))\nfoo.Qux(type(half))\nfoo.String\nfoo.String()\nfoo.String() != foo?.String()\nfoo.String() in foo\nfoo.String() not in foo\n```\n\n----------------------------------------\n\nTITLE: Handling Null/Nil Values\nDESCRIPTION: Tests how the language handles null or nil values, specifically in the context of accessing fields and calling methods. Optional chaining (?.) is heavily used to prevent errors when encountering null values.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_141\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": nil}.div\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": nil}?.div\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": nil}?.Bar\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": nil}?.Bar?.score\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": nil}.i64?.Bar()\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": foo == nil}\n```\n\n----------------------------------------\n\nTITLE: Testing groupBy Function with Various Inputs\nDESCRIPTION: This snippet tests the groupBy function with various inputs like numeric literals (1, 0.5), identifiers (f32, f64, i, i64, ok, foo), and expressions (abs, add, bitand, etc.). The groupBy function is invoked with an array and different expressions as arguments.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_65\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(array, 1)?.half\ngroupBy(array, 1)?.i\ngroupBy(array, 1)?.i32\ngroupBy(array, 1)?.i64\ngroupBy(array, 1)?.list\ngroupBy(array, 1)?.ok\ngroupBy(array, 1)?.score\ngroupBy(array, abs(#))\ngroupBy(array, abs(0.5))\ngroupBy(array, abs(1))\ngroupBy(array, abs(f32))\ngroupBy(array, abs(f64))\ngroupBy(array, abs(i))\ngroupBy(array, abs(i64))\ngroupBy(array, add(#, #))\ngroupBy(array, add(#, 1))?.i64\ngroupBy(array, bitnand(1, #))\ngroupBy(array, bitnot(#))\ngroupBy(array, bitnot(1))\ngroupBy(array, bitor(#, #))\ngroupBy(array, bitor(1, #))\ngroupBy(array, bitor(i32, #))\ngroupBy(array, bitshl(1, #))\ngroupBy(array, bitshr(i, #))\ngroupBy(array, bitushr(#, #))\ngroupBy(array, ceil(#))\ngroupBy(array, ceil(i))\ngroupBy(array, ceil(i32))\ngroupBy(array, div(#, #))\ngroupBy(array, f32 != #)\ngroupBy(array, f32 ** 0.5)\ngroupBy(array, f32 - #)\ngroupBy(array, f32 - f64)\ngroupBy(array, f32 / #)\ngroupBy(array, f32 < #)\ngroupBy(array, f32 <= #)\ngroupBy(array, f32 == #)\ngroupBy(array, f32 > 0.5)\ngroupBy(array, f32 > i32)\ngroupBy(array, f32 ^ i)\ngroupBy(array, f32)\ngroupBy(array, f32).Bar\ngroupBy(array, f32).Qux\ngroupBy(array, f32).String\ngroupBy(array, f32).add\ngroupBy(array, f32).array\ngroupBy(array, f32).div\ngroupBy(array, f32).f64\ngroupBy(array, f32).greet\ngroupBy(array, f32).half\ngroupBy(array, f32).i\ngroupBy(array, f32).i32\ngroupBy(array, f32).i64\ngroupBy(array, f32).list\ngroupBy(array, f32).ok\ngroupBy(array, f32).score\ngroupBy(array, f32)?.Bar\ngroupBy(array, f32)?.Qux\ngroupBy(array, f32)?.String\ngroupBy(array, f32)?.add\ngroupBy(array, f32)?.array\ngroupBy(array, f32)?.div\ngroupBy(array, f32)?.f32\ngroupBy(array, f32)?.f64\ngroupBy(array, f32)?.greet\ngroupBy(array, f32)?.half\ngroupBy(array, f32)?.i32\ngroupBy(array, f32)?.i64\ngroupBy(array, f32)?.list\ngroupBy(array, f32)?.ok\ngroupBy(array, f32)?.score\ngroupBy(array, f32)[foo]\ngroupBy(array, f64 != #)\ngroupBy(array, f64 != i64)\ngroupBy(array, f64 ** #)\ngroupBy(array, f64 - #)\ngroupBy(array, f64 - #).i32\ngroupBy(array, f64 < #)\ngroupBy(array, f64 == #)\ngroupBy(array, f64 > #)\ngroupBy(array, f64 >= #)\ngroupBy(array, f64 >= 0.5)\ngroupBy(array, f64)\ngroupBy(array, f64).Bar\ngroupBy(array, f64).Qux\ngroupBy(array, f64).String\ngroupBy(array, f64).add\ngroupBy(array, f64).array\ngroupBy(array, f64).div\ngroupBy(array, f64).f32\ngroupBy(array, f64).f64\ngroupBy(array, f64).foo\ngroupBy(array, f64).greet\ngroupBy(array, f64).half\ngroupBy(array, f64).i\ngroupBy(array, f64).i32\ngroupBy(array, f64).i64\ngroupBy(array, f64).list\ngroupBy(array, f64).ok\ngroupBy(array, f64).score\ngroupBy(array, f64)?.Bar\ngroupBy(array, f64)?.Qux\ngroupBy(array, f64)?.String\ngroupBy(array, f64)?.add\ngroupBy(array, f64)?.array\ngroupBy(array, f64)?.div\ngroupBy(array, f64)?.f32\ngroupBy(array, f64)?.f64\ngroupBy(array, f64)?.foo\ngroupBy(array, f64)?.greet\ngroupBy(array, f64)?.half\ngroupBy(array, f64)?.i\ngroupBy(array, f64)?.i32\ngroupBy(array, f64)?.i64\ngroupBy(array, f64)?.list\ngroupBy(array, f64)?.ok\ngroupBy(array, f64)?.score\ngroupBy(array, f64)[i32]\ngroupBy(array, false ? # : #)\ngroupBy(array, false || ok)\ngroupBy(array, false).Bar\ngroupBy(array, false).Qux\ngroupBy(array, false).String\ngroupBy(array, false).add\ngroupBy(array, false).array\ngroupBy(array, false).div\ngroupBy(array, false).f32\ngroupBy(array, false).f64\ngroupBy(array, false).greet\ngroupBy(array, false).half\ngroupBy(array, false).i\ngroupBy(array, false).i32\ngroupBy(array, false).i64\ngroupBy(array, false).list\ngroupBy(array, false).ok\ngroupBy(array, false).score\ngroupBy(array, false)?.Bar\ngroupBy(array, false)?.Qux\ngroupBy(array, false)?.String\ngroupBy(array, false)?.add\ngroupBy(array, false)?.array\ngroupBy(array, false)?.div\ngroupBy(array, false)?.f32\ngroupBy(array, false)?.f64\ngroupBy(array, false)?.foo\ngroupBy(array, false)?.greet\ngroupBy(array, false)?.half\ngroupBy(array, false)?.i\ngroupBy(array, false)?.i32\ngroupBy(array, false)?.i64\ngroupBy(array, false)?.list\ngroupBy(array, false)?.ok\ngroupBy(array, false)?.score\ngroupBy(array, findLastIndex(list, true))\ngroupBy(array, float(#))\ngroupBy(array, floor(#))\ngroupBy(array, floor(i32))\ngroupBy(array, foo)\ngroupBy(array, foo).Bar\ngroupBy(array, foo).Qux\ngroupBy(array, foo).String\ngroupBy(array, foo).add\ngroupBy(array, foo).array\ngroupBy(array, foo).div\ngroupBy(array, foo).f32\ngroupBy(array, foo).f64\ngroupBy(array, foo).foo\ngroupBy(array, foo).greet\ngroupBy(array, foo).half\ngroupBy(array, foo).i\ngroupBy(array, foo).i32\ngroupBy(array, foo).i64\ngroupBy(array, foo).list\ngroupBy(array, foo).ok\ngroupBy(array, foo).score\ngroupBy(array, foo)?.Bar\ngroupBy(array, foo)?.Qux\ngroupBy(array, foo)?.String\ngroupBy(array, foo)?.add\ngroupBy(array, foo)?.array\ngroupBy(array, foo)?.div\ngroupBy(array, foo)?.f32\ngroupBy(array, foo)?.f64\ngroupBy(array, foo)?.foo\ngroupBy(array, foo)?.greet\ngroupBy(array, foo)?.half\ngroupBy(array, foo)?.i\ngroupBy(array, foo)?.i32\ngroupBy(array, foo)?.i64\ngroupBy(array, foo)?.list\ngroupBy(array, foo)?.ok\ngroupBy(array, foo)?.score\ngroupBy(array, foo.Bar)\ngroupBy(array, foo?.Bar)\ngroupBy(array, get(array, #))\ngroupBy(array, get(list, #))\ngroupBy(array, get(list, i32))\ngroupBy(array, half(1))\ngroupBy(array, half(f64))\ngroupBy(array, half(f64))?.i64\ngroupBy(array, i != #)\ngroupBy(array, i % #)\ngroupBy(array, i * #)\ngroupBy(array, i * #)?.f64\ngroupBy(array, i ** #)\ngroupBy(array, i + #)\ngroupBy(array, i - f64).array\ngroupBy(array, i / #)\ngroupBy(array, i < #)\ngroupBy(array, i <= #)\ngroupBy(array, i <= f64)\ngroupBy(array, i > i)\ngroupBy(array, i ^ #)\ngroupBy(array, i ^ 0.5)\ngroupBy(array, i)\ngroupBy(array, i).Bar\ngroupBy(array, i).Qux\ngroupBy(array, i).String\ngroupBy(array, i).add\ngroupBy(array, i).array\ngroupBy(array, i).div\ngroupBy(array, i).f32\ngroupBy(array, i).f64\ngroupBy(array, i).foo\ngroupBy(array, i).greet\ngroupBy(array, i).half\ngroupBy(array, i).i\ngroupBy(array, i).i32\ngroupBy(array, i).i64\ngroupBy(array, i).list\ngroupBy(array, i).ok\ngroupBy(array, i).score\ngroupBy(array, i)?.Bar\ngroupBy(array, i)?.String\ngroupBy(array, i)?.add\ngroupBy(array, i)?.array\ngroupBy(array, i)?.div\ngroupBy(array, i)?.f32\ngroupBy(array, i)?.f64\ngroupBy(array, i)?.foo\ngroupBy(array, i)?.greet\ngroupBy(array, i)?.half\ngroupBy(array, i)?.i\ngroupBy(array, i)?.i32\ngroupBy(array, i)?.i64\ngroupBy(array, i)?.list\ngroupBy(array, i)?.ok\ngroupBy(array, i)?.score\ngroupBy(array, i)[f64]\ngroupBy(array, i)[false ? i32 : ok]\ngroupBy(array, i32 * f64)\ngroupBy(array, i32 ** # <= i32)\ngroupBy(array, i32 ** f64)\ngroupBy(array, i32 ** i)\ngroupBy(array, i32 ** i64)\ngroupBy(array, i32 + #)\ngroupBy(array, i32 - 1)?.foo\ngroupBy(array, i32 - i64)\ngroupBy(array, i32 / #)\ngroupBy(array, i32 / f32)\ngroupBy(array, i32 < #)\ngroupBy(array, i32 < f64)\ngroupBy(array, i32 <= 1)\ngroupBy(array, i32 == #)\ngroupBy(array, i32 == i)\ngroupBy(array, i32 > #)\ngroupBy(array, i32 >= #).Bar\ngroupBy(array, i32 ^ #)\ngroupBy(array, i32)\ngroupBy(array, i32).Bar\ngroupBy(array, i32).Qux\ngroupBy(array, i32).String\ngroupBy(array, i32).add\ngroupBy(array, i32).array\ngroupBy(array, i32).div\ngroupBy(array, i32).f32\ngroupBy(array, i32).f64\ngroupBy(array, i32).greet\ngroupBy(array, i32).half\ngroupBy(array, i32).i\ngroupBy(array, i32).i32\ngroupBy(array, i32).i64\ngroupBy(array, i32).list\ngroupBy(array, i32).ok\ngroupBy(array, i32).score\ngroupBy(array, i32)?.Bar\ngroupBy(array, i32)?.Qux\ngroupBy(array, i32)?.String\ngroupBy(array, i32)?.add\ngroupBy(array, i32)?.array\ngroupBy(array, i32)?.div\ngroupBy(array, i32)?.f32\ngroupBy(array, i32)?.f64\ngroupBy(array, i32)?.foo\ngroupBy(array, i32)?.greet\ngroupBy(array, i32)?.half\ngroupBy(array, i32)?.i\ngroupBy(array, i32)?.i32\ngroupBy(array, i32)?.i64\ngroupBy(array, i32)?.list\ngroupBy(array, i32)?.ok\ngroupBy(array, i32)?.score\ngroupBy(array, i32)[i]\ngroupBy(array, i64 != i)\ngroupBy(array, i64 % #)\ngroupBy(array, i64 * f32)\ngroupBy(array, i64 ** #)\ngroupBy(array, i64 ** i)\ngroupBy(array, i64 + #)\ngroupBy(array, i64 - #)\ngroupBy(array, i64 / #)?.Qux\ngroupBy(array, i64 / 0.5)\ngroupBy(array, i64 < #)\ngroupBy(array, i64 <= #).foo\ngroupBy(array, i64 >= #)\ngroupBy(array, i64 ^ #)\ngroupBy(array, i64)\ngroupBy(array, i64).Bar\ngroupBy(array, i64).Qux\ngroupBy(array, i64).String\ngroupBy(array, i64).add\ngroupBy(array, i64).array\ngroupBy(array, i64).div\ngroupBy(array, i64).f32\ngroupBy(array, i64).f64\ngroupBy(array, i64).foo\ngroupBy(array, i64).greet\ngroupBy(array, i64).half\ngroupBy(array, i64).i\ngroupBy(array, i64).i32\ngroupBy(array, i64).i64\ngroupBy(array, i64).list\ngroupBy(array, i64).ok\ngroupBy(array, i64).score\ngroupBy(array, i64)?.Bar\ngroupBy(array, i64)?.Qux\ngroupBy(array, i64)?.String\ngroupBy(array, i64)?.add\ngroupBy(array, i64)?.array\ngroupBy(array, i64)?.div\ngroupBy(array, i64)?.f32\ngroupBy(array, i64)?.f64\ngroupBy(array, i64)?.foo\ngroupBy(array, i64)?.greet\ngroupBy(array, i64)?.half\ngroupBy(array, i64)?.i\ngroupBy(array, i64)?.i32\ngroupBy(array, i64)?.i64\ngroupBy(array, i64)?.list\ngroupBy(array, i64)?.ok\ngroupBy(array, i64)?.score\ngroupBy(array, int(f64)).i32\ngroupBy(array, max(#))\ngroupBy(array, max(#, #, #)).ok\ngroupBy(array, max(0.5, #))\ngroupBy(array, max(1))\ngroupBy(array, max(f64))\ngroupBy(array, min(#))\ngroupBy(array, min(0.5))\ngroupBy(array, min(f32))\ngroupBy(array, min(i, #, i32))\ngroupBy(array, nil != #)\ngroupBy(array, nil != f64)\ngroupBy(array, nil != foo)\ngroupBy(array, nil != half)\ngroupBy(array, nil == #)\ngroupBy(array, nil == 0.5)\ngroupBy(array, none(array, false))\ngroupBy(array, none(array, ok))\ngroupBy(array, not ok)?.Bar\ngroupBy(array, not true)\ngroupBy(array, ok == ok)\ngroupBy(array, ok ? # : #)\ngroupBy(array, ok)\ngroupBy(array, ok).Bar\ngroupBy(array, ok).Qux\ngroupBy(array, ok).String\ngroupBy(array, ok).add\ngroupBy(array, ok).array\ngroupBy(array, ok).div\ngroupBy(array, ok).f32\ngroupBy(array, ok).f64\ngroupBy(array, ok).foo\ngroupBy(array, ok).greet\ngroupBy(array, ok).half\ngroupBy(array, ok).i\ngroupBy(array, ok).i32\ngroupBy(array, ok).i64\ngroupBy(array, ok).list\ngroupBy(array, ok).ok\ngroupBy(array, ok).score\ngroupBy(array, ok)?.Bar\ngroupBy(array, ok)?.Qux\ngroupBy(array, ok)?.String\ngroupBy(array, ok)?.array\ngroupBy(array, ok)?.div\ngroupBy(array, ok)?.f32\n```\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(array, ok)?.f64\n```\n\n----------------------------------------\n\nTITLE: Take Function Operations\nDESCRIPTION: Illustrates the `take` function, which retrieves a specified number of elements from an array or list. The snippets demonstrate the use of different index types (i, i32, i64) and showcases using take with a map function result.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_115\n\nLANGUAGE: Expr\nCODE:\n```\ntake(array, i)\ntake(array, i32)\ntake(array, i64)\ntake(list, i)\ntake(list, i32)\ntake(list, i64)\ntake(map(array, #), i)\n```\n\n----------------------------------------\n\nTITLE: Boolean Logic (and, or, &&, ||)\nDESCRIPTION: This snippet demonstrates various boolean logic operations in the Expr language, including 'and', 'or', '&&', and '||'. It showcases how these operations interact with 'ok', 'true', 'false', and comparison expressions involving different data types.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_93\n\nLANGUAGE: Expr\nCODE:\n```\nnot false or false == false\nnot false or ok\nnot false || ok\nnot ok and \"foo\" == \"foo\"\nnot ok and i32 > 0.5\nnot ok and ok\nnot ok or 1 != i\nnot ok or ok\nnot ok || array == list\nnot ok || ok\nnot true and ok ? i : half\nnot true || ok\nok && !false\nok && !ok\nok && \"foo\" matches \"bar\"\nok && (\"bar\" not endsWith \"bar\")\nok && (false || ok)\nok && (ok or false)\nok && (true || true)\nok && 0.5 < 1\nok && 0.5 < f64\nok && 0.5 <= 1\nok && 0.5 == nil\nok && 0.5 > i64\nok && 1 != 0.5\nok && 1 != i32\nok && 1 <= 1\nok && 1 <= f64\nok && 1 == 0.5\nok && 1 == nil\nok && 1 >= f64\nok && f32 != i\nok && f32 >= i64\nok && f64 <= 0.5\nok && false != ok\nok && false ? i : list\nok && false ? ok : ok\nok && i < 0.5\nok && i < i64\nok && i == 0.5\nok && i > f64\nok && i32 > 0.5\nok && i32 >= i64\nok && i64 != i\nok && i64 == 0.5\nok && nil != 0.5\nok && nil != 1\nok && nil == ok\nok && not false\nok && not true\nok && ok\nok && ok and false\nok && ok ? nil : div\nok && true != false\nok && true && 1 >= i64\nok == (false and ok)\nok == true && ok\nnot ok && 1 > 0.5\nnot true && ok\n```\n\n----------------------------------------\n\nTITLE: Conditional List Access with Various Types - Expr\nDESCRIPTION: This snippet demonstrates the usage of the `get` function combined with conditional expressions (`? :`) to access elements from different arrays and lists based on boolean conditions. It shows how to handle different data types (numbers, strings, functions, arrays, lists) within the conditional branches and how they interact with the `get` function. This highlights the dynamic typing and flexibility of the Expr language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_60\n\nLANGUAGE: Expr\nCODE:\n```\nget(false ? 0.5 : greet, list)\nget(false ? add : array, f64)\nget(false ? add : score, ok)\nget(false ? f64 : 1, ok)\nget(false ? f64 : score, add)\nget(false ? false : f32, i)\nget(false ? i32 : list, i64)\nget(false ? i64 : true, f64)\nget(false ? score : ok, trimSuffix(\"bar\", \"bar\"))\n```\n\n----------------------------------------\n\nTITLE: Map and List Operations\nDESCRIPTION: Illustrates operations on maps (dictionaries) and lists, including accessing properties, grouping elements, and working with nested structures. The examples cover various scenarios involving different data types within maps and lists.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_129\n\nLANGUAGE: expr-lang\nCODE:\n```\nvalues(groupBy(array, \"bar\"))\nvalues(groupBy(array, \"foo\"))\nvalues(groupBy(array, #))\nvalues(groupBy(array, 0.5))\nvalues(groupBy(array, 1))\nvalues(groupBy(array, foo))\nvalues(groupBy(array, i))\nvalues(groupBy(list, #))\nvalues(groupBy(list, 1))\nvalues(groupBy(list, i))\nvalues(groupBy(list, i32))\nvalues(groupBy(list, true))\nvalues({\"bar\": \"bar\"})\nvalues({\"bar\": array})\nvalues({\"foo\": add, \"bar\": div})\nvalues({\"foo\": ok})\n```\n\n----------------------------------------\n\nTITLE: Nil Safe Navigation\nDESCRIPTION: These examples demonstrates safe navigation from potentially nil environment variables. It covers method calls and attribute access.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_8\n\nLANGUAGE: Expr\nCODE:\n```\n$env?.[nil]?.Bar\n$env?.[nil]?.Bar()\n$env?.[nil]?.Bar?.[add]\n$env?.[nil]?.String\n$env?.[nil]?.String()\n$env?.[nil]?.[add]\n$env?.[nil]?.[add]?.[add]\n$env?.[nil]?.[array]\n$env?.[nil]?.[array].count(i)\n$env?.[nil]?.[array]?.f64()\n$env?.[nil]?.[f64]\n$env?.[nil]?.[f64].list\n$env?.[nil]?.[f64]?.Bar\n$env?.[nil]?.[foo]\n$env?.[nil]?.[foo]?.i()\n$env?.[nil]?.[greet]\n$env?.[nil]?.[greet]?.array()\n$env?.[nil]?.[i]\n$env?.[nil]?.[list]\n$env?.[nil]?.[ok]\n$env?.[nil]?.[str]\n$env?.[nil]?.[str]?.[array]\n$env?.[nil]?.add\n$env?.[nil]?.add()\n$env?.[nil]?.array\n$env?.[nil]?.array(add)\n$env?.[nil]?.array(list)\n$env?.[nil]?.f64\n$env?.[nil]?.f64.add\n$env?.[nil]?.f64.f64\n$env?.[nil]?.f64.i\n$env?.[nil]?.foo\n$env?.[nil]?.foo()\n$env?.[nil]?.foo?.String\n$env?.[nil]?.foobar.String()\n$env?.[nil]?.greet\n$env?.[nil]?.greet()\n$env?.[nil]?.greet(foobar)\n$env?.[nil]?.greet.f64\n$env?.[nil]?.i\n$env?.[nil]?.i()\n$env?.[nil]?.i(true or $env >= ok)\n$env?.[nil]?.i?.f64\n$env?.[nil]?.list\n$env?.[nil]?.list($env?.foo)\n$env?.[nil]?.list?.array\n$env?.[nil]?.list?.i\n$env?.[nil]?.ok\n$env?.[nil]?.ok()\n$env?.[nil]?.ok?.[str]\n$env?.[nil]?.str\n$env?.[nil]?.str()\n$env?.[nil]?.str(String)\n$env?.[nil]?.str(foobar)\n```\n\n----------------------------------------\n\nTITLE: Check if No Array Elements Match Predicate in Expr\nDESCRIPTION: The `none()` function tests whether no elements in an array satisfy a provided predicate. It returns `true` if all elements do not satisfy the predicate, otherwise returns `false`. If the array is empty, returns `true`.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_53\n\nLANGUAGE: expr\nCODE:\n```\nnone(tweets, {.Size > 280})\n```\n\n----------------------------------------\n\nTITLE: Count Function Usage in Expr\nDESCRIPTION: Illustrates the usage of the 'count' function in the Expr language with various collections, filters, and conditions. The 'count' function returns the number of elements in a collection that satisfy a given predicate or the total number of elements if no predicate is provided.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_78\n\nLANGUAGE: Expr\nCODE:\n```\ncount($env | filter(false))\ncount($env | map(foo), ok)\ncount($env | map(ok))\ncount($env | map(true))\ncount($env, false) ^ i\ncount($env, true) ** i\ncount($env.list, foo != foo)\ncount($env.list, ok)\ncount($env?.[str], true != nil)\ncount($env?.array, ok)\ncount($env?.list, ok)\ncount(1 .. 0)\ncount([$env && false])\ncount([false, false])\ncount([false])\ncount([false], #)\ncount([ok])\ncount([true])\ncount(array | map(false))\ncount(array | map(ok))\ncount(array, # != i)\ncount(array, # > #)\ncount(array, # >= i)\ncount(array, # not in array)\ncount(array, $env != #)\ncount(array, $env.ok)\ncount(array, $env?.false != nil and ok)\ncount(array, 1 != nil)\ncount(array, 1.0 != #)\ncount(array, array | none(true))\ncount(array, false and $env)\ncount(array, false) <= 1 ^ i\ncount(array, false) ^ f64\ncount(array, foo in list)\ncount(array, i >= #)\ncount(array, nil == $env)\ncount(array, ok)\ncount(array, ok) ^ f64\ncount(array, true) in array\ncount(array[:0])\ncount(filter($env, false))\ncount(filter(list, # != #))\ncount(i .. 0)\ncount(list | filter(false))\ncount(list | map(false))\ncount(list | map(true))\ncount(list, # != foo)\ncount(list, # != nil)\ncount(list, #.Bar == nil)\ncount(list, $env == $env)\ncount(list, $env in array)\ncount(list, 0 != nil)\ncount(list, 0 <= f64)\ncount(list, 0 == i)\ncount(list, 1 < i)\ncount(list, 1.0 < 1.0)\ncount(list, [#] | all(true))\ncount(list, add == $env)\ncount(list, f64 == nil)\ncount(list, foo != $env)\ncount(list, nil != 1.0)\ncount(list, nil != true)\ncount(list, ok)\ncount(list, ok) .. 1 | take(1)\ncount(list, str != $env)\ncount(list, true != nil)\ncount(list[:0])\ncount(map($env, $env), ok == $env)\ncount(map($env, false))\ncount(map($env, ok))\ncount(map($env, true))\ncount(map($env, true)) >= f64\ncount(map(array, false))\ncount(map(list, false))\ncount(map(list, ok))\ncount(sort($env))\ncount(sort($env), # < #.str)\ncount(sort($env), #)\ncount(sort($env), #.str && #)\ncount(toPairs($env), 0 in #)\n```\n\n----------------------------------------\n\nTITLE: Expr f64 Operations\nDESCRIPTION: This snippet includes several operations that involve the 'f64' (double) type. These include arithmetic operations such as addition, subtraction, multiplication, division, exponentiation, and bitwise operations. It demonstrates the usage of f64 values with environment variables, function calls, and comparison operators.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_81\n\nLANGUAGE: Expr\nCODE:\n```\nf64 - bitxor(i, i)\nf64 - ceil(f64)\nf64 - f64\nf64 - f64 < i\nf64 - f64 <= f64\nf64 - floor(0)\nf64 - i\nf64 - i >= 1\nf64 - i >= i\nf64 - i | median(1.0)\nf64 - last(array)\nf64 - len(str)\nf64 - max(array)\nf64 - max(f64)\nf64 - median(1.0)\nf64 - median(array)\nf64 - min(1.0, array)\nf64 / $env.f64\nf64 / $env.i\nf64 / $env?.f64\nf64 / $env?.i\nf64 / 0 != 1.0\nf64 / 0 + i\nf64 / 0 - 1.0\nf64 / 1 / 1.0\nf64 / 1 / i\nf64 / 1 <= 0\nf64 / 1.0 != 1\nf64 / 1.0 != f64\nf64 / 1.0 ** 1.0\nf64 / 1.0 - 1\nf64 / 1.0 <= 1.0\nf64 / 1.0 >= 0\nf64 / 1.0 ^ 1.0\nf64 / 1.0 ^ f64\nf64 / abs(1.0)\nf64 / abs(i)\nf64 / add(i, 1)\nf64 / array?.[i]\nf64 / ceil(1.0)\nf64 / f64\nf64 / f64 ** i\nf64 / f64 / 1.0\nf64 / f64 <= f64\nf64 / first(array)\nf64 / float(1.0)\nf64 / i\nf64 / i >= 1.0\nf64 / len($env)\nf64 / max(1)\nf64 / max(f64, f64)\nf64 / mean(1)\nf64 / mean(array)\n```\n\n----------------------------------------\n\nTITLE: Map Function Application in Expr\nDESCRIPTION: These expressions demonstrate the use of the `map` function in Expr. The `map` function applies a given expression to each element of an iterable (range, list, array) and returns a new list with the transformed values. The snippets show various expressions being applied, including arithmetic operations, comparisons, function calls, and property access, covering different data types and scenarios. '#' is often used as the placeholder for the current element within the `map` function.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_78\n\nLANGUAGE: Expr\nCODE:\n```\nmap(1 .. 1, f32)\nmap(1 .. 1, foo)\nmap(1 .. 1, score)\nmap(1 .. i, foo)\nmap(1 .. i32, #)\nmap(1 .. i32, 0.5 / f64)\nmap(1 .. i32, div)\nmap(1 .. i32, reduce(array, #))\nmap(1 .. i64, # ^ #)\nmap(1 .. i64, #)\nmap(1 .. i64, half)\nmap(1 .. i64, i32)\nmap([f64], half)\nmap([false], ok)\nmap([half], #)\nmap([i * i32], score)\nmap([i32, foo, score], #)\nmap([i32], foo)\nmap([i32], greet)\nmap([i32], half)\nmap([list, 1, foo], i32)\nmap([nil], foo)\nmap([score, \"bar\"], f32)\nmap([true, i32, 1], #)\nmap(array, !(# == #))\nmap(array, !(nil in list))\nmap(array, !ok)\nmap(array, \"bar\" in foo)\nmap(array, \"foo\" not endsWith \"bar\")\nmap(array, \"foo\") == array\nmap(array, # != #)\nmap(array, # != 0.5)\nmap(array, # != 1)\nmap(array, # != f64)\nmap(array, # != i32)\nmap(array, # != nil)\nmap(array, # % #)\nmap(array, # % 1)\nmap(array, # % i)\nmap(array, # % i64)\nmap(array, # * #)\nmap(array, # * 0.5)\nmap(array, # * 1)\nmap(array, # * f32)\nmap(array, # * f64)\nmap(array, # * i)\nmap(array, # ** #)\nmap(array, # ** 1)\nmap(array, # ** f32)\nmap(array, # ** i)\nmap(array, # ** i64)\nmap(array, # + #)\nmap(array, # + 0.5)\nmap(array, # + 1)\nmap(array, # + f32)\nmap(array, # + i)\nmap(array, # + i32)\nmap(array, # - #)\nmap(array, # - 0.5)\nmap(array, # - 1)\nmap(array, # - f32)\nmap(array, # - f64)\nmap(array, # - i)\nmap(array, # - i32)\nmap(array, # .. #)\nmap(array, # .. 1)\nmap(array, # / #)\nmap(array, # / 0.5)\nmap(array, # / 1)\nmap(array, # / f32)\nmap(array, # / f64)\nmap(array, # / i)\nmap(array, # / i64)\nmap(array, # < #)\nmap(array, # < 1)\nmap(array, # < f32)\nmap(array, # < i32)\nmap(array, # < i64)\nmap(array, # <= #)\nmap(array, # <= f32)\nmap(array, # <= i)\nmap(array, # <= i32)\nmap(array, # == #)\nmap(array, # == f32)\nmap(array, # == f64)\nmap(array, # == nil)\nmap(array, # > #)\nmap(array, # > 0.5)\nmap(array, # > 1)\nmap(array, # > f32)\nmap(array, # > f64)\nmap(array, # >= #)\nmap(array, # >= 1)\nmap(array, # >= f32)\nmap(array, # >= i32)\nmap(array, # >= i64)\nmap(array, # ^ #)\nmap(array, # ^ 0.5)\nmap(array, # ^ 1)\nmap(array, # ^ i)\nmap(array, # ^ i32)\nmap(array, # not in array)\nmap(array, #)\nmap(array, #) != array\nmap(array, #) != list\nmap(array, #) == array\nmap(array, #) == list\nmap(array, #)[i64]\nmap(array, #)[i]\nmap(array, -#)\nmap(array, --#)\nmap(array, -0.5)\nmap(array, -1)\nmap(array, -f64)\nmap(array, -i)\nmap(array, -i32)\nmap(array, -i64)\nmap(array, 0.5 != #)\nmap(array, 0.5 != 0.5)\nmap(array, 0.5 * #)\nmap(array, 0.5 * f64)\nmap(array, 0.5 ** f32)\nmap(array, 0.5 ** i64)\nmap(array, 0.5 + #)\nmap(array, 0.5 + 1)\nmap(array, 0.5 - #)\nmap(array, 0.5 - 0.5)\nmap(array, 0.5 / i)\nmap(array, 0.5 < #)\nmap(array, 0.5 < i32)\nmap(array, 0.5 > #)\nmap(array, 0.5 > i64)\nmap(array, 0.5 >= #)\nmap(array, 0.5 ^ #)\nmap(array, 0.5)[i]\nmap(array, 1 != #)\nmap(array, 1 != f32)\nmap(array, 1 % #)\nmap(array, 1 ** #)\nmap(array, 1 ** i)\nmap(array, 1 ** i64)\nmap(array, 1 + #)\nmap(array, 1 + f64)\nmap(array, 1 - #)\nmap(array, 1 .. #)\nmap(array, 1 / #)\nmap(array, 1 / i32)\nmap(array, 1 < #)\nmap(array, 1 <= #)\nmap(array, 1 <= 1)\nmap(array, 1 <= f32)\nmap(array, 1 == #)\nmap(array, 1 ^ #)\nmap(array, abs(#))\nmap(array, abs(i64))\nmap(array, add == nil)\nmap(array, add(#, #))\nmap(array, add(#, i))\nmap(array, add)\nmap(array, array)\nmap(array, array)[bitnot(i32)]\nmap(array, array)[i64]\nmap(array, array[#:#])\nmap(array, bitand(#, 1))\nmap(array, bitnand(#, 1))\nmap(array, bitnot(#))\nmap(array, bitnot(1))\nmap(array, bitshl(#, #))\nmap(array, bitshr(#, #))\nmap(array, bitshr(#, i64))\nmap(array, bitushr(1, #))\nmap(array, ceil(#))\nmap(array, ceil(0.5))\nmap(array, ceil(f32))\nmap(array, div(#, #))\nmap(array, div)\nmap(array, f32 * #)\nmap(array, f32 * f64)\nmap(array, f32 ** #)\nmap(array, f32 + #)\nmap(array, f32 / #)\nmap(array, f32 < #)\nmap(array, f32 == #)\nmap(array, f32 > #)\nmap(array, f32 >= #)\nmap(array, f32 >= i)\nmap(array, f32 ^ #)\nmap(array, f32)\nmap(array, f32)[min(i32)]\nmap(array, f64 != #)\nmap(array, f64 != 0.5)\nmap(array, f64 * #)\nmap(array, f64 ** #)\nmap(array, f64 ** 0.5)\nmap(array, f64 / #)\nmap(array, f64 < #)\nmap(array, f64 < f64)\nmap(array, f64 <= #)\nmap(array, f64 == #)\nmap(array, f64 >= #)\nmap(array, f64 >= i32)\nmap(array, f64 ^ #)\nmap(array, f64)\nmap(array, false && false)\nmap(array, false ? # : f64)\nmap(array, false ? greet : i)\nmap(array, false)[i32]\nmap(array, find(array, true))\nmap(array, findIndex(list, ok))\nmap(array, float(# + #))\nmap(array, float(#))\nmap(array, floor(#))\nmap(array, foo == foo)\nmap(array, foo)\nmap(array, foo.Bar)\nmap(array, foo.Qux)\nmap(array, foo.String())\nmap(array, foo.String)\nmap(array, foo?.Bar)\nmap(array, foo?.String)\nmap(array, get(array, #))\nmap(array, greet(\"bar\"))\nmap(array, greet(\"foo\"))\nmap(array, greet)\nmap(array, groupBy(array, #))\nmap(array, groupBy(array, f32))\nmap(array, groupBy(list, #))\nmap(array, groupBy(list, f64))\nmap(array, groupBy(list, i))\nmap(array, half != half)\nmap(array, half != nil)\nmap(array, half(0.5))\nmap(array, half(1))\nmap(array, half(f64))\nmap(array, half(i - 0.5))\nmap(array, half)\nmap(array, i % #)\nmap(array, i + #)\nmap(array, i - i32)\nmap(array, i / 0.5)\nmap(array, i <= #)\nmap(array, i <= f32)\nmap(array, i <= f64)\nmap(array, i == #)\nmap(array, i == f64)\nmap(array, i > i32)\nmap(array, i >= #)\nmap(array, i)\nmap(array, i)[i]\nmap(array, i32 * #)\nmap(array, i32 ** #)\nmap(array, i32 ** f64)\nmap(array, i32 / f32)\nmap(array, i32 < #)\nmap(array, i32 < f64)\nmap(array, i32 == #)\nmap(array, i32 == 1)\nmap(array, i32 > #)\nmap(array, i32 ^ #)\nmap(array, i32 not in array)\nmap(array, i32)\nmap(array, i32) == array\nmap(array, i32) == list\nmap(array, i64 != #)\nmap(array, i64 % #)\nmap(array, i64 * #)\nmap(array, i64 * 0.5)\nmap(array, i64 + 0.5)\nmap(array, i64 - #)\nmap(array, i64 .. #)\nmap(array, i64 < #)\nmap(array, i64 <= #)\nmap(array, i64 <= f64)\nmap(array, i64 <= i64)\nmap(array, i64 > #)\nmap(array, i64)\nmap(array, int(#))\nmap(array, int(0.5))\nmap(array, len(\"foo\"))\nmap(array, list != array)\nmap(array, list)\nmap(array, map(array, f64))\nmap(array, map(list, greet))\nmap(array, max(#))\nmap(array, max(f32, 1))\nmap(array, max(f64))\nmap(array, mean(array))\nmap(array, min(#, #))\nmap(array, nil == #)\nmap(array, nil == ok)\nmap(array, nil not in list)\nmap(array, not ok)\nmap(array, not true)\nmap(array, ok || ok)\nmap(array, ok)\nmap(array, ok)[i64]\nmap(array, reduce(array, \"bar\"))\nmap(array, reduce(array, #))\nmap(array, reduce(list, add))\nmap(array, reduce(list, half))\nmap(array, round(#))\nmap(array, score(#))\nmap(array, score(#, #))\nmap(array, score(1))\nmap(array, score)\nmap(array, string(add))\nmap(array, string(foo))\nmap(array, string(i64))\nmap(array, take(array, #))\nmap(array, toBase64(\"foo\"))\nmap(array, toJSON(#))\nmap(array, toJSON(foo))\nmap(array, toJSON(list))\nmap(array, true != nil)\nmap(array, true ? 0.5 : #)\nmap(array, true ? 0.5 : 1)\nmap(array, true ? f32 : div)\nmap(array, true ? i : true)\nmap(array, type(#))\nmap(array, type(f32))\nmap(array[1:i32], list)\nmap(false ? i32 : list, ok)\nmap(filter(array, false), foo)\nmap(filter(array, ok), 1 * #)\nmap(filter(list, # != #), #)\nmap(filter(list, false), #)\nmap(filter(list, ok), #)\nmap(filter(list, ok), i)\nmap(filter(list, true), i64)\nmap(groupBy(array, #).String, i32)\nmap(groupBy(array, #).greet, foo.Qux(.f32))\nmap(groupBy(array, #).greet, score)\nmap(groupBy(array, #).score, #?.list())\n```\n\n----------------------------------------\n\nTITLE: Nested `reduce` expressions in Expr\nDESCRIPTION: Shows how to nest `reduce` functions within each other, allowing for multi-level data aggregation and transformation. This is useful for complex data processing pipelines where results from one reduction are used as input for another.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_102\n\nLANGUAGE: Expr\nCODE:\n```\nreduce(reduce(array, array), f64 != #)\nreduce(reduce(array, list), get(array, i32))\nreduce(reduce(list, array), f64)\n```\n\n----------------------------------------\n\nTITLE: F64 Expressions in Expr\nDESCRIPTION: Presents a variety of expressions involving the 'f64' data type in the Expr language. These expressions cover various arithmetic, logical, and comparison operations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_80\n\nLANGUAGE: Expr\nCODE:\n```\nf64\nf64 != $env == false\nf64 != $env ?: false\nf64 != $env or $env\nf64 != $env or ok\nf64 != $env || $env\nf64 != $env || false\nf64 != $env.f64\nf64 != $env.i\nf64 != $env?.$env\nf64 != $env?.Bar\nf64 != $env?.Bar?.[ok]\nf64 != $env?.Bar?.list()\nf64 != $env?.String\nf64 != $env?.[Bar]\nf64 != $env?.[Bar]?.String\nf64 != $env?.[Bar]?.add\nf64 != $env?.[String]\nf64 != $env?.[foobar]\nf64 != $env?.[str]\nf64 != $env?.f64\nf64 != $env?.foobar\nf64 != $env?.i\nf64 != $env?.nil\nf64 != $env?.true\nf64 != 0 != true\nf64 != 0 + i\nf64 != 0 - i\nf64 != 0 == $env\nf64 != 0 == nil\nf64 != 1 / i\nf64 != 1 and $env\nf64 != 1 || $env\nf64 != 1.0 != $env\nf64 != 1.0 != nil\nf64 != 1.0 - 0\nf64 != 1.0 - 1\nf64 != 1.0 - i\nf64 != 1.0 == true\nf64 != 1.0 ?: add\nf64 != 1.0 and false\nf64 != 1.0 or $env\nf64 != array?.[i]\nf64 != f64\nf64 != f64 && $env\nf64 != f64 and true\nf64 != float(i)\nf64 != floor(f64)\nf64 != floor(i)\nf64 != i\nf64 != i != false\nf64 != i && $env\nf64 != i * f64\nf64 != i and $env\nf64 != i and nil not in array\nf64 != i and true\nf64 != int(1.0)\nf64 != last($env)\nf64 != len($env)\nf64 != mean(0)\nf64 != mean(1.0)\nf64 != mean(array)\nf64 != median(1.0)\nf64 != nil != false\nf64 != nil && $env\nf64 != nil or $env\nf64 != round(1.0)\nf64 * $env.f64\nf64 * $env.i\nf64 * $env?.f64\nf64 * $env?.i\nf64 * 0 * 1.0\nf64 * 0 + 1\nf64 * 0 - 1.0\nf64 * 1 != nil\nf64 * 1 * 0\nf64 * 1 * i\nf64 * 1 <= i\nf64 * 1 == nil\nf64 * 1 in array\nf64 * 1.0\nf64 * 1.0 != i\nf64 * 1.0 * 1.0\nf64 * 1.0 * f64\nf64 * 1.0 ** f64\nf64 * 1.0 < 0\nf64 * 1.0 < 1\nf64 * 1.0 | max(0)\nf64 * abs(1.0)\nf64 * array?.[1]\nf64 * array?.[i]\nf64 * bitnot(0)\nf64 * f64\nf64 * f64 * i\nf64 * f64 / i\nf64 * f64 > 1\nf64 * float(0)\nf64 * float(f64)\nf64 * float(i)\nf64 * i\nf64 * i != $env?.i\nf64 * i != sum(array)\nf64 * i ** 1.0\nf64 * i == nil\nf64 * i > $env?.f64\nf64 * int(1)\nf64 * int(1.0)\nf64 * len($env)\nf64 * len(foo.Bar)\nf64 * len(str)\nf64 * min(array)\nf64 * sum(array | sortBy(#))\nf64 ** $env.f64\nf64 ** $env.i\nf64 ** $env?.f64\nf64 ** $env?.i\nf64 ** 0 ** f64\nf64 ** 0 >= 1.0\nf64 ** 1 != nil\nf64 ** 1 - i\nf64 ** 1 / 0\nf64 ** 1 < f64\nf64 ** 1.0 != $env\nf64 ** 1.0 != f64\nf64 ** 1.0 * 1.0\nf64 ** 1.0 + 0\nf64 ** 1.0 / i\nf64 ** 1.0 > 1\nf64 ** 1.0 ^ 1.0\nf64 ** 1.0 not in array\nf64 ** abs(mean(1.0))\nf64 ** array?.[i]\nf64 ** bitnot(0)\nf64 ** f64\nf64 ** f64 * 0\nf64 ** f64 * i\nf64 ** f64 + 1.0\nf64 ** f64 - 1.0\nf64 ** f64 ^ i\nf64 ** f64 | median(0)\nf64 ** float(1.0)\nf64 ** i\nf64 ** i >= i\nf64 ** i ^ i\nf64 ** mean(1.0)\nf64 ** mean(f64)\nf64 ** min(1.0)\nf64 ** min(f64)\nf64 ** round(f64)\nf64 ** sum(array)\nf64 + $env.f64\nf64 + $env.i\nf64 + $env?.f64\nf64 + $env?.i\nf64 + 0 * f64\nf64 + 0 ^ 1.0\nf64 + 0 ^ f64\nf64 + 1 * 0\nf64 + 1 * i\nf64 + 1 / 1.0\nf64 + 1 < 1.0\nf64 + 1 > $env and false\nf64 + 1 ^ f64\nf64 + 1.0 != f64\nf64 + 1.0 < 1.0\nf64 + 1.0 < int(0)\nf64 + 1.0 <= $env.i\nf64 + 1.0 <= 0\nf64 + 1.0 == 0\nf64 + 1.0 == nil\nf64 + 1.0 ^ 0\nf64 + 1.0 ^ 1.0\nf64 + 1.0 not in array\nf64 + 1.0 | max(1.0)\nf64 + abs(i)\nf64 + array?.[i]\nf64 + bitnot(i)\nf64 + ceil(1)\nf64 + count($env, true)\nf64 + f64\nf64 + f64 ** 1.0\nf64 + f64 ^ i\nf64 + i\nf64 + i != 0\nf64 + i ** 1\nf64 + i - 1\nf64 + i / i\nf64 + i == i\nf64 + i > 1.0\nf64 + i in array\nf64 + int(i)\nf64 + min(f64)\nf64 + sum(array)\nf64 + sum(list, 1)\nf64 - $env.f64\nf64 - $env.i\nf64 - $env?.f64\nf64 - $env?.i\nf64 - 0 / 1\nf64 - 0 / f64\nf64 - 0 < 0\nf64 - 0 < 1\nf64 - 0 > 0\nf64 - 0 > f64\nf64 - 1 != $env\nf64 - 1 <= 1 + f64\nf64 - 1 > i\nf64 - 1 not in $env?.[Bar]\nf64 - 1 | mean(1.0)\nf64 - 1.0 - 0\nf64 - 1.0 - 1.0\nf64 - 1.0 / i\nf64 - 1.0 == f64\nf64 - 1.0 > 1\nf64 - array?.[i]\n```\n\n----------------------------------------\n\nTITLE: Equality Comparisons with Nil\nDESCRIPTION: This code snippet showcases the use of equality comparisons (==) with nil in the Expr language, including dot and bracket notation for accessing environment variables, optional chaining, and function calls. It highlights how nil is evaluated in these contexts.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_198\n\nLANGUAGE: Expr\nCODE:\n```\nnil == $env or f64 < 1.0\nnil == $env.add\nnil == $env.array\nnil == $env.f64\nnil == $env.foo\nnil == $env.greet\nnil == $env.i\nnil == $env.list\nnil == $env.ok\nnil == $env.str\nnil == $env?.Bar\nnil == $env?.String\nnil == $env?.String?.[list]\nnil == $env?.[Bar]\nnil == $env?.[String]\nnil == $env?.[foo.Bar]\nnil == $env?.[foobar?.[i]]\nnil == $env?.[foobar]\nnil == $env?.[str]\nnil == $env?.add\nnil == $env?.array\nnil == $env?.f64\nnil == $env?.foo\nnil == $env?.foobar\nnil == $env?.foobar?.add(foobar, foobar)\nnil == $env?.greet\nnil == $env?.i\nnil == $env?.list\nnil == $env?.ok\nnil == $env?.str\nnil == 0 ** 1.0 ? nil : nil\nnil == 0 || ok\nnil == 1 * i\nnil == 1 and find($env, #.add)?.[i]\nnil == 1.0 ?: i\nnil == 1.0 ^ f64\nnil == array?.[i]\nnil == f64 * f64\nnil == foo != ok\nnil == foo and ok\nnil == foo.Bar\nnil == foo.String\nnil == foo.String()\nnil == foo?.Bar\nnil == foo?.String\nnil == foo?.String()\nnil == greet != $env?.Bar\nnil == greet and $env?.[list]\nnil == greet or ok\nnil == i + i\nnil == i and ok\nnil == i in $env?.[String]\nnil == list?.[i]\nnil == nil != $env?.[String]\nnil == nil != nil || false\nnil == nil and ok\nnil == ok != ok\nnil == str != false || true\n```\n\n----------------------------------------\n\nTITLE: Accessing Keys of Various Data Structures in Expr\nDESCRIPTION: This snippet shows how to use the `keys` function to retrieve the keys of different data structures like `groupBy` results, maps, and literal objects in the Expr language. It highlights the versatility of the `keys` function in extracting keys from diverse data representations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_165\n\nLANGUAGE: Expr\nCODE:\n```\nkeys(groupBy(list, #))\nkeys(groupBy(list, foo))\nkeys(max($env))\nkeys(min($env))\nkeys(reduce(list, $env))\nkeys({foo: $env})\nkeys({foo: 0})\nkeys({foo: 1, foo: 0})\nkeys({foo: 1, foo: false})\nkeys({foo: 1.0})\nkeys({foo: 1})\nkeys({foo: add})\nkeys({foo: array})\nkeys({foo: f64})\nkeys({foo: false})\nkeys({foo: foo, foo: 0})\nkeys({foo: foo, foo: 1.0})\nkeys({foo: foo})\nkeys({foo: greet})\nkeys({foo: i, foo: true})\nkeys({foo: i})\nkeys({foo: nil})\nkeys({foo: ok})\nkeys({foo: str})\nkeys({foo: true, foo: list})\nkeys({foo: true})\n```\n\n----------------------------------------\n\nTITLE: Arithmetic and Bitwise Operations in Expr\nDESCRIPTION: These snippets show various arithmetic and bitwise operations performed with and on environment variables, as well as numeric literals in the Expr language. Operations include multiplication, exponentiation, addition, subtraction, division, range, bitwise XOR, and bitwise left shift.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_273\n\nLANGUAGE: Expr\nCODE:\n```\n{foo: 0 % i}\n{foo: 0 * 0}\n{foo: 0 * 1.0}\n{foo: 0 * 1}\n{foo: 0 * i}\n{foo: 0 ** 1}\n{foo: 0 ** i}\n{foo: 0 + 1.0}\n{foo: 0 + f64}\n{foo: 0 - 1.0}\n{foo: 0 - 1}\n{foo: 0 - f64}\n{foo: 0 .. 1}\n{foo: 0 .. i}\n{foo: 0 / 0}\n{foo: 0 / 1.0}\n{foo: 0 ^ 0}\n{foo: 0 ^ 1.0}\n{foo: 0 ^ i}\n{foo: 0 | bitshl(i)}\n{foo: 1 % 1}\n{foo: 1 * 0}\n{foo: 1 * 1.0}\n{foo: 1 * 1}\n{foo: 1 * f64}\n{foo: 1 * i}\n{foo: 1 ** 0}\n{foo: 1 ** 1.0}.f64\n{foo: 1 ** 1.0}.i\n{foo: 1 ** 1}\n{foo: 1 + 0}\n{foo: 1 + i}\n{foo: 1 - 1.0}\n{foo: 1 - f64}\n{foo: 1 - i}\n{foo: 1 .. i}\n{foo: 1 / 1.0}\n{foo: 1 / 1}\n{foo: 1 / f64}\n{foo: 1 ^ 0}\n{foo: 1 ^ 1.0}\n{foo: 1 ^ f64}\n{foo: 1.0 * 1.0}\n{foo: 1.0 * 1}\n{foo: 1.0 ** 1.0}\n{foo: 1.0 ** f64}\n{foo: 1.0 ** i}\n{foo: 1.0 + 1.0}\n{foo: 1.0 + 1}\n{foo: 1.0 + f64}\n{foo: 1.0 + i}\n{foo: 1.0 - 0}\n{foo: 1.0 - 1.0}\n{foo: 1.0 - 1}\n{foo: 1.0 - i}\n{foo: 1.0 / 0}\n{foo: 1.0 / 1.0}\n{foo: 1.0 / 1}\n{foo: 1.0 / f64}\n{foo: 1.0 / i}\n{foo: 1.0 ^ 0}\n{foo: 1.0 ^ 1.0}\n{foo: 1.0 ^ 1}\n{foo: 1.0 ^ i}\n```\n\n----------------------------------------\n\nTITLE: List Access with Filtering and Grouping - Expr\nDESCRIPTION: This snippet further explores the `get` function combined with `filter` and `groupBy` functions for accessing elements from lists and arrays after applying filtering and grouping operations. It showcases complex data transformations and demonstrates how to access specific elements within the transformed data structures. It highlights the Expr language's capabilities in data manipulation and querying.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_61\n\nLANGUAGE: Expr\nCODE:\n```\nget(filter(list, true), i)\nget(groupBy(array, \"bar\"), i)\nget(groupBy(array, \"bar\"), ok)\nget(groupBy(array, #), f32)\nget(groupBy(array, #), f64)\nget(groupBy(array, #), foo)\nget(groupBy(array, #), i)\nget(groupBy(array, #), i64 * 0.5)\nget(groupBy(array, #), i64)\nget(groupBy(array, 0.5), ok)\nget(groupBy(array, 1), f32)\nget(groupBy(array, f64), i64)\nget(groupBy(array, false), findIndex(array, ok))\nget(groupBy(array, i), ok)\nget(groupBy(array, true), i32)\nget(groupBy(list, \"bar\"), i32)\nget(groupBy(list, #), f32 <= f64)\nget(groupBy(list, #), f32)\nget(groupBy(list, #), foo)\nget(groupBy(list, #), i)\nget(groupBy(list, #), i32)\nget(groupBy(list, #), i64)\nget(groupBy(list, #), int(f32))\nget(groupBy(list, #), reduce(array, foo))\nget(groupBy(list, #), score(1))\nget(groupBy(list, 0.5), ok)\nget(groupBy(list, 1), i32)\nget(groupBy(list, foo), i32)\n```\n\n----------------------------------------\n\nTITLE: Prime numbers calculation in Expr\nDESCRIPTION: This snippet calculates prime numbers within a given range (2 to 1000). It filters the numbers using a predicate that checks if any number between 2 and N-1 divides N without a remainder.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/examples.md#_snippet_8\n\nLANGUAGE: Expr\nCODE:\n```\n2..1000 | filter(let N = #; none(2..N-1, N % # == 0))\n```\n\n----------------------------------------\n\nTITLE: splitAfter Function in Expr\nDESCRIPTION: Illustrates the use of the `splitAfter` function to split a string into an array of substrings after each instance of a delimiter.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_28\n\nLANGUAGE: expr\nCODE:\n```\nsplitAfter(\"apple,orange,grape\", \",\") == [\"apple,\", \"orange,\", \"grape\"]\n```\n\nLANGUAGE: expr\nCODE:\n```\nsplitAfter(\"apple,orange,grape\", \",\", 2) == [\"apple,\", \"orange,grape\"]\n```\n\n----------------------------------------\n\nTITLE: String Manipulation - Expr\nDESCRIPTION: Shows example use of string manipulation functions in the Expr language, including fromBase64 and fromJSON functions with various inputs.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_115\n\nLANGUAGE: Expr\nCODE:\n```\nfromBase64(string(ok))\nfromBase64(toBase64(str))\nfromBase64(toJSON(nil))\nfromBase64(toJSON(ok))\nfromBase64(toJSON(true))\nfromBase64(type(add))\nfromBase64(type(greet))\nfromBase64(type(ok))\nfromJSON(string(0))\nfromJSON(string(1))\nfromJSON(string(1.0))\nfromJSON(string(f64))\nfromJSON(string(false))\nfromJSON(string(i))\nfromJSON(string(ok))\nfromJSON(string(true))\nfromJSON(toJSON(0))\nfromJSON(toJSON(1))\nfromJSON(toJSON(1.0))\nfromJSON(toJSON(array))\nfromJSON(toJSON(f64))\nfromJSON(toJSON(false))\nfromJSON(toJSON(foo))\nfromJSON(toJSON(foo)).add\nfromJSON(toJSON(list))\nfromJSON(toJSON(nil))\nfromJSON(toJSON(nil))?.[i].i()\nfromJSON(toJSON(ok))\nfromJSON(toJSON(str))\nfromJSON(toJSON(str)) contains str\nfromJSON(toJSON(true))\nfromJSON(toJSON(type(ok)))\n```\n\n----------------------------------------\n\nTITLE: Object Property Access and Operations\nDESCRIPTION: Demonstrates accessing properties of objects (maps) using both dot notation and bracket notation, including optional chaining. Covers scenarios with nested objects, different data types for properties, and conditional property access.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_130\n\nLANGUAGE: expr-lang\nCODE:\n```\n{\"bar\": \"bar\" <= \"foo\"}\n{\"bar\": \"bar\", \"bar\": half}.add\n{\"bar\": \"bar\", \"bar\": i}.Qux\n{\"bar\": \"bar\", \"bar\": i}.String\n{\"bar\": \"bar\", \"foo\": 0.5}.i64\n{\"bar\": \"bar\", \"foo\": i64}?.Qux\n{\"bar\": \"bar\", \"foo\": score}.f32\n{\"bar\": \"bar\"}.String?.foo\n{\"bar\": \"bar\"}.array\n{\"bar\": \"bar\"}.f64\n{\"bar\": \"bar\"}.greet\n{\"bar\": \"bar\"}.list\n{\"bar\": \"bar\"}.ok\n{\"bar\": \"bar\"}?.Qux\n{\"bar\": \"bar\"}?.array\n{\"bar\": \"bar\"}?.half\n{\"bar\": \"bar\"}?.list\n{\"bar\": \"foo\", \"bar\": div}.half\n{\"bar\": \"foo\", \"foo\": f32}.String\n{\"bar\": \"foo\", \"foo\": i64}.ok?.f64\n{\"bar\": \"foo\", \"foo\": ok}?.i64\n{\"bar\": \"foo\"}.Bar\n{\"bar\": \"foo\"}.f32\n{\"bar\": \"foo\"}.foo\n{\"bar\": \"foo\"}.half\n{\"bar\": \"foo\"}.i\n{\"bar\": \"foo\"}.i64\n{\"bar\": \"foo\"}?.String\n{\"bar\": \"foo\"}?.f32\n{\"bar\": \"foo\"}?.foo\n{\"bar\": \"foo\"}?.greet\n{\"bar\": \"foo\"}?.i\n{\"bar\": \"foo\"}?.i32\n{\"bar\": \"foo\"}?.i?.String()\n{\"bar\": \"foo\"}?.list\n{\"bar\": \"foo\"}?.ok\n```\n\n----------------------------------------\n\nTITLE: Boolean and Comparison Operations\nDESCRIPTION: These snippets illustrate boolean logic and comparison operations, including `!=`, `&&`, `||`, `==`, `contains`, `in`, `not in`, `matches`, `startsWith`, and `not startsWith` operators. The expressions involve various data types and nested property accesses.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_3\n\nLANGUAGE: Expr\nCODE:\n```\n$env?.[String]?.true not in array\n$env?.[add] != 1.0 && false\n$env?.[add] * f64 && false\n$env?.[foo] != 1.0 || true\n$env?.[foobar] != $env.i\n$env?.[foobar] != foo\n$env?.[foobar] != greet\n$env?.[foobar] != i\n$env?.[foobar] != list\n$env?.[foobar] == array\n$env?.[foobar] == f64\n$env?.[foobar] == foo\n$env?.[foobar] == list != $env\n$env?.[foobar] == ok\n$env?.[foobar] contains str\n$env?.[foobar] in $env?.[String]\n$env?.[foobar] in list\n$env?.[foobar] not in array\n$env?.[foobar] not in list\n$env?.[foobar] not matches str\n$env?.[foobar] not startsWith foo?.String()\n$env?.[foobar] not startsWith trim(str)\n$env?.[foobar] startsWith $env or $env\n```\n\n----------------------------------------\n\nTITLE: Bitwise AND NOT Operation in Expr\nDESCRIPTION: Demonstrates the bitwise AND NOT operation using the `bitnand` function in Expr. It takes two integer arguments and returns the result of the bitwise AND NOT.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_93\n\nLANGUAGE: expr\nCODE:\n```\nbitnand(0b1010, 0b1100) == 0b10\n```\n\n----------------------------------------\n\nTITLE: Evaluating Boolean Logic - Expr\nDESCRIPTION: These expressions demonstrate boolean logic operations, including equality, inequality, AND, OR, and the ternary conditional operator.  The expressions test various combinations of boolean values and data types to evaluate their truthiness.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_125\n\nLANGUAGE: expr\nCODE:\n```\ntrue != nil || true == true\ntrue != ok != ok\ntrue == ok == ok\ntrue ? 0.5 : i <= f32\ntrue ? 1 : foo?.Bar\ntrue ? 1 : ok or i64 == 0.5\ntrue ? add : foo?.Bar\ntrue ? array : 0.5 >= i32\ntrue ? array : foo.String\ntrue ? array : foo?.Bar\ntrue ? array : foo?.String\ntrue ? array : i32 ** f64\ntrue ? div : i64 ** 1 ^ i32\ntrue ? false : 0.5 > i\ntrue ? false : foo.Qux\ntrue ? foo : 0.5 + -1\ntrue ? foo : foo.Bar\ntrue ? foo : i64 / f32\ntrue ? greet : foo.Bar\ntrue ? greet : ok == ok\ntrue ? half : 0.5 / i32\ntrue ? half : foo.String\ntrue ? i : 1 * i64\ntrue ? i32 : i32 - f32\ntrue ? i32 : i32 >= f32\ntrue ? i64 : f64 != i\ntrue ? list : f32 != i\ntrue ? nil : foo.String\ntrue ? nil : foo?.String\ntrue ? nil : i32 != f64 + 1\ntrue ? ok : foo.Qux\ntrue ? ok : foo?.String\ntrue ? score : ok or f64 < f32\ntrue and nil not in list\ntrue and ok or ok\ntrue and true || ok\ntrue or 0.5 not in array\ntrue || f32 not in groupBy(list, #)\ntrue || false ? half : half\n```\n\n----------------------------------------\n\nTITLE: Remove Duplicates from Array Using uniq() in Expr\nDESCRIPTION: The `uniq()` function removes duplicate elements from an array, returning a new array with only unique values, preserving the original order of the first occurrence of each element.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_64\n\nLANGUAGE: expr\nCODE:\n```\nuniq([1, 2, 3, 2, 1]) == [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Expr f64 Bitwise XOR Operations\nDESCRIPTION: This code snippet includes expressions using the bitwise XOR operator (^) with f64 values. It shows how f64 values are combined with environment variables, arithmetic operations, and function calls using the XOR operator. It demonstrates various scenarios where f64 interacts with other types and values using bitwise XOR.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_87\n\nLANGUAGE: Expr\nCODE:\n```\nf64 ^ $env.f64\nf64 ^ $env.i\nf64 ^ $env?.f64\nf64 ^ $env?.i\nf64 ^ 0 - 1.0\nf64 ^ 0 / i\nf64 ^ 0 < 0\nf64 ^ 0 >= 1.0 ?: greet\nf64 ^ 1 + 1.0\nf64 ^ 1.0\nf64 ^ 1.0 != 1.0\nf64 ^ 1.0 != f64\nf64 ^ 1.0 ** 1.0\nf64 ^ 1.0 > 1\nf64 ^ 1.0 >= i\nf64 ^ array?.[i]\nf64 ^ f64\nf64 ^ f64 != $env\nf64 ^ f64 ** i\nf64 ^ f64 + 1.0\nf64 ^ find(array, ok)\nf64 ^ float(i)\nf64 ^ i\nf64 ^ i ** 1.0\nf64 ^ i ** i\nf64 ^ i >= 0 || $env\nf64 ^ i not in array\nf64 ^ len($env)\nf64 ^ median(0)\nf64 ^ sum(array)\n```\n\n----------------------------------------\n\nTITLE: Range and List Access with Property Access - Expr\nDESCRIPTION: This snippet demonstrates accessing elements in lists with property access on those elements using `.Bar`, `.Qux`, and `.String`. It covers different index types, including integer ranges (e.g., `i .. i32`, `i64 .. 1`) and expressions involving arithmetic operations. It shows how to chain list access with property access and optional chaining (`?.`) for null-safe property retrieval.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_62\n\nLANGUAGE: Expr\nCODE:\n```\nget(i .. 1, 1 * 1)\nget(i .. i32, i)\nget(i32 .. i, i64)\nget(i64 .. 1, i32)\nget(i64 .. i, i32)\nget(i64 .. i64, i64)\nget(list, -1)\nget(list, -i)\nget(list, -i64)\nget(list, 1 * 1)\nget(list, 1 - 1)\nget(list, 1 - i)\nget(list, 1) != foo\nget(list, 1).Bar\nget(list, 1).Qux\nget(list, 1).String\nget(list, 1).String()\nget(list, 1)?.Bar\nget(list, 1)?.Qux\nget(list, 1)?.String\nget(list, 1)?.String()\nget(list, bitshr(i, i32))\nget(list, first(array))\nget(list, get(array, 1))\nget(list, get(array, i64))\nget(list, i % 1)\nget(list, i)\nget(list, i).Bar\nget(list, i).Qux\nget(list, i).String\nget(list, i)?.Bar\nget(list, i)?.Qux\nget(list, i)?.String\nget(list, i)?.String()\nget(list, i32 * i32)\nget(list, i32 - i32)\nget(list, i32)\nget(list, i32).Bar\nget(list, i32).Qux\nget(list, i32).String\nget(list, i32)?.Bar\nget(list, i32)?.Qux\nget(list, i32)?.String\nget(list, i32)?.String()\nget(list, i64 * 1)\nget(list, i64 * i)\nget(list, i64 - 1)\nget(list, i64)\nget(list, i64).Bar\nget(list, i64).Qux\nget(list, i64).String\nget(list, i64)?.Bar\nget(list, i64)?.Qux\nget(list, i64)?.String\nget(list, i64)?.String()\n```\n\n----------------------------------------\n\nTITLE: Variable Assignment (`let`) in Expr\nDESCRIPTION: This snippet demonstrates variable assignment using the `let` keyword in the Expr language, followed by usage of the variable in an expression. It also showcases accessing properties and checking conditions with the assigned variables.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_171\n\nLANGUAGE: Expr\nCODE:\n```\nlet foobar = $env not in array; foobar\nlet foobar = $env.f64; i < foobar\nlet foobar = $env.list; foobar\nlet foobar = $env.str; foobar\nlet foobar = $env; foobar == foobar\nlet foobar = $env; foobar.Bar\nlet foobar = $env; foobar.String\nlet foobar = $env; foobar.add\nlet foobar = $env; foobar.greet\nlet foobar = $env; foobar.ok\nlet foobar = $env; foobar.str\nlet foobar = $env; foobar?.[str]\nlet foobar = $env; foobar?.add\nlet foobar = $env; foobar?.foobar\nlet foobar = $env; foobar?.greet\nlet foobar = $env; foobar?.i\nlet foobar = $env; foobar?.list\nlet foobar = $env; foobar?.str\nlet foobar = $env?.[Bar]; foobar?.list\nlet foobar = $env?.[String]; foobar\nlet foobar = $env?.[String]; foobar?.[str]\nlet foobar = $env?.f64; foobar > foobar\nlet foobar = 0 + f64; foobar\nlet foobar = 0; foobar <= foobar\nlet foobar = 1 * 1.0; foobar\nlet foobar = 1.0 != 1.0; foobar\nlet foobar = 1.0; foobar * foobar\nlet foobar = 1; foobar % foobar\n```\n\n----------------------------------------\n\nTITLE: Sort Function Usage in Expr\nDESCRIPTION: Presents various examples of using the `sort` function with different data types, expressions, and pipeline operations. It also uses conditional statements and chained operations.  The sort function takes a list as an argument and returns a new list with the elements sorted in ascending order.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_209\n\nLANGUAGE: Expr\nCODE:\n```\nsort($env | map(#index))\nsort($env | map(0))\nsort($env) | all(#.Bar)\nsort($env) | all(#.add)\nsort($env) | all(#.ok)\nsort($env) | all(.str)\nsort($env) | all(true)\nsort($env) | any(#)\nsort($env) | any(#.f64)\nsort($env) | any(.String)\nsort($env) | any(.array)\nsort($env) | concat(list)\nsort($env) | count(#)\nsort($env) | count(#.foo)\nsort($env) | count(#.i == 0)\nsort($env) | count($env)\nsort($env) | filter(#)\nsort($env) | filter(#.i)\nsort($env) | find(#)\nsort($env) | find(#.Bar)\nsort($env) | find(#.list)\nsort($env) | find(false)\nsort($env) | findIndex(#)\nsort($env) | findIndex(#.add)\nsort($env) | findIndex(#.array)\nsort($env) | findIndex(.String)\nsort($env) | findIndex(.foo)\nsort($env) | findIndex(.ok)\nsort($env) | findIndex(ok)\nsort($env) | findLast(#)\nsort($env) | findLast(#.array)\nsort($env) | findLast(#.list?.foo(#))\nsort($env) | findLastIndex(#)\nsort($env) | findLastIndex(#.list)\nsort($env) | findLastIndex(.Bar)\nsort($env) | groupBy(#)\nsort($env) | groupBy(#.add)\nsort($env) | groupBy(#.greet)\nsort($env) | groupBy(#?.foo(i))\nsort($env) | groupBy(.array)\nsort($env) | groupBy(add)\nsort($env) | groupBy(i)\nsort($env) | map(#)\nsort($env) | map(#.f64)\nsort($env) | map(.foo)\nsort($env) | map(.list)\nsort($env) | map(1.0)\nsort($env) | map(i)\nsort($env) | map(true)\nsort($env) | mean(1.0)\nsort($env) | none(#)\nsort($env) | none(#.ok)\nsort($env) | none($env)\nsort($env) | none(.String)\nsort($env) | none(.array)\nsort($env) | one(#.f64)\nsort($env) | one(#.list)\nsort($env) | one(#.ok)\nsort($env) | one(#.ok.nil)\nsort($env) | one($env)\nsort($env) | one(.f64)\nsort($env) | one(.f64?.[.greet])\nsort($env) | one(.list)\nsort($env) | one(ok)\nsort($env) | reduce(#.String, nil)\nsort($env) | reduce(foo, foo)\nsort($env) | sortBy(#)\nsort($env) | sortBy(1.0)\nsort($env) | sortBy(i)\nsort($env) | sortBy(str)\nsort($env) | sum(#.greet)\nsort($env) | sum(#.str?.String)\nsort($env) | sum(.array)\nsort($env) | sum(false)\nsort($env) | sum(foo)\nsort($env)?.[i]\nsort($env)?.[i].add()\nsort($env)[:]\nsort($env.array)\nsort($env?.Bar)\nsort($env?.Bar?.greet)\nsort($env?.String)\nsort($env?.[Bar])\nsort($env?.[Bar]?.[array])\nsort($env?.[String])\nsort($env?.[foobar])\nsort($env?.[nil])\nsort($env?.[str])\nsort($env?.array)\nsort($env?.false)\nsort($env?.foobar)\nsort($env?.foobar?.greet)\nsort($env?.list | reduce(#acc))\nsort($env?.nil)\nsort(1..i)\nsort([$env])\nsort([0 .. 0])\nsort([0])\nsort([1.0])\nsort([1])\nsort([add])\nsort([array])\nsort([false])\nsort([foo])\nsort([i])\nsort([list])\nsort([nil])\nsort([ok])\nsort([str])\nsort([true])\nsort(array | map(#))\nsort(array | sortBy(#))\nsort(array)\nsort(array) == list\nsort(array) | find(true)\nsort(array) | findIndex($env?.ok)\nsort(array) | findLastIndex(false)\nsort(array) | get(i)\nsort(array) | groupBy(#)\nsort(array) | groupBy(str)\nsort(array) | map(#)\nsort(array) | map(0)\nsort(array) | map(1.0)\nsort(array) | map(list)\nsort(array) | one(false)\nsort(array) | reduce($env)\nsort(array) | reduce(foo)\nsort(array) | reduce(true, 1.0)\nsort(array) | sortBy(1)\nsort(array)?.[i]\nsort(array[0:])\nsort(concat(array))\nsort(false ? true : 0)\nsort(false ?: 1.0)\nsort(false ?: i)\nsort(filter($env, false))\nsort(first($env))\nsort(if false { 1 } else { 1.0 })\nsort(if false { 1.0 } else { 1 })\nsort(if ok { ok } else { 1.0 })\nsort(if true { add } else { str })\nsort(if true { f64 } else { $env })\nsort(if true { greet } else { 1 })\nsort(keys($env))\nsort(last($env))\nsort(list | map(#.Bar))\nsort(map(array, #))\nsort(map(array, 0))\nsort(map(array, 1.0))\nsort(map(list, str))\nsort(max($env))\nsort(max(array))\nsort(max(array, 1.0))\nsort(mean(array))\nsort(median(array))\nsort(min($env))\nsort(min(array))\nsort(min(array, 1.0))\nsort(ok ? 1.0 : $env)\nsort(ok ? list : str)\nsort(ok ?: 1.0)\nsort(ok ?: list)\nsort(reduce(array, array))\nsort(reverse(array))\nsort(sort($env))\nsort(sort(array))\nsort(sortBy(array, 1.0))\nsort(toPairs($env))\nsort(true ? i : 1.0)\nsort({foo: 1.0}.add)\nsort({foo: str}.greet)\n```\n\n----------------------------------------\n\nTITLE: Last Function Tests\nDESCRIPTION: This snippet focuses on tests for the `last()` function and its usage in combination with various functions and data types in the Expr language. These expressions are designed to validate the function's behavior with range, arrays, filtered lists, groupBy results, map results and conditional results.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_71\n\nLANGUAGE: expr\nCODE:\n```\nlast(1 .. 1)\nlast(1 .. i)\nlast([0.5])\nlast([f32, list])\nlast([list, list])\nlast(array)\nlast(array) != int(i64)\nlast(array) + f64\nlast(array) - f32\nlast(array) - i64\nlast(array) .. i32\nlast(array) / f32\nlast(array) <= i32\nlast(array) == f32\nlast(array) > f32 * i64\nlast(array) >= f64\nlast(false ? \"foo\" : true)\nlast(false ? 0.5 : \"bar\")\nlast(false ? 1 : foo)?.div\nlast(false ? div : score)\nlast(false ? f64 : false)\nlast(filter(array, false))\nlast(filter(array, ok))\nlast(filter(list, true))\nlast(groupBy(array, foo).Qux)\nlast(groupBy(array, i32).Qux)\nlast(groupBy(list, #).list)\nlast(groupBy(list, #)?.Qux)\nlast(groupBy(list, #)?.ok)\nlast(i32 .. 1)\nlast(i32 .. i64)\nlast(i64 .. 1)\nlast(list)\nlast(list).Bar\nlast(list).Qux\nlast(list).String\nlast(list).String()\nlast(list)?.Bar\nlast(list)?.Qux\nlast(list)?.String\nlast(list)?.String()\nlast(list[1:i64])\nlast(map(array, #))\nlast(map(array, 1))\nlast(map(array, array))\nlast(map(array, foo))\nlast(map(array, i))\nlast(map(list, \"foo\"))\nlast(map(list, #))\nlast(map(list, 1))\nlast(map(list, false))\nlast(map(list, half))\nlast(map(list, i32))\nlast(map(list, i64))\nlast(map(list, ok))\nlast(ok ? \"bar\" : true)\nlast(ok ? \"foo\" : f64)\nlast(ok ? 0.5 : \"foo\")\nlast(ok ? 0.5 : list)\nlast(ok ? 1 : add)\nlast(ok ? 1 : half)\nlast(ok ? array : array)\nlast(ok ? array : ok)\nlast(ok ? f32 : 0.5)\nlast(ok ? greet : 1)\nlast(ok ? i32 : array)\nlast(ok ? i64 : add)\nlast(ok ? ok : 0.5)\nlast(reduce(array, list))\nlast(reduce(list, array))\nlast(sort(array))\nlast(true ? \"bar\" : half)\nlast(true ? add : list)\nlast(true ? foo : 1)\nlast(true ? greet : true)\nlast(true ? ok : 1)\n```\n\n----------------------------------------\n\nTITLE: Expr groupBy with environment variables and properties\nDESCRIPTION: Demonstrates grouping based on comparisons involving environment variables and accessing their properties using direct and safe navigation.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_138\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(list, $env != f64)\ngroupBy(list, $env == add)\ngroupBy(list, $env == greet)\ngroupBy(list, $env.f64)\ngroupBy(list, $env.foo)\ngroupBy(list, $env.i)\ngroupBy(list, $env.str)\ngroupBy(list, $env?.[String])\ngroupBy(list, $env?.f64)\ngroupBy(list, $env?.foo)\ngroupBy(list, $env?.foobar)\n```\n\n----------------------------------------\n\nTITLE: Accessing Environment Variables and Methods\nDESCRIPTION: These examples demonstrate how to access values from the environment using `$env` and call methods on those values. The `?.` operator is used for safe navigation to prevent errors if a value is null.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_2\n\nLANGUAGE: Expr\nCODE:\n```\n$env?.[String]?.reduce(1.0)\n$env?.[String]?.reduce(foobar)\n$env?.[String]?.splitAfter(true)\n$env?.[String]?.str\n$env?.[String]?.str not startsWith str\n$env?.[String]?.str()\n$env?.[String]?.str().list\n$env?.[String]?.str()?.array\n$env?.[String]?.str(foo)\n$env?.[String]?.str(foobar)\n$env?.[String]?.str(foobar?.array)\n$env?.[String]?.str.add\n$env?.[String]?.str.array\n$env?.[String]?.str?.Bar\n$env?.[String]?.str?.String\n$env?.[String]?.str?.[add]\n$env?.[String]?.str?.add\n$env?.[String]?.str?.f64()\n$env?.[String]?.str?.f64(false)?.greet\n$env?.[String]?.sum(add)\n$env?.[String]?.take(String)?.str\n$env?.[String]?.trimPrefix(add)\n```\n\n----------------------------------------\n\nTITLE: Array 'any' Conditional Check\nDESCRIPTION: Checks if any element in the array satisfies the condition that it's less than another element. This operation filters and returns a boolean.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_45\n\nLANGUAGE: Expr\nCODE:\n```\narray | any(# < #)\n```\n\n----------------------------------------\n\nTITLE: String Uppercasing\nDESCRIPTION: Example showcasing the use of the `upper` function to convert a string to uppercase. It operates on the `str` variable to validate the string uppercasing functionality.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_28\n\nLANGUAGE: Expr\nCODE:\n```\n[upper(str)]\n```\n\n----------------------------------------\n\nTITLE: Optional Chaining Operator in Expr\nDESCRIPTION: Demonstrates the usage of the `?.` operator for safe access to fields of a struct or items of a map that might be nil.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_5\n\nLANGUAGE: expr\nCODE:\n```\nauthor.User?.Name\n```\n\n----------------------------------------\n\nTITLE: Logical NOT with Collection Operations (Expr)\nDESCRIPTION: This snippet tests the logical NOT operator (!) with operations on arrays and lists in the Expr language, including membership tests (in, not in), and functions like all, any, none, and reduce. It also includes comparisons between different collection types (array, list) and nil.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_3\n\nLANGUAGE: Expr\nCODE:\n```\n!!all(array, ok)\n!(0.5 in array)\n!(0.5 not in array)\n!(1 in array)\n!(1 not in array)\n!(f32 in array)\n!(f32 not in array)\n!(f64 in array)\n!(f64 not in array)\n!(i in array)\n!(i not in array)\n!(i32 in array)\n!(i32 not in array)\n!(i64 in array)\n!(i64 in array)\n!(list != array)\n!(list != list)\n!(list != nil)\n!(list == array)\n!(list == list)\n!(list == nil)\n!(nil in array)\n!(nil in list)\n!(nil not in array)\n!(nil not in list)\n!all(array, false)\n!all(array, ok)\n!all(array, true)\n!all(list, false)\n!all(list, ok)\n!all(list, true)\n!any(array, i == #)\n!any(array, ok)\n!any(array, true)\n!any(list, false)\n!any(list, ok)\n!any(list, true)\n!none(array, # > #)\n!none(array, # >= #)\n!none(array, false)\n!none(array, ok)\n!none(list, ok)\n!none(list, true)\n!none(list, true)\n!one(array, false)\n!one(array, ok)\n!one(array, true)\n!one(list, false)\n!one(list, ok)\n!one(list, true)\n!reduce(array, false)\n!reduce(array, ok)\n!reduce(array, true)\n!reduce(list, # != #)\n```\n\n----------------------------------------\n\nTITLE: Accessing Environment Variables\nDESCRIPTION: Demonstrates how to access environment variables using the $env keyword, including safe navigation with $env?.variable to handle potentially missing variables.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_12\n\nLANGUAGE: EXPR\nCODE:\n```\n1 - $env.f64\n1 - $env.i\n1 - $env?.f64\n1 - $env?.i\n1 / $env.f64\n1 / $env.i\n1 / $env?.f64\n1 / $env?.i\n1 < $env.f64\n1 < $env.i\n1 < $env?.f64\n1 < $env?.i\n1 <= $env.f64\n1 <= $env.i\n1 <= $env?.f64\n1 <= $env?.i\n1 == $env.f64\n1 == $env.i\n1 == $env?.f64\n1 == $env?.i\n1 > $env.f64\n1 > $env.i\n1 > $env?.f64\n1 > $env?.i\n1 >= $env.f64\n1 >= $env.i\n1 >= $env?.f64\n1 >= $env?.i\n1 ^ $env.f64\n1 ^ $env.i\n1 ^ $env?.f64\n1 ^ $env?.i\n1.0 * $env.f64\n1.0 * $env.i\n1.0 * $env?.f64\n1.0 * $env?.i\n1.0 ** $env.f64\n1.0 ** $env.i\n1.0 ** $env?.f64\n1.0 ** $env?.i\n1.0 + $env.f64\n1.0 + $env.i\n1.0 + $env?.f64\n1.0 + $env?.i\n1.0 - $env.f64\n1.0 - $env.i\n1.0 - $env?.f64\n1.0 - $env?.i\n1.0 / $env.f64\n1.0 / $env.i\n1.0 / $env?.f64\n1.0 / $env?.i\n1.0 < $env.f64\n1.0 < $env.i\n1.0 < $env?.f64\n1.0 < $env?.i\n1.0 <= $env.f64\n1.0 <= $env.i\n1.0 <= $env?.f64\n1.0 <= $env?.i\n1.0 == $env.f64\n1.0 == $env.i\n1.0 == $env?.f64\n1.0 == $env?.i\n1.0 > $env.f64\n1.0 > $env.i\n1.0 > $env?.f64\n1.0 > $env?.i\n1.0 >= $env.f64\n1.0 >= $env.i\n1.0 >= $env?.f64\n1.0 >= $env?.i\n1.0 ^ $env.f64\n1.0 ^ $env.i\n1.0 ^ $env?.f64\n1.0 ^ $env?.i\n```\n\n----------------------------------------\n\nTITLE: Expr: Ternary operator examples\nDESCRIPTION: This snippet demonstrates the ternary operator in the Expr language. It shows different variations of the ternary operator, including conditional data access, returning default values or performing calculations, and optional chaining.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_248\n\nLANGUAGE: Expr\nCODE:\n```\ntrue ? $env : $env.f64\ntrue ? $env : $env.foo\ntrue ? $env : $env.str\ntrue ? $env : $env?.Bar\ntrue ? $env : $env?.[array]\ntrue ? $env : foo.String\ntrue ? 0 : $env?.Bar?.greet\ntrue ? 0 : $env?.String\ntrue ? 0 : $env?.[Bar]\ntrue ? 0 : $env[:list(foobar)]\ntrue ? 1 : $env?.i\ntrue ? 1 : 1.0 / 1 == f64\ntrue ? 1.0 : $env.greet\ntrue ? 1.0 : $env.str\ntrue ? 1.0 : $env?.[i]\ntrue ? 1.0 : $env?.[str]\ntrue ? 1.0 : $env?.ok\ntrue ? 1.0 : str >= $env?.[Bar]\ntrue ? add : $env ^ 0 != $env\ntrue ? add : $env.f64\ntrue ? add : $env?.Bar\ntrue ? array : $env?.foo\ntrue ? array : foo.String\ntrue ? f64 : $env.add\ntrue ? f64 : $env?.[i]\ntrue ? f64 : $env?.greet\ntrue ? f64 : $env?.i\ntrue ? f64 : $env[foo?.[String]:]\ntrue ? false : $env | count($env)\ntrue ? false : $env?.f64\ntrue ? false : array != array\ntrue ? foo : $env.array\ntrue ? foo : $env.foo\ntrue ? foo : $env?.[String]\ntrue ? foo : $env?.[str]\ntrue ? foo : $env?.array\ntrue ? foo : $env?.str\ntrue ? foo : 1.0 + i\ntrue ? foo : foo?.Bar\ntrue ? foo : i .. i\ntrue ? greet : $env | sum(.greet)\ntrue ? greet : $env.greet\ntrue ? greet : $env?.[add].foo\ntrue ? greet : $env?.str\ntrue ? greet : nil != none($env, #)\ntrue ? i : $env?.[Bar]\ntrue ? list : $env?.String\ntrue ? list : $env?.[greet]\ntrue ? list : $env?.[ok]\ntrue ? list : $env?.ok\ntrue ? list : foo.Bar\ntrue ? list : foo?.Bar\ntrue ? list : foo?.String\ntrue ? nil : $env.str\ntrue ? nil : $env?.[f64]\ntrue ? nil : $env?.foo\ntrue ? nil : foo.Bar\ntrue ? ok : $env.foo\ntrue ? ok : $env?.[str]\ntrue ? ok : foo.String\ntrue ? str : foo?.Bar\ntrue ? str : i + i\ntrue ? true : $env?.String.str\ntrue ? true : $env?.greet\ntrue ? true : 1.0 == $env?.Bar\ntrue ? true : array | date(false, foo)\ntrue ? true : foo?.Bar\ntrue ? true : list | sum(#)\n\n```\n\n----------------------------------------\n\nTITLE: String Conversion with List Manipulation Functions\nDESCRIPTION: This snippet tests string conversion when using list manipulation functions such as `find`, `findIndex`, `findLast`, `findLastIndex`, `first`, and `flatten`. It assesses the proper handling and string representation of outputs from these list-oriented operations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_231\n\nLANGUAGE: Expr\nCODE:\n```\nstring(find(array, false))\nstring(find(list, true))\nstring(findIndex($env, true))\nstring(findIndex(list, false))\nstring(findLast(list, ok))\nstring(findLastIndex($env, false))\nstring(findLastIndex(list, false))\nstring(findLastIndex(list, ok))\nstring(first($env))\nstring(first(array))\nstring(first(list))\nstring(flatten(list))\n```\n\n----------------------------------------\n\nTITLE: Mapping with literals and array manipulation in Expr\nDESCRIPTION: Applies the map function with literal values, arithmetic operations, and functions to transform items in an array. Demonstrates how to perform complex calculations or apply boolean values across the data.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_187\n\nLANGUAGE: Expr\nCODE:\n```\nmap(array, 0 != #)\nmap(array, 0 - #)\nmap(array, 0 | bitxor(#))\nmap(array, 0) | find(false)\n```\n\n----------------------------------------\n\nTITLE: Modulo Operations with 'i' in Expr\nDESCRIPTION: Demonstrates modulo operations involving the variable 'i' with various operands, including environment variables, array access, and expressions. It utilizes comparison operators.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_147\n\nLANGUAGE: Expr\nCODE:\n```\ni % $env.i\ni % $env?.i\ni % 1 != 1.0\ni % 1 == i\ni % array?.[i]\ni % i\ni % i < i\ni % i <= 1\ni % i <= 1.0\ni % i == i ^ i\ni % len(str)\n```\n\n----------------------------------------\n\nTITLE: Expr: Logical OR examples using short-circuit evaluation\nDESCRIPTION: This snippet demonstrates short-circuiting in the OR (||) operations.  It illustrates combinations of logical conditions with variable access, function calls, and list operations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_255\n\nLANGUAGE: Expr\nCODE:\n```\ntrue || $env != 1.0 - $env\ntrue || $env != i\ntrue || $env == greet\ntrue || $env contains str\ntrue || $env in str\ntrue || $env not contains $env?.[foo]\ntrue || $env.ok\ntrue || $env?.Bar\ntrue || $env?.Bar()\ntrue || $env?.Bar?.i()\ntrue || $env?.String\ntrue || $env?.String()\ntrue || $env?.String(false > foobar, array(foobar))\ntrue || $env?.String(map(foobar | findIndex(#.str), .greet))\ntrue || $env?.String(reduce(foobar, #.list).i)\ntrue || $env?.String?.list\ntrue || $env?.[Bar(nil, 0)]\ntrue || $env?.[Bar]\ntrue || $env?.[String]\ntrue || $env?.[add]\ntrue || $env?.[add].f64\ntrue || $env?.[add].f64.list\ntrue || $env?.[array?.array()]\ntrue || $env?.[array]\ntrue || $env?.[f64]\ntrue || $env?.[foo]\ntrue || $env?.[foobar | findIndex(add)]\ntrue || $env?.[foobar]\ntrue || $env?.[greet]\ntrue || $env?.[i]\ntrue || $env?.[list]\ntrue || $env?.[ok]\ntrue || $env?.[ok]?.[ok]\ntrue || $env?.[str]\ntrue || $env?.foobar\ntrue || $env?.ok\ntrue || $env?.reduce($env)\n\n```\n\n----------------------------------------\n\nTITLE: Array Reduction Operation in Expr\nDESCRIPTION: Demonstrates the use of the `reduce` function in Expr to apply different operations on an array. The function takes an array and a value/expression as input, and reduces the array to a single value based on the operation provided.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_61\n\nLANGUAGE: Expr\nCODE:\n```\narray | reduce(0 == #)\narray | reduce(0)\narray | reduce(0, 0)\narray | reduce(0, 1.0)\narray | reduce(0, foo)\narray | reduce(0, i)\narray | reduce(0, list)\narray | reduce(0, true)\narray | reduce(1)\narray | reduce(1, 0)\narray | reduce(1, 1.0)\narray | reduce(1, add)\narray | reduce(1, false)\narray | reduce(1, foo)\narray | reduce(1, nil)\narray | reduce(1, ok)\narray | reduce(1, str)\narray | reduce(1.0 * 1)\narray | reduce(1.0 > 1.0)\narray | reduce(1.0)\narray | reduce(1.0) != f64\narray | reduce(1.0) / f64\narray | reduce(1.0) < i <= f64\narray | reduce(1.0, $env)\narray | reduce(1.0, 0)\narray | reduce(1.0, 1)\narray | reduce(1.0, 1.0)\narray | reduce(1.0, array)\narray | reduce(1.0, f64)\narray | reduce(1.0, false)\narray | reduce(1.0, foo)\narray | reduce(1.0, list)\narray | reduce(1.0, nil)\narray | reduce(1.0, ok)\narray | reduce(1.0, true)\narray | reduce(add)\narray | reduce(add, $env)\narray | reduce(add, 0)\narray | reduce(add, 1.0)\narray | reduce(add, array)\narray | reduce(add, f64)\narray | reduce(add, false)\narray | reduce(add, list)\narray | reduce(add, nil)\narray | reduce(add, ok)\narray | reduce(add, str)\narray | reduce(array)\narray | reduce(array) | reduce(false)\narray | reduce(array, $env)\narray | reduce(array, 0)\narray | reduce(array, 1.0)\narray | reduce(array, f64)\narray | reduce(array, foo)\narray | reduce(array, greet)\narray | reduce(array, list)\narray | reduce(array, nil)\narray | reduce(array, ok)\narray | reduce(f64)\narray | reduce(f64, 0)\narray | reduce(f64, 1)\narray | reduce(f64, 1.0)\narray | reduce(f64, array)\narray | reduce(f64, f64)\narray | reduce(f64, false)\narray | reduce(f64, foo)\narray | reduce(f64, i)\narray | reduce(f64, list)\narray | reduce(f64, nil)\narray | reduce(f64, true)\narray | reduce(false)\narray | reduce(false, $env)\narray | reduce(false, 1)\narray | reduce(false, 1.0)\narray | reduce(false, add)\narray | reduce(false, false)\narray | reduce(false, foo)\narray | reduce(false, i)\narray | reduce(false, list)\narray | reduce(false, nil)\narray | reduce(false, true)\narray | reduce(foo)\narray | reduce(foo, $env)\narray | reduce(foo, 0)\narray | reduce(foo, 1)\narray | reduce(foo, 1.0)\narray | reduce(foo, add)\narray | reduce(foo, array)\narray | reduce(foo, f64)\narray | reduce(foo, foo)\narray | reduce(foo, i)\narray | reduce(foo, list)\narray | reduce(foo, nil)\narray | reduce(foo, ok)\narray | reduce(foo, str)\narray | reduce(foo, true)\narray | reduce(greet)\narray | reduce(greet, 1.0)\narray | reduce(greet, array)\narray | reduce(greet, false)\narray | reduce(greet, foo)\narray | reduce(greet, greet)\narray | reduce(greet, i)\narray | reduce(greet, str)\narray | reduce(greet, true)\narray | reduce(i > 1)\narray | reduce(i)\narray | reduce(i, $env)\narray | reduce(i, 0)\narray | reduce(i, 1)\narray | reduce(i, 1.0)\narray | reduce(i, false)\narray | reduce(i, foo)\narray | reduce(i, list)\narray | reduce(i, nil)\narray | reduce(i, ok)\narray | reduce(list)\narray | reduce(list, $env)\narray | reduce(list, 0)\narray | reduce(list, 1.0)\narray | reduce(list, foo)\narray | reduce(list, i)\narray | reduce(list, list)\narray | reduce(list, nil)\narray | reduce(list, ok)\narray | reduce(list, ok) | all(true)\narray | reduce(list, true)\narray | reduce(median(0))\narray | reduce(nil != #)\narray | reduce(ok)\narray | reduce(ok, $env)\narray | reduce(ok, 0)\narray | reduce(ok, 1.0)\narray | reduce(ok, add)\narray | reduce(ok, false)\narray | reduce(ok, foo)\narray | reduce(ok, greet)\narray | reduce(ok, list)\narray | reduce(ok, nil)\narray | reduce(ok, true)\narray | reduce(str)\narray | reduce(str) | greet()\narray | reduce(str, $env)\narray | reduce(str, 1)\narray | reduce(str, 1.0)\narray | reduce(str, abs(1))\narray | reduce(str, add)\narray | reduce(str, foo)\narray | reduce(str, greet)\narray | reduce(str, i)\narray | reduce(str, list)\narray | reduce(str, nil)\narray | reduce(string(add))\narray | reduce(true and true)\narray | reduce(true)\narray | reduce(true, $env)\narray | reduce(true, 1)\narray | reduce(true, 1.0)\narray | reduce(true, array)\narray | reduce(true, foo)\narray | reduce(true, i)\narray | reduce(true, nil)\narray | reduce(true, ok)\narray | reduce(true, true)\n```\n\n----------------------------------------\n\nTITLE: Mapping with conditional operators in Expr\nDESCRIPTION: Demonstrates the usage of the `map` function, applying expressions that involve conditional operators to transform each item.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_185\n\nLANGUAGE: Expr\nCODE:\n```\nmap(array, $env && true)\nmap(array, $env == #)\nmap(array, $env == true)\n```\n\n----------------------------------------\n\nTITLE: Compile Expr with Static Typing in Go\nDESCRIPTION: This Go code demonstrates how to compile an Expr expression with static typing. It tries to compile the expression `name + age` and expects an error because `name` is a string and `age` is an integer, leading to a type mismatch.\nSOURCE: https://github.com/expr-lang/expr/blob/master/README.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\nout, err := expr.Compile(`name + age`)\n// err: invalid operation + (mismatched types string and int)\n// | name + age\n// | .....^\n```\n\n----------------------------------------\n\nTITLE: Type Checking for Lists in Expr\nDESCRIPTION: These examples demonstrate how the `type` function infers the data type of a list or dictionary in the Expr language. The function checks if a list contains a certain type or if a variable is nil, ok, or a string.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_264\n\nLANGUAGE: Expr\nCODE:\n```\ntype({foo: list})\ntype({foo: nil})\ntype({foo: ok, foo: 0})\ntype({foo: ok})\ntype({foo: str})\ntype({foo: true})\n```\n\n----------------------------------------\n\nTITLE: Defining Struct as Expr Environment in Go\nDESCRIPTION: This code snippet demonstrates defining a Go struct to be used as an environment for expr. It includes fields with different types and a struct tag to rename a field for use in expressions. The `time` package is used for `time.Time`.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/environment.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype Env struct {\n    UpdatedAt time.Time\n    Posts     []Post\n    Map       map[string]string `expr:\"tags\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Counting with Map and Conditional Operations in Expr\nDESCRIPTION: This snippet shows the count function used in combination with the 'map' function to transform arrays and lists before counting.  It also demonstrates the use of a ternary operator (ok ? array : i64).\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_32\n\nLANGUAGE: Expr\nCODE:\n```\ncount(map(array, #), # == i32)\ncount(map(array, #), not true)\ncount(map(array, #), ok)\ncount(map(array, false), #)\ncount(map(array, i), ok)\ncount(map(array, i32), 1 == #)\ncount(map(array, i64), f64 != nil)\ncount(map(array, ok), !#)\ncount(map(list, 0.5), \"bar\" == \"foo\")\ncount(map(list, div), ok)\ncount(map(list, f32), # == #)\ncount(map(list, greet), ok)\ncount(map(list, i32), # != i64)\ncount(map(list, ok), #)\ncount(map(list, ok), 0.5 <= i64)\ncount(ok ? array : i64, # > 0.5)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple Patcher\nDESCRIPTION: Defines a `FooPatcher` that implements the `Visit` method to replace an identifier node with a constant integer node using `ast.Patch`. It checks if a node is an identifier with the value \"foo\" and, if so, replaces it with an `ast.IntegerNode` representing the value 42.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/patch.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype FooPatcher struct{}\n\nfunc (FooPatcher) Visit(node *ast.Node) {\n    if n, ok := (*node).(*ast.IdentifierNode); ok && n.Value == \"foo\" {\n        // highlight-next-line\n        ast.Patch(node, &ast.IntegerNode{Value: 42})\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise Operations and Flags Decoding in Expr\nDESCRIPTION: This snippet demonstrates bitwise operations for decoding user permissions based on flags. It filters a list of flags based on whether they are enabled in a given user's permissions using a bitwise AND operation.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/examples.md#_snippet_3\n\nLANGUAGE: Expr\nCODE:\n```\nlet flags = [\n  {name: \"read\", value: 0b0001},\n  {name: \"write\", value: 0b0010},\n  {name: \"execute\", value: 0b0100},\n  {name: \"admin\", value: 0b1000}\n];\n\nlet userPermissions = 0b1011;\n\nflags\n| filter(userPermissions | bitand(.value) != 0)\n| map(.name)\n```\n\n----------------------------------------\n\nTITLE: Find Max with chained functions in Expr\nDESCRIPTION: Demonstrates using the `max` function with chained property accesses and optional calls. This shows how to get a property of properties using dot notation.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_192\n\nLANGUAGE: Expr\nCODE:\n```\nmax($env).Bar\nmax($env).Bar?.i().str\nmax($env).String\nmax($env).add\nmax($env).array\n```\n\n----------------------------------------\n\nTITLE: Scoring Expressions in Expr\nDESCRIPTION: This snippet demonstrates the usage of the 'score' function with a variety of expressions, showcasing different operations, data types, and function calls within the Expr language. It covers arithmetic operations, conditional logic, collection functions, and type conversions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_110\n\nLANGUAGE: Expr\nCODE:\n```\nscore(bitushr(1, i))\nscore(count(array, false))\nscore(count(array, ok))\nscore(count(array, true))\nscore(count(list, ok))\nscore(false ? f64 : 1)\nscore(false ? foo : 1)\nscore(find(array, i != #))\nscore(find(array, ok))\nscore(find(array, true))\nscore(findIndex(array, ok))\nscore(findIndex(array, true))\nscore(findIndex(list, true))\nscore(findLast(array, true))\nscore(findLastIndex(array, true))\nscore(findLastIndex(list, ok))\nscore(findLastIndex(list, true))\nscore(first(array))\nscore(get(array, 1))\nscore(get(array, i))\nscore(get(array, i32))\nscore(get(array, i64))\nscore(i % 1)\nscore(i % i)\nscore(i % i64)\nscore(i * 1 * i)\nscore(i * 1)\nscore(i * i)\nscore(i * i32)\nscore(i * i64)\nscore(i + 1)\nscore(i + i)\nscore(i + i32)\nscore(i - 1)\nscore(i - i)\nscore(i - i32)\nscore(i)\nscore(i) != f32\nscore(i) != f64\nscore(i) % i\nscore(i) % i * f64\nscore(i) * f32\nscore(i) * i32\nscore(i) ** (0.5 / 0.5)\nscore(i) ** -0.5\nscore(i) ** i32\nscore(i) ** i64\nscore(i) + f64\nscore(i) - f64\nscore(i) - i32\nscore(i) / i64\nscore(i) < 1 != ok\nscore(i) < f32\nscore(i) < f64 / 0.5\nscore(i) < i32\nscore(i) < i64\nscore(i) <= 0.5 / f32\nscore(i) <= f32\nscore(i) <= f64\nscore(i) <= i\nscore(i) <= i32\nscore(i) == f32\nscore(i) > f32\nscore(i) > i\nscore(i) > i64\nscore(i) >= f32\nscore(i) >= f64\nscore(i) >= i\nscore(i) >= i32\nscore(i) >= i64\nscore(i) ^ f32\nscore(i) ^ i32\nscore(i) ^ i64\nscore(i) ^ score(1)\nscore(i, 1) + -1\nscore(i, 1) .. i64\nscore(i, 1) <= f32\nscore(i, i)\nscore(i, i) ** f32\nscore(i32 % 1)\nscore(i32 % i)\nscore(i32 % i32)\nscore(i32 * 1)\nscore(i32 * i)\nscore(i32 * i32)\nscore(i32 * i64)\nscore(i32 + 1)\nscore(i32 + i)\nscore(i32 + i32)\nscore(i32 + i64)\nscore(i32 - 1)\nscore(i32 - i)\nscore(i32 - i32)\nscore(i32 - i64)\nscore(i64 % 1)\nscore(i64 % i)\nscore(i64 % i32)\nscore(i64 % i64)\nscore(i64 * 1)\nscore(i64 * i32)\nscore(i64 * i64)\nscore(i64 + 1)\nscore(i64 + i)\nscore(i64 + i32)\nscore(i64 - 1)\nscore(i64 - i64)\nscore(int(0.5))\nscore(int(1))\nscore(int(f32))\nscore(int(f64))\nscore(int(float(0.5)))\nscore(int(i))\nscore(int(i32))\nscore(int(i64))\nscore(last(array))\nscore(len(\"bar\"))\nscore(len(\"foo\"))\nscore(len(array))\nscore(len(list))\nscore(max(1))\nscore(max(1, i32, 0.5))\nscore(max(i))\nscore(max(i, i32))\nscore(min(1))\nscore(min(i))\nscore(min(i, i32))\nscore(ok ? 1 : \"bar\")\nscore(ok ? 1 : list)\nscore(reduce(array, #))\nscore(reduce(array, i))\nscore(reduce(list, 1))\nscore(reduce(list, i))\nscore(score(1))\nscore(score(i))\nscore(score(i32 + i))\nscore(sum(array))\n```\n\n----------------------------------------\n\nTITLE: toPairs Function in Expr\nDESCRIPTION: Examples of using the toPairs function to convert data structures into key-value pairs. This function is often used to iterate over maps or objects.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_243\n\nLANGUAGE: Expr\nCODE:\n```\ntoPairs($env) != array\ntoPairs($env) == array\ntoPairs($env) == list\ntoPairs($env) not in $env?.Bar\ntoPairs($env) | concat(array)\ntoPairs($env) | findLast(ok)\ntoPairs($env) | findLastIndex(true)\ntoPairs($env) | groupBy(1.0)\ntoPairs($env) | groupBy(i)\ntoPairs($env) | map(#)\ntoPairs($env) | map(1.0)\ntoPairs($env) | one(false)\ntoPairs($env) | one(true)\ntoPairs($env) | reduce(#)\ntoPairs($env) | reduce(1.0)\ntoPairs($env) | reduce(add)\ntoPairs($env) | reduce(foo)\ntoPairs($env) | reduce(greet)\ntoPairs($env) | reduce(i)\ntoPairs($env)?.[i]\ntoPairs(array | groupBy(f64))\ntoPairs(array | groupBy(ok))\ntoPairs(false ? $env : $env)\ntoPairs(groupBy(array, 1.0))\ntoPairs(groupBy(list, #))\ntoPairs(list | groupBy(#))\ntoPairs(list | groupBy(false))\ntoPairs(max($env))\ntoPairs(min($env))\ntoPairs(reduce(array, $env))\ntoPairs({foo: $env, foo: true})\ntoPairs({foo: $env})\ntoPairs({foo: 0})\ntoPairs({foo: 1, foo: $env})\ntoPairs({foo: 1.0 - 1.0})\ntoPairs({foo: 1.0, foo: 1})\ntoPairs({foo: 1.0})\ntoPairs({foo: 1})\ntoPairs({foo: add, foo: add})\ntoPairs({foo: add})\ntoPairs({foo: array})\ntoPairs({foo: f64})\ntoPairs({foo: foo, foo: greet})\ntoPairs({foo: foo, foo: ok})\ntoPairs({foo: foo, foo: str})\ntoPairs({foo: foo})\ntoPairs({foo: greet})\ntoPairs({foo: i})\ntoPairs({foo: list})\ntoPairs({foo: nil, foo: str})\ntoPairs({foo: nil})\ntoPairs({foo: ok})\ntoPairs({foo: str})\ntoPairs({foo: true})\n```\n\n----------------------------------------\n\nTITLE: Data Type Specific Access\nDESCRIPTION: Shows accessing specific members or properties that are unique to certain data types, such as numerical types (f32, f64, i32, i64), strings, lists, etc. Optional chaining is also tested for these data type-specific accesses.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_138\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": 1}.f32\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": add}.f32\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": array}.f32\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": div}.i32\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": f32}.i\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": i32}.i\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": f64}.list\n```\n\n----------------------------------------\n\nTITLE: String Lowercase Conversion in Expr\nDESCRIPTION: This snippet demonstrates the `lower` function, which converts a string to lowercase in Expr. It shows various inputs to the function, including environment variables, field access, function calls, and complex expressions. The example illustrates how `lower` can be used with diverse string sources and data types (after conversion to string).\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_177\n\nLANGUAGE: Expr\nCODE:\n```\nlower($env | reduce(str, 1.0))\nlower($env.str)\nlower($env?.[str])\nlower($env?.str)\nlower(false ? array : str)\nlower(foo.Bar)\nlower(foo.String())\nlower(foo?.Bar)\nlower(foo?.String())\nlower(greet(str))\nlower(greet(string(nil)))\nlower(greet(toJSON(array)))\nlower(list?.[i]?.Bar)\nlower(lower(str))\nlower(reduce(array, str))\nlower(str + str)\nlower(str | greet())\nlower(str)\nlower(str) == str\nlower(str) | greet()\nlower(str[1:])\nlower(string($env))\nlower(string(1))\nlower(string(1.0))\nlower(string(add))\nlower(string(array))\nlower(string(f64))\nlower(string(false))\nlower(string(foo))\nlower(string(list))\nlower(string(nil))\nlower(string(ok))\nlower(string(str))\nlower(string(true))\nlower(toBase64(str))\nlower(toJSON(0))\nlower(toJSON(1.0))\nlower(toJSON(array))\nlower(toJSON(f64))\nlower(toJSON(false))\nlower(toJSON(foo))\nlower(toJSON(i))\nlower(toJSON(list))\nlower(toJSON(nil))\nlower(toJSON(ok))\nlower(toJSON(str))\nlower(toJSON(true))\nlower(trimPrefix(str))\nlower(trimSuffix(str))\nlower(type($env))\nlower(type(1))\nlower(type(1.0))\nlower(type(add))\nlower(type(false))\nlower(type(foo))\nlower(type(i))\nlower(type(list))\nlower(type(nil))\nlower(type(ok))\nlower(type(str))\nlower(type(true))\n```\n\n----------------------------------------\n\nTITLE: Length of Object Literals with `len` in Expr\nDESCRIPTION: This snippet demonstrates calculating length of various object literals using `len` function in Expr. This covers various scenarios with multiple keys of different data types including nested structures.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_170\n\nLANGUAGE: Expr\nCODE:\n```\nlen({foo: $env, foo: $env})\nlen({foo: $env})\nlen({foo: 0})\nlen({foo: 1, foo: false})\nlen({foo: 1.0, foo: f64})\nlen({foo: 1.0})\nlen({foo: 1})\nlen({foo: add})\nlen({foo: array, foo: 1.0})\nlen({foo: array, foo: str})\nlen({foo: array})\nlen({foo: f64})\nlen({foo: false})\nlen({foo: foo, foo: 1.0})\nlen({foo: foo, foo: foo})\nlen({foo: foo, foo: nil})\nlen({foo: foo})\nlen({foo: greet, foo: str})\nlen({foo: i, foo: $env})\nlen({foo: i})\nlen({foo: list})\nlen({foo: nil})\nlen({foo: ok, foo: $env})\nlen({foo: ok})\nlen({foo: str, foo: str})\nlen({foo: str})\nlen({foo: true})\n```\n\n----------------------------------------\n\nTITLE: Expr: Logical AND with variable access and optional chaining\nDESCRIPTION: This snippet explores the usage of the logical AND operator combined with variable access and optional chaining in the Expr language.  It demonstrates complex conditions that involve accessing nested properties and potential nil values.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_250\n\nLANGUAGE: Expr\nCODE:\n```\ntrue and $env == f64\ntrue and $env startsWith $env?.Bar\ntrue and $env.ok\ntrue and $env?.Bar\ntrue and $env?.Bar?.Bar\ntrue and $env?.String\ntrue and $env?.String?.ok\ntrue and $env?.[Bar]\ntrue and $env?.[String]\ntrue and $env?.[str]\ntrue and $env?.foobar\ntrue and $env?.foobar?.array()\ntrue and $env?.ok\n\n```\n\n----------------------------------------\n\nTITLE: String EndsWith Checks in Expr\nDESCRIPTION: This snippet demonstrates the use of `endsWith` and `not endsWith` operators in the Expr language to check if a string `str` ends with a specific suffix. The expressions cover different scenarios, including checking against environment variables, object properties, function calls, and other strings.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_216\n\nLANGUAGE: Expr\nCODE:\n```\nstr endsWith $env.str\nstr endsWith $env?.Bar\nstr endsWith $env?.String\nstr endsWith $env?.[Bar]\nstr endsWith $env?.[String]\nstr endsWith $env?.[String]?.[add]\nstr endsWith $env?.[foobar]\nstr endsWith $env?.[str]\nstr endsWith $env?.str\nstr endsWith foo.Bar\nstr endsWith foo.String()\nstr endsWith foo?.Bar\nstr endsWith foo?.String()\nstr endsWith greet(str)\nstr endsWith str\nstr endsWith string(foo)\nstr endsWith string(nil)\nstr endsWith string(ok)\nstr endsWith toJSON(0)\nstr endsWith toJSON(foo)\nstr endsWith toJSON(i)\nstr endsWith toJSON(true)\nstr endsWith trimPrefix($env.str)\nstr endsWith type(list)\nstr endsWith {foo: f64}.f64\nstr endsWith {foo: nil, foo: $env}?.f64\nstr not endsWith $env.str\nstr not endsWith $env?.Bar\nstr not endsWith $env?.String\nstr not endsWith $env?.[Bar]\nstr not endsWith $env?.[String]\nstr not endsWith $env?.[String]?.String\nstr not endsWith $env?.[foobar?.foo($env)]\nstr not endsWith $env?.[str]\nstr not endsWith $env?.false\nstr not endsWith $env?.not\nstr not endsWith $env?.str\nstr not endsWith first($env)\nstr not endsWith first($env)?.[greet]\nstr not endsWith foo.Bar\nstr not endsWith foo.String()\nstr not endsWith foo?.Bar\nstr not endsWith foo?.String()\nstr not endsWith greet(str)\nstr not endsWith str\nstr not endsWith str && $env?.String\nstr not endsWith str || true\nstr not endsWith string(1)\nstr not endsWith type(i)\nstr not endsWith type(list)\n```\n\n----------------------------------------\n\nTITLE: Array Uniqueness\nDESCRIPTION: Illustrates the usage of the `uniq` function to remove duplicate elements from an array or list. It operates on both `array` and `list` variables to validate its functionality with different data structures.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_27\n\nLANGUAGE: Expr\nCODE:\n```\n[uniq(array)]\n[uniq(list)]\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT Operation in Expr\nDESCRIPTION: Demonstrates the bitwise NOT operation using the `bitnot` function in Expr. It takes one integer argument and returns the result of the bitwise NOT.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_94\n\nLANGUAGE: expr\nCODE:\n```\nbitnot(0b1010) == -0b1011\n```\n\n----------------------------------------\n\nTITLE: Flatten an Array Using flatten() in Expr\nDESCRIPTION: The `flatten()` function flattens a given array into a one-dimensional array. It recursively traverses nested arrays and combines all elements into a single-level array.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_63\n\nLANGUAGE: expr\nCODE:\n```\nflatten([1, 2, [3, 4]]) == [1, 2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: String Conversion with Bitwise and Numeric Functions\nDESCRIPTION: This snippet is responsible for string conversion in combination with bitwise and numeric functions. It tests `bitnot`, `ceil`, `concat`, `count` alongside other expressions to ensure that the functions integrate as strings correctly.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_228\n\nLANGUAGE: Expr\nCODE:\n```\nstring(bitnot(0))\nstring(bitnot(1))\nstring(bitnot(i))\nstring(ceil(0))\nstring(ceil(1))\nstring(ceil(1.0))\nstring(ceil(f64))\nstring(concat(array))\nstring(count($env, false))\n```\n\n----------------------------------------\n\nTITLE: Range Operator in Expr\nDESCRIPTION: Illustrates the use of the range operator `..` to create an array of consecutive integers.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_12\n\nLANGUAGE: expr\nCODE:\n```\n1..3 == [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Ceiling Function Examples in Expr\nDESCRIPTION: Shows the `ceil` function applied to different data types, expressions, and function results. Illustrates type conversions, operator precedence, and interactions with conditional logic.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_24\n\nLANGUAGE: Expr\nCODE:\n```\nceil(-0.5)\nceil(-1)\nceil(-f32)\nceil(-f64)\nceil(-i)\nceil(-i32)\nceil(-i64)\nceil(0.5 * 0.5)\nceil(0.5 * 1)\nceil(0.5 * f64)\nceil(0.5 * i)\nceil(0.5 ** 1)\nceil(0.5 ** f64)\nceil(0.5 ** i)\nceil(0.5 + 0.5)\nceil(0.5 + 1)\nceil(0.5 + f32)\nceil(0.5 + f64)\nceil(0.5 + i)\nceil(0.5 + i32)\nceil(0.5 + i64)\nceil(0.5 - 0.5)\nceil(0.5 - f64)\nceil(0.5 - i)\nceil(0.5 / 0.5)\nceil(0.5 / 1)\nceil(0.5 / f32)\nceil(0.5 / i)\nceil(0.5 / i32)\nceil(0.5 ^ 1)\nceil(0.5 ^ f32)\nceil(0.5 ^ i32)\nceil(0.5 ^ i64)\nceil(0.5) != 0.5 * 0.5\nceil(0.5) != i\nceil(0.5) != nil ? score : \"foo\"\nceil(0.5) ** round(f32)\nceil(0.5) - i\nceil(0.5) < i\nceil(0.5) == f32\nceil(0.5) == i ? div : half\nceil(0.5) == i64\nceil(0.5) > f64\nceil(0.5) >= i\nceil(0.5) >= i64\nceil(0.5) ^ i64\nceil(1 % i64)\nceil(1 * 0.5)\nceil(1 * 1)\nceil(1 ** 1)\nceil(1 + 0.5)\nceil(1 + 1)\nceil(1 + f64)\nceil(1 + i)\nceil(1 - 0.5)\nceil(1 - f64)\nceil(1 / 0.5)\nceil(1 / 1)\nceil(1 / f64)\nceil(1 / i64)\nceil(1 ^ f64)\nceil(1 ^ i)\nceil(1 ^ i64)\nceil(1) ** f32\nceil(1) + i32\nceil(1) / i\nceil(1) < f32 ^ i\nceil(1) <= f32\nceil(1) <= i64\nceil(1) == f32\nceil(1) > f32\nceil(1) >= f32\nceil(1) >= i64 ** 0.5\nceil(1) ^ i\nceil(abs(0.5))\nceil(abs(1))\nceil(abs(f32))\nceil(abs(f64))\nceil(abs(i32))\nceil(abs(i64))\nceil(add(1, 1))\nceil(array[1])\nceil(array[i64])\nceil(array[i])\nceil(bitnot(1))\nceil(bitnot(i))\nceil(ceil(0.5))\nceil(ceil(f64))\nceil(ceil(i))\nceil(ceil(i32))\nceil(count(list, ok))\nceil(f32 * 0.5)\nceil(f32 * i)\nceil(f32 * i32)\nceil(f32 ** i)\nceil(f32 ** i32)\nceil(f32 + 1)\nceil(f32 + i64)\nceil(f32 - f32)\nceil(f32 - i)\nceil(f32 - i32)\nceil(f32 - i64)\nceil(f32 / 0.5)\nceil(f32 / f64)\nceil(f32 / i32)\nceil(f32 ^ 0.5)\nceil(f32 ^ 1)\nceil(f32 ^ i64)\nceil(f32)\nceil(f32) != i64\nceil(f32) * i64\nceil(f32) ** -1\nceil(f32) ** i\nceil(f32) + i\nceil(f32) + i64\nceil(f32) - i32\nceil(f32) / i64\nceil(f32) < i\nceil(f32) < i32\nceil(f64 * 1)\nceil(f64 * i)\nceil(f64 ** i)\nceil(f64 ** i64)\nceil(f64 + 1)\nceil(f64 + f32)\nceil(f64 - 0.5)\nceil(f64 - f32)\nceil(f64 - f64)\nceil(f64 - i32)\nceil(f64 / 0.5)\nceil(f64 / f64)\nceil(f64 / i32)\nceil(f64 / i64)\nceil(f64 ^ 0.5)\nceil(f64 ^ f32)\nceil(f64 ^ f64)\nceil(f64 ^ i32)\nceil(f64 ^ i64)\nceil(f64)\nceil(f64) != i\nceil(f64) != i64\nceil(f64) * f32\nceil(f64) ** f32\nceil(f64) - i32\nceil(f64) / f64\nceil(f64) / i / i64\nceil(f64) in array\nceil(false ? add : 0.5)\nceil(find(array, ok))\nceil(findLast(array, true))\nceil(findLastIndex(list, ok))\nceil(findLastIndex(list, true))\nceil(first(array))\nceil(float(0.5))\nceil(float(1))\nceil(float(f64))\nceil(float(i))\nceil(float(i32))\nceil(float(i64))\nceil(floor(0.5))\nceil(floor(1))\nceil(floor(f64))\nceil(floor(i))\nceil(floor(i32))\nceil(floor(i64))\nceil(get(array, 1))\nceil(get(array, i))\nceil(half(0.5))\nceil(half(1))\nceil(half(f64))\nceil(i % i)\nceil(i * 0.5)\nceil(i * i)\nceil(i ** f64)\nceil(i ** i)\nceil(i + 0.5)\nceil(i + 1)\nceil(i + f32)\nceil(i + i64)\nceil(i - i)\nceil(i / f32)\nceil(i / i)\nceil(i / i64)\nceil(i ^ i)\nceil(i ^ i32)\nceil(i)\nceil(i) != i32\nceil(i) * f64\nceil(i) * i64\nceil(i) ** f64\nceil(i) + i\nceil(i) - f32\nceil(i) / f32\nceil(i) <= f64\nceil(i) == i32\nceil(i) > i64\nceil(i32 * i)\nceil(i32 * i32)\nceil(i32 ** i32)\nceil(i32 + 0.5)\nceil(i32 + i32)\nceil(i32 - 0.5)\nceil(i32 - 1)\nceil(i32 - i)\nceil(i32 - i64)\nceil(i32 / 0.5)\nceil(i32 / f32)\nceil(i32 / i)\nceil(i32 / i32)\nceil(i32 ^ 0.5)\nceil(i32 ^ i64)\nceil(i32)\nceil(i32) * 1 ^ i32\nceil(i32) * i32\nceil(i32) ** max(i)\nceil(i32) + f32\nceil(i32) + i\nceil(i32) + i32\nceil(i32) <= i64\nceil(i32) not in array\nceil(i64 % 1)\nceil(i64 % i32)\nceil(i64 * f32)\nceil(i64 * f64)\nceil(i64 ** i32)\nceil(i64 ** i64)\nceil(i64 + 0.5)\nceil(i64 + f64)\nceil(i64 + i32)\nceil(i64 - 0.5)\nceil(i64 - f64)\nceil(i64 / 0.5)\nceil(i64 / 1)\nceil(i64 / f64)\nceil(i64 ^ 0.5)\nceil(i64 ^ i)\nceil(i64 ^ i32)\nceil(i64 ^ i64)\nceil(i64)\nceil(i64) - -1\nceil(i64) - f32\nceil(i64) - i32\nceil(i64) / (0.5 - f32)\nceil(i64) >= f32\nceil(i64) ^ i32\nceil(int(0.5))\nceil(int(f32))\nceil(int(f64))\nceil(int(i))\nceil(int(i64))\nceil(len(\"bar\"))\nceil(len(array))\nceil(len(list))\nceil(max(1, i))\nceil(max(f32, 0.5))\nceil(max(f64))\nceil(max(i))\nceil(mean(array))\nceil(median(array))\nceil(min(0.5, f32))\nceil(min(1))\nceil(min(f32))\nceil(min(f64))\nceil(min(i))\nceil(min(i64))\nceil(ok ? f32 : nil)\nceil(ok ? i32 : \"bar\")\nceil(ok ? i32 : i64)\nceil(reduce(array, #))\nceil(reduce(array, 0.5))\nceil(reduce(list, 1))\nceil(round(0.5))\nceil(round(1))\nceil(round(f32))\nceil(round(f64))\nceil(round(i))\nceil(round(i32))\nceil(round(i64))\nceil(score(1))\nceil(score(i))\nceil(true ? 1 : half)\nceil(true ? 1 : nil)\nceil(true ? f64 : nil)\n```\n\n----------------------------------------\n\nTITLE: Expr groupBy with conditional and aggregation functions\nDESCRIPTION: Illustrates using an if-else conditional, aggregation functions like `max` and `mean`, and comparisons with `nil` within the groupBy function.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_130\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(array, if true { nil } else { f64 })\ngroupBy(array, max(i))\ngroupBy(array, mean(1.0))\ngroupBy(array, nil == $env)\n```\n\n----------------------------------------\n\nTITLE: Inequality Comparisons in Expr\nDESCRIPTION: This snippet illustrates inequality comparisons (`!=`) in the Expr language.  The examples involve comparisons of a variable `foo` with environment variables, properties of objects within the environment, literals, and other variables. These expressions cover a range of scenarios including handling of null values, chained comparisons, and conditional statements.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_104\n\nLANGUAGE: Expr\nCODE:\n```\nfoo != $env != ok\nfoo != $env && ok and ok\nfoo != $env == true\nfoo != $env ? $env : nil\nfoo != $env.foo\nfoo != $env?.Bar\nfoo != $env?.Bar?.[i]\nfoo != $env?.Bar?.array\nfoo != $env?.Bar?.list\nfoo != $env?.String\nfoo != $env?.String?.[greet]\nfoo != $env?.String?.greet\nfoo != $env?.[Bar]\nfoo != $env?.[String]\nfoo != $env?.[String]?.add\nfoo != $env?.[foobar]\nfoo != $env?.[str]\nfoo != $env?.foo\nfoo != $env?.foobar\nfoo != $env?.not\nfoo != first(list)\nfoo != foo\nfoo != foo != $env\nfoo != foo && $env.ok\nfoo != foo && get($env, 1)\nfoo != foo == $env || false\nfoo != foo == false\nfoo != foo == true\nfoo != foo or ok\nfoo != list?.[i]\nfoo != nil != $env\nfoo != nil ? 1.0 : $env\nfoo != nil ? str : foo\nfoo != nil || sum($env, $env)\n```\n\n----------------------------------------\n\nTITLE: Using the repeat function with strings and integers\nDESCRIPTION: Illustrates the usage of the `repeat` function, showing how to repeat a string a specified number of times, and how to use the result in further operations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_206\n\nLANGUAGE: Expr\nCODE:\n```\nrepeat(str, i)\nrepeat(str, i) not startsWith str\nrepeat(type(1), i)\n```\n\n----------------------------------------\n\nTITLE: Round Function Usage in Expr\nDESCRIPTION: Illustrates the application of the `round` function with diverse data types, arithmetic operations, and conditional expressions in Expr. The round function takes a numeric input and returns the nearest integer value.  It demonstrates how `round` interacts with operators and other functions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_208\n\nLANGUAGE: Expr\nCODE:\n```\nround($env | findIndex(true))\nround($env | reduce(0, foo))\nround($env | sum(1.0))\nround($env.f64)\nround($env.f64) != i\nround($env.i)\nround($env?.f64)\nround($env?.i)\nround(0 * 1.0)\nround(0 * f64)\nround(0 ** 0)\nround(0 ** f64)\nround(0 ** i)\nround(0 + 0)\nround(0 + 1)\nround(0 + 1.0)\nround(0 + i)\nround(0 - 1)\nround(0 / 0)\nround(0 / 1.0)\nround(0 / f64)\nround(0 ^ 1.0)\nround(0 ^ f64)\nround(0) / f64\nround(0) < i\nround(0) ^ f64\nround(0) ^ i\nround(0.1)\nround(1 * 0)\nround(1 ** 0)\nround(1 ** 1)\nround(1 ** i)\nround(1 + 0)\nround(1 + 1.0)\nround(1 + i)\nround(1 - 0)\nround(1 - 1.0)\nround(1 - i)\nround(1 / 1)\nround(1 / i)\nround(1 ^ 0)\nround(1 ^ 1.0)\nround(1 ^ f64)\nround(1 | bitnand(0))\nround(1) / f64\nround(1) ^ sum(array)\nround(1) not in array\nround(1.0 * 0)\nround(1.0 * 1)\nround(1.0 * 1.0)\nround(1.0 * f64)\nround(1.0 * i)\nround(1.0 ** 0)\nround(1.0 ** 1.0)\nround(1.0 ** i)\nround(1.0 + 0)\nround(1.0 - 1)\nround(1.0 - 1.0)\nround(1.0 - f64)\nround(1.0 - i)\nround(1.0 / 1)\nround(1.0 / 1.0)\nround(1.0 / i)\nround(1.0 ^ $env.i)\nround(1.0 ^ 0)\nround(1.0 ^ 1.0)\nround(1.0 ^ f64)\nround(1.0 ^ i)\nround(1.0 | max(i))\nround(1.0 | mean(0))\nround(1.0)\nround(1.0) * $env and false\nround(1.0) * f64\nround(1.0) ** 1.0 != 1\nround(1.0) ** f64\nround(1.0) + f64\nround(1.0) + mean(1.0, f64)\nround(1.0) / i\nround(1.0) <= i\nround(1.0) > i\nround(1.0) >= f64\nround(1.0) ^ f64\nround(1.0) ^ i\nround(1.0) ^ sum($env, 1)\nround(1.0) | median(array)\nround(1.1)\nround(abs(1.0))\nround(abs(i))\nround(array | reduce(#))\nround(array | sum(#))\nround(array | sum(1))\nround(array?.[0])\nround(array?.[i])\nround(bitnot(i))\nround(ceil(1.0))\nround(ceil(f64))\nround(f64 * 0)\nround(f64 * 1)\nround(f64 * 1.0)\nround(f64 * i)\nround(f64 ** 0)\nround(f64 + 1.0)\nround(f64 - 0)\nround(f64 - i)\nround(f64 / 0)\nround(f64 / 1.0)\nround(f64 / f64)\nround(f64 ^ 1)\nround(f64 ^ 1.0)\nround(f64 ^ f64)\nround(f64)\nround(f64) + f64\nround(f64) + f64 < 0\nround(f64) <= i\nround(f64) >= i\nround(false ? 0 : 1.0)\nround(false ?: 1)\nround(findLast(array, ok))\nround(findLastIndex($env, true))\nround(first(array))\nround(float(0))\nround(float(1))\nround(float(1.0))\nround(float(f64))\nround(float(i))\nround(floor(0))\nround(floor(1))\nround(floor(1.0))\nround(floor(f64))\nround(floor(i))\nround(i % 1)\nround(i * 1.0)\nround(i * i)\nround(i ** 0)\nround(i ** 1)\nround(i ** 1.0)\nround(i - 1)\nround(i - f64)\nround(i / 1.0)\nround(i / f64)\nround(i / i)\nround(i ^ 0)\nround(i ^ 1.0)\nround(i)\nround(i) + i\nround(i) / i\nround(i) == i\nround(i) > $env?.i\nround(i) > f64\nround(if false { foo } else { 0 })\nround(if true { 0 } else { greet })\nround(int(0))\nround(int(1))\nround(int(f64))\nround(int(string(1.0))))\nround(last(array))\nround(len(list))\nround(len(str))\nround(list | count(ok))\nround(list | reduce(1.0, 1.0))\nround(list | reduce(f64))\nround(max(1.0 * 0))\nround(max(1.0))\nround(max(array))\nround(max(array, array))\nround(max(f64))\nround(max(i))\nround(mean(0))\nround(mean(1))\nround(mean(1, 1.0))\nround(mean(1.0))\nround(mean(array))\nround(mean(f64))\nround(mean(f64, f64))\nround(mean(i))\nround(median(0))\nround(median(1))\nround(median(array))\nround(median(f64))\nround(median(f64, i))\nround(median(i))\nround(min(1))\nround(min(1.0))\nround(min(array))\nround(min(f64))\nround(min(i))\nround(ok ? i : 0)\nround(reduce(array, #))\nround(reduce(array, #, nil))\nround(reduce(list, #index, nil))\nround(round(1))\nround(round(1.0))\nround(sum($env, 0))\nround(sum($env, 1))\nround(sum($env, f64))\nround(sum(array))\n```\n\n----------------------------------------\n\nTITLE: String Manipulation Functions\nDESCRIPTION: Examples of using `trim` and `trimPrefix` functions to manipulate strings.  `trim` removes leading and trailing whitespace from a string, and `trimPrefix` removes a specified prefix from a string. The functions operate on the `str` variable.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_22\n\nLANGUAGE: Expr\nCODE:\n```\n[trim(str)]\n[trimPrefix(str)]\n```\n\n----------------------------------------\n\nTITLE: Boolean Logic and 'ok' Variable\nDESCRIPTION: This snippet demonstrates the use of boolean operators (AND, OR, !=, ==), the 'ok' variable, and access to environment variables within the Expr language. Includes conditional evaluation, short-circuiting behavior, and interaction with data structures.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_201\n\nLANGUAGE: Expr\nCODE:\n```\nok\nok != $env and $env\nok != $env.ok\nok != $env?.Bar\nok != $env?.String\nok != $env?.[Bar]\nok != $env?.[String]\nok != $env?.[str]\nok != $env?.foobar\nok != $env?.foobar?.greet\nok != $env?.ok\nok != any($env, ok)\nok != any(array, false)\nok != false && $env\nok != false or false\nok != nil && ok\nok != nil == ok and ok\nok != nil ? f64 : 1\nok != nil and $env\nok != ok\nok != sum($env?.[str])\nok != true != nil\nok != true != true\nok != true && ok\nok && $env != array\nok && $env != str\nok && $env == foo\nok && $env == greet\nok && $env not in array\nok && $env.ok\nok && $env?.Bar\nok && $env?.String\nok && $env?.String?.String\nok && $env?.String?.list\nok && $env?.[Bar]\nok && $env?.[Bar]?.add\nok && $env?.[String]\nok && $env?.[foobar?.Bar]\nok && $env?.[foobar]\nok && $env?.[str]\nok && $env?.foobar\nok && $env?.ok\nok && 0 < 0\nok && 1 != i\nok && 1 == 1\nok && 1 == f64\nok && 1.0 != $env\nok && 1.0 != 1.0\nok && 1.0 != f64\nok && 1.0 < f64\nok && 1.0 > 1\nok && add != $env\nok && add != $env?.String\nok && f64 > 1 or $env\nok && f64 > 1.0\nok && foo != foo\nok && foo != nil\nok && i <= f64\nok && i >= 1\nok && i not in array\nok && max($env)\nok && median(array)\nok && nil != $env\nok && nil == i\nok && nil == true\nok && nil in array\nok && ok\nok && ok && $env?.[str]\nok && ok == ok\nok && ok and $env\nok && ok or false\nok && ok || false\nok && one(list, false)\nok && str endsWith str\nok && true || $env?.String\nok == $env && ok\nok == $env || ok\nok == $env.ok\nok == $env?.Bar\nok == $env?.String\nok == $env?.String?.[greet]\nok == $env?.[Bar]\nok == $env?.[Bar]?.[array]\nok == $env?.[String]\nok == $env?.[str]\nok == $env?.foobar\nok == $env?.nil\nok == $env?.ok\nok == false != nil\nok == mean(array)\nok == min($env)\nok == nil != true\nok == nil ? 1.0 : $env\nok == ok\nok == ok ? nil : $env\nok == true && $env\n```\n\n----------------------------------------\n\nTITLE: Logical NOT with String Comparisons (Expr)\nDESCRIPTION: This snippet showcases how the logical NOT operator (!) is utilized with string comparison expressions in the Expr language, testing cases such as equality, inequality, less than, greater than, contains, startsWith, endsWith, and matches. It also includes comparisons with nil.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_2\n\nLANGUAGE: Expr\nCODE:\n```\n!!ok\n!(\"bar\" != \"bar\")\n!(\"bar\" != \"foo\")\n!(\"bar\" != nil)\n!(\"bar\" < \"foo\")\n!(\"bar\" <= \"foo\")\n!(\"bar\" == \"bar\")\n!(\"bar\" == \"foo\")\n!(\"bar\" == nil)\n!(\"bar\" > \"bar\")\n!(\"bar\" > \"foo\")\n!(\"bar\" >= \"bar\")\n!(\"bar\" >= \"foo\")\n!(\"bar\" contains \"bar\")\n!(\"bar\" contains \"foo\")\n!(\"bar\" endsWith \"bar\")\n!(\"bar\" endsWith \"foo\")\n!(\"bar\" in foo)\n!(\"bar\" matches \"foo\")\n!(\"bar\" not contains \"bar\")\n!(\"bar\" not endsWith \"bar\")\n!(\"bar\" not endsWith \"foo\")\n!(\"bar\" not in foo)\n!(\"bar\" not matches \"bar\")\n!(\"bar\" not startsWith \"bar\")\n!(\"bar\" not startsWith \"foo\")\n!(\"bar\" startsWith \"bar\")\n!(\"foo\" != \"bar\")\n!(\"foo\" != nil)\n!(\"foo\" < \"foo\")\n!(\"foo\" <= \"bar\")\n!(\"foo\" <= \"foo\")\n!(\"foo\" == \"bar\")\n!(\"foo\" == nil)\n!(\"foo\" > \"bar\")\n!(\"foo\" > \"foo\")\n!(\"foo\" >= \"bar\")\n!(\"foo\" contains \"bar\")\n!(\"foo\" contains \"foo\")\n!(\"foo\" endsWith \"foo\")\n!(\"foo\" in foo)\n!(\"foo\" matches \"bar\")\n!(\"foo\" matches \"foo\")\n!(\"foo\" not contains \"bar\")\n!(\"foo\" not contains \"foo\")\n!(\"foo\" not endsWith \"bar\")\n!(\"foo\" not matches \"bar\")\n!(\"foo\" not matches \"foo\")\n!(\"foo\" not startsWith \"bar\")\n!(\"foo\" not startsWith \"foo\")\n!(\"foo\" startsWith \"bar\")\n!(\"foo\" startsWith \"foo\")\n!(nil != \"bar\")\n!(nil != \"foo\")\n!(nil == \"bar\")\n!(nil == \"foo\")\n```\n\n----------------------------------------\n\nTITLE: Array Mean\nDESCRIPTION: Calculates the mean (average) of the elements in the array. Requires numeric elements. Returns the arithmetic mean of the array.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_56\n\nLANGUAGE: Expr\nCODE:\n```\narray | mean(0 / 1)\n```\n\n----------------------------------------\n\nTITLE: Collection Operations\nDESCRIPTION: Illustrates the use of collection operations like `all`, `any`, `findIndex`, `findLastIndex`, `groupBy`, `map`, `none`, `one`, `reduce`, `sortBy`, and `sum` on arrays and lists. The examples showcase different predicate functions and parameters used with these functions. The purpose is to validate correct function calls and expected behaviors.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_25\n\nLANGUAGE: Expr\nCODE:\n```\n[true] != [array]\n[true] in $env?.foobar\n[true] | all(#)\n[true] | any(#)\n[true] | any(false)\n[true] | findIndex(#)\n[true] | findLastIndex(false)\n[true] | groupBy(1.0)\n[true] | map(1.0)\n[true] | none(true)\n[true] | one(false)\n[true] | reduce($env)\n[true] | reduce($env, str)\n[true] | reduce(1.0)\n[true] | sortBy(#)\n[true] | sortBy(greet)\n[true] | sortBy(true)\n[true] | sum(1)\n[true] | sum(1.0)\n```\n\n----------------------------------------\n\nTITLE: String Conversion with 'i' variable and mathematical operations\nDESCRIPTION: This snippet tests the string conversion with the variable 'i' and mathematical operations performed on the variable 'i'\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_236\n\nLANGUAGE: Expr\nCODE:\n```\nstring(i != 0)\nstring(i != 1)\nstring(i != 1.0)\nstring(i != nil)\nstring(i % 1)\nstring(i * 1.0)\nstring(i ** 1.0)\nstring(i + 0)\nstring(i + 1)\nstring(i + 1.0)\nstring(i + f64)\nstring(i - 1)\nstring(i - 1.0)\nstring(i - f64)\nstring(i - i)\nstring(i .. 1)\nstring(i / 0)\nstring(i / f64)\nstring(i <= f64)\nstring(i == $env)\nstring(i == f64)\nstring(i > 0)\nstring(i >= 1.0)\nstring(i ^ 1)\nstring(i ^ f64)\nstring(i ^ i)\nstring(i not in array)\nstring(i | bitshr(i))\nstring(i | min(1.0, 1.0))\nstring(i)\nstring(i) not in foo\nstring(i) | indexOf(str)\n```\n\n----------------------------------------\n\nTITLE: Using the `repeat` function in Expr\nDESCRIPTION: Examples of using the `repeat` function, which seems to take a type and a number of repetitions.  These examples show repeating the 'type(ok)' i times.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_105\n\nLANGUAGE: Expr\nCODE:\n```\nrepeat(type(ok), i)\n```\n\n----------------------------------------\n\nTITLE: Using `reduce` with `map` function in Expr\nDESCRIPTION: This snippet shows how to combine the `reduce` function with the `map` function in Expr. It maps an array or list using an expression and then reduces the result, demonstrating complex data transformations within the language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_100\n\nLANGUAGE: Expr\nCODE:\n```\nreduce(map(array, \"bar\"), # not endsWith #)\nreduce(map(array, \"bar\"), add)\nreduce(map(array, \"foo\"), half(f64))\nreduce(map(array, #), # != i)\nreduce(map(array, #), # .. #)\nreduce(map(array, #), #)\nreduce(map(array, #), abs(#))\nreduce(map(array, #), i)\nreduce(map(array, #), i32 * #)\nreduce(map(array, #), not ok)\nreduce(map(array, 0.5), add)\nreduce(map(array, 0.5), div)\nreduce(map(array, 0.5), f32)\nreduce(map(array, 1), # ^ 0.5)\nreduce(map(array, 1), #)\nreduce(map(array, 1), foo)\nreduce(map(array, add), #)\nreduce(map(array, add), f32)\nreduce(map(array, add), list)\nreduce(map(array, array), f64)\nreduce(map(array, div), #)\nreduce(map(array, div), div)\nreduce(map(array, div), i32 * i)\nreduce(map(array, f32), f32)\nreduce(map(array, f32), i)\nreduce(map(array, f32), i32)\nreduce(map(array, f64), #)\nreduce(map(array, f64), f32 < #)\nreduce(map(array, false), # and true)\nreduce(map(array, false), f32)\nreduce(map(array, foo), # == nil)\nreduce(map(array, i), # / 1)\nreduce(map(array, i), #)\nreduce(map(array, i), add)\nreduce(map(array, i), f64 + 1)\nreduce(map(array, i32), array)\nreduce(map(array, i32), list)\nreduce(map(array, i64), # <= #)\nreduce(map(array, i64), #)\nreduce(map(array, list), filter(#, false))\nreduce(map(array, ok), i)\nreduce(map(array, score), i32)\nreduce(map(list, \"bar\"), #)\nreduce(map(list, \"foo\"), #)\nreduce(map(list, #), #)\nreduce(map(list, #), .Qux)\nreduce(map(list, #), add)\nreduce(map(list, #), array)\nreduce(map(list, #), f32)\nreduce(map(list, #), f64)\nreduce(map(list, #), half)\nreduce(map(list, #), i64)\nreduce(map(list, #), ok)\nreduce(map(list, 0.5), #)\nreduce(map(list, 0.5), foo)\nreduce(map(list, 1), # > #)\nreduce(map(list, 1), #)\nreduce(map(list, 1), list)\nreduce(map(list, array), div)\nreduce(map(list, div), add)\nreduce(map(list, f64), #)\nreduce(map(list, f64), ok)\nreduce(map(list, false), div)\nreduce(map(list, greet), #)\nreduce(map(list, i), #)\nreduce(map(list, i), [i32])\nreduce(map(list, i), f32)\nreduce(map(list, i), score(#))\nreduce(map(list, i32), #)\nreduce(map(list, i32), foo)\nreduce(map(list, i64), #)\nreduce(map(list, i64), i32)\nreduce(map(list, list), ok)\nreduce(map(list, score), #)\nreduce(map(list, score), f64)\nreduce(map(list, true), #)\nreduce(map(list, true), add)\nreduce(map(list, true), half)\n```\n\n----------------------------------------\n\nTITLE: Array Concatenation\nDESCRIPTION: Concatenates the array with another array. Requires both operands to be arrays. Returns a new array with elements combined from both input arrays.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_46\n\nLANGUAGE: Expr\nCODE:\n```\narray | concat(array)\n```\n\n----------------------------------------\n\nTITLE: Mapping $env with comparison and arithmetic operations in Expr\nDESCRIPTION: Illustrates mapping using the environment variable `$env` in combination with comparison and arithmetic operations. Demonstrates how to transform the input elements of a map to determine equality.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_181\n\nLANGUAGE: Expr\nCODE:\n```\nmap($env, $env) | count(ok)\nmap($env, $env) | findLast(ok)\nmap($env, $env) | map(array)\nmap($env, $env) | map(foo)\nmap($env, $env) | reduce($env)\nmap($env, $env) | reduce(0)\n```\n\n----------------------------------------\n\nTITLE: String Conversion with Comparison Operators\nDESCRIPTION: This snippet focuses on converting various expressions to strings, particularly with comparison operators. It covers numeric and variable comparisons, equality checks with different data types, and boolean operations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_223\n\nLANGUAGE: Expr\nCODE:\n```\nstring($env != 0)\nstring($env != 1)\nstring($env != 1.0)\nstring($env != add)\nstring($env != f64)\nstring($env != foo)\nstring($env != i)\nstring($env != nil)\nstring($env != ok)\nstring($env != str)\nstring($env != true)\nstring($env && false)\nstring($env && true)\nstring($env == $env)\nstring($env == array)\nstring($env == false)\nstring($env == foo)\nstring($env == greet)\nstring($env == nil)\nstring($env and true)\nstring($env in $env?.[Bar])\nstring($env in array)\nstring($env not in array)\nstring($env | all(false))\nstring($env | all(ok))\nstring($env | count(false))\nstring($env | findIndex(ok))\nstring($env | findIndex(true))\nstring($env | findLastIndex(true))\nstring($env | map(#index))\nstring($env | map($env))\nstring($env | map(1))\nstring($env | map(array))\nstring($env | map(greet))\nstring($env | none(ok))\nstring($env | one(true))\nstring($env | reduce(f64, 1.0))\nstring($env | sum(0))\nstring($env | sum(1))\nstring($env | sum(1.0))\nstring($env || false)\n```\n\n----------------------------------------\n\nTITLE: Using the trim function in Expr\nDESCRIPTION: Demonstrates the usage of the trim function in Expr language. This function removes leading and trailing whitespace from strings.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_120\n\nLANGUAGE: Expr\nCODE:\n```\ntrim(\"bar\") not in foo\ntrim(false ? \"bar\" : \"bar\")\ntrim(foo.Bar)\ntrim(foo.String())\ntrim(foo?.Bar)\ntrim(foo?.String())\ntrim(greet(\"bar\"))\ntrim(greet(\"foo\"))\ntrim(lower(\"bar\"))\ntrim(lower(\"foo\"))\ntrim(reduce(list, \"bar\"))\ntrim(string(\"bar\"))\ntrim(string(-f64))\ntrim(string(0.5))\ntrim(string(1))\ntrim(string(add))\ntrim(string(array))\ntrim(string(f32))\ntrim(string(foo))\ntrim(string(i64))\ntrim(string(list))\ntrim(string(nil))\ntrim(toJSON(\"bar\"))\ntrim(toJSON(1))\ntrim(toJSON(f32))\ntrim(toJSON(false))\ntrim(toJSON(foo))\ntrim(toJSON(i32))\ntrim(toJSON(i64))\ntrim(toJSON(ok))\ntrim(toJSON(true))\ntrim(trim(\"bar\"))\ntrim(trimPrefix(\"foo\"))\ntrim(trimSuffix(\"bar\"))\ntrim(true ? \"foo\" : greet)\ntrim(type(\"bar\"))\ntrim(type(\"foo\"))\ntrim(type(0.5))\ntrim(type(1))\ntrim(type(add))\ntrim(type(div))\ntrim(type(f32))\ntrim(type(f64))\ntrim(type(greet))\ntrim(type(i))\ntrim(type(list))\ntrim(type(nil))\ntrim(type(ok))\ntrim(type(score))\ntrim(type(true))\n```\n\n----------------------------------------\n\nTITLE: String Prefix/Suffix Checks in Expr\nDESCRIPTION: Illustrates the use of 'hasPrefix' and 'hasSuffix' functions within the Expr language to check for string prefixes and suffixes. It showcases variations with variables, function calls, and property accesses.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_144\n\nLANGUAGE: Expr\nCODE:\n```\nhasPrefix(str, str)\nhasSuffix(foo.String(), str)\nhasSuffix(str, greet(str))\nhasSuffix(str, str)\n```\n\n----------------------------------------\n\nTITLE: Expr Language Expressions\nDESCRIPTION: This code snippet presents a multitude of Expr language expressions used for testing diverse language features. The purpose is to validate that the Expr interpreter correctly parses and evaluates different syntax, operators, built-in functions, and data types. The expressions cover comparisons, arithmetic, logical operations, conditional statements, string manipulation, array/list manipulations, and function calls. The expected output varies based on the expression and the state of the 'env' variable, which serves as the context for the expressions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_0\n\nLANGUAGE: Expr\nCODE:\n```\n$env != $env == ok\n$env != $env ?: greet\n$env != $env.add\n$env != $env.array\n$env != $env.f64\n$env != $env.foo\n$env != $env.greet\n$env != $env.i\n$env != $env.list\n$env != $env.ok\n$env != $env.str\n$env != $env?.Bar\n$env != $env?.Bar?.add\n$env != $env?.Bar?.list\n$env != $env?.String\n$env != $env?.[Bar]\n$env != $env?.[Bar]?.sum(foobar matches Bar)\n$env != $env?.[String]\n$env != $env?.[String]?.[array]\n$env != $env?.[String]?.greet\n$env != $env?.[foobar]\n$env != $env?.[str]\n$env != $env?.add\n$env != $env?.array\n$env != $env?.f64\n$env != $env?.foo\n$env != $env?.foobar\n$env != $env?.foobar?.greet\n$env != $env?.greet\n$env != $env?.i\n$env != $env?.list\n$env != $env?.ok\n$env != $env?.str\n$env != 0 != ok\n$env != 0 && 1.0 != nil\n$env != 0 ?: $env?.[f64]\n$env != 1 / f64\n$env != 1.0 * i\n$env != 1.0 + f64\n$env != 1.0 - f64\n$env != 1.0 / i\n$env != 1.0 || abs($env)\n$env != add ? add : ok ?: array\n$env != array?.[i]\n$env != f64 / f64\n$env != false != ok\n$env != foo == $env?.[String]\n$env != foo and ok\n$env != foo.Bar\n$env != foo.String\n$env != foo.String()\n$env != foo?.Bar\n$env != foo?.String\n$env != foo?.String()\n$env != i not in toPairs($env)\n$env != list or ok\n$env != list?.[i]\n$env != nil != ok\n$env != str && ok\n$env != str + str\n$env != str || 1 in $env\n$env != true and nil != nil\n$env && false and $env matches $env\n$env && false or ok\n$env * 1 || true == true\n$env - 1.0 not startsWith $env && false\n$env .. $env in $env || true\n$env == $env && nil in list\n$env == $env ?: i != $env\n$env == $env and ok\n$env == $env or $env?.Bar()\n$env == $env.add\n$env == $env.array\n$env == $env.f64\n$env == $env.foo\n$env == $env.greet\n$env == $env.i\n$env == $env.list\n$env == $env.list?.[i]\n$env == $env.ok\n$env == $env.str\n$env == $env?.Bar\n$env == $env?.String\n$env == $env?.String?.foo\n$env == $env?.String?.foobar?.[array]\n$env == $env?.[Bar]\n$env == $env?.[Bar]?.[ok]?.[array]\n$env == $env?.[Bar]?.foo\n$env == $env?.[Bar]?.i\n$env == $env?.[String]\n$env == $env?.[str]\n$env == $env?.add\n$env == $env?.array\n$env == $env?.f64\n$env == $env?.f64 / i\n$env == $env?.foo\n$env == $env?.foobar\n$env == $env?.greet\n$env == $env?.i\n$env == $env?.list\n$env == $env?.ok\n$env == $env?.str\n$env == 0 ^ f64\n$env == 0 and take($env, 0)\n$env == 1 ?: array\n$env == 1.0 && $env != greet\n$env == 1.0 && map($env, false)?.[i]\n$env == 1.0 ** 1 ?: 1\n$env == 1.0 == none(array, true)\n$env == 1.0 ?: $env?.greet\n$env == 1.0 ^ $env?.f64\n$env == 1.0 ^ f64\n$env == 1.0 and add != add\n$env == add and $env[foo:]\n$env == array and ok\n$env == array?.[i]\n$env == f64 * f64\n$env == false not in $env?.[Bar]\n$env == false not in $env?.[String]\n$env == foo && ok\n$env == foo.Bar\n$env == foo.String\n$env == foo.String()\n$env == foo?.Bar\n$env == foo?.String\n$env == foo?.String()\n$env == i ** f64\n$env == i || ok\n$env == list && $env not in list\n$env == list && findLast($env, .array)\n$env == list?.[i]\n$env == list[i:]\n$env == nil && 1.0 > i\n$env == ok and $env in foo\n$env == str && ok or $env\n$env == str || ok\n$env >= 1.0 == $env or true\n$env contains $env?.Bar\n$env contains $env?.String\n$env contains $env?.[Bar]\n$env contains $env?.[Bar]?.[f64]\n$env contains $env?.[String]\n$env contains $env?.[str[:1.0]]\n$env contains $env?.foobar\n$env contains $env?.nil?.[list]\n$env endsWith $env?.Bar\n$env endsWith $env?.String\n$env endsWith $env?.[Bar]\n$env endsWith $env?.[Bar]?.str\n$env endsWith $env?.[String]\n$env endsWith $env?.[foobar?.[add]]\n$env endsWith $env?.foobar\n$env in $env.array\n$env in $env.list\n$env in $env?.Bar\n$env in $env?.Bar?.foo\n$env in $env?.String\n$env in $env?.String?.list\n$env in $env?.[Bar]\n$env in $env?.[String?.[str]]\n$env in $env?.[String]\n$env in $env?.array\n$env in $env?.foobar\n$env in $env?.foobar?.foo\n$env in $env?.list\n$env in $env?.true?.f64(foobar)\n$env in 0 .. i\n$env in 1 .. i\n$env in array or ok\n$env in i .. $env.i\n$env in list && $env and $env\n$env in list and $env?.[f64]\n$env matches $env && ok or true\n$env matches $env?.$env?.add\n$env matches $env?.Bar\n$env matches $env?.String\n$env matches $env?.[Bar]\n$env matches $env?.[Bar]?.[f64]\n$env matches $env?.[String]\n$env matches $env?.[String]?.ok()\n$env matches $env?.[foobar]\n$env matches $env?.foobar\n$env matches $env?.foobar?.Bar(foobar, foobar)\n$env matches $env?.foobar?.greet()\n$env not contains $env?.Bar\n$env not contains $env?.String\n$env not contains $env?.String?.[str]\n$env not contains $env?.String?.array\n$env not contains $env?.[Bar]\n$env not contains $env?.[Bar]?.add()\n$env not contains $env?.[Bar]?.ok\n$env not contains $env?.[String]\n$env not contains $env?.[first(foobar, greet)]\n$env not contains $env?.[foobar]\n$env not contains $env?.[toJSON(foobar)]\n$env not contains $env?.foobar\n$env not contains $env?.foobar?.[ok]\n$env not contains $env?.foobar?.greet()\n$env not endsWith $env?.Bar\n$env not endsWith $env?.Bar?.[list]\n$env not endsWith $env?.String\n$env not endsWith $env?.[Bar]\n$env not endsWith $env?.[String]\n$env not endsWith $env?.[foobar]\n$env not endsWith $env?.foobar\n$env not in $env.array\n$env not in $env.list\n$env not in $env?.Bar\n$env not in $env?.Bar?.[ok]\n$env not in $env?.String\n$env not in $env?.String?.f64\n$env not in $env?.[Bar]\n$env not in $env?.[String]\n$env not in $env?.[foobar]\n$env not in $env?.array\n$env not in $env?.list\n$env not in array && ok\n$env not in array == $env || false\n$env not in array == $env?.[String]\n$env not in array[:i]\n$env not in list or ok\n$env not matches $env?.Bar\n$env not matches $env?.Bar?.[add]\n$env not matches $env?.Bar?.array\n$env not matches $env?.String\n$env not matches $env?.String?.[add]\n$env not matches $env?.String?.[ok]\n$env not matches $env?.[Bar]\n$env not matches $env?.[String?.[Bar]]\n$env not matches $env?.[String]\n$env not matches $env?.[foobar]\n$env not startsWith $env?.Bar\n$env not startsWith $env?.Bar?.[greet]\n$env not startsWith $env?.String\n$env not startsWith $env?.[Bar]\n$env not startsWith $env?.[Bar]?.f64\n$env not startsWith $env?.[String]\n$env not startsWith $env?.[foobar]\n$env not startsWith $env?.foobar\n$env not startsWith $env?.foobar?.[foo]\n$env not startsWith $env?.foobar?.add\n$env or nil != nil || true\n$env or nil == list and false\n$env or true ?: greet\n$env startsWith $env?.Bar\n$env startsWith $env?.String\n$env startsWith $env?.[Bar]\n$env startsWith $env?.[String]\n$env startsWith $env?.[foobar]\n$env startsWith $env?.[foobar]?.[i]\n$env startsWith $env?.foobar\n$env startsWith $env?.foobar?.Bar()\n$env | any(false) != ok\n$env | filter(#.f64) | filter(false)\n$env | filter(false) | count(.i.greet)\n$env | filter(false) | find($env)\n$env | filter(false) | findIndex(.foo)\n$env | filter(false) | findLast(.greet)\n$env | filter(false) | findLast(.ok)\n$env | filter(false) | findLastIndex(.i)\n$env | filter(false) | map(#)\n$env | filter(false) | one(#)\n$env | filter(false) | sum(.greet)\n$env | filter(true) | map($env)\n$env | find(.add) startsWith str || true\n$env | findLast(false) == str or true\n$env | findLastIndex(true) - i\n$env | map(#index) | groupBy(f64)\n$env | map(#index) | map(i)\n$env | map(#index) | reduce(f64, nil)\n$env | map($env) | find(#.ok)\n$env | map($env) | map(list)\n$env | map($env) | sortBy(#.i)\n$env | map($env) | sortBy(.i)\n$env | map($env) | sortBy(i)\n$env | map(0) | groupBy(1)\n$env | map(0) | sortBy(#)\n$env | map(0) | sortBy(1.0)\n$env | map(1) | sum(#)\n$env | map(1.0) | filter(true)\n$env | map(1.0) | findLastIndex(ok)\n$env | map(1.0) | groupBy(foo)\n$env | map(1.0) | mean(0)\n$env | map(1.0) | none(true)\n$env | map(1.0) | reduce(1.0)\n$env | map(1.0) | reduce(false, list)\n$env | map(1.0) | sortBy(#)\n$env | map(false) | map(f64)\n$env | map(false) | reduce(str)\n$env | map(foo) | any(false)\n$env | map(foo) | findIndex(true)\n$env | map(foo) | groupBy(1)\n$env | map(foo) | reduce(#acc)\n$env | map(foo) | sum(1)\n$env | map(greet) | map(array)\n$env | map(i) | count(false)\n$env | map(list) | reduce(ok)\n$env | map(ok) | findLast(ok)\n$env | map(ok) | map($env)\n$env | map(ok) | none(#)\n$env | map(ok) | one(#)\n$env | map(ok) | reduce(0)\n$env | map(ok) | reduce(false)\n$env | map(str) | groupBy(foo)\n$env | map(true) | all(#)\n$env | map(true) | findLastIndex(#)\n$env | map(true) | map($env)\n$env | none(true) && ok\n$env | one(ok) || ok\n$env | reduce(#, nil) > $env and false\n$env | reduce($env, $env) | count(ok)\n$env | reduce($env, 1) | sum(0)\n$env | reduce(1.0, 1) <= f64\n$env | reduce(false, $env); list\n$env | reduce(ok, 1) ?: greet\n$env | sortBy(#, 0) * $env && false\n$env | sum(1.0) in array\n$env | sum(f64) > f64\n$env | sum(i) / bitnot(i)\n$env || true || $env < 1\n$env.add == $env.add\n$env.add == $env?.add\n$env.add == add\n$env.array != array\n$env.array != list\n$env.array == $env?.array\n$env.array == array\n$env.array == list\n$env.array | any($env?.ok)\n$env.array | any(false)\n$env.array | any(ok)\n$env.array | concat(array)\n$env.array | concat(list)\n$env.array | count(false)\n$env.array | filter(false)\n$env.array | filter(ok)\n$env.array | filter(true)\n$env.array | find(false)\n$env.array | find(ok)\n$env.array | find(true)\n$env.array | findIndex(false)\n$env.array | findIndex(nil == list)\n$env.array | findIndex(ok)\n$env.array | findIndex(true)\n$env.array | findLast(ok)\n$env.array | findLast(true)\n$env.array | findLastIndex(false)\n$env.array | findLastIndex(ok)\n$env.array | findLastIndex(true)\n$env.array | groupBy(#)\n$env.array | groupBy(0)\n$env.array | groupBy(1)\n$env.array | groupBy(1.0)\n$env.array | groupBy(f64)\n$env.array | groupBy(foo)\n$env.array | groupBy(i)\n$env.array | groupBy(ok)\n$env.array | map(#)\n$env.array | map(#index)\n$env.array | map($env)\n$env.array | map(1)\n$env.array | map(array)\n$env.array | map(f64)\n$env.array | map(false)\n$env.array | map(foo)\n$env.array | map(greet)\n$env.array | map(i)\n$env.array | map(list)\n$env.array | map(ok)\n$env.array | map(str)\n$env.array | map(true)\n$env.array | mean(1.0)\n$env.array | mean(f64)\n$env.array | mean(i)\n$env.array | median(0, array)\n$env.array | median(1)\n$env.array | none(ok)\n$env.array | none(true)\n$env.array | one(ok)\n$env.array | reduce(#)\n$env.array | reduce(#, 0)\n$env.array | reduce(#, foo)\n```\n\n----------------------------------------\n\nTITLE: Using the toJSON function in Expr\nDESCRIPTION: Demonstrates the usage of the toJSON function with various data types and expressions in Expr language. This function serializes Expr values to JSON format.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_118\n\nLANGUAGE: Expr\nCODE:\n```\ntoJSON(f32 ** i32)\ntoJSON(f32 + 0.5)\ntoJSON(f32 + f32)\ntoJSON(f32 - 0.5)\ntoJSON(f32 - f32)\ntoJSON(f32 - f64)\ntoJSON(f32 - i64)\ntoJSON(f32 < 0.5)\ntoJSON(f32 < i)\ntoJSON(f32 < i64)\ntoJSON(f32 <= 0.5)\ntoJSON(f32 <= 1)\ntoJSON(f32 <= i64)\ntoJSON(f32 == f64)\ntoJSON(f32 == i)\ntoJSON(f32 == nil)\ntoJSON(f32 > i)\ntoJSON(f32 > i32)\ntoJSON(f32 >= 0.5)\ntoJSON(f32 ^ i64)\ntoJSON(f32)\ntoJSON(f32) in foo\ntoJSON(f64 != 0.5)\ntoJSON(f64 != f32)\ntoJSON(f64 != i)\ntoJSON(f64 != i32)\ntoJSON(f64 != nil)\ntoJSON(f64 * 1)\ntoJSON(f64 * f64)\ntoJSON(f64 * i64)\ntoJSON(f64 ** 0.5)\ntoJSON(f64 ** f32)\ntoJSON(f64 + 0.5)\ntoJSON(f64 + f32)\ntoJSON(f64 + i32)\ntoJSON(f64 - f64)\ntoJSON(f64 - i)\ntoJSON(f64 - i64)\ntoJSON(f64 / 1)\ntoJSON(f64 < f64)\ntoJSON(f64 <= 0.5)\ntoJSON(f64 == f64)\ntoJSON(f64 >= 1)\ntoJSON(f64 >= f64)\ntoJSON(f64 ^ f32)\ntoJSON(f64)\ntoJSON(false != ok)\ntoJSON(false ? 0.5 : \"foo\")\ntoJSON(false ? add : f64)\ntoJSON(false ? array : 1)\ntoJSON(false ? false : foo)\ntoJSON(false ? nil : ok)\ntoJSON(false ? ok : i32)\ntoJSON(filter(list, true))\ntoJSON(find(list, ok))\ntoJSON(findIndex(map(array, list), ok))\ntoJSON(first(array))\ntoJSON(first(list))\ntoJSON(float(0.5))\ntoJSON(float(1))\ntoJSON(float(f32))\ntoJSON(float(f64))\ntoJSON(float(i))\ntoJSON(float(i64))\ntoJSON(floor(0.5))\ntoJSON(floor(f64))\ntoJSON(floor(i))\ntoJSON(floor(i32))\ntoJSON(foo != nil)\ntoJSON(foo in list)\ntoJSON(foo)\ntoJSON(foo.Bar)\ntoJSON(foo.String())\ntoJSON(foo?.Bar)\ntoJSON(foo?.String())\ntoJSON(get(array, i32))\ntoJSON(get(array, i64))\ntoJSON(get(list, 1))\ntoJSON(get(list, i))\ntoJSON(get(list, i32))\ntoJSON(get(list, i64))\ntoJSON(greet != nil)\ntoJSON(greet == greet)\ntoJSON(greet == nil)\ntoJSON(greet(\"bar\"))\ntoJSON(greet(\"foo\"))\ntoJSON(groupBy(array, #)?.div)\ntoJSON(groupBy(array, ok)?.foo)\ntoJSON(groupBy(list, #)?.foo)\ntoJSON(half(0.5))\ntoJSON(half(1))\ntoJSON(half(f64))\ntoJSON(i != 0.5)\ntoJSON(i != 1)\ntoJSON(i % i)\ntoJSON(i % i32)\ntoJSON(i * 0.5)\ntoJSON(i * 1)\ntoJSON(i * f32)\ntoJSON(i * i)\ntoJSON(i * i32)\ntoJSON(i ** f32)\ntoJSON(i ** i)\ntoJSON(i + 0.5)\ntoJSON(i + 1)\ntoJSON(i + i)\ntoJSON(i - 1)\ntoJSON(i - f32)\ntoJSON(i .. i)\ntoJSON(i .. i32)\ntoJSON(i / i64)\ntoJSON(i < f32)\ntoJSON(i < f64)\ntoJSON(i < i)\ntoJSON(i < i32)\ntoJSON(i <= 1)\ntoJSON(i <= f32)\ntoJSON(i <= f64)\ntoJSON(i <= i)\ntoJSON(i <= i32)\ntoJSON(i <= i64)\ntoJSON(i == 0.5)\ntoJSON(i == 1)\ntoJSON(i == i32)\ntoJSON(i == nil)\ntoJSON(i > 0.5)\ntoJSON(i > i)\ntoJSON(i > i32)\ntoJSON(i > i64)\ntoJSON(i >= f64)\ntoJSON(i >= i32)\ntoJSON(i ^ i64)\ntoJSON(i not in array)\ntoJSON(i)\ntoJSON(i) matches string(\"bar\")\ntoJSON(i32 != i)\ntoJSON(i32 != i64)\ntoJSON(i32 % 1)\ntoJSON(i32 * 0.5)\ntoJSON(i32 * i)\ntoJSON(i32 * i32)\ntoJSON(i32 * i64)\ntoJSON(i32 ** f64)\ntoJSON(i32 ** i64)\ntoJSON(i32 + 0.5)\ntoJSON(i32 + 1)\ntoJSON(i32 + f64)\ntoJSON(i32 .. i)\ntoJSON(i32 .. i64)\ntoJSON(i32 / 0.5)\ntoJSON(i32 / f32)\ntoJSON(i32 / f64)\ntoJSON(i32 / i64)\ntoJSON(i32 < 0.5)\ntoJSON(i32 < 1)\ntoJSON(i32 < i)\ntoJSON(i32 < i32)\ntoJSON(i32 <= 0.5)\ntoJSON(i32 > f64)\ntoJSON(i32 > i)\ntoJSON(i32 > i32)\ntoJSON(i32 >= f64)\ntoJSON(i32 ^ 0.5)\ntoJSON(i32 ^ f32)\ntoJSON(i32 ^ f64)\ntoJSON(i32 ^ i32)\ntoJSON(i32 in array)\ntoJSON(i32 not in array)\ntoJSON(i32)\ntoJSON(i32) contains foo.Bar\ntoJSON(i64 != 1)\ntoJSON(i64 != i)\ntoJSON(i64 != i32)\ntoJSON(i64 % i32)\ntoJSON(i64 * 0.5)\ntoJSON(i64 * f64)\ntoJSON(i64 ** f64)\ntoJSON(i64 ** i)\ntoJSON(i64 ** i32)\ntoJSON(i64 + 1)\ntoJSON(i64 - i32)\ntoJSON(i64 .. 1)\ntoJSON(i64 .. i32)\ntoJSON(i64 / f64)\ntoJSON(i64 / i)\ntoJSON(i64 / i64)\ntoJSON(i64 < 1)\ntoJSON(i64 < f64)\ntoJSON(i64 < i32)\ntoJSON(i64 <= 1)\ntoJSON(i64 <= i64)\ntoJSON(i64 == 0.5)\ntoJSON(i64 > 0.5)\ntoJSON(i64 > 1)\ntoJSON(i64 > i)\ntoJSON(i64 > i32)\ntoJSON(i64 > i64)\ntoJSON(i64 >= 1)\ntoJSON(i64 >= i)\ntoJSON(i64 >= i64)\ntoJSON(i64 ^ 0.5)\ntoJSON(i64 ^ f32)\ntoJSON(i64 ^ i32)\ntoJSON(i64 in array)\ntoJSON(i64)\ntoJSON(int(0.5))\ntoJSON(int(1))\ntoJSON(int(i))\ntoJSON(int(i32))\ntoJSON(int(i64))\ntoJSON(len(\"bar\"))\ntoJSON(len(array))\ntoJSON(len(greet(\"foo\")))\ntoJSON(len(list))\ntoJSON(list != array)\ntoJSON(list != nil)\ntoJSON(list == array)\ntoJSON(list == list)\ntoJSON(list)\ntoJSON(list[1])\ntoJSON(lower(\"bar\"))\ntoJSON(map(array, #))\ntoJSON(map(array, -#))\ntoJSON(map(array, array))\ntoJSON(map(array, false))\ntoJSON(map(array, i))\ntoJSON(map(array, i64))\ntoJSON(map(array, list))\ntoJSON(map(list, #))\ntoJSON(map(list, 0.5))\ntoJSON(map(list, 1))\ntoJSON(map(list, foo))\ntoJSON(map(list, i32))\ntoJSON(map(list, i64))\ntoJSON(map(list, list))\ntoJSON(map(list, ok))\ntoJSON(max(1))\ntoJSON(max(f32))\ntoJSON(max(f64))\ntoJSON(max(i32))\ntoJSON(mean(array))\ntoJSON(median(array))\ntoJSON(min(0.5))\ntoJSON(min(1))\ntoJSON(min(f32))\ntoJSON(min(f64))\ntoJSON(min(f64, f64))\ntoJSON(min(i))\ntoJSON(min(i32))\ntoJSON(min(i64))\ntoJSON(nil != 0.5)\ntoJSON(nil != 1)\ntoJSON(nil != add)\ntoJSON(nil != array)\ntoJSON(nil != f32)\ntoJSON(nil != false)\ntoJSON(nil != foo)\ntoJSON(nil != greet)\ntoJSON(nil != half)\ntoJSON(nil == 0.5)\ntoJSON(nil == 1)\ntoJSON(nil == div)\ntoJSON(nil == f64)\ntoJSON(nil == half)\ntoJSON(nil == i)\ntoJSON(nil == i64)\ntoJSON(nil == list)\ntoJSON(nil == nil)\ntoJSON(nil == ok)\ntoJSON(nil in array)\ntoJSON(nil) + foo.Bar\ntoJSON(none(array, ok))\ntoJSON(none(array, true))\ntoJSON(none(list, false))\ntoJSON(none(list, ok))\ntoJSON(not (\"foo\" not in foo))\ntoJSON(not (f32 != 1))\ntoJSON(not false)\ntoJSON(not ok)\ntoJSON(not true)\ntoJSON(ok != false)\ntoJSON(ok && false)\ntoJSON(ok && ok)\ntoJSON(ok == nil)\ntoJSON(ok == ok)\ntoJSON(ok ? \"foo\" : f32)\ntoJSON(ok ? 0.5 : f32)\ntoJSON(ok ? f64 : 0.5)\ntoJSON(ok ? i : false)\ntoJSON(ok ? nil : i)\ntoJSON(ok ? nil : true)\ntoJSON(ok ? true : greet)\ntoJSON(ok and ok)\ntoJSON(ok or true)\ntoJSON(ok)\ntoJSON(one(array, false))\ntoJSON(one(array, true))\ntoJSON(reduce(array, #))\ntoJSON(reduce(array, 0.5))\ntoJSON(reduce(array, array))\ntoJSON(reduce(array, foo))\ntoJSON(reduce(array, i64))\ntoJSON(reduce(array, list))\ntoJSON(reduce(array, score(i32 * i64)))\ntoJSON(reduce(list, #))\ntoJSON(reduce(list, 1))\ntoJSON(reduce(list, f32))\ntoJSON(reduce(list, false))\ntoJSON(reduce(list, i))\ntoJSON(reduce(list, i32))\ntoJSON(reduce(list, list))\ntoJSON(reduce(list, ok))\ntoJSON(reduce(list, true))\ntoJSON(round(1))\ntoJSON(round(f64))\ntoJSON(round(i32))\ntoJSON(score != score)\ntoJSON(score(1))\ntoJSON(score(1, 1))\ntoJSON(score(i))\ntoJSON(sort(array))\ntoJSON(string(\"bar\"))\ntoJSON(string(0.5))\ntoJSON(string(1))\ntoJSON(string(array))\ntoJSON(string(f32))\ntoJSON(string(f64))\ntoJSON(string(false))\ntoJSON(string(foo))\ntoJSON(string(half))\ntoJSON(string(i))\ntoJSON(string(i32))\ntoJSON(string(i64))\ntoJSON(string(list))\ntoJSON(string(nil))\ntoJSON(string(ok))\ntoJSON(string(score))\ntoJSON(string(true))\ntoJSON(sum(array))\ntoJSON(take(array, i32))\ntoJSON(toBase64(\"bar\"))\ntoJSON(toJSON(\"bar\"))\ntoJSON(toJSON(array))\ntoJSON(toJSON(f32))\ntoJSON(toJSON(f64))\ntoJSON(toJSON(false))\ntoJSON(toJSON(foo))\ntoJSON(toJSON(i))\ntoJSON(toJSON(i32))\ntoJSON(toJSON(i64))\ntoJSON(toJSON(list))\ntoJSON(toJSON(nil))\ntoJSON(toJSON(ok))\ntoJSON(trim(\"bar\"))\ntoJSON(trimPrefix(\"foo\"))\ntoJSON(trimSuffix(\"bar\"))\ntoJSON(true != true)\ntoJSON(true && ok)\ntoJSON(true == ok)\ntoJSON(true ? \"bar\" : \"bar\")\ntoJSON(true ? nil : score)\ntoJSON(true and false)\ntoJSON(true and true)\ntoJSON(true) in foo\ntoJSON(type(\"foo\"))\ntoJSON(type(add))\ntoJSON(type(array))\ntoJSON(type(f32))\ntoJSON(type(f64))\ntoJSON(type(false))\ntoJSON(type(foo))\ntoJSON(type(i))\ntoJSON(type(i32))\ntoJSON(type(i64))\ntoJSON(type(list))\ntoJSON(type(ok))\ntoJSON(type(score))\ntoJSON(type(true))\ntoJSON(upper(\"bar\"))\ntoJSON({\"bar\": 1, \"bar\": array})\ntoJSON({\"bar\": 1})\ntoJSON({\"bar\": f64})\ntoJSON({\"bar\": list})\ntoJSON({\"foo\": i})\ntoJSON({\"foo\": nil})\n```\n\n----------------------------------------\n\nTITLE: Convert to Float Using float() in Expr\nDESCRIPTION: The `float()` function converts a number or a string representation of a number into its corresponding float value.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_80\n\nLANGUAGE: expr\nCODE:\n```\nfloat(\"123.45\") == 123.45\n```\n\n----------------------------------------\n\nTITLE: indexOf Function in Expr\nDESCRIPTION: Illustrates the use of the `indexOf` function to find the index of the first occurrence of a substring within a string.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_31\n\nLANGUAGE: expr\nCODE:\n```\nindexOf(\"apple pie\", \"pie\") == 6\n```\n\n----------------------------------------\n\nTITLE: Expr: Type Checks with Numerical and Arithmetic Operations\nDESCRIPTION: This snippet uses the 'type()' function to check the type resulting from various arithmetic and numerical comparisons involving integers, floats, and nil values.  It shows how basic operations affect the resulting data type.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_259\n\nLANGUAGE: Expr\nCODE:\n```\ntype(0 != $env)\ntype(0 != 0)\ntype(0 != 1.0)\ntype(0 != f64)\ntype(0 != i)\ntype(0 != nil)\ntype(0 % i)\ntype(0 * 0)\ntype(0 + 0)\ntype(0 + 1)\ntype(0 + i)\ntype(0 - 1)\ntype(0 - f64)\ntype(0 .. 0)\ntype(0 .. 1)\ntype(0 .. i)\ntype(0 / 1)\ntype(0 / 1.0)\ntype(0 / i)\ntype(0 < 1.0)\ntype(0 <= 1)\ntype(0 <= i)\ntype(0 == 1)\ntype(0 == 1.0)\ntype(0 == i)\ntype(0 == nil)\ntype(0 > 1.0)\ntype(0 ^ 1.0)\ntype(0 ^ i)\ntype(0 | median(1, 1.0))\ntype(0 | min(0))\ntype(0 | min(i))\n\n```\n\n----------------------------------------\n\nTITLE: Bitwise Operations in Expr\nDESCRIPTION: Illustrates various bitwise operations (|, ^, bitand, bitnand, bitor, bitshl, bitshr, bitushr, bitxor, bitnot) in the Expr language. The examples demonstrate how to use these operators with different data types, including integers, floats, and variables, to perform bit manipulation and logical operations at the bit level.  The variable 'i' and environment variable '$env' are used to demonstrate the operations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_158\n\nLANGUAGE: Expr\nCODE:\n```\ni ^ $env.f64\ni ^ $env.i\ni ^ $env?.f64\ni ^ $env?.i\ni ^ 0 != 1.0\ni ^ 0 < i\ni ^ 0 not in array\ni ^ 1 == 0\ni ^ 1.0 != i\ni ^ 1.0 != nil\ni ^ 1.0 - 0\ni ^ 1.0 < 1\ni ^ 1.0 <= 0\ni ^ 1.0 == 0\ni ^ 1.0 > 1.0\ni ^ 1.0 > f64\ni ^ 1.0 > i\ni ^ 1.0 > max(0)\ni ^ 1.0 | max(0)\ni ^ abs(0)\ni ^ array?.[i]\ni ^ ceil(1)\ni ^ count($env, false)\ni ^ f64\ni ^ f64 * 0\ni ^ f64 ** f64\ni ^ f64 >= 1\ni ^ f64 ^ 1.0\ni ^ first(array)\ni ^ float(1.0)\ni ^ floor(1.0)\ni ^ i\ni ^ i * i\ni ^ i / f64\ni ^ i == nil\ni ^ i >= i\ni ^ i not in array\ni ^ int(1)\ni ^ int(1.0)\ni ^ len($env)\ni ^ max(array)\ni ^ mean(1.0)\ni ^ mean(array)\ni ^ mean(f64)\ni ^ min(1.0)\ni ^ min(i)\ni ^ sum(array)\ni | add(0)\ni | add(1)\ni | add(i)\ni | bitand(0)\ni | bitand(1)\ni | bitand(1) + i\ni | bitand(i)\ni | bitnand(0)\ni | bitnand(1)\ni | bitnand(i)\ni | bitor(0)\ni | bitor(1 % 1)\ni | bitor(1)\ni | bitor(i)\ni | bitshl($env.i)\ni | bitshl(0)\ni | bitshl(1)\ni | bitshl(i)\ni | bitshr(0)\ni | bitshr(0) != 1.0 || false\ni | bitshr(1)\ni | bitshr(i)\ni | bitushr(0)\ni | bitushr(1)\ni | bitushr(i)\ni | bitxor(0)\ni | bitxor(1)\ni | bitxor(i)\n```\n\n----------------------------------------\n\nTITLE: Reducing List with Various Parameters in Expr\nDESCRIPTION: This snippet demonstrates the `reduce` function on a list in the Expr language. It shows how `reduce` can be used with different parameters, including field accesses, environment variables, literals, and function calls. These parameters represent the initial accumulator value or the transformation applied to each element during reduction.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_172\n\nLANGUAGE: Expr\nCODE:\n```\nlist | reduce(#.String == nil)\nlist | reduce(#.String)\nlist | reduce(#.String, $env)\nlist | reduce(#.String, 1)\nlist | reduce(#.String, f64)\nlist | reduce(#.String, i)\nlist | reduce(#.String, nil)\nlist | reduce(#.String, true)\nlist | reduce(#?.Bar)\nlist | reduce(#?.String)\nlist | reduce(#acc)\nlist | reduce(#acc, $env)\nlist | reduce(#acc, 1)\nlist | reduce(#acc, 1.0)\nlist | reduce(#acc, add)\nlist | reduce(#acc, f64)\nlist | reduce(#acc, foo)\nlist | reduce(#acc, nil)\nlist | reduce(#acc, str)\nlist | reduce(#acc, true)\nlist | reduce(#index - 0)\nlist | reduce(#index <= 1)\nlist | reduce(#index)\nlist | reduce(#index, $env)\nlist | reduce(#index, 1.0)\nlist | reduce(#index, false)\nlist | reduce(#index, foo)\nlist | reduce(#index, list)\nlist | reduce(#index, nil)\nlist | reduce($env != #)\nlist | reduce($env not in array)\nlist | reduce($env)\nlist | reduce($env, $env)\nlist | reduce($env, 1)\nlist | reduce($env, 1.0)\nlist | reduce($env, add)\nlist | reduce($env, f64)\nlist | reduce($env, foo)\nlist | reduce($env, greet)\nlist | reduce($env, i)\nlist | reduce($env, list)\nlist | reduce($env, nil)\nlist | reduce($env, ok)\nlist | reduce($env, str)\nlist | reduce($env, true)\nlist | reduce($env.i)\nlist | reduce($env?.String)\nlist | reduce($env?.[String])\nlist | reduce($env?.[foobar])\nlist | reduce($env?.[str])\nlist | reduce($env?.add, max(1))\nlist | reduce(.Bar not in $env)\nlist | reduce(.Bar)\nlist | reduce(.Bar, 0)\nlist | reduce(.Bar, 1.0)\nlist | reduce(.Bar, i)\nlist | reduce(.Bar, nil)\nlist | reduce(.Bar, ok)\nlist | reduce(.Bar, true)\nlist | reduce(.String)\nlist | reduce(.String, $env)\nlist | reduce(.String, 0)\nlist | reduce(.String, 1.0)\nlist | reduce(.String, array)\nlist | reduce(.String, foo)\nlist | reduce(.String, greet)\nlist | reduce(.String, i)\nlist | reduce(.String, list)\nlist | reduce(.String, nil)\nlist | reduce(.String, ok)\nlist | reduce(0 == f64)\nlist | reduce(0)\nlist | reduce(0) ^ f64\nlist | reduce(0) | median(1.0)\nlist | reduce(0, $env)\nlist | reduce(0, 1.0)\nlist | reduce(0, array)\nlist | reduce(0, false)\nlist | reduce(0, foo)\nlist | reduce(0, i)\nlist | reduce(0, list)\nlist | reduce(0, nil)\nlist | reduce(0, ok)\nlist | reduce(0, true)\nlist | reduce(1 ** #index) <= i\nlist | reduce(1)\nlist | reduce(1, $env)\nlist | reduce(1, 1)\nlist | reduce(1, 1.0)\nlist | reduce(1, add)\nlist | reduce(1, array)\nlist | reduce(1, false)\nlist | reduce(1, foo)\nlist | reduce(1, greet)\nlist | reduce(1, i)\nlist | reduce(1, list)\nlist | reduce(1, nil)\nlist | reduce(1, ok)\nlist | reduce(1, str)\nlist | reduce(1, true)\nlist | reduce(1.0 <= i)\nlist | reduce(1.0 == 0)\nlist | reduce(1.0)\nlist | reduce(1.0, $env)\nlist | reduce(1.0, 0)\nlist | reduce(1.0, 1)\nlist | reduce(1.0, array)\nlist | reduce(1.0, f64)\nlist | reduce(1.0, false)\nlist | reduce(1.0, foo)\nlist | reduce(1.0, greet)\nlist | reduce(1.0, i)\nlist | reduce(1.0, list)\nlist | reduce(1.0, nil)\nlist | reduce(1.0, str)\nlist | reduce(1.0, true)\nlist | reduce([ok, foo])\nlist | reduce([true, #])\nlist | reduce(add)\nlist | reduce(add, $env)\nlist | reduce(add, 1)\nlist | reduce(add, 1.0)\nlist | reduce(add, array)\nlist | reduce(add, f64)\nlist | reduce(add, false)\nlist | reduce(add, foo)\nlist | reduce(add, nil)\nlist | reduce(array)\nlist | reduce(array) | none(ok)\nlist | reduce(array) | reduce(array)\nlist | reduce(array, $env)\nlist | reduce(array, 0)\nlist | reduce(array, 1)\nlist | reduce(array, 1.0)\nlist | reduce(array, add)\nlist | reduce(array, array)\nlist | reduce(array, f64)\nlist | reduce(array, false)\nlist | reduce(array, foo)\nlist | reduce(array, greet)\nlist | reduce(array, i)\nlist | reduce(array, nil)\nlist | reduce(array, ok)\nlist | reduce(array, str)\nlist | reduce(f64 != nil)\nlist | reduce(f64 <= 1.0)\nlist | reduce(f64)\nlist | reduce(f64, $env)\nlist | reduce(f64, 0)\nlist | reduce(f64, 1.0)\nlist | reduce(f64, array)\nlist | reduce(f64, f64)\nlist | reduce(f64, false)\nlist | reduce(f64, foo)\nlist | reduce(f64, greet)\nlist | reduce(f64, list)\nlist | reduce(f64, nil)\nlist | reduce(f64, str)\nlist | reduce(false || $env)\nlist | reduce(false)\nlist | reduce(false, $env)\nlist | reduce(false, 1)\nlist | reduce(false, 1.0)\nlist | reduce(false, array)\nlist | reduce(false, f64)\nlist | reduce(false, false)\nlist | reduce(false, foo)\nlist | reduce(false, greet)\nlist | reduce(false, i)\nlist | reduce(false, ok)\nlist | reduce(false, true)\nlist | reduce(first($env))\nlist | reduce(float(1.0))\nlist | reduce(foo == foo)\nlist | reduce(foo)\nlist | reduce(foo, $env)\nlist | reduce(foo, $env.array)\nlist | reduce(foo, 0)\nlist | reduce(foo, 1)\nlist | reduce(foo, 1.0)\nlist | reduce(foo, add)\nlist | reduce(foo, array)\nlist | reduce(foo, f64)\nlist | reduce(foo, foo)\nlist | reduce(foo, greet)\nlist | reduce(foo, i)\nlist | reduce(foo, list)\nlist | reduce(foo, nil)\nlist | reduce(foo, ok)\nlist | reduce(foo, str)\nlist | reduce(foo, true)\nlist | reduce(foo.Bar)\nlist | reduce(greet)\nlist | reduce(greet, $env)\nlist | reduce(greet, 1.0)\nlist | reduce(greet, add)\nlist | reduce(greet, array)\nlist | reduce(greet, false)\nlist | reduce(greet, foo)\nlist | reduce(greet, greet)\nlist | reduce(greet, list)\nlist | reduce(greet, nil)\nlist | reduce(greet, str)\nlist | reduce(greet, true)\nlist | reduce(i ^ i)\nlist | reduce(i)\nlist | reduce(i, 0)\nlist | reduce(i, 1.0)\nlist | reduce(i, add)\nlist | reduce(i, false)\nlist | reduce(i, foo)\nlist | reduce(i, greet)\nlist | reduce(i, i)\nlist | reduce(i, list) != $env?.String\nlist | reduce(i, nil)\nlist | reduce(i, str)\nlist | reduce(list)\nlist | reduce(list) | groupBy(0)\nlist | reduce(list, $env)\nlist | reduce(list, 1.0)\nlist | reduce(list, add)\nlist | reduce(list, array)\nlist | reduce(list, foo)\nlist | reduce(list, greet)\nlist | reduce(list, i)\nlist | reduce(list, nil)\nlist | reduce(list, ok)\nlist | reduce(list, str)\nlist | reduce(ok and #acc)\nlist | reduce(ok)\nlist | reduce(ok, $env)\nlist | reduce(ok, add)\nlist | reduce(ok, false)\nlist | reduce(ok, foo)\nlist | reduce(ok, i)\nlist | reduce(ok, list)\nlist | reduce(ok, nil)\nlist | reduce(ok, ok)\nlist | reduce(reduce(list, .Bar), ok)\nlist | reduce(str)\nlist | reduce(str) >= foo.Bar\nlist | reduce(str) contains str\nlist | reduce(str, $env)\nlist | reduce(str, 0)\nlist | reduce(str, 1.0)\nlist | reduce(str, add)\nlist | reduce(str, array)\nlist | reduce(str, f64)\nlist | reduce(str, foo)\nlist | reduce(str, i)\nlist | reduce(str, list)\nlist | reduce(str, ok)\nlist | reduce(str, str)\nlist | reduce(trim(str))\nlist | reduce(true and ok)\nlist | reduce(true)\nlist | reduce(true, 0)\nlist | reduce(true, array)\nlist | reduce(true, f64)\nlist | reduce(true, false)\nlist | reduce(true, foo)\nlist | reduce(true, i)\nlist | reduce(true, ok)\nlist | reduce(type(#))\nlist | reduce(values($env))\n```\n\n----------------------------------------\n\nTITLE: Field Access and Arithmetic Operations - Expr\nDESCRIPTION: Illustrates field access and arithmetic operations on fields with optional chaining in the Expr language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_109\n\nLANGUAGE: Expr\nCODE:\n```\nfoo.Bar\nfoo?.Bar\nfoo?.Bar + str\nfoo?.Bar + type(i)\nfoo.Bar + str\n```\n\n----------------------------------------\n\nTITLE: Counting with Collection Membership in Expr\nDESCRIPTION: This snippet demonstrates the use of 'in' and 'not in' operators for checking membership of an element within a collection, used in conjunction with the count function in Expr. It shows checking for inclusion in both 'array' and 'list'.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_28\n\nLANGUAGE: Expr\nCODE:\n```\ncount(array, # in array)\ncount(array, # not in array)\n```\n\n----------------------------------------\n\nTITLE: trimPrefix Function in Expr\nDESCRIPTION: Demonstrates the trimPrefix function, which removes a specified prefix from a string. Includes examples using different data sources and conversions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_245\n\nLANGUAGE: Expr\nCODE:\n```\ntrimPrefix($env.str)\ntrimPrefix($env?.[str])\ntrimPrefix($env?.str)\ntrimPrefix($env?.str, str)\ntrimPrefix(false ? greet : str)\ntrimPrefix(foo.Bar)\ntrimPrefix(foo.String())\ntrimPrefix(foo?.Bar)\ntrimPrefix(foo?.String())\ntrimPrefix(greet(str))\ntrimPrefix(greet(toJSON(false)))\ntrimPrefix(lower(str))\ntrimPrefix(reduce(list, str))\ntrimPrefix(str)\ntrimPrefix(str) <= str\ntrimPrefix(str, false ? i : str)\ntrimPrefix(str, foo?.Bar)\ntrimPrefix(str, str)\ntrimPrefix(str, type(true))\ntrimPrefix(str[0:])\ntrimPrefix(str[:i])\ntrimPrefix(string($env))\ntrimPrefix(string(0))\ntrimPrefix(string(1))\ntrimPrefix(string(1.0))\ntrimPrefix(string(array))\ntrimPrefix(string(false))\ntrimPrefix(string(foo))\ntrimPrefix(string(greet))\ntrimPrefix(string(i))\ntrimPrefix(string(list))\ntrimPrefix(string(nil))\ntrimPrefix(string(ok))\ntrimPrefix(string(str))\ntrimPrefix(string(true))\ntrimPrefix(toBase64(str))\ntrimPrefix(toJSON(0))\ntrimPrefix(toJSON(1.0))\ntrimPrefix(toJSON(array))\ntrimPrefix(toJSON(f64))\ntrimPrefix(toJSON(false))\ntrimPrefix(toJSON(foo))\ntrimPrefix(toJSON(i))\ntrimPrefix(toJSON(nil))\ntrimPrefix(toJSON(ok))\ntrimPrefix(toJSON(str))\ntrimPrefix(toJSON(true))\ntrimPrefix(trim(str))\ntrimPrefix(trimPrefix(str))\ntrimPrefix(trimPrefix(str, str))\ntrimPrefix(trimSuffix(str))\ntrimPrefix(type($env))\ntrimPrefix(type(0))\ntrimPrefix(type(1.0))\ntrimPrefix(type(add))\ntrimPrefix(type(array))\ntrimPrefix(type(f64))\ntrimPrefix(type(false))\ntrimPrefix(type(foo))\ntrimPrefix(type(i))\ntrimPrefix(type(nil))\ntrimPrefix(type(true))\ntrimPrefix(upper(str))\n```\n\n----------------------------------------\n\nTITLE: Using the median function in Expr\nDESCRIPTION: This snippet demonstrates the `median` function with different data types and operations, including ranges, arrays, map, filter, groupBy, and reduce operations. It showcases the capabilities of the `median` function in various scenarios within the Expr language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_83\n\nLANGUAGE: expr\nCODE:\n```\nmedian(1 .. i)\nmedian(array)\nmedian(array) != f32\nmedian(array) * 1 * f32\nmedian(array) * i32\nmedian(array) ** i64\nmedian(array) + f32\nmedian(array) >= i32\nmedian(array) ^ i32\nmedian(array) ^ i64\nmedian(array) not in array\nmedian(array[1:1])\nmedian(filter(array, ok))\nmedian(groupBy(list, #).i32)\nmedian(i .. i)\nmedian(i .. i64)\nmedian(i64 .. i64)\nmedian(map(array, #))\nmedian(map(array, 1))\nmedian(map(list, 0.5))\nmedian(map(list, f32))\nmedian(map(list, i32))\nmedian(reduce(array, array))\nmedian(reduce(list, array))\nmedian(sort(array))\n```\n\n----------------------------------------\n\nTITLE: Expr: 'in' and 'not in' list containment operations\nDESCRIPTION: This snippet demonstrates the 'in' and 'not in' operators used to check for the presence or absence of an element within a list (or array) using optional chaining.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_252\n\nLANGUAGE: Expr\nCODE:\n```\ntrue in $env?.Bar\ntrue in $env?.String\ntrue in $env?.[Bar]\ntrue in $env?.[String]\ntrue in $env?.[foobar]\ntrue not in $env?.Bar\ntrue not in $env?.String\ntrue not in $env?.[Bar]\ntrue not in $env?.[Bar]?.String\ntrue not in $env?.[Bar]?.foo\ntrue not in $env?.[String]\ntrue not in $env?.[String]?.[list]\ntrue not in $env?.[foobar]\n\n```\n\n----------------------------------------\n\nTITLE: Max Function Usage in Expr\nDESCRIPTION: This code snippet provides examples of using the `max` function within the Expr language.  It demonstrates finding the maximum value among various data types, performing arithmetic operations before determining the maximum, and using different function calls as input for the `max` function.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_80\n\nLANGUAGE: Expr\nCODE:\n```\nmax(-0.5)\nmax(-1)\nmax(-f32)\nmax(-f64)\nmax(-findIndex(array, ok))\nmax(-i)\nmax(-i, f32)\nmax(-i32)\nmax(-i64)\nmax(-reduce(array, #))\nmax(0.5 * f32)\nmax(0.5 * i)\nmax(0.5 * i64)\nmax(0.5 ** 0.5)\nmax(0.5 ** 1)\nmax(0.5 ** f32)\nmax(0.5 ** f64 ^ reduce(array, f64))\nmax(0.5 ** i)\nmax(0.5 ** i32)\nmax(0.5 + 1)\nmax(0.5 - 0.5)\nmax(0.5 - f32)\nmax(0.5 - f64)\nmax(0.5 / 0.5)\nmax(0.5 / 1)\nmax(0.5 / f64)\nmax(0.5 / i32)\nmax(0.5 / i64)\nmax(0.5 ^ 0.5)\nmax(0.5 ^ 1)\nmax(0.5 ^ i)\nmax(0.5 ^ i32)\nmax(0.5 ^ i64)\nmax(0.5) != f32\nmax(0.5) != i\nmax(0.5) + f64\nmax(0.5) + i\nmax(0.5) - i32\nmax(0.5) / i64\nmax(0.5) <= i\nmax(0.5) > f64\nmax(0.5) > i\nmax(0.5) > i64\nmax(0.5) >= i64\nmax(0.5, 0.5) != i\nmax(0.5, i) ** i32\nmax(1 % 1)\nmax(1 % i64)\nmax(1 * 0.5)\nmax(1 * 1)\nmax(1 * f64)\nmax(1 * i32)\nmax(1 ** 0.5)\nmax(1 ** 1)\nmax(1 ** f32)\nmax(1 ** i64)\nmax(1 + f32)\nmax(1 + i64)\nmax(1 - f32)\nmax(1 - f64)\nmax(1 / 1)\nmax(1 / f32)\nmax(1 / f32, i64)\nmax(1 / f64)\nmax(1 / i)\nmax(1 / i32)\nmax(1 / i64)\nmax(1 ^ 0.5)\nmax(1 ^ 1)\nmax(1 ^ f32)\nmax(1 ^ f64)\nmax(1 ^ i32)\nmax(1 ^ i64)\nmax(1) != 1 ? foo : \"bar\"\nmax(1) + f32\nmax(1) - f64\nmax(1) .. i\nmax(1) / i\nmax(1) == i64\nmax(1) > f64\nmax(1) > i32\nmax(1, i) not in array\nmax(abs(0.5))\nmax(abs(1))\nmax(abs(f32))\nmax(abs(f64))\nmax(abs(i))\nmax(abs(i32))\nmax(add(1, i))\nmax(array[1])\nmax(array[i64])\nmax(bitnand(i32, 1))\nmax(bitnot(1))\nmax(bitnot(i))\nmax(bitnot(i64))\nmax(bitshr(1, i32))\nmax(bitxor(1, 1))\nmax(ceil(0.5), f64 / i64)\nmax(ceil(f32))\nmax(ceil(i32))\nmax(f32 * 1)\nmax(f32 * f64)\nmax(f32 * i64)\nmax(f32 ** 1)\nmax(f32 ** f64)\nmax(f32 + 1)\nmax(f32 + f64)\nmax(f32 + i)\nmax(f32 + i64)\nmax(f32 - 1)\nmax(f32 - i64)\nmax(f32 / 0.5)\nmax(f32 / f32)\nmax(f32 ^ 1)\nmax(f32 ^ f32)\nmax(f32 ^ f64)\nmax(f32 ^ i64)\nmax(f32)\nmax(f32) * i64\nmax(f32) ** i\nmax(f32) + f32\nmax(f32) + f64\nmax(f32) - f64\nmax(f32) / i32\nmax(f32) < i\nmax(f32) == i\nmax(f32) ^ f32\nmax(f32, f32)\nmax(f32, f64)\nmax(f32, f64) in array\nmax(f32, i)\nmax(f32, i32)\nmax(f32, i32) ** i64\nmax(f32, i64)\nmax(f64 * 1)\nmax(f64 * f64)\nmax(f64 ** 0.5)\nmax(f64 ** f64)\nmax(f64 ** i)\nmax(f64 + 1)\nmax(f64 + f32)\nmax(f64 + f64)\nmax(f64 - 0.5)\nmax(f64 - i)\nmax(f64 ^ 0.5)\nmax(f64 ^ 1)\nmax(f64 ^ f32)\nmax(f64 ^ f64)\nmax(f64)\nmax(f64) != f64\nmax(f64) < i32\nmax(f64) <= f32\nmax(f64) == f32\nmax(f64) == i\nmax(f64) == round(i)\nmax(f64) ^ f32\nmax(f64) ^ i64\nmax(f64, f32)\nmax(f64, f32) <= int(f64)\nmax(f64, f64)\nmax(f64, i)\nmax(f64, i) - 1 ^ i\nmax(f64, i) < i\nmax(f64, i) > f64\nmax(f64, i32)\nmax(f64, i64)\nmax(f64, i64) ^ f32\nmax(false ? 0.5 : array)\nmax(false ? add : f64)\nmax(false ? div : half)\nmax(false ? div : i64)\nmax(false ? ok : 0.5)\nmax(find(array, false))\nmax(findIndex(list, false))\nmax(findIndex(list, ok))\nmax(findLast(array, false))\nmax(float(0.5))\nmax(float(1))\nmax(float(1), i)\nmax(float(i32))\nmax(float(i64))\nmax(float(score(i))))\nmax(floor(0.5))\nmax(floor(1))\nmax(floor(f32))\nmax(floor(i))\nmax(floor(i32))\nmax(floor(len(array))))\nmax(get(array, 1))\nmax(get(array, i))\nmax(get(array, i32))\nmax(get(array, i64))\nmax(half(0.5))\nmax(half(1))\nmax(half(1), i64)\nmax(half(f64))\nmax(i % 1)\nmax(i * 0.5)\nmax(i * f32)\nmax(i * i)\nmax(i * i64)\nmax(i ** f64)\nmax(i ** score(1))\nmax(i + 1)\nmax(i - 1)\nmax(i - i)\nmax(i - i64)\nmax(i ^ f64)\nmax(i)\nmax(i) != i32\nmax(i) != i64\nmax(i) % (i64 + i)\nmax(i) % array[i32]\nmax(i) ** (1 / i32)\nmax(i) + f64\nmax(i) - i\nmax(i) / f32\nmax(i) / i\nmax(i) < 0.5 - f64\nmax(i) < f32\nmax(i) < i32\nmax(i) <= f64\nmax(i) == f64\nmax(i) >= i\nmax(i, f32)\nmax(i, f64)\nmax(i, i)\nmax(i, i32)\nmax(i, i64)\nmax(i, i64, i32)\nmax(i32 % 1)\nmax(i32 * 0.5)\nmax(i32 * 1)\nmax(i32 * f32)\nmax(i32 * i)\nmax(i32 * i64)\nmax(i32 ** f32)\nmax(i32 ** i)\nmax(i32 ** i32)\nmax(i32 + 0.5)\nmax(i32 + i64)\n```\n\n----------------------------------------\n\nTITLE: toJSON Function Usage (Expr)\nDESCRIPTION: Examples demonstrating the `toJSON` function for serializing various data types, performing comparisons, logical operations, and working with array/list manipulations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_241\n\nLANGUAGE: Expr\nCODE:\n```\ntoJSON($env != 0)\ntoJSON($env != add)\ntoJSON($env != array)\ntoJSON($env != false)\ntoJSON($env != foo)\ntoJSON($env != greet)\ntoJSON($env != list)\ntoJSON($env != nil)\ntoJSON($env != str)\ntoJSON($env != true)\ntoJSON($env == $env)\ntoJSON($env == 0)\ntoJSON($env == 1)\ntoJSON($env == f64)\ntoJSON($env == false)\ntoJSON($env == foo)\ntoJSON($env == list)\ntoJSON($env == nil)\ntoJSON($env == str)\ntoJSON($env == true)\ntoJSON($env in list)\ntoJSON($env not in list)\ntoJSON($env or true)\ntoJSON($env | all(false))\ntoJSON($env | count(false))\ntoJSON($env | findIndex(ok))\ntoJSON($env | map(array))\ntoJSON($env | map(f64))\ntoJSON($env | map(list))\ntoJSON($env | map(str))\ntoJSON($env | map(true))\ntoJSON($env | reduce(#index, nil))\ntoJSON($env | reduce(false, 1))\ntoJSON($env | sum(0))\ntoJSON($env | sum(1))\ntoJSON($env | sum(1.0))\ntoJSON($env || true)\ntoJSON($env.array)\ntoJSON($env.f64)\ntoJSON($env.foo)\ntoJSON($env.i)\ntoJSON($env.list)\ntoJSON($env.ok)\ntoJSON($env.str)\ntoJSON($env?.$env)\ntoJSON($env?.Bar)\ntoJSON($env?.Bar?.[greet])\ntoJSON($env?.String)\ntoJSON($env?.[Bar])\ntoJSON($env?.[String])\ntoJSON($env?.[foobar])\ntoJSON($env?.[foobar]?.i())\ntoJSON($env?.[nil])\ntoJSON($env?.[str])\ntoJSON($env?.array)\ntoJSON($env?.f64)\ntoJSON($env?.false)\ntoJSON($env?.foo)\ntoJSON($env?.foobar)\ntoJSON($env?.i)\ntoJSON($env?.list)\ntoJSON($env?.nil)\ntoJSON($env?.ok)\ntoJSON($env?.str)\ntoJSON(0 != $env)\ntoJSON(0 != nil)\ntoJSON(0 % 1)\ntoJSON(0 % i)\ntoJSON(0 * 1.0)\ntoJSON(0 ** 1.0)\ntoJSON(0 ** f64)\ntoJSON(0 + 0)\ntoJSON(0 + 1)\ntoJSON(0 + 1.0)\ntoJSON(0 - 1)\ntoJSON(0 - 1.0)\ntoJSON(0 - f64)\ntoJSON(0 .. i)\ntoJSON(0 / 1.0)\ntoJSON(0 / f64)\ntoJSON(0 < 1.0)\ntoJSON(0 <= 1.0)\ntoJSON(0 <= f64)\ntoJSON(0 == 1.0)\ntoJSON(0 == f64)\ntoJSON(0 == nil)\ntoJSON(0 > i)\ntoJSON(0 >= 0)\ntoJSON(0 >= 1)\ntoJSON(0 >= 1.0)\ntoJSON(0 ^ 1.0)\ntoJSON(0 ^ f64)\ntoJSON(0 ^ i)\ntoJSON(0 in array)\ntoJSON(0 not in array)\ntoJSON(0 | bitshl(0))\ntoJSON(0 | bitshr(0))\ntoJSON(0) + str\ntoJSON(0) > str\ntoJSON(0) >= str\ntoJSON(0..i)\ntoJSON(0.0)\ntoJSON(1 != $env)\ntoJSON(1 != i)\ntoJSON(1 != nil)\ntoJSON(1 * 1.0)\ntoJSON(1 * i)\ntoJSON(1 ** i)\ntoJSON(1 + 1)\ntoJSON(1 + 1.0)\ntoJSON(1 + f64)\ntoJSON(1 - f64)\ntoJSON(1 .. 0)\ntoJSON(1 .. 1)\ntoJSON(1 .. i)\ntoJSON(1 / f64)\ntoJSON(1 / i)\ntoJSON(1 < 0)\ntoJSON(1 < 1.0)\ntoJSON(1 <= 0)\ntoJSON(1 <= 1)\ntoJSON(1 <= i)\ntoJSON(1 == 0)\ntoJSON(1 == 1.0)\ntoJSON(1 == nil)\ntoJSON(1 > 0)\ntoJSON(1 > 1)\ntoJSON(1 > i)\ntoJSON(1 >= f64)\ntoJSON(1 >= i)\ntoJSON(1 ^ 1.0)\ntoJSON(1 not in array)\ntoJSON(1) != str\ntoJSON(1) endsWith str\ntoJSON(1) not contains str\ntoJSON(1) not in $env?.true\ntoJSON(1) | greet()\ntoJSON(1.0 != $env)\ntoJSON(1.0 != 0)\ntoJSON(1.0 != 1)\ntoJSON(1.0 != 1.0)\ntoJSON(1.0 != i)\ntoJSON(1.0 != nil)\ntoJSON(1.0 * 1)\ntoJSON(1.0 * 1.0)\ntoJSON(1.0 * f64)\ntoJSON(1.0 * i)\ntoJSON(1.0 ** 1)\ntoJSON(1.0 ** 1.0)\ntoJSON(1.0 ** i)\ntoJSON(1.0 + 0)\ntoJSON(1.0 + 1)\ntoJSON(1.0 + 1.0)\ntoJSON(1.0 - 0)\ntoJSON(1.0 - 1)\ntoJSON(1.0 - 1.0)\ntoJSON(1.0 - f64)\ntoJSON(1.0 / 1)\ntoJSON(1.0 / 1.0)\ntoJSON(1.0 / i)\ntoJSON(1.0 < i)\ntoJSON(1.0 <= 0)\ntoJSON(1.0 <= 1.0)\ntoJSON(1.0 <= f64)\ntoJSON(1.0 <= i)\ntoJSON(1.0 == $env)\ntoJSON(1.0 == 1)\ntoJSON(1.0 == 1.0)\ntoJSON(1.0 == f64)\ntoJSON(1.0 > 0)\ntoJSON(1.0 > 1.0)\ntoJSON(1.0 > i)\ntoJSON(1.0 >= 0)\ntoJSON(1.0 >= 1)\ntoJSON(1.0 >= 1.0)\ntoJSON(1.0 >= i)\ntoJSON(1.0 ^ 1)\ntoJSON(1.0 ^ 1.0)\ntoJSON(1.0 ^ f64)\ntoJSON(1.0 ^ i)\ntoJSON(1.0 in array)\ntoJSON(1.0 not in array)\ntoJSON(1.0) + str\ntoJSON(1.0) <= str\ntoJSON(1.0) matches str\ntoJSON(1.0) not in foo\ntoJSON(1.0) | greet()\ntoJSON(1.0) | indexOf(str)\ntoJSON([0])\ntoJSON([1, 1])\ntoJSON([1.0])\ntoJSON([1])\ntoJSON([array, 0])\ntoJSON([array])\ntoJSON([f64, nil])\ntoJSON([false])\ntoJSON([foo, list])\ntoJSON([foo])\ntoJSON([nil])\ntoJSON([ok])\ntoJSON([str])\ntoJSON([true])\ntoJSON(abs(0))\ntoJSON(abs(1))\ntoJSON(abs(1.0))\ntoJSON(abs(f64))\ntoJSON(add != $env)\ntoJSON(add == add)\ntoJSON(add == nil)\ntoJSON(all(list, true))\ntoJSON(any(array, false))\ntoJSON(array != $env)\ntoJSON(array != array)\ntoJSON(array != list)\ntoJSON(array == array)\ntoJSON(array == list)\ntoJSON(array | count(ok))\ntoJSON(array | count(true))\ntoJSON(array | find(true))\ntoJSON(array | map(#))\ntoJSON(array | max(i))\ntoJSON(array | min(i))\ntoJSON(array | none(false))\ntoJSON(array | sortBy(#))\ntoJSON(array | sortBy(0))\ntoJSON(array | sum(i))\ntoJSON(array)\ntoJSON(array) + str\ntoJSON(array) < str\ntoJSON(array) == greet(str)\ntoJSON(array) not contains str\ntoJSON(array) | greet()\ntoJSON(array?.[0])\ntoJSON(array?.[1])\ntoJSON(array?.[i])\ntoJSON(array[1:])\ntoJSON(bitand(0, 0))\ntoJSON(bitnot(0))\ntoJSON(bitnot(1))\ntoJSON(bitnot(i))\ntoJSON(ceil(0))\ntoJSON(ceil(1))\ntoJSON(ceil(1.0))\ntoJSON(ceil(f64))\ntoJSON(ceil(i))\ntoJSON(concat(array))\ntoJSON(concat(list))\ntoJSON(count(array, true))\ntoJSON(count(list, false))\ntoJSON(count(list, true))\ntoJSON(f64 != 1)\ntoJSON(f64 != 1.0)\ntoJSON(f64 != f64)\ntoJSON(f64 != nil)\ntoJSON(f64 * 0)\ntoJSON(f64 * f64)\ntoJSON(f64 ** f64)\ntoJSON(f64 + 1.0)\ntoJSON(f64 - 1.0)\ntoJSON(f64 / 1.0)\ntoJSON(f64 < 0)\ntoJSON(f64 < 1)\ntoJSON(f64 < 1.0)\ntoJSON(f64 <= 0)\ntoJSON(f64 <= 1)\ntoJSON(f64 <= 1.0)\ntoJSON(f64 == $env)\ntoJSON(f64 == 0)\ntoJSON(f64 == 1.0)\ntoJSON(f64 == nil)\ntoJSON(f64 >= 1.0)\ntoJSON(f64 >= i)\ntoJSON(f64 ^ 0)\ntoJSON(f64 ^ f64)\ntoJSON(f64 ^ i)\ntoJSON(f64 in array)\ntoJSON(f64 | median(i))\ntoJSON(f64)\ntoJSON(f64) > str\ntoJSON(f64) in reduce(array, $env, array)\ntoJSON(f64) not in foo\ntoJSON(false != $env)\ntoJSON(false != false)\ntoJSON(false != nil)\ntoJSON(false != ok)\ntoJSON(false && $env)\ntoJSON(false && $env?.[greet])\ntoJSON(false == nil)\ntoJSON(false == true)\ntoJSON(false or false)\ntoJSON(false || false)\ntoJSON(false || ok)\ntoJSON(false) not endsWith str\ntoJSON(false) startsWith first($env)\ntoJSON(findIndex($env, false))\ntoJSON(findIndex($env, true))\ntoJSON(findIndex(list, false))\ntoJSON(findLastIndex($env, false))\ntoJSON(first($env))\ntoJSON(first(list))\ntoJSON(flatten(array))\ntoJSON(flatten(list))\ntoJSON(float(0))\ntoJSON(float(1))\ntoJSON(float(1.0))\ntoJSON(float(f64))\ntoJSON(float(i))\ntoJSON(floor(0))\ntoJSON(floor(1.0))\ntoJSON(floor(f64))\ntoJSON(floor(i))\ntoJSON(foo != $env)\ntoJSON(foo != foo)\ntoJSON(foo != nil)\ntoJSON(foo == $env)\ntoJSON(foo == foo)\ntoJSON(foo == nil)\ntoJSON(foo in list)\ntoJSON(foo not in list)\ntoJSON(foo)\ntoJSON(foo) < str\ntoJSON(foo) > str\ntoJSON(foo) not in $env?.String\ntoJSON(foo) not matches str\ntoJSON(foo) | greet()\ntoJSON(foo) | repeat(i))\ntoJSON(foo.Bar)\ntoJSON(foo.String())\ntoJSON(foo?.Bar)\ntoJSON(foo?.String())\ntoJSON(greet != $env)\ntoJSON(greet != greet)\ntoJSON(greet != nil)\ntoJSON(greet == $env)\ntoJSON(greet(str))\ntoJSON(groupBy(array, 1.0)?.Bar)\ntoJSON(i != 1.0)\ntoJSON(i != f64)\ntoJSON(i != i)\ntoJSON(i != nil)\ntoJSON(i % 1)\ntoJSON(i * 0)\ntoJSON(i * 1)\ntoJSON(i * 1.0)\ntoJSON(i * f64)\ntoJSON(i ** f64)\ntoJSON(i + 1 .. 0)\ntoJSON(i - i)\ntoJSON(i .. 1)\ntoJSON(i / f64)\ntoJSON(i / i)\ntoJSON(i < 1)\ntoJSON(i < 1.0)\ntoJSON(i <= 1)\ntoJSON(i == 0)\ntoJSON(i == 1.0)\ntoJSON(i == nil)\ntoJSON(i == nil) <= str\ntoJSON(i > f64)\ntoJSON(i >= 0)\ntoJSON(i >= i)\ntoJSON(i ^ 0)\ntoJSON(i ^ 1.0)\ntoJSON(i in array)\ntoJSON(i not in array)\ntoJSON(i)\ntoJSON(i) + str\ntoJSON(i) <= str\ntoJSON(i) not contains string(0)\ntoJSON(if false { add } else { ok })\ntoJSON(if false { str } else { str })\ntoJSON(if true { ok } else { f64 })\ntoJSON(int(0))\ntoJSON(int(1))\ntoJSON(int(1.0))\ntoJSON(int(f64))\ntoJSON(keys($env))\ntoJSON(last($env))\ntoJSON(last(list))\ntoJSON(len($env))\ntoJSON(len(list))\ntoJSON(len(str))\ntoJSON(let foobar = array; foobar)\ntoJSON(let foobar = false; foobar)\ntoJSON(list != list)\ntoJSON(list != nil)\ntoJSON(list == $env)\ntoJSON(list == $env.list)\ntoJSON(list == array)\ntoJSON(list == list)\ntoJSON(list == nil)\ntoJSON(list | all(false))\ntoJSON(list | find(false))\ntoJSON(list | find(ok))\ntoJSON(list | findIndex(true))\ntoJSON(list | map(#))\ntoJSON(list | map(#.Bar))\ntoJSON(list | map(0))\ntoJSON(list | map(true))\ntoJSON(list | none(true))\ntoJSON(list | reduce(#))\ntoJSON(list | reduce(0))\ntoJSON(list | reduce(foo))\ntoJSON(list)\ntoJSON(list) == str\ntoJSON(list) startsWith str\ntoJSON(list) | greet()\ntoJSON(list?.[0])\ntoJSON(list?.[i])\ntoJSON(lower(str))\ntoJSON(map($env, 0))\ntoJSON(map($env, array))\ntoJSON(map($env, foo))\n```\n\n----------------------------------------\n\nTITLE: Expr Boolean Inequality Operations\nDESCRIPTION: This snippet showcases inequality comparisons with boolean 'false'. It illustrates comparing 'false' with environment variables (using optional chaining), boolean literals, and various data types, demonstrating Expr's handling of type comparisons. The goal is to demonstrate how the '!=' operator behaves with a boolean false.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_92\n\nLANGUAGE: Expr\nCODE:\n```\nfalse != $env and ok\nfalse != $env.ok\nfalse != $env?.Bar\nfalse != $env?.String\nfalse != $env?.[Bar]\nfalse != $env?.[String]\nfalse != $env?.[foobar]\nfalse != $env?.[str]\nfalse != $env?.foobar\nfalse != $env?.ok\nfalse != nil == ok\n```\n\n----------------------------------------\n\nTITLE: Sum Function Usage (Expr)\nDESCRIPTION: Examples showing various usages of the `sum` function with different arguments and data types, including sorting and conditional expressions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_238\n\nLANGUAGE: Expr\nCODE:\n```\nsum(sort($env), #.add not in #.add)\nsum(sort($env), $env == #)\nsum(sort(array))\nsum(sort(ok ? i : 1.0))\nsum(sortBy(array, #))\nsum(sortBy(array, 0))\nsum(sortBy(array, 1))\nsum(sortBy(array, 1.0))\nsum(sortBy(array, f64))\nsum(sortBy(array, i))\nsum(sortBy(array, str))\nsum(take(array, i))\nsum(toPairs($env), i)\nsum(true ? str : 1.0)\nsum(true ? str : add)\nsum(true ? str : foo)\nsum(uniq(array))\nsum(uniq(array), 1.0 - 0)\n```\n\n----------------------------------------\n\nTITLE: Range Operations in Expr\nDESCRIPTION: Demonstrates usage of range operators (..) in the Expr language. The snippets illustrate how to create ranges using integers and variables. It also demonstrates how to chain other operations such as mapping and reducing after creating a range.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_160\n\nLANGUAGE: Expr\nCODE:\n```\ni..array?.[i]\ni..i\ni..i - 0\ni..i == $env\ni..i == nil\ni..i | map(#)\ni..i | reduce(foo)\nint(0) .. i\nint(0)..i\nint(1.0)..i\nint(i) .. i\nint(1.0)..i\n```\n\n----------------------------------------\n\nTITLE: Exponentiation Operations with 'i' in Expr\nDESCRIPTION: Demonstrates exponentiation operations involving the variable 'i' with different data types, variables, functions, and expressions. It includes safe navigation operators.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_149\n\nLANGUAGE: Expr\nCODE:\n```\ni ** $env.f64\ni ** $env.i\ni ** $env?.f64\ni ** $env?.i\ni ** 0 - abs(i)\ni ** 1 ^ 1.0\ni ** 1.0 + 1.0\ni ** 1.0 - i\ni ** 1.0 / i\ni ** 1.0 == $env\ni ** 1.0 >= f64 <= f64\ni ** 1.0 ^ 1\ni ** 1.0 ^ i\ni ** 1.0 | max(1)\ni ** abs(1.0)\ni ** array?.[i]\ni ** f64\ni ** f64 * 1.0\ni ** f64 == nil\ni ** i\ni ** i ** 1.0\ni ** i + f64\ni ** i / 1.0\ni ** i < 1\ni ** i > 0\ni ** i >= i\ni ** int(i)\ni ** len($env)\ni ** max(1)\ni ** mean(1, array)\ni ** min(1)\ni ** min(1.0)\ni ** min(1.0, array)\ni ** min(array)\ni ** sum($env, 1.0)\n```\n\n----------------------------------------\n\nTITLE: lower Function in Expr\nDESCRIPTION: Illustrates the use of the `lower` function to convert a string to lowercase.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_26\n\nLANGUAGE: expr\nCODE:\n```\nlower(\"HELLO\") == \"hello\"\n```\n\n----------------------------------------\n\nTITLE: Calculating Length of Maps in Expr\nDESCRIPTION: These expressions demonstrate how to calculate the length of maps (dictionaries) using the `len()` function in the Expr language. The maps contain different data types for their values, including numbers, strings, and functions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_73\n\nLANGUAGE: Expr\nCODE:\n```\nlen({\"foo\": 1})\nlen({\"foo\": add, \"foo\": \"foo\"})\nlen({\"foo\": i64})\n```\n\n----------------------------------------\n\nTITLE: Using the `reduce` function in Expr\nDESCRIPTION: The `reduce` function is used here with a list and different operations, including conditionals, function calls, and variable references. It demonstrates how `reduce` can be combined with other functions and expressions within the Expr language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_99\n\nLANGUAGE: Expr\nCODE:\n```\nreduce(list, ok ? # : #)\nreduce(list, ok ? # : score)\nreduce(list, ok ? greet : add)\nreduce(list, ok ? score : #)\nreduce(list, ok)\nreduce(list, reduce(array, ok))\nreduce(list, reduce(array, score))\nreduce(list, reduce(list, #))\nreduce(list, reduce(list, 1))\nreduce(list, reduce(list, add))\nreduce(list, reduce(list, i32))\nreduce(list, score(i))\nreduce(list, score)\nreduce(list, string(greet))\nreduce(list, toBase64(\"bar\"))\nreduce(list, toBase64(\"foo\"))\nreduce(list, toJSON(array))\nreduce(list, toJSON(list))\nreduce(list, toJSON(nil))\nreduce(list, true == nil)\nreduce(list, true ? foo : f64)\nreduce(list, type(#))\n```\n\n----------------------------------------\n\nTITLE: Mapping with Index Accessing in Expr\nDESCRIPTION: Illustrates using the map function in conjunction with accessing elements by their index. It shows how to transform the output, including access by dot notation and indexing.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_184\n\nLANGUAGE: Expr\nCODE:\n```\nmap(array, #)?.[i]\nmap(array, #index)\nmap(array, #index)?.[i]\n```\n\n----------------------------------------\n\nTITLE: Boolean Logic with Environment Variables\nDESCRIPTION: These examples demonstrate boolean logic operations involving environment variables. They showcase the use of `or` and `and` operators combined with property accesses on environment variables.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_6\n\nLANGUAGE: Expr\nCODE:\n```\n$env?.[greet]?.foobar or true\n$env?.[i].i and false\n$env?.[list] contains str && false\n$env?.[list] || false or true\n```\n\n----------------------------------------\n\nTITLE: trimSuffix Function in Expr\nDESCRIPTION: Illustrates the trimSuffix function used to remove a suffix from a string. Demonstrates various scenarios, including nested function calls and type conversions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_246\n\nLANGUAGE: Expr\nCODE:\n```\ntrimSuffix($env.str)\ntrimSuffix($env?.[str])\ntrimSuffix($env?.str)\ntrimSuffix(array | reduce(str, foo))\ntrimSuffix(foo.Bar)\ntrimSuffix(foo.String())\ntrimSuffix(foo?.Bar)\ntrimSuffix(foo?.Bar, str)\ntrimSuffix(foo?.String())\ntrimSuffix(greet(foo?.String()))\ntrimSuffix(greet(str))\ntrimSuffix(greet(str), str)\ntrimSuffix(greet(string(add)))\ntrimSuffix(lower(str))\ntrimSuffix(str | greet())\ntrimSuffix(str)\ntrimSuffix(str) != str\ntrimSuffix(str) <= greet(str)\ntrimSuffix(str) | greet()\ntrimSuffix(str, str)\ntrimSuffix(string($env), str)\ntrimSuffix(string(0))\ntrimSuffix(string(1.0))\ntrimSuffix(string(add))\ntrimSuffix(string(array))\ntrimSuffix(string(f64))\ntrimSuffix(string(false))\ntrimSuffix(string(foo))\ntrimSuffix(string(foo.Bar))\ntrimSuffix(string(greet))\ntrimSuffix(string(i))\ntrimSuffix(string(list))\ntrimSuffix(string(nil))\ntrimSuffix(string(ok))\ntrimSuffix(toBase64($env?.[str]))\ntrimSuffix(toBase64($env?.str))\ntrimSuffix(toBase64(str))\ntrimSuffix(toJSON(1.0))\ntrimSuffix(toJSON(array))\ntrimSuffix(toJSON(f64))\ntrimSuffix(toJSON(false))\ntrimSuffix(toJSON(foo))\ntrimSuffix(toJSON(list))\ntrimSuffix(toJSON(nil))\ntrimSuffix(toJSON(ok))\ntrimSuffix(toJSON(str))\ntrimSuffix(toJSON(true))\ntrimSuffix(trim(str))\ntrimSuffix(trimPrefix(str))\ntrimSuffix(trimSuffix(str))\ntrimSuffix(type($env))\ntrimSuffix(type(0))\ntrimSuffix(type(1))\ntrimSuffix(type(1.0))\ntrimSuffix(type(add))\ntrimSuffix(type(array))\ntrimSuffix(type(false))\ntrimSuffix(type(foo))\ntrimSuffix(type(greet))\ntrimSuffix(type(i))\ntrimSuffix(type(list))\ntrimSuffix(type(nil))\n```\n\n----------------------------------------\n\nTITLE: Object Field Access\nDESCRIPTION: Demonstrates accessing fields within an object using dot notation. This includes accessing fields directly and through optional chaining using the '?.' operator. The objects are defined inline using a JSON-like syntax.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_136\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": 1}.foo\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": 1}?.foo\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": add}.foo\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": i}.foo\n```\n\n----------------------------------------\n\nTITLE: Convert Map to Pairs Using toPairs() in Expr\nDESCRIPTION: The `toPairs()` function converts a map to an array of key-value pairs, represented as nested arrays.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_86\n\nLANGUAGE: expr\nCODE:\n```\ntoPairs({\"name\": \"John\", \"age\": 30}) == [[\"name\", \"John\"], [\"age\", 30]]\n```\n\n----------------------------------------\n\nTITLE: Expr: Logical OR with variable access and optional chaining\nDESCRIPTION: This snippet demonstrates the usage of the logical OR operator combined with variable access and optional chaining. It includes function calls, slicing, and index access with various data types.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_253\n\nLANGUAGE: Expr\nCODE:\n```\ntrue or $env in str\ntrue or $env startsWith str\ntrue or $env.ok\ntrue or $env?.Bar\ntrue or $env?.Bar()\ntrue or $env?.String\ntrue or $env?.String()\ntrue or $env?.String?.ok\ntrue or $env?.[0 | one(1.0)]\ntrue or $env?.[Bar]\ntrue or $env?.[String]\ntrue or $env?.[add]\ntrue or $env?.[add]?.str\ntrue or $env?.[array]\ntrue or $env?.[array]?.greet?.Bar\ntrue or $env?.[array]?.str()\ntrue or $env?.[f64]\ntrue or $env?.[foo]\ntrue or $env?.[greet]\ntrue or $env?.[greet]?.[add]\ntrue or $env?.[i.f64]\ntrue or $env?.[i]\ntrue or $env?.[list]\ntrue or $env?.[ok(foobar)]\ntrue or $env?.[ok]\ntrue or $env?.[str.greet]\ntrue or $env?.[str]\ntrue or $env?.[str].ok\ntrue or $env?.foobar\ntrue or $env?.min(1.0)\ntrue or $env?.ok\ntrue or $env?.sortBy(foo, 1.0)?.foo()\ntrue or $env[:1.0 or list]\ntrue or $env[:Bar]\ntrue or $env[:array ?: foo]\ntrue or $env[:bitnand(greet, foobar)]\ntrue or $env[:foobar?.String(foobar, foobar)]\ntrue or $env[:greet]\ntrue or $env[:true || foobar]\ntrue or $env[foobar?.[array]:]\n\n```\n\n----------------------------------------\n\nTITLE: Finding Elements in Expr\nDESCRIPTION: Demonstrates finding the first element that matches a condition in an array or list.  The `find` function returns the first element that satisfies the given condition or nil if no such element is found.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_38\n\nLANGUAGE: Expr\nCODE:\n```\nfind(1 .. i, ok)\nfind([ok], #)\nfind([score, score], # == #)\nfind(array, !(# <= i32))\nfind(array, !ok)\nfind(array, !true)\nfind(array, \"bar\" not startsWith \"foo\")\nfind(array, \"foo\" not contains \"bar\")\nfind(array, # != #)\nfind(array, # != 1)\nfind(array, # != i)\nfind(array, # != i32)\nfind(array, # != nil)\nfind(array, # - i != #)\nfind(array, # < #)\nfind(array, # < 0.5)\nfind(array, # < 1)\nfind(array, # < f32)\nfind(array, # < i)\nfind(array, # < i32)\nfind(array, # < i64)\nfind(array, # <= #)\nfind(array, # <= 0.5)\nfind(array, # <= 1)\nfind(array, # <= i32)\nfind(array, # == #)\nfind(array, # == 0.5)\nfind(array, # == 1)\nfind(array, # == i)\nfind(array, # == i64)\nfind(array, # == nil)\nfind(array, # > #)\nfind(array, # > 1)\nfind(array, # > i32)\nfind(array, # > i64)\nfind(array, # >= #)\nfind(array, # >= 1)\nfind(array, # >= f64)\nfind(array, # >= i)\nfind(array, # not in array)\nfind(array, 0.5 != 1)\nfind(array, 0.5 / i64 <= #)\nfind(array, 0.5 < #)\nfind(array, 0.5 < f64)\nfind(array, 0.5 <= #)\nfind(array, 0.5 >= #)\nfind(array, 0.5 >= 0.5)\nfind(array, 0.5 >= f64)\nfind(array, 1 != #)\nfind(array, 1 < #)\nfind(array, 1 < i32)\nfind(array, 1 < i64)\nfind(array, 1 <= #)\nfind(array, 1 <= i)\nfind(array, 1 == #)\nfind(array, 1 > #)\nfind(array, 1 >= #)\nfind(array, div != nil)\nfind(array, f32 != #)\nfind(array, f32 != f32)\nfind(array, f32 < #)\nfind(array, f32 <= #)\nfind(array, f32 == #)\nfind(array, f32 == i32)\nfind(array, f32 > #)\nfind(array, f32 >= #)\nfind(array, f64 != #)\nfind(array, f64 < #)\nfind(array, f64 < 1)\nfind(array, f64 <= #)\nfind(array, f64 == #)\nfind(array, f64 == i64)\nfind(array, false ? # : false)\nfind(array, false) != f64\nfind(array, floor(#) > #)\nfind(array, greet != greet)\nfind(array, i % # != f64)\nfind(array, i < 0.5)\nfind(array, i <= #)\nfind(array, i > 0.5)\nfind(array, i >= #)\nfind(array, i >= 1)\nfind(array, i32 != #)\nfind(array, i32 != i32)\nfind(array, i32 == #)\nfind(array, i32 > #)\nfind(array, i32 >= #)\nfind(array, i64 != #)\nfind(array, i64 != 1)\nfind(array, i64 < #)\nfind(array, i64 <= #)\nfind(array, i64 == #)\nfind(array, i64 > #)\nfind(array, nil != nil)\nfind(array, nil == #)\nfind(array, nil == 0.5)\nfind(array, nil == i32)\nfind(array, none(array, true))\nfind(array, not (# == #))\nfind(array, ok == nil)\nfind(array, ok and false)\nfind(array, ok)\nfind(array, ok) % i32\nfind(array, ok) ** i\nfind(array, ok) >= i32\nfind(array, true) > f64\nfind(array, true) > i64\nfind(filter(list, false), i64 not in array)\nfind(groupBy(array, #).Qux, .String?.f32)\nfind(groupBy(array, #).ok, first(#[1]))\nfind(i .. i64, ok)\nfind(i64 .. i32, # != #)\nfind(list, !false)\nfind(list, !ok)\nfind(list, \"bar\" not in #)\nfind(list, \"foo\" contains \"foo\")\nfind(list, # != #)\nfind(list, # != nil)\nfind(list, # == #)\nfind(list, # == foo)\nfind(list, # == nil)\nfind(list, 0.5 != 1)\nfind(list, 0.5 <= 0.5)\nfind(list, 1 != 0.5)\nfind(list, 1 < 1)\nfind(list, 1 < i64)\nfind(list, 1 == f64)\nfind(list, 1 > 0.5)\nfind(list, 1 > i)\nfind(list, 1 > i64)\nfind(list, f32 < 1)\nfind(list, f32 <= 0.5)\nfind(list, f32 <= i32)\nfind(list, f32 == i64)\nfind(list, f32 > f64)\nfind(list, f32 not in array)\nfind(list, f64 < f64)\nfind(list, false && true)\nfind(list, false)?.Bar\nfind(list, foo != #)\nfind(list, foo == #)\nfind(list, i != 1)\nfind(list, i != f64)\nfind(list, i != i32)\nfind(list, i32 != 1)\nfind(list, i32 != f64)\nfind(list, i32 < i)\nfind(list, i32 == i32)\nfind(list, nil != #)\nfind(list, nil != ok)\nfind(list, nil == array)\nfind(list, nil == div)\nfind(list, not false)\nfind(list, ok != false)\nfind(list, ok)\nfind(list, ok).String\nfind(list, ok).String()\nfind(list, ok)?.Bar\nfind(list, ok)?.Qux\nfind(list, ok)?.String\nfind(list, score == score)\nfind(list, true != nil)\nfind(list, true == true)\nfind(list, true or false)\nfind(list, true).Bar\nfind(list, true).Qux\nfind(list, true).String\nfind(list, true)?.Bar\nfind(list, true)?.String\nfind(map(array, #), # != f32)\nfind(map(array, #), # <= 1)\nfind(map(array, #), # == 0.5)\nfind(map(array, #), ok)\nfind(map(array, false), #)\nfind(map(array, foo), ok)\nfind(map(array, ok), #)\nfind(map(list, #), # != #)\nfind(map(list, #), ok)\nfind(map(list, 0.5), # != #)\nfind(map(list, add), 0.5 >= i64)\nfind(map(list, div), # == #)\nfind(map(list, f32), # > 0.5)\nfind(map(list, false), #)\nfind(map(list, i), # == i64)\nfind(map(list, ok), #)\nfind(map(list, true), #)\nfind(ok ? \"foo\" : f64, f32 >= #)\n```\n\n----------------------------------------\n\nTITLE: Expr Nested Safe Navigation on Boolean Property\nDESCRIPTION: This snippet demonstrates nested safe navigation, attempting to access property `i` of `div` after accessing it from a nested object where `bar` is `true`. If either `div` or the initial object is null, the expression evaluates to null.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_151\n\nLANGUAGE: expr\nCODE:\n```\n{\"foo\": score, \"bar\": true}.div?.i\n```\n\n----------------------------------------\n\nTITLE: Expr f64 'in' Operator Operations\nDESCRIPTION: This snippet demonstrates the usage of the 'in' operator with the f64 data type in the Expr language. It shows examples of checking whether an f64 value exists within arrays (literal and dynamic), environment variables, and other data structures. It includes expressions involving optional chaining, conditional logic, and function calls, highlighting the versatility of the 'in' operator.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_88\n\nLANGUAGE: Expr\nCODE:\n```\nf64 in $env && false\nf64 in $env.array\nf64 in $env?.Bar\nf64 in $env?.String\nf64 in $env?.[$env?.[String]]\nf64 in $env?.[Bar]\nf64 in $env?.[String]\nf64 in $env?.[foobar]\nf64 in $env?.array\nf64 in $env?.foobar\nf64 in $env?.foobar?.[add]\nf64 in $env?.nil\nf64 in [1.0]\nf64 in [foo, 1.0]\nf64 in [foo, i]\nf64 in [list, 1.0]\nf64 in [nil]\nf64 in array\nf64 in array or false\nf64 in reverse(array)\n```\n\n----------------------------------------\n\nTITLE: Range Operations with 'i' in Expr\nDESCRIPTION: Demonstrates range operations using the '..' operator with the variable 'i', various data types, variables, and function calls. Includes uses of the safe navigation operator '?.' and conditional checks.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_152\n\nLANGUAGE: Expr\nCODE:\n```\ni .. $env.i\ni .. $env?.i\ni .. 0 * i\ni .. 0 == list\ni .. 0 | all($env[.Bar:])\ni .. 0 | count($env)\ni .. 0 | groupBy(greet)\ni .. 0 | map(#)\ni .. 0 | median(f64)\ni .. 0 | sum(1)\ni .. 0 | sum(foo)\ni .. 0 | sum(str)\ni .. 1 | groupBy(#)\ni .. 1 | map(#)\ni .. 1 | sortBy(1)\ni .. 1 | sortBy(foo.Bar)\ni .. abs(i)\ni .. array?.[i]\ni .. i\ni .. i % 1\ni .. i | groupBy(#)\ni .. i | reduce(#)\ni .. i | reduce(false)\ni .. int(0)\ni .. len(array)\ni .. max(0)\ni .. median(i)\ni .. min(1)\n```\n\n----------------------------------------\n\nTITLE: Equality Comparison with foo\nDESCRIPTION: These snippets demonstrate equality comparisons within expressions, comparing a value against 'foo'.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_279\n\nLANGUAGE: Expr\nCODE:\n```\n{foo: 0}?.foobar == foo}\n```\n\n----------------------------------------\n\nTITLE: Using findIndex with groupBy and various conditions\nDESCRIPTION: Demonstrates the usage of `findIndex` with `groupBy` function and various conditions involving different data types and operators.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_40\n\nLANGUAGE: expr\nCODE:\n```\nfindIndex(groupBy(array, foo).String, #)\nfindIndex(groupBy(list, #).Qux, #)\nfindIndex(i32 .. 1, # >= #)\nfindIndex(list, !false)\nfindIndex(list, !ok)\nfindIndex(list, !true)\nfindIndex(list, \"bar\" > \"foo\")\nfindIndex(list, \"bar\" in #)\nfindIndex(list, \"bar\" not in #)\nfindIndex(list, # != #)\nfindIndex(list, # != nil)\nfindIndex(list, # == #)\nfindIndex(list, # == foo)\nfindIndex(list, # in list)\nfindIndex(list, #?.Bar not in #)\nfindIndex(list, 0.5 != i)\nfindIndex(list, 0.5 > 1)\nfindIndex(list, 0.5 >= i)\nfindIndex(list, 1 != i32)\nfindIndex(list, 1 < f64)\nfindIndex(list, 1 < i32)\nfindIndex(list, 1 == f32)\nfindIndex(list, 1 > 0.5)\nfindIndex(list, 1 > i32)\nfindIndex(list, 1 >= 1)\nfindIndex(list, 1 >= i)\nfindIndex(list, f32 != f32)\nfindIndex(list, f32 != i)\nfindIndex(list, f32 < i32)\nfindIndex(list, f32 == bitshl(i, i64))\nfindIndex(list, f32 > 1)\nfindIndex(list, f64 != 0.5)\nfindIndex(list, f64 < 1)\nfindIndex(list, f64 < i)\nfindIndex(list, f64 > 1)\nfindIndex(list, f64 >= f64)\nfindIndex(list, false != nil)\nfindIndex(list, false || ok)\nfindIndex(list, foo != #)\nfindIndex(list, greet == nil)\nfindIndex(list, i < 0.5)\nfindIndex(list, i <= i32)\nfindIndex(list, i32 == 1)\nfindIndex(list, i32 >= i64)\nfindIndex(list, i64 != f32)\nfindIndex(list, nil != 0.5)\nfindIndex(list, nil != f32)\nfindIndex(list, nil != i64)\nfindIndex(list, nil == \"foo\")\nfindIndex(list, nil == f64)\nfindIndex(list, not ok)\nfindIndex(list, not true)\nfindIndex(list, ok)\nfindIndex(list, ok) * i\nfindIndex(list, ok) ** i\nfindIndex(list, ok) >= f64\nfindIndex(list, ok) ^ i32\nfindIndex(list, true ? ok : #)\nfindIndex(list, true) % i64\n```\n\n----------------------------------------\n\nTITLE: Using the min function in Expr\nDESCRIPTION: This snippet demonstrates various ways to use the `min` function with different data types (i32, i64, f32, f64, i, half) and operations. It includes arithmetic operations, conditional expressions, built-in functions and array access to showcase the function's flexibility.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_84\n\nLANGUAGE: expr\nCODE:\n```\nmin(-0.5)\nmin(-0.5, i)\nmin(-1)\nmin(-f32)\nmin(-f64)\nmin(-half(0.5))\nmin(-i)\nmin(-i32)\nmin(-i64)\nmin(0.5 * 0.5)\nmin(0.5 * 1)\nmin(0.5 * f32, i32 ** i32)\nmin(0.5 * f64)\nmin(0.5 * i32)\nmin(0.5 * i64)\nmin(0.5 ** i)\nmin(0.5 ** i64)\nmin(0.5 + f64)\nmin(0.5 + i)\nmin(0.5 + i32)\nmin(0.5 - 0.5)\nmin(0.5 - 1)\nmin(0.5 - f32)\nmin(0.5 - f64)\nmin(0.5 - i)\nmin(0.5 / 0.5)\nmin(0.5 / i64)\nmin(0.5 / i64, i64)\nmin(0.5 ^ 0.5)\nmin(0.5 ^ f32)\nmin(0.5 ^ i)\nmin(0.5 ^ i32)\nmin(0.5) != i64\nmin(0.5) * i32\nmin(0.5) ** f64\nmin(0.5) ** i\nmin(0.5) + f64 ^ i64\nmin(0.5) - f32\nmin(0.5) - f64\nmin(0.5) / i32\nmin(0.5) < i32\nmin(0.5) == f32 / f32\nmin(0.5) == i\nmin(0.5) >= i64\nmin(0.5) ^ (f32 - i64)\nmin(0.5, 0.5) < f32 + f64\nmin(1 % 1)\nmin(1 % i)\nmin(1 % i32)\nmin(1 % i64)\nmin(1 * 0.5)\nmin(1 * 1)\nmin(1 * f32)\nmin(1 * i)\nmin(1 * i32)\nmin(1 ** i)\nmin(1 + 0.5)\nmin(1 + 1)\nmin(1 + f32)\nmin(1 + i64)\nmin(1 - 1)\nmin(1 - f64)\nmin(1 - i)\nmin(1 - i32)\nmin(1 - i64)\nmin(1 / 0.5)\nmin(1 / f32)\nmin(1 / i)\nmin(1 / i32)\nmin(1 / i64)\nmin(1 ^ 0.5)\nmin(1 ^ 1)\nmin(1 ^ f32)\nmin(1 ^ i)\nmin(1 ^ i32)\nmin(1 ^ i64)\nmin(1) != i\nmin(1) - i\nmin(1) .. i32\nmin(1) <= f32\nmin(1) <= f64\nmin(1) > i64\nmin(1) >= i\nmin(1) >= i64\nmin(1) ^ f64\nmin(abs(0.5))\nmin(abs(1))\nmin(abs(f32))\nmin(abs(f64))\nmin(abs(i))\nmin(abs(i32))\nmin(array[1])\nmin(array[i32])\nmin(array[i])\nmin(bitnand(1, i32))\nmin(bitnot(1))\nmin(bitnot(i))\nmin(bitnot(i32))\nmin(bitnot(i32), i64)\nmin(bitnot(i64))\nmin(ceil(0.5))\nmin(ceil(1))\nmin(ceil(f32))\nmin(ceil(f64))\nmin(ceil(i))\nmin(count(array, false))\nmin(count(list, ok))\nmin(f32 * 1)\nmin(f32 * i64)\nmin(f32 ** 0.5)\nmin(f32 - 0.5)\nmin(f32 - 1)\nmin(f32 - f64)\nmin(f32 - i)\nmin(f32 - i64)\nmin(f32 / 1)\nmin(f32 / i64)\nmin(f32 ^ i32)\nmin(f32)\nmin(f32) * i64\nmin(f32) / f64\nmin(f32) / i32\nmin(f32) == i\nmin(f32) >= f64\nmin(f32, -0.5)\nmin(f32, ceil(1))\nmin(f32, f32)\nmin(f32, f64)\nmin(f32, i)\nmin(f32, i32)\nmin(f32, i64)\nmin(f64 * 1)\nmin(f64 * f64)\nmin(f64 ** f32)\nmin(f64 ** f64)\nmin(f64 + 0.5)\nmin(f64 + f32)\nmin(f64 + i64)\nmin(f64 - 1)\nmin(f64 - i)\nmin(f64 - i32)\nmin(f64 / 0.5)\nmin(f64 / f32)\nmin(f64 / i)\nmin(f64 / i64)\nmin(f64 ^ 1)\nmin(f64)\nmin(f64) * f64\nmin(f64) * i32\nmin(f64) / i\nmin(f64) >= f64\nmin(f64, 0.5 ** i64)\nmin(f64, 0.5) == f64\nmin(f64, f32)\nmin(f64, f64)\nmin(f64, i)\nmin(f64, i32)\nmin(f64, i64)\nmin(false ? foo : i32)\nmin(false ? greet : f32)\nmin(find(array, false))\nmin(find(array, ok))\nmin(findIndex(array, false))\nmin(findLastIndex(array, i32 > #))\nmin(findLastIndex(array, ok))\nmin(findLastIndex(array, true))\nmin(findLastIndex(list, ok))\nmin(first(array))\nmin(float(0.5))\nmin(float(1))\nmin(float(f32))\nmin(float(f64))\nmin(float(i))\nmin(float(i64), i)\nmin(floor(0.5))\nmin(floor(1))\nmin(floor(f32))\nmin(floor(i))\nmin(floor(i32))\nmin(floor(i64))\nmin(half(0.5))\nmin(half(1))\nmin(half(1), -1)\nmin(half(f64 - 0.5))\nmin(half(f64))\nmin(i % 1)\nmin(i % i64)\nmin(i * i)\nmin(i ** 0.5)\nmin(i ** i)\nmin(i + 1)\nmin(i - 0.5)\nmin(i - f64)\nmin(i - i32)\nmin(i / 1) + f64\nmin(i / f64)\nmin(i ^ f32)\nmin(i ^ f64)\nmin(i ^ i)\nmin(i)\nmin(i) * f32\nmin(i) ** i64\nmin(i) / f64\nmin(i) / i\nmin(i) < f64\nmin(i) < i32\nmin(i) >= i32\nmin(i) ^ f32\nmin(i, f32)\nmin(i, f32, i) + i32\nmin(i, f64)\nmin(i, i)\nmin(i, i32)\nmin(i, i64)\nmin(i, last(array))\nmin(i32 % 1)\nmin(i32 * f32)\nmin(i32 * i)\nmin(i32 ** 0.5)\nmin(i32 ** i32)\nmin(i32 + i32)\nmin(i32 + i64)\nmin(i32 - 0.5)\nmin(i32 - i64)\nmin(i32 / 0.5)\nmin(i32 / f64)\nmin(i32 ^ 0.5)\nmin(i32 ^ f32)\nmin(i32 ^ f64)\nmin(i32 ^ i64)\nmin(i32)\nmin(i32) - i\nmin(i32) .. i32\nmin(i32) / i\nmin(i32) < i\nmin(i32) <= f32\nmin(i32) <= i\nmin(i32) > f32\nmin(i32) > i64 + f64\nmin(i32) >= i\nmin(i32) ^ f32\nmin(i32) ^ i64\nmin(i32, f32)\nmin(i32, f64 * 0.5)\nmin(i32, f64)\nmin(i32, i)\nmin(i32, i32)\nmin(i32, i64)\nmin(i64 % 1)\nmin(i64 * 0.5)\nmin(i64 * 1)\nmin(i64 * bitnot(i64))\nmin(i64 * i)\nmin(i64 * i32)\nmin(i64 * i64)\nmin(i64 ** 0.5)\nmin(i64 ** f64)\nmin(i64 ** i)\nmin(i64 ** i32)\nmin(i64 + f32)\nmin(i64 - f64)\nmin(i64 - i32)\nmin(i64 / 1)\nmin(i64 / f32)\nmin(i64 / i)\nmin(i64 / i32)\nmin(i64 / i64)\nmin(i64 ^ 0.5)\nmin(i64 ^ 1)\nmin(i64 ^ f64)\nmin(i64 ^ i32)\nmin(i64)\nmin(i64) / f32\nmin(i64) < i32\nmin(i64) >= f64\nmin(i64) not in array\nmin(i64, f32)\nmin(i64, f64)\nmin(i64, i)\nmin(i64, i32)\nmin(i64, i64)\nmin(i64, i64) < i64\nmin(int(0.5))\nmin(int(1))\nmin(int(f32))\nmin(int(f64))\nmin(int(i))\nmin(int(i32))\nmin(int(i64))\nmin(last(1 .. 1))\nmin(last(array))\nmin(len(array))\nmin(len(list))\nmin(max(0.5))\nmin(max(1, 0.5))\nmin(max(f32))\nmin(max(f64))\nmin(max(i))\nmin(max(i64, 1))\nmin(mean(array))\nmin(min(1))\nmin(min(1, 1, 1))\nmin(min(1, i, f32))\nmin(min(i))\nmin(min(i32))\nmin(min(reduce(list, f32)))\nmin(ok ? array : false)\nmin(ok ? f64 : i)\nmin(ok ? half : ok)\nmin(ok ? i : f32)\nmin(ok ? array : score)\nmin(ok ? true : div)\nmin(reduce(array, #))\nmin(reduce(array, 0.5))\nmin(reduce(array, 1))\nmin(reduce(list, 1))\nmin(round(0.5))\nmin(round(1))\nmin(round(f32))\nmin(round(i32))\nmin(round(i64))\nmin(score(1))\nmin(score(i))\nmin(sum(array))\nmin(true ? i : \"foo\")\nmin(true ? i : i32)\nmin(true ? i64 : \"foo\")\n```\n\n----------------------------------------\n\nTITLE: Array Comparisons\nDESCRIPTION: Illustrates various comparisons involving the `array` variable against variables, literals, and expressions. It covers inequality checks (`!=`), equality checks (`==`), and logical operations. The purpose is to validate the comparison logic and behavior of arrays.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_38\n\nLANGUAGE: Expr\nCODE:\n```\narray\narray != $env && false\narray != $env == false\narray != $env == ok\narray != $env and $env\narray != $env and $env?.[Bar]\narray != $env or true\narray != $env.array\narray != $env.list\narray != $env?.Bar\narray != $env?.Bar?.i\narray != $env?.String\narray != $env?.String?.foo()\narray != $env?.[Bar]\narray != $env?.[String]\narray != $env?.[String]?.[greet]\narray != $env?.[str]\narray != $env?.array\narray != $env?.foobar\narray != $env?.list\narray != [1.0 + f64]\narray != [f64]\narray != [foo]\narray != array\narray != array && true\narray != array or ok\narray != flatten(array)\narray != list\narray != list != false\narray != list && 1.0 > 0\narray != list || ok\narray != map($env, 1.0)\narray != map(list, #)\narray != map(list, 1.0)\narray != min($env)\narray != nil == $env\narray != nil ? list : greet\narray != nil and ok\narray != values($env)\narray != {foo: $env}?.str\narray == $env != ok\narray == $env && false\narray == $env and $env\narray == $env.array\narray == $env.list\narray == $env?.Bar\narray == $env?.String\narray == $env?.[Bar]\narray == $env?.[String]\narray == $env?.[foobar]\narray == $env?.[str]\narray == $env?.array\narray == $env?.foobar\narray == $env?.list\narray == [1.0]\narray == [1]\narray == [foo]\narray == [nil]\narray == [ok, 1.0]\narray == [str]\narray == array\narray == array != ok\narray == keys($env)\narray == list\narray == list != false\n```\n\n----------------------------------------\n\nTITLE: Predicate with Omitted Braces in Expr\nDESCRIPTION: Shows that braces can be omitted in a predicate if it's a simple expression.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_20\n\nLANGUAGE: expr\nCODE:\n```\nfilter(tweets, len(.Content) > 240)\n```\n\n----------------------------------------\n\nTITLE: Using findLast with arrays and various conditions\nDESCRIPTION: Demonstrates the usage of `findLast` with arrays and different conditions involving comparison, logical, and arithmetic operations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_43\n\nLANGUAGE: expr\nCODE:\n```\nfindLast([false], #)\nfindLast(array, !false)\nfindLast(array, !ok)\nfindLast(array, \"foo\" > \"bar\")\nfindLast(array, # != #)\nfindLast(array, # != 0.5)\nfindLast(array, # != 1)\nfindLast(array, # != f32)\nfindLast(array, # != f64)\nfindLast(array, # != i)\nfindLast(array, # < #)\nfindLast(array, # < 0.5)\nfindLast(array, # < f32)\nfindLast(array, # < f64)\nfindLast(array, # < i + #)\nfindLast(array, # <= #)\nfindLast(array, # <= 0.5)\nfindLast(array, # <= 1)\nfindLast(array, # <= f32)\nfindLast(array, # <= i64)\nfindLast(array, # == #)\nfindLast(array, # == 0.5)\nfindLast(array, # == nil)\nfindLast(array, # > #)\nfindLast(array, # > 0.5)\nfindLast(array, # > 1)\nfindLast(array, # > i)\nfindLast(array, # > i32)\nfindLast(array, # > i64)\nfindLast(array, # >= #)\nfindLast(array, # >= 0.5)\nfindLast(array, # >= 1)\nfindLast(array, # >= f32)\nfindLast(array, # >= i32)\nfindLast(array, 0.5 <= #)\nfindLast(array, 0.5 <= i64)\nfindLast(array, 0.5 > #)\nfindLast(array, 0.5 >= #)\nfindLast(array, 0.5 >= 1)\nfindLast(array, 1 != #)\nfindLast(array, 1 <= #)\nfindLast(array, 1 == #)\nfindLast(array, f32 >= #)\nfindLast(array, f64 != #)\nfindLast(array, f64 != nil)\nfindLast(array, f64 <= #)\nfindLast(array, f64 <= 1)\nfindLast(array, f64 == #)\nfindLast(array, f64 == nil)\nfindLast(array, f64 >= 1)\nfindLast(array, f64 >= i64)\nfindLast(array, false != true)\nfindLast(array, false or true)\nfindLast(array, greet != nil)\nfindLast(array, i < #)\nfindLast(array, i == i32)\nfindLast(array, i > #)\nfindLast(array, i >= 0.5)\nfindLast(array, i32 < #)\nfindLast(array, i32 == 0.5)\nfindLast(array, i32 > #)\nfindLast(array, i32 >= #)\nfindLast(array, i32 >= i32)\nfindLast(array, i64 != #)\nfindLast(array, i64 < #)\nfindLast(array, i64 <= #)\nfindLast(array, i64 == #)\nfindLast(array, i64 > 0.5)\nfindLast(array, list != nil)\nfindLast(array, nil != array)\nfindLast(array, not (array == array))\nfindLast(array, not false)\nfindLast(array, not ok)\nfindLast(array, ok and true)\nfindLast(array, ok)\nfindLast(array, ok) == i64\nfindLast(array, reduce(list, ok))\nfindLast(array, score != nil)\nfindLast(array, true) % i64\n```\n\n----------------------------------------\n\nTITLE: Expr Example: Custom Function with Context\nDESCRIPTION: This shows how a custom function `customFunc` will be transformed to include the context, when WithContext option is specified during compile time\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/configuration.md#_snippet_7\n\nLANGUAGE: expr\nCODE:\n```\ncustomFunc(42)\n// will be transformed to\ncustomFunc(ctx, 42)\n```\n\n----------------------------------------\n\nTITLE: Bitwise XOR Operation in Expr\nDESCRIPTION: Example demonstrating the `bitxor` operator in Expr.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_74\n\nLANGUAGE: Expr\nCODE:\n```\nbitxor(i, i)\n```\n\n----------------------------------------\n\nTITLE: Using the `round` function with numeric literals in Expr\nDESCRIPTION: This set of examples demonstrates the usage of the `round` function in Expr with various numeric literals, including negative numbers, floating-point numbers, integers, and simple arithmetic expressions. These test cases are useful for type checking during expression evaluation.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_106\n\nLANGUAGE: Expr\nCODE:\n```\nround(-0.5)\nround(-1)\nround(-f32)\nround(-f64)\nround(-i)\nround(-i32)\nround(-i64)\nround(0.5 * 1)\nround(0.5 * f64)\nround(0.5 * i32)\nround(0.5 ** 0.5)\nround(0.5 ** 1)\nround(0.5 ** i)\nround(0.5 ** i32)\nround(0.5 ** i64)\nround(0.5 + 1)\nround(0.5 + f64)\nround(0.5 + i)\nround(0.5 + i32)\nround(0.5 - 0.5)\nround(0.5 - 1)\nround(0.5 - i32)\nround(0.5 / 0.5)\nround(0.5 / 1)\nround(0.5 / f64)\nround(0.5 / i32)\nround(0.5 ^ f64)\nround(0.5 ^ i)\nround(0.5 ^ i64)\nround(0.5) * f32\nround(0.5) ** i32\nround(0.5) + -f32\nround(0.5) - i64 ^ i\nround(0.5) < f64\nround(0.5) <= i64\nround(0.5) == i32\nround(0.5) == i64\nround(0.5) == max(i, i64)\nround(0.5) > -1\nround(0.5) > i\nround(0.5) >= i\nround(0.5) in array\nround(1 % i)\nround(1 % i64)\nround(1 * 0.5)\nround(1 * f32)\nround(1 * i64)\nround(1 ** 0.5)\nround(1 ** 1)\nround(1 ** f32)\nround(1 ** f64)\nround(1 ** i)\nround(1 + 0.5)\nround(1 + 1)\nround(1 + i64)\nround(1 - 0.5)\nround(1 - 1)\nround(1 - i)\nround(1 - i32)\nround(1 - i64)\nround(1 / 0.5)\nround(1 / 1)\nround(1 / f32)\nround(1 / i)\nround(1 / i64)\nround(1 ^ 0.5)\nround(1 ^ 1)\nround(1 ^ f32)\nround(1 ^ i)\nround(1 ^ i64)\n```\n\n----------------------------------------\n\nTITLE: Math Operations and Functions in Expr\nDESCRIPTION: Demonstrates usage of mathematical functions and operations available in the Expr language, including `max`, `mean`, `median`, `min`, `abs`, `ceil`, `floor`, and various arithmetic operations. The snippets illustrate how to use these functions with integers, floats, variables, and expressions. The examples also make use of environment variables (`$env`) and data structures like arrays.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_159\n\nLANGUAGE: Expr\nCODE:\n```\ni | max($env.i)\ni | max(0)\ni | max(0, 1.0)\ni | max(1)\ni | max(1.0)\ni | max(1.0, array)\ni | max(1.0, f64)\ni | max(array)\ni | max(f64)\ni | max(f64, 0)\ni | max(f64, f64)\ni | max(i)\ni | max(i, array)\ni | mean(0)\ni | mean(1)\ni | mean(1, array)\ni | mean(1.0)\ni | mean(array)\ni | mean(f64)\ni | mean(f64, 1)\ni | mean(i)\ni | mean(i, f64)\ni | median(0)\ni | median(0, 0)\ni | median(1)\ni | median(1, 1)\ni | median(1.0)\ni | median(1.0, i)\ni | median(array)\ni | median(f64)\ni | median(i)\ni | median(i) != f64\ni | median(i, 1.0)\ni | min(0)\ni | min(0) | median(1.0)\ni | min(0, f64)\ni | min(1)\ni | min(1.0)\ni | min(array)\ni | min(f64)\ni | min(f64, array)\ni | min(i)\ni | min(i, 1)\n```\n\n----------------------------------------\n\nTITLE: Add Function Side Effects\nDESCRIPTION: Examples of using `add` with semicolons, potentially indicating side effects or chained expressions. These validate the sequential execution and handling of potentially independent expressions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_35\n\nLANGUAGE: Expr\nCODE:\n```\nadd; $env.array\nadd; add\nadd; greet\nadd; list\nadd; ok\nadd; {foo: f64}\n```\n\n----------------------------------------\n\nTITLE: Membership check using 'not in' operator - Expr\nDESCRIPTION: Demonstrates the 'not in' operator for checking if a value is not a member of a collection, including handling optional values and various data types.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_107\n\nLANGUAGE: Expr\nCODE:\n```\nfoo not in $env?.list\nfoo not in flatten(array)\nfoo not in keys($env)\nfoo not in list\nfoo not in $env?.[String]?.[list]\nfoo not in $env?.[foobar?.f64]\nfoo not in $env?.[foobar]\nfoo not in $env?.[nil | last(foobar)]\nfoo not in $env?.[nil]\nfoo not in $env?.foobar\nfoo not in $env?.foobar?.greet(foobar)\nfoo not in $env?.nil?.[ok]\nfoo not in [$env]\n```\n\n----------------------------------------\n\nTITLE: String Literal Example in Expr\nDESCRIPTION: Demonstrates a string literal in Expr enclosed in double quotes, including an escape sequence for a newline character.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_0\n\nLANGUAGE: expr\nCODE:\n```\n\"Hello\\nWorld\"\n```\n\n----------------------------------------\n\nTITLE: Sum Function Operations\nDESCRIPTION: Demonstrates various usages of the `sum` function with ranges, arrays, and other expressions, highlighting different data types and operation combinations. Includes conditional sums and sums with map/reduce operations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_114\n\nLANGUAGE: Expr\nCODE:\n```\nsum(1 .. 1)\nsum(1 .. i)\nsum(1 .. i32)\nsum(1 .. i64)\nsum([0.5])\nsum([f32])\nsum(array)\nsum(array) != f32\nsum(array) % i\nsum(array) % i64\nsum(array) - f32\nsum(array) / -f64\nsum(array) < i\nsum(array) == i64 - i\nsum(array) ^ f64\nsum(array) not in array\nsum(filter(array, ok))\nsum(groupBy(array, i32).String)\nsum(i32 .. 1)\nsum(i64 .. i32)\nsum(i64 .. i64)\nsum(list[i:1])\nsum(map(array, #))\nsum(map(array, f32))\nsum(map(list, 0.5))\nsum(map(list, f32))\nsum(map(list, i32))\nsum(ok ? array : i64)\nsum(reduce(array, array))\nsum(reduce(list, array))\nsum(sort(array))\nsum(true ? array : i32)\n```\n\n----------------------------------------\n\nTITLE: Using findLastIndex with arrays and comparison operators\nDESCRIPTION: Shows the utilization of `findLastIndex` with arrays and comparison, equality and inequality operators.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_48\n\nLANGUAGE: expr\nCODE:\n```\nfindLastIndex(array, # != #)\nfindLastIndex(array, # != 1)\nfindLastIndex(array, # != f32)\nfindLastIndex(array, # != f64)\nfindLastIndex(array, # != i32)\nfindLastIndex(array, # != i64)\nfindLastIndex(array, # != nil)\nfindLastIndex(array, # < #)\nfindLastIndex(array, # < 1)\nfindLastIndex(array, # < f64)\nfindLastIndex(array, # < i)\nfindLastIndex(array, # < i64)\nfindLastIndex(array, # <= #)\nfindLastIndex(array, # <= 0.5)\nfindLastIndex(array, # <= i64)\nfindLastIndex(array, # == #)\nfindLastIndex(array, # == 0.5)\nfindLastIndex(array, # == 1)\nfindLastIndex(array, # == f64)\nfindLastIndex(array, # == i64)\nfindLastIndex(array, # == nil)\nfindLastIndex(array, # > #)\nfindLastIndex(array, # > 0.5)\nfindLastIndex(array, # > f32)\nfindLastIndex(array, # > f64)\nfindLastIndex(array, # > i)\nfindLastIndex(array, # >= #)\nfindLastIndex(array, # >= 0.5)\nfindLastIndex(array, # >= 1)\nfindLastIndex(array, # >= f32)\nfindLastIndex(array, # >= i32)\n```\n\n----------------------------------------\n\nTITLE: Array Median\nDESCRIPTION: Calculates the median of the elements in the array. Requires numeric elements. Returns the median value of the array.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_57\n\nLANGUAGE: Expr\nCODE:\n```\narray | median($env.array)\n```\n\n----------------------------------------\n\nTITLE: Array 'all' Conditional Check\nDESCRIPTION: Checks if all elements in the array satisfy the condition that they are not nil. This operation filters and returns a boolean.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_44\n\nLANGUAGE: Expr\nCODE:\n```\narray | all(# != nil)\n```\n\n----------------------------------------\n\nTITLE: Expr Reduce Function with Field Access\nDESCRIPTION: Shows the use of the `reduce` function in expr with a variable `foo`. It iterates over an `array` and passes it along with foo to the reducing function, accumulating the results.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_146\n\nLANGUAGE: expr\nCODE:\n```\n{\"foo\": reduce(array, \"foo\")}\n```\n\n----------------------------------------\n\nTITLE: Multiplication Operations with 'i' in Expr\nDESCRIPTION: Demonstrates multiplication operations involving the variable 'i' with various data types, variables, function calls, and expressions. Includes uses of conditional property accessors.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_148\n\nLANGUAGE: Expr\nCODE:\n```\ni * $env.f64\ni * $env.i\ni * $env?.f64\ni * $env?.i\ni * - - f64\ni * 0 != f64\ni * 0 != nil\ni * 1 != 0\ni * 1 | bitshl(i)\ni * 1.0 + 1.0\ni * 1.0 + f64\ni * 1.0 - i\ni * 1.0 <= 0\ni * 1.0 == 0\ni * array?.[i]\ni * f64\ni * f64 ^ i\ni * floor(0)\ni * i\ni * i != i\ni * i % i\ni * i ** 1.0\ni * i / 1.0\ni * i <= i\ni * i == 0\ni * int(0)\ni * int(1.0)\ni * mean(array)\ni * mean(i)\ni * median(f64)\ni * median(i)\ni * min(i)\ni * sum($env, 0)\ni * sum(array)\n```\n\n----------------------------------------\n\nTITLE: Expr groupBy with placeholder expressions\nDESCRIPTION: Demonstrates the use of placeholders (#) within the groupBy function for various comparison operations and property access on array elements.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_122\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(array, # == #)\ngroupBy(array, # > #)\ngroupBy(array, # >= #).String\ngroupBy(array, # >= 0)\ngroupBy(array, # ^ #)\ngroupBy(array, #)\ngroupBy(array, #).Bar\ngroupBy(array, #).String\ngroupBy(array, #).add\ngroupBy(array, #).array\ngroupBy(array, #).f64\ngroupBy(array, #).foo\ngroupBy(array, #).greet\ngroupBy(array, #).i\ngroupBy(array, #).list\ngroupBy(array, #).ok\ngroupBy(array, #).str\ngroupBy(array, #)?.Bar\ngroupBy(array, #)?.String\ngroupBy(array, #)?.[f64]\ngroupBy(array, #)?.[foo]\ngroupBy(array, #)?.[i]\ngroupBy(array, #)?.[ok]\ngroupBy(array, #)?.[str]\ngroupBy(array, #)?.add\ngroupBy(array, #)?.array\ngroupBy(array, #)?.f64\ngroupBy(array, #)?.foo\ngroupBy(array, #)?.foobar\ngroupBy(array, #)?.greet\ngroupBy(array, #)?.i\ngroupBy(array, #)?.list\ngroupBy(array, #)?.ok\ngroupBy(array, #)?.str\n```\n\n----------------------------------------\n\nTITLE: Min Function Calls and Operations in Expr\nDESCRIPTION: Presents examples of calling the `min` function within the Expr language, demonstrating its usage with different argument types like numbers, arrays, and environment variables. It also contains several operators and built-in functions called inside the `min` function.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_194\n\nLANGUAGE: text\nCODE:\n```\nmin($env | findIndex(false))\nmin($env | map(1))\nmin($env | map(1.0))\nmin($env | reduce(array, 1))\nmin($env | sum(1.0))\nmin($env | sum(f64))\nmin($env) != array\nmin($env) == greet\nmin($env) == i\nmin($env) | all(false)\nmin($env) | any(false)\nmin($env) | count(ok)\nmin($env) | map(f64)\nmin($env) | reduce(0, 1)\nmin($env) | sum(0)\nmin($env).Bar\nmin($env).String\nmin($env).add\nmin($env).array\nmin($env).f64\nmin($env).false?.f64\nmin($env).foo\nmin($env).foobar\nmin($env).foobar?.ok\nmin($env).greet\nmin($env).i\nmin($env).list\nmin($env).nil?.foobar\nmin($env).ok\nmin($env).str\nmin($env)?.Bar\nmin($env)?.Bar?.foobar.foo().list\nmin($env)?.String\nmin($env)?.[str]\nmin($env)?.add\nmin($env)?.array\nmin($env)?.f64\nmin($env)?.foo\nmin($env)?.foobar\nmin($env)?.foobar?.foo.i\nmin($env)?.greet\nmin($env)?.i\nmin($env)?.list\nmin($env)?.not\nmin($env)?.ok\nmin($env)?.str\nmin($env.array)\nmin($env.array, sum(array))\nmin($env.f64)\nmin($env.i)\nmin($env?.$env)\nmin($env?.Bar)\nmin($env?.String)\nmin($env?.[Bar])\nmin($env?.[Bar])?.add()\nmin($env?.[Bar]?.Bar)\nmin($env?.[Bar]?.[greet])\nmin($env?.[String])\nmin($env?.[String])?.f64\nmin($env?.[foobar])\nmin($env?.[str])\nmin($env?.array)\nmin($env?.f64)\nmin($env?.f64, i)\nmin($env?.false)\nmin($env?.foobar)\nmin($env?.i)\nmin($env?.nil)\nmin($env?.true)\nmin(0 * 1)\nmin(0 * 1.0)\nmin(0 * f64)\nmin(0 ** 0)\nmin(0 ** 1.0)\nmin(0 ** i)\nmin(0 + f64)\nmin(0 - 1.0)\nmin(0 - f64)\nmin(0 - i)\nmin(0 .. i)\nmin(0 / 0)\nmin(0 ^ 1)\nmin(0 | bitshl(1))\nmin(0) * 0 < f64\nmin(0) * f64\nmin(0) ** f64\nmin(0) + i\nmin(0) - ceil(i)\nmin(0) ^ f64\nmin(0) in array\nmin(0) | max(0)\nmin(0.0)\nmin(1 * 1)\nmin(1 ** 0)\nmin(1 ** 1.0)\nmin(1 ** i)\nmin(1 + 1.0)\nmin(1 - f64)\nmin(1 / 0)\nmin(1 / 1)\nmin(1 / 1.0)\nmin(1 / i)\nmin(1 ^ 0)\nmin(1 | min(1.0))\nmin(1) % i\nmin(1) < f64\nmin(1) < i\nmin(1) <= i\nmin(1, 1.0) in array\nmin(1..i)\nmin(1.0 * 1.0)\nmin(1.0 * f64)\nmin(1.0 ** 0)\nmin(1.0 ** 1)\nmin(1.0 ** i)\nmin(1.0 + 0)\nmin(1.0 + 1)\nmin(1.0 + 1.0)\nmin(1.0 + i)\nmin(1.0 - 0)\nmin(1.0 - 1)\nmin(1.0 - f64)\nmin(1.0 - i)\nmin(1.0 / 1)\nmin(1.0 / 1.0)\nmin(1.0 / f64)\nmin(1.0 ^ 1)\nmin(1.0 ^ 1.0)\nmin(1.0 ^ f64)\nmin(1.0 | max(array))\nmin(1.0 | min(1.0))\nmin(1.0) ** i\nmin(1.0) - f64\nmin(1.0) <= 1.0 + 0\nmin(1.0) > i\nmin(1.0) >= i\nmin(1.0) not in array\nmin(1.0, 0) + i\nmin(1.1)\nmin([0])\nmin([1.0])\nmin([1])\nmin([array])\nmin([f64, 0])\nmin([f64])\nmin([i])\nmin(abs(0))\nmin(abs(1))\nmin(abs(1.0))\nmin(abs(f64))\nmin(add(0, 0))\nmin(array | find(ok))\nmin(array | findIndex(false))\nmin(array | findIndex(ok))\nmin(array | map(#))\nmin(array | reduce(#))\nmin(array | reduce(0))\nmin(array | reduce(1.0))\nmin(array | sortBy(0))\nmin(array | sortBy(1.0))\nmin(array | sum(#))\nmin(array | sum(1.0))\nmin(array)\nmin(array) .. i\nmin(array) / i\nmin(array) < 1.0 - i\nmin(array) | bitushr(0)\nmin(array) | get(str)\nmin(array) | median(0)\nmin(array, 1 - 0)\nmin(array, array)\nmin(array, ceil(0))\nmin(array, f64)\nmin(array, float(1.0))\nmin(array, i)\nmin(array, int(0))\nmin(array, sortBy(array, #))\nmin(array?.[i])\nmin(array[:0])?.[greet]\nmin(array[min(1):])\nmin(bitnot(1))\nmin(bitnot(i))\nmin(ceil(1))\nmin(ceil(1.0))\nmin(ceil(f64))\nmin(ceil(i))\nmin(count($env, false))\nmin(count($env, ok))\nmin(f64 * f64)\nmin(f64 ** 1)\nmin(f64 ** 1.0)\nmin(f64 ** f64)\nmin(f64 + 0)\nmin(f64 + 1.0)\nmin(f64 + f64)\nmin(f64 - 0)\nmin(f64 - 1.0)\nmin(f64 - i)\nmin(f64 / 1)\nmin(f64 / 1.0)\nmin(f64 ^ 0)\nmin(f64 ^ 1)\nmin(f64 ^ 1.0)\nmin(f64 ^ f64)\nmin(f64 ^ i)\nmin(f64)\nmin(f64) <= $env.i\nmin(f64) not in array\nmin(f64, 1.0 / 1.0)\nmin(f64, abs(f64))\nmin(f64, array)\nmin(f64, f64)\nmin(f64, i)\nmin(f64, min(1.0))\nmin(false ? 0 : greet)\nmin(false ? 0 : nil)\nmin(false ? array : nil)\nmin(false ? greet : foo)\nmin(findLast(array, false))\nmin(findLastIndex($env, true))\nmin(first($env))\nmin(first(array))\nmin(flatten(array))\nmin(float(1))\nmin(float(1.0))\nmin(float(f64))\nmin(float(i))\nmin(floor(1.0 + i))\nmin(floor(1.0))\nmin(floor(f64))\nmin(floor(i))\nmin(groupBy(array, #)?.array)\nmin(i % i)\nmin(i * f64)\nmin(i * i)\nmin(i + 1.0)\nmin(i + i)\nmin(i - 0)\nmin(i - f64)\nmin(i - i)\nmin(i .. 0)\nmin(i / 1.0)\nmin(i ^ 1.0)\nmin(i | bitor(0))\nmin(i | bitshr(1))\nmin(i | min(0))\nmin(i)\nmin(i) != $env?.i\nmin(i) % i\nmin(i) < i\nmin(i) <= f64\nmin(i, array)\nmin(i, array) .. i\nmin(i, f64)\nmin(i, i)\nmin(i, max(sum(array)))\nmin(if false { nil } else { 0 })\nmin(if false { ok } else { array })\nmin(if true { 1 } else { $env })\nmin(if true { 1.0 } else { true })\nmin(if true { false } else { foo })\nmin(if true { greet } else { 1.0 })\nmin(int(0))\nmin(int(1))\nmin(int(1.0))\nmin(int(i))\nmin(last($env))\nmin(last(array))\nmin(len($env))\nmin(len(array))\nmin(len(list))\nmin(len(str))\nmin(list | count(false))\nmin(list | count(true))\nmin(list | findIndex(false))\nmin(list | reduce(1))\nmin(list | reduce(1.0))\nmin(list | reduce(array))\nmin(list | sum(1))\nmin(list[1:1])\nmin(map($env, 0))\nmin(map($env, array))\nmin(map(array, #))\nmin(map(array, #index))\nmin(map(array, 1.0))\nmin(map(list, f64))\nmin(max($env))\nmin(max(0))\nmin(max(0, 1))\nmin(max(0, 1.0, 0))\nmin(max(1))\nmin(max(1.0))\nmin(max(1.0, 1.0))\nmin(max(array))\nmin(max(f64))\nmin(max(i))\nmin(mean(0))\nmin(mean(1))\nmin(mean(1.0))\nmin(mean(array))\nmin(mean(f64))\nmin(mean(i))\nmin(median(0))\nmin(median(1))\nmin(median(1.0))\nmin(median(array))\nmin(median(f64))\nmin(min($env))\nmin(min(0))\nmin(min(1.0))\nmin(min(1.0, 1))\nmin(min(f64))\nmin(min(f64, 1.0))\nmin(min(i))\nmin(ok ?: 1.0)\nmin(reduce(array, i))\nmin(reduce(list, f64))\nmin(reduce(list, f64), $env?.array)\nmin(reverse(array))\nmin(round(0))\nmin(round(0), array)\nmin(round(1))\nmin(round(1.0))\nmin(round(f64))\nmin(sort(array))\nmin(sortBy(array, f64))\nmin(sum($env, 1))\nmin(sum($env, 1.0))\nmin(sum(array))\nmin(sum(array), array)\nmin(sum(array, #))\nmin(sum(array, 1.0))\nmin(sum(list, 1))\nmin(sum(list, f64))\nmin(true ? 1.0 : str)\nmin(true ? nil : i)\nmin(true ?: add)\nmin(uniq(array))\nmin({foo: 0}.foo)\nmin({foo: add}.i)\nmin({foo: i}?.i)\nmin({foo: nil}?.i)\nmin({foo: sum(array)}.array)\n```\n\n----------------------------------------\n\nTITLE: Grouping by Various Expressions in Expr\nDESCRIPTION: Demonstrates the groupBy function in the Expr language, applied to a 'list' with different grouping criteria. The criteria include equality checks, array access, property access, and type conversions. Includes use of the safe navigation operator '?.'.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_143\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(list, add != add)\ngroupBy(list, array | sum(1))\ngroupBy(list, f64)\ngroupBy(list, f64).String\ngroupBy(list, f64).array\ngroupBy(list, f64).f64\ngroupBy(list, f64).foo\ngroupBy(list, f64).greet\ngroupBy(list, f64).i\ngroupBy(list, f64).ok\ngroupBy(list, f64)?.Bar\ngroupBy(list, f64)?.[f64]\ngroupBy(list, f64)?.[foo]\ngroupBy(list, f64)?.[i]\ngroupBy(list, f64)?.[ok]\ngroupBy(list, f64)?.[str]\ngroupBy(list, f64)?.array\ngroupBy(list, f64)?.f64\ngroupBy(list, f64)?.foo\ngroupBy(list, f64)?.ok\ngroupBy(list, f64)?.str\ngroupBy(list, false).Bar\ngroupBy(list, false).String\ngroupBy(list, false).add\ngroupBy(list, false).f64\ngroupBy(list, false).foo\ngroupBy(list, false).foobar\ngroupBy(list, false).i\ngroupBy(list, false).list\ngroupBy(list, false).str\ngroupBy(list, false)?.String\ngroupBy(list, false)?.[i]\ngroupBy(list, false)?.[ok]\ngroupBy(list, false)?.add\ngroupBy(list, false)?.array\ngroupBy(list, false)?.f64\ngroupBy(list, false)?.greet\ngroupBy(list, false)?.ok\ngroupBy(list, false)?.str\ngroupBy(list, foo != nil)\ngroupBy(list, foo == #)\ngroupBy(list, foo)\ngroupBy(list, foo).Bar\ngroupBy(list, foo).String\ngroupBy(list, foo).add\ngroupBy(list, foo).array\ngroupBy(list, foo).f64\ngroupBy(list, foo).foo\ngroupBy(list, foo).greet\ngroupBy(list, foo).i\ngroupBy(list, foo).list\ngroupBy(list, foo).ok\ngroupBy(list, foo).str\ngroupBy(list, foo)?.Bar\ngroupBy(list, foo)?.String\ngroupBy(list, foo)?.[f64]\ngroupBy(list, foo)?.[foo]\ngroupBy(list, foo)?.[ok]\ngroupBy(list, foo)?.[str]\ngroupBy(list, foo)?.add\ngroupBy(list, foo)?.array\ngroupBy(list, foo)?.f64\ngroupBy(list, foo)?.foo\ngroupBy(list, foo)?.greet\ngroupBy(list, foo)?.i\ngroupBy(list, foo)?.list\ngroupBy(list, foo)?.ok\ngroupBy(list, foo)?.str\ngroupBy(list, foo.Bar)\ngroupBy(list, foo?.Bar)\ngroupBy(list, greet(.Bar))\ngroupBy(list, i + i)\ngroupBy(list, i)\ngroupBy(list, i).add\ngroupBy(list, i).array\ngroupBy(list, i).f64\ngroupBy(list, i).foo\ngroupBy(list, i).i\ngroupBy(list, i).list\ngroupBy(list, i).ok\ngroupBy(list, i).str\ngroupBy(list, i)?.[ok]\ngroupBy(list, i)?.add\ngroupBy(list, i)?.array\ngroupBy(list, i)?.f64\ngroupBy(list, i)?.foo\ngroupBy(list, i)?.greet\ngroupBy(list, i)?.ok\ngroupBy(list, i)?.str\ngroupBy(list, if true { # } else { false })\ngroupBy(list, nil != 0)\ngroupBy(list, nil == 1.0)\ngroupBy(list, none($env, true))\ngroupBy(list, ok and ok)\ngroupBy(list, ok)\ngroupBy(list, ok).String\ngroupBy(list, ok).add\ngroupBy(list, ok).f64\ngroupBy(list, ok).foo\ngroupBy(list, ok).i\ngroupBy(list, ok).list\ngroupBy(list, ok).ok\ngroupBy(list, ok)?.Bar\ngroupBy(list, ok)?.[f64]\ngroupBy(list, ok)?.[foo]\ngroupBy(list, ok)?.[i]\ngroupBy(list, ok)?.[ok]\ngroupBy(list, ok)?.add\ngroupBy(list, ok)?.foo\ngroupBy(list, ok)?.list\ngroupBy(list, ok)?.str\ngroupBy(list, str == nil)\ngroupBy(list, str)\ngroupBy(list, str).add\ngroupBy(list, str).array\ngroupBy(list, str).foo\ngroupBy(list, str).greet\ngroupBy(list, str).list\ngroupBy(list, str).ok\ngroupBy(list, str).str\ngroupBy(list, str)?.[f64]\ngroupBy(list, str)?.[foo]\ngroupBy(list, str)?.[i]\ngroupBy(list, str)?.[ok]\ngroupBy(list, str)?.add\ngroupBy(list, str)?.f64\ngroupBy(list, str)?.foo\ngroupBy(list, str)?.foobar\ngroupBy(list, str)?.greet\ngroupBy(list, str)?.i\ngroupBy(list, str)?.list\ngroupBy(list, str)?.ok\ngroupBy(list, string(#))\ngroupBy(list, string(add)).str\ngroupBy(list, string(false))\ngroupBy(list, true).Bar\ngroupBy(list, true).add\ngroupBy(list, true).array\ngroupBy(list, true).f64\ngroupBy(list, true).foo\ngroupBy(list, true).greet\ngroupBy(list, true).i\ngroupBy(list, true).list\ngroupBy(list, true).ok\ngroupBy(list, true)?.Bar\ngroupBy(list, true)?.String\ngroupBy(list, true)?.[f64]\ngroupBy(list, true)?.[i]\ngroupBy(list, true)?.[ok]\ngroupBy(list, true)?.[str]\ngroupBy(list, true)?.add\ngroupBy(list, true)?.f64\ngroupBy(list, true)?.greet\ngroupBy(list, true)?.list\ngroupBy(list, true)?.str\ngroupBy(list, type(foo))\ngroupBy(map($env, 1.0), sum(array))\ngroupBy(map(array, list), $env?.[str])\ngroupBy(map(list, #index), #)\ngroupBy(reverse(array), foo)\ngroupBy(reverse(array), i + f64)\ngroupBy(reverse(array), ok)\ngroupBy(sort($env), # != .array)\ngroupBy(sort($env), #.add not contains str)\ngroupBy(sort($env), i)\ngroupBy(sort($env), max(#))\ngroupBy(toPairs($env), 1 <= 1.0)\ngroupBy(values($env), foo)\ngroupBy(values($env), i)\n```\n\n----------------------------------------\n\nTITLE: All Function Predicates\nDESCRIPTION: Demonstrates the usage of the `all` function with various predicate functions to check if all elements in a collection satisfy a certain condition.  These conditions include comparisons, boolean operations, and function calls. These examples help to test predicate application and overall logic of the `all` function.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_36\n\nLANGUAGE: Expr\nCODE:\n```\nall($env | filter(false), #[.ok:$env])\nall($env, true) and ok\nall($env.array, 1 > #)\nall($env.list, $env == #)\nall($env?.list, nil == $env)\nall([$env], ok)\nall([list], 1.0 < 1.0)\nall(array, # < #)\nall(array, # <= #)\nall(array, # == #)\nall(array, # == $env)\nall(array, # == 0)\nall(array, # > #)\nall(array, # >= #)\nall(array, $env != #)\nall(array, $env == #)\nall(array, 1.0 > 0)\nall(array, i >= 1)\nall(array, list | one(true))\nall(array, nil != nil)\nall(array, nil == true)\nall(array, ok)\nall(array, ok) || $env?.Bar\nall(array, str == nil)\nall(array, str startsWith str)\nall(array, true or $env)\nall(list | map(true), #)\nall(list, # != #)\nall(list, # in list)\nall(list, #.Bar >= str)\nall(list, $env != 0)\nall(list, 0 < 1.0)\nall(list, array | any(ok))\nall(list, f64 <= 1.0)\nall(list, foo == #)\nall(list, nil == nil)\nall(list, nil not in $env)\nall(list, ok)\nall(list, true and ok)\nall(sort($env), #)\nall(sort($env), .f64 | reduce(#, foo))\nall(sort($env), .f64)\nall(sort($env), .ok?.array)\nall(sort($env), 1.0 >= #)\nall(sort($env), sortBy(#, ok))\nall(toPairs($env), ok)\n```\n\n----------------------------------------\n\nTITLE: Basic Boolean Value\nDESCRIPTION: Simple boolean value.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_97\n\nLANGUAGE: Expr\nCODE:\n```\nok\n```\n\n----------------------------------------\n\nTITLE: Using findLastIndex with groupBy, ranges, and lists\nDESCRIPTION: Demonstrates the use of `findLastIndex` along with `groupBy`, range and list.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_50\n\nLANGUAGE: expr\nCODE:\n```\nfindLastIndex(groupBy(list, #).ok, #)\nfindLastIndex(groupBy(list, 0.5).Bar, #?.String endsWith .f32(list))\nfindLastIndex(i32 .. i32, ok)\nfindLastIndex(i64 .. 1, ok)\nfindLastIndex(list, !(nil != #))\nfindLastIndex(list, !false)\nfindLastIndex(list, !ok)\nfindLastIndex(list, !true)\nfindLastIndex(list, \"bar\" in #)\nfindLastIndex(list, \"bar\" matches \"foo\")\nfindLastIndex(list, \"bar\" not endsWith \"foo\")\n```\n\n----------------------------------------\n\nTITLE: Expr groupBy with function calls and type names\nDESCRIPTION: Presents examples of using built-in functions like `abs` and `bitshr` along with type names (f64) and their properties within groupBy.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_126\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(array, abs(#))\ngroupBy(array, bitshr(#, 0))\ngroupBy(array, f64 - 1)\ngroupBy(array, f64 / #)\ngroupBy(array, f64 < #)\ngroupBy(array, f64)\ngroupBy(array, f64).Bar\ngroupBy(array, f64).String\ngroupBy(array, f64).add\ngroupBy(array, f64).array\ngroupBy(array, f64).f64\ngroupBy(array, f64).i\ngroupBy(array, f64).ok\ngroupBy(array, f64).str\ngroupBy(array, f64)?.Bar\ngroupBy(array, f64)?.[i]\ngroupBy(array, f64)?.[ok]\ngroupBy(array, f64)?.[str]\ngroupBy(array, f64)?.add\ngroupBy(array, f64)?.foo\ngroupBy(array, f64)?.list\ngroupBy(array, f64)?.ok\ngroupBy(array, f64)?.str\n```\n\n----------------------------------------\n\nTITLE: Using findLast with groupBy, map, and complex member access\nDESCRIPTION: Explores the utilization of `findLast` with `groupBy`, `map` functions, and complex member access patterns to identify elements based on nested conditions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_44\n\nLANGUAGE: expr\nCODE:\n```\nfindLast(groupBy(array, #).i32, #)\nfindLast(groupBy(list, \"bar\").div, #?.f32?.half())\nfindLast(groupBy(list, #)[ok], .ok)\nfindLast(groupBy(list, f64).foo, .f32(#, #)?.Qux(#?.i64(add, nil)))\nfindLast(i .. 1, # < #)\nfindLast(i .. i32, # != i64)\nfindLast(i .. i32, ok)\nfindLast(i32 .. i64, # >= i)\nfindLast(i64 .. 1, # < #)\n```\n\n----------------------------------------\n\nTITLE: String Manipulation with Pipes\nDESCRIPTION: This snippet tests string manipulation using pipes in Expr. It includes functions like date, greet, hasPrefix, hasSuffix, indexOf, lastIndexOf, repeat, split, trim, and their variations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_220\n\nLANGUAGE: Expr\nCODE:\n```\nstr | date(str)\nstr | greet()\nstr | greet() != $env?.$env\nstr | greet() not in foo\nstr | hasPrefix($env?.[str])\nstr | hasPrefix(str)\nstr | hasSuffix(str)\nstr | indexOf(str)\nstr | lastIndexOf(str)\nstr | repeat(0)\nstr | repeat(1)\nstr | repeat(i)\nstr | split(str)\nstr | splitAfter(str)\nstr | splitAfter(str, 1)\nstr | trim(str)\nstr | trimPrefix(str)\nstr | trimPrefix(toJSON(ok))\nstr | trimPrefix(type(i))\nstr | trimSuffix(str)\n```\n\n----------------------------------------\n\nTITLE: String Conversion with Literals, Lists, and Other Functions\nDESCRIPTION: This snippet focuses on string conversion with literals (numeric, boolean, list), complex expressions, and function calls, aiming to cover different scenarios and edge cases.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_226\n\nLANGUAGE: Expr\nCODE:\n```\nstring(1) != str\nstring(1) < foo?.Bar\nstring(1) == $env?.[Bar]\nstring(1) not in foo\nstring(1) not startsWith toJSON(1)\nstring(1) | greet()\nstring(1..i)\nstring(1.0 != $env)\nstring(1.0 != 0)\nstring(1.0 != 1.0)\nstring(1.0 != nil)\nstring(1.0 * 0)\nstring(1.0 * 1)\nstring(1.0 * 1.0)\nstring(1.0 * f64)\nstring(1.0 * i)\nstring(1.0 ** 0)\nstring(1.0 ** 1)\nstring(1.0 ** 1.0)\nstring(1.0 ** f64)\nstring(1.0 ** i)\nstring(1.0 + 1.0)\nstring(1.0 + f64)\nstring(1.0 + i)\nstring(1.0 - 0)\nstring(1.0 - 1)\nstring(1.0 - 1.0)\nstring(1.0 - i)\nstring(1.0 / 0)\nstring(1.0 / 1)\nstring(1.0 / 1.0)\nstring(1.0 / f64)\nstring(1.0 < 1)\nstring(1.0 <= 1)\nstring(1.0 <= 1.0)\nstring(1.0 == 1)\nstring(1.0 == 1.0)\nstring(1.0 == f64)\nstring(1.0 == i)\nstring(1.0 == nil)\nstring(1.0 > 0)\nstring(1.0 > 1)\nstring(1.0 > 1.0)\nstring(1.0 > i)\nstring(1.0 >= 1)\nstring(1.0 >= 1.0)\nstring(1.0 ^ 0)\nstring(1.0 ^ 1)\nstring(1.0 ^ 1.0)\nstring(1.0 ^ f64)\nstring(1.0 ^ i)\nstring(1.0 in array)\nstring(1.0)\nstring(1.0) != str\nstring(1.0) not startsWith toJSON(false)\nstring(1.0) startsWith str\nstring(1.0) startsWith type(foo)\nstring(1.0) | greet()\nstring([$env, foo])\nstring([$env, ok])\nstring([$env])\nstring([0, nil])\nstring([1, true])\nstring([1.0])\nstring([1])\nstring([add])\nstring([array])\nstring([f64, f64])\nstring([f64])\nstring([false, 1])\nstring([false])\nstring([foo])\nstring([greet, i])\nstring([greet])\nstring([nil])\nstring([ok, 1])\nstring([ok, list])\nstring([ok, nil])\nstring([ok])\nstring([str])\nstring([true, list])\nstring([true])\nstring(abs(0))\nstring(abs(1))\nstring(abs(1.0))\nstring(abs(f64))\nstring(add == nil)\nstring(add(1, 0))\nstring(add(1, 1))\nstring(add)\nstring(add) in foo\nstring(add) matches str\nstring(add) | greet()\nstring(any(array, ok))\n```\n\n----------------------------------------\n\nTITLE: Less Than Comparisons with 'i' in Expr\nDESCRIPTION: Demonstrates less than comparisons using '<' operator with the variable 'i', involving various data types, environment variables, function calls, and array access using the safe navigation operator.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_154\n\nLANGUAGE: Expr\nCODE:\n```\ni < $env && false\ni < $env || true\ni < $env.f64\ni < $env.i\ni < $env?.f64\ni < $env?.i\ni < 0 && false\ni < 0 / i\ni < 0 < i\ni < 0 <= f64\ni < 0 > 0\ni < 0 || $env\ni < 1 ** i\ni < 1 + 1.0\ni < 1 / 1.0\ni < 1 < f64\ni < 1 <= $env?.[foo]\ni < 1 <= 1\ni < 1 <= sum($env, #)\ni < 1 ? array : add\ni < 1 || $env\ni < 1.0 != ok\ni < 1.0 ** 0\ni < 1.0 < $env?.f64\ni < 1.0 < 1.0\ni < 1.0 <= 1\ni < 1.0 <= 1.0\ni < 1.0 <= f64\ni < 1.0 == true\ni < 1.0 || ok\ni < abs(1.0)\ni < array?.[i]\ni < bitnot(i)\ni < ceil(f64)\ni < f64\ni < f64 != ok\ni < f64 ** ceil(1.0)\ni < f64 < 0\ni < f64 < f64 < i\ni < f64 >= $env\ni < f64 ? 1 : foo\ni < findIndex($env, ok)\ni < first(array)\ni < float(i)\ni < floor(0)\ni < i\ni < i + i\ni < i ^ 0\ni < int(0)\ni < max(f64)\ni < min(1.0)\ni < round(1.0)\ni < sum(array)\n```\n\n----------------------------------------\n\nTITLE: String 'in' checks in Expr\nDESCRIPTION: This snippet demonstrates the use of `in` and `not in` operators in the Expr language to check if a string `str` is present within a collection (e.g., array, object, result of a function call). The expressions cover various scenarios, including checking against environment variables, object properties, function calls, and literal collections.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_217\n\nLANGUAGE: Expr\nCODE:\n```\nstr in $env && $env\nstr in $env == ok\nstr in $env || $env\nstr in $env.foo\nstr in $env?.Bar\nstr in $env?.String\nstr in $env?.[Bar]\nstr in $env?.[Bar]?.[str]\nstr in $env?.[String]\nstr in $env?.[String]?.str()\nstr in $env?.[foobar?.[str]]\nstr in $env?.foo\nstr in $env?.foobar\nstr in $env?.foobar?.greet\nstr in [$env, nil]\nstr in [nil]\nstr in concat(array)\nstr in find(list, true)\nstr in foo\nstr in foo and false\nstr in foo || $env\nstr in list?.[i]\nstr in {foo: 1}\nstr in {foo: f64}\nstr in {foo: foo}\nstr in {foo: i, foo: 1}\nstr in {foo: nil, foo: 1.0}\nstr in {foo: nil}\nstr not in $env.foo\nstr not in $env?.Bar\nstr not in $env?.String\nstr not in $env?.String?.[ok]\nstr not in $env?.[Bar]\nstr not in $env?.[Bar]?.list\nstr not in $env?.[String]\nstr not in $env?.[String]?.add()\nstr not in $env?.[foobar]\nstr not in $env?.[foobar]?.[ok]\nstr not in $env?.[nil]\nstr not in $env?.foo\nstr not in $env?.foobar\nstr not in [nil, greet]\nstr not in [nil]\nstr not in foo\nstr not in foo && $env\nstr not in foo and false\nstr not in foo and ok\nstr not in foo || $env\nstr not in foo || ok\nstr not in foo || true\nstr not in groupBy(list, #)\nstr not in list?.[i]\nstr not in reduce($env, $env, list)\nstr not in {foo: 0, foo: add}\nstr not in {foo: 1.0}\nstr not in {foo: add}\nstr not in {foo: foo, foo: list, foo: $env}\nstr not in {foo: foo}\nstr not in {foo: nil}\n```\n\n----------------------------------------\n\nTITLE: Equality and Inequality (!=, ==)\nDESCRIPTION: Examples of equality and inequality comparisons using `!=` and `==` operators between different data types including booleans, nil, and function results. This highlights type-sensitive comparisons in the Expr language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_94\n\nLANGUAGE: Expr\nCODE:\n```\nok != !ok\nok != (0.5 not in array)\nok != false != ok\nok != nil == nil\nok != not ok\nok != ok\nok == !false\nok == !true\nok == (0.5 not in array)\nok == false ? f64 : 1\nok == nil ? nil : f64\nok == not false\nok == ok\nok == ok != false\ntrue != ok\nnot ok != ok\nnot true != ok\n```\n\n----------------------------------------\n\nTITLE: String Concatenation and Sequencing\nDESCRIPTION: This snippet focuses on testing string operations within a sequence. It combines string literals with variable concatenations and tests the behavior when combined with other language features.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_221\n\nLANGUAGE: Expr\nCODE:\n```\nstr; add\nstr; foo\nstr; greet\nstr; i\nstr; ok\nstr; str\nstr; uniq(array)\n```\n\n----------------------------------------\n\nTITLE: Testing 'none' function with various conditions\nDESCRIPTION: This snippet tests the 'none' function with different conditions applied to arrays and lists. It includes comparisons, logical operations, and checks for existence of values within arrays. It verifies if no element in the collection satisfies given predicate.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_87\n\nLANGUAGE: Expr\nCODE:\n```\nnone(array, 1 <= #)\nnone(array, 1 == 1)\nnone(array, 1 > #)\nnone(array, any(array, true))\nnone(array, f32 != #)\nnone(array, f32 < 0.5)\nnone(array, f32 < 1)\nnone(array, f32 == 1)\nnone(array, f32 > #)\nnone(array, f32 >= #)\nnone(array, f32 >= 1)\nnone(array, f32 >= f32)\nnone(array, f64 != 1)\nnone(array, f64 == #)\nnone(array, f64 > #)\nnone(array, f64 >= #)\nnone(array, i != #)\nnone(array, i < #)\nnone(array, i < f64)\nnone(array, i <= #)\nnone(array, i > #)\nnone(array, i >= #)\nnone(array, i >= 0.5)\nnone(array, i >= i32)\nnone(array, i32 != #)\nnone(array, i32 != i)\nnone(array, i32 != nil)\nnone(array, i32 < #)\nnone(array, i32 > #)\nnone(array, i64 != #)\nnone(array, i64 != 0.5)\nnone(array, i64 > i64)\nnone(array, i64 >= #)\nnone(array, nil != \"bar\")\nnone(array, nil != #)\nnone(array, nil != false)\nnone(array, nil != greet)\nnone(array, nil == #)\nnone(array, nil == 1)\nnone(array, nil == f32)\nnone(array, nil == greet)\nnone(array, nil == half)\nnone(array, not (# == #))\nnone(array, not (# >= 1))\nnone(array, not false)\nnone(array, ok)\nnone(array, reduce(array, true))\nnone(filter(array, # >= f64), ok)\nnone(groupBy(array, #).f64, # or #.Bar)\nnone(groupBy(list, #).div, ok)\nnone(groupBy(list, #).greet, #)\nnone(groupBy(list, 0.5).i, ok)\nnone(i .. i, ok)\nnone(i .. i32, # <= #)\nnone(list, !false)\nnone(list, !ok)\nnone(list, \"bar\" contains \"bar\")\nnone(list, # != #)\nnone(list, # != foo)\nnone(list, # != nil)\nnone(list, # == #)\nnone(list, # == foo)\nnone(list, # in list)\nnone(list, # not in list)\nnone(list, (0.5 not in array) || ok)\nnone(list, 0.5 != i32)\nnone(list, 0.5 > f64)\nnone(list, 0.5 > i)\nnone(list, 1 != i64)\nnone(list, 1 != nil)\nnone(list, 1 == f32)\nnone(list, 1 > 0.5)\nnone(list, all(array, ok))\nnone(list, f32 != 1 ** f64)\nnone(list, f32 >= 0.5)\nnone(list, f32 in array)\nnone(list, f32 not in array)\nnone(list, f64 <= i32)\nnone(list, f64 >= 1)\nnone(list, false) ? ok : half\nnone(list, false) || ok\nnone(list, foo != #)\nnone(list, foo == foo)\nnone(list, i != i)\nnone(list, i != i64)\nnone(list, i >= f32)\nnone(list, i32 == f32)\nnone(list, i32 > 1)\nnone(list, i32 > i64)\nnone(list, i32 not in array)\nnone(list, i64 != 0.5)\nnone(list, i64 > i64)\nnone(list, nil != #)\nnone(list, nil != greet)\nnone(list, nil != i64)\nnone(list, nil == #)\nnone(list, nil == list)\nnone(list, not false)\nnone(list, ok)\nnone(list, one(array, true))\nnone(list, true && ok)\nnone(list, true) and ok\nnone(map(array, #), ok)\nnone(map(array, div), # != #)\nnone(map(array, f64 == #), ok)\nnone(map(list, \"bar\"), # endsWith #)\nnone(map(list, #), nil == list)\nnone(map(list, #), ok)\nnone(map(list, 1), i > #)\nnone(map(list, ok), # ? true : #)\nnone(map(list, ok), #)\nnone(map(list, score), ok)\nnone(sort(filter(array, false)), #?.div > greet(#))\n```\n\n----------------------------------------\n\nTITLE: Expr f64 'not in' Operator Operations\nDESCRIPTION: This snippet demonstrates the usage of the 'not in' operator with f64 numbers in the Expr language. It shows how to check if a given f64 value is not present within different data structures like arrays (both literal and from environment variables), ranges, and results from function calls. These examples also cover optional chaining and conditional logic, showcasing the flexibility of the 'not in' operator.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_89\n\nLANGUAGE: Expr\nCODE:\n```\nf64 not in $env or true\nf64 not in $env.array\nf64 not in $env?.Bar\nf64 not in $env?.String\nf64 not in $env?.[Bar]\nf64 not in $env?.[String]\nf64 not in $env?.[String]?.foo\nf64 not in $env?.[foobar]\nf64 not in $env?.array\nf64 not in $env?.foobar\nf64 not in [$env]\nf64 not in [1.0]\nf64 not in [array | groupBy(#), i]\nf64 not in array\nf64 not in i .. i\nf64 not in keys($env)\nf64 not in map($env, $env)\nf64 not in map(array, 1)\n```\n\n----------------------------------------\n\nTITLE: Date and Duration Functions in Expr\nDESCRIPTION: Demonstrates the usage of the 'date' and 'duration' functions in the Expr language. The 'date' function is used to format a date, while the 'duration' function is likely used to represent a time duration from a string.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_79\n\nLANGUAGE: Expr\nCODE:\n```\ndate(str, str)\nduration(string(0))\nduration(toJSON(0))\n```\n\n----------------------------------------\n\nTITLE: Expr: More Logical OR examples with function calls and slicing\nDESCRIPTION: This snippet presents a continued exploration of logical OR operations.  It covers list slicing, function calls with parameters, and conditions involving numerical comparisons.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_256\n\nLANGUAGE: Expr\nCODE:\n```\ntrue || $env[:String == foo]\ntrue || $env[:foobar]\ntrue || $env[:ok ? false : add]\ntrue || $env[:str]\ntrue || $env[String.Bar(foobar):add()]\ntrue || $env[duration(String):]\ntrue || $env[false | bitand(str):]\ntrue || $env[foobar:]\ntrue || $env[foobar?.[str]:str()]\ntrue || $env[list endsWith str:foobar]\ntrue || 0 != $env?.f64\ntrue || 0 <= $env?.String(str)\ntrue || 1.0 < find($env, #)\ntrue || 1.0 <= i\ntrue || 1.0 > f64 == true\ntrue || add != add\ntrue || i > f64\ntrue || nil != f64\ntrue || nil == foo\ntrue || nil == ok\n\n```\n\n----------------------------------------\n\nTITLE: String Manipulation and Function Calls\nDESCRIPTION: Demonstrates various string manipulation functions, including `upper`, `lower`, `trim`, `toBase64`, and `toJSON`, along with function calls to `greet` and method calls on objects. Includes examples of optional chaining and property access.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_128\n\nLANGUAGE: expr-lang\nCODE:\n```\ntype(upper(\"foo\"))\nupper(\"bar\") not in foo\nupper(\"foo\" + \"foo\")\nupper(\"foo\") == toJSON(\"bar\")\nupper(foo.Bar)\nupper(foo.String())\nupper(foo?.Bar)\nupper(foo?.String())\nupper(greet(\"bar\"))\nupper(greet(\"foo\"))\nupper(last(list).Bar)\nupper(lower(\"bar\"))\nupper(lower(\"foo\"))\nupper(reduce(list, #)?.Bar)\nupper(string(\"foo\"))\nupper(string(0.5))\nupper(string(1))\nupper(string(add))\nupper(string(array))\nupper(string(f32))\nupper(string(i32))\nupper(string(i64))\nupper(string(list))\nupper(string(nil))\nupper(string(score))\nupper(string(true))\nupper(toBase64(\"bar\"))\nupper(toBase64(\"foo\"))\nupper(toJSON(\"foo\"))\nupper(toJSON(1))\nupper(toJSON(f32))\nupper(toJSON(false))\nupper(toJSON(foo))\nupper(toJSON(i))\nupper(toJSON(i32))\nupper(toJSON(list))\nupper(toJSON(nil))\nupper(toJSON(true))\nupper(trim(\"bar\"))\nupper(trim(\"foo\"))\nupper(trimSuffix(\"bar\"))\nupper(trimSuffix(\"foo\"))\nupper(type(\"bar\"))\nupper(type(\"foo\"))\nupper(type(array))\nupper(type(div))\nupper(type(f32))\nupper(type(foo.Bar))\nupper(type(greet))\nupper(type(i))\nupper(type(i32))\nupper(type(list))\nupper(type(nil))\nupper(type(ok))\nupper(type(score))\nupper(type(true))\nupper(upper(\"foo\"))\n```\n\n----------------------------------------\n\nTITLE: Dictionary Operations in Expr\nDESCRIPTION: These snippets demonstrate different dictionary operations in the Expr language. The examples include equality checks, conditional logic, list comprehensions and safe navigation operators. They cover checking for null values, comparing fields, and accessing properties from dictionaries.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_268\n\nLANGUAGE: Expr\nCODE:\n```\n{foo: $env != $env}\n{foo: $env != 0}\n{foo: $env != 1.0}\n{foo: $env != 1}\n{foo: $env != add}\n{foo: $env != f64, foo: foo}\n{foo: $env != foo}\n{foo: $env != greet}\n{foo: $env != greet}.Bar\n{foo: $env != list}\n{foo: $env != nil}\n{foo: $env != ok}\n{foo: $env != str}\n{foo: $env == $env}\n{foo: $env == 0}\n{foo: $env == 0}.array\n{foo: $env == 1.0}\n{foo: $env == 1}\n{foo: $env == add}\n{foo: $env == false}\n{foo: $env == foo}\n{foo: $env == foo}.i\n{foo: $env == greet}\n{foo: $env == i}\n{foo: $env == nil}\n{foo: $env == ok}\n{foo: $env == str}\n{foo: $env == true}\n{foo: $env and false}\n{foo: $env and true}\n{foo: $env in array}\n{foo: $env in list}\n{foo: $env or false}\n{foo: $env or true}\n{foo: $env | any(ok)}\n{foo: $env | any(true)}\n{foo: $env | map(#index)}\n{foo: $env | map($env)}\n{foo: $env | map(0)}\n{foo: $env | map(add), foo: i}\n{foo: $env | map(f64)}\n{foo: $env | map(foo)}\n{foo: $env | map(list)}\n{foo: $env | none(false)}\n{foo: $env | none(true)}\n{foo: $env | one(true)}\n{foo: $env | reduce($env, foo)}?.f64\n{foo: $env | reduce(1, $env)}\n{foo: $env | reduce(foo, 1.0)}\n{foo: $env | sum(0)}\n{foo: $env | sum(1.0)}\n{foo: $env || true}\n{foo: $env, foo: $env, foo: true}?.add\n{foo: $env, foo: $env}.Bar\n{foo: $env, foo: $env}.add\n{foo: $env, foo: $env}.f64\n{foo: $env, foo: $env}.greet\n{foo: $env, foo: $env}.i?.[ok]\n{foo: $env, foo: $env}?.String\n{foo: $env, foo: $env}?.array\n{foo: $env, foo: $env}?.foobar\n{foo: $env, foo: $env}?.ok\n{foo: $env, foo: 0}.Bar\n{foo: $env, foo: 0}.add\n{foo: $env, foo: 0}.greet\n{foo: $env, foo: 0}.ok\n{foo: $env, foo: 0}?.Bar\n{foo: $env, foo: 0}?.false?.ok\n{foo: $env, foo: 0}?.list\n{foo: $env, foo: 1.0, foo: foo}.ok\n{foo: $env, foo: 1.0}.String\n{foo: $env, foo: 1.0}.add\n{foo: $env, foo: 1.0}.greet\n{foo: $env, foo: 1.0}.list\n{foo: $env, foo: 1.0}?.array\n{foo: $env, foo: 1.0}?.foo\n{foo: $env, foo: 1.0}?.i\n{foo: $env, foo: 1.0}?.ok\n{foo: $env, foo: 1.0}?.str\n{foo: $env, foo: 1}.String\n{foo: $env, foo: 1}.f64\n{foo: $env, foo: 1}.ok\n{foo: $env, foo: 1}?.[str]\n{foo: $env, foo: 1}?.f64\n{foo: $env, foo: 1}?.greet\n{foo: $env, foo: 1}?.i\n{foo: $env, foo: add}.foo?.list\n{foo: $env, foo: add}.i\n{foo: $env, foo: add}.list\n{foo: $env, foo: add}.str\n{foo: $env, foo: add}?.add\n{foo: $env, foo: add}?.foo\n{foo: $env, foo: add}?.ok\n{foo: $env, foo: array}.array\n{foo: $env, foo: array}.foo\n{foo: $env, foo: array}.greet\n{foo: $env, foo: array}.i\n{foo: $env, foo: array}.list\n{foo: $env, foo: array}?.f64\n{foo: $env, foo: array}?.foo\n{foo: $env, foo: array}?.greet\n{foo: $env, foo: array}?.str\n{foo: $env, foo: f64}.String\n{foo: $env, foo: f64}.String?.array\n{foo: $env, foo: f64}?.foo\n{foo: $env, foo: f64}?.i\n{foo: $env, foo: false, foo: foo}?.str\n{foo: $env, foo: false}.add\n{foo: $env, foo: false}.array\n{foo: $env, foo: false}.str\n{foo: $env, foo: false}?.[str]\n{foo: $env, foo: false}?.array\n{foo: $env, foo: foo, foo: $env}?.greet\n{foo: $env, foo: foo, foo: list}.String\n{foo: $env, foo: foo}.String\n{foo: $env, foo: foo}.array\n{foo: $env, foo: foo}.foobar\n{foo: $env, foo: foo}.greet\n{foo: $env, foo: foo}.i\n{foo: $env, foo: foo}.list\n{foo: $env, foo: foo}.str\n{foo: $env, foo: foo}?.Bar\n{foo: $env, foo: foo}?.String\n{foo: $env, foo: foo}?.array\n{foo: $env, foo: foo}?.ok\n{foo: $env, foo: greet, foo: 0}.greet\n{foo: $env, foo: greet}.add\n{foo: $env, foo: greet}.foo\n{foo: $env, foo: greet}?.Bar\n{foo: $env, foo: greet}?.add\n{foo: $env, foo: greet}?.f64\n{foo: $env, foo: i}.greet\n{foo: $env, foo: i}?.add\n{foo: $env, foo: i}?.foo\n{foo: $env, foo: list, foo: 1}?.[str]\n{foo: $env, foo: list}.Bar\n{foo: $env, foo: list}.array\n{foo: $env, foo: list}.greet\n{foo: $env, foo: list}?.Bar?.greet\n{foo: $env, foo: list}?.[str]\n{foo: $env, foo: list}?.list\n{foo: $env, foo: nil}.Bar\n{foo: $env, foo: nil}.foo\n{foo: $env, foo: nil}.foobar?.i\n{foo: $env, foo: nil}.greet\n{foo: $env, foo: nil}.str\n{foo: $env, foo: nil}?.add\n{foo: $env, foo: nil}?.f64\n{foo: $env, foo: nil}?.foobar\n{foo: $env, foo: nil}?.list\n{foo: $env, foo: nil}?.str\n{foo: $env, foo: ok}.array\n{foo: $env, foo: ok}.f64\n{foo: $env, foo: str, foo: f64}?.i\n{foo: $env, foo: str}.array\n{foo: $env, foo: str}?.Bar\n{foo: $env, foo: str}?.greet\n{foo: $env, foo: true, foo: 1.0}?.list\n{foo: $env, foo: true}.foobar\n{foo: $env, foo: true}.list\n{foo: $env, foo: true}.str?.list\n{foo: $env, foo: true}?.[str]\n{foo: $env, foo: true}?.greet\n{foo: $env, foo: true}?.ok\n{foo: $env.add, foo: $env.ok}\n{foo: $env.add}\n{foo: $env.add}.String\n{foo: $env.add}.array\n{foo: $env.array, foo: add}\n{foo: $env.array, foo: {foo: array}}\n{foo: $env.array}\n{foo: $env.f64, foo: str}\n{foo: $env.f64}\n{foo: $env.f64}?.add\n{foo: $env.f64}?.array\n{foo: $env.foo, foo: f64}?.list\n{foo: $env.foo}\n{foo: $env.foo}?.String\n{foo: $env.greet, foo: array}\n{foo: $env.greet, foo: i}\n{foo: $env.greet}\n{foo: $env.i, foo: add}\n{foo: $env.i, foo: array}\n{foo: $env.i, foo: ok != $env}\n{foo: $env.i}\n{foo: $env.list, foo: 1.0 == 1.0}\n{foo: $env.list}\n{foo: $env.ok, foo: add}\n{foo: $env.ok}\n{foo: $env.ok}?.str\n{foo: $env.str}\n{foo: $env.str}.ok\n{foo: $env?.$env}\n{foo: $env?.Bar, foo: if false { foo } else { 0 }}\n```\n\n----------------------------------------\n\nTITLE: Equality Comparisons with Nil and Other Variables\nDESCRIPTION: These examples demonstrate equality comparisons where `nil` is compared to properties accessed through environment variables. They show various scenarios with and without safe navigation.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_7\n\nLANGUAGE: Expr\nCODE:\n```\n$env?.[nil] == array?.[0]\n$env?.[nil] == ok\n$env?.[nil] == str\n```\n\n----------------------------------------\n\nTITLE: JavaScript Expression Example 1\nDESCRIPTION: This JavaScript snippet shows how to allow only admins and moderators to moderate comments using Expr syntax. It checks if the user's group is either 'admin' or 'moderator', or if the user ID matches the comment's user ID.\nSOURCE: https://github.com/expr-lang/expr/blob/master/README.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Allow only admins and moderators to moderate comments.\nuser.Group in [\"admin\", \"moderator\"] || user.Id == comment.UserId\n```\n\n----------------------------------------\n\nTITLE: Expr groupBy with numerical and boolean expressions\nDESCRIPTION: Shows how to use numerical constants and boolean expressions, including property accesses, as criteria for groupBy, utilizing direct and safe navigation.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_124\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(array, 0 + #)\ngroupBy(array, 0 == 1.0)\ngroupBy(array, 0).Bar\ngroupBy(array, 0).String\ngroupBy(array, 0).add\ngroupBy(array, 0).array\ngroupBy(array, 0).foo\ngroupBy(array, 0).str\ngroupBy(array, 0)?.Bar\ngroupBy(array, 0)?.String\ngroupBy(array, 0)?.[f64]\ngroupBy(array, 0)?.[foo]\ngroupBy(array, 0)?.[i]\ngroupBy(array, 0)?.[str]\ngroupBy(array, 0)?.add\ngroupBy(array, 0)?.array\ngroupBy(array, 0)?.foo\ngroupBy(array, 0)?.foobar\ngroupBy(array, 0)?.greet\ngroupBy(array, 0)?.i\ngroupBy(array, 0)?.list\ngroupBy(array, 1).String\ngroupBy(array, 1).add\ngroupBy(array, 1).array\ngroupBy(array, 1).f64\ngroupBy(array, 1).foo\ngroupBy(array, 1).greet\ngroupBy(array, 1).i\ngroupBy(array, 1).list\ngroupBy(array, 1)?.Bar\ngroupBy(array, 1)?.[i]\ngroupBy(array, 1)?.[ok]\ngroupBy(array, 1)?.[str]\ngroupBy(array, 1)?.add\ngroupBy(array, 1)?.f64\ngroupBy(array, 1)?.list\ngroupBy(array, 1)?.ok\n```\n\n----------------------------------------\n\nTITLE: Variable 'greet' Comparisons and Function Calls - Expr\nDESCRIPTION: This snippet demonstrates the usage of a variable named `greet` within the Expr language. It shows comparisons of `greet` with itself, `nil`, and boolean conditions. It also involves calls to `greet` with various argument types, including string concatenations, object properties, and other function results like `lower`. This illustrates function application and string manipulation in Expr.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_64\n\nLANGUAGE: Expr\nCODE:\n```\ngreet\ngreet != greet\ngreet != greet != ok\ngreet != nil ? \"bar\" : add\ngreet != nil ? 0.5 : false\ngreet != nil ? list : false\ngreet == greet\ngreet == greet ? 0.5 : \"bar\"\ngreet == greet and ok\ngreet == nil == ok\ngreet == nil ? i64 : ok\ngreet in groupBy(array, f64).f32\ngreet in groupBy(list, #).score\ngreet not in sort(array)\ngreet(\"bar\" + \"bar\")\ngreet(\"foo\" + \"foo\")\ngreet(\"foo\") startsWith type(f64)\ngreet(false ? i64 : \"bar\")\ngreet(foo.Bar)\ngreet(foo.Qux(\"foo\"))\ngreet(foo.String())\ngreet(foo?.Bar)\ngreet(foo?.String())\ngreet(greet(\"bar\"))\ngreet(greet(\"foo\"))\ngreet(lower(\"bar\"))\ngreet(lower(\"foo\"))\n```\n\n----------------------------------------\n\nTITLE: Using the trimPrefix function in Expr\nDESCRIPTION: Demonstrates the usage of the trimPrefix function in Expr. This function removes a specified prefix from a string.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_121\n\nLANGUAGE: Expr\nCODE:\n```\ntrimPrefix(\"bar\" + \"foo\")\ntrimPrefix(\"foo\" + \"bar\")\ntrimPrefix(false ? 1 : \"bar\")\ntrimPrefix(foo.Bar)\ntrimPrefix(foo.String())\ntrimPrefix(foo?.Bar)\ntrimPrefix(foo?.String())\ntrimPrefix(greet(\"bar\"))\ntrimPrefix(greet(\"foo\"))\ntrimPrefix(greet(type(0.5)))\ntrimPrefix(lower(\"bar\"))\ntrimPrefix(string(\"foo\"))\ntrimPrefix(string(0.5))\ntrimPrefix(string(1))\ntrimPrefix(string(add))\ntrimPrefix(string(array))\ntrimPrefix(string(div))\ntrimPrefix(string(f32))\ntrimPrefix(string(f64))\ntrimPrefix(string(foo))\ntrimPrefix(string(greet))\ntrimPrefix(string(half))\ntrimPrefix(string(i))\ntrimPrefix(string(i32))\ntrimPrefix(string(i64))\ntrimPrefix(string(nil))\ntrimPrefix(string(score))\ntrimPrefix(string(true))\ntrimPrefix(string({\"bar\": greet}))\ntrimPrefix(toBase64(\"bar\"))\ntrimPrefix(toJSON(\"foo\"))\ntrimPrefix(toJSON(1))\ntrimPrefix(toJSON(array))\ntrimPrefix(toJSON(f32))\ntrimPrefix(toJSON(foo))\ntrimPrefix(toJSON(i32))\ntrimPrefix(toJSON(i64))\ntrimPrefix(toJSON(list))\ntrimPrefix(toJSON(nil))\ntrimPrefix(toJSON(true))\ntrimPrefix(trimPrefix(\"foo\"))\n```\n\n----------------------------------------\n\nTITLE: Any function examples in Expr\nDESCRIPTION: Demonstrates different use cases of the `any` function in the Expr language, including mapping, ternary operators, and reducing arrays. The `any` function likely checks if any element in a collection satisfies a given condition.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_14\n\nLANGUAGE: Expr\nCODE:\n```\nany(map(list, ok), #)\nany(ok ? \"foo\" : 1, ok)\nany(ok ? \"foo\" : f32, i > #)\nany(reduce(array, array), 1 == #)\n```\n\n----------------------------------------\n\nTITLE: Using the `score` function in Expr\nDESCRIPTION: These examples demonstrate the usage of the `score` function with different arguments and operations, including negative numbers, arithmetic operations, conditional expressions, and array access. These expressions can represent complex scoring calculations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_109\n\nLANGUAGE: Expr\nCODE:\n```\nscore(-1)\nscore(-1, i)\nscore(-get(array, i))\nscore(-i)\nscore(-i, i)\nscore(1 % 1)\nscore(1 % i)\nscore(1 % i32)\nscore(1 % i64)\nscore(1 * 1)\nscore(1 * i)\nscore(1 * i32)\nscore(1 * i64)\nscore(1 + 1)\nscore(1 + i)\nscore(1 + i32)\nscore(1 + i64)\nscore(1 - 1)\nscore(1 - i)\nscore(1 - i32)\nscore(1) != -f32\nscore(1) != i\nscore(1) != i32\nscore(1) % -1\nscore(1) % i\nscore(1) % i64\nscore(1) * f32\nscore(1) * i\nscore(1) * i64\nscore(1) ** i32\nscore(1) + f64\nscore(1) + i32\nscore(1) - f32\nscore(1) - i\nscore(1) - i32\nscore(1) - int(0.5)\nscore(1) .. i\nscore(1) .. i32\nscore(1) .. i64\nscore(1) .. score(1)\nscore(1) / f32\nscore(1) / i32\nscore(1) < i\nscore(1) < i32\nscore(1) < i64\nscore(1) < i64 - 0.5\nscore(1) <= 0.5 * 1\nscore(1) <= i\nscore(1) <= i64\nscore(1) == i32\nscore(1) == i64\nscore(1) > bitshr(i64, 1)\nscore(1) > f32\nscore(1) > i64\nscore(1) >= 0.5 + f64\nscore(1) >= f32\nscore(1) >= i\nscore(1) >= sum(array)\nscore(1) ^ f64\nscore(1) ^ i\nscore(1) ^ i32\nscore(1) in array\nscore(1) not in groupBy(list, false)\nscore(1, 1) < i\nscore(1, i) < f64\nscore(1, i) ^ f32\nscore(abs(1))\nscore(abs(i))\nscore(add(1, i))\nscore(array[1])\nscore(array[i64])\nscore(array[i])\nscore(bitnand(1, i64))\nscore(bitnand(i64, i32))\nscore(bitnot(1))\nscore(bitnot(i))\nscore(bitnot(i32))\nscore(bitnot(i64))\nscore(bitshl(i32, i))\nscore(bitshr(1, i64))\nscore(bitshr(i32, i64))\n```\n\n----------------------------------------\n\nTITLE: trimPrefix Function in Expr\nDESCRIPTION: Illustrates the use of the `trimPrefix` function to remove a specified prefix from a string.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_23\n\nLANGUAGE: expr\nCODE:\n```\ntrimPrefix(\"HelloWorld\", \"Hello\") == \"World\"\n```\n\n----------------------------------------\n\nTITLE: Expr groupBy with boolean operations and property access\nDESCRIPTION: Demonstrates grouping based on boolean logical operations, boolean literals (true/false), and accessing properties of boolean values with safe navigation.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_127\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(array, false and $env)\ngroupBy(array, false or true)\ngroupBy(array, false).Bar\ngroupBy(array, false).String\ngroupBy(array, false).add\ngroupBy(array, false).f64\ngroupBy(array, false).foo\ngroupBy(array, false).greet\ngroupBy(array, false).list\ngroupBy(array, false).str\ngroupBy(array, false)?.Bar\ngroupBy(array, false)?.String\ngroupBy(array, false)?.[f64]\ngroupBy(array, false)?.[foo]\ngroupBy(array, false)?.[i]\ngroupBy(array, false)?.[str]\ngroupBy(array, false)?.add\ngroupBy(array, false)?.f64\ngroupBy(array, false)?.foo\ngroupBy(array, false)?.greet\ngroupBy(array, false)?.ok\ngroupBy(array, false)?.str\n```\n\n----------------------------------------\n\nTITLE: Other Comparisons\nDESCRIPTION: Miscellaneous comparison examples using not endsWith and not in.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_98\n\nLANGUAGE: Expr\nCODE:\n```\nok == (\"bar\" not endsWith \"foo\")\nok == (i32 not in array)\nok == (nil not in list)\n```\n\n----------------------------------------\n\nTITLE: Bitwise AND Operations in Expr\nDESCRIPTION: Demonstrates the use of the `bitand` function in the Expr language with different data types (integers, floats, and variables). It covers comparisons, mathematical operations, and potential type coercion.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_16\n\nLANGUAGE: Expr\nCODE:\n```\nbitand(1 * i64, i)\nbitand(1, 1) != i\nbitand(1, i64) == f64\nbitand(i, i)\nbitand(i, i32)\nbitand(i, i64)\nbitand(i32, 1) != f32\nbitand(i32, i)\nbitand(i32, i) - i32\nbitand(i32, i32 * i)\nbitand(i32, i32)\nbitand(i32, i64)\nbitand(i64, 1) <= i32\nbitand(i64, i + i64)\nbitand(i64, i)\nbitand(i64, i) ^ f64\nbitand(i64, i32)\nbitand(i64, i64)\nbitand(int(i32), i64)\n```\n\n----------------------------------------\n\nTITLE: Counting with Boolean and Arithmetic Operations in Expr\nDESCRIPTION: This snippet showcases the count function used with boolean conditions, arithmetic operations, and function calls like 'div', 'any', 'reduce', 'groupBy', and range operators (..). It tests the interaction of these different language features.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_30\n\nLANGUAGE: Expr\nCODE:\n```\ncount(array, any(array, true))\ncount(array, div(#, 1) >= #)\ncount(array, f32 <= #)\ncount(array, f32 == #)\ncount(array, f64 < #)\ncount(array, f64 < f32)\ncount(array, f64 <= #)\ncount(array, f64 <= 1)\ncount(array, f64 == #)\ncount(array, false) ** i32\ncount(array, false) + f32\ncount(array, false) - i64\ncount(array, false) / f64\ncount(array, false) > i64 * i64\ncount(array, foo in list)\ncount(array, foo not in list)\ncount(array, i != #)\ncount(array, i < #)\ncount(array, i < 0.5)\ncount(array, i <= #)\ncount(array, i == #)\ncount(array, i > i64)\ncount(array, i >= #)\ncount(array, i32 != #)\ncount(array, i32 != i)\ncount(array, i32 < #)\ncount(array, i32 < 1)\ncount(array, i32 <= #)\ncount(array, i32 <= f32)\ncount(array, i32 == #)\ncount(array, i32 == 0.5)\ncount(array, i32 > #)\ncount(array, i32 >= #)\ncount(array, i32 >= f32)\ncount(array, i32 >= i32)\ncount(array, i64 != i32)\ncount(array, i64 != i64)\ncount(array, i64 < #)\ncount(array, i64 <= #)\ncount(array, i64 == #)\ncount(array, i64 == i64)\ncount(array, i64 > 1)\ncount(array, list != array)\ncount(array, list != nil)\ncount(array, nil != \"foo\")\ncount(array, nil != f64)\ncount(array, nil == 1)\ncount(array, nil == list)\ncount(array, nil == nil)\ncount(array, none(array, false))\ncount(array, not false)\ncount(array, ok or false)\ncount(array, ok)\ncount(array, ok) * i32\ncount(array, ok) ^ i\ncount(array, reduce(list, false))\ncount(array, true == ok)\ncount(array, true) / f64\ncount(filter(list, true), ok)\ncount(groupBy(list, #).String, .div?.array)\ncount(i .. 1, # == i)\ncount(i .. i, ok)\ncount(i32 .. i, # >= #)\ncount(i64 .. 1, nil != f32)\n```\n\n----------------------------------------\n\nTITLE: Expr Example: Array Access\nDESCRIPTION: This expression accesses an element of an array. It shows the default behavior where the return type is `any` when accessing elements from arrays created in Expr.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/configuration.md#_snippet_5\n\nLANGUAGE: expr\nCODE:\n```\nlet arr = [1, 2, 3]; arr[0]\n```\n\n----------------------------------------\n\nTITLE: JavaScript Expression Example 2\nDESCRIPTION: This JavaScript snippet demonstrates how to determine if a request falls within a permitted time window. It calculates the difference between the request time and the resource age and checks if it's less than 24 hours.\nSOURCE: https://github.com/expr-lang/expr/blob/master/README.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Determine whether the request is in the permitted time window.\nrequest.Time - resource.Age < duration(\"24h\")\n```\n\n----------------------------------------\n\nTITLE: Conditional Expressions with 'ok' as condition\nDESCRIPTION: These code snippets use the boolean variable 'ok' as a condition in ternary expressions (`ok ? value1 : value2`). They demonstrate the effect of 'ok' being true or false on selecting different values of various types, including primitives, functions, object properties, and expressions involving arithmetic and comparisons.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_95\n\nLANGUAGE: Expr\nCODE:\n```\nok ? \"bar\" : f64 <= f32\nok ? \"foo\" : foo.Bar\nok ? -0.5 : add\nok ? -f64 : list\nok ? -i32 : i\nok ? 0.5 / 0.5 : f64\nok ? 0.5 : i32 >= i64\nok ? 0.5 > 1 : 0.5 * i64\nok ? 1 + i : i32\nok ? 1 / i64 : greet\nok ? 1 : foo.Bar\nok ? 1 : foo?.Qux\nok ? abs(i64) : i64\nok ? add : abs(f32)\nok ? add : add\nok ? add : array\nok ? add : f64\nok ? add : foo\nok ? add : foo?.String\nok ? add : greet\nok ? add : half\nok ? add : i\nok ? add : i64\nok ? add : list\nok ? add : ok\nok ? array : array\nok ? array : f32\nok ? array : f64 + f64\nok ? array : foo\nok ? array : foo.String\nok ? array : foo?.String\nok ? array : greet\nok ? array : i\nok ? array : i32\nok ? array : list\nok ? array : ok\nok ? array : score\nok ? div : add\nok ? div : array\nok ? div : div\nok ? div : f64\nok ? div : foo\nok ? div : foo.Bar\nok ? div : greet\nok ? div : half\nok ? div : i32 > reduce(array, #)\nok ? div : nil == true\nok ? div : ok\nok ? div : score\nok ? f32 != i32 : f32\nok ? f32 ** i64 : score\nok ? f32 : -0.5\nok ? f32 : add\nok ? f32 : array\nok ? f32 : div\nok ? f32 : f32\nok ? f32 : f64\nok ? f32 : foo\nok ? f32 : half\nok ? f32 : i32\nok ? f32 : i64\nok ? f32 : ok\nok ? f32 : score\nok ? f64 : add\nok ? f64 : array\nok ? f64 : div\nok ? f64 : f64 - f64\nok ? f64 : false != true\nok ? f64 : foo\nok ? f64 : foo.String\nok ? f64 : greet\nok ? f64 : i32\nok ? f64 : i32 % i32\nok ? f64 : i32 >= -i64\nok ? f64 : ok\nok ? f64 : score\nok ? false : foo.Bar\nok ? foo : div\nok ? foo : f32\nok ? foo : foo\nok ? foo : greet\nok ? foo : half\nok ? foo : i32\nok ? foo : i32 > i32\nok ? foo : i64\nok ? foo : list\nok ? foo : ok\nok ? foo : score\nok ? foo.Qux : ok\nok ? greet : 0.5 > i\nok ? greet : 1 <= 0.5\nok ? greet : add\nok ? greet : div\nok ? greet : f32\nok ? greet : f64\nok ? greet : foo\nok ? greet : half\nok ? greet : i64\nok ? greet : list\nok ? greet : map(list, i)\nok ? greet : ok\nok ? greet : score\nok ? half : add\nok ? half : f32\nok ? half : f64\nok ? half : foo\nok ? half : foo?.Qux\nok ? half : greet\nok ? half : half\nok ? half : list\nok ? half : nil in list\nok ? half : ok\nok ? half : reduce(list, \"bar\")\nok ? half : string(array)\nok ? half(1) : add\nok ? i : 1 / i64\nok ? i : add\nok ? i : array\nok ? i : f32 <= 0.5\nok ? i : foo\nok ? i : half\nok ? i : i\nok ? i : i32\nok ? i : i64\nok ? i : list\nok ? i : ok\nok ? i : score\nok ? i32 : 1 - f64\nok ? i32 : add\nok ? i32 : div\nok ? i32 : f32\nok ? i32 : f32 + 0.5\nok ? i32 : f64\nok ? i32 : foo\nok ? i32 : foo.Qux\nok ? i32 : greet\nok ? i32 : i\nok ? i32 : i32\nok ? i32 : i32 + i32\nok ? i32 : list\nok ? i32 : ok\nok ? i32 : score\nok ? i64 : (ok ? list : half)\nok ? i64 : div\nok ? i64 : f32\nok ? i64 : foo\nok ? i64 : foo.String\nok ? i64 : half\nok ? i64 : i\nok ? i64 : i32\nok ? i64 : i64\nok ? i64 : list\nok ? i64 : ok\nok ? i64 ^ f32 : foo\nok ? list : 0.5 * f64\nok ? list : add\nok ? list : array\nok ? list : div\nok ? list : div(i64, 1)\nok ? list : f32\nok ? list : foo.String\nok ? list : greet\nok ? list : half\nok ? list : i\nok ? list : i - f32\nok ? list : i64\nok ? list : list\nok ? list : list != array\nok ? list : not ok\nok ? list : score\nok ? ok : false\n```\n\n----------------------------------------\n\nTITLE: Take Function Usage (Expr)\nDESCRIPTION: Examples demonstrating the use of the `take` function with different list and index arguments.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_239\n\nLANGUAGE: Expr\nCODE:\n```\ntake(array, i)\ntake(list, i)\n```\n\n----------------------------------------\n\nTITLE: Add Function Membership Tests\nDESCRIPTION: Examples illustrating the use of the `in` and `not in` operators to check if the `add` function is present in various data structures, including objects, arrays, and results of function calls. It helps to test the membership evaluation logic.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_33\n\nLANGUAGE: Expr\nCODE:\n```\nadd in $env?.Bar\nadd in $env?.String\nadd in $env?.[Bar]\nadd in $env?.[String]\nadd in $env?.[String]?.add\nadd in $env?.[String]?.array\nadd in $env?.[foobar]\nadd in $env?.foobar\nadd in $env?.foobar?.str()?.greet\nadd in [$env, $env]\nadd in keys($env)\nadd in values($env)\nadd in {foo: add}?.add\nadd not in $env?.Bar\nadd not in $env?.String\nadd not in $env?.[Bar]\nadd not in $env?.[String]\nadd not in $env?.[foobar]\nadd not in $env?.foobar\nadd not in $env?.foobar == false\nadd not in $env?.foobar?.[str]\nadd not in $env?.true?.[greet]\nadd not in first($env)\nadd not in keys($env)\nadd not in reverse(list)\nadd not in {foo: 1}?.array\n```\n\n----------------------------------------\n\nTITLE: String Conversion with Type Conversion Functions\nDESCRIPTION: This snippet tests string conversion of type conversion functions such as `float`, `floor`. It focuses on how the string conversion handles the output of these conversion operations with various data types.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_232\n\nLANGUAGE: Expr\nCODE:\n```\nstring(float(0))\nstring(float(1.0))\nstring(float(f64))\nstring(float(i))\nstring(floor(0))\nstring(floor(1))\nstring(floor(1.0))\nstring(floor(f64))\nstring(floor(i))\n```\n\n----------------------------------------\n\nTITLE: Lowercasing Strings in Expr with `lower` Function\nDESCRIPTION: These examples demonstrate the usage of the `lower` function in Expr to convert strings to lowercase.  The function is applied to string literals, concatenated strings, results of other functions (like `greet`, `trim`, `toBase64`, `toJSON`, `upper`, `string`), and properties of objects (foo.Bar, foo.String()).  The snippets validate the function's behavior with different input types.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_77\n\nLANGUAGE: Expr\nCODE:\n```\nlower(\"bar\" + \"bar\")\nlower(\"bar\") == trimSuffix(\"bar\")\nlower(\"foo\" + \"bar\")\nlower(false ? foo : \"bar\")\nlower(foo.Bar)\nlower(foo.String())\nlower(foo?.Bar)\nlower(foo?.String())\nlower(greet(\"bar\"))\nlower(greet(\"foo\"))\nlower(lower(\"bar\"))\nlower(lower(\"foo\"))\nlower(reduce(array, \"bar\"))\nlower(reduce(list, \"bar\"))\nlower(string(\"foo\"))\nlower(string(0.5))\nlower(string(add))\nlower(string(f32))\nlower(string(f64))\nlower(string(foo))\nlower(string(greet))\nlower(string(i))\nlower(string(i32))\nlower(string(i64))\nlower(string(list))\nlower(string(nil))\nlower(string(score))\nlower(toBase64(\"foo\"))\nlower(toBase64(string(i)))\nlower(toJSON(\"bar\"))\nlower(toJSON(\"foo\"))\nlower(toJSON(0.5))\nlower(toJSON(1))\nlower(toJSON(f64))\nlower(toJSON(foo))\nlower(toJSON(list))\nlower(toJSON(nil))\nlower(toJSON(ok))\nlower(toJSON(true))\nlower(trim(\"bar\"))\nlower(trim(\"foo\"))\nlower(trimPrefix(\"bar\"))\nlower(trimPrefix(\"foo\"))\nlower(trimSuffix(\"bar\"))\nlower(type(\"bar\"))\nlower(type(\"foo\"))\nlower(type(0.5))\nlower(type(1))\nlower(type(add))\nlower(type(div))\nlower(type(f32))\nlower(type(half))\nlower(type(i))\nlower(type(i32))\nlower(type(i64))\nlower(type(list))\nlower(type(ok))\nlower(type(true))\nlower(upper(\"bar\"))\nlower(upper(\"foo\"))\n```\n\n----------------------------------------\n\nTITLE: Array One\nDESCRIPTION: Checks if exactly one element in the array satisfies the condition that it is equal to itself. Requires proper datatypes for comparison Returns a boolean\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_60\n\nLANGUAGE: Expr\nCODE:\n```\narray | one(# == #)\n```\n\n----------------------------------------\n\nTITLE: Counting with List Operations and Conditions in Expr\nDESCRIPTION: This snippet uses count operations on 'list' with various boolean operators, comparisons, and collection membership checks. It demonstrates counting with boolean negation (!), string matching, relational operators, and type-specific comparisons.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_31\n\nLANGUAGE: Expr\nCODE:\n```\ncount(list, !false)\ncount(list, !true)\ncount(list, \"bar\" not matches \"bar\")\ncount(list, \"foo\" in #)\ncount(list, # != #)\ncount(list, # == #)\ncount(list, # == nil)\ncount(list, # in list)\ncount(list, 0.5 < f32)\ncount(list, 0.5 <= 0.5)\ncount(list, 0.5 <= i64)\ncount(list, 0.5 > 0.5)\ncount(list, 0.5 > 1)\ncount(list, 0.5 > f32)\ncount(list, 1 != i)\ncount(list, 1 >= 0.5)\ncount(list, 1 >= f32)\ncount(list, f32 == i64)\ncount(list, f32 >= f32)\ncount(list, false && false)\ncount(list, false) + -1\ncount(list, false) / f64\ncount(list, false) > f32\ncount(list, foo == #)\ncount(list, i != i64)\ncount(list, i < 0.5)\ncount(list, i <= i64)\ncount(list, i > 1)\ncount(list, i32 < f32)\ncount(list, i32 < i64)\ncount(list, i64 not in array)\ncount(list, nil != #)\ncount(list, nil != false)\ncount(list, nil == list)\ncount(list, not false)\ncount(list, ok)\ncount(list, ok) % i64\ncount(list, ok) / half(1)\ncount(list, ok) / i\ncount(list, ok) >= i32\ncount(list, ok) ^ i\ncount(list, ok) ^ i64\ncount(list, true or ok)\ncount(list, true || true)\ncount(list, true) * f32\ncount(list, true) == i\n```\n\n----------------------------------------\n\nTITLE: 'greet' Function Calls - Expr\nDESCRIPTION: Demonstrates different calls to a 'greet' function with various arguments, showcasing nested calls, conditional expressions, and other functions as arguments.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_119\n\nLANGUAGE: Expr\nCODE:\n```\ngreet($env.str)\ngreet($env?.str)\ngreet($env?.[str])\ngreet($env?.greet(str))\ngreet(foo.Bar)\ngreet(foo.String())\ngreet(foo?.Bar)\ngreet(foo?.Bar) not endsWith str\ngreet(foo?.String())\ngreet(greet($env?.[str]))\ngreet(greet(foo.String()))\ngreet(greet(str))\ngreet(greet(str[:i]))\ngreet(greet(type($env)))\ngreet(greet(type(true)))\ngreet(if false { 1.0 } else { str })\ngreet(if ok { str } else { nil })\ngreet(join($env | map(str)))\ngreet(keys($env)?.[i])\ngreet(last(list).Bar)\ngreet(list | reduce(#.Bar))\ngreet(list | reduce(str))\ngreet(list | reduce(str, str))\ngreet(list?.[i].Bar)\ngreet(lower(greet(str)))\ngreet(lower(str))\ngreet(ok ? str : 1)\ngreet(reduce(array, str))\ngreet(reduce(list, str))\ngreet(str + str)\ngreet(str | greet())\ngreet(str | repeat(0))\ngreet(str | trim(str))\ngreet(str)\ngreet(str) != $env && $env\ngreet(str) != str\ngreet(str) < str\ngreet(str) <= str\ngreet(str) == nil ? foo : nil\ngreet(str) > type(0)\ngreet(str) >= str\ngreet(str) contains str\ngreet(str) contains string(true))\ngreet(str) endsWith $env?.[str])\ngreet(str) endsWith str\ngreet(str) matches str\ngreet(str) not contains str\ngreet(str) not endsWith string(foo))\ngreet(str) not endsWith type(nil))\ngreet(str) not in foo\ngreet(str) not startsWith $env?.Bar\ngreet(str) | greet()\ngreet(str)[:]\ngreet(str)[:i]\ngreet(str)[i:]\ngreet(str[0:])\ngreet(str[1:0])\ngreet(str[1:])\ngreet(str[:1])\ngreet(str[:])\ngreet(str[:i])\ngreet(str[i:])\ngreet(str[i:i])\ngreet(string($env))\ngreet(string($env?.Bar))\ngreet(string(0))\ngreet(string(1))\ngreet(string(1.0))\ngreet(string(add))\ngreet(string(array | sortBy(str)))\ngreet(string(array))\ngreet(string(f64))\ngreet(string(false))\ngreet(string(foo))\ngreet(string(greet))\ngreet(string(groupBy(list, ok)))\ngreet(string(i))\ngreet(string(last(array)))\ngreet(string(list))\ngreet(string(nil))\ngreet(string(ok))\ngreet(string(str))\ngreet(string(true))\ngreet(toBase64(str))\ngreet(toJSON(0))\ngreet(toJSON(1))\ngreet(toJSON(1.0 + 1.0))\ngreet(toJSON(1.0))\ngreet(toJSON(array | sum(#)))\ngreet(toJSON(array))\ngreet(toJSON(f64))\ngreet(toJSON(false))\ngreet(toJSON(foo) | greet())\ngreet(toJSON(foo))\ngreet(toJSON(foo?.Bar))\ngreet(toJSON(i))\ngreet(toJSON(list))\ngreet(toJSON(nil))\ngreet(toJSON(ok))\ngreet(toJSON(str))\ngreet(toJSON(true))\ngreet(trim(str))\ngreet(trimPrefix(str))\ngreet(trimSuffix(foo.String()))\ngreet(trimSuffix(str))\ngreet(true ? str : i)\ngreet(true ? str : nil)\ngreet(type($env))\ngreet(type($env.ok))\ngreet(type(0))\ngreet(type(1))\ngreet(type(1.0))\ngreet(type(add))\ngreet(type(array))\ngreet(type(f64))\ngreet(type(false))\ngreet(type(foo))\ngreet(type(greet))\ngreet(type(i))\ngreet(type(list))\ngreet(type(map(array, ok)))\ngreet(type(nil == f64))\ngreet(type(nil))\ngreet(type(ok))\ngreet(type(str))\ngreet(type(true))\ngreet(upper(str))\n```\n\n----------------------------------------\n\nTITLE: Median Function Calls in Expr\nDESCRIPTION: Illustrates various calls to the `median` function with different data types, operations, and functions as arguments in the Expr language. It covers numeric literals, arithmetic operations, conditional expressions, array manipulations, and environment variables.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_193\n\nLANGUAGE: text\nCODE:\n```\nmedian(1 * 1)\nmedian(1 * 1.0)\nmedian(1 * i)\nmedian(1 ** i)\nmedian(1 + 0)\nmedian(1 + 1)\nmedian(1 + f64)\nmedian(1 + i)\nmedian(1 - 0)\nmedian(1 - 1)\nmedian(1 - 1.0)\nmedian(1 - f64)\nmedian(1 .. 0)\nmedian(1 / 1.0)\nmedian(1 ^ 0)\nmedian(1 ^ 0, f64)\nmedian(1 ^ i)\nmedian(1 | max(array), i)\nmedian(1) != 1.0 && ok\nmedian(1) ^ $env?.f64\nmedian(1.0 * f64)\nmedian(1.0 * i)\nmedian(1.0 ** 1.0)\nmedian(1.0 ** f64)\nmedian(1.0 ** i)\nmedian(1.0 + 0)\nmedian(1.0 + 1.0)\nmedian(1.0 + f64)\nmedian(1.0 + i)\nmedian(1.0 - 1)\nmedian(1.0 - 1.0)\nmedian(1.0 - i)\nmedian(1.0 / 1)\nmedian(1.0 / 1.0)\nmedian(1.0 / f64)\nmedian(1.0 / i)\nmedian(1.0 ^ 1)\nmedian(1.0 ^ f64)\nmedian(1.0 ^ i)\nmedian(1.0 | mean(i))\nmedian(1.0) + 1.0 != f64\nmedian(1.0) + i\nmedian(1.0) - f64\nmedian(1.0) / f64\nmedian(1.0) <= f64\nmedian(1.0) <= i / 0\nmedian(1.0) > 1.0 ? greet : list\nmedian(1.0) >= f64\nmedian(1.0) in array\nmedian(1.0) not in array\nmedian(1.0) | max(i)\nmedian(1.0, 0) ** f64\nmedian(1.1)\nmedian([0])\nmedian([1 % i])\nmedian([1, 1.0])\nmedian([1.0])\nmedian([1])\nmedian([1], $env.f64)\nmedian([array])\nmedian([i])\nmedian(abs(0))\nmedian(abs(1))\nmedian(abs(1.0))\nmedian(abs(f64))\nmedian(abs(i))\nmedian(add(1, 0))\nmedian(array | find(ok))\nmedian(array | map(#))\nmedian(array | reduce(1.0))\nmedian(array | reduce(i, foo))\nmedian(array | sortBy(#))\nmedian(array | sortBy(i))\nmedian(array | sum(#))\nmedian(array)\nmedian(array) != ok\nmedian(array) / f64\nmedian(array) < i\nmedian(array) >= i\nmedian(array) ^ f64\nmedian(array, $env?.i)\nmedian(array, array)\nmedian(array, f64)\nmedian(array, i .. 0)\nmedian(array, i)\nmedian(array?.[i])\nmedian(array[0:])\nmedian(array[1:])\nmedian(bitand(1, 1))\nmedian(bitnot(0))\nmedian(bitnot(1))\nmedian(bitnot(i))\nmedian(ceil($env.i))\nmedian(ceil(0))\nmedian(ceil(1.0))\nmedian(ceil(f64))\nmedian(ceil(i))\nmedian(concat(array))\nmedian(count(array[0:0]))\nmedian(f64 * $env?.f64)\nmedian(f64 * f64)\nmedian(f64 ** $env?.i)\nmedian(f64 ** 1.0)\nmedian(f64 + 1.0)\nmedian(f64 + f64)\nmedian(f64 - 1.0)\nmedian(f64 - i)\nmedian(f64 / 1.0)\nmedian(f64 / f64)\nmedian(f64 ^ 1)\nmedian(f64 ^ f64)\nmedian(f64 | min(1.0))\nmedian(f64)\nmedian(f64) + i\nmedian(f64) < f64\nmedian(f64, array)\nmedian(f64, array) / 0 == 0\nmedian(f64, f64)\nmedian(f64, i)\nmedian(f64, i) + i\nmedian(f64, i, 1 - 0)\nmedian(f64, list | sum(i))\nmedian(filter(list, false))\nmedian(findIndex($env, true))\nmedian(first(array))\nmedian(flatten(array))\nmedian(float(0))\nmedian(float(1))\nmedian(float(1.0))\nmedian(float(f64))\nmedian(float(i))\nmedian(floor(0))\nmedian(floor(1))\nmedian(floor(1.0))\nmedian(floor(f64))\nmedian(floor(i))\nmedian(i % i)\nmedian(i * 0)\nmedian(i * 1)\nmedian(i * 1.0)\nmedian(i ** 0)\nmedian(i + 1)\nmedian(i - 1.0)\nmedian(i - i)\nmedian(i .. i)\nmedian(i / 0)\nmedian(i / 1.0)\nmedian(i ^ 1.0)\nmedian(i ^ f64)\nmedian(i ^ i)\nmedian(i | bitnand(i))\nmedian(i)\nmedian(i) | median(array)\nmedian(i) | min(f64)\nmedian(i, array)\nmedian(i, f64)\nmedian(i, floor(1))\nmedian(i, i)\nmedian(i..i)\nmedian(if false { $env } else { 1 })\nmedian(if false { 1.0 } else { i })\nmedian(int(1))\nmedian(int(1.0))\nmedian(int(1.0), array)\nmedian(int(f64))\nmedian(int(i))\nmedian(last(array))\nmedian(len($env))\nmedian(list | map(array))\nmedian(list | reduce(i))\nmedian(map($env, 1))\nmedian(map($env, f64))\nmedian(map(list, 1.0))\nmedian(max(0))\nmedian(max(1))\nmedian(max(1.0))\nmedian(max(1.0, i))\nmedian(max(i))\nmedian(mean(0))\nmedian(mean(1))\nmedian(mean(1.0))\nmedian(mean(1.0, i))\nmedian(mean(array))\nmedian(mean(f64))\nmedian(mean(i))\nmedian(median(0))\nmedian(median(1, 1.0))\nmedian(median(1.0))\nmedian(median(array))\nmedian(median(f64, i))\nmedian(median(i))\nmedian(min(0 * 1))\nmedian(min(0))\nmedian(min(1))\nmedian(min(array))\nmedian(min(f64))\nmedian(min(i))\nmedian(reduce(array, #))\nmedian(reduce(array, i))\nmedian(reduce(list, #index))\nmedian(reduce(list, 1.0))\nmedian(reverse(array))\nmedian(round(0))\nmedian(round(1))\nmedian(round(1.0))\nmedian(round(f64))\nmedian(round(i))\nmedian(sort($env))\nmedian(sort(array))\nmedian(sum($env, 1.0))\nmedian(sum(array))\nmedian(sum(array), f64)\nmedian(sum(array, #))\nmedian(sum(list, i))\nmedian(true ? 0 : 1.0, f64)\nmedian(uniq(array))\n```\n\n----------------------------------------\n\nTITLE: String Conversion in Expr\nDESCRIPTION: This snippet demonstrates the usage of the 'string' function to convert various data types and expressions into strings within the Expr language. It covers boolean logic, arithmetic operations, comparisons, function calls, and collection access.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_112\n\nLANGUAGE: Expr\nCODE:\n```\nsortBy(array, string(true))\nstring(!!false)\nstring(!false)\nstring(!ok)\nstring(!true)\nstring(\"bar\" != nil)\nstring(\"bar\" <= \"bar\")\nstring(\"bar\" == \"bar\")\nstring(\"bar\" > \"foo\")\nstring(\"bar\" >= \"bar\")\nstring(\"bar\" not endsWith \"bar\")\nstring(\"bar\" not matches \"bar\")\nstring(\"bar\" not startsWith \"foo\")\nstring(\"bar\" startsWith \"foo\")\nstring(\"bar\") > type(i64)\nstring(\"bar\") >= toJSON(\"bar\")\nstring(\"foo\" != nil)\nstring(\"foo\" == \"foo\")\nstring(\"foo\" == nil)\nstring(\"foo\" > \"bar\")\nstring(\"foo\" in foo)\nstring(\"foo\" matches \"bar\")\nstring(\"foo\" not contains \"bar\")\nstring(\"foo\" not contains \"foo\")\nstring(\"foo\" not in foo)\nstring(--i)\nstring(-0.5)\nstring(-1)\nstring(-f32)\nstring(-f64)\nstring(-i)\nstring(-i32)\nstring(-i64)\nstring(0.5 != 0.5)\nstring(0.5 != f64)\nstring(0.5 != i)\nstring(0.5 != i32)\nstring(0.5 * 0.5)\nstring(0.5 * i)\nstring(0.5 * i32)\nstring(0.5 ** f32)\nstring(0.5 ** i32)\nstring(0.5 + f64)\nstring(0.5 + i)\nstring(0.5 + i64)\nstring(0.5 - f32)\nstring(0.5 - f64)\nstring(0.5 / 0.5)\nstring(0.5 / 1)\nstring(0.5 / f32)\nstring(0.5 / i)\nstring(0.5 < 0.5)\nstring(0.5 < 1)\nstring(0.5 < i64)\nstring(0.5 <= 0.5)\nstring(0.5 <= f64)\nstring(0.5 <= i)\nstring(0.5 <= i32)\nstring(0.5 == 0.5)\nstring(0.5 == 1)\nstring(0.5 == i64)\nstring(0.5 == nil)\nstring(0.5 > 0.5)\nstring(0.5 > 1)\nstring(0.5 > i)\nstring(0.5 > i64)\nstring(0.5 >= 0.5)\nstring(0.5 >= 1)\nstring(0.5 >= f32)\nstring(0.5 >= i32)\nstring(0.5 >= i64)\nstring(0.5 ^ f32)\nstring(0.5 ^ i)\nstring(0.5 ^ i32)\nstring(0.5 ^ i64)\nstring(0.5 in array)\nstring(0.5 not in array)\nstring(1 != 0.5)\nstring(1 != 1)\nstring(1 != i)\nstring(1 != i64)\nstring(1 != nil)\nstring(1 % 1)\nstring(1 % i)\nstring(1 % i32)\nstring(1 * 0.5)\nstring(1 * f32)\nstring(1 * f64)\nstring(1 ** 0.5)\nstring(1 ** 1)\nstring(1 ** i)\nstring(1 ** i64)\nstring(1 + 0.5)\nstring(1 + 1)\nstring(1 + f64)\nstring(1 - 0.5)\nstring(1 - f32)\nstring(1 - i32)\nstring(1 - i64)\nstring(1 .. 1)\nstring(1 .. i32)\nstring(1 .. i64)\nstring(1 / 0.5)\nstring(1 / f64)\nstring(1 / i)\nstring(1 / i32)\nstring(1 / i64)\nstring(1 < 0.5)\nstring(1 <= 1)\nstring(1 <= f32)\nstring(1 <= i)\nstring(1 <= i32)\nstring(1 <= i64)\nstring(1 == 1)\nstring(1 == f32)\nstring(1 == i32)\nstring(1 > 0.5)\nstring(1 > 1)\nstring(1 > i64)\nstring(1 >= f32)\nstring(1 >= i)\nstring(1 ^ 0.5)\nstring(1 ^ 1)\nstring(1 ^ f32)\nstring(1 ^ f64)\nstring(1 ^ i64)\nstring(1 not in array)\nstring([0.5])\nstring([div])\nstring([f64])\nstring([list])\nstring([score])\nstring([true])\nstring(abs(0.5))\nstring(abs(1))\nstring(abs(f32))\nstring(abs(i))\nstring(abs(i32))\nstring(add != add)\nstring(add != div)\nstring(add == div)\nstring(add == nil)\nstring(add)\nstring(add) in foo ? i64 : i32\nstring(add) not endsWith foo.Bar\nstring(all(array, ok))\nstring(all(array, true))\nstring(any(array, ok))\nstring(any(list, false))\nstring(any(list, ok))\nstring(array != array)\nstring(array != nil)\nstring(array)\nstring(array[i32])\nstring(bitnot(1))\nstring(bitnot(i32))\nstring(bitnot(i64))\nstring(ceil(0.5))\nstring(ceil(1))\nstring(ceil(f32))\nstring(ceil(f64))\nstring(ceil(i))\nstring(ceil(i64))\nstring(div != div)\nstring(div != nil)\nstring(div == add)\nstring(div == div)\nstring(div)\nstring(f32 != 0.5)\nstring(f32 != f64)\nstring(f32 != i)\nstring(f32 != nil)\nstring(f32 * 0.5)\nstring(f32 * 1)\nstring(f32 * f64)\nstring(f32 * i)\nstring(f32 * i32)\nstring(f32 ** 1)\nstring(f32 ** f64)\nstring(f32 + f32)\nstring(f32 + f64)\nstring(f32 + i32)\nstring(f32 + i64)\nstring(f32 - 0.5)\nstring(f32 - 1)\nstring(f32 - i64)\nstring(f32 / 0.5)\nstring(f32 / f64)\nstring(f32 / i64)\nstring(f32 < f32)\nstring(f32 <= i)\nstring(f32 <= i32)\nstring(f32 == 0.5)\nstring(f32 == i)\nstring(f32 > 0.5)\nstring(f32 > f64)\nstring(f32)\nstring(f32) in foo\nstring(f64 != 1)\nstring(f64 != i)\nstring(f64 != nil)\nstring(f64 * 0.5)\nstring(f64 * i)\nstring(f64 * i32)\nstring(f64 * i64)\nstring(f64 ** 0.5)\nstring(f64 ** f64)\nstring(f64 ** i)\nstring(f64 + 0.5)\nstring(f64 + 1)\nstring(f64 + f32)\nstring(f64 - 0.5)\nstring(f64 - 1)\nstring(f64 - i)\nstring(f64 / 0.5)\nstring(f64 < f32)\nstring(f64 < i)\nstring(f64 <= 1)\nstring(f64 <= f32)\nstring(f64 <= f64)\nstring(f64 == 1)\nstring(f64 == f32)\nstring(f64 == i)\nstring(f64 == i64)\nstring(f64 > 1)\nstring(f64 >= f32)\nstring(f64 >= i)\nstring(f64 ^ 0.5)\nstring(f64 ^ f32)\nstring(f64 ^ i)\nstring(f64 in array)\nstring(f64 not in array)\nstring(f64)\nstring(false != nil)\nstring(false != ok)\nstring(false != true)\nstring(false ? array : 0.5)\nstring(false ? f64 : i32)\nstring(false ? false : i)\nstring(false ? greet : f64)\nstring(false ? half : \"bar\")\nstring(false ? half : i)\nstring(false ? i : i)\nstring(false ? nil : nil)\nstring(false and ok)\nstring(false) endsWith toBase64(\"foo\")\nstring(filter(array, false))\nstring(filter(array, ok))\nstring(filter(array, true))\nstring(filter(list, false))\nstring(find(array, ok))\nstring(find(array, true))\nstring(find(list, ok))\nstring(findIndex(array, true))\nstring(findLast(array, false))\nstring(findLast(array, ok))\nstring(findLast(array, true))\nstring(findLastIndex(array, ok))\nstring(first(array))\nstring(first(list))\nstring(float(0.5))\nstring(float(1))\nstring(float(f64))\nstring(float(i))\nstring(float(i64))\nstring(floor(0.5))\nstring(floor(f32))\nstring(floor(f64))\nstring(floor(i))\nstring(floor(i32))\nstring(floor(i64))\nstring(foo == foo)\nstring(foo == nil)\nstring(foo not in list)\nstring(foo)\nstring(foo.Bar)\nstring(foo.Qux)\nstring(foo.String())\nstring(foo.String)\nstring(foo?.Bar)\nstring(foo?.Qux)\nstring(foo?.String())\nstring(foo?.String)\nstring(get(array, i))\nstring(get(array, i64))\nstring(get(list, 1))\nstring(get(list, i32))\nstring(get(list, i64))\nstring(greet != nil)\nstring(greet == greet)\nstring(greet == nil)\nstring(greet(\"bar\"))\nstring(greet(\"foo\"))\nstring(greet)\nstring(greet) == nil ? 0.5 : i\nstring(groupBy(array, #))\nstring(groupBy(array, 1))\nstring(groupBy(array, f32))\nstring(groupBy(array, false))\nstring(groupBy(array, i32))\nstring(groupBy(list, #))\nstring(groupBy(list, 0.5))\nstring(groupBy(list, 1))\nstring(groupBy(list, f64))\nstring(groupBy(list, false))\nstring(groupBy(list, i))\nstring(half != nil)\nstring(half == nil)\nstring(half(0.5))\nstring(half(1))\nstring(half(f64))\nstring(half)\nstring(i != 1)\nstring(i != i64)\nstring(i % 1)\nstring(i % i32)\nstring(i % i64)\nstring(i * 1)\nstring(i * f64)\nstring(i ** f32)\nstring(i ** f64)\nstring(i ** i64)\nstring(i + 0.5)\nstring(i + i)\nstring(i - f32)\nstring(i .. 1)\nstring(i .. i)\nstring(i .. i32)\nstring(i / 1)\nstring(i / f32)\nstring(i / f64)\nstring(i / i32)\nstring(i / i64)\nstring(i < 0.5)\nstring(i < 1)\nstring(i < i32)\nstring(i <= f32)\nstring(i <= i)\nstring(i == 1)\nstring(i == i)\nstring(i > 0.5)\nstring(i > 1)\nstring(i > f32)\nstring(i >= 0.5)\nstring(i >= i64)\nstring(i ^ 1)\nstring(i ^ f32)\nstring(i ^ i)\nstring(i ^ i64)\nstring(i)\nstring(i) in foo\nstring(i32 != 0.5)\nstring(i32 != 1)\nstring(i32 != f64)\nstring(i32 != i32)\nstring(i32 != nil)\nstring(i32 % 1)\nstring(i32 % i)\nstring(i32 % i64)\nstring(i32 * 1)\nstring(i32 * f32)\nstring(i32 * f64)\nstring(i32 * i)\nstring(i32 ** 0.5)\nstring(i32 ** f64)\nstring(i32 + 0.5)\nstring(i32 - 0.5)\nstring(i32 - 1)\nstring(i32 - f32)\nstring(i32 - f64)\nstring(i32 - i32)\nstring(i32 - i64)\nstring(i32 .. 1)\nstring(i32 .. i)\nstring(i32 / 0.5)\nstring(i32 < 1)\nstring(i32 < f64)\nstring(i32 < i64)\n```\n\n----------------------------------------\n\nTITLE: String Slicing and Advanced Operations\nDESCRIPTION: This snippet examines string slicing and its combinations with other functions and operators. It tests slicing with dynamic indices, and integrates it with function calls like greet.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_222\n\nLANGUAGE: Expr\nCODE:\n```\nstr[$env?.i:]\nstr[1:] endsWith str\nstr[1:] not contains str\nstr[1:] | greet()\nstr[:$env.i]\nstr[:$env?.i]\nstr[:]\nstr[:array | reduce(#)]\nstr[:array?.[i]]\nstr[:i]\nstr[:median(1, 1.0)]\nstr[:min(0)]\nstr[first(array):]\nstr[i:]\nstr[i:] not endsWith str\nstr[i:i]\n```\n\n----------------------------------------\n\nTITLE: Mapping Operations with Different Types in Expr\nDESCRIPTION: This code snippet demonstrates the usage of the `map` function in the Expr language. It shows how to apply various operations to elements within a list, including arithmetic operations, comparisons, and function calls, using different data types such as integers, floats, and strings.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_79\n\nLANGUAGE: Expr\nCODE:\n```\nmap(groupBy(list, i32).i, #)\nmap(i .. 1, -#)\nmap(i .. 1, 0.5 ^ #)\nmap(i .. 1, f32)\nmap(i .. 1, i)\nmap(i .. i, add(#, #))\nmap(i .. i, div)\nmap(i .. i, i32)\nmap(i .. i32, half)\nmap(i .. i64, min(#, #, #))\nmap(i32 .. 1, half)\nmap(i32 .. i, f32)\nmap(i32 .. i32, array)\nmap(i32 .. i64, div)\nmap(i32 .. i64, list)\nmap(i64 .. 1, #)\nmap(i64 .. 1, 1 ^ #)\nmap(i64 .. 1, array)\nmap(i64 .. 1, f32)\nmap(i64 .. 1, f64)\nmap(i64 .. i32, #)\nmap(i64 .. i64, # - #)\nmap(i64 .. i64, #)\nmap(list, !false)\nmap(list, !ok)\nmap(list, \"bar\" not matches \"foo\")\nmap(list, \"bar\") != list\nmap(list, \"bar\")[i64]\nmap(list, \"foo\" not in foo)\nmap(list, \"foo\" not matches #.Bar)\nmap(list, # != #)\nmap(list, # != nil)\nmap(list, # == #)\nmap(list, # in list)\nmap(list, #)\nmap(list, #) != array\nmap(list, #) == list\nmap(list, #)[i64]\nmap(list, #)[i]\nmap(list, #?.Bar)\nmap(list, #?.Qux)\nmap(list, #?.String())\nmap(list, #?.String)\nmap(list, -0.5)\nmap(list, -f32)\nmap(list, -i)\nmap(list, -i32)\nmap(list, .Bar)\nmap(list, .Qux)\nmap(list, .String())\nmap(list, .String)\nmap(list, 0.5 != 0.5)\nmap(list, 0.5 != i64)\nmap(list, 0.5 + i64)\nmap(list, 0.5 - 0.5)\nmap(list, 0.5 <= 0.5)\nmap(list, 0.5 == i32)\nmap(list, 0.5 in array)\nmap(list, 0.5) != array\nmap(list, 0.5) == array\nmap(list, 1 % i)\nmap(list, 1 ** 0.5)\nmap(list, 1 ** f32)\nmap(list, 1 + 1)\nmap(list, 1 / f64)\nmap(list, 1 / i64)\nmap(list, 1 < 0.5)\nmap(list, 1 <= i32)\nmap(list, 1 ^ i32)\nmap(list, [#])\nmap(list, [foo, 0.5, #])\nmap(list, [score])\nmap(list, abs(f32))\nmap(list, add)\nmap(list, array)\nmap(list, ceil(0.5))\nmap(list, count(array, true))\nmap(list, div)\nmap(list, f32 != i32)\nmap(list, f32 ** 1)\nmap(list, f32 + i64)\nmap(list, f32 < f32)\nmap(list, f32 == 0.5)\nmap(list, f32 > i64)\nmap(list, f32 >= i)\nmap(list, f32 >= i32)\nmap(list, f32 ^ i)\nmap(list, f32)\nmap(list, f64 < 0.5)\nmap(list, f64 < f32)\nmap(list, f64 <= 1)\nmap(list, f64 > 1)\nmap(list, f64 >= 0.5)\nmap(list, f64 >= f32)\nmap(list, f64)\nmap(list, f64)[i]\nmap(list, false ? # : list)\nmap(list, false) != array\nmap(list, float(f64))\nmap(list, float(i))\nmap(list, float(i32))\nmap(list, foo == #)\nmap(list, foo)\nmap(list, foo.Qux)\nmap(list, foo.String())\nmap(list, foo?.String)\nmap(list, greet)\nmap(list, groupBy(array, #))\nmap(list, groupBy(array, i))\nmap(list, groupBy(list, #))\nmap(list, half(0.5))\nmap(list, half(f64))\nmap(list, half)\nmap(list, i ** 1)\nmap(list, i + i64)\nmap(list, i .. i)\nmap(list, i < 0.5)\nmap(list, i == 1)\nmap(list, i)\nmap(list, i)[i64]\nmap(list, i32 % i64)\nmap(list, i32 ** 0.5)\nmap(list, i32 + f32)\nmap(list, i32 - i32)\nmap(list, i32 / f64)\nmap(list, i32 < 1)\nmap(list, i32 < i32)\nmap(list, i32 <= 1)\nmap(list, i32 >= 1)\nmap(list, i32)\nmap(list, i64 * i)\nmap(list, i64 + i64)\nmap(list, i64 <= i64)\nmap(list, i64 == nil)\nmap(list, i64)\nmap(list, i64)[i64]\nmap(list, i64)[i]\nmap(list, last(array))\nmap(list, list)\nmap(list, list)[i]\nmap(list, map(array, #))\nmap(list, map(array, 1))\nmap(list, map(array, div))\nmap(list, map(array, i64))\nmap(list, map(list, \"foo\"))\nmap(list, max(f32))\nmap(list, min(0.5))\nmap(list, min(f64))\nmap(list, nil != #)\nmap(list, nil != i64)\nmap(list, nil == #)\nmap(list, nil == ok)\nmap(list, nil not in list)\nmap(list, none(array, true))\nmap(list, not ok)\nmap(list, ok ? # : #)\nmap(list, ok || ok)\nmap(list, ok)\nmap(list, reduce(array, half))\nmap(list, reduce(list, foo))\nmap(list, reduce(list, half))\nmap(list, score(1))\nmap(list, score)\nmap(list, score)[i64]\nmap(list, string(#))\nmap(list, string(1))\nmap(list, string(add))\nmap(list, string(i32))\nmap(list, toJSON(#))\nmap(list, toJSON([#]))\nmap(list, toJSON(false))\nmap(list, toJSON(ok))\nmap(list, true ? i : f32)\nmap(list, true ? i32 : #)\nmap(list, true ? list : div)\nmap(list, true)[i32]\nmap(list, type(\"bar\"))\nmap(list, type(#))\nmap(list, type(i32))\nmap(list, type(true))\nmap(list[i64:i32], greet)\nmap(map(array, #), # - i32)\nmap(map(array, #), # == #)\nmap(map(array, #), # >= #)\nmap(map(array, #), #)\nmap(map(array, #), add)\nmap(map(array, #), bitand(#, #))\nmap(map(array, #), foo)\nmap(map(array, #), greet)\nmap(map(array, #), half)\nmap(map(array, #), i % i64)\nmap(map(array, #), i)\nmap(map(array, #), i32)\nmap(map(array, #), i64)\nmap(map(array, #), list)\nmap(map(array, 0.5), #)\nmap(map(array, 0.5), ok)\nmap(map(array, 1), greet)\nmap(map(array, array), i32 ^ i32)\nmap(map(array, array), i64)\nmap(map(array, array), reduce(#, array))\nmap(map(array, div), i)\nmap(map(array, div), list)\nmap(map(array, f32), #)\nmap(map(array, f32), array)\nmap(map(array, f32), f64)\nmap(map(array, f64), # > #)\nmap(map(array, f64), f64)\nmap(map(array, f64), greet)\nmap(map(array, foo), div)\nmap(map(array, greet), foo)\nmap(map(array, greet), list)\nmap(map(array, half), array)\nmap(map(array, i), #)\nmap(map(array, i32), #)\nmap(map(array, i64), array)\nmap(map(array, i64), f64)\nmap(map(array, list), foo)\nmap(map(array, ok), !#)\nmap(map(array, ok), -f32)\nmap(map(array, true), # != nil)\nmap(map(array, true), i64)\nmap(map(list, #), # != #)\nmap(map(list, #), #)\nmap(map(list, #), #?.Qux)\nmap(map(list, #), .Bar)\nmap(map(list, #), div)\nmap(map(list, #), f32)\nmap(map(list, #), f64)\nmap(map(list, #), greet)\nmap(map(list, #), half)\nmap(map(list, #), list)\nmap(map(list, #), ok)\nmap(map(list, #), score)\nmap(map(list, 0.5), #)\nmap(map(list, 0.5), div)\nmap(map(list, 1), # * #)\nmap(map(list, 1), f32)\nmap(map(list, add), #)\nmap(map(list, add), i)\nmap(map(list, array), f64)\nmap(map(list, array), findIndex(#, ok))\nmap(map(list, f64), f32)\nmap(map(list, f64), i32)\nmap(map(list, false), 0.5 / f64)\nmap(map(list, foo), #)\nmap(map(list, foo), list)\nmap(map(list, greet), \"bar\" <= \"foo\")\nmap(map(list, i64), # >= f64)\nmap(map(list, i64), #)\nmap(map(list, i64), i64)\nmap(map(list, list), #)\nmap(map(list, ok), f64 > i64)\nmap(map(list, ok), foo)\nmap(map(list, true), f64)\nmap(map(list, true), list)\nmap(ok ? \"bar\" : i64, ok)\nmap(ok ? \"bar\" : ok, i64)\nmap(ok ? \"bar\" : score, 1 .. #)\nmap(ok ? array : foo, foo)\nmap(ok ? array : i64, list)\nmap(ok ? list : i64, #)\nmap(ok ? list : list, add)\nmap(reduce(array, array), # <= #)\nmap(reduce(array, array), #)\nmap(reduce(list, array), -i32)\nmap(reduce(list, array), foo)\nmap(reduce(list, array), half)\nmap(reduce(list, list), #)\nmap(sort(array), # / 0.5)\nmap(sort(array), #)\nmap(sort(array), greet)\nmap(split(\"foo\", \"bar\"), #)\nmap(true ? \"foo\" : 0.5, # * #)\nmap(true ? array : \"foo\", f32 + #)\nmap(true ? list : greet, greet)\nmap(true ? list : list, #)\n```\n\n----------------------------------------\n\nTITLE: String Conversion with 'groupBy' function\nDESCRIPTION: This snippet tests the string conversion with 'groupBy' function by using the optional properties of `groupBy` function\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_235\n\nLANGUAGE: Expr\nCODE:\n```\nstring(groupBy(list, ok)?.greet)\nstring(groupBy(list, str))\n```\n\n----------------------------------------\n\nTITLE: Testing 'div' Function and Comparisons in Expr\nDESCRIPTION: This snippet focuses on the 'div' function and tests its interaction with various comparison operators, conditional expressions, and functions like 'reduce'. It aims to ensure correct evaluation and type handling in different scenarios.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_34\n\nLANGUAGE: Expr\nCODE:\n```\ndiv\ndiv != add\ndiv != add != nil\ndiv != add == ok\ndiv != div\ndiv != div != ok\ndiv != div && ok\ndiv != div ? \"bar\" : \"foo\"\ndiv != nil == ok\ndiv != nil || f32 < 0.5\ndiv != reduce(array, div)\ndiv == add\ndiv == add ? 1 : ok\ndiv == div\ndiv == nil ? f32 : half\ndiv == nil ? false : 1\ndiv(-i, array[i64])\ndiv(-i, i)\ndiv(1, i) + i\ndiv(findLast(array, true), i)\ndiv(i, -1)\ndiv(i, i)\ndiv(last(array), 1 * i32)\ndiv(score(1), bitnot(1))\n```\n\n----------------------------------------\n\nTITLE: Using findLast Function in Expr\nDESCRIPTION: This snippet demonstrates the usage of the `findLast` function in the Expr language. It includes examples with different data types, conditional expressions, property access, and chained operations. It attempts to find the last element in a collection that satisfies a given condition.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_96\n\nLANGUAGE: Expr\nCODE:\n```\nfindLast($env, false)?.f64?.[str]\nfindLast($env, false)?.foo\nfindLast($env, false)?.greet()\nfindLast($env, false)?.i\nfindLast($env, false)?.i()\nfindLast($env, false)?.list()\nfindLast($env, false)?.ok\nfindLast($env, false)?.ok()\nfindLast($env, false)?.str\nfindLast($env.array, # >= #)\nfindLast($env.array, str in $env)\nfindLast($env.list, ok)\nfindLast($env?.[str], # not in array)\nfindLast($env?.[str], false == #)\nfindLast($env?.array, $env.ok)\nfindLast($env?.array, i in array)\nfindLast($env?.array, ok)\nfindLast($env?.list, ok)\nfindLast([$env], $env != nil).array\nfindLast([1.0], ok)\nfindLast([false], $env | none(true))\nfindLast([ok], ok)\nfindLast([true], ok)\nfindLast(array | map(#index), ok)\nfindLast(array, # < f64)\nfindLast(array, # <= #)\nfindLast(array, # > 1.0)\nfindLast(array, $env?.ok)\nfindLast(array, 1 != #)\nfindLast(array, 1 < 1)\nfindLast(array, 1.0 >= 1.0)\nfindLast(array, f64 < 0)\nfindLast(array, f64 < f64)\nfindLast(array, f64 > #)\nfindLast(array, f64 >= 1.0)\nfindLast(array, f64 >= i)\nfindLast(array, false || true)\nfindLast(array, nil != #)\nfindLast(array, nil != nil)\nfindLast(array, ok ?: 1.0)\nfindLast(array, ok)\nfindLast(array, ok) >= f64\nfindLast(array, ok) in array\nfindLast(array, str not in foo)\nfindLast(filter(list, false), $env?.[array])\nfindLast(keys($env), foo == foo)\nfindLast(list | sortBy(0), # == #)\nfindLast(list, # == foo)\nfindLast(list, #.Bar in #)\nfindLast(list, #.String != nil)\nfindLast(list, $env != true)\nfindLast(list, $env == false)\nfindLast(list, $env == foo.String())\nfindLast(list, $env or true)\nfindLast(list, $env.ok)\nfindLast(list, 0 != 1.0)\nfindLast(list, 1 >= 1.0)\nfindLast(list, 1.0 <= f64)\nfindLast(list, 1.0 == 1)\nfindLast(list, 1.0 >= 1.0)\nfindLast(list, f64 == f64)\nfindLast(list, false)?.Bar\nfindLast(list, foo == #)\nfindLast(list, i > 0)\nfindLast(list, nil == #)\nfindLast(list, nil == greet)\nfindLast(list, ok)\nfindLast(list, ok).Bar\nfindLast(list, ok).String()\nfindLast(list, true && false)\nfindLast(list, true).String\nfindLast(list, true)?.Bar\nfindLast(min($env), .array and false)\nfindLast(sort($env), .array)\nfindLast(sort($env), .f64 != #.i)\nfindLast(sort($env), .list?.list)\nfindLast(sort($env), 1.0 != #.list)\n```\n\n----------------------------------------\n\nTITLE: Expr: Boolean comparisons and logical operations\nDESCRIPTION: This snippet showcases various boolean comparisons and logical operations using the Expr language.  It demonstrates how to use equality, inequality, AND, OR, and NOT operators with different data types, including booleans, numbers, strings, and nil.  It explores optional chaining with the ?. operator.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_247\n\nLANGUAGE: Expr\nCODE:\n```\ntrue != $env || $env >= 1.0\ntrue != $env.ok\ntrue != $env?.Bar\ntrue != $env?.String\ntrue != $env?.String?.String\ntrue != $env?.[Bar]\ntrue != $env?.[String]\ntrue != $env?.[String]?.Bar\ntrue != $env?.[foobar?.[greet]]\ntrue != $env?.[foobar]\ntrue != $env?.[str]\ntrue != $env?.ok\ntrue != false == ok\ntrue != nil and ok\ntrue != true ?: foo\ntrue && $env != list\ntrue && $env == list?.[i]\ntrue && $env == str\ntrue && $env.ok\ntrue && $env?.Bar\ntrue && $env?.String\ntrue && $env?.[Bar]\ntrue && $env?.[Bar]?.str\ntrue && $env?.[String]\ntrue && $env?.[foobar]\ntrue && $env?.[str]\ntrue && $env?.foobar\ntrue && $env?.ok\ntrue && 0 * i < 1\ntrue && 1.0 == f64\ntrue && 1.0 >= f64\ntrue && false && ok\ntrue && greet == greet\ntrue && nil == ok\ntrue && nil == str\ntrue && ok ?: str\ntrue && str startsWith $env?.String\ntrue == $env == ok\ntrue == $env || $env != ok\ntrue == $env || 1.0 >= f64\ntrue == $env.ok\ntrue == $env?.Bar\ntrue == $env?.String\ntrue == $env?.[Bar]\ntrue == $env?.[String]\ntrue == $env?.[foobar]\ntrue == $env?.[str]\ntrue == $env?.ok\ntrue == nil == ok\ntrue == ok && ok\n\n```\n\n----------------------------------------\n\nTITLE: Using `last` Function with Object Literals in Expr\nDESCRIPTION: This snippet shows various ways to use the `last` function with object literals. It demonstrates accessing potentially null properties and array values using optional chaining `?.`.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_167\n\nLANGUAGE: Expr\nCODE:\n```\nlast({foo: $env}?.foobar?.add)\nlast({foo: f64, foo: str}.foo)\nlast({foo: foo, foo: 1}?.[str])\nlast({foo: foo}.greet)\n```\n\n----------------------------------------\n\nTITLE: Group Array Elements Using groupBy() in Expr\nDESCRIPTION: The `groupBy()` function groups the elements of an array based on the result of applying a given predicate to each element. It returns a map where the keys are the results of the predicate and the values are arrays of elements that produced that result.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_60\n\nLANGUAGE: expr\nCODE:\n```\ngroupBy(users, .Age)\n```\n\n----------------------------------------\n\nTITLE: Array Filter\nDESCRIPTION: Filters elements from the array based on the condition that they are less than 1.0. Requires numeric elements. Returns a new array containing only elements that satisfy the filter condition.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_48\n\nLANGUAGE: Expr\nCODE:\n```\narray | filter(# < 1.0)\n```\n\n----------------------------------------\n\nTITLE: Membership Operations in Expr\nDESCRIPTION: These snippets illustrate the use of 'in' and 'not in' operators to check for membership within arrays, with environment variables or literals in the Expr language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_275\n\nLANGUAGE: Expr\nCODE:\n```\n{foo: 0 in array}\n{foo: 1 in array}\n{foo: 1 not in $env?.array}\n{foo: 1.0 in array}\n{foo: 1.0 not in array}\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Operations with Integer and Float Literals\nDESCRIPTION: Demonstrates basic arithmetic operations such as addition, subtraction, multiplication, division, exponentiation, and modulo with integer and floating-point literals.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_11\n\nLANGUAGE: EXPR\nCODE:\n```\n1 + 1 % i\n1 + 1.0 != i\n1 + 1.0 - i\n1 + 1.0 < f64\n1 + 1.0 ^ i\n1 + f64 ^ i ** 1\n1 - i / f64\n1 - i ^ i\n1 / 1 * f64\n1 / 1 ^ i\n1 / 1.0 ** i\n1 < 0 ^ i ** 1.0\n1 ^ 0 ** i\n1 ^ 1 > f64\n1 ^ 1 * i\n1 ^ 1 == i\n1.0 * 0 >= i\n1.0 * 1.0 <= f64\n1.0 * 1.0 > f64\n1.0 * 1.0 > i\n1.0 ** 0 / i\n1.0 ** 0 < i\n1.0 ** 0 == i\n1.0 ** 0 > i\n1.0 ** 1.0 != i\n1.0 ** 1.0 * i\n1.0 ** 1.0 < 0 != false\n1.0 + 0 != i\n1.0 + 0 + f64\n1.0 + 1.0 <= i\n1.0 + 1.0 ^ f64\n1.0 + 1.0 ^ i\n1.0 - 0 != f64\n1.0 - 1 + 1.0 == nil\n1.0 - 1 - i\n1.0 - 1 / i\n1.0 - 1.0 ** f64\n1.0 - 1.0 + f64\n1.0 - 1.0 < f64\n1.0 - 1.0 == i\n1.0 - 1.0 > f64\n1.0 - 1.0 >= f64\n1.0 / 0 != i\n1.0 / 0 * $env?.f64\n1.0 / 0 <= 1 + f64\n1.0 / 0 == i\n1.0 / 0 > $env?.f64\n1.0 / 1 * f64\n1.0 / 1 ** i\n1.0 / 1.0 + i\n1.0 / 1.0 - f64\n1.0 / 1.0 == i\n1.0 / 1.0 >= f64\n1.0 < 0 <= $env?.[str]\n1.0 < 1.0 ** f64\n1.0 < 1.0 / round(1.0)\n1.0 < 1.0 <= $env?.String\n1.0 < 1.0 ^ f64\n1.0 <= 0 % i\n1.0 <= 0 / f64\n1.0 <= 0 < f64 <= f64\n1.0 <= 0 >= i\n1.0 <= 1 ** i\n1.0 <= 1 / $env?.i\n1.0 <= 1 / i\n1.0 <= 1.0 ** 1 and false\n1.0 <= 1.0 - f64\n1.0 <= 1.0 < f64\n1.0 <= 1.0 >= f64\n1.0 == 1 != ok\n1.0 == 1 % i\n1.0 == 1 - f64\n1.0 == 1 - i\n1.0 == 1.0 != ok\n1.0 == 1.0 * f64\n1.0 == 1.0 - i\n1.0 == 1.0 / f64\n1.0 == 1.0 and ok\n1.0 > 0 / i\n1.0 > 0 < f64\n1.0 > 0 < i\n1.0 > 1.0 * array?.[i]\n1.0 > f64 * f64\n1.0 > f64 + f64\n1.0 > f64 / i\n1.0 > f64 < f64\n1.0 >= 0 / i\n1.0 >= 1 > i\n1.0 >= 1 > i >= i\n1.0 >= 1.0 * f64 or ok\n1.0 >= 1.0 + f64\n1.0 >= 1.0 / i\n1.0 >= f64 ** $env?.i\n1.0 >= f64 ** 0 > 1.0\n1.0 >= f64 / i\n1.0 >= i * f64\n1.0 >= i * i\n1.0 >= i + 1.0 >= $env\n1.0 >= i - i\n1.0 ^ 0 - i\n1.0 ^ 0 ^ f64\n1.0 ^ 1 * i\n1.0 ^ 1 == i\n1.0 ^ 1 >= 1 || false\n1.0 ^ 1.0 + 1.0 in array\n1.0 ^ 1.0 == $env?.i\n1.0 ^ 1.0 > i\n1.0 ^ 1.0 >= f64\n1.0 ^ f64 * i\n1.0 ^ i * i\n1.0 ^ i < f64 < 1.0\n1.0 ^ i > i\n```\n\n----------------------------------------\n\nTITLE: Boolean Operations\nDESCRIPTION: Demonstrates the usage of boolean operators such as `!=`, `&&`, `==`, `? :`, `and`, `or`, and `||` with different operands, including boolean literals, variables (`$env`), and nil values. The purpose is to verify the correct evaluation of boolean expressions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_23\n\nLANGUAGE: Expr\nCODE:\n```\n[true != false]\n[true != nil]\n[true && $env, list]\n[true && $env]\n[true && false, array]\n[true == $env]\n[true == nil]\n[true ? $env : 1.0]\n[true ?: 1]\n[true ?: array]\n[true ?: list]\n[true and $env]\n[true and true]\n[true or true]\n[true || $env]\n[true || true]\n```\n\n----------------------------------------\n\nTITLE: String Conversion of Environment Variables and Fields\nDESCRIPTION: This snippet tests string conversion specifically focused on environment variables, object properties, and optional chaining. It validates how Expr handles nested environment variable access and string conversions in these contexts.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_224\n\nLANGUAGE: Expr\nCODE:\n```\nstring($env)\nstring($env) matches str\nstring($env) not startsWith str\nstring($env) | greet()\nstring($env)[i:]\nstring($env.add)\nstring($env.array)\nstring($env.f64)\nstring($env.foo)\nstring($env.greet)\nstring($env.i)\nstring($env.list)\nstring($env.ok)\nstring($env.str)\nstring($env?.$env)\nstring($env?.Bar)\nstring($env?.Bar?.[str])\nstring($env?.String)\nstring($env?.String?.Bar)\nstring($env?.String?.String)\nstring($env?.[Bar])\nstring($env?.[Bar]?.[i])\nstring($env?.[String])\nstring($env?.[foobar])\nstring($env?.[str])\nstring($env?.add)\nstring($env?.array)\nstring($env?.f64)\nstring($env?.false)\nstring($env?.foo)\nstring($env?.foobar)\nstring($env?.greet)\nstring($env?.i)\nstring($env?.list)\nstring($env?.ok)\nstring($env?.str)\n```\n\n----------------------------------------\n\nTITLE: Expr: Type Checks with various values and operations\nDESCRIPTION: This snippet provides a variety of type checks using literals (numbers), variables and function calls, combined with operations such as range, slice and more.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_260\n\nLANGUAGE: Expr\nCODE:\n```\ntype(0) != str\ntype(0) in foo\ntype(0) not startsWith str\ntype(0)[i:]\ntype(0..i)\ntype(1 != $env)\ntype(1 != f64)\ntype(1 != nil)\ntype(1 % 1)\ntype(1 * 0)\ntype(1 * 1.0)\ntype(1 * f64)\ntype(1 * i)\ntype(1 ** 1.0)\ntype(1 ** f64)\ntype(1 + 0)\ntype(1 + 1)\ntype(1 + 1.0)\ntype(1 .. 0)\ntype(1 / 1)\ntype(1 / i)\ntype(1 <= 0)\ntype(1 <= 1)\ntype(1 <= 1.0)\ntype(1 <= i)\ntype(1 == i)\ntype(1 == nil)\ntype(1 > 0)\ntype(1 > 1)\ntype(1 > 1.0)\ntype(1 > f64)\ntype(1 >= 0)\ntype(1 >= 1.0)\ntype(1 >= i)\ntype(1 ^ 0)\ntype(1 ^ 1)\ntype(1 ^ 1.0)\ntype(1 in array)\ntype(1 not in array)\ntype(1) not in foo\ntype(1) startsWith reduce(list, #.Bar)\ntype(1) | greet()\n\n```\n\n----------------------------------------\n\nTITLE: Expr Example: Array Access with Type Casting\nDESCRIPTION: This expression explicitly casts an element of an array to an integer. This is necessary when `WarnOnAny` is enabled to avoid type checking errors due to the `any` type.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/configuration.md#_snippet_6\n\nLANGUAGE: expr\nCODE:\n```\nlet arr = [1, 2, 3]; int(arr[0])\n```\n\n----------------------------------------\n\nTITLE: Using floor function in Expr\nDESCRIPTION: This snippet illustrates the application of the `floor` function in the Expr language to different values and expressions. It includes mathematical operations, conditional evaluations, and environment variable lookups. The floor function returns the largest integer less than or equal to the given value.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_102\n\nLANGUAGE: Expr\nCODE:\n```\nfloor($env | findIndex(ok))\nfloor($env.f64)\nfloor($env.i)\nfloor($env?.f64)\nfloor($env?.i)\nfloor(0 % i)\nfloor(0 * 1)\nfloor(0 * 1.0)\nfloor(0 * i)\nfloor(0 + 1.0)\nfloor(0 + f64)\nfloor(0 - 0)\nfloor(0 - 1)\nfloor(0 - 1.0)\nfloor(0 - i)\nfloor(0 / 1)\nfloor(0 / f64)\nfloor(0 ^ 0)\nfloor(0 ^ 1.0)\nfloor(0 | min(1.0))\nfloor(0) * i\nfloor(0) <= f64\nfloor(1 * 1)\nfloor(1 * 1.0)\nfloor(1 * f64)\nfloor(1 * i)\nfloor(1 ** 0)\nfloor(1 ** 1)\nfloor(1 ** i)\nfloor(1 + 1.0)\nfloor(1 + i)\nfloor(1 - i)\nfloor(1 / 0)\nfloor(1 / 1.0)\nfloor(1 / f64)\nfloor(1 ^ 0)\nfloor(1 ^ 1.0)\nfloor(1 ^ f64)\nfloor(1 ^ i)\nfloor(1) != f64\nfloor(1) * f64\nfloor(1) + $env?.f64\nfloor(1) <= i\nfloor(1) in array\nfloor(1.0 * 1)\nfloor(1.0 * 1.0)\nfloor(1.0 * f64)\nfloor(1.0 ** 1)\nfloor(1.0 ** 1.0)\nfloor(1.0 ** f64)\nfloor(1.0 ** i)\nfloor(1.0 + 1)\nfloor(1.0 + 1.0)\nfloor(1.0 + f64)\nfloor(1.0 - 0)\nfloor(1.0 - 1.0)\nfloor(1.0 - f64)\nfloor(1.0 - i)\nfloor(1.0 / 0)\nfloor(1.0 / 1.0)\nfloor(1.0 / f64)\nfloor(1.0 ^ 0)\nfloor(1.0 ^ 1.0)\nfloor(1.0 ^ i)\nfloor(1.0 | max(f64))\nfloor(1.0 | mean(array))\nfloor(1.0) != $env?.f64\nfloor(1.0) + f64\nfloor(1.0) - $env.i\nfloor(1.0) == f64\nfloor(1.0) > i\nfloor(1.0) | median(0)\nfloor(abs(0))\nfloor(abs(1))\nfloor(abs(1.0))\nfloor(abs(f64))\nfloor(abs(i))\nfloor(add(i, i))\nfloor(array | findLast(ok))\nfloor(array | mean(1))\nfloor(array | mean(f64))\nfloor(array | reduce(#))\nfloor(array | sum(f64))\nfloor(array?.[i])\nfloor(bitnot(0))\nfloor(bitnot(1))\nfloor(ceil(1))\nfloor(ceil(1.0))\nfloor(ceil(i))\nfloor(count($env, true))\nfloor(count(list, ok))\nfloor(f64 * 1.0)\nfloor(f64 ** 1.0)\nfloor(f64 ** i)\nfloor(f64 + 0)\nfloor(f64 + 1.0)\nfloor(f64 - 1)\nfloor(f64 - 1.0)\nfloor(f64 - i)\nfloor(f64 / f64)\nfloor(f64 ^ 1.0)\nfloor(f64 ^ i)\nfloor(f64)\nfloor(f64) < f64\nfloor(f64) >= f64\nfloor(f64) >= i ^ f64\nfloor(f64) in array\nfloor(false ?: 1)\nfloor(findIndex($env, ok))\nfloor(findIndex(list, true))\nfloor(findLast(array, ok))\nfloor(findLastIndex(array, true))\nfloor(first(array))\nfloor(float(0))\nfloor(float(1))\nfloor(float(1.0))\nfloor(float(f64))\nfloor(floor(0))\nfloor(floor(1))\nfloor(floor(1.0))\nfloor(i * 1.0)\nfloor(i * i)\nfloor(i ** 1)\nfloor(i ** 1.0)\nfloor(i ** i)\nfloor(i + 1.0)\nfloor(i + i)\nfloor(i - f64)\nfloor(i / 0)\nfloor(i / 1)\nfloor(i / 1.0)\nfloor(i / f64)\nfloor(i ^ 0)\nfloor(i ^ 1.0)\nfloor(i ^ i)\nfloor(i | min(0))\nfloor(i)\nfloor(i) ** 1.0 >= 1.0\nfloor(i) ** i\nfloor(i) - f64\nfloor(i) / sum(array)\nfloor(i) == $env != ok\nfloor(i) == i\nfloor(i) ^ f64\nfloor(i) | max(1.0)\nfloor(if ok { i } else { $env })\nfloor(int(0))\nfloor(int(1))\nfloor(int(1.0))\nfloor(int(f64))\nfloor(int(i))\nfloor(last(array))\nfloor(len($env))\nfloor(len(array))\nfloor(len(list))\nfloor(len(str))\nfloor(let foobar = 1.0; foobar)\nfloor(list | sum(1))\nfloor(max(0))\nfloor(max(1))\nfloor(max(1.0))\nfloor(max(f64))\nfloor(max(i))\nfloor(mean(0))\nfloor(mean(0, 1.0))\nfloor(mean(1))\nfloor(mean(1.0))\nfloor(mean(array))\nfloor(mean(f64))\nfloor(mean(i))\nfloor(median(0))\nfloor(median(1))\nfloor(median(1.0))\nfloor(median(array))\nfloor(median(f64))\nfloor(median(i))\nfloor(min(1))\nfloor(min(1.0))\nfloor(min(1.0, 0))\nfloor(min(array))\nfloor(min(i))\nfloor(ok ? 1.0 : nil)\nfloor(ok ? i : greet)\nfloor(reduce(array, #))\nfloor(reduce(array, 1))\nfloor(round(1))\nfloor(round(1.0))\nfloor(round(f64))\nfloor(sum($env, 1.0))\nfloor(sum(array))\nfloor(sum(array, #))\nfloor(sum(array, 1.0))\nfloor(sum(list, 1.0))\n```\n\n----------------------------------------\n\nTITLE: Expr: Complex Type Checks with optional chaining\nDESCRIPTION: This snippet demonstrates the use of the type() function in conjunction with optional chaining and other operations like function calls and conditional access.  It shows how to check the type of complex expressions with optional members.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_258\n\nLANGUAGE: Expr\nCODE:\n```\ntype($env) != foo?.Bar\ntype($env) not contains toJSON(true)\ntype($env) not in foo\ntype($env) not matches str\ntype($env) | greet()\ntype($env.add)\ntype($env.array)\ntype($env.f64)\ntype($env.foo)\ntype($env.greet)\ntype($env.i)\ntype($env.list)\ntype($env.ok)\ntype($env.str)\ntype($env?.$env)\ntype($env?.Bar)\ntype($env?.String)\ntype($env?.String?.add)\ntype($env?.[Bar])\ntype($env?.[Bar]) | trimPrefix(str)\ntype($env?.[String])\ntype($env?.[String]?.[i])\ntype($env?.[String]?.i)\ntype($env?.[foobar])\ntype($env?.[nil])\ntype($env?.[str])\ntype($env?.add)\ntype($env?.add) | greet()\ntype($env?.array)\ntype($env?.f64)\ntype($env?.foo)\ntype($env?.foobar)\ntype($env?.greet)\ntype($env?.i)\ntype($env?.list)\ntype($env?.nil)\ntype($env?.ok)\ntype($env?.str)\ntype($env?.true)\n\n```\n\n----------------------------------------\n\nTITLE: Expr groupBy with dot notation properties\nDESCRIPTION: Illustrates grouping based on simple dot notation and chaining, with optional safe navigation.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_139\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(list, .Bar)\ngroupBy(list, .Bar).String\ngroupBy(list, .Bar).add\ngroupBy(list, .Bar).greet\ngroupBy(list, .Bar)?.Bar\ngroupBy(list, .Bar)?.[f64]\ngroupBy(list, .Bar)?.[foo]\ngroupBy(list, .Bar)?.[ok]\ngroupBy(list, .Bar)?.f64\ngroupBy(list, .Bar)?.greet\ngroupBy(list, .Bar)?.i\n```\n\n----------------------------------------\n\nTITLE: Array Find Last Index\nDESCRIPTION: Finds the index of the last element that is not equal to the environment variable. Requires the proper data type. Returns the index or -1 if not found\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_52\n\nLANGUAGE: Expr\nCODE:\n```\narray | findLastIndex(# != $env)\n```\n\n----------------------------------------\n\nTITLE: Logical NOT with Numeric Comparisons (Expr)\nDESCRIPTION: This code snippet evaluates the logical NOT operator (!) with various numeric comparison expressions involving integers (i64, i32, i), floating-point numbers (f64, f32) and the comparison operators such as <, >, <=, >=, !=, ==. This covers several type combinations to test the type coercion rules and comparison logic.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_1\n\nLANGUAGE: Expr\nCODE:\n```\n!!(1 <= f64)\n!!(1 > 0.5)\n!!(i64 != f64)\n!(0.5 != 0.5)\n!(0.5 != 1)\n!(0.5 != f32)\n!(0.5 != f64)\n!(0.5 != i)\n!(0.5 != i32)\n!(0.5 != i64)\n!(0.5 != nil)\n!(0.5 < 0.5)\n!(0.5 < 1)\n!(0.5 < f32)\n!(0.5 < f64)\n!(0.5 < i)\n!(0.5 < i32)\n!(0.5 < i64)\n!(0.5 <= 0.5)\n!(0.5 <= 1)\n!(0.5 <= f32)\n!(0.5 <= f64)\n!(0.5 <= i)\n!(0.5 <= i32)\n!(0.5 <= i64)\n!(0.5 == 0.5)\n!(0.5 == 1)\n!(0.5 == f32)\n!(0.5 == f64)\n!(0.5 == i)\n!(0.5 == i32)\n!(0.5 == i64)\n!(0.5 == nil)\n!(0.5 > 0.5)\n!(0.5 > 1)\n!(0.5 > f32)\n!(0.5 > f64)\n!(0.5 > i)\n!(0.5 > i32)\n!(0.5 > i64)\n!(0.5 >= 0.5)\n!(0.5 >= 1)\n!(0.5 >= f32)\n!(0.5 >= f64)\n!(0.5 >= i)\n!(0.5 >= i32)\n!(0.5 >= i64)\n!(1 != 0.5)\n!(1 != 1)\n!(1 != f32)\n!(1 != f64)\n!(1 != i)\n!(1 != i32)\n!(1 != i64)\n!(1 != nil)\n!(1 / i64 == i64)\n!(1 < 0.5)\n!(1 < 1)\n!(1 < f32)\n!(1 < f64)\n!(1 < i)\n!(1 < i32)\n!(1 < i64)\n!(1 <= 0.5)\n!(1 <= 1)\n!(1 <= f32)\n!(1 <= f64)\n!(1 <= i)\n!(1 <= i32)\n!(1 <= i64)\n!(1 == 0.5)\n!(1 == 1)\n!(1 == f32)\n!(1 == f64)\n!(1 == i)\n!(1 == i32)\n!(1 == i64)\n!(1 == nil)\n!(1 > 0.5)\n!(1 > 1)\n!(1 > f32)\n!(1 > f64)\n!(1 > i)\n!(1 > i32)\n!(1 > i64)\n!(1 >= 0.5)\n!(1 >= 1)\n!(1 >= f32)\n!(1 >= f64)\n!(1 >= i)\n!(1 >= i32)\n!(1 >= i64)\n!(-f32 < f32)\n!(-i < i32)\n!(-i32 >= i)\n!(i != 0.5)\n!(i != 1)\n!(i != f32)\n!(i != f64)\n!(i != i)\n!(i != i32)\n!(i != i64)\n!(i != nil)\n!(i < 0.5)\n!(i < 1)\n!(i < f64)\n!(i < i)\n!(i < i32)\n!(i < i64)\n!(i <= 0.5)\n!(i <= 1)\n!(i <= f32)\n!(i <= f64)\n!(i <= i32)\n!(i == 0.5)\n!(i == 1)\n!(i == f32)\n!(i == f64)\n!(i == i)\n!(i == i32)\n!(i == i64)\n!(i == nil)\n!(i > 0.5)\n!(i > 1)\n!(i > f32)\n!(i > f64)\n!(i > i)\n!(i > i32)\n!(i > i64)\n!(i >= 0.5)\n!(i >= 1 * i64)\n!(i >= 1)\n!(i >= f32)\n!(i >= f64)\n!(i >= i)\n!(i >= i32)\n!(i >= i64)\n!(i32 != 0.5)\n!(i32 != 1)\n!(i32 != f32)\n!(i32 != f64)\n!(i32 != i)\n!(i32 != i32)\n!(i32 != i64)\n!(i32 != nil)\n!(i32 < 0.5)\n!(i32 < 1)\n!(i32 < f32)\n!(i32 < f64)\n!(i32 < i)\n!(i32 < i32)\n!(i32 < i64)\n!(i32 <= 0.5)\n!(i32 <= 1)\n!(i32 <= f32)\n!(i32 <= f64)\n!(i32 <= i)\n!(i32 <= i32)\n!(i32 <= i64)\n!(i32 == 0.5)\n!(i32 == 1)\n!(i32 == f32)\n!(i32 == f64)\n!(i32 == i)\n!(i32 == i32)\n!(i32 == i64)\n!(i32 == nil)\n!(i32 > 0.5)\n!(i32 > 1)\n!(i32 > f32)\n!(i32 > f64)\n!(i32 > i)\n!(i32 > i32)\n!(i32 >= 0.5)\n!(i32 >= 1)\n!(i32 >= f32)\n!(i32 >= f64)\n!(i32 >= i)\n!(i32 >= i32)\n!(i32 >= i64)\n!(i64 != 0.5)\n!(i64 != 1)\n!(i64 != f32)\n!(i64 != f64)\n!(i64 != i)\n!(i64 != i32)\n!(i64 != i64)\n!(i64 != nil)\n!(i64 < 0.5)\n!(i64 < 1)\n!(i64 < f32)\n!(i64 < f64)\n!(i64 < i)\n!(i64 < i32 + i64)\n!(i64 < i32)\n!(i64 < i64)\n!(i64 <= 0.5)\n!(i64 <= 1)\n!(i64 <= f32)\n!(i64 <= f64)\n!(i64 <= i)\n!(i64 <= i32)\n!(i64 <= i64)\n!(i64 == 0.5)\n!(i64 == 1)\n!(i64 == f32)\n!(i64 == f64)\n!(i64 == i32)\n!(i64 == i64)\n!(i64 == nil)\n!(i64 > 0.5)\n!(i64 > 1)\n!(i64 > f32)\n!(i64 > f64)\n!(i64 > i)\n!(i64 > i32)\n!(i64 > i64)\n!(i64 >= 0.5)\n!(i64 >= 1)\n!(i64 >= f32)\n!(i64 >= f64)\n!(i64 >= i)\n!(i64 >= i32)\n!(i64 >= i64)\n```\n\n----------------------------------------\n\nTITLE: String Conversion with Array and List Operations\nDESCRIPTION: This snippet covers string conversion with array and list related functions. This includes filtering, mapping, reducing, sorting, and summing operations. The code aims to check correct evaluation of these operations during string conversion.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_227\n\nLANGUAGE: Expr\nCODE:\n```\nstring(array != $env)\nstring(array != array)\nstring(array != nil)\nstring(array == $env)\nstring(array == array)\nstring(array == list)\nstring(array == nil)\nstring(array | any(ok))\nstring(array | map($env))\nstring(array | map(f64))\nstring(array | one(true))\nstring(array | reduce(#acc))\nstring(array | reduce(add))\nstring(array | sortBy(#))\nstring(array | sum(#))\nstring(array | sum(f64))\nstring(array)\nstring(array) > str\nstring(array) >= foo.Bar\nstring(array) not in foo\nstring(array) not startsWith str\nstring(array) | greet()\nstring(array)[:i]\nstring(array?.[i])\nstring(array[i:])\n```\n\n----------------------------------------\n\nTITLE: Equality and Membership Checks\nDESCRIPTION: Showcases the use of equality (==, !=) and membership (in, not in) operators, including checks within environment variables and collections.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_15\n\nLANGUAGE: EXPR\nCODE:\n```\n1 + 1 not in array\n1 - 1.0 in array\n1 - 1.0 not in array\n1 / 1 in [nil]\n1 < 1 ?: array\n1 <= 1 == true or true\n1 == $env || ok\n1 == f64 && list == $env\n1 in $env.array\n1 in $env?.Bar\n1 in $env?.String\n1 in $env?.[Bar]\n1 in $env?.[String]\n1 in $env?.array\n1 in $env?.foobar\n1 not in $env.array\n1 not in $env?.Bar\n1 not in $env?.String\n1 not in $env?.[Bar]\n1 not in $env?.[String]\n1 not in $env?.array\n1 not in $env?.foobar\n1.0 != 1 / i\n1.0 != 1 ?: foo\n1.0 != 1.0 and $env not endsWith $env\n1.0 == nil ?: array\n1.0 == nil and $env.ok\n1.0 == nil or ok\n1.0 > 0 != ok\n1.0 > 1 ?: {foo: add, foo: ok}?.foo\n1.0 >= 1.0 == {foo: $env, foo: $env}.foo\n1.0 >= 1.0 ?: list\n1.0 in $env.array\n1.0 in $env?.Bar\n1.0 in $env?.String\n1.0 in $env?.[Bar]\n1.0 in $env?.[String]\n1.0 in $env?.array\n1.0 in $env?.foobar\n1.0 not in $env.array\n1.0 not in $env?.Bar\n1.0 not in $env?.String\n1.0 not in $env?.[Bar]\n1.0 not in $env?.[String]\n1.0 not in $env?.array\n1.0 not in $env?.foobar\n[$env != $env]\n[$env != 0]\n[$env != 1.0]\n[$env != 1]\n[$env != add]\n[$env != f64]\n[$env != false]\n[$env != foo]\n[$env != list]\n[$env != nil]\n[$env == $env]\n[$env == 0]\n[$env == 1.0]\n[$env == 1]\n[$env == add]\n[$env == false]\n[$env == foo]\n[$env == greet]\n[$env == i, f64]\n[$env == i]\n[$env == list]\n[$env == nil]\n[$env == ok]\n[$env == str]\n[$env == true]\n[$env in list]\n[$env not in array]\n[$env not in list, f64]\n[$env not in list]\n```\n\n----------------------------------------\n\nTITLE: String Conversion with 'greet' function\nDESCRIPTION: This snippet tests string conversion with the function 'greet'. It covers different calls, combinations, and scenarios involving the function 'greet'.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_234\n\nLANGUAGE: Expr\nCODE:\n```\nstring(greet(str))\nstring(greet)\nstring(greet) not matches str\n```\n\n----------------------------------------\n\nTITLE: Expr groupBy with function calls and variable 'greet'\nDESCRIPTION: Demonstrates grouping based on a comparison with 'greet', a function call 'greet(str)', and bitwise operations with 'i'.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_129\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(array, greet == $env)\ngroupBy(array, greet(str))\ngroupBy(array, i | bitand(#))?.list\ngroupBy(array, i)\ngroupBy(array, i).add\ngroupBy(array, i).array\ngroupBy(array, i).f64\ngroupBy(array, i).foo\ngroupBy(array, i).greet\ngroupBy(array, i).i\ngroupBy(array, i).ok\ngroupBy(array, i).str\ngroupBy(array, i)?.Bar\ngroupBy(array, i)?.[f64]\ngroupBy(array, i)?.[ok]\ngroupBy(array, i)?.[str]\ngroupBy(array, i)?.add\ngroupBy(array, i)?.array\ngroupBy(array, i)?.f64\ngroupBy(array, i)?.ok\ngroupBy(array, i)?.str\n```\n\n----------------------------------------\n\nTITLE: Compiling with a Patcher\nDESCRIPTION: Compiles the expression `foo + bar` using the `expr.Compile` function, applying the `FooPatcher` during compilation using the `expr.Patch` option. This modifies the expression tree before evaluation.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/patch.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nprogram, err := expr.Compile(`foo + bar`, expr.Patch(FooPatcher{}))\n```\n\n----------------------------------------\n\nTITLE: Array Max\nDESCRIPTION: Finds the maximum value within the array. Requires numeric elements. Returns the maximum value in the array.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_55\n\nLANGUAGE: Expr\nCODE:\n```\narray | max(0)\n```\n\n----------------------------------------\n\nTITLE: List Membership Check with 'not in' Operator in Expr\nDESCRIPTION: This snippet checks if an element is *not* present within a grouped list, utilizing the `not in` operator in Expr.  Specifically, it verifies if an item does not exist in the 'i' property of the result of `groupBy(list, #)`. The groupBy function groups elements based on a key (in this case, '#', likely representing the element itself).\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_75\n\nLANGUAGE: Expr\nCODE:\n```\nlist not in groupBy(list, #).i\n```\n\n----------------------------------------\n\nTITLE: Array Membership Check\nDESCRIPTION: Checks if the array is a member of the $env?.Bar. Returns a boolean indicating membership.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_42\n\nLANGUAGE: Expr\nCODE:\n```\narray in $env?.Bar\n```\n\n----------------------------------------\n\nTITLE: Array Find Last\nDESCRIPTION: Finds the last element in the array that is greater than another value. Requires numeric elements. Returns the last element that satisfies the condition.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_51\n\nLANGUAGE: Expr\nCODE:\n```\narray | findLast(# > #)\n```\n\n----------------------------------------\n\nTITLE: Evaluating Types with trimSuffix and string manipulations - Expr\nDESCRIPTION: These expressions use the `trimSuffix` function to remove a specified suffix from a string, often combined with string concatenation and other functions like `upper`, `lower`, `string`, `toBase64`, `toJSON` and `reduce`. The `trimSuffix` function removes the suffix if it's present and doesn't affect the string otherwise.  It is then used in conjunction with type() to determine its data type.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_123\n\nLANGUAGE: expr\nCODE:\n```\ntrimPrefix(upper(\"bar\"))\ntrimPrefix(upper(\"foo\"))\ntrimSuffix(\"bar\" + \"foo\")\ntrimSuffix(\"bar\") not contains reduce(list, \"bar\")\ntrimSuffix(\"foo\" + \"bar\")\ntrimSuffix(false ? i64 : \"foo\")\ntrimSuffix(foo.Bar)\ntrimSuffix(foo.String())\ntrimSuffix(foo?.Bar)\ntrimSuffix(foo?.String())\ntrimSuffix(greet(\"bar\"))\ntrimSuffix(greet(\"foo\"))\ntrimSuffix(lower(\"bar\"))\ntrimSuffix(reduce(array, \"foo\"))\ntrimSuffix(reduce(list, #)?.Bar)\ntrimSuffix(string(\"bar\"))\ntrimSuffix(string(\"foo\"))\ntrimSuffix(string(0.5))\ntrimSuffix(string(add))\ntrimSuffix(string(array))\ntrimSuffix(string(div))\ntrimSuffix(string(f64))\ntrimSuffix(string(false))\ntrimSuffix(string(foo))\ntrimSuffix(string(half))\ntrimSuffix(string(i))\ntrimSuffix(string(i32))\ntrimSuffix(string(i64))\ntrimSuffix(string(list))\ntrimSuffix(string(nil))\ntrimSuffix(string(ok))\ntrimSuffix(string(true))\ntrimSuffix(toBase64(\"bar\"))\ntrimSuffix(toBase64(\"foo\"))\ntrimSuffix(toJSON(1 > f64))\ntrimSuffix(toJSON(1))\ntrimSuffix(toJSON(f32))\ntrimSuffix(toJSON(f64))\ntrimSuffix(toJSON(false))\ntrimSuffix(toJSON(foo))\ntrimSuffix(toJSON(i))\ntrimSuffix(toJSON(i32))\ntrimSuffix(toJSON(i64))\ntrimSuffix(toJSON(list))\ntrimSuffix(toJSON(nil))\ntrimSuffix(toJSON(true))\ntrimSuffix(trim(\"bar\"))\ntrimSuffix(trim(\"foo\"))\ntrimSuffix(trimPrefix(\"bar\"))\ntrimSuffix(trimPrefix(\"foo\"))\ntrimSuffix(trimSuffix(\"bar\"))\n```\n\n----------------------------------------\n\nTITLE: Bitwise OR Operations in Expr\nDESCRIPTION: Presents examples of the `bitor` function usage in Expr with diverse data types demonstrating the function's behavior with different types and the precedence of bitwise operations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_19\n\nLANGUAGE: Expr\nCODE:\n```\nbitor(1, 1) < i\nbitor(1, 1) == i\nbitor(1, i32) != i64\nbitor(i, -i64)\nbitor(i, i)\nbitor(i, i64)\nbitor(i32, i)\nbitor(i32, i32)\nbitor(i32, i64)\nbitor(i64 % 1, i32)\nbitor(i64, i)\nbitor(i64, i32)\nbitor(i64, i64)\nbitor(min(i64), i)\nbitor(score(i), i64)\n```\n\n----------------------------------------\n\nTITLE: Defining Method for Struct Environment in Go\nDESCRIPTION: This snippet shows how to define a method on the struct that will be available as a function inside expr. It defines a `Format` method for the `Env` struct that takes a `time.Time` and returns a formatted string.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/environment.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc (Env) Format(t time.Time) string {\n    return t.Format(time.RFC822)\n}\n```\n\n----------------------------------------\n\nTITLE: Add Function Tests\nDESCRIPTION: Tests the `add` function with different input types and operators, including comparisons and exponentiation.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_11\n\nLANGUAGE: Expr\nCODE:\n```\nadd(1, i) < i\nadd(i, 1) ** f32\nadd(i, i)\nadd(i, i32 + 1)\n```\n\n----------------------------------------\n\nTITLE: Expression Sequences - Expr\nDESCRIPTION: Demonstrates expression sequences using semicolons, showcasing evaluation order and optional chaining.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_120\n\nLANGUAGE: Expr\nCODE:\n```\nfoo; $env?.foo\nfoo; $env?.ok\nfoo; $env?.str\nfoo; 1.0; $env?.ok\nfoo; f64\nfoo; foo; nil != ok\nfoo; foo?.Bar\nfoo; i\nfoo; list\nfoo; str\ngreet; $env?.[Bar]\ngreet; add\ngreet; array\ngreet; f64\ngreet; foo\ngreet; foo; i\ngreet; greet\ngreet; i\ngreet; ok\n```\n\n----------------------------------------\n\nTITLE: Using findLast with map and numeric operations\nDESCRIPTION: Demonstrates the usage of `findLast` alongside the `map` function and numeric operations for filtering elements.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_46\n\nLANGUAGE: expr\nCODE:\n```\nfindLast(map(array, #), # < #)\nfindLast(map(array, #), # < i32)\nfindLast(map(array, #), # <= 1)\nfindLast(map(array, #), # == f64)\nfindLast(map(array, #), 0.5 != 0.5)\nfindLast(map(array, #), i32 == #)\nfindLast(map(array, #), ok)\nfindLast(map(array, f64 * #), # + # > f32)\nfindLast(map(array, score), ok)\nfindLast(map(list, #), # == #)\nfindLast(map(list, #), greet == nil)\nfindLast(map(list, #), ok)\nfindLast(map(list, ok), # ? # : #)\n```\n\n----------------------------------------\n\nTITLE: Array Mapping\nDESCRIPTION: Applies the map function to the array, using the element itself (`#`) as input. The function returns a new array with the results of applying the mapping function to each element of the original array.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_40\n\nLANGUAGE: Expr\nCODE:\n```\narray | map(#)\n```\n\n----------------------------------------\n\nTITLE: Using the max function in Expr\nDESCRIPTION: This snippet demonstrates various ways to use the `max` function with different data types (i32, i64, f32, f64, i) and operations. It showcases the flexibility and type handling of the `max` function in the Expr language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_81\n\nLANGUAGE: expr\nCODE:\n```\nmax(i32 - 0.5)\nmax(i32 - 1)\nmax(i32 - f64)\nmax(i32 - i)\nmax(i32 / 1)\nmax(i32 ^ i)\nmax(i32 ^ i, f32)\nmax(i32)\nmax(i32) * i32\nmax(i32) / f32\nmax(i32) / i\nmax(i32) <= f32\nmax(i32) ^ f32\nmax(i32) in array\nmax(i32, f32)\nmax(i32, f64)\nmax(i32, i)\nmax(i32, i32)\nmax(i32, i64)\nmax(i64 % i)\nmax(i64 * 0.5)\nmax(i64 * i64)\nmax(i64 ** 0.5)\nmax(i64 ** f32)\nmax(i64 ** i64)\nmax(i64 + i)\nmax(i64 + i64)\nmax(i64 - 0.5)\nmax(i64 - 1)\nmax(i64 - f64)\nmax(i64 / f64)\nmax(i64 / i32)\nmax(i64 / i64)\nmax(i64 ^ 0.5)\nmax(i64 ^ 1)\nmax(i64 ^ i)\nmax(i64)\nmax(i64) ** (1 + 1)\nmax(i64) ** f32\nmax(i64) + i32\nmax(i64) - i32\nmax(i64) - i64\nmax(i64) .. i32\nmax(i64) < f32\nmax(i64) >= f32\nmax(i64) ^ i\nmax(i64, 0.5 + 1)\nmax(i64, 0.5, i64) ** i32\nmax(i64, f32)\nmax(i64, f64)\nmax(i64, half(1))\nmax(i64, i)\nmax(i64, i) + i32\nmax(i64, i32)\nmax(i64, i32) == f64\nmax(i64, i64)\nmax(int(0.5))\nmax(int(f32))\nmax(int(i32))\nmax(int(i64))\nmax(len(\"foo\"))\nmax(len(array))\nmax(len(list))\nmax(max(0.5))\nmax(max(0.5, f64))\nmax(max(1))\nmax(max(i))\nmax(max(i32))\nmax(max(i64))\nmax(mean(array))\nmax(median(array))\nmax(min(0.5, 0.5))\nmax(min(1))\nmax(min(1, f64))\nmax(min(f32, i64, i32))\nmax(min(i))\nmax(min(i32))\nmax(ok ? \"foo\" : f64)\nmax(ok ? 0.5 : i64)\nmax(ok ? 1 : i)\nmax(ok ? array : true)\nmax(ok ? foo : greet)\nmax(ok ? half : f32)\nmax(ok ? half : list)\nmax(ok ? i : 1)\nmax(ok ? i : nil)\nmax(reduce(array, # % #))\nmax(reduce(array, #))\nmax(reduce(array, 1))\nmax(reduce(array, f32))\nmax(reduce(array, f64))\nmax(reduce(list, 0.5))\nmax(reduce(list, f32), i64)\nmax(reduce(list, i64))\nmax(round(1))\nmax(round(f32))\nmax(round(f64))\nmax(round(i))\nmax(round(i32))\nmax(score(1))\nmax(score(i), i)\nmax(true ? f32 : f32)\nmax(true ? foo : array)\nmax(true ? greet : 1)\nmax({\"bar\": list}.String)\nmax({\"foo\": array}?.f32)\nmax({\"foo\": half}?.f32)\n```\n\n----------------------------------------\n\nTITLE: Variable Comparisons and Operations\nDESCRIPTION: This snippet tests various comparisons, arithmetic operations, and conditional assignments involving variables like `add` and `div`. It explores equality and inequality checks against other variables and nil, along with ternary operators that determine the return value based on these comparisons.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_10\n\nLANGUAGE: Expr\nCODE:\n```\nadd\nadd != add\nadd != add == nil\nadd != div\nadd != div != false\nadd != div == true\nadd != nil ? f64 : i64\nadd != reduce(list, add)\nadd == add\nadd == add != nil\nadd == add == nil\nadd == add ? 1 : i64\nadd == div\nadd == div ? f64 : list\nadd == nil ? false : i32\nadd == nil ? greet : i32\nadd == nil ? nil : nil\nadd in sort(array)\n```\n\n----------------------------------------\n\nTITLE: Using findLastIndex with arrays, arithmetic, and logical operators\nDESCRIPTION: Explores the usage of `findLastIndex` with arrays, arithmetic operations, logical negation, and other expressions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_49\n\nLANGUAGE: expr\nCODE:\n```\nfindLastIndex(array, # ^ # >= #)\nfindLastIndex(array, # not in array)\nfindLastIndex(array, 0.5 != #)\nfindLastIndex(array, 0.5 != i64)\nfindLastIndex(array, 0.5 < #)\nfindLastIndex(array, 0.5 < i32)\nfindLastIndex(array, 0.5 <= #)\nfindLastIndex(array, 0.5 > #)\nfindLastIndex(array, 0.5 >= 0.5)\nfindLastIndex(array, 0.5 >= f64)\nfindLastIndex(array, 1 != #)\nfindLastIndex(array, 1 <= #)\nfindLastIndex(array, 1 == #)\nfindLastIndex(array, 1 == f64)\nfindLastIndex(array, 1 >= i32)\nfindLastIndex(array, array == nil)\nfindLastIndex(array, f32 != #)\nfindLastIndex(array, f32 != f32)\nfindLastIndex(array, f32 < #)\nfindLastIndex(array, f32 == #)\nfindLastIndex(array, f32 == nil)\nfindLastIndex(array, f32 > #)\nfindLastIndex(array, f64 != #)\nfindLastIndex(array, f64 < #)\nfindLastIndex(array, f64 <= #)\nfindLastIndex(array, f64 <= i32)\nfindLastIndex(array, f64 == #)\nfindLastIndex(array, f64 == 0.5)\nfindLastIndex(array, f64 > #)\nfindLastIndex(array, false ? # : false)\nfindLastIndex(array, foo != foo)\nfindLastIndex(array, greet == greet)\nfindLastIndex(array, i - # >= #)\nfindLastIndex(array, i < #)\nfindLastIndex(array, i <= #)\nfindLastIndex(array, i > 0.5)\nfindLastIndex(array, i32 <= #)\nfindLastIndex(array, i32 <= 1)\nfindLastIndex(array, i32 <= f32)\nfindLastIndex(array, i32 > 0.5)\nfindLastIndex(array, i32 >= #)\nfindLastIndex(array, i64 <= # + #)\nfindLastIndex(array, i64 > #)\nfindLastIndex(array, min(1, #) <= i32 + #)\nfindLastIndex(array, nil != #)\nfindLastIndex(array, nil != add)\nfindLastIndex(array, nil != i32)\nfindLastIndex(array, nil == #)\nfindLastIndex(array, not (i32 != 0.5))\nfindLastIndex(array, not ok)\nfindLastIndex(array, ok && true)\nfindLastIndex(array, ok)\nfindLastIndex(array, ok) % i64\nfindLastIndex(array, ok) + f64\nfindLastIndex(array, one(list, ok))\nfindLastIndex(array, score == nil)\nfindLastIndex(array, true == false)\nfindLastIndex(array, true) / f32\nfindLastIndex(array, true) not in array\nfindLastIndex(filter(array, false), ok)\n```\n\n----------------------------------------\n\nTITLE: List Comparison Operations in Expr\nDESCRIPTION: These snippets showcase various list comparison operations using `!=` and `==` operators in Expr. They compare lists with different types, including numbers, strings, variables, and the results of function calls like `filter` and `map`. These expressions validate the correctness of list equality and inequality checks.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_74\n\nLANGUAGE: Expr\nCODE:\n```\nlist != 1 .. 1\nlist != [\"foo\"]\nlist != [i, 0.5]\nlist != [i]\nlist != array\nlist != filter(array, ok)\nlist != filter(array, true)\nlist != list\nlist != list ? 0.5 : div\nlist != list ? half : div\nlist != map(array, #)\nlist != map(list, 1)\nlist != map(list, i64)\nlist != nil && i32 <= 1\nlist != nil ? false : 1\nlist != nil ? i : 1\nlist != sort(array)\nlist == [div, nil]\nlist == [i]\nlist == array\nlist == array == nil\nlist == list\nlist == list != false\nlist == list ? i32 : i\nlist == map(list, #)\nlist == nil && ok\nlist == nil ? nil : \"foo\"\nlist == nil or f64 == f64\n```\n\n----------------------------------------\n\nTITLE: Get Map Values Using values() in Expr\nDESCRIPTION: The `values()` function retrieves all the values from a given map and returns them as an array. The order of values corresponds to the order of keys.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_77\n\nLANGUAGE: expr\nCODE:\n```\nvalues({\"name\": \"John\", \"age\": 30}) == [\"John\", 30]\n```\n\n----------------------------------------\n\nTITLE: Counting with Sort Function in Expr\nDESCRIPTION: This snippet demonstrates usage of the count function in combination with the 'sort' function to sort the array before counting elements that satisfy a certain condition.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_33\n\nLANGUAGE: Expr\nCODE:\n```\ncount(sort(array), 1 <= #)\n```\n\n----------------------------------------\n\nTITLE: Using findLast with range and comparison operators\nDESCRIPTION: Illustrates the application of `findLast` with ranges and various comparison operators to locate elements within specified conditions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_42\n\nLANGUAGE: expr\nCODE:\n```\nfindLast(1 .. i, # <= #)\nfindLast(1 .. i32, 1 >= #)\nfindLast(1 .. i64, ok)\n```\n\n----------------------------------------\n\nTITLE: Add Function Comparisons\nDESCRIPTION: Demonstrates various comparisons using the `add` function against variables, nil, and other expressions. It includes inequality checks (`!=`), equality checks (`==`), and conditional expressions. The aim is to validate the comparison logic and behavior of the `add` function.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_32\n\nLANGUAGE: Expr\nCODE:\n```\nadd != $env && $env?.ok\nadd != $env == $env\nadd != $env or ok\nadd != $env.add\nadd != $env?.Bar\nadd != $env?.String\nadd != $env?.[Bar]\nadd != $env?.[String]\nadd != $env?.[foobar?.[foobar]]\nadd != $env?.[foobar]\nadd != $env?.[str]\nadd != $env?.add\nadd != $env?.add ?: foo\nadd != $env?.foobar\nadd != $env?.foobar?.[array]\nadd != add\nadd != nil && $env\nadd != nil ?: false\nadd != nil || true\nadd == $env ? 0 : 1\nadd == $env ? array : ok\nadd == $env.add\nadd == $env?.Bar\nadd == $env?.Bar?.[str]\nadd == $env?.String\nadd == $env?.String?.ok()\nadd == $env?.[Bar]\nadd == $env?.[String]\nadd == $env?.[foobar]\nadd == $env?.[str]\nadd == $env?.add\nadd == $env?.foobar\nadd == add\nadd == last($env)\nadd == max($env)\nadd == nil != $env?.[Bar]\nadd == nil && $env[foobar:foobar]\nadd == nil || $env\nadd == nil || false\n```\n\n----------------------------------------\n\nTITLE: toJSON Function Usage\nDESCRIPTION: Demonstrates the use of the `toJSON` function with different input types. It covers converting lists, nil values, boolean values (true and false), and variables to JSON format. The purpose is to test the correct JSON serialization of various data types.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_21\n\nLANGUAGE: Expr\nCODE:\n```\n[toJSON(list)]\n[toJSON(nil), foo.Bar]\n[toJSON(nil)]\n[toJSON(ok)]\n[toJSON(true)]\n```\n\n----------------------------------------\n\nTITLE: Accessing AST of Compiled Program in Go\nDESCRIPTION: This code shows how to access the AST of a compiled expression using `program.Node()` and then traverse it using `ast.Walk`. Note that the AST of a compiled program might be modified by patchers and optimizers.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/visitor.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nprogram, err := expr.Compile(`foo + bar`)\nif err != nil {\n    panic(err)\n}\n\n// highlight-next-line\nnode := program.Node()\n\nv := &Visitor{}\nast.Walk(&node, v)\n```\n\n----------------------------------------\n\nTITLE: Negated String Operations on Fields - Expr\nDESCRIPTION: Demonstrates the negated string operations such as 'not contains', 'not endsWith', 'not startsWith', and 'not matches', applied on fields.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_112\n\nLANGUAGE: Expr\nCODE:\n```\nfoo.Bar not contains str\nfoo.Bar not endsWith str\nfoo.Bar not matches str\nfoo.Bar not matches toJSON(i)\nfoo.Bar not startsWith foo?.Bar\nfoo.Bar not startsWith str\nfoo?.Bar not contains str\nfoo?.Bar not endsWith $env?.[String]\nfoo?.Bar not endsWith $env?.foobar\nfoo?.Bar not endsWith str\nfoo?.Bar not matches $env?.[foobar]\nfoo?.Bar not matches $env?.[str]\nfoo?.Bar not matches str\nfoo?.Bar not startsWith $env.str\nfoo?.Bar not startsWith $env?.Bar\nfoo?.Bar not startsWith str\nfoo?.Bar not startsWith toJSON(nil)\nfoo?.Bar not startsWith type(str)\nfoo?.String() not contains $env?.[str]\nfoo?.String() not endsWith $env?.Bar\nfoo?.String() not endsWith $env?.[foobar]\nfoo?.String() not startsWith str\nfoo?.String() not startsWith type(foo)\n```\n\n----------------------------------------\n\nTITLE: Expr: Additional Logical OR examples with numerical and boolean operations\nDESCRIPTION: This snippet contains more logical OR operations involving numerical comparisons, boolean logic, and list manipulations, showcasing diverse scenarios.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_254\n\nLANGUAGE: Expr\nCODE:\n```\ntrue or 0 < f64\ntrue or 0 <= $env?.[f64]?.[foo]\ntrue or 1 > f64\ntrue or 1 >= $env in $env\ntrue or 1.0 > i\ntrue or 1.0 >= f64\ntrue or f64 + $env?.[add]\ntrue or false ?: sum($env, .Bar)\ntrue or false or ok\ntrue or i not in $env * f64\ntrue or nil == str in $env\ntrue or nil not in list\ntrue or ok and foo == $env?.[String]\ntrue or str contains $env?.str\ntrue or str not in foo\n\n```\n\n----------------------------------------\n\nTITLE: Expr groupBy with variable 'ok' and property access\nDESCRIPTION: Shows usage of a variable named 'ok' with various property access patterns, including safe navigation.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_131\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(array, ok)\ngroupBy(array, ok).Bar\ngroupBy(array, ok).String\ngroupBy(array, ok).add\ngroupBy(array, ok).f64\ngroupBy(array, ok).foo\ngroupBy(array, ok).greet\ngroupBy(array, ok).str\ngroupBy(array, ok)?.String\ngroupBy(array, ok)?.[foo]\ngroupBy(array, ok)?.[i]\ngroupBy(array, ok)?.[ok]\ngroupBy(array, ok)?.[str]\ngroupBy(array, ok)?.array\ngroupBy(array, ok)?.foo\ngroupBy(array, ok)?.list\ngroupBy(array, ok)?.ok\n```\n\n----------------------------------------\n\nTITLE: Evaluating floor function with various inputs - Expr\nDESCRIPTION: This snippet demonstrates the use of the `floor` function to calculate the floor of various numeric inputs, including floating-point numbers, integers, arithmetic expressions, and other function calls. The purpose is to test the implementation and type handling of the floor function in the expression language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_54\n\nLANGUAGE: Expr\nCODE:\n```\nfloor(-0.5)\nfloor(-1)\nfloor(-f32)\nfloor(-f64)\nfloor(-i)\nfloor(-i32)\nfloor(-i64)\nfloor(0.5 * 0.5)\nfloor(0.5 * 1)\nfloor(0.5 * i32)\nfloor(0.5 ** 1)\nfloor(0.5 ** f64)\nfloor(0.5 ** i)\nfloor(0.5 + 1)\nfloor(0.5 + f32)\nfloor(0.5 + i)\nfloor(0.5 + i32)\nfloor(0.5 + i64)\nfloor(0.5 - 1)\nfloor(0.5 - f32)\nfloor(0.5 - i)\nfloor(0.5 / 0.5)\nfloor(0.5 / 1)\nfloor(0.5 / i32)\nfloor(0.5 ^ 0.5)\nfloor(0.5 ^ 1)\nfloor(0.5 ^ f32)\nfloor(0.5 ^ f64)\nfloor(0.5 ^ i)\nfloor(0.5) != i64\nfloor(0.5) ** f32\nfloor(0.5) - i\nfloor(0.5) - i64\nfloor(0.5) / i\nfloor(0.5) <= i64\nfloor(0.5) > i32\nfloor(0.5) > i64 != ok\nfloor(0.5) >= f32\nfloor(0.5) ^ i\nfloor(1 % 1)\nfloor(1 % i)\nfloor(1 * 0.5)\nfloor(1 * 1)\nfloor(1 ** 1)\nfloor(1 ** f64)\nfloor(1 ** i32)\nfloor(1 + 0.5)\nfloor(1 + 1)\nfloor(1 + f32)\nfloor(1 + f64)\nfloor(1 + i32)\nfloor(1 - 0.5)\nfloor(1 - 1)\nfloor(1 - i)\nfloor(1 - i32)\nfloor(1 - i64)\nfloor(1 / 0.5)\nfloor(1 / 1)\nfloor(1 / i)\nfloor(1 / i64)\nfloor(1 ^ i)\nfloor(1 ^ i32)\nfloor(1 ^ i64)\nfloor(1) * i64\nfloor(1) - f32\nfloor(1) - i\nfloor(1) <= f32\nfloor(1) >= half(0.5)\nfloor(abs(0.5))\nfloor(abs(1))\nfloor(abs(f32))\nfloor(abs(f64))\nfloor(abs(i32))\nfloor(abs(i64))\nfloor(array[1])\nfloor(array[i32])\nfloor(array[i64])\nfloor(array[i])\nfloor(bitnot(1))\nfloor(bitnot(i))\nfloor(bitnot(i32))\nfloor(bitnot(i64))\nfloor(ceil(0.5))\nfloor(ceil(1))\nfloor(ceil(f64))\nfloor(ceil(i))\nfloor(ceil(i32))\nfloor(ceil(i64))\nfloor(count(array, false))\nfloor(count(array, ok))\nfloor(count(list, ok))\nfloor(f32 ** 1)\nfloor(f32 ** f64)\nfloor(f32 ** i32)\nfloor(f32 + f32)\nfloor(f32 + i32)\nfloor(f32 + i64)\nfloor(f32 - 0.5)\nfloor(f32 - f64)\nfloor(f32 / 0.5)\nfloor(f32 / f64)\nfloor(f32 / i)\nfloor(f32 / i32)\nfloor(f32 / i64)\nfloor(f32 ^ 0.5)\n```\n\n----------------------------------------\n\nTITLE: Equality Comparisons in Expr\nDESCRIPTION: These code snippets demonstrate various equality comparisons (`==`) in the Expr language, primarily involving the variable `foo`. The examples showcase comparisons with environment variables, other variables, nil values, and boolean results. They also cover conditional expressions and comparisons within arrays or lists.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_103\n\nLANGUAGE: Expr\nCODE:\n```\nfoo == $env != nil\nfoo == $env in $env?.foobar\nfoo == $env or $env.ok\nfoo == $env || $env\nfoo == $env.foo\nfoo == $env?.Bar\nfoo == $env?.Bar?.[i]\nfoo == $env?.String\nfoo == $env?.[Bar]\nfoo == $env?.[String]\nfoo == $env?.[String]?.[f64]\nfoo == $env?.[foobar?.greet]\nfoo == $env?.[foobar]\nfoo == $env?.[str]\nfoo == $env?.foo\nfoo == $env?.foobar\nfoo == $env?.foobar?.array()\nfoo == $env?.nil\nfoo == $env?.not\nfoo == foo\nfoo == foo != ok\nfoo == foo == ok\nfoo == foo ? $env : $env\nfoo == foo ?: f64\nfoo == foo ?: i\nfoo == foo or $env?.[greet]\nfoo == foo or ok\nfoo == foo || ok\nfoo == last($env)\nfoo == last(list)\nfoo == list?.[i]\nfoo == nil != $env\nfoo == nil != nil\nfoo == nil && $env or $env\nfoo == nil && f64 >= 1.0\nfoo == nil == $env\nfoo == nil ? foo : i\nfoo == nil ? true : i\nfoo == nil and ok\nfoo == nil || false\n```\n\n----------------------------------------\n\nTITLE: Variable Declaration with Pipe Operator in Expr\nDESCRIPTION: Illustrates variable declaration combined with the pipe operator for data transformation before assignment.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_15\n\nLANGUAGE: expr\nCODE:\n```\nlet name = user.Name | lower() | split(\" \"); \n\"Hello, \" + name[0] + \"!\"\n```\n\n----------------------------------------\n\nTITLE: Testing 'not' operator with various expressions\nDESCRIPTION: This code snippet tests the 'not' operator with different expressions, covering numerical comparisons, string operations, logical operations, and comparisons involving nil values. The purpose is to ensure that the 'not' operator correctly negates the results of various expressions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_88\n\nLANGUAGE: Expr\nCODE:\n```\nnot !(0.5 != i64)\nnot !(i < 1)\nnot !(i >= 0.5)\nnot !(i32 != i32)\nnot !(nil != false)\nnot !false\nnot !not false\nnot !ok\nnot !true\nnot (\"bar\" != \"bar\")\nnot (\"bar\" != \"foo\")\nnot (\"bar\" != nil)\nnot (\"bar\" < \"bar\")\nnot (\"bar\" < \"foo\")\nnot (\"bar\" <= \"bar\")\nnot (\"bar\" <= \"foo\")\nnot (\"bar\" == \"bar\")\nnot (\"bar\" == \"foo\")\nnot (\"bar\" == nil)\nnot (\"bar\" > \"bar\")\nnot (\"bar\" > \"foo\")\nnot (\"bar\" >= \"bar\")\nnot (\"bar\" >= \"foo\")\nnot (\"bar\" contains \"bar\")\nnot (\"bar\" contains \"foo\")\nnot (\"bar\" endsWith \"bar\")\nnot (\"bar\" endsWith \"foo\")\nnot (\"bar\" in foo)\nnot (\"bar\" matches \"bar\")\nnot (\"bar\" matches \"foo\")\nnot (\"bar\" not contains \"bar\")\nnot (\"bar\" not contains \"foo\")\nnot (\"bar\" not endsWith \"bar\")\nnot (\"bar\" not endsWith \"foo\")\nnot (\"bar\" not in foo)\nnot (\"bar\" not matches \"bar\")\nnot (\"bar\" not matches \"foo\")\nnot (\"bar\" not startsWith \"bar\")\nnot (\"bar\" not startsWith \"foo\")\nnot (\"bar\" startsWith \"bar\")\nnot (\"bar\" startsWith \"foo\")\nnot (\"foo\" != \"bar\")\nnot (\"foo\" != \"foo\")\nnot (\"foo\" != nil)\nnot (\"foo\" < \"bar\")\nnot (\"foo\" < \"foo\")\nnot (\"foo\" <= \"bar\")\nnot (\"foo\" <= \"foo\")\nnot (\"foo\" == \"bar\")\nnot (\"foo\" == \"foo\")\nnot (\"foo\" == nil)\nnot (\"foo\" > \"bar\")\nnot (\"foo\" > \"foo\")\nnot (\"foo\" >= \"bar\")\nnot (\"foo\" >= \"foo\")\nnot (\"foo\" contains \"bar\")\nnot (\"foo\" contains \"foo\")\nnot (\"foo\" endsWith \"bar\")\nnot (\"foo\" endsWith \"foo\")\nnot (\"foo\" in foo)\nnot (\"foo\" matches \"bar\")\nnot (\"foo\" matches \"foo\")\nnot (\"foo\" not contains \"bar\")\nnot (\"foo\" not contains \"foo\")\nnot (\"foo\" not endsWith \"bar\")\nnot (\"foo\" not endsWith \"foo\")\nnot (\"foo\" not in foo)\nnot (\"foo\" not matches \"foo\")\nnot (\"foo\" not startsWith \"foo\")\nnot (\"foo\" startsWith \"bar\")\nnot (\"foo\" startsWith \"foo\")\nnot (0.5 != 0.5)\nnot (0.5 != 1)\nnot (0.5 != f32)\nnot (0.5 != f64)\nnot (0.5 != i)\nnot (0.5 != i32)\nnot (0.5 != i64)\nnot (0.5 != nil)\nnot (0.5 < 0.5)\nnot (0.5 < 1)\nnot (0.5 < f32)\nnot (0.5 < f64)\nnot (0.5 < i)\nnot (0.5 < i32)\nnot (0.5 < i64)\nnot (0.5 <= 0.5)\nnot (0.5 <= 1)\nnot (0.5 <= f32)\nnot (0.5 <= f64)\nnot (0.5 <= i)\nnot (0.5 <= i32)\nnot (0.5 <= i64)\nnot (0.5 == 0.5)\nnot (0.5 == 1)\nnot (0.5 == f32)\nnot (0.5 == f64)\nnot (0.5 == i && i32 != i32)\nnot (0.5 == i)\nnot (0.5 == i32)\nnot (0.5 == i64)\nnot (0.5 == nil)\nnot (0.5 > 0.5)\nnot (0.5 > 1)\nnot (0.5 > f32)\nnot (0.5 > f64)\nnot (0.5 > i)\nnot (0.5 > i32)\nnot (0.5 > i64)\nnot (0.5 >= 0.5)\nnot (0.5 >= 1)\nnot (0.5 >= f32)\nnot (0.5 >= f64)\nnot (0.5 >= i)\nnot (0.5 >= i32)\nnot (0.5 >= i64)\nnot (0.5 in array)\nnot (0.5 not in array)\nnot (1 != 0.5)\nnot (1 != 1)\nnot (1 != f32)\nnot (1 != f64)\nnot (1 != i)\nnot (1 != i32)\nnot (1 != i64)\nnot (1 != nil)\nnot (1 < 0.5)\nnot (1 < 1)\nnot (1 < f32)\nnot (1 < f64)\nnot (1 < i)\nnot (1 < i32)\nnot (1 < i64)\nnot (1 <= 0.5)\nnot (1 <= 1)\nnot (1 <= f32)\nnot (1 <= f64)\nnot (1 <= i)\nnot (1 <= i32)\nnot (1 <= i64)\nnot (1 == 0.5)\nnot (1 == 1)\nnot (1 == f32)\nnot (1 == f64)\nnot (1 == i)\nnot (1 == i32)\nnot (1 == i64)\nnot (1 == nil)\nnot (1 > 0.5)\nnot (1 > 1)\nnot (1 > f32)\nnot (1 > f64)\nnot (1 > i)\nnot (1 > i32)\nnot (1 > i64)\nnot (1 >= 0.5)\nnot (1 >= 1)\nnot (1 >= f32)\nnot (1 >= f64)\nnot (1 >= i)\nnot (1 >= i32)\nnot (1 >= i64)\nnot (1 in array)\nnot (1 not in array)\nnot (add != add)\nnot (add != nil)\nnot (add == div)\nnot (add == nil)\nnot (array != array)\nnot (array != list)\nnot (array != nil)\nnot (array == array)\nnot (array == list)\nnot (array == nil)\nnot (array[i32] > i64)\nnot (div != add)\nnot (div != div)\nnot (div != nil)\nnot (div == add)\nnot (div == div)\nnot (div == nil)\nnot (f32 != 0.5)\nnot (f32 != 1)\nnot (f32 != f32)\nnot (f32 != f64)\nnot (f32 != i)\nnot (f32 != i32)\nnot (f32 != i64)\nnot (f32 != nil)\nnot (f32 < 0.5)\nnot (f32 < 1)\nnot (f32 < f32)\nnot (f32 < f64)\nnot (f32 < i)\nnot (f32 < i32)\nnot (f32 < i64)\nnot (f32 <= 0.5)\nnot (f32 <= 1)\nnot (f32 <= f64)\nnot (f32 <= i)\nnot (f32 <= i32)\nnot (f32 <= i64)\nnot (f32 == 0.5)\nnot (f32 == 1)\nnot (f32 == f32)\nnot (f32 == f64)\nnot (f32 == i)\nnot (f32 == i32)\nnot (f32 == i64)\nnot (f32 == nil)\nnot (f32 > 0.5)\nnot (f32 > 1)\nnot (f32 > f32)\nnot (f32 > f64)\nnot (f32 > i)\nnot (f32 > i32)\nnot (f32 > i64)\nnot (f32 >= 0.5)\nnot (f32 >= 1)\nnot (f32 >= f32)\nnot (f32 >= f64)\nnot (f32 >= i)\nnot (f32 >= i32)\nnot (f32 >= i64)\nnot (f32 in array)\nnot (f32 not in array)\nnot (f64 != 0.5)\nnot (f64 != 1)\nnot (f64 != f32)\nnot (f64 != f64)\nnot (f64 != i)\nnot (f64 != i32)\nnot (f64 != i64)\nnot (f64 != nil)\nnot (f64 < 0.5)\nnot (f64 < 1)\nnot (f64 < f32)\nnot (f64 < f64)\nnot (f64 < i32)\nnot (f64 < i64)\nnot (f64 <= -0.5)\nnot (f64 <= 0.5)\nnot (f64 <= 1)\nnot (f64 <= f32)\nnot (f64 <= f64)\nnot (f64 <= i)\nnot (f64 <= i32)\nnot (f64 <= i64)\nnot (f64 == 0.5)\nnot (f64 == 1)\nnot (f64 == f64)\nnot (f64 == i)\nnot (f64 == i32)\nnot (f64 == i64)\nnot (f64 == nil)\nnot (f64 > 0.5)\nnot (f64 > 1)\nnot (f64 > f32)\nnot (f64 > f64)\nnot (f64 > i)\nnot (f64 > i32)\nnot (f64 > i64)\nnot (f64 >= 0.5)\nnot (f64 >= 1)\nnot (f64 >= f32)\nnot (f64 >= f64)\nnot (f64 >= i)\nnot (f64 >= i32)\nnot (f64 >= i64)\nnot (f64 in array)\nnot (f64 not in array)\nnot (false != false)\nnot (false != nil)\nnot (false != ok)\nnot (false != true)\nnot (false && false)\nnot (false && ok)\nnot (false == nil)\nnot (false == ok)\nnot (false and false)\nnot (false and ok)\nnot (false and true)\nnot (false or false)\nnot (false or ok)\nnot (false or true)\nnot (false || false)\nnot (false || ok)\nnot (false || true)\nnot (findIndex(list, ok) != i ^ f64)\nnot (foo != foo)\nnot (foo != nil)\nnot (foo == foo)\nnot (foo == nil)\nnot (foo in list)\nnot (foo not in list)\nnot (greet != greet)\nnot (greet != nil)\nnot (greet == greet)\nnot (greet == nil)\nnot (half != half)\nnot (half != nil)\nnot (half == half)\nnot (half == nil)\nnot (i != 0.5)\nnot (i != 1)\nnot (i != f32)\nnot (i != f64)\nnot (i != i)\nnot (i != i32)\nnot (i != i64)\nnot (i != nil)\nnot (i < 0.5)\nnot (i < 1)\nnot (i < f32)\nnot (i < f64)\nnot (i < i)\nnot (i < i32)\nnot (i < i64)\nnot (i <= 0.5)\nnot (i <= 1)\nnot (i <= f32)\nnot (i <= f64)\nnot (i <= i)\nnot (i <= i32)\nnot (i <= i64)\nnot (i == 0.5)\nnot (i == 1)\nnot (i == ceil(f64))\nnot (i == f32)\nnot (i == f64)\nnot (i == i)\nnot (i == i32)\nnot (i == i64)\nnot (i == nil)\nnot (i > 0.5)\nnot (i > 1)\nnot (i > f32)\nnot (i > f64)\nnot (i > i)\nnot (i > i32)\nnot (i > i64)\nnot (i >= 0.5)\nnot (i >= 1)\nnot (i >= f32)\nnot (i >= f64)\nnot (i >= i)\nnot (i >= i32)\nnot (i >= i64)\nnot (i in array)\nnot (i not in array)\nnot (i32 != 0.5)\nnot (i32 != 1)\nnot (i32 != f32)\nnot (i32 != f64)\nnot (i32 != i)\nnot (i32 != i32)\nnot (i32 != i64)\nnot (i32 != nil)\nnot (i32 < 0.5)\nnot (i32 < 1)\nnot (i32 < f32 ** 0.5)\nnot (i32 < f32)\nnot (i32 < f64)\nnot (i32 < i)\nnot (i32 < i32)\nnot (i32 < i64)\nnot (i32 <= 0.5)\nnot (i32 <= 1)\nnot (i32 <= f32)\nnot (i32 <= f64)\nnot (i32 <= i)\nnot (i32 <= i32)\nnot (i32 <= i64)\nnot (i32 == -i)\nnot (i32 == 0.5)\nnot (i32 == 1)\nnot (i32 == f32)\nnot (i32 == f64)\nnot (i32 == i)\nnot (i32 == i32)\nnot (i32 == i64)\nnot (i32 == nil)\nnot (i32 > 0.5)\nnot (i32 > 1)\nnot (i32 > f32)\nnot (i32 > f64)\nnot (i32 > i)\nnot (i32 > i32)\nnot (i32 > i64)\nnot (i32 >= 0.5)\nnot (i32 >= 1)\nnot (i32 >= f32)\nnot (i32 >= f64)\nnot (i32 >= i)\nnot (i32 >= i32)\nnot (i32 >= i64)\nnot (i32 in array)\nnot (i32 not in array)\nnot (i64 != 0.5)\nnot (i64 != 1)\nnot (i64 != f32)\nnot (i64 != f64)\nnot (i64 != i)\nnot (i64 != i32)\nnot (i64 != i64)\nnot (i64 != nil)\nnot (i64 < 0.5)\nnot (i64 < 1)\nnot (i64 < f32)\nnot (i64 < f64)\nnot (i64 < i)\nnot (i64 < i32)\nnot (i64 < i64)\nnot (i64 <= 0.5)\nnot (i64 <= 1)\nnot (i64 <= f32)\n```\n\n----------------------------------------\n\nTITLE: Count Function Examples in Expr\nDESCRIPTION: Demonstrates the use of the `count` function with arrays and lists, applying different conditions and types. Includes examples with string comparison, membership checking and boolean operators.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_25\n\nLANGUAGE: Expr\nCODE:\n```\ncount([\"bar\", score, i], 1 != #)\ncount([\"bar\"], # startsWith #)\ncount([0.5], ok)\ncount([greet], ok)\ncount([i32], f32 != #)\ncount([list, 0.5], # not in list)\ncount([nil], ok)\ncount(array, !ok)\ncount(array, !true)\ncount(array, \"bar\" <= \"bar\")\n```\n\n----------------------------------------\n\nTITLE: Less Than or Equal Comparisons with 'i' in Expr\nDESCRIPTION: Demonstrates less than or equal comparisons using '<=' operator with the variable 'i', involving various data types, environment variables, functions, and array access using the safe navigation operator.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_155\n\nLANGUAGE: Expr\nCODE:\n```\ni <= $env.f64\ni <= $env.i\ni <= $env?.f64\ni <= $env?.i\ni <= 0 && $env\ni <= 0 * i\ni <= 0 < $env\ni <= 0 and $env\ni <= 0 or false\ni <= 1 / 1\ni <= 1 >= 1\ni <= 1 || ok\ni <= 1.0 && ok\ni <= 1.0 * i\ni <= 1.0 < 0\ni <= 1.0 <= 1\ni <= 1.0 or ok\ni <= 1.0 || $env.ok\ni <= bitnot(1)\ni <= ceil(1.0)\ni <= f64\ni <= f64 < 1.0\ni <= f64 > $env\ni <= f64 in $env?.String\ni <= floor(1)\ni <= i\ni <= i + i\ni <= i / 1\ni <= i <= 1\ni <= i == nil\ni <= i >= i\ni <= i ?: add\ni <= i ^ i\ni <= mean(1.0)\ni <= median(1.0)\n```\n\n----------------------------------------\n\nTITLE: Expr groupBy with numerical constants\nDESCRIPTION: Demonstrates grouping with numerical constants, showcasing simple arithmetic, equality, and property access using safe navigation.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_140\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(list, 0 + 1)\ngroupBy(list, 0 == 1)\ngroupBy(list, 0).String\ngroupBy(list, 0).f64\ngroupBy(list, 0).foo\ngroupBy(list, 0).list\ngroupBy(list, 0)?.Bar\ngroupBy(list, 0)?.[f64]\ngroupBy(list, 0)?.[i]\ngroupBy(list, 0)?.[str]\ngroupBy(list, 0)?.add\ngroupBy(list, 0)?.array\ngroupBy(list, 0)?.f64\ngroupBy(list, 0)?.foo\ngroupBy(list, 0)?.greet\ngroupBy(list, 0)?.i\ngroupBy(list, 0.1)\n```\n\n----------------------------------------\n\nTITLE: Checking Nil Values\nDESCRIPTION: This code snippet demonstrates how to check for nil values in the Expr language. It covers accessing properties of environment variables using both dot notation and bracket notation, including optional chaining.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_196\n\nLANGUAGE: Expr\nCODE:\n```\nnil != $env.i\nnil != $env.list\nnil != $env.ok\nnil != $env.str\nnil != $env?.Bar\nnil != $env?.String\nnil != $env?.[1.0 | first(nil)]\nnil != $env?.[Bar]\nnil != $env?.[String]\nnil != $env?.[foobar]\nnil != $env?.[greet(foobar)]\nnil != $env?.[str]\nnil != $env?.add\nnil != $env?.array\nnil != $env?.f64\nnil != $env?.foo\nnil != $env?.greet\nnil != $env?.i\nnil != $env?.list\nnil != $env?.ok\nnil != $env?.str\n```\n\n----------------------------------------\n\nTITLE: Expr groupBy with nested function calls\nDESCRIPTION: Illustrates usage of nested function calls like `filter` and `flatten` along with groupBy.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_134\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(filter($env, false), .ok.greet())\ngroupBy(flatten(array), #)\ngroupBy(flatten(list), #)\ngroupBy(groupBy(array, ok).i, #?.[ok][.f64:])\n```\n\n----------------------------------------\n\nTITLE: Variable `score` comparisons in Expr\nDESCRIPTION: These snippets demonstrate various comparisons involving the `score` variable. Comparisons include null checks, inequality and equality checks, conditional expressions, and membership tests in arrays and groupBy results.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_108\n\nLANGUAGE: Expr\nCODE:\n```\nscore\nscore != nil != ok\nscore != nil ? half : f64\nscore != nil or i32 > 0.5\nscore != nil || ok\nscore != score\nscore != score != ok\nscore != score ? i32 : i32\nscore == nil != nil\nscore == nil && ok\nscore == nil ? 0.5 : \"bar\"\nscore == score\nscore == score == true\nscore == score ? 0.5 : score\nscore in groupBy(list, #)?.array\nscore in sort(array)\n```\n\n----------------------------------------\n\nTITLE: Using the toPairs function in Expr\nDESCRIPTION: Demonstrates the usage of the toPairs function with various map expressions. This function transforms a map to an array of key-value pairs.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_119\n\nLANGUAGE: Expr\nCODE:\n```\ntoPairs(groupBy(array, # / #))\ntoPairs(groupBy(array, #))\ntoPairs(groupBy(array, 0.5))\ntoPairs(groupBy(array, 1))\ntoPairs(groupBy(array, false))\ntoPairs(groupBy(array, foo))\ntoPairs(groupBy(array, i))\ntoPairs(groupBy(array, i32))\ntoPairs(groupBy(array, ok))\ntoPairs(groupBy(array, true))\ntoPairs(groupBy(list, #))\ntoPairs(groupBy(list, 1))\ntoPairs(groupBy(list, f32))\ntoPairs(groupBy(list, i))\ntoPairs(groupBy(list, ok))\ntoPairs({\"bar\": f32})\ntoPairs({\"foo\": i32, \"bar\": score})\ntoPairs({\"foo\": nil})\n```\n\n----------------------------------------\n\nTITLE: Complex List Access and Function Interactions - Expr\nDESCRIPTION: This snippet showcases more complex scenarios involving the `get` function. It combines list access with various functions like `int`, `max`, `min`, `reduce`, `score`, `take`, `map`, `sort`, and conditional expressions. It demonstrates how to access elements in lists after applying complex transformations and function calls, highlighting the powerful capabilities of the Expr language for data manipulation.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_63\n\nLANGUAGE: Expr\nCODE:\n```\nget(list, int(1))\nget(list, max(i32))\nget(list, min(i32))\nget(list, min(i64))\nget(list, ok ? 0.5 : \"foo\")\nget(list, reduce(list, i64))\nget(list, score(1))\nget(list, score(i))\nget(list, true ? i : i32)\nget(list[i64:1], i)\nget(map(array, #), i)\nget(map(array, #), i32)\nget(map(array, #), i64)\nget(map(array, add), i32)\nget(map(array, array), i)\nget(map(array, greet), i64)\nget(map(array, half), i64)\nget(map(list, \"foo\"), i64)\nget(map(list, #), i)\nget(map(list, #), i64)\nget(map(list, 1), i32)\nget(map(list, array), i)\nget(map(list, i32), i64)\nget(map(list, i64), i64)\nget(ok ? 1 : \"bar\", f32)\nget(ok ? add : f32, array)\nget(ok ? f64 : div, i64)\nget(ok ? false : list, f32 > i)\nget(ok ? half : i32, i)\nget(ok ? half : ok, f64)\nget(ok ? i : 0.5, half)\nget(ok ? i32 : half, f64)\nget(ok ? i64 : foo, f32)\nget(ok ? list : i32, f32)\nget(ok ? ok : div, greet)\nget(ok ? score : f64, i)\nget(ok ? score : i64, foo)\nget(reduce(list, array), i32)\nget(sort(array), i32)\nget(take(list, i), i64)\nget(true ? \"bar\" : ok, score(i))\nget(true ? 0.5 : i32, array)\nget(true ? f32 : 0.5, ok)\nget(true ? false : foo, i64 > 0.5)\nget(true ? greet : i32, score)\nget(true ? half : f32, greet)\nget(true ? half : list, add)\nget(true ? i64 : greet, i32)\nget(true ? score : true, half)?.half\nget(true ? true : i, f64)\nget({\"foo\": foo, \"bar\": false}, type(i))\n```\n\n----------------------------------------\n\nTITLE: Expr groupBy with arithmetic and constants\nDESCRIPTION: Demonstrates grouping with simple arithmetic operations and property access, using safe navigation.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_141\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(list, 1 * i)\ngroupBy(list, 1).Bar\ngroupBy(list, 1).String\ngroupBy(list, 1).f64\ngroupBy(list, 1).foo\ngroupBy(list, 1).foobar\ngroupBy(list, 1).greet\ngroupBy(list, 1).str\ngroupBy(list, 1)?.Bar\ngroupBy(list, 1)?.String\ngroupBy(list, 1)?.[f64]\ngroupBy(list, 1)?.[foo]\ngroupBy(list, 1)?.[ok]\ngroupBy(list, 1)?.[str]\ngroupBy(list, 1)?.add\ngroupBy(list, 1)?.array\ngroupBy(list, 1)?.f64\ngroupBy(list, 1)?.greet\n```\n\n----------------------------------------\n\nTITLE: Optional Variable Access and Method Calls - Expr\nDESCRIPTION: This snippet demonstrates the usage of optional chaining (`?.`) when accessing properties and calling methods on the `foo` variable. It shows how to handle cases where `foo` might be `nil`, preventing errors when accessing its properties (`Bar`, `Qux`, `String`). It also demonstrates the use of functions like `toJSON`, `string`, and `upper` within method calls.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_57\n\nLANGUAGE: Expr\nCODE:\n```\nfoo?.Bar\nfoo?.Bar != foo?.Bar\nfoo?.Bar in foo\nfoo?.Bar matches toJSON(f64)\nfoo?.Bar not endsWith foo.Bar\nfoo?.Bar not endsWith toJSON(foo)\nfoo?.Qux\nfoo?.Qux(foo?.Bar)\nfoo?.Qux(string(i32))\nfoo?.Qux(toJSON(1))\nfoo?.Qux(toJSON(i32))\nfoo?.Qux(upper(\"bar\"))\nfoo?.String\nfoo?.String()\nfoo?.String() contains string(\"foo\")\n```\n\n----------------------------------------\n\nTITLE: Defining a Decimal Type\nDESCRIPTION: Defines a custom `Decimal` struct with a single `Value` field (integer). This is used in the advanced patching example to demonstrate transforming operations on custom types.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/patch.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ntype Decimal struct {\n    Value int\n}\n```\n\n----------------------------------------\n\nTITLE: Sorting Expressions in Expr\nDESCRIPTION: This snippet demonstrates various uses of the 'sort' function in the Expr language, showcasing its ability to sort ranges, arrays, and the results of other functions like 'groupBy' and 'map'.  It highlights different data types and potential comparison scenarios.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_111\n\nLANGUAGE: Expr\nCODE:\n```\nsort(1 .. 1)\nsort(1 .. i)\nsort([add])\nsort([greet])\nsort([half])\nsort([i64])\nsort([list])\nsort(array)\nsort(array) == array\nsort(false ? greet : array)\nsort(groupBy(list, #)?.foo)\nsort(groupBy(list, i32).half)\nsort(i .. i32)\nsort(i .. i64)\nsort(i32 .. 1)\nsort(i64 .. 1)\nsort(map(array, \"bar\"))\nsort(map(array, \"foo\"))\nsort(map(array, #))\nsort(map(array, 1))\nsort(map(array, f64))\nsort(map(array, i))\nsort(map(array, i64))\nsort(reduce(array, array))\n```\n\n----------------------------------------\n\nTITLE: Expr: More complex type checking examples with float values\nDESCRIPTION: This snippet continues with examples using float values with various operations and optional member access using type().\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_263\n\nLANGUAGE: Expr\nCODE:\n```\ntype(1.0 != $env)\ntype(1.0 != $env?.i)\ntype(1.0 != 1)\ntype(1.0 != 1.0)\ntype(1.0 != f64)\ntype(1.0 != i)\ntype(1.0 != nil)\ntype(1.0 * 0)\ntype(1.0 * 1)\ntype(1.0 * 1.0)\ntype(1.0 * f64)\ntype(1.0 * i)\ntype(1.0 ** 1)\ntype(1.0 ** 1.0)\ntype(1.0 ** f64)\n\n```\n\n----------------------------------------\n\nTITLE: Logical NOT with Other Operations (Expr)\nDESCRIPTION: This snippet includes logical NOT operator (!) and other operations like mathematical comparisons, string functions (hasPrefix, len), reduce function calls, short-circuiting (||, or), and checks for existence in lists/arrays.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_7\n\nLANGUAGE: Expr\nCODE:\n```\n!(len(\"bar\") <= i)\n!(add != add)\n!(add != div)\n!(add == add)\n!(add == div)\n!(array != array)\n!(array == array)\n!(div != div)\n!(div == div)\n!(f32 != f32)\n!(f32 != f64)\n!(f32 == f32)\n!(f64 != 0.5)\n!(f64 != 1)\n!(f64 != f32)\n!(f64 != f64)\n!(f64 == 0.5)\n!(f64 == 1)\n!(f64 == f32)\n!(f64 == f64)\n!(false && 0.5 == 1)\n!(false or 0.5 > i32)\n!(false || ok)\n!(foo != foo)\n!(foo == foo)\n!(foo == reduce(list, #))\n!(foo in list)\n!(foo not in list)\n!(greet != greet)\n!(greet == greet)\n!(half != half)\n!(half == half)\n!(i64 >= 1 * i64)\n!(i in array)\n!(i not in array)\n!(i32 in array)\n!(i32 not in array)\n!(i64 in array)\n!(len(\"bar\") <= i)\n!(nil != add)\n!(nil != array)\n!(nil != div)\n!(nil != f32)\n!(nil != f64)\n!(nil != false)\n!(nil != foo)\n!(nil != greet)\n!(nil != half)\n!(nil != i)\n!(nil != i32)\n!(nil != i64)\n!(nil != list)\n!(nil != nil)\n!(nil != ok)\n!(nil != score)\n!(nil != true)\n!(nil == add)\n!(nil == array)\n!(nil == div)\n!(nil == f32)\n!(nil == f64)\n!(nil == false)\n!(nil == foo)\n!(nil == greet)\n!(nil == half)\n!(nil == i)\n!(nil == i32)\n!(nil == i64)\n!(nil == list)\n!(nil == nil)\n!(nil == ok)\n!(nil == score)\n!(nil == true)\n!false or ok\n!hasPrefix(\"foo\", \"foo\")\n!not (\"bar\" == nil)\n!not (1 <= 1)\n!not (1 > 0.5)\n!not (greet == nil)\n!not (i32 == f64)\n!not false\n!not ok\n!not true\n!ok or f32 < i64\n!ok or false or false\n```\n\n----------------------------------------\n\nTITLE: Expr groupBy with range and map operations\nDESCRIPTION: Shows examples using ranges (i..i) and map operations within the groupBy function, highlighting property access.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_135\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(i..i, #)\ngroupBy(list | map(#), f64)\ngroupBy(list | map(#), ok)\ngroupBy(list | map(array), $env?.f64)\n```\n\n----------------------------------------\n\nTITLE: Bitwise XOR Operations in Expr\nDESCRIPTION: Illustrates use of the `bitxor` function with different data types and demonstrates precedence of operations involving bitwise XOR in Expr.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_23\n\nLANGUAGE: Expr\nCODE:\n```\nbitxor(-i, i64)\nbitxor(1, i) * i\nbitxor(bitnot(1), -i)\nbitxor(i, i32)\nbitxor(i, i64)\nbitxor(i32, 1) > i64\nbitxor(i32, i)\nbitxor(i32, i) ** f64\nbitxor(i32, i32)\nbitxor(i32, i64)\nbitxor(i32, i64) ** i32\nbitxor(i64, i)\nbitxor(i64, i32)\nbitxor(i64, i64)\nbitxor(score(1), i)\n```\n\n----------------------------------------\n\nTITLE: Mapping with ternary expressions and numeric literals in Expr\nDESCRIPTION: Demonstrates the use of ternary expressions and numeric literals within a map function. The code transforms the source data by evaluating a conditional expression or using numbers and functions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_182\n\nLANGUAGE: Expr\nCODE:\n```\nmap(false ? foo : list, $env.ok)\n```\n\n----------------------------------------\n\nTITLE: Expr: Determining variable types\nDESCRIPTION: This snippet uses the 'type()' function to determine the data type of various expressions and variables in the Expr language. It demonstrates how to check the type of variables, arithmetic operations, and conditional results.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_257\n\nLANGUAGE: Expr\nCODE:\n```\ntype($env != $env)\ntype($env != 0)\ntype($env != add)\ntype($env != f64)\ntype($env != foo)\ntype($env != greet)\ntype($env != list)\ntype($env != nil)\ntype($env && true)\ntype($env == $env)\ntype($env == 1)\ntype($env == 1.0)\ntype($env == add)\ntype($env == f64)\ntype($env == false)\ntype($env == foo)\ntype($env == nil)\ntype($env and true)\ntype($env in array)\ntype($env in list)\ntype($env not in array)\ntype($env not in list)\ntype($env or true)\ntype($env | all(true))\ntype($env | any(ok))\ntype($env | any(true))\ntype($env | count(ok))\ntype($env | findLastIndex(ok))\ntype($env | map(#index))\ntype($env | map(foo))\ntype($env | none(true))\ntype($env | one(false))\ntype($env | sum(0))\ntype($env | sum(1.0))\ntype($env || false)\n\n```\n\n----------------------------------------\n\nTITLE: Array Non-Membership Check\nDESCRIPTION: Checks if the array is NOT a member of the $env?.Bar. Returns a boolean indicating non-membership.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_43\n\nLANGUAGE: Expr\nCODE:\n```\narray not in $env?.Bar\n```\n\n----------------------------------------\n\nTITLE: Boolean AND with 'ok'\nDESCRIPTION: This code snippet demonstrates the use of the boolean AND operator in conjunction with the 'ok' variable.  It includes access to environment variables and their properties, demonstrating conditional checks.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_203\n\nLANGUAGE: Expr\nCODE:\n```\nok and $env != 0\nok and $env != 1.0\nok and $env != false\nok and $env != list\nok and $env == list\nok and $env in array\nok and $env.ok\nok and $env?.Bar\nok and $env?.Bar?.foobar\nok and $env?.String\nok and $env?.[Bar]\nok and $env?.[Bar]?.array\nok and $env?.[String]\n```\n\n----------------------------------------\n\nTITLE: Checking Variable Existence in $env in Expr\nDESCRIPTION: Shows how to check if a variable is defined in the `$env` map using the `in` operator.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_17\n\nLANGUAGE: expr\nCODE:\n```\n'foo' in $env\n```\n\n----------------------------------------\n\nTITLE: Array None\nDESCRIPTION: Checks if none of the elements in the array satisfy the condition that they are not equal to the environment variable. This operation filters and returns a boolean.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_59\n\nLANGUAGE: Expr\nCODE:\n```\narray | none(# != $env)\n```\n\n----------------------------------------\n\nTITLE: Membership Checks with 'in' and 'not in'\nDESCRIPTION: This snippet demonstrates how to use the 'in' and 'not in' operators to check for the membership of 'nil' within arrays and lists, accessing properties through various notations, including optional chaining and function calls.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_199\n\nLANGUAGE: Expr\nCODE:\n```\nnil in $env.array\nnil in $env.list\nnil in $env?.Bar\nnil in $env?.String\nnil in $env?.[Bar]\nnil in $env?.[String]\nnil in $env?.array\nnil in $env?.foobar?.i(false)\nnil in $env?.list\nnil in list && ok\nnil in list and $env == foo\nnil in list or ok\nnil not in $env or ok\nnil not in $env || 0 <= $env\nnil not in $env.array\nnil not in $env.list\nnil not in $env?.$env?.ok\nnil not in $env?.Bar\nnil not in $env?.Bar?.str\nnil not in $env?.String\nnil not in $env?.String?.greet\nnil not in $env?.[Bar]\nnil not in $env?.[String]\nnil not in $env?.[foobar]\nnil not in $env?.array\nnil not in $env?.foobar?.[list]\nnil not in $env?.foobar?.add(nil, f64)\nnil not in $env?.list\nnil not in array ?: i\nnil not in list[i:]\n```\n\n----------------------------------------\n\nTITLE: Expr f64 Sequencing Operations\nDESCRIPTION: This snippet includes expressions that use sequencing (;) with f64. It demonstrates how f64 can be followed by environment variables and other identifiers, primarily for the purpose of potentially evaluating expressions sequentially, or for their side effects.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_91\n\nLANGUAGE: Expr\nCODE:\n```\nf64; $env?.list\nf64; f64\nf64; foo?.String\nf64; i\nf64; str\n```\n\n----------------------------------------\n\nTITLE: Arithmetic and Boolean Comparisons with Nil\nDESCRIPTION: This snippet illustrates how nil comparisons interact with arithmetic operations, boolean operators, and conditional checks within the Expr language. It covers various operators and access patterns, including optional chaining.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_197\n\nLANGUAGE: Expr\nCODE:\n```\nnil != 0 - i\nnil != 0 / f64\nnil != 0 ?: array\nnil != 0 ^ $env?.i\nnil != 1 % i\nnil != 1.0 ?: reduce($env, #.String, true)\nnil != 1.0 ^ f64\nnil != 1.0 or 1.0 == 1\nnil != add and ok\nnil != array?.[i]\nnil != f64 / f64 && ok\nnil != f64 or i == i\nnil != false || $env > $env\nnil != foo ?: greet\nnil != foo ?: list\nnil != foo.Bar\nnil != foo.String\nnil != foo.String()\nnil != foo?.Bar\nnil != foo?.String\nnil != foo?.String()\nnil != greet ?: i\nnil != list?.[i]\nnil != list?.[i]?.Bar\nnil != list?.[i]?.String\nnil != list[:]\nnil != nil && $env?.[array]\nnil != ok || abs($env)\nnil != str && get($env, nil)\nnil != true || $env == 1.0\n```\n\n----------------------------------------\n\nTITLE: Expr Object Access\nDESCRIPTION: Demonstrates accessing properties of an object in the expr language.  The expression attempts to access the `Bar` property of an object with a `foo` property. This highlights basic object property access.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_143\n\nLANGUAGE: expr\nCODE:\n```\n{\"foo\": ok}.Bar\n```\n\n----------------------------------------\n\nTITLE: Complex Object and Function Calls\nDESCRIPTION: Demonstrates complex object access, function calls, and method calls, including nested calls and property access. These expressions can become unwieldy and difficult to read, showing potential limitations in syntax.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_17\n\nLANGUAGE: EXPR\nCODE:\n```\n1 == $env?.Bar?.Bar\n1 == $env?.String\n1 == $env?.String?.[greet]\n1 <= 1 or none($env, $env)\n1 == $env?.[Bar]?.foo\n1 == $env?.[foobar?.[f64]]\n1.0 != $env?.Bar?.[array]\n1.0 != $env?.Bar?.str\n1.0 != $env?.String?.[i]\n1.0 != $env?.String?.[ok]\n1.0 != $env?.[foobar?.add($env)]?.greet\n1.0 != $env?.[foobar?.add]\n1.0 >= 1 or none($env, $env)\n1.0 >= 1.0 == {foo: $env, foo: $env}.foo\n1.0 in $env?.String?.f64\n1.0 in $env?.[Bar]?.[add]\n1.0 in $env?.[Bar]?.array\n1.0 in $env?.[String]?.[i]\n1.0 in $env?.[String]?.[str]\n1.0 in $env?.[foobar?.[foo]]\n1.0 not in $env?.Bar?.[i]\n1.0 not in $env?.String?.[array]\n1.0 not in $env?.[foobar?.str]\n1.0 not in $env?.nil?.[list].array()\n[$env.foo?.String()]\n```\n\n----------------------------------------\n\nTITLE: Using the mean function in Expr\nDESCRIPTION: This snippet demonstrates various ways to use the `mean` function with different data types and operations. It covers ranges, arrays, map and filter operations, showcasing the functionality of calculating the mean in the Expr language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_82\n\nLANGUAGE: expr\nCODE:\n```\nmean(1 .. 1)\nmean(1 .. i)\nmean([f64, 0.5])\nmean([i])\nmean(array)\nmean(array) * i\nmean(array) + i\nmean(array) - min(i)\nmean(array) / i\nmean(array) / i64\nmean(array) < f32\nmean(array) < f64\nmean(array) <= i64\nmean(array) > f32\nmean(array) >= f32\nmean(array) >= i64\nmean(array) ^ i\nmean(array) ^ i32\nmean(filter(array, true))\nmean(groupBy(array, i64).score)\nmean(i .. 1)\nmean(i .. i)\nmean(map(array, #))\nmean(map(array, -#))\nmean(map(array, f32))\nmean(map(array, i))\nmean(map(array, i32))\nmean(map(list, 1))\nmean(map(list, f32))\nmean(map(list, i))\nmean(map(list, i32))\nmean(sort(array))\n```\n\n----------------------------------------\n\nTITLE: Expr groupBy with environment variables\nDESCRIPTION: Illustrates grouping based on comparisons with environment variables ($env) and accessing properties of these variables using both direct access and safe navigation (?.).\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_123\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(array, $env == foo)\ngroupBy(array, $env | sum(1.0))\ngroupBy(array, $env.f64)\ngroupBy(array, $env.foo)\ngroupBy(array, $env.ok)\ngroupBy(array, $env.str)\ngroupBy(array, $env?.[foobar])\ngroupBy(array, $env?.[str])\ngroupBy(array, $env?.f64)\ngroupBy(array, $env?.i)\ngroupBy(array, $env?.str)\n```\n\n----------------------------------------\n\nTITLE: Inequality Comparisons with 'i' in Expr\nDESCRIPTION: Demonstrates inequality comparisons involving the variable 'i' with various data types, variables (including '$env'), conditional property accessors, and arithmetic operations. The snippet includes a combination of '!=', '||', '&&', and safe navigation operators.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_146\n\nLANGUAGE: Expr\nCODE:\n```\ni != $env != $env\ni != $env != true\ni != $env || $env\ni != $env.f64\ni != $env.i\ni != $env?.$env?.list(add, nil)\ni != $env?.Bar\ni != $env?.Bar?.[f64]\ni != $env?.String\ni != $env?.[Bar]\ni != $env?.[Bar]?.[i]\ni != $env?.[String]\ni != $env?.[String]?.[array]\ni != $env?.[str]\ni != $env?.f64\ni != $env?.i\ni != $env?.true\ni != 0 != $env\ni != 0 ^ 0\ni != 0 or true\ni != 1 / 1\ni != 1 or ok\ni != 1.0 * 1.0\ni != 1.0 * array?.[i]\ni != 1.0 ** 0\ni != 1.0 + 1.0\ni != 1.0 + i\ni != 1.0 - 1.0\ni != 1.0 == ok\ni != 1.0 || $env\ni != abs(i)\ni != array?.[i]\ni != f64\ni != f64 && false\ni != f64 + 1.0\ni != float(1.0)\ni != floor(0)\ni != floor(1)\ni != i\ni != i != $env.ok\ni != i * f64\ni != last($env)\ni != max(1.0)\ni != mean(f64)\ni != median(1.0)\ni != min($env)\ni != min(i)\ni != nil != $env\ni != nil != ok\ni != sum(array)\n```\n\n----------------------------------------\n\nTITLE: Evaluating Types with trimPrefix and type function - Expr\nDESCRIPTION: These expressions use the `trimPrefix` function in conjunction with the `type` function to determine the data type of various values and expressions after a prefix is potentially removed. The `type` function returns the data type as a string, and `trimPrefix` removes a specified prefix from the input string if it exists.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_122\n\nLANGUAGE: expr\nCODE:\n```\ntrimPrefix(type(\"bar\"))\ntrimPrefix(type(0.5))\ntrimPrefix(type(1))\ntrimPrefix(type(array))\ntrimPrefix(type(f32))\ntrimPrefix(type(f64))\ntrimPrefix(type(greet))\ntrimPrefix(type(half))\ntrimPrefix(type(i))\ntrimPrefix(type(i32))\ntrimPrefix(type(i64))\ntrimPrefix(type(list))\ntrimPrefix(type(nil))\ntrimPrefix(type(ok))\ntrimPrefix(type(true))\n```\n\n----------------------------------------\n\nTITLE: Expr Ternary Operator with Boolean False\nDESCRIPTION: This snippet focuses on the use of the ternary operator with 'false' as the condition. The expressions show how different values and environment variables are selected based on whether the initial 'false' condition is met. It illustrates the operator's behavior and flexibility in choosing between alternatives, demonstrating Expr's conditional evaluation capabilities.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_95\n\nLANGUAGE: Expr\nCODE:\n```\nfalse ? $env : $env.greet\nfalse ? $env : $env.list\nfalse ? $env : $env?.[str]\nfalse ? $env : $env?.add\nfalse ? $env : foo.Bar\nfalse ? $env : foo?.Bar\nfalse ? 0 : array?.[i]\nfalse ? 0 : foo?.Bar\nfalse ? 1 : $env?.f64\nfalse ? 1 : $env?.i\nfalse ? 1 : $env?.ok\nfalse ? 1.0 : $env.greet\nfalse ? 1.0 : $env?.[Bar]\nfalse ? 1.0 : $env?.greet\nfalse ? 1.0 : $env?.list\nfalse ? 1.0 : $env?.ok\nfalse ? 1.0 : foo?.Bar\nfalse ? 1.0 : foo?.String()\nfalse ? 1.0 : str contains str\nfalse ? add : $env.array\nfalse ? add : list | reduce(true)\nfalse ? add : nil not in array\nfalse ? array : $env.f64\nfalse ? array : $env?.f64\nfalse ? array : $env?.list\nfalse ? array : 1 * f64\nfalse ? array : nil != str\nfalse ? f64 : $env.array\nfalse ? f64 : $env.f64\nfalse ? f64 : $env.list\nfalse ? f64 : $env.ok\nfalse ? f64 : $env?.[String]\nfalse ? f64 : $env?.greet\nfalse ? f64 : $env?.str\nfalse ? f64 : list | groupBy(#)\nfalse ? false : $env?.list\nfalse ? foo : $env?.String\nfalse ? foo : $env?.[Bar]\nfalse ? foo : $env?.[String]\nfalse ? foo : $env?.add\nfalse ? foo : $env?.f64\nfalse ? foo : $env?.i\nfalse ? foo : $env?.ok\nfalse ? foo : array | map(0)\nfalse ? foo : foo.Bar\nfalse ? foo : foo?.Bar\nfalse ? foo : foo?.String\nfalse ? greet : $env | map(1.0)\n```\n\n----------------------------------------\n\nTITLE: Expr f64 Greater Than or Equal Operations\nDESCRIPTION: This snippet showcases the greater than or equal to operator (>=) used with 'f64' numbers in the Expr language. It covers numerous scenarios including comparisons with environment variables, literals, results of conditional expressions, and function outputs. This demonstrates the flexibility of the language in handling comparisons with varying data types and within complex expressions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_86\n\nLANGUAGE: Expr\nCODE:\n```\nf64 >= $env && false\nf64 >= $env || true\nf64 >= $env.f64\nf64 >= $env.i\nf64 >= $env?.f64\nf64 >= $env?.i\nf64 >= 0 != $env\nf64 >= 0 >= f64\nf64 >= 0 ? greet : 1\nf64 >= 0 || ok\nf64 >= 1 != true\nf64 >= 1 < i\nf64 >= 1 ? 0 : foo\nf64 >= 1 ? foo : str\nf64 >= 1.0 != nil\nf64 >= 1.0 ** i < f64\nf64 >= 1.0 + 1.0\nf64 >= 1.0 > i\nf64 >= 1.0 ?: list\nf64 >= 1.0 and $env in str\nf64 >= 1.0 and $env?.[str]\nf64 >= array?.[i]\nf64 >= bitnot(i)\nf64 >= ceil(0)\nf64 >= ceil(i)\nf64 >= f64\nf64 >= f64 == ok\nf64 >= f64 ^ f64\nf64 >= float(0)\nf64 >= float(1)\nf64 >= float(1.0)\nf64 >= i\nf64 >= i != $env\nf64 >= i * f64\nf64 >= i + 1.0\nf64 >= mean(1)\nf64 >= mean(1.0)\nf64 >= sum(array)\n```\n\n----------------------------------------\n\nTITLE: Subtraction Operations with 'i' in Expr\nDESCRIPTION: Demonstrates subtraction operations involving the variable 'i' with various data types, variables, function calls, and expressions. Includes examples using the safe navigation operator '?.' and array indexing.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_151\n\nLANGUAGE: Expr\nCODE:\n```\ni - $env and false and ok\ni - $env.f64\ni - $env.i\ni - $env?.f64\ni - $env?.i\ni - 0 ** f64\ni - 0 ** i\ni - 0 | mean(1.0)\ni - 1 ** 1.0 ^ 1\ni - 1 / f64\ni - 1 ^ f64\ni - 1.0 != $env?.String\ni - 1.0 != 1.0\ni - 1.0 ** i\ni - 1.0 + 1\ni - 1.0 - 1.0\ni - 1.0 < f64\ni - 1.0 == $env\ni - 1.0 ^ i\ni - 1.0 not in array\ni - array?.[i]\ni - ceil(1)\ni - ceil(1.0)\ni - f64\ni - f64 != 1\ni - f64 != 1.0\ni - f64 >= f64\ni - f64 >= i\ni - f64 ^ 1.0 == 0\ni - float(f64)\ni - floor(1.0)\ni - floor(f64)\ni - i\ni - i != i\ni - i ** i\ni - i == 1.0\ni - i >= i\ni - i not in $env?.String\ni - int(0)\ni - len(array)\ni - max(1.0)\ni - max(array)\ni - mean(1.0)\ni - reduce($env, #acc, i)\ni - reduce(array, #index)\n```\n\n----------------------------------------\n\nTITLE: String Uppercasing with Upper\nDESCRIPTION: These examples demonstrate the usage of the `upper` function in the Expr language. This function converts a given string to uppercase. The snippets demonstrate various use cases including uppercasing string literals, the result of expressions, and nested function calls.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_266\n\nLANGUAGE: Expr\nCODE:\n```\nupper($env | reduce(str, nil))\nupper($env.str)\nupper($env?.[str])\nupper($env?.str)\nupper(array | reduce(str, list))\nupper(foo.Bar)\nupper(foo.String())\nupper(foo?.Bar)\nupper(foo?.String())\nupper(greet(str))\nupper(list | reduce(#.Bar))\nupper(lower(str))\nupper(str)\nupper(str) in foo\nupper(str) matches str\nupper(str) not endsWith str\nupper(str) not in foo\nupper(str[1:])\nupper(str[:0])\nupper(string($env))\nupper(string(0))\nupper(string(1))\nupper(string(add))\nupper(string(array))\nupper(string(f64))\nupper(string(foo))\nupper(string(foo.Bar))\nupper(string(i))\nupper(string(list))\nupper(string(nil))\nupper(string(ok))\nupper(string(str))\nupper(string(true))\nupper(toBase64(str))\nupper(toJSON(1.0))\nupper(toJSON(array))\nupper(toJSON(f64))\nupper(toJSON(false))\nupper(toJSON(foo))\nupper(toJSON(i))\nupper(toJSON(list))\nupper(toJSON(nil))\nupper(toJSON(ok))\nupper(toJSON(str))\nupper(toJSON(true))\nupper(trim(str))\nupper(trimPrefix(str))\nupper(type(0))\nupper(type(1))\nupper(type(1.0))\nupper(type(add))\nupper(type(array))\nupper(type(f64))\nupper(type(false))\nupper(type(foo))\nupper(type(greet))\nupper(type(list))\nupper(type(nil))\nupper(type(ok))\nupper(type(str))\nupper(type(true))\nupper(upper(str))\n```\n\n----------------------------------------\n\nTITLE: Object Values\nDESCRIPTION: Demonstrates how to extract the values from an object using the `values` function. It operates on the `$env` variable, which is assumed to be an object, to validate the object value extraction.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_29\n\nLANGUAGE: Expr\nCODE:\n```\n[values($env)]\n```\n\n----------------------------------------\n\nTITLE: Exponentiation Operator with i64 Type\nDESCRIPTION: This snippet demonstrates the exponentiation operator (`^`) with integer (i64) operands and other data types. It covers various combinations of integer, float (f32, f64), and other integer types (i32).  The goal is to test type promotion and operator precedence within the Expr language's interpreter.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_66\n\nLANGUAGE: expr\nCODE:\n```\ni64 ^ (i64 + 0.5)\ni64 ^ (i64 + 1)\ni64 ^ (i64 - f32)\ni64 ^ -0.5\ni64 ^ -1\ni64 ^ -f32\ni64 ^ -i64\ni64 ^ 0.5 != i64\ni64 ^ 0.5 ** 0.5\ni64 ^ 0.5 / f32\ni64 ^ 0.5 <= i64\ni64 ^ 0.5 == i\ni64 ^ 0.5 ^ f32\ni64 ^ 0.5 ^ i64\ni64 ^ 1 * i64\ni64 ^ 1 * round(0.5)\ni64 ^ 1 ** f64\ni64 ^ 1 ** i32\ni64 ^ 1 - f32\ni64 ^ 1 < f64\ni64 ^ 1 >= f32\ni64 ^ 1 >= half(1)\ni64 ^ 1 ^ f32\ni64 ^ 1 ^ i32\ni64 ^ abs(1)\ni64 ^ array[i]\ni64 ^ f32\ni64 ^ f32 * i32\ni64 ^ f32 ** f64\ni64 ^ f32 - f64\ni64 ^ f32 / i - i32\ni64 ^ f32 < f32\ni64 ^ f32 <= i64\ni64 ^ f32 ^ 1\ni64 ^ f64\ni64 ^ f64 * i\ni64 ^ f64 ** 1\ni64 ^ f64 > i64\ni64 ^ f64 ^ f32\ni64 ^ float(i32)\ni64 ^ floor(i32)\ni64 ^ floor(i64)\ni64 ^ half(0.5)\ni64 ^ half(1)\ni64 ^ i\ni64 ^ i * i\ni64 ^ i ** i32\ni64 ^ i + i % 1\ni64 ^ i + i64\ni64 ^ i - f32 ^ 1\ni64 ^ i - f64\ni64 ^ i / i\ni64 ^ i < f32\ni64 ^ i ^ i32\ni64 ^ i32\ni64 ^ i32 * i\ni64 ^ i32 + i32\ni64 ^ i32 + i64\ni64 ^ i64\ni64 ^ i64 * i64\ni64 ^ i64 + i\ni64 ^ i64 == i64\ni64 ^ i64 ^ 1\ni64 ^ i64 in array\ni64 ^ int(1)\ni64 ^ max(0.5)\ni64 ^ reduce(array, #)\ni64 ^ round(i64)\ni64 ^ score(1)\n```\n\n----------------------------------------\n\nTITLE: List Indexing in Expr\nDESCRIPTION: These expressions demonstrate various list indexing operations in Expr. They include accessing elements by constant indices, variable indices (i, i32, i64), calculated indices (1 - 1, i * i64), and slices (i32:i32, i:i64). It also covers checking if elements at specific indices are in a list, accessing properties of elements at those indices (Bar, Qux, String), using the safe navigation operator '?', and using `int()` function calls within the index.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_76\n\nLANGUAGE: Expr\nCODE:\n```\nlist[-1]\nlist[-i32]\nlist[-i64]\nlist[-i]\nlist[1 - 1]\nlist[1] not in list\nlist[1].Bar\nlist[1].Qux\nlist[1].String\nlist[1].String()\nlist[1]?.Bar\nlist[1]?.Qux\nlist[1]?.String\nlist[1]?.String()\nlist[bitnot(i)]\nlist[bitshr(i32, i32)]\nlist[findIndex(array, true)]\nlist[first(array)]\nlist[i * i64]\nlist[i32:i32]\nlist[i32:i]\nlist[i32]\nlist[i32] in list\nlist[i32].Bar\nlist[i32].Qux\nlist[i32].String\nlist[i32]?.Bar\nlist[i32]?.Qux\nlist[i32]?.String\nlist[i32]?.String()\nlist[i64:i32 - i]\nlist[i64:i64]\nlist[i64]\nlist[i64] in list\nlist[i64].Bar\nlist[i64].Qux\nlist[i64].String\nlist[i64]?.Bar\nlist[i64]?.Qux\nlist[i64]?.String\nlist[i:i32]\nlist[i:i64]\nlist[i:i64] == nil != nil\nlist[i:i]\nlist[i]\nlist[i].Bar\nlist[i].Qux\nlist[i].String\nlist[i].String()\nlist[i]?.Bar\nlist[i]?.Qux\nlist[i]?.String\nlist[i]?.String()\nlist[int(f32)]\nlist[int(f64)]\nlist[int(i)]\nlist[int(i64)]\nlist[max(i64, 1)]\nlist[min(i)]\nlist[min(i32)]\nlist[ok ? 1 : half]\nlist[score(1)]\nlist[score(i)]\n```\n\n----------------------------------------\n\nTITLE: Expr Reduce Function with Implicit Variable\nDESCRIPTION: Demonstrates using the `reduce` function with an implicit variable `#`. This is a shorthand to access elements during the reduction, often referring to the current element being processed.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_147\n\nLANGUAGE: expr\nCODE:\n```\n{\"foo\": reduce(array, #)}\n```\n\n----------------------------------------\n\nTITLE: Expr f64 Comparison Operations\nDESCRIPTION: This snippet demonstrates comparison operations applied to the 'f64' (double) type within the Expr language. The examples showcase comparisons with various data types, environment variables, conditional checks, and function return values. It highlights how 'f64' values interact with other types in inequality comparisons.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_82\n\nLANGUAGE: Expr\nCODE:\n```\nf64 < $env.f64\nf64 < $env.i\nf64 < $env?.f64\nf64 < $env?.i\nf64 < 0 % 1\nf64 < 0 ** f64\nf64 < 0 + 1.0\nf64 < 0 + i\nf64 < 0 < $env > $env\nf64 < 0 <= $env?.[array]\nf64 < 0 == false\nf64 < 0 or true\nf64 < 1 % 1\nf64 < 1 / 0\nf64 < 1 <= f64\nf64 < 1 or ok\nf64 < 1 or true\nf64 < 1.0 && $env\nf64 < 1.0 - 1.0\nf64 < 1.0 - f64\nf64 < 1.0 / 1\nf64 < 1.0 / 1.0\nf64 < 1.0 / f64\nf64 < 1.0 < 1.0\nf64 < 1.0 <= i\nf64 < 1.0 == false\nf64 < 1.0 >= 1.0 == true\nf64 < 1.0 ?: true\nf64 < abs(1)\nf64 < array?.[i]\nf64 < ceil(1.0)\nf64 < count(list, true)\nf64 < f64\nf64 < f64 > 0\nf64 < f64 ?: ok\nf64 < f64 in $env?.String\nf64 < float(1)\nf64 < floor(1)\nf64 < floor(f64)\nf64 < i\nf64 < i != nil\nf64 < i % i\nf64 < i >= f64\nf64 < i || true\nf64 < max(array)\nf64 < max(f64)\nf64 < mean(f64)\nf64 < median(array)\nf64 < min(0)\nf64 < min(1.0)\nf64 < min(i)\nf64 < round(1.0)\nf64 < sum(array)\n```\n\n----------------------------------------\n\nTITLE: Comparison Operators for Fields - Expr\nDESCRIPTION: Demonstrates the usage of various comparison operators (==, !=, <, >, <=, >=) with fields in Expr. It covers comparisons with different data types and optional chaining.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_110\n\nLANGUAGE: Expr\nCODE:\n```\nfoo.Bar < foo.Bar\nfoo.Bar <= str\nfoo.Bar == $env?.Bar\nfoo.Bar == foo?.Bar\nfoo.Bar == str\nfoo.Bar > foo.String()\nfoo.Bar > str\nfoo.Bar >= str\nfoo.Bar >= type(ok)\nfoo?.Bar < str\nfoo?.Bar < string(0)\nfoo?.Bar <= str\nfoo?.Bar == $env.str\nfoo?.Bar == nil and false\nfoo?.Bar == str\nfoo?.Bar > str\nfoo?.Bar > type(false)\nfoo?.Bar >= $env.str\nfoo?.Bar >= str\nfoo?.Bar >= toJSON(foo)\nfoo.Bar != foo?.Bar\nfoo.Bar != str\nfoo?.Bar != nil == $env\nfoo?.Bar != str\nfoo?.Bar != type(f64)\nfoo.String() != str\nfoo?.String() != str\n```\n\n----------------------------------------\n\nTITLE: Division Operations with 'i' in Expr\nDESCRIPTION: Demonstrates division operations involving the variable 'i' with different data types, variables, function calls, and array access. It also includes use of conditional property access and bitwise operations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_153\n\nLANGUAGE: Expr\nCODE:\n```\ni / $env.f64\ni / $env.i\ni / $env?.f64\ni / $env?.i\ni / 0 + f64 == i\ni / 0 - f64\ni / 0 < 1\ni / 0 == 1.0\ni / 1 * i\ni / 1 ** f64\ni / 1.0 != 1\ni / 1.0 != 1.0\ni / 1.0 * ceil(1.0)\ni / 1.0 + f64\ni / 1.0 - 0\ni / 1.0 - f64\ni / 1.0 < 0\ni / 1.0 < i\ni / 1.0 > 1.0\ni / 1.0 in array\ni / array?.[i]\ni / bitnot(0)\ni / count(array, false)\ni / f64\ni / f64 < 1.0\ni / floor(1.0)\ni / i\ni / i + 1.0\ni / i < 0\ni / i <= 0\ni / i == 1.0\ni / i == i\ni / i in array\ni / len($env)\ni / mean(1.0, 1.0)\ni / sum(array)\ni / sum(list, f64)\n```\n\n----------------------------------------\n\nTITLE: Conditional array reductions in Expr\nDESCRIPTION: Demonstrates conditional execution where the input array to `reduce` is determined by a boolean condition. These are useful in scenarios where the data source for the reduction depends on runtime conditions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_104\n\nLANGUAGE: Expr\nCODE:\n```\nreduce(true ? array : 1, array)\nreduce(true ? array : array, #)\n```\n\n----------------------------------------\n\nTITLE: Example Expr Expressions\nDESCRIPTION: This snippet contains a variety of expressions demonstrating arithmetic, logical, comparison, and other operations within the Expr language. These expressions showcase how different data types interact and how operators are used to perform calculations, comparisons, and logical evaluations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_8\n\nLANGUAGE: Expr\nCODE:\n```\n0.5 >= 0.5 ? array[i64] : f32\n0.5 >= 0.5 and ok\n0.5 >= i && 1 < 0.5\n0.5 >= i32 == ok\n0.5 >= i32 and ok\n0.5 ^ 0.5 == f64\n0.5 ^ 0.5 >= i32\n0.5 ^ 0.5 >= i64\n0.5 ^ 1 ** i64\n0.5 ^ 1 - f32\n0.5 ^ 1 < f32\n0.5 ^ 1 < i\n0.5 ^ 1 <= i32\n0.5 ^ 1 > f64 / 1\n0.5 ^ 1 >= i\n0.5 ^ f32 * i\n0.5 ^ f32 ** i64\n0.5 ^ f32 <= i32\n0.5 ^ f32 > i64\n0.5 ^ f32 >= i\n0.5 ^ f64 - i64\n0.5 ^ f64 / f32\n0.5 ^ f64 < f32\n0.5 ^ f64 > i32\n0.5 ^ i != f64\n0.5 ^ i * reduce(array, i)\n0.5 ^ i ** floor(0.5)\n0.5 ^ i / (0.5 + i32)\n0.5 ^ i < -f64\n0.5 ^ i <= i32\n0.5 ^ i >= i64\n0.5 ^ i32 * reduce(list, f64)\n0.5 ^ i32 ** f32\n0.5 ^ i32 < f32 ? ok : i32\n0.5 ^ i32 == i64\n0.5 ^ i32 ^ f64\n0.5 ^ i32 in array\n0.5 ^ i64 * i\n0.5 ^ i64 ** i\n0.5 ^ i64 ** i64\n0.5 ^ i64 > i32\n0.5 in array != ok\n0.5 in array && ok\n1 != 0.5 != ok\n1 != 0.5 and 1 == 1\n1 != 1 && ok\n1 != 1 ? f64 : 0.5 > i\n1 != 1 ? list : score\n1 != f32 != ok\n1 != f32 ? ok : half\n1 != i or ok\n1 != i64 ? add : div\n1 != nil && ok\n1 != nil == ok\n1 != nil or not false\n1 % 1 != i\n1 % 1 != i32\n1 % 1 % i\n1 % 1 / f32\n1 % 1 / i32\n1 % 1 < f64\n1 % 1 < i\n1 % 1 == f64\n1 % 1 == i ? nil : 0.5\n1 % 1 == i32\n1 % array[i32]\n1 % array[i]\n1 % i != -i64\n1 % i != 1 != nil\n1 % i - i64\n1 % i < i32\n1 % i >= f64\n1 % i >= i\n1 % i not in array\n1 % i32 != i\n1 % i32 <= f32\n1 % i32 > i64\n1 % i32 >= f64\n1 % i64 - f32\n1 % i64 < score(i)\n1 % i64 > f32\n1 * 0.5 + f64\n1 * 0.5 + i32\n1 * 0.5 + round(f64)\n1 * 0.5 / i\n1 * 0.5 / i64\n1 * 0.5 < i64\n1 * 0.5 == f32\n1 * 0.5 >= f32\n1 * 1 - i32\n1 * 1 <= int(i)\n1 * 1 >= f32\n1 * f32 != f64 - 0.5\n1 * f32 <= reduce(array, #)\n1 * f32 >= f64\n1 * f64 * i64\n1 * f64 <= i64\n1 * f64 > i\n1 * f64 >= f64\n1 * i * f32\n1 * i - i32\n1 * i / f64\n1 * i < f32\n1 * i > i32\n1 * i not in array\n1 * i32 + i32\n1 * i32 - i\n1 * i32 < i\n1 * i64 * f32\n1 * i64 + i\n1 * i64 - f64\n1 * i64 / f64\n1 * i64 <= f64\n1 * i64 in array\n1 ** 0.5 * i\n1 ** 0.5 ** f32\n1 ** 0.5 ** f64\n1 ** 0.5 ** i64\n1 ** 0.5 - f32\n1 ** 0.5 - i32\n1 ** 0.5 - i64\n1 ** 0.5 < -f32\n1 ** 0.5 > i\n1 ** 0.5 > i64\n1 ** 0.5 ^ f64\n1 ** 1 ** f64\n1 ** 1 + f64\n1 ** 1 + i64\n1 ** 1 - round(0.5)\n1 ** 1 / f64\n1 ** 1 < f32\n1 ** 1 == 0.5 + i32\n1 ** 1 >= i\n1 ** 1 >= i32\n1 ** 1 ^ i\n1 ** 1 ^ i32\n1 ** 1 in array\n1 ** array[i32]\n1 ** f32 / i32\n1 ** f32 / i64\n1 ** f32 <= f32\n1 ** f32 <= i64\n1 ** f32 == i64 ? i32 : array\n1 ** f32 >= f32\n1 ** f32 >= i\n1 ** f32 ^ f32\n1 ** f32 ^ i64\n1 ** i + i32\n1 ** i >= i\n1 ** i32 != i32\n1 ** i32 + f32\n1 ** i32 + i64\n1 ** i64 <= f32\n1 ** i64 <= f64\n1 ** i64 <= i32\n1 ** i64 > f32\n1 + 0.5 != i32\n1 + 0.5 + i\n1 + 0.5 - i64\n1 + 0.5 < f32\n1 + 0.5 < i\n1 + 0.5 == f64\n1 + 0.5 == f64 != nil\n1 + 0.5 > i64\n1 + 0.5 not in array\n1 + 1 != 0.5 ? 0.5 : half\n1 + 1 - f32\n1 + 1 - i\n1 + 1 < i\n1 + 1 == f64 * i64\n1 + 1 > f32\n1 + 1 >= half(0.5)\n1 + 1 >= i\n1 + f32 != i32\n1 + f32 < i32\n1 + f32 <= i\n1 + f32 > i64\n1 + f64 == i64\n1 + f64 >= f64\n1 + i .. i32\n1 + i <= ceil(f32)\n1 + i <= f64\n1 + i >= min(i64)\n1 + i32 != i32\n1 + i32 - f64\n1 + i32 < f32\n1 + i32 < i32\n1 + i32 <= f64\n1 + i32 > reduce(array, #)\n1 + i32 >= f64\n1 + i64 != i32\n1 + i64 != i64\n1 + i64 < i32\n1 + i64 <= i64\n1 - 0.5 != f32\n1 - 0.5 + i\n1 - 0.5 - f32\n1 - 0.5 <= i32\n1 - 0.5 <= i64\n1 - 1 < i64 ? 0.5 : \\\"foo\\\"\n1 - 1 <= i32 + i64\n1 - 1 == f64\n1 - 1 > i32 / i32\n1 - f32 != f32\n1 - f32 <= i64\n1 - f64 != f32\n1 - f64 + f32\n1 - f64 + i - 0.5\n1 - f64 <= i\n1 - f64 in array\n1 - f64 not in array\n1 - i > f64\n1 - i > i\n1 - i > i32\n1 - i >= i64\n1 - i not in array\n1 - i32 < i32\n1 - i32 < i64\n1 - i32 == i32\n1 - i64 <= i32\n1 .. i != list\n1 / 0.5 <= abs(f32)\n1 / 0.5 <= i32\n1 / 0.5 == f64\n1 / 0.5 > f32\n1 / 0.5 >= i\n1 / 0.5 >= i - i\n1 / 0.5 >= i32\n1 / 1 != i32\n1 / 1 * f32\n1 / 1 <= f64\n1 / 1 in array\n1 / f32 != f64\n1 / f32 / i64\n1 / f32 <= f32\n1 / f32 <= f64\n1 / f32 == i32\n1 / f32 == i32 / i\n1 / f32 > f32\n1 / f32 >= f64\n1 / f64 + f64\n1 / f64 < f32\n1 / f64 == f64\n1 / i * f32\n1 / i / f64\n1 / i < i\n1 / i == f64\n1 / i >= i32\n1 / i in map(list, 1)\n1 / i32 > f32\n1 / i32 >= i64\n1 / i64 * i\n1 / i64 > f32 / f64\n1 / i64 > f64\n1 / i64 >= f64\n1 < 1 == ok\n1 < 1 and ok\n1 < array[get(array, i32)]\n1 < array[i32]\n1 < f32 != not true\n1 < f64 || ok\n1 < i ? array : foo\n1 < i32 || 1 >= f32\n1 < i64 == ok\n1 < i64 ? ok : list\n1 <= 1 == ok\n1 <= 1 || add == add\n1 <= f32 && ok\n1 <= f64 || ok\n1 <= i32 ? foo : f32\n1 == 0.5 ? i32 : greet\n1 == 0.5 and ok\n1 == 1 || ok\n1 == f64 && 0.5 != nil\n1 == f64 || ok\n1 == i32 && ok\n1 == i32 == ok\n1 == i64 == ok\n1 == nil ? ok : half\n1 > 0.5 == ok\n1 > array[i64]\n1 > f32 && ok\n1 > f32 == reduce(array, ok)\n1 > f64 != ok\n1 > i == ok\n1 > i64 or i != 1\n1 >= 1 != (nil not in list)\n1 >= f32 ? i64 : half\n1 >= f64 ? ok : half\n1 >= i and ok\n1 ^ 0.5 != f32\n1 ^ 0.5 != i\n1 ^ 0.5 ** f32\n1 ^ 0.5 ** i32\n1 ^ 0.5 - i32\n1 ^ 0.5 < i32\n1 ^ 0.5 <= f64\n1 ^ 0.5 == i\n1 ^ 0.5 ^ f32\n1 ^ 0.5 ^ i64\n1 ^ 1 != f64\n1 ^ 1 != i64\n1 ^ 1 ** i\n1 ^ 1 + f64\n1 ^ 1 / i\n1 ^ 1 < i\n1 ^ 1 < i64\n1 ^ 1 >= i\n1 ^ 1 >= i32\n1 ^ f32 < i32\n1 ^ f32 <= f64\n1 ^ f64 / f64\n1 ^ f64 == f32\n1 ^ f64 > f32\n1 ^ f64 >= 1 / f64\n1 ^ i != i * f32\n1 ^ i - i32\n1 ^ i < i\n1 ^ i32 * i32\n1 ^ i32 ** i64\n1 ^ i32 / i\n1 ^ i32 >= i32\n1 ^ i32 >= i64\n1 ^ i64 * i64\n1 ^ i64 ** reduce(list, 1)\n1 ^ i64 - i64\n1 ^ i64 / f64\n1 ^ i64 > i\n1 ^ i64 >= i32 + i32\n1 in array ? f32 : foo\n[!false]\n[!ok]\n[!true]\n[\\\"bar\\\" + \\\"foo\\\"]\n[\\\"bar\\\" < \\\"bar\\\"]\n[\\\"bar\\\" not contains \\\"bar\\\"]\n[-0.5]\n[-1]\n[-f32]\n[-f64]\n[-i64]\n[0.5 != f32]\n[0.5 != i]\n[0.5 * 0.5]\n[0.5 * f32]\n[0.5 ** i]\n[0.5 - 0.5]\n[0.5 - i]\n[0.5 / i32]\n[0.5 <= i32, half]\n[0.5 > 1]\n[0.5 > f32]\n[0.5 > i64]\n[0.5 >= f64]\n[0.5 ^ 0.5]\n[1 != 1]\n[1 * 0.5]\n[1 ** 0.5]\n[1 + i64, add]\n[1 == i64]\n[1 == i]\n[[f32]]\n[add != nil]\n[add, add]\n[add, f32]\n[add, i]\n[add]\n[all(list, false)]\n[any(list, ok)]\n[array, add]\n[array, array]\n[array, f32]\n[array, greet]\n[array, i64]\n[array, i]\n[array, list]\n[array, ok, add]\n[array, string(nil)]\n[array]\n[bitnot(1)]\n[ceil(i32)]\n[div(1, 1)]\n[div, add]\n[div, foo]\n[div, i32]\n[div, i64, array]\n[div]\n[f32 * i]\n[f32 + f64]\n[f32 >= i]\n[f32, f64]\n[f32, foo, greet]\n[f32, greet]\n[f32, i32]\n[f32, list]\n[f32, ok]\n[f32, score]\n[f32]\n[f64 + f64]\n[f64 / f64]\n[f64 < 0.5]\n[f64 < f32]\n[f64 < i64]\n[f64 <= 1]\n[f64 in array]\n[f64, add]\n[f64, f64]\n[f64, half]\n[f64, i64]\n[f64]\n[f64] == array\n[find(array, true)]\n[findIndex(list, false)]\n[findLast(list, ok)]\n[float(0.5)]\n[float(1)]\n[foo, add]\n[foo, array]\n[foo, half]\n[foo, i]\n[foo, ok]\n[foo, reduce(array, #)]\n[foo.Bar]\n[foo.Qux]\n[foo?.Bar, f32, f64]\n[foo?.Bar, i32]\n[foo?.Bar]\n[foo?.Qux]\n[foo?.String()]\n[foo]\n[greet != nil]\n[greet, array]\n[greet, div]\n[greet, foo]\n[greet, greet]\n[greet, half]\n[greet, i64]\n[greet, list]\n[greet]\n[greet] == list\n[groupBy(array, \\\"bar\\\")]\n[groupBy(array, #), half]\n[groupBy(array, #)]\n[groupBy(array, f64)]\n[groupBy(list, #)?.Qux]\n[half(0.5)]\n[half(f64)]\n[half(i64 ^ 1)]\n[half, array]\n[half, div]\n[half, f64]\n[half, i64 < f64]\n[half, list]\n[half]\n[i != i64]\n[i .. 1]\n[i / i]\n[i < i64, score]\n[i <= 0.5]\n[i == i32]\n[i >= i32]\n[i ^ 1]\n[i, array, list]\n[i, array]\n[i, greet(\\\"bar\\\")]\n[i, greet]\n[i, i32]\n[i, i]\n[i, list]\n[i32 < i]\n[i32 > 1]\n[i32, -1]\n[i32, div]\n[i32, f64]\n[i32, i32]\n[i32, list]\n[i32, type(greet)]\n[i32]\n[i64 != f64]\n[i64 + 0.5]\n[i64 / f64]\n[i64 <= i64]\n[i64 >= 1]\n[i64 ^ 1]\n[i64, div]\n[i64, foo]\n[i64, half]\n[i64, score]\n[i64]\n[i]\n[list != nil]\n[list, div]\n[list, f32]\n[list, greet]\n[list, half]\n[list, i]\n[list, ok]\n[list]\n[map(array, #)]\n[map(array, add)]\n[map(array, f64)]\n[map(array, foo)]\n[max(1)]\n[nil != 0.5]\n[not false]\n[ok ? 1 : greet]\n[ok, f32]\n[ok, half]\n[ok, i64]\n[ok, i]\n[ok, list, 0.5] == list\n[ok, ok]\n[ok]\n[reduce(array, foo)]\n[reduce(list, #)]\n[reduce(list, div)]\n[score == nil]\n[score, div]\n[score, f32]\n[score, f64]\n[score, greet]\n[score, half]\n[score, one(array, # > i32)]\n[score, score]\n[score]\n[string(0.5)]\n[string(1)]\n[string(foo)]\n[string(i)]\n[string(i64)]\n[toJSON(list)]\n[trimPrefix(\\\"bar\\\")]\n[true ? add : f64]\n[true and ok]\n[true || ok]\n[type(1)]\n[type(add)]\n[type(div)]\n[type(greet)]\n[type(nil)]\nabs(-0.5)\nabs(-1)\nabs(-f32)\nabs(-f64)\nabs(-i)\nabs(-i32)\nabs(-i64)\nabs(0.5 * 0.5)\nabs(0.5 * 1)\nabs(0.5 * i)\nabs(0.5 * i64)\nabs(0.5 ** 0.5)\nabs(0.5 ** 1)\nabs(0.5 ** i32)\nabs(0.5 + 0.5)\nabs(0.5 + 1)\nabs(0.5 + f32)\nabs(0.5 + i)\nabs(0.5 + i64)\nabs(0.5 - 0.5)\nabs(0.5 - 1)\nabs(0.5 - i)\nabs(0.5 - i32)\nabs(0.5 - i64)\nabs(0.5 / 0.5)\nabs(0.5 / 1)\nabs(0.5 / f64)\nabs(0.5 ^ 0.5)\nabs(0.5 ^ 1)\nabs(0.5 ^ f32)\nabs(0.5) - i32\nabs(0.5) / f32\nabs(0.5) < f64\nabs(0.5) < i32\nabs(0.5) <= i64\nabs(0.5) == -0.5\nabs(0.5) == half(1)\nabs(0.5) > i32\nabs(0.5) >= f64\nabs(0.5) ^ i64\nabs(0.5) not in array\nabs(1 * f32)\nabs(1 * f64)\nabs(1 * i32)\nabs(1 ** 0.5)\nabs(1 ** 1)\nabs(1 ** i)\nabs(1 + 1)\nabs(1 + i)\nabs(1 + i64)\nabs(1 - 0.5)\nabs(1 - 1)\nabs(1 - i64)\nabs(1 / 0.5)\nabs(1 / 1)\nabs(1 / i)\nabs(1 / i32)\nabs(1 ^ f32)\nabs(1 ^ i)\nabs(1 ^ i32)\nabs(1) - i32\nabs(1) .. i\nabs(1) / f64\nabs(1) / i64\nabs(1) < i64\nabs(1) <= i32\nabs(1) == i32\nabs(1) >= i\nabs(1) ^ f64\nabs(abs(0.5))\nabs(abs(1))\nabs(abs(f64))\nabs(abs(i32))\nabs(abs(i64))\nabs(add(i, 1))\nabs(bitand(i64, i32))\nabs(bitnand(i64, i))\nabs(bitnot(1))\nabs(bitnot(i))\nabs(bitnot(i32))\nabs(bitnot(i64))\nabs(bitushr(1, 1))\nabs(ceil(0.5))\nabs(ceil(1))\nabs(ceil(f32))\nabs(ceil(i))\nabs(ceil(i32))\nabs(ceil(i64))\nabs(count(array, ok))\nabs(count(array, true))\nabs(count(list, false))\nabs(div(i, i))\nabs(f32 * 0.5)\nabs(f32 ** 1)\nabs(f32 ** f32)\nabs(f32 ** i32)\nabs(f32 + 0.5)\nabs(f32 + 1)\nabs(f32 + i)\nabs(f32 + i32)\nabs(f32 - 0.5)\nabs(f32 - 1)\nabs(f32 - i32)\nabs(f32 - i64)\nabs(f32 / 0.5)\nabs(f32 / 1)\nabs(f32 / f32)\nabs(f32 / f64)\nabs(f32 / i32)\nabs(f32 ^ i)\nabs(f32 ^ i64)\nabs(f32)\nabs(f32) ** f32\nabs(f32) ** i\nabs(f32) + i64\nabs(f32) - i32\nabs(f32) / f64\nabs(f32) < f64\nabs(f32) >= 0.5 / 1\nabs(f32) ^ f32\nabs(f64 * f32)\nabs(f64 * f64)\nabs(f64 ** 1)\nabs(f64 + 0.5)\nabs(f64 + 1)\nabs(f64 + f64)\nabs(f64 - 1)\nabs(f64 - f32)\nabs(f64 / 0.5)\nabs(f64 / 1)\nabs(f64 / f64)\nabs(f64 / i)\nabs(f64 ^ 0.5)\nabs(f64 ^ f32)\nabs(f64 ^ i)\nabs(f64 ^ i64)\nabs(f64)\nabs(f64) + f32\nabs(f64) + f64\nabs(f64) + i32\nabs(f64) + i64 / i\nabs(f64) - i\nabs(f64) < i32\nabs(f64) <= f64\nabs(f64) > i64\nabs(f64) ^ f32\nabs(f64) ^ i64\nabs(f64) in array\nabs(false ? f32 : 1)\nabs(false ? half : 0.5)\n```\n\n----------------------------------------\n\nTITLE: Date Addition with Duration in Expr\nDESCRIPTION: Demonstrates adding a duration to a date using the `+` operator.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_38\n\nLANGUAGE: expr\nCODE:\n```\ncreatedAt + duration(\"1h\")\n```\n\n----------------------------------------\n\nTITLE: String Conversion with Conditional expressions\nDESCRIPTION: This snippet tests the string conversion of conditional expressions\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_237\n\nLANGUAGE: Expr\nCODE:\n```\nstring(if false { foo } else { false })\nstring(if false { ok } else { i })\nstring(if ok { 1 } else { 1.0 })\n```\n\n----------------------------------------\n\nTITLE: Array Variable Access in Expr\nDESCRIPTION: Examples of accessing array variables in Expr, including conditional access using the safe navigation operator and various indices.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_65\n\nLANGUAGE: Expr\nCODE:\n```\narray; $env.ok\narray; add\narray; array\narray; foo.String\narray; greet\narray; i\narray; list\narray?.[$env.i]\narray?.[$env?.i]\narray?.[0 % i]\narray?.[1] % i\narray?.[1] .. i\narray?.[1] / f64\narray?.[array?.[i]]\narray?.[bitnot(i)]\narray?.[i]\narray?.[i] != 1.0 ?: 1.0\narray?.[i] != f64\narray?.[i] != i * 1.0\narray?.[i] * i\narray?.[i] ** i\narray?.[i] - f64\narray?.[i] - i\narray?.[i] .. i\narray?.[i] / i\narray?.[i] < 0 + 1.0\narray?.[i] < f64\narray?.[i] <= f64\narray?.[i] == f64\narray?.[i] > f64\narray?.[i] >= f64\narray?.[i] >= i\narray?.[i] ^ f64\narray?.[i] ^ i\narray?.[i] not in array\narray?.[i] | add(i)\narray?.[i] | bitshr(0)\narray?.[i] | min(0)\narray?.[int(1.0)]\narray?.[len(list)]\narray?.[list | count(ok)]\narray?.[mean(1)]\narray?.[mean(i)]\narray?.[median(1)]\n```\n\n----------------------------------------\n\nTITLE: Finding the Maximum of Two Numbers in Expr\nDESCRIPTION: The `max()` function returns the larger of the two numbers passed as arguments. Both arguments must be numerical values.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_44\n\nLANGUAGE: expr\nCODE:\n```\nmax(5, 7) == 7\n```\n\n----------------------------------------\n\nTITLE: Mapping with Mathematical and String Functions in Expr\nDESCRIPTION: Demonstrates applying various mathematical and string functions within the map function, transforming list elements to fit mathematical expressions or formatted strings.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_189\n\nLANGUAGE: Expr\nCODE:\n```\nmap(list, round(f64))\nmap(list, trim(str))\nmap(list, string(#))\n```\n\n----------------------------------------\n\nTITLE: hasSuffix Function in Expr\nDESCRIPTION: Illustrates the use of the `hasSuffix` function to check if a string ends with a given suffix.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_34\n\nLANGUAGE: expr\nCODE:\n```\nhasSuffix(\"HelloWorld\", \"World\") == true\n```\n\n----------------------------------------\n\nTITLE: Array Find\nDESCRIPTION: Finds the first element in the array that is greater than or equal to 1.0. Requires numeric elements. Returns the first element that satisfies the given condition, or nil if no element is found.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_49\n\nLANGUAGE: Expr\nCODE:\n```\narray | find(# >= 1.0)\n```\n\n----------------------------------------\n\nTITLE: Logical NOT with Nil Comparisons (Expr)\nDESCRIPTION: This snippet demonstrates comparisons of nil with different datatypes and operations, combined with the logical NOT operator.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_5\n\nLANGUAGE: Expr\nCODE:\n```\n!(add != nil)\n!(add == nil)\n!(array != nil)\n!(array == nil)\n!(div != nil)\n!(div == nil)\n!(f32 != nil)\n!(f64 != nil)\n!(false != nil)\n!(foo != nil)\n!(foo == nil)\n!(greet != nil)\n!(greet == nil)\n!(half != nil)\n!(half == nil)\n!(i != nil)\n!(i32 != nil)\n!(i32 == nil)\n!(i64 != nil)\n!(i64 == nil)\n!(list != nil)\n!(list == nil)\n!(nil != nil)\n!(ok != nil)\n!(score != nil)\n!(score == nil)\n!(true != nil)\n!(true == nil)\n!(nil == add)\n!(nil == div)\n!(nil == f32)\n!(nil == f64)\n!(nil == false)\n!(nil == greet)\n!(nil == half)\n!(nil == i)\n!(nil == i32)\n!(nil == i64)\n!(nil == list)\n!(nil == ok)\n!(nil == score)\n!(nil == true)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Unsigned Shift Right Operation in Expr\nDESCRIPTION: Illustrates the usage of `bitushr` for unsigned bitwise right shift operations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_73\n\nLANGUAGE: Expr\nCODE:\n```\nbitushr(i, i)\n```\n\n----------------------------------------\n\nTITLE: Expr f64 Greater Than Operations\nDESCRIPTION: This snippet demonstrates the use of the greater than operator (>) with the f64 data type in the Expr language. The examples cover different scenarios, including comparisons with environment variables (with and without optional chaining), arithmetic expressions, conditional operators, and function calls. It shows how f64 values are compared with other types and expressions in the language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_85\n\nLANGUAGE: Expr\nCODE:\n```\nf64 > $env.f64\nf64 > $env.i\nf64 > $env?.[str]?.[f64]\nf64 > $env?.f64\nf64 > $env?.i\nf64 > 0 + 1.0\nf64 > 0 >= 0\nf64 > 0 >= 1.0\nf64 > 0 ? 1 : 1.0\nf64 > 0 and $env?.String\nf64 > 0 or true\nf64 > 1 ** i\nf64 > 1 / f64\nf64 > 1 / i\nf64 > 1 <= i\nf64 > 1 >= f64\nf64 > 1 >= i\nf64 > 1 ? array : false\nf64 > 1 or true\nf64 > 1.0 * i\nf64 > 1.0 ** f64\nf64 > 1.0 / 0\nf64 > 1.0 <= f64\nf64 > 1.0 == true\nf64 > 1.0 > $env\nf64 > 1.0 > median(list, 1)\nf64 > 1.0 ? i : false\nf64 > 1.0 and true\nf64 > array?.[i]\nf64 > ceil(0)\nf64 > f64\nf64 > f64 != true\nf64 > f64 * f64\nf64 > f64 - 1\nf64 > f64 >= 1.0\nf64 > float(1.0)\nf64 > i\nf64 > i < f64 ?: $env\nf64 > i == $env\nf64 > i ^ 1\nf64 > max(array)\nf64 > mean(1.0)\nf64 > median(f64)\nf64 > round(1)\nf64 > round(i)\nf64 > sum($env | filter(false))\nf64 > sum($env, f64)\n```\n\n----------------------------------------\n\nTITLE: Find Last Element Matching Predicate in Expr\nDESCRIPTION: The `findLast()` function returns the last element in an array that satisfies the given predicate. If no element satisfies the predicate, the function returns `nil`.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_58\n\nLANGUAGE: expr\nCODE:\n```\nfindLast([1, 2, 3, 4], # > 2) == 4\n```\n\n----------------------------------------\n\nTITLE: Logical NOT with Ternary Operator (Expr)\nDESCRIPTION: This snippet demonstrates the usage of the logical NOT operator (!) in conjunction with the ternary operator (?:) in Expr. It showcases various data types and expressions as possible results of the ternary operation and the operator inverting the boolean condition for each ternary expression.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_6\n\nLANGUAGE: Expr\nCODE:\n```\n!false ? \"foo\" : 0.5\n!false ? \"foo\" : f32\n!false ? 0.5 : \"foo\"\n!false ? 0.5 : f32\n!false ? 1 : half\n!false ? 1 : i\n!false ? add : f32\n!false ? add : i64\n!false ? array : add\n!false ? array : ok\n!false ? div : array\n!false ? div : greet\n!false ? div : half\n!false ? f32 : add\n!false ? f32 : false\n!false ? f64 : \"foo\"\n!false ? foo : \"bar\"\n!false ? half : 1\n!false ? half : add\n!false ? half : list\n!false ? half : true\n!false ? i : nil\n!false ? i32 : list\n!false ? i64 : foo\n!false ? i64 : i64\n!false ? nil : add\n!false ? nil : f64\n!false ? nil : foo\n!false ? nil : half\n!false ? ok : 1\n!false ? score : \"bar\"\n!false ? score : foo\n!false ? score : ok\n!false ? true : \"foo\"\n!ok ? \"bar\" : \"foo\"\n!ok ? \"bar\" : foo\n!ok ? \"foo\" : 0.5\n!ok ? \"foo\" : list\n!ok ? 0.5 : 1\n!ok ? 0.5 : i\n!ok ? 1 : array\n!ok ? 1 : div\n!ok ? 1 : f64\n!ok ? 1 : list\n!ok ? 1 : ok\n!ok ? add : 0.5\n!ok ? array : div\n!ok ? array : f32\n!ok ? array : foo\n!ok ? array : i\n!ok ? array : i32\n!ok ? div : \"foo\"\n!ok ? div : 1\n!ok ? div : i\n!ok ? f32 : \"bar\"\n!ok ? f32 : add\n!ok ? f32 : false\n!ok ? f32 : greet\n!ok ? f64 : \"bar\"\n!ok ? f64 : \"foo\"\n!ok ? f64 : 0.5\n!ok ? f64 : half\n!ok ? f64 : score\n!ok ? false : ok\n!ok ? foo : \"foo\"\n!ok ? foo : f32\n!ok ? foo : false\n!ok ? foo : i32\n!ok ? greet : div\n!ok ? greet : list\n!ok ? greet : nil\n!ok ? half : f64\n!ok ? i : \"bar\"\n!ok ? i : array\n!ok ? i : div\n!ok ? i : foo\n!ok ? i32 : 0.5\n!ok ? i32 : f32\n!ok ? i32 : greet\n!ok ? i32 : nil\n!ok ? i64 : 0.5\n!ok ? i64 : 1\n!ok ? i64 : f32\n!ok ? i64 : true\n!ok ? list : f32\n!ok ? list : i\n!ok ? nil : 1\n!ok ? nil : array\n!ok ? ok : f32\n!ok ? ok : list\n```\n\n----------------------------------------\n\nTITLE: Variable 'i' in Expr\nDESCRIPTION: Defines a variable 'i' in the Expr context. It is mainly used for calculations and comparisons.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_145\n\nLANGUAGE: Expr\nCODE:\n```\ni\n```\n\n----------------------------------------\n\nTITLE: Bitwise Unsigned Shift Right Operations in Expr\nDESCRIPTION: Examples demonstrating `bitushr` function with various integer types and operations within Expr, focusing on unsigned shift right behavior.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_22\n\nLANGUAGE: Expr\nCODE:\n```\nbitushr(-i64, i64)\nbitushr(1 % i, i)\nbitushr(1, i) * i\nbitushr(abs(1), i32)\nbitushr(i, i)\nbitushr(i, i) % i64\nbitushr(i, i32)\nbitushr(i, i64)\nbitushr(i32, i)\nbitushr(i32, i32)\nbitushr(i32, i64)\nbitushr(i64, i)\nbitushr(i64, i32)\nbitushr(i64, i64)\n```\n\n----------------------------------------\n\nTITLE: Finding Index in Expr\nDESCRIPTION: Demonstrates how to find the index of the first element that matches a given condition within an array. The `findIndex` function iterates through the array and returns the index of the first element satisfying the provided boolean expression.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_39\n\nLANGUAGE: Expr\nCODE:\n```\nfindIndex(array, !ok)\nfindIndex(array, \"bar\" == \"foo\")\nfindIndex(array, \"foo\" > \"foo\")\nfindIndex(array, \"foo\" in foo)\nfindIndex(array, # != #)\nfindIndex(array, # != 0.5)\nfindIndex(array, # != f32)\nfindIndex(array, # != f64)\nfindIndex(array, # != i)\nfindIndex(array, # != i64)\nfindIndex(array, # != nil)\nfindIndex(array, # < #)\nfindIndex(array, # < 1)\nfindIndex(array, # < i32)\nfindIndex(array, # <= #)\nfindIndex(array, # <= 0.5)\nfindIndex(array, # <= 1)\nfindIndex(array, # == #)\nfindIndex(array, # == 0.5)\nfindIndex(array, # == 1)\nfindIndex(array, # == i32)\nfindIndex(array, # == nil)\nfindIndex(array, # > #)\nfindIndex(array, # > 0.5)\nfindIndex(array, # > 1)\nfindIndex(array, # > f64)\nfindIndex(array, # > i)\nfindIndex(array, # > i64)\nfindIndex(array, # >= #)\nfindIndex(array, # >= 0.5)\nfindIndex(array, # >= 1)\nfindIndex(array, # >= f32)\nfindIndex(array, # >= f64)\nfindIndex(array, # >= i)\nfindIndex(array, # >= i32)\nfindIndex(array, # >= i64)\nfindIndex(array, 0.5 != #)\nfindIndex(array, 0.5 != 1)\nfindIndex(array, 0.5 < 1)\nfindIndex(array, 0.5 <= #)\nfindIndex(array, 0.5 == #)\nfindIndex(array, 0.5 == i64)\nfindIndex(array, 0.5 > #)\nfindIndex(array, 0.5 > 0.5)\nfindIndex(array, 0.5 > i)\nfindIndex(array, 0.5 > i32)\nfindIndex(array, 0.5 >= 0.5)\nfindIndex(array, 0.5 >= 1)\nfindIndex(array, 0.5 not in array)\nfindIndex(array, 1 != #)\nfindIndex(array, 1 != i64)\nfindIndex(array, 1 != nil)\nfindIndex(array, 1 < #)\nfindIndex(array, 1 <= #)\nfindIndex(array, 1 > #)\nfindIndex(array, 1 > i)\nfindIndex(array, 1 >= #)\nfindIndex(array, add != div)\nfindIndex(array, add != nil)\nfindIndex(array, f32 != #)\nfindIndex(array, f32 != 1)\nfindIndex(array, f32 < #)\nfindIndex(array, f32 == #)\nfindIndex(array, f32 >= #)\nfindIndex(array, f32 >= i32)\nfindIndex(array, f64 >= #)\nfindIndex(array, f64 >= i32)\nfindIndex(array, false) == -f64\nfindIndex(array, i != f64)\nfindIndex(array, i < #)\nfindIndex(array, i < i32)\nfindIndex(array, i <= #)\nfindIndex(array, i <= 0.5)\nfindIndex(array, i == #)\nfindIndex(array, i >= i)\nfindIndex(array, i >= i32)\nfindIndex(array, i32 != #)\nfindIndex(array, i32 < #)\nfindIndex(array, i32 == #)\nfindIndex(array, i32 > f32)\nfindIndex(array, i64 != #)\nfindIndex(array, i64 != nil)\nfindIndex(array, i64 < 0.5)\nfindIndex(array, i64 <= #)\nfindIndex(array, i64 <= i64)\nfindIndex(array, i64 > #)\nfindIndex(array, i64 >= #)\nfindIndex(array, i64 >= f64)\nfindIndex(array, i64 >= i32)\nfindIndex(array, nil != half)\nfindIndex(array, nil != ok)\nfindIndex(array, nil == #)\nfindIndex(array, nil == 1)\nfindIndex(array, nil == nil)\nfindIndex(array, not false)\nfindIndex(array, ok)\nfindIndex(array, ok) / f64\nfindIndex(array, ok) / i\nfindIndex(array, ok) <= f32\nfindIndex(array, one(list, false))\nfindIndex(array, true) + f64\nfindIndex(array, true) - f64\nfindIndex(array, true) .. i\nfindIndex(filter(array, false), # > 1)\nfindIndex(filter(array, true), # not in array)\nfindIndex(filter(list, false), 1 <= i64)\nfindIndex(groupBy(array, #).f64, .Bar(half(add, half, div, greet, f64)))\nfindIndex(groupBy(array, false).String, #?.i64())\n```\n\n----------------------------------------\n\nTITLE: Bitwise Shift Left Operation in Expr\nDESCRIPTION: Examples of using `bitshl` for bitwise left shift operations in Expr, combining variables and environment values.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_71\n\nLANGUAGE: Expr\nCODE:\n```\nbitshl(i, $env?.i)\nbitshl(i, i)\n```\n\n----------------------------------------\n\nTITLE: Expr Object Access with Nested Objects\nDESCRIPTION: This example showcases accessing a property `add` of a nested object. The object consists of properties `foo` and `bar`, where `bar` contains the `add` property being accessed.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_149\n\nLANGUAGE: expr\nCODE:\n```\n{\"foo\": score, \"bar\": add}.add\n```\n\n----------------------------------------\n\nTITLE: toBase64 Function Usage (Expr)\nDESCRIPTION: Demonstrates different ways to use the `toBase64` function, including accessing environment variables, object properties, function calls, and various string operations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_240\n\nLANGUAGE: Expr\nCODE:\n```\ntoBase64($env.foo?.Bar)\ntoBase64($env.str)\ntoBase64($env?.[str])\ntoBase64($env?.str)\ntoBase64(foo.Bar)\ntoBase64(foo.String())\ntoBase64(foo?.Bar)\ntoBase64(foo?.String())\ntoBase64(greet(str))\ntoBase64(lower(str))\ntoBase64(str + str)\ntoBase64(str)\ntoBase64(str) > str\ntoBase64(str) >= str\ntoBase64(str) not contains $env?.str\ntoBase64(str) not startsWith str\ntoBase64(str) | greet()\ntoBase64(str) | repeat(i)\ntoBase64(str)[i:]\ntoBase64(str[:0])\ntoBase64(string($env))\ntoBase64(string(0))\ntoBase64(string(1))\ntoBase64(string(1.0))\ntoBase64(string(array))\ntoBase64(string(f64))\ntoBase64(string(false))\ntoBase64(string(foo))\ntoBase64(string(greet))\ntoBase64(string(i))\ntoBase64(string(list))\ntoBase64(string(nil))\ntoBase64(string(ok))\ntoBase64(string(str))\ntoBase64(toBase64(str))\ntoBase64(toJSON(0))\ntoBase64(toJSON(1.0))\ntoBase64(toJSON(array))\ntoBase64(toJSON(f64))\ntoBase64(toJSON(false))\ntoBase64(toJSON(foo))\ntoBase64(toJSON(i / 1))\ntoBase64(toJSON(i))\ntoBase64(toJSON(list))\ntoBase64(toJSON(nil))\ntoBase64(toJSON(ok))\ntoBase64(toJSON(true))\ntoBase64(trimPrefix(str))\ntoBase64(trimSuffix(str))\ntoBase64(type($env))\ntoBase64(type(0))\ntoBase64(type(1))\ntoBase64(type(1.0 < 1.0))\ntoBase64(type(1.0))\ntoBase64(type(add))\ntoBase64(type(array))\ntoBase64(type(f64))\ntoBase64(type(false))\ntoBase64(type(foo))\ntoBase64(type(greet))\ntoBase64(type(i))\ntoBase64(type(list))\ntoBase64(type(nil))\ntoBase64(type(ok))\ntoBase64(type(true))\ntoBase64(upper(str))\n```\n\n----------------------------------------\n\nTITLE: lastIndexOf Function in Expr\nDESCRIPTION: Demonstrates the use of the `lastIndexOf` function to find the index of the last occurrence of a substring within a string.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_32\n\nLANGUAGE: expr\nCODE:\n```\nlastIndexOf(\"apple pie apple\", \"apple\") == 10\n```\n\n----------------------------------------\n\nTITLE: Using the none function in Expr\nDESCRIPTION: This snippet demonstrates various ways to use the `none` function with different data types, comparison operators, range and functions. It covers usage with arrays, ranges, literals, comparison operators, and property access. This showcases the versatility of the `none` function in the Expr language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_86\n\nLANGUAGE: expr\nCODE:\n```\nnone(1 .. i, # < #)\nnone(1 .. i32, # <= #)\nnone([foo, list, 1 >= i], ok)\nnone([greet], ok)\nnone([true], #)\nnone(array, !(i32 != i32))\nnone(array, !false)\nnone(array, !true)\nnone(array, \"bar\" endsWith \"foo\")\nnone(array, # != #)\nnone(array, # != 0.5)\nnone(array, # != 1)\nnone(array, # != f32)\nnone(array, # != f64)\nnone(array, # != i)\nnone(array, # < #)\nnone(array, # < 0.5)\nnone(array, # < f32)\nnone(array, # < i32)\nnone(array, # < i64)\nnone(array, # <= #)\nnone(array, # <= 0.5)\nnone(array, # <= 1)\nnone(array, # <= f32)\nnone(array, # <= i)\nnone(array, # <= i32)\nnone(array, # <= i64)\nnone(array, # == #)\nnone(array, # == 0.5)\nnone(array, # == f32)\nnone(array, # == i32)\nnone(array, # == i64)\nnone(array, # == nil)\nnone(array, # > #)\nnone(array, # > 0.5)\nnone(array, # > i)\nnone(array, # >= #)\nnone(array, # >= 0.5)\nnone(array, # >= 1)\nnone(array, # >= f32)\nnone(array, # >= f64)\nnone(array, # >= i32)\nnone(array, # >= i64)\nnone(array, # in array)\nnone(array, 0.5 != #)\nnone(array, 0.5 != 1)\nnone(array, 0.5 < #)\nnone(array, 0.5 < i64)\nnone(array, 0.5 <= #)\nnone(array, 0.5 <= 1)\nnone(array, 0.5 <= f64)\nnone(array, 0.5 == #)\nnone(array, 0.5 > 0.5)\nnone(array, 0.5 > 1)\nnone(array, 0.5 > f32)\nnone(array, 0.5 >= #)\nnone(array, 0.5 >= 1)\nnone(array, 1 < #)\n```\n\n----------------------------------------\n\nTITLE: Expr: Type Checks with Floating-point Arithmetic\nDESCRIPTION: This snippet shows basic arithmetic with floating-point numbers using type().\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_262\n\nLANGUAGE: Expr\nCODE:\n```\ntype(1 + 0)\ntype(1 + 1)\ntype(1 + 1.0)\ntype(1 .. 0)\ntype(1 / 1)\ntype(1 / i)\ntype(1 <= 0)\ntype(1 <= 1)\ntype(1 <= 1.0)\ntype(1 <= i)\ntype(1 == i)\ntype(1 == nil)\ntype(1 > 0)\ntype(1 > 1)\ntype(1 > 1.0)\ntype(1 > f64)\ntype(1 >= 0)\ntype(1 >= 1.0)\ntype(1 >= i)\ntype(1 ^ 0)\ntype(1 ^ 1)\ntype(1 ^ 1.0)\ntype(1 in array)\ntype(1 not in array)\ntype(1) not in foo\ntype(1) startsWith reduce(list, #.Bar)\ntype(1) | greet()\n\n```\n\n----------------------------------------\n\nTITLE: Expr Language Expressions\nDESCRIPTION: This snippet includes a collection of Expr language expressions. These expressions demonstrate various ways to access properties, call methods, and use optional chaining within the Expr language, typically within an environment context ($env). The expressions use various operators, conditional logic and built in functions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_1\n\nLANGUAGE: Expr\nCODE:\n```\n$env?.[Bar]?.i(foobar, str | reduce($env, f64))\n$env?.[Bar]?.i(greet, foobar)\n$env?.[Bar]?.i(list, foobar)\n$env?.[Bar]?.i.str\n$env?.[Bar]?.i?.[foo]\n$env?.[Bar]?.i?.[greet]\n$env?.[Bar]?.i?.array\n$env?.[Bar]?.i?.greet\n$env?.[Bar]?.i?.i\n$env?.[Bar]?.i?.str\n$env?.[Bar]?.keys(Bar, false)\n$env?.[Bar]?.list\n$env?.[Bar]?.list()\n$env?.[Bar]?.list()?.[ok]\n$env?.[Bar]?.list()?.str\n$env?.[Bar]?.list(foo.String)\n$env?.[Bar]?.list(foobar)\n$env?.[Bar]?.list(foobar).f64\n$env?.[Bar]?.list(foobar)?.[str]\n$env?.[Bar]?.list(foobar?.list)\n$env?.[Bar]?.list.Bar\n$env?.[Bar]?.list.add\n$env?.[Bar]?.list.f64\n$env?.[Bar]?.list.foobar\n$env?.[Bar]?.list?.Bar(foo, f64)\n$env?.[Bar]?.list?.[greet]\n$env?.[Bar]?.list?.[list]\n$env?.[Bar]?.list?.foo\n$env?.[Bar]?.list?.str\n$env?.[Bar]?.lower(nil)\n$env?.[Bar]?.map(nil)\n$env?.[Bar]?.nil?.i?.f64\n$env?.[Bar]?.none(list)\n$env?.[Bar]?.none(ok)\n$env?.[Bar]?.not.ok\n$env?.[Bar]?.now(foobar, foobar, $env)\n$env?.[Bar]?.ok\n$env?.[Bar]?.ok()\n$env?.[Bar]?.ok().list\n$env?.[Bar]?.ok()?.add\n$env?.[Bar]?.ok(add)\n$env?.[Bar]?.ok.String\n$env?.[Bar]?.ok.list\n$env?.[Bar]?.ok?.[greet]\n$env?.[Bar]?.ok?.foo\n$env?.[Bar]?.reduce(1.0)\n$env?.[Bar]?.str\n$env?.[Bar]?.str($env == foobar)\n$env?.[Bar]?.str($env)\n$env?.[Bar]?.str()\n$env?.[Bar]?.str().add.i\n$env?.[Bar]?.str()?.[list]\n$env?.[Bar]?.str(f64)\n$env?.[Bar]?.str(f64, array)\n$env?.[Bar]?.str(list | first(true, foobar))\n$env?.[Bar]?.str(nil)\n$env?.[Bar]?.str.Bar\n$env?.[Bar]?.str.foo\n$env?.[Bar]?.str.ok\n$env?.[Bar]?.str?.[add]\n$env?.[Bar]?.str?.[array]\n$env?.[Bar]?.str?.[list]\n$env?.[Bar]?.str?.[str]\n$env?.[Bar]?.sum(foobar)\n$env?.[Bar]?.true?.[ok]\n$env?.[Bar]?.values(foobar, foobar)\n$env?.[String] != 1 ? f64 : f64\n$env?.[String] != add\n$env?.[String] != array\n$env?.[String] != f64\n$env?.[String] != foo\n$env?.[String] != foo ? foo : 0\n$env?.[String] != i\n$env?.[String] != list\n$env?.[String] != ok\n$env?.[String] != str\n$env?.[String] == $env.i\n$env?.[String] == add\n$env?.[String] == greet\n$env?.[String] == i && $env\n$env?.[String] == list\n$env?.[String] == str\n$env?.[String] contains str\n$env?.[String] endsWith $env?.[str]\n$env?.[String] in list\n$env?.[String] matches str\n$env?.[String] not contains str\n$env?.[String] not in array\n$env?.[String] not in list\n$env?.[String] not matches str\n$env?.[String] not startsWith str\n$env?.[String] startsWith min($env)\n$env?.[String] startsWith str\n$env?.[String]?.$env.list\n$env?.[String]?.$env?.[foo]\n$env?.[String]?.$env?.[ok]\n$env?.[String]?.$env?.array\n$env?.[String]?.Bar\n$env?.[String]?.Bar()\n$env?.[String]?.Bar().foo\n$env?.[String]?.Bar(f64)\n$env?.[String]?.Bar(foobar)\n$env?.[String]?.Bar.String\n$env?.[String]?.Bar.greet\n$env?.[String]?.Bar.str\n$env?.[String]?.Bar?.Bar()\n$env?.[String]?.Bar?.[foo]\n$env?.[String]?.Bar?.[greet]\n$env?.[String]?.Bar?.[str]\n$env?.[String]?.Bar?.add\n$env?.[String]?.Bar?.i\n$env?.[String]?.Bar?.list()\n$env?.[String]?.String\n$env?.[String]?.String()\n$env?.[String]?.String().list\n$env?.[String]?.String(String)\n$env?.[String]?.String(add)\n$env?.[String]?.String(foobar, $env)\n$env?.[String]?.String(foobar?.[list])?.str()\n$env?.[String]?.String(greet)\n$env?.[String]?.String(ok && foobar)\n$env?.[String]?.String.split(false, add).str.array\n$env?.[String]?.String?.Bar\n$env?.[String]?.String?.[foo]\n$env?.[String]?.String?.[greet]\n$env?.[String]?.String?.[list]\n$env?.[String]?.String?.array\n$env?.[String]?.String?.foo?.foo\n$env?.[String]?.String?.list\n$env?.[String]?.[$env == true]\n$env?.[String]?.[$env.foo]\n$env?.[String]?.[$env?.[greet]]\n$env?.[String]?.[$env?.array]\n$env?.[String]?.[add]\n$env?.[String]?.[add].str\n$env?.[String]?.[add]?.[list]\n$env?.[String]?.[add]?.add\n$env?.[String]?.[add]?.greet\n$env?.[String]?.[array]\n$env?.[String]?.[array] == list\n$env?.[String]?.[array].Bar\n$env?.[String]?.[array].ok\n$env?.[String]?.[array]?.Bar()\n$env?.[String]?.[array]?.[ok]\n$env?.[String]?.[array]?.add\n$env?.[String]?.[array]?.f64\n$env?.[String]?.[array]?.list?.[add]\n$env?.[String]?.[f64]\n$env?.[String]?.[f64].list\n$env?.[String]?.[f64].list()\n$env?.[String]?.[f64]?.Bar\n$env?.[String]?.[f64]?.Bar()\n$env?.[String]?.[f64]?.[f64]\n$env?.[String]?.[f64]?.array()\n$env?.[String]?.[f64]?.greet\n$env?.[String]?.[f64]?.ok\n$env?.[String]?.[foo != nil]\n$env?.[String]?.[foo]\n$env?.[String]?.[foo].String\n$env?.[String]?.[foo].f64\n$env?.[String]?.[foo].i\n$env?.[String]?.[foo]?.String\n$env?.[String]?.[foo]?.[ok]\n$env?.[String]?.[foo]?.[ok]?.[f64]\n$env?.[String]?.[foo]?.add\n$env?.[String]?.[foo]?.f64()\n$env?.[String]?.[greet]\n$env?.[String]?.[greet].String\n$env?.[String]?.[greet].str\n$env?.[String]?.[greet]?.[ok]\n$env?.[String]?.[greet]?.i\n$env?.[String]?.[greet]?.list(foobar)\n$env?.[String]?.[greet]?.str\n$env?.[String]?.[i]\n$env?.[String]?.[i].Bar\n$env?.[String]?.[i].f64\n$env?.[String]?.[i].foo\n$env?.[String]?.[i].list\n$env?.[String]?.[i].ok\n$env?.[String]?.[i]?.array\n$env?.[String]?.[list]\n$env?.[String]?.[list].array()\n$env?.[String]?.[list].greet\n$env?.[String]?.[list].ok\n$env?.[String]?.[list]?.String()\n$env?.[String]?.[list]?.[add]\n$env?.[String]?.[list]?.greet\n$env?.[String]?.[ok and ok]\n$env?.[String]?.[ok not in $env]\n$env?.[String]?.[ok]\n$env?.[String]?.[ok].add\n$env?.[String]?.[ok].ok\n$env?.[String]?.[ok]?.Bar\n$env?.[String]?.[ok]?.[f64]\n$env?.[String]?.[ok]?.greet\n$env?.[String]?.[ok]?.i\n$env?.[String]?.[str]\n$env?.[String]?.[str].f64\n$env?.[String]?.[str]?.[f64]\n$env?.[String]?.[str]?.foo\n$env?.[String]?.add\n$env?.[String]?.add()\n$env?.[String]?.add()?.[foo]\n$env?.[String]?.add()?.f64()\n$env?.[String]?.add(1)\n$env?.[String]?.add(foobar)\n$env?.[String]?.add.Bar\n$env?.[String]?.add.String\n$env?.[String]?.add?.[add]\n$env?.[String]?.add?.[greet]\n$env?.[String]?.add?.greet\n$env?.[String]?.add?.greet()\n$env?.[String]?.all(ok)\n$env?.[String]?.any(foobar, ok)\n$env?.[String]?.array\n$env?.[String]?.array()\n$env?.[String]?.array()?.f64(list)\n$env?.[String]?.array(String)\n$env?.[String]?.array(add)\n$env?.[String]?.array(f64)\n$env?.[String]?.array(foobar not startsWith foo)\n$env?.[String]?.array(foobar)\n$env?.[String]?.array(i)\n$env?.[String]?.array(str)\n$env?.[String]?.array.String\n$env?.[String]?.array.array(String, foo)\n$env?.[String]?.array.i\n$env?.[String]?.array.i()\n$env?.[String]?.array.ok\n$env?.[String]?.array?.Bar\n$env?.[String]?.array?.[greet]\n$env?.[String]?.array?.f64\n$env?.[String]?.array?.foo\n$env?.[String]?.array?.list(i)\n$env?.[String]?.bitshl(foobar)\n$env?.[String]?.bitushr(foobar)\n$env?.[String]?.ceil(nil)\n$env?.[String]?.f64\n$env?.[String]?.f64()\n$env?.[String]?.f64().Bar\n$env?.[String]?.f64()?.f64\n$env?.[String]?.f64(String?.[array])\n$env?.[String]?.f64(foobar)\n$env?.[String]?.f64.Bar()\n$env?.[String]?.f64.i\n$env?.[String]?.f64.ok\n$env?.[String]?.f64?.String\n$env?.[String]?.f64?.[add]\n$env?.[String]?.f64?.[ok]?.str\n$env?.[String]?.f64?.foo()\n$env?.[String]?.f64?.greet()\n$env?.[String]?.f64?.i\n$env?.[String]?.f64?.ok()\n$env?.[String]?.false?.str\n$env?.[String]?.find(foobar)\n$env?.[String]?.foo\n$env?.[String]?.foo()\n$env?.[String]?.foo()?.str\n$env?.[String]?.foo(f64, foobar)\n$env?.[String]?.foo(foobar)\n$env?.[String]?.foo.String\n$env?.[String]?.foo.foo\n$env?.[String]?.foo.greet\n$env?.[String]?.foo.ok\n$env?.[String]?.foo.str\n$env?.[String]?.foo?.Bar\n$env?.[String]?.foo?.String\n$env?.[String]?.foo?.[add]\n$env?.[String]?.foo?.[array]\n$env?.[String]?.foo?.[f64]\n$env?.[String]?.foo?.[foo]\n$env?.[String]?.foo?.array\n$env?.[String]?.foo?.i\n$env?.[String]?.foo?.list\n$env?.[String]?.foo?.str\n$env?.[String]?.foo?.str()\n$env?.[String]?.foobar\n$env?.[String]?.foobar.f64\n$env?.[String]?.foobar.str()\n$env?.[String]?.foobar?.[list]\n$env?.[String]?.foobar?.[ok]\n$env?.[String]?.foobar?.array\n$env?.[String]?.foobar?.foo\n$env?.[String]?.foobar?.i\n$env?.[String]?.foobar?.i()\n$env?.[String]?.fromJSON(foobar)\n$env?.[String]?.fromPairs(false)\n$env?.[String]?.get(str)\n$env?.[String]?.greet\n$env?.[String]?.greet != str\n$env?.[String]?.greet()\n$env?.[String]?.greet().Bar\n$env?.[String]?.greet()?.[list]\n$env?.[String]?.greet()?.[str]\n$env?.[String]?.greet(add)\n$env?.[String]?.greet(foobar)\n$env?.[String]?.greet(greet)\n$env?.[String]?.greet.add\n$env?.[String]?.greet.array()\n$env?.[String]?.greet.foo\n$env?.[String]?.greet.i\n$env?.[String]?.greet.list\n$env?.[String]?.greet?.Bar\n$env?.[String]?.greet?.[array]\n$env?.[String]?.greet?.[str]\n$env?.[String]?.greet?.list.str\n$env?.[String]?.groupBy(1.0)\n$env?.[String]?.groupBy(foobar)\n$env?.[String]?.groupBy(str)\n$env?.[String]?.hasPrefix(nil)?.String\n$env?.[String]?.i\n$env?.[String]?.i()\n$env?.[String]?.i()?.[array]\n$env?.[String]?.i()?.[greet]\n$env?.[String]?.i(foo)\n$env?.[String]?.i(foobar)\n$env?.[String]?.i(ok)\n$env?.[String]?.i(str)\n$env?.[String]?.i(true)\n$env?.[String]?.i.String\n$env?.[String]?.i.greet\n$env?.[String]?.i.list\n$env?.[String]?.i?.[greet]\n$env?.[String]?.i?.[ok]\n$env?.[String]?.i?.foo\n$env?.[String]?.i?.foo()\n$env?.[String]?.i?.greet\n$env?.[String]?.i?.list\n$env?.[String]?.i?.ok.f64\n$env?.[String]?.int(foo)\n$env?.[String]?.len(false)\n$env?.[String]?.list\n$env?.[String]?.list()\n$env?.[String]?.list(1.0)\n$env?.[String]?.list(Bar)\n$env?.[String]?.list(foobar)\n$env?.[String]?.list(foobar).greet\n$env?.[String]?.list(greet)\n$env?.[String]?.list(nil in foobar or foobar)\n$env?.[String]?.list(ok)\n$env?.[String]?.list(true, true)\n$env?.[String]?.list.add()\n$env?.[String]?.list.foo\n$env?.[String]?.list.list\n$env?.[String]?.list?.[ok]\n$env?.[String]?.list?.add?.list\n$env?.[String]?.list?.array\n$env?.[String]?.list?.foobar\n$env?.[String]?.list?.i\n$env?.[String]?.nil.String\n$env?.[String]?.not\n$env?.[String]?.ok\n$env?.[String]?.ok()\n$env?.[String]?.ok()?.list\n$env?.[String]?.ok(f64, foobar)\n$env?.[String]?.ok(foobar?.[1.0])\n$env?.[String]?.ok(toJSON(foo)).f64\n$env?.[String]?.ok.add\n$env?.[String]?.ok.foo\n$env?.[String]?.ok.i\n$env?.[String]?.ok.str\n$env?.[String]?.ok?.[f64]\n$env?.[String]?.ok?.[foo]\n$env?.[String]?.ok?.[list]\n$env?.[String]?.ok?.[ok]\n$env?.[String]?.ok?.add\n$env?.[String]?.ok?.f64\n$env?.[String]?.ok?.ok\n$env?.[String]?.one($env)\n$env?.[String]?.one(foobar)?.[f64]\n```\n\n----------------------------------------\n\nTITLE: Array Find Index\nDESCRIPTION: Finds the index of the first element in the array that is not equal to 0. Requires numeric elements. Returns the index of the first element that satisfies the condition, or -1 if no element is found.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_50\n\nLANGUAGE: Expr\nCODE:\n```\narray | findIndex(# != 0)\n```\n\n----------------------------------------\n\nTITLE: Bitwise NAND Operations in Expr\nDESCRIPTION: Illustrates usage of the `bitnand` function in Expr, showcasing type interactions between integers and the impact of bitwise operations in conditional expressions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_17\n\nLANGUAGE: Expr\nCODE:\n```\nbitnand(1, i64) != int(i64)\nbitnand(i, i)\nbitnand(i, i32 + i32)\nbitnand(i, i32)\nbitnand(i, i64)\nbitnand(i32, bitnot(1))\nbitnand(i32, i)\nbitnand(i32, i32)\nbitnand(i32, i64)\nbitnand(i64 + i, i32)\nbitnand(i64 + i64, i64)\nbitnand(i64, -1)\nbitnand(i64, 1) + i64 + 1\nbitnand(i64, i)\nbitnand(i64, i32)\nbitnand(i64, i32) > f64\nbitnand(i64, i64)\n```\n\n----------------------------------------\n\nTITLE: Logical and Comparison Operations with 'not in' - Expr\nDESCRIPTION: Illustrates the usage of 'not in' operator combined with logical and comparison operations in the Expr language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_108\n\nLANGUAGE: Expr\nCODE:\n```\nfoo not in list != false\nfoo not in list && ok\n```\n\n----------------------------------------\n\nTITLE: Using findLastIndex with ranges and arrays and string operations\nDESCRIPTION: Illustrates the use of `findLastIndex` with range, arrays and string operations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_47\n\nLANGUAGE: expr\nCODE:\n```\nfindLastIndex(1 .. 1, i64 < #)\nfindLastIndex([i64, half], ok)\nfindLastIndex(array, \"bar\" not matches \"foo\")\nfindLastIndex(array, \"bar\" startsWith \"foo\")\nfindLastIndex(array, \"foo\" == nil)\nfindLastIndex(array, \"foo\" >= \"foo\")\nfindLastIndex(array, \"foo\" contains \"foo\")\n```\n\n----------------------------------------\n\nTITLE: Function Calls with Numeric Literals in Expr\nDESCRIPTION: These snippets demonstrate calling functions (max, min) with numeric literals and using bitwise operators in the Expr language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_276\n\nLANGUAGE: Expr\nCODE:\n```\n{foo: 1.0 | max(1.0)}\n{foo: 1.0 | min(1)}\n```\n\n----------------------------------------\n\nTITLE: Expr: Boolean short circuit evaluation\nDESCRIPTION: This snippet showcases the short-circuit evaluation of boolean expressions in the Expr language.  It focuses on the ?: operator, where the right-hand side is evaluated only if the left-hand side is false.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_249\n\nLANGUAGE: Expr\nCODE:\n```\ntrue ?: $env != 0 ^ $env\ntrue ?: $env % i\ntrue ?: $env | count(.list)\ntrue ?: $env | find(#)\ntrue ?: $env | groupBy(1.0)\ntrue ?: $env | reduce(#.list)\ntrue ?: $env | reduce(1.0)\ntrue ?: $env.add\ntrue ?: $env.array\ntrue ?: $env.foo\ntrue ?: $env.greet\ntrue ?: $env.i\ntrue ?: $env.list\ntrue ?: $env.ok\ntrue ?: $env.str\ntrue ?: $env?.[Bar]\ntrue ?: $env?.[String()]\ntrue ?: $env?.[array]\ntrue ?: $env?.[i]\ntrue ?: $env?.[list]\ntrue ?: $env?.add\ntrue ?: $env?.array\ntrue ?: $env?.f64\ntrue ?: $env?.foo\ntrue ?: $env?.greet\ntrue ?: $env?.ok\ntrue ?: $env[:foobar]\ntrue ?: 1.0 == f64\ntrue ?: foo.Bar\ntrue ?: foo.String\ntrue ?: foo?.String\ntrue ?: nil != f64\ntrue ?: nil == $env?.str\n\n```\n\n----------------------------------------\n\nTITLE: String Conversion with Specific Data Types and Comparison\nDESCRIPTION: This code snippet examines the use of string conversion in conjunction with specific data types, such as float64, and checks how these interact during comparison. The tests validate that the values and operations are handled correctly when converted to strings.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_229\n\nLANGUAGE: Expr\nCODE:\n```\nstring(f64 != $env)\nstring(f64 != f64)\nstring(f64 != nil)\nstring(f64 * 1)\nstring(f64 * f64)\nstring(f64 ** 0)\nstring(f64 ** 1.0)\nstring(f64 + 1)\nstring(f64 + 1.0)\nstring(f64 + f64)\nstring(f64 - 1)\nstring(f64 < 1.0)\nstring(f64 < f64)\nstring(f64 == $env)\nstring(f64 == 1.0)\nstring(f64 == nil)\nstring(f64 > 0)\nstring(f64 > 1)\nstring(f64 > 1.0)\nstring(f64 > f64)\nstring(f64 >= 0)\nstring(f64 >= 1.0)\nstring(f64 >= i)\nstring(f64 ^ 1.0)\nstring(f64 ^ i)\nstring(f64)\nstring(f64) + str\nstring(f64) < str\n```\n\n----------------------------------------\n\nTITLE: Expr groupBy with list and placeholders\nDESCRIPTION: Demonstrates using 'list' instead of 'array' with various expressions involving placeholders and safe navigation.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_136\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(list, # == #)\ngroupBy(list, #)\ngroupBy(list, #).Bar\ngroupBy(list, #).String\ngroupBy(list, #).add\ngroupBy(list, #).array\ngroupBy(list, #).f64\ngroupBy(list, #).foo\ngroupBy(list, #).greet\ngroupBy(list, #).i\ngroupBy(list, #).list\ngroupBy(list, #).ok\ngroupBy(list, #).str\ngroupBy(list, #)?.Bar\ngroupBy(list, #)?.String\ngroupBy(list, #)?.[f64]\ngroupBy(list, #)?.[foo]\ngroupBy(list, #)?.[i]\ngroupBy(list, #)?.[ok]\ngroupBy(list, #)?.[str]\ngroupBy(list, #)?.add\ngroupBy(list, #)?.array\ngroupBy(list, #)?.f64\ngroupBy(list, #)?.foo\ngroupBy(list, #)?.greet\ngroupBy(list, #)?.i\ngroupBy(list, #)?.list\ngroupBy(list, #)?.ok\ngroupBy(list, #)?.str\n```\n\n----------------------------------------\n\nTITLE: Generating JSON Documentation with Expr\nDESCRIPTION: This code snippet demonstrates how to generate documentation in JSON format using the `docgen` package. It imports necessary packages, creates documentation from a placeholder `env` variable, marshals the documentation into JSON format, and prints it to the console. You need to replace `env` with your actual environment type.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docgen/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n  \n\t\"github.com/expr-lang/expr/docgen\"\n)\n\nfunc main() {\n\t// TODO: Replace env with your own types.\n\tdoc := docgen.CreateDoc(env)\n  \n\tbuf, err := json.MarshalIndent(doc, \"\", \"  \")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(string(buf))\n}\n```\n\n----------------------------------------\n\nTITLE: Expr Boolean AND Operations\nDESCRIPTION: This snippet represents logical AND operations with the boolean 'false' as the left-hand operand in the Expr language. The code showcases usage with environment variables, function results, and other complex expressions, highlighting short-circuiting behavior and type compatibility checks within the logical AND context. The goal is to demonstrate the behavior of AND with a boolean false.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_93\n\nLANGUAGE: Expr\nCODE:\n```\nfalse && $env == count(array)\nfalse && $env > findLastIndex($env, #)\nfalse && $env >= sum($env)?.[array]\nfalse && $env in str\nfalse && $env not in list\nfalse && $env or ok\nfalse && $env.ok\nfalse && $env?.Bar\nfalse && $env?.String\nfalse && $env?.String()\nfalse && $env?.String(foobar.Bar)\nfalse && $env?.[Bar]\nfalse && $env?.[String]\nfalse && $env?.[add]\nfalse && $env?.[add].array\nfalse && $env?.[array]\nfalse && $env?.[array]?.[ok]\nfalse && $env?.[f64 > str]\nfalse && $env?.[f64]\nfalse && $env?.[f64]?.array\nfalse && $env?.[foo]\nfalse && $env?.[foobar - foobar]\nfalse && $env?.[foobar.add]\nfalse && $env?.[foobar]\nfalse && $env?.[greet]\nfalse && $env?.[greet].i\nfalse && $env?.[i]\nfalse && $env?.[list]\nfalse && $env?.[ok]\nfalse && $env?.[ok].add\nfalse && $env?.[str]\nfalse && $env?.[str].String\nfalse && $env?.foobar\nfalse && $env?.ok\nfalse && $env[:Bar < 0]\nfalse && $env[:ok()]\nfalse && $env[foobar:Bar]\nfalse && $env[foobar:foobar?.[String]]\nfalse && $env[foobar?.ok(foobar):]\nfalse && $env[i:]\nfalse && $env[ok.String:all(foobar, #.foo)]\nfalse && 0 >= i\nfalse && 0 not in map($env, i)\nfalse && 1 == 1 ** $env\nfalse && 1.0 == i\nfalse && 1.0 == int(1)\nfalse && 1.0 > $env[:ok]\nfalse && 1.0 > i\nfalse && f64 < i\nfalse && i < f64\nfalse && i in array\nfalse && nil != greet\nfalse && nil == ok\nfalse && nil in reduce($env, #)\nfalse && ok || ok\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT Operation in Expr\nDESCRIPTION: Examples of the `bitnot` function in Expr, including its usage with environment variables, array lookups, boolean expressions, and function results.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_69\n\nLANGUAGE: Expr\nCODE:\n```\nbitnot($env | findIndex(true))\nbitnot($env | findLastIndex(ok))\nbitnot($env.i)\nbitnot($env?.[str]?.[i])\nbitnot($env?.i)\nbitnot(0 * 1)\nbitnot(0 * i)\nbitnot(0 - 0)\nbitnot(0 - 1)\nbitnot(0 | min(0))\nbitnot(0) < f64\nbitnot(0) == $env?.[Bar]\nbitnot(0) in array\nbitnot(0) | min(array, 0)\nbitnot(1 % i)\nbitnot(1 * 0)\nbitnot(1 - i)\nbitnot(1 | min(i))\nbitnot(1) != i && false\nbitnot(1) == f64\nbitnot(abs(i))\nbitnot(array | count(false))\nbitnot(array | count(ok))\nbitnot(array | sum(#))\nbitnot(array | sum(i))\nbitnot(array?.[0])\nbitnot(array?.[i])\nbitnot(bitand(1, 0))\nbitnot(bitnot(0))\nbitnot(bitnot(1))\nbitnot(bitnot(i))\nbitnot(count(array, false))\nbitnot(count(list, ok))\nbitnot(false ? nil : 1)\nbitnot(false ?: 1)\nbitnot(findIndex($env, ok))\nbitnot(findIndex(array, ok))\nbitnot(findLastIndex(array, true))\nbitnot(first(array))\nbitnot(i % i)\nbitnot(i * 0)\nbitnot(i * 1)\nbitnot(i + 0)\nbitnot(i | add(i))\nbitnot(i | min(1.0))\nbitnot(i)\nbitnot(i) + i\nbitnot(i) - i\nbitnot(if false { f64 } else { 0 })\nbitnot(if true { 1 } else { foo })\nbitnot(int(1))\nbitnot(int(1.0))\nbitnot(int(f64))\nbitnot(last(array))\nbitnot(len($env))\nbitnot(len(array))\nbitnot(len(str))\nbitnot(list | findLastIndex(ok))\nbitnot(list | findLastIndex(true))\nbitnot(max(0))\nbitnot(max(1))\nbitnot(max(1, 0))\nbitnot(max(array, 0))\nbitnot(max(i))\nbitnot(min(0))\nbitnot(min(array))\nbitnot(min(i))\nbitnot(min(i, 0))\nbitnot(reduce(array, #))\nbitnot(reduce(array, 0))\nbitnot(reduce(list, i))\nbitnot(sum(array))\nbitnot(sum(array, #))\nbitnot(sum(list, 0))\n```\n\n----------------------------------------\n\nTITLE: Evaluating first function with various inputs - Expr\nDESCRIPTION: This snippet demonstrates the use of the `first` function on a range of inputs, including ranges, arrays, maps, and conditional expressions. The purpose is likely to test the function's behavior with different data types and complex expressions. It covers cases with optional chaining and property access.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_52\n\nLANGUAGE: Expr\nCODE:\n```\nfirst(1 .. 1)\nfirst(1 .. i64)\nfirst([f32])\nfirst([foo])\nfirst([ok])\nfirst(array)\nfirst(array) * i\nfirst(array) * i64\nfirst(array) + f32\nfirst(array) <= i\nfirst(array) == f32\nfirst(array) == f64\nfirst(array) == i64\nfirst(array) > 0.5 ** i\nfirst(array) > i64\nfirst(array) ^ f64\nfirst(array[1:1])\nfirst(false ? foo : 1)\nfirst(false ? greet : foo)\nfirst(get(groupBy(array, #), i))\nfirst(groupBy(array, #).greet)\nfirst(groupBy(list, #)?.div)\nfirst(i .. i)\nfirst(i64 .. i32)\nfirst(i64 .. i64)\nfirst(list)\nfirst(list) not in list\nfirst(list).Bar\nfirst(list).Qux\nfirst(list).String\nfirst(list).String()\nfirst(list)?.Bar\nfirst(list)?.Qux\nfirst(list)?.String\nfirst(list)?.String()\nfirst(map(array, #))\nfirst(map(array, 0.5))\nfirst(map(array, 1))\nfirst(map(array, add))\nfirst(map(array, array))\nfirst(map(array, div))\nfirst(map(array, half))\nfirst(map(array, i))\nfirst(map(array, i32))\nfirst(map(array, i64))\nfirst(map(array, ok))\nfirst(map(list, #))\nfirst(map(list, 0.5))\nfirst(map(list, f32))\nfirst(map(list, greet))\nfirst(map(list, i))\nfirst(map(list, list))\nfirst(map(list, score))\nfirst(ok ? 0.5 : false)\nfirst(ok ? array : add)\nfirst(ok ? greet : i64)\nfirst(ok ? list : ok)\nfirst(reduce(list, array))\nfirst(sort(array))\nfirst(true ? f32 : div)\nfirst(true ? greet : div)\nfirst(true ? score : div)\n```\n\n----------------------------------------\n\nTITLE: Mapping with Nested Functions and Sort in Expr\nDESCRIPTION: Illustrates using nested `map` calls and the `sort` function. This shows how to sort an environment variable, or the results of another function call.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_190\n\nLANGUAGE: Expr\nCODE:\n```\nmap(map(array, #), #)\nmap(sort($env), #.greet?.Bar(Bar))\n```\n\n----------------------------------------\n\nTITLE: duration Function in Expr\nDESCRIPTION: Illustrates the use of the `duration` function to create a `time.Duration` value from a string.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_36\n\nLANGUAGE: expr\nCODE:\n```\nduration(\"1h\").Seconds() == 3600\n```\n\n----------------------------------------\n\nTITLE: Nested Mapping with Environment Variable in Expr\nDESCRIPTION: This snippet shows a nested `map` operation involving an environment variable in Expr. It first maps the environment variable to a new list using `map($env | map(foo), #.String)`, then accesses a field called String from each element in the resulting list.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_178\n\nLANGUAGE: Expr\nCODE:\n```\nmap($env | map(foo), #.String)\n```\n\n----------------------------------------\n\nTITLE: Expr Boolean Equality Operations\nDESCRIPTION: This snippet showcases equality comparisons (==) where the boolean 'false' is the left-hand operand. It illustrates comparisons with environment variables, including optional chaining, and other identifiers. These expressions demonstrate how the equality operator behaves in different contexts.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_94\n\nLANGUAGE: Expr\nCODE:\n```\nfalse == $env && ok\nfalse == $env.ok\nfalse == $env?.Bar\nfalse == $env?.String\nfalse == $env?.[Bar]\nfalse == $env?.[String]\nfalse == $env?.[String]?.[f64]\nfalse == $env?.[String]?.greet\nfalse == $env?.[foobar]?.[str]\nfalse == $env?.[str]\nfalse == $env?.ok\nfalse == nil && ok\n```\n\n----------------------------------------\n\nTITLE: Predicate with Struct Access in Expr\nDESCRIPTION: Illustrates accessing struct fields within a predicate without explicitly using the `#` symbol.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_19\n\nLANGUAGE: expr\nCODE:\n```\nfilter(tweets, {len(.Content) > 240})\n```\n\n----------------------------------------\n\nTITLE: Implementing ast.Visitor in Go\nDESCRIPTION: This code snippet shows how to implement the `ast.Visitor` interface to collect identifiers from an expression's AST. The `Visit` method checks if a node is an `ast.IdentifierNode` and, if so, appends its value to the `Identifiers` slice.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/visitor.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype Visitor struct {\n    Identifiers []string\n}\n\nfunc (v *Visitor) Visit(node *ast.Node) {\n    if n, ok := (*node).(*ast.IdentifierNode); ok {\n        v.Identifiers = append(v.Identifiers, n.Value)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Nil Comparison in Expr\nDESCRIPTION: Demonstrates comparisons of the `nil` value with environment variables in the Expr language. It shows how to check if an environment variable is not equal to nil.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_195\n\nLANGUAGE: text\nCODE:\n```\nnil != $env.add\nnil != $env.array\nnil != $env.f64\nnil != $env.foo\nnil != $env.greet\n```\n\n----------------------------------------\n\nTITLE: Chained Operations and 'none' function\nDESCRIPTION: This snippet demonstrates a combination of chained operations, the 'none' function with lambdas, and access to environment variables and function calls within the Expr language.  It showcases conditional evaluation and list comprehensions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_200\n\nLANGUAGE: Expr\nCODE:\n```\nnil; $env.greet\nnil; $env.ok\nnone($env | map($env), .f64 != foo)\nnone($env, false) && ok == true\nnone($env.array, str not in $env)\nnone($env?.[str], 1 > f64)\nnone($env?.[str], ok)\nnone(1 .. 0, $env < $env)\nnone(1 .. 0, $env | all(ok))\nnone([$env, foo], false != #)\nnone([$env], .f64 in #.String)\nnone([1.0], ok)\nnone([greet, 1.0], ok)\nnone([nil, foo], ok)\nnone(array, # != #)\nnone(array, # != 0)\nnone(array, # != nil)\nnone(array, # < 1)\nnone(array, # <= #)\nnone(array, # == 0)\nnone(array, # >= #)\nnone(array, $env == foo)\nnone(array, $env.ok)\nnone(array, 0 <= 0)\nnone(array, 1 == #)\nnone(array, add == add)\nnone(array, f64 == #)\nnone(array, i != #)\nnone(array, i < #)\nnone(array, nil == i)\nnone(array, ok && false)\nnone(array, ok)\nnone(concat(array), f64 >= #)\nnone(flatten(array), ok)\nnone(list | map($env), #.ok)\nnone(list | map(str), ok)\nnone(list, # != foo)\nnone(list, # == #)\nnone(list, $env != $env)\nnone(list, $env != i)\nnone(list, $env != nil)\nnone(list, $env.ok)\nnone(list, 1 == f64)\nnone(list, 1.0 > 1.0)\nnone(list, array == $env)\nnone(list, f64 != $env)\nnone(list, false != true)\nnone(list, foo != foo)\nnone(list, foo == #)\nnone(list, foo == foo)\nnone(list, ok == $env)\nnone(list, ok)\nnone(list, str < .Bar)\nnone(list, true == $env)\nnone(map($env, 1.0), ok)\nnone(map(list, $env), ok)\nnone(sort($env), #.add?.greet(foo))\n```\n\n----------------------------------------\n\nTITLE: Array Get\nDESCRIPTION: Retrieves an element from the array at index 0. Requires array elements. Returns the element at the specified index.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_53\n\nLANGUAGE: Expr\nCODE:\n```\narray | get(0)\n```\n\n----------------------------------------\n\nTITLE: Counting with Relational Operators in Expr\nDESCRIPTION: This snippet illustrates the usage of various relational operators (e.g., !=, <, <=, ==, >, >=) within the count function in Expr. The conditions involve comparisons between elements of an array (represented by '#') and other values (e.g., numbers, variables, nil).\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_27\n\nLANGUAGE: Expr\nCODE:\n```\ncount(array, # != #)\ncount(array, # != 0.5)\ncount(array, # != i)\ncount(array, # != i64)\ncount(array, # != nil)\ncount(array, # < #)\ncount(array, # < i)\ncount(array, # < i32)\ncount(array, # <= #)\ncount(array, # <= 0.5)\ncount(array, # <= 1)\ncount(array, # <= i)\ncount(array, # <= i32)\ncount(array, # == #)\ncount(array, # == 0.5)\ncount(array, # == 1)\ncount(array, # == f32)\ncount(array, # == i)\ncount(array, # == i64)\ncount(array, # == nil)\ncount(array, # > #)\ncount(array, # > 0.5)\ncount(array, # > i)\ncount(array, # > i64)\ncount(array, # >= #)\ncount(array, # >= 0.5)\ncount(array, # >= 1)\ncount(array, # >= f32)\ncount(array, # >= i)\n```\n\n----------------------------------------\n\nTITLE: hasPrefix Function in Expr\nDESCRIPTION: Shows how to use the `hasPrefix` function to check if a string starts with a given prefix.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_33\n\nLANGUAGE: expr\nCODE:\n```\nhasPrefix(\"HelloWorld\", \"Hello\") == true\n```\n\n----------------------------------------\n\nTITLE: Conditional Property Access in Expr\nDESCRIPTION: These examples showcase conditional property access in Expr using the optional chaining operator (?.), accessing properties based on runtime conditions, including accessing String properties and method calls.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_278\n\nLANGUAGE: Expr\nCODE:\n```\n{foo: $env?.add}?.array\n{foo: 0}?.add\n{foo: 0}?.array\n{foo: 0}?.f64\n{foo: 0}?.foo\n{foo: 0}?.greet\n{foo: 0}?.i\n{foo: 0}?.list\n{foo: 0}?.ok\n{foo: 0}?.str\n{foo: 1, foo: 0}?.f64\n{foo: 1, foo: 0}?.list\n{foo: 1, foo: 1.0}?.Bar\n{foo: 1, foo: 1.0}?.foobar\n{foo: 1, foo: 1.0}?.greet\n{foo: 1, foo: 1}?.ok\n{foo: 1, foo: add}?.Bar\n{foo: 1, foo: add}?.list\n{foo: 1, foo: array}?.ok\n{foo: 1, foo: f64}?.f64\n{foo: 1, foo: f64}?.i\n{foo: 1, foo: false}?.add\n{foo: 1, foo: false}?.ok\n{foo: 1, foo: foo}?.foo\n{foo: 1, foo: foo}?.foobar\n{foo: 1, foo: foo}?.greet\n{foo: 1, foo: foo}?.list\n{foo: 1, foo: greet}?.greet\n{foo: 1, foo: list}?.Bar\n{foo: 1, foo: add}?.add\n{foo: 1, foo: nil}?.Bar\n{foo: 1, foo: nil}?.String\n{foo: 1, foo: nil}?.add\n{foo: 1, foo: nil}?.list\n{foo: 1, foo: nil}?.str\n{foo: 1, foo: ok}?.String\n{foo: 1, foo: ok}?.str\n{foo: 1, foo: str}?.str\n{foo: 1.0, foo: 0}?.foo\n{foo: 1.0, foo: 0}?.str\n{foo: 1.0, foo: 1.0}?.add\n{foo: 1.0, foo: 1.0}?.f64\n{foo: 1.0, foo: 1.0}?.greet\n{foo: 1.0, foo: 1}?.Bar\n{foo: 1.0, foo: 1}?.add\n{foo: 1.0, foo: 1}?.greet\n{foo: 1.0, foo: 1}?.i\n{foo: 1.0, foo: add}?.String\n{foo: 1.0, foo: add}?.f64\n{foo: 1.0, foo: add}?.greet\n{foo: 1.0, foo: add}?.list\n{foo: 1.0, foo: array}?.Bar\n{foo: 1.0, foo: array}?.f64\n{foo: 1.0, foo: array}?.list\n{foo: 1.0, foo: false}?.f64\n{foo: 1.0, foo: false}?.foo\n{foo: 1.0, foo: foo, foo: add}.array\n{foo: 1.0, foo: foo, foo: false}?.greet\n{foo: 1.0, foo: foo}.Bar\n{foo: 1.0, foo: foo}.f64\n{foo: 1.0, foo: foo}.foo\n{foo: 1.0, foo: foo}.list\n{foo: 1.0, foo: greet}.i\n{foo: 0}?.Bar\n{foo: 0}?.String\n{foo: 0}?.add\n{foo: 0}?.array\n{foo: 0}?.f64\n{foo: 0}?.foo\n{foo: 0}?.greet\n{foo: 0}?.i\n{foo: 0}?.list\n{foo: 0}?.ok\n{foo: 0}?.str\n{foo: 0, foo: $env}?.greet\n{foo: 0, foo: $env}?.str\n{foo: 0, foo: 0}?.f64\n{foo: 0, foo: 0}?.ok\n{foo: 0, foo: 1.0}?.f64\n{foo: 0, foo: 1.0}?.i\n{foo: 0, foo: 1}?.ok\n{foo: 0, foo: add}?.array\n{foo: 0, foo: add}?.foobar\n{foo: 0, foo: add}?.greet\n{foo: 0, foo: array}?.foo\n{foo: 0, foo: array}?.not\n{foo: 0, foo: f64}?.foo\n{foo: 0, foo: false}?.f64\n{foo: 0, foo: false}?.foo\n{foo: 0, foo: foo}?.array\n{foo: 0, foo: foo}?.f64\n{foo: 0, foo: foo}?.ok\n{foo: 0, foo: greet}?.add\n{foo: 0, foo: greet}?.str\n{foo: 0, foo: i}?.foo.Bar\n{foo: 1, foo: 0, foo: add}?.array\n{foo: 1, foo: 1.0}?.str?.array()\n{foo: 1, foo: add}?.Bar\n{foo: 1, foo: array}?.foo\n{foo: 1, foo: foo}.f64\n{foo: 1, foo: nil, foo: greet}.foo\n{foo: 1, foo: ok}.foo\n{foo: 1, foo: str, foo: 0}.i\n{foo: 1.0, foo: 1.0}?.f64\n{foo: 1.0, foo: add}?.f64?.str?.[array]\n{foo: 0, foo: list}?.f64\n```\n\n----------------------------------------\n\nTITLE: Using flatten Function in Expr\nDESCRIPTION: This snippet demonstrates the usage of the `flatten` function in the Expr language. It showcases examples of flattening nested arrays, using conditional expressions, and accessing properties of the flattened data.  It collapses a multi-dimensional array into a single-dimensional array.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_99\n\nLANGUAGE: Expr\nCODE:\n```\nflatten($env | map(array))\nflatten($env | map(foo))\nflatten($env | map(i))\nflatten($env.array)\nflatten($env.list)\nflatten($env?.array)\nflatten($env?.list)\nflatten($env?.list)?.[i]\nflatten(0 .. i)\nflatten(1 .. 1)\nflatten(1 .. i)\nflatten([$env])\nflatten([0 <= 1])\nflatten([0, 1.0])\nflatten([0])\nflatten([1.0, foo])\nflatten([1.0])\nflatten([1])\nflatten([add, greet])\nflatten([add])\nflatten([array, ok])\nflatten([array])\nflatten([f64])\nflatten([false, list])\nflatten([false])\nflatten([foo, 1.0])\nflatten([foo])\nflatten([greet])\nflatten([i, list])\nflatten([i])\nflatten([list])\nflatten([nil])\nflatten([ok, true])\nflatten([ok])\nflatten([str])\nflatten(array | map(#))\nflatten(array | map(1.0))\nflatten(array | map(false))\nflatten(array | sortBy(#))\nflatten(array | sortBy(1.0))\nflatten(array)\nflatten(array) | groupBy(#)\nflatten(array) | map(#)\nflatten(array) | one(true)\nflatten(array) | reduce(1.0)\nflatten(array) | sum(#)\nflatten(array)?.[i]\nflatten(array)[i:]\nflatten(array[0:])\nflatten(array[:1])\nflatten(concat(array))\nflatten(concat(list))\nflatten(filter(list, false))\nflatten(flatten(array))\nflatten(groupBy(list, #).i)\nflatten(i .. 0)\nflatten(i..i)\nflatten(if true { array } else { add })\nflatten(keys($env))\nflatten(list | map(#))\nflatten(list | map(i))\nflatten(list | sortBy(f64))\nflatten(list | sortBy(str))\nflatten(list)\nflatten(list) == list\nflatten(list) | filter(true)\nflatten(list) | findLastIndex(false)\nflatten(list) | groupBy(foo)\nflatten(list) | map(f64)\nflatten(list) | map(false)\nflatten(list) | map(foo)\nflatten(list) | map(ok)\nflatten(list) | reduce(#)\nflatten(list) | reduce($env, $env)\nflatten(list) | sortBy(0)\n```\n\n----------------------------------------\n\nTITLE: Type Conversion Functions in Expr\nDESCRIPTION: Demonstrates the usage of type conversion functions like `int` and `float` in the Expr language. The snippets illustrate how to convert different data types (numbers, strings, booleans, etc.) to integers and floats. These snippets also demonstrates the use of more complex expressions as arguments to these conversion functions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_164\n\nLANGUAGE: Expr\nCODE:\n```\nint($env | count(ok))\nint($env | findIndex(ok))\nint($env | findIndex(true))\nint($env | sum(i))\nint($env.f64)\nint($env.i)\nint($env?.f64)\nint($env?.i)\nint(0 % 1)\nint(0 % i)\nint(0 * 1)\nint(0 * 1.0)\nint(0 ** 1.0)\nint(0 + 1)\nint(0 + 1.0)\nint(0 - 1.0)\nint(0 / 0)\nint(0 / 1)\nint(0 / i)\nint(0 ^ 0)\nint(0 ^ 1.0)\nint(0 ^ i)\nint(0 | bitshl(0))\nint(0 | bitshr(i))\nint(0 | bitxor(i))\nint(0 | min(1.0, 1))\nint(0) % count(array, true)\nint(0) * i\nint(0) + i\nint(0) - i\nint(0) .. i\nint(0) == i\nint(0) > 1.0 > 1\nint(0) ^ i\nint(0) | mean(i)\nint(0) | median(array)\nint(0)..i\nint(1 % 1)\nint(1 * 0)\nint(1 * 1.0)\nint(1 ** 1.0)\nint(1 ** i)\nint(1 + f64)\nint(1 - 1.0)\nint(1 - f64)\nint(1 - i)\nint(1 / 1.0)\nint(1 / f64)\nint(1 ^ 0)\nint(1 ^ 1.0)\nint(1 | max(i))\nint(1) != i\nint(1) <= f64\nint(1) == f64\nint(1) == i\nint(1) ^ f64\nint(1) not in array\nint(1.0 * 1)\nint(1.0 * 1.0)\nint(1.0 * f64)\nint(1.0 ** 0)\nint(1.0 ** 1.0)\nint(1.0 ** f64)\nint(1.0 + 0)\nint(1.0 + 1)\nint(1.0 - 1)\nint(1.0 / 0)\nint(1.0 / 1)\nint(1.0 / 1.0)\nint(1.0 ^ 1)\nint(1.0 ^ 1.0)\nint(1.0 ^ f64)\nint(1.0 ^ i)\nint(1.0 | min(f64))\nint(1.0)\nint(1.0) != 1.0 ^ i\nint(1.0) != f64\nint(1.0) != i\nint(1.0) * i\nint(1.0) ** f64\nint(1.0) / i\nint(1.0) == f64\nint(1.0) == i\nint(1.0) >= f64\nint(1.0) in array\nint(1.0) | median(array)\nint(1.0)..i\nint(abs(0))\nint(abs(1))\nint(abs(f64))\nint(abs(i))\nint(array | min(1.0))\nint(array | reduce(#))\nint(array | reduce(#index))\nint(array | sum(#))\nint(array?.[1])\nint(array?.[i])\nint(bitnot(0))\nint(bitnot(1))\nint(bitnot(i))\nint(bitshr(0, i))\nint(ceil($env?.i))\nint(ceil(0))\nint(ceil(1))\nint(ceil(f64))\nint(ceil(i))\nint(count($env, true))\nint(count(list, false))\nint(count(list, ok))\nint(f64 * 0)\nint(f64 * 1)\nint(f64 * 1.0)\nint(f64 * f64)\nint(f64 ** 1)\nint(f64 ** i)\nint(f64 + i)\nint(f64 - 0)\nint(f64 - 1)\nint(f64 - 1.0)\nint(f64 - i)\nint(f64 / 0)\nint(f64 ^ 0)\nint(f64 ^ i)\nint(f64 | mean(i))\nint(f64 | min(1.0))\nint(f64)\nint(f64) <= ceil(1.0)\nint(f64) <= f64\nint(f64) == i\nint(f64) in array\nint(findLast(array, true))\nint(findLastIndex($env, ok))\nint(float(0))\nint(float(1))\nint(float(1.0))\nint(float(f64))\nint(float(i))\nint(floor(1.0))\nint(floor(f64))\nint(floor(i))\nint(i % i)\nint(i ** 1)\nint(i ** 1.0)\nint(i ** i)\nint(i + 0)\nint(i + 1)\nint(i + 1.0)\nint(i - 1)\nint(i - 1.0)\nint(i - i)\nint(i / 1.0)\nint(i | bitxor(1))\nint(i)\nint(i) != f64\nint(i) * i\nint(i) .. i\nint(i) < i\nint(i) == sum(array)\nint(i) | min(array)\nint(if true { 1.0 } else { $env })\nint(int(0))\nint(int(1))\nint(int(1.0))\nint(int(i))\nint(last(array))\nint(len($env))\nint(len(0 .. i))\nint(len(array))\nint(len(list))\nint(let foobar = 1.0; foobar)\nint(list | findLastIndex(ok))\nint(list | reduce(#index))\nint(list | reduce(0))\nint(list | reduce(1.0))\nint(list | sum(f64))\nint(max(0))\nint(max(1.0))\nint(max(array))\nint(max(f64))\nint(max(i))\nint(mean(0))\nint(mean(1))\nint(mean(1.0))\nint(mean(1.0, f64))\nint(mean(array))\nint(median(0))\nint(median(1))\nint(median(1.0))\nint(median(array))\nint(median(f64))\nint(median(i))\nint(min(0))\nint(min(1))\nint(min(1.0))\nint(min(array))\nint(min(i))\nint(ok ? 1.0 : greet)\nint(ok ? f64 : list)\nint(reduce(list, 1.0))\nint(round(1))\nint(round(1.0))\nint(round(f64))\nint(round(i))\nint(sum($env, i))\nint(sum(array))\nint(sum(array, #))\nint(sum(array, f64))\nint(true ? 1.0 : $env)\nint(true ? f64 : foo)\n```\n\n----------------------------------------\n\nTITLE: Expr Example: Compile Time Evaluation\nDESCRIPTION: This snippet illustrates how functions calls with constant arguments will be evaluated during compilation, when ConstExpr option is specified.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/configuration.md#_snippet_8\n\nLANGUAGE: expr\nCODE:\n```\nfib(10)    // will be transformed to 55 during the compilation\nfib(12+12) // will be transformed to 267914296 during the compilation\nfib(x)     // will **not** be transformed and will be evaluated at runtime\n```\n\n----------------------------------------\n\nTITLE: Logical Operations\nDESCRIPTION: Demonstrates logical operations like AND (&&), OR (||), and conditional expressions (?:).\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_16\n\nLANGUAGE: EXPR\nCODE:\n```\n1 < $env?.f64 && ok\n1 == f64 && list == $env\n1 < 1.0 || ok\n1 <= 1.0 || ok\n1 == $env && ok != false\n1 > i && ok\n1.0 != 1.0 and $env not endsWith $env\n1.0 != f64 && ok\n1.0 < 1.0 && $env?.String(foobar, i)\n1.0 < 1.0 && $env?.[ok]\n1.0 < 1.0 ? foo != nil : str\n1.0 <= 1.0 and false\n1.0 <= f64 && ok\n1.0 == 1.0 and ok\n1.0 == f64 && ok\n[$env and false]\n[$env and true]\n[$env or false, list]\n[$env or false]\n```\n\n----------------------------------------\n\nTITLE: Membership Tests with 'greet' - Expr\nDESCRIPTION: Demonstrates the usage of 'in' and 'not in' operators with the 'greet' variable to test for membership in different contexts.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_118\n\nLANGUAGE: Expr\nCODE:\n```\ngreet in $env?.Bar\ngreet in $env?.String\ngreet in $env?.[Bar]\ngreet in $env?.[Bar] && ok\ngreet in $env?.[String]\ngreet in $env?.[foobar?.[i]]\ngreet in $env?.foobar?.[foo]\ngreet in $env?.nil\ngreet in $env?.true\ngreet in [nil]\ngreet in sort($env)\ngreet in toPairs($env)\ngreet not in $env?.Bar\ngreet not in $env?.String\ngreet not in $env?.String?.str\ngreet not in $env?.[Bar]\ngreet not in $env?.[String]\ngreet not in $env?.[foobar]\ngreet not in last($env)\ngreet not in toPairs($env)\ngreet not in {foo: foo}.list and ok\n```\n\n----------------------------------------\n\nTITLE: Expr groupBy with floating point constants\nDESCRIPTION: Illustrates grouping with floating-point constants, comparisons, and property access, including safe navigation and the `get` function.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_142\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(list, 1.0 > 1.0)?.[f64]\ngroupBy(list, 1.0 ^ 1.0)\ngroupBy(list, 1.0) | get(1)\ngroupBy(list, 1.0).String\ngroupBy(list, 1.0).add\ngroupBy(list, 1.0).f64\ngroupBy(list, 1.0).foo\ngroupBy(list, 1.0).foobar\ngroupBy(list, 1.0).greet\ngroupBy(list, 1.0).i\ngroupBy(list, 1.0).list\ngroupBy(list, 1.0).str\ngroupBy(list, 1.0)?.Bar\ngroupBy(list, 1.0)?.String\ngroupBy(list, 1.0)?.[f64]\ngroupBy(list, 1.0)?.[foo]\ngroupBy(list, 1.0)?.[i]\ngroupBy(list, 1.0)?.[ok]\ngroupBy(list, 1.0)?.[str]\ngroupBy(list, 1.0)?.add\ngroupBy(list, 1.0)?.array\ngroupBy(list, 1.0)?.f64\ngroupBy(list, 1.0)?.foo\ngroupBy(list, 1.0)?.greet\ngroupBy(list, 1.0)?.i\ngroupBy(list, 1.0)?.ok\ngroupBy(list, 1.0)?.str\n```\n\n----------------------------------------\n\nTITLE: Bitwise AND Operation in Expr\nDESCRIPTION: Demonstrates the bitwise AND operation using the `bitand` function in Expr. It takes two integer arguments and returns the result of the bitwise AND.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_90\n\nLANGUAGE: expr\nCODE:\n```\nbitand(0b1010, 0b1100) == 0b1000\n```\n\n----------------------------------------\n\nTITLE: Conditional `reduce` expressions in Expr\nDESCRIPTION: Examples of using the `reduce` function with conditional expressions to determine the initial value based on a boolean condition. This highlights the flexibility of Expr in handling different data types depending on runtime conditions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_101\n\nLANGUAGE: Expr\nCODE:\n```\nreduce(ok ? \"bar\" : i32, #)\nreduce(ok ? \"foo\" : list, #)\nreduce(ok ? array : half, f32)\nreduce(ok ? list : i, #)\n```\n\n----------------------------------------\n\nTITLE: Array Comparison\nDESCRIPTION: Compares the array with a list using the equality operator. This checks if the array is equal to a specific list.  The operation returns a boolean value indicating whether the array is equal to the list.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_39\n\nLANGUAGE: Expr\nCODE:\n```\narray == list[:]\n```\n\n----------------------------------------\n\nTITLE: Logical NOT with Boolean Operations (Expr)\nDESCRIPTION: This snippet tests the logical NOT operator (!) alongside boolean operations (&&, ||, and, or) and comparisons involving boolean literals (true, false), variables (ok), and nil in the Expr language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_4\n\nLANGUAGE: Expr\nCODE:\n```\n!(false != false)\n!(false != nil)\n!(false != ok)\n!(false != true)\n!(false && false)\n!(false && ok)\n!(false && true)\n!(false == false)\n!(false == nil)\n!(false == ok)\n!(false == true)\n!(false and false)\n!(false and ok)\n!(false and true)\n!(false or false)\n!(false or ok)\n!(false || false)\n!(false || ok)\n!(false || true)\n!(ok != false)\n!(ok != nil)\n!(ok != ok)\n!(ok != true)\n!(ok && false)\n!(ok && ok)\n!(ok && true)\n!(ok == nil)\n!(ok == ok)\n!(ok == true)\n!(ok and ok)\n!(ok and true)\n!(ok or false)\n!(ok or ok)\n!(ok or true)\n!(ok || false)\n!(ok || ok)\n!(ok || true)\n!(true != false)\n!(true != nil)\n!(true != ok)\n!(true != true)\n!(true && false)\n!(true && ok)\n!(true && true)\n!(true == false)\n!(true == nil)\n!(true == ok)\n!(true == true)\n!(true and ok)\n!(true and true)\n!(true or ok)\n!(true or true)\n!(true || false)\n!(true || ok)\n!(true || true)\n!ok\n!ok != !true\n!ok != ok\n!ok && ok\n!ok == ok\n!ok and ok\n!ok or ok\n!ok || ok\n```\n\n----------------------------------------\n\nTITLE: String Conversion with 'foo' variable and its properties\nDESCRIPTION: This snippet concentrates on string conversion with the variable `foo` and its properties, testing different operations and access patterns, including optional chaining.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_233\n\nLANGUAGE: Expr\nCODE:\n```\nstring(foo != $env)\nstring(foo != foo)\nstring(foo != nil)\nstring(foo == $env)\nstring(foo == foo)\nstring(foo == nil)\nstring(foo in list)\nstring(foo not in list)\nstring(foo)\nstring(foo) != $env?.Bar\nstring(foo) != $env?.foobar\nstring(foo) < str\nstring(foo) > str\nstring(foo) contains str\nstring(foo) not endsWith type(str)\nstring(foo) startsWith str\nstring(foo) | greet()\nstring(foo.Bar)\nstring(foo.String())\nstring(foo.String)\nstring(foo?.Bar)\nstring(foo?.Bar) not in foo\nstring(foo?.String())\nstring(foo?.String)\n```\n\n----------------------------------------\n\nTITLE: Array Count\nDESCRIPTION: Counts the number of elements in the array that do not equal each other. This example always evaluates to 0. It returns a numerical count of the elements satisfying the condition.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_47\n\nLANGUAGE: Expr\nCODE:\n```\narray | count(# != #)\n```\n\n----------------------------------------\n\nTITLE: Basic Expr Usage in Go\nDESCRIPTION: This Go example demonstrates a basic usage of Expr. It defines an environment with variables like `greet`, `names`, and `sprintf`, then compiles and runs an expression that uses these variables. The `sprintf` function formats the greeting with the first name in the `names` array.\nSOURCE: https://github.com/expr-lang/expr/blob/master/README.md#_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/expr-lang/expr\"\n)\n\nfunc main() {\n\tenv := map[string]interface{}{\n\t\t\"greet\":   \"Hello, %v!\",\n\t\t\"names\":   []string{\"world\", \"you\"},\n\t\t\"sprintf\": fmt.Sprintf,\n\t}\n\n\tcode := `sprintf(greet, names[0])`\n\n\tprogram, err := expr.Compile(code, expr.Env(env))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\toutput, err := expr.Run(program, env)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(output)\n}\n```\n\n----------------------------------------\n\nTITLE: Addition Operations with 'i' in Expr\nDESCRIPTION: Demonstrates addition operations involving the variable 'i' with various data types, variables, function calls, and expressions, including the safe navigation operator '?.' and array indexing.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_150\n\nLANGUAGE: Expr\nCODE:\n```\ni + $env != str || true\ni + $env.f64\ni + $env.i\ni + $env?.f64\ni + $env?.i\ni + 0 ** f64\ni + 1 != 1.0\ni + 1 .. i\ni + 1 < 0\ni + 1 in array\ni + 1.0 != nil\ni + 1.0 ** f64\ni + 1.0 <= 1.0\ni + 1.0 == f64\ni + abs(1)\ni + array?.[i]\ni + bitnot(0)\ni + ceil($env.i)\ni + f64\ni + f64 ** i\ni + f64 <= i\ni + float(1.0)\ni + i\ni + i / 0\ni + i > i <= 0\ni + i | add(1)\ni + len($env)\ni + max(array, array)\ni + mean(0)\ni + mean(1.0)\ni + mean(i)\ni + reduce(list, 1.0)\n```\n\n----------------------------------------\n\nTITLE: Type Casting to Float - Expr\nDESCRIPTION: This snippet demonstrates type casting to float using the `float()` function. It covers various numeric types (integer, float, and double), arithmetic operations, and function calls as input to the `float()` function. The purpose is to test the type conversion rules and ensure correct handling of different numeric values.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_53\n\nLANGUAGE: Expr\nCODE:\n```\nfloat(-0.5)\nfloat(-1)\nfloat(-f32)\nfloat(-f64)\nfloat(-i)\nfloat(-i32)\nfloat(-i64)\nfloat(0.5 * 0.5)\nfloat(0.5 * 1)\nfloat(0.5 * f32)\nfloat(0.5 * i64)\nfloat(0.5 ** 0.5)\nfloat(0.5 ** f32)\nfloat(0.5 + 1)\nfloat(0.5 + i32)\nfloat(0.5 + i64)\nfloat(0.5 - 0.5)\nfloat(0.5 - 1)\nfloat(0.5 - i64)\nfloat(0.5 / 0.5)\nfloat(0.5 / i32)\nfloat(0.5 / i64)\nfloat(0.5 ^ 1)\nfloat(0.5 ^ i)\nfloat(0.5) != f32\nfloat(0.5) != i32\nfloat(0.5) * f32\nfloat(0.5) * i32\nfloat(0.5) * i64\nfloat(0.5) ** f64\nfloat(0.5) ** i\nfloat(0.5) ** i32\nfloat(0.5) - i\nfloat(0.5) - i64\nfloat(0.5) / f32\nfloat(0.5) / f64\nfloat(0.5) / i32\nfloat(0.5) == i32 * 0.5\nfloat(0.5) ^ i64\nfloat(0.5) in array\nfloat(1 % i64)\nfloat(1 * 0.5)\nfloat(1 * f32)\nfloat(1 * i)\nfloat(1 * i64)\nfloat(1 ** 0.5)\nfloat(1 ** 1)\nfloat(1 ** f64)\nfloat(1 ** i)\nfloat(1 + f64)\nfloat(1 + i32)\nfloat(1 - 0.5)\nfloat(1 / 0.5)\nfloat(1 ^ f64)\nfloat(1) * f32\nfloat(1) * i64\nfloat(1) ** i\nfloat(1) ** i64\nfloat(1) - f64\nfloat(1) <= i64\nfloat(1) == i64\nfloat(1) > -0.5\nfloat(1) > i64\nfloat(1) >= f64\nfloat(1) >= i\nfloat(abs(f32))\nfloat(abs(f64))\nfloat(abs(i))\nfloat(abs(i32))\nfloat(add(1, 1))\nfloat(array[i32])\nfloat(array[i64])\nfloat(array[i])\nfloat(bitnot(1))\nfloat(bitnot(i))\nfloat(bitnot(i32))\nfloat(bitnot(i64))\nfloat(ceil(0.5))\nfloat(ceil(f32))\nfloat(ceil(f64))\nfloat(ceil(i32))\nfloat(ceil(i64))\nfloat(count(array, false))\nfloat(count(array, ok))\nfloat(count(list, i32 == 0.5))\nfloat(f32 * f64)\nfloat(f32 * i)\nfloat(f32 * i32)\nfloat(f32 ** 1)\nfloat(f32 ** f32)\nfloat(f32 ** i)\nfloat(f32 ** i64)\nfloat(f32 + 0.5)\nfloat(f32 + 1)\nfloat(f32 + f64)\nfloat(f32 + i32)\nfloat(f32 + i64)\nfloat(f32 - 0.5)\nfloat(f32 - f64)\nfloat(f32 - i64)\nfloat(f32 / 0.5)\nfloat(f32 / 1)\nfloat(f32 / i)\nfloat(f32 ^ 0.5)\nfloat(f32 ^ 1)\nfloat(f32 ^ f32)\nfloat(f32 ^ i)\nfloat(f32 ^ i32)\nfloat(f32)\nfloat(f32) < i32\nfloat(f32) <= f32\nfloat(f32) <= f64 / f32\nfloat(f32) <= i\nfloat(f32) > i\nfloat(f32) >= i64\nfloat(f32) ^ f64\nfloat(f32) ^ i64\nfloat(f64 * 0.5)\nfloat(f64 * 1)\nfloat(f64 * f32)\nfloat(f64 * f64)\nfloat(f64 * i32)\nfloat(f64 ** f32)\nfloat(f64 + 1)\nfloat(f64 + i)\nfloat(f64 + i32)\nfloat(f64 - 1)\nfloat(f64 - i)\nfloat(f64 / 0.5)\nfloat(f64 / 1)\nfloat(f64 / i64)\nfloat(f64 ^ f32)\nfloat(f64)\nfloat(f64) * f32\nfloat(f64) * i\nfloat(f64) / -i32\nfloat(f64) / i\nfloat(f64) == f64\nfloat(f64) > f64\nfloat(f64) > i64\nfloat(f64) >= f32\nfloat(f64) >= i\nfloat(f64) >= i64\nfloat(f64) ^ i64\nfloat(false ? f64 : 0.5)\nfloat(false ? half : f64)\nfloat(false ? list : f64)\nfloat(find(array, ok))\nfloat(findIndex(array, ok))\nfloat(findLastIndex(array, ok))\nfloat(findLastIndex(list, true))\nfloat(first(array))\nfloat(float(0.5))\nfloat(float(1))\nfloat(float(f32))\nfloat(float(f64))\nfloat(float(i))\nfloat(float(i32))\nfloat(floor(0.5))\nfloat(floor(1))\nfloat(floor(f32))\nfloat(floor(f64))\nfloat(floor(i32))\nfloat(floor(i64))\nfloat(get(array, 1))\nfloat(get(array, i))\nfloat(half(0.5))\nfloat(half(1))\nfloat(half(f64))\nfloat(i % i32)\nfloat(i * 0.5)\nfloat(i * f64)\nfloat(i * i64)\nfloat(i ** f32)\nfloat(i ** i32)\nfloat(i + 0.5)\nfloat(i + 1)\nfloat(i + i64)\nfloat(i - 1)\nfloat(i - f64)\nfloat(i / 0.5)\nfloat(i / 1)\nfloat(i ^ 0.5)\nfloat(i ^ i32)\nfloat(i)\nfloat(i) != 1 ? nil : foo\nfloat(i) != f64\nfloat(i) + f32\nfloat(i) + f64\nfloat(i) < i\nfloat(i) == f32\nfloat(i) == i\nfloat(i) > f64\nfloat(i32 % i)\nfloat(i32 % i64)\nfloat(i32 * f64)\nfloat(i32 * i32)\nfloat(i32 ** 1)\nfloat(i32 + f64)\nfloat(i32 + i64)\nfloat(i32 / 1)\nfloat(i32 / f32)\nfloat(i32 / i32)\nfloat(i32 ^ f64)\nfloat(i32 ^ i32)\nfloat(i32)\nfloat(i32) != f64\nfloat(i32) ** f32\nfloat(i32) ** i\nfloat(i32) > i32\nfloat(i32) >= i\nfloat(i64 % i64)\nfloat(i64 * i64)\nfloat(i64 ** 1)\nfloat(i64 + f32)\nfloat(i64 + i)\nfloat(i64 - 0.5)\nfloat(i64 - 1)\nfloat(i64 - f32)\nfloat(i64 / 1)\nfloat(i64 ^ f32)\nfloat(i64)\nfloat(i64) != i\nfloat(i64) ** max(f64)\nfloat(i64) + i32\nfloat(i64) - 0.5 ^ f32\nfloat(i64) - f64\nfloat(i64) / i32\nfloat(i64) < i32\nfloat(i64) == i\nfloat(i64) == i64\nfloat(i64) > i\nfloat(i64) ^ f32\nfloat(int(0.5))\nfloat(int(1))\nfloat(int(f32))\nfloat(int(i))\nfloat(int(i32))\nfloat(last(array))\nfloat(len(\"bar\"))\nfloat(len(array))\nfloat(len(list))\nfloat(max(0.5))\nfloat(max(0.5, i64))\nfloat(max(1))\nfloat(max(1, 1))\nfloat(max(f32))\nfloat(max(f64))\nfloat(max(i))\nfloat(max(i32))\nfloat(max(i64))\nfloat(mean(array))\nfloat(min(1))\nfloat(min(f64))\nfloat(min(f64, i64))\nfloat(min(i32))\nfloat(min(i64))\nfloat(ok ? 0.5 : foo)\nfloat(ok ? 0.5 : list)\nfloat(reduce(array, #))\nfloat(reduce(array, 0.5))\nfloat(reduce(array, f64))\nfloat(reduce(array, i32))\nfloat(reduce(list, i64))\nfloat(round(0.5))\nfloat(round(1))\nfloat(round(i32))\nfloat(round(i64))\nfloat(score(1))\nfloat(score(1, 1))\nfloat(score(i))\nfloat(string(0.5))\nfloat(string(1))\nfloat(string(f64 - 0.5))\nfloat(string(i))\nfloat(string(i32))\nfloat(string(i64))\nfloat(sum(array))\nfloat(toJSON(0.5))\nfloat(toJSON(1))\nfloat(toJSON(f32))\nfloat(toJSON(f64))\nfloat(toJSON(i32))\nfloat(toJSON(i64))\nfloat(true ? f32 : \"foo\")\n```\n\n----------------------------------------\n\nTITLE: Equality Comparisons with 'i' in Expr\nDESCRIPTION: Demonstrates equality comparisons using '==' operator with the variable 'i', involving various data types, variables, function calls, and array access using the safe navigation operator.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_156\n\nLANGUAGE: Expr\nCODE:\n```\ni == $env != $env\ni == $env != ok\ni == $env ?: 1.0\ni == $env || false\ni == $env.f64\ni == $env.i\ni == $env?.Bar\ni == $env?.String\ni == $env?.String?.[f64]?.foo\ni == $env?.[Bar]\ni == $env?.[String]\ni == $env?.[foobar]\ni == $env?.[str]\ni == $env?.f64\ni == $env?.foobar\ni == $env?.i\ni == 0 != ok\ni == 0 ** i\ni == 0 - 1.0\ni == 0 - f64 && false\ni == 0 ?: $env\ni == 0 or $env\ni == 0 or ok\ni == 0 || $env\ni == 1 != false\ni == 1 ** 1.0\ni == 1 - 1.0\ni == 1 / f64\ni == 1 == false\ni == 1 and true\ni == 1.0 != ok ?: foo\ni == 1.0 ** 1.0\n```\n\n----------------------------------------\n\nTITLE: ToBase64 Encoding\nDESCRIPTION: Demonstrates the `toBase64` function with different inputs, including string concatenations, field accesses, function calls, conditional expressions, and type conversions. Shows how to encode strings, function results, and type information into Base64 format.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_116\n\nLANGUAGE: Expr\nCODE:\n```\ntoBase64(\"bar\" + \"bar\")\ntoBase64(\"bar\" + \"foo\")\ntoBase64(\"bar\") startsWith type(score)\ntoBase64(\"foo\" + \"bar\")\ntoBase64(foo.Bar)\ntoBase64(foo.String())\ntoBase64(foo?.Bar)\ntoBase64(foo?.String())\ntoBase64(greet(\"bar\"))\ntoBase64(greet(\"foo\"))\ntoBase64(lower(\"bar\"))\ntoBase64(lower(\"foo\"))\ntoBase64(ok ? \"bar\" : f64)\ntoBase64(reduce(list, \"bar\"))\ntoBase64(string(\"foo\"))\ntoBase64(string(0.5))\ntoBase64(string(1))\ntoBase64(string(add))\ntoBase64(string(array))\ntoBase64(string(f32))\ntoBase64(string(f64))\ntoBase64(string(foo))\ntoBase64(string(greet))\ntoBase64(string(half))\ntoBase64(string(i))\ntoBase64(string(list))\ntoBase64(string(ok))\ntoBase64(toBase64(\"bar\"))\ntoBase64(toJSON(\"bar\"))\ntoBase64(toJSON(0.5))\ntoBase64(toJSON(1))\ntoBase64(toJSON(f32))\ntoBase64(toJSON(f64))\ntoBase64(toJSON(foo))\ntoBase64(toJSON(i64))\ntoBase64(toJSON(list))\ntoBase64(toJSON(nil))\ntoBase64(toJSON(ok))\ntoBase64(toJSON(true))\ntoBase64(trim(\"bar\"))\ntoBase64(trimPrefix(\"foo\"))\ntoBase64(trimSuffix(\"foo\"))\ntoBase64(type(0.5))\ntoBase64(type(1))\ntoBase64(type(add))\ntoBase64(type(div))\ntoBase64(type(f32))\ntoBase64(type(f64))\ntoBase64(type(false))\ntoBase64(type(foo))\ntoBase64(type(greet))\ntoBase64(type(half))\ntoBase64(type(i))\ntoBase64(type(i32))\ntoBase64(type(i64))\ntoBase64(type(list))\ntoBase64(type(nil))\ntoBase64(type(score))\ntoBase64(upper(\"foo\"))\n```\n\n----------------------------------------\n\nTITLE: Bitwise XOR Operation in Expr\nDESCRIPTION: Demonstrates the bitwise XOR operation using the `bitxor` function in Expr. It takes two integer arguments and returns the result of the bitwise XOR.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_92\n\nLANGUAGE: expr\nCODE:\n```\nbitxor(0b1010, 0b1100) == 0b110\n```\n\n----------------------------------------\n\nTITLE: Type Check Expressions\nDESCRIPTION: Demonstrates type checking for various expressions using the `type()` function in expr-lang. Covers arithmetic operations, comparisons, logical operations, and data structure interactions.  The expressions are designed to test the type system's ability to handle different data types and operations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_127\n\nLANGUAGE: expr-lang\nCODE:\n```\ntype(map(list, ok))\ntype(max(0.5))\ntype(max(0.5, f64))\ntype(max(1))\ntype(max(1, i32))\ntype(max(f64))\ntype(max(i64))\ntype(median(array))\ntype(min(1))\ntype(min(f32))\ntype(min(i))\ntype(min(i32))\ntype(min(i64))\ntype(nil != \"foo\")\ntype(nil != 0.5)\ntype(nil != 1)\ntype(nil != greet)\ntype(nil != half)\ntype(nil != i32)\ntype(nil != i64))\ntype(nil != nil)\ntype(nil != score)\ntype(nil == \"foo\")\ntype(nil == array)\ntype(nil == f32)\ntype(nil == false)\ntype(nil == foo)\ntype(nil == greet)\ntype(nil == nil)\ntype(nil == score)\ntype(nil in array)\ntype(nil in list)\ntype(nil not in array)\ntype(nil not in list)\ntype(none(list, ok))\ntype(none(list, true))\ntype(not (f64 <= i))\ntype(not false)\ntype(not ok)\ntype(not true)\ntype(ok != false)\ntype(ok != nil)\ntype(ok != true)\ntype(ok && false)\ntype(ok == nil)\ntype(ok ? \"bar\" : half)\ntype(ok ? 1 : \"bar\")\ntype(ok ? array : i64)\ntype(ok ? array : score)\ntype(ok ? i : \"bar\")\ntype(ok ? i : nil)\ntype(ok ? nil : 0.5)\ntype(ok ? nil : div)\ntype(ok and ok)\ntype(ok or false)\ntype(ok || false)\ntype(ok)\ntype(one(array, false))\ntype(one(array, true))\ntype(one(list, false))\ntype(one(list, true))\ntype(reduce(array, \"bar\"))\ntype(reduce(array, #))\ntype(reduce(array, 1))\ntype(reduce(array, foo))\ntype(reduce(array, greet))\ntype(reduce(array, i))\ntype(reduce(array, ok))\ntype(reduce(list, \"foo\"))\ntype(reduce(list, #))\ntype(reduce(list, array))\ntype(reduce(list, i64))\ntype(reduce(list, ok))\ntype(round(0.5))\ntype(round(1))\ntype(round(f64))\ntype(round(i))\ntype(round(i64))\ntype(score != score)\ntype(score == nil)\ntype(score(1))\ntype(score(1, 1))\ntype(score(i))\ntype(score))\ntype(sort(array))\ntype(string(0.5))\ntype(string(1))\ntype(string(add))\ntype(string(div))\ntype(string(f32))\ntype(string(f64))\ntype(string(false))\ntype(string(greet))\ntype(string(i32))\ntype(string(i64))\ntype(string(list))\ntype(string(nil))\ntype(string(ok))\ntype(string(score))\ntype(toBase64(\"bar\"))\ntype(toJSON(\"bar\"))\ntype(toJSON(\"foo\"))\ntype(toJSON(0.5))\ntype(toJSON(1))\ntype(toJSON(array))\ntype(toJSON(false))\ntype(toJSON(i))\ntype(toJSON(i32))\ntype(toJSON(i64))\ntype(toJSON(list))\ntype(toJSON(nil))\ntype(trim(\"foo\"))\ntype(trimPrefix(\"bar\"))\ntype(true != nil)\ntype(true == false))\ntype(true == nil)\ntype(true ? array : false)\ntype(true ? array : half)\ntype(true ? div : add)\ntype(true ? f64 : i32)\ntype(true ? ok : 1)\ntype(true and false)\ntype(true and true)\ntype(true or true)\ntype(true || ok)\ntype(true || true)\ntype(true) in foo\ntype(true) matches string(list))\ntype(type(0.5))\ntype(type(1))\ntype(type(add))\ntype(type(div))\ntype(type(foo))\ntype(type(greet))\ntype(type(half))\ntype(type(i))\ntype(type(i32))\ntype(type(i64))\ntype(type(nil))\ntype(type(ok))\ntype(type(true))\n```\n\n----------------------------------------\n\nTITLE: Expr groupBy with mixed expressions\nDESCRIPTION: Illustrates use of floating-point numbers, arithmetic operations, and safe navigation in groupBy expressions for property access.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_125\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(array, 1.0 != $env)\ngroupBy(array, 1.0 - 1.0)\ngroupBy(array, 1.0 < 0)?.ok\ngroupBy(array, 1.0 ^ #)\ngroupBy(array, 1.0) == $env?.Bar\ngroupBy(array, 1.0).Bar\ngroupBy(array, 1.0).add\ngroupBy(array, 1.0).array\ngroupBy(array, 1.0).f64\ngroupBy(array, 1.0).foo\ngroupBy(array, 1.0).greet\ngroupBy(array, 1.0).i\ngroupBy(array, 1.0).list\ngroupBy(array, 1.0).ok\ngroupBy(array, 1.0).str\ngroupBy(array, 1.0)?.Bar\ngroupBy(array, 1.0)?.String\ngroupBy(array, 1.0)?.[f64]\ngroupBy(array, 1.0)?.[foo]\ngroupBy(array, 1.0)?.[ok]\ngroupBy(array, 1.0)?.[str]\ngroupBy(array, 1.0)?.add\ngroupBy(array, 1.0)?.f64\ngroupBy(array, 1.0)?.foo\ngroupBy(array, 1.0)?.greet\ngroupBy(array, 1.0)?.i\ngroupBy(array, 1.0)?.list\ngroupBy(array, 1.0)?.ok\ngroupBy(array, 1.0)?.str\n```\n\n----------------------------------------\n\nTITLE: Sequential Evaluation\nDESCRIPTION: Demonstrates sequential evaluation using the semicolon (;).\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_20\n\nLANGUAGE: EXPR\nCODE:\n```\n1.0; $env.i\n1.0; $env?.Bar\n1.0; $env?.list\n1.0; 1.0 < f64\n```\n\n----------------------------------------\n\nTITLE: Generating Markdown Documentation with Expr\nDESCRIPTION: This code snippet demonstrates how to generate documentation in Markdown format using the `docgen` package. It imports the `docgen` package, creates documentation from a placeholder `env` variable, and prints the Markdown representation of the documentation to the console.  You need to replace `env` with your actual environment type.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docgen/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/expr-lang/expr/docgen\"\n\nfunc main() {\n\t// TODO: Replace env with your own types.\n\tdoc := docgen.CreateDoc(env)\n\n\tprint(doc.Markdown())\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise Shift Right Operations in Expr\nDESCRIPTION: Showcases the usage of the `bitshr` function with different types, including integers, variables and function calls, also demonstrating potential type conversions and precedence of operations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_21\n\nLANGUAGE: Expr\nCODE:\n```\nbitshr(i % 1, i32)\nbitshr(i, 1) - i64\nbitshr(i, i32)\nbitshr(i, i64)\nbitshr(i32, i)\nbitshr(i32, i) - f32\nbitshr(i32, i32)\nbitshr(i32, i64)\nbitshr(i64, i32)\nbitshr(i64, i64)\n```\n\n----------------------------------------\n\nTITLE: Absolute Value Function Usage\nDESCRIPTION: Demonstrates the use of the `abs` function with various numerical inputs, expressions, and variable combinations. It covers integer, float, and computed values, along with function calls. These examples validate the absolute value calculation for various numerical types and operations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_31\n\nLANGUAGE: Expr\nCODE:\n```\nabs($env | count(true))\nabs($env | sum(1))\nabs($env | sum(1.0))\nabs($env.f64)\nabs($env.i)\nabs($env?.f64)\nabs($env?.i)\nabs(0 * 1.0)\nabs(0 ** f64)\nabs(0 + 0)\nabs(0 + 1.0)\nabs(0 + i)\nabs(0 - 1.0)\nabs(0 - f64)\nabs(0 - i)\nabs(0 / 0)\nabs(0 ^ 1.0)\nabs(0 | mean(i, i))\nabs(0) * f64\nabs(0) - i\nabs(0) / f64\nabs(0) in array\nabs(0.1)\nabs(1 % 1)\nabs(1 % i)\nabs(1 * f64)\nabs(1 ** 1)\nabs(1 ** 1.0)\nabs(1 ** f64)\nabs(1 + 0)\nabs(1 - 1)\nabs(1 - 1.0)\nabs(1 - f64)\nabs(1 / i)\nabs(1 ^ 0)\nabs(1 ^ 1)\nabs(1 ^ i)\nabs(1 | max(array))\nabs(1) + f64\nabs(1) < f64\nabs(1) < i\nabs(1) >= i\nabs(1) | mean(i)\nabs(1.0 * 0)\nabs(1.0 * 1)\nabs(1.0 * 1.0)\nabs(1.0 * i)\nabs(1.0 ** 0)\nabs(1.0 ** 1)\nabs(1.0 ** 1.0)\nabs(1.0 ** i)\nabs(1.0 + 1)\nabs(1.0 + 1.0)\nabs(1.0 + f64)\nabs(1.0 - 1)\nabs(1.0 - 1.0)\nabs(1.0 - i)\nabs(1.0 / 0)\nabs(1.0 / 1)\nabs(1.0 / 1.0)\nabs(1.0 ^ 0)\nabs(1.0 ^ 1)\nabs(1.0 ^ 1.0)\nabs(1.0 ^ f64)\nabs(1.0 ^ i)\nabs(1.0 | mean(array))\nabs(1.0) != f64\nabs(1.0) * i\nabs(1.0) ** f64\nabs(1.0) + count(list, false)\nabs(1.0) - f64\nabs(1.0) / 0 in array\nabs(1.0) / f64\nabs(1.0) <= reduce(array, #)\nabs(1.0) == i\nabs(1.0) ^ f64 > 0\nabs(1.0) ^ i\nabs(1.0) in $env?.[String]\nabs(1.0) in array\nabs(abs(1.0))\nabs(abs(f64))\nabs(add(1, 1))\nabs(array | count(true))\nabs(array | find(ok))\nabs(array | findLast(true))\nabs(array | reduce(#))\nabs(array | reduce(#acc))\nabs(array | reduce(#index))\nabs(array | reduce(0))\nabs(array | reduce(0, array))\nabs(array | reduce(1.0))\nabs(array | reduce(1.0, foo))\nabs(array?.[i])\nabs(bitnot(0))\nabs(bitnot(1))\nabs(bitnot(i))\nabs(bitor(0, 0))\nabs(ceil(0))\nabs(ceil(1))\nabs(count($env, false))\nabs(count($env, true))\nabs(f64 * 1)\nabs(f64 * 1.0)\nabs(f64 * f64)\nabs(f64 * i)\nabs(f64 ** 0)\nabs(f64 ** 1)\nabs(f64 ** 1.0)\nabs(f64 + 0)\nabs(f64 + 1.0)\nabs(f64 + f64)\nabs(f64 - 1)\nabs(f64 - i)\nabs(f64 / f64)\nabs(f64 ^ 0)\nabs(f64 ^ 1.0)\nabs(f64 ^ i)\nabs(f64)\nabs(f64) != f64\nabs(f64) != i\nabs(f64) + i\nabs(f64) - f64\nabs(f64) / i\nabs(findIndex($env, true))\nabs(first(array))\nabs(float(0))\nabs(float(1.0))\nabs(float(f64))\nabs(floor(1))\nabs(floor(1.0))\nabs(i % i)\nabs(i * 0)\nabs(i * f64)\nabs(i ** 0)\nabs(i ** 1.0)\nabs(i + 0)\nabs(i + i)\nabs(i - 1.0)\nabs(i / 1.0)\nabs(i / i)\nabs(i ^ 1.0)\nabs(i | bitshl(0))\nabs(i)\nabs(i) + f64\nabs(i) ^ i\nabs(i) not in array\nabs(i) | bitshr(0)\nabs(if false { array } else { 1 })\nabs(if false { array } else { i })\nabs(if true { i } else { i })\nabs(int(0))\nabs(int(1))\nabs(int(1.0))\nabs(int(i))\nabs(last(array))\nabs(len($env))\nabs(len(str))\nabs(list | findIndex(ok))\nabs(list | findIndex(true))\nabs(list | reduce(1))\nabs(list | sum(1.0))\nabs(max(0))\nabs(max(1))\nabs(max(1.0))\nabs(max(array))\nabs(max(f64))\nabs(max(f64, f64))\nabs(max(i))\nabs(mean(0))\nabs(mean(1))\nabs(mean(1.0))\nabs(mean(array))\nabs(mean(f64))\nabs(mean(i))\nabs(median(0))\nabs(median(1))\nabs(median(1.0))\nabs(median(array))\nabs(median(f64))\nabs(median(f64, array))\nabs(median(i))\nabs(min(0))\nabs(min(1.0))\nabs(min(array))\nabs(min(i))\nabs(reduce(array, #))\nabs(reduce(array, #, nil))\nabs(reduce(array, i))\nabs(reduce(list, 0))\nabs(reduce(list, 1))\nabs(round(0))\nabs(round(1))\nabs(round(1.0))\nabs(sum($env, 1.0))\nabs(sum(array))\nabs(sum(array, #))\nabs(sum(array, 0))\nabs(sum(array, f64))\nabs(sum(list, 1.0))\n```\n\n----------------------------------------\n\nTITLE: Using `round` with mixed operations and functions in Expr\nDESCRIPTION: These examples demonstrate how the `round` function can be used in combination with comparison operators, arithmetic operators, built-in functions (ceil, abs, add, div, etc.), array access, and conditional expressions.  They showcase the versatility and composability of Expr's functions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_107\n\nLANGUAGE: Expr\nCODE:\n```\nround(1) != ceil(i32)\nround(1) * i32\nround(1) + i64\nround(1) - i64\nround(1) / i32\nround(1) / i64\nround(1) < i64\nround(1) <= i\nround(1) == i\nround(1) >= f64\nround(1) >= i32\nround(1) >= i64\nround(1) ^ f64\nround(1) not in array\nround(abs(0.5))\nround(abs(1))\nround(abs(f64))\nround(abs(i))\nround(abs(i64))\nround(add(1, i))\nround(array[1])\nround(array[i32])\nround(array[i64])\nround(bitnot(i))\nround(bitnot(i32))\nround(bitnot(i64))\nround(ceil(1))\nround(ceil(f64))\nround(ceil(i32))\nround(ceil(i64))\nround(count(list, true))\nround(div(1, 1))\nround(f32 * 0.5)\nround(f32 * 1)\nround(f32 * f64)\nround(f32 * i32 ^ f32)\nround(f32 * i64)\nround(f32 ** 0.5)\nround(f32 ** 1)\nround(f32 + f64)\nround(f32 + i32)\nround(f32 - 0.5)\nround(f32 - i)\nround(f32 / i32)\nround(f32 ^ 0.5)\nround(f32 ^ f32)\nround(f32 ^ i)\nround(f32 ^ i64)\nround(f32)\nround(f32) * i32\nround(f32) - i32\nround(f32) / f32\nround(f32) == i32\nround(f64 * 0.5)\nround(f64 * i)\nround(f64 ** 0.5)\nround(f64 ** 1)\nround(f64 ** f32)\nround(f64 ** i)\nround(f64 + f64)\nround(f64 + i)\nround(f64 + i32)\nround(f64 - 0.5)\nround(f64 - 1)\nround(f64 - i32)\nround(f64 / f64)\nround(f64 / i)\nround(f64 / i32)\nround(f64 / i64)\nround(f64 ^ 1)\nround(f64 ^ f64)\nround(f64)\nround(f64) * f32\nround(f64) ** i32\nround(f64) + f64\nround(f64) <= f64\nround(f64) > i\nround(f64) > i32\nround(f64) >= i64\nround(f64) not in array\nround(false ? f32 : f64)\nround(false ? f64 : 1)\nround(false ? nil : 1)\nround(findIndex(array, # <= #))\nround(findIndex(list, ok))\nround(findLast(array, ok))\nround(findLast(array, true))\nround(findLastIndex(array, ok))\nround(findLastIndex(list, ok))\nround(float(0.5))\nround(float(1))\nround(float(f32))\nround(float(i))\nround(floor(0.5))\nround(floor(1))\nround(floor(f64))\nround(floor(i32))\nround(floor(i64))\nround(get(array, i))\nround(get(array, i32))\nround(get(array, i64))\nround(half(-1))\nround(half(0.5))\nround(half(1))\nround(half(f64))\nround(i % i32)\nround(i % i64)\nround(i * 1)\nround(i * f64)\nround(i * i32)\nround(i ** 1)\nround(i ** i64)\nround(i + 0.5)\nround(i + 1)\nround(i + f64)\nround(i + i)\nround(i + i32)\nround(i + i64)\nround(i - i)\nround(i - i32)\nround(i / 1)\nround(i / i)\nround(i / i64)\nround(i ^ 0.5) > f32\nround(i ^ 1)\nround(i ^ f32)\nround(i)\nround(i) * f32\nround(i) * i\nround(i) / f64\nround(i) < i\nround(i) < i32\nround(i) > i\nround(i) > i64 != ok\nround(i) >= f32\nround(i) >= i64\nround(i) ^ i32\nround(i32 % 1)\nround(i32 * 1)\nround(i32 ** 1)\nround(i32 ** f32)\nround(i32 ** f64)\nround(i32 + 0.5)\nround(i32 + 1)\nround(i32 + i32)\nround(i32 - 1)\nround(i32 - f32)\nround(i32 - f64)\nround(i32 / 0.5)\nround(i32 / 1)\nround(i32 ^ f64)\nround(i32)\nround(i32) != i\nround(i32) * f32\nround(i32) ** f64\nround(i32) - i\nround(i32) < i32\nround(i32) <= ceil(1)\nround(i32) <= f64\nround(i32) <= i64\nround(i32) >= f64\nround(i32) >= i32\nround(i32) ^ f64\nround(i64 % i)\nround(i64 % i32)\nround(i64 * 0.5)\nround(i64 * i)\nround(i64 ** 1)\nround(i64 ** f64)\nround(i64 ** i64)\nround(i64 + f32)\nround(i64 - 0.5)\nround(i64 - 1)\nround(i64 - i)\nround(i64 / 0.5)\nround(i64 / 1)\nround(i64 ^ 1)\nround(i64 ^ i32)\nround(i64 ^ i64)\nround(i64)\nround(i64) != f64\nround(i64) * i64\nround(i64) ** i32\nround(i64) - bitnot(1)\nround(i64) - f32\nround(i64) < f64\nround(i64) ^ f64\nround(int(0.5))\nround(int(1))\nround(int(f32))\nround(int(f64))\nround(int(i))\nround(int(i32))\nround(int(i64))\nround(last(array))\nround(len(\"bar\"))\nround(len(\"foo\"))\nround(len(array))\nround(len(list))\nround(max(0.5))\nround(max(1))\nround(max(i))\nround(max(i32))\nround(max(i64))\nround(max(i64, f32))\nround(mean(array))\nround(median(array))\nround(min(0.5))\nround(min(1))\nround(min(f32))\nround(min(f64))\nround(min(i32))\nround(min(i64))\nround(reduce(array, #))\nround(reduce(array, 0.5))\nround(reduce(array, 1))\nround(reduce(array, i64))\nround(reduce(list, 0.5))\nround(reduce(list, f32))\nround(round(0.5))\nround(round(1))\nround(round(f32))\nround(round(f64))\nround(round(i))\nround(round(i32))\nround(round(i64))\nround(score(1))\nround(score(i))\nround(sum(array))\nround(true ? i : ok)\n```\n\n----------------------------------------\n\nTITLE: Testing 'f32' Arithmetic Operations in Expr\nDESCRIPTION: This snippet covers a variety of arithmetic operations involving 'f32' (32-bit floating-point) values. It tests multiplication, exponentiation, addition, subtraction, and division with different data types and function calls, ensuring correct mathematical calculations and type interactions within the Expr language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_36\n\nLANGUAGE: Expr\nCODE:\n```\nf32 * (0.5 + f64)\nf32 * (0.5 + i32)\nf32 * (0.5 - f32)\nf32 * (f64 + f64)\nf32 * (f64 + i64)\nf32 * (f64 - i)\nf32 * -0.5\nf32 * -1\nf32 * -f64\nf32 * -i\nf32 * -i64\nf32 * -len(array)\nf32 * 0.5 * 0.5\nf32 * 0.5 * i\nf32 * 0.5 * i32\nf32 * 0.5 - i32\nf32 * 0.5 / i\nf32 * 0.5 <= i\nf32 * 0.5 ^ f32\nf32 * 0.5 not in array\nf32 * 1 != f32\nf32 * 1 * f64\nf32 * 1 * i32\nf32 * 1 ** 0.5\nf32 * 1 + f64\nf32 * 1 < i64\nf32 * 1 >= i64\nf32 * 1 ^ i64\nf32 * ceil(i)\nf32 * f32\nf32 * f32 * 0.5\nf32 * f32 < i32\nf32 * f32 <= i64\nf32 * f32 > f32 - 1\nf32 * f32 ^ 0.5\nf32 * f32 in array\nf32 * f64\nf32 * f64 + f64\nf32 * f64 + i32\nf32 * f64 / i64\nf32 * f64 >= 1 - i\nf32 * float(i)\nf32 * float(i32)\nf32 * floor(0.5)\nf32 * floor(i)\nf32 * half(0.5)\nf32 * half(1)\nf32 * half(f64)\nf32 * i\nf32 * i != i32\nf32 * i - i\nf32 * i / f64\nf32 * i == i64\nf32 * i32\nf32 * i32 != max(i)\nf32 * i32 * i32\nf32 * i32 ** 0.5\nf32 * i32 >= i\nf32 * i64\nf32 * i64 != f64\nf32 * i64 ** i\nf32 * int(i64)\nf32 * min(i64)\nf32 * reduce(array, 1)\nf32 * reduce(list, 1)\nf32 * round(f64)\nf32 ** (0.5 + 0.5)\nf32 ** (0.5 - 1)\nf32 ** (0.5 / f32)\nf32 ** (1 / f64)\nf32 ** (f32 - 0.5)\nf32 ** (f64 - i64)\nf32 ** (i % 1)\nf32 ** (i64 * i32)\nf32 ** (i64 + 0.5)\nf32 ** (i64 - 1)\nf32 ** -0.5\nf32 ** -f32\nf32 ** -f64\nf32 ** -i\nf32 ** 0.5 != f32\nf32 ** 0.5 + f32\nf32 ** 0.5 >= -i64\nf32 ** 0.5 ^ (f32 / f64)\nf32 ** 0.5 ^ i64\nf32 ** 1 + i64\nf32 ** 1 / i\nf32 ** 1 < f64\nf32 ** 1 < i64\nf32 ** 1 <= i64\nf32 ** ceil(i64)\nf32 ** f32\nf32 ** f32 * f32\nf32 ** f32 ** f32\nf32 ** f32 < f64\nf32 ** f32 ^ f32\nf32 ** f32 ^ f64\nf32 ** f64\nf32 ** f64 ** 1\nf32 ** f64 <= f64\nf32 ** f64 >= i\nf32 ** float(f32)\nf32 ** float(f64)\nf32 ** half(0.5)\nf32 ** half(1)\nf32 ** i\nf32 ** i != half(1)\nf32 ** i ** f64\nf32 ** i ** i32\nf32 ** i <= i64\nf32 ** i32\nf32 ** i32 / i32\nf32 ** i32 == f64\nf32 ** i32 ^ f32\nf32 ** i64\nf32 ** i64 / f32\nf32 ** i64 == i32\nf32 ** i64 > i32\nf32 ** int(f64)\nf32 ** len(\"foo\")\nf32 ** max(f32)\nf32 ** max(i32)\nf32 ** median(array)\nf32 ** reduce(array, 0.5)\nf32 ** round(f64)\nf32 + -0.5\nf32 + -1\nf32 + -f32\nf32 + -i\nf32 + 0.5 ** f32\nf32 + 0.5 + i32\nf32 + 0.5 - i\nf32 + 0.5 - i32\nf32 + 0.5 / f32\nf32 + 0.5 == i\nf32 + 0.5 > i64\nf32 + 0.5 ^ 0.5\nf32 + 1 * 0.5\nf32 + 1 * 1\nf32 + 1 + i\nf32 + 1 - f64\nf32 + 1 - i64\nf32 + 1 / f64\nf32 + 1 < f32\nf32 + 1 < i\nf32 + 1 >= ceil(0.5)\nf32 + bitnot(i64)\nf32 + ceil(-1)\nf32 + ceil(1)\nf32 + ceil(f32)\nf32 + f32\nf32 + f32 * 0.5\nf32 + f32 ** i64\nf32 + f32 - i32\nf32 + f32 / 1\nf32 + f32 > i32\nf32 + f32 ^ 0.5\nf32 + f64\nf32 + f64 in array\nf32 + findIndex(array, true)\nf32 + first(array)\nf32 + float(i)\nf32 + floor(1)\nf32 + floor(i64)\nf32 + half(1)\nf32 + half(f64)\nf32 + i\nf32 + i != i64\nf32 + i + 1\nf32 + i + i\nf32 + i - i32\nf32 + i == f64\nf32 + i32\nf32 + i32 != f32\nf32 + i32 % i\nf32 + i32 / f32\nf32 + i32 <= i\nf32 + i32 ^ 0.5\nf32 + i64\nf32 + i64 != f32\nf32 + i64 + 0.5\nf32 + i64 < f32\nf32 + i64 <= i32\nf32 + i64 >= i\nf32 + i64 >= i32\nf32 + int(1)\nf32 + int(f64)\nf32 + max(0.5)\nf32 + max(f64)\nf32 + reduce(array, #)\nf32 + round(1)\nf32 + round(i32)\nf32 + score(1)\nf32 + score(i)\nf32 - -1\nf32 - -f64\nf32 - -i\nf32 - 0.5 ** i64\nf32 - 0.5 + 0.5\nf32 - 0.5 + f64\nf32 - 0.5 - i64\nf32 - 0.5 < i\nf32 - 0.5 <= i32\nf32 - 0.5 <= i64\nf32 - 0.5 > f64\nf32 - 1 % i64\nf32 - 1 * i64\nf32 - 1 + 1\nf32 - 1 / 0.5\nf32 - 1 < i32\nf32 - 1 <= i32\nf32 - 1 == f32\nf32 - 1 >= f64\nf32 - abs(i32)\nf32 - abs(i64)\nf32 - bitshl(i, i32)\nf32 - ceil(f64)\nf32 - f32\nf32 - f32 ** i32\nf32 - f32 + i\nf32 - f32 == i\nf32 - f64\nf32 - f64 + f64\nf32 - f64 - i\nf32 - f64 <= f32\nf32 - i\nf32 - i >= f32\nf32 - i32\nf32 - i32 * 0.5\nf32 - i32 * f64\nf32 - i32 ** 1\nf32 - i32 <= f32\nf32 - i32 <= i32\nf32 - i32 >= abs(0.5)\nf32 - i64\nf32 - i64 ** 0.5\nf32 - len(array)\nf32 - max(1)\nf32 - min(0.5)\nf32 - min(0.5, 0.5)\nf32 - reduce(array, #)\nf32 - score(1)\nf32 - score(i)\nf32 / (0.5 - i32)\nf32 / (1 + i)\nf32 / (f64 - 0.5)\nf32 / (i - i32)\nf32 / (i32 + 1)\nf32 / -1\nf32 / -f64\nf32 / -i64\nf32 / 0.5 ** f64\nf32 / 0.5 / i\nf32 / 0.5 <= i64\nf32 / 0.5 ^ f64\nf32 / 1 * i32\nf32 / 1 <= f32\nf32 / 1 >= 0.5 ? f64 : foo\nf32 / 1 >= f32\nf32 / 1 >= i32\nf32 / array[1]\nf32 / array[i32]\nf32 / bitnot(i)\nf32 / ceil(1)\nf32 / ceil(f32)\nf32 / count(list, false)\nf32 / f32\nf32 / f32 / 0.5\nf32 / f32 ^ 1\nf32 / f64\nf32 / f64 * i32\nf32 / f64 + f32\nf32 / f64 - i32\nf32 / f64 / 1\nf32 / f64 / f64\nf32 / f64 / i64\nf32 / f64 < i\nf32 / float(1)\nf32 / float(i32)\nf32 / float(i64)\nf32 / floor(i)\nf32 / half(0.5)\nf32 / half(1)\nf32 / half(f64)\nf32 / i\nf32 / i * 0.5\nf32 / i / 0.5\nf32 / i <= i\nf32 / i == i32\n```\n\n----------------------------------------\n\nTITLE: Bitwise Left Shift Operation in Expr\nDESCRIPTION: Demonstrates the bitwise Left Shift operation using the `bitshl` function in Expr. It takes two integer arguments: the number to shift and the number of bits to shift by.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_95\n\nLANGUAGE: expr\nCODE:\n```\nbitshl(0b101101, 2) == 0b10110100\n```\n\n----------------------------------------\n\nTITLE: Multiple Variable Declarations in Expr\nDESCRIPTION: Shows how to declare multiple variables using semicolon-separated `let` statements.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_14\n\nLANGUAGE: expr\nCODE:\n```\nlet x = 42; \nlet y = 2; \nx * y\n```\n\n----------------------------------------\n\nTITLE: Ceiling Function Operations in Expr\nDESCRIPTION: Demonstrates the usage of the `ceil` function in Expr, performing ceiling operations on various expressions including environment variables, arithmetic operations, and function calls.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_75\n\nLANGUAGE: Expr\nCODE:\n```\nceil($env | sum(0))\nceil($env | sum(f64))\nceil($env | sum(i))\nceil($env.f64)\nceil($env.i)\nceil($env?.[str] | sum(1.0))\nceil($env?.array | findLast(ok))\nceil($env?.f64)\nceil($env?.i)\nceil($env?.i) < f64\nceil(0 * 1)\nceil(0 * 1.0)\nceil(0 ** 1)\nceil(0 ** 1.0)\nceil(0 ** f64)\nceil(0 + 1)\nceil(0 + 1.0)\nceil(0 + i)\nceil(0 - 0)\nceil(0 - 1.0)\nceil(0 - i)\nceil(0 / 1)\nceil(0 / 1.0)\nceil(0 ^ 0)\nceil(0 ^ 1.0)\nceil(0 ^ f64)\nceil(0 ^ i)\nceil(0 | add(i))\nceil(0 | bitshl(i))\nceil(0 | median(1.0))\nceil(0) != f64\nceil(0) <= f64\nceil(0.0)\nceil(1 % 1)\nceil(1 * f64)\nceil(1 ** 1.0)\nceil(1 ** f64)\nceil(1 + f64)\nceil(1 + i)\nceil(1 - 1.0)\nceil(1 ^ 1.0)\nceil(1 | bitor(0))\nceil(1) != i\nceil(1) > f64\nceil(1) ^ i\nceil(1) | median(1.0, 1)\nceil(1) | min(array)\nceil(1.0 * 0)\nceil(1.0 * 1)\nceil(1.0 * 1.0)\nceil(1.0 * i)\nceil(1.0 ** i)\nceil(1.0 + 0)\nceil(1.0 + 1)\nceil(1.0 + 1.0)\nceil(1.0 + i)\nceil(1.0 - 0)\nceil(1.0 - 1)\nceil(1.0 - 1.0)\nceil(1.0 - f64)\nceil(1.0 - i)\nceil(1.0 / 1)\nceil(1.0 / 1.0)\nceil(1.0 / f64)\nceil(1.0 ^ 0)\nceil(1.0 ^ 1.0)\nceil(1.0 ^ f64)\nceil(1.0 | min(1))\nceil(1.0) == nil ? foo : str\nceil(1.0) >= f64\nceil(1.0) not in array\nceil(1.0) | mean(1)\nceil(abs(0))\nceil(abs(f64))\nceil(abs(i))\nceil(array?.[i])\nceil(bitnot(0))\nceil(bitnot(1))\nceil(ceil(0))\nceil(ceil(1))\nceil(ceil(1.0))\nceil(ceil(f64))\nceil(count($env, false))\nceil(f64 * 0)\nceil(f64 ** 0)\n```\n\n----------------------------------------\n\nTITLE: Calculating the Floor of a Number in Expr\nDESCRIPTION: The `floor()` function returns the largest integer value less than or equal to the input number. The input number must be a numerical value.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_48\n\nLANGUAGE: expr\nCODE:\n```\nfloor(1.5) == 1.0\n```\n\n----------------------------------------\n\nTITLE: Using `reduce` with `sort` function in Expr\nDESCRIPTION: The `reduce` function combined with the `sort` function allows processing a sorted array. These examples showcase reducing the sorted array based on placeholder (`#`), foo, greet and ok variables.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_103\n\nLANGUAGE: Expr\nCODE:\n```\nreduce(sort(array), #)\nreduce(sort(array), foo)\nreduce(sort(array), greet)\nreduce(sort(array), ok)\n```\n\n----------------------------------------\n\nTITLE: Expr: Type Checks with Floating-point and Optional Member Access\nDESCRIPTION: This snippet showcases type checks with floating-point numbers, nil values, optional member access and arithmetic operations, further demonstrating how these constructs are handled in the Expr language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_261\n\nLANGUAGE: Expr\nCODE:\n```\ntype(1.0 != $env)\ntype(1.0 != $env?.i)\ntype(1.0 != 1)\ntype(1.0 != 1.0)\ntype(1.0 != f64)\ntype(1.0 != i)\ntype(1.0 != nil)\ntype(1.0 * 0)\ntype(1.0 * 1)\ntype(1.0 * 1.0)\ntype(1.0 * f64)\ntype(1.0 * i)\ntype(1.0 ** 1)\ntype(1.0 ** 1.0)\ntype(1.0 ** f64)\n\n```\n\n----------------------------------------\n\nTITLE: Expr Safe Navigation on Boolean Property\nDESCRIPTION: This snippet uses the safe navigation operator `?.` on a boolean property (`false`). The expression accesses a potentially undefined `array` property, returning `null` if the parent is `null` or `undefined`.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_150\n\nLANGUAGE: expr\nCODE:\n```\n{\"foo\": score, \"bar\": false}?.array\n```\n\n----------------------------------------\n\nTITLE: Bitwise Right Shift Operation in Expr\nDESCRIPTION: Demonstrates the bitwise Right Shift operation using the `bitshr` function in Expr. It takes two integer arguments: the number to shift and the number of bits to shift by.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_96\n\nLANGUAGE: expr\nCODE:\n```\nbitshr(0b101101, 2) == 0b1011\n```\n\n----------------------------------------\n\nTITLE: Traversing AST with ast.Walk in Go\nDESCRIPTION: This snippet demonstrates how to parse an expression using `parser.Parse` and then traverse its AST using `ast.Walk` with a custom `Visitor`. It prints the collected identifiers from the expression 'foo + bar'.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/visitor.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntree, err := parser.Parse(`foo + bar`)\nif err != nil {\n    panic(err)\n}\n\nv := &Visitor{}\n// highlight-next-line\nast.Walk(&tree.Node, v)\n\nfmt.Println(v.Identifiers) // [foo, bar]\n```\n\n----------------------------------------\n\nTITLE: Numeric and Boolean Operations in Maps\nDESCRIPTION: Illustrates various numeric (arithmetic, comparison) and boolean operations within maps. This includes testing negative values, basic arithmetic operators, equality, greater than/less than, and the power operator.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_131\n\nLANGUAGE: expr-lang\nCODE:\n```\n{\"bar\": -0.5}\n{\"bar\": -f32}\n{\"bar\": -f64}\n{\"bar\": -i32}\n{\"bar\": 0.5 != nil}\n{\"bar\": 0.5 * 1}.foo\n{\"bar\": 0.5, \"bar\": 0.5}.half\n{\"bar\": 0.5, \"bar\": add, \"foo\": i32}.list\n{\"bar\": 0.5, \"bar\": i}?.add\n{\"bar\": 0.5, \"bar\": list}?.div\n{\"bar\": 0.5, \"bar\": nil, \"bar\": nil}.i32\n{\"bar\": 0.5, \"bar\": ok, \"foo\": 1}?.String\n{\"bar\": 0.5, \"bar\": true}.score\n{\"bar\": 0.5, \"foo\": 0.5}?.f32\n{\"bar\": 0.5, \"foo\": array}?.list\n{\"bar\": 0.5, \"foo\": f32}.i32?.Bar\n{\"bar\": 0.5, \"foo\": ok}?.array\n{\"bar\": 0.5}.Qux\n{\"bar\": 0.5}.String\n{\"bar\": 0.5}.add\n{\"bar\": 0.5}.array\n{\"bar\": 0.5}.f32\n{\"bar\": 0.5}.f64\n{\"bar\": 0.5}.half\n{\"bar\": 0.5}.i\n{\"bar\": 0.5}.i32\n{\"bar\": 0.5}.i64\n{\"bar\": 0.5}.ok\n{\"bar\": 0.5}?.Bar\n{\"bar\": 0.5}?.Qux\n{\"bar\": 0.5}?.String\n{\"bar\": 0.5}?.div\n{\"bar\": 0.5}?.foo\n{\"bar\": 0.5}?.greet\n{\"bar\": 0.5}?.half\n{\"bar\": 0.5}?.i\n{\"bar\": 0.5}?.i32\n{\"bar\": 0.5}?.i64\n{\"bar\": 0.5}?.list\n{\"bar\": 0.5}?.score\n```\n\n----------------------------------------\n\nTITLE: Expr groupBy with aggregation and type functions\nDESCRIPTION: Demonstrates grouping based on aggregation functions like `sum` and `toJSON`, boolean expressions, and the `type` function.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_133\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(array, sum(array))\ngroupBy(array, toJSON(array))\ngroupBy(array, true && true)\ngroupBy(array, true).Bar\ngroupBy(array, true).add\ngroupBy(array, true).array\ngroupBy(array, true).f64\ngroupBy(array, true).foo\ngroupBy(array, true).i\ngroupBy(array, true).list\ngroupBy(array, true).str\ngroupBy(array, true)?.[f64]\ngroupBy(array, true)?.[foo]\ngroupBy(array, true)?.[i]\ngroupBy(array, true)?.[ok]\ngroupBy(array, true)?.[str]\ngroupBy(array, true)?.add\ngroupBy(array, true)?.f64\ngroupBy(array, true)?.i\ngroupBy(array, true)?.list\ngroupBy(array, true)?.ok\ngroupBy(array, true)?.str\ngroupBy(array, type(#))\ngroupBy(array, type(i))\n```\n\n----------------------------------------\n\nTITLE: Using findLastIndex Function in Expr\nDESCRIPTION: This snippet demonstrates the usage of the `findLastIndex` function in the Expr language. It shows various examples with conditions, mathematical operations, string comparisons, and logical operators.  It attempts to find the index of the last element that satisfies a given condition within a collection.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_97\n\nLANGUAGE: Expr\nCODE:\n```\nfindLastIndex($env, ok) > i\nfindLastIndex($env, ok) ^ f64\nfindLastIndex($env, true) <= f64\nfindLastIndex($env, true) | bitor(1)\nfindLastIndex($env, true) | bitshl(1)\nfindLastIndex($env?.[str], 1.0 > #)\nfindLastIndex($env?.array, ok)\nfindLastIndex([false, true, $env], #.greet != true)\nfindLastIndex([list], foo not in #)\nfindLastIndex([true], str < str)\nfindLastIndex(array, # < #)\nfindLastIndex(array, # < i)\nfindLastIndex(array, # <= #)\nfindLastIndex(array, # > #)\nfindLastIndex(array, $env == 1.0)\nfindLastIndex(array, $env.ok)\nfindLastIndex(array, 0 == $env)\nfindLastIndex(array, 1 >= 1.0)\nfindLastIndex(array, add == nil)\nfindLastIndex(array, any($env, false))\nfindLastIndex(array, false) != 1.0 + 1.0\nfindLastIndex(array, nil == ok)\nfindLastIndex(array, ok)\nfindLastIndex(array, str in foo)\nfindLastIndex(array, str not in $env)\nfindLastIndex(array, true) * f64\nfindLastIndex(false ? nil : $env, ok)\nfindLastIndex(flatten(array), ok)\nfindLastIndex(list, # == #)\nfindLastIndex(list, #.Bar == nil)\nfindLastIndex(list, $env.ok)\nfindLastIndex(list, 0 != 1)\nfindLastIndex(list, 0 > 1.0)\nfindLastIndex(list, foo != #)\nfindLastIndex(list, foo != $env)\nfindLastIndex(list, foo not in list)\nfindLastIndex(list, nil != nil)\nfindLastIndex(list, nil == 1)\nfindLastIndex(list, ok)\nfindLastIndex(list, ok) < i\nfindLastIndex(list, str == $env)\nfindLastIndex(list, str not in #)\nfindLastIndex(list, true) > f64\nfindLastIndex(map(array, ok), #)\nfindLastIndex(map(list, add), ok)\nfindLastIndex(sort($env), #.foo?.greet)\nfindLastIndex(sort($env), $env ?: #.i)\n```\n\n----------------------------------------\n\nTITLE: Comparison Operations with 'greet' variable - Expr\nDESCRIPTION: Illustrates comparison operations with the 'greet' variable against different values, including environment variables, fields, and function results.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_117\n\nLANGUAGE: Expr\nCODE:\n```\ngreet != $env != nil\ngreet != $env && $env\ngreet != $env == nil\ngreet != $env and $env\ngreet != $env or sum(array, true)\ngreet != $env.greet\ngreet != $env?.Bar\ngreet != $env?.String\ngreet != $env?.String?.add()\ngreet != $env?.[Bar]\ngreet != $env?.[String]\ngreet != $env?.[foobar]\ngreet != $env?.[str]\ngreet != $env?.greet\ngreet != $env?.true\ngreet != get($env, str)\ngreet != greet\ngreet != greet != nil\ngreet != greet != ok\ngreet != greet && true\ngreet != greet || false\ngreet != nil and $env\ngreet != {foo: str}.foobar\ngreet == $env and false\ngreet == $env.greet\ngreet == $env?.Bar\ngreet == $env?.String\ngreet == $env?.[Bar]\ngreet == $env?.[String]\ngreet == $env?.[foobar]\ngreet == $env?.[str]\ngreet == $env?.foobar\ngreet == $env?.foobar?.String\ngreet == $env?.greet\ngreet == greet\ngreet == greet == ok\ngreet == greet ? 1.0 : foo\ngreet == min($env)\ngreet == nil == true\ngreet == nil or $env\ngreet == nil || true\n```\n\n----------------------------------------\n\nTITLE: Bitwise Unsigned Right Shift Operation in Expr\nDESCRIPTION: Demonstrates the bitwise Unsigned Right Shift operation using the `bitushr` function in Expr. It takes two integer arguments: the number to shift and the number of bits to shift by.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_97\n\nLANGUAGE: expr\nCODE:\n```\nbitushr(-0b101, 2) == 4611686018427387902\n```\n\n----------------------------------------\n\nTITLE: Add Function Arithmetic\nDESCRIPTION: Showcases arithmetic operations performed using the `add` function with different inputs. It covers multiplication, addition, and comparisons. The purpose is to validate the correct numerical calculations and comparisons involving the `add` function.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_34\n\nLANGUAGE: Expr\nCODE:\n```\nadd($env.i, i)\nadd(0, 1) * f64\nadd(i, 1) >= f64 > i\nadd(i, array?.[i])\nadd(i, i)\nadd(i, list | sum(i))\nadd(min(0, i), i)\nadd(sum(array), i)\n```\n\n----------------------------------------\n\nTITLE: Ternary Operator Examples\nDESCRIPTION: These snippets demonstrate the ternary operator (condition ? value1 : value2) in the Expr language. They showcase its use with different data types as the condition, the return values, and the interactions between those types. The snippets cover a wide range of possible expression results, including primitives, functions, and collections.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_92\n\nLANGUAGE: Expr\nCODE:\n```\nnot false ? \"foo\" : \"foo\"\nnot false ? 0.5 : \"foo\"\nnot false ? 0.5 : array\nnot false ? 0.5 : div\nnot false ? 0.5 : foo\nnot false ? 0.5 : i64\nnot false ? 0.5 : nil\nnot false ? 1 : 0.5\nnot false ? add : array\nnot false ? array : 0.5\nnot false ? array : 1\nnot false ? array : f64\nnot false ? array : i\nnot false ? array : true\nnot false ? div : 0.5\nnot false ? div : f64\nnot false ? f32 : 0.5\nnot false ? f32 : 1\nnot false ? f32 : i\nnot false ? f32 : nil\nnot false ? f32 : score\nnot false ? f64 : \"foo\"\nnot false ? f64 : f64\nnot false ? false : half\nnot false ? false : list\nnot false ? foo : f64\nnot false ? greet : 1\nnot false ? i : \"bar\"\nnot false ? i : 1\nnot false ? i : array\nnot false ? i : i\nnot false ? i32 : greet\nnot false ? i64 : list\nnot false ? list : i\nnot false ? list : true\nnot false ? nil : f32\nnot false ? nil : half\nnot false ? nil : ok\nnot false ? ok : 1\nnot false ? score : ok\nnot false ? true : f64\nnot false ? true : nil\nnot ok ? \"bar\" : list\nnot ok ? \"foo\" : 0.5\nnot ok ? \"foo\" : 1\nnot ok ? 0.5 : \"bar\"\nnot ok ? 0.5 : 0.5\nnot ok ? 0.5 : i\nnot ok ? 1 : f64\nnot ok ? 1 : nil\nnot ok ? add : array\nnot ok ? add : groupBy(array, #)\nnot ok ? array : 1\nnot ok ? array : f32\nnot ok ? div : f64\nnot ok ? f32 : f32\nnot ok ? f64 : f64\nnot ok ? f64 : half\nnot ok ? foo : foo\nnot ok ? greet : 0.5\nnot ok ? half : half\nnot ok ? i : 1\nnot ok ? i : add\nnot ok ? i32 : 1\nnot ok ? i32 : i\nnot ok ? i64 : f32\nnot ok ? i64 : f64\nnot ok ? nil : \"bar\"\nnot ok ? nil : 0.5\nnot ok ? nil : foo\nnot ok ? nil : greet\nnot ok ? nil : i\nnot ok ? ok : false\nnot ok ? ok : list\nnot ok ? score : \"foo\"\nnot ok ? score : score\nnot ok ? true : 1\nnot ok ? true : div\nnot ok ? true : half\nnot ok ? true : i64\nnot ok ? true : nil\nnot true ? \"bar\" : array\nnot true ? \"bar\" : i32\nnot true ? \"foo\" : f32\nnot true ? \"foo\" : f64\nnot true ? 0.5 : foo\nnot true ? 0.5 : greet\nnot true ? 0.5 : i\nnot true ? 0.5 : i64\nnot true ? 1 : f32\nnot true ? add : i32\nnot true ? add : ok\nnot true ? array : nil\nnot true ? f32 : 0.5\nnot true ? f32 : div\nnot true ? f64 : 1\nnot true ? f64 : array\nnot true ? foo : greet\nnot true ? foo : ok\nnot true ? greet : 1\nnot true ? greet : i64\nnot true ? greet : list\nnot true ? greet : true\nnot true ? half : half\nnot true ? i : f64\nnot true ? i64 : \"foo\"\nnot true ? i64 : array\nnot true ? i64 : i64\nnot true ? list : \"bar\"\nnot true ? list : f64\nnot true ? list : foo\nnot true ? nil : div\nnot true ? ok : nil\nnot true ? score : f32\nnot true ? score : score\nnot true ? true : 1\n```\n\n----------------------------------------\n\nTITLE: Counting with String Condition in Expr\nDESCRIPTION: This snippet demonstrates the use of the count function in Expr with a string-based condition. It counts the number of elements in the 'array' that do not end with the string 'bar'. It also shows counting elements where 'foo' matches 'foo'.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_26\n\nLANGUAGE: Expr\nCODE:\n```\ncount(array, \"bar\" not endsWith \"bar\")\ncount(array, \"foo\" matches \"foo\")\n```\n\n----------------------------------------\n\nTITLE: Using timezone() in Expr\nDESCRIPTION: The `timezone()` function returns the timezone of the given string. A list of available timezones can be found in the tz database. The returned timezone can be used for converting dates to the specified timezone using the `In()` method.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_42\n\nLANGUAGE: expr\nCODE:\n```\ntimezone(\"Europe/Zurich\")\ntimezone(\"UTC\")\n```\n\n----------------------------------------\n\nTITLE: Bitwise Shift and XOR Operations\nDESCRIPTION: Demonstrates bitwise shift left (bitshl) and bitwise XOR (bitxor) operations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_19\n\nLANGUAGE: EXPR\nCODE:\n```\n1 | bitshl(0) != f64\n1 | bitxor(1) >= i\n```\n\n----------------------------------------\n\nTITLE: Pipe Operator Equivalent in Expr\nDESCRIPTION: Shows the equivalent nested function call representation of the pipe operator example.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_11\n\nLANGUAGE: expr\nCODE:\n```\nsplit(lower(user.Name), \" \")\n```\n\n----------------------------------------\n\nTITLE: Indexing and Method Calls with Optional Chaining on Env Variables in Expr\nDESCRIPTION: These examples demonstrate the use of indexing and method calls combined with optional chaining when accessing environment variables in Expr. They highlight how to safely access array elements, call methods, and handle potential null or undefined values.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_271\n\nLANGUAGE: Expr\nCODE:\n```\n{foo: $env}.Bar?.[str]\n{foo: $env}.add?.[array]\n{foo: $env}.add?.[foo]\n{foo: $env}.add?.[ok]\n{foo: $env}.add?.array\n{foo: $env}.add?.list\n{foo: $env}.array?.i\n{foo: $env}.array?.str\n{foo: $env}.foo?.i\n{foo: $env}.list?.greet\n{foo: $env}.ok?.[ok]\n{foo: $env}.str?.Bar\n{foo: $env}?.String?.[add]\n{foo: $env}?.String?.str()\n{foo: $env}?.[str]\n{foo: $env}?.add?.[array]\n{foo: $env}?.array?.[greet]\n{foo: $env}?.foo.Bar\n{foo: $env}?.foo.ok\n{foo: $env}?.foobar?.greet(nil)\n{foo: $env}?.greet?.list()\n{foo: $env}?.greet?.ok\n{foo: $env}?.i?.[array]\n{foo: $env}?.list?.[foo]\n{foo: $env}?.list?.greet?.[i]\n{foo: $env}?.ok?.[str]\n{foo: $env}?.str?.[ok]\n{foo: $env}?.str?.array\n{foo: $env}?.str?.foo\n{foo: 0}.String?.[f64]\n{foo: 0}.String?.ok()\n{foo: 0}.greet?.[list]\n{foo: 0}.list?.[foo].String\n{foo: 0}.ok?.[array]\n{foo: 0}.ok?.foo?.[i]\n{foo: 0}.str?.String\n{foo: 0}?.[str]\n{foo: 0}?.ok?.[str]\n{foo: 1.0, foo: str}?.i?.[add]\n{foo: 1.0, foo: 0, foo: array}.String\n{foo: 1.0, foo: 0}.String?.String\n{foo: 1.0, foo: add}?.f64?.str?.[array]\n{foo: 1, foo: foo, foo: $env}?.[str]\n{foo: 1, foo: i, foo: list}?.[str]\n{foo: 0, foo: list}?.[str]\n{foo: 0, foo: add}?.[str]\n{foo: 0, foo: 0, foo: false}?.list\n```\n\n----------------------------------------\n\nTITLE: Miscellaneous Expr Expressions\nDESCRIPTION: This snippet includes several miscellaneous expressions in Expr, demonstrating various operators, function calls, and data types. The expressions cover logical operations, comparison, literals, function calls and list values.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_179\n\nLANGUAGE: Expr\nCODE:\n```\nlist; foo; $env.array\nlist; foo?.Bar\nlist; greet\nlist; list\nlist; nil == nil\nlist; nil; foo?.String\nlist; ok\nlist; str\nlist[1:] | findLast(true)\nlist[1:] | map(0)\nlist[1:] | map(ok)\nlist[1:] | reduce(foo)\nlist[:1] | groupBy(ok)\nlist[:] | map(#index)\nlist[:i] | filter(true)\nlist[:i] | sum(f64)\nlist[:mean(i)]\nlist[:median(array)]\nlist[:min(i)]\nlist[:sum(array)]\nlist[i:] | groupBy(true)\nlist[i:] | sortBy(0)\nlist[1:] | map(0)\nlist[1:] | map(ok)\n```\n\n----------------------------------------\n\nTITLE: Testing 'f32' Comparisons in Expr\nDESCRIPTION: This section tests comparisons involving the 'f32' (32-bit floating-point) data type. It shows various relational operators used to compare 'f32' with other numeric types (0.5, 1, f64, i, i32, i64), boolean values, and function results. These tests validate type conversion and comparison behavior within Expr.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_35\n\nLANGUAGE: Expr\nCODE:\n```\nf32\nf32 != -0.5\nf32 != -1\nf32 != -f32\nf32 != 0.5 != false\nf32 != 0.5 * 1\nf32 != 0.5 * i64\nf32 != 0.5 ** f32\nf32 != 0.5 + 1\nf32 != 0.5 - i64\nf32 != 0.5 / 0.5\nf32 != 0.5 / i32\nf32 != 0.5 == ok\nf32 != 0.5 == true\nf32 != 0.5 ? array : score\nf32 != 0.5 ? foo : f64\nf32 != 0.5 ? true : i32\nf32 != 0.5 ^ 1\nf32 != 0.5 ^ f32\nf32 != 1 && ok\nf32 != 1 * i\nf32 != 1 + i64\nf32 != f32\nf32 != f32 / 0.5\nf32 != f32 / f32\nf32 != f64\nf32 != findLast(array, ok)\nf32 != findLastIndex(array, ok)\nf32 != floor(0.5)\nf32 != half(0.5)\nf32 != i\nf32 != i != true\nf32 != i % 1\nf32 != i % i\nf32 != i ** i64\nf32 != i / f64\nf32 != i32\nf32 != i32 % i\nf32 != i32 * i32\nf32 != i32 + 0.5\nf32 != i64\nf32 != i64 != nil\nf32 != i64 != true\nf32 != i64 ? 0.5 : f64\nf32 != i64 ^ i32\nf32 != int(f32)\nf32 != int(i32)\nf32 != len(array)\nf32 != nil ? true : score\nf32 != nil || ok\nf32 != round(i)\nf32 != score(1)\nf32 != score(1, i)\n```\n\n----------------------------------------\n\nTITLE: Counting with Mixed Type Comparisons in Expr\nDESCRIPTION: This snippet illustrates count operations involving mixed-type comparisons. It shows comparisons of floating-point numbers (0.5, 1, f32, f64) with generic elements (#) and integer variables (i, i32).\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_29\n\nLANGUAGE: Expr\nCODE:\n```\ncount(array, 0.5 != #)\ncount(array, 0.5 < #)\ncount(array, 0.5 <= #)\ncount(array, 0.5 <= f32)\ncount(array, 0.5 <= f64)\ncount(array, 0.5 == #)\ncount(array, 0.5 == f32)\ncount(array, 0.5 == i)\ncount(array, 0.5 > #)\ncount(array, 1 != #)\ncount(array, 1 != 0.5)\ncount(array, 1 < #)\ncount(array, 1 <= #)\ncount(array, 1 == #)\ncount(array, 1 >= #)\n```\n\n----------------------------------------\n\nTITLE: Bitwise NAND Operation in Expr\nDESCRIPTION: Demonstrates the use of the `bitnand` operator with variables and environment values in Expr.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_68\n\nLANGUAGE: Expr\nCODE:\n```\nbitnand($env.i, i)\nbitnand(i, i)\n```\n\n----------------------------------------\n\nTITLE: Double Negation Examples\nDESCRIPTION: Demonstrates the use of double negation (`not not`) on comparison expressions, boolean values, and logical operations. It showcases the principle that double negation should resolve to the original value.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_91\n\nLANGUAGE: Expr\nCODE:\n```\nnot not (f64 <= 1)\nnot not (i32 < i64)\nnot not (i64 >= f64)\nnot not (nil != greet)\nnot not (ok or ok)\nnot not false\nnot not ok\nnot not true\n```\n\n----------------------------------------\n\nTITLE: Mapping with $env and index variables in Expr\nDESCRIPTION: Applies a transformation based on the environment variable `$env` and index `#index`. This example demonstrates accessing the environment within the map function, filtering, and mapping the list using some function.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_180\n\nLANGUAGE: Expr\nCODE:\n```\nmap($env, #index) | filter(false)\nmap($env, #index) | map(greet)\nmap($env, #index) | reduce(0, $env)\n```\n\n----------------------------------------\n\nTITLE: String Conversion and Comparisons\nDESCRIPTION: This snippet tests string conversions with comparisons. It checks the behavior of \"str\" with \"not matches\", \"not startsWith\", and \"startsWith\" operators in combination with various variables and expressions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_219\n\nLANGUAGE: Expr\nCODE:\n```\nstr not matches type(true)\nstr not startsWith $env.str\nstr not startsWith $env?.$env?.[add]\nstr not startsWith $env?.Bar\nstr not startsWith $env?.String\nstr not startsWith $env?.[Bar]\nstr not startsWith $env?.[Bar]?.[i]\nstr not startsWith $env?.[String]\nstr not startsWith $env?.[nil]\nstr not startsWith $env?.[str]\nstr not startsWith $env?.nil\nstr not startsWith $env?.str\nstr not startsWith foo.Bar\nstr not startsWith foo.String()\nstr not startsWith foo?.Bar\nstr not startsWith foo?.String()\nstr not startsWith greet(str)\nstr not startsWith lower(str)\nstr not startsWith str\nstr not startsWith str ?: 1.0\nstr not startsWith str ?: ok\nstr not startsWith string(nil)\nstr not startsWith toJSON(foo)\nstr not startsWith toJSON(true)\nstr not startsWith trimSuffix(string(foo))\nstr not startsWith type(0)\nstr not startsWith type(add)\nstr not startsWith type(f64)\nstr not startsWith type(ok)\nstr startsWith $env.str\nstr startsWith $env?.Bar\nstr startsWith $env?.String\nstr startsWith $env?.String?.[greet]\nstr startsWith $env?.[Bar]\nstr startsWith $env?.[String]\nstr startsWith $env?.[foobar]\nstr startsWith $env?.[str]\nstr startsWith $env?.foobar\nstr startsWith $env?.str\nstr startsWith first($env)\nstr startsWith foo.Bar\nstr startsWith foo.String()\nstr startsWith foo?.Bar\nstr startsWith greet(str)\nstr startsWith str\nstr startsWith str && ok\nstr startsWith str[1:]\nstr startsWith toJSON(1.0)\nstr startsWith toJSON(list)\nstr startsWith toJSON(true)\n```\n\n----------------------------------------\n\nTITLE: String Conversion of Numeric Operations\nDESCRIPTION: This snippet tests string conversion of various numeric operations. It includes arithmetic, comparison, and bitwise operations with integers, floating-point numbers, and variables, ensuring correct handling during string conversion.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_225\n\nLANGUAGE: Expr\nCODE:\n```\nstring(0 != 0)\nstring(0 != 1.0)\nstring(0 != nil)\nstring(0 % 1)\nstring(0 * 0)\nstring(0 * 1)\nstring(0 * f64)\nstring(0 * i)\nstring(0 ** 0)\nstring(0 ** 1)\nstring(0 ** 1.0)\nstring(0 ** f64)\nstring(0 + 1.0)\nstring(0 - 1)\nstring(0 .. i)\nstring(0 < 0)\nstring(0 < 1)\nstring(0 < 1.0)\nstring(0 < f64)\nstring(0 <= 0)\nstring(0 <= f64)\nstring(0 <= i)\nstring(0 == $env)\nstring(0 == 1)\nstring(0 == i)\nstring(0 == nil)\nstring(0 > f64)\nstring(0 > i)\nstring(0 >= 1)\nstring(0 >= i)\nstring(0) >= str\nstring(1 != f64)\nstring(1 != nil)\nstring(1 % 1)\nstring(1 * 0)\nstring(1 * 1.0)\nstring(1 * f64)\nstring(1 * i)\nstring(1 ** 0)\nstring(1 ** 1)\nstring(1 ** 1.0)\nstring(1 ** f64)\nstring(1 + i)\nstring(1 - 1)\nstring(1 - 1.0)\nstring(1 - f64)\nstring(1 .. 0)\nstring(1 .. 1)\nstring(1 / 0)\nstring(1 / 1.0)\nstring(1 / f64)\nstring(1 < 0)\nstring(1 < 1.0)\nstring(1 <= 1.0)\nstring(1 <= f64)\nstring(1 <= i)\nstring(1 == $env)\nstring(1 == i)\nstring(1 == nil)\nstring(1 > $env?.i)\nstring(1 > 0)\nstring(1 >= 1)\nstring(1 >= 1.0)\nstring(1 >= f64)\nstring(1 >= i)\nstring(1 ^ 1)\nstring(1 ^ 1.0)\nstring(1 ^ i)\nstring(1 | min(1.0))\n```\n\n----------------------------------------\n\nTITLE: String Operations with `lastIndexOf` in Expr\nDESCRIPTION: This snippet shows the usage of `lastIndexOf` function in Expr to determine the last index of a substring within a string.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_168\n\nLANGUAGE: Expr\nCODE:\n```\nlastIndexOf(str, str)\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT Operations in Expr\nDESCRIPTION: Examples of the `bitnot` function in Expr with diverse data types including integers, floats, array access, and results of other bitwise functions. Demonstrates type conversions and operator precedence.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_18\n\nLANGUAGE: Expr\nCODE:\n```\nbitnot(-1)\nbitnot(-i)\nbitnot(-i32)\nbitnot(-i64)\nbitnot(1 % 1)\nbitnot(1 % i32)\nbitnot(1 % i64)\nbitnot(1 * 1)\nbitnot(1 * i64)\nbitnot(1 + 1)\nbitnot(1 - i)\nbitnot(1 - i32)\nbitnot(1) * i % 1\nbitnot(1) ** f32\nbitnot(1) ** i\nbitnot(1) + i32\nbitnot(1) - i\nbitnot(1) - i32\nbitnot(1) / min(i)\nbitnot(1) < i32\nbitnot(1) < i64\nbitnot(1) == i32\nbitnot(1) > f64\nbitnot(1) >= i\nbitnot(1) >= i64\nbitnot(abs(1))\nbitnot(abs(i32))\nbitnot(abs(i64))\nbitnot(array[1])\nbitnot(array[i64])\nbitnot(array[i])\nbitnot(bitnot(i))\nbitnot(bitushr(1, 1))\nbitnot(bitushr(i32, 1))\nbitnot(bitxor(i, i64))\nbitnot(count(array, false))\nbitnot(findLast(array, ok))\nbitnot(first(array))\nbitnot(get(array, 1))\nbitnot(get(array, i))\nbitnot(i % i64)\nbitnot(i * i)\nbitnot(i * i32)\nbitnot(i + 1)\nbitnot(i - 1)\nbitnot(i - i64)\nbitnot(i)\nbitnot(i) % i32\nbitnot(i) * i\nbitnot(i) + f64\nbitnot(i) .. i64\nbitnot(i) == 1 - i\nbitnot(i) > i\nbitnot(i) >= i32\nbitnot(i) ^ f32\nbitnot(i) ^ f64\nbitnot(i) in array\nbitnot(i32 % 1)\nbitnot(i32 % i64)\nbitnot(i32 + i)\nbitnot(i32 + i32)\nbitnot(i32 - 1)\nbitnot(i32 - i32)\nbitnot(i32)\nbitnot(i32) != f64\nbitnot(i32) != i32\nbitnot(i32) * i\nbitnot(i32) * i64\nbitnot(i32) ** f32\nbitnot(i32) - i32\nbitnot(i32) / f64\nbitnot(i32) == i64\nbitnot(i32) > 1 != true\nbitnot(i32) >= f32\nbitnot(i64 % 1)\nbitnot(i64 % i)\nbitnot(i64 % i32)\nbitnot(i64 * 1)\nbitnot(i64 * i)\nbitnot(i64 * i32)\nbitnot(i64 * i64)\nbitnot(i64 - 1)\nbitnot(i64 - i)\nbitnot(i64 - i64)\nbitnot(i64)\nbitnot(i64) % i32\nbitnot(i64) * f32\nbitnot(i64) < f32\nbitnot(i64) > f64\nbitnot(i64) > i % i\nbitnot(i64) >= i32 ^ f32\nbitnot(i64) ^ f64\nbitnot(i64) not in array\nbitnot(int(f32))\nbitnot(int(f64))\nbitnot(int(i))\nbitnot(int(i32))\nbitnot(int(i64))\nbitnot(last(array))\nbitnot(len(\"bar\"))\nbitnot(len(\"foo\"))\nbitnot(len(list))\nbitnot(max(1))\nbitnot(max(1, i64))\nbitnot(max(i))\nbitnot(max(i32))\nbitnot(min(1))\nbitnot(min(i32))\nbitnot(min(i64))\nbitnot(ok ? 1 : array)\nbitnot(ok ? 1 : ok)\nbitnot(ok ? i : add)\nbitnot(reduce(array, #))\nbitnot(reduce(array, 1))\nbitnot(reduce(list, 1))\nbitnot(score(1))\nbitnot(score(i))\nbitnot(sum(array))\n```\n\n----------------------------------------\n\nTITLE: Expr groupBy with variable 'foo' and property access\nDESCRIPTION: Illustrates using a variable named 'foo', checking for its presence in a list, and accessing its properties with both direct and safe navigation.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_128\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(array, foo not in list)\ngroupBy(array, foo)\ngroupBy(array, foo).Bar\ngroupBy(array, foo).String\ngroupBy(array, foo).add\ngroupBy(array, foo).array\ngroupBy(array, foo).foo\ngroupBy(array, foo).greet\ngroupBy(array, foo).i\ngroupBy(array, foo).list\ngroupBy(array, foo).ok\ngroupBy(array, foo).str\ngroupBy(array, foo)?.String\ngroupBy(array, foo)?.[f64]\ngroupBy(array, foo)?.[foo]\ngroupBy(array, foo)?.[i]\ngroupBy(array, foo)?.[ok]\ngroupBy(array, foo)?.add\ngroupBy(array, foo)?.array\ngroupBy(array, foo)?.f64\ngroupBy(array, foo)?.greet\ngroupBy(array, foo)?.i\ngroupBy(array, foo)?.list\ngroupBy(array, foo)?.ok\ngroupBy(array, foo)?.str\ngroupBy(array, foo.Bar)\n```\n\n----------------------------------------\n\nTITLE: Chained Operations\nDESCRIPTION: Examples demonstrating chained operations using optional chaining and method calls. This shows how to access nested properties or call multiple methods in sequence, while safely handling potential null values in the chain.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_142\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": f32}?.f64?.i\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": half, \"bar\": \"foo\"}?.half\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": i, \"foo\": \"bar\"}?.div?.f32\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": nil}.array?.half()\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": add}.i?.score\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": f32}.score?.greet\n```\n\n----------------------------------------\n\nTITLE: Accessing Date Components in Expr\nDESCRIPTION: Date objects in Expr provide methods to access individual date components, such as year, month, day, hour, minute, and second.  These methods allow you to extract specific information from a date object.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_41\n\nLANGUAGE: expr\nCODE:\n```\ndate(\"2023-08-14\").Year() == 2023\n```\n\n----------------------------------------\n\nTITLE: String Conversion with Boolean Values and Conditional Logic\nDESCRIPTION: This snippet focuses on the conversion of boolean values into strings, along with expressions that involve logical operators and conditional statements. It checks for the correct representation of boolean results and ensures correct behavior in conditional contexts.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_230\n\nLANGUAGE: Expr\nCODE:\n```\nstring(false != $env)\nstring(false != false)\nstring(false != true)\nstring(false && $env)\nstring(false && ok)\nstring(false == $env)\nstring(false == nil)\nstring(false ? foo : 1)\nstring(false ?: i)\nstring(false and false)\nstring(false or $env)\nstring(false or false)\nstring(false or ok)\nstring(false || $env)\nstring(false) not contains str\nstring(false) | greet()\n```\n\n----------------------------------------\n\nTITLE: upper Function in Expr\nDESCRIPTION: Shows the usage of the `upper` function to convert a string to uppercase.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_25\n\nLANGUAGE: expr\nCODE:\n```\nupper(\"hello\") == \"HELLO\"\n```\n\n----------------------------------------\n\nTITLE: Install Expr using Go Get\nDESCRIPTION: This command installs the Expr library using `go get`.  It fetches the Expr package from GitHub and adds it to the project's dependencies.\nSOURCE: https://github.com/expr-lang/expr/blob/master/README.md#_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\ngo get github.com/expr-lang/expr\n```\n\n----------------------------------------\n\nTITLE: Expr: Additional Logical AND examples\nDESCRIPTION: This snippet continues exploring logical AND operations with diverse conditions. It tests comparisons with numbers, list containment checks using 'in', and other arithmetic operations to evaluate true/false scenarios.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_251\n\nLANGUAGE: Expr\nCODE:\n```\ntrue and 1 > f64\ntrue and 1 > i\ntrue and 1 in sort($env)\ntrue and 1.0 > f64\ntrue and array != list\ntrue and f64 < f64\ntrue and false || ok\ntrue and i == i\ntrue and nil != greet\ntrue and nil == greet\ntrue and str != str\ntrue and true || $env >= $env\n\n```\n\n----------------------------------------\n\nTITLE: repeat Function in Expr\nDESCRIPTION: Shows how to use the `repeat` function to repeat a string a specified number of times.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_30\n\nLANGUAGE: expr\nCODE:\n```\nrepeat(\"Hi\", 3) == \"HiHiHi\"\n```\n\n----------------------------------------\n\nTITLE: Character Frequency Grouping in Expr\nDESCRIPTION: This snippet calculates character frequencies in a range of numbers, groups them by frequency, and provides examples of characters with the highest frequency. It converts numbers 1 to 100000 to strings, groups by the frequency of '0' character, and presents counts, lengths, and examples.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/examples.md#_snippet_0\n\nLANGUAGE: Expr\nCODE:\n```\nlet char = \"0\";\n1..100000\n| map(string(#))\n| groupBy(split(#, char) | len() - 1)\n| toPairs()\n| map({{\n    count: #[0], \n    len: len(#[1]), \n    examples: [first(#[1]), last(#[1])],\n }})\n| sortBy(.len, 'desc')\n```\n\n----------------------------------------\n\nTITLE: List Reduction Examples\nDESCRIPTION: Demonstrates the use of the `reduce` function on arrays and lists. The intention of reduce is likely to combine all elements, but in these examples it just appears to be used with static values (false, ok, true), which wouldn't actually reduce the lists.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_96\n\nLANGUAGE: Expr\nCODE:\n```\nnot reduce(array, false)\nnot reduce(array, ok)\nnot reduce(array, true)\nnot reduce(list, false)\nnot reduce(list, ok)\nnot reduce(list, true)\n```\n\n----------------------------------------\n\nTITLE: Expr f64 Equality Operations\nDESCRIPTION: This snippet covers equality comparisons (==) with 'f64' numbers in the Expr language. It shows comparisons between f64 and environment variables (including optional chaining), boolean values, and other data types. It also incorporates various function calls and nested expressions within the equality checks, illustrating how the interpreter handles diverse type combinations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_84\n\nLANGUAGE: Expr\nCODE:\n```\nf64 == $env && true\nf64 == $env == $env\nf64 == $env ? add : $env\nf64 == $env or $env\nf64 == $env.f64\nf64 == $env.i\nf64 == $env?.Bar\nf64 == $env?.String\nf64 == $env?.[Bar]\nf64 == $env?.[String]\nf64 == $env?.[str]\nf64 == $env?.f64\nf64 == $env?.foobar\nf64 == $env?.foobar?.str\nf64 == $env?.i\nf64 == 0 && $env?.[add]\nf64 == 0 && sum($env)\nf64 == 0 or ok\nf64 == 1 != ok\nf64 == 1 * i\nf64 == 1 - 1.0\nf64 == 1 - f64\nf64 == 1.0 ** 0\nf64 == 1.0 + f64\nf64 == 1.0 == ok\nf64 == 1.0 ?: nil\nf64 == 1.0 and true\nf64 == 1.0 || $env\nf64 == abs(1.0)\nf64 == array?.[i]\nf64 == bitor(i, 1)\nf64 == count(array, ok)\nf64 == f64\nf64 == f64 ^ i\nf64 == findLastIndex($env, true)\nf64 == i\nf64 == i / i\nf64 == int(f64)\nf64 == mean(1.0)\nf64 == median(i)\nf64 == min($env)\nf64 == min(1.0)\nf64 == nil != nil\nf64 == nil != ok\nf64 == nil ?: list\nf64 == nil || max(array)\nf64 == nil || true\n```\n\n----------------------------------------\n\nTITLE: Expr groupBy with variable 'str' and built-in functions\nDESCRIPTION: Examples utilizing a variable 'str', the `round` function, and various property access patterns.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_132\n\nLANGUAGE: Expr\nCODE:\n```\ngroupBy(array, round(i))\ngroupBy(array, str)\ngroupBy(array, str).Bar\ngroupBy(array, str).String\ngroupBy(array, str).add\ngroupBy(array, str).foo\ngroupBy(array, str).list\ngroupBy(array, str).str\ngroupBy(array, str)?.String\ngroupBy(array, str)?.[i]\ngroupBy(array, str)?.[ok]\ngroupBy(array, str)?.array\ngroupBy(array, str)?.f64\ngroupBy(array, str)?.i\ngroupBy(array, str)?.list\ngroupBy(array, str)?.not\ngroupBy(array, str)?.ok\ngroupBy(array, str)?.str\n```\n\n----------------------------------------\n\nTITLE: Arithmetic and Property Access with Various Data Types\nDESCRIPTION: Demonstrates how arithmetic operations interact with property access within maps. This highlights edge cases and different data type combinations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_132\n\nLANGUAGE: expr-lang\nCODE:\n```\n{\"bar\": 1 * i}\n{\"bar\": 1 ** 0.5}\n{\"bar\": 1 / 0.5}\n{\"bar\": 1 / f32}\n{\"bar\": 1 ^ 1}\n{\"bar\": 1, \"bar\": add, \"foo\": \"bar\"}?.add\n{\"bar\": 1, \"bar\": add}.div\n{\"bar\": 1, \"bar\": f32}?.Bar\n{\"bar\": 1, \"bar\": f64, \"foo\": array}.ok\n{\"bar\": 1, \"foo\": \"bar\"}.half\n{\"bar\": 1, \"foo\": array, \"bar\": score}?.i\n{\"bar\": 1, \"foo\": i}?.list\n{\"bar\": 1, \"foo\": i}?.ok\n{\"bar\": 1, \"foo\": ok}?.f32\n{\"bar\": 1, \"foo\": score}.f64\n{\"bar\": 1}.String\n{\"bar\": 1}.add\n{\"bar\": 1}.f32\n{\"bar\": 1}.foo\n{\"bar\": 1}.greet\n{\"bar\": 1}.half\n{\"bar\": 1}.i\n{\"bar\": 1}.i32\n{\"bar\": 1}.list\n{\"bar\": 1}.score\n{\"bar\": 1}?.Qux\n{\"bar\": 1}?.add\n{\"bar\": 1}?.div\n{\"bar\": 1}?.f32\n{\"bar\": 1}?.f64\n{\"bar\": 1}?.i\n{\"bar\": 1}?.i32\n{\"bar\": 1}?.i64\n{\"bar\": 1}?.list\n{\"bar\": 1}?.ok\n```\n\n----------------------------------------\n\nTITLE: Operators and Expressions\nDESCRIPTION: Demonstrates using operators on objects, including arithmetic, comparison, and logical operators. The expressions cover various combinations of data types and operators to validate the language's operator precedence and type coercion rules.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_139\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": i != 1}\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": i - f64}\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": i / 1}\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": f32 > 1}\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": f64 < f64}\n```\n\nLANGUAGE: Expr\nCODE:\n```\n{\"foo\": false or false}.array\n```\n\n----------------------------------------\n\nTITLE: Convert to Integer Using int() in Expr\nDESCRIPTION: The `int()` function converts a number or a string representation of a number into its corresponding integer value.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_79\n\nLANGUAGE: expr\nCODE:\n```\nint(\"123\") == 123\n```\n\n----------------------------------------\n\nTITLE: Comparison Operations in Expr\nDESCRIPTION: This set of snippets showcases various comparison operations (less than, less than or equal to, greater than, greater than or equal to) involving environment variables, numeric literals, and different data types in the Expr language. The operations demonstrate how different types are compared.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_274\n\nLANGUAGE: Expr\nCODE:\n```\n{foo: 0 < 0, foo: i}\n{foo: 0 < 1.0}\n{foo: 0 < 1}\n{foo: 0 < f64}\n{foo: 0 <= 0}\n{foo: 0 <= 1.0}\n{foo: 1 < 1.0}\n{foo: 1 < 1}\n{foo: 1 < i}\n{foo: 1 <= 1}\n{foo: 1 > 0}\n{foo: 1 > 1.0}\n{foo: 1 > i}\n{foo: 1 >= 1}\n{foo: 1 >= f64}\n{foo: 1 >= i}\n{foo: 1.0 < 1.0}\n{foo: 1.0 < 1.0}.String\n{foo: 1.0 <= 0}\n{foo: 1.0 <= 1.0}\n{foo: 1.0 <= 1}\n{foo: 1.0 <= f64}\n{foo: 1.0 <= i}\n{foo: 1.0 > 1.0}\n{foo: 1.0 > 1}\n{foo: 1.0 > f64}\n{foo: 1.0 > f64}.array\n{foo: 1.0 > i}\n{foo: 1.0 >= 0}\n{foo: 1.0 >= 1.0}\n{foo: 1.0 >= 1}\n{foo: 1.0 >= f64}\n{foo: 1.0 >= i, foo: greet}\n{foo: 1.0 >= i}\n```\n\n----------------------------------------\n\nTITLE: Chained Function Calls and Statistical Aggregations\nDESCRIPTION: Examples of chained function calls using the pipe operator (|) along with statistical aggregation functions like max, mean, median, and min.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_18\n\nLANGUAGE: EXPR\nCODE:\n```\n1 + f64 | max(array)\n1 + f64 | median(array)\n1 - f64 | min(array)\n1.0 * 1.0 | mean(array)\n1.0 ** 0 | median(1)\n1.0 ** 1.0 | median(1.0)\n1.0 ** f64 | median(i)\n1.0 ** f64 | min(1)\n1.0 + 1 | median(1.0)\n1.0 + 1.0 | mean(1)\n1.0 + 1.0 | median(1.0)\n1.0 | max(1.0, f64) < f64\n1.0 | max(array) <= i\n1.0 | mean(f64) != i\n1.0 | median(0) ^ i\n1.0 | median(array) | get(foo)\n1.0 | min(1.0) ** i\n```\n\n----------------------------------------\n\nTITLE: Get First Element of Array Using first() in Expr\nDESCRIPTION: The `first()` function retrieves and returns the first element from an array. If the array is empty, it returns `nil`.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_70\n\nLANGUAGE: expr\nCODE:\n```\nfirst([1, 2, 3]) == 1\n```\n\n----------------------------------------\n\nTITLE: Type Checking\nDESCRIPTION: Demonstrates the use of the `type` function to determine the data type of different variables and literals. It covers various data types such as numbers, strings, booleans, lists, and variables. The examples are designed to verify the correct type inference and reporting of the `type` function.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_26\n\nLANGUAGE: Expr\nCODE:\n```\n[type($env)]\n[type(0)]\n[type(1.0)]\n[type(add)]\n[type(array)]\n[type(f64)]\n[type(false)]\n[type(foo)]\n[type(greet)]\n[type(list), array]\n[type(list)]\n[type(ok)]\n[type(str), foo]?.[i]\n[type(str)]\n[type(true)]\n```\n\n----------------------------------------\n\nTITLE: Logical NOT Operator with Boolean Literals (Expr)\nDESCRIPTION: This snippet demonstrates the usage of the logical NOT operator (!) with boolean literals (true and false) in the Expr language.  It shows how the operator inverts the truthiness of the boolean value.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_0\n\nLANGUAGE: Expr\nCODE:\n```\n!!false\n!!true\n!false\n!true\n```\n\n----------------------------------------\n\nTITLE: Calculating the Absolute Value in Expr\nDESCRIPTION: The `abs()` function returns the absolute value of a given number. If the number is positive, it returns the number itself; if the number is negative, it returns the negation of the number.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_46\n\nLANGUAGE: expr\nCODE:\n```\nabs(-5) == 5\n```\n\n----------------------------------------\n\nTITLE: Array Min\nDESCRIPTION: Finds the minimum value within the array. Requires numeric elements. Returns the minimum value in the array.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_58\n\nLANGUAGE: Expr\nCODE:\n```\narray | min(0)\n```\n\n----------------------------------------\n\nTITLE: Keys Function Test\nDESCRIPTION: This snippet examines the behavior of the `keys` function when applied to different data structures, including objects created by `groupBy`, literal object definitions, and objects with various data types as values. These tests ensure the correct extraction of keys from object-like structures within the Expr language.\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_70\n\nLANGUAGE: expr\nCODE:\n```\nkeys(groupBy(array, \"foo\"))\nkeys(groupBy(array, # ** 0.5))\nkeys(groupBy(array, #))\nkeys(groupBy(array, f32 != f64))\nkeys(groupBy(array, foo))\nkeys(groupBy(array, i32))\nkeys(groupBy(array, ok))\nkeys(groupBy(list, \"bar\"))\nkeys(groupBy(list, #))\nkeys(groupBy(list, false))\nkeys(groupBy(list, i32))\nkeys({\"bar\": 1})\nkeys({\"bar\": array, \"foo\": \"bar\"})\nkeys({\"bar\": f32})\nkeys({\"foo\": array, \"bar\": f64})\nkeys({\"foo\": array})\n```\n\n----------------------------------------\n\nTITLE: Ceiling Function Usage in Expr\nDESCRIPTION: Demonstrates the usage of the 'ceil' function in the Expr language with various data types and operations. The 'ceil' function returns the smallest integer greater than or equal to its argument.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_76\n\nLANGUAGE: Expr\nCODE:\n```\nceil(f64 ** 1)\nceil(f64 ** 1.0)\nceil(f64 ** i)\nceil(f64 + 1.0)\nceil(f64 + f64)\nceil(f64 - 1)\nceil(f64 / 1)\nceil(f64 / 1.0)\nceil(f64 / f64)\nceil(f64 / i)\nceil(f64 ^ 1.0)\nceil(f64 ^ i)\nceil(f64 | min(1.0))\nceil(f64)\nceil(f64) != i\nceil(f64) * f64\nceil(f64) * i\nceil(f64) == f64\nceil(f64) == i\nceil(f64) ^ i\nceil(f64) | median(1.0, i, i)\nceil(false ?: 0)\nceil(false ?: 1)\nceil(findIndex($env, true))\nceil(findIndex(array, true))\nceil(findLastIndex($env, true))\nceil(first(array))\nceil(float(1.0))\nceil(float(f64))\nceil(float(i))\nceil(floor(0))\nceil(floor(1))\nceil(floor(1.0))\nceil(floor(f64))\nceil(floor(i))\nceil(i % i)\nceil(i * 1)\nceil(i * 1.0)\nceil(i ** 0)\nceil(i ** 1)\nceil(i ** 1.0)\nceil(i + 1)\nceil(i + i)\nceil(i - 0)\nceil(i - 1.0)\nceil(i - i)\nceil(i / 1)\nceil(i / 1.0)\nceil(i / f64)\nceil(i / i)\nceil(i ^ 0)\nceil(i ^ f64)\nceil(i ^ i)\nceil(i | min(0))\nceil(i | min(1.0))\nceil(i)\nceil(i) != 0 ?: 1.0\nceil(i) == i\nceil(i) > i\nceil(i) >= f64\nceil(if false { false } else { f64 })\nceil(if true { 1.0 } else { 1.0 })\nceil(if true { 1.0 } else { f64 })\nceil(if true { i } else { foo })\nceil(indexOf(str, str))\nceil(int(0))\nceil(int(1))\nceil(int(1.0))\nceil(int(f64))\nceil(int(i))\nceil(last(array))\nceil(len($env))\nceil(len(array))\nceil(len(list))\nceil(len(str))\nceil(let foobar = 1.0; foobar)\nceil(list | reduce(0))\nceil(list | reduce(0, 1.0))\nceil(list | reduce(f64))\nceil(list | sum(i))\nceil(max(0))\nceil(max(1))\nceil(max(1.0))\nceil(max(array))\nceil(max(f64))\nceil(max(i))\nceil(mean(1))\nceil(mean(1.0 ^ 1.0))\nceil(mean(1.0))\nceil(mean(array))\nceil(mean(f64))\nceil(mean(f64, 1))\nceil(mean(i))\nceil(mean(i, i, 0))\nceil(median(0))\nceil(median(1.0))\nceil(median(1.0, 0))\nceil(median(1.0, i))\nceil(median(array))\nceil(median(f64))\nceil(median(i))\nceil(median(i, 1.0))\nceil(min(0))\nceil(min(1))\nceil(min(1.0))\nceil(min(1.0, f64))\nceil(min(1.0, i))\nceil(min(array))\nceil(min(f64))\nceil(reduce(array, #))\nceil(reduce(array, #acc))\nceil(reduce(array, 1.0))\nceil(reduce(list, 0))\nceil(round(0))\nceil(round(1.0))\nceil(round(i))\nceil(sum(array))\nceil(sum(list, 1.0))\n```\n\n----------------------------------------\n\nTITLE: Bitwise Shift Right Operation in Expr\nDESCRIPTION: Examples of using `bitshr` for bitwise right shift operations in Expr, with environment values and sum of array.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_72\n\nLANGUAGE: Expr\nCODE:\n```\nbitshr(i, $env?.i)\nbitshr(i, i)\nbitshr(i, sum(array))\n```\n\n----------------------------------------\n\nTITLE: Bitwise OR Operation in Expr\nDESCRIPTION: Demonstrates the use of the `bitor` operator in Expr with different variables, array lookups and function calls.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_70\n\nLANGUAGE: Expr\nCODE:\n```\nbitor($env.i, i)\nbitor(i, array?.[i])\nbitor(i, i)\nbitor(i, len(list))\n```\n\n----------------------------------------\n\nTITLE: Bitwise AND Operation in Expr\nDESCRIPTION: Examples of using the `bitand` operator in Expr with various operands, including variables, array sums, and numeric literals.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_67\n\nLANGUAGE: Expr\nCODE:\n```\nbitand(1, i) * i\nbitand(i, 0) + f64\nbitand(i, i)\nbitand(i, sum(array))\n```\n\n----------------------------------------\n\nTITLE: Bitwise OR Operation in Expr\nDESCRIPTION: Demonstrates the bitwise OR operation using the `bitor` function in Expr. It takes two integer arguments and returns the result of the bitwise OR.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_91\n\nLANGUAGE: expr\nCODE:\n```\nbitor(0b1010, 0b1100) == 0b1110\n```\n\n----------------------------------------\n\nTITLE: Any Function Predicates\nDESCRIPTION: Demonstrates the usage of the `any` function with various predicate functions to check if at least one element in a collection satisfies a condition. This covers multiple predicate expressions involving comparisons, logical operations, and variable evaluations. The test cases ensure the proper functioning of `any` under various conditions.\nSOURCE: https://github.com/expr-lang/expr/blob/master/testdata/generated.txt#_snippet_37\n\nLANGUAGE: Expr\nCODE:\n```\nany($env, ok) || $env == foo\nany($env, true) || $env?.[str]\nany($env.list, ok)\nany($env?.[str], true and true)\nany($env?.array, # == #)\nany($env?.list, ok)\nany(array, # != #)\nany(array, # != $env)\nany(array, # < 0)\nany(array, # <= #)\nany(array, $env != #)\nany(array, $env != add)\nany(array, $env | all(true))\nany(array, $env?.ok)\nany(array, 0 == #)\nany(array, 1 == 1.0)\nany(array, array == array)\nany(array, foo == nil)\nany(array, i != #)\nany(array, i <= i)\nany(array, ok != ok)\nany(array, ok or $env)\nany(array, ok)\nany(array, str >= str)\nany(keys($env), ok)\nany(list, # != #)\nany(list, # == #)\nany(list, # in list)\nany(list, $env != false)\nany(list, $env && false)\nany(list, $env == 1.0)\nany(list, $env == list)\nany(list, $env == str)\nany(list, $env?.ok)\nany(list, i ^ i == 1.0)\nany(list, list != array)\nany(list, nil != 1)\nany(list, nil == nil)\nany(list, ok)\nany(map(array, add), ok)\nany(sortBy(list, i), ok)\nany(values($env), # != 1.0)\n```\n\n----------------------------------------\n\nTITLE: now Function in Expr\nDESCRIPTION: Demonstrates the use of the `now` function to get the current date as a `time.Time` value.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_35\n\nLANGUAGE: expr\nCODE:\n```\nnow().Year() == 2024\n```\n\n----------------------------------------\n\nTITLE: Nested Predicate with Variable Access in Expr\nDESCRIPTION: Demonstrates accessing outer variables in nested predicates using explicit variable declarations.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_21\n\nLANGUAGE: expr\nCODE:\n```\nfilter(posts, {\n    let post = #; \n    any(.Comments, .Author == post.Author)\n})\n```\n\n----------------------------------------\n\nTITLE: Predicate Example in Expr\nDESCRIPTION: Demonstrates using a predicate within the `filter` function to filter elements based on a condition.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_18\n\nLANGUAGE: expr\nCODE:\n```\nfilter(0..9, {# % 2 == 0})\n```\n\n----------------------------------------\n\nTITLE: Multiline String Literal in Expr\nDESCRIPTION: Shows how to define a multiline string literal in Expr using backticks. Backtick strings are raw strings and do not support escape sequences.\nSOURCE: https://github.com/expr-lang/expr/blob/master/docs/language-definition.md#_snippet_1\n\nLANGUAGE: expr\nCODE:\n```\n`Hello\nWorld`\n```\n\n----------------------------------------\n\nTITLE: Absolute Value Calculations\nDESCRIPTION: Calculates the absolute value of various data types and function calls within the Expr language. It tests the `abs` function with boolean conditions, array lookups, numerical values, type conversions (float, half, int), and results of other functions (floor, get, len, max, mean, median, min, reduce, round, score, sum).\nSOURCE: https://github.com/expr-lang/expr/blob/master/test/fuzz/fuzz_corpus.txt#_snippet_9\n\nLANGUAGE: Expr\nCODE:\n```\nabs(false ? list : 1)\nabs(find(array, ok))\nabs(find(array, true))\nabs(findIndex(list, ok))\nabs(findIndex(list, true))\nabs(findLastIndex(array, ok))\nabs(first(array))\nabs(float(0.5))\nabs(float(1))\nabs(float(f32))\nabs(float(f64))\nabs(float(i))\nabs(float(i32))\nabs(floor(0.5))\nabs(floor(f32))\nabs(floor(i32))\nabs(get(array, 1))\nabs(get(array, i))\nabs(get(array, i32))\nabs(get(array, i64))\nabs(half(0.5))\nabs(half(1))\nabs(half(f64))\nabs(i * 1)\nabs(i * f32)\nabs(i ** 1)\nabs(i ** f32)\nabs(i ** i32)\nabs(i + 0.5)\nabs(i + f64)\nabs(i - 0.5)\nabs(i - 1)\nabs(i - f32)\nabs(i - f64)\nabs(i - i32)\nabs(i / 0.5)\nabs(i / f64)\nabs(i / i)\nabs(i / i32)\nabs(i / i64)\nabs(i ^ 0.5)\nabs(i ^ f64)\nabs(i ^ i)\nabs(i ^ i32)\nabs(i ^ i64)\nabs(i)\nabs(i) % i\nabs(i) * i32\nabs(i) ** f32\nabs(i) + f64\nabs(i) - f32\nabs(i) .. i\nabs(i) .. i32\nabs(i) / f32\nabs(i) < f64\nabs(i) <= i64\nabs(i) == 0.5 / i\nabs(i) > i64\nabs(i) ^ f64\nabs(i) ^ half(1)\nabs(i) ^ i\nabs(i) ^ i32\nabs(i32 % i32)\nabs(i32 % i64)\nabs(i32 * f64)\nabs(i32 * i32)\nabs(i32 ** 0.5)\nabs(i32 ** 1)\nabs(i32 ** i32)\nabs(i32 + 0.5)\nabs(i32 + 1)\nabs(i32 + f64)\nabs(i32 + i)\nabs(i32 + i32)\nabs(i32 - 0.5)\nabs(i32 - i64)\nabs(i32 / 0.5)\nabs(i32 / i)\nabs(i32 / i64)\nabs(i32)\nabs(i32) != f64\nabs(i32) * f32\nabs(i32) * i\nabs(i32) ** i\nabs(i32) - i32\nabs(i32) / -1\nabs(i32) / i32 ** f64\nabs(i32) < i64 == false\nabs(i32) <= i\nabs(i32) <= i32\nabs(i32) == i32\nabs(i32) ^ i64\nabs(i32) in array\nabs(i64 * 0.5)\nabs(i64 * f32)\nabs(i64 * i32)\nabs(i64 ** 0.5)\nabs(i64 ** f64)\nabs(i64 ** i64)\nabs(i64 + 0.5)\nabs(i64 + 1)\nabs(i64 + f32)\nabs(i64 + f64)\nabs(i64 + i)\nabs(i64 - 0.5)\nabs(i64 - i)\nabs(i64 / f32)\nabs(i64 / i32)\nabs(i64 ^ f64)\nabs(i64 ^ i)\nabs(i64 ^ i32)\nabs(i64)\nabs(i64) * i32\nabs(i64) ** i\nabs(i64) + f32\nabs(i64) / i\nabs(i64) > i32\nabs(i64) ^ i32\nabs(i64) not in array\nabs(int(0.5))\nabs(int(1))\nabs(int(i))\nabs(int(i32))\nabs(int(i64))\nabs(last(array))\nabs(len(\"foo\"))\nabs(len(list))\nabs(max(0.5))\nabs(max(f32))\nabs(max(f64))\nabs(max(i32))\nabs(max(i64))\nabs(mean(array))\nabs(median(array))\nabs(min(0.5))\nabs(min(1))\nabs(min(f32))\nabs(min(f64))\nabs(min(i))\nabs(min(i32))\nabs(ok ? 1 : \"foo\")\nabs(ok ? f32 : 0.5)\nabs(ok ? f32 : nil)\nabs(ok ? f64 : ok)\nabs(ok ? i32 : foo)\nabs(reduce(array, #))\nabs(reduce(array, i))\nabs(reduce(list, 1))\nabs(reduce(list, i32))\nabs(round(0.5))\nabs(round(1))\nabs(round(f32))\nabs(round(i))\nabs(round(i64))\nabs(score(1))\nabs(score(i))\nabs(sum(array))\nabs(true ? 1 : ok)\n```"
  }
]