[
  {
    "owner": "ash-project",
    "repo": "spark",
    "content": "TITLE: Defining a Spark DSL Extension in Elixir\nDESCRIPTION: Creating a DSL extension with Spark.Dsl.Extension that defines the structure and schema for a validator DSL. It includes a Field entity and a fields section.\nSOURCE: https://github.com/ash-project/spark/blob/main/documentation/tutorials/get-started-with-spark.md#2025-04-19_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyLibrary.Validator.Dsl do\n  defmodule Field do\n    defstruct [:name, :type, :transform, :check]\n  end\n\n  @field %Spark.Dsl.Entity{\n    name: :field,\n    args: [:name, :type],\n    target: Field,\n    describe: \"A field that is accepted by the validator\",\n    # you can include nested entities here, but\n    # note that you provide a keyword list like below\n    # we need to know which struct key to place the nested entities in\n    # entities: [\n    #   key: [...]\n    # ],\n    schema: [\n      name: [\n        type: :atom,\n        required: true,\n        doc: \"The name of the field\"\n      ],\n      type: [\n        type: {:one_of, [:integer, :string]},\n        required: true,\n        doc: \"The type of the field\"\n      ],\n      check: [\n        type: {:fun, 1},\n        doc: \"A function that can be used to check if the value is valid after type validation.\"\n      ],\n      transform: [\n        type: {:fun, 1},\n        doc: \"A function that will be used to transform the value after successful validation\"\n      ]\n    ]\n  }\n\n  @fields %Spark.Dsl.Section{\n    name: :fields,\n    schema: [\n      required: [\n        type: {:list, :atom},\n        doc: \"The fields that must be provided for validation to succeed\"\n      ]\n    ],\n    entities: [\n      @field\n    ],\n    describe: \"Configure the fields that are supported and required\"\n  }\n\n  use Spark.Dsl.Extension, sections: [@fields]\nend\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Validator with MyLibrary.Validator DSL in Elixir\nDESCRIPTION: Example usage of the custom validator DSL that will be implemented. It shows how to define fields with validation and transformation rules.\nSOURCE: https://github.com/ash-project/spark/blob/main/documentation/tutorials/get-started-with-spark.md#2025-04-19_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.PersonValidator do\n  use MyLibrary.Validator\n\n  fields do\n    required [:name]\n    field :name, :string\n\n    field :email, :string do\n      check &String.contains?(&1, \"@\")\n      transform &String.trim/1\n    end\n\n    # This syntax is also supported\n    # field :email, :string, check: &String.contains?(&1, \"@\"), process: &String.trim/1\n  end\nend\n\nMyApp.PersonValidator.validate(%{name: \"Zach\", email: \" foo@example.com \"})\n{:ok, %{name: \"Zach\", email: \"foo@example.com\"}}\n\nMyApp.PersonValidator.validate(%{name: \"Zach\", email: \" blank \"})\n:error\n```\n\n----------------------------------------\n\nTITLE: Implementing the Validator Base Module\nDESCRIPTION: The main validator module that defines the validate/2 function used by all generated validators. This implementation checks that all required fields are present and validates each field's type and custom checks.\nSOURCE: https://github.com/ash-project/spark/blob/main/documentation/tutorials/get-started-with-spark.md#2025-04-19_snippet_15\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyLibrary.Validator do\n  use Spark.Dsl,\n    default_extensions: [\n      extensions: [MyLibrary.Validator.Dsl]\n    ]\n\n  def validate(module, data) do\n    fields = MyLibrary.Validator.Info.fields(module)\n    required = MyLibrary.Validator.Info.fields_required!(module)\n\n    case Enum.reject(required, &Map.has_key?(data, &1)) do\n      [] ->\n        validate_fields(fields, data)\n      missing_required_fields ->\n        {:error, :missing_required_fields, missing_required_fields}\n    end\n  end\n\n  defp validate_fields(fields, data) do\n    Enum.reduce_while(fields, {:ok, %{}}, fn field, {:ok, acc} ->\n      case Map.fetch(data, field.name) do\n        {:ok, value} ->\n          case validate_value(field, value) do\n            {:ok, value} ->\n              {:cont, {:ok, Map.put(acc, field.name, value)}}\n            :error ->\n              {:halt, {:error, :invalid, field.name}}\n          end\n\n        :error ->\n          {:cont, {:ok, acc}}\n      end\n    end)\n  end\n\n  defp validate_value(field, value) do\n    with true <- type_check(field, value),\n         true <- check(field, value) do\n      {:ok, transform(field, value)}\n    else\n      _ ->\n        :error\n    end\n  end\n\n  defp type_check(%{type: :string}, value) when is_binary(value) do\n    true\n  end\n\n  defp type_check(%{type: :integer}, value) when is_integer(value) do\n    true\n  end\n\n  defp type_check(_, _), do: false\n\n  defp check(%{check: check}, value) when is_function(check, 1) do\n    check.(value)\n  end\n\n  defp check(_, _), do: true\n\n  defp transform(%{transform: transform}, value) when is_function(transform, 1) do\n    transform.(value)\n  end\n\n  defp transform(_, value), do: value\nend\n```\n\n----------------------------------------\n\nTITLE: Creating a DSL Module with Spark.Dsl in Elixir\nDESCRIPTION: Defining the main DSL module that users will import with 'use'. It includes the previously defined extension by default.\nSOURCE: https://github.com/ash-project/spark/blob/main/documentation/tutorials/get-started-with-spark.md#2025-04-19_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyLibrary.Validator do\n  use Spark.Dsl,\n    default_extensions: [\n      extensions: [MyLibrary.Validator.Dsl]\n    ]\nend\n```\n\n----------------------------------------\n\nTITLE: Updated DSL Extension with Code Generation\nDESCRIPTION: Enhanced Spark DSL Extension configuration that includes the code generation transformer. This setup adds field validation logic, ensures required fields are properly defined, and generates a validate/1 function in each validator module.\nSOURCE: https://github.com/ash-project/spark/blob/main/documentation/tutorials/get-started-with-spark.md#2025-04-19_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\nuse Spark.Dsl.Extension,\n  sections: [@fields],\n  transformers: [\n    MyLibrary.Validator.Transformers.AddId,\n    MyLibrary.Validator.Transformers.GenerateValidate\n  ],\n  verifiers: [\n    MyLibrary.Validator.Verifiers.VerifyRequired\n  ]\n```\n\n----------------------------------------\n\nTITLE: Using the Custom Validator DSL in Elixir\nDESCRIPTION: An example of using the custom validator DSL to define a PersonValidator with field validations and transformations.\nSOURCE: https://github.com/ash-project/spark/blob/main/documentation/tutorials/get-started-with-spark.md#2025-04-19_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.PersonValidator do\n  use MyLibrary.Validator\n\n  fields do\n    required [:name]\n    field :name, :string\n\n    field :email, :string do\n      check &String.contains?(&1, \"@\")\n      transform &String.trim/1\n    end\n\n    # This syntax is also supported\n    # field :email, :string, check: &String.contains?(&1, \"@\"), transform: &String.trim/1\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Generating Validate Function with Transformer\nDESCRIPTION: A transformer that generates a validate/1 function into modules using the DSL. This allows each validator to have a consistent interface while delegating to a central implementation that uses the module's metadata.\nSOURCE: https://github.com/ash-project/spark/blob/main/documentation/tutorials/get-started-with-spark.md#2025-04-19_snippet_13\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyLibrary.Validator.Transformers.GenerateValidate do\n  use Spark.Dsl.Transformer\n\n  def transform(dsl_state) do\n\n    validate = quote do\n      def validate(data) do\n        # Our generated code can be very simple\n        # because we can get all the info we need from the module\n        # in our regular ELixir code.\n        MyLibrary.Validator.validate(__MODULE__, data)\n      end\n    end\n\n    {:ok, Spark.Dsl.Transformer.eval(dsl_state, [], validate)}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Adding Verifiers to Spark DSL Extension\nDESCRIPTION: Configures a Spark DSL Extension to include both transformers and verifiers. This setup adds field validation logic and ensures that fields marked as required are properly defined in the DSL.\nSOURCE: https://github.com/ash-project/spark/blob/main/documentation/tutorials/get-started-with-spark.md#2025-04-19_snippet_11\n\nLANGUAGE: elixir\nCODE:\n```\nuse Spark.Dsl.Extension,\n  sections: [@fields],\n  transformers: [\n    MyLibrary.Validator.Transformers.AddId\n  ],\n  verifiers: [\n    MyLibrary.Validator.Verifiers.VerifyRequired\n  ]\n```\n\n----------------------------------------\n\nTITLE: Implementing a Field Verifier in Spark DSL Extension\nDESCRIPTION: Defines a verifier that checks if all fields listed in 'required' are also defined in 'fields'. This ensures data validation consistency by confirming that required fields have proper definitions.\nSOURCE: https://github.com/ash-project/spark/blob/main/documentation/tutorials/get-started-with-spark.md#2025-04-19_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyLibrary.Validator.Verifiers.VerifyRequired do\n  use Spark.Dsl.Verifier\n\n  # dsl_state here is a map of the underlying DSL data\n  def verify(dsl_state) do\n    # we can use our info module here, even though we are passing in a\n    # map of data and not a module! Very handy.\n\n    required = MyLibrary.Validator.Info.fields_required!(dsl_state)\n    fields = Enum.map(MyLibrary.Validator.Info.fields(dsl_state), &(&1.name))\n\n    if Enum.all?(required, &Enum.member?(fields, &1)) do\n      :ok\n    else\n      {:error,\n       Spark.Error.DslError.exception(\n         message: \"All required fields must be specified in fields\",\n         path: [:fields, :required],\n         # this is how you get the original module out.\n         # only do this for display purposes.\n         # the module is not yet compiled (we're compiling it right now!), so if you\n         # try to call functions on it, you will deadlock the compiler\n         # and get an error\n         module: Spark.Dsl.Verifier.get_persisted(dsl_state, :module)\n       )}\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Creating a Spark DSL Transformer in Elixir\nDESCRIPTION: Implementing a transformer that modifies the DSL data structure at compile time to add an ID field to all validators.\nSOURCE: https://github.com/ash-project/spark/blob/main/documentation/tutorials/get-started-with-spark.md#2025-04-19_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyLibrary.Validator.Transformers.AddId do\n  use Spark.Dsl.Transformer\n\n  # dsl_state here is a map of the underlying DSL data\n  def transform(dsl_state) do\n    {:ok,\n      Spark.Dsl.Transformer.add_entity(dsl_state, [:fields], %MyLibrary.Validator.Dsl.Field{\n        name: :id,\n        type: :string\n      })\n    }\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Adding a Transformer to a Spark DSL Extension in Elixir\nDESCRIPTION: Modifying the DSL extension to include a transformer that will automatically add an ID field to all validators.\nSOURCE: https://github.com/ash-project/spark/blob/main/documentation/tutorials/get-started-with-spark.md#2025-04-19_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\nuse Spark.Dsl.Extension, sections: [@fields], transformers: [\n  MyLibrary.Validator.Transformers.AddId\n]\n```\n\n----------------------------------------\n\nTITLE: Creating an Info Generator for a Spark DSL in Elixir\nDESCRIPTION: Using Spark.InfoGenerator to automatically create helper functions for accessing DSL information.\nSOURCE: https://github.com/ash-project/spark/blob/main/documentation/tutorials/get-started-with-spark.md#2025-04-19_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyLibrary.Validator.Info do\n  use Spark.InfoGenerator, extension: MyLibrary.Validator.Dsl, sections: [:fields]\nend\n```\n\n----------------------------------------\n\nTITLE: Extracting Information from a Spark DSL Module in Elixir\nDESCRIPTION: Examples of using Spark.Dsl.Extension functions to retrieve entity information from a module that uses the custom DSL.\nSOURCE: https://github.com/ash-project/spark/blob/main/documentation/tutorials/get-started-with-spark.md#2025-04-19_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\niex(1)> Spark.Dsl.Extension.get_entities(MyApp.PersonValidator, :fields)\niex(2)> Spark.Dsl.Extension.get_entities(MyApp.PersonValidator, :fields)\n[\n  %MyLibrary.Validator.Dsl.Field{\n    name: :name,\n    type: :string,\n    transform: nil,\n    check: nil\n  },\n  %MyLibrary.Validator.Dsl.Field{\n    name: :email,\n    type: :string,\n    transform: &String.trim/1,\n    # This is an example of some under the hood magic that spark does\n    # to allow you to define a function inside your DSL. This sort of thing\n    # is quite difficult to do with hand-rolled DSLs.\n    check: &MyApp.PersonValidator.check_0_generated_18E6D5D8C34DFA0EDA8E926DAAEE7E52/1\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Using InfoGenerator Functions to Access DSL Data in Elixir\nDESCRIPTION: Examples of using the automatically generated Info functions to retrieve DSL information from a module.\nSOURCE: https://github.com/ash-project/spark/blob/main/documentation/tutorials/get-started-with-spark.md#2025-04-19_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\niex(1)> MyLibrary.Validator.Info.fields(MyApp.PersonValidator)\n[\n  %MyLibrary.Validator.Dsl.Field{\n    name: :name,\n    type: :string,\n    transform: nil,\n    check: nil\n  },\n  %MyLibrary.Validator.Dsl.Field{\n    name: :email,\n    type: :string,\n    transform: &String.trim/1,\n    check: &MyApp.PersonValidator.check_0_generated_18E6D5D8C34DFA0EDA8E926DAAEE7E52/1\n  }\n]\n# Returns `:error` for fields not specified\niex(2)> MyLibrary.Validator.Info.fields_required(MyApp.PersonValidator)\n{:ok, [:name]}\n# The `!` version can be used for fields you know will always be set\niex(3)> MyLibrary.Validator.Info.fields_required!(MyApp.PersonValidator)\n[:name]\n```\n\n----------------------------------------\n\nTITLE: Viewing the Results of a Transformer in a Spark DSL in Elixir\nDESCRIPTION: Demonstrating how the transformer has modified the DSL by adding an ID field to the list of fields.\nSOURCE: https://github.com/ash-project/spark/blob/main/documentation/tutorials/get-started-with-spark.md#2025-04-19_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\niex(1)> MyLibrary.Validator.Info.fields(MyApp.PersonValidator)\n[\n  %MyLibrary.Validator.Dsl.Field{\n    name: :id,\n    type: :string,\n    transform: nil,\n    check: nil\n  },\n  %MyLibrary.Validator.Dsl.Field{\n    name: :name,\n    type: :string,\n    transform: nil,\n    check: nil\n  },\n  %MyLibrary.Validator.Dsl.Field{\n    name: :email,\n    type: :string,\n    transform: &String.trim/1,\n    check: &MyApp.PersonValidator.check_0_generated_18E6D5D8C34DFA0EDA8E926DAAEE7E52/1\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Accessing DSL Values Example in Elixir\nDESCRIPTION: Example showing the conventional way to access DSL values through module functions versus direct variable access, highlighting the benefits for type specifications and documentation.\nSOURCE: https://github.com/ash-project/spark/blob/main/documentation/how_to/writing-extensions.md#2025-04-19_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nmodule_as_variable.table()  # Direct access - not type-checkable\nExtension.table(module)     # Proper access - can be type checked\n```\n\n----------------------------------------\n\nTITLE: Creating and Using DSL Fragments in Ash/Spark\nDESCRIPTION: This example demonstrates how to create a DSL fragment for a PostgreSQL data layer and incorporate it into an Ash Resource. The fragment encapsulates database configuration settings while maintaining the extension capabilities of the full DSL.\nSOURCE: https://github.com/ash-project/spark/blob/main/documentation/how_to/split-up-large-dsls.md#2025-04-19_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Accounts.User.Fragments.DataLayer do\n  use Spark.Dsl.Fragment,\n    of: Ash.Resource,\n    data_layer: AshPostgres.DataLayer\n\n  postgres do\n    table \"users\"\n    repo MyApp.Repo\n    ...\n  end\nend\n\ndefmodule MyApp.Accounts.User do\n  use Ash.Resource,\n    fragments: [MyApp.Accounts.User.Fragments.DataLayer]\n\n  ...\nend\n```\n\n----------------------------------------\n\nTITLE: Example of Invalid Validator Definition\nDESCRIPTION: A sample module that will trigger the verifier's validation error because it defines required fields that don't exist in the fields list. This demonstrates how validation errors are caught during compilation.\nSOURCE: https://github.com/ash-project/spark/blob/main/documentation/tutorials/get-started-with-spark.md#2025-04-19_snippet_12\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.BadValidator do\n  use MyLibrary.Validator\n\n  fields do\n    required [:name, :email]\n    field :name, :string\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Spark.Options Autocomplete in Elixir Functions\nDESCRIPTION: Example showing how to set up autocomplete with documentation for function options using @doc metadata and schema definition. Demonstrates schema configuration for a verbose option with type, documentation, and default value.\nSOURCE: https://github.com/ash-project/spark/blob/main/documentation/how_to/setup-autocomplete.md#2025-04-19_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\n@schema [\n  verbose?: [\n    type: :boolean,\n    doc: \"Whether or not to log verbose messages to the console\",\n    default: false\n  ]\n]\n\n@doc spark_opts: [{1, @schema}]\ndef do_something(arg, opts \\\\ []) do\n  opts = Spark.Options.validate!(opts, @schema)\n\n  ...\nend\n```\n\n----------------------------------------\n\nTITLE: Updating ValidationError Pattern Matching in Elixir\nDESCRIPTION: Code modification required for handling validation errors after NimbleOptions was vendored into Spark. Users need to update their pattern matching from NimbleOptions.ValidationError to Spark.Options.ValidationError.\nSOURCE: https://github.com/ash-project/spark/blob/main/documentation/how_to/upgrade-to-2.0.md#2025-04-19_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nSpark.Options.ValidationError\n```\n\n----------------------------------------\n\nTITLE: Spark Mix Task - Cheat Sheets\nDESCRIPTION: Mix task for generating cheat sheets with shortened documentation\nSOURCE: https://github.com/ash-project/spark/blob/main/CHANGELOG.md#2025-04-19_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nmix spark.replace_doc_links\n```\n\n----------------------------------------\n\nTITLE: Mix Tasks - Spark Installation\nDESCRIPTION: Mix task for installing Spark, also known as igniter.install spark\nSOURCE: https://github.com/ash-project/spark/blob/main/CHANGELOG.md#2025-04-19_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nmix spark.install\n```\n\nLANGUAGE: elixir\nCODE:\n```\nmix igniter.install spark\n```"
  }
]